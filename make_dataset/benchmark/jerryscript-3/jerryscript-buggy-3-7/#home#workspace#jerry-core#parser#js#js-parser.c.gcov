        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "debugger.h"
        -:   17:#include "ecma-exceptions.h"
        -:   18:#include "ecma-extended-info.h"
        -:   19:#include "ecma-helpers.h"
        -:   20:#include "ecma-literal-storage.h"
        -:   21:#include "ecma-module.h"
        -:   22:#include "jcontext.h"
        -:   23:#include "js-parser-internal.h"
        -:   24:
        -:   25:#if JERRY_PARSER
        -:   26:
        -:   27:JERRY_STATIC_ASSERT ((int) ECMA_PARSE_STRICT_MODE == (int) PARSER_IS_STRICT,
        -:   28:                     ecma_parse_strict_mode_must_be_equal_to_parser_is_strict);
        -:   29:
        -:   30:#if JERRY_ESNEXT
        -:   31:JERRY_STATIC_ASSERT (PARSER_SAVE_STATUS_FLAGS (PARSER_ALLOW_SUPER) == 0x1,
        -:   32:                     incorrect_saving_of_ecma_parse_allow_super);
        -:   33:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_ALLOW_SUPER) == PARSER_ALLOW_SUPER,
        -:   34:                     incorrect_restoring_of_ecma_parse_allow_super);
        -:   35:
        -:   36:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_FUNCTION_CONTEXT) == 0,
        -:   37:                     ecma_parse_function_context_must_not_be_transformed);
        -:   38:#endif /* JERRY_ESNEXT */
        -:   39:
        -:   40:/** \addtogroup parser Parser
        -:   41: * @{
        -:   42: *
        -:   43: * \addtogroup jsparser JavaScript
        -:   44: * @{
        -:   45: *
        -:   46: * \addtogroup jsparser_parser Parser
        -:   47: * @{
        -:   48: */
        -:   49:
        -:   50:/**
        -:   51: * Compute real literal indicies.
        -:   52: *
        -:   53: * @return length of the prefix opcodes
        -:   54: */
        -:   55:static void
        6:   56:parser_compute_indicies (parser_context_t *context_p, /**< context */
        -:   57:                         uint16_t *ident_end, /**< end of the identifier group */
        -:   58:                         uint16_t *const_literal_end) /**< end of the const literal group */
        -:   59:{
        6:   60:  parser_list_iterator_t literal_iterator;
        -:   61:  lexer_literal_t *literal_p;
        -:   62:
        6:   63:  uint16_t ident_count = 0;
        6:   64:  uint16_t const_literal_count = 0;
        -:   65:
        -:   66:  uint16_t ident_index;
        -:   67:  uint16_t const_literal_index;
        -:   68:  uint16_t literal_index;
        -:   69:
        -:   70:  /* First phase: count the number of items in each group. */
        6:   71:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
       37:   72:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:   73:  {
       25:   74:    switch (literal_p->type)
        -:   75:    {
       10:   76:      case LEXER_IDENT_LITERAL:
        -:   77:      {
       10:   78:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:   79:        {
        7:   80:          ident_count++;
        7:   81:          break;
        -:   82:        }
        3:   83:        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   84:        {
    #####:   85:          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   86:          /* This literal should not be freed even if an error is encountered later. */
    #####:   87:          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:   88:        }
        3:   89:        continue;
        -:   90:      }
        8:   91:      case LEXER_STRING_LITERAL:
        -:   92:      {
        8:   93:        const_literal_count++;
        8:   94:        break;
        -:   95:      }
        2:   96:      case LEXER_NUMBER_LITERAL:
        -:   97:      {
        2:   98:        const_literal_count++;
        2:   99:        continue;
        -:  100:      }
        5:  101:      case LEXER_FUNCTION_LITERAL:
        -:  102:      case LEXER_REGEXP_LITERAL:
        -:  103:      {
        5:  104:        continue;
        -:  105:      }
    #####:  106:      default:
        -:  107:      {
    #####:  108:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  109:        continue;
        -:  110:      }
        -:  111:    }
        -:  112:
       15:  113:    const uint8_t *char_p = literal_p->u.char_p;
       15:  114:    uint32_t status_flags = context_p->status_flags;
        -:  115:
       15:  116:    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR)
       15:  117:        && literal_p->prop.length < 0xfff)
        -:  118:    {
       15:  119:      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);
        -:  120:
       15:  121:      if (bytes_to_end < 0xfffff)
        -:  122:      {
       15:  123:        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);
       15:  124:        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;
       15:  125:        status_flags |= PARSER_HAS_LATE_LIT_INIT;
       15:  126:        context_p->status_flags = status_flags;
       15:  127:        char_p = NULL;
        -:  128:      }
        -:  129:    }
        -:  130:
       15:  131:    if (char_p != NULL)
        -:  132:    {
    #####:  133:      literal_p->u.value = ecma_find_or_create_literal_string (char_p,
    #####:  134:                                                               literal_p->prop.length,
    #####:  135:                                                               (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        -:  136:
    #####:  137:      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:  138:      {
    #####:  139:        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);
        -:  140:        /* This literal should not be freed even if an error is encountered later. */
    #####:  141:        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
        6:  146:  ident_index = context_p->register_count;
        6:  147:  const_literal_index = (uint16_t) (ident_index + ident_count);
        6:  148:  literal_index = (uint16_t) (const_literal_index + const_literal_count);
        -:  149:
        -:  150:  /* Second phase: Assign an index to each literal. */
        6:  151:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  152:
       37:  153:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  154:  {
       25:  155:    switch (literal_p->type)
        -:  156:    {
       10:  157:      case LEXER_IDENT_LITERAL:
        -:  158:      {
       10:  159:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:  160:        {
        7:  161:          literal_p->prop.index = ident_index;
        7:  162:          ident_index++;
        -:  163:        }
       10:  164:        break;
        -:  165:      }
       10:  166:      case LEXER_STRING_LITERAL:
        -:  167:      case LEXER_NUMBER_LITERAL:
        -:  168:      {
       10:  169:        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);
       10:  170:        literal_p->prop.index = const_literal_index;
       10:  171:        const_literal_index++;
       10:  172:        break;
        -:  173:      }
        5:  174:      case LEXER_FUNCTION_LITERAL:
        -:  175:      case LEXER_REGEXP_LITERAL:
        -:  176:      {
        5:  177:        JERRY_ASSERT (literal_p->status_flags == 0);
        -:  178:
        5:  179:        literal_p->prop.index = literal_index;
        5:  180:        literal_index++;
        5:  181:        break;
        -:  182:      }
    #####:  183:      default:
        -:  184:      {
    #####:  185:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL
        -:  186:                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);
    #####:  187:        break;
        -:  188:      }
        -:  189:    }
        -:  190:  }
        -:  191:
        6:  192:  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);
        6:  193:  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);
        6:  194:  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);
        -:  195:
        6:  196:  context_p->literal_count = literal_index;
        -:  197:
        6:  198:  *ident_end = ident_index;
        6:  199:  *const_literal_end = const_literal_index;
        6:  200:} /* parser_compute_indicies */
        -:  201:
        -:  202:/**
        -:  203: * Initialize literal pool.
        -:  204: */
        -:  205:static void
        6:  206:parser_init_literal_pool (parser_context_t *context_p, /**< context */
        -:  207:                          ecma_value_t *literal_pool_p) /**< start of literal pool */
        -:  208:{
        6:  209:  parser_list_iterator_t literal_iterator;
        -:  210:  lexer_literal_t *literal_p;
        -:  211:
        6:  212:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  213:
       37:  214:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  215:  {
       25:  216:    switch (literal_p->type)
        -:  217:    {
       10:  218:      case LEXER_IDENT_LITERAL:
        -:  219:      {
       10:  220:        if (!(literal_p->status_flags & LEXER_FLAG_USED))
        -:  221:        {
        3:  222:          break;
        -:  223:        }
        -:  224:        /* FALLTHRU */
        -:  225:      }
        -:  226:      case LEXER_STRING_LITERAL:
        -:  227:      {
       15:  228:        ecma_value_t lit_value = literal_p->u.value;
        -:  229:
       15:  230:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
       15:  231:        literal_pool_p[literal_p->prop.index] = lit_value;
       15:  232:        break;
        -:  233:      }
        2:  234:      case LEXER_NUMBER_LITERAL:
        -:  235:      {
        2:  236:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  237:
        2:  238:        literal_pool_p[literal_p->prop.index] = literal_p->u.value;
        2:  239:        break;
        -:  240:      }
        5:  241:      case LEXER_FUNCTION_LITERAL:
        -:  242:      case LEXER_REGEXP_LITERAL:
        -:  243:      {
        5:  244:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  245:
        5:  246:        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index],
        -:  247:                                         literal_p->u.bytecode_p);
        5:  248:        break;
        -:  249:      }
    #####:  250:      default:
        -:  251:      {
    #####:  252:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  253:        break;
        -:  254:      }
        -:  255:    }
    #####:  256:  }
        6:  257:} /* parser_init_literal_pool */
        -:  258:
        -:  259:/*
        -:  260: * During byte code post processing certain bytes are not
        -:  261: * copied into the final byte code buffer. For example, if
        -:  262: * one byte is enough for encoding a literal index, the
        -:  263: * second byte is not copied. However, when a byte is skipped,
        -:  264: * the offsets of those branches which crosses (jumps over)
        -:  265: * that byte code should also be decreased by one. Instead
        -:  266: * of finding these jumps every time when a byte is skipped,
        -:  267: * all branch offset updates are computed in one step.
        -:  268: *
        -:  269: * Branch offset mapping example:
        -:  270: *
        -:  271: * Let's assume that each parser_mem_page of the byte_code
        -:  272: * buffer is 8 bytes long and only 4 bytes are kept for a
        -:  273: * given page:
        -:  274: *
        -:  275: * +---+---+---+---+---+---+---+---+
        -:  276: * | X | 1 | 2 | 3 | X | 4 | X | X |
        -:  277: * +---+---+---+---+---+---+---+---+
        -:  278: *
        -:  279: * X marks those bytes which are removed. The resulting
        -:  280: * offset mapping is the following:
        -:  281: *
        -:  282: * +---+---+---+---+---+---+---+---+
        -:  283: * | 0 | 1 | 2 | 3 | 3 | 4 | 4 | 4 |
        -:  284: * +---+---+---+---+---+---+---+---+
        -:  285: *
        -:  286: * Each X is simply replaced by the index of the previous
        -:  287: * index starting from zero. This shows the number of
        -:  288: * copied bytes before a given byte including the byte
        -:  289: * itself. The last byte always shows the number of bytes
        -:  290: * copied from this page.
        -:  291: *
        -:  292: * This mapping allows recomputing all branch targets,
        -:  293: * since mapping[to] - mapping[from] is the new argument
        -:  294: * for forward branches. As for backward branches, the
        -:  295: * equation is reversed to mapping[from] - mapping[to].
        -:  296: *
        -:  297: * The mapping is relative to one page, so distance
        -:  298: * computation affecting multiple pages requires a loop.
        -:  299: * We should also note that only argument bytes can
        -:  300: * be skipped, so removed bytes cannot be targeted by
        -:  301: * branches. Valid branches always target instruction
        -:  302: * starts only.
        -:  303: */
        -:  304:
        -:  305:/**
        -:  306: * Recompute the argument of a forward branch.
        -:  307: *
        -:  308: * @return the new distance
        -:  309: */
        -:  310:static size_t
        2:  311:parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  312:                              size_t full_distance, /**< full distance */
        -:  313:                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  314:{
        2:  315:  size_t new_distance = 0;
        -:  316:
        4:  317:  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)
        -:  318:  {
    #####:  319:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  320:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  321:    page_p = page_p->next_p;
        -:  322:  }
        -:  323:
        2:  324:  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        2:  325:  return new_distance - bytes_copied_before_jump;
        -:  326:} /* parser_update_forward_branch */
        -:  327:
        -:  328:/**
        -:  329: * Recompute the argument of a backward branch.
        -:  330: *
        -:  331: * @return the new distance
        -:  332: */
        -:  333:static size_t
    #####:  334:parser_update_backward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  335:                               size_t full_distance, /**< full distance */
        -:  336:                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  337:{
    #####:  338:  size_t new_distance = bytes_copied_before_jump;
        -:  339:
    #####:  340:  while (full_distance >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  341:  {
    #####:  342:    JERRY_ASSERT (page_p != NULL);
    #####:  343:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  344:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  345:    page_p = page_p->next_p;
        -:  346:  }
        -:  347:
    #####:  348:  if (full_distance > 0)
        -:  349:  {
    #####:  350:    size_t offset = PARSER_CBC_STREAM_PAGE_SIZE - full_distance;
        -:  351:
    #####:  352:    JERRY_ASSERT (page_p != NULL);
        -:  353:
    #####:  354:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  355:    new_distance -= page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  356:  }
        -:  357:
    #####:  358:  return new_distance;
        -:  359:} /* parser_update_backward_branch */
        -:  360:
        -:  361:/**
        -:  362: * Update targets of all branches in one step.
        -:  363: */
        -:  364:static void
        6:  365:parse_update_branches (parser_context_t *context_p, /**< context */
        -:  366:                       uint8_t *byte_code_p) /**< byte code */
        -:  367:{
        6:  368:  parser_mem_page_t *page_p = context_p->byte_code.first_p;
        6:  369:  parser_mem_page_t *prev_page_p = NULL;
        6:  370:  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;
        6:  371:  size_t last_position = context_p->byte_code.last_position;
        6:  372:  size_t offset = 0;
        6:  373:  size_t bytes_copied = 0;
        -:  374:
        6:  375:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  376:  {
        1:  377:    last_page_p = NULL;
        1:  378:    last_position = 0;
        -:  379:  }
        -:  380:
      114:  381:  while (page_p != last_page_p || offset < last_position)
        -:  382:  {
        -:  383:    /* Branch instructions are marked to improve search speed. */
      102:  384:    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)
        -:  385:    {
        2:  386:      uint8_t *bytes_p = byte_code_p + bytes_copied;
        -:  387:      uint8_t flags;
        2:  388:      uint8_t bytes_copied_before_jump = 0;
        -:  389:      size_t branch_argument_length;
        -:  390:      size_t target_distance;
        -:  391:      size_t length;
        -:  392:
        2:  393:      if (offset > 0)
        -:  394:      {
        2:  395:        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  396:      }
        2:  397:      bytes_p += bytes_copied_before_jump;
        -:  398:
        2:  399:      if (*bytes_p == CBC_EXT_OPCODE)
        -:  400:      {
    #####:  401:        bytes_p++;
    #####:  402:        flags = cbc_ext_flags[*bytes_p];
        -:  403:      }
        -:  404:      else
        -:  405:      {
        2:  406:        flags = cbc_flags[*bytes_p];
        -:  407:      }
        -:  408:
        2:  409:      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
        2:  410:      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);
        2:  411:      bytes_p++;
        -:  412:
        -:  413:      /* Decoding target. */
        2:  414:      length = branch_argument_length;
        2:  415:      target_distance = 0;
        -:  416:      do
        -:  417:      {
        2:  418:        target_distance = (target_distance << 8) | *bytes_p;
        2:  419:        bytes_p++;
        -:  420:      }
        2:  421:      while (--length > 0);
        -:  422:
        2:  423:      if (CBC_BRANCH_IS_FORWARD (flags))
        -:  424:      {
        -:  425:        /* Branch target was not set. */
        2:  426:        JERRY_ASSERT (target_distance > 0);
        -:  427:
        2:  428:        target_distance = parser_update_forward_branch (page_p,
        -:  429:                                                        offset + target_distance,
        -:  430:                                                        bytes_copied_before_jump);
        -:  431:      }
        -:  432:      else
        -:  433:      {
    #####:  434:        if (target_distance < offset)
        -:  435:        {
    #####:  436:          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];
    #####:  437:          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;
        -:  438:
    #####:  439:          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);
        -:  440:        }
    #####:  441:        else if (target_distance == offset)
        -:  442:        {
    #####:  443:          target_distance = bytes_copied_before_jump;
        -:  444:        }
        -:  445:        else
        -:  446:        {
    #####:  447:          target_distance = parser_update_backward_branch (prev_page_p,
        -:  448:                                                           target_distance - offset,
        -:  449:                                                           bytes_copied_before_jump);
        -:  450:        }
        -:  451:      }
        -:  452:
        -:  453:      /* Encoding target again. */
        -:  454:      do
        -:  455:      {
        2:  456:        bytes_p--;
        2:  457:        *bytes_p = (uint8_t) (target_distance & 0xff);
        2:  458:        target_distance >>= 8;
        -:  459:      }
        2:  460:      while (--branch_argument_length > 0);
        -:  461:    }
        -:  462:
      102:  463:    offset++;
      102:  464:    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  465:    {
        1:  466:      parser_mem_page_t *next_p = page_p->next_p;
        -:  467:
        -:  468:      /* We reverse the pages before the current page. */
        1:  469:      page_p->next_p = prev_page_p;
        1:  470:      prev_page_p = page_p;
        -:  471:
        1:  472:      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        1:  473:      page_p = next_p;
        1:  474:      offset = 0;
        -:  475:    }
        -:  476:  }
        -:  477:
        -:  478:  /* After this point the pages of the byte code stream are
        -:  479:   * not used anymore. However, they needs to be freed during
        -:  480:   * cleanup, so the first and last pointers of the stream
        -:  481:   * descriptor are reversed as well. */
        6:  482:  if (last_page_p != NULL)
        -:  483:  {
        5:  484:    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);
        5:  485:    last_page_p->next_p = prev_page_p;
        -:  486:  }
        -:  487:  else
        -:  488:  {
        1:  489:    last_page_p = context_p->byte_code.last_p;
        -:  490:  }
        -:  491:
        6:  492:  context_p->byte_code.last_p = context_p->byte_code.first_p;
        6:  493:  context_p->byte_code.first_p = last_page_p;
        6:  494:} /* parse_update_branches */
        -:  495:
        -:  496:#if JERRY_DEBUGGER
        -:  497:
        -:  498:/**
        -:  499: * Send current breakpoint list.
        -:  500: */
        -:  501:static void
        -:  502:parser_send_breakpoints (parser_context_t *context_p, /**< context */
        -:  503:                         jerry_debugger_header_type_t type) /**< message type */
        -:  504:{
        -:  505:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  506:  JERRY_ASSERT (context_p->breakpoint_info_count > 0);
        -:  507:
        -:  508:  jerry_debugger_send_data (type,
        -:  509:                            context_p->breakpoint_info,
        -:  510:                            context_p->breakpoint_info_count * sizeof (parser_breakpoint_info_t));
        -:  511:
        -:  512:  context_p->breakpoint_info_count = 0;
        -:  513:} /* parser_send_breakpoints */
        -:  514:
        -:  515:/**
        -:  516: * Append a breakpoint info.
        -:  517: */
        -:  518:void
        -:  519:parser_append_breakpoint_info (parser_context_t *context_p, /**< context */
        -:  520:                               jerry_debugger_header_type_t type, /**< message type */
        -:  521:                               uint32_t value) /**< line or offset of the breakpoint */
        -:  522:{
        -:  523:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  524:
        -:  525:  context_p->status_flags |= PARSER_DEBUGGER_BREAKPOINT_APPENDED;
        -:  526:
        -:  527:  if (context_p->breakpoint_info_count >= JERRY_DEBUGGER_SEND_MAX (parser_breakpoint_info_t))
        -:  528:  {
        -:  529:    parser_send_breakpoints (context_p, type);
        -:  530:  }
        -:  531:
        -:  532:  context_p->breakpoint_info[context_p->breakpoint_info_count].value = value;
        -:  533:  context_p->breakpoint_info_count = (uint16_t) (context_p->breakpoint_info_count + 1);
        -:  534:} /* parser_append_breakpoint_info */
        -:  535:
        -:  536:#endif /* JERRY_DEBUGGER */
        -:  537:
        -:  538:/**
        -:  539: * Forward iterator: move to the next byte code
        -:  540: *
        -:  541: * @param page_p page
        -:  542: * @param offset offset
        -:  543: */
        -:  544:#define PARSER_NEXT_BYTE(page_p, offset) \
        -:  545:  do { \
        -:  546:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:  547:    { \
        -:  548:      offset = 0; \
        -:  549:      page_p = page_p->next_p; \
        -:  550:    } \
        -:  551:  } while (0)
        -:  552:
        -:  553:/**
        -:  554: * Forward iterator: move to the next byte code. Also updates the offset of the previous byte code.
        -:  555: *
        -:  556: * @param page_p page
        -:  557: * @param offset offset
        -:  558: * @param real_offset real offset
        -:  559: */
        -:  560:#define PARSER_NEXT_BYTE_UPDATE(page_p, offset, real_offset) \
        -:  561:  do { \
        -:  562:    page_p->bytes[offset] = real_offset; \
        -:  563:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:  564:    { \
        -:  565:      offset = 0; \
        -:  566:      real_offset = 0; \
        -:  567:      page_p = page_p->next_p; \
        -:  568:    } \
        -:  569:  } while (0)
        -:  570:
        -:  571:/**
        -:  572: * Post processing main function.
        -:  573: *
        -:  574: * @return compiled code
        -:  575: */
        -:  576:static ecma_compiled_code_t *
        6:  577:parser_post_processing (parser_context_t *context_p) /**< context */
        -:  578:{
        -:  579:  uint16_t literal_one_byte_limit;
        6:  580:  uint16_t ident_end;
        6:  581:  uint16_t const_literal_end;
        -:  582:  parser_mem_page_t *page_p;
        -:  583:  parser_mem_page_t *last_page_p;
        -:  584:  size_t last_position;
        -:  585:  size_t offset;
        -:  586:  size_t length;
        -:  587:  size_t literal_length;
        -:  588:  size_t total_size;
        -:  589:  uint8_t real_offset;
        -:  590:  uint8_t *byte_code_p;
        -:  591:  bool needs_uint16_arguments;
        6:  592:  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;
        -:  593:  ecma_compiled_code_t *compiled_code_p;
        -:  594:  ecma_value_t *literal_pool_p;
        -:  595:  uint8_t *dst_p;
        -:  596:
        -:  597:#if JERRY_ESNEXT
        6:  598:  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  599:      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  600:  {
    #####:  601:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  602:#ifndef JERRY_NDEBUG
    #####:  603:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  604:#endif /* !JERRY_NDEBUG */
        -:  605:
    #####:  606:    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -:  607:
    #####:  608:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
        -:  609:
    #####:  610:    parser_branch_t branch;
    #####:  611:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  612:    parser_set_branch_to_current_position (context_p, &branch);
        -:  613:
    #####:  614:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  615:  }
        -:  616:
        6:  617:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  618:  {
    #####:  619:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  620:#ifndef JERRY_NDEBUG
    #####:  621:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  622:#endif /* !JERRY_NDEBUG */
        -:  623:
    #####:  624:    if (context_p->stack_limit < PARSER_FINALLY_CONTEXT_STACK_ALLOCATION)
        -:  625:    {
    #####:  626:      context_p->stack_limit = PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -:  627:    }
        -:  628:
    #####:  629:    parser_branch_t branch;
        -:  630:
    #####:  631:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  632:    parser_set_branch_to_current_position (context_p, &branch);
        -:  633:
    #####:  634:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  635:  }
        -:  636:#endif /* JERRY_ESNEXT */
        -:  637:
        -:  638:#if JERRY_LINE_INFO
        -:  639:  JERRY_ASSERT (context_p->line_info_p != NULL);
        -:  640:#endif /* JERRY_LINE_INFO */
        -:  641:
        6:  642:  JERRY_ASSERT (context_p->stack_depth == 0);
        -:  643:#ifndef JERRY_NDEBUG
        6:  644:  JERRY_ASSERT (context_p->context_stack_depth == 0);
        -:  645:#endif /* !JERRY_NDEBUG */
        -:  646:
        6:  647:  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)
        -:  648:  {
    #####:  649:    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  650:  }
        -:  651:
        6:  652:  if (JERRY_UNLIKELY (context_p->script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -:  653:  {
        -:  654:    /* This is probably never happens in practice. */
    #####:  655:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  656:  }
        -:  657:
        6:  658:  context_p->script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        -:  659:
        6:  660:  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);
        -:  661:
        -:  662:#if JERRY_DEBUGGER
        -:  663:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  664:      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))
        -:  665:  {
        -:  666:    /* Always provide at least one breakpoint. */
        -:  667:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  668:    parser_flush_cbc (context_p);
        -:  669:
        -:  670:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -:  671:
        -:  672:    context_p->last_breakpoint_line = context_p->token.line;
        -:  673:  }
        -:  674:
        -:  675:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  676:      && context_p->breakpoint_info_count > 0)
        -:  677:  {
        -:  678:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -:  679:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -:  680:  }
        -:  681:#endif /* JERRY_DEBUGGER */
        -:  682:
        6:  683:  parser_compute_indicies (context_p, &ident_end, &const_literal_end);
        -:  684:
        6:  685:  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  686:  {
        6:  687:    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;
        -:  688:  }
        -:  689:  else
        -:  690:  {
    #####:  691:    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;
        -:  692:  }
        -:  693:
        6:  694:  last_page_p = context_p->byte_code.last_p;
        6:  695:  last_position = context_p->byte_code.last_position;
        -:  696:
        6:  697:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  698:  {
        1:  699:    last_page_p = NULL;
        1:  700:    last_position = 0;
        -:  701:  }
        -:  702:
        6:  703:  page_p = context_p->byte_code.first_p;
        6:  704:  offset = 0;
        6:  705:  length = 0;
        -:  706:
       45:  707:  while (page_p != last_page_p || offset < last_position)
        -:  708:  {
        -:  709:    uint8_t *opcode_p;
        -:  710:    uint8_t flags;
        -:  711:    size_t branch_offset_length;
        -:  712:
       33:  713:    opcode_p = page_p->bytes + offset;
       33:  714:    last_opcode = (cbc_opcode_t) (*opcode_p);
       33:  715:    PARSER_NEXT_BYTE (page_p, offset);
       33:  716:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);
       33:  717:    flags = cbc_flags[last_opcode];
       33:  718:    length++;
        -:  719:
       33:  720:    switch (last_opcode)
        -:  721:    {
        3:  722:      case CBC_EXT_OPCODE:
        -:  723:      {
        -:  724:        cbc_ext_opcode_t ext_opcode;
        -:  725:
        3:  726:        ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        3:  727:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        3:  728:        flags = cbc_ext_flags[ext_opcode];
        3:  729:        PARSER_NEXT_BYTE (page_p, offset);
        3:  730:        length++;
        3:  731:        break;
        -:  732:      }
    #####:  733:      case CBC_POST_DECR:
        -:  734:      {
    #####:  735:        *opcode_p = CBC_PRE_DECR;
    #####:  736:        break;
        -:  737:      }
    #####:  738:      case CBC_POST_INCR:
        -:  739:      {
    #####:  740:        *opcode_p = CBC_PRE_INCR;
    #####:  741:        break;
        -:  742:      }
    #####:  743:      case CBC_POST_DECR_IDENT:
        -:  744:      {
    #####:  745:        *opcode_p = CBC_PRE_DECR_IDENT;
    #####:  746:        break;
        -:  747:      }
    #####:  748:      case CBC_POST_INCR_IDENT:
        -:  749:      {
    #####:  750:        *opcode_p = CBC_PRE_INCR_IDENT;
    #####:  751:        break;
        -:  752:      }
       30:  753:      default:
        -:  754:      {
       30:  755:        break;
        -:  756:      }
        -:  757:    }
        -:  758:
       76:  759:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  760:    {
       29:  761:      uint8_t *first_byte = page_p->bytes + offset;
       29:  762:      uint32_t literal_index = *first_byte;
        -:  763:
       29:  764:      PARSER_NEXT_BYTE (page_p, offset);
       29:  765:      length++;
        -:  766:
       29:  767:      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;
        -:  768:
       29:  769:      if (literal_index >= PARSER_REGISTER_START)
        -:  770:      {
        4:  771:        literal_index -= PARSER_REGISTER_START;
        -:  772:      }
        -:  773:      else
        -:  774:      {
       25:  775:        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;
        -:  776:      }
        -:  777:
       29:  778:      if (literal_index <= literal_one_byte_limit)
        -:  779:      {
       29:  780:        *first_byte = (uint8_t) literal_index;
        -:  781:      }
        -:  782:      else
        -:  783:      {
    #####:  784:        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  785:        {
    #####:  786:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);
    #####:  787:          *first_byte = CBC_MAXIMUM_BYTE_VALUE;
    #####:  788:          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);
    #####:  789:          length++;
        -:  790:        }
        -:  791:        else
        -:  792:        {
    #####:  793:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);
    #####:  794:          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);
    #####:  795:          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);
    #####:  796:          length++;
        -:  797:        }
        -:  798:      }
       29:  799:      PARSER_NEXT_BYTE (page_p, offset);
        -:  800:
       29:  801:      if (flags & CBC_HAS_LITERAL_ARG2)
        -:  802:      {
       10:  803:        if (flags & CBC_HAS_LITERAL_ARG)
        -:  804:        {
       10:  805:          flags = CBC_HAS_LITERAL_ARG;
        -:  806:        }
        -:  807:        else
        -:  808:        {
    #####:  809:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -:  810:        }
        -:  811:      }
        -:  812:      else
        -:  813:      {
       19:  814:        break;
        -:  815:      }
        -:  816:    }
        -:  817:
       33:  818:    if (flags & CBC_HAS_BYTE_ARG)
        -:  819:    {
        -:  820:      /* This argument will be copied without modification. */
        2:  821:      PARSER_NEXT_BYTE (page_p, offset);
        2:  822:      length++;
        -:  823:    }
        -:  824:
       33:  825:    if (flags & CBC_HAS_BRANCH_ARG)
        -:  826:    {
        2:  827:      bool prefix_zero = true;
        -:  828:
        -:  829:      /* The leading zeroes are dropped from the stream.
        -:  830:       * Although dropping these zeroes for backward
        -:  831:       * branches are unnecessary, we use the same
        -:  832:       * code path for simplicity. */
        2:  833:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -:  834:
        8:  835:      while (--branch_offset_length > 0)
        -:  836:      {
        4:  837:        uint8_t byte = page_p->bytes[offset];
        4:  838:        if (byte > 0 || !prefix_zero)
        -:  839:        {
    #####:  840:          prefix_zero = false;
    #####:  841:          length++;
        -:  842:        }
        -:  843:        else
        -:  844:        {
        4:  845:          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
        -:  846:        }
        4:  847:        PARSER_NEXT_BYTE (page_p, offset);
        -:  848:      }
        -:  849:
        2:  850:      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1)
        1:  851:          && prefix_zero
        1:  852:          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)
        -:  853:      {
        -:  854:        /* Uncoditional jumps which jump right after the instruction
        -:  855:         * are effectively NOPs. These jumps are removed from the
        -:  856:         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these
        -:  857:         * instructions, since this form is constructed during post
        -:  858:         * processing and cannot be emitted directly. */
    #####:  859:        *opcode_p = CBC_JUMP_FORWARD;
    #####:  860:        length--;
        -:  861:      }
        -:  862:      else
        -:  863:      {
        -:  864:        /* Other last bytes are always copied. */
        2:  865:        length++;
        -:  866:      }
        -:  867:
        2:  868:      PARSER_NEXT_BYTE (page_p, offset);
        -:  869:    }
        -:  870:  }
        -:  871:
        6:  872:  if (!(context_p->status_flags & PARSER_NO_END_LABEL)
        5:  873:      || !(PARSER_OPCODE_IS_RETURN (last_opcode)))
        -:  874:  {
        3:  875:    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  876:
        -:  877:#if JERRY_ESNEXT
        3:  878:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  879:    {
    #####:  880:      length++;
        -:  881:    }
        -:  882:#endif /* JERRY_ESNEXT */
        -:  883:
        3:  884:    length++;
        -:  885:  }
        -:  886:
        6:  887:  needs_uint16_arguments = false;
        6:  888:  total_size = sizeof (cbc_uint8_arguments_t);
        -:  889:
        6:  890:  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE
        6:  891:      || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE
        6:  892:      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)
        -:  893:  {
    #####:  894:    needs_uint16_arguments = true;
    #####:  895:    total_size = sizeof (cbc_uint16_arguments_t);
        -:  896:  }
        -:  897:
        6:  898:  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);
        -:  899:
        6:  900:  total_size += literal_length + length;
        -:  901:
        6:  902:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -:  903:  {
    #####:  904:    total_size += context_p->argument_count * sizeof (ecma_value_t);
        -:  905:  }
        -:  906:
        -:  907:#if JERRY_ESNEXT
        -:  908:  /* function.name */
        6:  909:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -:  910:  {
        6:  911:    total_size += sizeof (ecma_value_t);
        -:  912:  }
        -:  913:
        6:  914:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -:  915:  {
    #####:  916:    total_size += sizeof (ecma_value_t);
        -:  917:  }
        -:  918:#endif /* JERRY_ESNEXT */
        -:  919:
        -:  920:#if JERRY_LINE_INFO
    #####:  921:  total_size += sizeof (ecma_value_t);
        -:  922:#endif /* JERRY_LINE_INFO */
        -:  923:
        -:  924:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        6:  925:  uint8_t extended_info = 0;
        -:  926:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  927:
        -:  928:#if JERRY_ESNEXT
        6:  929:  if (context_p->argument_length != UINT16_MAX)
        -:  930:  {
    #####:  931:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH;
    #####:  932:    total_size += ecma_extended_info_get_encoded_length (context_p->argument_length);
        -:  933:  }
        -:  934:#endif /* JERRY_ESNEXT */
        -:  935:
        -:  936:#if JERRY_FUNCTION_TO_STRING
    #####:  937:  if (context_p->last_context_p != NULL)
        -:  938:  {
    #####:  939:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE;
        -:  940:
    #####:  941:    const uint8_t *start_p = context_p->source_start_p;
    #####:  942:    const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -:  943:
    #####:  944:    if (function_start_p < start_p || function_start_p >= start_p + context_p->source_size)
        -:  945:    {
        -:  946:      JERRY_ASSERT (context_p->arguments_start_p != NULL
        -:  947:                    && function_start_p >= context_p->arguments_start_p
        -:  948:                    && function_start_p < context_p->arguments_start_p + context_p->arguments_size);
        -:  949:
    #####:  950:      start_p = context_p->arguments_start_p;
    #####:  951:      extended_info |= CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS;
        -:  952:    }
        -:  953:
    #####:  954:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (function_start_p - start_p));
    #####:  955:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (context_p->function_end_p - function_start_p));
        -:  956:  }
        -:  957:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  958:
        -:  959:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        6:  960:  if (extended_info != 0)
        -:  961:  {
    #####:  962:    total_size += sizeof (uint8_t);
        -:  963:  }
        -:  964:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  965:
        6:  966:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -:  967:
        6:  968:  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);
        -:  969:
        -:  970:#if JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE
        -:  971:  // Avoid getting junk bytes
    #####:  972:  memset (compiled_code_p, 0, total_size);
        -:  973:#endif /* JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE */
        -:  974:
        -:  975:#if JERRY_MEM_STATS
    #####:  976:  jmem_stats_allocate_byte_code_bytes (total_size);
        -:  977:#endif /* JERRY_MEM_STATS */
        -:  978:
        6:  979:  byte_code_p = (uint8_t *) compiled_code_p;
        6:  980:  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);
        6:  981:  compiled_code_p->refs = 1;
        6:  982:  compiled_code_p->status_flags = 0;
        -:  983:
        -:  984:#if JERRY_ESNEXT
        6:  985:  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -:  986:  {
    #####:  987:    JERRY_ASSERT (context_p->argument_count > 0);
    #####:  988:    context_p->argument_count--;
        -:  989:  }
        -:  990:#endif /* JERRY_ESNEXT */
        -:  991:
        6:  992:  if (needs_uint16_arguments)
        -:  993:  {
    #####:  994:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  995:
    #####:  996:    args_p->stack_limit = context_p->stack_limit;
    #####:  997:    args_p->script_value = context_p->script_value;
    #####:  998:    args_p->argument_end = context_p->argument_count;
    #####:  999:    args_p->register_end = context_p->register_count;
    #####: 1000:    args_p->ident_end = ident_end;
    #####: 1001:    args_p->const_literal_end = const_literal_end;
    #####: 1002:    args_p->literal_end = context_p->literal_count;
        -: 1003:
    #####: 1004:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;
    #####: 1005:    byte_code_p += sizeof (cbc_uint16_arguments_t);
        -: 1006:  }
        -: 1007:  else
        -: 1008:  {
        6: 1009:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 1010:
        6: 1011:    args_p->stack_limit = (uint8_t) context_p->stack_limit;
        6: 1012:    args_p->argument_end = (uint8_t) context_p->argument_count;
        6: 1013:    args_p->script_value = context_p->script_value;
        6: 1014:    args_p->register_end = (uint8_t) context_p->register_count;
        6: 1015:    args_p->ident_end = (uint8_t) ident_end;
        6: 1016:    args_p->const_literal_end = (uint8_t) const_literal_end;
        6: 1017:    args_p->literal_end = (uint8_t) context_p->literal_count;
        -: 1018:
        6: 1019:    byte_code_p += sizeof (cbc_uint8_arguments_t);
        -: 1020:  }
        -: 1021:
        -: 1022:  uint16_t encoding_limit;
        -: 1023:  uint16_t encoding_delta;
        -: 1024:
        6: 1025:  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)
        -: 1026:  {
    #####: 1027:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;
    #####: 1028:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1029:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1030:  }
        -: 1031:  else
        -: 1032:  {
        6: 1033:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        6: 1034:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1035:  }
        -: 1036:
        6: 1037:  if (context_p->status_flags & PARSER_IS_STRICT)
        -: 1038:  {
    #####: 1039:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;
        -: 1040:  }
        -: 1041:
        6: 1042:  if ((context_p->status_flags & PARSER_ARGUMENTS_NEEDED)
    #####: 1043:      && PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1044:  {
    #####: 1045:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;
        -: 1046:  }
        -: 1047:
        6: 1048:  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))
        -: 1049:  {
        4: 1050:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;
        -: 1051:  }
        -: 1052:
        6: 1053:  uint16_t function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_NORMAL);
        -: 1054:
        6: 1055:  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 1056:  {
        3: 1057:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ACCESSOR);
        -: 1058:  }
        3: 1059:  else if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 1060:  {
        1: 1061:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_SCRIPT);
        -: 1062:  }
        -: 1063:#if JERRY_ESNEXT
        2: 1064:  else if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)
        -: 1065:  {
        1: 1066:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1067:    {
    #####: 1068:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_ARROW);
        -: 1069:    }
        -: 1070:    else
        -: 1071:    {
        1: 1072:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ARROW);
        -: 1073:    }
        -: 1074:  }
        1: 1075:  else if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1076:  {
    #####: 1077:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1078:    {
    #####: 1079:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1080:    }
        -: 1081:    else
        -: 1082:    {
    #####: 1083:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_GENERATOR);
        -: 1084:    }
        -: 1085:  }
        1: 1086:  else if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1087:  {
    #####: 1088:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC);
        -: 1089:  }
        1: 1090:  else if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)
        -: 1091:  {
    #####: 1092:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_CONSTRUCTOR);
        -: 1093:  }
        1: 1094:  else if (context_p->status_flags & PARSER_IS_METHOD)
        -: 1095:  {
    #####: 1096:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_METHOD);
        -: 1097:  }
        -: 1098:
        6: 1099:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1100:  {
    #####: 1101:    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));
    #####: 1102:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;
        -: 1103:  }
        -: 1104:#endif /* JERRY_ESNEXT */
        -: 1105:
        6: 1106:  compiled_code_p->status_flags |= function_type;
        -: 1107:
        -: 1108:#if JERRY_LINE_INFO
    #####: 1109:  compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_LINE_INFO;
        -: 1110:#endif /* JERRY_LINE_INFO */
        -: 1111:
        6: 1112:  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;
        6: 1113:  byte_code_p += literal_length;
        6: 1114:  dst_p = byte_code_p;
        -: 1115:
        6: 1116:  parser_init_literal_pool (context_p, literal_pool_p);
        -: 1117:
        6: 1118:  page_p = context_p->byte_code.first_p;
        6: 1119:  offset = 0;
        6: 1120:  real_offset = 0;
        6: 1121:  uint8_t last_register_index = (uint8_t) JERRY_MIN (context_p->register_count,
        -: 1122:                                                     (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));
        -: 1123:
       45: 1124:  while (page_p != last_page_p || offset < last_position)
        -: 1125:  {
        -: 1126:    uint8_t flags;
        -: 1127:    uint8_t *opcode_p;
        -: 1128:    uint8_t *branch_mark_p;
        -: 1129:    cbc_opcode_t opcode;
        -: 1130:    size_t branch_offset_length;
        -: 1131:
       33: 1132:    opcode_p = dst_p;
       33: 1133:    branch_mark_p = page_p->bytes + offset;
       33: 1134:    opcode = (cbc_opcode_t) (*branch_mark_p);
       33: 1135:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        -: 1136:
       33: 1137:    if (opcode == CBC_JUMP_FORWARD)
        -: 1138:    {
        -: 1139:      /* These opcodes are deleted from the stream. */
    #####: 1140:      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;
        -: 1141:
        -: 1142:      do
        -: 1143:      {
    #####: 1144:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1145:      }
    #####: 1146:      while (--counter > 0);
        -: 1147:
    #####: 1148:      continue;
        -: 1149:    }
        -: 1150:
        -: 1151:    /* Storing the opcode */
       33: 1152:    *dst_p++ = (uint8_t) opcode;
       33: 1153:    real_offset++;
       33: 1154:    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
       33: 1155:    flags = cbc_flags[opcode];
        -: 1156:
        -: 1157:#if JERRY_DEBUGGER
        -: 1158:    if (opcode == CBC_BREAKPOINT_DISABLED)
        -: 1159:    {
        -: 1160:      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);
        -: 1161:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);
        -: 1162:    }
        -: 1163:#endif /* JERRY_DEBUGGER */
        -: 1164:
       33: 1165:    if (opcode == CBC_EXT_OPCODE)
        -: 1166:    {
        -: 1167:      cbc_ext_opcode_t ext_opcode;
        -: 1168:
        3: 1169:      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        3: 1170:      flags = cbc_ext_flags[ext_opcode];
        3: 1171:      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        -: 1172:
        -: 1173:      /* Storing the extended opcode */
        3: 1174:      *dst_p++ = (uint8_t) ext_opcode;
        3: 1175:      opcode_p++;
        3: 1176:      real_offset++;
        3: 1177:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1178:    }
        -: 1179:
        -: 1180:    /* Only literal and call arguments can be combined. */
       33: 1181:    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG)
        -: 1182:                   || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));
        -: 1183:
       76: 1184:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -: 1185:    {
       29: 1186:      uint16_t first_byte = page_p->bytes[offset];
        -: 1187:
       29: 1188:      uint8_t *opcode_pos_p = dst_p - 1;
       29: 1189:      *dst_p++ = (uint8_t) first_byte;
       29: 1190:      real_offset++;
       29: 1191:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1192:
       29: 1193:      if (first_byte > literal_one_byte_limit)
        -: 1194:      {
    #####: 1195:        *dst_p++ = page_p->bytes[offset];
        -: 1196:
    #####: 1197:        if (first_byte >= encoding_limit)
        -: 1198:        {
    #####: 1199:          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);
        -: 1200:        }
    #####: 1201:        real_offset++;
        -: 1202:      }
       29: 1203:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1204:
       29: 1205:      if (flags & CBC_HAS_LITERAL_ARG2)
        -: 1206:      {
       10: 1207:        if (flags & CBC_HAS_LITERAL_ARG)
        -: 1208:        {
       10: 1209:          flags = CBC_HAS_LITERAL_ARG;
        -: 1210:        }
        -: 1211:        else
        -: 1212:        {
    #####: 1213:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -: 1214:        }
        -: 1215:      }
        -: 1216:      else
        -: 1217:      {
       19: 1218:        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))
        -: 1219:        {
        2: 1220:          *opcode_pos_p = CBC_MOV_IDENT;
        -: 1221:        }
        -: 1222:
       19: 1223:        break;
        -: 1224:      }
        -: 1225:    }
        -: 1226:
       33: 1227:    if (flags & CBC_HAS_BYTE_ARG)
        -: 1228:    {
        -: 1229:      /* This argument will be copied without modification. */
        2: 1230:      *dst_p++ = page_p->bytes[offset];
        2: 1231:      real_offset++;
        2: 1232:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        2: 1233:      continue;
        -: 1234:    }
        -: 1235:
       31: 1236:    if (flags & CBC_HAS_BRANCH_ARG)
        -: 1237:    {
        2: 1238:      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;
        2: 1239:      bool prefix_zero = true;
        -: 1240:
        -: 1241:      /* The leading zeroes are dropped from the stream. */
        2: 1242:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -: 1243:
        8: 1244:      while (--branch_offset_length > 0)
        -: 1245:      {
        4: 1246:        uint8_t byte = page_p->bytes[offset];
        4: 1247:        if (byte > 0 || !prefix_zero)
        -: 1248:        {
    #####: 1249:          prefix_zero = false;
    #####: 1250:          *dst_p++ = page_p->bytes[offset];
    #####: 1251:          real_offset++;
        -: 1252:        }
        -: 1253:        else
        -: 1254:        {
        -: 1255:          /* When a leading zero is dropped, the branch
        -: 1256:           * offset length must be decreased as well. */
        4: 1257:          (*opcode_p)--;
        -: 1258:        }
        4: 1259:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1260:      }
        -: 1261:
        2: 1262:      *dst_p++ = page_p->bytes[offset];
        2: 1263:      real_offset++;
        2: 1264:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        2: 1265:      continue;
        -: 1266:    }
        -: 1267:  }
        -: 1268:
        -: 1269:#if JERRY_DEBUGGER
        -: 1270:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1271:      && context_p->breakpoint_info_count > 0)
        -: 1272:  {
        -: 1273:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);
        -: 1274:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -: 1275:  }
        -: 1276:#endif /* JERRY_DEBUGGER */
        -: 1277:
        6: 1278:  if (!(context_p->status_flags & PARSER_NO_END_LABEL))
        -: 1279:  {
        3: 1280:    *dst_p++ = CBC_RETURN_WITH_BLOCK;
        -: 1281:
        -: 1282:#if JERRY_ESNEXT
        3: 1283:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1284:    {
    #####: 1285:      dst_p[-1] = CBC_EXT_OPCODE;
    #####: 1286:      dst_p[0] = CBC_EXT_ASYNC_EXIT;
    #####: 1287:      dst_p++;
        -: 1288:    }
        -: 1289:#endif /* JERRY_ESNEXT */
        -: 1290:  }
        6: 1291:  JERRY_ASSERT (dst_p == byte_code_p + length);
        -: 1292:
        -: 1293:#if JERRY_LINE_INFO
    #####: 1294:  uint8_t *line_info_p = parser_line_info_generate (context_p);
        -: 1295:#endif /* JERRY_LINE_INFO */
        -: 1296:
        6: 1297:  parse_update_branches (context_p, byte_code_p);
        -: 1298:
        6: 1299:  parser_cbc_stream_free (&context_p->byte_code);
        -: 1300:
        6: 1301:  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)
        -: 1302:  {
        4: 1303:    parser_list_iterator_t literal_iterator;
        -: 1304:    lexer_literal_t *literal_p;
        4: 1305:    uint16_t register_count = context_p->register_count;
        -: 1306:
        4: 1307:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
       32: 1308:    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -: 1309:    {
       24: 1310:      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT)
       15: 1311:          && literal_p->prop.index >= register_count)
        -: 1312:      {
       15: 1313:        uint32_t source_data = literal_p->u.source_data;
       15: 1314:        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);
       15: 1315:        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,
        -: 1316:                                                                     source_data >> 20,
       15: 1317:                                                                     (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
       15: 1318:        literal_pool_p[literal_p->prop.index] = lit_value;
        -: 1319:      }
        -: 1320:    }
        -: 1321:  }
        -: 1322:
        6: 1323:  ecma_value_t *base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);
        -: 1324:
        6: 1325:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1326:  {
    #####: 1327:    parser_list_iterator_t literal_iterator;
    #####: 1328:    uint16_t argument_count = 0;
    #####: 1329:    uint16_t register_count = context_p->register_count;
    #####: 1330:    base_p -= context_p->argument_count;
        -: 1331:
    #####: 1332:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
    #####: 1333:    while (argument_count < context_p->argument_count)
        -: 1334:    {
        -: 1335:      lexer_literal_t *literal_p;
    #####: 1336:      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);
        -: 1337:
    #####: 1338:      JERRY_ASSERT (literal_p != NULL);
        -: 1339:
    #####: 1340:      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1341:      {
    #####: 1342:        continue;
        -: 1343:      }
        -: 1344:
        -: 1345:      /* All arguments must be moved to initialized registers. */
    #####: 1346:      if (literal_p->type == LEXER_UNUSED_LITERAL)
        -: 1347:      {
    #####: 1348:        base_p[argument_count] = ECMA_VALUE_EMPTY;
    #####: 1349:        argument_count++;
    #####: 1350:        continue;
        -: 1351:      }
        -: 1352:
    #####: 1353:      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);
        -: 1354:
    #####: 1355:      JERRY_ASSERT (literal_p->prop.index >= register_count);
        -: 1356:
    #####: 1357:      base_p[argument_count] = literal_pool_p[literal_p->prop.index];
    #####: 1358:      argument_count++;
        -: 1359:    }
        -: 1360:  }
        -: 1361:
        -: 1362:#if JERRY_ESNEXT
        6: 1363:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -: 1364:  {
        6: 1365:    *(--base_p) = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1366:  }
        -: 1367:
        6: 1368:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 1369:  {
    #####: 1370:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_TAGGED_LITERALS;
    #####: 1371:    *(--base_p) = (ecma_value_t) context_p->tagged_template_literal_cp;
        -: 1372:  }
        -: 1373:#endif /* JERRY_ESNEXT */
        -: 1374:
        -: 1375:#if JERRY_LINE_INFO
    #####: 1376:  ECMA_SET_INTERNAL_VALUE_POINTER (base_p[-1], line_info_p);
        -: 1377:#endif /* JERRY_LINE_INFO */
        -: 1378:
        -: 1379:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        6: 1380:  if (extended_info != 0)
        -: 1381:  {
        -: 1382:#if JERRY_LINE_INFO
    #####: 1383:    base_p--;
        -: 1384:#endif /* JERRY_LINE_INFO */
        -: 1385:
    #####: 1386:    uint8_t *extended_info_p = ((uint8_t *) base_p) - 1;
        -: 1387:
    #####: 1388:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_EXTENDED_INFO;
    #####: 1389:    *extended_info_p = extended_info;
        -: 1390:
        -: 1391:#if JERRY_ESNEXT
    #####: 1392:    if (context_p->argument_length != UINT16_MAX)
        -: 1393:    {
    #####: 1394:      ecma_extended_info_encode_vlq (&extended_info_p, context_p->argument_length);
        -: 1395:    }
        -: 1396:#endif /* JERRY_ESNEXT */
        -: 1397:
        -: 1398:#if JERRY_FUNCTION_TO_STRING
    #####: 1399:    if (context_p->last_context_p != NULL)
        -: 1400:    {
    #####: 1401:      const uint8_t *start_p = context_p->source_start_p;
        -: 1402:
    #####: 1403:      if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 1404:      {
    #####: 1405:        start_p = context_p->arguments_start_p;
        -: 1406:      }
        -: 1407:
    #####: 1408:      const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -: 1409:
    #####: 1410:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (function_start_p - start_p));
    #####: 1411:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (context_p->function_end_p - function_start_p));
        -: 1412:    }
        -: 1413:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1414:  }
        -: 1415:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -: 1416:
        -: 1417:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1418:  if (context_p->is_show_opcodes)
        -: 1419:  {
        -: 1420:    util_print_cbc (compiled_code_p);
        -: 1421:    JERRY_DEBUG_MSG ("\nByte code size: %d bytes\n", (int) length);
        -: 1422:    context_p->total_byte_code_size += (uint32_t) length;
        -: 1423:  }
        -: 1424:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1425:
        -: 1426:#if JERRY_DEBUGGER
        -: 1427:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1428:  {
        -: 1429:    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);
        -: 1430:  }
        -: 1431:#endif /* JERRY_DEBUGGER */
        -: 1432:
        6: 1433:  return compiled_code_p;
        -: 1434:} /* parser_post_processing */
        -: 1435:
        -: 1436:#undef PARSER_NEXT_BYTE
        -: 1437:#undef PARSER_NEXT_BYTE_UPDATE
        -: 1438:
        -: 1439:/**
        -: 1440: * Free identifiers and literals.
        -: 1441: */
        -: 1442:static void
    #####: 1443:parser_free_literals (parser_list_t *literal_pool_p) /**< literals */
        -: 1444:{
    #####: 1445:  parser_list_iterator_t literal_iterator;
        -: 1446:  lexer_literal_t *literal_p;
        -: 1447:
    #####: 1448:  parser_list_iterator_init (literal_pool_p, &literal_iterator);
    #####: 1449:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1450:  {
    #####: 1451:    util_free_literal (literal_p);
        -: 1452:  }
        -: 1453:
    #####: 1454:  parser_list_free (literal_pool_p);
    #####: 1455:} /* parser_free_literals */
        -: 1456:
        -: 1457:/**
        -: 1458: * Parse function arguments
        -: 1459: */
        -: 1460:static void
        5: 1461:parser_parse_function_arguments (parser_context_t *context_p, /**< context */
        -: 1462:                                 lexer_token_type_t end_type) /**< expected end type */
        -: 1463:{
        5: 1464:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1465:
        -: 1466:#if JERRY_ESNEXT
        5: 1467:  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        5: 1468:  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));
        -: 1469:
        5: 1470:  bool has_duplicated_arg_names = false;
        -: 1471:
        5: 1472:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1473:  {
    #####: 1474:    parser_branch_t branch;
    #####: 1475:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_TRY_CREATE_CONTEXT, &branch);
    #####: 1476:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1477:
        -: 1478:#ifndef JERRY_NDEBUG
    #####: 1479:    context_p->context_stack_depth = PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 1480:#endif /* !JERRY_NDEBUG */
        -: 1481:  }
        -: 1482:#endif /* JERRY_ESNEXT */
        -: 1483:
        5: 1484:  if (context_p->token.type == end_type)
        -: 1485:  {
        -: 1486:#if JERRY_ESNEXT
        3: 1487:    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;
        -: 1488:
        3: 1489:    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1490:    {
    #####: 1491:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1492:      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1493:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1494:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
    #####: 1495:      return;
        -: 1496:    }
        -: 1497:#endif /* JERRY_ESNEXT */
        3: 1498:    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        3: 1499:    return;
        -: 1500:  }
        -: 1501:
        -: 1502:#if JERRY_ESNEXT
        2: 1503:  bool has_complex_argument = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT) != 0;
        -: 1504:#endif /* JERRY_ESNEXT */
        2: 1505:  bool is_strict = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT) != 0;
        -: 1506:
        2: 1507:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
        2: 1508:  scanner_set_active (context_p);
        -: 1509:
        -: 1510:#if JERRY_ESNEXT
        2: 1511:  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;
        -: 1512:#endif /* JERRY_ESNEXT */
        -: 1513:
        -: 1514:  while (true)
    #####: 1515:  {
        -: 1516:#if JERRY_ESNEXT
        2: 1517:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 1518:    {
    #####: 1519:      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)
        -: 1520:      {
    #####: 1521:        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);
        -: 1522:      }
    #####: 1523:      lexer_next_token (context_p);
        -: 1524:
    #####: 1525:      if (has_duplicated_arg_names)
        -: 1526:      {
    #####: 1527:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1528:      }
        -: 1529:
    #####: 1530:      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1531:    }
        -: 1532:
        2: 1533:    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1534:    {
    #####: 1535:      if (has_duplicated_arg_names)
        -: 1536:      {
    #####: 1537:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1538:      }
        -: 1539:
    #####: 1540:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1541:
    #####: 1542:      if (!(context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM))
        -: 1543:      {
    #####: 1544:        parser_emit_cbc_literal (context_p,
        -: 1545:                                 CBC_PUSH_LITERAL,
    #####: 1546:                                 (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
        -: 1547:      }
        -: 1548:      else
        -: 1549:      {
    #####: 1550:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1551:      }
        -: 1552:
    #####: 1553:      uint32_t flags = (PARSER_PATTERN_BINDING
        -: 1554:                        | PARSER_PATTERN_TARGET_ON_STACK
        -: 1555:                        | PARSER_PATTERN_LOCAL
        -: 1556:                        | PARSER_PATTERN_ARGUMENTS);
        -: 1557:
    #####: 1558:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1559:      {
    #####: 1560:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1561:        {
    #####: 1562:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1563:          {
    #####: 1564:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1565:          }
        -: 1566:
    #####: 1567:          if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1568:          {
    #####: 1569:            parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1570:          }
        -: 1571:
    #####: 1572:          if (context_p->argument_length == UINT16_MAX)
        -: 1573:          {
    #####: 1574:            context_p->argument_length = context_p->argument_count;
        -: 1575:          }
        -: 1576:
    #####: 1577:          flags |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 1578:        }
    #####: 1579:        else if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 1580:        {
    #####: 1581:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1582:          {
    #####: 1583:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1584:          }
    #####: 1585:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1586:        }
        -: 1587:        else
        -: 1588:        {
    #####: 1589:          parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 1590:        }
        -: 1591:      }
        -: 1592:
    #####: 1593:      parser_parse_initializer (context_p, flags);
        -: 1594:
    #####: 1595:      context_p->argument_count++;
    #####: 1596:      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1597:      {
    #####: 1598:        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1599:      }
        -: 1600:
    #####: 1601:      if (context_p->token.type != LEXER_COMMA)
        -: 1602:      {
    #####: 1603:        if (context_p->token.type != end_type)
        -: 1604:        {
    #####: 1605:          parser_error_t error = ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED
    #####: 1606:                                                                  : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1607:
    #####: 1608:          parser_raise_error (context_p, error);
        -: 1609:        }
    #####: 1610:        break;
        -: 1611:      }
        -: 1612:
    #####: 1613:      lexer_next_token (context_p);
        -: 1614:
    #####: 1615:      if (context_p->token.type == end_type)
        -: 1616:      {
    #####: 1617:        break;
        -: 1618:      }
    #####: 1619:      continue;
        -: 1620:    }
        -: 1621:#endif /* JERRY_ESNEXT */
        -: 1622:
        2: 1623:    if (context_p->token.type != LEXER_LITERAL
        2: 1624:        || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1625:    {
    #####: 1626:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1627:    }
        -: 1628:
        2: 1629:    lexer_construct_literal_object (context_p,
        2: 1630:                                    &context_p->token.lit_location,
        -: 1631:                                    LEXER_IDENT_LITERAL);
        -: 1632:
        2: 1633:    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1634:    {
    #####: 1635:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1636:    }
        -: 1637:
        2: 1638:    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1639:    {
        -: 1640:#if JERRY_ESNEXT
    #####: 1641:      if ((context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT)
    #####: 1642:          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))
        -: 1643:      {
    #####: 1644:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1645:      }
    #####: 1646:      has_duplicated_arg_names = true;
        -: 1647:#endif /* JERRY_ESNEXT */
        -: 1648:
    #####: 1649:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1650:    }
        -: 1651:    else
        -: 1652:    {
        2: 1653:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 1654:    }
        -: 1655:
        2: 1656:    lexer_next_token (context_p);
        -: 1657:
        -: 1658:#if JERRY_ESNEXT
        2: 1659:    uint16_t literal_index = context_p->lit_object.index;
        -: 1660:
        2: 1661:    if (context_p->token.type == LEXER_ASSIGN)
        -: 1662:    {
    #####: 1663:      JERRY_ASSERT (has_complex_argument);
        -: 1664:
    #####: 1665:      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1666:      {
    #####: 1667:        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1668:      }
        -: 1669:
    #####: 1670:      if (context_p->argument_length == UINT16_MAX)
        -: 1671:      {
    #####: 1672:        context_p->argument_length = context_p->argument_count;
        -: 1673:      }
        -: 1674:
    #####: 1675:      parser_branch_t skip_init;
        -: 1676:
    #####: 1677:      if (has_duplicated_arg_names)
        -: 1678:      {
    #####: 1679:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1680:      }
        -: 1681:
    #####: 1682:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1683:
        -: 1684:      /* LEXER_ASSIGN does not overwrite lit_object. */
    #####: 1685:      parser_emit_cbc_literal (context_p,
        -: 1686:                               CBC_PUSH_LITERAL,
    #####: 1687:                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
    #####: 1688:      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 1689:
    #####: 1690:      lexer_next_token (context_p);
    #####: 1691:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1692:
    #####: 1693:      parser_set_branch_to_current_position (context_p, &skip_init);
        -: 1694:
    #####: 1695:      uint16_t opcode = CBC_ASSIGN_LET_CONST;
        -: 1696:
    #####: 1697:      if (literal_index >= PARSER_REGISTER_START)
        -: 1698:      {
    #####: 1699:        opcode = CBC_MOV_IDENT;
        -: 1700:      }
    #####: 1701:      else if (!scanner_literal_is_created (context_p, literal_index))
        -: 1702:      {
    #####: 1703:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1704:      }
        -: 1705:
    #####: 1706:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1707:    }
        2: 1708:    else if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1709:    {
    #####: 1710:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1711:
    #####: 1712:      uint16_t opcode = CBC_MOV_IDENT;
        -: 1713:
    #####: 1714:      if (literal_index < PARSER_REGISTER_START)
        -: 1715:      {
    #####: 1716:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1717:
    #####: 1718:        if (scanner_literal_is_created (context_p, literal_index))
        -: 1719:        {
    #####: 1720:          opcode = CBC_ASSIGN_LET_CONST;
        -: 1721:        }
        -: 1722:      }
        -: 1723:
    #####: 1724:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1725:    }
        2: 1726:    else if (has_complex_argument && literal_index < PARSER_REGISTER_START)
        -: 1727:    {
    #####: 1728:      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;
        -: 1729:
    #####: 1730:      if (scanner_literal_is_created (context_p, literal_index))
        -: 1731:      {
    #####: 1732:        opcode = CBC_ASSIGN_LET_CONST_LITERAL;
        -: 1733:      }
        -: 1734:
    #####: 1735:      parser_emit_cbc_literal_value (context_p,
        -: 1736:                                     opcode,
    #####: 1737:                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),
        -: 1738:                                     literal_index);
        -: 1739:    }
        -: 1740:#endif /* JERRY_ESNEXT */
        -: 1741:
        2: 1742:    context_p->argument_count++;
        2: 1743:    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1744:    {
    #####: 1745:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1746:    }
        -: 1747:
        2: 1748:    if (context_p->token.type != LEXER_COMMA)
        -: 1749:    {
        2: 1750:      if (context_p->token.type != end_type)
        -: 1751:      {
    #####: 1752:        parser_error_t error = ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED
    #####: 1753:                                                                : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1754:
    #####: 1755:        parser_raise_error (context_p, error);
        -: 1756:      }
        2: 1757:      break;
        -: 1758:    }
        -: 1759:
        -: 1760:#if JERRY_ESNEXT
    #####: 1761:    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1762:    {
    #####: 1763:      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);
        -: 1764:    }
        -: 1765:#endif /* JERRY_ESNEXT */
        -: 1766:
    #####: 1767:    lexer_next_token (context_p);
        -: 1768:
        -: 1769:#if JERRY_ESNEXT
    #####: 1770:    if (context_p->token.type == end_type)
        -: 1771:    {
    #####: 1772:      break;
        -: 1773:    }
        -: 1774:#endif /* JERRY_ESNEXT */
        -: 1775:  }
        -: 1776:
        2: 1777:  scanner_revert_active (context_p);
        -: 1778:
        -: 1779:#if JERRY_ESNEXT
        2: 1780:  JERRY_ASSERT (has_complex_argument || !(context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT));
        -: 1781:
        2: 1782:  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1783:  {
    #####: 1784:    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1785:    parser_emit_cbc (context_p, CBC_POP);
        -: 1786:  }
        -: 1787:
        2: 1788:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1789:  {
    #####: 1790:    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)
    #####: 1791:        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))
    #####: 1792:    {
    #####: 1793:      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 1794:
    #####: 1795:      parser_branch_t branch;
    #####: 1796:      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);
    #####: 1797:      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1798:
        -: 1799:#ifndef JERRY_NDEBUG
    #####: 1800:      PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -: 1801:#endif /* !JERRY_NDEBUG */
        -: 1802:    }
        -: 1803:    else
        -: 1804:    {
    #####: 1805:      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -: 1806:    }
        -: 1807:  }
        -: 1808:
        2: 1809:  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);
        -: 1810:#endif /* JERRY_ESNEXT */
        -: 1811:
        2: 1812:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
        -: 1813:
        2: 1814:  if (is_strict)
        -: 1815:  {
    #####: 1816:    context_p->status_flags |= PARSER_IS_STRICT;
        -: 1817:  }
        -: 1818:} /* parser_parse_function_arguments */
        -: 1819:
        -: 1820:#ifndef JERRY_NDEBUG
        -: 1821:JERRY_STATIC_ASSERT (PARSER_SCANNING_SUCCESSFUL == PARSER_HAS_LATE_LIT_INIT,
        -: 1822:                     parser_scanning_successful_should_share_the_bit_position_with_parser_has_late_lit_init);
        -: 1823:#endif /* !JERRY_NDEBUG */
        -: 1824:
        -: 1825:/**
        -: 1826: * Parse and compile EcmaScript source code
        -: 1827: *
        -: 1828: * Note: source must be a valid UTF-8 string
        -: 1829: *
        -: 1830: * @return compiled code
        -: 1831: */
        -: 1832:static ecma_compiled_code_t *
        1: 1833:parser_parse_source (void *source_p, /**< source code */
        -: 1834:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 1835:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 1836:{
        1: 1837:  parser_context_t context;
        -: 1838:  ecma_compiled_code_t *compiled_code_p;
        -: 1839:
        1: 1840:  context.error = PARSER_ERR_NO_ERROR;
        1: 1841:  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;
        1: 1842:  context.global_status_flags = parse_opts;
        -: 1843:
        -: 1844:#if JERRY_ESNEXT
        1: 1845:  context.status_flags |= PARSER_RESTORE_STATUS_FLAGS (parse_opts);
        1: 1846:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        -: 1847:#endif /* JERRY_ESNEXT */
        -: 1848:
        1: 1849:  context.stack_depth = 0;
        1: 1850:  context.stack_limit = 0;
        1: 1851:  context.options_p = options_p;
        1: 1852:  context.script_p = NULL;
        1: 1853:  context.arguments_start_p = NULL;
        1: 1854:  context.arguments_size = 0;
        -: 1855:#if JERRY_MODULE_SYSTEM
        1: 1856:  if (context.global_status_flags & ECMA_PARSE_MODULE)
        -: 1857:  {
    #####: 1858:    context.status_flags |= PARSER_IS_STRICT;
        -: 1859:  }
        -: 1860:
        1: 1861:  context.module_names_p = NULL;
        -: 1862:#endif /* JERRY_MODULE_SYSTEM */
        -: 1863:
        1: 1864:  context.argument_list = ECMA_VALUE_EMPTY;
        -: 1865:
        1: 1866:  if (context.options_p != NULL
        1: 1867:      && (context.options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST))
        -: 1868:  {
    #####: 1869:    context.argument_list = context.options_p->argument_list;
        -: 1870:  }
        1: 1871:  else if (context.global_status_flags & ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE)
        -: 1872:  {
    #####: 1873:    JERRY_ASSERT (context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE);
    #####: 1874:    context.argument_list = ((ecma_value_t *) source_p)[1];
        -: 1875:  }
        -: 1876:
        1: 1877:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 1878:  {
    #####: 1879:    JERRY_ASSERT (ecma_is_value_string (context.argument_list));
        -: 1880:
    #####: 1881:    context.status_flags |= PARSER_IS_FUNCTION;
        -: 1882:#if JERRY_ESNEXT
    #####: 1883:    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)
        -: 1884:    {
    #####: 1885:      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 1886:    }
    #####: 1887:    if (parse_opts & ECMA_PARSE_ASYNC_FUNCTION)
        -: 1888:    {
    #####: 1889:      context.status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 1890:    }
        -: 1891:#endif /* JERRY_ESNEXT */
        -: 1892:
    #####: 1893:    ecma_string_t *string_p = ecma_get_string_from_value (context.argument_list);
    #####: 1894:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 1895:
    #####: 1896:    context.arguments_start_p = ecma_string_get_chars (string_p, &context.arguments_size, NULL, NULL, &flags);
        -: 1897:
    #####: 1898:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1899:    {
    #####: 1900:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_ARG_LIST;
        -: 1901:    }
        -: 1902:  }
        -: 1903:
        1: 1904:  if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 1905:  {
        1: 1906:    context.source_start_p = ((parser_source_char_t *) source_p)->source_p;
        1: 1907:    context.source_size = (lit_utf8_size_t) ((parser_source_char_t *) source_p)->source_size;
        -: 1908:  }
        -: 1909:  else
        -: 1910:  {
    #####: 1911:    ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 1912:
    #####: 1913:    JERRY_ASSERT (ecma_is_value_string (source));
        -: 1914:
    #####: 1915:    ecma_string_t *string_p = ecma_get_string_from_value (source);
    #####: 1916:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 1917:
    #####: 1918:    context.source_start_p = ecma_string_get_chars (string_p, &context.source_size, NULL, NULL, &flags);
        -: 1919:
    #####: 1920:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1921:    {
    #####: 1922:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_SOURCE;
        -: 1923:    }
        -: 1924:  }
        -: 1925:
        -: 1926:#if JERRY_DEBUGGER
        -: 1927:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1928:  {
        -: 1929:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,
        -: 1930:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -: 1931:                                context.source_start_p,
        -: 1932:                                context.source_size);
        -: 1933:  }
        -: 1934:#endif /* JERRY_DEBUGGER */
        -: 1935:
        1: 1936:  context.user_value = ECMA_VALUE_EMPTY;
        -: 1937:
        1: 1938:  if ((context.global_status_flags & ECMA_PARSE_EVAL)
    #####: 1939:      && JERRY_CONTEXT (vm_top_context_p) != NULL)
    #####: 1940:  {
    #####: 1941:    const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;
        -: 1942:
        -: 1943:#if JERRY_SNAPSHOT_EXEC
    #####: 1944:    if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 1945:    {
        -: 1946:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 1947:      ecma_value_t parent_script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;;
    #####: 1948:      cbc_script_t *parent_script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, parent_script_value);
        -: 1949:
    #####: 1950:      if (parent_script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 1951:      {
    #####: 1952:        context.user_value = CBC_SCRIPT_GET_USER_VALUE (parent_script_p);
        -: 1953:      }
        -: 1954:#if JERRY_SNAPSHOT_EXEC
        -: 1955:    }
        -: 1956:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1957:  }
        1: 1958:  else if (context.options_p != NULL
        1: 1959:           && (context.options_p->options & JERRY_PARSE_HAS_USER_VALUE))
        -: 1960:  {
    #####: 1961:    context.user_value = context.options_p->user_value;
        -: 1962:  }
        -: 1963:
        -: 1964:#if JERRY_RESOURCE_NAME
        1: 1965:  ecma_value_t resource_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 1966:
        1: 1967:  if (context.options_p != NULL
        1: 1968:      && (context.options_p->options & JERRY_PARSE_HAS_RESOURCE))
        -: 1969:  {
        1: 1970:    JERRY_ASSERT (ecma_is_value_string (context.options_p->resource_name));
        -: 1971:
        1: 1972:    ecma_ref_ecma_string (ecma_get_string_from_value (context.options_p->resource_name));
        1: 1973:    resource_name = context.options_p->resource_name;
        -: 1974:  }
    #####: 1975:  else if (context.global_status_flags & ECMA_PARSE_EVAL)
        -: 1976:  {
    #####: 1977:    resource_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_EVAL);
        -: 1978:  }
        -: 1979:#endif /* JERRY_RESOURCE_NAME */
        -: 1980:
        1: 1981:  context.last_context_p = NULL;
        1: 1982:  context.last_statement.current_p = NULL;
        1: 1983:  context.token.flags = 0;
        1: 1984:  lexer_init_line_info (&context);
        -: 1985:
        1: 1986:  scanner_info_t scanner_info_end;
        1: 1987:  scanner_info_end.next_p = NULL;
        1: 1988:  scanner_info_end.source_p = NULL;
        1: 1989:  scanner_info_end.type = SCANNER_TYPE_END;
        1: 1990:  context.next_scanner_info_p = &scanner_info_end;
        1: 1991:  context.active_scanner_info_p = NULL;
        1: 1992:  context.skipped_scanner_info_p = NULL;
        1: 1993:  context.skipped_scanner_info_end_p = NULL;
        -: 1994:
        1: 1995:  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1996:
        1: 1997:  context.argument_count = 0;
        -: 1998:#if JERRY_ESNEXT
        1: 1999:  context.argument_length = UINT16_MAX;
        -: 2000:#endif /* JERRY_ESNEXT */
        1: 2001:  context.register_count = 0;
        1: 2002:  context.literal_count = 0;
        -: 2003:
        1: 2004:  parser_cbc_stream_init (&context.byte_code);
        1: 2005:  context.byte_code_size = 0;
        1: 2006:  parser_list_init (&context.literal_pool,
        -: 2007:                    sizeof (lexer_literal_t),
        -: 2008:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));
        1: 2009:  context.scope_stack_p = NULL;
        1: 2010:  context.scope_stack_size = 0;
        1: 2011:  context.scope_stack_top = 0;
        1: 2012:  context.scope_stack_reg_top = 0;
        -: 2013:#if JERRY_ESNEXT
        1: 2014:  context.scope_stack_global_end = 0;
        1: 2015:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2016:#endif /* JERRY_ESNEXT */
        -: 2017:
        -: 2018:#ifndef JERRY_NDEBUG
        1: 2019:  context.context_stack_depth = 0;
        -: 2020:#endif /* !JERRY_NDEBUG */
        -: 2021:
        -: 2022:#if JERRY_LINE_INFO
    #####: 2023:  context.line_info_p = NULL;
        -: 2024:#endif /* JERRY_LINE_INFO */
        -: 2025:
        -: 2026:#if JERRY_FUNCTION_TO_STRING
    #####: 2027:  context.function_start_p = NULL;
    #####: 2028:  context.function_end_p = NULL;
        -: 2029:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2030:
        -: 2031:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2032:  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES);
        -: 2033:  context.total_byte_code_size = 0;
        -: 2034:
        -: 2035:  if (context.is_show_opcodes)
        -: 2036:  {
        -: 2037:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n",
        -: 2038:                     (context.arguments_start_p == NULL) ? "Script"
        -: 2039:                                                         : "Function");
        -: 2040:  }
        -: 2041:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2042:
        1: 2043:  scanner_scan_all (&context);
        -: 2044:
        1: 2045:  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))
        -: 2046:  {
    #####: 2047:    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);
        -: 2048:
        -: 2049:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2050:     * situation. However, a simple value can still be thrown. */
    #####: 2051:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2052:    return NULL;
        -: 2053:  }
        -: 2054:
        1: 2055:  size_t script_size = sizeof (cbc_script_t);
        -: 2056:
        1: 2057:  if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2058:  {
    #####: 2059:    script_size += sizeof (ecma_value_t);
        -: 2060:  }
        -: 2061:
        -: 2062:#if JERRY_FUNCTION_TO_STRING
    #####: 2063:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2064:  {
    #####: 2065:    script_size += sizeof (ecma_value_t);
        -: 2066:  }
        -: 2067:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2068:
        -: 2069:#if JERRY_MODULE_SYSTEM
        1: 2070:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2071:  {
    #####: 2072:    script_size += sizeof (ecma_value_t);
        -: 2073:  }
        -: 2074:#endif /* JERRY_MODULE_SYSTEM */
        -: 2075:
        1: 2076:  if (context.arguments_start_p == NULL)
        -: 2077:  {
        1: 2078:    context.source_p = context.source_start_p;
        1: 2079:    context.source_end_p = context.source_start_p + context.source_size;
        -: 2080:  }
        -: 2081:  else
        -: 2082:  {
    #####: 2083:    context.source_p = context.arguments_start_p;
    #####: 2084:    context.source_end_p = context.arguments_start_p + context.arguments_size;
        -: 2085:  }
        -: 2086:
        1: 2087:  context.u.allocated_buffer_p = NULL;
        1: 2088:  context.token.flags = 0;
        1: 2089:  lexer_init_line_info (&context);
        -: 2090:
        1: 2091:  parser_stack_init (&context);
        -: 2092:
        -: 2093:#if JERRY_DEBUGGER
        -: 2094:  context.breakpoint_info_count = 0;
        -: 2095:#endif /* JERRY_DEBUGGER */
        -: 2096:
        1: 2097:  JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_p);
        1: 2098:  JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2099:
        1: 2100:  if (context.next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT)
        -: 2101:  {
    #####: 2102:    context.status_flags |= PARSER_IS_STRICT;
        -: 2103:  }
        -: 2104:
        1: 2105:  PARSER_TRY (context.try_buffer)
        -: 2106:  {
        1: 2107:    context.script_p = parser_malloc (&context, script_size);
        -: 2108:
        1: 2109:    CBC_SCRIPT_SET_TYPE (context.script_p, context.user_value, CBC_SCRIPT_REF_ONE);
        -: 2110:
        -: 2111:#if JERRY_BUILTIN_REALMS
        1: 2112:    context.script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -: 2113:#endif /* JERRY_BUILTIN_REALMS */
        -: 2114:
        -: 2115:#if JERRY_RESOURCE_NAME
        1: 2116:    context.script_p->resource_name = resource_name;
        -: 2117:#endif /* JERRY_RESOURCE_NAME */
        -: 2118:
        1: 2119:    ECMA_SET_INTERNAL_VALUE_POINTER (context.script_value, context.script_p);
        -: 2120:
        -: 2121:    /* Pushing a dummy value ensures the stack is never empty.
        -: 2122:     * This simplifies the stack management routines. */
        1: 2123:    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);
        -: 2124:    /* The next token must always be present to make decisions
        -: 2125:     * in the parser. Therefore when a token is consumed, the
        -: 2126:     * lexer_next_token() must be immediately called. */
        1: 2127:    lexer_next_token (&context);
        -: 2128:
        1: 2129:    if (context.arguments_start_p != NULL)
        -: 2130:    {
    #####: 2131:      parser_parse_function_arguments (&context, LEXER_EOS);
        -: 2132:
    #####: 2133:      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
    #####: 2134:      scanner_release_next (&context, sizeof (scanner_info_t));
        -: 2135:
    #####: 2136:      context.source_p = context.source_start_p;
    #####: 2137:      context.source_end_p = context.source_start_p + context.source_size;
    #####: 2138:      lexer_init_line_info (&context);
        -: 2139:
    #####: 2140:      lexer_next_token (&context);
        -: 2141:    }
        -: 2142:#if JERRY_MODULE_SYSTEM
        1: 2143:    else if (parse_opts & ECMA_PARSE_MODULE)
        -: 2144:    {
    #####: 2145:      parser_branch_t branch;
    #####: 2146:      parser_emit_cbc_forward_branch (&context, CBC_JUMP_FORWARD, &branch);
        -: 2147:
    #####: 2148:      scanner_create_variables (&context, SCANNER_CREATE_VARS_NO_OPTS);
    #####: 2149:      parser_emit_cbc (&context, CBC_RETURN_WITH_BLOCK);
        -: 2150:
    #####: 2151:      parser_set_branch_to_current_position (&context, &branch);
        -: 2152:    }
        -: 2153:#endif /* JERRY_MODULE_SYSTEM */
        -: 2154:    else
        -: 2155:    {
        1: 2156:      JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_start_p
        -: 2157:                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2158:
        -: 2159:#if JERRY_ESNEXT
        1: 2160:      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))
        -: 2161:      {
    #####: 2162:        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2163:      }
        -: 2164:
        1: 2165:      if (!(parse_opts & ECMA_PARSE_EVAL))
        -: 2166:      {
        1: 2167:        scanner_check_variables (&context);
        -: 2168:      }
        -: 2169:#endif /* JERRY_ESNEXT */
        -: 2170:
        1: 2171:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);
        -: 2172:    }
        -: 2173:
        1: 2174:    parser_parse_statements (&context);
        -: 2175:
        1: 2176:    JERRY_ASSERT (context.last_statement.current_p == NULL);
        -: 2177:
        1: 2178:    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        1: 2179:    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);
        -: 2180:
        -: 2181:#ifndef JERRY_NDEBUG
        1: 2182:    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);
        1: 2183:    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));
        1: 2184:    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;
        -: 2185:#endif /* !JERRY_NDEBUG */
        -: 2186:
        1: 2187:    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));
        -: 2188:
        1: 2189:    compiled_code_p = parser_post_processing (&context);
        1: 2190:    parser_list_free (&context.literal_pool);
        -: 2191:
        -: 2192:    /* When parsing is successful, only the dummy value can be remained on the stack. */
        1: 2193:    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE
        -: 2194:                  && context.stack.last_position == 1
        -: 2195:                  && context.stack.first_p != NULL
        -: 2196:                  && context.stack.first_p->next_p == NULL
        -: 2197:                  && context.stack.last_p == NULL);
        -: 2198:
        1: 2199:    JERRY_ASSERT (context.arguments_start_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));
        -: 2200:
        1: 2201:    context.script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -: 2202:
        1: 2203:    if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2204:    {
    #####: 2205:      CBC_SCRIPT_GET_USER_VALUE (context.script_p) = ecma_copy_value_if_not_object (context.user_value);
        -: 2206:    }
        -: 2207:
        -: 2208:#if JERRY_MODULE_SYSTEM
        1: 2209:    if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2210:    {
    #####: 2211:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
    #####: 2212:      ecma_value_t module = ecma_make_object_value ((ecma_object_t *) JERRY_CONTEXT (module_current_p));
        -: 2213:
    #####: 2214:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = module;
    #####: 2215:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_IMPORT_META;
        -: 2216:    }
        -: 2217:#endif /* JERRY_MODULE_SYSTEM */
        -: 2218:
        -: 2219:#if JERRY_FUNCTION_TO_STRING
    #####: 2220:    if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2221:    {
        -: 2222:      ecma_string_t *string_p;
        -: 2223:
    #####: 2224:      if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER)
        -: 2225:      {
    #####: 2226:        string_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (context.source_start_p, context.source_size);
        -: 2227:      }
        -: 2228:      else
        -: 2229:      {
    #####: 2230:        string_p = ecma_new_ecma_string_from_utf8 (context.source_start_p, context.source_size);
        -: 2231:      }
        -: 2232:
    #####: 2233:      context.script_p->source_code = ecma_make_string_value (string_p);
        -: 2234:    }
        -: 2235:    else
        -: 2236:    {
    #####: 2237:      ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2238:
    #####: 2239:      ecma_ref_ecma_string (ecma_get_string_from_value (source));
    #####: 2240:      context.script_p->source_code = source;
        -: 2241:    }
        -: 2242:
    #####: 2243:    if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2244:    {
    #####: 2245:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
        -: 2246:
    #####: 2247:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = context.argument_list;
        -: 2248:
    #####: 2249:      ecma_ref_ecma_string (ecma_get_string_from_value (context.argument_list));
    #####: 2250:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS;
        -: 2251:    }
        -: 2252:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2253:
        -: 2254:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2255:    if (context.is_show_opcodes)
        -: 2256:    {
        -: 2257:      JERRY_DEBUG_MSG ("\n%s parsing successfully completed. Total byte code size: %d bytes\n",
        -: 2258:                       (context.arguments_start_p == NULL) ? "Script"
        -: 2259:                                                           : "Function",
        -: 2260:                       (int) context.total_byte_code_size);
        -: 2261:    }
        -: 2262:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2263:  }
        -: 2264:  PARSER_CATCH
        -: 2265:  {
    #####: 2266:    if (context.last_statement.current_p != NULL)
        -: 2267:    {
    #####: 2268:      parser_free_jumps (context.last_statement);
        -: 2269:    }
        -: 2270:
    #####: 2271:    parser_free_allocated_buffer (&context);
        -: 2272:
    #####: 2273:    scanner_cleanup (&context);
        -: 2274:
        -: 2275:#if JERRY_MODULE_SYSTEM
    #####: 2276:    if (context.module_names_p != NULL)
        -: 2277:    {
    #####: 2278:      ecma_module_release_module_names (context.module_names_p);
        -: 2279:    }
        -: 2280:#endif
        -: 2281:
    #####: 2282:    compiled_code_p = NULL;
    #####: 2283:    parser_free_literals (&context.literal_pool);
    #####: 2284:    parser_cbc_stream_free (&context.byte_code);
        -: 2285:
        -: 2286:#if JERRY_RESOURCE_NAME
    #####: 2287:    ecma_deref_ecma_string (ecma_get_string_from_value (context.script_p->resource_name));
        -: 2288:#endif /* JERRY_RESOURCE_NAME */
        -: 2289:
    #####: 2290:    if (context.script_p != NULL)
        -: 2291:    {
    #####: 2292:      JERRY_ASSERT (context.script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);
    #####: 2293:      jmem_heap_free_block (context.script_p, script_size);
        -: 2294:    }
        -: 2295:  }
        -: 2296:  PARSER_TRY_END
        -: 2297:
        1: 2298:  if (context.scope_stack_p != NULL)
        -: 2299:  {
        1: 2300:    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2301:  }
        -: 2302:
        -: 2303:#if JERRY_LINE_INFO
    #####: 2304:  parser_line_info_free (context.line_info_p);
        -: 2305:#endif /* JERRY_LINE_INFO */
        -: 2306:
        -: 2307:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2308:  if (context.is_show_opcodes)
        -: 2309:  {
        -: 2310:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n",
        -: 2311:                     (context.arguments_start_p == NULL) ? "Script"
        -: 2312:                                                         : "Function");
        -: 2313:  }
        -: 2314:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2315:
        1: 2316:  parser_stack_free (&context);
        -: 2317:
        1: 2318:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_SOURCE)
        -: 2319:  {
    #####: 2320:    jmem_heap_free_block ((void *) context.source_start_p, context.source_size);
        -: 2321:  }
        -: 2322:
        1: 2323:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_ARG_LIST)
        -: 2324:  {
    #####: 2325:    jmem_heap_free_block ((void *) context.arguments_start_p, context.arguments_size);
        -: 2326:  }
        -: 2327:
        1: 2328:  if (compiled_code_p != NULL)
        -: 2329:  {
        1: 2330:    return compiled_code_p;
        -: 2331:  }
        -: 2332:
        -: 2333:#if JERRY_DEBUGGER
        -: 2334:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2335:  {
        -: 2336:    jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);
        -: 2337:  }
        -: 2338:#endif /* JERRY_DEBUGGER */
        -: 2339:
    #####: 2340:  if (context.error == PARSER_ERR_OUT_OF_MEMORY)
        -: 2341:  {
        -: 2342:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2343:     * situation. However, a simple value can still be thrown. */
    #####: 2344:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2345:    return NULL;
        -: 2346:  }
        -: 2347:
        -: 2348:#if JERRY_ERROR_MESSAGES
        -: 2349:  ecma_string_t *err_str_p;
        -: 2350:
    #####: 2351:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2352:  {
    #####: 2353:    ecma_value_t error = jcontext_take_exception ();
    #####: 2354:    ecma_property_t *prop_p = ecma_find_named_property (ecma_get_object_from_value (error),
        -: 2355:                                                        ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE));
    #####: 2356:    ecma_free_value (error);
    #####: 2357:    JERRY_ASSERT (prop_p);
    #####: 2358:    err_str_p = ecma_get_string_from_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 2359:    ecma_ref_ecma_string (err_str_p);
        -: 2360:  }
        -: 2361:  else
        -: 2362:  {
    #####: 2363:    const lit_utf8_byte_t *err_bytes_p = (const lit_utf8_byte_t *) parser_error_to_string (context.error);
    #####: 2364:    lit_utf8_size_t err_bytes_size = lit_zt_utf8_string_size (err_bytes_p);
    #####: 2365:    err_str_p = ecma_new_ecma_string_from_utf8 (err_bytes_p, err_bytes_size);
        -: 2366:  }
    #####: 2367:  ecma_value_t err_str_val = ecma_make_string_value (err_str_p);
    #####: 2368:  ecma_value_t line_str_val = ecma_make_uint32_value (context.token.line);
    #####: 2369:  ecma_value_t col_str_val = ecma_make_uint32_value (context.token.column);
        -: 2370:
    #####: 2371:  ecma_raise_standard_error_with_format (JERRY_ERROR_SYNTAX,
        -: 2372:                                         "% [%:%:%]",
        -: 2373:                                         err_str_val,
        -: 2374:                                         resource_name,
        -: 2375:                                         line_str_val,
        -: 2376:                                         col_str_val);
        -: 2377:
    #####: 2378:  ecma_free_value (col_str_val);
    #####: 2379:  ecma_free_value (line_str_val);
    #####: 2380:  ecma_deref_ecma_string (err_str_p);
        -: 2381:#else /* !JERRY_ERROR_MESSAGES */
        -: 2382:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2383:  {
        -: 2384:    jcontext_release_exception ();
        -: 2385:  }
        -: 2386:
        -: 2387:  ecma_raise_syntax_error ("");
        -: 2388:#endif /* JERRY_ERROR_MESSAGES */
        -: 2389:
    #####: 2390:  return NULL;
        -: 2391:} /* parser_parse_source */
        -: 2392:
        -: 2393:/**
        -: 2394: * Save parser context before function parsing.
        -: 2395: */
        -: 2396:static void
        5: 2397:parser_save_context (parser_context_t *context_p, /**< context */
        -: 2398:                     parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2399:{
        5: 2400:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2401:
        -: 2402:#if JERRY_DEBUGGER
        -: 2403:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2404:      && context_p->breakpoint_info_count > 0)
        -: 2405:  {
        -: 2406:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -: 2407:    context_p->breakpoint_info_count = 0;
        -: 2408:  }
        -: 2409:#endif /* JERRY_DEBUGGER */
        -: 2410:
        -: 2411:#if JERRY_ESNEXT
        5: 2412:  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2413:  {
    #####: 2414:    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2415:  }
        -: 2416:#endif /* JERRY_ESNEXT */
        -: 2417:
        -: 2418:  /* Save private part of the context. */
        -: 2419:
        5: 2420:  saved_context_p->status_flags = context_p->status_flags;
        5: 2421:  saved_context_p->stack_depth = context_p->stack_depth;
        5: 2422:  saved_context_p->stack_limit = context_p->stack_limit;
        5: 2423:  saved_context_p->prev_context_p = context_p->last_context_p;
        5: 2424:  saved_context_p->last_statement = context_p->last_statement;
        -: 2425:
        5: 2426:  saved_context_p->argument_count = context_p->argument_count;
        -: 2427:#if JERRY_ESNEXT
        5: 2428:  saved_context_p->argument_length = context_p->argument_length;
        -: 2429:#endif /* JERRY_ESNEXT */
        5: 2430:  saved_context_p->register_count = context_p->register_count;
        5: 2431:  saved_context_p->literal_count = context_p->literal_count;
        -: 2432:
        5: 2433:  saved_context_p->byte_code = context_p->byte_code;
        5: 2434:  saved_context_p->byte_code_size = context_p->byte_code_size;
        5: 2435:  saved_context_p->literal_pool_data = context_p->literal_pool.data;
        5: 2436:  saved_context_p->scope_stack_p = context_p->scope_stack_p;
        5: 2437:  saved_context_p->scope_stack_size = context_p->scope_stack_size;
        5: 2438:  saved_context_p->scope_stack_top = context_p->scope_stack_top;
        5: 2439:  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2440:#if JERRY_ESNEXT
        5: 2441:  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;
        5: 2442:  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;
        -: 2443:#endif /* JERRY_ESNEXT */
        -: 2444:
        -: 2445:#ifndef JERRY_NDEBUG
        5: 2446:  saved_context_p->context_stack_depth = context_p->context_stack_depth;
        -: 2447:#endif /* !JERRY_NDEBUG */
        -: 2448:
        -: 2449:#if JERRY_LINE_INFO
    #####: 2450:  saved_context_p->line_info_p = context_p->line_info_p;
        -: 2451:#endif /* JERRY_LINE_INFO */
        -: 2452:
        -: 2453:#if JERRY_FUNCTION_TO_STRING
    #####: 2454:  saved_context_p->function_start_p = context_p->function_start_p;
        -: 2455:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2456:
        -: 2457:  /* Reset private part of the context. */
        -: 2458:
        5: 2459:  context_p->status_flags &= PARSER_IS_STRICT;
        5: 2460:  context_p->stack_depth = 0;
        5: 2461:  context_p->stack_limit = 0;
        5: 2462:  context_p->last_context_p = saved_context_p;
        5: 2463:  context_p->last_statement.current_p = NULL;
        -: 2464:
        5: 2465:  context_p->argument_count = 0;
        -: 2466:#if JERRY_ESNEXT
        5: 2467:  context_p->argument_length = UINT16_MAX;
        -: 2468:#endif /* JERRY_ESNEXT */
        5: 2469:  context_p->register_count = 0;
        5: 2470:  context_p->literal_count = 0;
        -: 2471:
        5: 2472:  parser_cbc_stream_init (&context_p->byte_code);
        5: 2473:  context_p->byte_code_size = 0;
        5: 2474:  parser_list_reset (&context_p->literal_pool);
        5: 2475:  context_p->scope_stack_p = NULL;
        5: 2476:  context_p->scope_stack_size = 0;
        5: 2477:  context_p->scope_stack_top = 0;
        5: 2478:  context_p->scope_stack_reg_top = 0;
        -: 2479:#if JERRY_ESNEXT
        5: 2480:  context_p->scope_stack_global_end = 0;
        5: 2481:  context_p->tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2482:#endif /* JERRY_ESNEXT */
        -: 2483:
        -: 2484:#ifndef JERRY_NDEBUG
        5: 2485:  context_p->context_stack_depth = 0;
        -: 2486:#endif /* !JERRY_NDEBUG */
        -: 2487:
        -: 2488:#if JERRY_LINE_INFO
    #####: 2489:  context_p->line_info_p = NULL;
        -: 2490:#endif /* JERRY_LINE_INFO */
        5: 2491:} /* parser_save_context */
        -: 2492:
        -: 2493:/**
        -: 2494: * Restore parser context after function parsing.
        -: 2495: */
        -: 2496:static void
        5: 2497:parser_restore_context (parser_context_t *context_p, /**< context */
        -: 2498:                        parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2499:{
        5: 2500:  parser_list_free (&context_p->literal_pool);
        -: 2501:
        5: 2502:  if (context_p->scope_stack_p != NULL)
        -: 2503:  {
        2: 2504:    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2505:  }
        -: 2506:
        -: 2507:#if JERRY_LINE_INFO
    #####: 2508:  parser_line_info_free (context_p->line_info_p);
        -: 2509:#endif /* JERRY_LINE_INFO */
        -: 2510:
        -: 2511:  /* Restore private part of the context. */
        -: 2512:
        5: 2513:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2514:
        5: 2515:  context_p->status_flags = saved_context_p->status_flags;
        5: 2516:  context_p->stack_depth = saved_context_p->stack_depth;
        5: 2517:  context_p->stack_limit = saved_context_p->stack_limit;
        5: 2518:  context_p->last_context_p = saved_context_p->prev_context_p;
        5: 2519:  context_p->last_statement = saved_context_p->last_statement;
        -: 2520:
        5: 2521:  context_p->argument_count = saved_context_p->argument_count;
        -: 2522:#if JERRY_ESNEXT
        5: 2523:  context_p->argument_length = saved_context_p->argument_length;
        -: 2524:#endif /* JERRY_ESNEXT */
        5: 2525:  context_p->register_count = saved_context_p->register_count;
        5: 2526:  context_p->literal_count = saved_context_p->literal_count;
        -: 2527:
        5: 2528:  context_p->byte_code = saved_context_p->byte_code;
        5: 2529:  context_p->byte_code_size = saved_context_p->byte_code_size;
        5: 2530:  context_p->literal_pool.data = saved_context_p->literal_pool_data;
        5: 2531:  context_p->scope_stack_p = saved_context_p->scope_stack_p;
        5: 2532:  context_p->scope_stack_size = saved_context_p->scope_stack_size;
        5: 2533:  context_p->scope_stack_top = saved_context_p->scope_stack_top;
        5: 2534:  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;
        -: 2535:#if JERRY_ESNEXT
        5: 2536:  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;
        5: 2537:  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;
        -: 2538:#endif /* JERRY_ESNEXT */
        -: 2539:
        -: 2540:#ifndef JERRY_NDEBUG
        5: 2541:  context_p->context_stack_depth = saved_context_p->context_stack_depth;
        -: 2542:#endif /* !JERRY_NDEBUG */
        -: 2543:
        -: 2544:#if JERRY_LINE_INFO
    #####: 2545:  context_p->line_info_p = saved_context_p->line_info_p;
        -: 2546:#endif /* JERRY_LINE_INFO */
        5: 2547:} /* parser_restore_context */
        -: 2548:
        -: 2549:/**
        -: 2550: * Parse function code
        -: 2551: *
        -: 2552: * @return compiled code
        -: 2553: */
        -: 2554:ecma_compiled_code_t *
        4: 2555:parser_parse_function (parser_context_t *context_p, /**< context */
        -: 2556:                       uint32_t status_flags) /**< extra status flags */
        -: 2557:{
        4: 2558:  parser_saved_context_t saved_context;
        -: 2559:  ecma_compiled_code_t *compiled_code_p;
        -: 2560:
        4: 2561:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
        4: 2562:  parser_save_context (context_p, &saved_context);
        4: 2563:  context_p->status_flags |= status_flags;
        -: 2564:#if JERRY_ESNEXT
        4: 2565:  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;
        -: 2566:#endif /* JERRY_ESNEXT */
        -: 2567:
        -: 2568:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2569:  if (context_p->is_show_opcodes)
        -: 2570:  {
        -: 2571:#if JERRY_ESNEXT
        -: 2572:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n",
        -: 2573:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor"
        -: 2574:                                                                          : "Function");
        -: 2575:#else /* !JERRY_ESNEXT */
        -: 2576:    JERRY_DEBUG_MSG ("\n--- Function parsing start ---\n\n");
        -: 2577:#endif /* JERRY_ESNEXT */
        -: 2578:  }
        -: 2579:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2580:
        -: 2581:#if JERRY_DEBUGGER
        -: 2582:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2583:  {
        -: 2584:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2585:  }
        -: 2586:#endif /* JERRY_DEBUGGER */
        -: 2587:
        4: 2588:  lexer_next_token (context_p);
        -: 2589:
        4: 2590:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2591:  {
    #####: 2592:    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -: 2593:  }
        -: 2594:
        4: 2595:  lexer_next_token (context_p);
        -: 2596:
        4: 2597:  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
        4: 2598:  lexer_next_token (context_p);
        -: 2599:
        4: 2600:  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER)
        2: 2601:      && context_p->argument_count != 0)
        -: 2602:  {
    #####: 2603:    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);
        -: 2604:  }
        -: 2605:
        4: 2606:  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER)
        1: 2607:      && context_p->argument_count != 1)
        -: 2608:  {
    #####: 2609:    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);
        -: 2610:  }
        -: 2611:
        -: 2612:#if JERRY_ESNEXT
        4: 2613:  if ((context_p->status_flags & (PARSER_CLASS_CONSTRUCTOR | PARSER_ALLOW_SUPER_CALL)) == PARSER_CLASS_CONSTRUCTOR)
        -: 2614:  {
    #####: 2615:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_FIELD_INIT);
    #####: 2616:    parser_flush_cbc (context_p);
        -: 2617:  }
        -: 2618:#endif /* JERRY_ESNEXT */
        -: 2619:
        -: 2620:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2621:  if (context_p->is_show_opcodes
        -: 2622:      && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))
        -: 2623:  {
        -: 2624:    JERRY_DEBUG_MSG ("  Note: legacy (non-strict) argument definition\n\n");
        -: 2625:  }
        -: 2626:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2627:
        4: 2628:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2629:  {
    #####: 2630:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2631:  }
        -: 2632:
        4: 2633:  lexer_next_token (context_p);
        4: 2634:  parser_parse_statements (context_p);
        4: 2635:  compiled_code_p = parser_post_processing (context_p);
        -: 2636:
        -: 2637:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2638:  if (context_p->is_show_opcodes)
        -: 2639:  {
        -: 2640:#if JERRY_ESNEXT
        -: 2641:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n",
        -: 2642:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor"
        -: 2643:                                                                          : "Function");
        -: 2644:#else /* !JERRY_ESNEXT */
        -: 2645:    JERRY_DEBUG_MSG ("\n--- Function parsing end ---\n\n");
        -: 2646:#endif /* JERRY_ESNEXT */
        -: 2647:  }
        -: 2648:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2649:
        4: 2650:  parser_restore_context (context_p, &saved_context);
        -: 2651:
        4: 2652:  return compiled_code_p;
        -: 2653:} /* parser_parse_function */
        -: 2654:
        -: 2655:#if JERRY_ESNEXT
        -: 2656:
        -: 2657:/**
        -: 2658: * Parse arrow function code
        -: 2659: *
        -: 2660: * @return compiled code
        -: 2661: */
        -: 2662:ecma_compiled_code_t *
        1: 2663:parser_parse_arrow_function (parser_context_t *context_p, /**< context */
        -: 2664:                             uint32_t status_flags) /**< extra status flags */
        -: 2665:{
        1: 2666:  parser_saved_context_t saved_context;
        -: 2667:  ecma_compiled_code_t *compiled_code_p;
        -: 2668:
        1: 2669:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
        1: 2670:  JERRY_ASSERT (status_flags & PARSER_IS_ARROW_FUNCTION);
        1: 2671:  parser_save_context (context_p, &saved_context);
        1: 2672:  context_p->status_flags |= status_flags;
        1: 2673:  context_p->status_flags |= saved_context.status_flags & (PARSER_ALLOW_NEW_TARGET
        -: 2674:                                                           | PARSER_ALLOW_SUPER
        -: 2675:                                                           | PARSER_ALLOW_SUPER_CALL);
        -: 2676:
        -: 2677:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2678:  if (context_p->is_show_opcodes)
        -: 2679:  {
        -: 2680:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing start ---\n\n");
        -: 2681:  }
        -: 2682:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2683:
        -: 2684:#if JERRY_DEBUGGER
        -: 2685:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2686:  {
        -: 2687:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2688:  }
        -: 2689:#endif /* JERRY_DEBUGGER */
        -: 2690:
        1: 2691:  if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2692:  {
        1: 2693:    lexer_next_token (context_p);
        1: 2694:    parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
        1: 2695:    lexer_next_token (context_p);
        -: 2696:  }
        -: 2697:  else
        -: 2698:  {
    #####: 2699:    parser_parse_function_arguments (context_p, LEXER_ARROW);
        -: 2700:  }
        -: 2701:
        1: 2702:  JERRY_ASSERT (context_p->token.type == LEXER_ARROW);
        -: 2703:
        1: 2704:  lexer_next_token (context_p);
        -: 2705:
        1: 2706:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2707:  {
        1: 2708:    lexer_next_token (context_p);
        -: 2709:
        1: 2710:    context_p->status_flags |= PARSER_IS_CLOSURE;
        1: 2711:    parser_parse_statements (context_p);
        -: 2712:
        -: 2713:    /* Unlike normal function, arrow functions consume their close brace. */
        1: 2714:    JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE);
        1: 2715:    lexer_next_token (context_p);
        -: 2716:  }
        -: 2717:  else
        -: 2718:  {
    #####: 2719:    if (context_p->status_flags & PARSER_IS_STRICT
    #####: 2720:        && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2721:    {
    #####: 2722:      parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2723:    }
        -: 2724:
        -: 2725:#if JERRY_LINE_INFO
    #####: 2726:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2727:#endif /* JERRY_LINE_INFO */
        -: 2728:
    #####: 2729:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2730:
    #####: 2731:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2732:    {
    #####: 2733:      context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
        -: 2734:    }
        -: 2735:    else
        -: 2736:    {
    #####: 2737:      parser_emit_cbc (context_p, CBC_RETURN);
        -: 2738:    }
    #####: 2739:    parser_flush_cbc (context_p);
        -: 2740:
    #####: 2741:    lexer_update_await_yield (context_p, saved_context.status_flags);
        -: 2742:  }
        -: 2743:
        1: 2744:  compiled_code_p = parser_post_processing (context_p);
        -: 2745:
        -: 2746:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2747:  if (context_p->is_show_opcodes)
        -: 2748:  {
        -: 2749:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing end ---\n\n");
        -: 2750:  }
        -: 2751:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2752:
        1: 2753:  parser_restore_context (context_p, &saved_context);
        -: 2754:
        1: 2755:  return compiled_code_p;
        -: 2756:} /* parser_parse_arrow_function */
        -: 2757:
        -: 2758:/**
        -: 2759: * Parse class fields
        -: 2760: *
        -: 2761: * @return compiled code
        -: 2762: */
        -: 2763:ecma_compiled_code_t *
    #####: 2764:parser_parse_class_fields (parser_context_t *context_p) /**< context */
        -: 2765:{
    #####: 2766:  parser_saved_context_t saved_context;
        -: 2767:  ecma_compiled_code_t *compiled_code_p;
        -: 2768:
    #####: 2769:  uint32_t extra_status_flags = context_p->status_flags & PARSER_INSIDE_WITH;
        -: 2770:
    #####: 2771:  parser_save_context (context_p, &saved_context);
    #####: 2772:  context_p->status_flags |= (PARSER_IS_FUNCTION
        -: 2773:                              | PARSER_ALLOW_SUPER
        -: 2774:                              | PARSER_INSIDE_CLASS_FIELD
        -: 2775:                              | PARSER_ALLOW_NEW_TARGET
        -: 2776:                              | extra_status_flags);
        -: 2777:
        -: 2778:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2779:  if (context_p->is_show_opcodes)
        -: 2780:  {
        -: 2781:    JERRY_DEBUG_MSG ("\n--- Class fields parsing start ---\n\n");
        -: 2782:  }
        -: 2783:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2784:
        -: 2785:#if JERRY_DEBUGGER
        -: 2786:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2787:  {
        -: 2788:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2789:  }
        -: 2790:#endif /* JERRY_DEBUGGER */
        -: 2791:
    #####: 2792:  const uint8_t *source_end_p = context_p->source_end_p;
    #####: 2793:  bool first_computed_class_field = true;
    #####: 2794:  scanner_location_t end_location;
    #####: 2795:  scanner_get_location (&end_location, context_p);
        -: 2796:
        -: 2797:  do
        -: 2798:  {
    #####: 2799:    uint8_t class_field_type = context_p->stack_top_uint8;
    #####: 2800:    parser_stack_pop_uint8 (context_p);
        -: 2801:
    #####: 2802:    scanner_range_t range = {0};
        -: 2803:
    #####: 2804:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2805:    {
    #####: 2806:      parser_stack_pop (context_p, &range, sizeof (scanner_range_t));
        -: 2807:    }
    #####: 2808:    else if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 2809:    {
    #####: 2810:      parser_stack_pop (context_p, &range.start_location, sizeof (scanner_location_t));
        -: 2811:    }
        -: 2812:
    #####: 2813:    uint16_t literal_index = 0;
        -: 2814:
    #####: 2815:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 2816:    {
    #####: 2817:      scanner_set_location (context_p, &range.start_location);
    #####: 2818:      context_p->source_end_p = source_end_p;
    #####: 2819:      scanner_seek (context_p);
        -: 2820:
    #####: 2821:      lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 2822:
    #####: 2823:      literal_index = context_p->lit_object.index;
        -: 2824:
    #####: 2825:      if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2826:      {
    #####: 2827:        lexer_next_token (context_p);
    #####: 2828:        JERRY_ASSERT (context_p->token.type == LEXER_ASSIGN);
        -: 2829:      }
        -: 2830:    }
    #####: 2831:    else if (first_computed_class_field)
        -: 2832:    {
    #####: 2833:      parser_emit_cbc (context_p, CBC_PUSH_NUMBER_0);
    #####: 2834:      first_computed_class_field = false;
        -: 2835:    }
        -: 2836:
    #####: 2837:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2838:    {
    #####: 2839:      if (!(class_field_type & PARSER_CLASS_FIELD_NORMAL))
        -: 2840:      {
    #####: 2841:        scanner_set_location (context_p, &range.start_location);
    #####: 2842:        scanner_seek (context_p);
        -: 2843:      }
        -: 2844:
    #####: 2845:      context_p->source_end_p = range.source_end_p;
    #####: 2846:      lexer_next_token (context_p);
        -: 2847:
        -: 2848:#if JERRY_LINE_INFO
    #####: 2849:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2850:#endif /* JERRY_LINE_INFO */
        -: 2851:
    #####: 2852:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2853:
    #####: 2854:      if (context_p->token.type != LEXER_EOS)
        -: 2855:      {
    #####: 2856:        parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 2857:      }
        -: 2858:    }
        -: 2859:    else
        -: 2860:    {
    #####: 2861:      parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 2862:    }
        -: 2863:
    #####: 2864:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 2865:    {
    #####: 2866:      parser_emit_cbc_literal (context_p, CBC_ASSIGN_PROP_THIS_LITERAL, literal_index);
        -: 2867:
        -: 2868:      /* Prepare stack slot for assignment property reference base. Needed by vm.c */
    #####: 2869:      if (context_p->stack_limit == context_p->stack_depth)
        -: 2870:      {
    #####: 2871:        context_p->stack_limit++;
    #####: 2872:        JERRY_ASSERT (context_p->stack_limit <= PARSER_MAXIMUM_STACK_LIMIT);
        -: 2873:      }
        -: 2874:    }
        -: 2875:    else
        -: 2876:    {
    #####: 2877:      parser_flush_cbc (context_p);
        -: 2878:
        -: 2879:      /* The next opcode pushes two more temporary values onto the stack */
    #####: 2880:      if (context_p->stack_depth + 1 > context_p->stack_limit)
        -: 2881:      {
    #####: 2882:        context_p->stack_limit = (uint16_t) (context_p->stack_depth + 1);
    #####: 2883:        if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 2884:        {
    #####: 2885:          parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 2886:        }
        -: 2887:      }
        -: 2888:
    #####: 2889:      parser_emit_cbc_ext (context_p, CBC_EXT_SET_NEXT_COMPUTED_FIELD);
        -: 2890:    }
        -: 2891:  }
    #####: 2892:  while (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -: 2893:
    #####: 2894:  if (!first_computed_class_field)
        -: 2895:  {
    #####: 2896:    parser_emit_cbc (context_p, CBC_POP);
        -: 2897:  }
        -: 2898:
    #####: 2899:  parser_flush_cbc (context_p);
    #####: 2900:  context_p->source_end_p = source_end_p;
    #####: 2901:  scanner_set_location (context_p, &end_location);
        -: 2902:
        -: 2903:#if JERRY_LINE_INFO
    #####: 2904:  if (context_p->line_info_p == NULL)
        -: 2905:  {
    #####: 2906:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2907:  }
        -: 2908:#endif /* JERRY_LINE_INFO */
        -: 2909:
    #####: 2910:  compiled_code_p = parser_post_processing (context_p);
        -: 2911:
        -: 2912:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2913:  if (context_p->is_show_opcodes)
        -: 2914:  {
        -: 2915:    JERRY_DEBUG_MSG ("\n--- Class fields parsing end ---\n\n");
        -: 2916:  }
        -: 2917:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2918:
    #####: 2919:  parser_restore_context (context_p, &saved_context);
        -: 2920:
    #####: 2921:  return compiled_code_p;
        -: 2922:} /* parser_parse_class_fields */
        -: 2923:
        -: 2924:/**
        -: 2925: * Check whether the last emitted cbc opcode was an anonymous function declaration
        -: 2926: *
        -: 2927: * @return PARSER_NOT_FUNCTION_LITERAL - if the last opcode is not a function literal
        -: 2928: *         PARSER_NAMED_FUNCTION - if the last opcode is not a named function declataion
        -: 2929: *         PARSER_ANONYMOUS_CLASS - if the last opcode is an anonymous class declaration
        -: 2930: *         literal index of the anonymous function literal - otherwise
        -: 2931: */
        -: 2932:uint16_t
        3: 2933:parser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */
        -: 2934:{
        3: 2935:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 2936:  {
    #####: 2937:    return PARSER_ANONYMOUS_CLASS;
        -: 2938:  }
        -: 2939:
        3: 2940:  if (context_p->last_cbc.literal_type != LEXER_FUNCTION_LITERAL)
        -: 2941:  {
        3: 2942:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 2943:  }
        -: 2944:
    #####: 2945:  uint16_t literal_index = PARSER_NOT_FUNCTION_LITERAL;
        -: 2946:
    #####: 2947:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2948:  {
    #####: 2949:    literal_index = context_p->last_cbc.literal_index;
        -: 2950:  }
    #####: 2951:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2952:  {
    #####: 2953:    literal_index = context_p->last_cbc.value;
        -: 2954:  }
    #####: 2955:  else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -: 2956:  {
    #####: 2957:    literal_index = context_p->last_cbc.third_literal_index;
        -: 2958:  }
        -: 2959:  else
        -: 2960:  {
    #####: 2961:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 2962:  }
        -: 2963:
        -: 2964:  const ecma_compiled_code_t *bytecode_p;
    #####: 2965:  bytecode_p = (const ecma_compiled_code_t *) (PARSER_GET_LITERAL (literal_index)->u.bytecode_p);
    #####: 2966:  bool is_anon = ecma_is_value_magic_string (*ecma_compiled_code_resolve_function_name (bytecode_p),
        -: 2967:                                             LIT_MAGIC_STRING__EMPTY);
        -: 2968:
    #####: 2969:  return (is_anon ? literal_index : PARSER_NAMED_FUNCTION);
        -: 2970:} /* parser_check_anonymous_function_declaration */
        -: 2971:
        -: 2972:/**
        -: 2973: * Set the function name of the function literal corresponds to the given function literal index
        -: 2974: * to the given character buffer of literal corresponds to the given name index.
        -: 2975: */
        -: 2976:void
        4: 2977:parser_set_function_name (parser_context_t *context_p, /**< context */
        -: 2978:                          uint16_t function_literal_index, /**< function literal index */
        -: 2979:                          uint16_t name_index, /**< function name literal index */
        -: 2980:                          uint32_t status_flags) /**< status flags */
        -: 2981:{
        -: 2982:  ecma_compiled_code_t *bytecode_p;
        4: 2983:  bytecode_p = (ecma_compiled_code_t *) (PARSER_GET_LITERAL (function_literal_index)->u.bytecode_p);
        -: 2984:
        4: 2985:  parser_compiled_code_set_function_name (context_p, bytecode_p, name_index, status_flags);
        4: 2986:} /* parser_set_function_name */
        -: 2987:
        -: 2988:/**
        -: 2989: * Set the function name of the given compiled code
        -: 2990: * to the given character buffer of literal corresponds to the given name index.
        -: 2991: */
        -: 2992:void
        5: 2993:parser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */
        -: 2994:                                        ecma_compiled_code_t *bytecode_p, /**< function literal index */
        -: 2995:                                        uint16_t name_index, /**< function name literal index */
        -: 2996:                                        uint32_t status_flags) /**< status flags */
        -: 2997:{
        -: 2998:  ecma_value_t *func_name_start_p;
        5: 2999:  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);
        -: 3000:
        5: 3001:  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))
        -: 3002:  {
    #####: 3003:    return;
        -: 3004:  }
        -: 3005:
        5: 3006:  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;
        5: 3007:  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;
        -: 3008:
       27: 3009:  while (scope_stack_p > scope_stack_start_p)
        -: 3010:  {
       18: 3011:    scope_stack_p--;
        -: 3012:
       18: 3013:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC
       17: 3014:        && scanner_decode_map_to (scope_stack_p) == name_index)
        -: 3015:    {
        1: 3016:      name_index = scope_stack_p->map_from;
        1: 3017:      break;
        -: 3018:    }
        -: 3019:  }
        -: 3020:
        5: 3021:  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);
        -: 3022:
        5: 3023:  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)
        -: 3024:  {
    #####: 3025:    return;
        -: 3026:  }
        -: 3027:
        5: 3028:  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;
        5: 3029:  uint32_t name_length = name_lit_p->prop.length;
        -: 3030:
        5: 3031:  if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 3032:  {
        3: 3033:    name_length += 4;
        3: 3034:    name_buffer_p = (uint8_t *) parser_malloc (context_p, name_length * sizeof (uint8_t));
        3: 3035:    char *prefix_p = (status_flags & PARSER_IS_PROPERTY_GETTER) ? "get " : "set ";
        3: 3036:    memcpy (name_buffer_p, prefix_p, 4);
        3: 3037:    memcpy (name_buffer_p + 4, name_lit_p->u.char_p, name_lit_p->prop.length);
        -: 3038:  }
        -: 3039:
        5: 3040:  *func_name_start_p = ecma_find_or_create_literal_string (name_buffer_p,
        -: 3041:                                                           name_length,
        5: 3042:                                                           (status_flags & LEXER_FLAG_ASCII) != 0);
        -: 3043:
        5: 3044:  if (name_buffer_p != name_lit_p->u.char_p)
        -: 3045:  {
        3: 3046:    parser_free (name_buffer_p, name_length);
        -: 3047:  }
        -: 3048:} /* parser_compiled_code_set_function_name */
        -: 3049:
        -: 3050:#endif /* JERRY_ESNEXT */
        -: 3051:
        -: 3052:/**
        -: 3053: * Raise a parse error.
        -: 3054: */
        -: 3055:void
    #####: 3056:parser_raise_error (parser_context_t *context_p, /**< context */
        -: 3057:                    parser_error_t error) /**< error code */
        -: 3058:{
        -: 3059:  /* Must be compatible with the scanner because
        -: 3060:   * the lexer might throws errors during prescanning. */
    #####: 3061:  parser_saved_context_t *saved_context_p = context_p->last_context_p;
        -: 3062:
    #####: 3063:  while (saved_context_p != NULL)
        -: 3064:  {
    #####: 3065:    parser_cbc_stream_free (&saved_context_p->byte_code);
        -: 3066:
        -: 3067:    /* First the current literal pool is freed, and then it is replaced
        -: 3068:     * by the literal pool coming from the saved context. Since literals
        -: 3069:     * are not used anymore, this is a valid replacement. The last pool
        -: 3070:     * is freed by parser_parse_source. */
        -: 3071:
    #####: 3072:    parser_free_literals (&context_p->literal_pool);
    #####: 3073:    context_p->literal_pool.data = saved_context_p->literal_pool_data;
        -: 3074:
    #####: 3075:    if (context_p->scope_stack_p != NULL)
        -: 3076:    {
    #####: 3077:      parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 3078:    }
    #####: 3079:    context_p->scope_stack_p = saved_context_p->scope_stack_p;
    #####: 3080:    context_p->scope_stack_size = saved_context_p->scope_stack_size;
        -: 3081:
    #####: 3082:    if (saved_context_p->last_statement.current_p != NULL)
        -: 3083:    {
    #####: 3084:      parser_free_jumps (saved_context_p->last_statement);
        -: 3085:    }
        -: 3086:
        -: 3087:#if JERRY_ESNEXT
    #####: 3088:    if (saved_context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3089:    {
    #####: 3090:      ecma_collection_t *collection = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 3091:                                                                       saved_context_p->tagged_template_literal_cp);
    #####: 3092:      ecma_collection_free_template_literal (collection);
        -: 3093:    }
        -: 3094:#endif /* JERRY_ESNEXT  */
        -: 3095:
        -: 3096:#if JERRY_LINE_INFO
    #####: 3097:    parser_line_info_free (saved_context_p->line_info_p);
        -: 3098:#endif /* JERRY_LINE_INFO */
        -: 3099:
    #####: 3100:    saved_context_p = saved_context_p->prev_context_p;
        -: 3101:  }
        -: 3102:
        -: 3103:#if JERRY_ESNEXT
    #####: 3104:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3105:  {
    #####: 3106:    ecma_collection_t *collection = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 3107:                                                                     context_p->tagged_template_literal_cp);
    #####: 3108:    ecma_collection_free_template_literal (collection);
        -: 3109:  }
        -: 3110:#endif /* JERRY_ESNEXT  */
        -: 3111:
    #####: 3112:  context_p->error = error;
    #####: 3113:  PARSER_THROW (context_p->try_buffer);
        -: 3114:  /* Should never been reached. */
        -: 3115:  JERRY_ASSERT (0);
        -: 3116:} /* parser_raise_error */
        -: 3117:
        -: 3118:#endif /* JERRY_PARSER */
        -: 3119:
        -: 3120:/**
        -: 3121: * Parse EcmaScript source code
        -: 3122: *
        -: 3123: * Note:
        -: 3124: *      if arg_list_p is not NULL, a function body is parsed
        -: 3125: *      returned value must be freed with ecma_free_value
        -: 3126: *
        -: 3127: * @return pointer to compiled byte code - if success
        -: 3128: *         NULL - otherwise
        -: 3129: */
        -: 3130:ecma_compiled_code_t *
        1: 3131:parser_parse_script (void *source_p, /**< source code */
        -: 3132:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 3133:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 3134:{
        -: 3135:#if JERRY_PARSER
        1: 3136:  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p,
        -: 3137:                                                          parse_opts,
        -: 3138:                                                          options_p);
        -: 3139:
        1: 3140:  if (JERRY_UNLIKELY (bytecode_p == NULL))
        -: 3141:  {
        -: 3142:    /* Exception has already thrown. */
    #####: 3143:    return NULL;
        -: 3144:  }
        -: 3145:
        -: 3146:#if JERRY_DEBUGGER
        -: 3147:  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3148:      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3149:  {
        -: 3150:    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);
        -: 3151:    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);
        -: 3152:
        -: 3153:    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)
        -: 3154:    {
        -: 3155:      jerry_debugger_receive (NULL);
        -: 3156:
        -: 3157:      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))
        -: 3158:      {
        -: 3159:        break;
        -: 3160:      }
        -: 3161:
        -: 3162:      jerry_debugger_transport_sleep ();
        -: 3163:    }
        -: 3164:  }
        -: 3165:#endif /* JERRY_DEBUGGER */
        -: 3166:
        1: 3167:  return bytecode_p;
        -: 3168:#else /* !JERRY_PARSER */
        -: 3169:  JERRY_UNUSED (arg_list_p);
        -: 3170:  JERRY_UNUSED (arg_list_size);
        -: 3171:  JERRY_UNUSED (source_p);
        -: 3172:  JERRY_UNUSED (source_size);
        -: 3173:  JERRY_UNUSED (parse_opts);
        -: 3174:  JERRY_UNUSED (resource_name);
        -: 3175:
        -: 3176:  ecma_raise_syntax_error (ECMA_ERR_MSG ("Source code parsing is disabled"));
        -: 3177:  return NULL;
        -: 3178:#endif /* JERRY_PARSER */
        -: 3179:} /* parser_parse_script */
        -: 3180:
        -: 3181:/**
        -: 3182: * @}
        -: 3183: * @}
        -: 3184: * @}
        -: 3185: */
