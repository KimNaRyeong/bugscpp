        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-math.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-number-arithmetic.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "jrt.h"
        -:   29:#include "jrt-libc-includes.h"
        -:   30:
        -:   31:#if defined (_WIN32)
        -:   32:#include <intrin.h>
        -:   33:#endif
        -:   34:
        -:   35:#if JERRY_BUILTIN_MATH
        -:   36:
        -:   37:#define ECMA_BUILTINS_INTERNAL
        -:   38:#include "ecma-builtins-internal.h"
        -:   39:
        -:   40:/**
        -:   41: * This object has a custom dispatch function.
        -:   42: */
        -:   43:#define BUILTIN_CUSTOM_DISPATCH
        -:   44:
        -:   45:/**
        -:   46: * List of built-in routine identifiers.
        -:   47: */
        -:   48:enum
        -:   49:{
        -:   50:  ECMA_MATH_OBJECT_ROUTINE_START = 0,
        -:   51:
        -:   52:  ECMA_MATH_OBJECT_ABS, /* ECMA-262 v5, 15.8.2.1 */
        -:   53:  ECMA_MATH_OBJECT_ACOS, /* ECMA-262 v5, 15.8.2.2 */
        -:   54:  ECMA_MATH_OBJECT_ASIN, /* ECMA-262 v5, 15.8.2.3 */
        -:   55:  ECMA_MATH_OBJECT_ATAN, /* ECMA-262 v5, 15.8.2.4 */
        -:   56:  ECMA_MATH_OBJECT_CEIL, /* ECMA-262 v5, 15.8.2.6 */
        -:   57:  ECMA_MATH_OBJECT_COS, /* ECMA-262 v5, 15.8.2.7 */
        -:   58:  ECMA_MATH_OBJECT_EXP, /* ECMA-262 v5, 15.8.2.8 */
        -:   59:  ECMA_MATH_OBJECT_FLOOR, /* ECMA-262 v5, 15.8.2.9 */
        -:   60:  ECMA_MATH_OBJECT_LOG, /* ECMA-262 v5, 15.8.2.10 */
        -:   61:  ECMA_MATH_OBJECT_ROUND, /* ECMA-262 v5, 15.8.2.15 */
        -:   62:  ECMA_MATH_OBJECT_SIN, /* ECMA-262 v5, 15.8.2.16 */
        -:   63:  ECMA_MATH_OBJECT_SQRT, /* ECMA-262 v5, 15.8.2.17 */
        -:   64:  ECMA_MATH_OBJECT_TAN, /* ECMA-262 v5, 15.8.2.18 */
        -:   65:#if JERRY_ESNEXT
        -:   66:  ECMA_MATH_OBJECT_ACOSH, /* ECMA-262 v6, 20.2.2.3  */
        -:   67:  ECMA_MATH_OBJECT_ASINH, /* ECMA-262 v6, 20.2.2.5  */
        -:   68:  ECMA_MATH_OBJECT_ATANH, /* ECMA-262 v6, 20.2.2.7  */
        -:   69:  ECMA_MATH_OBJECT_CBRT, /* ECMA-262 v6, 20.2.2.9  */
        -:   70:  ECMA_MATH_OBJECT_CLZ32, /* ECMA-262 v6, 20.2.2.11  */
        -:   71:  ECMA_MATH_OBJECT_COSH, /* ECMA-262 v6, 20.2.2.13  */
        -:   72:  ECMA_MATH_OBJECT_EXPM1, /* ECMA-262 v6, 20.2.2.15  */
        -:   73:  ECMA_MATH_OBJECT_FROUND, /* ECMA-262 v6, 20.2.2.17  */
        -:   74:  ECMA_MATH_OBJECT_LOG1P, /* ECMA-262 v6, 20.2.2.21  */
        -:   75:  ECMA_MATH_OBJECT_LOG10, /* ECMA-262 v6, 20.2.2.22  */
        -:   76:  ECMA_MATH_OBJECT_LOG2, /* ECMA-262 v6, 20.2.2.23  */
        -:   77:  ECMA_MATH_OBJECT_SIGN, /* ECMA-262 v6, 20.2.2.29 */
        -:   78:  ECMA_MATH_OBJECT_SINH, /* ECMA-262 v6, 20.2.2.31  */
        -:   79:  ECMA_MATH_OBJECT_TANH, /* ECMA-262 v6, 20.2.2.34  */
        -:   80:  ECMA_MATH_OBJECT_TRUNC, /* ECMA-262 v6, 20.2.2.35  */
        -:   81:#endif /* JERRY_ESNEXT */
        -:   82:  ECMA_MATH_OBJECT_ATAN2, /* ECMA-262 v5, 15.8.2.5 */ /* first routine with 2 arguments */
        -:   83:#if JERRY_ESNEXT
        -:   84:  ECMA_MATH_OBJECT_IMUL, /* ECMA-262 v6, 20.2.2.19  */
        -:   85:#endif /* JERRY_ESNEXT */
        -:   86:  ECMA_MATH_OBJECT_POW, /* ECMA-262 v5, 15.8.2.13 */ /* last routine with 1 or 2 arguments*/
        -:   87:  ECMA_MATH_OBJECT_MAX, /* ECMA-262 v5, 15.8.2.11 */
        -:   88:  ECMA_MATH_OBJECT_MIN, /* ECMA-262 v5, 15.8.2.12 */
        -:   89:#if JERRY_ESNEXT
        -:   90:  ECMA_MATH_OBJECT_HYPOT, /* ECMA-262 v6, 20.2.2.18  */
        -:   91:#endif /* JERRY_ESNEXT */
        -:   92:  ECMA_MATH_OBJECT_RANDOM, /* ECMA-262 v5, 15.8.2.14 */
        -:   93:};
        -:   94:
        -:   95:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-math.inc.h"
        -:   96:#define BUILTIN_UNDERSCORED_ID math
        -:   97:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   98:
        -:   99:/** \addtogroup ecma ECMA
        -:  100: * @{
        -:  101: *
        -:  102: * \addtogroup ecmabuiltins
        -:  103: * @{
        -:  104: *
        -:  105: * \addtogroup object ECMA Object object built-in
        -:  106: * @{
        -:  107: */
        -:  108:
        -:  109:/**
        -:  110: * The Math object's 'max' 'min' routines.
        -:  111: *
        -:  112: * See also:
        -:  113: *          ECMA-262 v5, 15.8.2.11
        -:  114: *          ECMA-262 v5, 15.8.2.12
        -:  115: *
        -:  116: * @return ecma value
        -:  117: *         Returned value must be freed with ecma_free_value.
        -:  118: */
        -:  119:static ecma_value_t
    #####:  120:ecma_builtin_math_object_max_min (bool is_max, /**< 'max' or 'min' operation */
        -:  121:                                  const ecma_value_t *arg, /**< arguments list */
        -:  122:                                  uint32_t args_number) /**< number of arguments */
        -:  123:{
    #####:  124:  ecma_number_t result_num = ecma_number_make_infinity (is_max);
    #####:  125:  bool nan_found = false;
        -:  126:
    #####:  127:  while (args_number > 0)
        -:  128:  {
    #####:  129:    ecma_number_t arg_num;
        -:  130:
    #####:  131:    if (ecma_is_value_number (*arg))
        -:  132:    {
    #####:  133:      arg_num = ecma_get_number_from_value (*arg);
        -:  134:    }
        -:  135:    else
        -:  136:    {
    #####:  137:      ecma_value_t value = ecma_op_to_number (*arg, &arg_num);
        -:  138:
    #####:  139:      if (ECMA_IS_VALUE_ERROR (value))
        -:  140:      {
    #####:  141:        return value;
        -:  142:      }
        -:  143:    }
        -:  144:
    #####:  145:    arg++;
    #####:  146:    args_number--;
        -:  147:
    #####:  148:    if (JERRY_UNLIKELY (nan_found || ecma_number_is_nan (arg_num)))
        -:  149:    {
    #####:  150:      nan_found = true;
    #####:  151:      continue;
        -:  152:    }
        -:  153:
    #####:  154:    if (ecma_number_is_zero (arg_num)
    #####:  155:        && ecma_number_is_zero (result_num))
    #####:  156:    {
    #####:  157:      bool is_negative = ecma_number_is_negative (arg_num);
        -:  158:
    #####:  159:      if (is_max ? !is_negative : is_negative)
        -:  160:      {
    #####:  161:        result_num = arg_num;
        -:  162:      }
        -:  163:    }
        -:  164:    else
        -:  165:    {
    #####:  166:      if (is_max ? (arg_num > result_num) : (arg_num < result_num))
        -:  167:      {
    #####:  168:        result_num = arg_num;
        -:  169:      }
        -:  170:    }
        -:  171:  }
        -:  172:
    #####:  173:  if (JERRY_UNLIKELY (nan_found))
        -:  174:  {
    #####:  175:    result_num = ecma_number_make_nan ();
        -:  176:  }
        -:  177:
    #####:  178:  return ecma_make_number_value (result_num);
        -:  179:} /* ecma_builtin_math_object_max_min */
        -:  180:
        -:  181:#if JERRY_ESNEXT
        -:  182:/**
        -:  183: * The Math object's 'hypot' routine
        -:  184: *
        -:  185: * See also:
        -:  186: *          ECMA-262 v6, 20.2.2.18
        -:  187: *
        -:  188: * @return ecma value
        -:  189: *         Returned value must be freed with ecma_free_value.
        -:  190: */
        -:  191:static ecma_value_t
    #####:  192:ecma_builtin_math_object_hypot (const ecma_value_t *arg, /**< arguments list */
        -:  193:                                uint32_t args_number) /**< number of arguments */
        -:  194:{
    #####:  195:  if (args_number == 0)
        -:  196:  {
    #####:  197:    return ecma_make_number_value (0.0);
        -:  198:  }
        -:  199:
    #####:  200:  bool nan_found = false;
    #####:  201:  bool inf_found = false;
    #####:  202:  ecma_number_t result_num = 0;
        -:  203:
    #####:  204:  while (args_number > 0)
        -:  205:  {
    #####:  206:    ecma_number_t arg_num;
    #####:  207:    if (ecma_is_value_number (*arg))
        -:  208:    {
    #####:  209:      arg_num = ecma_get_number_from_value (*arg);
        -:  210:    }
        -:  211:    else
        -:  212:    {
    #####:  213:      ecma_value_t value = ecma_op_to_number (*arg, &arg_num);
    #####:  214:      if (ECMA_IS_VALUE_ERROR (value))
        -:  215:      {
    #####:  216:        return value;
        -:  217:      }
        -:  218:    }
        -:  219:
    #####:  220:    arg++;
    #####:  221:    args_number--;
        -:  222:
    #####:  223:    if (JERRY_UNLIKELY (inf_found || ecma_number_is_infinity (arg_num)))
        -:  224:    {
    #####:  225:      inf_found = true;
    #####:  226:      continue;
        -:  227:    }
        -:  228:
    #####:  229:    if (JERRY_UNLIKELY (nan_found || ecma_number_is_nan (arg_num)))
        -:  230:    {
    #####:  231:      nan_found = true;
    #####:  232:      continue;
        -:  233:    }
        -:  234:
    #####:  235:    result_num += arg_num * arg_num;
        -:  236:  }
        -:  237:
    #####:  238:  if (JERRY_UNLIKELY (inf_found))
        -:  239:  {
    #####:  240:    return ecma_make_number_value (ecma_number_make_infinity (false));
        -:  241:  }
        -:  242:
    #####:  243:  if (JERRY_UNLIKELY (nan_found))
        -:  244:  {
    #####:  245:    return ecma_make_nan_value ();
        -:  246:  }
        -:  247:
    #####:  248:  return ecma_make_number_value (sqrt (result_num));
        -:  249:} /* ecma_builtin_math_object_hypot */
        -:  250:
        -:  251:/**
        -:  252: * The Math object's 'trunc' routine
        -:  253: *
        -:  254: * See also:
        -:  255: *          ECMA-262 v6, 20.2.2.35
        -:  256: *
        -:  257: * @return ecma number
        -:  258: */
        -:  259:static ecma_number_t
    #####:  260:ecma_builtin_math_object_trunc (ecma_number_t arg)
        -:  261:{
    #####:  262:  if (ecma_number_is_nan (arg) || ecma_number_is_infinity (arg) || ecma_number_is_zero (arg))
        -:  263:  {
    #####:  264:    return arg;
        -:  265:  }
        -:  266:
    #####:  267:  if ((arg > 0) && (arg < 1))
        -:  268:  {
    #####:  269:    return (ecma_number_t) 0.0;
        -:  270:  }
        -:  271:
    #####:  272:  if ((arg < 0) && (arg > -1))
        -:  273:  {
    #####:  274:    return (ecma_number_t) -0.0;
        -:  275:  }
        -:  276:
    #####:  277:  return (ecma_number_t) arg - fmod (arg, 1);
        -:  278:} /* ecma_builtin_math_object_trunc */
        -:  279:
        -:  280:/**
        -:  281: * The Math object's 'sign' routine
        -:  282: *
        -:  283: * See also:
        -:  284: *          ECMA-262 v6, 20.2.2.29
        -:  285: *
        -:  286: * @return ecma number
        -:  287: */
        -:  288:static ecma_number_t
    #####:  289:ecma_builtin_math_object_sign (ecma_number_t arg)
        -:  290:{
    #####:  291:  if (ecma_number_is_nan (arg) || ecma_number_is_zero (arg))
        -:  292:  {
    #####:  293:    return arg;
        -:  294:  }
        -:  295:
    #####:  296:  if (ecma_number_is_negative (arg))
        -:  297:  {
    #####:  298:    return (ecma_number_t) -1.0;
        -:  299:  }
        -:  300:
    #####:  301:  return (ecma_number_t) 1.0;
        -:  302:} /* ecma_builtin_math_object_sign */
        -:  303:
        -:  304:#endif /* JERRY_ESNEXT */
        -:  305:
        -:  306:/**
        -:  307: * The Math object's 'random' routine.
        -:  308: *
        -:  309: * See also:
        -:  310: *          ECMA-262 v5, 15.8.2.14
        -:  311: *
        -:  312: * @return ecma value
        -:  313: *         Returned value must be freed with ecma_free_value.
        -:  314: */
        -:  315:static ecma_value_t
    #####:  316:ecma_builtin_math_object_random (void)
        -:  317:{
    #####:  318:  const ecma_number_t rand_max = (ecma_number_t) RAND_MAX;
    #####:  319:  const ecma_number_t rand_max_min_1 = (ecma_number_t) (RAND_MAX - 1);
        -:  320:
    #####:  321:  return ecma_make_number_value (((ecma_number_t) rand ()) / rand_max * rand_max_min_1 / rand_max);
        -:  322:} /* ecma_builtin_math_object_random */
        -:  323:
        -:  324:/**
        -:  325: * Dispatcher for the built-in's routines.
        -:  326: *
        -:  327: * @return ecma value
        -:  328: *         Returned value must be freed with ecma_free_value.
        -:  329: */
        -:  330:ecma_value_t
    #####:  331:ecma_builtin_math_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  332:                                    ecma_value_t this_arg, /**< 'this' argument value */
        -:  333:                                    const ecma_value_t arguments_list[], /**< list of arguments
        -:  334:                                                                          *   passed to routine */
        -:  335:                                    uint32_t arguments_number) /**< length of arguments' list */
        -:  336:{
        -:  337:  JERRY_UNUSED (this_arg);
        -:  338:
    #####:  339:  if (builtin_routine_id <= ECMA_MATH_OBJECT_POW)
        -:  340:  {
    #####:  341:    ecma_number_t x = ecma_number_make_nan ();
    #####:  342:    ecma_number_t y = ecma_number_make_nan ();
        -:  343:
    #####:  344:    if (arguments_number >= 1)
        -:  345:    {
    #####:  346:      if (ecma_is_value_number (arguments_list[0]))
        -:  347:      {
    #####:  348:        x = ecma_get_number_from_value (arguments_list[0]);
        -:  349:      }
        -:  350:      else
        -:  351:      {
    #####:  352:        ecma_value_t value = ecma_op_to_number (arguments_list[0], &x);
        -:  353:
    #####:  354:        if (ECMA_IS_VALUE_ERROR (value))
        -:  355:        {
    #####:  356:          return value;
        -:  357:        }
        -:  358:      }
        -:  359:    }
        -:  360:
    #####:  361:    if (builtin_routine_id >= ECMA_MATH_OBJECT_ATAN2
    #####:  362:        && arguments_number >= 2)
        -:  363:    {
    #####:  364:      if (ecma_is_value_number (arguments_list[1]))
        -:  365:      {
    #####:  366:        y = ecma_get_number_from_value (arguments_list[1]);
        -:  367:      }
        -:  368:      else
        -:  369:      {
    #####:  370:        ecma_value_t value = ecma_op_to_number (arguments_list[1], &y);
        -:  371:
    #####:  372:        if (ECMA_IS_VALUE_ERROR (value))
        -:  373:        {
    #####:  374:          return value;
        -:  375:        }
        -:  376:      }
        -:  377:    }
        -:  378:
    #####:  379:    switch (builtin_routine_id)
        -:  380:    {
    #####:  381:      case ECMA_MATH_OBJECT_ABS:
        -:  382:      {
    #####:  383:        x = DOUBLE_TO_ECMA_NUMBER_T (fabs (x));
    #####:  384:        break;
        -:  385:      }
    #####:  386:      case ECMA_MATH_OBJECT_ACOS:
        -:  387:      {
    #####:  388:        x = DOUBLE_TO_ECMA_NUMBER_T (acos (x));
    #####:  389:        break;
        -:  390:      }
    #####:  391:      case ECMA_MATH_OBJECT_ASIN:
        -:  392:      {
    #####:  393:        x = DOUBLE_TO_ECMA_NUMBER_T (asin (x));
    #####:  394:        break;
        -:  395:      }
    #####:  396:      case ECMA_MATH_OBJECT_ATAN:
        -:  397:      {
    #####:  398:        x = DOUBLE_TO_ECMA_NUMBER_T (atan (x));
    #####:  399:        break;
        -:  400:      }
    #####:  401:      case ECMA_MATH_OBJECT_CEIL:
        -:  402:      {
    #####:  403:        x = DOUBLE_TO_ECMA_NUMBER_T (ceil (x));
    #####:  404:        break;
        -:  405:      }
    #####:  406:      case ECMA_MATH_OBJECT_COS:
        -:  407:      {
    #####:  408:        x = DOUBLE_TO_ECMA_NUMBER_T (cos (x));
    #####:  409:        break;
        -:  410:      }
    #####:  411:      case ECMA_MATH_OBJECT_EXP:
        -:  412:      {
    #####:  413:        x = DOUBLE_TO_ECMA_NUMBER_T (exp (x));
    #####:  414:        break;
        -:  415:      }
    #####:  416:      case ECMA_MATH_OBJECT_FLOOR:
        -:  417:      {
    #####:  418:        x = DOUBLE_TO_ECMA_NUMBER_T (floor (x));
    #####:  419:        break;
        -:  420:      }
    #####:  421:      case ECMA_MATH_OBJECT_LOG:
        -:  422:      {
    #####:  423:        x = DOUBLE_TO_ECMA_NUMBER_T (log (x));
    #####:  424:        break;
        -:  425:      }
        -:  426:#if JERRY_ESNEXT
    #####:  427:      case ECMA_MATH_OBJECT_TRUNC:
        -:  428:      {
    #####:  429:        x = ecma_builtin_math_object_trunc (x);
    #####:  430:        break;
        -:  431:      }
    #####:  432:      case ECMA_MATH_OBJECT_SIGN:
        -:  433:      {
    #####:  434:        x = ecma_builtin_math_object_sign (x);
    #####:  435:        break;
        -:  436:      }
        -:  437:#endif /* JERRY_ESNEXT */
    #####:  438:      case ECMA_MATH_OBJECT_ROUND:
        -:  439:      {
    #####:  440:        if (ecma_number_is_nan (x)
    #####:  441:            || ecma_number_is_zero (x)
    #####:  442:            || ecma_number_is_infinity (x)
    #####:  443:            || fmod (x, 1.0) == 0)
        -:  444:        {
        -:  445:          /* Do nothing. */
        -:  446:        }
    #####:  447:        else if (ecma_number_is_negative (x)
    #####:  448:                 && x >= -ECMA_NUMBER_HALF)
        -:  449:        {
    #####:  450:          x = -ECMA_NUMBER_ZERO;
        -:  451:        }
        -:  452:        else
        -:  453:        {
    #####:  454:          const ecma_number_t up_half = x + ECMA_NUMBER_HALF;
    #####:  455:          const ecma_number_t down_half = x - ECMA_NUMBER_HALF;
    #####:  456:          const ecma_number_t up_rounded = up_half - ecma_op_number_remainder (up_half, ECMA_NUMBER_ONE);
    #####:  457:          const ecma_number_t down_rounded = down_half - ecma_op_number_remainder (down_half, ECMA_NUMBER_ONE);
        -:  458:
    #####:  459:          if (up_rounded - x <= x - down_rounded)
        -:  460:          {
    #####:  461:            x = up_rounded;
        -:  462:          }
        -:  463:          else
        -:  464:          {
    #####:  465:            x = down_rounded;
        -:  466:          }
        -:  467:        }
    #####:  468:        break;
        -:  469:      }
    #####:  470:      case ECMA_MATH_OBJECT_SIN:
        -:  471:      {
    #####:  472:        x = DOUBLE_TO_ECMA_NUMBER_T (sin (x));
    #####:  473:        break;
        -:  474:      }
    #####:  475:      case ECMA_MATH_OBJECT_SQRT:
        -:  476:      {
    #####:  477:        x = DOUBLE_TO_ECMA_NUMBER_T (sqrt (x));
    #####:  478:        break;
        -:  479:      }
    #####:  480:      case ECMA_MATH_OBJECT_TAN:
        -:  481:      {
    #####:  482:        x = DOUBLE_TO_ECMA_NUMBER_T (tan (x));
    #####:  483:        break;
        -:  484:      }
    #####:  485:      case ECMA_MATH_OBJECT_ATAN2:
        -:  486:      {
    #####:  487:        x = DOUBLE_TO_ECMA_NUMBER_T (atan2 (x, y));
    #####:  488:        break;
        -:  489:      }
    #####:  490:      case ECMA_MATH_OBJECT_POW:
        -:  491:      {
    #####:  492:        x = ecma_number_pow (x, y);
    #####:  493:        break;
        -:  494:      }
        -:  495:#if JERRY_ESNEXT
    #####:  496:      case ECMA_MATH_OBJECT_ACOSH:
        -:  497:      {
    #####:  498:        x = DOUBLE_TO_ECMA_NUMBER_T (acosh (x));
    #####:  499:        break;
        -:  500:      }
    #####:  501:      case ECMA_MATH_OBJECT_ASINH:
        -:  502:      {
    #####:  503:        x = DOUBLE_TO_ECMA_NUMBER_T (asinh (x));
    #####:  504:        break;
        -:  505:      }
    #####:  506:      case ECMA_MATH_OBJECT_ATANH:
        -:  507:      {
    #####:  508:        x = DOUBLE_TO_ECMA_NUMBER_T (atanh (x));
    #####:  509:        break;
        -:  510:      }
    #####:  511:      case ECMA_MATH_OBJECT_CBRT:
        -:  512:      {
    #####:  513:        x = DOUBLE_TO_ECMA_NUMBER_T (cbrt (x));
    #####:  514:        break;
        -:  515:      }
    #####:  516:      case ECMA_MATH_OBJECT_COSH:
        -:  517:      {
    #####:  518:        x = DOUBLE_TO_ECMA_NUMBER_T (cosh (x));
    #####:  519:        break;
        -:  520:      }
    #####:  521:      case ECMA_MATH_OBJECT_EXPM1:
        -:  522:      {
    #####:  523:        x = DOUBLE_TO_ECMA_NUMBER_T (expm1 (x));
    #####:  524:        break;
        -:  525:      }
    #####:  526:      case ECMA_MATH_OBJECT_LOG1P:
        -:  527:      {
    #####:  528:        x = DOUBLE_TO_ECMA_NUMBER_T (log1p (x));
    #####:  529:        break;
        -:  530:      }
    #####:  531:      case ECMA_MATH_OBJECT_LOG10:
        -:  532:      {
    #####:  533:        x = DOUBLE_TO_ECMA_NUMBER_T (log10 (x));
    #####:  534:        break;
        -:  535:      }
    #####:  536:      case ECMA_MATH_OBJECT_LOG2:
        -:  537:      {
    #####:  538:        x = DOUBLE_TO_ECMA_NUMBER_T (log2 (x));
    #####:  539:        break;
        -:  540:      }
    #####:  541:      case ECMA_MATH_OBJECT_SINH:
        -:  542:      {
    #####:  543:        x = DOUBLE_TO_ECMA_NUMBER_T (sinh (x));
    #####:  544:        break;
        -:  545:      }
    #####:  546:      case ECMA_MATH_OBJECT_TANH:
        -:  547:      {
    #####:  548:        x = DOUBLE_TO_ECMA_NUMBER_T (tanh (x));
    #####:  549:        break;
        -:  550:      }
    #####:  551:      case ECMA_MATH_OBJECT_CLZ32:
        -:  552:      {
    #####:  553:        uint32_t n = ecma_number_to_uint32 (x);
        -:  554:#if defined (__GNUC__) || defined (__clang__)
    #####:  555:        x = n ? __builtin_clz (n) : 32;
        -:  556:#elif defined (_WIN32)
        -:  557:        unsigned long ret;
        -:  558:        x = _BitScanReverse (&ret, n) ? 31 - ret : 32;
        -:  559:#else
        -:  560:        x = 32;
        -:  561:        for (int i = 31; i >= 0; i--)
        -:  562:        {
        -:  563:          if (n >> i)
        -:  564:          {
        -:  565:            x = 31 - i;
        -:  566:            break;
        -:  567:          }
        -:  568:        }
        -:  569:#endif
    #####:  570:        break;
        -:  571:      }
    #####:  572:      case ECMA_MATH_OBJECT_FROUND:
        -:  573:      {
    #####:  574:        x = (float) x;
    #####:  575:        break;
        -:  576:      }
    #####:  577:      case ECMA_MATH_OBJECT_IMUL:
        -:  578:      {
    #####:  579:        x = (int32_t) (ecma_number_to_uint32 (x) * ecma_number_to_uint32 (y));
    #####:  580:        break;
        -:  581:      }
        -:  582:#endif /* JERRY_ESNEXT */
        -:  583:    }
    #####:  584:    return ecma_make_number_value (x);
        -:  585:  } /* if (builtin_routine_id <= ECMA_MATH_OBJECT_POW) */
        -:  586:
    #####:  587:  if (builtin_routine_id <= ECMA_MATH_OBJECT_MIN)
        -:  588:  {
    #####:  589:    return ecma_builtin_math_object_max_min (builtin_routine_id == ECMA_MATH_OBJECT_MAX,
        -:  590:                                             arguments_list,
        -:  591:                                             arguments_number);
        -:  592:  }
        -:  593:
        -:  594:#if JERRY_ESNEXT
    #####:  595:  if (builtin_routine_id == ECMA_MATH_OBJECT_HYPOT)
        -:  596:  {
    #####:  597:    return ecma_builtin_math_object_hypot (arguments_list, arguments_number);
        -:  598:  }
        -:  599:#endif /* JERRY_ESNEXT */
        -:  600:
    #####:  601:  JERRY_ASSERT (builtin_routine_id == ECMA_MATH_OBJECT_RANDOM);
        -:  602:
    #####:  603:  return ecma_builtin_math_object_random ();
        -:  604:} /* ecma_builtin_math_dispatch_routine */
        -:  605:
        -:  606:/**
        -:  607: * @}
        -:  608: * @}
        -:  609: * @}
        -:  610: */
        -:  611:
        -:  612:#endif /* JERRY_BUILTIN_MATH */
