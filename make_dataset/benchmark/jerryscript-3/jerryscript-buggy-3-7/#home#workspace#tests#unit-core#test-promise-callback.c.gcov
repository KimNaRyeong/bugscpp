        -:    0:Source:/home/workspace/tests/unit-core/test-promise-callback.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:
        -:   18:#include "test-common.h"
        -:   19:
        -:   20:/* Note: RS = ReSolve, RJ = ReJect */
        -:   21:typedef enum
        -:   22:{
        -:   23:  C = JERRY_PROMISE_EVENT_CREATE, /**< same as JERRY_PROMISE_CALLBACK_CREATE with undefined value */
        -:   24:  RS = JERRY_PROMISE_EVENT_RESOLVE, /**< same as JERRY_PROMISE_CALLBACK_RESOLVE */
        -:   25:  RJ = JERRY_PROMISE_EVENT_REJECT, /**< same as JERRY_PROMISE_CALLBACK_REJECT */
        -:   26:  RSF = JERRY_PROMISE_EVENT_RESOLVE_FULFILLED, /**< same as JERRY_PROMISE_EVENT_RESOLVE_FULFILLED */
        -:   27:  RJF = JERRY_PROMISE_EVENT_REJECT_FULFILLED, /**< same as JERRY_PROMISE_EVENT_REJECT_FULFILLED */
        -:   28:  RWH = JERRY_PROMISE_EVENT_REJECT_WITHOUT_HANDLER, /**< same as JERRY_PROMISE_EVENT_REJECT_WITHOUT_HANDLER */
        -:   29:  CHA = JERRY_PROMISE_EVENT_CATCH_HANDLER_ADDED, /**< same as JERRY_PROMISE_EVENT_CATCH_HANDLER_ADDED */
        -:   30:  BR = JERRY_PROMISE_EVENT_BEFORE_REACTION_JOB, /**< same as JERRY_PROMISE_CALLBACK_BEFORE_REACTION_JOB */
        -:   31:  AR = JERRY_PROMISE_EVENT_AFTER_REACTION_JOB, /**< same as JERRY_PROMISE_CALLBACK_AFTER_REACTION_JOB */
        -:   32:  A = JERRY_PROMISE_EVENT_ASYNC_AWAIT, /**< same as JERRY_PROMISE_CALLBACK_ASYNC_AWAIT */
        -:   33:  BRS = JERRY_PROMISE_EVENT_ASYNC_BEFORE_RESOLVE, /**< same as JERRY_PROMISE_CALLBACK_ASYNC_BEFORE_RESOLVE */
        -:   34:  BRJ = JERRY_PROMISE_EVENT_ASYNC_BEFORE_REJECT, /**< same as JERRY_PROMISE_CALLBACK_ASYNC_BEFORE_REJECT */
        -:   35:  ARS = JERRY_PROMISE_EVENT_ASYNC_AFTER_RESOLVE, /**< same as JERRY_PROMISE_CALLBACK_ASYNC_AFTER_RESOLVE */
        -:   36:  ARJ = JERRY_PROMISE_EVENT_ASYNC_AFTER_REJECT, /**< same as JERRY_PROMISE_CALLBACK_ASYNC_AFTER_REJECT */
        -:   37:  CP = UINT8_MAX - 1, /**< same as JERRY_PROMISE_CALLBACK_CREATE with Promise value */
        -:   38:  E = UINT8_MAX, /**< marks the end of the event list */
        -:   39:} jerry_promise_callback_event_abbreviations_t;
        -:   40:
        -:   41:static int user;
        -:   42:static const uint8_t *next_event_p;
        -:   43:
        -:   44:static void
    #####:   45:promise_callback (jerry_promise_event_type_t event_type, /**< event type */
        -:   46:                  const jerry_value_t object, /**< target object */
        -:   47:                  const jerry_value_t value, /**< optional argument */
        -:   48:                  void *user_p) /**< user pointer passed to the callback */
        -:   49:{
    #####:   50:  TEST_ASSERT (user_p == (void *) &user);
        -:   51:
    #####:   52:  switch (event_type)
        -:   53:  {
    #####:   54:    case JERRY_PROMISE_EVENT_CREATE:
        -:   55:    {
    #####:   56:      TEST_ASSERT (jerry_value_is_promise (object));
    #####:   57:      if (jerry_value_is_undefined (value))
        -:   58:      {
        -:   59:        break;
        -:   60:      }
        -:   61:
    #####:   62:      TEST_ASSERT (jerry_value_is_promise (value));
    #####:   63:      TEST_ASSERT (*next_event_p++ == CP);
        -:   64:      return;
        -:   65:    }
    #####:   66:    case JERRY_PROMISE_EVENT_RESOLVE:
        -:   67:    case JERRY_PROMISE_EVENT_REJECT:
        -:   68:    case JERRY_PROMISE_EVENT_RESOLVE_FULFILLED:
        -:   69:    case JERRY_PROMISE_EVENT_REJECT_FULFILLED:
        -:   70:    case JERRY_PROMISE_EVENT_REJECT_WITHOUT_HANDLER:
        -:   71:    {
    #####:   72:      TEST_ASSERT (jerry_value_is_promise (object));
        -:   73:      break;
        -:   74:    }
    #####:   75:    case JERRY_PROMISE_EVENT_CATCH_HANDLER_ADDED:
        -:   76:    case JERRY_PROMISE_EVENT_BEFORE_REACTION_JOB:
        -:   77:    case JERRY_PROMISE_EVENT_AFTER_REACTION_JOB:
        -:   78:    {
    #####:   79:      TEST_ASSERT (jerry_value_is_promise (object));
    #####:   80:      TEST_ASSERT (jerry_value_is_undefined (value));
        -:   81:      break;
        -:   82:    }
    #####:   83:    case JERRY_PROMISE_EVENT_ASYNC_AWAIT:
        -:   84:    {
    #####:   85:      TEST_ASSERT (jerry_value_is_object (object));
    #####:   86:      TEST_ASSERT (jerry_value_is_promise (value));
        -:   87:      break;
        -:   88:    }
    #####:   89:    default:
        -:   90:    {
    #####:   91:      TEST_ASSERT (event_type == JERRY_PROMISE_EVENT_ASYNC_BEFORE_RESOLVE
        -:   92:                   || event_type == JERRY_PROMISE_EVENT_ASYNC_BEFORE_REJECT
        -:   93:                   || event_type == JERRY_PROMISE_EVENT_ASYNC_AFTER_RESOLVE
        -:   94:                   || event_type == JERRY_PROMISE_EVENT_ASYNC_AFTER_REJECT);
    #####:   95:      TEST_ASSERT (jerry_value_is_object (object));
        -:   96:      break;
        -:   97:    }
        -:   98:  }
        -:   99:
    #####:  100:  TEST_ASSERT (*next_event_p++ == (uint8_t) event_type);
        -:  101:} /* promise_callback */
        -:  102:
        -:  103:static void
    #####:  104:run_eval (const uint8_t *event_list_p, /**< event list */
        -:  105:          const char *source_p) /**< source code */
        -:  106:{
    #####:  107:  next_event_p = event_list_p;
        -:  108:
    #####:  109:  jerry_value_t result = jerry_eval ((const jerry_char_t *) source_p, strlen (source_p), 0);
        -:  110:
    #####:  111:  TEST_ASSERT (!jerry_value_is_error (result));
    #####:  112:  jerry_release_value (result);
        -:  113:
    #####:  114:  result = jerry_run_all_enqueued_jobs ();
    #####:  115:  TEST_ASSERT (!jerry_value_is_error (result));
    #####:  116:  jerry_release_value (result);
        -:  117:
    #####:  118:  TEST_ASSERT (*next_event_p == UINT8_MAX);
    #####:  119:} /* run_eval */
        -:  120:
        -:  121:int
    #####:  122:main (void)
        -:  123:{
    #####:  124:  TEST_INIT ();
        -:  125:
    #####:  126:  if (!jerry_is_feature_enabled (JERRY_FEATURE_PROMISE))
        -:  127:  {
    #####:  128:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Promise is disabled!\n");
    #####:  129:    return 0;
        -:  130:  }
        -:  131:
        -:  132:  /* The test system enables this feature when Promises are enabled. */
    #####:  133:  TEST_ASSERT (jerry_is_feature_enabled (JERRY_FEATURE_PROMISE_CALLBACK));
        -:  134:
    #####:  135:  jerry_init (JERRY_INIT_EMPTY);
        -:  136:
    #####:  137:  jerry_promise_event_filter_t filters = (JERRY_PROMISE_EVENT_FILTER_MAIN
        -:  138:                                          | JERRY_PROMISE_EVENT_FILTER_ERROR
        -:  139:                                          | JERRY_PROMISE_EVENT_FILTER_REACTION_JOB
        -:  140:                                          | JERRY_PROMISE_EVENT_FILTER_ASYNC_MAIN
        -:  141:                                          | JERRY_PROMISE_EVENT_FILTER_ASYNC_REACTION_JOB);
        -:  142:
    #####:  143:  jerry_promise_set_callback (filters, promise_callback, (void *) &user);
        -:  144:
        -:  145:  /* Test promise creation. */
        -:  146:  static uint8_t events1[] = { C, C, C, E };
        -:  147:
    #####:  148:  run_eval (events1,
        -:  149:            "'use strict'\n"
        -:  150:            "new Promise((res, rej) => {})\n"
        -:  151:            "new Promise((res, rej) => {})\n"
        -:  152:            "new Promise((res, rej) => {})\n");
        -:  153:
        -:  154:  /* Test then call. */
        -:  155:  static uint8_t events2[] = { C, CP, E };
        -:  156:
    #####:  157:  run_eval (events2,
        -:  158:            "'use strict'\n"
        -:  159:            "var promise = new Promise((res, rej) => {})\n"
        -:  160:            "promise.then(() => {}, () => {})\n");
        -:  161:
        -:  162:  /* Test then call with extended Promise. */
        -:  163:  static uint8_t events3[] = { C, C, E };
        -:  164:
    #####:  165:  run_eval (events3,
        -:  166:            "'use strict'\n"
        -:  167:            "var P = class extends Promise {}\n"
        -:  168:            "var promise = new P((res, rej) => {})\n"
        -:  169:            "promise.then(() => {})\n");
        -:  170:
        -:  171:  /* Test resolve and reject calls. */
        -:  172:  static uint8_t events4[] = { C, C, RS, RJ, RWH, E };
        -:  173:
    #####:  174:  run_eval (events4,
        -:  175:            "'use strict'\n"
        -:  176:            "var resolve\n"
        -:  177:            "var reject\n"
        -:  178:            "new Promise((res, rej) => resolve = res)\n"
        -:  179:            "new Promise((res, rej) => reject = rej)\n"
        -:  180:            "resolve(1)\n"
        -:  181:            "reject(1)\n");
        -:  182:
        -:  183:  /* Test then and resolve calls. */
        -:  184:  static uint8_t events5[] = { C, CP, RS, BR, RS, AR, E };
        -:  185:
    #####:  186:  run_eval (events5,
        -:  187:            "'use strict'\n"
        -:  188:            "var resolve\n"
        -:  189:            "var promise = new Promise((res, rej) => resolve = res)\n"
        -:  190:            "promise.then(() => {})\n"
        -:  191:            "resolve(1)\n");
        -:  192:
        -:  193:  /* Test resolve and then calls. */
        -:  194:  static uint8_t events6[] = { C, RS, CP, BR, RS, AR, E };
        -:  195:
    #####:  196:  run_eval (events6,
        -:  197:            "'use strict'\n"
        -:  198:            "var promise = new Promise((res, rej) => res(1))\n"
        -:  199:            "promise.then(() => {})\n");
        -:  200:
        -:  201:  /* Test Promise.resolve. */
        -:  202:  static uint8_t events7[] = { C, RS, CP, BR, RS, AR, E };
        -:  203:
    #####:  204:  run_eval (events7,
        -:  205:            "Promise.resolve(4).then(() => {})\n");
        -:  206:
        -:  207:  /* Test Promise.reject. */
        -:  208:  static uint8_t events8[] = { C, RJ, RWH, CP, CHA, BR, RJ, RWH, AR, E };
        -:  209:
    #####:  210:  run_eval (events8,
        -:  211:            "Promise.reject(4).catch(() => { throw 'Error' })\n");
        -:  212:
        -:  213:  /* Test Promise.race without resolve */
        -:  214:  static uint8_t events9[] = { C, C, C, CP, CP, E };
        -:  215:
    #####:  216:  run_eval (events9,
        -:  217:            "'use strict'\n"
        -:  218:            "var p1 = new Promise((res, rej) => {})\n"
        -:  219:            "var p2 = new Promise((res, rej) => {})\n"
        -:  220:            "Promise.race([p1,p2])\n");
        -:  221:
        -:  222:  /* Test Promise.race with resolve. */
        -:  223:  static uint8_t events10[] = { C, RS, C, RJ, RWH, C, CP, CP, CHA, BR, RS, RS, AR, BR, RJF, RS, AR, E };
        -:  224:
    #####:  225:  run_eval (events10,
        -:  226:            "'use strict'\n"
        -:  227:            "var p1 = new Promise((res, rej) => res(1))\n"
        -:  228:            "var p2 = new Promise((res, rej) => rej(1))\n"
        -:  229:            "Promise.race([p1,p2])\n");
        -:  230:
        -:  231:  /* Test Promise.all without resolve. */
        -:  232:  static uint8_t events11[] = { C, C, C, CP, CP, E };
        -:  233:
    #####:  234:  run_eval (events11,
        -:  235:            "'use strict'\n"
        -:  236:            "var p1 = new Promise((res, rej) => {})\n"
        -:  237:            "var p2 = new Promise((res, rej) => {})\n"
        -:  238:            "Promise.all([p1,p2])\n");
        -:  239:
        -:  240:  /* Test Promise.all with resolve. */
        -:  241:  static uint8_t events12[] = { C, RS, C, RJ, RWH, C, CP, CP, CHA, BR, RS, AR, BR, RJ, RWH, RS, AR, E };
        -:  242:
    #####:  243:  run_eval (events12,
        -:  244:            "'use strict'\n"
        -:  245:            "var p1 = new Promise((res, rej) => res(1))\n"
        -:  246:            "var p2 = new Promise((res, rej) => rej(1))\n"
        -:  247:            "Promise.all([p1,p2])\n");
        -:  248:
        -:  249:  /* Test async function. */
        -:  250:  static uint8_t events13[] = { C, RS, E };
        -:  251:
    #####:  252:  run_eval (events13,
        -:  253:            "'use strict'\n"
        -:  254:            "async function f() {}\n"
        -:  255:            "f()\n");
        -:  256:
        -:  257:  /* Test await with resolved Promise. */
        -:  258:  static uint8_t events14[] = { C, RS, A, C, BRS, RS, ARS, E };
        -:  259:
    #####:  260:  run_eval (events14,
        -:  261:            "'use strict'\n"
        -:  262:            "async function f(p) { await p }\n"
        -:  263:            "f(Promise.resolve(1))\n");
        -:  264:
        -:  265:  /* Test await with non-Promise value. */
        -:  266:  static uint8_t events15[] = { C, RS, A, C, BRS, C, RS, A, ARS, BRS, RS, ARS, E };
        -:  267:
    #####:  268:  run_eval (events15,
        -:  269:            "'use strict'\n"
        -:  270:            "async function f(p) { await p; await 'X' }\n"
        -:  271:            "f(Promise.resolve(1))\n");
        -:  272:
        -:  273:  /* Test await with rejected Promise. */
        -:  274:  static uint8_t events16[] = { C, RJ, RWH, A, CHA, C, BRJ, C, RS, RS, ARJ, E };
        -:  275:
    #####:  276:  run_eval (events16,
        -:  277:            "'use strict'\n"
        -:  278:            "async function f(p) { try { await p; } catch (e) { Promise.resolve(1) } }\n"
        -:  279:            "f(Promise.reject(1))\n");
        -:  280:
        -:  281:  /* Test async generator function. */
        -:  282:  static uint8_t events17[] = { C, RS, C, A, BRS, RS, ARS, E };
        -:  283:
    #####:  284:  run_eval (events17,
        -:  285:            "'use strict'\n"
        -:  286:            "async function *f(p) { await p; return 4 }\n"
        -:  287:            "f(Promise.resolve(1)).next()\n");
        -:  288:
        -:  289:  /* Test yield* operation. */
        -:  290:  static uint8_t events18[] = { C, C, RS, A, BRS, C, RS, A, ARS, BRS, RS, ARS, E };
        -:  291:
    #####:  292:  run_eval (events18,
        -:  293:            "'use strict'\n"
        -:  294:            "async function *f(p) { yield 1 }\n"
        -:  295:            "async function *g() { yield* f() }\n"
        -:  296:            "g().next()\n");
        -:  297:
        -:  298:  /* Test multiple fulfill operations. */
        -:  299:  static uint8_t events19[] = { C, RS, RSF, RJF, E };
        -:  300:
    #####:  301:  run_eval (events19,
        -:  302:            "'use strict'\n"
        -:  303:            "var resolve, reject\n"
        -:  304:            "var p1 = new Promise((res, rej) => { resolve = res, reject = rej })\n"
        -:  305:            "resolve(1)\n"
        -:  306:            "resolve(2)\n"
        -:  307:            "reject(3)\n");
        -:  308:
        -:  309:  /* Test multiple fulfill operations. */
        -:  310:  static uint8_t events20[] = { C, RJ, RWH, RSF, RJF, E };
        -:  311:
    #####:  312:  run_eval (events20,
        -:  313:            "'use strict'\n"
        -:  314:            "var resolve, reject\n"
        -:  315:            "var p1 = new Promise((res, rej) => { resolve = res, reject = rej })\n"
        -:  316:            "reject(1)\n"
        -:  317:            "resolve(2)\n"
        -:  318:            "reject(3)\n");
        -:  319:
        -:  320:  /* Test catch handler added later is reported only once. */
        -:  321:  static uint8_t events21[] = { C, RJ, RWH, CP, CHA, CP, CP, BR, RS, AR, BR, RS, AR, BR, RS, AR, E };
        -:  322:
    #####:  323:  run_eval (events21,
        -:  324:            "'use strict'\n"
        -:  325:            "var rej = Promise.reject(4)\n"
        -:  326:            "rej.catch(() => {})\n"
        -:  327:            "rej.catch(() => {})\n"
        -:  328:            "rej.catch(() => {})\n");
        -:  329:
        -:  330:  /* Test catch handler added later is reported only once. */
        -:  331:  static uint8_t events22[] = { C, RJ, RWH, A, CHA, C, BRJ, A, ARJ, BRJ, RJ, RWH, ARJ, E };
        -:  332:
    #####:  333:  run_eval (events22,
        -:  334:            "'use strict'\n"
        -:  335:            "async function f(p) { try { await p; } catch(e) { await p; } }"
        -:  336:            "f(Promise.reject(4))\n");
        -:  337:
        -:  338:  /* Test chained then. */
        -:  339:  static uint8_t events23[] = { C, RJ, RWH, CP, CHA, CP, BR, RJ, AR, BR, RS, AR, E };
        -:  340:
    #####:  341:  run_eval (events23,
        -:  342:            "'use strict'\n"
        -:  343:            "var p = Promise.reject(0)\n"
        -:  344:            "p.then(() => {}).catch(() => {})\n");
        -:  345:
        -:  346:  /* Test disabled filters. */
    #####:  347:  jerry_promise_set_callback (JERRY_PROMISE_EVENT_FILTER_DISABLE, promise_callback, (void *) &user);
        -:  348:
        -:  349:  static uint8_t events24[] = { E };
        -:  350:
    #####:  351:  run_eval (events24,
        -:  352:            "'use strict'\n"
        -:  353:            "async function f(p) { await p }"
        -:  354:            "f(Promise.resolve(1))\n");
        -:  355:
        -:  356:  /* Test filtered events. */
    #####:  357:  filters = JERRY_PROMISE_EVENT_FILTER_REACTION_JOB | JERRY_PROMISE_EVENT_FILTER_ASYNC_REACTION_JOB;
    #####:  358:  jerry_promise_set_callback (filters, promise_callback, (void *) &user);
        -:  359:
        -:  360:  static uint8_t events25[] = { BR, AR, BRS, ARS, E };
        -:  361:
    #####:  362:  run_eval (events25,
        -:  363:            "'use strict'\n"
        -:  364:            "async function f(p) { await p }"
        -:  365:            "f(Promise.resolve(1).then(() => {}))\n");
        -:  366:
    #####:  367:  jerry_cleanup ();
    #####:  368:  return 0;
        -:  369:} /* main */
