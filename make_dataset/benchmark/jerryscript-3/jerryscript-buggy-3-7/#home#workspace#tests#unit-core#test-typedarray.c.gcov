        -:    0:Source:/home/workspace/tests/unit-core/test-typedarray.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:#include "jerryscript-port.h"
        -:   18:#include "jerryscript-port-default.h"
        -:   19:#include "test-common.h"
        -:   20:
        -:   21:#include <stdio.h>
        -:   22:
        -:   23:/**
        -:   24: * Type to describe test cases.
        -:   25: */
        -:   26:typedef struct
        -:   27:{
        -:   28:  jerry_typedarray_type_t typedarray_type; /**< what kind of TypedArray */
        -:   29:  char *constructor_name; /**< JS constructor name for TypedArray */
        -:   30:  uint32_t element_count; /**< number of elements for the TypedArray */
        -:   31:  uint32_t bytes_per_element; /**< bytes per elment of the given typedarray_type */
        -:   32:} test_entry_t;
        -:   33:
        -:   34:/**
        -:   35: * Register a JavaScript value in the global object.
        -:   36: */
        -:   37:static void
    #####:   38:register_js_value (const char *name_p, /**< name of the function */
        -:   39:                    jerry_value_t value) /**< function callback */
        -:   40:{
    #####:   41:  jerry_value_t global_obj_val = jerry_get_global_object ();
        -:   42:
    #####:   43:  jerry_value_t name_val = jerry_create_string ((const jerry_char_t *) name_p);
    #####:   44:  jerry_value_t result_val = jerry_set_property (global_obj_val, name_val, value);
        -:   45:
    #####:   46:  jerry_release_value (name_val);
    #####:   47:  jerry_release_value (global_obj_val);
        -:   48:
    #####:   49:  jerry_release_value (result_val);
    #####:   50:} /* register_js_value */
        -:   51:
        -:   52:static jerry_value_t
    #####:   53:assert_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   54:                const jerry_value_t args_p[], /**< function arguments */
        -:   55:                const jerry_length_t args_cnt) /**< number of function arguments */
        -:   56:{
        -:   57:  JERRY_UNUSED (call_info_p);
        -:   58:
    #####:   59:  if (jerry_value_is_true (args_p[0]))
        -:   60:  {
    #####:   61:    return jerry_create_boolean (true);
        -:   62:  }
        -:   63:  else
        -:   64:  {
    #####:   65:    if (args_cnt > 1
    #####:   66:        && jerry_value_is_string (args_p[1]))
    #####:   67:    {
    #####:   68:      jerry_length_t utf8_sz = jerry_get_string_size (args_p[1]);
    #####:   69:      TEST_ASSERT (utf8_sz <= 127); /* 127 is the expected max assert fail message size. */
    #####:   70:      JERRY_VLA (char, string_from_utf8, utf8_sz + 1);
    #####:   71:      string_from_utf8[utf8_sz] = 0;
        -:   72:
    #####:   73:      jerry_string_to_char_buffer (args_p[1], (jerry_char_t *) string_from_utf8, utf8_sz);
        -:   74:
    #####:   75:      printf ("JS assert: %s\n", string_from_utf8);
        -:   76:    }
    #####:   77:    TEST_ASSERT (false);
        -:   78:  }
        -:   79:} /* assert_handler */
        -:   80:
        -:   81:/**
        -:   82: * Do simple TypedArray property validation.
        -:   83: */
        -:   84:static void
    #####:   85:test_typedarray_info (jerry_value_t typedarray, /**< target TypedArray to query */
        -:   86:                      jerry_typedarray_type_t typedarray_type, /**< expected TypedArray type */
        -:   87:                      jerry_length_t element_count, /**< expected element count */
        -:   88:                      jerry_length_t bytes_per_element) /**< bytes per element for the given type */
        -:   89:{
    #####:   90:  TEST_ASSERT (!jerry_value_is_error (typedarray));
    #####:   91:  TEST_ASSERT (jerry_value_is_typedarray (typedarray));
    #####:   92:  TEST_ASSERT (jerry_get_typedarray_type (typedarray) == typedarray_type);
    #####:   93:  TEST_ASSERT (jerry_get_typedarray_length (typedarray) == element_count);
        -:   94:
    #####:   95:  jerry_length_t byte_length = (uint32_t) -1;
    #####:   96:  jerry_length_t byte_offset = (uint32_t) -1;
    #####:   97:  jerry_value_t arraybuffer = jerry_get_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:   98:  TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
        -:   99:
    #####:  100:  TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:  101:  TEST_ASSERT (byte_offset == 0);
        -:  102:
    #####:  103:  jerry_release_value (arraybuffer);
    #####:  104:} /* test_typedarray_info */
        -:  105:
        -:  106:/**
        -:  107: * Test construction of TypedArrays and validate properties.
        -:  108: */
        -:  109:static void
    #####:  110:test_typedarray_queries (test_entry_t test_entries[]) /**< test cases */
        -:  111:{
    #####:  112:  jerry_value_t global_obj_val = jerry_get_global_object ();
        -:  113:
    #####:  114:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  115:  {
        -:  116:    /* Create TypedArray via construct call */
        -:  117:    {
    #####:  118:      jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) test_entries[i].constructor_name);
    #####:  119:      jerry_value_t prop_value = jerry_get_property (global_obj_val, prop_name);
    #####:  120:      TEST_ASSERT (!jerry_value_is_error (prop_value));
    #####:  121:      jerry_value_t length_arg = jerry_create_number (test_entries[i].element_count);
        -:  122:
    #####:  123:      jerry_value_t typedarray = jerry_construct_object (prop_value, &length_arg, 1);
        -:  124:
    #####:  125:      jerry_release_value (prop_name);
    #####:  126:      jerry_release_value (prop_value);
    #####:  127:      jerry_release_value (length_arg);
        -:  128:
    #####:  129:      test_typedarray_info (typedarray,
        -:  130:                            test_entries[i].typedarray_type,
        -:  131:                            test_entries[i].element_count,
        -:  132:                            test_entries[i].bytes_per_element);
    #####:  133:      jerry_release_value (typedarray);
        -:  134:    }
        -:  135:
        -:  136:    /* Create TypedArray via api call */
        -:  137:    {
    #####:  138:      jerry_value_t typedarray = jerry_create_typedarray (test_entries[i].typedarray_type,
        -:  139:                                                          test_entries[i].element_count);
    #####:  140:      test_typedarray_info (typedarray,
        -:  141:                            test_entries[i].typedarray_type,
        -:  142:                            test_entries[i].element_count,
        -:  143:                            test_entries[i].bytes_per_element);
    #####:  144:      jerry_release_value (typedarray);
        -:  145:    }
        -:  146:  }
        -:  147:
    #####:  148:  jerry_release_value (global_obj_val);
    #####:  149:} /* test_typedarray_queries */
        -:  150:
        -:  151:/**
        -:  152: * Test value at given position in the buffer based on TypedArray type.
        -:  153: */
        -:  154:static
    #####:  155:void test_buffer_value (uint64_t value, /**< value to test for */
        -:  156:                        const void *buffer, /**< buffer to read value from */
        -:  157:                        uint32_t start_offset, /**< start offset of the value */
        -:  158:                        jerry_typedarray_type_t typedarray_type, /**< type of TypedArray */
        -:  159:                        uint32_t bytes_per_element) /**< bytes per element for the given type */
        -:  160:{
    #####:  161:  uint32_t offset = start_offset / bytes_per_element;
        -:  162:
        -:  163:#define TEST_VALUE_AT(TYPE, BUFFER, OFFSET, VALUE) TEST_ASSERT (((TYPE *) BUFFER)[OFFSET] == (TYPE) (VALUE))
        -:  164:
    #####:  165:  switch (typedarray_type)
        -:  166:  {
    #####:  167:    case JERRY_TYPEDARRAY_UINT8:      TEST_VALUE_AT (uint8_t,  buffer, offset, value); break;
    #####:  168:    case JERRY_TYPEDARRAY_INT8:       TEST_VALUE_AT (int8_t,   buffer, offset, value); break;
    #####:  169:    case JERRY_TYPEDARRAY_UINT16:     TEST_VALUE_AT (uint16_t, buffer, offset, value); break;
    #####:  170:    case JERRY_TYPEDARRAY_INT16:      TEST_VALUE_AT (int16_t,  buffer, offset, value); break;
    #####:  171:    case JERRY_TYPEDARRAY_UINT32:     TEST_VALUE_AT (uint32_t, buffer, offset, value); break;
    #####:  172:    case JERRY_TYPEDARRAY_INT32:      TEST_VALUE_AT (int32_t,  buffer, offset, value); break;
    #####:  173:    case JERRY_TYPEDARRAY_FLOAT32:    TEST_VALUE_AT (float,    buffer, offset, value); break;
    #####:  174:    case JERRY_TYPEDARRAY_FLOAT64:    TEST_VALUE_AT (double,   buffer, offset, value); break;
    #####:  175:    case JERRY_TYPEDARRAY_BIGINT64:   TEST_VALUE_AT (int64_t,  buffer, offset, value); break;
    #####:  176:    case JERRY_TYPEDARRAY_BIGUINT64:  TEST_VALUE_AT (uint64_t, buffer, offset, value); break;
        -:  177:
    #####:  178:    case JERRY_TYPEDARRAY_UINT8CLAMPED:
        -:  179:    {
    #####:  180:      int64_t signed_value = (int64_t) value;
    #####:  181:      uint8_t expected = (uint8_t) value;
        -:  182:
        -:  183:      /* clamp the value if required*/
    #####:  184:      if (signed_value > 0xFF)
        -:  185:      {
        -:  186:        expected = 0xFF;
        -:  187:      }
    #####:  188:      else if (signed_value < 0)
        -:  189:      {
    #####:  190:        expected = 0;
        -:  191:      }
        -:  192:
    #####:  193:      TEST_VALUE_AT (uint8_t, buffer, offset, expected); break;
        -:  194:    }
    #####:  195:    default: TEST_ASSERT (false); break;
        -:  196:  }
        -:  197:
        -:  198:#undef TEST_VALUE_AT
    #####:  199:} /* test_buffer_value */
        -:  200:
        -:  201:static void
    #####:  202:test_typedarray_complex_creation (test_entry_t test_entries[], /**< test cases */
        -:  203:                                  bool use_external_buffer) /**< run tests using arraybuffer with external memory */
    #####:  204:{
    #####:  205:  const uint32_t arraybuffer_size = 256;
        -:  206:
    #####:  207:  JERRY_VLA (uint8_t, buffer_ext, arraybuffer_size);
    #####:  208:  memset (buffer_ext, 0, arraybuffer_size);
        -:  209:
    #####:  210:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  211:  {
    #####:  212:    const uint32_t offset = 8;
    #####:  213:    uint32_t element_count = test_entries[i].element_count;
    #####:  214:    uint32_t bytes_per_element = test_entries[i].bytes_per_element;
        -:  215:
        -:  216:    /* new %TypedArray% (buffer, offset, length); */
        -:  217:    jerry_value_t typedarray;
        -:  218:    {
        -:  219:      jerry_value_t arraybuffer;
        -:  220:
    #####:  221:      if (use_external_buffer)
        -:  222:      {
    #####:  223:        arraybuffer = jerry_create_arraybuffer_external (arraybuffer_size, buffer_ext, NULL);
        -:  224:      }
        -:  225:      else
        -:  226:      {
    #####:  227:        arraybuffer = jerry_create_arraybuffer (arraybuffer_size);
        -:  228:      }
        -:  229:
    #####:  230:      jerry_value_t js_offset = jerry_create_number (offset);
    #####:  231:      jerry_value_t js_element_count = jerry_create_number (element_count);
        -:  232:
    #####:  233:      register_js_value ("expected_offset", js_offset);
    #####:  234:      register_js_value ("expected_length", js_element_count);
        -:  235:
    #####:  236:      typedarray = jerry_create_typedarray_for_arraybuffer_sz (test_entries[i].typedarray_type,
        -:  237:                                                               arraybuffer,
        -:  238:                                                               offset,
        -:  239:                                                               element_count);
    #####:  240:      TEST_ASSERT (!jerry_value_is_error (typedarray));
        -:  241:
    #####:  242:      jerry_release_value (js_offset);
    #####:  243:      jerry_release_value (js_element_count);
    #####:  244:      jerry_release_value (arraybuffer);
        -:  245:    }
        -:  246:
    #####:  247:    register_js_value ("array", typedarray);
        -:  248:
    #####:  249:    const jerry_char_t test_exptected_src[] = TEST_STRING_LITERAL (
        -:  250:      "assert (array.length == expected_length,"
        -:  251:      "        'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  252:      "assert (array.byteOffset == expected_offset);"
        -:  253:    );
    #####:  254:    jerry_value_t result = jerry_eval (test_exptected_src,
        -:  255:                                       sizeof (test_exptected_src) - 1,
        -:  256:                                       JERRY_PARSE_STRICT_MODE);
    #####:  257:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  258:    jerry_release_value (result);
        -:  259:
    #####:  260:    const jerry_char_t set_element_src[] = TEST_STRING_LITERAL (
        -:  261:      "array[0] = 0x11223344n"
        -:  262:    );
        -:  263:
        -:  264:    /* crop the last 'n' character */
    #####:  265:    size_t src_length = sizeof (set_element_src) - 2;
        -:  266:
    #####:  267:    if (test_entries[i].typedarray_type >= JERRY_TYPEDARRAY_BIGINT64)
        -:  268:    {
        -:  269:      /* use the last 'n' character */
    #####:  270:      src_length++;
        -:  271:    }
        -:  272:
    #####:  273:    result = jerry_eval (set_element_src, src_length, JERRY_PARSE_STRICT_MODE);
    #####:  274:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  275:    jerry_release_value (result);
        -:  276:
    #####:  277:    {
    #####:  278:      jerry_length_t byte_length = 0;
    #####:  279:      jerry_length_t byte_offset = 0;
    #####:  280:      jerry_value_t buffer = jerry_get_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:  281:      TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:  282:      TEST_ASSERT (byte_offset == offset);
        -:  283:
    #####:  284:      JERRY_VLA (uint8_t, test_buffer, arraybuffer_size);
        -:  285:
    #####:  286:      jerry_typedarray_type_t type = jerry_get_typedarray_type (typedarray);
    #####:  287:      jerry_value_t read_count = jerry_arraybuffer_read (buffer, 0, test_buffer, offset + byte_length);
    #####:  288:      TEST_ASSERT (read_count == offset + byte_length);
    #####:  289:      test_buffer_value (0x11223344, test_buffer, offset, type, bytes_per_element);
        -:  290:
    #####:  291:      if (use_external_buffer)
        -:  292:      {
    #####:  293:        test_buffer_value (0x11223344, buffer_ext, offset, type, bytes_per_element);
    #####:  294:        TEST_ASSERT (memcmp (buffer_ext, test_buffer, offset + byte_length) == 0);
        -:  295:      }
        -:  296:
    #####:  297:      jerry_release_value (buffer);
        -:  298:    }
        -:  299:
    #####:  300:    jerry_release_value (typedarray);
        -:  301:  }
    #####:  302:} /* test_typedarray_complex_creation */
        -:  303:
        -:  304:/**
        -:  305: * Test get/set/delete property by index.
        -:  306: */
    #####:  307:static void test_property_by_index (test_entry_t test_entries[])
        -:  308:{
    #####:  309:  int test_int_numbers[5] = {-5, -70, 13, 0, 56};
    #####:  310:  double test_double_numbers[5] = {-83.153, -35.15, 0, 13.1, 89.8975};
    #####:  311:  uint8_t test_uint_numbers[5] = {83, 15, 36, 0, 43};
    #####:  312:  uint64_t test_uint64_numbers[5] = {83, 0, 1, UINT32_MAX, UINT64_MAX};
    #####:  313:  int64_t test_int64_numbers[5] = {INT64_MAX, INT64_MIN, 0, INT32_MAX, INT32_MIN};
        -:  314:
    #####:  315:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  316:  {
        -:  317:    jerry_value_t test_number;
    #####:  318:    uint32_t test_numbers_length = sizeof (test_int_numbers) / sizeof (int);
    #####:  319:    jerry_value_t typedarray = jerry_create_typedarray (test_entries[i].typedarray_type, test_numbers_length);
    #####:  320:    jerry_typedarray_type_t type = jerry_get_typedarray_type (typedarray);
        -:  321:
        -:  322:    jerry_value_t set_result;
        -:  323:    jerry_value_t get_result;
        -:  324:
    #####:  325:    switch (type)
        -:  326:    {
        -:  327:      case JERRY_TYPEDARRAY_INT8:
        -:  328:      case JERRY_TYPEDARRAY_INT16:
        -:  329:      case JERRY_TYPEDARRAY_INT32:
        -:  330:      {
    #####:  331:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  332:        {
    #####:  333:          test_number = jerry_create_number (test_int_numbers[j]);
    #####:  334:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  335:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  336:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  337:
    #####:  338:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  339:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  340:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  341:          TEST_ASSERT (jerry_get_number_value (get_result) == test_int_numbers[j]);
        -:  342:
    #####:  343:          jerry_release_value (test_number);
    #####:  344:          jerry_release_value (set_result);
    #####:  345:          jerry_release_value (get_result);
        -:  346:        }
        -:  347:        break;
        -:  348:      }
        -:  349:      case JERRY_TYPEDARRAY_FLOAT32:
        -:  350:      case JERRY_TYPEDARRAY_FLOAT64:
        -:  351:      {
    #####:  352:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  353:        {
    #####:  354:          test_number = jerry_create_number (test_double_numbers[j]);
    #####:  355:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  356:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  357:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  358:
    #####:  359:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  360:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  361:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  362:
    #####:  363:          double epsilon = pow (10, -5);
    #####:  364:          double get_abs = fabs (jerry_get_number_value (get_result) - test_double_numbers[j]);
    #####:  365:          TEST_ASSERT (get_abs < epsilon);
        -:  366:
    #####:  367:          jerry_release_value (test_number);
    #####:  368:          jerry_release_value (set_result);
    #####:  369:          jerry_release_value (get_result);
        -:  370:
        -:  371:          /* Testing positive and negative infinity */
    #####:  372:          for (uint8_t k = 0; k < 2; k++)
        -:  373:          {
    #####:  374:            jerry_value_t inf = jerry_create_number_infinity (k);
    #####:  375:            jerry_value_t set_inf = jerry_set_property_by_index (typedarray, 0, inf);
    #####:  376:            TEST_ASSERT (jerry_value_is_boolean (set_inf));
    #####:  377:            TEST_ASSERT (jerry_value_is_true (set_inf));
    #####:  378:            jerry_value_t get_inf = jerry_get_property_by_index (typedarray, 0);
    #####:  379:            TEST_ASSERT (isinf (jerry_get_number_value (get_inf)));
        -:  380:
    #####:  381:            jerry_release_value (inf);
    #####:  382:            jerry_release_value (set_inf);
    #####:  383:            jerry_release_value (get_inf);
        -:  384:          }
        -:  385:        }
        -:  386:        break;
        -:  387:      }
        -:  388:      case JERRY_TYPEDARRAY_BIGINT64:
        -:  389:      {
    #####:  390:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  391:        {
    #####:  392:          test_number = jerry_create_bigint ((uint64_t *) &test_int64_numbers[j], 1, true);
    #####:  393:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  394:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  395:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  396:
    #####:  397:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  398:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  399:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  400:          int64_t get_number;
        -:  401:          bool sign;
    #####:  402:          jerry_get_bigint_digits (get_result, (uint64_t *) &get_number, 1, &sign);
        -:  403:
    #####:  404:          TEST_ASSERT (sign ? get_number : -get_number == test_int64_numbers[j]);
        -:  405:
    #####:  406:          jerry_release_value (test_number);
    #####:  407:          jerry_release_value (set_result);
    #####:  408:          jerry_release_value (get_result);
        -:  409:        }
        -:  410:        break;
        -:  411:      }
        -:  412:      case JERRY_TYPEDARRAY_BIGUINT64:
        -:  413:      {
    #####:  414:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  415:        {
    #####:  416:          test_number = jerry_create_bigint (&test_uint64_numbers[j], 1, false);
    #####:  417:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  418:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  419:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  420:
    #####:  421:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  422:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  423:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  424:          uint64_t get_number;
        -:  425:          bool sign;
    #####:  426:          jerry_get_bigint_digits (get_result, &get_number, 1, &sign);
        -:  427:
    #####:  428:          TEST_ASSERT (get_number == test_uint64_numbers[j]);
        -:  429:
    #####:  430:          jerry_release_value (test_number);
    #####:  431:          jerry_release_value (set_result);
    #####:  432:          jerry_release_value (get_result);
        -:  433:        }
        -:  434:        break;
        -:  435:      }
        -:  436:      default:
        -:  437:      {
    #####:  438:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  439:        {
    #####:  440:          test_number = jerry_create_number (test_uint_numbers[j]);
    #####:  441:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  442:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  443:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  444:
    #####:  445:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  446:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  447:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  448:          TEST_ASSERT (jerry_get_number_value (get_result) == test_uint_numbers[j]);
        -:  449:
    #####:  450:          jerry_release_value (test_number);
    #####:  451:          jerry_release_value (set_result);
    #####:  452:          jerry_release_value (get_result);
        -:  453:        }
        -:  454:        break;
        -:  455:      }
        -:  456:    }
        -:  457:
    #####:  458:    jerry_value_t set_undefined = jerry_set_property_by_index (typedarray, 100, jerry_create_number (50));
        -:  459:
    #####:  460:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  461:    {
    #####:  462:      TEST_ASSERT (jerry_value_is_error (set_undefined));
        -:  463:    }
        -:  464:    else
        -:  465:    {
    #####:  466:      TEST_ASSERT (jerry_value_is_boolean (set_undefined) && !jerry_value_is_true (set_undefined));
        -:  467:    }
        -:  468:
    #####:  469:    jerry_value_t get_undefined = jerry_get_property_by_index (typedarray, 100);
        -:  470:
    #####:  471:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  472:    {
    #####:  473:      TEST_ASSERT (jerry_value_is_error (set_undefined));
        -:  474:    }
        -:  475:    else
        -:  476:    {
    #####:  477:      TEST_ASSERT (jerry_value_is_undefined (get_undefined));
        -:  478:    }
        -:  479:
    #####:  480:    TEST_ASSERT (jerry_value_is_undefined (get_undefined));
    #####:  481:    jerry_release_value (set_undefined);
    #####:  482:    jerry_release_value (get_undefined);
    #####:  483:    jerry_release_value (typedarray);
        -:  484:  }
    #####:  485:} /* test_property_by_index */
        -:  486:
        -:  487:static void
    #####:  488:test_detached_arraybuffer (void)
        -:  489:{
        -:  490:  static jerry_typedarray_type_t types[] =
        -:  491:  {
        -:  492:    JERRY_TYPEDARRAY_UINT8,
        -:  493:    JERRY_TYPEDARRAY_UINT8CLAMPED,
        -:  494:    JERRY_TYPEDARRAY_INT8,
        -:  495:    JERRY_TYPEDARRAY_UINT16,
        -:  496:    JERRY_TYPEDARRAY_INT16,
        -:  497:    JERRY_TYPEDARRAY_UINT32,
        -:  498:    JERRY_TYPEDARRAY_INT32,
        -:  499:    JERRY_TYPEDARRAY_FLOAT32,
        -:  500:    JERRY_TYPEDARRAY_FLOAT64,
        -:  501:    JERRY_TYPEDARRAY_BIGINT64,
        -:  502:    JERRY_TYPEDARRAY_BIGUINT64,
        -:  503:  };
        -:  504:
        -:  505:  /* Creating an TypedArray for a detached array buffer with a given length/offset is invalid */
        -:  506:  {
        -:  507:    uint8_t buf[1];
    #####:  508:    const uint32_t length = 1;
    #####:  509:    jerry_value_t arraybuffer = jerry_create_arraybuffer_external (length, buf, NULL);
    #####:  510:    TEST_ASSERT (!jerry_value_is_error (arraybuffer));
    #####:  511:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  512:    TEST_ASSERT (jerry_get_arraybuffer_byte_length (arraybuffer) == length);
        -:  513:
    #####:  514:    jerry_value_t is_detachable = jerry_is_arraybuffer_detachable (arraybuffer);
    #####:  515:    TEST_ASSERT (!jerry_value_is_error (is_detachable));
    #####:  516:    TEST_ASSERT (jerry_value_is_true (is_detachable));
    #####:  517:    jerry_release_value (is_detachable);
        -:  518:
    #####:  519:    jerry_value_t res = jerry_detach_arraybuffer (arraybuffer);
    #####:  520:    TEST_ASSERT (!jerry_value_is_error (res));
    #####:  521:    jerry_release_value (res);
        -:  522:
    #####:  523:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  524:    {
    #####:  525:      jerry_value_t typedarray = jerry_create_typedarray_for_arraybuffer_sz (types[idx], arraybuffer, 0, 4);
    #####:  526:      TEST_ASSERT (jerry_value_is_error (typedarray));
    #####:  527:      TEST_ASSERT (jerry_get_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  528:      jerry_release_value (typedarray);
        -:  529:    }
        -:  530:
    #####:  531:    jerry_release_value (arraybuffer);
        -:  532:  }
        -:  533:
        -:  534:  /* Creating an TypedArray for a detached array buffer without length/offset is valid */
        -:  535:  {
        -:  536:    uint8_t buf[1];
    #####:  537:    const uint32_t length = 1;
    #####:  538:    jerry_value_t arraybuffer = jerry_create_arraybuffer_external (length, buf, NULL);
    #####:  539:    TEST_ASSERT (!jerry_value_is_error (arraybuffer));
    #####:  540:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  541:    TEST_ASSERT (jerry_get_arraybuffer_byte_length (arraybuffer) == length);
        -:  542:
    #####:  543:    jerry_value_t is_detachable = jerry_is_arraybuffer_detachable (arraybuffer);
    #####:  544:    TEST_ASSERT (!jerry_value_is_error (is_detachable));
    #####:  545:    TEST_ASSERT (jerry_value_is_true (is_detachable));
    #####:  546:    jerry_release_value (is_detachable);
        -:  547:
    #####:  548:    jerry_value_t res = jerry_detach_arraybuffer (arraybuffer);
    #####:  549:    TEST_ASSERT (!jerry_value_is_error (res));
    #####:  550:    jerry_release_value (res);
        -:  551:
    #####:  552:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  553:    {
    #####:  554:      jerry_value_t typedarray = jerry_create_typedarray_for_arraybuffer (types[idx], arraybuffer);
    #####:  555:      TEST_ASSERT (jerry_value_is_error (typedarray));
    #####:  556:      TEST_ASSERT (jerry_get_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  557:      jerry_release_value (typedarray);
        -:  558:    }
        -:  559:
    #####:  560:    jerry_release_value (arraybuffer);
        -:  561:  }
    #####:  562:} /* test_detached_arraybuffer */
        -:  563:
        -:  564:int
    #####:  565:main (void)
        -:  566:{
    #####:  567:  jerry_init (JERRY_INIT_EMPTY);
        -:  568:
    #####:  569:  if (!jerry_is_feature_enabled (JERRY_FEATURE_TYPEDARRAY))
        -:  570:  {
    #####:  571:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TypedArray is disabled!\n");
    #####:  572:    jerry_cleanup ();
    #####:  573:    return 0;
        -:  574:  }
        -:  575:
    #####:  576:  jerry_value_t function_val = jerry_create_external_function (assert_handler);
    #####:  577:  register_js_value ("assert", function_val);
    #####:  578:  jerry_release_value (function_val);
        -:  579:
    #####:  580:  test_entry_t test_entries[] =
        -:  581:  {
        -:  582:#define TEST_ENTRY(TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT) \
        -:  583:      { TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT }
        -:  584:
        -:  585:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8,        "Uint8Array",        12, 1),
        -:  586:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8CLAMPED, "Uint8ClampedArray", 12, 1),
        -:  587:    TEST_ENTRY (JERRY_TYPEDARRAY_INT8,         "Int8Array",         12, 1),
        -:  588:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16,       "Uint16Array",       12, 2),
        -:  589:    TEST_ENTRY (JERRY_TYPEDARRAY_INT16,        "Int16Array",        12, 2),
        -:  590:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16,       "Uint16Array",       12, 2),
        -:  591:    TEST_ENTRY (JERRY_TYPEDARRAY_INT32,        "Int32Array",        12, 4),
        -:  592:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT32,       "Uint32Array",       12, 4),
        -:  593:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT32,      "Float32Array",      12, 4),
        -:  594:  /* TODO: add check if the float64 is supported */
        -:  595:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT64,      "Float64Array",      12, 8),
        -:  596:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGINT64,     "BigInt64Array",     12, 8),
        -:  597:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGUINT64,    "BigUint64Array",    12, 8),
        -:  598:
        -:  599:    TEST_ENTRY (JERRY_TYPEDARRAY_INVALID, NULL, 0, 0)
        -:  600:#undef TEST_ENTRY
        -:  601:  };
        -:  602:
        -:  603:  /* Test TypedArray queries */
    #####:  604:  test_typedarray_queries (test_entries);
        -:  605:
        -:  606:  /* Test TypedArray operations in js */
        -:  607:  {
    #####:  608:    const uint32_t element_count = 14;
        -:  609:
    #####:  610:    jerry_value_t array = jerry_create_typedarray (JERRY_TYPEDARRAY_UINT8, element_count);
        -:  611:
    #####:  612:    {
    #####:  613:      uint8_t expected_value = 42;
    #####:  614:      JERRY_VLA (uint8_t, expected_data, element_count);
    #####:  615:      memset (expected_data, expected_value, element_count);
        -:  616:
        -:  617:      jerry_length_t byte_length;
        -:  618:      jerry_length_t offset;
    #####:  619:      jerry_value_t buffer = jerry_get_typedarray_buffer (array, &offset, &byte_length);
    #####:  620:      TEST_ASSERT (byte_length == element_count);
    #####:  621:      jerry_length_t written = jerry_arraybuffer_write (buffer, offset, expected_data, element_count);
    #####:  622:      TEST_ASSERT (written == element_count);
    #####:  623:      jerry_release_value (buffer);
        -:  624:
    #####:  625:      jerry_value_t js_element_count = jerry_create_number (element_count);
    #####:  626:      jerry_value_t js_expected_value = jerry_create_number (expected_value);
        -:  627:
    #####:  628:      register_js_value ("array", array);
    #####:  629:      register_js_value ("expected_length", js_element_count);
    #####:  630:      register_js_value ("expected_value", js_expected_value);
        -:  631:
    #####:  632:      jerry_release_value (js_element_count);
    #####:  633:      jerry_release_value (js_expected_value);
        -:  634:    }
        -:  635:
        -:  636:    /* Check read and to write */
    #####:  637:    const jerry_char_t eval_src[] = TEST_STRING_LITERAL (
        -:  638:      "assert (array.length == expected_length, 'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  639:      "for (var i = 0; i < array.length; i++)"
        -:  640:      "{"
        -:  641:      "  assert (array[i] == expected_value);"
        -:  642:      "  array[i] = i;"
        -:  643:      "};"
        -:  644:    );
    #####:  645:    jerry_value_t result = jerry_eval (eval_src,
        -:  646:                                       sizeof (eval_src) - 1,
        -:  647:                                       JERRY_PARSE_STRICT_MODE);
        -:  648:
    #####:  649:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  650:    jerry_release_value (result);
        -:  651:
        -:  652:    /* Check write results */
    #####:  653:    {
        -:  654:      jerry_length_t byte_length;
        -:  655:      jerry_length_t offset;
    #####:  656:      jerry_value_t buffer = jerry_get_typedarray_buffer (array, &offset, &byte_length);
    #####:  657:      TEST_ASSERT (byte_length == element_count);
        -:  658:
    #####:  659:      JERRY_VLA (uint8_t, result_data, element_count);
        -:  660:
    #####:  661:      jerry_length_t read_count = jerry_arraybuffer_read (buffer, offset, result_data, byte_length);
    #####:  662:      TEST_ASSERT (read_count == byte_length);
        -:  663:
    #####:  664:      for (uint8_t i = 0; i < read_count; i++)
        -:  665:      {
    #####:  666:        TEST_ASSERT (result_data[i] == i);
        -:  667:      }
        -:  668:
    #####:  669:      jerry_release_value (buffer);
        -:  670:    }
        -:  671:
    #####:  672:    jerry_release_value (array);
        -:  673:  }
        -:  674:
    #####:  675:  test_typedarray_complex_creation (test_entries, false);
    #####:  676:  test_typedarray_complex_creation (test_entries, true);
        -:  677:
    #####:  678:  test_property_by_index (test_entries);
        -:  679:
        -:  680:  /* test invalid things */
        -:  681:  {
    #####:  682:    jerry_value_t values[] =
        -:  683:    {
    #####:  684:      jerry_create_number (11),
    #####:  685:      jerry_create_boolean (false),
    #####:  686:      jerry_create_string ((const jerry_char_t *) "test"),
    #####:  687:      jerry_create_object (),
    #####:  688:      jerry_create_null (),
    #####:  689:      jerry_create_arraybuffer (16),
    #####:  690:      jerry_create_error (JERRY_ERROR_TYPE, (const jerry_char_t *) "error"),
    #####:  691:      jerry_create_undefined (),
    #####:  692:      jerry_create_promise (),
        -:  693:    };
        -:  694:
    #####:  695:    for (size_t idx = 0; idx < sizeof (values) / sizeof (values[0]); idx++)
        -:  696:    {
        -:  697:      /* A non-TypedArray object should not be regarded a TypedArray. */
    #####:  698:      bool is_typedarray = jerry_value_is_typedarray (values[idx]);
    #####:  699:      TEST_ASSERT (is_typedarray == false);
        -:  700:
        -:  701:      /* JERRY_TYPEDARRAY_INVALID should be returned for non-TypedArray objects */
    #####:  702:      jerry_typedarray_type_t type = jerry_get_typedarray_type (values[idx]);
    #####:  703:      TEST_ASSERT (type == JERRY_TYPEDARRAY_INVALID);
        -:  704:
        -:  705:      /* Zero should be returned for non-TypedArray objects */
    #####:  706:      jerry_length_t length = jerry_get_typedarray_length (values[idx]);
    #####:  707:      TEST_ASSERT (length == 0);
        -:  708:
        -:  709:      /**
        -:  710:       * Getting the ArrayBuffer from a non-TypedArray object(s) should return an error
        -:  711:       * and should not modify the output parameter values.
        -:  712:       */
        -:  713:      {
    #####:  714:        jerry_length_t offset = 22;
    #####:  715:        jerry_length_t byte_count = 23;
    #####:  716:        jerry_value_t error = jerry_get_typedarray_buffer (values[idx], &offset, &byte_count);
    #####:  717:        TEST_ASSERT (jerry_value_is_error (error));
    #####:  718:        TEST_ASSERT (offset == 22);
    #####:  719:        TEST_ASSERT (byte_count == 23);
    #####:  720:        jerry_release_value (error);
        -:  721:      }
        -:  722:
        -:  723:      /**
        -:  724:       * Creating a TypedArray from a non-ArrayBuffer should result an error.
        -:  725:       */
    #####:  726:      if (!jerry_value_is_arraybuffer (values[idx]))
        -:  727:      {
    #####:  728:        jerry_value_t error = jerry_create_typedarray_for_arraybuffer (JERRY_TYPEDARRAY_UINT8, values[idx]);
    #####:  729:        TEST_ASSERT (jerry_value_is_error (error));
    #####:  730:        jerry_release_value (error);
        -:  731:      }
        -:  732:
    #####:  733:      jerry_release_value (values[idx]);
        -:  734:    }
        -:  735:  }
        -:  736:
    #####:  737:  test_detached_arraybuffer ();
        -:  738:
    #####:  739:  jerry_cleanup ();
        -:  740:
    #####:  741:  return 0;
        -:  742:} /* main */
