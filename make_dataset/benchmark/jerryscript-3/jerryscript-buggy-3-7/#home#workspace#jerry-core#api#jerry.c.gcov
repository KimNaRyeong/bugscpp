        -:    0:Source:/home/workspace/jerry-core/api/jerry.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:#include <math.h>
        -:   18:
        -:   19:#include "debugger.h"
        -:   20:#include "ecma-alloc.h"
        -:   21:#include "ecma-array-object.h"
        -:   22:#include "ecma-arraybuffer-object.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-builtin-helpers.h"
        -:   25:#include "ecma-builtins.h"
        -:   26:#include "ecma-comparison.h"
        -:   27:#include "ecma-container-object.h"
        -:   28:#include "ecma-dataview-object.h"
        -:   29:#include "ecma-eval.h"
        -:   30:#include "ecma-exceptions.h"
        -:   31:#include "ecma-extended-info.h"
        -:   32:#include "ecma-function-object.h"
        -:   33:#include "ecma-gc.h"
        -:   34:#include "ecma-helpers.h"
        -:   35:#include "ecma-init-finalize.h"
        -:   36:#include "ecma-iterator-object.h"
        -:   37:#include "ecma-lex-env.h"
        -:   38:#include "ecma-line-info.h"
        -:   39:#include "ecma-literal-storage.h"
        -:   40:#include "ecma-objects.h"
        -:   41:#include "ecma-objects-general.h"
        -:   42:#include "ecma-regexp-object.h"
        -:   43:#include "ecma-promise-object.h"
        -:   44:#include "ecma-proxy-object.h"
        -:   45:#include "ecma-shared-arraybuffer-object.h"
        -:   46:#include "ecma-symbol-object.h"
        -:   47:#include "ecma-typedarray-object.h"
        -:   48:#include "jcontext.h"
        -:   49:#include "jerryscript.h"
        -:   50:#include "jerryscript-debugger-transport.h"
        -:   51:#include "jmem.h"
        -:   52:#include "js-parser.h"
        -:   53:#include "lit-char-helpers.h"
        -:   54:#include "opcodes.h"
        -:   55:#include "re-compiler.h"
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   58:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   59:
        -:   60:#if JERRY_BUILTIN_REGEXP
        -:   61:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   62:                     && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   63:                     && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE
        -:   64:                     && (int) RE_FLAG_STICKY== (int) JERRY_REGEXP_FLAG_STICKY
        -:   65:                     && (int) RE_FLAG_UNICODE == (int) JERRY_REGEXP_FLAG_UNICODE
        -:   66:                     && (int) RE_FLAG_DOTALL == (int) JERRY_REGEXP_FLAG_DOTALL,
        -:   67:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   68:#endif /* JERRY_BUILTIN_REGEXP */
        -:   69:
        -:   70:#if JERRY_ESNEXT
        -:   71:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   72:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   73:                     && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   74:                     promise_internal_state_matches_external);
        -:   75:#endif /* JERRY_ESNEXT */
        -:   76:
        -:   77:/**
        -:   78: * Offset between internal and external arithmetic operator types
        -:   79: */
        -:   80:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   81:
        -:   82:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   83:                     && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_MUL)
        -:   84:                     && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   85:                     && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   86:                     number_arithmetics_operation_type_matches_external);
        -:   87:
        -:   88:#if !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC
        -:   89:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   90:#endif /* !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC */
        -:   91:
        -:   92:/** \addtogroup jerry Jerry engine interface
        -:   93: * @{
        -:   94: */
        -:   95:
        -:   96:/**
        -:   97: * Assert that it is correct to call API in current state.
        -:   98: *
        -:   99: * Note:
        -:  100: *         By convention, there are some states when API could not be invoked.
        -:  101: *
        -:  102: *         The API can be and only be invoked when the ECMA_STATUS_API_AVAILABLE
        -:  103: *         flag is set.
        -:  104: *
        -:  105: *         This procedure checks whether the API is available, and terminates
        -:  106: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  107: *
        -:  108: * Note:
        -:  109: *         The API could not be invoked in the following cases:
        -:  110: *           - before jerry_init and after jerry_cleanup
        -:  111: *           - between enter to and return from a native free callback
        -:  112: */
        -:  113:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  114:jerry_assert_api_available (void)
        -:  115:{
       58:  116:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);
        -:  117:} /* jerry_assert_api_available */
        -:  118:
        -:  119:/**
        -:  120: * Turn on API availability
        -:  121: */
        -:  122:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  123:jerry_make_api_available (void)
        -:  124:{
        1:  125:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;
        -:  126:} /* jerry_make_api_available */
        -:  127:
        -:  128:/**
        -:  129: * Turn off API availability
        -:  130: */
        -:  131:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  132:jerry_make_api_unavailable (void)
        -:  133:{
        1:  134:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_AVAILABLE;
        -:  135:} /* jerry_make_api_unavailable */
        -:  136:
        -:  137:/**
        -:  138: * Create an API compatible return value.
        -:  139: *
        -:  140: * @return return value for Jerry API functions
        -:  141: */
        -:  142:static jerry_value_t
        6:  143:jerry_return (jerry_value_t value) /**< return value */
        -:  144:{
        6:  145:  if (ECMA_IS_VALUE_ERROR (value))
        -:  146:  {
    #####:  147:    value = ecma_create_error_reference_from_context ();
        -:  148:  }
        -:  149:
        6:  150:  return value;
        -:  151:} /* jerry_return */
        -:  152:
        -:  153:/**
        -:  154: * Throw an API compatible return value.
        -:  155: *
        -:  156: * @return return value for Jerry API functions
        -:  157: */
        -:  158:static inline jerry_value_t JERRY_ATTR_ALWAYS_INLINE
        -:  159:jerry_throw (jerry_value_t value) /**< return value */
        -:  160:{
    #####:  161:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (value));
    #####:  162:  return ecma_create_error_reference_from_context ();
        -:  163:} /* jerry_throw */
        -:  164:
        -:  165:/**
        -:  166: * Jerry engine initialization
        -:  167: */
        -:  168:void
        1:  169:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  170:{
        -:  171:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  172:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));
        -:  173:
        -:  174:  /* Zero out all non-external members. */
        1:  175:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,
        -:  176:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  177:
        1:  178:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  179:
        -:  180:  jerry_make_api_available ();
        -:  181:
        1:  182:  jmem_init ();
        1:  183:  ecma_init ();
        1:  184:} /* jerry_init */
        -:  185:
        -:  186:/**
        -:  187: * Terminate Jerry engine
        -:  188: */
        -:  189:void
        1:  190:jerry_cleanup (void)
        -:  191:{
        -:  192:  jerry_assert_api_available ();
        -:  193:
        -:  194:#if JERRY_DEBUGGER
        -:  195:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  196:  {
        -:  197:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  198:
        -:  199:    jerry_debugger_transport_close ();
        -:  200:  }
        -:  201:#endif /* JERRY_DEBUGGER */
        -:  202:
        2:  203:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p);
        -:  204:       this_p != NULL;
    #####:  205:       this_p = this_p->next_p)
        -:  206:  {
    #####:  207:    if (this_p->manager_p->deinit_cb)
        -:  208:    {
    #####:  209:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  210:      this_p->manager_p->deinit_cb (data);
        -:  211:    }
        -:  212:  }
        -:  213:
        -:  214:#if JERRY_ESNEXT
        1:  215:  ecma_free_all_enqueued_jobs ();
        -:  216:#endif /* JERRY_ESNEXT */
        1:  217:  ecma_finalize ();
        -:  218:  jerry_make_api_unavailable ();
        -:  219:
        2:  220:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL;
        -:  221:       this_p != NULL;
    #####:  222:       this_p = next_p)
        -:  223:  {
    #####:  224:    next_p = this_p->next_p;
    #####:  225:    if (this_p->manager_p->finalize_cb)
        -:  226:    {
    #####:  227:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  228:      this_p->manager_p->finalize_cb (data);
        -:  229:    }
    #####:  230:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  231:  }
        -:  232:
        1:  233:  jmem_finalize ();
    #####:  234:} /* jerry_cleanup */
        -:  235:
        -:  236:/**
        -:  237: * Retrieve a context data item, or create a new one.
        -:  238: *
        -:  239: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  240: *
        -:  241: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  242: * none was found.
        -:  243: */
        -:  244:void *
    #####:  245:jerry_get_context_data (const jerry_context_data_manager_t *manager_p)
        -:  246:{
    #####:  247:  void *ret = NULL;
        -:  248:  jerry_context_data_header_t *item_p;
        -:  249:
    #####:  250:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  251:  {
    #####:  252:    if (item_p->manager_p == manager_p)
        -:  253:    {
    #####:  254:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  255:    }
        -:  256:  }
        -:  257:
    #####:  258:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  259:  item_p->manager_p = manager_p;
    #####:  260:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  261:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  262:
    #####:  263:  if (manager_p->bytes_needed > 0)
        -:  264:  {
    #####:  265:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  266:    memset (ret, 0, manager_p->bytes_needed);
        -:  267:  }
        -:  268:
    #####:  269:  if (manager_p->init_cb)
        -:  270:  {
    #####:  271:    manager_p->init_cb (ret);
        -:  272:  }
        -:  273:
    #####:  274:  return ret;
        -:  275:} /* jerry_get_context_data */
        -:  276:
        -:  277:/**
        -:  278: * Register external magic string array
        -:  279: */
        -:  280:void
    #####:  281:jerry_register_magic_strings (const jerry_char_t * const *ex_str_items_p, /**< character arrays, representing
        -:  282:                                                                           *   external magic strings' contents */
        -:  283:                              uint32_t count, /**< number of the strings */
        -:  284:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  285:{
        -:  286:  jerry_assert_api_available ();
        -:  287:
    #####:  288:  lit_magic_strings_ex_set ((const lit_utf8_byte_t * const *) ex_str_items_p,
        -:  289:                            count,
        -:  290:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  291:} /* jerry_register_magic_strings */
        -:  292:
        -:  293:/**
        -:  294: * Run garbage collection
        -:  295: */
        -:  296:void
    #####:  297:jerry_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  298:{
        -:  299:  jerry_assert_api_available ();
        -:  300:
    #####:  301:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  302:  {
        -:  303:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  304:    ecma_gc_run ();
    #####:  305:    return;
        -:  306:  }
        -:  307:
    #####:  308:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  309:} /* jerry_gc */
        -:  310:
        -:  311:/**
        -:  312: * Get heap memory stats.
        -:  313: *
        -:  314: * @return true - get the heap stats successful
        -:  315: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  316: */
        -:  317:bool
    #####:  318:jerry_get_memory_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  319:{
        -:  320:#if JERRY_MEM_STATS
    #####:  321:  if (out_stats_p == NULL)
        -:  322:  {
        -:  323:    return false;
        -:  324:  }
        -:  325:
        -:  326:  jmem_heap_stats_t jmem_heap_stats;
    #####:  327:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  328:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  329:
    #####:  330:  *out_stats_p = (jerry_heap_stats_t)
        -:  331:  {
        -:  332:    .version = 1,
    #####:  333:    .size = jmem_heap_stats.size,
    #####:  334:    .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  335:    .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes
        -:  336:  };
        -:  337:
    #####:  338:  return true;
        -:  339:#else /* !JERRY_MEM_STATS */
        -:  340:  JERRY_UNUSED (out_stats_p);
    #####:  341:  return false;
        -:  342:#endif /* JERRY_MEM_STATS */
        -:  343:} /* jerry_get_memory_stats */
        -:  344:
        -:  345:/**
        -:  346: * Simple Jerry runner
        -:  347: *
        -:  348: * @return true  - if run was successful
        -:  349: *         false - otherwise
        -:  350: */
        -:  351:bool
    #####:  352:jerry_run_simple (const jerry_char_t *script_source_p, /**< script source */
        -:  353:                  size_t script_source_size, /**< script source size */
        -:  354:                  jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  355:{
    #####:  356:  bool result = false;
        -:  357:
    #####:  358:  jerry_init (flags);
        -:  359:
    #####:  360:  jerry_value_t parse_ret_val = jerry_parse (script_source_p, script_source_size, NULL);
        -:  361:
    #####:  362:  if (!ecma_is_value_error_reference (parse_ret_val))
        -:  363:  {
    #####:  364:    jerry_value_t run_ret_val = jerry_run (parse_ret_val);
        -:  365:
    #####:  366:    if (!ecma_is_value_error_reference (run_ret_val))
        -:  367:    {
    #####:  368:      result = true;
        -:  369:    }
        -:  370:
    #####:  371:    jerry_release_value (run_ret_val);
        -:  372:  }
        -:  373:
    #####:  374:  jerry_release_value (parse_ret_val);
    #####:  375:  jerry_cleanup ();
        -:  376:
    #####:  377:  return result;
        -:  378:} /* jerry_run_simple */
        -:  379:
        -:  380:#if JERRY_PARSER
        -:  381:
        -:  382:/**
        -:  383: * Common code for parsing a script, module, or function.
        -:  384: *
        -:  385: * @return function object value - if script was parsed successfully,
        -:  386: *         thrown error - otherwise
        -:  387: */
        -:  388:static jerry_value_t
        1:  389:jerry_parse_common (void *source_p, /**< script source */
        -:  390:                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */
        -:  391:                    uint32_t parse_opts) /**< internal parsing options */
        -:  392:{
        -:  393:  jerry_assert_api_available ();
        -:  394:
        1:  395:  if (options_p != NULL)
        -:  396:  {
        1:  397:    const uint32_t allowed_options = (JERRY_PARSE_STRICT_MODE
        -:  398:                                      | JERRY_PARSE_MODULE
        -:  399:                                      | JERRY_PARSE_HAS_ARGUMENT_LIST
        -:  400:                                      | JERRY_PARSE_HAS_RESOURCE
        -:  401:                                      | JERRY_PARSE_HAS_START
        -:  402:                                      | JERRY_PARSE_HAS_USER_VALUE);
        1:  403:    uint32_t options = options_p->options;
        -:  404:
        1:  405:    if ((options & ~allowed_options) != 0
        1:  406:        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)
    #####:  407:            && ((options_p->options & JERRY_PARSE_MODULE)
    #####:  408:                || !ecma_is_value_string (options_p->argument_list)))
        1:  409:        || ((options_p->options & JERRY_PARSE_HAS_RESOURCE)
        1:  410:            && !ecma_is_value_string (options_p->resource_name)))
        -:  411:    {
    #####:  412:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  413:    }
        -:  414:  }
        -:  415:
        -:  416:#if JERRY_DEBUGGER
        -:  417:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  418:      && options_p != NULL
        -:  419:      && (options_p->options & JERRY_PARSE_HAS_RESOURCE)
        -:  420:      && ecma_is_value_string (options_p->resource_name))
        -:  421:  {
        -:  422:    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->resource_name),
        -:  423:                                resource_name_start_p,
        -:  424:                                resource_name_size);
        -:  425:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  426:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  427:                                resource_name_start_p,
        -:  428:                                resource_name_size);
        -:  429:    ECMA_FINALIZE_UTF8_STRING (resource_name_start_p, resource_name_size);
        -:  430:  }
        -:  431:#endif /* JERRY_DEBUGGER */
        -:  432:
        1:  433:  if (options_p != NULL)
        -:  434:  {
        1:  435:    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);
        -:  436:  }
        -:  437:
        1:  438:  if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  439:  {
        -:  440:#if JERRY_MODULE_SYSTEM
    #####:  441:    JERRY_CONTEXT (module_current_p) = ecma_module_create ();
        -:  442:#else /* !JERRY_MODULE_SYSTEM */
    #####:  443:    return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  444:#endif /* JERRY_MODULE_SYSTEM */
        -:  445:  }
        -:  446:
        -:  447:  ecma_compiled_code_t *bytecode_data_p;
        1:  448:  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);
        -:  449:
        1:  450:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  451:  {
        -:  452:#if JERRY_MODULE_SYSTEM
    #####:  453:    if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  454:    {
    #####:  455:      ecma_module_cleanup_context ();
        -:  456:    }
        -:  457:#endif /* JERRY_MODULE_SYSTEM */
        -:  458:
    #####:  459:    return ecma_create_error_reference_from_context ();
        -:  460:  }
        -:  461:
        -:  462:#if JERRY_MODULE_SYSTEM
        1:  463:  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))
        -:  464:  {
    #####:  465:    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);
    #####:  466:    module_p->u.compiled_code_p = bytecode_data_p;
        -:  467:
    #####:  468:    JERRY_CONTEXT (module_current_p) = NULL;
        -:  469:
    #####:  470:    return ecma_make_object_value ((ecma_object_t *) module_p);
        -:  471:  }
        -:  472:#endif /* JERRY_MODULE_SYSTEM */
        -:  473:
        1:  474:  if (JERRY_UNLIKELY (options_p != NULL
        -:  475:                      && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))
        -:  476:  {
    #####:  477:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -:  478:
        -:  479:#if JERRY_BUILTIN_REALMS
    #####:  480:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));
        -:  481:#endif /* JERRY_BUILTIN_REALMS */
        -:  482:
    #####:  483:    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);
    #####:  484:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  485:    ecma_bytecode_deref (bytecode_data_p);
        -:  486:
    #####:  487:    return ecma_make_object_value (func_obj_p);
        -:  488:  }
        -:  489:
        1:  490:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  491:
        1:  492:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  493:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;
        1:  494:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);
        -:  495:
        1:  496:  return ecma_make_object_value (object_p);
        -:  497:} /* jerry_parse_common */
        -:  498:
        -:  499:#endif /* JERRY_PARSER */
        -:  500:
        -:  501:/**
        -:  502: * Parse a script, module, or function and create a compiled code using a character string
        -:  503: *
        -:  504: * @return function object value - if script was parsed successfully,
        -:  505: *         thrown error - otherwise
        -:  506: */
        -:  507:jerry_value_t
        1:  508:jerry_parse (const jerry_char_t *source_p, /**< script source */
        -:  509:             size_t source_size, /**< script source size */
        -:  510:             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  511:{
        -:  512:#if JERRY_PARSER
        1:  513:  parser_source_char_t source_char;
        1:  514:  source_char.source_p = source_p;
        1:  515:  source_char.source_size = source_size;
        -:  516:
        1:  517:  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);
        -:  518:#else /* !JERRY_PARSER */
        -:  519:  JERRY_UNUSED (source_p);
        -:  520:  JERRY_UNUSED (source_size);
        -:  521:  JERRY_UNUSED (options_p);
        -:  522:
        -:  523:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  524:#endif /* JERRY_PARSER */
        -:  525:} /* jerry_parse */
        -:  526:
        -:  527:/**
        -:  528: * Parse a script, module, or function and create a compiled code using a string value
        -:  529: *
        -:  530: * @return function object value - if script was parsed successfully,
        -:  531: *         thrown error - otherwise
        -:  532: */
        -:  533:jerry_value_t
    #####:  534:jerry_parse_value (const jerry_value_t source_value, /**< script source */
        -:  535:                   const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  536:{
        -:  537:#if JERRY_PARSER
    #####:  538:  if (!ecma_is_value_string (source_value))
        -:  539:  {
    #####:  540:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  541:  }
        -:  542:
    #####:  543:  ecma_value_t source[1];
    #####:  544:  source[0] = source_value;
        -:  545:
    #####:  546:  return jerry_parse_common ((void *) source, options_p, ECMA_PARSE_HAS_SOURCE_VALUE);
        -:  547:#else /* !JERRY_PARSER */
        -:  548:  JERRY_UNUSED (source_value);
        -:  549:  JERRY_UNUSED (options_p);
        -:  550:
        -:  551:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  552:#endif /* JERRY_PARSER */
        -:  553:} /* jerry_parse_value */
        -:  554:
        -:  555:/**
        -:  556: * Run a Script or Module created by jerry_parse.
        -:  557: *
        -:  558: * Note:
        -:  559: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  560: *
        -:  561: * @return result of bytecode - if run was successful
        -:  562: *         thrown error - otherwise
        -:  563: */
        -:  564:jerry_value_t
        1:  565:jerry_run (const jerry_value_t func_val) /**< function to run */
        -:  566:{
        -:  567:  jerry_assert_api_available ();
        -:  568:
        1:  569:  if (!ecma_is_value_object (func_val))
        -:  570:  {
    #####:  571:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  572:  }
        -:  573:
        1:  574:  ecma_object_t *object_p = ecma_get_object_from_value (func_val);
        -:  575:
        1:  576:  if (ecma_get_object_type (object_p) != ECMA_OBJECT_TYPE_CLASS)
        -:  577:  {
    #####:  578:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  579:  }
        -:  580:
        1:  581:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  582:
        1:  583:  if (ext_object_p->u.cls.type != ECMA_OBJECT_CLASS_SCRIPT)
        -:  584:  {
    #####:  585:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  586:  }
        -:  587:
        -:  588:  const ecma_compiled_code_t *bytecode_data_p;
        1:  589:  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  590:
        1:  591:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);
        -:  592:
        1:  593:  return jerry_return (vm_run_global (bytecode_data_p));
        -:  594:} /* jerry_run */
        -:  595:
        -:  596:/**
        -:  597: * Perform eval
        -:  598: *
        -:  599: * Note:
        -:  600: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  601: *
        -:  602: * @return result of eval, may be error value.
        -:  603: */
        -:  604:jerry_value_t
    #####:  605:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  606:            size_t source_size, /**< length of source code */
        -:  607:            uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  608:{
        -:  609:  jerry_assert_api_available ();
        -:  610:
    #####:  611:  uint32_t allowed_parse_options = JERRY_PARSE_STRICT_MODE;
        -:  612:
    #####:  613:  if ((parse_opts & ~allowed_parse_options) != 0)
        -:  614:  {
    #####:  615:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  616:  }
        -:  617:
    #####:  618:  parser_source_char_t source_char;
    #####:  619:  source_char.source_p = source_p;
    #####:  620:  source_char.source_size = source_size;
        -:  621:
    #####:  622:  return jerry_return (ecma_op_eval_chars_buffer ((void *) &source_char, parse_opts));
        -:  623:} /* jerry_eval */
        -:  624:
        -:  625:/**
        -:  626: * Link modules to their dependencies. The dependencies are resolved by a user callback.
        -:  627: *
        -:  628: * Note:
        -:  629: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  630: *
        -:  631: * @return true - if linking is successful, error - otherwise
        -:  632: */
        -:  633:jerry_value_t
    #####:  634:jerry_module_link (const jerry_value_t module_val, /**< root module */
        -:  635:                   jerry_module_resolve_callback_t callback, /**< resolve module callback, uses
        -:  636:                                                              *   jerry_port_module_resolve when NULL is passed */
        -:  637:                   void *user_p) /**< pointer passed to the resolve callback */
        -:  638:{
        -:  639:  jerry_assert_api_available ();
        -:  640:
        -:  641:#if JERRY_MODULE_SYSTEM
    #####:  642:  if (callback == NULL)
        -:  643:  {
    #####:  644:    callback = jerry_port_module_resolve;
        -:  645:  }
        -:  646:
    #####:  647:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  648:
    #####:  649:  if (module_p == NULL)
        -:  650:  {
    #####:  651:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  652:  }
        -:  653:
    #####:  654:  return jerry_return (ecma_module_link (module_p, callback, user_p));
        -:  655:#else /* !JERRY_MODULE_SYSTEM */
        -:  656:  JERRY_UNUSED (module_val);
        -:  657:  JERRY_UNUSED (callback);
        -:  658:  JERRY_UNUSED (user_p);
        -:  659:
    #####:  660:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  661:#endif /* JERRY_MODULE_SYSTEM */
        -:  662:} /* jerry_module_link */
        -:  663:
        -:  664:/**
        -:  665: * Evaluate a module and its dependencies. The module must be in linked state.
        -:  666: *
        -:  667: * Note:
        -:  668: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  669: *
        -:  670: * @return result of module bytecode execution - if evaluation was successful
        -:  671: *         error - otherwise
        -:  672: */
        -:  673:jerry_value_t
    #####:  674:jerry_module_evaluate (const jerry_value_t module_val) /**< root module */
        -:  675:{
        -:  676:  jerry_assert_api_available ();
        -:  677:
        -:  678:#if JERRY_MODULE_SYSTEM
    #####:  679:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  680:
    #####:  681:  if (module_p == NULL)
        -:  682:  {
    #####:  683:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  684:  }
        -:  685:
    #####:  686:  if (module_p->header.u.cls.u1.module_state != JERRY_MODULE_STATE_LINKED)
        -:  687:  {
    #####:  688:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module must be in linked state")));
        -:  689:  }
        -:  690:
    #####:  691:  return jerry_return (ecma_module_evaluate (module_p));
        -:  692:#else /* !JERRY_MODULE_SYSTEM */
        -:  693:  JERRY_UNUSED (module_val);
        -:  694:
    #####:  695:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  696:#endif /* JERRY_MODULE_SYSTEM */
        -:  697:} /* jerry_module_evaluate */
        -:  698:
        -:  699:/**
        -:  700: * Returns the current status of a module
        -:  701: *
        -:  702: * @return current status - if module_val is a module,
        -:  703: *         JERRY_MODULE_STATE_INVALID - otherwise
        -:  704: */
        -:  705:jerry_module_state_t
    #####:  706:jerry_module_get_state (const jerry_value_t module_val) /**< module object */
        -:  707:{
        -:  708:  jerry_assert_api_available ();
        -:  709:
        -:  710:#if JERRY_MODULE_SYSTEM
    #####:  711:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  712:
    #####:  713:  if (module_p == NULL)
        -:  714:  {
    #####:  715:    return JERRY_MODULE_STATE_INVALID;
        -:  716:  }
        -:  717:
    #####:  718:  return (jerry_module_state_t) module_p->header.u.cls.u1.module_state;
        -:  719:#else /* !JERRY_MODULE_SYSTEM */
        -:  720:  JERRY_UNUSED (module_val);
        -:  721:
    #####:  722:  return JERRY_MODULE_STATE_INVALID;
        -:  723:#endif /* JERRY_MODULE_SYSTEM */
        -:  724:} /* jerry_module_get_state */
        -:  725:
        -:  726:/**
        -:  727: * Sets a callback which is called after a module state is changed to linked, evaluated, or error.
        -:  728: */
        -:  729:void
    #####:  730:jerry_module_set_state_changed_callback (jerry_module_state_changed_callback_t callback, /**< callback */
        -:  731:                                         void *user_p) /**< pointer passed to the callback */
        -:  732:{
        -:  733:  jerry_assert_api_available ();
        -:  734:
        -:  735:#if JERRY_MODULE_SYSTEM
    #####:  736:  JERRY_CONTEXT (module_state_changed_callback_p) = callback;
    #####:  737:  JERRY_CONTEXT (module_state_changed_callback_user_p) = user_p;
        -:  738:#else /* !JERRY_MODULE_SYSTEM */
        -:  739:  JERRY_UNUSED (callback);
        -:  740:  JERRY_UNUSED (user_p);
        -:  741:#endif /* JERRY_MODULE_SYSTEM */
    #####:  742:} /* jerry_module_set_state_changed_callback */
        -:  743:
        -:  744:/**
        -:  745: * Sets a callback which is called when an import.meta expression of a module is evaluated the first time.
        -:  746: */
        -:  747:void
    #####:  748:jerry_module_set_import_meta_callback (jerry_module_import_meta_callback_t callback, /**< callback */
        -:  749:                                       void *user_p) /**< pointer passed to the callback */
        -:  750:{
        -:  751:  jerry_assert_api_available ();
        -:  752:
        -:  753:#if JERRY_MODULE_SYSTEM
    #####:  754:  JERRY_CONTEXT (module_import_meta_callback_p) = callback;
    #####:  755:  JERRY_CONTEXT (module_import_meta_callback_user_p) = user_p;
        -:  756:#else /* !JERRY_MODULE_SYSTEM */
        -:  757:  JERRY_UNUSED (callback);
        -:  758:  JERRY_UNUSED (user_p);
        -:  759:#endif /* JERRY_MODULE_SYSTEM */
    #####:  760:} /* jerry_module_set_import_meta_callback */
        -:  761:
        -:  762:/**
        -:  763: * Returns the number of import/export requests of a module
        -:  764: *
        -:  765: * @return number of import/export requests of a module
        -:  766: */
        -:  767:size_t
    #####:  768:jerry_module_get_number_of_requests (const jerry_value_t module_val) /**< module */
        -:  769:{
        -:  770:  jerry_assert_api_available ();
        -:  771:
        -:  772:#if JERRY_MODULE_SYSTEM
    #####:  773:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  774:
    #####:  775:  if (module_p == NULL)
        -:  776:  {
    #####:  777:    return 0;
        -:  778:  }
        -:  779:
    #####:  780:  size_t number_of_requests = 0;
        -:  781:
    #####:  782:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  783:
    #####:  784:  while (node_p != NULL)
        -:  785:  {
    #####:  786:    number_of_requests++;
    #####:  787:    node_p = node_p->next_p;
        -:  788:  }
        -:  789:
    #####:  790:  return number_of_requests;
        -:  791:#else /* !JERRY_MODULE_SYSTEM */
        -:  792:  JERRY_UNUSED (module_val);
        -:  793:
    #####:  794:  return 0;
        -:  795:#endif /* JERRY_MODULE_SYSTEM */
        -:  796:} /* jerry_module_get_number_of_requests */
        -:  797:
        -:  798:/**
        -:  799: * Returns the module request specified by the request_index argument
        -:  800: *
        -:  801: * Note:
        -:  802: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  803: *
        -:  804: * @return string - if the request has not been resolved yet,
        -:  805: *         module object - if the request has been resolved successfully,
        -:  806: *         error - otherwise
        -:  807: */
        -:  808:jerry_value_t
    #####:  809:jerry_module_get_request (const jerry_value_t module_val, /**< module */
        -:  810:                          size_t request_index) /**< request index */
        -:  811:{
        -:  812:  jerry_assert_api_available ();
        -:  813:
        -:  814:#if JERRY_MODULE_SYSTEM
    #####:  815:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  816:
    #####:  817:  if (module_p == NULL)
        -:  818:  {
    #####:  819:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  820:  }
        -:  821:
    #####:  822:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  823:
    #####:  824:  while (node_p != NULL)
        -:  825:  {
    #####:  826:    if (request_index == 0)
        -:  827:    {
    #####:  828:      return ecma_copy_value (node_p->u.path_or_module);
        -:  829:    }
        -:  830:
    #####:  831:    --request_index;
    #####:  832:    node_p = node_p->next_p;
        -:  833:  }
        -:  834:
    #####:  835:  return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Request is not available")));
        -:  836:#else /* !JERRY_MODULE_SYSTEM */
        -:  837:  JERRY_UNUSED (module_val);
        -:  838:  JERRY_UNUSED (request_index);
        -:  839:
    #####:  840:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  841:#endif /* JERRY_MODULE_SYSTEM */
        -:  842:} /* jerry_module_get_request */
        -:  843:
        -:  844:/**
        -:  845: * Returns the namespace object of a module
        -:  846: *
        -:  847: * Note:
        -:  848: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  849: *
        -:  850: * @return object - if namespace object is available,
        -:  851: *         error - otherwise
        -:  852: */
        -:  853:jerry_value_t
    #####:  854:jerry_module_get_namespace (const jerry_value_t module_val) /**< module */
        -:  855:{
        -:  856:  jerry_assert_api_available ();
        -:  857:
        -:  858:#if JERRY_MODULE_SYSTEM
    #####:  859:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  860:
    #####:  861:  if (module_p == NULL)
        -:  862:  {
    #####:  863:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  864:  }
        -:  865:
    #####:  866:  if (module_p->header.u.cls.u1.module_state < JERRY_MODULE_STATE_LINKED
    #####:  867:      || module_p->header.u.cls.u1.module_state > JERRY_MODULE_STATE_EVALUATED)
        -:  868:  {
    #####:  869:    return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Namespace object is not available")));
        -:  870:  }
        -:  871:
    #####:  872:  JERRY_ASSERT (module_p->namespace_object_p != NULL);
        -:  873:
    #####:  874:  ecma_ref_object (module_p->namespace_object_p);
    #####:  875:  return ecma_make_object_value (module_p->namespace_object_p);
        -:  876:#else /* !JERRY_MODULE_SYSTEM */
        -:  877:  JERRY_UNUSED (module_val);
        -:  878:
    #####:  879:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  880:#endif /* JERRY_MODULE_SYSTEM */
        -:  881:} /* jerry_module_get_namespace */
        -:  882:
        -:  883:/**
        -:  884: * Sets the callback which is called when dynamic imports are resolved
        -:  885: */
        -:  886:void
    #####:  887:jerry_module_set_import_callback (jerry_module_import_callback_t callback_p, /**< callback which handles
        -:  888:                                                                              *   dynamic import calls */
        -:  889:                                  void *user_p) /**< user pointer passed to the callback */
        -:  890:{
        -:  891:  jerry_assert_api_available ();
        -:  892:
        -:  893:#if JERRY_MODULE_SYSTEM
    #####:  894:  JERRY_CONTEXT (module_import_callback_p) = callback_p;
    #####:  895:  JERRY_CONTEXT (module_import_callback_user_p) = user_p;
        -:  896:#else /* !JERRY_MODULE_SYSTEM */
        -:  897:  JERRY_UNUSED (callback_p);
        -:  898:  JERRY_UNUSED (user_p);
        -:  899:#endif /* JERRY_MODULE_SYSTEM */
    #####:  900:} /* jerry_module_set_import_callback */
        -:  901:
        -:  902:/**
        -:  903: * Creates a native module with a list of exports. The initial state of the module is linked.
        -:  904: *
        -:  905: * Note:
        -:  906: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  907: *
        -:  908: * @return native module - if the module is successfully created,
        -:  909: *         error - otherwise
        -:  910: */
        -:  911:jerry_value_t
    #####:  912:jerry_native_module_create (jerry_native_module_evaluate_callback_t callback, /**< evaluation callback for
        -:  913:                                                                               *   native modules */
        -:  914:                            const jerry_value_t * const exports_p, /**< list of the exported bindings of the module,
        -:  915:                                                                    *   must be valid string identifiers */
        -:  916:                            size_t number_of_exports) /**< number of exports in the exports_p list */
        -:  917:{
        -:  918:  jerry_assert_api_available ();
        -:  919:
        -:  920:#if JERRY_MODULE_SYSTEM
    #####:  921:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
    #####:  922:  ecma_object_t *scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:  923:  ecma_module_names_t *local_exports_p = NULL;
        -:  924:
    #####:  925:  for (size_t i = 0; i < number_of_exports; i++)
        -:  926:  {
    #####:  927:    if (!ecma_is_value_string (exports_p[i]))
        -:  928:    {
    #####:  929:      ecma_deref_object (scope_p);
    #####:  930:      ecma_module_release_module_names (local_exports_p);
    #####:  931:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be string values")));
        -:  932:    }
        -:  933:
    #####:  934:    ecma_string_t *name_str_p = ecma_get_string_from_value (exports_p[i]);
        -:  935:
    #####:  936:    bool valid_identifier = false;
        -:  937:
    #####:  938:    ECMA_STRING_TO_UTF8_STRING (name_str_p, name_start_p, name_size);
        -:  939:
    #####:  940:    if (name_size > 0)
        -:  941:    {
    #####:  942:      const lit_utf8_byte_t *name_p = name_start_p;
    #####:  943:      const lit_utf8_byte_t *name_end_p = name_start_p + name_size;
    #####:  944:      lit_code_point_t code_point;
        -:  945:
    #####:  946:      lit_utf8_size_t size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  947:
    #####:  948:      if (lit_code_point_is_identifier_start (code_point))
        -:  949:      {
    #####:  950:        name_p += size;
        -:  951:
    #####:  952:        valid_identifier = true;
        -:  953:
    #####:  954:        while (name_p < name_end_p)
        -:  955:        {
    #####:  956:          size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  957:
    #####:  958:          if (!lit_code_point_is_identifier_part (code_point))
        -:  959:          {
    #####:  960:            valid_identifier = false;
    #####:  961:            break;
        -:  962:          }
        -:  963:
    #####:  964:          name_p += size;
        -:  965:        }
        -:  966:      }
        -:  967:    }
        -:  968:
    #####:  969:    ECMA_FINALIZE_UTF8_STRING (name_start_p, name_size);
        -:  970:
    #####:  971:    if (!valid_identifier)
        -:  972:    {
    #####:  973:      ecma_deref_object (scope_p);
    #####:  974:      ecma_module_release_module_names (local_exports_p);
    #####:  975:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be valid identifiers")));
        -:  976:    }
        -:  977:
    #####:  978:    if (ecma_find_named_property (scope_p, name_str_p) != NULL)
        -:  979:    {
    #####:  980:      continue;
        -:  981:    }
        -:  982:
    #####:  983:    ecma_create_named_data_property (scope_p, name_str_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -:  984:
        -:  985:    ecma_module_names_t *new_export_p;
    #####:  986:    new_export_p = (ecma_module_names_t *) jmem_heap_alloc_block (sizeof (ecma_module_names_t));
        -:  987:
    #####:  988:    new_export_p->next_p = local_exports_p;
    #####:  989:    local_exports_p = new_export_p;
        -:  990:
    #####:  991:    ecma_ref_ecma_string (name_str_p);
    #####:  992:    new_export_p->imex_name_p = name_str_p;
        -:  993:
    #####:  994:    ecma_ref_ecma_string (name_str_p);
    #####:  995:    new_export_p->local_name_p = name_str_p;
        -:  996:  }
        -:  997:
    #####:  998:  ecma_module_t *module_p = ecma_module_create ();
        -:  999:
    #####: 1000:  module_p->header.u.cls.u2.module_flags |= ECMA_MODULE_IS_NATIVE;
    #####: 1001:  module_p->scope_p = scope_p;
    #####: 1002:  module_p->local_exports_p = local_exports_p;
    #####: 1003:  module_p->u.callback = callback;
        -: 1004:
    #####: 1005:  ecma_deref_object (scope_p);
        -: 1006:
    #####: 1007:  return ecma_make_object_value (&module_p->header.object);
        -: 1008:
        -: 1009:#else /* !JERRY_MODULE_SYSTEM */
        -: 1010:  JERRY_UNUSED (callback);
        -: 1011:  JERRY_UNUSED (exports_p);
        -: 1012:  JERRY_UNUSED (number_of_exports);
        -: 1013:
    #####: 1014:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1015:#endif /* JERRY_MODULE_SYSTEM */
        -: 1016:} /* jerry_native_module_create */
        -: 1017:
        -: 1018:/**
        -: 1019: * Gets the value of an export which belongs to a native module.
        -: 1020: *
        -: 1021: * Note:
        -: 1022: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1023: *
        -: 1024: * @return value of the export - if success
        -: 1025: *         error - otherwise
        -: 1026: */
        -: 1027:jerry_value_t
    #####: 1028:jerry_native_module_get_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1029:                                const jerry_value_t export_name_val) /**< string identifier of the export */
        -: 1030:{
        -: 1031:  jerry_assert_api_available ();
        -: 1032:
        -: 1033:#if JERRY_MODULE_SYSTEM
    #####: 1034:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1035:
    #####: 1036:  if (module_p == NULL)
        -: 1037:  {
    #####: 1038:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1039:  }
        -: 1040:
    #####: 1041:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1042:      || !ecma_is_value_string (export_name_val))
        -: 1043:  {
    #####: 1044:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1045:  }
        -: 1046:
    #####: 1047:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1048:                                                          ecma_get_string_from_value (export_name_val));
        -: 1049:
    #####: 1050:  if (property_p == NULL)
        -: 1051:  {
    #####: 1052:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1053:  }
        -: 1054:
    #####: 1055:  return ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 1056:#else /* !JERRY_MODULE_SYSTEM */
        -: 1057:  JERRY_UNUSED (native_module_val);
        -: 1058:  JERRY_UNUSED (export_name_val);
        -: 1059:
    #####: 1060:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1061:#endif /* JERRY_MODULE_SYSTEM */
        -: 1062:} /* jerry_native_module_get_export */
        -: 1063:
        -: 1064:/**
        -: 1065: * Sets the value of an export which belongs to a native module.
        -: 1066: *
        -: 1067: * Note:
        -: 1068: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1069: *
        -: 1070: * @return true value - if the operation was successful
        -: 1071: *         error - otherwise
        -: 1072: */
        -: 1073:jerry_value_t
    #####: 1074:jerry_native_module_set_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1075:                                const jerry_value_t export_name_val, /**< string identifier of the export */
        -: 1076:                                const jerry_value_t value_to_set) /**< new value of the export */
        -: 1077:{
        -: 1078:  jerry_assert_api_available ();
        -: 1079:
        -: 1080:#if JERRY_MODULE_SYSTEM
    #####: 1081:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1082:
    #####: 1083:  if (module_p == NULL)
        -: 1084:  {
    #####: 1085:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1086:  }
        -: 1087:
    #####: 1088:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1089:      || !ecma_is_value_string (export_name_val)
    #####: 1090:      || ecma_is_value_error_reference (value_to_set))
        -: 1091:  {
    #####: 1092:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1093:  }
        -: 1094:
    #####: 1095:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1096:                                                          ecma_get_string_from_value (export_name_val));
        -: 1097:
    #####: 1098:  if (property_p == NULL)
        -: 1099:  {
    #####: 1100:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1101:  }
        -: 1102:
    #####: 1103:  ecma_named_data_property_assign_value (module_p->scope_p,
    #####: 1104:                                         ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1105:                                         value_to_set);
    #####: 1106:  return ECMA_VALUE_TRUE;
        -: 1107:#else /* !JERRY_MODULE_SYSTEM */
        -: 1108:  JERRY_UNUSED (native_module_val);
        -: 1109:  JERRY_UNUSED (export_name_val);
        -: 1110:  JERRY_UNUSED (value_to_set);
        -: 1111:
    #####: 1112:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1113:#endif /* JERRY_MODULE_SYSTEM */
        -: 1114:} /* jerry_native_module_set_export */
        -: 1115:
        -: 1116:/**
        -: 1117: * Run enqueued Promise jobs until the first thrown error or until all get executed.
        -: 1118: *
        -: 1119: * Note:
        -: 1120: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1121: *
        -: 1122: * @return result of last executed job, may be error value.
        -: 1123: */
        -: 1124:jerry_value_t
        1: 1125:jerry_run_all_enqueued_jobs (void)
        -: 1126:{
        -: 1127:  jerry_assert_api_available ();
        -: 1128:
        -: 1129:#if JERRY_ESNEXT
        1: 1130:  return ecma_process_all_enqueued_jobs ();
        -: 1131:#else /* !JERRY_ESNEXT */
    #####: 1132:  return ECMA_VALUE_UNDEFINED;
        -: 1133:#endif /* JERRY_ESNEXT */
        -: 1134:} /* jerry_run_all_enqueued_jobs */
        -: 1135:
        -: 1136:/**
        -: 1137: * Get global object
        -: 1138: *
        -: 1139: * Note:
        -: 1140: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1141: *
        -: 1142: * @return api value of global object
        -: 1143: */
        -: 1144:jerry_value_t
        5: 1145:jerry_get_global_object (void)
        -: 1146:{
        -: 1147:  jerry_assert_api_available ();
        5: 1148:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        5: 1149:  ecma_ref_object (global_obj_p);
        5: 1150:  return ecma_make_object_value (global_obj_p);
        -: 1151:} /* jerry_get_global_object */
        -: 1152:
        -: 1153:/**
        -: 1154: * Check if the specified value is an abort value.
        -: 1155: *
        -: 1156: * @return true  - if both the error and abort values are set,
        -: 1157: *         false - otherwise
        -: 1158: */
        -: 1159:bool
    #####: 1160:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -: 1161:{
        -: 1162:  jerry_assert_api_available ();
        -: 1163:
    #####: 1164:  if (!ecma_is_value_error_reference (value))
        -: 1165:  {
    #####: 1166:    return false;
        -: 1167:  }
        -: 1168:
    #####: 1169:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1170:
    #####: 1171:  return ECMA_EXTENDED_PRIMITIVE_GET_TYPE (error_ref_p) == ECMA_EXTENDED_PRIMITIVE_ABORT;
        -: 1172:} /* jerry_value_is_abort */
        -: 1173:
        -: 1174:/**
        -: 1175: * Check if the specified value is an array object value.
        -: 1176: *
        -: 1177: * @return true  - if the specified value is an array object,
        -: 1178: *         false - otherwise
        -: 1179: */
        -: 1180:bool
    #####: 1181:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -: 1182:{
        -: 1183:  jerry_assert_api_available ();
        -: 1184:
    #####: 1185:  return (ecma_is_value_object (value)
    #####: 1186:          && ecma_get_object_base_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1187:} /* jerry_value_is_array */
        -: 1188:
        -: 1189:/**
        -: 1190: * Check if the specified value is boolean.
        -: 1191: *
        -: 1192: * @return true  - if the specified value is boolean,
        -: 1193: *         false - otherwise
        -: 1194: */
        -: 1195:bool
    #####: 1196:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -: 1197:{
        -: 1198:  jerry_assert_api_available ();
        -: 1199:
    #####: 1200:  return ecma_is_value_boolean (value);
        -: 1201:} /* jerry_value_is_boolean */
        -: 1202:
        -: 1203:/**
        -: 1204: * Check if the specified value is true.
        -: 1205: *
        -: 1206: * @return true  - if the specified value is true
        -: 1207: *         false - otherwise
        -: 1208: */
        -: 1209:bool
    #####: 1210:jerry_value_is_true (const jerry_value_t value) /**< api value */
        -: 1211:{
        -: 1212:  jerry_assert_api_available ();
        -: 1213:
    #####: 1214:  return ecma_is_value_true (value);
        -: 1215:} /* jerry_value_is_true */
        -: 1216:
        -: 1217:/**
        -: 1218: * Check if the specified value is false.
        -: 1219: *
        -: 1220: * @return true  - if the specified value is false
        -: 1221: *         false - otherwise
        -: 1222: */
        -: 1223:bool
    #####: 1224:jerry_value_is_false (const jerry_value_t value) /**< api value */
        -: 1225:{
        -: 1226:  jerry_assert_api_available ();
        -: 1227:
    #####: 1228:  return ecma_is_value_false (value);
        -: 1229:} /* jerry_value_is_false */
        -: 1230:
        -: 1231:/**
        -: 1232: * Check if the specified value is a constructor function object value.
        -: 1233: *
        -: 1234: * @return true - if the specified value is a function value that implements [[Construct]],
        -: 1235: *         false - otherwise
        -: 1236: */
        -: 1237:bool
    #####: 1238:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -: 1239:{
        -: 1240:  jerry_assert_api_available ();
        -: 1241:
    #####: 1242:  return ecma_is_constructor (value);
        -: 1243:} /* jerry_value_is_constructor */
        -: 1244:
        -: 1245:/**
        -: 1246: * Check if the specified value is an error or abort value.
        -: 1247: *
        -: 1248: * @return true  - if the specified value is an error value,
        -: 1249: *         false - otherwise
        -: 1250: */
        -: 1251:bool
        8: 1252:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -: 1253:{
        -: 1254:  jerry_assert_api_available ();
        -: 1255:
        8: 1256:  return ecma_is_value_error_reference (value);
        -: 1257:} /* jerry_value_is_error */
        -: 1258:
        -: 1259:/**
        -: 1260: * Check if the specified value is a function object value.
        -: 1261: *
        -: 1262: * @return true - if the specified value is callable,
        -: 1263: *         false - otherwise
        -: 1264: */
        -: 1265:bool
    #####: 1266:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -: 1267:{
        -: 1268:  jerry_assert_api_available ();
        -: 1269:
    #####: 1270:  return ecma_op_is_callable (value);
        -: 1271:} /* jerry_value_is_function */
        -: 1272:
        -: 1273:/**
        -: 1274: * Check if the specified value is an async function object value.
        -: 1275: *
        -: 1276: * @return true - if the specified value is an async function,
        -: 1277: *         false - otherwise
        -: 1278: */
        -: 1279:bool
    #####: 1280:jerry_value_is_async_function (const jerry_value_t value) /**< api value */
        -: 1281:{
        -: 1282:  jerry_assert_api_available ();
        -: 1283:
        -: 1284:#if JERRY_ESNEXT
    #####: 1285:  if (ecma_is_value_object (value))
        -: 1286:  {
    #####: 1287:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1288:
    #####: 1289:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1290:    {
        -: 1291:      const ecma_compiled_code_t *bytecode_data_p;
    #####: 1292:      bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);
    #####: 1293:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -: 1294:
    #####: 1295:      return (type == CBC_FUNCTION_ASYNC
    #####: 1296:              || type == CBC_FUNCTION_ASYNC_ARROW
    #####: 1297:              || type == CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1298:    }
        -: 1299:  }
        -: 1300:#else /* !JERRY_ESNEXT */
        -: 1301:  JERRY_UNUSED (value);
        -: 1302:#endif /* JERRY_ESNEXT */
        -: 1303:
    #####: 1304:  return false;
        -: 1305:} /* jerry_value_is_async_function */
        -: 1306:
        -: 1307:/**
        -: 1308: * Check if the specified value is number.
        -: 1309: *
        -: 1310: * @return true  - if the specified value is number,
        -: 1311: *         false - otherwise
        -: 1312: */
        -: 1313:bool
    #####: 1314:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -: 1315:{
        -: 1316:  jerry_assert_api_available ();
        -: 1317:
    #####: 1318:  return ecma_is_value_number (value);
        -: 1319:} /* jerry_value_is_number */
        -: 1320:
        -: 1321:/**
        -: 1322: * Check if the specified value is null.
        -: 1323: *
        -: 1324: * @return true  - if the specified value is null,
        -: 1325: *         false - otherwise
        -: 1326: */
        -: 1327:bool
    #####: 1328:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -: 1329:{
        -: 1330:  jerry_assert_api_available ();
        -: 1331:
    #####: 1332:  return ecma_is_value_null (value);
        -: 1333:} /* jerry_value_is_null */
        -: 1334:
        -: 1335:/**
        -: 1336: * Check if the specified value is object.
        -: 1337: *
        -: 1338: * @return true  - if the specified value is object,
        -: 1339: *         false - otherwise
        -: 1340: */
        -: 1341:bool
    #####: 1342:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -: 1343:{
        -: 1344:  jerry_assert_api_available ();
        -: 1345:
    #####: 1346:  return ecma_is_value_object (value);
        -: 1347:} /* jerry_value_is_object */
        -: 1348:
        -: 1349:/**
        -: 1350: * Check if the specified value is promise.
        -: 1351: *
        -: 1352: * @return true  - if the specified value is promise,
        -: 1353: *         false - otherwise
        -: 1354: */
        -: 1355:bool
    #####: 1356:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -: 1357:{
        -: 1358:  jerry_assert_api_available ();
        -: 1359:#if JERRY_ESNEXT
    #####: 1360:  return (ecma_is_value_object (value)
    #####: 1361:          && ecma_is_promise (ecma_get_object_from_value (value)));
        -: 1362:#else /* !JERRY_ESNEXT */
        -: 1363:  JERRY_UNUSED (value);
    #####: 1364:  return false;
        -: 1365:#endif /* JERRY_ESNEXT */
        -: 1366:} /* jerry_value_is_promise */
        -: 1367:
        -: 1368:/**
        -: 1369: * Check if the specified value is a proxy object.
        -: 1370: *
        -: 1371: * @return true  - if the specified value is a proxy object,
        -: 1372: *         false - otherwise
        -: 1373: */
        -: 1374:bool
    #####: 1375:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -: 1376:{
        -: 1377:  jerry_assert_api_available ();
        -: 1378:#if JERRY_BUILTIN_PROXY
    #####: 1379:  return (ecma_is_value_object (value)
    #####: 1380:          && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -: 1381:#else /* !JERRY_BUILTIN_PROXY */
        -: 1382:  JERRY_UNUSED (value);
    #####: 1383:  return false;
        -: 1384:#endif /* JERRY_BUILTIN_PROXY */
        -: 1385:} /* jerry_value_is_proxy */
        -: 1386:
        -: 1387:/**
        -: 1388: * Check if the specified value is string.
        -: 1389: *
        -: 1390: * @return true  - if the specified value is string,
        -: 1391: *         false - otherwise
        -: 1392: */
        -: 1393:bool
    #####: 1394:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -: 1395:{
        -: 1396:  jerry_assert_api_available ();
        -: 1397:
    #####: 1398:  return ecma_is_value_string (value);
        -: 1399:} /* jerry_value_is_string */
        -: 1400:
        -: 1401:/**
        -: 1402: * Check if the specified value is symbol.
        -: 1403: *
        -: 1404: * @return true  - if the specified value is symbol,
        -: 1405: *         false - otherwise
        -: 1406: */
        -: 1407:bool
    #####: 1408:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -: 1409:{
        -: 1410:  jerry_assert_api_available ();
        -: 1411:
        -: 1412:#if JERRY_ESNEXT
    #####: 1413:  return ecma_is_value_symbol (value);
        -: 1414:#else /* !JERRY_ESNEXT */
        -: 1415:  JERRY_UNUSED (value);
    #####: 1416:  return false;
        -: 1417:#endif /* JERRY_ESNEXT */
        -: 1418:} /* jerry_value_is_symbol */
        -: 1419:
        -: 1420:/**
        -: 1421: * Check if the specified value is BigInt.
        -: 1422: *
        -: 1423: * @return true  - if the specified value is BigInt,
        -: 1424: *         false - otherwise
        -: 1425: */
        -: 1426:bool
    #####: 1427:jerry_value_is_bigint (const jerry_value_t value) /**< api value */
        -: 1428:{
        -: 1429:  jerry_assert_api_available ();
        -: 1430:
        -: 1431:#if JERRY_BUILTIN_BIGINT
    #####: 1432:  return ecma_is_value_bigint (value);
        -: 1433:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1434:  JERRY_UNUSED (value);
    #####: 1435:  return false;
        -: 1436:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1437:} /* jerry_value_is_bigint */
        -: 1438:
        -: 1439:/**
        -: 1440: * Check if the specified value is undefined.
        -: 1441: *
        -: 1442: * @return true  - if the specified value is undefined,
        -: 1443: *         false - otherwise
        -: 1444: */
        -: 1445:bool
    #####: 1446:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -: 1447:{
        -: 1448:  jerry_assert_api_available ();
        -: 1449:
    #####: 1450:  return ecma_is_value_undefined (value);
        -: 1451:} /* jerry_value_is_undefined */
        -: 1452:
        -: 1453:/**
        -: 1454: * Perform the base type of the JavaScript value.
        -: 1455: *
        -: 1456: * @return jerry_type_t value
        -: 1457: */
        -: 1458:jerry_type_t
    #####: 1459:jerry_value_get_type (const jerry_value_t value) /**< input value to check */
        -: 1460:{
        -: 1461:  jerry_assert_api_available ();
        -: 1462:
    #####: 1463:  if (ecma_is_value_error_reference (value))
        -: 1464:  {
    #####: 1465:    return JERRY_TYPE_ERROR;
        -: 1466:  }
        -: 1467:
    #####: 1468:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -: 1469:
    #####: 1470:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -: 1471:
    #####: 1472:  switch (lit_id)
        -: 1473:  {
    #####: 1474:    case LIT_MAGIC_STRING_UNDEFINED:
        -: 1475:    {
    #####: 1476:      return JERRY_TYPE_UNDEFINED;
        -: 1477:    }
    #####: 1478:    case LIT_MAGIC_STRING_BOOLEAN:
        -: 1479:    {
    #####: 1480:      return JERRY_TYPE_BOOLEAN;
        -: 1481:    }
    #####: 1482:    case LIT_MAGIC_STRING_NUMBER:
        -: 1483:    {
    #####: 1484:      return JERRY_TYPE_NUMBER;
        -: 1485:    }
    #####: 1486:    case LIT_MAGIC_STRING_STRING:
        -: 1487:    {
    #####: 1488:      return JERRY_TYPE_STRING;
        -: 1489:    }
        -: 1490:#if JERRY_ESNEXT
    #####: 1491:    case LIT_MAGIC_STRING_SYMBOL:
        -: 1492:    {
    #####: 1493:      return JERRY_TYPE_SYMBOL;
        -: 1494:    }
        -: 1495:#endif /* JERRY_ESNEXT */
    #####: 1496:    case LIT_MAGIC_STRING_FUNCTION:
        -: 1497:    {
    #####: 1498:      return JERRY_TYPE_FUNCTION;
        -: 1499:    }
        -: 1500:#if JERRY_BUILTIN_BIGINT
    #####: 1501:    case LIT_MAGIC_STRING_BIGINT:
        -: 1502:    {
    #####: 1503:      return JERRY_TYPE_BIGINT;
        -: 1504:    }
        -: 1505:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 1506:    default:
        -: 1507:    {
    #####: 1508:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -: 1509:
        -: 1510:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -: 1511:       * Thus we'll do an extra check for 'null' here.
        -: 1512:       */
    #####: 1513:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -: 1514:    }
        -: 1515:  }
        -: 1516:} /* jerry_value_get_type */
        -: 1517:
        -: 1518:/**
        -: 1519: * Used by jerry_object_get_type to get the type of class objects
        -: 1520: */
        -: 1521:static const uint8_t jerry_class_object_type[] =
        -: 1522:{
        -: 1523:  /* These objects require custom property resolving. */
        -: 1524:  JERRY_OBJECT_TYPE_STRING, /**< type of ECMA_OBJECT_CLASS_STRING */
        -: 1525:  JERRY_OBJECT_TYPE_ARGUMENTS, /**< type of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 1526:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1527:  JERRY_OBJECT_TYPE_TYPEDARRAY, /**< type of ECMA_OBJECT_CLASS_TYPEDARRAY */
        -: 1528:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1529:#if JERRY_MODULE_SYSTEM
        -: 1530:  JERRY_OBJECT_TYPE_MODULE_NAMESPACE, /**< type of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 1531:#endif
        -: 1532:
        -: 1533:  /* These objects are marked by Garbage Collector. */
        -: 1534:#if JERRY_ESNEXT
        -: 1535:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_GENERATOR */
        -: 1536:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 1537:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 1538:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 1539:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 1540:#if JERRY_BUILTIN_REGEXP
        -: 1541:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 1542:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1543:#endif /* JERRY_ESNEXT */
        -: 1544:#if JERRY_MODULE_SYSTEM
        -: 1545:  JERRY_OBJECT_TYPE_MODULE, /**< type of ECMA_OBJECT_CLASS_MODULE */
        -: 1546:#endif
        -: 1547:#if JERRY_ESNEXT
        -: 1548:  JERRY_OBJECT_TYPE_PROMISE, /**< type of ECMA_OBJECT_CLASS_PROMISE */
        -: 1549:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 1550:#endif /* JERRY_ESNEXT */
        -: 1551:#if JERRY_BUILTIN_DATAVIEW
        -: 1552:  JERRY_OBJECT_TYPE_DATAVIEW, /**< type of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 1553:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1554:#if JERRY_BUILTIN_CONTAINER
        -: 1555:  JERRY_OBJECT_TYPE_CONTAINER, /**< type of ECMA_OBJECT_CLASS_CONTAINER */
        -: 1556:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1557:
        -: 1558:  /* Normal objects. */
        -: 1559:  JERRY_OBJECT_TYPE_BOOLEAN, /**< type of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 1560:  JERRY_OBJECT_TYPE_NUMBER, /**< type of ECMA_OBJECT_CLASS_NUMBER */
        -: 1561:  JERRY_OBJECT_TYPE_ERROR, /**< type of ECMA_OBJECT_CLASS_ERROR */
        -: 1562:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 1563:#if JERRY_PARSER
        -: 1564:  JERRY_OBJECT_TYPE_SCRIPT, /**< type of ECMA_OBJECT_CLASS_SCRIPT */
        -: 1565:#endif /* JERRY_PARSER */
        -: 1566:#if JERRY_BUILTIN_DATE
        -: 1567:  JERRY_OBJECT_TYPE_DATE, /**< type of ECMA_OBJECT_CLASS_DATE */
        -: 1568:#endif /* JERRY_BUILTIN_DATE */
        -: 1569:#if JERRY_BUILTIN_REGEXP
        -: 1570:  JERRY_OBJECT_TYPE_REGEXP, /**< type of ECMA_OBJECT_CLASS_REGEXP */
        -: 1571:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1572:#if JERRY_ESNEXT
        -: 1573:  JERRY_OBJECT_TYPE_SYMBOL, /**< type of ECMA_OBJECT_CLASS_SYMBOL */
        -: 1574:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 1575:#endif /* JERRY_ESNEXT */
        -: 1576:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1577:  JERRY_OBJECT_TYPE_ARRAYBUFFER, /**< type of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 1578:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1579:  JERRY_OBJECT_TYPE_SHARED_ARRAY_BUFFER, /**< type of ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER */
        -: 1580:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1581:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1582:#if JERRY_BUILTIN_BIGINT
        -: 1583:  JERRY_OBJECT_TYPE_BIGINT, /**< type of ECMA_OBJECT_CLASS_BIGINT */
        -: 1584:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1585:#if JERRY_BUILTIN_WEAKREF
        -: 1586:  JERRY_OBJECT_TYPE_WEAKREF, /**< type of ECMA_OBJECT_CLASS_WEAKREF */
        -: 1587:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1588:};
        -: 1589:
        -: 1590:JERRY_STATIC_ASSERT (sizeof (jerry_class_object_type) == ECMA_OBJECT_CLASS__MAX,
        -: 1591:                     jerry_class_object_type_must_have_object_class_max_elements);
        -: 1592:
        -: 1593:/**
        -: 1594: * Get the object type of the given value
        -: 1595: *
        -: 1596: * @return JERRY_OBJECT_TYPE_NONE - if the given value is not an object
        -: 1597: *         jerry_object_type_t value - otherwise
        -: 1598: */
        -: 1599:jerry_object_type_t
    #####: 1600:jerry_object_get_type (const jerry_value_t value) /**< input value to check */
        -: 1601:{
        -: 1602:  jerry_assert_api_available ();
        -: 1603:
    #####: 1604:  if (!ecma_is_value_object (value))
        -: 1605:  {
    #####: 1606:    return JERRY_OBJECT_TYPE_NONE;
        -: 1607:  }
        -: 1608:
    #####: 1609:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1610:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1611:
    #####: 1612:  switch (ecma_get_object_type (obj_p))
        -: 1613:  {
    #####: 1614:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1615:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1616:    {
    #####: 1617:      JERRY_ASSERT (ext_obj_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 1618:      return jerry_class_object_type[ext_obj_p->u.cls.type];
        -: 1619:    }
    #####: 1620:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1621:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1622:    {
    #####: 1623:      return JERRY_OBJECT_TYPE_ARRAY;
        -: 1624:    }
        -: 1625:#if JERRY_ESNEXT
    #####: 1626:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1627:    {
    #####: 1628:      return JERRY_OBJECT_TYPE_PROXY;
        -: 1629:    }
        -: 1630:#endif /* JERRY_ESNEXT */
    #####: 1631:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1632:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1633:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1634:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1635:    {
    #####: 1636:      return JERRY_OBJECT_TYPE_FUNCTION;
        -: 1637:    }
    #####: 1638:    default:
        -: 1639:    {
    #####: 1640:      break;
        -: 1641:    }
        -: 1642:  }
        -: 1643:
    #####: 1644:  return JERRY_OBJECT_TYPE_GENERIC;
        -: 1645:} /* jerry_object_get_type */
        -: 1646:
        -: 1647:/**
        -: 1648: * Get the function type of the given value
        -: 1649: *
        -: 1650: * @return JERRY_FUNCTION_TYPE_NONE - if the given value is not a function object
        -: 1651: *         jerry_function_type_t value - otherwise
        -: 1652: */
        -: 1653:jerry_function_type_t
    #####: 1654:jerry_function_get_type (const jerry_value_t value) /**< input value to check */
        -: 1655:{
        -: 1656:  jerry_assert_api_available ();
        -: 1657:
    #####: 1658:  if (ecma_is_value_object (value))
        -: 1659:  {
    #####: 1660:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1661:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1662:
    #####: 1663:    switch (ecma_get_object_type (obj_p))
        -: 1664:    {
    #####: 1665:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1666:      {
    #####: 1667:        return JERRY_FUNCTION_TYPE_BOUND;
        -: 1668:      }
    #####: 1669:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1670:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1671:      {
    #####: 1672:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1673:      }
    #####: 1674:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1675:      {
    #####: 1676:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_obj_p);
        -: 1677:
    #####: 1678:        switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))
        -: 1679:        {
        -: 1680:#if JERRY_ESNEXT
    #####: 1681:          case CBC_FUNCTION_ARROW:
        -: 1682:          case CBC_FUNCTION_ASYNC_ARROW:
        -: 1683:          {
    #####: 1684:            return JERRY_FUNCTION_TYPE_ARROW;
        -: 1685:          }
    #####: 1686:          case CBC_FUNCTION_GENERATOR:
        -: 1687:          case CBC_FUNCTION_ASYNC_GENERATOR:
        -: 1688:          {
    #####: 1689:            return JERRY_FUNCTION_TYPE_GENERATOR;
        -: 1690:          }
        -: 1691:#endif /* JERRY_ESNEXT */
    #####: 1692:          case CBC_FUNCTION_ACCESSOR:
        -: 1693:          {
    #####: 1694:            return JERRY_FUNCTION_TYPE_ACCESSOR;
        -: 1695:          }
    #####: 1696:          default:
        -: 1697:          {
    #####: 1698:            break;
        -: 1699:          }
        -: 1700:        }
    #####: 1701:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1702:      }
    #####: 1703:      default:
        -: 1704:      {
    #####: 1705:        break;
        -: 1706:      }
        -: 1707:    }
    #####: 1708:  }
        -: 1709:
    #####: 1710:  return JERRY_FUNCTION_TYPE_NONE;
        -: 1711:} /* jerry_function_get_type */
        -: 1712:
        -: 1713:/**
        -: 1714: * Get the itearator type of the given value
        -: 1715: *
        -: 1716: * @return JERRY_ITERATOR_TYPE_NONE - if the given value is not an iterator object
        -: 1717: *         jerry_iterator_type_t value - otherwise
        -: 1718: */
        -: 1719:jerry_iterator_type_t
    #####: 1720:jerry_iterator_get_type (const jerry_value_t value) /**< input value to check */
        -: 1721:{
        -: 1722:  jerry_assert_api_available ();
        -: 1723:
        -: 1724:#if JERRY_ESNEXT
    #####: 1725:  if (ecma_is_value_object (value))
        -: 1726:  {
    #####: 1727:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1728:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1729:
    #####: 1730:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 1731:    {
    #####: 1732:      switch (ext_obj_p->u.cls.type)
        -: 1733:      {
    #####: 1734:        case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1735:        {
    #####: 1736:          return JERRY_ITERATOR_TYPE_ARRAY;
        -: 1737:        }
        -: 1738:#if JERRY_BUILTIN_CONTAINER
    #####: 1739:        case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1740:        {
    #####: 1741:          return JERRY_ITERATOR_TYPE_SET;
        -: 1742:        }
    #####: 1743:        case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1744:        {
    #####: 1745:          return JERRY_ITERATOR_TYPE_MAP;
        -: 1746:        }
        -: 1747:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1748:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1749:        {
    #####: 1750:          return JERRY_ITERATOR_TYPE_STRING;
        -: 1751:        }
    #####: 1752:        default:
        -: 1753:        {
    #####: 1754:          break;
        -: 1755:        }
        -: 1756:      }
    #####: 1757:    }
        -: 1758:  }
        -: 1759:#else /* !JERRY_ESNEXT */
        -: 1760:  JERRY_UNUSED (value);
        -: 1761:#endif /* JERRY_ESNEXT */
        -: 1762:
    #####: 1763:  return JERRY_ITERATOR_TYPE_NONE;
        -: 1764:} /* jerry_iterator_get_type */
        -: 1765:
        -: 1766:/**
        -: 1767: * Check if the specified feature is enabled.
        -: 1768: *
        -: 1769: * @return true  - if the specified feature is enabled,
        -: 1770: *         false - otherwise
        -: 1771: */
        -: 1772:bool
    #####: 1773:jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -: 1774:{
    #####: 1775:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -: 1776:
        -: 1777:  return (false
        -: 1778:#if JERRY_CPOINTER_32_BIT
        -: 1779:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -: 1780:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1781:#if JERRY_ERROR_MESSAGES
        -: 1782:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -: 1783:#endif /* JERRY_ERROR_MESSAGES */
        -: 1784:#if JERRY_PARSER
    #####: 1785:          || feature == JERRY_FEATURE_JS_PARSER
        -: 1786:#endif /* JERRY_PARSER */
        -: 1787:#if JERRY_MEM_STATS
    #####: 1788:          || feature == JERRY_FEATURE_MEM_STATS
        -: 1789:#endif /* JERRY_MEM_STATS */
        -: 1790:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1791:          || feature == JERRY_FEATURE_PARSER_DUMP
        -: 1792:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1793:#if JERRY_REGEXP_DUMP_BYTE_CODE
        -: 1794:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -: 1795:#endif /* JERRY_REGEXP_DUMP_BYTE_CODE */
        -: 1796:#if JERRY_SNAPSHOT_SAVE
    #####: 1797:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -: 1798:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1799:#if JERRY_SNAPSHOT_EXEC
    #####: 1800:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -: 1801:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1802:#if JERRY_DEBUGGER
        -: 1803:          || feature == JERRY_FEATURE_DEBUGGER
        -: 1804:#endif /* JERRY_DEBUGGER */
        -: 1805:#if JERRY_VM_EXEC_STOP
    #####: 1806:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -: 1807:#endif /* JERRY_VM_EXEC_STOP */
        -: 1808:#if JERRY_VM_THROW
        -: 1809:          || feature == JERRY_FEATURE_VM_THROW
        -: 1810:#endif /* JERRY_VM_THROW */
        -: 1811:#if JERRY_BUILTIN_JSON
    #####: 1812:          || feature == JERRY_FEATURE_JSON
        -: 1813:#endif /* JERRY_BUILTIN_JSON */
        -: 1814:#if JERRY_ESNEXT
    #####: 1815:          || feature == JERRY_FEATURE_PROMISE
    #####: 1816:          || feature == JERRY_FEATURE_SYMBOL
        -: 1817:#endif /* JERRY_ESNEXT */
        -: 1818:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1819:          || feature == JERRY_FEATURE_TYPEDARRAY
        -: 1820:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1821:#if JERRY_BUILTIN_DATAVIEW
    #####: 1822:          || feature == JERRY_FEATURE_DATAVIEW
        -: 1823:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1824:#if JERRY_BUILTIN_PROXY
    #####: 1825:          || feature == JERRY_FEATURE_PROXY
        -: 1826:#endif /* JERRY_BUILTIN_PROXY */
        -: 1827:#if JERRY_BUILTIN_DATE
    #####: 1828:          || feature == JERRY_FEATURE_DATE
        -: 1829:#endif /* JERRY_BUILTIN_DATE */
        -: 1830:#if JERRY_BUILTIN_REGEXP
    #####: 1831:          || feature == JERRY_FEATURE_REGEXP
        -: 1832:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1833:#if JERRY_LINE_INFO
    #####: 1834:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1835:#endif /* JERRY_LINE_INFO */
        -: 1836:#if JERRY_LOGGING
    #####: 1837:          || feature == JERRY_FEATURE_LOGGING
        -: 1838:#endif /* JERRY_LOGGING */
        -: 1839:#if JERRY_BUILTIN_GLOBAL_THIS
    #####: 1840:          || feature == JERRY_FEATURE_GLOBAL_THIS
        -: 1841:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        -: 1842:#if JERRY_BUILTIN_CONTAINER
    #####: 1843:          || feature == JERRY_FEATURE_MAP
    #####: 1844:          || feature == JERRY_FEATURE_SET
    #####: 1845:          || feature == JERRY_FEATURE_WEAKMAP
    #####: 1846:          || feature == JERRY_FEATURE_WEAKSET
        -: 1847:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1848:#if JERRY_BUILTIN_WEAKREF
    #####: 1849:          || feature == JERRY_FEATURE_WEAKREF
        -: 1850:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1851:#if JERRY_BUILTIN_BIGINT
    #####: 1852:          || feature == JERRY_FEATURE_BIGINT
        -: 1853:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1854:#if JERRY_BUILTIN_REALMS
    #####: 1855:          || feature == JERRY_FEATURE_REALM
        -: 1856:#endif /* JERRY_BUILTIN_REALMS */
        -: 1857:#if JERRY_PROMISE_CALLBACK
    #####: 1858:          || feature == JERRY_FEATURE_PROMISE_CALLBACK
        -: 1859:#endif /* JERRY_PROMISE_CALLBACK */
        -: 1860:#if JERRY_MODULE_SYSTEM
    #####: 1861:          || feature == JERRY_FEATURE_MODULE
        -: 1862:#endif /* JERRY_MODULE_SYSTEM */
        -: 1863:#if JERRY_FUNCTION_TO_STRING
    #####: 1864:          || feature == JERRY_FEATURE_FUNCTION_TO_STRING
        -: 1865:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1866:          );
        -: 1867:} /* jerry_is_feature_enabled */
        -: 1868:
        -: 1869:/**
        -: 1870: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1871: *
        -: 1872: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1873: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1874: */
        -: 1875:jerry_value_t
    #####: 1876:jerry_binary_operation (jerry_binary_operation_t op, /**< operation */
        -: 1877:                        const jerry_value_t lhs, /**< first operand */
        -: 1878:                        const jerry_value_t rhs) /**< second operand */
        -: 1879:{
        -: 1880:  jerry_assert_api_available ();
        -: 1881:
    #####: 1882:  if (ecma_is_value_error_reference (lhs) || ecma_is_value_error_reference (rhs))
        -: 1883:  {
    #####: 1884:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 1885:  }
        -: 1886:
    #####: 1887:  switch (op)
        -: 1888:  {
    #####: 1889:    case JERRY_BIN_OP_EQUAL:
        -: 1890:    {
    #####: 1891:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1892:    }
    #####: 1893:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1894:    {
    #####: 1895:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1896:    }
    #####: 1897:    case JERRY_BIN_OP_LESS:
        -: 1898:    {
    #####: 1899:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1900:    }
    #####: 1901:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1902:    {
    #####: 1903:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1904:    }
    #####: 1905:    case JERRY_BIN_OP_GREATER:
        -: 1906:    {
    #####: 1907:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1908:    }
    #####: 1909:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1910:    {
    #####: 1911:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1912:    }
    #####: 1913:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1914:    {
    #####: 1915:      if (!ecma_is_value_object (lhs)
    #####: 1916:          || !ecma_op_is_callable (rhs))
        -: 1917:      {
    #####: 1918:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1919:      }
        -: 1920:
    #####: 1921:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1922:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1923:    }
    #####: 1924:    case JERRY_BIN_OP_ADD:
        -: 1925:    {
    #####: 1926:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1927:    }
    #####: 1928:    case JERRY_BIN_OP_SUB:
        -: 1929:    case JERRY_BIN_OP_MUL:
        -: 1930:    case JERRY_BIN_OP_DIV:
        -: 1931:    case JERRY_BIN_OP_REM:
        -: 1932:    {
    #####: 1933:      return jerry_return (do_number_arithmetic (op - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1934:    }
    #####: 1935:    default:
        -: 1936:    {
    #####: 1937:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported binary operation")));
        -: 1938:    }
        -: 1939:  }
        -: 1940:} /* jerry_binary_operation */
        -: 1941:
        -: 1942:/**
        -: 1943: * Create abort from an api value.
        -: 1944: *
        -: 1945: * Create abort value from an api value. If the second argument is true
        -: 1946: * it will release the input api value.
        -: 1947: *
        -: 1948: * @return api abort value
        -: 1949: */
        -: 1950:jerry_value_t
    #####: 1951:jerry_create_abort_from_value (jerry_value_t value, /**< api value */
        -: 1952:                               bool release) /**< release api value */
        -: 1953:{
        -: 1954:  jerry_assert_api_available ();
        -: 1955:
    #####: 1956:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1957:  {
        -: 1958:    /* This is a rare case so it is optimized for
        -: 1959:     * binary size rather than performance. */
    #####: 1960:    if (jerry_value_is_abort (value))
        -: 1961:    {
    #####: 1962:      return release ? value : jerry_acquire_value (value);
        -: 1963:    }
        -: 1964:
    #####: 1965:    value = jerry_get_value_from_error (value, release);
    #####: 1966:    release = true;
        -: 1967:  }
        -: 1968:
    #####: 1969:  if (!release)
        -: 1970:  {
    #####: 1971:    value = ecma_copy_value (value);
        -: 1972:  }
        -: 1973:
    #####: 1974:  return ecma_create_error_reference (value, false);
        -: 1975:} /* jerry_create_abort_from_value */
        -: 1976:
        -: 1977:/**
        -: 1978: * Create error from an api value.
        -: 1979: *
        -: 1980: * Create error value from an api value. If the second argument is true
        -: 1981: * it will release the input api value.
        -: 1982: *
        -: 1983: * @return api error value
        -: 1984: */
        -: 1985:jerry_value_t
    #####: 1986:jerry_create_error_from_value (jerry_value_t value, /**< api value */
        -: 1987:                               bool release) /**< release api value */
        -: 1988:{
        -: 1989:  jerry_assert_api_available ();
        -: 1990:
    #####: 1991:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1992:  {
        -: 1993:    /* This is a rare case so it is optimized for
        -: 1994:     * binary size rather than performance. */
    #####: 1995:    if (!jerry_value_is_abort (value))
        -: 1996:    {
    #####: 1997:      return release ? value : jerry_acquire_value (value);
        -: 1998:    }
        -: 1999:
    #####: 2000:    value = jerry_get_value_from_error (value, release);
    #####: 2001:    release = true;
        -: 2002:  }
        -: 2003:
    #####: 2004:  if (!release)
        -: 2005:  {
    #####: 2006:    value = ecma_copy_value (value);
        -: 2007:  }
        -: 2008:
    #####: 2009:  return ecma_create_error_reference (value, true);
        -: 2010:} /* jerry_create_error_from_value */
        -: 2011:
        -: 2012:/**
        -: 2013: * Get the value from an error value.
        -: 2014: *
        -: 2015: * Extract the api value from an error. If the second argument is true
        -: 2016: * it will release the input error value.
        -: 2017: *
        -: 2018: * Note:
        -: 2019: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2020: *
        -: 2021: * @return jerry_value_t value
        -: 2022: */
        -: 2023:jerry_value_t
    #####: 2024:jerry_get_value_from_error (jerry_value_t value, /**< api value */
        -: 2025:                            bool release) /**< release api value */
        -: 2026:{
        -: 2027:  jerry_assert_api_available ();
        -: 2028:
    #####: 2029:  if (!ecma_is_value_error_reference (value))
        -: 2030:  {
    #####: 2031:    return release ? value : ecma_copy_value (value);
        -: 2032:  }
        -: 2033:
    #####: 2034:  jerry_value_t ret_val = jerry_acquire_value (ecma_get_extended_primitive_from_value (value)->u.value);
        -: 2035:
    #####: 2036:  if (release)
        -: 2037:  {
    #####: 2038:    jerry_release_value (value);
        -: 2039:  }
    #####: 2040:  return ret_val;
        -: 2041:} /* jerry_get_value_from_error */
        -: 2042:
        -: 2043:/**
        -: 2044: * Set new decorator callback for Error objects. The decorator can
        -: 2045: * create or update any properties of the newly created Error object.
        -: 2046: */
        -: 2047:void
    #####: 2048:jerry_set_error_object_created_callback (jerry_error_object_created_callback_t callback, /**< new callback */
        -: 2049:                                         void *user_p) /**< user pointer passed to the callback */
        -: 2050:{
        -: 2051:  jerry_assert_api_available ();
        -: 2052:
    #####: 2053:  JERRY_CONTEXT (error_object_created_callback_p) = callback;
    #####: 2054:  JERRY_CONTEXT (error_object_created_callback_user_p) = user_p;
    #####: 2055:} /* jerry_set_error_object_created_callback */
        -: 2056:
        -: 2057:/**
        -: 2058: * Return the type of the Error object if possible.
        -: 2059: *
        -: 2060: * @return one of the jerry_error_t value as the type of the Error object
        -: 2061: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 2062: */
        -: 2063:jerry_error_t
    #####: 2064:jerry_get_error_type (jerry_value_t value) /**< api value */
        -: 2065:{
    #####: 2066:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2067:  {
    #####: 2068:    value = ecma_get_extended_primitive_from_value (value)->u.value;
        -: 2069:  }
        -: 2070:
    #####: 2071:  if (!ecma_is_value_object (value))
        -: 2072:  {
    #####: 2073:    return JERRY_ERROR_NONE;
        -: 2074:  }
        -: 2075:
    #####: 2076:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 2077:  jerry_error_t error_type = ecma_get_error_type (object_p);
        -: 2078:
    #####: 2079:  return (jerry_error_t) error_type;
        -: 2080:} /* jerry_get_error_type */
        -: 2081:
        -: 2082:/**
        -: 2083: * Get number from the specified value as a double.
        -: 2084: *
        -: 2085: * @return stored number as double
        -: 2086: */
        -: 2087:double
    #####: 2088:jerry_get_number_value (const jerry_value_t value) /**< api value */
        -: 2089:{
        -: 2090:  jerry_assert_api_available ();
        -: 2091:
    #####: 2092:  if (!ecma_is_value_number (value))
        -: 2093:  {
    #####: 2094:    return 0;
        -: 2095:  }
        -: 2096:
    #####: 2097:  return (double) ecma_get_number_from_value (value);
        -: 2098:} /* jerry_get_number_value */
        -: 2099:
        -: 2100:/**
        -: 2101: * Call ToBoolean operation on the api value.
        -: 2102: *
        -: 2103: * @return true  - if the logical value is true
        -: 2104: *         false - otherwise
        -: 2105: */
        -: 2106:bool
    #####: 2107:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 2108:{
        -: 2109:  jerry_assert_api_available ();
        -: 2110:
    #####: 2111:  if (ecma_is_value_error_reference (value))
        -: 2112:  {
    #####: 2113:    return false;
        -: 2114:  }
        -: 2115:
    #####: 2116:  return ecma_op_to_boolean (value);
        -: 2117:} /* jerry_value_to_boolean */
        -: 2118:
        -: 2119:/**
        -: 2120: * Call ToNumber operation on the api value.
        -: 2121: *
        -: 2122: * Note:
        -: 2123: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2124: *
        -: 2125: * @return converted number value - if success
        -: 2126: *         thrown error - otherwise
        -: 2127: */
        -: 2128:jerry_value_t
    #####: 2129:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 2130:{
        -: 2131:  jerry_assert_api_available ();
        -: 2132:
    #####: 2133:  if (ecma_is_value_error_reference (value))
        -: 2134:  {
    #####: 2135:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2136:  }
        -: 2137:
    #####: 2138:  ecma_number_t num;
    #####: 2139:  ecma_value_t ret_value = ecma_op_to_number (value, &num);
        -: 2140:
    #####: 2141:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2142:  {
    #####: 2143:    return ecma_create_error_reference_from_context ();
        -: 2144:  }
        -: 2145:
    #####: 2146:  return ecma_make_number_value (num);
        -: 2147:} /* jerry_value_to_number */
        -: 2148:
        -: 2149:/**
        -: 2150: * Call ToObject operation on the api value.
        -: 2151: *
        -: 2152: * Note:
        -: 2153: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2154: *
        -: 2155: * @return converted object value - if success
        -: 2156: *         thrown error - otherwise
        -: 2157: */
        -: 2158:jerry_value_t
    #####: 2159:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 2160:{
        -: 2161:  jerry_assert_api_available ();
        -: 2162:
    #####: 2163:  if (ecma_is_value_error_reference (value))
        -: 2164:  {
    #####: 2165:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2166:  }
        -: 2167:
    #####: 2168:  return jerry_return (ecma_op_to_object (value));
        -: 2169:} /* jerry_value_to_object */
        -: 2170:
        -: 2171:/**
        -: 2172: * Call ToPrimitive operation on the api value.
        -: 2173: *
        -: 2174: * Note:
        -: 2175: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2176: *
        -: 2177: * @return converted primitive value - if success
        -: 2178: *         thrown error - otherwise
        -: 2179: */
        -: 2180:jerry_value_t
    #####: 2181:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 2182:{
        -: 2183:  jerry_assert_api_available ();
        -: 2184:
    #####: 2185:  if (ecma_is_value_error_reference (value))
        -: 2186:  {
    #####: 2187:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2188:  }
        -: 2189:
    #####: 2190:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 2191:} /* jerry_value_to_primitive */
        -: 2192:
        -: 2193:/**
        -: 2194: * Call the ToString ecma builtin operation on the api value.
        -: 2195: *
        -: 2196: * Note:
        -: 2197: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2198: *
        -: 2199: * @return converted string value - if success
        -: 2200: *         thrown error - otherwise
        -: 2201: */
        -: 2202:jerry_value_t
    #####: 2203:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 2204:{
        -: 2205:
        -: 2206:  jerry_assert_api_available ();
        -: 2207:
    #####: 2208:  if (ecma_is_value_error_reference (value))
        -: 2209:  {
    #####: 2210:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2211:  }
        -: 2212:
    #####: 2213:  ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 2214:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 2215:  {
    #####: 2216:    return ecma_create_error_reference_from_context ();
        -: 2217:  }
        -: 2218:
    #####: 2219:  return ecma_make_string_value (str_p);
        -: 2220:} /* jerry_value_to_string */
        -: 2221:
        -: 2222:/**
        -: 2223: * Call the BigInt constructor ecma builtin operation on the api value.
        -: 2224: *
        -: 2225: * Note:
        -: 2226: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2227: *
        -: 2228: * @return BigInt value - if success
        -: 2229: *         thrown error - otherwise
        -: 2230: */
        -: 2231:jerry_value_t
    #####: 2232:jerry_value_to_bigint (const jerry_value_t value) /**< input value */
        -: 2233:{
        -: 2234:  jerry_assert_api_available ();
        -: 2235:
        -: 2236:#if JERRY_BUILTIN_BIGINT
    #####: 2237:  if (ecma_is_value_error_reference (value))
        -: 2238:  {
    #####: 2239:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2240:  }
        -: 2241:
    #####: 2242:  return jerry_return (ecma_bigint_to_bigint (value, true));
        -: 2243:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2244:  JERRY_UNUSED (value);
    #####: 2245:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2246:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2247:} /* jerry_value_to_bigint */
        -: 2248:
        -: 2249:/**
        -: 2250: * Convert any number to integer number.
        -: 2251: *
        -: 2252: * Note:
        -: 2253: *      For non-number values 0 is returned.
        -: 2254: *
        -: 2255: * @return integer representation of the number.
        -: 2256: */
        -: 2257:double
    #####: 2258:jerry_value_as_integer (const jerry_value_t value) /**< input value */
        -: 2259:{
        -: 2260:  jerry_assert_api_available ();
        -: 2261:
    #####: 2262:  if (!ecma_is_value_number (value))
        -: 2263:  {
    #####: 2264:    return 0;
        -: 2265:  }
        -: 2266:
    #####: 2267:  double number = ecma_get_number_from_value (value);
        -: 2268:
    #####: 2269:  if (ecma_number_is_nan (number))
        -: 2270:  {
    #####: 2271:    return ECMA_NUMBER_ZERO;
        -: 2272:  }
        -: 2273:
    #####: 2274:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -: 2275:  {
    #####: 2276:    return number;
        -: 2277:  }
        -: 2278:
    #####: 2279:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -: 2280:
    #####: 2281:  return ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        -: 2282:} /* jerry_value_as_integer */
        -: 2283:
        -: 2284:/**
        -: 2285: * Convert any number to int32 number.
        -: 2286: *
        -: 2287: * Note:
        -: 2288: *      For non-number values 0 is returned.
        -: 2289: *
        -: 2290: * @return int32 representation of the number.
        -: 2291: */
        -: 2292:int32_t
    #####: 2293:jerry_value_as_int32 (const jerry_value_t value) /**< input value */
        -: 2294:{
        -: 2295:  jerry_assert_api_available ();
        -: 2296:
    #####: 2297:  if (!ecma_is_value_number (value))
        -: 2298:  {
    #####: 2299:    return 0;
        -: 2300:  }
        -: 2301:
    #####: 2302:  return ecma_number_to_int32 (ecma_get_number_from_value (value));
        -: 2303:} /* jerry_value_as_int32 */
        -: 2304:
        -: 2305:/**
        -: 2306: * Convert any number to uint32 number.
        -: 2307: *
        -: 2308: * Note:
        -: 2309: *      For non-number values 0 is returned.
        -: 2310: *
        -: 2311: * @return uint32 representation of the number.
        -: 2312: */
        -: 2313:uint32_t
    #####: 2314:jerry_value_as_uint32 (const jerry_value_t value) /**< input value */
        -: 2315:{
        -: 2316:  jerry_assert_api_available ();
        -: 2317:
    #####: 2318:  if (!ecma_is_value_number (value))
        -: 2319:  {
    #####: 2320:    return 0;
        -: 2321:  }
        -: 2322:
    #####: 2323:  return ecma_number_to_uint32 (ecma_get_number_from_value (value));
        -: 2324:} /* jerry_value_as_uint32 */
        -: 2325:
        -: 2326:/**
        -: 2327: * Acquire specified Jerry API value.
        -: 2328: *
        -: 2329: * Note:
        -: 2330: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2331: *
        -: 2332: * @return acquired api value
        -: 2333: */
        -: 2334:jerry_value_t
    #####: 2335:jerry_acquire_value (jerry_value_t value) /**< API value */
        -: 2336:{
        -: 2337:  jerry_assert_api_available ();
        -: 2338:
    #####: 2339:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2340:  {
    #####: 2341:    ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
    #####: 2342:    return value;
        -: 2343:  }
        -: 2344:
    #####: 2345:  return ecma_copy_value (value);
        -: 2346:} /* jerry_acquire_value */
        -: 2347:
        -: 2348:/**
        -: 2349: * Release specified Jerry API value
        -: 2350: */
        -: 2351:void
       24: 2352:jerry_release_value (jerry_value_t value) /**< API value */
        -: 2353:{
        -: 2354:  jerry_assert_api_available ();
        -: 2355:
       24: 2356:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2357:  {
    #####: 2358:    ecma_deref_error_reference (ecma_get_extended_primitive_from_value (value));
    #####: 2359:    return;
        -: 2360:  }
        -: 2361:
       24: 2362:  ecma_free_value (value);
        -: 2363:} /* jerry_release_value */
        -: 2364:
        -: 2365:/**
        -: 2366: * Create an array object value
        -: 2367: *
        -: 2368: * Note:
        -: 2369: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2370: *
        -: 2371: * @return value of the constructed array object
        -: 2372: */
        -: 2373:jerry_value_t
    #####: 2374:jerry_create_array (uint32_t size) /**< size of array */
        -: 2375:{
        -: 2376:  jerry_assert_api_available ();
        -: 2377:
    #####: 2378:  ecma_object_t *array_p = ecma_op_new_array_object (size);
    #####: 2379:  return ecma_make_object_value (array_p);
        -: 2380:} /* jerry_create_array */
        -: 2381:
        -: 2382:/**
        -: 2383: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 2384: *
        -: 2385: * @return value of the created boolean
        -: 2386: */
        -: 2387:jerry_value_t
    #####: 2388:jerry_create_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 2389:{
        -: 2390:  jerry_assert_api_available ();
        -: 2391:
    #####: 2392:  return jerry_return (ecma_make_boolean_value (value));
        -: 2393:} /* jerry_create_boolean */
        -: 2394:
        -: 2395:/**
        -: 2396: * Create an error object
        -: 2397: *
        -: 2398: * Note:
        -: 2399: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2400: *      - the error flag is set for the returned value
        -: 2401: *
        -: 2402: * @return value of the constructed error object
        -: 2403: */
        -: 2404:jerry_value_t
    #####: 2405:jerry_create_error (jerry_error_t error_type, /**< type of error */
        -: 2406:                    const jerry_char_t *message_p) /**< value of 'message' property
        -: 2407:                                                    *   of constructed error object */
        -: 2408:{
    #####: 2409:  return jerry_create_error_sz (error_type,
        -: 2410:                                (lit_utf8_byte_t *) message_p,
        -: 2411:                                lit_zt_utf8_string_size (message_p));
        -: 2412:} /* jerry_create_error */
        -: 2413:
        -: 2414:/**
        -: 2415: * Create an error object
        -: 2416: *
        -: 2417: * Note:
        -: 2418: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2419: *      - the error flag is set for the returned value
        -: 2420: *
        -: 2421: * @return value of the constructed error object
        -: 2422: */
        -: 2423:jerry_value_t
    #####: 2424:jerry_create_error_sz (jerry_error_t error_type, /**< type of error */
        -: 2425:                       const jerry_char_t *message_p, /**< value of 'message' property
        -: 2426:                                                       *   of constructed error object */
        -: 2427:                       jerry_size_t message_size) /**< size of the message in bytes */
        -: 2428:{
        -: 2429:  jerry_assert_api_available ();
        -: 2430:
    #####: 2431:  if (message_p == NULL || message_size == 0)
        -: 2432:  {
    #####: 2433:    return ecma_create_error_object_reference (ecma_new_standard_error ((jerry_error_t) error_type, NULL));
        -: 2434:  }
        -: 2435:  else
        -: 2436:  {
    #####: 2437:    ecma_string_t *message_string_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) message_p,
        -: 2438:                                                                      (lit_utf8_size_t) message_size);
        -: 2439:
    #####: 2440:    ecma_object_t *error_object_p = ecma_new_standard_error ((jerry_error_t) error_type,
        -: 2441:                                                             message_string_p);
        -: 2442:
    #####: 2443:    ecma_deref_ecma_string (message_string_p);
        -: 2444:
    #####: 2445:    return ecma_create_error_object_reference (error_object_p);
        -: 2446:  }
        -: 2447:} /* jerry_create_error_sz */
        -: 2448:
        -: 2449:/**
        -: 2450: * Create an external function object
        -: 2451: *
        -: 2452: * Note:
        -: 2453: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2454: *
        -: 2455: * @return value of the constructed function object
        -: 2456: */
        -: 2457:jerry_value_t
        5: 2458:jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler
        -: 2459:                                                                     *   for the function */
        -: 2460:{
        -: 2461:  jerry_assert_api_available ();
        -: 2462:
        5: 2463:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);
        5: 2464:  return ecma_make_object_value (func_obj_p);
        -: 2465:} /* jerry_create_external_function */
        -: 2466:
        -: 2467:/**
        -: 2468: * Creates a jerry_value_t representing a number value.
        -: 2469: *
        -: 2470: * Note:
        -: 2471: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2472: *
        -: 2473: * @return jerry_value_t created from the given double argument.
        -: 2474: */
        -: 2475:jerry_value_t
    #####: 2476:jerry_create_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 2477:{
        -: 2478:  jerry_assert_api_available ();
        -: 2479:
    #####: 2480:  return ecma_make_number_value ((ecma_number_t) value);
        -: 2481:} /* jerry_create_number */
        -: 2482:
        -: 2483:/**
        -: 2484: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 2485: *
        -: 2486: * Note:
        -: 2487: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2488: *
        -: 2489: * @return jerry_value_t representing an infinity value.
        -: 2490: */
        -: 2491:jerry_value_t
    #####: 2492:jerry_create_number_infinity (bool sign) /**< true for negative Infinity
        -: 2493:                                          *   false for positive Infinity */
        -: 2494:{
        -: 2495:  jerry_assert_api_available ();
        -: 2496:
    #####: 2497:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 2498:} /* jerry_create_number_infinity */
        -: 2499:
        -: 2500:/**
        -: 2501: * Creates a jerry_value_t representing a not-a-number value.
        -: 2502: *
        -: 2503: * Note:
        -: 2504: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2505: *
        -: 2506: * @return jerry_value_t representing a not-a-number value.
        -: 2507: */
        -: 2508:jerry_value_t
    #####: 2509:jerry_create_number_nan (void)
        -: 2510:{
        -: 2511:  jerry_assert_api_available ();
        -: 2512:
    #####: 2513:  return ecma_make_nan_value ();
        -: 2514:} /* jerry_create_number_nan */
        -: 2515:
        -: 2516:/**
        -: 2517: * Creates a jerry_value_t representing an undefined value.
        -: 2518: *
        -: 2519: * @return value of undefined
        -: 2520: */
        -: 2521:jerry_value_t
    #####: 2522:jerry_create_undefined (void)
        -: 2523:{
        -: 2524:  jerry_assert_api_available ();
        -: 2525:
    #####: 2526:  return ECMA_VALUE_UNDEFINED;
        -: 2527:} /* jerry_create_undefined */
        -: 2528:
        -: 2529:/**
        -: 2530: * Creates and returns a jerry_value_t with type null object.
        -: 2531: *
        -: 2532: * @return jerry_value_t representing null
        -: 2533: */
        -: 2534:jerry_value_t
    #####: 2535:jerry_create_null (void)
        -: 2536:{
        -: 2537:  jerry_assert_api_available ();
        -: 2538:
    #####: 2539:  return ECMA_VALUE_NULL;
        -: 2540:} /* jerry_create_null */
        -: 2541:
        -: 2542:/**
        -: 2543: * Create new JavaScript object, like with new Object().
        -: 2544: *
        -: 2545: * Note:
        -: 2546: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2547: *
        -: 2548: * @return value of the created object
        -: 2549: */
        -: 2550:jerry_value_t
    #####: 2551:jerry_create_object (void)
        -: 2552:{
        -: 2553:  jerry_assert_api_available ();
        -: 2554:
    #####: 2555:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 2556:} /* jerry_create_object */
        -: 2557:
        -: 2558:/**
        -: 2559: * Create an empty Promise object which can be resolve/reject later
        -: 2560: * by calling jerry_resolve_or_reject_promise.
        -: 2561: *
        -: 2562: * Note:
        -: 2563: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2564: *
        -: 2565: * @return value of the created object
        -: 2566: */
        -: 2567:jerry_value_t
    #####: 2568:jerry_create_promise (void)
        -: 2569:{
        -: 2570:  jerry_assert_api_available ();
        -: 2571:
        -: 2572:#if JERRY_ESNEXT
    #####: 2573:  ecma_value_t promise_value = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2574:
    #####: 2575:  return promise_value;
        -: 2576:#else /* !JERRY_ESNEXT */
    #####: 2577:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 2578:#endif /* JERRY_ESNEXT */
        -: 2579:} /* jerry_create_promise */
        -: 2580:
        -: 2581:/**
        -: 2582: * Create a new Proxy object with the given target and handler
        -: 2583: *
        -: 2584: * Note:
        -: 2585: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2586: *
        -: 2587: * @return value of the created Proxy object
        -: 2588: */
        -: 2589:jerry_value_t
    #####: 2590:jerry_create_proxy (const jerry_value_t target, /**< target argument */
        -: 2591:                    const jerry_value_t handler) /**< handler argument */
        -: 2592:{
        -: 2593:  jerry_assert_api_available ();
        -: 2594:
    #####: 2595:  if (ecma_is_value_error_reference (target)
    #####: 2596:      || ecma_is_value_error_reference (handler))
        -: 2597:  {
    #####: 2598:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2599:  }
        -: 2600:
        -: 2601:#if JERRY_BUILTIN_PROXY
    #####: 2602:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, 0);
    #####: 2603:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2604:#else /* !JERRY_BUILTIN_PROXY */
    #####: 2605:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2606:#endif /* JERRY_BUILTIN_PROXY */
        -: 2607:} /* jerry_create_proxy */
        -: 2608:
        -: 2609:#if JERRY_BUILTIN_PROXY
        -: 2610:
        -: 2611:JERRY_STATIC_ASSERT ((int) JERRY_PROXY_SKIP_RESULT_VALIDATION == (int) ECMA_PROXY_SKIP_RESULT_VALIDATION,
        -: 2612:                     jerry_and_ecma_proxy_skip_result_validation_must_be_equal);
        -: 2613:
        -: 2614:#endif /* JERRY_BUILTIN_PROXY */
        -: 2615:
        -: 2616:/**
        -: 2617: * Create a new Proxy object with the given target, handler, and special options
        -: 2618: *
        -: 2619: * Note:
        -: 2620: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2621: *
        -: 2622: * @return value of the created Proxy object
        -: 2623: */
        -: 2624:jerry_value_t
    #####: 2625:jerry_create_special_proxy (const jerry_value_t target, /**< target argument */
        -: 2626:                            const jerry_value_t handler, /**< handler argument */
        -: 2627:                            uint32_t options) /**< jerry_proxy_object_options_t option bits */
        -: 2628:{
        -: 2629:  jerry_assert_api_available ();
        -: 2630:
    #####: 2631:  if (ecma_is_value_error_reference (target)
    #####: 2632:      || ecma_is_value_error_reference (handler))
        -: 2633:  {
    #####: 2634:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2635:  }
        -: 2636:
        -: 2637:#if JERRY_BUILTIN_PROXY
    #####: 2638:  options &= JERRY_PROXY_SKIP_RESULT_VALIDATION;
        -: 2639:
    #####: 2640:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, options);
    #####: 2641:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2642:#else /* !JERRY_BUILTIN_PROXY */
        -: 2643:  JERRY_UNUSED (options);
    #####: 2644:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2645:#endif /* JERRY_BUILTIN_PROXY */
        -: 2646:} /* jerry_create_special_proxy */
        -: 2647:
        -: 2648:/**
        -: 2649: * Create string from a valid UTF-8 string
        -: 2650: *
        -: 2651: * Note:
        -: 2652: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2653: *
        -: 2654: * @return value of the created string
        -: 2655: */
        -: 2656:jerry_value_t
    #####: 2657:jerry_create_string_from_utf8 (const jerry_char_t *str_p) /**< pointer to string */
        -: 2658:{
    #####: 2659:  return jerry_create_string_sz_from_utf8 (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2660:} /* jerry_create_string_from_utf8 */
        -: 2661:
        -: 2662:/**
        -: 2663: * Create string from a valid UTF-8 string
        -: 2664: *
        -: 2665: * Note:
        -: 2666: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2667: *
        -: 2668: * @return value of the created string
        -: 2669: */
        -: 2670:jerry_value_t
    #####: 2671:jerry_create_string_sz_from_utf8 (const jerry_char_t *str_p, /**< pointer to string */
        -: 2672:                                  jerry_size_t str_size) /**< string size */
        -: 2673:{
        -: 2674:  jerry_assert_api_available ();
        -: 2675:
    #####: 2676:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2677:                                                                                 (lit_utf8_size_t) str_size);
        -: 2678:
    #####: 2679:  return ecma_make_string_value (ecma_str_p);
        -: 2680:} /* jerry_create_string_sz_from_utf8 */
        -: 2681:
        -: 2682:/**
        -: 2683: * Create string from a valid CESU-8 string
        -: 2684: *
        -: 2685: * Note:
        -: 2686: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2687: *
        -: 2688: * @return value of the created string
        -: 2689: */
        -: 2690:jerry_value_t
        5: 2691:jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */
        -: 2692:{
        5: 2693:  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2694:} /* jerry_create_string */
        -: 2695:
        -: 2696:/**
        -: 2697: * Create string from a valid CESU-8 string
        -: 2698: *
        -: 2699: * Note:
        -: 2700: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2701: *
        -: 2702: * @return value of the created string
        -: 2703: */
        -: 2704:jerry_value_t
        6: 2705:jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2706:                        jerry_size_t str_size) /**< string size */
        -: 2707:{
        -: 2708:  jerry_assert_api_available ();
        -: 2709:
        6: 2710:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,
        -: 2711:                                                              (lit_utf8_size_t) str_size);
        6: 2712:  return ecma_make_string_value (ecma_str_p);
        -: 2713:} /* jerry_create_string_sz */
        -: 2714:
        -: 2715:/**
        -: 2716: * Create external string from a valid CESU-8 string
        -: 2717: *
        -: 2718: * Note:
        -: 2719: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2720: *
        -: 2721: * @return value of the created external string
        -: 2722: */
        -: 2723:jerry_value_t
    #####: 2724:jerry_create_external_string (const jerry_char_t *str_p, /**< pointer to string */
        -: 2725:                              void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2726:{
    #####: 2727:  return jerry_create_external_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p), user_p);
        -: 2728:} /* jerry_create_external_string */
        -: 2729:
        -: 2730:/**
        -: 2731: * Create external string from a valid CESU-8 string
        -: 2732: *
        -: 2733: * Note:
        -: 2734: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2735: *
        -: 2736: * @return value of the created external string
        -: 2737: */
        -: 2738:jerry_value_t
    #####: 2739:jerry_create_external_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2740:                                 jerry_size_t str_size, /**< string size */
        -: 2741:                                 void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2742:{
        -: 2743:  jerry_assert_api_available ();
        -: 2744:
    #####: 2745:  ecma_string_t *ecma_str_p = ecma_new_ecma_external_string_from_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2746:                                                                        (lit_utf8_size_t) str_size,
        -: 2747:                                                                        user_p);
    #####: 2748:  return ecma_make_string_value (ecma_str_p);
        -: 2749:} /* jerry_create_external_string_sz */
        -: 2750:
        -: 2751:/**
        -: 2752: * Create symbol from an api value
        -: 2753: *
        -: 2754: * Note:
        -: 2755: *      The given argument is converted to string. This operation can throw an error.
        -: 2756: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2757: *
        -: 2758: * @return value of the created symbol, if success
        -: 2759: *         thrown error, otherwise
        -: 2760: */
        -: 2761:jerry_value_t
    #####: 2762:jerry_create_symbol (const jerry_value_t value) /**< api value */
        -: 2763:{
        -: 2764:  jerry_assert_api_available ();
        -: 2765:
    #####: 2766:  if (ecma_is_value_error_reference (value))
        -: 2767:  {
    #####: 2768:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2769:  }
        -: 2770:
        -: 2771:#if JERRY_ESNEXT
    #####: 2772:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 2773:#else /* !JERRY_ESNEXT */
    #####: 2774:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 2775:#endif /* JERRY_ESNEXT */
        -: 2776:} /* jerry_create_symbol */
        -: 2777:
        -: 2778:/**
        -: 2779: * Create BigInt from a sequence of uint64 digits
        -: 2780: *
        -: 2781: * @return value of the created bigint, if success
        -: 2782: *         thrown error, otherwise
        -: 2783: */
        -: 2784:jerry_value_t
    #####: 2785:jerry_create_bigint (const uint64_t *digits_p, /**< BigInt digits (lowest digit first) */
        -: 2786:                     uint32_t size, /**< number of BigInt digits */
        -: 2787:                     bool sign) /**< sign bit, true if the result should be negative */
        -: 2788:{
        -: 2789:  jerry_assert_api_available ();
        -: 2790:
        -: 2791:#if JERRY_BUILTIN_BIGINT
    #####: 2792:  return jerry_return (ecma_bigint_create_from_digits (digits_p, size, sign));
        -: 2793:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2794:  JERRY_UNUSED (digits_p);
        -: 2795:  JERRY_UNUSED (size);
        -: 2796:  JERRY_UNUSED (sign);
    #####: 2797:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2798:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2799:} /* jerry_create_bigint */
        -: 2800:
        -: 2801:/**
        -: 2802: * Calculates the size of the given pattern and creates a RegExp object.
        -: 2803: *
        -: 2804: * @return value of the constructed RegExp object.
        -: 2805: */
        -: 2806:jerry_value_t
    #####: 2807:jerry_create_regexp (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2808:                     uint16_t flags) /**< optional RegExp flags */
        -: 2809:{
    #####: 2810:  return jerry_create_regexp_sz (pattern_p, lit_zt_utf8_string_size (pattern_p), flags);
        -: 2811:} /* jerry_create_regexp */
        -: 2812:
        -: 2813:/**
        -: 2814: * Creates a RegExp object with the given pattern and flags.
        -: 2815: *
        -: 2816: * @return value of the constructed RegExp object.
        -: 2817: */
        -: 2818:jerry_value_t
    #####: 2819:jerry_create_regexp_sz (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2820:                        jerry_size_t pattern_size, /**< length of the pattern */
        -: 2821:                        uint16_t flags) /**< optional RegExp flags */
        -: 2822:{
        -: 2823:  jerry_assert_api_available ();
        -: 2824:
        -: 2825:#if JERRY_BUILTIN_REGEXP
    #####: 2826:  if (!lit_is_valid_utf8_string (pattern_p, pattern_size, true))
        -: 2827:  {
    #####: 2828:    return jerry_throw (ecma_raise_common_error (ECMA_ERR_MSG ("Input must be a valid utf8 string")));
        -: 2829:  }
        -: 2830:
    #####: 2831:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 2832:
    #####: 2833:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 2834:  {
    #####: 2835:    return ECMA_VALUE_ERROR;
        -: 2836:  }
        -: 2837:
    #####: 2838:  ecma_string_t *ecma_pattern = ecma_new_ecma_string_from_utf8 (pattern_p, pattern_size);
        -: 2839:
    #####: 2840:  jerry_value_t ret_val = ecma_op_create_regexp_with_flags (regexp_obj_p,
        -: 2841:                                                            ecma_make_string_value (ecma_pattern),
        -: 2842:                                                            flags);
    #####: 2843:  ecma_deref_ecma_string (ecma_pattern);
        -: 2844:
    #####: 2845:  return ret_val;
        -: 2846:
        -: 2847:#else /* !JERRY_BUILTIN_REGEXP */
        -: 2848:  JERRY_UNUSED (pattern_p);
        -: 2849:  JERRY_UNUSED (pattern_size);
        -: 2850:  JERRY_UNUSED (flags);
        -: 2851:
        -: 2852:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("RegExp is not supported")));
        -: 2853:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2854:} /* jerry_create_regexp_sz */
        -: 2855:
        -: 2856:/**
        -: 2857: * Creates a new realm (global object).
        -: 2858: *
        -: 2859: * @return new realm object
        -: 2860: */
        -: 2861:jerry_value_t
    #####: 2862:jerry_create_realm (void)
        -: 2863:{
        -: 2864:  jerry_assert_api_available ();
        -: 2865:
        -: 2866:#if JERRY_BUILTIN_REALMS
    #####: 2867:  ecma_global_object_t *global_object_p = ecma_builtin_create_global_object ();
    #####: 2868:  return ecma_make_object_value ((ecma_object_t *) global_object_p);
        -: 2869:#else /* !JERRY_BUILTIN_REALMS */
    #####: 2870:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Realms are disabled")));
        -: 2871:#endif /* JERRY_BUILTIN_REALMS */
        -: 2872:} /* jerry_create_realm */
        -: 2873:
        -: 2874:/**
        -: 2875: * Get length of an array object
        -: 2876: *
        -: 2877: * Note:
        -: 2878: *      Returns 0, if the value parameter is not an array object.
        -: 2879: *
        -: 2880: * @return length of the given array
        -: 2881: */
        -: 2882:uint32_t
    #####: 2883:jerry_get_array_length (const jerry_value_t value) /**< api value */
        -: 2884:{
        -: 2885:  jerry_assert_api_available ();
        -: 2886:
    #####: 2887:  if (!jerry_value_is_object (value))
        -: 2888:  {
    #####: 2889:    return 0;
        -: 2890:  }
        -: 2891:
    #####: 2892:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2893:
    #####: 2894:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -: 2895:  {
    #####: 2896:    return ecma_array_get_length (object_p);
        -: 2897:  }
        -: 2898:
    #####: 2899:  return 0;
        -: 2900:} /* jerry_get_array_length */
        -: 2901:
        -: 2902:/**
        -: 2903: * Get size of Jerry string
        -: 2904: *
        -: 2905: * Note:
        -: 2906: *      Returns 0, if the value parameter is not a string.
        -: 2907: *
        -: 2908: * @return number of bytes in the buffer needed to represent the string
        -: 2909: */
        -: 2910:jerry_size_t
    #####: 2911:jerry_get_string_size (const jerry_value_t value) /**< input string */
        -: 2912:{
        -: 2913:  jerry_assert_api_available ();
        -: 2914:
    #####: 2915:  if (!ecma_is_value_string (value))
        -: 2916:  {
    #####: 2917:    return 0;
        -: 2918:  }
        -: 2919:
    #####: 2920:  return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 2921:} /* jerry_get_string_size */
        -: 2922:
        -: 2923:/**
        -: 2924: * Get UTF-8 encoded string size from Jerry string
        -: 2925: *
        -: 2926: * Note:
        -: 2927: *      Returns 0, if the value parameter is not a string.
        -: 2928: *
        -: 2929: * @return number of bytes in the buffer needed to represent the UTF-8 encoded string
        -: 2930: */
        -: 2931:jerry_size_t
    #####: 2932:jerry_get_utf8_string_size (const jerry_value_t value) /**< input string */
        -: 2933:{
        -: 2934:  jerry_assert_api_available ();
        -: 2935:
    #####: 2936:  if (!ecma_is_value_string (value))
        -: 2937:  {
    #####: 2938:    return 0;
        -: 2939:  }
        -: 2940:
    #####: 2941:  return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 2942:} /* jerry_get_utf8_string_size */
        -: 2943:
        -: 2944:/**
        -: 2945: * Get length of Jerry string
        -: 2946: *
        -: 2947: * Note:
        -: 2948: *      Returns 0, if the value parameter is not a string.
        -: 2949: *
        -: 2950: * @return number of characters in the string
        -: 2951: */
        -: 2952:jerry_length_t
    #####: 2953:jerry_get_string_length (const jerry_value_t value) /**< input string */
        -: 2954:{
        -: 2955:  jerry_assert_api_available ();
        -: 2956:
    #####: 2957:  if (!ecma_is_value_string (value))
        -: 2958:  {
    #####: 2959:    return 0;
        -: 2960:  }
        -: 2961:
    #####: 2962:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 2963:} /* jerry_get_string_length */
        -: 2964:
        -: 2965:/**
        -: 2966: * Get UTF-8 string length from Jerry string
        -: 2967: *
        -: 2968: * Note:
        -: 2969: *      Returns 0, if the value parameter is not a string.
        -: 2970: *
        -: 2971: * @return number of characters in the string
        -: 2972: */
        -: 2973:jerry_length_t
    #####: 2974:jerry_get_utf8_string_length (const jerry_value_t value) /**< input string */
        -: 2975:{
        -: 2976:  jerry_assert_api_available ();
        -: 2977:
    #####: 2978:  if (!ecma_is_value_string (value))
        -: 2979:  {
    #####: 2980:    return 0;
        -: 2981:  }
        -: 2982:
    #####: 2983:  return ecma_string_get_utf8_length (ecma_get_string_from_value (value));
        -: 2984:} /* jerry_get_utf8_string_length */
        -: 2985:
        -: 2986:/**
        -: 2987: * Copy the characters of a string into a specified buffer.
        -: 2988: *
        -: 2989: * Note:
        -: 2990: *      The '\0' character could occur in character buffer.
        -: 2991: *      Returns 0, if the value parameter is not a string or
        -: 2992: *      the buffer is not large enough for the whole string.
        -: 2993: *
        -: 2994: * Note:
        -: 2995: *      If the size of the string in jerry value is larger than the size of the
        -: 2996: *      target buffer, the copy will fail.
        -: 2997: *      To copy substring use jerry_substring_to_char_buffer() instead.
        -: 2998: *
        -: 2999: * @return number of bytes, actually copied to the buffer.
        -: 3000: */
        -: 3001:jerry_size_t
    #####: 3002:jerry_string_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3003:                             jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3004:                             jerry_size_t buffer_size) /**< size of output buffer */
        -: 3005:{
        -: 3006:  jerry_assert_api_available ();
        -: 3007:
    #####: 3008:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3009:  {
    #####: 3010:    return 0;
        -: 3011:  }
        -: 3012:
    #####: 3013:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3014:
    #####: 3015:  if (ecma_string_get_size (str_p) > buffer_size)
        -: 3016:  {
    #####: 3017:    return 0;
        -: 3018:  }
        -: 3019:
    #####: 3020:  return ecma_string_copy_to_cesu8_buffer (str_p,
        -: 3021:                                           (lit_utf8_byte_t *) buffer_p,
        -: 3022:                                           buffer_size);
        -: 3023:} /* jerry_string_to_char_buffer */
        -: 3024:
        -: 3025:/**
        -: 3026: * Copy the characters of an utf-8 encoded string into a specified buffer.
        -: 3027: *
        -: 3028: * Note:
        -: 3029: *      The '\0' character could occur anywhere in the returned string
        -: 3030: *      Returns 0, if the value parameter is not a string or the buffer
        -: 3031: *      is not large enough for the whole string.
        -: 3032: *
        -: 3033: * Note:
        -: 3034: *      If the size of the string in jerry value is larger than the size of the
        -: 3035: *      target buffer, the copy will fail.
        -: 3036: *      To copy a substring use jerry_substring_to_utf8_char_buffer() instead.
        -: 3037: *
        -: 3038: * @return number of bytes copied to the buffer.
        -: 3039: */
        -: 3040:jerry_size_t
    #####: 3041:jerry_string_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3042:                                  jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3043:                                  jerry_size_t buffer_size) /**< size of output buffer */
        -: 3044:{
        -: 3045:  jerry_assert_api_available ();
        -: 3046:
    #####: 3047:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3048:  {
    #####: 3049:    return 0;
        -: 3050:  }
        -: 3051:
    #####: 3052:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3053:
    #####: 3054:  if (ecma_string_get_utf8_size (str_p) > buffer_size)
        -: 3055:  {
    #####: 3056:    return 0;
        -: 3057:  }
        -: 3058:
    #####: 3059:  return ecma_string_copy_to_utf8_buffer (str_p,
        -: 3060:                                          (lit_utf8_byte_t *) buffer_p,
        -: 3061:                                          buffer_size);
        -: 3062:} /* jerry_string_to_utf8_char_buffer */
        -: 3063:
        -: 3064:/**
        -: 3065: * Copy the characters of an cesu-8 encoded substring into a specified buffer.
        -: 3066: *
        -: 3067: * Note:
        -: 3068: *      The '\0' character could occur anywhere in the returned string
        -: 3069: *      Returns 0, if the value parameter is not a string.
        -: 3070: *      It will extract the substring beetween the specified start position
        -: 3071: *      and the end position (or the end of the string, whichever comes first).
        -: 3072: *
        -: 3073: * @return number of bytes copied to the buffer.
        -: 3074: */
        -: 3075:jerry_size_t
    #####: 3076:jerry_substring_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3077:                                jerry_length_t start_pos, /**< position of the first character */
        -: 3078:                                jerry_length_t end_pos, /**< position of the last character */
        -: 3079:                                jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3080:                                jerry_size_t buffer_size) /**< size of output buffer */
        -: 3081:{
        -: 3082:  jerry_assert_api_available ();
        -: 3083:
    #####: 3084:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3085:  {
    #####: 3086:    return 0;
        -: 3087:  }
        -: 3088:
    #####: 3089:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3090:
    #####: 3091:  return ecma_substring_copy_to_cesu8_buffer (str_p,
        -: 3092:                                              start_pos,
        -: 3093:                                              end_pos,
        -: 3094:                                              (lit_utf8_byte_t *) buffer_p,
        -: 3095:                                              buffer_size);
        -: 3096:} /* jerry_substring_to_char_buffer */
        -: 3097:
        -: 3098:/**
        -: 3099: * Copy the characters of an utf-8 encoded substring into a specified buffer.
        -: 3100: *
        -: 3101: * Note:
        -: 3102: *      The '\0' character could occur anywhere in the returned string
        -: 3103: *      Returns 0, if the value parameter is not a string.
        -: 3104: *      It will extract the substring beetween the specified start position
        -: 3105: *      and the end position (or the end of the string, whichever comes first).
        -: 3106: *
        -: 3107: * @return number of bytes copied to the buffer.
        -: 3108: */
        -: 3109:jerry_size_t
    #####: 3110:jerry_substring_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3111:                                     jerry_length_t start_pos, /**< position of the first character */
        -: 3112:                                     jerry_length_t end_pos, /**< position of the last character */
        -: 3113:                                     jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3114:                                     jerry_size_t buffer_size) /**< size of output buffer */
        -: 3115:{
        -: 3116:  jerry_assert_api_available ();
        -: 3117:
    #####: 3118:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3119:  {
    #####: 3120:    return 0;
        -: 3121:  }
        -: 3122:
    #####: 3123:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3124:
    #####: 3125:  return ecma_substring_copy_to_utf8_buffer (str_p,
        -: 3126:                                             start_pos,
        -: 3127:                                             end_pos,
        -: 3128:                                             (lit_utf8_byte_t *) buffer_p,
        -: 3129:                                             buffer_size);
        -: 3130:} /* jerry_substring_to_utf8_char_buffer */
        -: 3131:
        -: 3132:/**
        -: 3133: * Sets the global callback which is called when an external string is freed.
        -: 3134: */
        -: 3135:void
    #####: 3136:jerry_string_set_external_free_callback (jerry_external_string_free_callback_t callback_p) /**< free callback */
        -: 3137:{
    #####: 3138:  JERRY_CONTEXT (external_string_free_callback_p) = callback_p;
    #####: 3139:} /* jerry_string_set_external_free_callback */
        -: 3140:
        -: 3141:/**
        -: 3142: * Returns the user pointer assigned to an external string.
        -: 3143: *
        -: 3144: * @return user pointer, if value is an external string
        -: 3145: *         NULL, otherwise
        -: 3146: */
        -: 3147:void *
    #####: 3148:jerry_string_get_external_user_pointer (const jerry_value_t value, /**< string value */
        -: 3149:                                        bool *is_external) /**< [out] true - if value is an external string,
        -: 3150:                                                            *         false - otherwise */
        -: 3151:{
    #####: 3152:  if (is_external != NULL)
        -: 3153:  {
    #####: 3154:    *is_external = false;
        -: 3155:  }
        -: 3156:
    #####: 3157:  if (!ecma_is_value_string (value))
        -: 3158:  {
    #####: 3159:    return NULL;
        -: 3160:  }
        -: 3161:
    #####: 3162:  ecma_string_t *string_p = ecma_get_string_from_value (value);
        -: 3163:
    #####: 3164:  if (ECMA_IS_DIRECT_STRING (string_p)
    #####: 3165:      || ECMA_STRING_GET_CONTAINER (string_p) != ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 3166:  {
    #####: 3167:    return NULL;
        -: 3168:  }
        -: 3169:
    #####: 3170:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 3171:
    #####: 3172:  if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -: 3173:  {
    #####: 3174:    return NULL;
        -: 3175:  }
        -: 3176:
    #####: 3177:  if (is_external != NULL)
        -: 3178:  {
    #####: 3179:    *is_external = true;
        -: 3180:  }
        -: 3181:
    #####: 3182:  return ((ecma_external_string_t *) string_p)->user_p;
        -: 3183:} /* jerry_string_get_external_user_pointer */
        -: 3184:
        -: 3185:/**
        -: 3186: * Checks whether the object or it's prototype objects have the given property.
        -: 3187: *
        -: 3188: * @return raised error - if the operation fail
        -: 3189: *         true/false API value  - depend on whether the property exists
        -: 3190: */
        -: 3191:jerry_value_t
    #####: 3192:jerry_has_property (const jerry_value_t obj_val, /**< object value */
        -: 3193:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3194:{
        -: 3195:  jerry_assert_api_available ();
        -: 3196:
    #####: 3197:  if (!ecma_is_value_object (obj_val)
    #####: 3198:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3199:  {
    #####: 3200:    return ECMA_VALUE_FALSE;
        -: 3201:  }
        -: 3202:
    #####: 3203:  return jerry_return (ecma_op_object_has_property (ecma_get_object_from_value (obj_val),
        -: 3204:                                                    ecma_get_prop_name_from_value (prop_name_val)));
        -: 3205:} /* jerry_has_property */
        -: 3206:
        -: 3207:/**
        -: 3208: * Checks whether the object has the given property.
        -: 3209: *
        -: 3210: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 3211: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 3212: */
        -: 3213:jerry_value_t
    #####: 3214:jerry_has_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3215:                        const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3216:{
        -: 3217:  jerry_assert_api_available ();
        -: 3218:
    #####: 3219:  if (!ecma_is_value_object (obj_val)
    #####: 3220:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3221:  {
    #####: 3222:    return ECMA_VALUE_FALSE;
        -: 3223:  }
        -: 3224:
    #####: 3225:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 3226:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3227:
        -: 3228:#if JERRY_BUILTIN_PROXY
    #####: 3229:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 3230:  {
    #####: 3231:    ecma_property_descriptor_t prop_desc;
        -: 3232:
    #####: 3233:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 3234:
    #####: 3235:    if (ecma_is_value_true (status))
        -: 3236:    {
    #####: 3237:      ecma_free_property_descriptor (&prop_desc);
        -: 3238:    }
        -: 3239:
    #####: 3240:    return jerry_return (status);
        -: 3241:  }
        -: 3242:#endif /* JERRY_BUILTIN_PROXY */
        -: 3243:
    #####: 3244:  return ecma_make_boolean_value (ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p));
        -: 3245:} /* jerry_has_own_property */
        -: 3246:
        -: 3247:/**
        -: 3248: * Checks whether the object has the given internal property.
        -: 3249: *
        -: 3250: * @return true  - if the internal property exists
        -: 3251: *         false - otherwise
        -: 3252: */
        -: 3253:bool
    #####: 3254:jerry_has_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3255:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3256:{
        -: 3257:  jerry_assert_api_available ();
        -: 3258:
    #####: 3259:  if (!ecma_is_value_object (obj_val)
    #####: 3260:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3261:  {
    #####: 3262:    return false;
        -: 3263:  }
        -: 3264:
    #####: 3265:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3266:
    #####: 3267:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3268:
    #####: 3269:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3270:  {
    #####: 3271:    return false;
        -: 3272:  }
        -: 3273:
    #####: 3274:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3275:
    #####: 3276:  if (property_p == NULL)
        -: 3277:  {
    #####: 3278:    return false;
        -: 3279:  }
        -: 3280:
    #####: 3281:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3282:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3283:
    #####: 3284:  return property_p != NULL;
        -: 3285:} /* jerry_has_internal_property */
        -: 3286:
        -: 3287:/**
        -: 3288: * Delete a property from an object.
        -: 3289: *
        -: 3290: * @return true  - if property was deleted successfully
        -: 3291: *         false - otherwise
        -: 3292: */
        -: 3293:bool
    #####: 3294:jerry_delete_property (const jerry_value_t obj_val, /**< object value */
        -: 3295:                       const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3296:{
        -: 3297:  jerry_assert_api_available ();
        -: 3298:
    #####: 3299:  if (!ecma_is_value_object (obj_val)
    #####: 3300:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3301:  {
    #####: 3302:    return false;
        -: 3303:  }
        -: 3304:
    #####: 3305:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3306:                                                  ecma_get_prop_name_from_value (prop_name_val),
        -: 3307:                                                  false);
        -: 3308:
        -: 3309:#if JERRY_BUILTIN_PROXY
    #####: 3310:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3311:  {
        -: 3312:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3313:    jcontext_release_exception ();
        -: 3314:  }
        -: 3315:#endif /* JERRY_BUILTIN_PROXY */
        -: 3316:
    #####: 3317:  return ecma_is_value_true (ret_value);
        -: 3318:} /* jerry_delete_property */
        -: 3319:
        -: 3320:/**
        -: 3321: * Delete indexed property from the specified object.
        -: 3322: *
        -: 3323: * @return true  - if property was deleted successfully
        -: 3324: *         false - otherwise
        -: 3325: */
        -: 3326:bool
    #####: 3327:jerry_delete_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3328:                                uint32_t index) /**< index to be written */
        -: 3329:{
        -: 3330:  jerry_assert_api_available ();
        -: 3331:
    #####: 3332:  if (!ecma_is_value_object (obj_val))
        -: 3333:  {
    #####: 3334:    return false;
        -: 3335:  }
        -: 3336:
    #####: 3337:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 3338:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3339:                                                  str_idx_p,
        -: 3340:                                                  false);
    #####: 3341:  ecma_deref_ecma_string (str_idx_p);
        -: 3342:
        -: 3343:#if JERRY_BUILTIN_PROXY
    #####: 3344:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3345:  {
        -: 3346:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3347:    jcontext_release_exception ();
        -: 3348:  }
        -: 3349:#endif /* JERRY_BUILTIN_PROXY */
        -: 3350:
    #####: 3351:  return ecma_is_value_true (ret_value);
        -: 3352:} /* jerry_delete_property_by_index */
        -: 3353:
        -: 3354:/**
        -: 3355: * Delete an internal property from an object.
        -: 3356: *
        -: 3357: * @return true  - if property was deleted successfully
        -: 3358: *         false - otherwise
        -: 3359: */
        -: 3360:bool
    #####: 3361:jerry_delete_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3362:                                const jerry_value_t prop_name_val) /**< property name value */
        -: 3363:{
        -: 3364:  jerry_assert_api_available ();
        -: 3365:
    #####: 3366:  if (!ecma_is_value_object (obj_val)
    #####: 3367:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3368:  {
    #####: 3369:    return false;
        -: 3370:  }
        -: 3371:
    #####: 3372:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3373:
    #####: 3374:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3375:
    #####: 3376:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3377:  {
    #####: 3378:    return true;
        -: 3379:  }
        -: 3380:
    #####: 3381:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3382:
    #####: 3383:  if (property_p == NULL)
        -: 3384:  {
    #####: 3385:    return true;
        -: 3386:  }
        -: 3387:
    #####: 3388:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3389:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3390:
    #####: 3391:  if (property_p == NULL)
        -: 3392:  {
    #####: 3393:    return true;
        -: 3394:  }
        -: 3395:
    #####: 3396:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 3397:
    #####: 3398:  return true;
        -: 3399:} /* jerry_delete_internal_property */
        -: 3400:
        -: 3401:/**
        -: 3402: * Get value of a property to the specified object with the given name.
        -: 3403: *
        -: 3404: * Note:
        -: 3405: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3406: *
        -: 3407: * @return value of the property - if success
        -: 3408: *         value marked with error flag - otherwise
        -: 3409: */
        -: 3410:jerry_value_t
    #####: 3411:jerry_get_property (const jerry_value_t obj_val, /**< object value */
        -: 3412:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3413:{
        -: 3414:  jerry_assert_api_available ();
        -: 3415:
    #####: 3416:  if (!ecma_is_value_object (obj_val)
    #####: 3417:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3418:  {
    #####: 3419:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3420:  }
        -: 3421:
    #####: 3422:  jerry_value_t ret_value = ecma_op_object_get (ecma_get_object_from_value (obj_val),
        -: 3423:                                                ecma_get_prop_name_from_value (prop_name_val));
    #####: 3424:  return jerry_return (ret_value);
        -: 3425:} /* jerry_get_property */
        -: 3426:
        -: 3427:/**
        -: 3428: * Get value by an index from the specified object.
        -: 3429: *
        -: 3430: * Note:
        -: 3431: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3432: *
        -: 3433: * @return value of the property specified by the index - if success
        -: 3434: *         value marked with error flag - otherwise
        -: 3435: */
        -: 3436:jerry_value_t
    #####: 3437:jerry_get_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3438:                             uint32_t index) /**< index to be written */
        -: 3439:{
        -: 3440:  jerry_assert_api_available ();
        -: 3441:
    #####: 3442:  if (!ecma_is_value_object (obj_val))
        -: 3443:  {
    #####: 3444:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3445:  }
        -: 3446:
    #####: 3447:  ecma_value_t ret_value = ecma_op_object_get_by_index (ecma_get_object_from_value (obj_val), index);
        -: 3448:
    #####: 3449:  return jerry_return (ret_value);
        -: 3450:} /* jerry_get_property_by_index */
        -: 3451:
        -: 3452:/**
        -: 3453: * Get the own property value of an object with the given name.
        -: 3454: *
        -: 3455: * Note:
        -: 3456: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3457: *
        -: 3458: * @return value of the property - if success
        -: 3459: *         value marked with error flag - otherwise
        -: 3460: */
        -: 3461:jerry_value_t
    #####: 3462:jerry_get_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3463:                        const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3464:                        const jerry_value_t receiver_val, /**< receiver object value */
        -: 3465:                        bool *found_p) /**< [out] true, if the property is found
        -: 3466:                                        *   or obj_val is a Proxy object, false otherwise */
        -: 3467:{
        -: 3468:  jerry_assert_api_available ();
        -: 3469:
    #####: 3470:  if (found_p != NULL)
        -: 3471:  {
    #####: 3472:    *found_p = false;
        -: 3473:  }
        -: 3474:
    #####: 3475:  if (!ecma_is_value_object (obj_val)
    #####: 3476:      || !ecma_is_value_prop_name (prop_name_val)
    #####: 3477:      || !ecma_is_value_object (receiver_val))
        -: 3478:  {
    #####: 3479:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3480:  }
        -: 3481:
    #####: 3482:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 3483:  ecma_string_t *property_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3484:
        -: 3485:#if JERRY_BUILTIN_PROXY
    #####: 3486:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 3487:  {
    #####: 3488:    if (found_p != NULL)
        -: 3489:    {
    #####: 3490:      *found_p = true;
        -: 3491:    }
        -: 3492:
    #####: 3493:    return jerry_return (ecma_proxy_object_get (object_p, property_name_p, receiver_val));
        -: 3494:  }
        -: 3495:#endif /* JERRY_BUILTIN_PROXY */
        -: 3496:
    #####: 3497:  ecma_value_t ret_value = ecma_op_object_find_own (receiver_val, object_p, property_name_p);
        -: 3498:
    #####: 3499:  if (ecma_is_value_found (ret_value))
        -: 3500:  {
    #####: 3501:    if (found_p != NULL)
        -: 3502:    {
    #####: 3503:      *found_p = true;
        -: 3504:    }
        -: 3505:
    #####: 3506:    return jerry_return (ret_value);
        -: 3507:  }
        -: 3508:
    #####: 3509:  return ECMA_VALUE_UNDEFINED;
        -: 3510:} /* jerry_get_own_property */
        -: 3511:
        -: 3512:/**
        -: 3513: * Get value of an internal property to the specified object with the given name.
        -: 3514: *
        -: 3515: * Note:
        -: 3516: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3517: *
        -: 3518: * @return value of the internal property - if the internal property exists
        -: 3519: *         undefined value - if the internal does not property exists
        -: 3520: *         value marked with error flag - otherwise
        -: 3521: */
        -: 3522:jerry_value_t
    #####: 3523:jerry_get_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3524:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3525:{
        -: 3526:  jerry_assert_api_available ();
        -: 3527:
    #####: 3528:  if (!ecma_is_value_object (obj_val)
    #####: 3529:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3530:  {
    #####: 3531:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3532:  }
        -: 3533:
    #####: 3534:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3535:
    #####: 3536:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3537:
    #####: 3538:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3539:  {
    #####: 3540:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3541:  }
        -: 3542:
    #####: 3543:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3544:
    #####: 3545:  if (property_p == NULL)
        -: 3546:  {
    #####: 3547:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3548:  }
        -: 3549:
    #####: 3550:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3551:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3552:
    #####: 3553:  if (property_p == NULL)
        -: 3554:  {
    #####: 3555:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3556:  }
        -: 3557:
    #####: 3558:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3559:} /* jerry_get_internal_property */
        -: 3560:
        -: 3561:/**
        -: 3562: * Set a property to the specified object with the given name.
        -: 3563: *
        -: 3564: * Note:
        -: 3565: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3566: *
        -: 3567: * @return true value - if the operation was successful
        -: 3568: *         value marked with error flag - otherwise
        -: 3569: */
        -: 3570:jerry_value_t
        5: 3571:jerry_set_property (const jerry_value_t obj_val, /**< object value */
        -: 3572:                    const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3573:                    const jerry_value_t value_to_set) /**< value to set */
        -: 3574:{
        -: 3575:  jerry_assert_api_available ();
        -: 3576:
        5: 3577:  if (ecma_is_value_error_reference (value_to_set)
        5: 3578:      || !ecma_is_value_object (obj_val)
        5: 3579:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3580:  {
    #####: 3581:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3582:  }
        -: 3583:
        5: 3584:  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),
        -: 3585:                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3586:                                           value_to_set,
        -: 3587:                                           true));
        -: 3588:} /* jerry_set_property */
        -: 3589:
        -: 3590:/**
        -: 3591: * Set indexed value in the specified object
        -: 3592: *
        -: 3593: * Note:
        -: 3594: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3595: *
        -: 3596: * @return true value - if the operation was successful
        -: 3597: *         value marked with error flag - otherwise
        -: 3598: */
        -: 3599:jerry_value_t
    #####: 3600:jerry_set_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3601:                             uint32_t index, /**< index to be written */
        -: 3602:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3603:{
        -: 3604:  jerry_assert_api_available ();
        -: 3605:
    #####: 3606:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3607:      || !ecma_is_value_object (obj_val))
        -: 3608:  {
    #####: 3609:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3610:  }
        -: 3611:
    #####: 3612:  ecma_value_t ret_value = ecma_op_object_put_by_index (ecma_get_object_from_value (obj_val),
        -: 3613:                                                        index,
        -: 3614:                                                        value_to_set,
        -: 3615:                                                        true);
        -: 3616:
    #####: 3617:  return jerry_return (ret_value);
        -: 3618:} /* jerry_set_property_by_index */
        -: 3619:
        -: 3620:/**
        -: 3621: * Set an internal property to the specified object with the given name.
        -: 3622: *
        -: 3623: * Note:
        -: 3624: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 3625: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3626: *
        -: 3627: * @return true value - if the operation was successful
        -: 3628: *         value marked with error flag - otherwise
        -: 3629: */
        -: 3630:bool
    #####: 3631:jerry_set_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3632:                             const jerry_value_t prop_name_val, /**< property name value */
        -: 3633:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3634:{
        -: 3635:  jerry_assert_api_available ();
        -: 3636:
    #####: 3637:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3638:      || !ecma_is_value_object (obj_val)
    #####: 3639:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3640:  {
    #####: 3641:    return false;
        -: 3642:  }
        -: 3643:
    #####: 3644:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3645:
    #####: 3646:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3647:
    #####: 3648:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3649:  {
    #####: 3650:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3651:  }
        -: 3652:
    #####: 3653:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3654:  ecma_object_t *internal_object_p;
        -: 3655:
    #####: 3656:  if (property_p == NULL)
        -: 3657:  {
    #####: 3658:    ecma_property_value_t *value_p = ecma_create_named_data_property (obj_p,
        -: 3659:                                                                      internal_string_p,
        -: 3660:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3661:                                                                      NULL);
        -: 3662:
    #####: 3663:    internal_object_p = ecma_create_object (NULL,
        -: 3664:                                            sizeof (ecma_extended_object_t),
        -: 3665:                                            ECMA_OBJECT_TYPE_CLASS);
        -: 3666:    {
    #####: 3667:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 3668:      container_p->u.cls.type = ECMA_OBJECT_CLASS_INTERNAL_OBJECT;
        -: 3669:    }
        -: 3670:
    #####: 3671:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 3672:    ecma_deref_object (internal_object_p);
        -: 3673:  }
        -: 3674:  else
        -: 3675:  {
    #####: 3676:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 3677:  }
        -: 3678:
    #####: 3679:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
    #####: 3680:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 3681:
    #####: 3682:  if (property_p == NULL)
        -: 3683:  {
    #####: 3684:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 3685:                                                                      prop_name_p,
        -: 3686:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3687:                                                                      NULL);
        -: 3688:
    #####: 3689:    value_p->value = ecma_copy_value_if_not_object (value_to_set);
        -: 3690:  }
        -: 3691:  else
        -: 3692:  {
    #####: 3693:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value_to_set);
        -: 3694:  }
        -: 3695:
    #####: 3696:  return true;
        -: 3697:} /* jerry_set_internal_property */
        -: 3698:
        -: 3699:/**
        -: 3700: * Construct empty property descriptor, i.e.:
        -: 3701: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 3702: *
        -: 3703: * @return empty property descriptor
        -: 3704: */
        -: 3705:jerry_property_descriptor_t
    #####: 3706:jerry_property_descriptor_create (void)
        -: 3707:{
        -: 3708:  jerry_property_descriptor_t prop_desc;
        -: 3709:
    #####: 3710:  prop_desc.flags = JERRY_PROP_NO_OPTS;
    #####: 3711:  prop_desc.value = ECMA_VALUE_UNDEFINED;
    #####: 3712:  prop_desc.getter = ECMA_VALUE_UNDEFINED;
    #####: 3713:  prop_desc.setter = ECMA_VALUE_UNDEFINED;
        -: 3714:
    #####: 3715:  return prop_desc;
        -: 3716:} /* jerry_property_descriptor_create */
        -: 3717:
        -: 3718:/**
        -: 3719: * Convert a ecma_property_descriptor_t to a jerry_property_descriptor_t
        -: 3720: *
        -: 3721: * if error occurs the property descriptor's value field is filled with ECMA_VALUE_ERROR
        -: 3722: *
        -: 3723: * @return jerry_property_descriptor_t
        -: 3724: */
        -: 3725:static jerry_property_descriptor_t
    #####: 3726:jerry_property_descriptor_from_ecma (const ecma_property_descriptor_t *prop_desc_p) /**<[out] property_descriptor */
        -: 3727:{
    #####: 3728:  jerry_property_descriptor_t prop_desc = jerry_property_descriptor_create ();
        -: 3729:
    #####: 3730:  prop_desc.flags = prop_desc_p->flags;
        -: 3731:
    #####: 3732:  if (prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED))
        -: 3733:  {
    #####: 3734:    prop_desc.value = prop_desc_p->value;
        -: 3735:  }
        -: 3736:
    #####: 3737:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3738:  {
    #####: 3739:    prop_desc.getter = ECMA_VALUE_NULL;
        -: 3740:
    #####: 3741:    if (prop_desc_p->get_p != NULL)
        -: 3742:    {
    #####: 3743:      prop_desc.getter = ecma_make_object_value (prop_desc_p->get_p);
    #####: 3744:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.getter));
        -: 3745:    }
        -: 3746:  }
        -: 3747:
    #####: 3748:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3749:  {
    #####: 3750:    prop_desc.setter = ECMA_VALUE_NULL;
        -: 3751:
    #####: 3752:    if (prop_desc_p->set_p != NULL)
        -: 3753:    {
    #####: 3754:      prop_desc.setter = ecma_make_object_value (prop_desc_p->set_p);
    #####: 3755:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.setter));
        -: 3756:    }
        -: 3757:  }
        -: 3758:
    #####: 3759:  return prop_desc;
        -: 3760:} /* jerry_property_descriptor_from_ecma */
        -: 3761:
        -: 3762:/**
        -: 3763: * Convert a jerry_property_descriptor_t to a ecma_property_descriptor_t
        -: 3764: *
        -: 3765: * Note:
        -: 3766: *     if error occurs the property descriptor's value field
        -: 3767: *     is set to ECMA_VALUE_ERROR, but no error is thrown
        -: 3768: *
        -: 3769: * @return ecma_property_descriptor_t
        -: 3770: */
        -: 3771:static ecma_property_descriptor_t
    #####: 3772:jerry_property_descriptor_to_ecma (const jerry_property_descriptor_t *prop_desc_p) /**< input property_descriptor */
        -: 3773:{
    #####: 3774:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 3775:
    #####: 3776:  prop_desc.flags = prop_desc_p->flags;
        -: 3777:
        -: 3778:  /* Copy data property info. */
    #####: 3779:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3780:  {
    #####: 3781:    if (ecma_is_value_error_reference (prop_desc_p->value)
    #####: 3782:        || (prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -: 3783:    {
    #####: 3784:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3785:      return prop_desc;
        -: 3786:    }
        -: 3787:
    #####: 3788:    prop_desc.value = prop_desc_p->value;
        -: 3789:  }
        -: 3790:
        -: 3791:  /* Copy accessor property info. */
    #####: 3792:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3793:  {
    #####: 3794:    ecma_value_t getter = prop_desc_p->getter;
        -: 3795:
    #####: 3796:    if (ecma_is_value_error_reference (getter))
        -: 3797:    {
    #####: 3798:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3799:      return prop_desc;
        -: 3800:    }
        -: 3801:
    #####: 3802:    if (ecma_op_is_callable (getter))
        -: 3803:    {
    #####: 3804:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 3805:    }
    #####: 3806:    else if (!ecma_is_value_null (getter))
        -: 3807:    {
    #####: 3808:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3809:      return prop_desc;
        -: 3810:    }
        -: 3811:  }
        -: 3812:
    #####: 3813:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3814:  {
    #####: 3815:    ecma_value_t setter = prop_desc_p->setter;
        -: 3816:
    #####: 3817:    if (ecma_is_value_error_reference (setter))
        -: 3818:    {
    #####: 3819:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3820:      return prop_desc;
        -: 3821:    }
        -: 3822:
    #####: 3823:    if (ecma_op_is_callable (setter))
        -: 3824:    {
    #####: 3825:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 3826:    }
    #####: 3827:    else if (!ecma_is_value_null (setter))
        -: 3828:    {
    #####: 3829:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3830:      return prop_desc;
        -: 3831:    }
        -: 3832:  }
        -: 3833:
    #####: 3834:  const uint16_t configurable_mask = JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED;
    #####: 3835:  const uint16_t enumerable_mask = JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_ENUMERABLE_DEFINED;
    #####: 3836:  const uint16_t writable_mask = JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED;
        -: 3837:
    #####: 3838:  if ((prop_desc_p->flags & configurable_mask) == JERRY_PROP_IS_CONFIGURABLE
    #####: 3839:      || (prop_desc_p->flags & enumerable_mask) == JERRY_PROP_IS_ENUMERABLE
    #####: 3840:      || (prop_desc_p->flags & writable_mask) == JERRY_PROP_IS_WRITABLE)
        -: 3841:  {
    #####: 3842:    prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3843:    return prop_desc;
        -: 3844:  }
        -: 3845:
    #####: 3846:  prop_desc.flags |= (uint16_t) (prop_desc_p->flags | JERRY_PROP_SHOULD_THROW);
        -: 3847:
    #####: 3848:  return prop_desc;
        -: 3849:} /* jerry_property_descriptor_to_ecma */
        -: 3850:
        -: 3851:/** Helper function to return false value or error depending on the given flag.
        -: 3852: *
        -: 3853: * @return value marked with error flag - if is_throw is true
        -: 3854: *         false value - otherwise
        -: 3855: */
        -: 3856:static jerry_value_t
    #####: 3857:jerry_type_error_or_false (const char *msg_p, /**< message */
        -: 3858:                           uint16_t flags) /**< property descriptor flags */
        -: 3859:{
    #####: 3860:  if (!(flags & JERRY_PROP_SHOULD_THROW))
        -: 3861:  {
    #####: 3862:    return ECMA_VALUE_FALSE;
        -: 3863:  }
        -: 3864:
    #####: 3865:  return jerry_throw (ecma_raise_type_error (msg_p));
        -: 3866:} /* jerry_type_error_or_false */
        -: 3867:
        -: 3868:/**
        -: 3869: * Define a property to the specified object with the given name.
        -: 3870: *
        -: 3871: * Note:
        -: 3872: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3873: *
        -: 3874: * @return true value - if the operation was successful
        -: 3875: *         false value - if the property cannot be defined and JERRY_PROP_SHOULD_THROW is not set
        -: 3876: *         value marked with error flag - otherwise
        -: 3877: */
        -: 3878:jerry_value_t
    #####: 3879:jerry_define_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3880:                           const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3881:                           const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3882:{
        -: 3883:  jerry_assert_api_available ();
        -: 3884:
    #####: 3885:  if (!ecma_is_value_object (obj_val)
    #####: 3886:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3887:  {
    #####: 3888:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3889:  }
        -: 3890:
    #####: 3891:  if (prop_desc_p->flags & (JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_VALUE_DEFINED)
    #####: 3892:      && prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 3893:  {
    #####: 3894:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3895:  }
        -: 3896:
    #####: 3897:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (prop_desc_p);
        -: 3898:
    #####: 3899:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 3900:  {
    #####: 3901:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3902:  }
        -: 3903:
    #####: 3904:  return jerry_return (ecma_op_object_define_own_property (ecma_get_object_from_value (obj_val),
        -: 3905:                                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3906:                                                           &prop_desc));
        -: 3907:} /* jerry_define_own_property */
        -: 3908:
        -: 3909:/**
        -: 3910: * Construct property descriptor from specified property.
        -: 3911: *
        -: 3912: * @return true - if success, the prop_desc_p fields contains the property info
        -: 3913: *         false - otherwise, the prop_desc_p is unchanged
        -: 3914: */
        -: 3915:jerry_value_t
    #####: 3916:jerry_get_own_property_descriptor (const jerry_value_t  obj_val, /**< object value */
        -: 3917:                                   const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3918:                                   jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3919:{
        -: 3920:  jerry_assert_api_available ();
        -: 3921:
    #####: 3922:  if (!ecma_is_value_object (obj_val)
    #####: 3923:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3924:  {
    #####: 3925:    return ECMA_VALUE_FALSE;
        -: 3926:  }
        -: 3927:
    #####: 3928:  ecma_property_descriptor_t prop_desc;
        -: 3929:
    #####: 3930:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (obj_val),
        -: 3931:                                                                    ecma_get_prop_name_from_value (prop_name_val),
        -: 3932:                                                                    &prop_desc);
        -: 3933:
        -: 3934:#if JERRY_BUILTIN_PROXY
    #####: 3935:  if (ECMA_IS_VALUE_ERROR (status))
        -: 3936:  {
    #####: 3937:    return jerry_throw (status);
        -: 3938:  }
        -: 3939:#endif /* JERRY_BUILTIN_PROXY */
        -: 3940:
    #####: 3941:  if (!ecma_is_value_true (status))
        -: 3942:  {
    #####: 3943:    return ECMA_VALUE_FALSE;
        -: 3944:  }
        -: 3945:
        -: 3946:  /* The flags are always filled in the returned descriptor. */
    #####: 3947:  JERRY_ASSERT ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 3948:                && (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 3949:                && ((prop_desc.flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 3950:                    || !(prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED)));
        -: 3951:
    #####: 3952:  prop_desc_p->flags = prop_desc.flags;
    #####: 3953:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 3954:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 3955:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 3956:
    #####: 3957:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3958:  {
    #####: 3959:    prop_desc_p->value = prop_desc.value;
        -: 3960:  }
        -: 3961:
    #####: 3962:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3963:  {
    #####: 3964:    if (prop_desc.get_p != NULL)
        -: 3965:    {
    #####: 3966:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 3967:    }
        -: 3968:    else
        -: 3969:    {
    #####: 3970:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 3971:    }
        -: 3972:  }
        -: 3973:
    #####: 3974:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3975:  {
    #####: 3976:    if (prop_desc.set_p != NULL)
        -: 3977:    {
    #####: 3978:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 3979:    }
        -: 3980:    else
        -: 3981:    {
    #####: 3982:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 3983:    }
        -: 3984:  }
        -: 3985:
    #####: 3986:  return ECMA_VALUE_TRUE;
        -: 3987:} /* jerry_get_own_property_descriptor */
        -: 3988:
        -: 3989:/**
        -: 3990: * Free fields of property descriptor (setter, getter and value).
        -: 3991: */
        -: 3992:void
    #####: 3993:jerry_property_descriptor_free (const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3994:{
    #####: 3995:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3996:  {
    #####: 3997:    jerry_release_value (prop_desc_p->value);
        -: 3998:  }
        -: 3999:
    #####: 4000:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 4001:  {
    #####: 4002:    jerry_release_value (prop_desc_p->getter);
        -: 4003:  }
        -: 4004:
    #####: 4005:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 4006:  {
    #####: 4007:    jerry_release_value (prop_desc_p->setter);
        -: 4008:  }
    #####: 4009:} /* jerry_property_descriptor_free */
        -: 4010:
        -: 4011:/**
        -: 4012: * Invoke function specified by a function value
        -: 4013: *
        -: 4014: * Note:
        -: 4015: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4016: *      - If function is invoked as constructor, it should support [[Construct]] method,
        -: 4017: *        otherwise, if function is simply called - it should support [[Call]] method.
        -: 4018: *
        -: 4019: * @return returned jerry value of the invoked function
        -: 4020: */
        -: 4021:static jerry_value_t
    #####: 4022:jerry_invoke_function (bool is_invoke_as_constructor, /**< true - invoke function as constructor
        -: 4023:                                                       *          (this_arg_p should be NULL, as it is ignored),
        -: 4024:                                                       *   false - perform function call */
        -: 4025:                       const jerry_value_t func_obj_val, /**< function object to call */
        -: 4026:                       const jerry_value_t this_val, /**< object value of 'this' binding */
        -: 4027:                       const jerry_value_t args_p[], /**< function's call arguments */
        -: 4028:                       const jerry_size_t args_count) /**< number of the arguments */
        -: 4029:{
    #####: 4030:  JERRY_ASSERT (args_count == 0 || args_p != NULL);
        -: 4031:
    #####: 4032:  if (ecma_is_value_error_reference (func_obj_val)
    #####: 4033:      || ecma_is_value_error_reference (this_val))
        -: 4034:  {
    #####: 4035:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4036:  }
        -: 4037:
    #####: 4038:  for (uint32_t i = 0; i < args_count; i++)
        -: 4039:  {
    #####: 4040:    if (ecma_is_value_error_reference (args_p[i]))
        -: 4041:    {
    #####: 4042:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4043:    }
        -: 4044:  }
        -: 4045:
    #####: 4046:  if (is_invoke_as_constructor)
        -: 4047:  {
    #####: 4048:    JERRY_ASSERT (jerry_value_is_constructor (func_obj_val));
        -: 4049:
    #####: 4050:    return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_obj_val),
        -: 4051:                                                     ecma_get_object_from_value (func_obj_val),
        -: 4052:                                                     args_p,
        -: 4053:                                                     args_count));
        -: 4054:  }
        -: 4055:  else
        -: 4056:  {
    #####: 4057:    JERRY_ASSERT (jerry_value_is_function (func_obj_val));
        -: 4058:
    #####: 4059:    return jerry_return (ecma_op_function_call (ecma_get_object_from_value (func_obj_val),
        -: 4060:                                                this_val,
        -: 4061:                                                args_p,
        -: 4062:                                                args_count));
        -: 4063:  }
        -: 4064:} /* jerry_invoke_function */
        -: 4065:
        -: 4066:/**
        -: 4067: * Call function specified by a function value
        -: 4068: *
        -: 4069: * Note:
        -: 4070: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4071: *      error flag must not be set for any arguments of this function.
        -: 4072: *
        -: 4073: * @return returned jerry value of the called function
        -: 4074: */
        -: 4075:jerry_value_t
    #####: 4076:jerry_call_function (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4077:                     const jerry_value_t this_val, /**< object for 'this' binding */
        -: 4078:                     const jerry_value_t args_p[], /**< function's call arguments */
        -: 4079:                     jerry_size_t args_count) /**< number of the arguments */
        -: 4080:{
        -: 4081:  jerry_assert_api_available ();
        -: 4082:
    #####: 4083:  if (jerry_value_is_function (func_obj_val) && !ecma_is_value_error_reference (this_val))
        -: 4084:  {
    #####: 4085:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4086:    {
    #####: 4087:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4088:      {
    #####: 4089:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4090:      }
        -: 4091:    }
        -: 4092:
    #####: 4093:    return jerry_invoke_function (false, func_obj_val, this_val, args_p, args_count);
        -: 4094:  }
        -: 4095:
    #####: 4096:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4097:} /* jerry_call_function */
        -: 4098:
        -: 4099:/**
        -: 4100: * Construct object value invoking specified function value as a constructor
        -: 4101: *
        -: 4102: * Note:
        -: 4103: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4104: *      error flag must not be set for any arguments of this function.
        -: 4105: *
        -: 4106: * @return returned jerry value of the invoked constructor
        -: 4107: */
        -: 4108:jerry_value_t
    #####: 4109:jerry_construct_object (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4110:                        const jerry_value_t args_p[], /**< function's call arguments
        -: 4111:                                                       *   (NULL if arguments number is zero) */
        -: 4112:                        jerry_size_t args_count) /**< number of the arguments */
        -: 4113:{
        -: 4114:  jerry_assert_api_available ();
        -: 4115:
    #####: 4116:  if (jerry_value_is_constructor (func_obj_val))
        -: 4117:  {
    #####: 4118:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4119:    {
    #####: 4120:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4121:      {
    #####: 4122:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4123:      }
        -: 4124:    }
        -: 4125:
    #####: 4126:    ecma_value_t this_val = ECMA_VALUE_UNDEFINED;
    #####: 4127:    return jerry_invoke_function (true, func_obj_val, this_val, args_p, args_count);
        -: 4128:  }
        -: 4129:
    #####: 4130:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4131:} /* jerry_construct_object */
        -: 4132:
        -: 4133:/**
        -: 4134: * Get keys of the specified object value
        -: 4135: *
        -: 4136: * Note:
        -: 4137: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4138: *
        -: 4139: * @return array object value - if success
        -: 4140: *         value marked with error flag - otherwise
        -: 4141: */
        -: 4142:jerry_value_t
    #####: 4143:jerry_get_object_keys (const jerry_value_t obj_val) /**< object value */
        -: 4144:{
        -: 4145:  jerry_assert_api_available ();
        -: 4146:
    #####: 4147:  if (!ecma_is_value_object (obj_val))
        -: 4148:  {
    #####: 4149:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4150:  }
        -: 4151:
    #####: 4152:  ecma_collection_t *prop_names = ecma_op_object_get_enumerable_property_names (ecma_get_object_from_value (obj_val),
        -: 4153:                                                                                ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 4154:
        -: 4155:#if JERRY_BUILTIN_PROXY
    #####: 4156:  if (JERRY_UNLIKELY (prop_names == NULL))
        -: 4157:  {
    #####: 4158:    return ECMA_VALUE_ERROR;
        -: 4159:  }
        -: 4160:#endif /* JERRY_BUILTIN_PROXY */
        -: 4161:
    #####: 4162:  return ecma_op_new_array_object_from_collection (prop_names, false);
        -: 4163:} /* jerry_get_object_keys */
        -: 4164:
        -: 4165:/**
        -: 4166: * Get the prototype of the specified object
        -: 4167: *
        -: 4168: * Note:
        -: 4169: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4170: *
        -: 4171: * @return prototype object or null value - if success
        -: 4172: *         value marked with error flag - otherwise
        -: 4173: */
        -: 4174:jerry_value_t
    #####: 4175:jerry_get_prototype (const jerry_value_t obj_val) /**< object value */
        -: 4176:{
        -: 4177:  jerry_assert_api_available ();
        -: 4178:
    #####: 4179:  if (!ecma_is_value_object (obj_val))
        -: 4180:  {
    #####: 4181:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4182:  }
        -: 4183:
    #####: 4184:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4185:
        -: 4186:#if JERRY_BUILTIN_PROXY
    #####: 4187:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4188:  {
    #####: 4189:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 4190:  }
        -: 4191:#endif /* JERRY_BUILTIN_PROXY */
        -: 4192:
    #####: 4193:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 4194:  {
    #####: 4195:    return ECMA_VALUE_NULL;
        -: 4196:  }
        -: 4197:
    #####: 4198:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 4199:  ecma_ref_object (proto_obj_p);
        -: 4200:
    #####: 4201:  return ecma_make_object_value (proto_obj_p);
        -: 4202:} /* jerry_get_prototype */
        -: 4203:
        -: 4204:/**
        -: 4205: * Set the prototype of the specified object
        -: 4206: *
        -: 4207: * @return true value - if success
        -: 4208: *         value marked with error flag - otherwise
        -: 4209: */
        -: 4210:jerry_value_t
    #####: 4211:jerry_set_prototype (const jerry_value_t obj_val, /**< object value */
        -: 4212:                     const jerry_value_t proto_obj_val) /**< prototype object value */
        -: 4213:{
        -: 4214:  jerry_assert_api_available ();
        -: 4215:
    #####: 4216:  if (!ecma_is_value_object (obj_val)
    #####: 4217:      || ecma_is_value_error_reference (proto_obj_val)
    #####: 4218:      || (!ecma_is_value_object (proto_obj_val) && !ecma_is_value_null (proto_obj_val)))
        -: 4219:  {
    #####: 4220:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4221:  }
    #####: 4222:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4223:
        -: 4224:#if JERRY_BUILTIN_PROXY
    #####: 4225:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4226:  {
    #####: 4227:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto_obj_val));
        -: 4228:  }
        -: 4229:#endif /* JERRY_BUILTIN_PROXY */
        -: 4230:
    #####: 4231:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto_obj_val);
        -: 4232:} /* jerry_set_prototype */
        -: 4233:
        -: 4234:/**
        -: 4235: * Utility to check if a given object can be used for the foreach api calls.
        -: 4236: *
        -: 4237: * Some objects/classes uses extra internal objects to correctly store data.
        -: 4238: * These extre object should never be exposed externally to the API user.
        -: 4239: *
        -: 4240: * @returns true - if the user can access the object in the callback.
        -: 4241: *          false - if the object is an internal object which should no be accessed by the user.
        -: 4242: */
        -: 4243:static
    #####: 4244:bool jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 4245:{
    #####: 4246:  if (ecma_is_lexical_environment (object_p))
        -: 4247:  {
    #####: 4248:    return false;
        -: 4249:  }
        -: 4250:
    #####: 4251:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 4252:
    #####: 4253:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 4254:  {
    #####: 4255:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 4256:    switch (ext_object_p->u.cls.type)
        -: 4257:    {
        -: 4258:      /* An object's internal property object should not be iterable by foreach. */
    #####: 4259:      case ECMA_OBJECT_CLASS_INTERNAL_OBJECT:
        -: 4260:      {
    #####: 4261:        return false;
        -: 4262:      }
        -: 4263:    }
        -: 4264:  }
        -: 4265:
    #####: 4266:  return true;
        -: 4267:} /* jerry_object_is_valid_foreach */
        -: 4268:
        -: 4269:/**
        -: 4270: * Traverse objects.
        -: 4271: *
        -: 4272: * @return true - traversal was interrupted by the callback.
        -: 4273: *         false - otherwise - traversal visited all objects.
        -: 4274: */
        -: 4275:bool
    #####: 4276:jerry_objects_foreach (jerry_objects_foreach_t foreach_p, /**< function pointer of the iterator function */
        -: 4277:                       void *user_data_p) /**< pointer to user data */
        -: 4278:{
        -: 4279:  jerry_assert_api_available ();
        -: 4280:
    #####: 4281:  JERRY_ASSERT (foreach_p != NULL);
        -: 4282:
    #####: 4283:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4284:
    #####: 4285:  while (iter_cp != JMEM_CP_NULL)
        -: 4286:  {
    #####: 4287:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4288:
    #####: 4289:    if (jerry_object_is_valid_foreach (iter_p)
    #####: 4290:        && !foreach_p (ecma_make_object_value (iter_p), user_data_p))
        -: 4291:    {
    #####: 4292:      return true;
        -: 4293:    }
        -: 4294:
    #####: 4295:    iter_cp = iter_p->gc_next_cp;
        -: 4296:  }
        -: 4297:
    #####: 4298:  return false;
        -: 4299:} /* jerry_objects_foreach */
        -: 4300:
        -: 4301:/**
        -: 4302: * Traverse objects having a given native type info.
        -: 4303: *
        -: 4304: * @return true - traversal was interrupted by the callback.
        -: 4305: *         false - otherwise - traversal visited all objects.
        -: 4306: */
        -: 4307:bool
    #####: 4308:jerry_objects_foreach_by_native_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 4309:                                                                                        *   of the native pointer */
        -: 4310:                                      jerry_objects_foreach_by_native_info_t foreach_p, /**< function to apply for
        -: 4311:                                                                                         *   each matching object */
        -: 4312:                                      void *user_data_p) /**< pointer to user data */
        -: 4313:{
        -: 4314:  jerry_assert_api_available ();
        -: 4315:
    #####: 4316:  JERRY_ASSERT (native_info_p != NULL);
    #####: 4317:  JERRY_ASSERT (foreach_p != NULL);
        -: 4318:
        -: 4319:  ecma_native_pointer_t *native_pointer_p;
        -: 4320:
    #####: 4321:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4322:
    #####: 4323:  while (iter_cp != JMEM_CP_NULL)
        -: 4324:  {
    #####: 4325:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4326:
    #####: 4327:    if (jerry_object_is_valid_foreach (iter_p))
        -: 4328:    {
    #####: 4329:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 4330:      if (native_pointer_p
    #####: 4331:          && !foreach_p (ecma_make_object_value (iter_p), native_pointer_p->native_p, user_data_p))
        -: 4332:      {
    #####: 4333:        return true;
        -: 4334:      }
        -: 4335:    }
        -: 4336:
    #####: 4337:    iter_cp = iter_p->gc_next_cp;
        -: 4338:  }
        -: 4339:
    #####: 4340:  return false;
        -: 4341:} /* jerry_objects_foreach_by_native_info */
        -: 4342:
        -: 4343:/**
        -: 4344: * Get native pointer and its type information, associated with the given native type info.
        -: 4345: *
        -: 4346: * Note:
        -: 4347: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 4348: *
        -: 4349: * @return true - if there is an associated pointer,
        -: 4350: *         false - otherwise
        -: 4351: */
        -: 4352:bool
    #####: 4353:jerry_get_object_native_pointer (const jerry_value_t obj_val, /**< object to get native pointer from */
        -: 4354:                                 void **out_native_pointer_p, /**< [out] native pointer */
        -: 4355:                                 const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 4356:                                                                                   *   of the native pointer */
        -: 4357:{
        -: 4358:  jerry_assert_api_available ();
        -: 4359:
    #####: 4360:  if (!ecma_is_value_object (obj_val))
        -: 4361:  {
    #####: 4362:    return false;
        -: 4363:  }
        -: 4364:
        -: 4365:  ecma_native_pointer_t *native_pointer_p;
    #####: 4366:  native_pointer_p = ecma_get_native_pointer_value (ecma_get_object_from_value (obj_val), (void *) native_info_p);
        -: 4367:
    #####: 4368:  if (native_pointer_p == NULL)
        -: 4369:  {
    #####: 4370:    return false;
        -: 4371:  }
        -: 4372:
    #####: 4373:  if (out_native_pointer_p != NULL)
        -: 4374:  {
    #####: 4375:    *out_native_pointer_p = native_pointer_p->native_p;
        -: 4376:  }
        -: 4377:
    #####: 4378:  return true;
        -: 4379:} /* jerry_get_object_native_pointer */
        -: 4380:
        -: 4381:/**
        -: 4382: * Set native pointer and an optional type info for the specified object.
        -: 4383: *
        -: 4384: *
        -: 4385: * Note:
        -: 4386: *      If native pointer was already set for the object, its value is updated.
        -: 4387: *
        -: 4388: * Note:
        -: 4389: *      If a non-NULL free callback is specified in the native type info,
        -: 4390: *      it will be called by the garbage collector when the object is freed.
        -: 4391: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 4392: *      The type info always overwrites the previous value, so passing
        -: 4393: *      a NULL value deletes the current type info.
        -: 4394: */
        -: 4395:void
    #####: 4396:jerry_set_object_native_pointer (const jerry_value_t obj_val, /**< object to set native pointer in */
        -: 4397:                                 void *native_pointer_p, /**< native pointer */
        -: 4398:                                 const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4399:{
        -: 4400:  jerry_assert_api_available ();
        -: 4401:
    #####: 4402:  if (ecma_is_value_object (obj_val))
        -: 4403:  {
    #####: 4404:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4405:
    #####: 4406:    ecma_create_native_pointer_property (object_p, native_pointer_p, native_info_p);
        -: 4407:  }
    #####: 4408:} /* jerry_set_object_native_pointer */
        -: 4409:
        -: 4410:/**
        -: 4411: * Delete the previously set native pointer by the native type info from the specified object.
        -: 4412: *
        -: 4413: * Note:
        -: 4414: *      If the specified object has no matching native pointer for the given native type info
        -: 4415: *      the function has no effect.
        -: 4416: *
        -: 4417: * Note:
        -: 4418: *      This operation cannot throw an exception.
        -: 4419: *
        -: 4420: * @return true - if the native pointer has been deleted succesfully
        -: 4421: *         false - otherwise
        -: 4422: */
        -: 4423:bool
    #####: 4424:jerry_delete_object_native_pointer (const jerry_value_t obj_val, /**< object to delete native pointer from */
        -: 4425:                                    const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4426:{
        -: 4427:  jerry_assert_api_available ();
        -: 4428:
    #####: 4429:  if (ecma_is_value_object (obj_val))
        -: 4430:  {
    #####: 4431:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4432:
    #####: 4433:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 4434:  }
        -: 4435:
    #####: 4436:  return false;
        -: 4437:} /* jerry_delete_object_native_pointer */
        -: 4438:
        -: 4439:/**
        -: 4440: * Initialize the references stored in a buffer pointed by a native pointer.
        -: 4441: * The references are initialized to undefined.
        -: 4442: */
        -: 4443:void
    #####: 4444:jerry_native_pointer_init_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4445:                                      const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4446:                                                                                        *   the native pointer */
        -: 4447:{
        -: 4448:  jerry_assert_api_available ();
        -: 4449:
    #####: 4450:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4451:  {
    #####: 4452:    return;
        -: 4453:  }
        -: 4454:
    #####: 4455:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4456:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4457:
    #####: 4458:  while (value_p < end_p)
        -: 4459:  {
    #####: 4460:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4461:  }
        -: 4462:} /* jerry_native_pointer_init_references */
        -: 4463:
        -: 4464:/**
        -: 4465: * Release the value references after a buffer pointed by a native pointer
        -: 4466: * is not attached to an object anymore. All references are set to undefined
        -: 4467: * similar to jerry_native_pointer_init_references.
        -: 4468: */
        -: 4469:void
    #####: 4470:jerry_native_pointer_release_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4471:                                         const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4472:                                                                                           *   the native pointer */
        -: 4473:{
        -: 4474:  jerry_assert_api_available ();
        -: 4475:
    #####: 4476:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4477:  {
    #####: 4478:    return;
        -: 4479:  }
        -: 4480:
    #####: 4481:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4482:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4483:
    #####: 4484:  while (value_p < end_p)
        -: 4485:  {
    #####: 4486:    ecma_free_value_if_not_object (*value_p);
    #####: 4487:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4488:  }
        -: 4489:} /* jerry_native_pointer_release_references */
        -: 4490:
        -: 4491:/**
        -: 4492: * Updates a value reference inside the area specified by the number_of_references and
        -: 4493: * offset_of_references fields in its corresponding jerry_object_native_info_t data.
        -: 4494: * The area must be part of a buffer which is currently assigned to an object.
        -: 4495: *
        -: 4496: * Note:
        -: 4497: *      Error references are not supported, they are replaced by undefined values.
        -: 4498: */
        -: 4499:void
    #####: 4500:jerry_native_pointer_set_reference (jerry_value_t *reference_p, /**< a valid non-NULL pointer to
        -: 4501:                                                                 *   a reference in a native buffer. */
        -: 4502:                                    jerry_value_t value) /**< new value of the reference */
        -: 4503:{
        -: 4504:  jerry_assert_api_available ();
        -: 4505:
    #####: 4506:  if (reference_p == NULL)
        -: 4507:  {
    #####: 4508:    return;
        -: 4509:  }
        -: 4510:
    #####: 4511:  if (ecma_is_value_error_reference (value))
        -: 4512:  {
    #####: 4513:    value = ECMA_VALUE_UNDEFINED;
        -: 4514:  }
        -: 4515:
    #####: 4516:  ecma_free_value_if_not_object (*reference_p);
    #####: 4517:  *reference_p = ecma_copy_value_if_not_object (value);
        -: 4518:} /* jerry_native_pointer_set_reference */
        -: 4519:
        -: 4520:/**
        -: 4521: * Applies the given function to the every property in the object.
        -: 4522: *
        -: 4523: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 4524: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 4525: *                - object fields traversal was stopped on callback that returned false;
        -: 4526: *         false - otherwise,
        -: 4527: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 4528: */
        -: 4529:bool
    #####: 4530:jerry_foreach_object_property (const jerry_value_t obj_val, /**< object value */
        -: 4531:                               jerry_object_property_foreach_t foreach_p, /**< foreach function */
        -: 4532:                               void *user_data_p) /**< user data for foreach function */
        -: 4533:{
        -: 4534:  jerry_assert_api_available ();
        -: 4535:
    #####: 4536:  if (!ecma_is_value_object (obj_val))
        -: 4537:  {
    #####: 4538:    return false;
        -: 4539:  }
        -: 4540:
    #####: 4541:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 4542:  ecma_collection_t *names_p = ecma_op_object_enumerate (object_p);
        -: 4543:
        -: 4544:#if JERRY_BUILTIN_PROXY
    #####: 4545:  if (names_p == NULL)
        -: 4546:  {
        -: 4547:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 4548:    jcontext_release_exception ();
    #####: 4549:    return false;
        -: 4550:  }
        -: 4551:#endif /* JERRY_BUILTIN_PROXY */
        -: 4552:
    #####: 4553:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 4554:
    #####: 4555:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 4556:
    #####: 4557:  bool continuous = true;
        -: 4558:
    #####: 4559:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 4560:  {
    #####: 4561:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 4562:
    #####: 4563:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 4564:
    #####: 4565:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 4566:    {
    #####: 4567:      break;
        -: 4568:    }
        -: 4569:
    #####: 4570:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 4571:    ecma_free_value (property_value);
        -: 4572:  }
        -: 4573:
    #####: 4574:  ecma_collection_free (names_p);
        -: 4575:
    #####: 4576:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 4577:  {
    #####: 4578:    return true;
        -: 4579:  }
        -: 4580:
    #####: 4581:  jcontext_release_exception ();
    #####: 4582:  return false;
        -: 4583:} /* jerry_foreach_object_property */
        -: 4584:
        -: 4585:/**
        -: 4586: * Gets the property keys for the given object using the selected filters.
        -: 4587: *
        -: 4588: * @return array containing the filtered property keys in successful operation
        -: 4589: *         value marked with error flag - otherwise
        -: 4590: */
        -: 4591:jerry_value_t
    #####: 4592:jerry_object_get_property_names (const jerry_value_t obj_val, /**< object */
        -: 4593:                                 jerry_property_filter_t filter) /**< property filter options */
        -: 4594:{
        -: 4595:  jerry_assert_api_available ();
        -: 4596:
    #####: 4597:  if (!ecma_is_value_object (obj_val))
        -: 4598:  {
    #####: 4599:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4600:  }
        -: 4601:
    #####: 4602:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 4603:  ecma_object_t *obj_iter_p = obj_p;
    #####: 4604:  ecma_collection_t *result_p = ecma_new_collection ();
        -: 4605:
    #####: 4606:  ecma_ref_object (obj_iter_p);
        -: 4607:
        -: 4608:  while (true)
    #####: 4609:  {
        -: 4610:    /* Step 1. Get Object.[[OwnKeys]] */
    #####: 4611:    ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_iter_p, filter);
        -: 4612:
        -: 4613:#if JERRY_BUILTIN_PROXY
    #####: 4614:    if (prop_names_p == NULL)
        -: 4615:    {
    #####: 4616:      ecma_deref_object (obj_iter_p);
    #####: 4617:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4618:    }
        -: 4619:#endif /* JERRY_BUILTIN_PROXY */
        -: 4620:
    #####: 4621:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 4622:    {
    #####: 4623:      ecma_value_t key = prop_names_p->buffer_p[i];
    #####: 4624:      ecma_string_t *key_p = ecma_get_prop_name_from_value (key);
    #####: 4625:      uint32_t index = ecma_string_get_array_index (key_p);
        -: 4626:
        -: 4627:      /* Step 2. Filter by key type */
    #####: 4628:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS
        -: 4629:                    | JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS
        -: 4630:                    | JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -: 4631:      {
    #####: 4632:        if (ecma_is_value_symbol (key))
        -: 4633:        {
    #####: 4634:          if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
        -: 4635:          {
    #####: 4636:            continue;
        -: 4637:          }
        -: 4638:        }
    #####: 4639:        else if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 4640:        {
    #####: 4641:          if ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
    #####: 4642:              || ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
    #####: 4643:                  && !(filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER)))
        -: 4644:          {
    #####: 4645:            continue;
        -: 4646:          }
        -: 4647:        }
    #####: 4648:        else if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 4649:        {
    #####: 4650:          continue;
        -: 4651:        }
        -: 4652:      }
        -: 4653:
        -: 4654:      /* Step 3. Filter property attributes */
    #####: 4655:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE
        -: 4656:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE
        -: 4657:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE))
        -: 4658:      {
    #####: 4659:        ecma_property_descriptor_t prop_desc;
    #####: 4660:        ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_iter_p, key_p, &prop_desc);
        -: 4661:
        -: 4662:#if JERRY_BUILTIN_PROXY
    #####: 4663:        if (ECMA_IS_VALUE_ERROR (status))
        -: 4664:        {
    #####: 4665:          ecma_collection_free (prop_names_p);
    #####: 4666:          ecma_collection_free (result_p);
    #####: 4667:          ecma_deref_object (obj_iter_p);
    #####: 4668:          return jerry_throw (ECMA_VALUE_ERROR);
        -: 4669:        }
        -: 4670:#endif /* JERRY_BUILTIN_PROXY */
        -: 4671:
    #####: 4672:        JERRY_ASSERT (ecma_is_value_true (status));
    #####: 4673:        uint16_t flags = prop_desc.flags;
    #####: 4674:        ecma_free_property_descriptor (&prop_desc);
        -: 4675:
    #####: 4676:        if ((!(flags & JERRY_PROP_IS_CONFIGURABLE)
    #####: 4677:             && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE))
    #####: 4678:            || (!(flags & JERRY_PROP_IS_ENUMERABLE)
    #####: 4679:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE))
    #####: 4680:            || (!(flags & JERRY_PROP_IS_WRITABLE)
    #####: 4681:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE)))
        -: 4682:        {
    #####: 4683:          continue;
        -: 4684:        }
        -: 4685:      }
        -: 4686:
    #####: 4687:      if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####: 4688:          && (filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER))
        -: 4689:      {
    #####: 4690:        ecma_deref_ecma_string (key_p);
    #####: 4691:        key = ecma_make_uint32_value (index);
        -: 4692:      }
        -: 4693:      else
        -: 4694:      {
    #####: 4695:        ecma_ref_ecma_string (key_p);
        -: 4696:      }
        -: 4697:
    #####: 4698:      if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) && obj_iter_p != obj_p)
    #####: 4699:      {
    #####: 4700:        uint32_t duplicate_idx = 0;
    #####: 4701:        while (duplicate_idx < result_p->item_count)
        -: 4702:        {
    #####: 4703:          ecma_value_t value = result_p->buffer_p[duplicate_idx];
    #####: 4704:          JERRY_ASSERT (ecma_is_value_prop_name (value) || ecma_is_value_number (value));
    #####: 4705:          if (JERRY_UNLIKELY (ecma_is_value_number (value)))
        -: 4706:          {
    #####: 4707:            if (ecma_get_number_from_value (value) == ecma_get_number_from_value (key))
        -: 4708:            {
    #####: 4709:              break;
        -: 4710:            }
        -: 4711:          }
    #####: 4712:          else if (ecma_compare_ecma_strings (ecma_get_prop_name_from_value (value), key_p))
        -: 4713:          {
    #####: 4714:            break;
        -: 4715:          }
        -: 4716:
    #####: 4717:          duplicate_idx++;
        -: 4718:        }
        -: 4719:
    #####: 4720:        if (duplicate_idx == result_p->item_count)
        -: 4721:        {
    #####: 4722:          ecma_collection_push_back (result_p, key);
        -: 4723:        }
        -: 4724:      }
        -: 4725:      else
        -: 4726:      {
    #####: 4727:        ecma_collection_push_back (result_p, key);
        -: 4728:      }
        -: 4729:    }
        -: 4730:
    #####: 4731:    ecma_collection_free (prop_names_p);
        -: 4732:
        -: 4733:    /* Step 4: Traverse prototype chain */
        -: 4734:
    #####: 4735:    if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) != JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN)
        -: 4736:    {
    #####: 4737:      break;
        -: 4738:    }
        -: 4739:
    #####: 4740:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_iter_p);
        -: 4741:
    #####: 4742:    if (proto_p == NULL)
        -: 4743:    {
    #####: 4744:      break;
        -: 4745:    }
        -: 4746:
    #####: 4747:    ecma_deref_object (obj_iter_p);
        -: 4748:
    #####: 4749:    if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 4750:    {
    #####: 4751:      ecma_collection_free (result_p);
    #####: 4752:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4753:    }
        -: 4754:
    #####: 4755:    obj_iter_p = proto_p;
        -: 4756:  }
        -: 4757:
    #####: 4758:  ecma_deref_object (obj_iter_p);
        -: 4759:
    #####: 4760:  return ecma_op_new_array_object_from_collection (result_p, false);
        -: 4761:} /* jerry_object_get_property_names */
        -: 4762:
        -: 4763:/**
        -: 4764: * FromPropertyDescriptor abstract operation.
        -: 4765: *
        -: 4766: * @return new jerry_value_t - if success
        -: 4767: *         value marked with error flag - otherwise
        -: 4768: */
        -: 4769:jerry_value_t
    #####: 4770:jerry_from_property_descriptor (const jerry_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -: 4771:{
        -: 4772:  jerry_assert_api_available ();
        -: 4773:
    #####: 4774:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (src_prop_desc_p);
        -: 4775:
    #####: 4776:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 4777:  {
    #####: 4778:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4779:  }
        -: 4780:
    #####: 4781:  ecma_object_t *desc_obj_p = ecma_op_from_property_descriptor (&prop_desc);
        -: 4782:
    #####: 4783:  return ecma_make_object_value (desc_obj_p);
        -: 4784:} /* jerry_from_property_descriptor */
        -: 4785:
        -: 4786:/**
        -: 4787: * ToPropertyDescriptor abstract operation.
        -: 4788: *
        -: 4789: * @return true - if the conversion is successful
        -: 4790: *         thrown error - otherwise
        -: 4791: */
        -: 4792:jerry_value_t
    #####: 4793:jerry_to_property_descriptor (jerry_value_t obj_value, /**< object value */
        -: 4794:                              jerry_property_descriptor_t *out_prop_desc_p) /**< [out] filled property descriptor
        -: 4795:                                                                             *   if return value is true,
        -: 4796:                                                                             *   unmodified otherwise */
        -: 4797:{
        -: 4798:  jerry_assert_api_available ();
        -: 4799:
    #####: 4800:  ecma_property_descriptor_t prop_desc;
    #####: 4801:  jerry_value_t result = ecma_op_to_property_descriptor (obj_value, &prop_desc);
        -: 4802:
    #####: 4803:  if (ECMA_IS_VALUE_ERROR (result))
        -: 4804:  {
    #####: 4805:    return jerry_throw (result);
        -: 4806:  }
        -: 4807:
    #####: 4808:  JERRY_ASSERT (result == ECMA_VALUE_EMPTY);
        -: 4809:
    #####: 4810:  *out_prop_desc_p = jerry_property_descriptor_from_ecma (&prop_desc);
    #####: 4811:  return ECMA_VALUE_TRUE;
        -: 4812:} /* jerry_to_property_descriptor */
        -: 4813:
        -: 4814:/**
        -: 4815: * Resolve or reject the promise with an argument.
        -: 4816: *
        -: 4817: * @return undefined value - if success
        -: 4818: *         value marked with error flag - otherwise
        -: 4819: */
        -: 4820:jerry_value_t
    #####: 4821:jerry_resolve_or_reject_promise (jerry_value_t promise, /**< the promise value */
        -: 4822:                                 jerry_value_t argument, /**< the argument */
        -: 4823:                                 bool is_resolve) /**< whether the promise should be resolved or rejected */
        -: 4824:{
        -: 4825:  jerry_assert_api_available ();
        -: 4826:
        -: 4827:#if JERRY_ESNEXT
    #####: 4828:  if (!ecma_is_value_object (promise) || !ecma_is_promise (ecma_get_object_from_value (promise)))
        -: 4829:  {
    #####: 4830:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4831:  }
        -: 4832:
    #####: 4833:  if (ecma_is_value_error_reference (argument))
        -: 4834:  {
    #####: 4835:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4836:  }
        -: 4837:
    #####: 4838:  if (is_resolve)
        -: 4839:  {
    #####: 4840:    return ecma_fulfill_promise_with_checks (promise, argument);
        -: 4841:  }
        -: 4842:
    #####: 4843:  return ecma_reject_promise_with_checks (promise, argument);
        -: 4844:#else /* !JERRY_ESNEXT */
        -: 4845:  JERRY_UNUSED (promise);
        -: 4846:  JERRY_UNUSED (argument);
        -: 4847:  JERRY_UNUSED (is_resolve);
        -: 4848:
    #####: 4849:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4850:#endif /* JERRY_ESNEXT */
        -: 4851:} /* jerry_resolve_or_reject_promise */
        -: 4852:
        -: 4853:/**
        -: 4854: * Get the result of a promise.
        -: 4855: *
        -: 4856: * @return - Promise result
        -: 4857: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 4858: */
        -: 4859:jerry_value_t
    #####: 4860:jerry_get_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 4861:{
        -: 4862:  jerry_assert_api_available ();
        -: 4863:
        -: 4864:#if JERRY_ESNEXT
    #####: 4865:  if (!jerry_value_is_promise (promise))
        -: 4866:  {
    #####: 4867:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4868:  }
        -: 4869:
    #####: 4870:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 4871:#else /* !JERRY_ESNEXT */
        -: 4872:  JERRY_UNUSED (promise);
    #####: 4873:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4874:#endif /* JERRY_ESNEXT */
        -: 4875:} /* jerry_get_promise_result */
        -: 4876:
        -: 4877:/**
        -: 4878: * Get the state of a promise object.
        -: 4879: *
        -: 4880: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 4881: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 4882: *           or the promise support was not enabled.
        -: 4883: */
        -: 4884:jerry_promise_state_t
    #####: 4885:jerry_get_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 4886:{
        -: 4887:  jerry_assert_api_available ();
        -: 4888:
        -: 4889:#if JERRY_ESNEXT
    #####: 4890:  if (!jerry_value_is_promise (promise))
        -: 4891:  {
    #####: 4892:    return JERRY_PROMISE_STATE_NONE;
        -: 4893:  }
        -: 4894:
    #####: 4895:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 4896:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 4897:
    #####: 4898:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 4899:#else /* !JERRY_ESNEXT */
        -: 4900:  JERRY_UNUSED (promise);
    #####: 4901:  return JERRY_PROMISE_STATE_NONE;
        -: 4902:#endif /* JERRY_ESNEXT */
        -: 4903:} /* jerry_get_promise_state */
        -: 4904:
        -: 4905:/**
        -: 4906: * Sets a callback for tracking Promise and async operations.
        -: 4907: *
        -: 4908: * Note:
        -: 4909: *     the previous callback is overwritten
        -: 4910: */
        1: 4911:void jerry_promise_set_callback (jerry_promise_event_filter_t filters, /**< combination of event filters */
        -: 4912:                                 jerry_promise_callback_t callback, /**< notification callback */
        -: 4913:                                 void *user_p) /**< user pointer passed to the callback */
        -: 4914:{
        -: 4915:  jerry_assert_api_available ();
        -: 4916:
        -: 4917:#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK
    #####: 4918:  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)
        -: 4919:  {
    #####: 4920:    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;
    #####: 4921:    return;
        -: 4922:  }
        -: 4923:
    #####: 4924:  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;
    #####: 4925:  JERRY_CONTEXT (promise_callback) = callback;
    #####: 4926:  JERRY_CONTEXT (promise_callback_user_p) = user_p;
        -: 4927:#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */
        -: 4928:  JERRY_UNUSED (filters);
        -: 4929:  JERRY_UNUSED (callback);
        -: 4930:  JERRY_UNUSED (user_p);
        -: 4931:#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */
        1: 4932:} /* jerry_promise_set_callback */
        -: 4933:
        -: 4934:/**
        -: 4935: * Get the well-knwon symbol represented by the given `symbol` enum value.
        -: 4936: *
        -: 4937: * Note:
        -: 4938: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4939: *
        -: 4940: * @return undefined value - if invalid well-known symbol was requested
        -: 4941: *         well-known symbol value - otherwise
        -: 4942: */
        -: 4943:jerry_value_t
    #####: 4944:jerry_get_well_known_symbol (jerry_well_known_symbol_t symbol) /**< jerry_well_known_symbol_t enum value */
        -: 4945:{
        -: 4946:  jerry_assert_api_available ();
        -: 4947:
        -: 4948:#if JERRY_ESNEXT
    #####: 4949:  lit_magic_string_id_t id = (lit_magic_string_id_t) (LIT_GLOBAL_SYMBOL__FIRST + symbol);
        -: 4950:
    #####: 4951:  if (!LIT_IS_GLOBAL_SYMBOL (id))
        -: 4952:  {
    #####: 4953:    return ECMA_VALUE_UNDEFINED;
        -: 4954:  }
        -: 4955:
    #####: 4956:  return ecma_make_symbol_value (ecma_op_get_global_symbol (id));
        -: 4957:#else /* !JERRY_ESNEXT */
        -: 4958:  JERRY_UNUSED (symbol);
        -: 4959:
    #####: 4960:  return ECMA_VALUE_UNDEFINED;
        -: 4961:#endif /* JERRY_ESNEXT */
        -: 4962:} /** jerry_get_well_known_symbol */
        -: 4963:
        -: 4964:/**
        -: 4965: * Returns the description internal property of a symbol.
        -: 4966: *
        -: 4967: * Note:
        -: 4968: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4969: *
        -: 4970: * @return string or undefined value containing the symbol's description - if success
        -: 4971: *         thrown error - otherwise
        -: 4972: */
        -: 4973:jerry_value_t
    #####: 4974:jerry_get_symbol_description (const jerry_value_t symbol) /**< symbol value */
        -: 4975:{
        -: 4976:  jerry_assert_api_available ();
        -: 4977:
        -: 4978:#if JERRY_ESNEXT
    #####: 4979:  if (!ecma_is_value_symbol (symbol))
        -: 4980:  {
    #####: 4981:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4982:  }
        -: 4983:
        -: 4984:  /* Note: This operation cannot throw an error */
    #####: 4985:  return ecma_copy_value (ecma_get_symbol_description (ecma_get_symbol_from_value (symbol)));
        -: 4986:#else /* !JERRY_ESNEXT */
        -: 4987:  JERRY_UNUSED (symbol);
        -: 4988:
    #####: 4989:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 4990:#endif /* JERRY_ESNEXT */
        -: 4991:} /* jerry_get_symbol_description */
        -: 4992:
        -: 4993:/**
        -: 4994: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 4995: *
        -: 4996: * Note:
        -: 4997: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4998: *
        -: 4999: * @return string value containing the symbol's descriptive string - if success
        -: 5000: *         thrown error - otherwise
        -: 5001: */
        -: 5002:jerry_value_t
    #####: 5003:jerry_get_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 5004:{
        -: 5005:  jerry_assert_api_available ();
        -: 5006:
        -: 5007:#if JERRY_ESNEXT
    #####: 5008:  if (!ecma_is_value_symbol (symbol))
        -: 5009:  {
    #####: 5010:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 5011:  }
        -: 5012:
        -: 5013:  /* Note: This operation cannot throw an error */
    #####: 5014:  return ecma_get_symbol_descriptive_string (symbol);
        -: 5015:#else /* !JERRY_ESNEXT */
        -: 5016:  JERRY_UNUSED (symbol);
        -: 5017:
    #####: 5018:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 5019:#endif /* JERRY_ESNEXT */
        -: 5020:} /** jerry_get_symbol_descriptive_string */
        -: 5021:
        -: 5022:/**
        -: 5023: * Get the number of uint64 digits of a BigInt value
        -: 5024: *
        -: 5025: * @return number of uint64 digits
        -: 5026: */
        -: 5027:uint32_t
    #####: 5028:jerry_get_bigint_size_in_digits (jerry_value_t value) /**< BigInt value */
        -: 5029:{
        -: 5030:  jerry_assert_api_available ();
        -: 5031:
        -: 5032:#if JERRY_BUILTIN_BIGINT
    #####: 5033:  if (!ecma_is_value_bigint (value))
        -: 5034:  {
    #####: 5035:    return 0;
        -: 5036:  }
        -: 5037:
    #####: 5038:  return ecma_bigint_get_size_in_digits (value);
        -: 5039:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5040:  JERRY_UNUSED (value);
    #####: 5041:  return 0;
        -: 5042:#endif /* JERRY_BUILTIN_BIGINT */
        -: 5043:} /* jerry_get_bigint_size_in_digits */
        -: 5044:
        -: 5045:/**
        -: 5046: * Get the uint64 digits of a BigInt value (lowest digit first)
        -: 5047: */
        -: 5048:void
    #####: 5049:jerry_get_bigint_digits (jerry_value_t value, /**< BigInt value */
        -: 5050:                         uint64_t *digits_p, /**< [out] buffer for digits */
        -: 5051:                         uint32_t size, /**< buffer size in digits */
        -: 5052:                         bool *sign_p) /**< [out] sign of BigInt */
        -: 5053:{
        -: 5054:#if JERRY_BUILTIN_BIGINT
    #####: 5055:  if (!ecma_is_value_bigint (value))
        -: 5056:  {
    #####: 5057:    if (sign_p != NULL)
        -: 5058:    {
    #####: 5059:      *sign_p = false;
        -: 5060:    }
    #####: 5061:    memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5062:  }
        -: 5063:
    #####: 5064:  ecma_bigint_get_digits_and_sign (value, digits_p, size, sign_p);
        -: 5065:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5066:  JERRY_UNUSED (value);
        -: 5067:
    #####: 5068:  if (sign_p != NULL)
        -: 5069:  {
    #####: 5070:    *sign_p = false;
        -: 5071:  }
    #####: 5072:  memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5073:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 5074:} /* jerry_get_bigint_digits */
        -: 5075:
        -: 5076:/**
        -: 5077: * Get the target object of a Proxy object
        -: 5078: *
        -: 5079: * @return type error - if proxy_value is not a Proxy object
        -: 5080: *         target object - otherwise
        -: 5081: */
        -: 5082:jerry_value_t
    #####: 5083:jerry_get_proxy_target (jerry_value_t proxy_value) /**< proxy value */
        -: 5084:{
        -: 5085:  jerry_assert_api_available ();
        -: 5086:
        -: 5087:#if JERRY_BUILTIN_PROXY
    #####: 5088:  if (ecma_is_value_object (proxy_value))
        -: 5089:  {
    #####: 5090:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5091:
    #####: 5092:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5093:    {
    #####: 5094:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5095:
    #####: 5096:      if (!ecma_is_value_null (proxy_object_p->target))
        -: 5097:      {
    #####: 5098:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->target));
        -: 5099:      }
    #####: 5100:      return proxy_object_p->target;
        -: 5101:    }
        -: 5102:  }
        -: 5103:#else /* !JERRY_BUILTIN_PROXY */
        -: 5104:  JERRY_UNUSED (proxy_value);
        -: 5105:#endif /* JERRY_BUILTIN_PROXY */
        -: 5106:
    #####: 5107:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5108:} /* jerry_get_proxy_target */
        -: 5109:
        -: 5110:/**
        -: 5111: * Get the handler object of a Proxy object
        -: 5112: *
        -: 5113: * @return type error - if proxy_value is not a Proxy object
        -: 5114: *         handler object - otherwise
        -: 5115: */
        -: 5116:jerry_value_t
    #####: 5117:jerry_get_proxy_handler (jerry_value_t proxy_value) /**< proxy value */
        -: 5118:{
        -: 5119:  jerry_assert_api_available ();
        -: 5120:
        -: 5121:#if JERRY_BUILTIN_PROXY
    #####: 5122:  if (ecma_is_value_object (proxy_value))
        -: 5123:  {
    #####: 5124:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5125:
    #####: 5126:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5127:    {
    #####: 5128:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5129:
    #####: 5130:      if (!ecma_is_value_null (proxy_object_p->handler))
        -: 5131:      {
    #####: 5132:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->handler));
        -: 5133:      }
    #####: 5134:      return proxy_object_p->handler;
        -: 5135:    }
        -: 5136:  }
        -: 5137:#else /* !JERRY_BUILTIN_PROXY */
        -: 5138:  JERRY_UNUSED (proxy_value);
        -: 5139:#endif /* JERRY_BUILTIN_PROXY */
        -: 5140:
    #####: 5141:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5142:} /* jerry_get_proxy_handler */
        -: 5143:
        -: 5144:/**
        -: 5145: * Validate UTF-8 string
        -: 5146: *
        -: 5147: * @return true - if UTF-8 string is well-formed
        -: 5148: *         false - otherwise
        -: 5149: */
        -: 5150:bool
        1: 5151:jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */
        -: 5152:                            jerry_size_t buf_size) /**< string size */
        -: 5153:{
        1: 5154:  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,
        -: 5155:                                   (lit_utf8_size_t) buf_size,
        -: 5156:                                   true);
        -: 5157:} /* jerry_is_valid_utf8_string */
        -: 5158:
        -: 5159:/**
        -: 5160: * Validate CESU-8 string
        -: 5161: *
        -: 5162: * @return true - if CESU-8 string is well-formed
        -: 5163: *         false - otherwise
        -: 5164: */
        -: 5165:bool
    #####: 5166:jerry_is_valid_cesu8_string (const jerry_char_t *cesu8_buf_p, /**< CESU-8 string */
        -: 5167:                             jerry_size_t buf_size) /**< string size */
        -: 5168:{
    #####: 5169:  return lit_is_valid_cesu8_string ((lit_utf8_byte_t *) cesu8_buf_p,
        -: 5170:                                    (lit_utf8_size_t) buf_size);
        -: 5171:} /* jerry_is_valid_cesu8_string */
        -: 5172:
        -: 5173:/**
        -: 5174: * Allocate memory on the engine's heap.
        -: 5175: *
        -: 5176: * Note:
        -: 5177: *      This function may take away memory from the executed JavaScript code.
        -: 5178: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 5179: *      malloc), it should be used instead.
        -: 5180: *
        -: 5181: * @return allocated memory on success
        -: 5182: *         NULL otherwise
        -: 5183: */
        -: 5184:void *
    #####: 5185:jerry_heap_alloc (size_t size) /**< size of the memory block */
        -: 5186:{
        -: 5187:  jerry_assert_api_available ();
        -: 5188:
    #####: 5189:  return jmem_heap_alloc_block_null_on_error (size);
        -: 5190:} /* jerry_heap_alloc */
        -: 5191:
        -: 5192:/**
        -: 5193: * Free memory allocated on the engine's heap.
        -: 5194: */
        -: 5195:void
    #####: 5196:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 5197:                 size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 5198:{
        -: 5199:  jerry_assert_api_available ();
        -: 5200:
    #####: 5201:  jmem_heap_free_block (mem_p, size);
    #####: 5202:} /* jerry_heap_free */
        -: 5203:
        -: 5204:/**
        -: 5205: * Create an external engine context.
        -: 5206: *
        -: 5207: * @return the pointer to the context.
        -: 5208: */
        -: 5209:jerry_context_t *
    #####: 5210:jerry_create_context (uint32_t heap_size, /**< the size of heap */
        -: 5211:                      jerry_context_alloc_t alloc, /**< the alloc function */
        -: 5212:                      void *cb_data_p) /**< the cb_data for alloc function */
        -: 5213:{
        -: 5214:  JERRY_UNUSED (heap_size);
        -: 5215:
        -: 5216:#if JERRY_EXTERNAL_CONTEXT
        -: 5217:
        -: 5218:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 5219:
        -: 5220:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5221:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 5222:
        -: 5223:  /* Minimum heap size is 1Kbyte. */
        -: 5224:  if (heap_size < 1024)
        -: 5225:  {
        -: 5226:    return NULL;
        -: 5227:  }
        -: 5228:
        -: 5229:  total_size += heap_size;
        -: 5230:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5231:
        -: 5232:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 5233:
        -: 5234:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 5235:
        -: 5236:  if (context_p == NULL)
        -: 5237:  {
        -: 5238:    return NULL;
        -: 5239:  }
        -: 5240:
        -: 5241:  memset (context_p, 0, total_size);
        -: 5242:
        -: 5243:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 5244:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 5245:
        -: 5246:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 5247:
        -: 5248:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5249:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 5250:  context_p->heap_size = heap_size;
        -: 5251:  byte_p += heap_size;
        -: 5252:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5253:
        -: 5254:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 5255:
        -: 5256:  JERRY_UNUSED (byte_p);
        -: 5257:  return context_p;
        -: 5258:
        -: 5259:#else /* !JERRY_EXTERNAL_CONTEXT */
        -: 5260:
        -: 5261:  JERRY_UNUSED (alloc);
        -: 5262:  JERRY_UNUSED (cb_data_p);
        -: 5263:
    #####: 5264:  return NULL;
        -: 5265:
        -: 5266:#endif /* JERRY_EXTERNAL_CONTEXT */
        -: 5267:} /* jerry_create_context */
        -: 5268:
        -: 5269:/**
        -: 5270: * When JERRY_VM_EXEC_STOP is enabled, the callback passed to this function
        -: 5271: * is periodically called with the user_p argument. If frequency is greater
        -: 5272: * than 1, the callback is only called at every frequency ticks.
        -: 5273: */
        -: 5274:void
    #####: 5275:jerry_set_vm_exec_stop_callback (jerry_vm_exec_stop_callback_t stop_cb, /**< periodically called user function */
        -: 5276:                                 void *user_p, /**< pointer passed to the function */
        -: 5277:                                 uint32_t frequency) /**< frequency of the function call */
        -: 5278:{
        -: 5279:#if JERRY_VM_EXEC_STOP
    #####: 5280:  if (frequency == 0)
        -: 5281:  {
    #####: 5282:    frequency = 1;
        -: 5283:  }
        -: 5284:
    #####: 5285:  JERRY_CONTEXT (vm_exec_stop_frequency) = frequency;
    #####: 5286:  JERRY_CONTEXT (vm_exec_stop_counter) = frequency;
    #####: 5287:  JERRY_CONTEXT (vm_exec_stop_cb) = stop_cb;
    #####: 5288:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
        -: 5289:#else /* !JERRY_VM_EXEC_STOP */
        -: 5290:  JERRY_UNUSED (stop_cb);
        -: 5291:  JERRY_UNUSED (user_p);
        -: 5292:  JERRY_UNUSED (frequency);
        -: 5293:#endif /* JERRY_VM_EXEC_STOP */
    #####: 5294:} /* jerry_set_vm_exec_stop_callback */
        -: 5295:
        -: 5296:/**
        -: 5297: * When JERRY_VM_THROW is enabled, the callback passed to this
        -: 5298: * function is called when an error is thrown in ECMAScript code.
        -: 5299: */
    #####: 5300:void jerry_set_vm_throw_callback (jerry_vm_throw_callback_t throw_cb, /**< callback which is called on throws */
        -: 5301:                                  void *user_p) /**< pointer passed to the function */
        -: 5302:{
        -: 5303:#if JERRY_VM_THROW
    #####: 5304:  JERRY_CONTEXT (vm_throw_callback_p) = throw_cb;
    #####: 5305:  JERRY_CONTEXT (vm_throw_callback_user_p) = user_p;
        -: 5306:#else /* !JERRY_VM_THROW */
        -: 5307:  JERRY_UNUSED (throw_cb);
        -: 5308:  JERRY_UNUSED (user_p);
        -: 5309:#endif /* JERRY_VM_THROW */
    #####: 5310:} /* jerry_set_vm_throw_callback */
        -: 5311:
        -: 5312:/**
        -: 5313: * Get backtrace. The backtrace is an array of strings where
        -: 5314: * each string contains the position of the corresponding frame.
        -: 5315: * The array length is zero if the backtrace is not available.
        -: 5316: *
        -: 5317: * @return array value
        -: 5318: */
        -: 5319:jerry_value_t
    #####: 5320:jerry_get_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 5321:{
    #####: 5322:  return vm_get_backtrace (max_depth);
        -: 5323:} /* jerry_get_backtrace */
        -: 5324:
        -: 5325:/**
        -: 5326: * Low-level function to capture each backtrace frame.
        -: 5327: * The captured frame data is passed to a callback function.
        -: 5328: */
        -: 5329:void
    #####: 5330:jerry_backtrace_capture (jerry_backtrace_callback_t callback, /**< callback function */
        -: 5331:                         void *user_p) /**< user pointer passed to the callback function */
        -: 5332:{
    #####: 5333:  jerry_backtrace_frame_t frame;
    #####: 5334:  vm_frame_ctx_t *context_p = JERRY_CONTEXT (vm_top_context_p);
        -: 5335:
    #####: 5336:  while (context_p != NULL)
        -: 5337:  {
    #####: 5338:    frame.context_p = context_p;
    #####: 5339:    frame.frame_type = JERRY_BACKTRACE_FRAME_JS;
        -: 5340:
    #####: 5341:    if (!callback (&frame, user_p))
        -: 5342:    {
    #####: 5343:      return;
        -: 5344:    }
        -: 5345:
    #####: 5346:    context_p = context_p->prev_context_p;
        -: 5347:  }
        -: 5348:} /* jerry_backtrace_capture */
        -: 5349:
        -: 5350:/**
        -: 5351: * Returns with the type of the backtrace frame.
        -: 5352: *
        -: 5353: * @return frame type listed in jerry_backtrace_frame_types_t
        -: 5354: */
        -: 5355:jerry_backtrace_frame_types_t
    #####: 5356:jerry_backtrace_get_frame_type (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5357:{
    #####: 5358:  return (jerry_backtrace_frame_types_t) frame_p->frame_type;
        -: 5359:} /* jerry_backtrace_get_frame_type */
        -: 5360:
        -: 5361:/**
        -: 5362: * Initialize and return with the location private field of a backtrace frame.
        -: 5363: *
        -: 5364: * @return pointer to the location private field - if the location is available,
        -: 5365: *         NULL - otherwise
        -: 5366: */
        -: 5367:const jerry_backtrace_location_t *
    #####: 5368:jerry_backtrace_get_location (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5369:{
        -: 5370:  JERRY_UNUSED (frame_p);
        -: 5371:
        -: 5372:#if JERRY_LINE_INFO
    #####: 5373:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5374:  {
    #####: 5375:    vm_frame_ctx_t *context_p = frame_p->context_p;
    #####: 5376:    const ecma_compiled_code_t *bytecode_header_p = context_p->shared_p->bytecode_header_p;
        -: 5377:
    #####: 5378:    if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO))
        -: 5379:    {
        -: 5380:      return NULL;
        -: 5381:    }
        -: 5382:
    #####: 5383:    frame_p->location.resource_name = ecma_get_resource_name (bytecode_header_p);
        -: 5384:
    #####: 5385:    ecma_line_info_get (ecma_compiled_code_get_line_info (bytecode_header_p),
    #####: 5386:                        (uint32_t) (context_p->byte_code_p - context_p->byte_code_start_p),
        -: 5387:                        &frame_p->location);
        -: 5388:
    #####: 5389:    return &frame_p->location;
        -: 5390:  }
        -: 5391:#endif /* JERRY_LINE_INFO */
        -: 5392:
    #####: 5393:  return NULL;
        -: 5394:} /* jerry_backtrace_get_location */
        -: 5395:
        -: 5396:/**
        -: 5397: * Initialize and return with the called function private field of a backtrace frame.
        -: 5398: * The backtrace frame is created for running the code bound to this function.
        -: 5399: *
        -: 5400: * @return pointer to the called function - if the function is available,
        -: 5401: *         NULL - otherwise
        -: 5402: */
        -: 5403:const jerry_value_t *
    #####: 5404:jerry_backtrace_get_function (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5405:{
    #####: 5406:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5407:  {
    #####: 5408:    vm_frame_ctx_t *context_p = frame_p->context_p;
        -: 5409:
    #####: 5410:    if (context_p->shared_p->function_object_p != NULL)
        -: 5411:    {
    #####: 5412:      frame_p->function = ecma_make_object_value (context_p->shared_p->function_object_p);
    #####: 5413:      return &frame_p->function;
        -: 5414:    }
        -: 5415:  }
        -: 5416:
    #####: 5417:  return NULL;
        -: 5418:} /* jerry_backtrace_get_function */
        -: 5419:
        -: 5420:/**
        -: 5421: * Initialize and return with the 'this' binding private field of a backtrace frame.
        -: 5422: * The 'this' binding is a hidden value passed to the called function. As for arrow
        -: 5423: * functions, the 'this' binding is assigned at function creation.
        -: 5424: *
        -: 5425: * @return pointer to the 'this' binding - if the binding is available,
        -: 5426: *         NULL - otherwise
        -: 5427: */
        -: 5428:const jerry_value_t *
    #####: 5429:jerry_backtrace_get_this (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5430:{
    #####: 5431:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5432:  {
    #####: 5433:    frame_p->this_binding = frame_p->context_p->this_binding;
    #####: 5434:    return &frame_p->this_binding;
        -: 5435:  }
        -: 5436:
    #####: 5437:  return NULL;
        -: 5438:} /* jerry_backtrace_get_this */
        -: 5439:
        -: 5440:/**
        -: 5441: * Returns true, if the code bound to the backtrace frame is strict mode code.
        -: 5442: *
        -: 5443: * @return true - if strict mode code is bound to the frame,
        -: 5444: *         false - otherwise
        -: 5445: */
        -: 5446:bool
    #####: 5447:jerry_backtrace_is_strict (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5448:{
    #####: 5449:  return (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS
    #####: 5450:          && (frame_p->context_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0);
        -: 5451:} /* jerry_backtrace_is_strict */
        -: 5452:
        -: 5453:/**
        -: 5454: * Get the resource name (usually a file name) of the currently executed script or the given function object
        -: 5455: *
        -: 5456: * Note: returned value must be freed with jerry_release_value, when it is no longer needed
        -: 5457: *
        -: 5458: * @return JS string constructed from
        -: 5459: *         - the currently executed function object's resource name, if the given value is undefined
        -: 5460: *         - resource name of the function object, if the given value is a function object
        -: 5461: *         - "<anonymous>", otherwise
        -: 5462: */
        -: 5463:jerry_value_t
    #####: 5464:jerry_get_resource_name (const jerry_value_t value) /**< jerry api value */
        -: 5465:{
        -: 5466:#if JERRY_RESOURCE_NAME
    #####: 5467:  if (ecma_is_value_undefined (value) && JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 5468:  {
    #####: 5469:    return ecma_copy_value (ecma_get_resource_name (JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p));
        -: 5470:  }
        -: 5471:
    #####: 5472:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5473:
    #####: 5474:  if (script_value == JMEM_CP_NULL)
        -: 5475:  {
    #####: 5476:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5477:  }
        -: 5478:
    #####: 5479:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5480:
    #####: 5481:  return ecma_copy_value (script_p->resource_name);
        -: 5482:#else /* !JERRY_RESOURCE_NAME */
        -: 5483:  JERRY_UNUSED (value);
        -: 5484:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5485:#endif /* JERRY_RESOURCE_NAME */
        -: 5486:} /* jerry_get_resource_name */
        -: 5487:
        -: 5488:/**
        -: 5489: * Returns the user value assigned to a script / module / function.
        -: 5490: *
        -: 5491: * Note:
        -: 5492: *    This value is usually set by the parser when
        -: 5493: *    the JERRY_PARSE_HAS_USER_VALUE flag is passed.
        -: 5494: *
        -: 5495: * @return user value
        -: 5496: */
        -: 5497:jerry_value_t
    #####: 5498:jerry_get_user_value (const jerry_value_t value) /**< jerry api value */
        -: 5499:{
    #####: 5500:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5501:
    #####: 5502:  if (script_value == JMEM_CP_NULL)
        -: 5503:  {
    #####: 5504:    return ECMA_VALUE_UNDEFINED;
        -: 5505:  }
        -: 5506:
    #####: 5507:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5508:
    #####: 5509:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE))
        -: 5510:  {
    #####: 5511:    return ECMA_VALUE_UNDEFINED;
        -: 5512:  }
        -: 5513:
    #####: 5514:  return ecma_copy_value (CBC_SCRIPT_GET_USER_VALUE (script_p));
        -: 5515:} /* jerry_get_user_value */
        -: 5516:
        -: 5517:/**
        -: 5518: * Returns a newly created source info structure corresponding to the passed script/module/function.
        -: 5519: *
        -: 5520: * @return a newly created source info, if at least one field is available, NULL otherwise
        -: 5521: */
        -: 5522:jerry_source_info_t *
    #####: 5523:jerry_get_source_info (const jerry_value_t value) /**< jerry api value */
        -: 5524:{
        -: 5525:  jerry_assert_api_available ();
        -: 5526:
        -: 5527:#if JERRY_FUNCTION_TO_STRING
    #####: 5528:  if (!ecma_is_value_object (value))
        -: 5529:  {
        -: 5530:    return NULL;
        -: 5531:  }
        -: 5532:
        -: 5533:  jerry_source_info_t source_info;
        -: 5534:
    #####: 5535:  source_info.enabled_fields = 0;
    #####: 5536:  source_info.source_code = ECMA_VALUE_UNDEFINED;
    #####: 5537:  source_info.function_arguments = ECMA_VALUE_UNDEFINED;
    #####: 5538:  source_info.source_range_start = 0;
    #####: 5539:  source_info.source_range_length = 0;
        -: 5540:
    #####: 5541:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 5542:  cbc_script_t *script_p = NULL;
        -: 5543:
        -: 5544:  while (true)
        -: 5545:  {
    #####: 5546:    switch (ecma_get_object_type (object_p))
        -: 5547:    {
    #####: 5548:      case ECMA_OBJECT_TYPE_CLASS:
        -: 5549:      {
    #####: 5550:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 5551:        const ecma_compiled_code_t *bytecode_p = NULL;
        -: 5552:
    #####: 5553:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 5554:        {
    #####: 5555:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5556:                                                        ext_object_p->u.cls.u3.value);
        -: 5557:        }
        -: 5558:#if JERRY_MODULE_SYSTEM
    #####: 5559:        else if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 5560:        {
    #####: 5561:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 5562:
    #####: 5563:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 5564:          {
    #####: 5565:            bytecode_p = module_p->u.compiled_code_p;
        -: 5566:          }
        -: 5567:        }
        -: 5568:#endif /* JERRY_MODULE_SYSTEM */
        -: 5569:
    #####: 5570:        if (bytecode_p == NULL)
        -: 5571:        {
        -: 5572:          return NULL;
        -: 5573:        }
        -: 5574:
    #####: 5575:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5576:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5577:        break;
        -: 5578:      }
    #####: 5579:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 5580:      {
        -: 5581:        const ecma_compiled_code_t *bytecode_p;
    #####: 5582:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
        -: 5583:
    #####: 5584:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5585:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5586:
    #####: 5587:        if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -: 5588:        {
    #####: 5589:          uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####: 5590:          uint8_t extended_info = *extended_info_p;
        -: 5591:
        -: 5592:#if JERRY_ESNEXT
    #####: 5593:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -: 5594:          {
    #####: 5595:            ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5596:          }
        -: 5597:#endif /* JERRY_ESNEXT */
        -: 5598:
    #####: 5599:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 5600:          {
    #####: 5601:            ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5602:
    #####: 5603:            ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5604:
    #####: 5605:            source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5606:            source_info.source_code = function_arguments;
    #####: 5607:            script_p = NULL;
        -: 5608:          }
        -: 5609:
    #####: 5610:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_RANGE;
    #####: 5611:          source_info.source_range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####: 5612:          source_info.source_range_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5613:        }
        -: 5614:
        -: 5615:        JERRY_ASSERT (script_p != NULL || (source_info.enabled_fields & JERRY_SOURCE_INFO_HAS_SOURCE_CODE));
        -: 5616:
    #####: 5617:        if (source_info.enabled_fields == 0 && (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -: 5618:        {
    #####: 5619:          ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5620:
    #####: 5621:          ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5622:
    #####: 5623:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_FUNCTION_ARGUMENTS;
    #####: 5624:          source_info.function_arguments = function_arguments;
        -: 5625:        }
        -: 5626:        break;
        -: 5627:      }
    #####: 5628:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 5629:      {
    #####: 5630:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 5631:
    #####: 5632:        object_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -: 5633:                                                               ext_object_p->u.bound_function.target_function);
    #####: 5634:        continue;
        -: 5635:      }
        -: 5636:#if JERRY_ESNEXT
    #####: 5637:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 5638:      {
    #####: 5639:        ecma_value_t script_value = ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
    #####: 5640:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5641:        break;
        -: 5642:      }
        -: 5643:#endif /* JERRY_ESNEXT */
        -: 5644:      default:
        -: 5645:      {
        -: 5646:        return NULL;
        -: 5647:      }
        -: 5648:    }
        -: 5649:
        -: 5650:    break;
        -: 5651:  }
        -: 5652:
    #####: 5653:  jerry_source_info_t *source_info_p = jmem_heap_alloc_block_null_on_error (sizeof (jerry_source_info_t));
        -: 5654:
    #####: 5655:  if (source_info_p == NULL)
        -: 5656:  {
        -: 5657:    return NULL;
        -: 5658:  }
        -: 5659:
    #####: 5660:  if (script_p != NULL)
        -: 5661:  {
    #####: 5662:    ecma_ref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 5663:
    #####: 5664:    source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5665:    source_info.source_code = script_p->source_code;
        -: 5666:  }
        -: 5667:
        -: 5668:  JERRY_ASSERT (source_info.enabled_fields != 0);
        -: 5669:
    #####: 5670:  *source_info_p = source_info;
    #####: 5671:  return source_info_p;
        -: 5672:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5673:  JERRY_UNUSED (value);
    #####: 5674:  return NULL;
        -: 5675:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 5676:} /* jerry_get_source_info */
        -: 5677:
        -: 5678:/**
        -: 5679: * Frees the the source info structure returned by jerry_get_source_info.
        -: 5680: */
        -: 5681:void
    #####: 5682:jerry_free_source_info (jerry_source_info_t *source_info_p) /**< source info block */
        -: 5683:{
        -: 5684:  jerry_assert_api_available ();
        -: 5685:
        -: 5686:#if JERRY_FUNCTION_TO_STRING
    #####: 5687:  if (source_info_p != NULL)
        -: 5688:  {
    #####: 5689:    ecma_free_value (source_info_p->source_code);
    #####: 5690:    ecma_free_value (source_info_p->function_arguments);
    #####: 5691:    jmem_heap_free_block (source_info_p, sizeof (jerry_source_info_t));
        -: 5692:  }
        -: 5693:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5694:  JERRY_UNUSED (source_info_p);
        -: 5695:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 5696:} /* jerry_free_source_info */
        -: 5697:
        -: 5698:/**
        -: 5699: * Replaces the currently active realm with another realm.
        -: 5700: *
        -: 5701: * The replacement should be temporary, and the original realm must be
        -: 5702: * restored after the tasks are completed. During the replacement, the
        -: 5703: * realm must be referenced by the application (i.e. the gc must not
        -: 5704: * reclaim it). This is also true to the returned previously active
        -: 5705: * realm, so there is no need to free the value after the restoration.
        -: 5706: *
        -: 5707: * @return previous realm value - if the passed value is a realm
        -: 5708: *         exception - otherwise
        -: 5709: */
        -: 5710:jerry_value_t
    #####: 5711:jerry_set_realm (jerry_value_t realm_value) /**< jerry api value */
        -: 5712:{
        -: 5713:  jerry_assert_api_available ();
        -: 5714:
        -: 5715:#if JERRY_BUILTIN_REALMS
    #####: 5716:  if (ecma_is_value_object (realm_value))
        -: 5717:  {
    #####: 5718:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5719:
    #####: 5720:    if (ecma_builtin_is_global (object_p))
        -: 5721:    {
    #####: 5722:      ecma_global_object_t *previous_global_object_p = JERRY_CONTEXT (global_object_p);
    #####: 5723:      JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) object_p;
    #####: 5724:      return ecma_make_object_value ((ecma_object_t *) previous_global_object_p);
        -: 5725:    }
        -: 5726:  }
        -: 5727:
    #####: 5728:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5729:#else /* !JERRY_BUILTIN_REALMS */
        -: 5730:  JERRY_UNUSED (realm_value);
    #####: 5731:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5732:#endif /* JERRY_BUILTIN_REALMS */
        -: 5733:} /* jerry_set_realm */
        -: 5734:
        -: 5735:/**
        -: 5736: * Gets the 'this' binding of a realm
        -: 5737: *
        -: 5738: * @return type error - if realm_value is not a realm
        -: 5739: *         this value - otherwise
        -: 5740: */
        -: 5741:jerry_value_t
    #####: 5742:jerry_realm_get_this (jerry_value_t realm_value) /**< realm value */
        -: 5743:{
        -: 5744:  jerry_assert_api_available ();
        -: 5745:
        -: 5746:#if JERRY_BUILTIN_REALMS
    #####: 5747:  if (ecma_is_value_object (realm_value))
        -: 5748:  {
    #####: 5749:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5750:
    #####: 5751:    if (ecma_builtin_is_global (object_p))
        -: 5752:    {
    #####: 5753:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -: 5754:
    #####: 5755:      ecma_ref_object (ecma_get_object_from_value (global_object_p->this_binding));
    #####: 5756:      return global_object_p->this_binding;
        -: 5757:    }
        -: 5758:  }
        -: 5759:
        -: 5760:#else /* !JERRY_BUILTIN_REALMS */
    #####: 5761:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 5762:
    #####: 5763:  if (realm_value == ecma_make_object_value (global_object_p))
        -: 5764:  {
    #####: 5765:    ecma_ref_object (global_object_p);
    #####: 5766:    return realm_value;
        -: 5767:  }
        -: 5768:#endif /* JERRY_BUILTIN_REALMS */
        -: 5769:
    #####: 5770:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5771:} /* jerry_realm_get_this */
        -: 5772:
        -: 5773:/**
        -: 5774: * Sets the 'this' binding of a realm
        -: 5775: *
        -: 5776: * This function must be called before executing any script on the realm.
        -: 5777: * Otherwise the operation is undefined.
        -: 5778: *
        -: 5779: * @return type error - if realm_value is not a realm or this_value is not object
        -: 5780: *         true - otherwise
        -: 5781: */
        -: 5782:jerry_value_t
    #####: 5783:jerry_realm_set_this (jerry_value_t realm_value, /**< realm value */
        -: 5784:                      jerry_value_t this_value) /**< this value */
        -: 5785:{
        -: 5786:  jerry_assert_api_available ();
        -: 5787:
        -: 5788:#if JERRY_BUILTIN_REALMS
    #####: 5789:  if (!ecma_is_value_object (this_value))
        -: 5790:  {
    #####: 5791:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Second argument must be an object")));
        -: 5792:  }
        -: 5793:
    #####: 5794:  if (ecma_is_value_object (realm_value))
        -: 5795:  {
    #####: 5796:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5797:
    #####: 5798:    if (ecma_builtin_is_global (object_p))
        -: 5799:    {
    #####: 5800:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
    #####: 5801:      global_object_p->this_binding = this_value;
        -: 5802:
    #####: 5803:      ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, ecma_get_object_from_value (this_value));
        -: 5804:
    #####: 5805:      ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -: 5806:#if JERRY_ESNEXT
    #####: 5807:      global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -: 5808:#endif /* JERRY_ESNEXT */
    #####: 5809:      ecma_deref_object (global_lex_env_p);
    #####: 5810:      return ECMA_VALUE_TRUE;
        -: 5811:    }
        -: 5812:  }
        -: 5813:
    #####: 5814:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("First argument is not a realm")));
        -: 5815:#else /* !JERRY_BUILTIN_REALMS */
        -: 5816:  JERRY_UNUSED (realm_value);
        -: 5817:  JERRY_UNUSED (this_value);
    #####: 5818:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5819:#endif /* JERRY_BUILTIN_REALMS */
        -: 5820:} /* jerry_realm_set_this */
        -: 5821:
        -: 5822:/**
        -: 5823: * Check if the given value is an ArrayBuffer object.
        -: 5824: *
        -: 5825: * @return true - if it is an ArrayBuffer object
        -: 5826: *         false - otherwise
        -: 5827: */
        -: 5828:bool
    #####: 5829:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 5830:{
        -: 5831:  jerry_assert_api_available ();
        -: 5832:
        -: 5833:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5834:  return ecma_is_arraybuffer (value);
        -: 5835:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5836:  JERRY_UNUSED (value);
    #####: 5837:  return false;
        -: 5838:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5839:} /* jerry_value_is_arraybuffer */
        -: 5840:
        -: 5841:/**
        -: 5842: * Creates an ArrayBuffer object with the given length (size).
        -: 5843: *
        -: 5844: * Notes:
        -: 5845: *      * the length is specified in bytes.
        -: 5846: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5847: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5848: *
        -: 5849: * @return value of the constructed ArrayBuffer object
        -: 5850: */
        -: 5851:jerry_value_t
    #####: 5852:jerry_create_arraybuffer (const jerry_length_t size) /**< size of the ArrayBuffer to create */
        -: 5853:{
        -: 5854:  jerry_assert_api_available ();
        -: 5855:
        -: 5856:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5857:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 5858:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5859:  JERRY_UNUSED (size);
    #####: 5860:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5861:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5862:} /* jerry_create_arraybuffer */
        -: 5863:
        -: 5864:/**
        -: 5865: * Creates an ArrayBuffer object with user specified buffer.
        -: 5866: *
        -: 5867: * Notes:
        -: 5868: *     * the size is specified in bytes.
        -: 5869: *     * the buffer passed should be at least the specified bytes big.
        -: 5870: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5871: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 5872: *
        -: 5873: * @return value of the construced ArrayBuffer object
        -: 5874: */
        -: 5875:jerry_value_t
    #####: 5876:jerry_create_arraybuffer_external (const jerry_length_t size, /**< size of the buffer to used */
        -: 5877:                                   uint8_t *buffer_p, /**< buffer to use as the ArrayBuffer's backing */
        -: 5878:                                   jerry_value_free_callback_t free_cb) /**< buffer free callback */
        -: 5879:{
        -: 5880:  jerry_assert_api_available ();
        -: 5881:
        -: 5882:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5883:  ecma_object_t *arraybuffer;
        -: 5884:
    #####: 5885:  if (JERRY_UNLIKELY (size == 0 || buffer_p == NULL))
        -: 5886:  {
    #####: 5887:    arraybuffer = ecma_arraybuffer_new_object (0);
        -: 5888:  }
        -: 5889:  else
        -: 5890:  {
    #####: 5891:    arraybuffer = ecma_arraybuffer_new_object_external (size, buffer_p, free_cb);
        -: 5892:  }
        -: 5893:
    #####: 5894:  return jerry_return (ecma_make_object_value (arraybuffer));
        -: 5895:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5896:  JERRY_UNUSED (size);
        -: 5897:  JERRY_UNUSED (buffer_p);
        -: 5898:  JERRY_UNUSED (free_cb);
    #####: 5899:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5900:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5901:} /* jerry_create_arraybuffer_external */
        -: 5902:
        -: 5903:/**
        -: 5904: * Check if the given value is a SharedArrayBuffer object.
        -: 5905: *
        -: 5906: * @return true - if it is a SharedArrayBuffer object
        -: 5907: *         false - otherwise
        -: 5908: */
        -: 5909:bool
    #####: 5910:jerry_value_is_shared_arraybuffer (const jerry_value_t value) /**< value to check if it is a SharedArrayBuffer */
        -: 5911:{
        -: 5912:  jerry_assert_api_available ();
        -: 5913:
    #####: 5914:  return ecma_is_shared_arraybuffer (value);
        -: 5915:} /* jerry_value_is_shared_arraybuffer */
        -: 5916:
        -: 5917:/**
        -: 5918: * Creates a SharedArrayBuffer object with the given length (size).
        -: 5919: *
        -: 5920: * Notes:
        -: 5921: *      * the length is specified in bytes.
        -: 5922: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5923: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5924: *
        -: 5925: * @return value of the constructed SharedArrayBuffer object
        -: 5926: */
        -: 5927:jerry_value_t
    #####: 5928:jerry_create_shared_arraybuffer (const jerry_length_t size) /**< size of the SharedArrayBuffer to create */
        -: 5929:{
        -: 5930:  jerry_assert_api_available ();
        -: 5931:
        -: 5932:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 5933:  return jerry_return (ecma_make_object_value (ecma_shared_arraybuffer_new_object (size)));
        -: 5934:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5935:  JERRY_UNUSED (size);
    #####: 5936:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 5937:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5938:} /* jerry_create_shared_arraybuffer */
        -: 5939:
        -: 5940:/**
        -: 5941: * Creates a SharedArrayBuffer object with user specified buffer.
        -: 5942: *
        -: 5943: * Notes:
        -: 5944: *     * the size is specified in bytes.
        -: 5945: *     * the buffer passed should be at least the specified bytes big.
        -: 5946: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5947: *     * if the size is zero or buffer_p is a null pointer this will return an empty SharedArrayBuffer.
        -: 5948: *
        -: 5949: * @return value of the construced SharedArrayBuffer object
        -: 5950: */
        -: 5951:jerry_value_t
    #####: 5952:jerry_create_shared_arraybuffer_external (const jerry_length_t size, /**< size of the buffer to used */
        -: 5953:                                          uint8_t *buffer_p, /**< buffer to use as the SharedArrayBuffer's backing */
        -: 5954:                                          jerry_value_free_callback_t free_cb) /**< buffer free callback */
        -: 5955:{
        -: 5956:  jerry_assert_api_available ();
        -: 5957:
        -: 5958:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 5959:  ecma_object_t *shared_arraybuffer;
        -: 5960:
    #####: 5961:  if (JERRY_UNLIKELY (size == 0 || buffer_p == NULL))
        -: 5962:  {
    #####: 5963:    shared_arraybuffer = ecma_shared_arraybuffer_new_object (0);
        -: 5964:  }
        -: 5965:  else
        -: 5966:  {
    #####: 5967:    shared_arraybuffer = ecma_shared_arraybuffer_new_object_external (size, buffer_p, free_cb);
        -: 5968:  }
        -: 5969:
    #####: 5970:  return jerry_return (ecma_make_object_value (shared_arraybuffer));
        -: 5971:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5972:  JERRY_UNUSED (size);
        -: 5973:  JERRY_UNUSED (buffer_p);
        -: 5974:  JERRY_UNUSED (free_cb);
    #####: 5975:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 5976:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5977:} /* jerry_create_shared_arraybuffer_external */
        -: 5978:
        -: 5979:/**
        -: 5980: * Copy bytes into the ArrayBuffer or SharedArrayBuffer from a buffer.
        -: 5981: *
        -: 5982: * Note:
        -: 5983: *     * returns 0, if the passed object is not an ArrayBuffer or SharedArrayBuffer
        -: 5984: *
        -: 5985: * @return number of bytes copied into the ArrayBuffer or SharedArrayBuffer.
        -: 5986: */
        -: 5987:jerry_length_t
    #####: 5988:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer or SharedArrayBuffer */
        -: 5989:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 5990:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 5991:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 5992:{
        -: 5993:  jerry_assert_api_available ();
        -: 5994:
        -: 5995:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5996:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 5997:  {
    #####: 5998:    return 0;
        -: 5999:  }
        -: 6000:
    #####: 6001:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6002:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6003:
    #####: 6004:  if (offset >= length)
        -: 6005:  {
    #####: 6006:    return 0;
        -: 6007:  }
        -: 6008:
    #####: 6009:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6010:
    #####: 6011:  if (copy_count > 0)
        -: 6012:  {
    #####: 6013:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6014:
    #####: 6015:    memcpy ((void *) (mem_buffer_p + offset), (void *) buf_p, copy_count);
        -: 6016:  }
        -: 6017:
    #####: 6018:  return copy_count;
        -: 6019:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6020:  JERRY_UNUSED (value);
        -: 6021:  JERRY_UNUSED (offset);
        -: 6022:  JERRY_UNUSED (buf_p);
        -: 6023:  JERRY_UNUSED (buf_size);
    #####: 6024:  return 0;
        -: 6025:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6026:} /* jerry_arraybuffer_write */
        -: 6027:
        -: 6028:/**
        -: 6029: * Copy bytes from a buffer into an ArrayBuffer or SharedArrayBuffer.
        -: 6030: *
        -: 6031: * Note:
        -: 6032: *     * if the object passed is not an ArrayBuffer or SharedArrayBuffer will return 0.
        -: 6033: *
        -: 6034: * @return number of bytes read from the ArrayBuffer.
        -: 6035: */
        -: 6036:jerry_length_t
    #####: 6037:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer or SharedArrayBuffer to read from */
        -: 6038:                        jerry_length_t offset, /**< start offset of the ArrayBuffer or SharedArrayBuffer */
        -: 6039:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 6040:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 6041:{
        -: 6042:  jerry_assert_api_available ();
        -: 6043:
        -: 6044:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6045:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6046:  {
    #####: 6047:    return 0;
        -: 6048:  }
        -: 6049:
    #####: 6050:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6051:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6052:
    #####: 6053:  if (offset >= length)
        -: 6054:  {
    #####: 6055:    return 0;
        -: 6056:  }
        -: 6057:
    #####: 6058:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6059:
    #####: 6060:  if (copy_count > 0)
        -: 6061:  {
    #####: 6062:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6063:
    #####: 6064:    memcpy ((void *) buf_p, (void *) (mem_buffer_p + offset), copy_count);
        -: 6065:  }
        -: 6066:
    #####: 6067:  return copy_count;
        -: 6068:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6069:  JERRY_UNUSED (value);
        -: 6070:  JERRY_UNUSED (offset);
        -: 6071:  JERRY_UNUSED (buf_p);
        -: 6072:  JERRY_UNUSED (buf_size);
    #####: 6073:  return 0;
        -: 6074:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6075:} /* jerry_arraybuffer_read */
        -: 6076:
        -: 6077:/**
        -: 6078: * Get the length (size) of the ArrayBuffer or SharedArrayBuffer in bytes.
        -: 6079: *
        -: 6080: * Note:
        -: 6081: *     This is the 'byteLength' property of an ArrayBuffer or SharedArrayBuffer.
        -: 6082: *
        -: 6083: * @return the length of the ArrayBuffer in bytes.
        -: 6084: */
        -: 6085:jerry_length_t
    #####: 6086:jerry_get_arraybuffer_byte_length (const jerry_value_t value) /**< ArrayBuffer or SharedArrayBuffer */
        -: 6087:{
        -: 6088:  jerry_assert_api_available ();
        -: 6089:
        -: 6090:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6091:  if (ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value))
        -: 6092:  {
    #####: 6093:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6094:    return ecma_arraybuffer_get_length (buffer_p);
        -: 6095:  }
        -: 6096:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6097:  JERRY_UNUSED (value);
        -: 6098:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6099:  return 0;
        -: 6100:} /* jerry_get_arraybuffer_byte_length */
        -: 6101:
        -: 6102:/**
        -: 6103: * Get a pointer for the start of the ArrayBuffer.
        -: 6104: *
        -: 6105: * Note:
        -: 6106: *    * This is a high-risk operation as the bounds are not checked
        -: 6107: *      when accessing the pointer elements.
        -: 6108: *
        -: 6109: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 6110: *         pointer is NULL if:
        -: 6111: *            - the parameter is not an ArrayBuffer
        -: 6112: *            - an external ArrayBuffer has been detached
        -: 6113: */
        -: 6114:uint8_t *
    #####: 6115:jerry_get_arraybuffer_pointer (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 6116:{
        -: 6117:  jerry_assert_api_available ();
        -: 6118:
        -: 6119:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6120:  if (ecma_is_value_error_reference (array_buffer)
    #####: 6121:      || !(ecma_is_arraybuffer (array_buffer) || ecma_is_shared_arraybuffer (array_buffer)))
        -: 6122:  {
    #####: 6123:    return NULL;
        -: 6124:  }
        -: 6125:
    #####: 6126:  ecma_object_t *buffer_p = ecma_get_object_from_value (array_buffer);
    #####: 6127:  lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
    #####: 6128:  return (uint8_t *const) mem_buffer_p;
        -: 6129:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6130:  JERRY_UNUSED (array_buffer);
        -: 6131:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6132:
    #####: 6133:  return NULL;
        -: 6134:} /* jerry_get_arraybuffer_pointer */
        -: 6135:
        -: 6136:/**
        -: 6137: * Get if the ArrayBuffer is detachable.
        -: 6138: *
        -: 6139: * @return boolean value - if success
        -: 6140: *         value marked with error flag - otherwise
        -: 6141: */
        -: 6142:jerry_value_t
    #####: 6143:jerry_is_arraybuffer_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 6144:{
        -: 6145:  jerry_assert_api_available ();
        -: 6146:
        -: 6147:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6148:  if (ecma_is_arraybuffer (value))
        -: 6149:  {
    #####: 6150:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6151:    return ecma_arraybuffer_is_detached (buffer_p) ? ECMA_VALUE_FALSE : ECMA_VALUE_TRUE;
        -: 6152:  }
        -: 6153:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6154:  JERRY_UNUSED (value);
        -: 6155:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6156:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6157:} /* jerry_is_arraybuffer_detachable */
        -: 6158:
        -: 6159:/**
        -: 6160: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 6161: *
        -: 6162: * Note: If the ArrayBuffer has been created with `jerry_create_arraybuffer_external`
        -: 6163: *       the optional free callback is called on a successful detach operation
        -: 6164: *
        -: 6165: * @return null value - if success
        -: 6166: *         value marked with error flag - otherwise
        -: 6167: */
        -: 6168:jerry_value_t
    #####: 6169:jerry_detach_arraybuffer (const jerry_value_t value) /**< ArrayBuffer */
        -: 6170:{
        -: 6171:  jerry_assert_api_available ();
        -: 6172:
        -: 6173:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6174:  if (ecma_is_arraybuffer (value))
        -: 6175:  {
    #####: 6176:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6177:    if (ecma_arraybuffer_detach (buffer_p))
        -: 6178:    {
    #####: 6179:      return ECMA_VALUE_NULL;
        -: 6180:    }
    #####: 6181:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has already been detached")));
        -: 6182:  }
        -: 6183:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6184:  JERRY_UNUSED (value);
        -: 6185:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6186:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6187:} /* jerry_detach_arraybuffer */
        -: 6188:
        -: 6189:/**
        -: 6190: * DataView related functions
        -: 6191: */
        -: 6192:
        -: 6193:/**
        -: 6194: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 6195: *
        -: 6196: * Notes:
        -: 6197: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 6198: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 6199: *
        -: 6200: * @return value of the constructed DataView object - if success
        -: 6201: *         created error - otherwise
        -: 6202: */
        -: 6203:jerry_value_t
    #####: 6204:jerry_create_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 6205:                       const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 6206:                       const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 6207:{
        -: 6208:  jerry_assert_api_available ();
        -: 6209:
        -: 6210:#if JERRY_BUILTIN_DATAVIEW
    #####: 6211:  if (ecma_is_value_error_reference (array_buffer))
        -: 6212:  {
    #####: 6213:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6214:  }
        -: 6215:
    #####: 6216:  ecma_value_t arguments_p[3] =
        -: 6217:  {
        -: 6218:    array_buffer,
    #####: 6219:    ecma_make_uint32_value (byte_offset),
    #####: 6220:    ecma_make_uint32_value (byte_length)
        -: 6221:  };
    #####: 6222:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
    #####: 6223:  if (old_new_target_p == NULL)
        -: 6224:  {
    #####: 6225:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ECMA_BUILTIN_ID_DATAVIEW);
        -: 6226:  }
        -: 6227:
    #####: 6228:  ecma_value_t dataview_value = ecma_op_dataview_create (arguments_p, 3);
    #####: 6229:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6230:  return jerry_return (dataview_value);
        -: 6231:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6232:  JERRY_UNUSED (array_buffer);
        -: 6233:  JERRY_UNUSED (byte_offset);
        -: 6234:  JERRY_UNUSED (byte_length);
    #####: 6235:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6236:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6237:} /* jerry_create_dataview */
        -: 6238:
        -: 6239:/**
        -: 6240: * Check if the given value is a DataView object.
        -: 6241: *
        -: 6242: * @return true - if it is a DataView object
        -: 6243: *         false - otherwise
        -: 6244: */
        -: 6245:bool
    #####: 6246:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 6247:{
        -: 6248:  jerry_assert_api_available ();
        -: 6249:
        -: 6250:#if JERRY_BUILTIN_DATAVIEW
    #####: 6251:  return ecma_is_dataview (value);
        -: 6252:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6253:  JERRY_UNUSED (value);
    #####: 6254:  return false;
        -: 6255:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6256:} /* jerry_value_is_dataview */
        -: 6257:
        -: 6258:/**
        -: 6259: * Get the underlying ArrayBuffer from a DataView.
        -: 6260: *
        -: 6261: * Additionally the byteLength and byteOffset properties are also returned
        -: 6262: * which were specified when the DataView was created.
        -: 6263: *
        -: 6264: * Note:
        -: 6265: *     the returned value must be freed with a jerry_release_value call
        -: 6266: *
        -: 6267: * @return ArrayBuffer of a DataView
        -: 6268: *         TypeError if the object is not a DataView.
        -: 6269: */
        -: 6270:jerry_value_t
    #####: 6271:jerry_get_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 6272:                           jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6273:                           jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6274:{
        -: 6275:  jerry_assert_api_available ();
        -: 6276:
        -: 6277:#if JERRY_BUILTIN_DATAVIEW
    #####: 6278:  if (ecma_is_value_error_reference (value))
        -: 6279:  {
    #####: 6280:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6281:  }
        -: 6282:
    #####: 6283:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 6284:
    #####: 6285:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 6286:  {
    #####: 6287:    return ecma_create_error_reference_from_context ();
        -: 6288:  }
        -: 6289:
    #####: 6290:  if (byte_offset != NULL)
        -: 6291:  {
    #####: 6292:    *byte_offset = dataview_p->byte_offset;
        -: 6293:  }
        -: 6294:
    #####: 6295:  if (byte_length != NULL)
        -: 6296:  {
    #####: 6297:    *byte_length = dataview_p->header.u.cls.u3.length;
        -: 6298:  }
        -: 6299:
    #####: 6300:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 6301:  ecma_ref_object (arraybuffer_p);
        -: 6302:
    #####: 6303:  return ecma_make_object_value (arraybuffer_p);
        -: 6304:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6305:  JERRY_UNUSED (value);
        -: 6306:  JERRY_UNUSED (byte_offset);
        -: 6307:  JERRY_UNUSED (byte_length);
    #####: 6308:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6309:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6310:} /* jerry_get_dataview_buffer */
        -: 6311:
        -: 6312:/**
        -: 6313: * TypedArray related functions
        -: 6314: */
        -: 6315:
        -: 6316:/**
        -: 6317: * Check if the given value is a TypedArray object.
        -: 6318: *
        -: 6319: * @return true - if it is a TypedArray object
        -: 6320: *         false - otherwise
        -: 6321: */
        -: 6322:bool
    #####: 6323:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 6324:{
        -: 6325:  jerry_assert_api_available ();
        -: 6326:
        -: 6327:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6328:  return ecma_is_typedarray (value);
        -: 6329:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6330:  JERRY_UNUSED (value);
    #####: 6331:  return false;
        -: 6332:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6333:} /* jerry_value_is_typedarray */
        -: 6334:
        -: 6335:#if JERRY_BUILTIN_TYPEDARRAY
        -: 6336:/**
        -: 6337: * TypedArray mapping type
        -: 6338: */
        -: 6339:typedef struct
        -: 6340:{
        -: 6341:  jerry_typedarray_type_t api_type; /**< api type */
        -: 6342:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 6343:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 6344:  uint8_t element_size_shift; /**< element size shift */
        -: 6345:} jerry_typedarray_mapping_t;
        -: 6346:
        -: 6347:/**
        -: 6348: * List of TypedArray mappings
        -: 6349: */
        -: 6350:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] =
        -: 6351:{
        -: 6352:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT) \
        -: 6353:  { JERRY_TYPEDARRAY_ ## NAME, ECMA_BUILTIN_ID_ ## NAME ## ARRAY_PROTOTYPE, \
        -: 6354:    ECMA_ ## LIT_NAME ## _ARRAY, SIZE_SHIFT }
        -: 6355:
        -: 6356:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),
        -: 6357:  TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 6358:  TYPEDARRAY_ENTRY (INT8, INT8, 0),
        -: 6359:  TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 6360:  TYPEDARRAY_ENTRY (INT16, INT16, 1),
        -: 6361:  TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 6362:  TYPEDARRAY_ENTRY (INT32, INT32, 2),
        -: 6363:  TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 6364:#if JERRY_NUMBER_TYPE_FLOAT64
        -: 6365:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 6366:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 6367:#if JERRY_BUILTIN_BIGINT
        -: 6368:  TYPEDARRAY_ENTRY (BIGINT64, BIGINT64, 3),
        -: 6369:  TYPEDARRAY_ENTRY (BIGUINT64, BIGUINT64, 3),
        -: 6370:#endif /* JERRY_BUILTIN_BIGINT */
        -: 6371:#undef TYPEDARRAY_ENTRY
        -: 6372:};
        -: 6373:
        -: 6374:/**
        -: 6375: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 6376: * information.
        -: 6377: *
        -: 6378: * @return true - if the TypedArray information was found
        -: 6379: *         false - if there is no such TypedArray type
        -: 6380: */
        -: 6381:static bool
    #####: 6382:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 6383:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 6384:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 6385:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 6386:{
    #####: 6387:  JERRY_ASSERT (prototype_id != NULL);
    #####: 6388:  JERRY_ASSERT (id != NULL);
    #####: 6389:  JERRY_ASSERT (element_size_shift != NULL);
        -: 6390:
    #####: 6391:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6392:  {
    #####: 6393:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 6394:    {
    #####: 6395:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 6396:      *id = jerry_typedarray_mappings[i].id;
    #####: 6397:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 6398:      return true;
        -: 6399:    }
        -: 6400:  }
        -: 6401:
    #####: 6402:  return false;
        -: 6403:} /* jerry_typedarray_find_by_type */
        -: 6404:
        -: 6405:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6406:
        -: 6407:/**
        -: 6408: * Create a TypedArray object with a given type and length.
        -: 6409: *
        -: 6410: * Notes:
        -: 6411: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6412: *      * byteOffset property will be set to 0.
        -: 6413: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 6414: *
        -: 6415: * @return - new TypedArray object
        -: 6416: */
        -: 6417:jerry_value_t
    #####: 6418:jerry_create_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6419:                         jerry_length_t length) /**< element count of the new TypedArray */
        -: 6420:{
        -: 6421:  jerry_assert_api_available ();
        -: 6422:
        -: 6423:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6424:  ecma_builtin_id_t prototype_id = 0;
    #####: 6425:  ecma_typedarray_type_t id = 0;
    #####: 6426:  uint8_t element_size_shift = 0;
        -: 6427:
    #####: 6428:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6429:  {
    #####: 6430:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6431:  }
        -: 6432:
    #####: 6433:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 6434:
    #####: 6435:  ecma_value_t array_value = ecma_typedarray_create_object_with_length (length,
        -: 6436:                                                                        NULL,
        -: 6437:                                                                        prototype_obj_p,
        -: 6438:                                                                        element_size_shift,
        -: 6439:                                                                        id);
        -: 6440:
    #####: 6441:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 6442:
    #####: 6443:  return array_value;
        -: 6444:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6445:  JERRY_UNUSED (type_name);
        -: 6446:  JERRY_UNUSED (length);
    #####: 6447:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6448:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6449:} /* jerry_create_typedarray */
        -: 6450:
        -: 6451:/**
        -: 6452: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6453: *
        -: 6454: * Notes:
        -: 6455: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6456: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 6457: *
        -: 6458: * @return - new TypedArray object
        -: 6459: */
        -: 6460:jerry_value_t
    #####: 6461:jerry_create_typedarray_for_arraybuffer_sz (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6462:                                            const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 6463:                                            jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 6464:                                            jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 6465:{
        -: 6466:  jerry_assert_api_available ();
        -: 6467:
        -: 6468:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6469:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6470:  {
    #####: 6471:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6472:  }
        -: 6473:
    #####: 6474:  ecma_builtin_id_t prototype_id = 0;
    #####: 6475:  ecma_typedarray_type_t id = 0;
    #####: 6476:  uint8_t element_size_shift = 0;
        -: 6477:
    #####: 6478:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6479:  {
    #####: 6480:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6481:  }
        -: 6482:
    #####: 6483:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 6484:  {
    #####: 6485:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not an ArrayBuffer")));
        -: 6486:  }
        -: 6487:
    #####: 6488:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 6489:  ecma_value_t arguments_p[3] =
        -: 6490:  {
        -: 6491:    arraybuffer,
    #####: 6492:    ecma_make_uint32_value (byte_offset),
    #####: 6493:    ecma_make_uint32_value (length)
        -: 6494:  };
        -: 6495:
    #####: 6496:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 6497:  ecma_free_value (arguments_p[1]);
    #####: 6498:  ecma_free_value (arguments_p[2]);
        -: 6499:
    #####: 6500:  return jerry_return (array_value);
        -: 6501:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6502:  JERRY_UNUSED (type_name);
        -: 6503:  JERRY_UNUSED (arraybuffer);
        -: 6504:  JERRY_UNUSED (byte_offset);
        -: 6505:  JERRY_UNUSED (length);
    #####: 6506:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6507:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6508:} /* jerry_create_typedarray_for_arraybuffer_sz */
        -: 6509:
        -: 6510:/**
        -: 6511: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6512: *
        -: 6513: * Notes:
        -: 6514: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6515: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 6516: *
        -: 6517: * @return - new TypedArray object
        -: 6518: */
        -: 6519:jerry_value_t
    #####: 6520:jerry_create_typedarray_for_arraybuffer (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6521:                                         const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 6522:{
        -: 6523:  jerry_assert_api_available ();
        -: 6524:
        -: 6525:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6526:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6527:  {
    #####: 6528:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6529:  }
        -: 6530:
    #####: 6531:  jerry_length_t byteLength = jerry_get_arraybuffer_byte_length (arraybuffer);
    #####: 6532:  return jerry_create_typedarray_for_arraybuffer_sz (type_name, arraybuffer, 0, byteLength);
        -: 6533:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6534:  JERRY_UNUSED (type_name);
        -: 6535:  JERRY_UNUSED (arraybuffer);
    #####: 6536:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6537:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6538:} /* jerry_create_typedarray_for_arraybuffer */
        -: 6539:
        -: 6540:/**
        -: 6541: * Get the type of the TypedArray.
        -: 6542: *
        -: 6543: * @return - type of the TypedArray
        -: 6544: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 6545: */
        -: 6546:jerry_typedarray_type_t
    #####: 6547:jerry_get_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 6548:{
        -: 6549:  jerry_assert_api_available ();
        -: 6550:
        -: 6551:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6552:  if (!ecma_is_typedarray (value))
        -: 6553:  {
    #####: 6554:    return JERRY_TYPEDARRAY_INVALID;
        -: 6555:  }
        -: 6556:
    #####: 6557:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6558:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 6559:
    #####: 6560:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6561:  {
    #####: 6562:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 6563:    {
    #####: 6564:      return jerry_typedarray_mappings[i].api_type;
        -: 6565:    }
        -: 6566:  }
        -: 6567:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6568:  JERRY_UNUSED (value);
        -: 6569:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6570:
    #####: 6571:  return JERRY_TYPEDARRAY_INVALID;
        -: 6572:} /* jerry_get_typedarray_type */
        -: 6573:
        -: 6574:/**
        -: 6575: * Get the element count of the TypedArray.
        -: 6576: *
        -: 6577: * @return length of the TypedArray.
        -: 6578: */
        -: 6579:jerry_length_t
    #####: 6580:jerry_get_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 6581:{
        -: 6582:  jerry_assert_api_available ();
        -: 6583:
        -: 6584:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6585:  if (ecma_is_typedarray (value))
        -: 6586:  {
    #####: 6587:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6588:    return ecma_typedarray_get_length (array_p);
        -: 6589:  }
        -: 6590:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6591:  JERRY_UNUSED (value);
        -: 6592:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6593:
    #####: 6594:  return 0;
        -: 6595:} /* jerry_get_typedarray_length */
        -: 6596:
        -: 6597:/**
        -: 6598: * Get the underlying ArrayBuffer from a TypedArray.
        -: 6599: *
        -: 6600: * Additionally the byteLength and byteOffset properties are also returned
        -: 6601: * which were specified when the TypedArray was created.
        -: 6602: *
        -: 6603: * Note:
        -: 6604: *     the returned value must be freed with a jerry_release_value call
        -: 6605: *
        -: 6606: * @return ArrayBuffer of a TypedArray
        -: 6607: *         TypeError if the object is not a TypedArray.
        -: 6608: */
        -: 6609:jerry_value_t
    #####: 6610:jerry_get_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 6611:                             jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6612:                             jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6613:{
        -: 6614:  jerry_assert_api_available ();
        -: 6615:
        -: 6616:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6617:  if (!ecma_is_typedarray (value))
        -: 6618:  {
    #####: 6619:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Object is not a TypedArray")));
        -: 6620:  }
        -: 6621:
    #####: 6622:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6623:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 6624:
    #####: 6625:  if (byte_length != NULL)
        -: 6626:  {
    #####: 6627:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 6628:  }
        -: 6629:
    #####: 6630:  if (byte_offset != NULL)
        -: 6631:  {
    #####: 6632:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 6633:  }
        -: 6634:
    #####: 6635:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 6636:  ecma_ref_object (arraybuffer_p);
    #####: 6637:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 6638:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6639:  JERRY_UNUSED (value);
        -: 6640:  JERRY_UNUSED (byte_length);
        -: 6641:  JERRY_UNUSED (byte_offset);
    #####: 6642:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6643:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6644:} /* jerry_get_typedarray_buffer */
        -: 6645:
        -: 6646:/**
        -: 6647: * Parse the given JSON string to create a jerry_value_t.
        -: 6648: *
        -: 6649: * The behaviour is equivalent with the "JSON.parse(string)" JS call.
        -: 6650: *
        -: 6651: * Note:
        -: 6652: *      The returned value must be freed with jerry_release_value.
        -: 6653: *
        -: 6654: * @return - jerry_value_t containing a JavaScript value.
        -: 6655: *         - Error value if there was problems during the parse.
        -: 6656: */
        -: 6657:jerry_value_t
    #####: 6658:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 6659:                  jerry_size_t string_size) /**< json string size */
        -: 6660:{
        -: 6661:  jerry_assert_api_available ();
        -: 6662:
        -: 6663:#if JERRY_BUILTIN_JSON
    #####: 6664:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 6665:
    #####: 6666:  if (ecma_is_value_undefined (ret_value))
        -: 6667:  {
    #####: 6668:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON string parse error")));
        -: 6669:  }
        -: 6670:
    #####: 6671:  return jerry_return (ret_value);
        -: 6672:#else /* !JERRY_BUILTIN_JSON */
        -: 6673:  JERRY_UNUSED (string_p);
        -: 6674:  JERRY_UNUSED (string_size);
        -: 6675:
        -: 6676:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6677:#endif /* JERRY_BUILTIN_JSON */
        -: 6678:} /* jerry_json_parse */
        -: 6679:
        -: 6680:/**
        -: 6681: * Create a JSON string from a JavaScript value.
        -: 6682: *
        -: 6683: * The behaviour is equivalent with the "JSON.stringify(input_value)" JS call.
        -: 6684: *
        -: 6685: * Note:
        -: 6686: *      The returned value must be freed with jerry_release_value,
        -: 6687: *
        -: 6688: * @return - jerry_value_t containing a JSON string.
        -: 6689: *         - Error value if there was a problem during the stringification.
        -: 6690: */
        -: 6691:jerry_value_t
    #####: 6692:jerry_json_stringify (const jerry_value_t input_value) /**< a value to stringify */
        -: 6693:{
        -: 6694:  jerry_assert_api_available ();
        -: 6695:#if JERRY_BUILTIN_JSON
    #####: 6696:  if (ecma_is_value_error_reference (input_value))
        -: 6697:  {
    #####: 6698:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6699:  }
        -: 6700:
    #####: 6701:  ecma_value_t ret_value = ecma_builtin_json_stringify_no_opts (input_value);
        -: 6702:
    #####: 6703:  if (ecma_is_value_undefined (ret_value))
        -: 6704:  {
    #####: 6705:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON stringify error")));
        -: 6706:  }
        -: 6707:
    #####: 6708:  return jerry_return (ret_value);
        -: 6709:#else /* JERRY_BUILTIN_JSON */
        -: 6710:  JERRY_UNUSED (input_value);
        -: 6711:
        -: 6712:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6713:#endif /* JERRY_BUILTIN_JSON */
        -: 6714:} /* jerry_json_stringify */
        -: 6715:
        -: 6716:/**
        -: 6717: * Create a container type specified in jerry_container_type_t.
        -: 6718: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 6719: * inserted to the container.
        -: 6720: *
        -: 6721: * Note:
        -: 6722: *      The returned value must be freed with jerry_release_value
        -: 6723: * @return jerry_value_t representing a container with the given type.
        -: 6724: */
        -: 6725:jerry_value_t
    #####: 6726:jerry_create_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 6727:                        const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 6728:                        jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 6729:{
        -: 6730:  jerry_assert_api_available ();
        -: 6731:
        -: 6732:#if JERRY_BUILTIN_CONTAINER
    #####: 6733:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 6734:  {
    #####: 6735:    if (ecma_is_value_error_reference (arguments_list_p[i]))
        -: 6736:    {
    #####: 6737:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6738:    }
        -: 6739:  }
        -: 6740:
        -: 6741:  lit_magic_string_id_t lit_id;
        -: 6742:  ecma_builtin_id_t proto_id;
        -: 6743:  ecma_builtin_id_t ctor_id;
        -: 6744:
    #####: 6745:  switch (container_type)
        -: 6746:  {
    #####: 6747:    case JERRY_CONTAINER_TYPE_MAP:
        -: 6748:    {
    #####: 6749:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 6750:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 6751:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 6752:      break;
        -: 6753:    }
    #####: 6754:    case JERRY_CONTAINER_TYPE_SET:
        -: 6755:    {
    #####: 6756:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 6757:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 6758:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 6759:      break;
        -: 6760:    }
    #####: 6761:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 6762:    {
    #####: 6763:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 6764:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 6765:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 6766:      break;
        -: 6767:    }
    #####: 6768:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 6769:    {
    #####: 6770:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 6771:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 6772:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 6773:      break;
        -: 6774:    }
    #####: 6775:    default:
        -: 6776:    {
    #####: 6777:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Invalid container type")));
        -: 6778:    }
        -: 6779:  }
    #####: 6780:  ecma_object_t * old_new_target_p = JERRY_CONTEXT (current_new_target_p);
        -: 6781:
    #####: 6782:  if (old_new_target_p == NULL)
        -: 6783:  {
    #####: 6784:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ctor_id);
        -: 6785:  }
        -: 6786:
    #####: 6787:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p,
        -: 6788:                                                           arguments_list_len,
        -: 6789:                                                           lit_id,
        -: 6790:                                                           proto_id);
        -: 6791:
    #####: 6792:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6793:  return container_value;
        -: 6794:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6795:  JERRY_UNUSED (arguments_list_p);
        -: 6796:  JERRY_UNUSED (arguments_list_len);
        -: 6797:  JERRY_UNUSED (container_type);
    #####: 6798:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 6799:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6800:} /* jerry_create_container */
        -: 6801:
        -: 6802:/**
        -: 6803: * Get the type of the given container object.
        -: 6804: *
        -: 6805: * @return Corresponding type to the given container object.
        -: 6806: */
        -: 6807:jerry_container_type_t
    #####: 6808:jerry_get_container_type (const jerry_value_t value) /**< the container object */
        -: 6809:{
        -: 6810:  jerry_assert_api_available ();
        -: 6811:
        -: 6812:#if JERRY_BUILTIN_CONTAINER
    #####: 6813:  if (ecma_is_value_object (value))
        -: 6814:  {
    #####: 6815:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6816:
    #####: 6817:    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_CONTAINER))
        -: 6818:    {
    #####: 6819:      switch (((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id)
        -: 6820:      {
    #####: 6821:        case LIT_MAGIC_STRING_MAP_UL:
        -: 6822:        {
    #####: 6823:          return JERRY_CONTAINER_TYPE_MAP;
        -: 6824:        }
    #####: 6825:        case LIT_MAGIC_STRING_SET_UL:
        -: 6826:        {
    #####: 6827:          return JERRY_CONTAINER_TYPE_SET;
        -: 6828:        }
    #####: 6829:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 6830:        {
    #####: 6831:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 6832:        }
    #####: 6833:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 6834:        {
    #####: 6835:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 6836:        }
    #####: 6837:        default:
        -: 6838:        {
    #####: 6839:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 6840:        }
        -: 6841:      }
        -: 6842:    }
        -: 6843:  }
        -: 6844:
        -: 6845:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6846:  JERRY_UNUSED (value);
        -: 6847:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 6848:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 6849:} /* jerry_get_container_type */
        -: 6850:
        -: 6851:/**
        -: 6852: * Return a new array containing elements from a Container or a Container Iterator.
        -: 6853: * Sets the boolean input value to `true` if the container object has key/value pairs.
        -: 6854: *
        -: 6855: * Note:
        -: 6856: *     the returned value must be freed with a jerry_release_value call
        -: 6857: *
        -: 6858: * @return an array of items for maps/sets or their iterators, error otherwise
        -: 6859: */
        -: 6860:jerry_value_t
    #####: 6861:jerry_get_array_from_container (jerry_value_t value, /**< the container or iterator object */
        -: 6862:                                bool *is_key_value_p) /**< [out] is key-value structure */
        -: 6863:{
        -: 6864:  jerry_assert_api_available ();
        -: 6865:
        -: 6866:#if JERRY_BUILTIN_CONTAINER
    #####: 6867:  const char *container_needed = ECMA_ERR_MSG ("Value is not a Container or Iterator");
        -: 6868:
    #####: 6869:  if (!ecma_is_value_object (value))
        -: 6870:  {
    #####: 6871:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 6872:  }
        -: 6873:
    #####: 6874:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6875:
    #####: 6876:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 6877:  {
    #####: 6878:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 6879:  }
        -: 6880:
    #####: 6881:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 6882:
        -: 6883:  uint32_t entry_count;
        -: 6884:  uint8_t entry_size;
        -: 6885:
    #####: 6886:  uint32_t index = 0;
    #####: 6887:  uint8_t iterator_kind = ECMA_ITERATOR__COUNT;
        -: 6888:  ecma_value_t *start_p;
        -: 6889:
    #####: 6890:  *is_key_value_p = false;
        -: 6891:
    #####: 6892:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_MAP_ITERATOR
    #####: 6893:      || ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_SET_ITERATOR)
    #####: 6894:  {
    #####: 6895:    ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 6896:
    #####: 6897:    if (ecma_is_value_empty (iterated_value))
        -: 6898:    {
    #####: 6899:      return ecma_op_new_array_object_from_collection (ecma_new_collection (), false);
        -: 6900:    }
        -: 6901:
    #####: 6902:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
        -: 6903:
    #####: 6904:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####: 6905:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6906:    index = ext_obj_p->u.cls.u2.iterator_index;
        -: 6907:
    #####: 6908:    entry_size = ecma_op_container_entry_size (map_object_p->u.cls.u2.container_id);
    #####: 6909:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6910:
    #####: 6911:    iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
        -: 6912:  }
    #####: 6913:  else if (jerry_get_container_type (value) != JERRY_CONTAINER_TYPE_INVALID)
        -: 6914:  {
    #####: 6915:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, ext_obj_p->u.cls.u3.value);
    #####: 6916:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6917:    entry_size = ecma_op_container_entry_size (ext_obj_p->u.cls.u2.container_id);
        -: 6918:
    #####: 6919:    index = 0;
    #####: 6920:    iterator_kind = ECMA_ITERATOR_KEYS;
    #####: 6921:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6922:
    #####: 6923:    if (ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL
    #####: 6924:        || ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 6925:    {
    #####: 6926:      iterator_kind = ECMA_ITERATOR_ENTRIES;
        -: 6927:    }
        -: 6928:  }
        -: 6929:  else
        -: 6930:  {
    #####: 6931:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 6932:  }
        -: 6933:
    #####: 6934:  *is_key_value_p = (iterator_kind == ECMA_ITERATOR_ENTRIES);
    #####: 6935:  ecma_collection_t *collection_buffer = ecma_new_collection ();
        -: 6936:
    #####: 6937:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 6938:  {
    #####: 6939:    ecma_value_t *entry_p = start_p + i;
        -: 6940:
    #####: 6941:    if (ecma_is_value_empty (*entry_p))
        -: 6942:    {
    #####: 6943:      continue;
        -: 6944:    }
        -: 6945:
    #####: 6946:    if (iterator_kind != ECMA_ITERATOR_VALUES)
        -: 6947:    {
    #####: 6948:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[0]));
        -: 6949:    }
        -: 6950:
    #####: 6951:    if (iterator_kind != ECMA_ITERATOR_KEYS)
        -: 6952:    {
    #####: 6953:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[1]));
        -: 6954:    }
        -: 6955:  }
    #####: 6956:  return ecma_op_new_array_object_from_collection (collection_buffer, false);
        -: 6957:#else /* JERRY_BUILTIN_CONTAINER */
        -: 6958:  JERRY_UNUSED (value);
        -: 6959:  JERRY_UNUSED (is_key_value_p);
    #####: 6960:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 6961:#endif
        -: 6962:} /* jerry_get_array_from_container */
        -: 6963:
        -: 6964:/**
        -: 6965: * Perform container operation on the given operands (add, get, set, has, delete, size, clear).
        -: 6966: *
        -: 6967: * @return error - if argument is invalid or operation is unsuccessful or unsupported
        -: 6968: *                 result of the container operation - otherwise.
        -: 6969: */
        -: 6970:jerry_value_t
    #####: 6971:jerry_container_operation (jerry_container_operation_t operation, /**< container operation */
        -: 6972:                           jerry_value_t container, /**< container */
        -: 6973:                           jerry_value_t *arguments, /**< list of arguments */
        -: 6974:                           uint32_t arguments_number) /**< number of arguments */
        -: 6975:{
        -: 6976:  jerry_assert_api_available ();
        -: 6977:#if JERRY_BUILTIN_CONTAINER
    #####: 6978:  if (!ecma_is_value_object (container))
        -: 6979:  {
    #####: 6980:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not an object.")));
        -: 6981:  }
        -: 6982:
    #####: 6983:  ecma_object_t *obj_p = ecma_get_object_from_value (container);
        -: 6984:
    #####: 6985:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 6986:  {
    #####: 6987:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not a container object.")));
        -: 6988:  }
    #####: 6989:  uint16_t type = ((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id;
    #####: 6990:  ecma_extended_object_t *container_object_p = ecma_op_container_get_object (container, type);
        -: 6991:
    #####: 6992:  if (container_object_p == NULL)
        -: 6993:  {
    #####: 6994:    return ecma_create_error_reference_from_context ();
        -: 6995:  }
        -: 6996:
    #####: 6997:  switch (operation)
        -: 6998:  {
    #####: 6999:    case JERRY_CONTAINER_OP_ADD:
        -: 7000:    case JERRY_CONTAINER_OP_DELETE:
        -: 7001:    case JERRY_CONTAINER_OP_GET:
        -: 7002:    case JERRY_CONTAINER_OP_HAS:
        -: 7003:    {
    #####: 7004:      if (arguments_number != 1 || ecma_is_value_error_reference (arguments[0]))
        -: 7005:      {
    #####: 7006:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7007:      }
    #####: 7008:      break;
        -: 7009:    }
    #####: 7010:    case JERRY_CONTAINER_OP_SET:
        -: 7011:    {
    #####: 7012:      if (arguments_number != 2
    #####: 7013:          || ecma_is_value_error_reference (arguments[0])
    #####: 7014:          || ecma_is_value_error_reference (arguments[1]))
        -: 7015:      {
    #####: 7016:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7017:      }
    #####: 7018:      break;
        -: 7019:    }
    #####: 7020:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7021:    case JERRY_CONTAINER_OP_SIZE:
        -: 7022:    {
    #####: 7023:      if (arguments_number != 0)
        -: 7024:      {
    #####: 7025:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7026:      }
    #####: 7027:      break;
        -: 7028:    }
    #####: 7029:    default:
        -: 7030:    {
    #####: 7031:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7032:    }
        -: 7033:  }
        -: 7034:
        -: 7035:  jerry_value_t result;
    #####: 7036:  const char *incorrect_type_call = ECMA_ERR_MSG ("Operator called on incorrect container type");
        -: 7037:
    #####: 7038:  switch (operation)
        -: 7039:  {
    #####: 7040:    case JERRY_CONTAINER_OP_ADD:
        -: 7041:    {
    #####: 7042:      if (type == LIT_MAGIC_STRING_MAP_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7043:      {
    #####: 7044:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7045:      }
    #####: 7046:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[0], type);
    #####: 7047:      break;
        -: 7048:    }
    #####: 7049:    case JERRY_CONTAINER_OP_GET:
        -: 7050:    {
    #####: 7051:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7052:      {
    #####: 7053:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7054:      }
    #####: 7055:      result = ecma_op_container_get (container_object_p, arguments[0], type);
    #####: 7056:      break;
        -: 7057:    }
    #####: 7058:    case JERRY_CONTAINER_OP_SET:
        -: 7059:    {
    #####: 7060:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7061:      {
    #####: 7062:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7063:      }
    #####: 7064:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[1], type);
    #####: 7065:      break;
        -: 7066:    }
    #####: 7067:    case JERRY_CONTAINER_OP_HAS:
        -: 7068:    {
    #####: 7069:      result = ecma_op_container_has (container_object_p, arguments[0], type);
    #####: 7070:      break;
        -: 7071:    }
    #####: 7072:    case JERRY_CONTAINER_OP_DELETE:
        -: 7073:    {
    #####: 7074:      if (type == LIT_MAGIC_STRING_WEAKMAP_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7075:      {
    #####: 7076:        result = ecma_op_container_delete_weak (container_object_p, arguments[0], type);
    #####: 7077:        break;
        -: 7078:      }
    #####: 7079:      result = ecma_op_container_delete (container_object_p, arguments[0], type);
    #####: 7080:      break;
        -: 7081:    }
    #####: 7082:    case JERRY_CONTAINER_OP_SIZE:
        -: 7083:    {
    #####: 7084:      result = ecma_op_container_size (container_object_p);
    #####: 7085:      break;
        -: 7086:    }
    #####: 7087:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7088:    {
    #####: 7089:      if (type == LIT_MAGIC_STRING_WEAKSET_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7090:      {
    #####: 7091:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7092:      }
    #####: 7093:      result = ecma_op_container_clear (container_object_p);
    #####: 7094:      break;
        -: 7095:    }
    #####: 7096:    default:
        -: 7097:    {
    #####: 7098:      result = jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported container operation")));
    #####: 7099:      break;
        -: 7100:    }
        -: 7101:  }
    #####: 7102:  return jerry_return (result);
        -: 7103:#else /* JERRY_BUILTIN_CONTAINER */
        -: 7104:  JERRY_UNUSED (operation);
        -: 7105:  JERRY_UNUSED (container);
        -: 7106:  JERRY_UNUSED (arguments);
        -: 7107:  JERRY_UNUSED (arguments_number);
    #####: 7108:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 7109:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7110:} /* jerry_container_operation */
        -: 7111:
        -: 7112:/**
        -: 7113: * @}
        -: 7114: */
