        -:    0:Source:/home/workspace/tests/unit-core/test-api.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "config.h"
        -:   17:#include "jerryscript.h"
        -:   18:
        -:   19:#include "test-common.h"
        -:   20:
        -:   21:const jerry_char_t test_source[] = TEST_STRING_LITERAL (
        -:   22:  "function assert (arg) { "
        -:   23:  "  if (!arg) { "
        -:   24:  "    throw Error('Assert failed');"
        -:   25:  "  } "
        -:   26:  "} "
        -:   27:  "this.t = 1; "
        -:   28:  "function f () { "
        -:   29:  "return this.t; "
        -:   30:  "} "
        -:   31:  "this.foo = f; "
        -:   32:  "this.bar = function (a) { "
        -:   33:  "return a + t; "
        -:   34:  "}; "
        -:   35:  "function A () { "
        -:   36:  "this.t = 12; "
        -:   37:  "} "
        -:   38:  "this.A = A; "
        -:   39:  "this.a = new A (); "
        -:   40:  "function call_external () { "
        -:   41:  "  return this.external ('1', true); "
        -:   42:  "} "
        -:   43:  "function call_throw_test() { "
        -:   44:  "  var catched = false; "
        -:   45:  "  try { "
        -:   46:  "    this.throw_test(); "
        -:   47:  "  } catch (e) { "
        -:   48:  "    catched = true; "
        -:   49:  "    assert(e.name == 'TypeError'); "
        -:   50:  "    assert(e.message == 'error'); "
        -:   51:  "  } "
        -:   52:  "  assert(catched); "
        -:   53:  "} "
        -:   54:  "function throw_reference_error() { "
        -:   55:  " throw new ReferenceError ();"
        -:   56:  "} "
        -:   57:  "p = {'alpha':32, 'bravo':false, 'charlie':{}, 'delta':123.45, 'echo':'foobar'};"
        -:   58:  "np = {}; Object.defineProperty (np, 'foxtrot', { "
        -:   59:  "get: function() { throw 'error'; }, enumerable: true }) "
        -:   60:);
        -:   61:
        -:   62:bool test_api_is_free_callback_was_called = false;
        -:   63:
        -:   64:static jerry_value_t
    #####:   65:handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   66:         const jerry_value_t args_p[], /**< arguments list */
        -:   67:         const jerry_length_t args_cnt) /**< arguments length */
        -:   68:{
        -:   69:  char buffer[32];
        -:   70:  jerry_size_t sz;
        -:   71:
    #####:   72:  printf ("ok %u %u %p %u\n",
    #####:   73:          (unsigned int) call_info_p->function,
    #####:   74:          (unsigned int) call_info_p->this_value,
        -:   75:          (void *) args_p,
        -:   76:          (unsigned int) args_cnt);
        -:   77:
    #####:   78:  TEST_ASSERT (args_cnt == 2);
        -:   79:
    #####:   80:  TEST_ASSERT (jerry_value_is_string (args_p[0]));
    #####:   81:  sz = jerry_get_string_size (args_p[0]);
    #####:   82:  TEST_ASSERT (sz == 1);
    #####:   83:  sz = jerry_string_to_char_buffer (args_p[0],
        -:   84:                                    (jerry_char_t *) buffer,
        -:   85:                                    sz);
    #####:   86:  TEST_ASSERT (sz == 1);
    #####:   87:  TEST_ASSERT (!strncmp (buffer, "1", (size_t) sz));
        -:   88:
    #####:   89:  TEST_ASSERT (jerry_value_is_boolean (args_p[1]));
        -:   90:
    #####:   91:  return jerry_create_string ((jerry_char_t *) "string from handler");
        -:   92:} /* handler */
        -:   93:
        -:   94:static jerry_value_t
    #####:   95:handler_throw_test (const jerry_call_info_t *call_info_p, /**< call information */
        -:   96:                    const jerry_value_t args_p[], /**< arguments list */
        -:   97:                    const jerry_length_t args_cnt) /**< arguments length */
        -:   98:{
    #####:   99:  printf ("ok %u %u %p %u\n",
    #####:  100:          (unsigned int) call_info_p->function,
    #####:  101:          (unsigned int) call_info_p->this_value,
        -:  102:          (void *) args_p,
        -:  103:          (unsigned int) args_cnt);
        -:  104:
    #####:  105:  return jerry_create_error (JERRY_ERROR_TYPE, (jerry_char_t *) "error");
        -:  106:} /* handler_throw_test */
        -:  107:
        -:  108:static void
    #####:  109:handler_construct_1_freecb (void *native_p, /**< native pointer */
        -:  110:                            jerry_object_native_info_t *info_p) /**< native info */
        -:  111:{
    #####:  112:  TEST_ASSERT ((uintptr_t) native_p == (uintptr_t) 0x0000000000000000ull);
    #####:  113:  TEST_ASSERT (info_p->free_cb == handler_construct_1_freecb);
    #####:  114:  printf ("ok object free callback\n");
        -:  115:
    #####:  116:  test_api_is_free_callback_was_called = true;
    #####:  117:} /* handler_construct_1_freecb */
        -:  118:
        -:  119:static void
    #####:  120:handler_construct_2_freecb (void *native_p, /**< native pointer */
        -:  121:                            jerry_object_native_info_t *info_p) /**< native info */
        -:  122:{
    #####:  123:  TEST_ASSERT ((uintptr_t) native_p == (uintptr_t) 0x0012345678abcdefull);
    #####:  124:  TEST_ASSERT (info_p->free_cb == handler_construct_2_freecb);
    #####:  125:  printf ("ok object free callback\n");
        -:  126:
    #####:  127:  test_api_is_free_callback_was_called = true;
    #####:  128:} /* handler_construct_2_freecb */
        -:  129:
        -:  130:/**
        -:  131: * The name of the jerry_object_native_info_t struct.
        -:  132: */
        -:  133:#define JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE(c_type) _jerry_object_native_info_##c_type
        -:  134:
        -:  135:/**
        -:  136: * Define a native pointer's type based on the C type and free callback.
        -:  137: */
        -:  138:#define JERRY_DEFINE_NATIVE_HANDLE_INFO(c_type, native_free_cb) \
        -:  139:  static const jerry_object_native_info_t JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (c_type) = \
        -:  140:  { \
        -:  141:    .free_cb = (jerry_object_native_free_callback_t) native_free_cb, \
        -:  142:    .number_of_references = 0, \
        -:  143:    .offset_of_references = 0, \
        -:  144:  }
        -:  145:
        -:  146:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind1, handler_construct_1_freecb);
        -:  147:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind2, handler_construct_2_freecb);
        -:  148:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind3, NULL);
        -:  149:
        -:  150:static jerry_value_t
    #####:  151:handler_construct (const jerry_call_info_t *call_info_p, /**< call information */
        -:  152:                   const jerry_value_t args_p[], /**< arguments list */
        -:  153:                   const jerry_length_t args_cnt) /**< arguments length */
        -:  154:{
    #####:  155:  printf ("ok construct %u %u %p %u\n",
    #####:  156:          (unsigned int) call_info_p->function,
    #####:  157:          (unsigned int) call_info_p->this_value,
        -:  158:          (void *) args_p,
        -:  159:          (unsigned int) args_cnt);
        -:  160:
    #####:  161:  TEST_ASSERT (jerry_value_is_object (call_info_p->this_value));
        -:  162:
    #####:  163:  TEST_ASSERT (args_cnt == 1);
    #####:  164:  TEST_ASSERT (jerry_value_is_boolean (args_p[0]));
    #####:  165:  TEST_ASSERT (jerry_value_is_true (args_p[0]));
        -:  166:
    #####:  167:  jerry_value_t this_value = call_info_p->this_value;
    #####:  168:  jerry_value_t field_name = jerry_create_string ((jerry_char_t *) "value_field");
    #####:  169:  jerry_value_t res = jerry_set_property (this_value, field_name, args_p[0]);
    #####:  170:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  171:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  172:  jerry_release_value (res);
    #####:  173:  jerry_release_value (field_name);
        -:  174:
        -:  175:  /* Set a native pointer. */
    #####:  176:  jerry_set_object_native_pointer (this_value,
        -:  177:                                   (void *) 0x0000000000000000ull,
        -:  178:                                   &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1));
        -:  179:
        -:  180:  /* Check that the native pointer was set. */
    #####:  181:  void *ptr = NULL;
    #####:  182:  bool is_ok = jerry_get_object_native_pointer (this_value, &ptr, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1));
    #####:  183:  TEST_ASSERT (is_ok
        -:  184:               && (uintptr_t) ptr == (uintptr_t) 0x0000000000000000ull);
        -:  185:
        -:  186:  /* Set a second native pointer. */
    #####:  187:  jerry_set_object_native_pointer (this_value,
        -:  188:                                   (void *) 0x0012345678abcdefull,
        -:  189:                                   &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2));
        -:  190:
        -:  191:  /* Check that a second native pointer was set. */
    #####:  192:  is_ok = jerry_get_object_native_pointer (this_value, &ptr, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2));
    #####:  193:  TEST_ASSERT (is_ok
        -:  194:               && (uintptr_t) ptr == (uintptr_t) 0x0012345678abcdefull);
        -:  195:
        -:  196:  /* Check that the first native pointer is still set. */
    #####:  197:  is_ok = jerry_get_object_native_pointer (this_value, &ptr, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1));
    #####:  198:  TEST_ASSERT (is_ok
        -:  199:               && (uintptr_t) ptr == (uintptr_t) 0x0000000000000000ull);
    #####:  200:  return jerry_create_boolean (true);
        -:  201:} /* handler_construct */
        -:  202:
        -:  203:/**
        -:  204: * Extended Magic Strings
        -:  205: */
        -:  206:#define JERRY_MAGIC_STRING_ITEMS \
        -:  207:  JERRY_MAGIC_STRING_DEF (GLOBAL, global) \
        -:  208:  JERRY_MAGIC_STRING_DEF (GREEK_ZERO_SIGN, \xed\xa0\x80\xed\xb6\x8a) \
        -:  209:  JERRY_MAGIC_STRING_DEF (CONSOLE, console)
        -:  210:
        -:  211:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) \
        -:  212:  static const char jerry_magic_string_ex_ ## NAME[] = # STRING;
        -:  213:
        -:  214:JERRY_MAGIC_STRING_ITEMS
        -:  215:
        -:  216:#undef JERRY_MAGIC_STRING_DEF
        -:  217:
        -:  218:const jerry_length_t magic_string_lengths[] =
        -:  219:{
        -:  220:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) \
        -:  221:    (jerry_length_t) (sizeof (jerry_magic_string_ex_ ## NAME) - 1u),
        -:  222:
        -:  223:  JERRY_MAGIC_STRING_ITEMS
        -:  224:
        -:  225:#undef JERRY_MAGIC_STRING_DEF
        -:  226:};
        -:  227:
        -:  228:const jerry_char_t *magic_string_items[] =
        -:  229:{
        -:  230:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) \
        -:  231:    (const jerry_char_t *) jerry_magic_string_ex_ ## NAME,
        -:  232:
        -:  233:  JERRY_MAGIC_STRING_ITEMS
        -:  234:
        -:  235:#undef JERRY_MAGIC_STRING_DEF
        -:  236:};
        -:  237:
        -:  238:static bool
    #####:  239:foreach (const jerry_value_t name, /**< field name */
        -:  240:         const jerry_value_t value, /**< field value */
        -:  241:         void *user_data) /**< user data */
        -:  242:{
        -:  243:  char str_buf_p[128];
    #####:  244:  jerry_size_t sz = jerry_string_to_char_buffer (name, (jerry_char_t *) str_buf_p, 128);
    #####:  245:  str_buf_p[sz] = '\0';
        -:  246:
    #####:  247:  TEST_ASSERT (!strncmp ((const char *) user_data, "user_data", 9));
    #####:  248:  TEST_ASSERT (sz > 0);
        -:  249:
    #####:  250:  if (!strncmp (str_buf_p, "alpha", (size_t) sz))
        -:  251:  {
    #####:  252:    TEST_ASSERT (jerry_value_is_number (value));
    #####:  253:    TEST_ASSERT (jerry_get_number_value (value) == 32.0);
        -:  254:    return true;
        -:  255:  }
    #####:  256:  else if (!strncmp (str_buf_p, "bravo", (size_t) sz))
        -:  257:  {
    #####:  258:    TEST_ASSERT (jerry_value_is_boolean (value));
    #####:  259:    TEST_ASSERT (jerry_value_is_true (value) == false);
    #####:  260:    TEST_ASSERT (jerry_value_is_false (value));
        -:  261:    return true;
        -:  262:  }
    #####:  263:  else if (!strncmp (str_buf_p, "charlie", (size_t) sz))
        -:  264:  {
    #####:  265:    TEST_ASSERT (jerry_value_is_object (value));
        -:  266:    return true;
        -:  267:  }
    #####:  268:  else if (!strncmp (str_buf_p, "delta", (size_t) sz))
        -:  269:  {
    #####:  270:    TEST_ASSERT (jerry_value_is_number (value));
    #####:  271:    TEST_ASSERT (jerry_get_number_value (value) == 123.45);
        -:  272:    return true;
        -:  273:  }
    #####:  274:  else if (!strncmp (str_buf_p, "echo", (size_t) sz))
        -:  275:  {
    #####:  276:    TEST_ASSERT (jerry_value_is_string (value));
    #####:  277:    jerry_size_t echo_sz = jerry_string_to_char_buffer (value,
        -:  278:                                                        (jerry_char_t *) str_buf_p,
        -:  279:                                                        128);
    #####:  280:    str_buf_p[echo_sz] = '\0';
    #####:  281:    TEST_ASSERT (!strncmp (str_buf_p, "foobar", (size_t) echo_sz));
        -:  282:    return true;
        -:  283:  }
        -:  284:
    #####:  285:  TEST_ASSERT (false);
        -:  286:  return false;
        -:  287:} /* foreach */
        -:  288:
        -:  289:static bool
    #####:  290:foreach_exception (const jerry_value_t name, /**< field name */
        -:  291:                   const jerry_value_t value, /**< field value */
        -:  292:                   void *user_data) /**< user data */
        -:  293:{
        -:  294:  JERRY_UNUSED (value);
        -:  295:  JERRY_UNUSED (user_data);
        -:  296:  char str_buf_p[128];
    #####:  297:  jerry_size_t sz = jerry_string_to_char_buffer (name, (jerry_char_t *) str_buf_p, 128);
    #####:  298:  str_buf_p[sz] = '\0';
        -:  299:
    #####:  300:  if (!strncmp (str_buf_p, "foxtrot", (size_t) sz))
        -:  301:  {
    #####:  302:    TEST_ASSERT (false);
        -:  303:  }
        -:  304:
    #####:  305:  return true;
        -:  306:} /* foreach_exception */
        -:  307:
        -:  308:static bool
    #####:  309:foreach_subset (const jerry_value_t name, /**< field name */
        -:  310:                const jerry_value_t value, /**< field value */
        -:  311:                void *user_data) /**< user data */
        -:  312:{
        -:  313:  JERRY_UNUSED (name);
        -:  314:  JERRY_UNUSED (value);
    #####:  315:  int *count_p = (int *) (user_data);
        -:  316:
    #####:  317:  if (*count_p == 3)
        -:  318:  {
        -:  319:    return false;
        -:  320:  }
    #####:  321:  (*count_p)++;
    #####:  322:  return true;
        -:  323:} /* foreach_subset */
        -:  324:
        -:  325:static jerry_value_t
    #####:  326:get_property (const jerry_value_t obj_val, /**< object value */
        -:  327:              const char *str_p) /**< property name */
        -:  328:{
    #####:  329:  jerry_value_t prop_name_val = jerry_create_string ((const jerry_char_t *) str_p);
    #####:  330:  jerry_value_t ret_val = jerry_get_property (obj_val, prop_name_val);
    #####:  331:  jerry_release_value (prop_name_val);
    #####:  332:  return ret_val;
        -:  333:} /* get_property */
        -:  334:
        -:  335:static jerry_value_t
    #####:  336:set_property (const jerry_value_t obj_val, /**< object value */
        -:  337:              const char *str_p, /**< property name */
        -:  338:              const jerry_value_t val) /**< value to set */
        -:  339:{
    #####:  340:  jerry_value_t prop_name_val = jerry_create_string ((const jerry_char_t *) str_p);
    #####:  341:  jerry_value_t ret_val = jerry_set_property (obj_val, prop_name_val, val);
    #####:  342:  jerry_release_value (prop_name_val);
    #####:  343:  return ret_val;
        -:  344:} /* set_property */
        -:  345:
        -:  346:static bool
    #####:  347:test_run_simple (const char *script_p) /**< source code to run */
        -:  348:{
    #####:  349:  size_t script_size = strlen (script_p);
        -:  350:
    #####:  351:  return jerry_run_simple ((const jerry_char_t *) script_p, script_size, JERRY_INIT_EMPTY);
        -:  352:} /* test_run_simple */
        -:  353:
        -:  354:static void
    #####:  355:test_syntax_error (const char *script_p, /**< source code to run */
        -:  356:                   const jerry_parse_options_t *options_p, /**< additional parsing options */
        -:  357:                   const char *error_message_p, /**< error message */
        -:  358:                   bool run_script) /**< run script before checking the error message */
        -:  359:{
    #####:  360:  jerry_value_t result_val = jerry_parse ((const jerry_char_t *) script_p,
        -:  361:                                          strlen (script_p),
        -:  362:                                          options_p);
        -:  363:
    #####:  364:  if (run_script)
        -:  365:  {
    #####:  366:    TEST_ASSERT (!jerry_value_is_error (result_val));
    #####:  367:    jerry_value_t script_val = result_val;
        -:  368:
    #####:  369:    result_val = jerry_run (script_val);
    #####:  370:    jerry_release_value (script_val);
        -:  371:  }
        -:  372:
    #####:  373:  TEST_ASSERT (jerry_value_is_error (result_val));
    #####:  374:  result_val = jerry_get_value_from_error (result_val, true);
        -:  375:
    #####:  376:  jerry_value_t err_str_val = jerry_value_to_string (result_val);
    #####:  377:  jerry_size_t err_str_size = jerry_get_string_size (err_str_val);
        -:  378:  jerry_char_t err_str_buf[256];
        -:  379:
    #####:  380:  TEST_ASSERT (err_str_size <= sizeof (err_str_buf));
    #####:  381:  TEST_ASSERT (err_str_size == strlen (error_message_p));
        -:  382:
    #####:  383:  TEST_ASSERT (jerry_string_to_char_buffer (err_str_val, err_str_buf, err_str_size) == err_str_size);
        -:  384:
    #####:  385:  jerry_release_value (err_str_val);
    #####:  386:  jerry_release_value (result_val);
    #####:  387:  TEST_ASSERT (memcmp ((char *) err_str_buf, error_message_p, err_str_size) == 0);
    #####:  388:} /* test_syntax_error */
        -:  389:
        -:  390:int
    #####:  391:main (void)
    #####:  392:{
    #####:  393:  TEST_INIT ();
        -:  394:
        -:  395:  bool is_ok;
        -:  396:  jerry_size_t sz, cesu8_sz;
        -:  397:  jerry_length_t cesu8_length;
        -:  398:  jerry_value_t val_t, val_foo, val_bar, val_A, val_A_prototype, val_a, val_a_foo, val_value_field, val_p, val_np;
        -:  399:  jerry_value_t val_call_external;
        -:  400:  jerry_value_t global_obj_val, obj_val;
        -:  401:  jerry_value_t external_func_val, external_construct_val;
        -:  402:  jerry_value_t throw_test_handler_val;
        -:  403:  jerry_value_t parsed_code_val, proto_val, prim_val;
        -:  404:  jerry_value_t res, args[2];
        -:  405:  double number_val;
        -:  406:  char buffer[32];
        -:  407:
    #####:  408:  is_ok = test_run_simple ("throw 'Hello World';");
    #####:  409:  TEST_ASSERT (!is_ok);
        -:  410:
    #####:  411:  jerry_init (JERRY_INIT_EMPTY);
        -:  412:
    #####:  413:  parsed_code_val = jerry_parse (test_source,
        -:  414:                                 sizeof (test_source) - 1,
        -:  415:                                 NULL);
    #####:  416:  TEST_ASSERT (!jerry_value_is_error (parsed_code_val));
        -:  417:
    #####:  418:  res = jerry_run (parsed_code_val);
    #####:  419:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  420:  jerry_release_value (res);
    #####:  421:  jerry_release_value (parsed_code_val);
        -:  422:
    #####:  423:  global_obj_val = jerry_get_global_object ();
        -:  424:
        -:  425:  /* Get global.boo (non-existing field) */
    #####:  426:  val_t = get_property (global_obj_val, "boo");
    #####:  427:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  428:  TEST_ASSERT (jerry_value_is_undefined (val_t));
        -:  429:
        -:  430:  /* Get global.t */
    #####:  431:  val_t = get_property (global_obj_val, "t");
    #####:  432:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  433:  TEST_ASSERT (jerry_value_is_number (val_t)
        -:  434:               && jerry_get_number_value (val_t) == 1.0);
    #####:  435:  jerry_release_value (val_t);
        -:  436:
        -:  437:  /* Get global.foo */
    #####:  438:  val_foo = get_property (global_obj_val, "foo");
    #####:  439:  TEST_ASSERT (!jerry_value_is_error (val_foo));
    #####:  440:  TEST_ASSERT (jerry_value_is_object (val_foo));
        -:  441:
        -:  442:  /* Call foo (4, 2) */
    #####:  443:  args[0] = jerry_create_number (4);
    #####:  444:  args[1] = jerry_create_number (2);
    #####:  445:  res = jerry_call_function (val_foo, jerry_create_undefined (), args, 2);
    #####:  446:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  447:  TEST_ASSERT (jerry_value_is_number (res)
        -:  448:               && jerry_get_number_value (res) == 1.0);
    #####:  449:  jerry_release_value (res);
        -:  450:
        -:  451:  /* Get global.bar */
    #####:  452:  val_bar = get_property (global_obj_val, "bar");
    #####:  453:  TEST_ASSERT (!jerry_value_is_error (val_bar));
    #####:  454:  TEST_ASSERT (jerry_value_is_object (val_bar));
        -:  455:
        -:  456:  /* Call bar (4, 2) */
    #####:  457:  res = jerry_call_function (val_bar, jerry_create_undefined (), args, 2);
    #####:  458:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  459:  TEST_ASSERT (jerry_value_is_number (res)
        -:  460:               && jerry_get_number_value (res) == 5.0);
    #####:  461:  jerry_release_value (res);
    #####:  462:  jerry_release_value (val_bar);
        -:  463:
        -:  464:  /* Set global.t = "abcd" */
    #####:  465:  jerry_release_value (args[0]);
    #####:  466:  args[0] = jerry_create_string ((jerry_char_t *) "abcd");
    #####:  467:  res = set_property (global_obj_val, "t", args[0]);
    #####:  468:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  469:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  470:  jerry_release_value (res);
        -:  471:
        -:  472:  /* Call foo (4, 2) */
    #####:  473:  res = jerry_call_function (val_foo, jerry_create_undefined (), args, 2);
    #####:  474:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  475:  TEST_ASSERT (jerry_value_is_string (res));
    #####:  476:  sz = jerry_get_string_size (res);
    #####:  477:  TEST_ASSERT (sz == 4);
    #####:  478:  sz = jerry_string_to_char_buffer (res, (jerry_char_t *) buffer, sz);
    #####:  479:  TEST_ASSERT (sz == 4);
    #####:  480:  jerry_release_value (res);
    #####:  481:  TEST_ASSERT (!strncmp (buffer, "abcd", (size_t) sz));
    #####:  482:  jerry_release_value (args[0]);
    #####:  483:  jerry_release_value (args[1]);
        -:  484:
        -:  485:  /* Get global.A */
    #####:  486:  val_A = get_property (global_obj_val, "A");
    #####:  487:  TEST_ASSERT (!jerry_value_is_error (val_A));
    #####:  488:  TEST_ASSERT (jerry_value_is_object (val_A));
        -:  489:
        -:  490:  /* Get A.prototype */
    #####:  491:  is_ok = jerry_value_is_constructor (val_A);
    #####:  492:  TEST_ASSERT (is_ok);
    #####:  493:  val_A_prototype = get_property (val_A, "prototype");
    #####:  494:  TEST_ASSERT (!jerry_value_is_error (val_A_prototype));
    #####:  495:  TEST_ASSERT (jerry_value_is_object (val_A_prototype));
    #####:  496:  jerry_release_value (val_A);
        -:  497:
        -:  498:  /* Set A.prototype.foo = global.foo */
    #####:  499:  res = set_property (val_A_prototype, "foo", val_foo);
    #####:  500:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  501:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  502:  jerry_release_value (res);
    #####:  503:  jerry_release_value (val_A_prototype);
    #####:  504:  jerry_release_value (val_foo);
        -:  505:
        -:  506:  /* Get global.a */
    #####:  507:  val_a = get_property (global_obj_val, "a");
    #####:  508:  TEST_ASSERT (!jerry_value_is_error (val_a));
    #####:  509:  TEST_ASSERT (jerry_value_is_object (val_a));
        -:  510:
        -:  511:  /* Get a.t */
    #####:  512:  res = get_property (val_a, "t");
    #####:  513:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  514:  TEST_ASSERT (jerry_value_is_number (res)
        -:  515:               && jerry_get_number_value (res) == 12.0);
    #####:  516:  jerry_release_value (res);
        -:  517:
        -:  518:  /* foreach properties */
    #####:  519:  val_p = get_property (global_obj_val, "p");
    #####:  520:  is_ok = jerry_foreach_object_property (val_p, foreach, (void *) "user_data");
    #####:  521:  TEST_ASSERT (is_ok);
        -:  522:
        -:  523:  /* break foreach at third element */
    #####:  524:  int count = 0;
    #####:  525:  is_ok = jerry_foreach_object_property (val_p, foreach_subset, &count);
    #####:  526:  TEST_ASSERT (is_ok);
    #####:  527:  TEST_ASSERT (count == 3);
    #####:  528:  jerry_release_value (val_p);
        -:  529:
        -:  530:  /* foreach with throw test */
    #####:  531:  val_np = get_property (global_obj_val, "np");
    #####:  532:  is_ok = !jerry_foreach_object_property (val_np, foreach_exception, NULL);
    #####:  533:  TEST_ASSERT (is_ok);
    #####:  534:  jerry_release_value (val_np);
        -:  535:
        -:  536:  /* Get a.foo */
    #####:  537:  val_a_foo = get_property (val_a, "foo");
    #####:  538:  TEST_ASSERT (!jerry_value_is_error (val_a_foo));
    #####:  539:  TEST_ASSERT (jerry_value_is_object (val_a_foo));
        -:  540:
        -:  541:  /* Call a.foo () */
    #####:  542:  res = jerry_call_function (val_a_foo, val_a, NULL, 0);
    #####:  543:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  544:  TEST_ASSERT (jerry_value_is_number (res)
        -:  545:               && jerry_get_number_value (res) == 12.0);
    #####:  546:  jerry_release_value (res);
    #####:  547:  jerry_release_value (val_a_foo);
        -:  548:
    #####:  549:  jerry_release_value (val_a);
        -:  550:
        -:  551:  /* Create native handler bound function object and set it to 'external' variable */
    #####:  552:  external_func_val = jerry_create_external_function (handler);
    #####:  553:  TEST_ASSERT (jerry_value_is_function (external_func_val)
        -:  554:               && jerry_value_is_constructor (external_func_val));
        -:  555:
    #####:  556:  res = set_property (global_obj_val, "external", external_func_val);
    #####:  557:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  558:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  559:  jerry_release_value (external_func_val);
        -:  560:
        -:  561:  /* Call 'call_external' function that should call external function created above */
    #####:  562:  val_call_external = get_property (global_obj_val, "call_external");
    #####:  563:  TEST_ASSERT (!jerry_value_is_error (val_call_external));
    #####:  564:  TEST_ASSERT (jerry_value_is_object (val_call_external));
    #####:  565:  res = jerry_call_function (val_call_external, global_obj_val, NULL, 0);
    #####:  566:  jerry_release_value (val_call_external);
    #####:  567:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  568:  TEST_ASSERT (jerry_value_is_string (res));
    #####:  569:  sz = jerry_get_string_size (res);
    #####:  570:  TEST_ASSERT (sz == 19);
    #####:  571:  sz = jerry_string_to_char_buffer (res, (jerry_char_t *) buffer, sz);
    #####:  572:  TEST_ASSERT (sz == 19);
    #####:  573:  jerry_release_value (res);
    #####:  574:  TEST_ASSERT (!strncmp (buffer, "string from handler", (size_t) sz));
        -:  575:
        -:  576:  /* Create native handler bound function object and set it to 'external_construct' variable */
    #####:  577:  external_construct_val = jerry_create_external_function (handler_construct);
    #####:  578:  TEST_ASSERT (jerry_value_is_function (external_construct_val)
        -:  579:               && jerry_value_is_constructor (external_construct_val));
        -:  580:
    #####:  581:  res = set_property (global_obj_val, "external_construct", external_construct_val);
    #####:  582:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  583:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  584:  jerry_release_value (res);
        -:  585:
        -:  586:  /* Call external function created above, as constructor */
    #####:  587:  args[0] = jerry_create_boolean (true);
    #####:  588:  res = jerry_construct_object (external_construct_val, args, 1);
    #####:  589:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  590:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  591:  val_value_field = get_property (res, "value_field");
        -:  592:
        -:  593:  /* Get 'value_field' of constructed object */
    #####:  594:  TEST_ASSERT (!jerry_value_is_error (val_value_field));
    #####:  595:  TEST_ASSERT (jerry_value_is_boolean (val_value_field)
        -:  596:               && jerry_value_is_true (val_value_field));
    #####:  597:  jerry_release_value (val_value_field);
    #####:  598:  jerry_release_value (external_construct_val);
        -:  599:
    #####:  600:  void *ptr = NULL;
    #####:  601:  is_ok = jerry_get_object_native_pointer (res, &ptr, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2));
    #####:  602:  TEST_ASSERT (is_ok
        -:  603:               && (uintptr_t) ptr == (uintptr_t) 0x0012345678abcdefull);
        -:  604:
        -:  605:  /* Passing NULL for info_p is allowed. */
    #####:  606:  is_ok = jerry_get_object_native_pointer (res, &ptr, NULL);
    #####:  607:  TEST_ASSERT (!is_ok);
        -:  608:
    #####:  609:  jerry_release_value (res);
        -:  610:
        -:  611:  /* Test: It is ok to set native pointer's free callback as NULL. */
    #####:  612:  jerry_value_t obj_freecb = jerry_create_object ();
    #####:  613:  jerry_set_object_native_pointer (obj_freecb,
        -:  614:                                   (void *) 0x1234,
        -:  615:                                   &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind3));
        -:  616:
    #####:  617:  jerry_release_value (obj_freecb);
        -:  618:
        -:  619:  /* Test: Throwing exception from native handler. */
    #####:  620:  throw_test_handler_val = jerry_create_external_function (handler_throw_test);
    #####:  621:  TEST_ASSERT (jerry_value_is_function (throw_test_handler_val));
        -:  622:
    #####:  623:  res = set_property (global_obj_val, "throw_test", throw_test_handler_val);
    #####:  624:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  625:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  626:  jerry_release_value (res);
    #####:  627:  jerry_release_value (throw_test_handler_val);
        -:  628:
    #####:  629:  val_t = get_property (global_obj_val, "call_throw_test");
    #####:  630:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  631:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  632:
    #####:  633:  res = jerry_call_function (val_t, global_obj_val, NULL, 0);
    #####:  634:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  635:  jerry_release_value (val_t);
    #####:  636:  jerry_release_value (res);
        -:  637:
        -:  638:  /* Test: Unhandled exception in called function */
    #####:  639:  val_t = get_property (global_obj_val, "throw_reference_error");
    #####:  640:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  641:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  642:
    #####:  643:  res = jerry_call_function (val_t, global_obj_val, NULL, 0);
        -:  644:
    #####:  645:  TEST_ASSERT (jerry_value_is_error (res));
    #####:  646:  jerry_release_value (val_t);
        -:  647:
        -:  648:  /* 'res' should contain exception object */
    #####:  649:  res = jerry_get_value_from_error (res, true);
    #####:  650:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  651:  jerry_release_value (res);
        -:  652:
        -:  653:  /* Test: Call of non-function */
    #####:  654:  obj_val = jerry_create_object ();
    #####:  655:  res = jerry_call_function (obj_val, global_obj_val, NULL, 0);
    #####:  656:  TEST_ASSERT (jerry_value_is_error (res));
        -:  657:
        -:  658:  /* 'res' should contain exception object */
    #####:  659:  res = jerry_get_value_from_error (res, true);
    #####:  660:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  661:  jerry_release_value (res);
        -:  662:
    #####:  663:  jerry_release_value (obj_val);
        -:  664:
        -:  665:  /* Test: Unhandled exception in function called, as constructor */
    #####:  666:  val_t = get_property (global_obj_val, "throw_reference_error");
    #####:  667:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  668:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  669:
    #####:  670:  res = jerry_construct_object (val_t, NULL, 0);
    #####:  671:  TEST_ASSERT (jerry_value_is_error (res));
    #####:  672:  jerry_release_value (val_t);
        -:  673:
        -:  674:  /* 'res' should contain exception object */
    #####:  675:  res = jerry_get_value_from_error (res, true);
    #####:  676:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  677:  jerry_release_value (res);
        -:  678:
        -:  679:  /* Test: Call of non-function as constructor */
    #####:  680:  obj_val = jerry_create_object ();
    #####:  681:  res = jerry_construct_object (obj_val, NULL, 0);
    #####:  682:  TEST_ASSERT (jerry_value_is_error (res));
        -:  683:
        -:  684:  /* 'res' should contain exception object */
    #####:  685:  res = jerry_get_value_from_error (res, true);
    #####:  686:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  687:  jerry_release_value (res);
        -:  688:
    #####:  689:  jerry_release_value (obj_val);
        -:  690:
        -:  691:  /* Test: Array Object API */
    #####:  692:  jerry_value_t array_obj_val = jerry_create_array (10);
    #####:  693:  TEST_ASSERT (jerry_value_is_array (array_obj_val));
    #####:  694:  TEST_ASSERT (jerry_get_array_length (array_obj_val) == 10);
        -:  695:
    #####:  696:  jerry_value_t v_in = jerry_create_number (10.5);
    #####:  697:  res = jerry_set_property_by_index (array_obj_val, 5, v_in);
    #####:  698:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  699:  TEST_ASSERT (jerry_value_is_boolean (res) && jerry_value_is_true (res));
    #####:  700:  jerry_release_value (res);
    #####:  701:  jerry_value_t v_out = jerry_get_property_by_index (array_obj_val, 5);
        -:  702:
    #####:  703:  TEST_ASSERT (jerry_value_is_number (v_out)
        -:  704:               && jerry_get_number_value (v_out) == 10.5);
        -:  705:
    #####:  706:  jerry_delete_property_by_index (array_obj_val, 5);
    #####:  707:  jerry_value_t v_und = jerry_get_property_by_index (array_obj_val, 5);
        -:  708:
    #####:  709:  TEST_ASSERT (jerry_value_is_undefined (v_und));
        -:  710:
    #####:  711:  jerry_release_value (v_in);
    #####:  712:  jerry_release_value (v_out);
    #####:  713:  jerry_release_value (v_und);
    #####:  714:  jerry_release_value (array_obj_val);
        -:  715:
        -:  716:  /* Test: object keys */
    #####:  717:  res = jerry_get_object_keys (global_obj_val);
    #####:  718:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  719:  TEST_ASSERT (jerry_value_is_array (res));
    #####:  720:  TEST_ASSERT (jerry_get_array_length (res) == 15);
    #####:  721:  jerry_release_value (res);
        -:  722:
        -:  723:  /* Test: jerry_value_to_primitive */
    #####:  724:  obj_val = jerry_eval ((jerry_char_t *) "new String ('hello')", 20, JERRY_PARSE_NO_OPTS);
    #####:  725:  TEST_ASSERT (!jerry_value_is_error (obj_val));
    #####:  726:  TEST_ASSERT (jerry_value_is_object (obj_val));
    #####:  727:  TEST_ASSERT (!jerry_value_is_string (obj_val));
    #####:  728:  prim_val = jerry_value_to_primitive (obj_val);
    #####:  729:  TEST_ASSERT (!jerry_value_is_error (prim_val));
    #####:  730:  TEST_ASSERT (jerry_value_is_string (prim_val));
    #####:  731:  jerry_release_value (prim_val);
        -:  732:
        -:  733:  /* Test: jerry_get_prototype */
    #####:  734:  proto_val = jerry_get_prototype (jerry_create_undefined ());
    #####:  735:  TEST_ASSERT (jerry_value_is_error (proto_val));
    #####:  736:  jerry_value_t error = jerry_get_value_from_error (proto_val, true);
    #####:  737:  TEST_ASSERT (jerry_get_error_type (error) == JERRY_ERROR_TYPE);
    #####:  738:  jerry_release_value (error);
        -:  739:
    #####:  740:  proto_val = jerry_get_prototype (obj_val);
    #####:  741:  TEST_ASSERT (!jerry_value_is_error (proto_val));
    #####:  742:  TEST_ASSERT (jerry_value_is_object (proto_val));
    #####:  743:  jerry_release_value (proto_val);
    #####:  744:  jerry_release_value (obj_val);
        -:  745:
    #####:  746:  if (jerry_is_feature_enabled (JERRY_FEATURE_PROXY))
        -:  747:  {
    #####:  748:    jerry_value_t target = jerry_create_object ();
    #####:  749:    jerry_value_t handler = jerry_create_object ();
    #####:  750:    jerry_value_t proxy = jerry_create_proxy (target, handler);
    #####:  751:    jerry_value_t obj_proto = jerry_eval ((jerry_char_t *) "Object.prototype", 16, JERRY_PARSE_NO_OPTS);
        -:  752:
    #####:  753:    jerry_release_value (target);
    #####:  754:    jerry_release_value (handler);
    #####:  755:    proto_val = jerry_get_prototype (proxy);
    #####:  756:    TEST_ASSERT (!jerry_value_is_error (proto_val));
    #####:  757:    TEST_ASSERT (proto_val == obj_proto);
    #####:  758:    jerry_release_value (proto_val);
    #####:  759:    jerry_release_value (obj_proto);
    #####:  760:    jerry_release_value (proxy);
        -:  761:  }
        -:  762:
        -:  763:  /* Test: jerry_set_prototype */
    #####:  764:  obj_val = jerry_create_object ();
    #####:  765:  res = jerry_set_prototype (obj_val, jerry_create_null ());
    #####:  766:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  767:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####:  768:  TEST_ASSERT (jerry_value_is_true (res));
        -:  769:
    #####:  770:  jerry_value_t new_proto = jerry_create_object ();
    #####:  771:  res = jerry_set_prototype (obj_val, new_proto);
    #####:  772:  jerry_release_value (new_proto);
    #####:  773:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  774:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####:  775:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  776:  proto_val = jerry_get_prototype (obj_val);
    #####:  777:  TEST_ASSERT (!jerry_value_is_error (proto_val));
    #####:  778:  TEST_ASSERT (jerry_value_is_object (proto_val));
    #####:  779:  jerry_release_value (proto_val);
    #####:  780:  jerry_release_value (obj_val);
        -:  781:
    #####:  782:  if (jerry_is_feature_enabled (JERRY_FEATURE_PROXY))
        -:  783:  {
    #####:  784:    jerry_value_t target = jerry_create_object ();
    #####:  785:    jerry_value_t handler = jerry_create_object ();
    #####:  786:    jerry_value_t proxy = jerry_create_proxy (target, handler);
    #####:  787:    new_proto = jerry_eval ((jerry_char_t *) "Function.prototype", 18, JERRY_PARSE_NO_OPTS);
        -:  788:
    #####:  789:    res = jerry_set_prototype (proxy, new_proto);
    #####:  790:    TEST_ASSERT (!jerry_value_is_error (res));
    #####:  791:    jerry_value_t target_proto = jerry_get_prototype (target);
    #####:  792:    TEST_ASSERT (target_proto == new_proto);
        -:  793:
    #####:  794:    jerry_release_value (target);
    #####:  795:    jerry_release_value (handler);
    #####:  796:    jerry_release_value (proxy);
    #####:  797:    jerry_release_value (new_proto);
    #####:  798:    jerry_release_value (target_proto);
        -:  799:  }
        -:  800:
        -:  801:  /* Test: eval */
    #####:  802:  const jerry_char_t eval_code_src1[] = "(function () { return 123; })";
    #####:  803:  val_t = jerry_eval (eval_code_src1, sizeof (eval_code_src1) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  804:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  805:  TEST_ASSERT (jerry_value_is_object (val_t));
    #####:  806:  TEST_ASSERT (jerry_value_is_function (val_t));
        -:  807:
    #####:  808:  res = jerry_call_function (val_t, jerry_create_undefined (), NULL, 0);
    #####:  809:  TEST_ASSERT (!jerry_value_is_error (res));
    #####:  810:  TEST_ASSERT (jerry_value_is_number (res)
        -:  811:               && jerry_get_number_value (res) == 123.0);
    #####:  812:  jerry_release_value (res);
        -:  813:
    #####:  814:  jerry_release_value (val_t);
        -:  815:
        -:  816:  /* cleanup. */
    #####:  817:  jerry_release_value (global_obj_val);
        -:  818:
        -:  819:  /* Test: run gc. */
    #####:  820:  jerry_gc (JERRY_GC_PRESSURE_LOW);
        -:  821:
        -:  822:  /* Test: spaces */
    #####:  823:  const jerry_char_t eval_code_src2[] = "\x0a \x0b \x0c \xc2\xa0 \xe2\x80\xa8 \xe2\x80\xa9 \xef\xbb\xbf 4321";
    #####:  824:  val_t = jerry_eval (eval_code_src2, sizeof (eval_code_src2) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  825:  TEST_ASSERT (!jerry_value_is_error (val_t));
    #####:  826:  TEST_ASSERT (jerry_value_is_number (val_t)
        -:  827:               && jerry_get_number_value (val_t) == 4321.0);
    #####:  828:  jerry_release_value (val_t);
        -:  829:
        -:  830:  /* Test: number */
    #####:  831:  val_t = jerry_create_number (6.25);
    #####:  832:  number_val = jerry_get_number_value (val_t);
    #####:  833:  TEST_ASSERT (number_val * 3 == 18.75);
    #####:  834:  jerry_release_value (val_t);
        -:  835:
    #####:  836:  val_t = jerry_create_number_infinity (true);
    #####:  837:  number_val = jerry_get_number_value (val_t);
    #####:  838:  TEST_ASSERT (number_val * 3 == number_val && number_val != 0.0);
    #####:  839:  jerry_release_value (val_t);
        -:  840:
    #####:  841:  val_t = jerry_create_number_nan ();
    #####:  842:  number_val = jerry_get_number_value (val_t);
    #####:  843:  TEST_ASSERT (number_val != number_val);
    #####:  844:  jerry_release_value (val_t);
        -:  845:
        -:  846:  /* Test: create function */
    #####:  847:  jerry_value_t script_source = jerry_create_string ((const jerry_char_t *) "  return 5 +  a+\nb+c");
        -:  848:
        -:  849:  jerry_parse_options_t parse_options;
    #####:  850:  parse_options.options = JERRY_PARSE_HAS_ARGUMENT_LIST;
    #####:  851:  parse_options.argument_list = jerry_create_string ((const jerry_char_t *) "a , b,c");
        -:  852:
    #####:  853:  jerry_value_t func_val = jerry_parse_value (script_source, &parse_options);
        -:  854:
    #####:  855:  TEST_ASSERT (!jerry_value_is_error (func_val));
        -:  856:
    #####:  857:  jerry_release_value (parse_options.argument_list);
    #####:  858:  jerry_release_value (script_source);
        -:  859:
    #####:  860:  jerry_value_t func_args[3] =
        -:  861:  {
    #####:  862:    jerry_create_number (4),
    #####:  863:    jerry_create_number (6),
    #####:  864:    jerry_create_number (-2)
        -:  865:  };
        -:  866:
    #####:  867:  val_t = jerry_call_function (func_val, func_args[0], func_args, 3);
    #####:  868:  number_val = jerry_get_number_value (val_t);
    #####:  869:  TEST_ASSERT (number_val == 13.0);
        -:  870:
    #####:  871:  jerry_release_value (val_t);
    #####:  872:  jerry_release_value (func_val);
        -:  873:
    #####:  874:  parse_options.options = JERRY_PARSE_HAS_ARGUMENT_LIST;
    #####:  875:  parse_options.argument_list = jerry_create_null ();
        -:  876:
    #####:  877:  func_val = jerry_parse ((const jerry_char_t *) "", 0, &parse_options);
    #####:  878:  jerry_release_value (parse_options.argument_list);
        -:  879:
    #####:  880:  TEST_ASSERT (jerry_value_is_error (func_val)
        -:  881:               && jerry_get_error_type (func_val) == JERRY_ERROR_TYPE);
    #####:  882:  jerry_release_value (func_val);
        -:  883:
    #####:  884:  script_source = jerry_create_number (4.5);
    #####:  885:  func_val = jerry_parse_value (script_source, NULL);
    #####:  886:  jerry_release_value (script_source);
        -:  887:
    #####:  888:  TEST_ASSERT (jerry_value_is_error (func_val)
        -:  889:               && jerry_get_error_type (func_val) == JERRY_ERROR_TYPE);
    #####:  890:  jerry_release_value (func_val);
        -:  891:
    #####:  892:  jerry_cleanup ();
        -:  893:
    #####:  894:  TEST_ASSERT (test_api_is_free_callback_was_called);
        -:  895:
        -:  896:  /* Test: jerry_get_value_from_error */
        -:  897:  {
    #####:  898:    jerry_init (JERRY_INIT_EMPTY);
    #####:  899:    jerry_value_t num_val = jerry_create_number (123);
    #####:  900:    num_val = jerry_create_error_from_value (num_val, true);
    #####:  901:    TEST_ASSERT (jerry_value_is_error (num_val));
    #####:  902:    jerry_value_t num2_val = jerry_get_value_from_error (num_val, false);
    #####:  903:    TEST_ASSERT (jerry_value_is_error (num_val));
    #####:  904:    TEST_ASSERT (!jerry_value_is_error (num2_val));
    #####:  905:    double num = jerry_get_number_value (num2_val);
    #####:  906:    TEST_ASSERT (num == 123);
    #####:  907:    num2_val = jerry_get_value_from_error (num_val, true);
    #####:  908:    TEST_ASSERT (!jerry_value_is_error (num2_val));
    #####:  909:    num = jerry_get_number_value (num2_val);
    #####:  910:    TEST_ASSERT (num == 123);
    #####:  911:    jerry_release_value (num2_val);
    #####:  912:    jerry_cleanup ();
        -:  913:  }
        -:  914:
        -:  915:  /* Test parsing/executing scripts with lexically scoped global variables multiple times. */
    #####:  916:  if (jerry_is_feature_enabled (JERRY_FEATURE_SYMBOL))
        -:  917:  {
    #####:  918:    jerry_init (JERRY_INIT_EMPTY);
    #####:  919:    const jerry_char_t scoped_src_p[] = "let a; this.b = 5";
    #####:  920:    jerry_value_t parse_result = jerry_parse (scoped_src_p,
        -:  921:                                              sizeof (scoped_src_p) - 1,
        -:  922:                                              NULL);
    #####:  923:    TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  924:    jerry_release_value (parse_result);
        -:  925:
    #####:  926:    parse_result = jerry_parse (scoped_src_p,
        -:  927:                                sizeof (scoped_src_p) - 1,
        -:  928:                                NULL);
    #####:  929:    TEST_ASSERT (!jerry_value_is_error (parse_result));
        -:  930:
    #####:  931:    jerry_value_t run_result = jerry_run (parse_result);
    #####:  932:    TEST_ASSERT (!jerry_value_is_error (run_result));
    #####:  933:    jerry_release_value (run_result);
        -:  934:
        -:  935:    /* Should be a syntax error due to redeclaration. */
    #####:  936:    run_result = jerry_run (parse_result);
    #####:  937:    TEST_ASSERT (jerry_value_is_error (run_result));
    #####:  938:    jerry_release_value (run_result);
    #####:  939:    jerry_release_value (parse_result);
        -:  940:
        -:  941:    /* The variable should have no effect on parsing. */
    #####:  942:    parse_result = jerry_parse (scoped_src_p,
        -:  943:                                sizeof (scoped_src_p) - 1,
        -:  944:                                NULL);
    #####:  945:    TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  946:    jerry_release_value (parse_result);
        -:  947:
        -:  948:    /* The already existing global binding should not affect a new lexical binding */
    #####:  949:    const jerry_char_t scoped_src2_p[] = "let b = 6; this.b + b";
    #####:  950:    parse_result = jerry_parse (scoped_src2_p,
        -:  951:                                sizeof (scoped_src2_p) - 1,
        -:  952:                                NULL);
    #####:  953:    TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  954:    run_result = jerry_run (parse_result);
    #####:  955:    TEST_ASSERT (jerry_value_is_number (run_result));
    #####:  956:    TEST_ASSERT (jerry_get_number_value (run_result) == 11);
    #####:  957:    jerry_release_value (run_result);
    #####:  958:    jerry_release_value (parse_result);
        -:  959:
        -:  960:    /* Check restricted global property */
    #####:  961:    const jerry_char_t scoped_src3_p[] = "let undefined;";
    #####:  962:    parse_result = jerry_parse (scoped_src3_p,
        -:  963:                                sizeof (scoped_src3_p) - 1,
        -:  964:                                NULL);
    #####:  965:    TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  966:    run_result = jerry_run (parse_result);
    #####:  967:    TEST_ASSERT (jerry_value_is_error (run_result));
    #####:  968:    TEST_ASSERT (jerry_get_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####:  969:    jerry_release_value (run_result);
    #####:  970:    jerry_release_value (parse_result);
        -:  971:
    #####:  972:    jerry_value_t global_obj = jerry_get_global_object ();
    #####:  973:    jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "foo");
        -:  974:
    #####:  975:    jerry_property_descriptor_t prop_desc = jerry_property_descriptor_create ();
    #####:  976:    prop_desc.flags |= JERRY_PROP_IS_VALUE_DEFINED;
    #####:  977:    prop_desc.value = jerry_create_number (5.2);
        -:  978:
    #####:  979:    jerry_value_t define_result = jerry_define_own_property (global_obj, prop_name, &prop_desc);
    #####:  980:    TEST_ASSERT (jerry_value_is_boolean (define_result) && jerry_value_is_true (define_result));
    #####:  981:    jerry_release_value (define_result);
        -:  982:
    #####:  983:    jerry_property_descriptor_free (&prop_desc);
    #####:  984:    jerry_release_value (prop_name);
    #####:  985:    jerry_release_value (global_obj);
        -:  986:
    #####:  987:    const jerry_char_t scoped_src4_p[] = "let foo;";
    #####:  988:    parse_result = jerry_parse (scoped_src4_p,
        -:  989:                                sizeof (scoped_src4_p) - 1,
        -:  990:                                NULL);
    #####:  991:    TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  992:    run_result = jerry_run (parse_result);
    #####:  993:    TEST_ASSERT (jerry_value_is_error (run_result));
    #####:  994:    TEST_ASSERT (jerry_get_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####:  995:    jerry_release_value (run_result);
    #####:  996:    jerry_release_value (parse_result);
        -:  997:
    #####:  998:    if (jerry_is_feature_enabled (JERRY_FEATURE_REALM))
        -:  999:    {
    #####: 1000:      const jerry_char_t proxy_src_p[] = "new Proxy({}, { getOwnPropertyDescriptor() { throw 42.1 }})";
    #####: 1001:      jerry_value_t proxy = jerry_eval (proxy_src_p, sizeof (proxy_src_p) - 1, JERRY_PARSE_NO_OPTS);
    #####: 1002:      TEST_ASSERT (jerry_value_is_object (proxy));
    #####: 1003:      jerry_value_t new_realm_value = jerry_create_realm ();
        -: 1004:
    #####: 1005:      jerry_value_t set_realm_this_result = jerry_realm_set_this (new_realm_value, proxy);
    #####: 1006:      TEST_ASSERT (jerry_value_is_boolean (set_realm_this_result) && jerry_value_is_true (set_realm_this_result));
    #####: 1007:      jerry_release_value (set_realm_this_result);
        -: 1008:
    #####: 1009:      jerry_value_t old_realm = jerry_set_realm (new_realm_value);
        -: 1010:
    #####: 1011:      const jerry_char_t scoped_src5_p[] = "let a;";
    #####: 1012:      parse_result = jerry_parse (scoped_src5_p,
        -: 1013:                                  sizeof (scoped_src5_p) - 1,
        -: 1014:                                  NULL);
    #####: 1015:      TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####: 1016:      run_result = jerry_run (parse_result);
    #####: 1017:      TEST_ASSERT (jerry_value_is_error (run_result));
    #####: 1018:      jerry_value_t error_value = jerry_get_value_from_error (run_result, false);
    #####: 1019:      TEST_ASSERT (jerry_value_is_number (error_value) && jerry_get_number_value (error_value) == 42.1);
    #####: 1020:      jerry_release_value (error_value);
    #####: 1021:      jerry_release_value (run_result);
    #####: 1022:      jerry_release_value (parse_result);
        -: 1023:
    #####: 1024:      jerry_set_realm (old_realm);
        -: 1025:
    #####: 1026:      jerry_release_value (new_realm_value);
    #####: 1027:      jerry_release_value (proxy);
        -: 1028:
    #####: 1029:      const jerry_char_t proxy_src2_p[] = "new Proxy(Object.defineProperty({}, 'b', {value: 5.2}), {})";
    #####: 1030:      proxy = jerry_eval (proxy_src2_p, sizeof (proxy_src2_p) - 1, JERRY_PARSE_NO_OPTS);
    #####: 1031:      TEST_ASSERT (jerry_value_is_object (proxy));
    #####: 1032:      new_realm_value = jerry_create_realm ();
        -: 1033:
    #####: 1034:      set_realm_this_result = jerry_realm_set_this (new_realm_value, proxy);
    #####: 1035:      TEST_ASSERT (jerry_value_is_boolean (set_realm_this_result) && jerry_value_is_true (set_realm_this_result));
    #####: 1036:      jerry_release_value (set_realm_this_result);
        -: 1037:
    #####: 1038:      old_realm = jerry_set_realm (new_realm_value);
        -: 1039:
    #####: 1040:      const jerry_char_t scoped_src6_p[] = "let b;";
    #####: 1041:      parse_result = jerry_parse (scoped_src6_p,
        -: 1042:                                  sizeof (scoped_src6_p) - 1,
        -: 1043:                                  NULL);
    #####: 1044:      TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####: 1045:      run_result = jerry_run (parse_result);
    #####: 1046:      TEST_ASSERT (jerry_value_is_error (run_result));
    #####: 1047:      TEST_ASSERT (jerry_value_is_error (run_result));
    #####: 1048:      TEST_ASSERT (jerry_get_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####: 1049:      jerry_release_value (run_result);
    #####: 1050:      jerry_release_value (parse_result);
        -: 1051:
    #####: 1052:      jerry_set_realm (old_realm);
        -: 1053:
    #####: 1054:      jerry_release_value (new_realm_value);
    #####: 1055:      jerry_release_value (proxy);
        -: 1056:    }
        -: 1057:
    #####: 1058:    jerry_cleanup ();
        -: 1059:  }
        -: 1060:
        -: 1061:  /* Test: parser error location */
    #####: 1062:  if (jerry_is_feature_enabled (JERRY_FEATURE_ERROR_MESSAGES))
        -: 1063:  {
    #####: 1064:    jerry_init (JERRY_INIT_SHOW_OPCODES);
        -: 1065:
    #####: 1066:    test_syntax_error ("b = 'hello';\nvar a = (;",
        -: 1067:                       NULL,
        -: 1068:                       "SyntaxError: Unexpected end of input [<anonymous>:2:10]",
        -: 1069:                       false);
        -: 1070:
    #####: 1071:    parse_options.options = JERRY_PARSE_HAS_RESOURCE;
    #####: 1072:    parse_options.resource_name = jerry_create_string ((const jerry_char_t *) "filename.js");
        -: 1073:
    #####: 1074:    test_syntax_error ("b = 'hello';\nvar a = (;",
        -: 1075:                       &parse_options,
        -: 1076:                       "SyntaxError: Unexpected end of input [filename.js:2:10]",
        -: 1077:                       false);
        -: 1078:
    #####: 1079:    test_syntax_error ("eval(\"var b;\\nfor (,); \");",
        -: 1080:                       &parse_options,
        -: 1081:                       "SyntaxError: Unexpected end of input [<eval>:2:6]",
        -: 1082:                       true);
        -: 1083:
    #####: 1084:    parse_options.options |= JERRY_PARSE_HAS_START;
    #####: 1085:    parse_options.start_line = 10;
    #####: 1086:    parse_options.start_column = 20;
        -: 1087:
    #####: 1088:    test_syntax_error ("for (var a in []",
        -: 1089:                       &parse_options,
        -: 1090:                       "SyntaxError: Expected ')' token [filename.js:10:36]",
        -: 1091:                       false);
        -: 1092:
    #####: 1093:    jerry_release_value (parse_options.resource_name);
    #####: 1094:    jerry_cleanup ();
        -: 1095:  }
        -: 1096:
        -: 1097:  /* External Magic String */
    #####: 1098:  jerry_init (JERRY_INIT_SHOW_OPCODES);
        -: 1099:
    #####: 1100:  uint32_t num_magic_string_items = (uint32_t) (sizeof (magic_string_items) / sizeof (jerry_char_t *));
    #####: 1101:  jerry_register_magic_strings (magic_string_items,
        -: 1102:                                num_magic_string_items,
        -: 1103:                                magic_string_lengths);
        -: 1104:
    #####: 1105:  const jerry_char_t ms_code_src[] = "var global = {}; var console = [1]; var process = 1;";
    #####: 1106:  parsed_code_val = jerry_parse (ms_code_src,
        -: 1107:                                 sizeof (ms_code_src) - 1,
        -: 1108:                                 NULL);
    #####: 1109:  TEST_ASSERT (!jerry_value_is_error (parsed_code_val));
        -: 1110:
    #####: 1111:  res = jerry_run (parsed_code_val);
    #####: 1112:  TEST_ASSERT (!jerry_value_is_error (res));
    #####: 1113:  jerry_release_value (res);
    #####: 1114:  jerry_release_value (parsed_code_val);
        -: 1115:
        -: 1116:  /* call jerry_create_string functions which will returns with the registered external magic strings */
    #####: 1117:  args[0] = jerry_create_string ((jerry_char_t *) "console");
    #####: 1118:  args[1] = jerry_create_string ((jerry_char_t *) "\xed\xa0\x80\xed\xb6\x8a"); /**< greek zero sign */
        -: 1119:
    #####: 1120:  cesu8_length = jerry_get_string_length (args[0]);
    #####: 1121:  cesu8_sz = jerry_get_string_size (args[0]);
        -: 1122:
    #####: 1123:  JERRY_VLA (char, string_console, cesu8_sz);
    #####: 1124:  jerry_string_to_char_buffer (args[0], (jerry_char_t *) string_console, cesu8_sz);
        -: 1125:
    #####: 1126:  TEST_ASSERT (!strncmp (string_console, "console", cesu8_sz));
    #####: 1127:  TEST_ASSERT (cesu8_length == 7);
    #####: 1128:  TEST_ASSERT (cesu8_length == cesu8_sz);
        -: 1129:
    #####: 1130:  jerry_release_value (args[0]);
        -: 1131:
    #####: 1132:  const jerry_char_t test_magic_str_access_src[] = "'console'.charAt(6) == 'e'";
    #####: 1133:  res = jerry_eval (test_magic_str_access_src,
        -: 1134:                    sizeof (test_magic_str_access_src) - 1,
        -: 1135:                    JERRY_PARSE_NO_OPTS);
    #####: 1136:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####: 1137:  TEST_ASSERT (jerry_value_is_true (res));
        -: 1138:
    #####: 1139:  jerry_release_value (res);
        -: 1140:
    #####: 1141:  cesu8_length = jerry_get_string_length (args[1]);
    #####: 1142:  cesu8_sz = jerry_get_string_size (args[1]);
        -: 1143:
    #####: 1144:  JERRY_VLA (char, string_greek_zero_sign, cesu8_sz);
    #####: 1145:  jerry_string_to_char_buffer (args[1], (jerry_char_t *) string_greek_zero_sign, cesu8_sz);
        -: 1146:
    #####: 1147:  TEST_ASSERT (!strncmp (string_greek_zero_sign, "\xed\xa0\x80\xed\xb6\x8a", cesu8_sz));
    #####: 1148:  TEST_ASSERT (cesu8_length == 2);
    #####: 1149:  TEST_ASSERT (cesu8_sz == 6);
        -: 1150:
    #####: 1151:  jerry_release_value (args[1]);
        -: 1152:
    #####: 1153:  jerry_cleanup ();
        -: 1154:
        -: 1155:  return 0;
        -: 1156:} /* main */
