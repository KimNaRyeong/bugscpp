        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-ops.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:#include "js-scanner-internal.h"
        -:   18:#include "lit-char-helpers.h"
        -:   19:
        -:   20:#if JERRY_PARSER
        -:   21:
        -:   22:/** \addtogroup parser Parser
        -:   23: * @{
        -:   24: *
        -:   25: * \addtogroup jsparser JavaScript
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser_scanner Scanner
        -:   29: * @{
        -:   30: */
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:
        -:   34:/**
        -:   35: * Add the "async" literal to the literal pool.
        -:   36: */
        -:   37:void
    #####:   38:scanner_add_async_literal (parser_context_t *context_p, /**< context */
        -:   39:                           scanner_context_t *scanner_context_p) /**< scanner context */
        -:   40:{
    #####:   41:  lexer_lit_location_t async_literal;
        -:   42:
    #####:   43:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC);
        -:   44:
    #####:   45:  parser_stack_pop_uint8 (context_p);
    #####:   46:  parser_stack_pop (context_p, &async_literal, sizeof (lexer_lit_location_t));
        -:   47:
    #####:   48:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -:   49:                                                                     scanner_context_p->active_literal_pool_p,
        -:   50:                                                                     &async_literal);
        -:   51:
    #####:   52:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:   53:
    #####:   54:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:   55:  {
    #####:   56:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:   57:  }
    #####:   58:} /* scanner_add_async_literal */
        -:   59:
        -:   60:/**
        -:   61: * Init scanning the body of an arrow function.
        -:   62: */
        -:   63:static void
        1:   64:scanner_check_arrow_body (parser_context_t *context_p, /**< context */
        -:   65:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:   66:{
        1:   67:  lexer_next_token (context_p);
        -:   68:
        1:   69:  scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARROW;
        -:   70:
        1:   71:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -:   72:  {
    #####:   73:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:   74:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_EXPRESSION);
    #####:   75:    return;
        -:   76:  }
        -:   77:
        1:   78:  lexer_next_token (context_p);
        1:   79:  parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_ARROW);
        1:   80:  scanner_check_directives (context_p, scanner_context_p);
        -:   81:} /* scanner_check_arrow_body */
        -:   82:
        -:   83:/**
        -:   84: * Process arrow function with argument list.
        -:   85: */
        -:   86:void
        1:   87:scanner_check_arrow (parser_context_t *context_p, /**< context */
        -:   88:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -:   89:{
        1:   90:  parser_stack_pop_uint8 (context_p);
        -:   91:
        1:   92:  lexer_next_token (context_p);
        -:   93:
        1:   94:  if (context_p->token.type != LEXER_ARROW
        1:   95:      || (context_p->token.flags & LEXER_WAS_NEWLINE))
        -:   96:  {
    #####:   97:    if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:   98:    {
    #####:   99:      scanner_add_async_literal (context_p, scanner_context_p);
        -:  100:    }
        -:  101:
    #####:  102:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  103:    scanner_pop_literal_pool (context_p, scanner_context_p);
    #####:  104:    return;
        -:  105:  }
        -:  106:
        1:  107:  if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  108:  {
    #####:  109:    parser_stack_pop (context_p, NULL, sizeof (lexer_lit_location_t) + 1);
        -:  110:  }
        -:  111:
        1:  112:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        1:  113:  uint16_t status_flags = literal_pool_p->status_flags;
        -:  114:
        1:  115:  bool is_async_arrow = (status_flags & SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW) != 0;
        -:  116:
        1:  117:  status_flags |= SCANNER_LITERAL_POOL_ARROW_FLAGS;
        1:  118:  status_flags &= (uint16_t) ~(SCANNER_LITERAL_POOL_IN_WITH
        -:  119:                               | SCANNER_LITERAL_POOL_GENERATOR
        -:  120:                               | SCANNER_LITERAL_POOL_ASYNC);
        -:  121:
        1:  122:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  123:
        1:  124:  if (is_async_arrow)
        -:  125:  {
    #####:  126:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  127:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  128:  }
        -:  129:
        1:  130:  literal_pool_p->status_flags = status_flags;
        -:  131:
        1:  132:  scanner_filter_arguments (context_p, scanner_context_p);
        1:  133:  scanner_check_arrow_body (context_p, scanner_context_p);
        -:  134:} /* scanner_check_arrow */
        -:  135:
        -:  136:/**
        -:  137: * Process arrow function with a single argument.
        -:  138: */
        -:  139:void
    #####:  140:scanner_scan_simple_arrow (parser_context_t *context_p, /**< context */
        -:  141:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  142:                           const uint8_t *source_p) /**< identifier end position */
        -:  143:{
    #####:  144:  uint16_t status_flags = SCANNER_LITERAL_POOL_ARROW_FLAGS;
        -:  145:
    #####:  146:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  147:
    #####:  148:  if (scanner_context_p->async_source_p != NULL)
        -:  149:  {
    #####:  150:    JERRY_ASSERT (scanner_context_p->async_source_p == source_p);
        -:  151:
    #####:  152:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  153:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  154:  }
        -:  155:
    #####:  156:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
    #####:  157:  literal_pool_p->source_p = source_p;
        -:  158:
    #####:  159:  lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
    #####:  160:  location_p->type |= SCANNER_LITERAL_IS_ARG;
        -:  161:
        -:  162:  /* Skip the => token, which size is two. */
    #####:  163:  context_p->source_p += 2;
    #####:  164:  PARSER_PLUS_EQUAL_LC (context_p->column, 2);
    #####:  165:  context_p->token.flags = (uint8_t) (context_p->token.flags & ~LEXER_NO_SKIP_SPACES);
        -:  166:
    #####:  167:  scanner_check_arrow_body (context_p, scanner_context_p);
    #####:  168:} /* scanner_scan_simple_arrow */
        -:  169:
        -:  170:/**
        -:  171: * Process the next argument of a might-be arrow function.
        -:  172: */
        -:  173:void
    #####:  174:scanner_check_arrow_arg (parser_context_t *context_p, /**< context */
        -:  175:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -:  176:{
    #####:  177:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  178:
    #####:  179:  const uint8_t *source_p = context_p->source_p;
    #####:  180:  bool process_arrow = false;
        -:  181:
    #####:  182:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  183:
    #####:  184:  if (context_p->token.type == LEXER_THREE_DOTS)
        -:  185:  {
    #####:  186:    lexer_next_token (context_p);
        -:  187:  }
        -:  188:
    #####:  189:  switch (context_p->token.type)
        -:  190:  {
    #####:  191:    case LEXER_RIGHT_PAREN:
        -:  192:    {
    #####:  193:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  194:      return;
        -:  195:    }
    #####:  196:    case LEXER_LITERAL:
        -:  197:    {
    #####:  198:      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  199:      {
    #####:  200:        break;
        -:  201:      }
        -:  202:
    #####:  203:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:  204:
    #####:  205:      if (lexer_check_arrow (context_p))
        -:  206:      {
    #####:  207:        process_arrow = true;
    #####:  208:        break;
        -:  209:      }
        -:  210:
    #####:  211:      lexer_lit_location_t *argument_literal_p = scanner_append_argument (context_p, scanner_context_p);
        -:  212:
    #####:  213:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  214:
    #####:  215:      lexer_next_token (context_p);
        -:  216:
    #####:  217:      if (context_p->token.type == LEXER_COMMA || context_p->token.type == LEXER_RIGHT_PAREN)
        -:  218:      {
    #####:  219:        return;
        -:  220:      }
        -:  221:
    #####:  222:      if (context_p->token.type != LEXER_ASSIGN)
        -:  223:      {
    #####:  224:        break;
        -:  225:      }
        -:  226:
    #####:  227:      if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  228:      {
    #####:  229:        JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####:  230:        return;
        -:  231:      }
        -:  232:
    #####:  233:      scanner_binding_literal_t binding_literal;
    #####:  234:      binding_literal.literal_p = argument_literal_p;
        -:  235:
    #####:  236:      parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####:  237:      parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
    #####:  238:      return;
        -:  239:    }
    #####:  240:    case LEXER_LEFT_SQUARE:
        -:  241:    case LEXER_LEFT_BRACE:
        -:  242:    {
    #####:  243:      scanner_append_hole (context_p, scanner_context_p);
    #####:  244:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_ARROW_ARG, false);
        -:  245:
    #####:  246:      if (context_p->token.type == LEXER_LEFT_BRACE)
        -:  247:      {
        -:  248:#if JERRY_ESNEXT
    #####:  249:        parser_stack_push_uint8 (context_p, 0);
        -:  250:#endif /* JERRY_ESNEXT */
    #####:  251:        parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####:  252:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####:  253:        return;
        -:  254:      }
        -:  255:
    #####:  256:      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####:  257:      scanner_context_p->mode = SCAN_MODE_BINDING;
    #####:  258:      lexer_next_token (context_p);
    #####:  259:      return;
        -:  260:    }
        -:  261:  }
        -:  262:
    #####:  263:  scanner_pop_literal_pool (context_p, scanner_context_p);
    #####:  264:  parser_stack_pop_uint8 (context_p);
        -:  265:
    #####:  266:  if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  267:  {
    #####:  268:    scanner_add_async_literal (context_p, scanner_context_p);
        -:  269:  }
        -:  270:
    #####:  271:  parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
        -:  272:
    #####:  273:  if (process_arrow)
        -:  274:  {
    #####:  275:    scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
        -:  276:  }
        -:  277:} /* scanner_check_arrow_arg */
        -:  278:
        -:  279:/**
        -:  280: * Detect async functions.
        -:  281: *
        -:  282: * @return true, if async is followed by a function keyword, false otherwise
        -:  283: */
        -:  284:bool
    #####:  285:scanner_check_async_function (parser_context_t *context_p, /**< context */
        -:  286:                              scanner_context_t *scanner_context_p) /**< scanner context */
        -:  287:{
    #####:  288:  JERRY_ASSERT (lexer_token_is_async (context_p));
    #####:  289:  JERRY_ASSERT (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION
        -:  290:                || scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW);
    #####:  291:  JERRY_ASSERT (scanner_context_p->async_source_p != NULL);
        -:  292:
    #####:  293:  lexer_lit_location_t async_literal = context_p->token.lit_location;
        -:  294:
    #####:  295:  lexer_next_token (context_p);
        -:  296:
    #####:  297:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -:  298:  {
    #####:  299:    if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -:  300:    {
    #####:  301:      return true;
        -:  302:    }
        -:  303:
    #####:  304:    if (context_p->token.type == LEXER_LITERAL
    #####:  305:        && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  306:    {
    #####:  307:      if (!lexer_check_arrow (context_p))
        -:  308:      {
    #####:  309:        scanner_raise_error (context_p);
        -:  310:      }
        -:  311:
    #####:  312:      scanner_scan_simple_arrow (context_p, scanner_context_p, scanner_context_p->async_source_p);
    #####:  313:      scanner_context_p->async_source_p = NULL;
    #####:  314:      return false;
        -:  315:    }
        -:  316:
    #####:  317:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -:  318:    {
    #####:  319:      parser_stack_push (context_p, &async_literal, sizeof (lexer_lit_location_t));
    #####:  320:      parser_stack_push_uint8 (context_p, SCAN_STACK_USE_ASYNC);
    #####:  321:      return false;
        -:  322:    }
        -:  323:  }
        -:  324:
    #####:  325:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -:  326:                                                                     scanner_context_p->active_literal_pool_p,
        -:  327:                                                                     &async_literal);
    #####:  328:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:  329:
    #####:  330:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:  331:  {
    #####:  332:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:  333:  }
        -:  334:
    #####:  335:  scanner_context_p->async_source_p = NULL;
    #####:  336:  scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  337:  return false;
        -:  338:} /* scanner_check_async_function */
        -:  339:
        -:  340:/**
        -:  341: * Check whether the statement of an if/else construct is a function statement.
        -:  342: */
        -:  343:void
    #####:  344:scanner_check_function_after_if (parser_context_t *context_p, /**< context */
        -:  345:                                 scanner_context_t *scanner_context_p) /**< scanner context */
        -:  346:{
    #####:  347:  lexer_next_token (context_p);
    #####:  348:  scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -:  349:
    #####:  350:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_KEYW_FUNCTION))
        -:  351:  {
        -:  352:    scanner_literal_pool_t *literal_pool_p;
    #####:  353:    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        -:  354:
    #####:  355:    literal_pool_p->source_p = context_p->source_p;
    #####:  356:    parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  357:  }
    #####:  358:} /* scanner_check_function_after_if */
        -:  359:
        -:  360:#endif /* JERRY_ESNEXT */
        -:  361:
        -:  362:#if JERRY_MODULE_SYSTEM
        -:  363:
        -:  364:/**
        -:  365: * Check whether the next token is meta.
        -:  366: */
        -:  367:void
    #####:  368:scanner_check_import_meta (parser_context_t *context_p) /**< context */
        -:  369:{
    #####:  370:  lexer_next_token (context_p);
        -:  371:
    #####:  372:  if (context_p->token.type != LEXER_LITERAL
    #####:  373:      || context_p->token.lit_location.type != LEXER_IDENT_LITERAL
    #####:  374:      || context_p->token.keyword_type != LEXER_KEYW_META
    #####:  375:      || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -:  376:  {
    #####:  377:    scanner_raise_error (context_p);
        -:  378:  }
        -:  379:
    #####:  380:  lexer_next_token (context_p);
        -:  381:
    #####:  382:  context_p->global_status_flags |= ECMA_PARSE_INTERNAL_HAS_IMPORT_META;
    #####:  383:} /* scanner_check_import_meta */
        -:  384:
        -:  385:#endif /* JERRY_MODULE_SYSTEM */
        -:  386:
        -:  387:#if JERRY_ESNEXT
        -:  388:
        -:  389:/**
        -:  390: * Arrow types for scanner_scan_bracket() function.
        -:  391: */
        -:  392:typedef enum
        -:  393:{
        -:  394:  SCANNER_SCAN_BRACKET_NO_ARROW, /**< not an arrow function */
        -:  395:  SCANNER_SCAN_BRACKET_SIMPLE_ARROW, /**< simple arrow function */
        -:  396:  SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG, /**< arrow function with one argument */
        -:  397:} scanner_scan_bracket_arrow_type_t;
        -:  398:
        -:  399:#endif /* JERRY_ESNEXT */
        -:  400:
        -:  401:/**
        -:  402: * Scan bracketed expressions.
        -:  403: */
        -:  404:void
        1:  405:scanner_scan_bracket (parser_context_t *context_p, /**< context */
        -:  406:                      scanner_context_t *scanner_context_p) /**< scanner context */
        -:  407:{
        1:  408:  size_t depth = 0;
        -:  409:#if JERRY_ESNEXT
        -:  410:  const uint8_t *arrow_source_p;
        1:  411:  const uint8_t *async_source_p = NULL;
        1:  412:  scanner_scan_bracket_arrow_type_t arrow_type = SCANNER_SCAN_BRACKET_NO_ARROW;
        -:  413:#endif /* JERRY_ESNEXT */
        -:  414:
        1:  415:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_PAREN);
        -:  416:
        -:  417:  do
        -:  418:  {
        -:  419:#if JERRY_ESNEXT
        1:  420:    arrow_source_p = context_p->source_p;
        -:  421:#endif /* JERRY_ESNEXT */
        1:  422:    depth++;
        1:  423:    lexer_next_token (context_p);
        -:  424:  }
        1:  425:  while (context_p->token.type == LEXER_LEFT_PAREN);
        -:  426:
        1:  427:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  428:
        1:  429:  switch (context_p->token.type)
        -:  430:  {
    #####:  431:    case LEXER_LITERAL:
        -:  432:    {
    #####:  433:      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  434:      {
        -:  435:#if JERRY_ESNEXT
    #####:  436:        arrow_source_p = NULL;
        -:  437:#endif /* JERRY_ESNEXT */
    #####:  438:        break;
        -:  439:      }
        -:  440:
        -:  441:#if JERRY_ESNEXT
    #####:  442:      const uint8_t *source_p = context_p->source_p;
        -:  443:
    #####:  444:      if (lexer_check_arrow (context_p))
        -:  445:      {
    #####:  446:        arrow_source_p = source_p;
    #####:  447:        arrow_type = SCANNER_SCAN_BRACKET_SIMPLE_ARROW;
    #####:  448:        break;
        -:  449:      }
        -:  450:
    #####:  451:      size_t total_depth = depth;
        -:  452:#endif /* JERRY_ESNEXT */
        -:  453:
    #####:  454:      while (depth > 0 && lexer_check_next_character (context_p, LIT_CHAR_RIGHT_PAREN))
        -:  455:      {
    #####:  456:        lexer_consume_next_character (context_p);
    #####:  457:        depth--;
        -:  458:      }
        -:  459:
    #####:  460:      if (context_p->token.keyword_type == LEXER_KEYW_EVAL
    #####:  461:          && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  462:      {
        -:  463:#if JERRY_ESNEXT
        -:  464:        /* A function call cannot be an eval function. */
    #####:  465:        arrow_source_p = NULL;
    #####:  466:        const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        -:  467:#else /* !JERRY_ESNEXT */
    #####:  468:        const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  469:#endif /* JERRY_ESNEXT */
        -:  470:
    #####:  471:        scanner_context_p->active_literal_pool_p->status_flags |= flags;
    #####:  472:        break;
        -:  473:      }
        -:  474:
        -:  475:#if JERRY_ESNEXT
    #####:  476:      if (total_depth == depth)
        -:  477:      {
    #####:  478:        if (lexer_check_arrow_param (context_p))
        -:  479:        {
    #####:  480:          JERRY_ASSERT (depth > 0);
    #####:  481:          depth--;
    #####:  482:          break;
        -:  483:        }
        -:  484:
    #####:  485:        if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  486:        {
    #####:  487:          async_source_p = source_p;
        -:  488:        }
        -:  489:      }
    #####:  490:      else if (depth == total_depth - 1)
        -:  491:      {
    #####:  492:        if (lexer_check_arrow (context_p))
        -:  493:        {
    #####:  494:          arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;
    #####:  495:          break;
        -:  496:        }
        -:  497:
    #####:  498:        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  499:        {
    #####:  500:          scanner_add_async_literal (context_p, scanner_context_p);
        -:  501:        }
        -:  502:      }
        -:  503:
    #####:  504:      arrow_source_p = NULL;
        -:  505:#endif /* JERRY_ESNEXT */
    #####:  506:      break;
        -:  507:    }
        -:  508:#if JERRY_ESNEXT
        1:  509:    case LEXER_THREE_DOTS:
        -:  510:    case LEXER_LEFT_SQUARE:
        -:  511:    case LEXER_LEFT_BRACE:
        -:  512:    case LEXER_RIGHT_PAREN:
        -:  513:    {
        1:  514:      JERRY_ASSERT (depth > 0);
        1:  515:      depth--;
        1:  516:      break;
        -:  517:    }
        -:  518:#endif /* JERRY_ESNEXT */
    #####:  519:    default:
        -:  520:    {
        -:  521:#if JERRY_ESNEXT
    #####:  522:      arrow_source_p = NULL;
        -:  523:#endif /* JERRY_ESNEXT */
    #####:  524:      break;
        -:  525:    }
        -:  526:  }
        -:  527:
        -:  528:#if JERRY_ESNEXT
        1:  529:  if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL)
    #####:  530:      && (arrow_source_p == NULL || depth > 0))
        -:  531:  {
    #####:  532:    scanner_context_p->async_source_p = NULL;
        -:  533:  }
        -:  534:#endif /* JERRY_ESNEXT */
        -:  535:
        2:  536:  while (depth > 0)
        -:  537:  {
    #####:  538:    parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
    #####:  539:    depth--;
        -:  540:  }
        -:  541:
        -:  542:#if JERRY_ESNEXT
        1:  543:  if (arrow_source_p != NULL)
        -:  544:  {
        1:  545:    JERRY_ASSERT (async_source_p == NULL);
        -:  546:
        1:  547:    if (arrow_type == SCANNER_SCAN_BRACKET_SIMPLE_ARROW)
        -:  548:    {
    #####:  549:      scanner_scan_simple_arrow (context_p, scanner_context_p, arrow_source_p);
    #####:  550:      return;
        -:  551:    }
        -:  552:
        1:  553:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_ARGUMENTS);
        -:  554:
        1:  555:    uint16_t status_flags = 0;
        -:  556:
        1:  557:    if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL))
        -:  558:    {
    #####:  559:      status_flags |= SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW;
    #####:  560:      arrow_source_p = scanner_context_p->async_source_p;
    #####:  561:      scanner_context_p->async_source_p = NULL;
        -:  562:    }
        -:  563:
        -:  564:    scanner_literal_pool_t *literal_pool_p;
        1:  565:    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        1:  566:    literal_pool_p->source_p = arrow_source_p;
        -:  567:
        1:  568:    if (arrow_type == SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG)
        -:  569:    {
    #####:  570:      scanner_append_argument (context_p, scanner_context_p);
    #####:  571:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  572:
    #####:  573:      context_p->token.type = LEXER_RIGHT_PAREN;
    #####:  574:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  575:    }
        1:  576:    else if (context_p->token.type == LEXER_RIGHT_PAREN)
        -:  577:    {
        1:  578:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  579:    }
        -:  580:    else
        -:  581:    {
    #####:  582:      scanner_check_arrow_arg (context_p, scanner_context_p);
        -:  583:    }
        -:  584:  }
    #####:  585:  else if (JERRY_UNLIKELY (async_source_p != NULL))
        -:  586:  {
    #####:  587:    scanner_context_p->async_source_p = async_source_p;
    #####:  588:    scanner_check_async_function (context_p, scanner_context_p);
        -:  589:  }
        -:  590:#endif /* JERRY_ESNEXT */
    #####:  591:} /* scanner_scan_bracket */
        -:  592:
        -:  593:/**
        -:  594: * Check directives before a source block.
        -:  595: */
        -:  596:void
        6:  597:scanner_check_directives (parser_context_t *context_p, /**< context */
        -:  598:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  599:{
        6:  600:  scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        -:  601:
       12:  602:  while (context_p->token.type == LEXER_LITERAL
        1:  603:         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  604:  {
    #####:  605:    bool is_use_strict = false;
        -:  606:
    #####:  607:    if (lexer_string_is_use_strict (context_p)
    #####:  608:        && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  609:    {
    #####:  610:      is_use_strict = true;
    #####:  611:      context_p->status_flags |= PARSER_IS_STRICT;
        -:  612:    }
        -:  613:
    #####:  614:    lexer_next_token (context_p);
        -:  615:
    #####:  616:    if (!lexer_string_is_directive (context_p))
        -:  617:    {
    #####:  618:      if (is_use_strict)
        -:  619:      {
    #####:  620:        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -:  621:      }
        -:  622:
        -:  623:      /* The string is part of an expression statement. */
    #####:  624:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  625:      break;
        -:  626:    }
        -:  627:
    #####:  628:    if (is_use_strict)
        -:  629:    {
    #####:  630:      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -:  631:    }
        -:  632:
    #####:  633:    if (context_p->token.type == LEXER_SEMICOLON)
        -:  634:    {
    #####:  635:      lexer_next_token (context_p);
        -:  636:    }
        -:  637:  }
        6:  638:} /* scanner_check_directives */
        -:  639:
        -:  640:/**
        -:  641: * @}
        -:  642: * @}
        -:  643: * @}
        -:  644: */
        -:  645:
        -:  646:#endif /* JERRY_PARSER */
