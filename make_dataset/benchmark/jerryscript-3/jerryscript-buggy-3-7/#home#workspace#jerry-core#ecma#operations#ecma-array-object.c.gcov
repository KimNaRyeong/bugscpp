        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-array-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-iterator-object.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-property-hashmap.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-number-arithmetic.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-objects-general.h"
        -:   29:#include "ecma-function-object.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmaarrayobject ECMA Array object related routines
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:#if JERRY_CPOINTER_32_BIT
        -:   39:/**
        -:   40: * Maximum length of the array length to allocate fast mode access for it
        -:   41: * e.g. new Array(5000) is constructed as fast mode access array,
        -:   42: * but new Array(50000000) is consturcted as normal property list based array
        -:   43: */
        -:   44:#define ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH (1 << 17)
        -:   45:#else /* JERRY_CPOINTER_32_BIT */
        -:   46:/**
        -:   47: * Maximum length of the array length to allocate fast mode access for it
        -:   48: * e.g. new Array(5000) is constructed as fast mode access array,
        -:   49: * but new Array(50000000) is consturcted as normal property list based array
        -:   50: */
        -:   51:#define ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH (1 << 13)
        -:   52:#endif /* JERRY_CPOINTER_32_BIT */
        -:   53:
        -:   54:/**
        -:   55: * Property name type flag for array indices.
        -:   56: */
        -:   57:#define ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE \
        -:   58:  (ECMA_DIRECT_STRING_UINT << ECMA_PROPERTY_NAME_TYPE_SHIFT)
        -:   59:
        -:   60:/**
        -:   61: * Allocate a new array object with the given length
        -:   62: *
        -:   63: * @return pointer to the constructed array object
        -:   64: */
        -:   65:static ecma_object_t *
        2:   66:ecma_op_alloc_array_object (uint32_t length) /**< length of the new array */
        -:   67:{
        -:   68:#if JERRY_BUILTIN_ARRAY
        2:   69:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);
        -:   70:#else /* !JERRY_BUILTIN_ARRAY */
        -:   71:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -:   72:#endif /* JERRY_BUILTIN_ARRAY */
        -:   73:
        2:   74:  ecma_object_t *object_p = ecma_create_object (array_prototype_object_p,
        -:   75:                                                sizeof (ecma_extended_object_t),
        -:   76:                                                ECMA_OBJECT_TYPE_ARRAY);
        -:   77:
        -:   78:  /*
        -:   79:   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.
        -:   80:   *
        -:   81:   * See also: ecma_object_get_class_name
        -:   82:   */
        -:   83:
        2:   84:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        2:   85:  ext_obj_p->u.array.length = length;
        2:   86:  ext_obj_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:   87:
        2:   88:  return object_p;
        -:   89:} /* ecma_op_alloc_array_object */
        -:   90:
        -:   91:/**
        -:   92: * Check whether the given object is fast-access mode array
        -:   93: *
        -:   94: * @return true - if the object is fast-access mode array
        -:   95: *         false, otherwise
        -:   96: */
        -:   97:extern inline bool JERRY_ATTR_ALWAYS_INLINE
       88:   98:ecma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */
        -:   99:{
       98:  100:  return (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY &&
        6:  101:          ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p));
        -:  102:} /* ecma_op_object_is_fast_array */
        -:  103:
        -:  104:/**
        -:  105: * Check whether the given array object is fast-access mode array
        -:  106: *
        -:  107: * @return true - if the array object is fast-access mode array
        -:  108: *         false, otherwise
        -:  109: */
        -:  110:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        5:  111:ecma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */
        -:  112:{
       11:  113:  JERRY_ASSERT (ecma_get_object_base_type ((ecma_object_t *) array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:  114:
       11:  115:  return array_p->u.array.length_prop_and_hole_count & ECMA_FAST_ARRAY_FLAG;
        -:  116:} /* ecma_op_array_is_fast_array */
        -:  117:
        -:  118:/**
        -:  119: * Allocate a new array object with the given length
        -:  120: *
        -:  121: * Note: The returned array can be normal of fast access mode
        -:  122: *
        -:  123: * @return pointer to the constructed array object
        -:  124: */
        -:  125:ecma_object_t *
        2:  126:ecma_op_new_array_object (uint32_t length) /**< length of the new array */
        -:  127:{
        2:  128:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
        -:  129:
        2:  130:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
        2:  131:  ecma_value_t *values_p = NULL;
        -:  132:
        2:  133:  if (length > 0)
        -:  134:  {
    #####:  135:    if (length >= ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH)
        -:  136:    {
    #####:  137:      return object_p;
        -:  138:    }
        -:  139:
    #####:  140:    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  141:
    #####:  142:    if (JERRY_UNLIKELY (values_p == NULL))
        -:  143:    {
    #####:  144:      return object_p;
        -:  145:    }
        -:  146:  }
        -:  147:
        2:  148:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        2:  149:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
        2:  150:  ext_obj_p->u.array.length_prop_and_hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  151:
        2:  152:  for (uint32_t i = 0; i < aligned_length; i++)
        -:  153:  {
    #####:  154:    values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  155:  }
        -:  156:
        2:  157:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
        2:  158:  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
        2:  159:  return object_p;
        -:  160:} /* ecma_op_new_array_object */
        -:  161:
        -:  162:/**
        -:  163: * Allocate a new array object from the given length
        -:  164: *
        -:  165: * Note: The returned array can be normal of fast access mode
        -:  166: *
        -:  167: * @return NULL - if the given length is invalid
        -:  168: *         pointer to the constructed array object - otherwise
        -:  169: */
        -:  170:ecma_object_t *
    #####:  171:ecma_op_new_array_object_from_length (ecma_length_t length) /**< length of the new array */
        -:  172:{
        -:  173:#if JERRY_ESNEXT
    #####:  174:  if (length > UINT32_MAX)
        -:  175:  {
    #####:  176:    ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
    #####:  177:    return NULL;
        -:  178:  }
        -:  179:#endif /* JERRY_ESNEXT */
        -:  180:
    #####:  181:  return ecma_op_new_array_object ((uint32_t) length);
        -:  182:} /* ecma_op_new_array_object_from_length */
        -:  183:
        -:  184:/**
        -:  185: * Allocate a new array object from the given buffer
        -:  186: *
        -:  187: * Note: The returned array can be normal of fast access mode
        -:  188: *
        -:  189: * @return ecma_value - constructed array object
        -:  190: */
        -:  191:ecma_value_t
    #####:  192:ecma_op_new_array_object_from_buffer (const ecma_value_t *args_p, /**< array element list */
        -:  193:                                      uint32_t length) /**< number of array elements */
        -:  194:{
    #####:  195:  if (length == 0)
        -:  196:  {
    #####:  197:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  198:  }
        -:  199:
    #####:  200:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
    #####:  201:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
        -:  202:  ecma_value_t *values_p;
    #####:  203:  values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  204:
    #####:  205:  if (values_p != NULL)
        -:  206:  {
    #####:  207:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  208:    ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  209:    JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
        -:  210:
    #####:  211:    for (uint32_t i = 0; i < length; i++)
        -:  212:    {
    #####:  213:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
    #####:  214:      values_p[i] = ecma_copy_value_if_not_object (args_p[i]);
        -:  215:    }
        -:  216:
    #####:  217:    for (uint32_t i = length; i < aligned_length; i++)
        -:  218:    {
    #####:  219:      values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  220:    }
        -:  221:
    #####:  222:    ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
        -:  223:  }
        -:  224:  else
        -:  225:  {
    #####:  226:    for (uint32_t i = 0; i < length; i++)
        -:  227:    {
    #####:  228:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
        -:  229:
    #####:  230:      ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -:  231:      ecma_property_value_t *prop_value_p;
    #####:  232:      prop_value_p = ecma_create_named_data_property (object_p,
        -:  233:                                                      prop_name_p,
        -:  234:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  235:                                                      NULL);
    #####:  236:      ecma_deref_ecma_string (prop_name_p);
    #####:  237:      prop_value_p->value = ecma_copy_value_if_not_object (args_p[i]);
        -:  238:    }
        -:  239:  }
        -:  240:
    #####:  241:  return ecma_make_object_value (object_p);
        -:  242:} /* ecma_op_new_array_object_from_buffer */
        -:  243:
        -:  244:/**
        -:  245: * Allocate a new fast acces mode array object from the given collection
        -:  246: *
        -:  247: * Note: The given collection will be unavailable after and it's underlying buffer is reused
        -:  248: *
        -:  249: * @return ecma_value - constructed fast access mode array object
        -:  250: */
        -:  251:ecma_value_t
    #####:  252:ecma_op_new_array_object_from_collection (ecma_collection_t *collection_p, /**< collection to create array from */
        -:  253:                                          bool unref_objects) /**< true - if the collection potentially
        -:  254:                                                                          containts objects
        -:  255:                                                                   false - otherwise */
        -:  256:{
    #####:  257:  const uint32_t item_count = collection_p->item_count;
        -:  258:
    #####:  259:  if (item_count == 0)
        -:  260:  {
    #####:  261:    ecma_collection_destroy (collection_p);
    #####:  262:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  263:  }
        -:  264:
        -:  265:  ecma_object_t *object_p;
    #####:  266:  ecma_value_t *buffer_p = collection_p->buffer_p;
    #####:  267:  const uint32_t old_size = ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity);
    #####:  268:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (collection_p->item_count);
        -:  269:
    #####:  270:  jmem_heap_free_block (collection_p, sizeof (ecma_collection_t));
    #####:  271:  buffer_p = jmem_heap_realloc_block (buffer_p, old_size, aligned_length * sizeof (ecma_value_t));
    #####:  272:  object_p = ecma_op_alloc_array_object (item_count);
        -:  273:
    #####:  274:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  275:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  276:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
    #####:  277:  JERRY_ASSERT (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE);
    #####:  278:  ECMA_SET_POINTER (object_p->u1.property_list_cp, buffer_p);
        -:  279:
    #####:  280:  if (JERRY_UNLIKELY (unref_objects))
        -:  281:  {
    #####:  282:    for (uint32_t i = 0; i < item_count; i++)
        -:  283:    {
        -:  284:      /* Strong references from the collection are no longer needed
        -:  285:         since GC will mark these object as a fast access mode array properties */
    #####:  286:      ecma_deref_if_object (buffer_p[i]);
        -:  287:    }
        -:  288:  }
        -:  289:
    #####:  290:  for (uint32_t i = item_count; i < aligned_length; i++)
        -:  291:  {
    #####:  292:    buffer_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  293:  }
        -:  294:
    #####:  295:  return ecma_make_object_value (object_p);
        -:  296:} /* ecma_op_new_array_object_from_collection */
        -:  297:
        -:  298:/**
        -:  299: * Converts a fast access mode array back to a normal property list based array
        -:  300: */
        -:  301:void
    #####:  302:ecma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */
        -:  303:{
    #####:  304:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  305:
    #####:  306:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  307:
    #####:  308:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  309:  {
    #####:  310:    ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  311:    return;
        -:  312:  }
        -:  313:
    #####:  314:  uint32_t length = ext_obj_p->u.array.length;
    #####:  315:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
    #####:  316:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  317:
    #####:  318:  ecma_ref_object (object_p);
        -:  319:
    #####:  320:  ecma_property_pair_t *property_pair_p = NULL;
    #####:  321:  jmem_cpointer_t next_property_pair_cp = JMEM_CP_NULL;
        -:  322:
    #####:  323:  uint32_t prop_index = 1;
    #####:  324:  int32_t index = (int32_t) (length - 1);
        -:  325:
    #####:  326:  while (index >= 0)
        -:  327:  {
    #####:  328:    if (ecma_is_value_array_hole (values_p[index]))
        -:  329:    {
    #####:  330:      index--;
    #####:  331:      continue;
        -:  332:    }
        -:  333:
    #####:  334:    if (prop_index == 1)
        -:  335:    {
    #####:  336:      property_pair_p = ecma_alloc_property_pair ();
    #####:  337:      property_pair_p->header.next_property_cp = next_property_pair_cp;
    #####:  338:      property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;
    #####:  339:      property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  340:      ECMA_SET_NON_NULL_POINTER (next_property_pair_cp, property_pair_p);
        -:  341:    }
        -:  342:
    #####:  343:    JERRY_ASSERT (index <= ECMA_DIRECT_STRING_MAX_IMM);
        -:  344:
    #####:  345:    property_pair_p->names_cp[prop_index] = (jmem_cpointer_t) index;
    #####:  346:    property_pair_p->header.types[prop_index] = (ecma_property_t) (ECMA_PROPERTY_FLAG_DATA
        -:  347:                                                                   | ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE
        -:  348:                                                                   | ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE);
        -:  349:
    #####:  350:    property_pair_p->values[prop_index].value = values_p[index];
        -:  351:
    #####:  352:    index--;
    #####:  353:    prop_index = !prop_index;
        -:  354:  }
        -:  355:
    #####:  356:  ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  357:  jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));
    #####:  358:  ECMA_SET_POINTER (object_p->u1.property_list_cp, property_pair_p);
        -:  359:
    #####:  360:  ecma_deref_object (object_p);
        -:  361:} /* ecma_fast_array_convert_to_normal */
        -:  362:
        -:  363:/**
        -:  364: * [[Put]] operation for a fast access mode array
        -:  365: *
        -:  366: * @return false - If the property name is not array index, or the requested index to be set
        -:  367: *                 would result too much array hole in the underlying buffer. The these cases
        -:  368: *                 the array is converted back to normal property list based array.
        -:  369: *         true - If the indexed property can be set with/without resizing the underlying buffer.
        -:  370: */
        -:  371:bool
        1:  372:ecma_fast_array_set_property (ecma_object_t *object_p, /**< fast access mode array object */
        -:  373:                              uint32_t index, /**< property name index */
        -:  374:                              ecma_value_t value) /**< value to be set */
        -:  375:{
        1:  376:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        1:  377:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        1:  378:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  379:
        -:  380:  ecma_value_t *values_p;
        -:  381:
        1:  382:  if (JERRY_LIKELY (index < old_length))
        -:  383:  {
    #####:  384:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  385:
    #####:  386:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  387:
    #####:  388:    if (ecma_is_value_array_hole (values_p[index]))
        -:  389:    {
    #####:  390:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  391:    }
        -:  392:    else
        -:  393:    {
    #####:  394:      ecma_free_value_if_not_object (values_p[index]);
        -:  395:    }
        -:  396:
    #####:  397:    values_p[index] = ecma_copy_value_if_not_object (value);
        -:  398:
    #####:  399:    return true;
        -:  400:  }
        -:  401:
        1:  402:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
        1:  403:  uint32_t new_holes = index - old_length;
        -:  404:
        1:  405:  if (JERRY_UNLIKELY (new_holes > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT
        -:  406:                      || ((old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT) + new_holes) > ECMA_FAST_ARRAY_MAX_HOLE_COUNT))
        -:  407:  {
    #####:  408:    ecma_fast_array_convert_to_normal (object_p);
        -:  409:
    #####:  410:    return false;
        -:  411:  }
        -:  412:
        1:  413:  uint32_t new_length = index + 1;
        -:  414:
        1:  415:  JERRY_ASSERT (new_length < UINT32_MAX);
        -:  416:
        1:  417:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
        -:  418:
        1:  419:  if (JERRY_LIKELY (index < aligned_length))
        -:  420:  {
    #####:  421:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  422:
    #####:  423:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  424:    /* This area is filled with ECMA_VALUE_ARRAY_HOLE, but not counted in u.array.length_prop_and_hole_count */
    #####:  425:    JERRY_ASSERT (ecma_is_value_array_hole (values_p[index]));
    #####:  426:    ext_obj_p->u.array.length_prop_and_hole_count += new_holes * ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  427:    ext_obj_p->u.array.length = new_length;
        -:  428:  }
        -:  429:  else
        -:  430:  {
        1:  431:    values_p = ecma_fast_array_extend (object_p, new_length);
        1:  432:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  433:  }
        -:  434:
        1:  435:  values_p[index] = ecma_copy_value_if_not_object (value);
        -:  436:
        1:  437:  return true;
        -:  438:} /* ecma_fast_array_set_property */
        -:  439:
        -:  440:/**
        -:  441: * Get the number of array holes in a fast access array object
        -:  442: *
        -:  443: * @return number of array holes in a fast access array object
        -:  444: */
        -:  445:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    #####:  446:ecma_fast_array_get_hole_count (ecma_object_t *obj_p) /**< fast access mode array object */
        -:  447:{
    #####:  448:  JERRY_ASSERT (ecma_op_object_is_fast_array (obj_p));
        -:  449:
    #####:  450:  return ((ecma_extended_object_t *) obj_p)->u.array.length_prop_and_hole_count >> ECMA_FAST_ARRAY_HOLE_SHIFT;
        -:  451:} /* ecma_fast_array_get_hole_count */
        -:  452:
        -:  453:/**
        -:  454: * Extend the underlying buffer of a fast mode access array for the given new length
        -:  455: *
        -:  456: * @return pointer to the extended underlying buffer
        -:  457: */
        -:  458:ecma_value_t *
        2:  459:ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */
        -:  460:                        uint32_t new_length) /**< new length of the fast access mode array */
        -:  461:{
        2:  462:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        2:  463:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        2:  464:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  465:
        2:  466:  JERRY_ASSERT (old_length < new_length);
        -:  467:
        2:  468:  ecma_ref_object (object_p);
        -:  469:
        -:  470:  ecma_value_t *new_values_p;
        2:  471:  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
        2:  472:  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  473:
        2:  474:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  475:  {
        2:  476:    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));
        -:  477:  }
        -:  478:  else
        -:  479:  {
    #####:  480:    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
    #####:  481:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  482:                                                             old_length_aligned * sizeof (ecma_value_t),
        -:  483:                                                             new_length_aligned * sizeof (ecma_value_t));
        -:  484:  }
        -:  485:
       18:  486:  for (uint32_t i = old_length; i < new_length_aligned; i++)
        -:  487:  {
       16:  488:    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  489:  }
        -:  490:
        2:  491:  ext_obj_p->u.array.length_prop_and_hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;
        2:  492:  ext_obj_p->u.array.length = new_length;
        -:  493:
        2:  494:  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);
        -:  495:
        2:  496:  ecma_deref_object (object_p);
        2:  497:  return new_values_p;
        -:  498:} /* ecma_fast_array_extend */
        -:  499:
        -:  500:/**
        -:  501: * Delete the array object's property referenced by its value pointer.
        -:  502: *
        -:  503: * Note: specified property must be owned by specified object.
        -:  504: *
        -:  505: * @return true, if the property is deleted
        -:  506: *         false, otherwise
        -:  507: */
        -:  508:bool
    #####:  509:ecma_array_object_delete_property (ecma_object_t *object_p, /**< object */
        -:  510:                                   ecma_string_t *property_name_p) /**< property name */
        -:  511:{
    #####:  512:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
    #####:  513:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  514:
    #####:  515:  if (!ecma_op_object_is_fast_array (object_p))
        -:  516:  {
    #####:  517:    return false;
        -:  518:  }
        -:  519:
    #####:  520:  JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  521:
    #####:  522:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  523:
    #####:  524:  JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
    #####:  525:  JERRY_ASSERT (index < ext_obj_p->u.array.length);
        -:  526:
    #####:  527:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  528:
    #####:  529:  if (ecma_is_value_array_hole (values_p[index]))
        -:  530:  {
    #####:  531:    return true;
        -:  532:  }
        -:  533:
    #####:  534:  ecma_free_value_if_not_object (values_p[index]);
        -:  535:
    #####:  536:  values_p[index] = ECMA_VALUE_ARRAY_HOLE;
    #####:  537:  ext_obj_p->u.array.length_prop_and_hole_count += ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  538:  return true;
        -:  539:} /* ecma_array_object_delete_property */
        -:  540:
        -:  541:/**
        -:  542: * Low level delete of fast access mode array items
        -:  543: *
        -:  544: * @return the updated value of new_length
        -:  545: */
        -:  546:uint32_t
    #####:  547:ecma_delete_fast_array_properties (ecma_object_t *object_p, /**< fast access mode array */
        -:  548:                                   uint32_t new_length) /**< new length of the fast access mode array */
        -:  549:{
    #####:  550:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  551:
    #####:  552:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  553:
    #####:  554:  ecma_ref_object (object_p);
    #####:  555:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  556:
    #####:  557:  uint32_t old_length = ext_obj_p->u.array.length;
    #####:  558:  const uint32_t old_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
    #####:  559:  JERRY_ASSERT (new_length < old_length);
        -:  560:
    #####:  561:  for (uint32_t i = new_length; i < old_length; i++)
        -:  562:  {
    #####:  563:    if (ecma_is_value_array_hole (values_p[i]))
        -:  564:    {
    #####:  565:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  566:    }
        -:  567:    else
        -:  568:    {
    #####:  569:      ecma_free_value_if_not_object (values_p[i]);
        -:  570:    }
        -:  571:  }
        -:  572:
        -:  573:  jmem_cpointer_t new_property_list_cp;
        -:  574:
    #####:  575:  if (new_length == 0)
        -:  576:  {
    #####:  577:    jmem_heap_free_block (values_p, old_aligned_length * sizeof (ecma_value_t));
    #####:  578:    new_property_list_cp = JMEM_CP_NULL;
        -:  579:  }
        -:  580:  else
        -:  581:  {
    #####:  582:    const uint32_t new_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  583:
        -:  584:    ecma_value_t *new_values_p;
    #####:  585:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  586:                                                             old_aligned_length * sizeof (ecma_value_t),
        -:  587:                                                             new_aligned_length * sizeof (ecma_value_t));
        -:  588:
    #####:  589:    for (uint32_t i = new_length; i < new_aligned_length; i++)
        -:  590:    {
    #####:  591:      new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  592:    }
        -:  593:
    #####:  594:    ECMA_SET_NON_NULL_POINTER (new_property_list_cp, new_values_p);
        -:  595:  }
        -:  596:
    #####:  597:  ext_obj_p->u.array.length = new_length;
    #####:  598:  object_p->u1.property_list_cp = new_property_list_cp;
        -:  599:
    #####:  600:  ecma_deref_object (object_p);
        -:  601:
    #####:  602:  return new_length;
        -:  603:} /* ecma_delete_fast_array_properties */
        -:  604:
        -:  605:/**
        -:  606: * Update the length of a fast access mode array to a new length
        -:  607: *
        -:  608: * Note: if the new length would result too much array hole in the underlying arraybuffer
        -:  609: *       the array is converted back to normal property list based array
        -:  610: */
        -:  611:static void
    #####:  612:ecma_fast_array_set_length (ecma_object_t *object_p, /**< fast access mode array object */
        -:  613:                            uint32_t new_length) /**< new length of the fast access mode array object*/
        -:  614:{
    #####:  615:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  616:
    #####:  617:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  618:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  619:
    #####:  620:  JERRY_ASSERT (new_length >= old_length);
        -:  621:
    #####:  622:  if (new_length == old_length)
        -:  623:  {
    #####:  624:    return;
        -:  625:  }
        -:  626:
    #####:  627:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
    #####:  628:  uint32_t new_holes = new_length - old_length;
        -:  629:
    #####:  630:  if (JERRY_UNLIKELY (new_holes > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT
        -:  631:                      || ((old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT) + new_holes) > ECMA_FAST_ARRAY_MAX_HOLE_COUNT))
        -:  632:  {
    #####:  633:    ecma_fast_array_convert_to_normal (object_p);
        -:  634:  }
        -:  635:  else
        -:  636:  {
    #####:  637:    ecma_fast_array_extend (object_p, new_length);
        -:  638:  }
        -:  639:
    #####:  640:  return;
        -:  641:} /* ecma_fast_array_set_length */
        -:  642:
        -:  643:/**
        -:  644: * Get collection of property names of a fast access mode array object
        -:  645: *
        -:  646: * Note: Since the fast array object only contains indexed, enumerable, writable, configurable properties
        -:  647: *       we can return a collection of non-array hole array indices
        -:  648: *
        -:  649: * @return collection of strings - property names
        -:  650: */
        -:  651:ecma_collection_t *
    #####:  652:ecma_fast_array_object_own_property_keys (ecma_object_t *object_p, /**< fast access mode array object */
        -:  653:                                          jerry_property_filter_t filter) /**< property name filter options */
        -:  654:{
    #####:  655:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  656:
    #####:  657:  ecma_collection_t *ret_p = ecma_new_collection ();
        -:  658:
    #####:  659:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -:  660:  {
    #####:  661:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  662:    uint32_t length = ext_obj_p->u.array.length;
        -:  663:
    #####:  664:    if (length != 0)
        -:  665:    {
    #####:  666:      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  667:
    #####:  668:      for (uint32_t i = 0; i < length; i++)
        -:  669:      {
    #####:  670:        if (ecma_is_value_array_hole (values_p[i]))
        -:  671:        {
    #####:  672:          continue;
        -:  673:        }
        -:  674:
    #####:  675:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);
        -:  676:
    #####:  677:        ecma_collection_push_back (ret_p, ecma_make_string_value (index_str_p));
        -:  678:      }
        -:  679:    }
        -:  680:  }
        -:  681:
    #####:  682:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -:  683:  {
    #####:  684:    ecma_collection_push_back (ret_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
        -:  685:  }
        -:  686:
    #####:  687:  return ret_p;
        -:  688:} /* ecma_fast_array_object_own_property_keys */
        -:  689:
        -:  690:#if JERRY_ESNEXT
        -:  691:/**
        -:  692: * Array object creation with custom prototype.
        -:  693: *
        -:  694: * See also: ECMA-262 v6, 9.4.2.3
        -:  695: *
        -:  696: * @return ecma value
        -:  697: *         Returned value must be freed with ecma_free_value
        -:  698: */
        -:  699:ecma_object_t *
    #####:  700:ecma_op_array_species_create (ecma_object_t *original_array_p, /**< The object from whom the new array object
        -:  701:                                                                *   is being created */
        -:  702:                              ecma_length_t length) /**< length of the array */
        -:  703:{
    #####:  704:  ecma_value_t constructor = ECMA_VALUE_UNDEFINED;
    #####:  705:  ecma_value_t original_array = ecma_make_object_value (original_array_p);
        -:  706:
    #####:  707:  ecma_value_t is_array = ecma_is_value_array (original_array);
        -:  708:
    #####:  709:  if (ECMA_IS_VALUE_ERROR (is_array))
        -:  710:  {
    #####:  711:    return NULL;
        -:  712:  }
        -:  713:
    #####:  714:  if (ecma_is_value_true (is_array))
        -:  715:  {
    #####:  716:    constructor = ecma_op_object_get_by_magic_id (original_array_p, LIT_MAGIC_STRING_CONSTRUCTOR);
    #####:  717:    if (ECMA_IS_VALUE_ERROR (constructor))
        -:  718:    {
    #####:  719:      return NULL;
        -:  720:    }
        -:  721:
        -:  722:#if JERRY_BUILTIN_REALMS
    #####:  723:    if (ecma_is_constructor (constructor))
        -:  724:    {
    #####:  725:      ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);
    #####:  726:      ecma_global_object_t *global_object_p = ecma_op_function_get_function_realm (constructor_p);
        -:  727:
    #####:  728:      if ((ecma_object_t *) global_object_p != ecma_builtin_get_global ()
    #####:  729:          && constructor_p == ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_ARRAY))
        -:  730:      {
    #####:  731:        ecma_deref_object (constructor_p);
    #####:  732:        constructor = ECMA_VALUE_UNDEFINED;
        -:  733:      }
        -:  734:    }
        -:  735:#endif /* JERRY_BUILTIN_REALMS */
        -:  736:
    #####:  737:    if (ecma_is_value_object (constructor))
        -:  738:    {
    #####:  739:      ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####:  740:      constructor = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
    #####:  741:      ecma_deref_object (ctor_object_p);
        -:  742:
    #####:  743:      if (ECMA_IS_VALUE_ERROR (constructor))
        -:  744:      {
    #####:  745:        return NULL;
        -:  746:      }
        -:  747:
    #####:  748:      if (ecma_is_value_null (constructor))
        -:  749:      {
    #####:  750:        constructor = ECMA_VALUE_UNDEFINED;
        -:  751:      }
        -:  752:    }
        -:  753:  }
        -:  754:
    #####:  755:  if (ecma_is_value_undefined (constructor))
        -:  756:  {
    #####:  757:    return ecma_op_new_array_object_from_length (length);
        -:  758:  }
        -:  759:
    #####:  760:  if (!ecma_is_constructor (constructor))
        -:  761:  {
    #####:  762:    ecma_free_value (constructor);
    #####:  763:    ecma_raise_type_error (ECMA_ERR_MSG ("Invalid species constructor"));
    #####:  764:    return NULL;
        -:  765:  }
        -:  766:
    #####:  767:  ecma_value_t len_val = ecma_make_length_value (length);
    #####:  768:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####:  769:  ecma_value_t ret_val = ecma_op_function_construct (ctor_object_p,
        -:  770:                                                     ctor_object_p,
        -:  771:                                                     &len_val,
        -:  772:                                                     1);
        -:  773:
    #####:  774:  ecma_deref_object (ctor_object_p);
    #####:  775:  ecma_free_value (len_val);
        -:  776:
    #####:  777:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  778:  {
    #####:  779:    return NULL;
        -:  780:  }
        -:  781:
    #####:  782:  return ecma_get_object_from_value (ret_val);
        -:  783:} /* ecma_op_array_species_create */
        -:  784:
        -:  785:/**
        -:  786: * CreateArrayIterator Abstract Operation
        -:  787: *
        -:  788: * See also:
        -:  789: *          ECMA-262 v6, 22.1.5.1
        -:  790: *
        -:  791: * Referenced by:
        -:  792: *          ECMA-262 v6, 22.1.3.4
        -:  793: *          ECMA-262 v6, 22.1.3.13
        -:  794: *          ECMA-262 v6, 22.1.3.29
        -:  795: *          ECMA-262 v6, 22.1.3.30
        -:  796: *
        -:  797: * Note:
        -:  798: *      Returned value must be freed with ecma_free_value.
        -:  799: *
        -:  800: * @return array iterator object
        -:  801: */
        -:  802:ecma_value_t
    #####:  803:ecma_op_create_array_iterator (ecma_object_t *obj_p, /**< array object */
        -:  804:                               ecma_iterator_kind_t kind) /**< array iterator kind */
        -:  805:{
    #####:  806:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -:  807:
    #####:  808:  return ecma_op_create_iterator_object (ecma_make_object_value (obj_p),
        -:  809:                                         prototype_obj_p,
        -:  810:                                         ECMA_OBJECT_CLASS_ARRAY_ITERATOR,
        -:  811:                                         kind);
        -:  812:} /* ecma_op_create_array_iterator */
        -:  813:#endif /* JERRY_ESNEXT */
        -:  814:
        -:  815:/**
        -:  816: * Low level delete of array items from new_length to old_length
        -:  817: *
        -:  818: * Note: new_length must be less than old_length
        -:  819: *
        -:  820: * @return the updated value of new_length
        -:  821: */
        -:  822:static uint32_t
    #####:  823:ecma_delete_array_properties (ecma_object_t *object_p, /**< object */
        -:  824:                              uint32_t new_length, /**< new length */
        -:  825:                              uint32_t old_length) /**< old length */
        -:  826:{
    #####:  827:  JERRY_ASSERT (new_length < old_length);
    #####:  828:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:  829:
    #####:  830:  if (ecma_op_object_is_fast_array (object_p))
        -:  831:  {
    #####:  832:    return ecma_delete_fast_array_properties (object_p, new_length);
        -:  833:  }
        -:  834:
        -:  835:  /* First the minimum value of new_length is updated. */
    #####:  836:  jmem_cpointer_t current_prop_cp = object_p->u1.property_list_cp;
        -:  837:
    #####:  838:  if (current_prop_cp == JMEM_CP_NULL)
        -:  839:  {
    #####:  840:    return new_length;
        -:  841:  }
        -:  842:
        -:  843:  ecma_property_header_t *current_prop_p;
        -:  844:
        -:  845:#if JERRY_PROPERTY_HASHMAP
    #####:  846:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  847:
    #####:  848:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  849:  {
    #####:  850:    current_prop_cp = current_prop_p->next_property_cp;
        -:  851:  }
        -:  852:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  853:
    #####:  854:  while (current_prop_cp != JMEM_CP_NULL)
        -:  855:  {
    #####:  856:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
    #####:  857:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
        -:  858:
    #####:  859:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  860:
    #####:  861:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  862:    {
    #####:  863:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  864:          && !ecma_is_property_configurable (current_prop_p->types[i]))
        -:  865:      {
    #####:  866:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i],
    #####:  867:                                                         prop_pair_p->names_cp[i]);
        -:  868:
    #####:  869:        if (index < old_length && index >= new_length)
        -:  870:        {
    #####:  871:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  872:
    #####:  873:          new_length = index + 1;
        -:  874:
    #####:  875:          if (new_length == old_length)
        -:  876:          {
        -:  877:            /* Early return. */
    #####:  878:            return new_length;
        -:  879:          }
        -:  880:        }
        -:  881:      }
        -:  882:    }
        -:  883:
    #####:  884:    current_prop_cp = current_prop_p->next_property_cp;
        -:  885:  }
        -:  886:
        -:  887:  /* Second all properties between new_length and old_length are deleted. */
    #####:  888:  current_prop_cp = object_p->u1.property_list_cp;
    #####:  889:  ecma_property_header_t *prev_prop_p = NULL;
        -:  890:
        -:  891:#if JERRY_PROPERTY_HASHMAP
    #####:  892:  JERRY_ASSERT (current_prop_cp != JMEM_CP_NULL);
        -:  893:
    #####:  894:  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;
    #####:  895:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  896:
    #####:  897:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  898:  {
    #####:  899:    prev_prop_p = current_prop_p;
    #####:  900:    current_prop_cp = current_prop_p->next_property_cp;
    #####:  901:    hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  902:  }
        -:  903:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  904:
    #####:  905:  while (current_prop_cp != JMEM_CP_NULL)
        -:  906:  {
    #####:  907:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  908:
    #####:  909:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
    #####:  910:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  911:
    #####:  912:    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  913:    {
    #####:  914:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  915:          && ecma_is_property_configurable (current_prop_p->types[i]))
        -:  916:      {
    #####:  917:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i],
    #####:  918:                                                         prop_pair_p->names_cp[i]);
        -:  919:
    #####:  920:        if (index < old_length && index >= new_length)
        -:  921:        {
    #####:  922:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  923:
        -:  924:#if JERRY_PROPERTY_HASHMAP
    #####:  925:          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)
        -:  926:          {
    #####:  927:            hashmap_status = ecma_property_hashmap_delete (object_p,
    #####:  928:                                                           prop_pair_p->names_cp[i],
    #####:  929:                                                           current_prop_p->types + i);
        -:  930:          }
        -:  931:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  932:
    #####:  933:          ecma_gc_free_property (object_p, prop_pair_p, i);
    #####:  934:          current_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  935:          prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  936:        }
        -:  937:      }
        -:  938:    }
        -:  939:
    #####:  940:    if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_DELETED
    #####:  941:        && current_prop_p->types[1] == ECMA_PROPERTY_TYPE_DELETED)
    #####:  942:    {
    #####:  943:      if (prev_prop_p == NULL)
        -:  944:      {
    #####:  945:        object_p->u1.property_list_cp = current_prop_p->next_property_cp;
        -:  946:      }
        -:  947:      else
        -:  948:      {
    #####:  949:        prev_prop_p->next_property_cp = current_prop_p->next_property_cp;
        -:  950:      }
        -:  951:
    #####:  952:      jmem_cpointer_t next_prop_cp = current_prop_p->next_property_cp;
    #####:  953:      ecma_dealloc_property_pair ((ecma_property_pair_t *) current_prop_p);
    #####:  954:      current_prop_cp = next_prop_cp;
        -:  955:    }
        -:  956:    else
        -:  957:    {
    #####:  958:      prev_prop_p = current_prop_p;
    #####:  959:      current_prop_cp = current_prop_p->next_property_cp;
        -:  960:    }
        -:  961:  }
        -:  962:
        -:  963:#if JERRY_PROPERTY_HASHMAP
    #####:  964:  if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  965:  {
    #####:  966:    ecma_property_hashmap_free (object_p);
    #####:  967:    ecma_property_hashmap_create (object_p);
        -:  968:  }
        -:  969:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  970:
    #####:  971:  return new_length;
        -:  972:} /* ecma_delete_array_properties */
        -:  973:
        -:  974:/**
        -:  975: * Update the length of an array to a new length
        -:  976: *
        -:  977: * @return ecma value
        -:  978: *         Returned value must be freed with ecma_free_value
        -:  979: */
        -:  980:ecma_value_t
    #####:  981:ecma_op_array_object_set_length (ecma_object_t *object_p, /**< the array object */
        -:  982:                                 ecma_value_t new_value, /**< new length value */
        -:  983:                                 uint16_t flags) /**< property descriptor flags */
        -:  984:{
    #####:  985:  ecma_number_t new_len_num;
    #####:  986:  ecma_value_t completion = ecma_op_to_number (new_value, &new_len_num);
        -:  987:
    #####:  988:  if (ECMA_IS_VALUE_ERROR (completion))
        -:  989:  {
    #####:  990:    return completion;
        -:  991:  }
        -:  992:
    #####:  993:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion));
        -:  994:
    #####:  995:  if (ecma_is_value_object (new_value))
        -:  996:  {
    #####:  997:    ecma_value_t compared_num_val = ecma_op_to_number (new_value, &new_len_num);
        -:  998:
    #####:  999:    if (ECMA_IS_VALUE_ERROR (compared_num_val))
        -: 1000:    {
    #####: 1001:      return compared_num_val;
        -: 1002:    }
        -: 1003:  }
        -: 1004:
    #####: 1005:  uint32_t new_len_uint32 = ecma_number_to_uint32 (new_len_num);
        -: 1006:
    #####: 1007:  if (((ecma_number_t) new_len_uint32) != new_len_num)
        -: 1008:  {
    #####: 1009:    return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -: 1010:  }
        -: 1011:
        -: 1012:  /* Only the writable and data properties can be modified. */
    #####: 1013:  if (flags & (JERRY_PROP_IS_CONFIGURABLE
        -: 1014:               | JERRY_PROP_IS_ENUMERABLE
        -: 1015:               | JERRY_PROP_IS_GET_DEFINED
        -: 1016:               | JERRY_PROP_IS_SET_DEFINED))
        -: 1017:  {
    #####: 1018:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1019:  }
        -: 1020:
    #####: 1021:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1022:
    #####: 1023:  uint32_t old_len_uint32 = ext_object_p->u.array.length;
        -: 1024:
    #####: 1025:  if (new_len_num == old_len_uint32)
        -: 1026:  {
        -: 1027:    /* Only the writable flag must be updated. */
    #####: 1028:    if (flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 1029:    {
    #####: 1030:      if (!(flags & JERRY_PROP_IS_WRITABLE))
        -: 1031:      {
    #####: 1032:        if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1033:        {
    #####: 1034:          ecma_fast_array_convert_to_normal (object_p);
        -: 1035:        }
        -: 1036:
    #####: 1037:        ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1038:      }
    #####: 1039:      else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1040:      {
    #####: 1041:        return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1042:      }
        -: 1043:    }
    #####: 1044:    return ECMA_VALUE_TRUE;
        -: 1045:  }
    #####: 1046:  else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1047:  {
    #####: 1048:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1049:  }
        -: 1050:
    #####: 1051:  uint32_t current_len_uint32 = new_len_uint32;
        -: 1052:
    #####: 1053:  if (new_len_uint32 < old_len_uint32)
        -: 1054:  {
    #####: 1055:    current_len_uint32 = ecma_delete_array_properties (object_p, new_len_uint32, old_len_uint32);
        -: 1056:  }
    #####: 1057:  else if (ecma_op_object_is_fast_array (object_p))
        -: 1058:  {
    #####: 1059:    ecma_fast_array_set_length (object_p, new_len_uint32);
        -: 1060:  }
        -: 1061:
    #####: 1062:  ext_object_p->u.array.length = current_len_uint32;
        -: 1063:
    #####: 1064:  if ((flags & JERRY_PROP_IS_WRITABLE_DEFINED)
    #####: 1065:      && !(flags & JERRY_PROP_IS_WRITABLE))
        -: 1066:  {
    #####: 1067:    if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1068:    {
    #####: 1069:      ecma_fast_array_convert_to_normal (object_p);
        -: 1070:    }
        -: 1071:
    #####: 1072:    ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1073:  }
        -: 1074:
    #####: 1075:  if (current_len_uint32 == new_len_uint32)
        -: 1076:  {
    #####: 1077:    return ECMA_VALUE_TRUE;
        -: 1078:  }
        -: 1079:
    #####: 1080:  return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1081:} /* ecma_op_array_object_set_length */
        -: 1082:
        -: 1083:/**
        -: 1084: * Property descriptor bitset for fast array data properties.
        -: 1085: * If the property desciptor fields contains all the flags below
        -: 1086: * attempt to stay fast access array during [[DefineOwnProperty]] operation.
        -: 1087: */
        -: 1088:#define ECMA_FAST_ARRAY_DATA_PROP_FLAGS (JERRY_PROP_IS_VALUE_DEFINED \
        -: 1089:                                         | JERRY_PROP_IS_ENUMERABLE_DEFINED \
        -: 1090:                                         | JERRY_PROP_IS_ENUMERABLE \
        -: 1091:                                         | JERRY_PROP_IS_CONFIGURABLE_DEFINED \
        -: 1092:                                         | JERRY_PROP_IS_CONFIGURABLE \
        -: 1093:                                         | JERRY_PROP_IS_WRITABLE_DEFINED \
        -: 1094:                                         | JERRY_PROP_IS_WRITABLE)
        -: 1095:
        -: 1096:/**
        -: 1097: * [[DefineOwnProperty]] ecma array object's operation
        -: 1098: *
        -: 1099: * See also:
        -: 1100: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1101: *          ECMA-262 v5, 15.4.5.1
        -: 1102: *
        -: 1103: * @return ecma value
        -: 1104: *         Returned value must be freed with ecma_free_value
        -: 1105: */
        -: 1106:ecma_value_t
        1: 1107:ecma_op_array_object_define_own_property (ecma_object_t *object_p, /**< the array object */
        -: 1108:                                          ecma_string_t *property_name_p, /**< property name */
        -: 1109:                                          const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1110:{
        1: 1111:  if (ecma_string_is_length (property_name_p))
        -: 1112:  {
    #####: 1113:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 1114:                  || !(property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));
    #####: 1115:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 1116:                  || !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));
    #####: 1117:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 1118:                  || !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE));
        -: 1119:
    #####: 1120:    if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1121:    {
    #####: 1122:      return ecma_op_array_object_set_length (object_p, property_desc_p->value, property_desc_p->flags);
        -: 1123:    }
        -: 1124:
    #####: 1125:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 1126:    ecma_value_t length_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -: 1127:
    #####: 1128:    ecma_value_t result = ecma_op_array_object_set_length (object_p, length_value, property_desc_p->flags);
        -: 1129:
    #####: 1130:    ecma_fast_free_value (length_value);
    #####: 1131:    return result;
        -: 1132:  }
        -: 1133:
        1: 1134:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1135:
        1: 1136:  if (ecma_op_object_is_fast_array (object_p))
        -: 1137:  {
        1: 1138:    if ((property_desc_p->flags & ECMA_FAST_ARRAY_DATA_PROP_FLAGS) == ECMA_FAST_ARRAY_DATA_PROP_FLAGS)
        -: 1139:    {
        1: 1140:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1141:
        1: 1142:      if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1143:      {
    #####: 1144:        ecma_fast_array_convert_to_normal (object_p);
        -: 1145:      }
        1: 1146:      else if (ecma_fast_array_set_property (object_p, index, property_desc_p->value))
        -: 1147:      {
        1: 1148:        return ECMA_VALUE_TRUE;
        -: 1149:      }
        -: 1150:
    #####: 1151:      JERRY_ASSERT (!ecma_op_array_is_fast_array (ext_object_p));
        -: 1152:    }
        -: 1153:    else
        -: 1154:    {
    #####: 1155:      ecma_fast_array_convert_to_normal (object_p);
        -: 1156:    }
        -: 1157:  }
        -: 1158:
    #####: 1159:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
    #####: 1160:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1161:
    #####: 1162:  if (index == ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1163:  {
    #####: 1164:    return ecma_op_general_object_define_own_property (object_p, property_name_p, property_desc_p);
        -: 1165:  }
        -: 1166:
    #####: 1167:  bool update_length = (index >= ext_object_p->u.array.length);
        -: 1168:
    #####: 1169:  if (update_length
    #####: 1170:      && !ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1171:  {
    #####: 1172:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1173:  }
        -: 1174:
    #####: 1175:  ecma_property_descriptor_t prop_desc;
        -: 1176:
    #####: 1177:  prop_desc = *property_desc_p;
    #####: 1178:  prop_desc.flags &= (uint16_t) ~JERRY_PROP_SHOULD_THROW;
        -: 1179:
    #####: 1180:  ecma_value_t completition = ecma_op_general_object_define_own_property (object_p,
        -: 1181:                                                                          property_name_p,
        -: 1182:                                                                          &prop_desc);
    #####: 1183:  JERRY_ASSERT (ecma_is_value_boolean (completition));
        -: 1184:
    #####: 1185:  if (ecma_is_value_false (completition))
        -: 1186:  {
    #####: 1187:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1188:  }
        -: 1189:
    #####: 1190:  if (update_length)
        -: 1191:  {
    #####: 1192:    ext_object_p->u.array.length = index + 1;
        -: 1193:  }
        -: 1194:
    #####: 1195:  return ECMA_VALUE_TRUE;
        -: 1196:} /* ecma_op_array_object_define_own_property */
        -: 1197:
        -: 1198:/**
        -: 1199: * Get the length of the an array object
        -: 1200: *
        -: 1201: * @return the array length
        -: 1202: */
        -: 1203:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1204:ecma_array_get_length (ecma_object_t *array_p) /**< array object */
        -: 1205:{
    #####: 1206:  JERRY_ASSERT (ecma_get_object_base_type (array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1207:
    #####: 1208:  return ((ecma_extended_object_t *) array_p)->u.array.length;
        -: 1209:} /* ecma_array_get_length */
        -: 1210:
        -: 1211:/**
        -: 1212: * The Array.prototype and %TypedArray%.prototype objects' 'toString' routine.
        -: 1213: *
        -: 1214: * See also:
        -: 1215: *          ECMA-262 v5, 15.4.4.2
        -: 1216: *          ECMA-262 v6, 22.1.3.7
        -: 1217: *
        -: 1218: * @return ecma value
        -: 1219: *         Returned value must be freed with ecma_free_value.
        -: 1220: */
        -: 1221:ecma_value_t
    #####: 1222:ecma_array_object_to_string (ecma_value_t this_arg) /**< this argument */
        -: 1223:{
    #####: 1224:  JERRY_ASSERT (ecma_is_value_object (this_arg));
        -: 1225:
    #####: 1226:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1227:
    #####: 1228:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
        -: 1229:
        -: 1230:  /* 2. */
    #####: 1231:  ecma_value_t join_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_JOIN);
    #####: 1232:  if (ECMA_IS_VALUE_ERROR (join_value))
        -: 1233:  {
    #####: 1234:    return join_value;
        -: 1235:  }
        -: 1236:
    #####: 1237:  if (!ecma_op_is_callable (join_value))
        -: 1238:  {
        -: 1239:    /* 3. */
    #####: 1240:    ret_value = ecma_builtin_helper_object_to_string (this_arg);
        -: 1241:  }
        -: 1242:  else
        -: 1243:  {
        -: 1244:    /* 4. */
    #####: 1245:    ecma_object_t *join_func_obj_p = ecma_get_object_from_value (join_value);
        -: 1246:
    #####: 1247:    ret_value = ecma_op_function_call (join_func_obj_p, this_arg, NULL, 0);
        -: 1248:  }
        -: 1249:
    #####: 1250:  ecma_free_value (join_value);
        -: 1251:
    #####: 1252:  return ret_value;
        -: 1253:} /* ecma_array_object_to_string */
        -: 1254:
        -: 1255:/**
        -: 1256: * @}
        -: 1257: * @}
        -: 1258: */
