        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-mem.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:
        -:   20:/** \addtogroup mem Memory allocation
        -:   21: * @{
        -:   22: *
        -:   23: * \addtogroup mem_parser Parser memory manager
        -:   24: * @{
        -:   25: */
        -:   26:
        -:   27:/**********************************************************************/
        -:   28:/* Memory allocation                                                  */
        -:   29:/**********************************************************************/
        -:   30:
        -:   31:/**
        -:   32: * Allocate memory.
        -:   33: *
        -:   34: * @return allocated memory.
        -:   35: */
        -:   36:void *
       33:   37:parser_malloc (parser_context_t *context_p, /**< context */
        -:   38:               size_t size) /**< size of the memory block */
        -:   39:{
        -:   40:  void *result;
        -:   41:
       33:   42:  JERRY_ASSERT (size > 0);
       33:   43:  result = jmem_heap_alloc_block_null_on_error (size);
        -:   44:
       33:   45:  if (result == NULL)
        -:   46:  {
    #####:   47:    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);
        -:   48:  }
       33:   49:  return result;
        -:   50:} /* parser_malloc */
        -:   51:
        -:   52:/**
        -:   53: * Free memory allocated by parser_malloc.
        -:   54: */
        -:   55:extern inline void JERRY_ATTR_ALWAYS_INLINE
        6:   56:parser_free (void *ptr, /**< pointer to free */
        -:   57:             size_t size) /**< size of the memory block */
        -:   58:{
       26:   59:  jmem_heap_free_block (ptr, size);
        6:   60:} /* parser_free */
        -:   61:
        -:   62:/**
        -:   63: * Allocate local memory for short term use.
        -:   64: *
        -:   65: * @return allocated memory.
        -:   66: */
        -:   67:void *
    #####:   68:parser_malloc_local (parser_context_t *context_p, /**< context */
        -:   69:                     size_t size) /**< size of the memory */
        -:   70:{
        -:   71:  void *result;
        -:   72:
    #####:   73:  JERRY_ASSERT (size > 0);
    #####:   74:  result = jmem_heap_alloc_block (size);
    #####:   75:  if (result == 0)
        -:   76:  {
    #####:   77:    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);
        -:   78:  }
    #####:   79:  return result;
        -:   80:} /* parser_malloc_local */
        -:   81:
        -:   82:/**
        -:   83: * Free memory allocated by parser_malloc_local.
        -:   84: */
        -:   85:void
    #####:   86:parser_free_local (void *ptr, /**< pointer to free */
        -:   87:                   size_t size) /**< size of the memory */
        -:   88:{
    #####:   89:  jmem_heap_free_block (ptr, size);
    #####:   90:} /* parser_free_local */
        -:   91:
        -:   92:/**
        -:   93: * Free the dynamically allocated buffer stored in the context
        -:   94: */
        -:   95:extern inline void JERRY_ATTR_ALWAYS_INLINE
       10:   96:parser_free_allocated_buffer (parser_context_t *context_p) /**< context */
        -:   97:{
       10:   98:  if (context_p->u.allocated_buffer_p != NULL)
        -:   99:  {
    #####:  100:    parser_free_local (context_p->u.allocated_buffer_p,
    #####:  101:                       context_p->allocated_buffer_size);
    #####:  102:    context_p->u.allocated_buffer_p = NULL;
        -:  103:  }
       10:  104:} /* parser_free_allocated_buffer */
        -:  105:
        -:  106:/**********************************************************************/
        -:  107:/* Parser data management functions                                   */
        -:  108:/**********************************************************************/
        -:  109:
        -:  110:/**
        -:  111: * Initialize parse data.
        -:  112: */
        -:  113:static void
       20:  114:parser_data_init (parser_mem_data_t *data_p, /**< memory manager */
        -:  115:                  uint32_t page_size) /**< size of each page */
        -:  116:{
       20:  117:  data_p->first_p = NULL;
       20:  118:  data_p->last_p = NULL;
       20:  119:  data_p->last_position = page_size;
       20:  120:} /* parser_data_init */
        -:  121:
        -:  122:/**
        -:  123: * Free parse data.
        -:  124: */
        -:  125:static void
       20:  126:parser_data_free (parser_mem_data_t *data_p, /**< memory manager */
        -:  127:                  uint32_t page_size) /**< size of each page */
        -:  128:{
       20:  129:  parser_mem_page_t *page_p = data_p->first_p;
        -:  130:
       60:  131:  while (page_p != NULL)
        -:  132:  {
       20:  133:    parser_mem_page_t *next_p = page_p->next_p;
        -:  134:
       20:  135:    parser_free (page_p, page_size);
       20:  136:    page_p = next_p;
        -:  137:  }
       20:  138:} /* parser_data_free */
        -:  139:
        -:  140:/**********************************************************************/
        -:  141:/* Parser byte stream management functions                            */
        -:  142:/**********************************************************************/
        -:  143:
        -:  144:/**
        -:  145: * Initialize byte stream.
        -:  146: */
        -:  147:void
        6:  148:parser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */
        -:  149:{
        6:  150:  parser_data_init (data_p, PARSER_CBC_STREAM_PAGE_SIZE);
        6:  151:} /* parser_cbc_stream_init */
        -:  152:
        -:  153:/**
        -:  154: * Free byte stream.
        -:  155: */
        -:  156:void
        6:  157:parser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */
        -:  158:{
        6:  159:  parser_data_free (data_p,
        -:  160:                    sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE);
        6:  161:} /* parser_cbc_stream_free */
        -:  162:
        -:  163:/**
        -:  164: * Appends a byte at the end of the byte stream.
        -:  165: */
        -:  166:void
        6:  167:parser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */
        -:  168:                              parser_mem_data_t *data_p) /**< memory manager */
        -:  169:{
        6:  170:  size_t size = sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE;
        6:  171:  parser_mem_page_t *page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  172:
        6:  173:  page_p->next_p = NULL;
        6:  174:  data_p->last_position = 0;
        -:  175:
        6:  176:  if (data_p->last_p != NULL)
        -:  177:  {
        1:  178:    data_p->last_p->next_p = page_p;
        -:  179:  }
        -:  180:  else
        -:  181:  {
        5:  182:    data_p->first_p = page_p;
        -:  183:  }
        6:  184:  data_p->last_p = page_p;
        6:  185:} /* parser_cbc_stream_alloc_page */
        -:  186:
        -:  187:/**********************************************************************/
        -:  188:/* Parser list management functions                                   */
        -:  189:/**********************************************************************/
        -:  190:
        -:  191:/**
        -:  192: * Initialize parser list.
        -:  193: */
        -:  194:void
        7:  195:parser_list_init (parser_list_t *list_p, /**< parser list */
        -:  196:                  uint32_t item_size, /**< size for each page */
        -:  197:                  uint32_t item_count) /**< number of items on each page */
        -:  198:{
        -:  199:  /* Align to pointer size. */
        7:  200:  item_size = (uint32_t) (((item_size) + sizeof (void *) - 1) & ~(sizeof (void *) - 1));
        7:  201:  parser_data_init (&list_p->data, item_size * item_count);
        7:  202:  list_p->page_size = item_size * item_count;
        7:  203:  list_p->item_size = item_size;
        7:  204:  list_p->item_count = item_count;
        7:  205:} /* parser_list_init */
        -:  206:
        -:  207:/**
        -:  208: * Free parser list.
        -:  209: */
        -:  210:void
       12:  211:parser_list_free (parser_list_t *list_p) /**< parser list */
        -:  212:{
       12:  213:  parser_data_free (&list_p->data,
       12:  214:                    (uint32_t) (sizeof (parser_mem_page_t *) + list_p->page_size));
       12:  215:} /* parser_list_free */
        -:  216:
        -:  217:/**
        -:  218: * Reset parser list.
        -:  219: */
        -:  220:void
        5:  221:parser_list_reset (parser_list_t *list_p) /**< parser list */
        -:  222:{
        5:  223:  parser_data_init (&list_p->data, list_p->page_size);
        5:  224:} /* parser_list_reset */
        -:  225:
        -:  226:/**
        -:  227: * Allocate space for the next item.
        -:  228: *
        -:  229: * @return pointer to the appended item.
        -:  230: */
        -:  231:void *
       37:  232:parser_list_append (parser_context_t *context_p, /**< context */
        -:  233:                    parser_list_t *list_p) /**< parser list */
        -:  234:{
       37:  235:  parser_mem_page_t *page_p = list_p->data.last_p;
        -:  236:  void *result;
        -:  237:
       37:  238:  if (list_p->data.last_position + list_p->item_size > list_p->page_size)
        -:  239:  {
       12:  240:    size_t size = sizeof (parser_mem_page_t *) + list_p->page_size;
        -:  241:
       12:  242:    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  243:
       12:  244:    page_p->next_p = NULL;
       12:  245:    list_p->data.last_position = 0;
        -:  246:
       12:  247:    if (list_p->data.last_p != NULL)
        -:  248:    {
        2:  249:      list_p->data.last_p->next_p = page_p;
        -:  250:    }
        -:  251:    else
        -:  252:    {
       10:  253:      list_p->data.first_p = page_p;
        -:  254:    }
       12:  255:    list_p->data.last_p = page_p;
        -:  256:  }
        -:  257:
       37:  258:  result = page_p->bytes + list_p->data.last_position;
       37:  259:  list_p->data.last_position += list_p->item_size;
       37:  260:  return result;
        -:  261:} /* parser_list_append */
        -:  262:
        -:  263:/**
        -:  264: * Return the nth item of the list.
        -:  265: *
        -:  266: * @return pointer to the item.
        -:  267: */
        -:  268:void *
       35:  269:parser_list_get (parser_list_t *list_p, /**< parser list */
        -:  270:                 size_t index) /**< item index */
        -:  271:{
       35:  272:  size_t item_count = list_p->item_count;
       35:  273:  parser_mem_page_t *page_p = list_p->data.first_p;
        -:  274:
       87:  275:  while (index >= item_count)
        -:  276:  {
       17:  277:    JERRY_ASSERT (page_p != NULL);
       17:  278:    page_p = page_p->next_p;
       17:  279:    index -= item_count;
        -:  280:  }
        -:  281:
       35:  282:  JERRY_ASSERT (page_p != NULL);
       35:  283:  JERRY_ASSERT (page_p != list_p->data.last_p
        -:  284:                || (index * list_p->item_size < list_p->data.last_position));
       35:  285:  return page_p->bytes + (index * list_p->item_size);
        -:  286:} /* parser_list_get */
        -:  287:
        -:  288:/**
        -:  289: * Initialize a parser list iterator.
        -:  290: */
        -:  291:void
       85:  292:parser_list_iterator_init (parser_list_t *list_p, /**< parser list */
        -:  293:                           parser_list_iterator_t *iterator_p) /**< iterator */
        -:  294:{
       85:  295:  iterator_p->list_p = list_p;
       85:  296:  iterator_p->current_p = list_p->data.first_p;
       85:  297:  iterator_p->current_position = 0;
       85:  298:} /* parser_list_iterator_init */
        -:  299:
        -:  300:/**
        -:  301: * Next iterator step.
        -:  302: *
        -:  303: * @return the address of the current item, or NULL at the end.
        -:  304: */
        -:  305:void *
      358:  306:parser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */
        -:  307:{
        -:  308:  void *result;
        -:  309:
      358:  310:  if (iterator_p->current_p == NULL)
        -:  311:  {
       71:  312:    return NULL;
        -:  313:  }
        -:  314:
      287:  315:  result = iterator_p->current_p->bytes + iterator_p->current_position;
      287:  316:  iterator_p->current_position += iterator_p->list_p->item_size;
        -:  317:
      287:  318:  if (iterator_p->current_p->next_p == NULL)
        -:  319:  {
      157:  320:    if (iterator_p->current_position >= iterator_p->list_p->data.last_position)
        -:  321:    {
       57:  322:      iterator_p->current_p = NULL;
       57:  323:      iterator_p->current_position = 0;
        -:  324:    }
        -:  325:  }
      130:  326:  else if (iterator_p->current_position >= iterator_p->list_p->page_size)
        -:  327:  {
       18:  328:    iterator_p->current_p = iterator_p->current_p->next_p;
       18:  329:    iterator_p->current_position = 0;
        -:  330:  }
      287:  331:  return result;
        -:  332:} /* parser_list_iterator_next */
        -:  333:
        -:  334:/**********************************************************************/
        -:  335:/* Parser stack management functions                                  */
        -:  336:/**********************************************************************/
        -:  337:
        -:  338:/* Stack is a reversed storage. */
        -:  339:
        -:  340:/**
        -:  341: * Initialize parser stack.
        -:  342: */
        -:  343:void
        2:  344:parser_stack_init (parser_context_t *context_p) /**< context */
        -:  345:{
        2:  346:  parser_data_init (&context_p->stack, PARSER_STACK_PAGE_SIZE);
        2:  347:  context_p->free_page_p = NULL;
        2:  348:} /* parser_stack_init */
        -:  349:
        -:  350:/**
        -:  351: * Free parser stack.
        -:  352: */
        -:  353:void
        2:  354:parser_stack_free (parser_context_t *context_p) /**< context */
        -:  355:{
        2:  356:  parser_data_free (&context_p->stack,
        -:  357:                    sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  358:
        2:  359:  if (context_p->free_page_p != NULL)
        -:  360:  {
    #####:  361:    parser_free (context_p->free_page_p,
        -:  362:                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  363:  }
        2:  364:} /* parser_stack_free */
        -:  365:
        -:  366:/**
        -:  367: * Pushes an uint8_t value onto the stack.
        -:  368: */
        -:  369:void
       47:  370:parser_stack_push_uint8 (parser_context_t *context_p, /**< context */
        -:  371:                         uint8_t uint8_value) /**< value pushed onto the stack */
        -:  372:{
       47:  373:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  374:
        -:  375:  /* This assert might trigger false positive valgrind errors, when
        -:  376:   * parser_stack_push() pushes not fully initialized structures.
        -:  377:   * More precisely when the last byte of the structure is uninitialized. */
       47:  378:  JERRY_ASSERT (page_p == NULL
        -:  379:                || context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  380:
       47:  381:  if (context_p->stack.last_position >= PARSER_STACK_PAGE_SIZE)
        -:  382:  {
        2:  383:    if (context_p->free_page_p != NULL)
        -:  384:    {
    #####:  385:      page_p = context_p->free_page_p;
    #####:  386:      context_p->free_page_p = NULL;
        -:  387:    }
        -:  388:    else
        -:  389:    {
        2:  390:      size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;
        2:  391:      page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  392:    }
        -:  393:
        2:  394:    page_p->next_p = context_p->stack.first_p;
        2:  395:    context_p->stack.last_position = 0;
        2:  396:    context_p->stack.first_p = page_p;
        -:  397:  }
        -:  398:
       47:  399:  page_p->bytes[context_p->stack.last_position++] = uint8_value;
       47:  400:  context_p->stack_top_uint8 = uint8_value;
       47:  401:} /* parser_stack_push_uint8 */
        -:  402:
        -:  403:/**
        -:  404: * Pops the last uint8_t value from the stack.
        -:  405: */
        -:  406:void
       45:  407:parser_stack_pop_uint8 (parser_context_t *context_p) /**< context */
        -:  408:{
       45:  409:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  410:
       45:  411:  JERRY_ASSERT (page_p != NULL
        -:  412:                && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  413:
       45:  414:  context_p->stack.last_position--;
        -:  415:
       45:  416:  if (context_p->stack.last_position == 0)
        -:  417:  {
    #####:  418:    context_p->stack.first_p = page_p->next_p;
    #####:  419:    context_p->stack.last_position = PARSER_STACK_PAGE_SIZE;
        -:  420:
    #####:  421:    if (context_p->free_page_p == NULL)
        -:  422:    {
    #####:  423:      context_p->free_page_p = page_p;
        -:  424:    }
        -:  425:    else
        -:  426:    {
        -:  427:      parser_free (page_p,
        -:  428:                   sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  429:    }
        -:  430:
    #####:  431:    page_p = context_p->stack.first_p;
        -:  432:
    #####:  433:    JERRY_ASSERT (page_p != NULL);
        -:  434:  }
        -:  435:
       45:  436:  context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];
       45:  437:} /* parser_stack_pop_uint8 */
        -:  438:
        -:  439:/**
        -:  440: * Change last byte of the stack.
        -:  441: */
        -:  442:void
    #####:  443:parser_stack_change_last_uint8 (parser_context_t *context_p, /**< context */
        -:  444:                                uint8_t new_value) /**< new value */
        -:  445:{
    #####:  446:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  447:
    #####:  448:  JERRY_ASSERT (page_p != NULL
        -:  449:                && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  450:
    #####:  451:  page_p->bytes[context_p->stack.last_position - 1] = new_value;
    #####:  452:  context_p->stack_top_uint8 = new_value;
    #####:  453:} /* parser_stack_change_last_uint8 */
        -:  454:
        -:  455:/**
        -:  456: * Get the uint8 value before the top of the stack.
        -:  457: *
        -:  458: * Pointer to the uint8 value
        -:  459: */
        -:  460:uint8_t *
    #####:  461:parser_stack_get_prev_uint8 (parser_context_t *context_p) /**< context */
        -:  462:{
    #####:  463:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  464:
    #####:  465:  JERRY_ASSERT (page_p != NULL && (context_p->stack.last_position >= 2 || page_p->next_p != NULL));
        -:  466:
    #####:  467:  if (context_p->stack.last_position >= 2)
        -:  468:  {
    #####:  469:    return page_p->bytes + (context_p->stack.last_position - 2);
        -:  470:  }
        -:  471:
    #####:  472:  return page_p->next_p->bytes + (PARSER_STACK_PAGE_SIZE - 1);
        -:  473:} /* parser_stack_get_prev_uint8 */
        -:  474:
        -:  475:/**
        -:  476: * Pushes an uint16_t value onto the stack.
        -:  477: */
        -:  478:void
    #####:  479:parser_stack_push_uint16 (parser_context_t *context_p, /**< context */
        -:  480:                          uint16_t uint16_value) /**< value pushed onto the stack */
        -:  481:{
    #####:  482:  if (context_p->stack.last_position + 2 <= PARSER_STACK_PAGE_SIZE)
        -:  483:  {
    #####:  484:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  485:
    #####:  486:    JERRY_ASSERT (page_p != NULL
        -:  487:                  && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  488:
    #####:  489:    page_p->bytes[context_p->stack.last_position++] = (uint8_t) (uint16_value >> 8);
    #####:  490:    page_p->bytes[context_p->stack.last_position++] = (uint8_t) uint16_value;
    #####:  491:    context_p->stack_top_uint8 = (uint8_t) uint16_value;
        -:  492:  }
        -:  493:  else
        -:  494:  {
    #####:  495:    parser_stack_push_uint8 (context_p, (uint8_t) (uint16_value >> 8));
    #####:  496:    parser_stack_push_uint8 (context_p, (uint8_t) uint16_value);
        -:  497:  }
    #####:  498:} /* parser_stack_push_uint16 */
        -:  499:
        -:  500:/**
        -:  501: * Pops the last uint16_t value from the stack.
        -:  502: *
        -:  503: * @return the value popped from the stack.
        -:  504: */
        -:  505:uint16_t
    #####:  506:parser_stack_pop_uint16 (parser_context_t *context_p) /**< context */
        -:  507:{
    #####:  508:  uint32_t value = context_p->stack_top_uint8;
        -:  509:
    #####:  510:  if (context_p->stack.last_position >= 3)
        -:  511:  {
    #####:  512:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  513:
    #####:  514:    JERRY_ASSERT (page_p != NULL
        -:  515:                  && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  516:
    #####:  517:    value |= ((uint32_t) page_p->bytes[context_p->stack.last_position - 2]) << 8;
    #####:  518:    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 3];
    #####:  519:    context_p->stack.last_position -= 2;
        -:  520:  }
        -:  521:  else
        -:  522:  {
    #####:  523:    parser_stack_pop_uint8 (context_p);
    #####:  524:    value |= ((uint32_t) context_p->stack_top_uint8) << 8;
    #####:  525:    parser_stack_pop_uint8 (context_p);
        -:  526:  }
    #####:  527:  return (uint16_t) value;
        -:  528:} /* parser_stack_pop_uint16 */
        -:  529:
        -:  530:/**
        -:  531: * Pushes a data onto the stack.
        -:  532: */
        -:  533:void
        5:  534:parser_stack_push (parser_context_t *context_p, /**< context */
        -:  535:                   const void *data_p, /**< data pushed onto the stack */
        -:  536:                   uint32_t length) /**< length of the data */
        -:  537:{
        5:  538:  uint32_t fragment_length = PARSER_STACK_PAGE_SIZE - context_p->stack.last_position;
        5:  539:  const uint8_t *bytes_p = (const uint8_t *) data_p;
        -:  540:  parser_mem_page_t *page_p;
        -:  541:
        5:  542:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  543:
        5:  544:  context_p->stack_top_uint8 = bytes_p[length - 1];
        -:  545:
        5:  546:  if (fragment_length > 0)
        -:  547:  {
        -:  548:    /* Fill the remaining bytes. */
        5:  549:    if (fragment_length > length)
        -:  550:    {
        5:  551:      fragment_length = length;
        -:  552:    }
        -:  553:
        5:  554:    memcpy (context_p->stack.first_p->bytes + context_p->stack.last_position,
        -:  555:            bytes_p,
        -:  556:            fragment_length);
        -:  557:
        5:  558:    if (fragment_length == length)
        -:  559:    {
        5:  560:      context_p->stack.last_position += length;
        5:  561:      return;
        -:  562:    }
        -:  563:
    #####:  564:    bytes_p += fragment_length;
    #####:  565:    length -= fragment_length;
        -:  566:  }
        -:  567:
    #####:  568:  if (context_p->free_page_p != NULL)
        -:  569:  {
    #####:  570:    page_p = context_p->free_page_p;
    #####:  571:    context_p->free_page_p = NULL;
        -:  572:  }
        -:  573:  else
        -:  574:  {
    #####:  575:    size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;
        -:  576:
    #####:  577:    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  578:  }
        -:  579:
    #####:  580:  page_p->next_p = context_p->stack.first_p;
        -:  581:
    #####:  582:  context_p->stack.first_p = page_p;
        -:  583:
    #####:  584:  memcpy (page_p->bytes, bytes_p, length);
    #####:  585:  context_p->stack.last_position = length;
        -:  586:} /* parser_stack_push */
        -:  587:
        -:  588:/**
        -:  589: * Pop bytes from the top of the stack.
        -:  590: */
        -:  591:void
        5:  592:parser_stack_pop (parser_context_t *context_p, /**< context */
        -:  593:                  void *data_p, /**< destination buffer, can be NULL */
        -:  594:                  uint32_t length) /**< length of the data */
        -:  595:{
        5:  596:  uint8_t *bytes_p = (uint8_t *) data_p;
        5:  597:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  598:
        5:  599:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  600:
        5:  601:  if (context_p->stack.last_position > length)
        -:  602:  {
        5:  603:    context_p->stack.last_position -= length;
        5:  604:    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];
        -:  605:
        5:  606:    if (bytes_p != NULL)
        -:  607:    {
        5:  608:      memcpy (bytes_p, context_p->stack.first_p->bytes + context_p->stack.last_position, length);
        -:  609:    }
        5:  610:    return;
        -:  611:  }
        -:  612:
    #####:  613:  JERRY_ASSERT (page_p->next_p != NULL);
        -:  614:
    #####:  615:  length -= context_p->stack.last_position;
        -:  616:
    #####:  617:  if (bytes_p != NULL)
        -:  618:  {
    #####:  619:    memcpy (bytes_p + length, page_p->bytes, context_p->stack.last_position);
        -:  620:  }
        -:  621:
    #####:  622:  context_p->stack.first_p = page_p->next_p;
    #####:  623:  context_p->stack.last_position = PARSER_STACK_PAGE_SIZE - length;
    #####:  624:  context_p->stack_top_uint8 = page_p->next_p->bytes[context_p->stack.last_position - 1];
        -:  625:
    #####:  626:  if (bytes_p != NULL && length > 0)
        -:  627:  {
    #####:  628:    memcpy (bytes_p, page_p->next_p->bytes + context_p->stack.last_position, length);
        -:  629:  }
        -:  630:
    #####:  631:  JERRY_ASSERT (context_p->stack.last_position > 0);
        -:  632:
    #####:  633:  if (context_p->free_page_p == NULL)
        -:  634:  {
    #####:  635:    context_p->free_page_p = page_p;
        -:  636:  }
        -:  637:  else
        -:  638:  {
        -:  639:    parser_free (page_p,
        -:  640:                 sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  641:  }
        -:  642:} /* parser_stack_pop */
        -:  643:
        -:  644:/**
        -:  645: * Initialize stack iterator.
        -:  646: */
        -:  647:extern inline void
        6:  648:parser_stack_iterator_init (parser_context_t *context_p, /**< context */
        -:  649:                            parser_stack_iterator_t *iterator) /**< iterator */
        -:  650:{
        6:  651:  iterator->current_p = context_p->stack.first_p;
        6:  652:  iterator->current_position = context_p->stack.last_position;
        6:  653:} /* parser_stack_iterator_init */
        -:  654:
        -:  655:/**
        -:  656: * Read the next byte from the stack.
        -:  657: *
        -:  658: * @return byte
        -:  659: */
        -:  660:extern inline uint8_t
    #####:  661:parser_stack_iterator_read_uint8 (parser_stack_iterator_t *iterator) /**< iterator */
        -:  662:{
    #####:  663:  JERRY_ASSERT (iterator->current_position > 0 && iterator->current_position <= PARSER_STACK_PAGE_SIZE);
    #####:  664:  return iterator->current_p->bytes[iterator->current_position - 1];
        -:  665:} /* parser_stack_iterator_read_uint8 */
        -:  666:
        -:  667:/**
        -:  668: * Skip the next n bytes of the stack.
        -:  669: */
        -:  670:void
    #####:  671:parser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */
        -:  672:                            size_t length) /**< number of skipped bytes */
        -:  673:{
    #####:  674:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  675:
    #####:  676:  if (length < iterator->current_position)
        -:  677:  {
    #####:  678:    iterator->current_position -= length;
        -:  679:  }
        -:  680:  else
        -:  681:  {
    #####:  682:    iterator->current_position = PARSER_STACK_PAGE_SIZE - (length - iterator->current_position);
    #####:  683:    iterator->current_p = iterator->current_p->next_p;
        -:  684:  }
    #####:  685:} /* parser_stack_iterator_skip */
        -:  686:
        -:  687:/**
        -:  688: * Read bytes from the stack.
        -:  689: */
        -:  690:void
    #####:  691:parser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */
        -:  692:                            void *data_p, /**< destination buffer */
        -:  693:                            size_t length) /**< length of the data */
        -:  694:{
    #####:  695:  uint8_t *bytes_p = (uint8_t *) data_p;
        -:  696:
    #####:  697:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  698:
    #####:  699:  if (length <= iterator->current_position)
        -:  700:  {
    #####:  701:    memcpy (bytes_p,
    #####:  702:            iterator->current_p->bytes + iterator->current_position - length,
        -:  703:            length);
        -:  704:  }
        -:  705:  else
        -:  706:  {
    #####:  707:    JERRY_ASSERT (iterator->current_p->next_p != NULL);
        -:  708:
    #####:  709:    length -= iterator->current_position;
    #####:  710:    memcpy (bytes_p + length,
    #####:  711:            iterator->current_p->bytes,
        -:  712:            iterator->current_position);
    #####:  713:    memcpy (bytes_p,
    #####:  714:            iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length,
        -:  715:            length);
        -:  716:  }
    #####:  717:} /* parser_stack_iterator_read */
        -:  718:
        -:  719:/**
        -:  720: * Write bytes onto the stack.
        -:  721: */
        -:  722:void
    #####:  723:parser_stack_iterator_write (parser_stack_iterator_t *iterator, /**< iterator */
        -:  724:                             const void *data_p, /**< destination buffer */
        -:  725:                             size_t length) /**< length of the data */
        -:  726:{
    #####:  727:  const uint8_t *bytes_p = (const uint8_t *) data_p;
        -:  728:
    #####:  729:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  730:
    #####:  731:  if (length <= iterator->current_position)
        -:  732:  {
    #####:  733:    memcpy (iterator->current_p->bytes + iterator->current_position - length,
        -:  734:            bytes_p,
        -:  735:            length);
        -:  736:  }
        -:  737:  else
        -:  738:  {
    #####:  739:    JERRY_ASSERT (iterator->current_p->next_p != NULL);
        -:  740:
    #####:  741:    length -= iterator->current_position;
    #####:  742:    memcpy (iterator->current_p->bytes,
    #####:  743:            bytes_p + length,
        -:  744:            iterator->current_position);
    #####:  745:    memcpy (iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length,
        -:  746:            bytes_p,
        -:  747:            length);
        -:  748:  }
    #####:  749:} /* parser_stack_iterator_write */
        -:  750:
        -:  751:/**
        -:  752: * @}
        -:  753: * @}
        -:  754: */
        -:  755:
        -:  756:#endif /* JERRY_PARSER */
