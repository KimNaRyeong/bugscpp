        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-builtin-object.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-exceptions.h"
        -:   27:#include "ecma-function-object.h"
        -:   28:#include "ecma-gc.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-lcache.h"
        -:   32:#include "ecma-lex-env.h"
        -:   33:#include "ecma-objects.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-promise-object.h"
        -:   36:#include "ecma-regexp-object.h"
        -:   37:#include "jcontext.h"
        -:   38:#include "opcodes.h"
        -:   39:#include "vm.h"
        -:   40:#include "vm-stack.h"
        -:   41:
        -:   42:/** \addtogroup vm Virtual machine
        -:   43: * @{
        -:   44: *
        -:   45: * \addtogroup vm_executor Executor
        -:   46: * @{
        -:   47: */
        -:   48:
        -:   49:/**
        -:   50: * Get the value of object[property].
        -:   51: *
        -:   52: * @return ecma value
        -:   53: */
        -:   54:static ecma_value_t
        4:   55:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   56:                 ecma_value_t property) /**< property name */
        -:   57:{
        4:   58:  if (ecma_is_value_object (object))
        -:   59:  {
        4:   60:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        4:   61:    ecma_string_t *property_name_p = NULL;
        -:   62:
        4:   63:    if (ecma_is_value_integer_number (property))
        -:   64:    {
    #####:   65:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   66:
    #####:   67:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   68:      {
    #####:   69:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   70:        {
    #####:   71:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   72:
    #####:   73:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   74:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   75:          {
    #####:   76:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   77:
    #####:   78:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   79:            {
    #####:   80:              return ecma_fast_copy_value (values_p[int_value]);
        -:   81:            }
        -:   82:          }
        -:   83:        }
        -:   84:
    #####:   85:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,
        -:   86:                                                                       (uintptr_t) int_value);
        -:   87:      }
        -:   88:    }
        4:   89:    else if (ecma_is_value_string (property))
        -:   90:    {
        3:   91:      property_name_p = ecma_get_string_from_value (property);
        -:   92:    }
        -:   93:
        -:   94:#if JERRY_ESNEXT
        4:   95:    if (ecma_is_value_symbol (property))
        -:   96:    {
        1:   97:      property_name_p = ecma_get_symbol_from_value (property);
        -:   98:    }
        -:   99:#endif /* JERRY_ESNEXT */
        -:  100:
        4:  101:    if (property_name_p != NULL)
        -:  102:    {
        -:  103:#if JERRY_LCACHE
        4:  104:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  105:
        4:  106:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  107:      {
    #####:  108:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  109:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  110:      }
        -:  111:#endif /* JERRY_LCACHE */
        -:  112:
        -:  113:      /* There is no need to free the name. */
        4:  114:      return ecma_op_object_get (object_p, property_name_p);
        -:  115:    }
        -:  116:  }
        -:  117:
    #####:  118:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  119:  {
        -:  120:#if JERRY_ERROR_MESSAGES
    #####:  121:    ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  122:                                                                      "Cannot read property '%' of %",
        -:  123:                                                                      property,
        -:  124:                                                                      object);
        -:  125:#else /* !JERRY_ERROR_MESSAGES */
        -:  126:    ecma_value_t error_value = ecma_raise_type_error (NULL);
        -:  127:#endif /* JERRY_ERROR_MESSAGES */
    #####:  128:    return error_value;
        -:  129:  }
        -:  130:
    #####:  131:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  132:
    #####:  133:  if (property_name_p == NULL)
        -:  134:  {
    #####:  135:    return ECMA_VALUE_ERROR;
        -:  136:  }
        -:  137:
    #####:  138:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  139:
    #####:  140:  ecma_deref_ecma_string (property_name_p);
    #####:  141:  return get_value_result;
        -:  142:} /* vm_op_get_value */
        -:  143:
        -:  144:/**
        -:  145: * Set the value of object[property].
        -:  146: *
        -:  147: * Note:
        -:  148: *  this function frees its object and property arguments
        -:  149: *
        -:  150: * @return an ecma value which contains an error
        -:  151: *         if the property setting is unsuccessful
        -:  152: */
        -:  153:static ecma_value_t
    #####:  154:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  155:                 ecma_value_t property, /**< property name */
        -:  156:                 ecma_value_t value, /**< ecma value */
        -:  157:                 bool is_strict) /**< strict mode */
        -:  158:{
    #####:  159:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  160:  ecma_object_t *object_p;
        -:  161:  ecma_string_t *property_p;
        -:  162:
    #####:  163:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  164:  {
    #####:  165:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  166:    {
        -:  167:#if JERRY_ERROR_MESSAGES
    #####:  168:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  169:                                                      "Cannot set property '%' of %",
        -:  170:                                                      property,
        -:  171:                                                      base);
        -:  172:#else /* !JERRY_ERROR_MESSAGES */
        -:  173:      result = ecma_raise_type_error (NULL);
        -:  174:#endif /* JERRY_ERROR_MESSAGES */
    #####:  175:      ecma_free_value (property);
    #####:  176:      return result;
        -:  177:    }
        -:  178:
    #####:  179:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  180:    {
    #####:  181:      property_p = ecma_op_to_string (property);
    #####:  182:      ecma_fast_free_value (property);
        -:  183:
    #####:  184:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  185:      {
    #####:  186:        ecma_free_value (base);
    #####:  187:        return ECMA_VALUE_ERROR;
        -:  188:      }
        -:  189:    }
        -:  190:    else
        -:  191:    {
    #####:  192:      property_p = ecma_get_prop_name_from_value (property);
        -:  193:    }
        -:  194:
    #####:  195:    ecma_value_t object = ecma_op_to_object (base);
    #####:  196:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  197:
    #####:  198:    object_p = ecma_get_object_from_value (object);
    #####:  199:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  200:
    #####:  201:    result = ecma_op_object_put_with_receiver (object_p,
        -:  202:                                               property_p,
        -:  203:                                               value,
        -:  204:                                               base,
        -:  205:                                               is_strict);
        -:  206:
    #####:  207:    ecma_free_value (base);
        -:  208:  }
        -:  209:  else
        -:  210:  {
    #####:  211:    object_p = ecma_get_object_from_value (base);
        -:  212:
    #####:  213:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  214:    {
    #####:  215:      property_p = ecma_op_to_string (property);
    #####:  216:      ecma_fast_free_value (property);
        -:  217:
    #####:  218:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  219:      {
    #####:  220:        ecma_deref_object (object_p);
    #####:  221:        return ECMA_VALUE_ERROR;
        -:  222:      }
        -:  223:    }
        -:  224:    else
        -:  225:    {
    #####:  226:      property_p = ecma_get_prop_name_from_value (property);
        -:  227:    }
        -:  228:
    #####:  229:    if (!ecma_is_lexical_environment (object_p))
        -:  230:    {
    #####:  231:      result = ecma_op_object_put_with_receiver (object_p,
        -:  232:                                                 property_p,
        -:  233:                                                 value,
        -:  234:                                                 base,
        -:  235:                                                 is_strict);
        -:  236:    }
        -:  237:    else
        -:  238:    {
    #####:  239:      result = ecma_op_set_mutable_binding (object_p,
        -:  240:                                            property_p,
        -:  241:                                            value,
        -:  242:                                            is_strict);
        -:  243:    }
        -:  244:  }
        -:  245:
    #####:  246:  ecma_deref_object (object_p);
    #####:  247:  ecma_deref_ecma_string (property_p);
    #####:  248:  return result;
        -:  249:} /* vm_op_set_value */
        -:  250:
        -:  251:/** Compact bytecode define */
        -:  252:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  253:
        -:  254:/**
        -:  255: * Decode table for both opcodes and extended opcodes.
        -:  256: */
        -:  257:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA =
        -:  258:{
        -:  259:  CBC_OPCODE_LIST
        -:  260:  CBC_EXT_OPCODE_LIST
        -:  261:};
        -:  262:
        -:  263:#undef CBC_OPCODE
        -:  264:
        -:  265:/**
        -:  266: * Run global code
        -:  267: *
        -:  268: * Note:
        -:  269: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  270: *
        -:  271: * @return ecma value
        -:  272: */
        -:  273:ecma_value_t
        1:  274:vm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */
        -:  275:{
        -:  276:#if JERRY_BUILTIN_REALMS
        1:  277:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  278:#else /* !JERRY_BUILTIN_REALMS */
    #####:  279:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  280:#endif /* JERRY_BUILTIN_REALMS */
        -:  281:
        -:  282:#if JERRY_ESNEXT
        1:  283:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  284:  {
    #####:  285:    ecma_create_global_lexical_block (global_obj_p);
        -:  286:  }
        -:  287:#endif /* JERRY_ESNEXT */
        -:  288:
        1:  289:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  290:
        1:  291:  vm_frame_ctx_shared_t shared;
        1:  292:  shared.bytecode_header_p = bytecode_p;
        1:  293:  shared.function_object_p = NULL;
        1:  294:  shared.status_flags = 0;
        -:  295:
        -:  296:#if JERRY_BUILTIN_REALMS
        1:  297:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  298:
        1:  299:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  300:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  301:#else /* !JERRY_BUILTIN_REALMS */
    #####:  302:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  303:#endif /* JERRY_BUILTIN_REALMS */
        -:  304:
        1:  305:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  306:
        -:  307:#if JERRY_BUILTIN_REALMS
        1:  308:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  309:#endif /* JERRY_BUILTIN_REALMS */
        -:  310:
        1:  311:  return result;
        -:  312:} /* vm_run_global */
        -:  313:
        -:  314:/**
        -:  315: * Run specified eval-mode bytecode
        -:  316: *
        -:  317: * @return ecma value
        -:  318: */
        -:  319:ecma_value_t
    #####:  320:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  321:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  322:{
        -:  323:  ecma_value_t this_binding;
        -:  324:  ecma_object_t *lex_env_p;
        -:  325:
        -:  326:  /* ECMA-262 v5, 10.4.2 */
    #####:  327:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  328:  {
    #####:  329:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  330:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  331:
        -:  332:#if JERRY_DEBUGGER
        -:  333:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  334:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  335:
        -:  336:    while (chain_index != 0)
        -:  337:    {
        -:  338:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  339:      {
        -:  340:        ecma_bytecode_deref (bytecode_data_p);
        -:  341:        ecma_free_value (this_binding);
        -:  342:        return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid scope chain index for eval"));
        -:  343:      }
        -:  344:
        -:  345:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  346:
        -:  347:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  348:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  349:      {
        -:  350:        chain_index--;
        -:  351:      }
        -:  352:    }
        -:  353:#endif /* JERRY_DEBUGGER */
        -:  354:  }
        -:  355:  else
        -:  356:  {
        -:  357:#if JERRY_BUILTIN_REALMS
    #####:  358:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  359:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  360:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  361:#else /* !JERRY_BUILTIN_REALMS */
    #####:  362:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  363:    ecma_ref_object (global_obj_p);
    #####:  364:    this_binding = ecma_make_object_value (global_obj_p);
        -:  365:#endif /* JERRY_BUILTIN_REALMS */
    #####:  366:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  367:  }
        -:  368:
    #####:  369:  ecma_ref_object (lex_env_p);
        -:  370:
    #####:  371:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  372:  {
    #####:  373:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  374:
    #####:  375:    ecma_deref_object (lex_env_p);
    #####:  376:    lex_env_p = strict_lex_env_p;
        -:  377:  }
        -:  378:
    #####:  379:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  380:  {
    #####:  381:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  382:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  383:
    #####:  384:    ecma_deref_object (lex_env_p);
    #####:  385:    lex_env_p = lex_block_p;
        -:  386:  }
        -:  387:
    #####:  388:  vm_frame_ctx_shared_t shared;
    #####:  389:  shared.bytecode_header_p = bytecode_data_p;
    #####:  390:  shared.function_object_p = NULL;
    #####:  391:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  392:
    #####:  393:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  394:
    #####:  395:  ecma_deref_object (lex_env_p);
    #####:  396:  ecma_free_value (this_binding);
        -:  397:
        -:  398:#if JERRY_SNAPSHOT_EXEC
    #####:  399:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  400:  {
    #####:  401:    ecma_bytecode_deref (bytecode_data_p);
        -:  402:  }
        -:  403:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  404:  ecma_bytecode_deref (bytecode_data_p);
        -:  405:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  406:
    #####:  407:  return completion_value;
        -:  408:} /* vm_run_eval */
        -:  409:
        -:  410:#if JERRY_MODULE_SYSTEM
        -:  411:
        -:  412:/**
        -:  413: * Run module code
        -:  414: *
        -:  415: * Note:
        -:  416: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  417: *
        -:  418: * @return ecma value
        -:  419: */
        -:  420:ecma_value_t
    #####:  421:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  422:{
    #####:  423:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  424:
    #####:  425:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  426:  {
    #####:  427:    return module_init_result;
        -:  428:  }
        -:  429:
    #####:  430:  vm_frame_ctx_shared_t shared;
    #####:  431:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  432:  shared.function_object_p = &module_p->header.object;
    #####:  433:  shared.status_flags = 0;
        -:  434:
    #####:  435:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  436:} /* vm_run_module */
        -:  437:
        -:  438:#endif /* JERRY_MODULE_SYSTEM */
        -:  439:
        -:  440:/**
        -:  441: * Construct object
        -:  442: *
        -:  443: * @return object value
        -:  444: */
        -:  445:static ecma_value_t
        5:  446:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  447:                             ecma_value_t lit_value) /**< literal */
        -:  448:{
        -:  449:  ecma_compiled_code_t *bytecode_p;
        -:  450:
        -:  451:#if JERRY_SNAPSHOT_EXEC
    #####:  452:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  453:  {
        -:  454:#endif /* JERRY_SNAPSHOT_EXEC */
        5:  455:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  456:                                                  lit_value);
        -:  457:#if JERRY_SNAPSHOT_EXEC
        -:  458:  }
        -:  459:  else
        -:  460:  {
    #####:  461:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  462:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  463:  }
        -:  464:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  465:
        -:  466:#if JERRY_BUILTIN_REGEXP
        5:  467:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  468:  {
    #####:  469:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  470:
    #####:  471:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  472:    {
    #####:  473:      return ECMA_VALUE_ERROR;
        -:  474:    }
        -:  475:
    #####:  476:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  477:  }
        -:  478:#else /* !JERRY_BUILTIN_REGEXP */
        -:  479:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  480:#endif /* JERRY_BUILTIN_REGEXP */
        -:  481:
        -:  482:  ecma_object_t *func_obj_p;
        -:  483:
        -:  484:#if JERRY_ESNEXT
        5:  485:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  486:  {
        1:  487:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,
        -:  488:                                                       bytecode_p,
        -:  489:                                                       frame_ctx_p->this_binding);
        -:  490:  }
        -:  491:  else
        -:  492:  {
        4:  493:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  494:  }
        -:  495:#else /* !JERRY_ESNEXT */
    #####:  496:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  497:#endif /* JERRY_ESNEXT */
        -:  498:
        5:  499:  return ecma_make_object_value (func_obj_p);
        -:  500:} /* vm_construct_literal_object */
        -:  501:
        -:  502:/**
        -:  503: * Get implicit this value
        -:  504: *
        -:  505: * @return true - if the implicit 'this' value is updated,
        -:  506: *         false - otherwise
        -:  507: */
        -:  508:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  509:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  510:{
    #####:  511:  if (ecma_is_value_object (*this_value_p))
        -:  512:  {
    #####:  513:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  514:
    #####:  515:    if (ecma_is_lexical_environment (this_obj_p))
        -:  516:    {
    #####:  517:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  518:
    #####:  519:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  520:
    #####:  521:      *this_value_p = completion_value;
    #####:  522:      return true;
        -:  523:    }
        -:  524:  }
    #####:  525:  return false;
        -:  526:} /* vm_get_implicit_this_value */
        -:  527:
        -:  528:/**
        -:  529: * Special bytecode sequence for error handling while the vm_loop
        -:  530: * is preserved for an execute operation
        -:  531: */
        -:  532:static const uint8_t vm_error_byte_code_p[] =
        -:  533:{
        -:  534:  CBC_EXT_OPCODE, CBC_EXT_ERROR
        -:  535:};
        -:  536:
        -:  537:#if JERRY_ESNEXT
        -:  538:
        -:  539:static ecma_object_t *
    #####:  540:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  541:{
    #####:  542:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  543:
    #####:  544:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  545:  {
    #####:  546:    return frame_ctx_p->shared_p->function_object_p;
        -:  547:  }
        -:  548:
    #####:  549:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  550:
    #####:  551:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  552:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  553:} /* vm_get_class_function */
        -:  554:
        -:  555:/**
        -:  556: * 'super(...)' function call handler.
        -:  557: */
        -:  558:static void
    #####:  559:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  560:{
    #####:  561:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  562:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  563:
    #####:  564:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  565:  uint8_t opcode = byte_code_p[-2];
        -:  566:  uint32_t arguments_list_len;
        -:  567:
    #####:  568:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  569:
    #####:  570:  ecma_collection_t *collection_p = NULL;
        -:  571:  ecma_value_t *arguments_p;
        -:  572:
    #####:  573:  if (spread_arguments)
        -:  574:  {
    #####:  575:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  576:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  577:    arguments_p = collection_p->buffer_p;
    #####:  578:    arguments_list_len = collection_p->item_count;
        -:  579:  }
        -:  580:  else
        -:  581:  {
    #####:  582:    arguments_list_len = byte_code_p[-1];
    #####:  583:    arguments_p = frame_ctx_p->stack_top_p;
        -:  584:  }
        -:  585:
    #####:  586:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  587:  ecma_value_t completion_value;
        -:  588:
    #####:  589:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  590:
    #####:  591:  if (!ecma_is_constructor (func_value))
        -:  592:  {
    #####:  593:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Value for class heritage is not a constructor"));
        -:  594:  }
        -:  595:  else
        -:  596:  {
    #####:  597:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  598:    completion_value = ecma_op_function_construct (func_obj_p,
        -:  599:                                                   JERRY_CONTEXT (current_new_target_p),
        -:  600:                                                   arguments_p,
        -:  601:                                                   arguments_list_len);
        -:  602:
    #####:  603:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  604:    {
    #####:  605:      ecma_free_value (completion_value);
    #####:  606:      completion_value = ecma_raise_reference_error (ECMA_ERR_MSG ("Super constructor may only be called once"));
        -:  607:    }
        -:  608:  }
        -:  609:
        -:  610:  /* Free registers. */
    #####:  611:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  612:  {
    #####:  613:    ecma_fast_free_value (arguments_p[i]);
        -:  614:  }
        -:  615:
    #####:  616:  if (collection_p != NULL)
        -:  617:  {
    #####:  618:    ecma_collection_destroy (collection_p);
        -:  619:  }
        -:  620:
    #####:  621:  if (ecma_is_value_object (completion_value))
        -:  622:  {
    #####:  623:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  624:
    #####:  625:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  626:    {
    #####:  627:      ecma_free_value (completion_value);
    #####:  628:      completion_value = ECMA_VALUE_ERROR;
        -:  629:    }
        -:  630:  }
        -:  631:
    #####:  632:  ecma_free_value (func_value);
        -:  633:
    #####:  634:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  635:  {
        -:  636:#if JERRY_DEBUGGER
        -:  637:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  638:#endif /* JERRY_DEBUGGER */
    #####:  639:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  640:  }
        -:  641:  else
        -:  642:  {
    #####:  643:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  644:    frame_ctx_p->this_binding = completion_value;
        -:  645:
    #####:  646:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  647:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  648:
    #####:  649:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  650:    {
    #####:  651:      ecma_fast_free_value (completion_value);
        -:  652:    }
    #####:  653:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  654:    {
    #####:  655:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  656:    }
        -:  657:    else
        -:  658:    {
    #####:  659:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  660:      frame_ctx_p->block_result = completion_value;
        -:  661:    }
        -:  662:  }
    #####:  663:} /* vm_super_call */
        -:  664:
        -:  665:/**
        -:  666: * Perform one of the following call/construct operation with spreaded argument list
        -:  667: *   - f(...args)
        -:  668: *   - o.f(...args)
        -:  669: *   - new O(...args)
        -:  670: */
        -:  671:static void
    #####:  672:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  673:{
    #####:  674:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  675:
    #####:  676:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  677:  ecma_value_t completion_value;
    #####:  678:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  679:
    #####:  680:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  681:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  682:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  683:
    #####:  684:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  685:  {
    #####:  686:    const char *constructor_message_p = ecma_check_constructor (func_value);
    #####:  687:    if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  688:    {
    #####:  689:      completion_value = ecma_raise_type_error (constructor_message_p);
        -:  690:    }
        -:  691:    else
        -:  692:    {
    #####:  693:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  694:
    #####:  695:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  696:                                                     constructor_obj_p,
    #####:  697:                                                     collection_p->buffer_p,
        -:  698:                                                     collection_p->item_count);
        -:  699:    }
        -:  700:  }
        -:  701:  else
        -:  702:  {
    #####:  703:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  704:
    #####:  705:    if (!ecma_is_value_object (func_value)
    #####:  706:        || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  707:    {
    #####:  708:      completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  709:    }
        -:  710:    else
        -:  711:    {
    #####:  712:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  713:
    #####:  714:      completion_value = ecma_op_function_call (func_obj_p,
        -:  715:                                                this_value,
    #####:  716:                                                collection_p->buffer_p,
        -:  717:                                                collection_p->item_count);
        -:  718:    }
        -:  719:
    #####:  720:    if (is_call_prop)
        -:  721:    {
    #####:  722:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  723:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  724:    }
        -:  725:  }
        -:  726:
    #####:  727:  ecma_collection_free (collection_p);
    #####:  728:  ecma_free_value (func_value);
        -:  729:
    #####:  730:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  731:  {
        -:  732:#if JERRY_DEBUGGER
        -:  733:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  734:#endif /* JERRY_DEBUGGER */
    #####:  735:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  736:  }
        -:  737:  else
        -:  738:  {
    #####:  739:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  740:
    #####:  741:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  742:    {
    #####:  743:      ecma_fast_free_value (completion_value);
        -:  744:    }
    #####:  745:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  746:    {
    #####:  747:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  748:    }
        -:  749:    else
        -:  750:    {
    #####:  751:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  752:      frame_ctx_p->block_result = completion_value;
        -:  753:    }
        -:  754:
        -:  755:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  756:    frame_ctx_p->byte_code_p += 3;
        -:  757:  }
    #####:  758:} /* vm_spread_operation */
        -:  759:#endif /* JERRY_ESNEXT */
        -:  760:
        -:  761:/**
        -:  762: * 'Function call' opcode handler.
        -:  763: *
        -:  764: * See also: ECMA-262 v5, 11.2.3
        -:  765: */
        -:  766:static void
        2:  767:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  768:{
        2:  769:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        2:  770:  uint8_t opcode = byte_code_p[-1];
        -:  771:  uint32_t arguments_list_len;
        -:  772:
        2:  773:  if (opcode >= CBC_CALL0)
        -:  774:  {
        2:  775:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  776:  }
        -:  777:  else
        -:  778:  {
    #####:  779:    arguments_list_len = *byte_code_p++;
        -:  780:  }
        -:  781:
        2:  782:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  783:
        2:  784:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        2:  785:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
        2:  786:  ecma_value_t func_value = stack_top_p[-1];
        -:  787:  ecma_value_t completion_value;
        -:  788:
        2:  789:  if (!ecma_is_value_object (func_value)
        2:  790:      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  791:  {
    #####:  792:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  793:  }
        -:  794:  else
        -:  795:  {
        2:  796:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  797:
        2:  798:    completion_value = ecma_op_function_call (func_obj_p,
        -:  799:                                              this_value,
        -:  800:                                              stack_top_p,
        -:  801:                                              arguments_list_len);
        -:  802:  }
        -:  803:
        2:  804:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  805:
        -:  806:  /* Free registers. */
        5:  807:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  808:  {
        3:  809:    ecma_fast_free_value (stack_top_p[i]);
        -:  810:  }
        -:  811:
        2:  812:  if (is_call_prop)
        -:  813:  {
        1:  814:    ecma_free_value (*(--stack_top_p));
        1:  815:    ecma_free_value (*(--stack_top_p));
        -:  816:  }
        -:  817:
        2:  818:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  819:  {
        -:  820:#if JERRY_DEBUGGER
        -:  821:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  822:#endif /* JERRY_DEBUGGER */
    #####:  823:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  824:  }
        -:  825:  else
        -:  826:  {
        2:  827:    frame_ctx_p->byte_code_p = byte_code_p;
        2:  828:    ecma_free_value (*(--stack_top_p));
        2:  829:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  830:
        2:  831:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  832:    {
        1:  833:      ecma_fast_free_value (completion_value);
        -:  834:    }
        1:  835:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  836:    {
    #####:  837:      *stack_top_p++ = completion_value;
        -:  838:    }
        -:  839:    else
        -:  840:    {
        1:  841:      ecma_fast_free_value (frame_ctx_p->block_result);
        1:  842:      frame_ctx_p->block_result = completion_value;
        -:  843:    }
        -:  844:  }
        -:  845:
        2:  846:  frame_ctx_p->stack_top_p = stack_top_p;
        2:  847:} /* opfunc_call */
        -:  848:
        -:  849:/**
        -:  850: * 'Constructor call' opcode handler.
        -:  851: *
        -:  852: * See also: ECMA-262 v5, 11.2.2
        -:  853: */
        -:  854:static void
    #####:  855:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  856:{
    #####:  857:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
    #####:  858:  uint8_t opcode = byte_code_p[-1];
        -:  859:  unsigned int arguments_list_len;
        -:  860:
    #####:  861:  if (opcode >= CBC_NEW0)
        -:  862:  {
    #####:  863:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  864:  }
        -:  865:  else
        -:  866:  {
    #####:  867:    arguments_list_len = *byte_code_p++;
        -:  868:  }
        -:  869:
    #####:  870:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
    #####:  871:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  872:  ecma_value_t completion_value;
        -:  873:
    #####:  874:  const char *constructor_message_p = ecma_check_constructor (constructor_value);
    #####:  875:  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  876:  {
    #####:  877:    completion_value = ecma_raise_type_error (constructor_message_p);
        -:  878:  }
        -:  879:  else
        -:  880:  {
    #####:  881:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  882:
    #####:  883:    completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  884:                                                   constructor_obj_p,
        -:  885:                                                   stack_top_p,
        -:  886:                                                   arguments_list_len);
        -:  887:  }
        -:  888:
        -:  889:  /* Free registers. */
    #####:  890:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  891:  {
    #####:  892:    ecma_fast_free_value (stack_top_p[i]);
        -:  893:  }
        -:  894:
    #####:  895:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  896:  {
        -:  897:#if JERRY_DEBUGGER
        -:  898:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  899:#endif /* JERRY_DEBUGGER */
    #####:  900:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  901:  }
        -:  902:  else
        -:  903:  {
    #####:  904:    ecma_free_value (stack_top_p[-1]);
    #####:  905:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  906:    stack_top_p[-1] = completion_value;
        -:  907:  }
        -:  908:
    #####:  909:  frame_ctx_p->stack_top_p = stack_top_p;
    #####:  910:} /* opfunc_construct */
        -:  911:
        -:  912:/**
        -:  913: * Read literal index from the byte code stream into destination.
        -:  914: *
        -:  915: * @param destination destination
        -:  916: */
        -:  917:#define READ_LITERAL_INDEX(destination) \
        -:  918:  do \
        -:  919:  { \
        -:  920:    (destination) = *byte_code_p++; \
        -:  921:    if ((destination) >= encoding_limit) \
        -:  922:    { \
        -:  923:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  924:    } \
        -:  925:  } \
        -:  926:  while (0)
        -:  927:
        -:  928:/**
        -:  929: * Get literal value by literal index.
        -:  930: *
        -:  931: * @param literal_index literal index
        -:  932: * @param target_value target value
        -:  933: *
        -:  934: * TODO: For performance reasons, we define this as a macro.
        -:  935: * When we are able to construct a function with similar speed,
        -:  936: * we can remove this macro.
        -:  937: */
        -:  938:#define READ_LITERAL(literal_index, target_value) \
        -:  939:  do \
        -:  940:  { \
        -:  941:    if ((literal_index) < ident_end) \
        -:  942:    { \
        -:  943:      if ((literal_index) < register_end) \
        -:  944:      { \
        -:  945:        /* Note: There should be no specialization for arguments. */ \
        -:  946:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index)); \
        -:  947:      } \
        -:  948:      else \
        -:  949:      { \
        -:  950:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]); \
        -:  951:        \
        -:  952:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, \
        -:  953:                                                  name_p); \
        -:  954:        \
        -:  955:        if (ECMA_IS_VALUE_ERROR (result)) \
        -:  956:        { \
        -:  957:          goto error; \
        -:  958:        } \
        -:  959:        (target_value) = result; \
        -:  960:      } \
        -:  961:    } \
        -:  962:    else if (literal_index < const_literal_end) \
        -:  963:    { \
        -:  964:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]); \
        -:  965:    } \
        -:  966:    else \
        -:  967:    { \
        -:  968:      /* Object construction. */ \
        -:  969:      (target_value) = vm_construct_literal_object (frame_ctx_p, \
        -:  970:                                                    literal_start_p[literal_index]); \
        -:  971:    } \
        -:  972:  } \
        -:  973:  while (0)
        -:  974:
        -:  975:/**
        -:  976: * Store the original value for post increase/decrease operators
        -:  977: *
        -:  978: * @param value original value
        -:  979: */
        -:  980:#define POST_INCREASE_DECREASE_PUT_RESULT(value) \
        -:  981:  if (opcode_data & VM_OC_PUT_STACK) \
        -:  982:  { \
        -:  983:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG) \
        -:  984:    { \
        -:  985:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT \
        -:  986:                    || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  987:      *stack_top_p++ = (value); \
        -:  988:    } \
        -:  989:    else \
        -:  990:    { \
        -:  991:      /* The parser ensures there is enough space for the \
        -:  992:       * extra value on the stack. See js-parser-expr.c. */ \
        -:  993:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT \
        -:  994:                    || opcode == CBC_POST_DECR_PUSH_RESULT); \
        -:  995:      stack_top_p++; \
        -:  996:      stack_top_p[-1] = stack_top_p[-2]; \
        -:  997:      stack_top_p[-2] = stack_top_p[-3]; \
        -:  998:      stack_top_p[-3] = (value); \
        -:  999:    } \
        -: 1000:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK; \
        -: 1001:  } \
        -: 1002:  else \
        -: 1003:  { \
        -: 1004:    JERRY_ASSERT (opcode_data & VM_OC_PUT_BLOCK); \
        -: 1005:    ecma_free_value (frame_ctx_p->block_result); \
        -: 1006:    frame_ctx_p->block_result = (value); \
        -: 1007:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK; \
        -: 1008:  }
        -: 1009:
        -: 1010:/**
        -: 1011: * Get the end of the existing topmost context
        -: 1012: */
        -: 1013:#define VM_LAST_CONTEXT_END() \
        -: 1014:  (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -: 1015:
        -: 1016:/**
        -: 1017: * Run generic byte code.
        -: 1018: *
        -: 1019: * @return ecma value
        -: 1020: */
        -: 1021:static ecma_value_t JERRY_ATTR_NOINLINE
       10: 1022:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1023:{
       10: 1024:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
       10: 1025:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
       10: 1026:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -: 1027:
       10: 1028:  ecma_value_t *stack_top_p;
        -: 1029:  uint16_t encoding_limit;
        -: 1030:  uint16_t encoding_delta;
        -: 1031:  uint16_t register_end;
        -: 1032:  uint16_t ident_end;
        -: 1033:  uint16_t const_literal_end;
       10: 1034:  int32_t branch_offset = 0;
       10: 1035:  uint8_t branch_offset_length = 0;
       10: 1036:  ecma_value_t left_value;
        -: 1037:  ecma_value_t right_value;
       10: 1038:  ecma_value_t result = ECMA_VALUE_EMPTY;
       10: 1039:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -: 1040:
        -: 1041:  /* Prepare for byte code execution. */
       10: 1042:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 1043:  {
       10: 1044:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
       10: 1045:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1046:  }
        -: 1047:  else
        -: 1048:  {
    #####: 1049:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1050:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1051:  }
        -: 1052:
       10: 1053:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1054:  {
    #####: 1055:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1056:    register_end = args_p->register_end;
    #####: 1057:    ident_end = args_p->ident_end;
    #####: 1058:    const_literal_end = args_p->const_literal_end;
        -: 1059:  }
        -: 1060:  else
        -: 1061:  {
       10: 1062:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
       10: 1063:    register_end = args_p->register_end;
       10: 1064:    ident_end = args_p->ident_end;
       10: 1065:    const_literal_end = args_p->const_literal_end;
        -: 1066:  }
        -: 1067:
       10: 1068:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1069:
        -: 1070:  /* Outer loop for exception handling. */
    #####: 1071:  while (true)
        -: 1072:  {
        -: 1073:    /* Internal loop for byte code execution. */
        -: 1074:    while (true)
       31: 1075:    {
       41: 1076:      const uint8_t *byte_code_start_p = byte_code_p;
       41: 1077:      uint8_t opcode = *byte_code_p++;
       41: 1078:      uint32_t opcode_data = opcode;
        -: 1079:
       41: 1080:      if (opcode == CBC_EXT_OPCODE)
        -: 1081:      {
        3: 1082:        opcode = *byte_code_p++;
        3: 1083:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1084:      }
        -: 1085:
       41: 1086:      opcode_data = vm_decode_table[opcode_data];
        -: 1087:
       41: 1088:      left_value = ECMA_VALUE_UNDEFINED;
       41: 1089:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1090:
       41: 1091:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1092:
       41: 1093:      if (operands >= VM_OC_GET_LITERAL)
        -: 1094:      {
        -: 1095:        uint16_t literal_index;
       15: 1096:        READ_LITERAL_INDEX (literal_index);
       15: 1097:        READ_LITERAL (literal_index, left_value);
        -: 1098:
       15: 1099:        if (operands != VM_OC_GET_LITERAL)
        -: 1100:        {
       10: 1101:          switch (operands)
        -: 1102:          {
        8: 1103:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1104:            {
        -: 1105:              uint16_t second_literal_index;
        8: 1106:              READ_LITERAL_INDEX (second_literal_index);
        8: 1107:              READ_LITERAL (second_literal_index, right_value);
        8: 1108:              break;
        -: 1109:            }
        2: 1110:            case VM_OC_GET_STACK_LITERAL:
        -: 1111:            {
        2: 1112:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        2: 1113:              right_value = left_value;
        2: 1114:              left_value = *(--stack_top_p);
        2: 1115:              break;
        -: 1116:            }
    #####: 1117:            default:
        -: 1118:            {
    #####: 1119:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1120:
    #####: 1121:              right_value = left_value;
    #####: 1122:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1123:              break;
        -: 1124:            }
        -: 1125:          }
        5: 1126:        }
        -: 1127:      }
       26: 1128:      else if (operands >= VM_OC_GET_STACK)
        -: 1129:      {
        6: 1130:        JERRY_ASSERT (operands == VM_OC_GET_STACK
        -: 1131:                      || operands == VM_OC_GET_STACK_STACK);
        -: 1132:
        6: 1133:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        6: 1134:        left_value = *(--stack_top_p);
        -: 1135:
        6: 1136:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1137:        {
        1: 1138:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        1: 1139:          right_value = left_value;
        1: 1140:          left_value = *(--stack_top_p);
        -: 1141:        }
        -: 1142:      }
       20: 1143:      else if (operands == VM_OC_GET_BRANCH)
        -: 1144:      {
        3: 1145:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        3: 1146:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1147:
        3: 1148:        branch_offset = *(byte_code_p++);
        -: 1149:
        3: 1150:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1151:        {
    #####: 1152:          branch_offset <<= 8;
    #####: 1153:          branch_offset |= *(byte_code_p++);
        -: 1154:
    #####: 1155:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1156:          {
    #####: 1157:            branch_offset <<= 8;
    #####: 1158:            branch_offset |= *(byte_code_p++);
        -: 1159:          }
        -: 1160:        }
        -: 1161:
        3: 1162:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1163:        {
        -: 1164:#if JERRY_VM_EXEC_STOP
    #####: 1165:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL
    #####: 1166:              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1167:          {
    #####: 1168:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1169:
    #####: 1170:            if (ecma_is_value_undefined (result))
        -: 1171:            {
    #####: 1172:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1173:            }
        -: 1174:            else
        -: 1175:            {
    #####: 1176:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1177:
    #####: 1178:              if (ecma_is_value_error_reference (result))
        -: 1179:              {
    #####: 1180:                ecma_raise_error_from_error_reference (result);
        -: 1181:              }
        -: 1182:              else
        -: 1183:              {
    #####: 1184:                jcontext_raise_exception (result);
        -: 1185:              }
        -: 1186:
        -: 1187:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1188:              jcontext_set_abort_flag (true);
    #####: 1189:              result = ECMA_VALUE_ERROR;
    #####: 1190:              goto error;
        -: 1191:            }
        -: 1192:          }
        -: 1193:#endif /* JERRY_VM_EXEC_STOP */
        -: 1194:
    #####: 1195:          branch_offset = -branch_offset;
        -: 1196:        }
        -: 1197:      }
        -: 1198:
       41: 1199:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1200:      {
    #####: 1201:        case VM_OC_POP:
        -: 1202:        {
    #####: 1203:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1204:          ecma_free_value (*(--stack_top_p));
    #####: 1205:          continue;
        -: 1206:        }
    #####: 1207:        case VM_OC_POP_BLOCK:
        -: 1208:        {
    #####: 1209:          ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 1210:          frame_ctx_p->block_result = *(--stack_top_p);
    #####: 1211:          continue;
        -: 1212:        }
        1: 1213:        case VM_OC_PUSH:
        -: 1214:        {
        1: 1215:          *stack_top_p++ = left_value;
        1: 1216:          continue;
        -: 1217:        }
        2: 1218:        case VM_OC_PUSH_TWO:
        -: 1219:        {
        2: 1220:          *stack_top_p++ = left_value;
        2: 1221:          *stack_top_p++ = right_value;
        2: 1222:          continue;
        -: 1223:        }
    #####: 1224:        case VM_OC_PUSH_THREE:
        -: 1225:        {
        -: 1226:          uint16_t literal_index;
        -: 1227:
    #####: 1228:          *stack_top_p++ = left_value;
    #####: 1229:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1230:
    #####: 1231:          READ_LITERAL_INDEX (literal_index);
    #####: 1232:          READ_LITERAL (literal_index, left_value);
        -: 1233:
    #####: 1234:          *stack_top_p++ = right_value;
    #####: 1235:          *stack_top_p++ = left_value;
    #####: 1236:          continue;
        -: 1237:        }
    #####: 1238:        case VM_OC_PUSH_UNDEFINED:
        -: 1239:        {
    #####: 1240:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1241:          continue;
        -: 1242:        }
        1: 1243:        case VM_OC_PUSH_TRUE:
        -: 1244:        {
        1: 1245:          *stack_top_p++ = ECMA_VALUE_TRUE;
        1: 1246:          continue;
        -: 1247:        }
    #####: 1248:        case VM_OC_PUSH_FALSE:
        -: 1249:        {
    #####: 1250:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1251:          continue;
        -: 1252:        }
        1: 1253:        case VM_OC_PUSH_NULL:
        -: 1254:        {
        1: 1255:          *stack_top_p++ = ECMA_VALUE_NULL;
        1: 1256:          continue;
        -: 1257:        }
    #####: 1258:        case VM_OC_PUSH_THIS:
        -: 1259:        {
    #####: 1260:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1261:          continue;
        -: 1262:        }
        1: 1263:        case VM_OC_PUSH_0:
        -: 1264:        {
        1: 1265:          *stack_top_p++ = ecma_make_integer_value (0);
        1: 1266:          continue;
        -: 1267:        }
    #####: 1268:        case VM_OC_PUSH_POS_BYTE:
        -: 1269:        {
    #####: 1270:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1271:          *stack_top_p++ = ecma_make_integer_value (number + 1);
    #####: 1272:          continue;
        -: 1273:        }
        1: 1274:        case VM_OC_PUSH_NEG_BYTE:
        -: 1275:        {
        1: 1276:          ecma_integer_value_t number = *byte_code_p++;
        1: 1277:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
        1: 1278:          continue;
        -: 1279:        }
    #####: 1280:        case VM_OC_PUSH_LIT_0:
        -: 1281:        {
    #####: 1282:          stack_top_p[0] = left_value;
    #####: 1283:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1284:          stack_top_p += 2;
    #####: 1285:          continue;
        -: 1286:        }
    #####: 1287:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1288:        {
    #####: 1289:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1290:          stack_top_p[0] = left_value;
    #####: 1291:          stack_top_p[1] = ecma_make_integer_value (number + 1);
    #####: 1292:          stack_top_p += 2;
    #####: 1293:          continue;
        -: 1294:        }
    #####: 1295:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1296:        {
    #####: 1297:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1298:          stack_top_p[0] = left_value;
    #####: 1299:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1300:          stack_top_p += 2;
    #####: 1301:          continue;
        -: 1302:        }
        1: 1303:        case VM_OC_PUSH_OBJECT:
        -: 1304:        {
        1: 1305:          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
        -: 1306:                                                     0,
        -: 1307:                                                     ECMA_OBJECT_TYPE_GENERAL);
        -: 1308:
        1: 1309:          *stack_top_p++ = ecma_make_object_value (obj_p);
        1: 1310:          continue;
        -: 1311:        }
    #####: 1312:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1313:        {
    #####: 1314:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1315:
    #####: 1316:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1317:
    #####: 1318:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1319:
    #####: 1320:          JERRY_ASSERT (frame_ctx_p->lex_env_p ==
        -: 1321:                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1322:
    #####: 1323:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1324:
    #####: 1325:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1326:
    #####: 1327:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1328:
    #####: 1329:          ecma_free_value (right_value);
    #####: 1330:          ecma_deref_object (name_lex_env);
    #####: 1331:          *stack_top_p++ = left_value;
    #####: 1332:          continue;
        -: 1333:        }
    #####: 1334:        case VM_OC_CREATE_BINDING:
        -: 1335:        {
        -: 1336:#if !JERRY_ESNEXT
        -: 1337:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1338:#endif /* !JERRY_ESNEXT */
        -: 1339:
        -: 1340:          uint32_t literal_index;
        -: 1341:
    #####: 1342:          READ_LITERAL_INDEX (literal_index);
        -: 1343:
    #####: 1344:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1345:
    #####: 1346:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1347:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1348:
    #####: 1349:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1350:
        -: 1351:#if JERRY_ESNEXT
    #####: 1352:          if (opcode == CBC_CREATE_LET)
        -: 1353:          {
    #####: 1354:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1355:          }
    #####: 1356:          else if (opcode == CBC_CREATE_CONST)
        -: 1357:          {
    #####: 1358:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1359:          }
        -: 1360:
        -: 1361:          ecma_property_value_t *property_value_p;
    #####: 1362:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1363:
    #####: 1364:          if (opcode != CBC_CREATE_VAR)
        -: 1365:          {
    #####: 1366:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1367:          }
        -: 1368:#else /* !JERRY_ESNEXT */
    #####: 1369:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1370:#endif /* JERRY_ESNEXT */
        -: 1371:
    #####: 1372:          continue;
        -: 1373:        }
        1: 1374:        case VM_OC_VAR_EVAL:
        -: 1375:        {
        -: 1376:          uint32_t literal_index;
        1: 1377:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1378:
        1: 1379:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1380:          {
        -: 1381:            uint32_t value_index;
        1: 1382:            READ_LITERAL_INDEX (value_index);
        1: 1383:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1384:
        1: 1385:            lit_value = vm_construct_literal_object (frame_ctx_p,
        1: 1386:                                                     literal_start_p[value_index]);
        -: 1387:          }
        -: 1388:
        1: 1389:          READ_LITERAL_INDEX (literal_index);
        1: 1390:          JERRY_ASSERT (literal_index >= register_end);
        -: 1391:
        1: 1392:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1393:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1394:
        2: 1395:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1396:          {
        -: 1397:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1398:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1399:            {
    #####: 1400:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1401:
    #####: 1402:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1403:            }
        -: 1404:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1405:
    #####: 1406:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1407:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1408:          }
        -: 1409:
        -: 1410:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
        1: 1411:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1412:          {
    #####: 1413:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1414:
    #####: 1415:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1416:          }
        -: 1417:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1418:
        -: 1419:          /* 'Variable declaration' */
        1: 1420:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1421:
        -: 1422:#if JERRY_BUILTIN_PROXY
        1: 1423:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1424:          {
    #####: 1425:            goto error;
        -: 1426:          }
        -: 1427:#endif /* JERRY_BUILTIN_PROXY */
        -: 1428:
        1: 1429:          ecma_property_t *prop_p = NULL;
        -: 1430:
        1: 1431:          if (ecma_is_value_false (result))
        -: 1432:          {
        1: 1433:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
        1: 1434:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1435:
        1: 1436:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1437:            {
    #####: 1438:              result = ECMA_VALUE_ERROR;
    #####: 1439:              goto error;
        -: 1440:            }
        -: 1441:          }
        -: 1442:
        1: 1443:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1444:          {
        1: 1445:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1446:
        1: 1447:            if (prop_p != NULL)
        -: 1448:            {
    #####: 1449:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1450:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1451:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1452:              ecma_free_object (lit_value);
        -: 1453:            }
        -: 1454:            else
        -: 1455:            {
        1: 1456:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
        1: 1457:              ecma_free_object (lit_value);
        -: 1458:
        1: 1459:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1460:              {
    #####: 1461:                goto error;
        -: 1462:              }
        -: 1463:            }
        -: 1464:          }
        1: 1465:          continue;
        -: 1466:        }
        -: 1467:#if JERRY_ESNEXT
    #####: 1468:        case VM_OC_EXT_VAR_EVAL:
        -: 1469:        {
        -: 1470:          uint32_t literal_index;
    #####: 1471:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1472:
    #####: 1473:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1474:
    #####: 1475:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1476:          {
        -: 1477:            uint32_t value_index;
    #####: 1478:            READ_LITERAL_INDEX (value_index);
    #####: 1479:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1480:
    #####: 1481:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1482:                                                     literal_start_p[value_index]);
        -: 1483:          }
        -: 1484:
    #####: 1485:          READ_LITERAL_INDEX (literal_index);
    #####: 1486:          JERRY_ASSERT (literal_index >= register_end);
        -: 1487:
    #####: 1488:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1489:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1490:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1491:
    #####: 1492:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1493:          {
        -: 1494:#if !(defined JERRY_NDEBUG)
    #####: 1495:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1496:            {
    #####: 1497:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1498:
    #####: 1499:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1500:            }
        -: 1501:#endif /* !JERRY_NDEBUG */
        -: 1502:
    #####: 1503:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1504:            prev_lex_env_p = lex_env_p;
    #####: 1505:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1506:          }
        -: 1507:
    #####: 1508:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1509:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1510:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1511:
    #####: 1512:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1513:          ecma_property_value_t *property_value_p;
        -: 1514:
    #####: 1515:          if (property_p == NULL)
        -: 1516:          {
    #####: 1517:            property_value_p = ecma_create_named_data_property (prev_lex_env_p,
        -: 1518:                                                                name_p,
        -: 1519:                                                                ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1520:                                                                NULL);
        -: 1521:
    #####: 1522:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1523:            {
    #####: 1524:              continue;
        -: 1525:            }
        -: 1526:          }
        -: 1527:          else
        -: 1528:          {
    #####: 1529:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1530:            {
    #####: 1531:              continue;
        -: 1532:            }
        -: 1533:
    #####: 1534:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1535:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1536:          }
        -: 1537:
    #####: 1538:          property_value_p->value = lit_value;
    #####: 1539:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1540:          continue;
        -: 1541:        }
        -: 1542:#endif /* JERRY_ESNEXT */
    #####: 1543:        case VM_OC_CREATE_ARGUMENTS:
        -: 1544:        {
        -: 1545:          uint32_t literal_index;
    #####: 1546:          READ_LITERAL_INDEX (literal_index);
        -: 1547:
    #####: 1548:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1549:
    #####: 1550:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1551:                                                    frame_ctx_p->lex_env_p);
        -: 1552:
    #####: 1553:          if (literal_index < register_end)
        -: 1554:          {
    #####: 1555:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1556:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1557:            continue;
        -: 1558:          }
        -: 1559:
    #####: 1560:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1561:
    #####: 1562:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1563:
    #####: 1564:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1565:          ecma_property_value_t *property_value_p;
        -: 1566:
    #####: 1567:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1568:          property_value_p->value = result;
        -: 1569:
    #####: 1570:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1571:          continue;
        -: 1572:        }
        -: 1573:#if JERRY_SNAPSHOT_EXEC
    #####: 1574:        case VM_OC_SET_BYTECODE_PTR:
        -: 1575:        {
    #####: 1576:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1577:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1578:          continue;
        -: 1579:        }
        -: 1580:#endif /* JERRY_SNAPSHOT_EXEC */
        1: 1581:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1582:        {
        -: 1583:          uint32_t literal_index, value_index;
        -: 1584:          ecma_value_t lit_value;
        1: 1585:          bool release = false;
        -: 1586:
        1: 1587:          READ_LITERAL_INDEX (value_index);
        -: 1588:
        1: 1589:          if (value_index < register_end)
        -: 1590:          {
        -: 1591:            /* Take (not copy) the reference. */
        1: 1592:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1593:          }
        -: 1594:          else
        -: 1595:          {
    #####: 1596:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1597:                                                     literal_start_p[value_index]);
    #####: 1598:            release = true;
        -: 1599:          }
        -: 1600:
        1: 1601:          READ_LITERAL_INDEX (literal_index);
        -: 1602:
        1: 1603:          JERRY_ASSERT (value_index != literal_index);
        1: 1604:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1605:
        1: 1606:          if (literal_index < register_end)
        -: 1607:          {
    #####: 1608:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1609:            JERRY_ASSERT (release);
    #####: 1610:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1611:            continue;
        -: 1612:          }
        -: 1613:
        1: 1614:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1615:
        1: 1616:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        1: 1617:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1618:
        -: 1619:          ecma_property_value_t *property_value_p;
        1: 1620:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1621:                                                              name_p,
        -: 1622:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1623:                                                              NULL);
        -: 1624:
        1: 1625:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        1: 1626:          property_value_p->value = lit_value;
        -: 1627:
        1: 1628:          if (release)
        -: 1629:          {
    #####: 1630:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1631:          }
        1: 1632:          continue;
        -: 1633:        }
        -: 1634:#if JERRY_ESNEXT
        1: 1635:        case VM_OC_CHECK_VAR:
        -: 1636:        {
        1: 1637:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1638:                        == CBC_FUNCTION_SCRIPT);
        -: 1639:
        -: 1640:          uint32_t literal_index;
        1: 1641:          READ_LITERAL_INDEX (literal_index);
        -: 1642:
        1: 1643:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1644:          {
        1: 1645:            continue;
        -: 1646:          }
        -: 1647:
    #####: 1648:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1649:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1650:
    #####: 1651:          if (binding_p != NULL)
        -: 1652:          {
    #####: 1653:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1654:            goto error;
        -: 1655:          }
        -: 1656:
    #####: 1657:          continue;
        -: 1658:        }
    #####: 1659:        case VM_OC_CHECK_LET:
        -: 1660:        {
    #####: 1661:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1662:                        == CBC_FUNCTION_SCRIPT);
        -: 1663:
        -: 1664:          uint32_t literal_index;
    #####: 1665:          READ_LITERAL_INDEX (literal_index);
        -: 1666:
    #####: 1667:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1668:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1669:
    #####: 1670:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1671:          {
    #####: 1672:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1673:
    #####: 1674:            if (!ecma_is_value_false (result))
        -: 1675:            {
    #####: 1676:              if (ecma_is_value_true (result))
        -: 1677:              {
    #####: 1678:                result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
        -: 1679:              }
        -: 1680:
    #####: 1681:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1682:              goto error;
        -: 1683:            }
        -: 1684:
    #####: 1685:            continue;
        -: 1686:          }
        -: 1687:
    #####: 1688:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1689:
        -: 1690:#if JERRY_BUILTIN_PROXY
    #####: 1691:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1692:          {
    #####: 1693:            goto error;
        -: 1694:          }
        -: 1695:#endif /* JERRY_BUILTIN_PROXY */
        -: 1696:
    #####: 1697:          if (ecma_is_value_true (result))
        -: 1698:          {
    #####: 1699:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1700:            goto error;
        -: 1701:          }
        -: 1702:
    #####: 1703:          continue;
        -: 1704:        }
    #####: 1705:        case VM_OC_ASSIGN_LET_CONST:
        -: 1706:        {
        -: 1707:          uint32_t literal_index;
    #####: 1708:          READ_LITERAL_INDEX (literal_index);
        -: 1709:
    #####: 1710:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1711:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1712:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1713:                            && (frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)));
        -: 1714:
    #####: 1715:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1716:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1717:
    #####: 1718:          JERRY_ASSERT (property_p != NULL
        -: 1719:                        && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1720:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
    #####: 1721:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1722:
    #####: 1723:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1724:
    #####: 1725:          if (ecma_is_value_object (left_value))
        -: 1726:          {
    #####: 1727:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1728:          }
    #####: 1729:          continue;
        -: 1730:        }
        1: 1731:        case VM_OC_INIT_BINDING:
        -: 1732:        {
        -: 1733:          uint32_t literal_index;
        -: 1734:
        1: 1735:          READ_LITERAL_INDEX (literal_index);
        -: 1736:
        1: 1737:          JERRY_ASSERT (literal_index >= register_end);
        -: 1738:
        1: 1739:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1740:
        1: 1741:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        1: 1742:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1743:
        1: 1744:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1745:
        1: 1746:          if (opcode == CBC_INIT_LET)
        -: 1747:          {
        1: 1748:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1749:          }
    #####: 1750:          else if (opcode == CBC_INIT_CONST)
        -: 1751:          {
    #####: 1752:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1753:          }
        -: 1754:
        -: 1755:          ecma_property_value_t *property_value_p;
        1: 1756:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1757:                                                              name_p,
        -: 1758:                                                              prop_attributes,
        -: 1759:                                                              NULL);
        -: 1760:
        1: 1761:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1762:
        1: 1763:          ecma_value_t value = *(--stack_top_p);
        -: 1764:
        1: 1765:          property_value_p->value = value;
        1: 1766:          ecma_deref_if_object (value);
        1: 1767:          continue;
        -: 1768:        }
    #####: 1769:        case VM_OC_THROW_CONST_ERROR:
        -: 1770:        {
    #####: 1771:          result = ecma_raise_type_error (ECMA_ERR_MSG ("Constant bindings cannot be reassigned"));
    #####: 1772:          goto error;
        -: 1773:        }
    #####: 1774:        case VM_OC_COPY_TO_GLOBAL:
        -: 1775:        {
        -: 1776:          uint32_t literal_index;
    #####: 1777:          READ_LITERAL_INDEX (literal_index);
        -: 1778:
    #####: 1779:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1780:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1781:
    #####: 1782:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1783:          {
        -: 1784:#ifndef JERRY_NDEBUG
    #####: 1785:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1786:            {
    #####: 1787:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1788:
    #####: 1789:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1790:            }
        -: 1791:#endif /* !JERRY_NDEBUG */
        -: 1792:
    #####: 1793:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1794:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1795:          }
        -: 1796:
    #####: 1797:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1798:          {
    #####: 1799:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1800:            ecma_property_value_t *prop_value_p;
        -: 1801:
    #####: 1802:            if (property_p == NULL)
        -: 1803:            {
    #####: 1804:              prop_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1805:                                                              name_p,
        -: 1806:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1807:                                                              NULL);
        -: 1808:            }
        -: 1809:            else
        -: 1810:            {
        -: 1811:#ifndef JERRY_NDEBUG
    #####: 1812:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1813:#endif /* !JERRY_NDEBUG */
    #####: 1814:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1815:            }
        -: 1816:
    #####: 1817:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1818:          }
        -: 1819:          else
        -: 1820:          {
    #####: 1821:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1822:
    #####: 1823:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1824:            {
    #####: 1825:              goto error;
        -: 1826:            }
        -: 1827:          }
        -: 1828:
    #####: 1829:          goto free_left_value;
        -: 1830:        }
    #####: 1831:        case VM_OC_COPY_FROM_ARG:
        -: 1832:        {
        -: 1833:          uint32_t literal_index;
    #####: 1834:          READ_LITERAL_INDEX (literal_index);
    #####: 1835:          JERRY_ASSERT (literal_index >= register_end);
        -: 1836:
    #####: 1837:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1838:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1839:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1840:
    #####: 1841:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1842:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1843:          JERRY_ASSERT (arg_lex_env_p != NULL
        -: 1844:                        && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1845:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1846:
        -: 1847:          ecma_property_value_t *property_value_p;
    #####: 1848:          property_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1849:                                                              name_p,
        -: 1850:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1851:                                                              NULL);
        -: 1852:
    #####: 1853:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1854:          JERRY_ASSERT (property_p != NULL);
        -: 1855:
    #####: 1856:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1857:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1858:          continue;
        -: 1859:        }
    #####: 1860:        case VM_OC_CLONE_CONTEXT:
        -: 1861:        {
    #####: 1862:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1863:
    #####: 1864:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1865:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1866:          continue;
        -: 1867:        }
    #####: 1868:        case VM_OC_SET__PROTO__:
        -: 1869:        {
    #####: 1870:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1871:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1872:          {
    #####: 1873:            goto error;
        -: 1874:          }
    #####: 1875:          goto free_left_value;
        -: 1876:        }
    #####: 1877:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1878:        {
    #####: 1879:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1880:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1881:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1882:
    #####: 1883:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1884:          ecma_value_t value = stack_top_p[-1];
        -: 1885:
    #####: 1886:          if (!push_computed)
        -: 1887:          {
    #####: 1888:            stack_top_p++;
        -: 1889:          }
        -: 1890:
    #####: 1891:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1892:          stack_top_p[-4] = left_value;
        -: 1893:
    #####: 1894:          if (!push_computed)
        -: 1895:          {
    #####: 1896:            continue;
        -: 1897:          }
        -: 1898:
    #####: 1899:          left_value = value;
        -: 1900:          /* FALLTHRU */
        -: 1901:        }
    #####: 1902:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1903:        {
    #####: 1904:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1905:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1906:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1907:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1908:
    #####: 1909:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1910:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1911:
    #####: 1912:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1913:          {
    #####: 1914:            goto error;
        -: 1915:          }
    #####: 1916:          goto free_left_value;
        -: 1917:        }
    #####: 1918:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1919:        {
    #####: 1920:          left_value = *(--stack_top_p);
        -: 1921:
    #####: 1922:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1923:          {
    #####: 1924:            continue;
        -: 1925:          }
        -: 1926:
    #####: 1927:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1928:
    #####: 1929:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1930:          {
    #####: 1931:            goto error;
        -: 1932:          }
        -: 1933:
    #####: 1934:          goto free_left_value;
        -: 1935:        }
    #####: 1936:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1937:        {
        -: 1938:          /* Swap values. */
    #####: 1939:          left_value ^= right_value;
    #####: 1940:          right_value ^= left_value;
    #####: 1941:          left_value ^= right_value;
        -: 1942:          /* FALLTHRU */
        -: 1943:        }
        -: 1944:#endif /* JERRY_ESNEXT */
        1: 1945:        case VM_OC_SET_PROPERTY:
        -: 1946:        {
        -: 1947:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1948:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1949:
        1: 1950:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1951:
        1: 1952:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1953:
        1: 1954:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1955:          {
    #####: 1956:            result = ECMA_VALUE_ERROR;
    #####: 1957:            goto error;
        -: 1958:          }
        -: 1959:
        -: 1960:#if JERRY_ESNEXT
        1: 1961:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1962:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1963:          {
    #####: 1964:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 1965:            goto error;
        -: 1966:          }
        -: 1967:
        1: 1968:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1969:#else /* !JERRY_ESNEXT */
    #####: 1970:          const int index = -1;
        -: 1971:#endif /* JERRY_ESNEXT */
        -: 1972:
        1: 1973:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1974:
        1: 1975:          opfunc_set_data_property (object_p, prop_name_p, left_value);
        1: 1976:          ecma_deref_ecma_string (prop_name_p);
        -: 1977:
        1: 1978:          goto free_both_values;
        -: 1979:        }
        3: 1980:        case VM_OC_SET_GETTER:
        -: 1981:        case VM_OC_SET_SETTER:
        -: 1982:        {
        3: 1983:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1984:
        3: 1985:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1986:
        3: 1987:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1988:          {
    #####: 1989:            result = ECMA_VALUE_ERROR;
    #####: 1990:            goto error;
        -: 1991:          }
        -: 1992:
        -: 1993:#if JERRY_ESNEXT
        3: 1994:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1995:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1996:          {
    #####: 1997:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 1998:            goto error;
        -: 1999:          }
        -: 2000:
        3: 2001:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 2002:#else /* !JERRY_ESNEXT */
    #####: 2003:          const int index = -1;
        -: 2004:#endif /* JERRY_ESNEXT */
        -: 2005:
        3: 2006:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
        3: 2007:                               stack_top_p[index],
        -: 2008:                               prop_name_p,
        -: 2009:                               right_value);
        -: 2010:
        3: 2011:          ecma_deref_ecma_string (prop_name_p);
        -: 2012:
        3: 2013:          goto free_both_values;
        -: 2014:        }
        1: 2015:        case VM_OC_PUSH_ARRAY:
        -: 2016:        {
        -: 2017:          /* Note: this operation cannot throw an exception */
        1: 2018:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
        1: 2019:          continue;
        -: 2020:        }
        -: 2021:#if JERRY_ESNEXT
    #####: 2022:        case VM_OC_LOCAL_EVAL:
        -: 2023:        {
    #####: 2024:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 2025:          uint8_t parse_opts = *byte_code_p++;
    #####: 2026:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 2027:          continue;
        -: 2028:        }
    #####: 2029:        case VM_OC_SUPER_CALL:
        -: 2030:        {
    #####: 2031:          uint8_t arguments_list_len = *byte_code_p++;
        -: 2032:
    #####: 2033:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 2034:          {
    #####: 2035:            stack_top_p -= arguments_list_len;
    #####: 2036:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2037:
    #####: 2038:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2039:            {
    #####: 2040:              result = ECMA_VALUE_ERROR;
    #####: 2041:              goto error;
        -: 2042:            }
        -: 2043:
    #####: 2044:            stack_top_p++;
    #####: 2045:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2046:          }
        -: 2047:          else
        -: 2048:          {
    #####: 2049:            stack_top_p -= arguments_list_len;
        -: 2050:          }
        -: 2051:
    #####: 2052:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 2053:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2054:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2055:          return ECMA_VALUE_UNDEFINED;
        -: 2056:        }
    #####: 2057:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 2058:        {
        -: 2059:          uint16_t literal_index;
        -: 2060:
    #####: 2061:          READ_LITERAL_INDEX (literal_index);
    #####: 2062:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
    #####: 2063:          continue;
        -: 2064:        }
    #####: 2065:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2066:        {
    #####: 2067:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode,
    #####: 2068:                                                                     frame_ctx_p->shared_p->bytecode_header_p);
    #####: 2069:          continue;
        -: 2070:        }
    #####: 2071:        case VM_OC_INIT_CLASS:
        -: 2072:        {
    #####: 2073:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2074:
    #####: 2075:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2076:          {
    #####: 2077:            goto error;
        -: 2078:          }
    #####: 2079:          continue;
        -: 2080:        }
    #####: 2081:        case VM_OC_FINALIZE_CLASS:
        -: 2082:        {
    #####: 2083:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2084:
    #####: 2085:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2086:          {
        -: 2087:            uint16_t literal_index;
    #####: 2088:            READ_LITERAL_INDEX (literal_index);
    #####: 2089:            left_value = literal_start_p[literal_index];
        -: 2090:          }
        -: 2091:
    #####: 2092:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 2093:          continue;
        -: 2094:        }
    #####: 2095:        case VM_OC_SET_FIELD_INIT:
        -: 2096:        {
    #####: 2097:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2098:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-2]);
        -: 2099:
    #####: 2100:          ecma_property_value_t *property_value_p = ecma_create_named_data_property (object_p,
        -: 2101:                                                                                     property_name_p,
        -: 2102:                                                                                     ECMA_PROPERTY_FIXED,
        -: 2103:                                                                                     NULL);
    #####: 2104:          property_value_p->value = left_value;
        -: 2105:
    #####: 2106:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2107:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 2108:
    #####: 2109:          if (property_p != NULL)
        -: 2110:          {
    #####: 2111:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2112:            ecma_value_t *compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t,
        -: 2113:                                                                                  property_value_p->value);
    #####: 2114:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2115:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2116:          }
        -: 2117:
    #####: 2118:          goto free_left_value;
        -: 2119:        }
    #####: 2120:        case VM_OC_RUN_FIELD_INIT:
        -: 2121:        {
    #####: 2122:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2123:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2124:
    #####: 2125:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2126:          {
    #####: 2127:            goto error;
        -: 2128:          }
    #####: 2129:          continue;
        -: 2130:        }
    #####: 2131:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2132:        {
    #####: 2133:          left_value = stack_top_p[-2];
    #####: 2134:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2135:          stack_top_p--;
        -: 2136:
    #####: 2137:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2138:
    #####: 2139:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2140:          {
    #####: 2141:            goto error;
        -: 2142:          }
    #####: 2143:          goto free_left_value;
        -: 2144:        }
    #####: 2145:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2146:        {
    #####: 2147:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2148:          stack_top_p[-2] = ecma_make_integer_value (next_index);
    #####: 2149:          stack_top_p++;
        -: 2150:
    #####: 2151:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2152:
    #####: 2153:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2154:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
        -: 2155:
    #####: 2156:          result = stack_top_p[-2];
    #####: 2157:          stack_top_p[-1] = ecma_copy_value (computed_class_fields_p[next_index]);
    #####: 2158:          stack_top_p[-2] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2159:          break;
        -: 2160:        }
    #####: 2161:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2162:        {
    #####: 2163:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2164:
    #####: 2165:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2166:          {
    #####: 2167:            goto error;
        -: 2168:          }
        -: 2169:
    #####: 2170:          *stack_top_p++ = result;
    #####: 2171:          continue;
        -: 2172:        }
    #####: 2173:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2174:        {
    #####: 2175:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2176:
    #####: 2177:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2178:          {
    #####: 2179:            goto error;
        -: 2180:          }
        -: 2181:
    #####: 2182:          *stack_top_p++ = result;
    #####: 2183:          continue;
        -: 2184:        }
    #####: 2185:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2186:        {
    #####: 2187:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2188:          {
    #####: 2189:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2190:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2191:
    #####: 2192:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2193:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2194:            *stack_top_p++ = obj_value;
        -: 2195:          }
        -: 2196:          else
        -: 2197:          {
    #####: 2198:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2199:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2200:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2201:            stack_top_p--;
        -: 2202:          }
    #####: 2203:          continue;
        -: 2204:        }
    #####: 2205:        case VM_OC_SET_HOME_OBJECT:
        -: 2206:        {
    #####: 2207:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2208:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2209:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2210:          continue;
        -: 2211:        }
    #####: 2212:        case VM_OC_SUPER_REFERENCE:
        -: 2213:        {
    #####: 2214:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2215:
    #####: 2216:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2217:          {
    #####: 2218:            goto error;
        -: 2219:          }
        -: 2220:
    #####: 2221:          goto free_left_value;
        -: 2222:        }
    #####: 2223:        case VM_OC_SET_FUNCTION_NAME:
        -: 2224:        {
    #####: 2225:          char *prefix_p = NULL;
    #####: 2226:          lit_utf8_size_t prefix_size = 0;
        -: 2227:
    #####: 2228:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2229:          {
        -: 2230:            ecma_value_t prop_name_value;
        -: 2231:
    #####: 2232:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2233:            {
        -: 2234:              uint16_t literal_index;
    #####: 2235:              READ_LITERAL_INDEX (literal_index);
    #####: 2236:              prop_name_value = literal_start_p[literal_index];
        -: 2237:            }
        -: 2238:            else
        -: 2239:            {
    #####: 2240:              prop_name_value = stack_top_p[-2];
        -: 2241:            }
        -: 2242:
    #####: 2243:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2244:
    #####: 2245:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2246:            {
    #####: 2247:              result = ECMA_VALUE_ERROR;
    #####: 2248:              goto error;
        -: 2249:            }
        -: 2250:
    #####: 2251:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2252:
    #####: 2253:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2254:            {
    #####: 2255:              ecma_ref_ecma_string (prop_name_p);
    #####: 2256:              ecma_free_value (stack_top_p[-2]);
    #####: 2257:              stack_top_p[-2] = left_value;
        -: 2258:            }
        -: 2259:
    #####: 2260:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2261:            {
    #####: 2262:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2263:              prefix_size = 4;
        -: 2264:            }
        -: 2265:          }
        -: 2266:
    #####: 2267:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2268:
    #####: 2269:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2270:          {
    #####: 2271:            ecma_free_value (left_value);
    #####: 2272:            continue;
        -: 2273:          }
        -: 2274:
        -: 2275:          ecma_property_value_t *value_p;
    #####: 2276:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2277:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2278:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2279:                                                     NULL);
        -: 2280:
    #####: 2281:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2282:          {
    #####: 2283:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2284:          }
        -: 2285:
    #####: 2286:          value_p->value = ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value),
        -: 2287:                                                       prefix_p,
        -: 2288:                                                       prefix_size);
    #####: 2289:          ecma_free_value (left_value);
    #####: 2290:          continue;
        -: 2291:        }
    #####: 2292:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2293:        {
    #####: 2294:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2295:          continue;
        -: 2296:        }
    #####: 2297:        case VM_OC_PUSH_REST_OBJECT:
        -: 2298:        {
    #####: 2299:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2300:
    #####: 2301:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2302:
    #####: 2303:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2304:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2305:          uint16_t argument_end;
        -: 2306:
    #####: 2307:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2308:          {
    #####: 2309:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2310:          }
        -: 2311:          else
        -: 2312:          {
    #####: 2313:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2314:          }
        -: 2315:
    #####: 2316:          if (arg_list_len < argument_end)
        -: 2317:          {
    #####: 2318:            arg_list_len = argument_end;
        -: 2319:          }
        -: 2320:
    #####: 2321:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end,
        -: 2322:                                                         arg_list_len - argument_end);
        -: 2323:
    #####: 2324:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2325:          *stack_top_p++ = result;
    #####: 2326:          continue;
        -: 2327:        }
    #####: 2328:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2329:        {
    #####: 2330:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2331:
    #####: 2332:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2333:          {
    #####: 2334:            goto error;
        -: 2335:          }
        -: 2336:
    #####: 2337:          uint32_t context_size = (uint32_t) (stack_top_p
    #####: 2338:                                              + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION
    #####: 2339:                                              - VM_LAST_CONTEXT_END ());
    #####: 2340:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2341:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2342:
    #####: 2343:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2344:          stack_top_p[-2] = result;
    #####: 2345:          stack_top_p[-3] = left_value;
        -: 2346:
    #####: 2347:          continue;
        -: 2348:        }
    #####: 2349:        case VM_OC_ITERATOR_STEP:
        -: 2350:        {
    #####: 2351:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2352:
    #####: 2353:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2354:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2355:
    #####: 2356:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2357:
    #####: 2358:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2359:          {
    #####: 2360:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2361:            goto error;
        -: 2362:          }
        -: 2363:
    #####: 2364:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2365:
    #####: 2366:          if (!ecma_is_value_false (result))
        -: 2367:          {
    #####: 2368:            value = ecma_op_iterator_value (result);
    #####: 2369:            ecma_free_value (result);
        -: 2370:
    #####: 2371:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2372:            {
    #####: 2373:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2374:              result = value;
    #####: 2375:              goto error;
        -: 2376:            }
        -: 2377:          }
        -: 2378:          else
        -: 2379:          {
    #####: 2380:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2381:          }
        -: 2382:
    #####: 2383:          *stack_top_p++ = value;
    #####: 2384:          continue;
        -: 2385:        }
    #####: 2386:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2387:        {
    #####: 2388:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2389:
    #####: 2390:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2391:          {
    #####: 2392:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2393:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2394:
    #####: 2395:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2396:            {
    #####: 2397:              goto error;
        -: 2398:            }
        -: 2399:          }
        -: 2400:
    #####: 2401:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2402:                                                                stack_top_p,
        -: 2403:                                                                PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2404:          continue;
        -: 2405:        }
    #####: 2406:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2407:        {
    #####: 2408:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2409:
    #####: 2410:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2411:          {
    #####: 2412:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2413:            continue;
        -: 2414:          }
        -: 2415:
    #####: 2416:          stack_top_p--;
    #####: 2417:          continue;
        -: 2418:        }
    #####: 2419:        case VM_OC_REST_INITIALIZER:
        -: 2420:        {
    #####: 2421:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2422:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2423:
    #####: 2424:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2425:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2426:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2427:          uint32_t index = 0;
        -: 2428:
        -: 2429:          while (true)
    #####: 2430:          {
    #####: 2431:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2432:
    #####: 2433:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2434:            {
    #####: 2435:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2436:              ecma_deref_object (array_p);
    #####: 2437:              goto error;
        -: 2438:            }
        -: 2439:
    #####: 2440:            if (ecma_is_value_false (result))
        -: 2441:            {
    #####: 2442:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2443:              break;
        -: 2444:            }
        -: 2445:
    #####: 2446:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2447:            ecma_free_value (result);
        -: 2448:
    #####: 2449:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2450:            {
    #####: 2451:              ecma_deref_object (array_p);
    #####: 2452:              result = value;
    #####: 2453:              goto error;
        -: 2454:            }
        -: 2455:
    #####: 2456:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2457:            JERRY_ASSERT (set_result);
    #####: 2458:            ecma_free_value (value);
        -: 2459:          }
        -: 2460:
    #####: 2461:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2462:          continue;
        -: 2463:        }
    #####: 2464:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2465:        {
    #####: 2466:          left_value = stack_top_p[-1];
    #####: 2467:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2468:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2469:
    #####: 2470:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2471:          {
    #####: 2472:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2473:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2474:          }
        -: 2475:
    #####: 2476:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2477:          stack_top_p += context_stack_allocation;
    #####: 2478:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2479:
    #####: 2480:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2481:          stack_top_p[-2] = left_value;
        -: 2482:
    #####: 2483:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2484:          {
    #####: 2485:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2486:          }
    #####: 2487:          continue;
        -: 2488:        }
    #####: 2489:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2490:        {
    #####: 2491:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2492:
    #####: 2493:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2494:
    #####: 2495:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2496:          {
    #####: 2497:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2498:          }
        -: 2499:
    #####: 2500:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2501:                                                                stack_top_p,
        -: 2502:                                                                context_stack_allocation);
    #####: 2503:          continue;
        -: 2504:        }
    #####: 2505:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2506:        {
    #####: 2507:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2508:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2509:          {
    #####: 2510:            result = ECMA_VALUE_ERROR;
    #####: 2511:            goto error;
        -: 2512:          }
        -: 2513:
    #####: 2514:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2515:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2516:
    #####: 2517:          left_value = ecma_make_object_value (result_object_p);
    #####: 2518:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2519:
    #####: 2520:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2521:          {
    #####: 2522:            goto error;
        -: 2523:          }
        -: 2524:
    #####: 2525:          ecma_free_value (last_context_end_p[-3]);
    #####: 2526:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2527:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2528:
    #####: 2529:          *stack_top_p++ = left_value;
    #####: 2530:          continue;
        -: 2531:        }
    #####: 2532:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2533:        {
    #####: 2534:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2535:          {
    #####: 2536:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2537:
    #####: 2538:            if (property_key == NULL)
        -: 2539:            {
    #####: 2540:              result = ECMA_VALUE_ERROR;
    #####: 2541:              goto error;
        -: 2542:            }
        -: 2543:
    #####: 2544:            ecma_free_value (left_value);
    #####: 2545:            left_value = ecma_make_string_value (property_key);
        -: 2546:          }
        -: 2547:
    #####: 2548:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2549:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2550:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2551:
    #####: 2552:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2553:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2554:          /* FALLTHRU */
        -: 2555:        }
    #####: 2556:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2557:        {
    #####: 2558:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2559:          ecma_value_t base = last_context_end_p[-2];
        -: 2560:
    #####: 2561:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2562:          {
    #####: 2563:            left_value = *last_context_end_p++;
    #####: 2564:            while (last_context_end_p < stack_top_p)
        -: 2565:            {
    #####: 2566:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2567:              last_context_end_p++;
        -: 2568:            }
    #####: 2569:            stack_top_p--;
        -: 2570:          }
        -: 2571:
    #####: 2572:          result = vm_op_get_value (base, left_value);
        -: 2573:
    #####: 2574:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2575:          {
    #####: 2576:            goto error;
        -: 2577:          }
        -: 2578:
    #####: 2579:          *stack_top_p++ = result;
    #####: 2580:          goto free_left_value;
        -: 2581:        }
    #####: 2582:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2583:        {
    #####: 2584:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2585:          stack_top_p -= arguments_list_len;
        -: 2586:
    #####: 2587:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2588:
    #####: 2589:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2590:          {
    #####: 2591:            result = ECMA_VALUE_ERROR;
    #####: 2592:            goto error;
        -: 2593:          }
        -: 2594:
    #####: 2595:          stack_top_p++;
    #####: 2596:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2597:
    #####: 2598:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2599:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2600:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2601:          return ECMA_VALUE_UNDEFINED;
        -: 2602:        }
    #####: 2603:        case VM_OC_CREATE_GENERATOR:
        -: 2604:        {
    #####: 2605:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2606:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2607:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2608:
        -: 2609:          vm_executable_object_t *executable_object_p;
    #####: 2610:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2611:
    #####: 2612:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2613:        }
    #####: 2614:        case VM_OC_YIELD:
        -: 2615:        {
    #####: 2616:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2617:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2618:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2619:          return *stack_top_p;
        -: 2620:        }
    #####: 2621:        case VM_OC_ASYNC_YIELD:
        -: 2622:        {
    #####: 2623:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2624:
    #####: 2625:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2626:
    #####: 2627:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2628:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2629:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2630:          return ECMA_VALUE_UNDEFINED;
        -: 2631:        }
    #####: 2632:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2633:        {
    #####: 2634:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2635:
    #####: 2636:          JERRY_ASSERT (!(async_generator_object_p->u.cls.u2.executable_obj_flags
        -: 2637:                          & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2638:
        -: 2639:          /* Byte code is executed at the first time. */
    #####: 2640:          left_value = stack_top_p[-1];
    #####: 2641:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2642:
    #####: 2643:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2644:          {
    #####: 2645:            goto error;
        -: 2646:          }
        -: 2647:
    #####: 2648:          ecma_free_value (left_value);
    #####: 2649:          left_value = result;
    #####: 2650:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2651:
    #####: 2652:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2653:          {
    #####: 2654:            goto error;
        -: 2655:          }
        -: 2656:
    #####: 2657:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2658:
    #####: 2659:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2660:          {
    #####: 2661:            goto error;
        -: 2662:          }
        -: 2663:
    #####: 2664:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2665:          frame_ctx_p->block_result = left_value;
        -: 2666:
    #####: 2667:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2668:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2669:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2670:          return ECMA_VALUE_UNDEFINED;
        -: 2671:        }
    #####: 2672:        case VM_OC_AWAIT:
        -: 2673:        {
    #####: 2674:          if (JERRY_UNLIKELY (frame_ctx_p->block_result == ECMA_VALUE_UNDEFINED))
        -: 2675:          {
    #####: 2676:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2677:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2678:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2679:
    #####: 2680:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2681:
    #####: 2682:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2683:            {
    #####: 2684:              goto error;
        -: 2685:            }
    #####: 2686:            return result;
        -: 2687:          }
        -: 2688:          /* FALLTHRU */
        -: 2689:        }
        -: 2690:        case VM_OC_GENERATOR_AWAIT:
        -: 2691:        {
    #####: 2692:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2693:
    #####: 2694:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2695:
    #####: 2696:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2697:          {
    #####: 2698:            goto error;
        -: 2699:          }
        -: 2700:
    #####: 2701:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2702:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2703:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2704:          return ECMA_VALUE_UNDEFINED;
        -: 2705:        }
    #####: 2706:        case VM_OC_EXT_RETURN:
        -: 2707:        {
    #####: 2708:          result = left_value;
    #####: 2709:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2710:
    #####: 2711:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2712:
    #####: 2713:          while (stack_top_p > stack_bottom_p)
        -: 2714:          {
    #####: 2715:            ecma_fast_free_value (*(--stack_top_p));
        -: 2716:          }
        -: 2717:
    #####: 2718:          goto error;
        -: 2719:        }
    #####: 2720:        case VM_OC_ASYNC_EXIT:
        -: 2721:        {
    #####: 2722:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2723:
    #####: 2724:          result = frame_ctx_p->block_result;
    #####: 2725:          frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 2726:
    #####: 2727:          if (result == ECMA_VALUE_UNDEFINED)
        -: 2728:          {
    #####: 2729:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2730:          }
        -: 2731:
    #####: 2732:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2733:
    #####: 2734:          if (context_type == VM_CONTEXT_TRY)
        -: 2735:          {
    #####: 2736:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2737:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2738:          }
        -: 2739:          else
        -: 2740:          {
    #####: 2741:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2742:            left_value = stack_top_p[-2];
        -: 2743:          }
        -: 2744:
    #####: 2745:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2746:          {
    #####: 2747:            ecma_reject_promise (result, left_value);
        -: 2748:          }
        -: 2749:          else
        -: 2750:          {
    #####: 2751:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2752:            ecma_fulfill_promise (result, left_value);
        -: 2753:          }
        -: 2754:
    #####: 2755:          ecma_free_value (left_value);
        -: 2756:
    #####: 2757:          frame_ctx_p->context_depth = 0;
    #####: 2758:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2759:          return result;
        -: 2760:        }
    #####: 2761:        case VM_OC_STRING_CONCAT:
        -: 2762:        {
    #####: 2763:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2764:
    #####: 2765:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2766:          {
    #####: 2767:            result = ECMA_VALUE_ERROR;
    #####: 2768:            goto error;
        -: 2769:          }
    #####: 2770:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2771:
    #####: 2772:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2773:          {
    #####: 2774:            ecma_deref_ecma_string (left_str_p);
    #####: 2775:            result = ECMA_VALUE_ERROR;
    #####: 2776:            goto error;
        -: 2777:          }
        -: 2778:
    #####: 2779:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2780:          ecma_deref_ecma_string (right_str_p);
        -: 2781:
    #####: 2782:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2783:          goto free_both_values;
        -: 2784:        }
    #####: 2785:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2786:        {
    #####: 2787:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2788:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2789:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2790:
    #####: 2791:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2792:          continue;
        -: 2793:        }
    #####: 2794:        case VM_OC_PUSH_NEW_TARGET:
        -: 2795:        {
    #####: 2796:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2797:          if (new_target_object_p == NULL)
        -: 2798:          {
    #####: 2799:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2800:          }
        -: 2801:          else
        -: 2802:          {
    #####: 2803:            ecma_ref_object (new_target_object_p);
    #####: 2804:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2805:          }
    #####: 2806:          continue;
        -: 2807:        }
    #####: 2808:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2809:        {
    #####: 2810:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2811:          {
    #####: 2812:            result = ECMA_VALUE_ERROR;
    #####: 2813:            goto error;
        -: 2814:          }
    #####: 2815:          continue;
        -: 2816:        }
    #####: 2817:        case VM_OC_ASSIGN_SUPER:
        -: 2818:        {
    #####: 2819:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2820:
    #####: 2821:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2822:          {
    #####: 2823:            goto error;
        -: 2824:          }
    #####: 2825:          continue;
        -: 2826:        }
        -: 2827:#endif /* JERRY_ESNEXT */
    #####: 2828:        case VM_OC_PUSH_ELISON:
        -: 2829:        {
    #####: 2830:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2831:          continue;
        -: 2832:        }
        1: 2833:        case VM_OC_APPEND_ARRAY:
        -: 2834:        {
        1: 2835:          uint16_t values_length = *byte_code_p++;
        1: 2836:          stack_top_p -= values_length;
        -: 2837:
        -: 2838:#if JERRY_ESNEXT
        1: 2839:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2840:          {
    #####: 2841:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2842:          }
        -: 2843:#endif /* JERRY_ESNEXT */
        1: 2844:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2845:
        -: 2846:#if JERRY_ESNEXT
        1: 2847:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2848:          {
    #####: 2849:            goto error;
        -: 2850:          }
        -: 2851:#else /* !JERRY_ESNEXT */
        -: 2852:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2853:#endif /* JERRY_ESNEXT */
        1: 2854:          continue;
        -: 2855:        }
    #####: 2856:        case VM_OC_IDENT_REFERENCE:
        -: 2857:        {
        -: 2858:          uint16_t literal_index;
        -: 2859:
    #####: 2860:          READ_LITERAL_INDEX (literal_index);
        -: 2861:
    #####: 2862:          JERRY_ASSERT (literal_index < ident_end);
        -: 2863:
    #####: 2864:          if (literal_index < register_end)
        -: 2865:          {
    #####: 2866:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2867:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2868:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2869:          }
        -: 2870:          else
        -: 2871:          {
    #####: 2872:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2873:
    #####: 2874:            ecma_object_t *ref_base_lex_env_p;
        -: 2875:
    #####: 2876:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 2877:                                                     &ref_base_lex_env_p,
        -: 2878:                                                     name_p);
        -: 2879:
    #####: 2880:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2881:            {
    #####: 2882:              goto error;
        -: 2883:            }
        -: 2884:
    #####: 2885:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2886:            ecma_ref_ecma_string (name_p);
    #####: 2887:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2888:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2889:            *stack_top_p++ = result;
        -: 2890:          }
    #####: 2891:          continue;
        -: 2892:        }
        3: 2893:        case VM_OC_PROP_GET:
        -: 2894:        {
        3: 2895:          result = vm_op_get_value (left_value, right_value);
        -: 2896:
        3: 2897:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2898:          {
    #####: 2899:            goto error;
        -: 2900:          }
        -: 2901:
        3: 2902:          *stack_top_p++ = result;
        3: 2903:          goto free_both_values;
        -: 2904:        }
        1: 2905:        case VM_OC_PROP_REFERENCE:
        -: 2906:        {
        -: 2907:          /* Forms with reference requires preserving the base and offset. */
        -: 2908:
        1: 2909:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2910:          {
    #####: 2911:            left_value = stack_top_p[-2];
    #####: 2912:            right_value = stack_top_p[-1];
        -: 2913:          }
        1: 2914:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2915:          {
        1: 2916:            *stack_top_p++ = left_value;
        1: 2917:            right_value = left_value;
        1: 2918:            left_value = stack_top_p[-2];
        -: 2919:          }
        -: 2920:          else
        -: 2921:          {
    #####: 2922:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2923:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
    #####: 2924:            *stack_top_p++ = left_value;
    #####: 2925:            *stack_top_p++ = right_value;
        -: 2926:          }
        -: 2927:          /* FALLTHRU */
        -: 2928:        }
        -: 2929:        case VM_OC_PROP_PRE_INCR:
        -: 2930:        case VM_OC_PROP_PRE_DECR:
        -: 2931:        case VM_OC_PROP_POST_INCR:
        -: 2932:        case VM_OC_PROP_POST_DECR:
        -: 2933:        {
        1: 2934:          result = vm_op_get_value (left_value,
        -: 2935:                                    right_value);
        -: 2936:
        1: 2937:          if (opcode < CBC_PRE_INCR)
        -: 2938:          {
        1: 2939:            left_value = ECMA_VALUE_UNDEFINED;
        1: 2940:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2941:          }
        -: 2942:
        1: 2943:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2944:          {
    #####: 2945:            goto error;
        -: 2946:          }
        -: 2947:
        1: 2948:          if (opcode < CBC_PRE_INCR)
        -: 2949:          {
        1: 2950:            break;
        -: 2951:          }
        -: 2952:
    #####: 2953:          stack_top_p += 2;
    #####: 2954:          left_value = result;
    #####: 2955:          right_value = ECMA_VALUE_UNDEFINED;
        -: 2956:          /* FALLTHRU */
        -: 2957:        }
        2: 2958:        case VM_OC_PRE_INCR:
        -: 2959:        case VM_OC_PRE_DECR:
        -: 2960:        case VM_OC_POST_INCR:
        -: 2961:        case VM_OC_POST_DECR:
        -: 2962:        {
        2: 2963:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
        2: 2964:          ecma_number_t result_number;
        -: 2965:
        2: 2966:          byte_code_p = byte_code_start_p + 1;
        -: 2967:
        2: 2968:          if (ecma_is_value_integer_number (left_value))
        -: 2969:          {
        2: 2970:            result = left_value;
        2: 2971:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2972:
        2: 2973:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
        2: 2974:            ecma_integer_value_t int_increase = 0;
        -: 2975:
        2: 2976:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 2977:            {
    #####: 2978:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 2979:              {
    #####: 2980:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 2981:              }
        -: 2982:            }
        2: 2983:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 2984:            {
        2: 2985:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 2986:            }
        -: 2987:
        2: 2988:            if (JERRY_LIKELY (int_increase != 0))
        -: 2989:            {
        -: 2990:              /* Postfix operators require the unmodifed number value. */
        2: 2991:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 2992:              {
        2: 2993:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 2994:              }
        -: 2995:
        2: 2996:              result = (ecma_value_t) (int_value + int_increase);
        2: 2997:              break;
        -: 2998:            }
    #####: 2999:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3000:          }
    #####: 3001:          else if (ecma_is_value_float_number (left_value))
        -: 3002:          {
    #####: 3003:            result = left_value;
    #####: 3004:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3005:            result_number = ecma_get_number_from_value (result);
        -: 3006:          }
        -: 3007:          else
        -: 3008:          {
    #####: 3009:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3010:
    #####: 3011:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3012:            {
    #####: 3013:              goto error;
        -: 3014:            }
        -: 3015:
    #####: 3016:            ecma_free_value (left_value);
    #####: 3017:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3018:
        -: 3019:#if JERRY_BUILTIN_BIGINT
    #####: 3020:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3021:            {
    #####: 3022:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3023:
    #####: 3024:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3025:              {
    #####: 3026:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3027:              }
        -: 3028:
        -: 3029:              /* Postfix operators require the unmodifed number value. */
    #####: 3030:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3031:              {
    #####: 3032:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3033:
    #####: 3034:                result = ecma_bigint_unary (result, operation_type);
        -: 3035:              }
        -: 3036:              else
        -: 3037:              {
    #####: 3038:                ecma_value_t original_value = result;
    #####: 3039:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3040:                ecma_free_value (original_value);
        -: 3041:              }
        -: 3042:
    #####: 3043:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3044:              {
    #####: 3045:                goto error;
        -: 3046:              }
    #####: 3047:              break;
        -: 3048:            }
        -: 3049:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3050:
    #####: 3051:            result = ecma_make_number_value (result_number);
        -: 3052:          }
        -: 3053:
    #####: 3054:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3055:
    #####: 3056:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3057:          {
        -: 3058:            /* For decrement operators */
    #####: 3059:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3060:          }
        -: 3061:
        -: 3062:          /* Postfix operators require the unmodifed number value. */
    #####: 3063:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3064:          {
    #####: 3065:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3066:
    #####: 3067:            result = ecma_make_number_value (result_number + increase);
    #####: 3068:            break;
        -: 3069:          }
        -: 3070:
    #####: 3071:          if (ecma_is_value_integer_number (result))
        -: 3072:          {
    #####: 3073:            result = ecma_make_number_value (result_number + increase);
        -: 3074:          }
        -: 3075:          else
        -: 3076:          {
    #####: 3077:            result = ecma_update_float_number (result, result_number + increase);
        -: 3078:          }
    #####: 3079:          break;
        -: 3080:        }
    #####: 3081:        case VM_OC_ASSIGN:
        -: 3082:        {
    #####: 3083:          result = left_value;
    #####: 3084:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3085:          break;
        -: 3086:        }
        2: 3087:        case VM_OC_MOV_IDENT:
        -: 3088:        {
        -: 3089:          uint32_t literal_index;
        -: 3090:
        2: 3091:          READ_LITERAL_INDEX (literal_index);
        -: 3092:
        2: 3093:          JERRY_ASSERT (literal_index < register_end);
        2: 3094:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3095:
        2: 3096:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        2: 3097:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
        2: 3098:          continue;
        -: 3099:        }
    #####: 3100:        case VM_OC_ASSIGN_PROP:
        -: 3101:        {
    #####: 3102:          result = stack_top_p[-1];
    #####: 3103:          stack_top_p[-1] = left_value;
    #####: 3104:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3105:          break;
        -: 3106:        }
    #####: 3107:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3108:        {
    #####: 3109:          result = stack_top_p[-1];
    #####: 3110:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 3111:          *stack_top_p++ = left_value;
    #####: 3112:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3113:          break;
        -: 3114:        }
        8: 3115:        case VM_OC_RETURN:
        -: 3116:        {
        8: 3117:          JERRY_ASSERT (opcode == CBC_RETURN
        -: 3118:                        || opcode == CBC_RETURN_WITH_BLOCK
        -: 3119:                        || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3120:
        8: 3121:          if (opcode == CBC_RETURN_WITH_BLOCK)
        -: 3122:          {
        4: 3123:            left_value = frame_ctx_p->block_result;
        4: 3124:            frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 3125:          }
        -: 3126:
        8: 3127:          result = left_value;
        8: 3128:          left_value = ECMA_VALUE_UNDEFINED;
        8: 3129:          goto error;
        -: 3130:        }
    #####: 3131:        case VM_OC_THROW:
        -: 3132:        {
    #####: 3133:          jcontext_raise_exception (left_value);
        -: 3134:
    #####: 3135:          result = ECMA_VALUE_ERROR;
    #####: 3136:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3137:          goto error;
        -: 3138:        }
    #####: 3139:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3140:        {
    #####: 3141:          result = ecma_raise_reference_error (ECMA_ERR_MSG ("Undefined reference"));
    #####: 3142:          goto error;
        -: 3143:        }
    #####: 3144:        case VM_OC_EVAL:
        -: 3145:        {
    #####: 3146:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3147:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3148:                        || (*byte_code_p == CBC_EXT_OPCODE
        -: 3149:                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3150:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3151:          continue;
        -: 3152:        }
        2: 3153:        case VM_OC_CALL:
        -: 3154:        {
        2: 3155:          frame_ctx_p->call_operation = VM_EXEC_CALL;
        2: 3156:          frame_ctx_p->byte_code_p = byte_code_start_p;
        2: 3157:          frame_ctx_p->stack_top_p = stack_top_p;
        2: 3158:          return ECMA_VALUE_UNDEFINED;
        -: 3159:        }
    #####: 3160:        case VM_OC_NEW:
        -: 3161:        {
    #####: 3162:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
    #####: 3163:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 3164:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 3165:          return ECMA_VALUE_UNDEFINED;
        -: 3166:        }
    #####: 3167:        case VM_OC_ERROR:
        -: 3168:        {
    #####: 3169:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3170:#if JERRY_DEBUGGER
        -: 3171:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3172:#endif /* JERRY_DEBUGGER */
        -: 3173:
    #####: 3174:          result = ECMA_VALUE_ERROR;
    #####: 3175:          goto error;
        -: 3176:        }
    #####: 3177:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3178:        {
    #####: 3179:          ecma_value_t this_value = stack_top_p[-3];
        -: 3180:
    #####: 3181:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3182:          {
        -: 3183:            /* Lexical environment cannot be 'this' value. */
    #####: 3184:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3185:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3186:          }
    #####: 3187:          else if (vm_get_implicit_this_value (&this_value))
        -: 3188:          {
    #####: 3189:            ecma_free_value (stack_top_p[-3]);
    #####: 3190:            stack_top_p[-3] = this_value;
        -: 3191:          }
        -: 3192:
    #####: 3193:          continue;
        -: 3194:        }
    #####: 3195:        case VM_OC_PROP_DELETE:
        -: 3196:        {
    #####: 3197:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3198:
    #####: 3199:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3200:          {
    #####: 3201:            goto error;
        -: 3202:          }
        -: 3203:
    #####: 3204:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3205:
    #####: 3206:          *stack_top_p++ = result;
    #####: 3207:          goto free_both_values;
        -: 3208:        }
    #####: 3209:        case VM_OC_DELETE:
        -: 3210:        {
        -: 3211:          uint16_t literal_index;
        -: 3212:
    #####: 3213:          READ_LITERAL_INDEX (literal_index);
        -: 3214:
    #####: 3215:          if (literal_index < register_end)
        -: 3216:          {
    #####: 3217:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3218:            continue;
        -: 3219:          }
        -: 3220:
    #####: 3221:          result = vm_op_delete_var (literal_start_p[literal_index],
        -: 3222:                                     frame_ctx_p->lex_env_p);
        -: 3223:
    #####: 3224:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3225:          {
    #####: 3226:            goto error;
        -: 3227:          }
        -: 3228:
    #####: 3229:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3230:
    #####: 3231:          *stack_top_p++ = result;
    #####: 3232:          continue;
        -: 3233:        }
        1: 3234:        case VM_OC_JUMP:
        -: 3235:        {
        1: 3236:          byte_code_p = byte_code_start_p + branch_offset;
        1: 3237:          continue;
        -: 3238:        }
    #####: 3239:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3240:        {
    #####: 3241:          ecma_value_t value = *(--stack_top_p);
        -: 3242:
    #####: 3243:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3244:
    #####: 3245:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3246:          {
    #####: 3247:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3248:            ecma_free_value (*--stack_top_p);
        -: 3249:          }
    #####: 3250:          ecma_free_value (value);
    #####: 3251:          continue;
        -: 3252:        }
        2: 3253:        case VM_OC_BRANCH_IF_TRUE:
        -: 3254:        case VM_OC_BRANCH_IF_FALSE:
        -: 3255:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3256:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3257:        {
        2: 3258:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
        2: 3259:          ecma_value_t value = *(--stack_top_p);
        -: 3260:
        2: 3261:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3262:
        2: 3263:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3264:          {
        2: 3265:            boolean_value = !boolean_value;
        -: 3266:          }
        -: 3267:
        2: 3268:          if (boolean_value)
        -: 3269:          {
        1: 3270:            byte_code_p = byte_code_start_p + branch_offset;
        1: 3271:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3272:            {
        -: 3273:              /* "Push" the value back to the stack. */
    #####: 3274:              ++stack_top_p;
    #####: 3275:              continue;
        -: 3276:            }
        -: 3277:          }
        -: 3278:
        2: 3279:          ecma_fast_free_value (value);
        2: 3280:          continue;
        -: 3281:        }
        -: 3282:#if JERRY_ESNEXT
    #####: 3283:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3284:        {
    #####: 3285:          left_value = stack_top_p[-1];
        -: 3286:
    #####: 3287:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3288:          {
    #####: 3289:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3290:            continue;
        -: 3291:          }
    #####: 3292:          --stack_top_p;
    #####: 3293:          continue;
        -: 3294:        }
        -: 3295:#endif /* JERRY_ESNEXT */
    #####: 3296:        case VM_OC_PLUS:
        -: 3297:        case VM_OC_MINUS:
        -: 3298:        {
    #####: 3299:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3300:
    #####: 3301:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3302:          {
    #####: 3303:            goto error;
        -: 3304:          }
        -: 3305:
    #####: 3306:          *stack_top_p++ = result;
    #####: 3307:          goto free_left_value;
        -: 3308:        }
    #####: 3309:        case VM_OC_NOT:
        -: 3310:        {
    #####: 3311:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3312:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3313:          goto free_left_value;
        -: 3314:        }
    #####: 3315:        case VM_OC_BIT_NOT:
        -: 3316:        {
        -: 3317:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3318:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3319:
    #####: 3320:          if (ecma_is_value_integer_number (left_value))
        -: 3321:          {
    #####: 3322:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3323:            goto free_left_value;
        -: 3324:          }
        -: 3325:
    #####: 3326:          result = do_number_bitwise_not (left_value);
        -: 3327:
    #####: 3328:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3329:          {
    #####: 3330:            goto error;
        -: 3331:          }
        -: 3332:
    #####: 3333:          *stack_top_p++ = result;
    #####: 3334:          goto free_left_value;
        -: 3335:        }
    #####: 3336:        case VM_OC_VOID:
        -: 3337:        {
    #####: 3338:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3339:          goto free_left_value;
        -: 3340:        }
    #####: 3341:        case VM_OC_TYPEOF_IDENT:
        -: 3342:        {
        -: 3343:          uint16_t literal_index;
        -: 3344:
    #####: 3345:          READ_LITERAL_INDEX (literal_index);
        -: 3346:
    #####: 3347:          JERRY_ASSERT (literal_index < ident_end);
        -: 3348:
    #####: 3349:          if (literal_index < register_end)
        -: 3350:          {
    #####: 3351:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3352:          }
        -: 3353:          else
        -: 3354:          {
    #####: 3355:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3356:
    #####: 3357:            ecma_object_t *ref_base_lex_env_p;
        -: 3358:
    #####: 3359:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 3360:                                                     &ref_base_lex_env_p,
        -: 3361:                                                     name_p);
        -: 3362:
    #####: 3363:            if (ref_base_lex_env_p == NULL)
        -: 3364:            {
    #####: 3365:              jcontext_release_exception ();
    #####: 3366:              result = ECMA_VALUE_UNDEFINED;
        -: 3367:            }
    #####: 3368:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3369:            {
    #####: 3370:              goto error;
        -: 3371:            }
        -: 3372:
    #####: 3373:            left_value = result;
        -: 3374:          }
        -: 3375:          /* FALLTHRU */
        -: 3376:        }
        -: 3377:        case VM_OC_TYPEOF:
        -: 3378:        {
    #####: 3379:          result = opfunc_typeof (left_value);
        -: 3380:
    #####: 3381:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3382:          {
    #####: 3383:            goto error;
        -: 3384:          }
        -: 3385:
    #####: 3386:          *stack_top_p++ = result;
    #####: 3387:          goto free_left_value;
        -: 3388:        }
    #####: 3389:        case VM_OC_ADD:
        -: 3390:        {
    #####: 3391:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3392:          {
    #####: 3393:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3394:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3395:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3396:            continue;
        -: 3397:          }
        -: 3398:
    #####: 3399:          if (ecma_is_value_float_number (left_value)
    #####: 3400:              && ecma_is_value_number (right_value))
        -: 3401:          {
    #####: 3402:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +
    #####: 3403:                                       ecma_get_number_from_value (right_value));
        -: 3404:
    #####: 3405:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3406:            ecma_free_number (right_value);
    #####: 3407:            continue;
        -: 3408:          }
        -: 3409:
    #####: 3410:          if (ecma_is_value_float_number (right_value)
    #####: 3411:              && ecma_is_value_integer_number (left_value))
        -: 3412:          {
    #####: 3413:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +
    #####: 3414:                                       ecma_get_float_from_value (right_value));
        -: 3415:
    #####: 3416:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3417:            continue;
        -: 3418:          }
        -: 3419:
    #####: 3420:          result = opfunc_addition (left_value, right_value);
        -: 3421:
    #####: 3422:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3423:          {
    #####: 3424:            goto error;
        -: 3425:          }
        -: 3426:
    #####: 3427:          *stack_top_p++ = result;
    #####: 3428:          goto free_both_values;
        -: 3429:        }
    #####: 3430:        case VM_OC_SUB:
        -: 3431:        {
        -: 3432:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX
        -: 3433:                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3434:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3435:
    #####: 3436:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3437:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3438:
    #####: 3439:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3440:          {
    #####: 3441:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3442:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3443:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3444:            continue;
        -: 3445:          }
        -: 3446:
    #####: 3447:          if (ecma_is_value_float_number (left_value)
    #####: 3448:              && ecma_is_value_number (right_value))
        -: 3449:          {
    #####: 3450:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -
    #####: 3451:                                       ecma_get_number_from_value (right_value));
        -: 3452:
    #####: 3453:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3454:            ecma_free_number (right_value);
    #####: 3455:            continue;
        -: 3456:          }
        -: 3457:
    #####: 3458:          if (ecma_is_value_float_number (right_value)
    #####: 3459:              && ecma_is_value_integer_number (left_value))
        -: 3460:          {
    #####: 3461:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -
    #####: 3462:                                       ecma_get_float_from_value (right_value));
        -: 3463:
    #####: 3464:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3465:            continue;
        -: 3466:          }
        -: 3467:
    #####: 3468:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,
        -: 3469:                                         left_value,
        -: 3470:                                         right_value);
        -: 3471:
    #####: 3472:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3473:          {
    #####: 3474:            goto error;
        -: 3475:          }
        -: 3476:
    #####: 3477:          *stack_top_p++ = result;
    #####: 3478:          goto free_both_values;
        -: 3479:        }
    #####: 3480:        case VM_OC_MUL:
        -: 3481:        {
    #####: 3482:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3483:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3484:
        -: 3485:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3486:                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3487:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3488:
    #####: 3489:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3490:          {
    #####: 3491:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3492:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3493:
    #####: 3494:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer
    #####: 3495:                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3496:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer
    #####: 3497:                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3498:                && left_integer != 0
    #####: 3499:                && right_integer != 0)
        -: 3500:            {
    #####: 3501:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3502:              continue;
        -: 3503:            }
        -: 3504:
    #####: 3505:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3506:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3507:            continue;
        -: 3508:          }
        -: 3509:
    #####: 3510:          if (ecma_is_value_float_number (left_value)
    #####: 3511:              && ecma_is_value_number (right_value))
        -: 3512:          {
    #####: 3513:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *
    #####: 3514:                                       ecma_get_number_from_value (right_value));
        -: 3515:
    #####: 3516:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3517:            ecma_free_number (right_value);
    #####: 3518:            continue;
        -: 3519:          }
        -: 3520:
    #####: 3521:          if (ecma_is_value_float_number (right_value)
    #####: 3522:              && ecma_is_value_integer_number (left_value))
        -: 3523:          {
    #####: 3524:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *
    #####: 3525:                                       ecma_get_float_from_value (right_value));
        -: 3526:
    #####: 3527:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3528:            continue;
        -: 3529:          }
        -: 3530:
    #####: 3531:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,
        -: 3532:                                         left_value,
        -: 3533:                                         right_value);
        -: 3534:
    #####: 3535:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3536:          {
    #####: 3537:            goto error;
        -: 3538:          }
        -: 3539:
    #####: 3540:          *stack_top_p++ = result;
    #####: 3541:          goto free_both_values;
        -: 3542:        }
    #####: 3543:        case VM_OC_DIV:
        -: 3544:        {
    #####: 3545:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3546:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3547:
    #####: 3548:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,
        -: 3549:                                         left_value,
        -: 3550:                                         right_value);
        -: 3551:
    #####: 3552:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3553:          {
    #####: 3554:            goto error;
        -: 3555:          }
        -: 3556:
    #####: 3557:          *stack_top_p++ = result;
    #####: 3558:          goto free_both_values;
        -: 3559:        }
    #####: 3560:        case VM_OC_MOD:
        -: 3561:        {
    #####: 3562:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3563:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3564:
    #####: 3565:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3566:          {
    #####: 3567:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3568:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3569:
    #####: 3570:            if (right_integer != 0)
        -: 3571:            {
    #####: 3572:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3573:
    #####: 3574:              if (mod_result != 0 || left_integer >= 0)
        -: 3575:              {
    #####: 3576:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3577:                continue;
        -: 3578:              }
        -: 3579:            }
        -: 3580:          }
        -: 3581:
    #####: 3582:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,
        -: 3583:                                         left_value,
        -: 3584:                                         right_value);
        -: 3585:
    #####: 3586:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3587:          {
    #####: 3588:            goto error;
        -: 3589:          }
        -: 3590:
    #####: 3591:          *stack_top_p++ = result;
    #####: 3592:          goto free_both_values;
        -: 3593:        }
        -: 3594:#if JERRY_ESNEXT
    #####: 3595:        case VM_OC_EXP:
        -: 3596:        {
    #####: 3597:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,
        -: 3598:                                         left_value,
        -: 3599:                                         right_value);
        -: 3600:
    #####: 3601:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3602:          {
    #####: 3603:            goto error;
        -: 3604:          }
        -: 3605:
    #####: 3606:          *stack_top_p++ = result;
    #####: 3607:          goto free_both_values;
        -: 3608:        }
        -: 3609:#endif /* JERRY_ESNEXT */
        2: 3610:        case VM_OC_EQUAL:
        -: 3611:        {
        2: 3612:          result = opfunc_equality (left_value, right_value);
        -: 3613:
        2: 3614:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3615:          {
    #####: 3616:            goto error;
        -: 3617:          }
        -: 3618:
        2: 3619:          *stack_top_p++ = result;
        2: 3620:          goto free_both_values;
        -: 3621:        }
    #####: 3622:        case VM_OC_NOT_EQUAL:
        -: 3623:        {
    #####: 3624:          result = opfunc_equality (left_value, right_value);
        -: 3625:
    #####: 3626:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3627:          {
    #####: 3628:            goto error;
        -: 3629:          }
        -: 3630:
    #####: 3631:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3632:          goto free_both_values;
        -: 3633:        }
    #####: 3634:        case VM_OC_STRICT_EQUAL:
        -: 3635:        {
    #####: 3636:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3637:
    #####: 3638:          result = ecma_make_boolean_value (is_equal);
        -: 3639:
    #####: 3640:          *stack_top_p++ = result;
    #####: 3641:          goto free_both_values;
        -: 3642:        }
    #####: 3643:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3644:        {
    #####: 3645:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3646:
    #####: 3647:          result = ecma_make_boolean_value (!is_equal);
        -: 3648:
    #####: 3649:          *stack_top_p++ = result;
    #####: 3650:          goto free_both_values;
        -: 3651:        }
    #####: 3652:        case VM_OC_BIT_OR:
        -: 3653:        {
        -: 3654:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3655:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3656:
    #####: 3657:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3658:          {
    #####: 3659:            *stack_top_p++ = left_value | right_value;
    #####: 3660:            continue;
        -: 3661:          }
        -: 3662:
    #####: 3663:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,
        -: 3664:                                            left_value,
        -: 3665:                                            right_value);
        -: 3666:
    #####: 3667:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3668:          {
    #####: 3669:            goto error;
        -: 3670:          }
        -: 3671:
    #####: 3672:          *stack_top_p++ = result;
    #####: 3673:          goto free_both_values;
        -: 3674:        }
    #####: 3675:        case VM_OC_BIT_XOR:
        -: 3676:        {
        -: 3677:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3678:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3679:
    #####: 3680:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3681:          {
    #####: 3682:            *stack_top_p++ = left_value ^ right_value;
    #####: 3683:            continue;
        -: 3684:          }
        -: 3685:
    #####: 3686:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,
        -: 3687:                                            left_value,
        -: 3688:                                            right_value);
        -: 3689:
    #####: 3690:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3691:          {
    #####: 3692:            goto error;
        -: 3693:          }
        -: 3694:
    #####: 3695:          *stack_top_p++ = result;
    #####: 3696:          goto free_both_values;
        -: 3697:        }
    #####: 3698:        case VM_OC_BIT_AND:
        -: 3699:        {
        -: 3700:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3701:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3702:
    #####: 3703:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3704:          {
    #####: 3705:            *stack_top_p++ = left_value & right_value;
    #####: 3706:            continue;
        -: 3707:          }
        -: 3708:
    #####: 3709:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,
        -: 3710:                                            left_value,
        -: 3711:                                            right_value);
        -: 3712:
    #####: 3713:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3714:          {
    #####: 3715:            goto error;
        -: 3716:          }
        -: 3717:
    #####: 3718:          *stack_top_p++ = result;
    #####: 3719:          goto free_both_values;
        -: 3720:        }
    #####: 3721:        case VM_OC_LEFT_SHIFT:
        -: 3722:        {
        -: 3723:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3724:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3725:
    #####: 3726:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3727:          {
    #####: 3728:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3729:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3730:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 3731:            continue;
        -: 3732:          }
        -: 3733:
    #####: 3734:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,
        -: 3735:                                            left_value,
        -: 3736:                                            right_value);
        -: 3737:
    #####: 3738:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3739:          {
    #####: 3740:            goto error;
        -: 3741:          }
        -: 3742:
    #####: 3743:          *stack_top_p++ = result;
    #####: 3744:          goto free_both_values;
        -: 3745:        }
    #####: 3746:        case VM_OC_RIGHT_SHIFT:
        -: 3747:        {
        -: 3748:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3749:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3750:
    #####: 3751:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3752:          {
    #####: 3753:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3754:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3755:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3756:            continue;
        -: 3757:          }
        -: 3758:
    #####: 3759:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,
        -: 3760:                                            left_value,
        -: 3761:                                            right_value);
        -: 3762:
    #####: 3763:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3764:          {
    #####: 3765:            goto error;
        -: 3766:          }
        -: 3767:
    #####: 3768:          *stack_top_p++ = result;
    #####: 3769:          goto free_both_values;
        -: 3770:        }
    #####: 3771:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3772:        {
        -: 3773:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3774:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3775:
    #####: 3776:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3777:          {
    #####: 3778:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3779:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3780:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3781:            continue;
        -: 3782:          }
        -: 3783:
    #####: 3784:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,
        -: 3785:                                            left_value,
        -: 3786:                                            right_value);
        -: 3787:
    #####: 3788:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3789:          {
    #####: 3790:            goto error;
        -: 3791:          }
        -: 3792:
    #####: 3793:          *stack_top_p++ = result;
    #####: 3794:          goto free_both_values;
        -: 3795:        }
    #####: 3796:        case VM_OC_LESS:
        -: 3797:        {
    #####: 3798:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3799:          {
    #####: 3800:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3801:#if !JERRY_VM_EXEC_STOP
        -: 3802:            /* This is a lookahead to the next opcode to improve performance.
        -: 3803:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
    #####: 3804:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3805:            {
    #####: 3806:              byte_code_start_p = byte_code_p++;
    #####: 3807:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
    #####: 3808:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3809:
    #####: 3810:              if (is_less)
        -: 3811:              {
    #####: 3812:                branch_offset = *(byte_code_p++);
        -: 3813:
    #####: 3814:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3815:                {
    #####: 3816:                  branch_offset <<= 8;
    #####: 3817:                  branch_offset |= *(byte_code_p++);
    #####: 3818:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3819:                  {
    #####: 3820:                    branch_offset <<= 8;
    #####: 3821:                    branch_offset |= *(byte_code_p++);
        -: 3822:                  }
        -: 3823:                }
        -: 3824:
        -: 3825:                /* Note: The opcode is a backward branch. */
    #####: 3826:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3827:              }
        -: 3828:              else
        -: 3829:              {
    #####: 3830:                byte_code_p += branch_offset_length;
        -: 3831:              }
        -: 3832:
    #####: 3833:              continue;
        -: 3834:            }
        -: 3835:#endif /* !JERRY_VM_EXEC_STOP */
    #####: 3836:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3837:            continue;
        -: 3838:          }
        -: 3839:
    #####: 3840:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3841:          {
    #####: 3842:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3843:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3844:
    #####: 3845:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3846:            goto free_both_values;
        -: 3847:          }
        -: 3848:
    #####: 3849:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3850:
    #####: 3851:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3852:          {
    #####: 3853:            goto error;
        -: 3854:          }
        -: 3855:
    #####: 3856:          *stack_top_p++ = result;
    #####: 3857:          goto free_both_values;
        -: 3858:        }
    #####: 3859:        case VM_OC_GREATER:
        -: 3860:        {
    #####: 3861:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3862:          {
    #####: 3863:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3864:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3865:
    #####: 3866:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3867:            continue;
        -: 3868:          }
        -: 3869:
    #####: 3870:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3871:          {
    #####: 3872:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3873:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3874:
    #####: 3875:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3876:            goto free_both_values;
        -: 3877:          }
        -: 3878:
    #####: 3879:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3880:
    #####: 3881:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3882:          {
    #####: 3883:            goto error;
        -: 3884:          }
        -: 3885:
    #####: 3886:          *stack_top_p++ = result;
    #####: 3887:          goto free_both_values;
        -: 3888:        }
    #####: 3889:        case VM_OC_LESS_EQUAL:
        -: 3890:        {
    #####: 3891:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3892:          {
    #####: 3893:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3894:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3895:
    #####: 3896:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3897:            continue;
        -: 3898:          }
        -: 3899:
    #####: 3900:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3901:          {
    #####: 3902:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3903:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3904:
    #####: 3905:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3906:            goto free_both_values;
        -: 3907:          }
        -: 3908:
    #####: 3909:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3910:
    #####: 3911:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3912:          {
    #####: 3913:            goto error;
        -: 3914:          }
        -: 3915:
    #####: 3916:          *stack_top_p++ = result;
    #####: 3917:          goto free_both_values;
        -: 3918:        }
    #####: 3919:        case VM_OC_GREATER_EQUAL:
        -: 3920:        {
    #####: 3921:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3922:          {
    #####: 3923:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3924:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3925:
    #####: 3926:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3927:            continue;
        -: 3928:          }
        -: 3929:
    #####: 3930:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3931:          {
    #####: 3932:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3933:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3934:
    #####: 3935:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3936:            goto free_both_values;
        -: 3937:          }
        -: 3938:
    #####: 3939:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3940:
    #####: 3941:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3942:          {
    #####: 3943:            goto error;
        -: 3944:          }
        -: 3945:
    #####: 3946:          *stack_top_p++ = result;
    #####: 3947:          goto free_both_values;
        -: 3948:        }
    #####: 3949:        case VM_OC_IN:
        -: 3950:        {
    #####: 3951:          result = opfunc_in (left_value, right_value);
        -: 3952:
    #####: 3953:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3954:          {
    #####: 3955:            goto error;
        -: 3956:          }
        -: 3957:
    #####: 3958:          *stack_top_p++ = result;
    #####: 3959:          goto free_both_values;
        -: 3960:        }
    #####: 3961:        case VM_OC_INSTANCEOF:
        -: 3962:        {
    #####: 3963:          result = opfunc_instanceof (left_value, right_value);
        -: 3964:
    #####: 3965:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3966:          {
    #####: 3967:            goto error;
        -: 3968:          }
        -: 3969:
    #####: 3970:          *stack_top_p++ = result;
    #####: 3971:          goto free_both_values;
        -: 3972:        }
    #####: 3973:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3974:        {
        -: 3975:#if JERRY_ESNEXT
        -: 3976:          ecma_value_t *stack_context_top_p;
    #####: 3977:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3978:
    #####: 3979:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 3980:
    #####: 3981:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 3982:          {
    #####: 3983:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3984:
    #####: 3985:            if (stack_context_top_p != stack_top_p)
        -: 3986:            {
        -: 3987:               /* Preserve the value of switch statement. */
    #####: 3988:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 3989:            }
        -: 3990:
    #####: 3991:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 3992:
    #####: 3993:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 3994:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 3995:          }
        -: 3996:          else
        -: 3997:          {
    #####: 3998:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 3999:
    #####: 4000:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4001:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4002:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4003:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4004:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4005:
    #####: 4006:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4007:
    #####: 4008:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4009:          }
        -: 4010:#else /* !JERRY_ESNEXT */
        -: 4011:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4012:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4013:
    #####: 4014:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4015:#endif /* JERRY_ESNEXT */
        -: 4016:
    #####: 4017:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4018:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4019:
    #####: 4020:          continue;
        -: 4021:        }
    #####: 4022:        case VM_OC_WITH:
        -: 4023:        {
    #####: 4024:          ecma_value_t value = *(--stack_top_p);
        -: 4025:          ecma_object_t *object_p;
        -: 4026:          ecma_object_t *with_env_p;
        -: 4027:
    #####: 4028:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4029:
    #####: 4030:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4031:
    #####: 4032:          result = ecma_op_to_object (value);
    #####: 4033:          ecma_free_value (value);
        -: 4034:
    #####: 4035:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4036:          {
    #####: 4037:            goto error;
        -: 4038:          }
        -: 4039:
    #####: 4040:          object_p = ecma_get_object_from_value (result);
        -: 4041:
    #####: 4042:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4043:          ecma_deref_object (object_p);
        -: 4044:
    #####: 4045:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4046:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4047:
    #####: 4048:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4049:
    #####: 4050:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4051:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4052:          continue;
        -: 4053:        }
    #####: 4054:        case VM_OC_FOR_IN_INIT:
        -: 4055:        {
    #####: 4056:          ecma_value_t value = *(--stack_top_p);
        -: 4057:
    #####: 4058:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4059:
    #####: 4060:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 4061:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 4062:          ecma_free_value (value);
        -: 4063:
    #####: 4064:          if (prop_names_p == NULL)
        -: 4065:          {
        -: 4066:#if JERRY_ESNEXT
    #####: 4067:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4068:            {
    #####: 4069:              result = expr_obj_value;
    #####: 4070:              goto error;
        -: 4071:            }
        -: 4072:#endif /* JERRY_ESNEXT */
        -: 4073:
        -: 4074:            /* The collection is already released */
    #####: 4075:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4076:            continue;
        -: 4077:          }
        -: 4078:
    #####: 4079:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4080:
    #####: 4081:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4082:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 4083:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 4084:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 4085:          stack_top_p[-3] = 0;
    #####: 4086:          stack_top_p[-4] = expr_obj_value;
        -: 4087:
        -: 4088:#if JERRY_ESNEXT
    #####: 4089:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4090:          {
        -: 4091:            /* No need to duplicate the first context. */
    #####: 4092:            byte_code_p += 2;
        -: 4093:          }
        -: 4094:#endif /* JERRY_ESNEXT */
    #####: 4095:          continue;
        -: 4096:        }
    #####: 4097:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4098:        {
    #####: 4099:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4100:
        -: 4101:          ecma_collection_t *collection_p;
    #####: 4102:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4103:
    #####: 4104:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4105:
    #####: 4106:          uint32_t index = context_top_p[-3];
    #####: 4107:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4108:
    #####: 4109:          *stack_top_p++ = buffer_p[index];
    #####: 4110:          context_top_p[-3]++;
    #####: 4111:          continue;
        -: 4112:        }
    #####: 4113:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4114:        {
    #####: 4115:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4116:
        -: 4117:          ecma_collection_t *collection_p;
    #####: 4118:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4119:
    #####: 4120:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4121:
    #####: 4122:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 4123:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 4124:          uint32_t index = stack_top_p[-3];
        -: 4125:
    #####: 4126:          while (index < collection_p->item_count)
        -: 4127:          {
    #####: 4128:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4129:
    #####: 4130:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4131:
    #####: 4132:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4133:            {
    #####: 4134:              goto error;
        -: 4135:            }
        -: 4136:
    #####: 4137:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4138:            {
    #####: 4139:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4140:              break;
        -: 4141:            }
        -: 4142:
    #####: 4143:            ecma_deref_ecma_string (prop_name_p);
    #####: 4144:            index++;
        -: 4145:          }
        -: 4146:
    #####: 4147:          if (index == collection_p->item_count)
        -: 4148:          {
    #####: 4149:            ecma_deref_object (object_p);
    #####: 4150:            ecma_collection_destroy (collection_p);
    #####: 4151:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4152:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4153:          }
        -: 4154:          else
        -: 4155:          {
    #####: 4156:            stack_top_p[-3] = index;
        -: 4157:          }
    #####: 4158:          continue;
        -: 4159:        }
        -: 4160:#if JERRY_ESNEXT
    #####: 4161:        case VM_OC_FOR_OF_INIT:
        -: 4162:        {
    #####: 4163:          ecma_value_t value = *(--stack_top_p);
        -: 4164:
    #####: 4165:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4166:
    #####: 4167:          ecma_value_t next_method;
    #####: 4168:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4169:
    #####: 4170:          ecma_free_value (value);
        -: 4171:
    #####: 4172:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4173:          {
    #####: 4174:            result = iterator;
    #####: 4175:            goto error;
        -: 4176:          }
        -: 4177:
    #####: 4178:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4179:
    #####: 4180:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4181:          {
    #####: 4182:            ecma_free_value (iterator);
    #####: 4183:            ecma_free_value (next_method);
    #####: 4184:            goto error;
        -: 4185:          }
        -: 4186:
    #####: 4187:          if (ecma_is_value_false (result))
        -: 4188:          {
    #####: 4189:            ecma_free_value (iterator);
    #####: 4190:            ecma_free_value (next_method);
    #####: 4191:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4192:            continue;
        -: 4193:          }
        -: 4194:
    #####: 4195:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4196:          ecma_free_value (result);
        -: 4197:
    #####: 4198:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4199:          {
    #####: 4200:            result = next_value;
    #####: 4201:            ecma_free_value (iterator);
    #####: 4202:            ecma_free_value (next_method);
    #####: 4203:            goto error;
        -: 4204:          }
        -: 4205:
    #####: 4206:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4207:
    #####: 4208:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4209:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4210:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4211:          stack_top_p[-2] = next_value;
    #####: 4212:          stack_top_p[-3] = iterator;
    #####: 4213:          stack_top_p[-4] = next_method;
        -: 4214:
    #####: 4215:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4216:          {
        -: 4217:            /* No need to duplicate the first context. */
    #####: 4218:            byte_code_p += 2;
        -: 4219:          }
    #####: 4220:          continue;
        -: 4221:        }
    #####: 4222:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4223:        {
    #####: 4224:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4225:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4226:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4227:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4228:
    #####: 4229:          *stack_top_p++ = context_top_p[-2];
    #####: 4230:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4231:          continue;
        -: 4232:        }
    #####: 4233:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4234:        {
    #####: 4235:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4236:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4237:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4238:
    #####: 4239:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4240:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4241:
    #####: 4242:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4243:          {
    #####: 4244:            goto error;
        -: 4245:          }
        -: 4246:
    #####: 4247:          if (ecma_is_value_false (result))
        -: 4248:          {
    #####: 4249:            ecma_free_value (stack_top_p[-2]);
    #####: 4250:            ecma_free_value (stack_top_p[-3]);
    #####: 4251:            ecma_free_value (stack_top_p[-4]);
    #####: 4252:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4253:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4254:            continue;
        -: 4255:          }
        -: 4256:
    #####: 4257:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4258:          ecma_free_value (result);
        -: 4259:
    #####: 4260:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4261:          {
    #####: 4262:            result = next_value;
    #####: 4263:            goto error;
        -: 4264:          }
        -: 4265:
    #####: 4266:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4267:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4268:          stack_top_p[-2] = next_value;
    #####: 4269:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4270:          continue;
        -: 4271:        }
    #####: 4272:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4273:        {
    #####: 4274:          ecma_value_t value = *(--stack_top_p);
        -: 4275:
    #####: 4276:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4277:
    #####: 4278:          ecma_value_t next_method;
    #####: 4279:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4280:
    #####: 4281:          ecma_free_value (value);
        -: 4282:
    #####: 4283:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4284:          {
    #####: 4285:            goto error;
        -: 4286:          }
        -: 4287:
    #####: 4288:          ecma_value_t iterator = result;
    #####: 4289:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4290:
    #####: 4291:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4292:          {
    #####: 4293:            ecma_free_value (iterator);
    #####: 4294:            ecma_free_value (next_method);
    #####: 4295:            goto error;
        -: 4296:          }
        -: 4297:
    #####: 4298:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4299:
    #####: 4300:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4301:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4302:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4303:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4304:          stack_top_p[-3] = iterator;
    #####: 4305:          stack_top_p[-4] = next_method;
        -: 4306:
    #####: 4307:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4308:          {
        -: 4309:            /* No need to duplicate the first context. */
    #####: 4310:            byte_code_p += 2;
        -: 4311:          }
        -: 4312:
    #####: 4313:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4314:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4315:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4316:
    #####: 4317:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4318:                                  | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4319:
    #####: 4320:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4321:              || frame_ctx_p->block_result != ECMA_VALUE_UNDEFINED)
        -: 4322:          {
    #####: 4323:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4324:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4325:
    #####: 4326:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4327:            {
    #####: 4328:              goto error;
        -: 4329:            }
        -: 4330:
    #####: 4331:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4332:            return ECMA_VALUE_UNDEFINED;
        -: 4333:          }
        -: 4334:
    #####: 4335:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4336:
    #####: 4337:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4338:          {
    #####: 4339:            goto error;
        -: 4340:          }
    #####: 4341:          return result;
        -: 4342:        }
    #####: 4343:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4344:        {
    #####: 4345:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4346:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4347:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4348:
    #####: 4349:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4350:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4351:
    #####: 4352:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4353:          {
    #####: 4354:            goto error;
        -: 4355:          }
        -: 4356:
    #####: 4357:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4358:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4359:
    #####: 4360:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4361:          {
    #####: 4362:            goto error;
        -: 4363:          }
        -: 4364:
    #####: 4365:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4366:                                 | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4367:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4368:
    #####: 4369:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4370:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4371:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4372:          return ECMA_VALUE_UNDEFINED;
        -: 4373:        }
        -: 4374:#endif /* JERRY_ESNEXT */
    #####: 4375:        case VM_OC_TRY:
        -: 4376:        {
        -: 4377:          /* Try opcode simply creates the try context. */
    #####: 4378:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4379:
    #####: 4380:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4381:
    #####: 4382:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 4383:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4384:
    #####: 4385:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
    #####: 4386:          continue;
        -: 4387:        }
    #####: 4388:        case VM_OC_CATCH:
        -: 4389:        {
        -: 4390:          /* Catches are ignored and turned to jumps. */
    #####: 4391:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4392:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4393:
    #####: 4394:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4395:          continue;
        -: 4396:        }
    #####: 4397:        case VM_OC_FINALLY:
        -: 4398:        {
    #####: 4399:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4400:
    #####: 4401:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4402:
    #####: 4403:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4404:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4405:
    #####: 4406:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4407:          {
    #####: 4408:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4409:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4410:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4411:            ecma_deref_object (lex_env_p);
        -: 4412:          }
        -: 4413:
    #####: 4414:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4415:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4416:
    #####: 4417:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4418:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4419:          continue;
        -: 4420:        }
    #####: 4421:        case VM_OC_CONTEXT_END:
        -: 4422:        {
    #####: 4423:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4424:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4425:
    #####: 4426:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4427:
    #####: 4428:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4429:          {
    #####: 4430:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4431:
    #####: 4432:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4433:            continue;
        -: 4434:          }
        -: 4435:
        -: 4436:#if JERRY_ESNEXT
    #####: 4437:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4438:          {
    #####: 4439:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4440:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4441:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4442:            ecma_deref_object (lex_env_p);
        -: 4443:          }
        -: 4444:#endif /* JERRY_ESNEXT */
        -: 4445:
    #####: 4446:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,
        -: 4447:                              PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4448:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4449:
    #####: 4450:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4451:          {
    #####: 4452:            result = *stack_top_p;
    #####: 4453:            goto error;
        -: 4454:          }
        -: 4455:
    #####: 4456:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4457:          {
    #####: 4458:            jcontext_raise_exception (*stack_top_p);
        -: 4459:#if JERRY_VM_THROW
    #####: 4460:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4461:#endif /* JERRY_VM_THROW */
    #####: 4462:            result = ECMA_VALUE_ERROR;
        -: 4463:
        -: 4464:#if JERRY_DEBUGGER
        -: 4465:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4466:#endif /* JERRY_DEBUGGER */
    #####: 4467:            goto error;
        -: 4468:          }
        -: 4469:
    #####: 4470:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4471:
    #####: 4472:          uint32_t jump_target = *stack_top_p;
        -: 4473:
    #####: 4474:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4475:                                                            stack_top_p,
        -: 4476:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4477:                                                            jump_target);
    #####: 4478:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4479:          switch (type)
        -: 4480:          {
    #####: 4481:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4482:            {
    #####: 4483:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4484:
    #####: 4485:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4486:              stack_top_p[-2] = jump_target;
    #####: 4487:              break;
        -: 4488:            }
        -: 4489:#if JERRY_ESNEXT
    #####: 4490:            case VM_CONTEXT_FOUND_ERROR:
        -: 4491:            {
    #####: 4492:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4493:              result = ECMA_VALUE_ERROR;
    #####: 4494:              goto error;
        -: 4495:            }
    #####: 4496:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4497:            {
    #####: 4498:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4499:              stack_top_p[-2] = jump_target;
    #####: 4500:              return ECMA_VALUE_UNDEFINED;
        -: 4501:            }
        -: 4502:#endif /* JERRY_ESNEXT */
    #####: 4503:            default:
        -: 4504:            {
    #####: 4505:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4506:              break;
        -: 4507:            }
        -: 4508:          }
        -: 4509:
    #####: 4510:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4511:          continue;
        -: 4512:        }
    #####: 4513:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4514:        {
    #####: 4515:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4516:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4517:
    #####: 4518:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4519:
    #####: 4520:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4521:                                                            stack_top_p,
        -: 4522:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4523:                                                            (uint32_t) branch_offset);
    #####: 4524:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4525:          switch (type)
        -: 4526:          {
    #####: 4527:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4528:            {
    #####: 4529:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4530:
    #####: 4531:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4532:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4533:              break;
        -: 4534:            }
        -: 4535:#if JERRY_ESNEXT
    #####: 4536:            case VM_CONTEXT_FOUND_ERROR:
        -: 4537:            {
    #####: 4538:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4539:              result = ECMA_VALUE_ERROR;
    #####: 4540:              goto error;
        -: 4541:            }
    #####: 4542:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4543:            {
    #####: 4544:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4545:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4546:              return ECMA_VALUE_UNDEFINED;
        -: 4547:            }
        -: 4548:#endif /* JERRY_ESNEXT */
    #####: 4549:            default:
        -: 4550:            {
    #####: 4551:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4552:              break;
        -: 4553:            }
        -: 4554:          }
        -: 4555:
    #####: 4556:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4557:          continue;
        -: 4558:        }
        -: 4559:#if JERRY_MODULE_SYSTEM
    #####: 4560:        case VM_OC_MODULE_IMPORT:
        -: 4561:        {
    #####: 4562:          left_value = *(--stack_top_p);
        -: 4563:
    #####: 4564:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4565:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4566:
        -: 4567:#if JERRY_SNAPSHOT_EXEC
    #####: 4568:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4569:          {
        -: 4570:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4571:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4572:
    #####: 4573:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4574:            {
    #####: 4575:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4576:            }
        -: 4577:#if JERRY_SNAPSHOT_EXEC
        -: 4578:          }
        -: 4579:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4580:
    #####: 4581:          result = ecma_module_import (left_value, user_value);
    #####: 4582:          ecma_free_value (left_value);
        -: 4583:
    #####: 4584:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4585:          {
    #####: 4586:            goto error;
        -: 4587:          }
        -: 4588:
    #####: 4589:          *stack_top_p++ = result;
    #####: 4590:          continue;
        -: 4591:        }
    #####: 4592:        case VM_OC_MODULE_IMPORT_META:
        -: 4593:        {
    #####: 4594:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4595:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4596:
    #####: 4597:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4598:
    #####: 4599:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4600:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4601:
    #####: 4602:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4603:          {
    #####: 4604:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4605:
    #####: 4606:            ecma_value_t module = import_meta;
    #####: 4607:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4608:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4609:
    #####: 4610:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4611:            {
    #####: 4612:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4613:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4614:            }
        -: 4615:
    #####: 4616:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4617:          }
        -: 4618:          else
        -: 4619:          {
    #####: 4620:            ecma_ref_object (import_meta_object_p);
        -: 4621:          }
        -: 4622:
    #####: 4623:          *stack_top_p++ = import_meta;
    #####: 4624:          continue;
        -: 4625:        }
        -: 4626:#endif /* JERRY_MODULE_SYSTEM */
        -: 4627:#if JERRY_DEBUGGER
        -: 4628:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4629:        {
        -: 4630:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4631:          {
        -: 4632:            continue;
        -: 4633:          }
        -: 4634:
        -: 4635:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4636:
        -: 4637:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4638:
        -: 4639:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4640:
        -: 4641:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4642:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4643:          {
        -: 4644:            result = ECMA_VALUE_ERROR;
        -: 4645:            goto error;
        -: 4646:          }
        -: 4647:          continue;
        -: 4648:        }
        -: 4649:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4650:        {
        -: 4651:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4652:          {
        -: 4653:            continue;
        -: 4654:          }
        -: 4655:
        -: 4656:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4657:
        -: 4658:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4659:
        -: 4660:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4661:
        -: 4662:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4663:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4664:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4665:          {
        -: 4666:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4667:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4668:            {
        -: 4669:              result = ECMA_VALUE_ERROR;
        -: 4670:              goto error;
        -: 4671:            }
        -: 4672:            continue;
        -: 4673:          }
        -: 4674:
        -: 4675:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4676:          {
        -: 4677:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4678:            continue;
        -: 4679:          }
        -: 4680:
        -: 4681:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4682:
        -: 4683:          if (jerry_debugger_receive (NULL))
        -: 4684:          {
        -: 4685:            continue;
        -: 4686:          }
        -: 4687:
        -: 4688:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4689:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4690:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4691:          {
        -: 4692:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4693:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4694:            {
        -: 4695:              result = ECMA_VALUE_ERROR;
        -: 4696:              goto error;
        -: 4697:            }
        -: 4698:          }
        -: 4699:          continue;
        -: 4700:        }
        -: 4701:#endif /* JERRY_DEBUGGER */
    #####: 4702:        case VM_OC_NONE:
        -: 4703:        default:
        -: 4704:        {
    #####: 4705:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4706:
    #####: 4707:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4708:        }
        -: 4709:      }
        -: 4710:
        3: 4711:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4712:
        3: 4713:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4714:      {
        -: 4715:        uint16_t literal_index;
        -: 4716:
        2: 4717:        READ_LITERAL_INDEX (literal_index);
        -: 4718:
        2: 4719:        if (literal_index < register_end)
        -: 4720:        {
    #####: 4721:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4722:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4723:
    #####: 4724:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4725:          {
    #####: 4726:            result = ecma_fast_copy_value (result);
        -: 4727:          }
        -: 4728:        }
        -: 4729:        else
        -: 4730:        {
        2: 4731:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4732:
        2: 4733:          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 4734:                                                                          var_name_str_p,
        -: 4735:                                                                          is_strict,
        -: 4736:                                                                          result);
        -: 4737:
        2: 4738:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4739:          {
    #####: 4740:            ecma_free_value (result);
    #####: 4741:            result = put_value_result;
    #####: 4742:            goto error;
        -: 4743:          }
        -: 4744:
        2: 4745:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4746:          {
        2: 4747:            ecma_fast_free_value (result);
        -: 4748:          }
        -: 4749:        }
        -: 4750:      }
        1: 4751:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4752:      {
    #####: 4753:        ecma_value_t property = *(--stack_top_p);
    #####: 4754:        ecma_value_t base = *(--stack_top_p);
        -: 4755:
    #####: 4756:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4757:        {
    #####: 4758:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 4759:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 4760:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4761:
    #####: 4762:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4763:          {
    #####: 4764:            goto free_both_values;
        -: 4765:          }
    #####: 4766:          result = ecma_fast_copy_value (result);
        -: 4767:        }
        -: 4768:        else
        -: 4769:        {
    #####: 4770:          ecma_value_t set_value_result = vm_op_set_value (base,
        -: 4771:                                                           property,
        -: 4772:                                                           result,
        -: 4773:                                                           is_strict);
        -: 4774:
    #####: 4775:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4776:          {
    #####: 4777:            ecma_free_value (result);
    #####: 4778:            result = set_value_result;
    #####: 4779:            goto error;
        -: 4780:          }
        -: 4781:
    #####: 4782:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4783:          {
    #####: 4784:            ecma_fast_free_value (result);
    #####: 4785:            goto free_both_values;
        -: 4786:          }
        -: 4787:        }
        -: 4788:      }
        -: 4789:
        3: 4790:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4791:      {
        1: 4792:        *stack_top_p++ = result;
        -: 4793:      }
        2: 4794:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4795:      {
    #####: 4796:        ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 4797:        frame_ctx_p->block_result = result;
        -: 4798:      }
        -: 4799:
       14: 4800:free_both_values:
       12: 4801:      ecma_fast_free_value (right_value);
       12: 4802:free_left_value:
       12: 4803:      ecma_fast_free_value (left_value);
        -: 4804:    }
        -: 4805:
        8: 4806:error:
        8: 4807:    ecma_fast_free_value (left_value);
        8: 4808:    ecma_fast_free_value (right_value);
        -: 4809:
        8: 4810:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4811:    {
    #####: 4812:      JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4813:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4814:
    #####: 4815:      while (stack_top_p > stack_bottom_p)
        -: 4816:      {
    #####: 4817:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4818:#if JERRY_ESNEXT
    #####: 4819:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4820:        {
    #####: 4821:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4822:          continue;
        -: 4823:        }
        -: 4824:#endif /* JERRY_ESNEXT */
    #####: 4825:        ecma_fast_free_value (stack_item);
        -: 4826:      }
        -: 4827:
        -: 4828:#if JERRY_VM_THROW
    #####: 4829:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4830:      {
    #####: 4831:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4832:
    #####: 4833:        jerry_vm_throw_callback_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4834:
    #####: 4835:        if (vm_throw_callback_p != NULL)
        -: 4836:        {
    #####: 4837:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4838:        }
        -: 4839:      }
        -: 4840:#endif /* JERRY_VM_THROW */
        -: 4841:
        -: 4842:#if JERRY_DEBUGGER
        -: 4843:      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION
        -: 4844:                                  | JERRY_DEBUGGER_VM_IGNORE
        -: 4845:                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4846:
        -: 4847:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4848:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4849:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4850:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4851:      {
        -: 4852:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4853:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4854:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4855:
        -: 4856:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4857:        {
        -: 4858:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4859:
        -: 4860:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4861:          {
        -: 4862:            ecma_free_value (current_error_value);
        -: 4863:          }
        -: 4864:          else
        -: 4865:          {
        -: 4866:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4867:          }
        -: 4868:
        -: 4869:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4870:        }
        -: 4871:      }
        -: 4872:#endif /* JERRY_DEBUGGER */
        -: 4873:    }
        -: 4874:
        8: 4875:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4876:
        8: 4877:    if (frame_ctx_p->context_depth == 0)
        -: 4878:    {
        -: 4879:      /* In most cases there is no context. */
        8: 4880:      ecma_fast_free_value (frame_ctx_p->block_result);
        8: 4881:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
        8: 4882:      return result;
        -: 4883:    }
        -: 4884:
    #####: 4885:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4886:    {
    #####: 4887:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4888:                                     stack_top_p,
        -: 4889:                                     VM_CONTEXT_FINALLY_RETURN,
        -: 4890:                                     0))
        -: 4891:      {
    #####: 4892:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4893:        {
    #####: 4894:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4895:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4896:
    #####: 4897:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4898:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4899:          stack_top_p[-2] = result;
    #####: 4900:          continue;
        -: 4901:        }
        -: 4902:#if JERRY_ESNEXT
    #####: 4903:        case VM_CONTEXT_FOUND_ERROR:
        -: 4904:        {
    #####: 4905:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4906:
    #####: 4907:          ecma_free_value (result);
    #####: 4908:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4909:          result = ECMA_VALUE_ERROR;
    #####: 4910:          break;
        -: 4911:        }
    #####: 4912:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4913:        {
    #####: 4914:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4915:
    #####: 4916:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4917:          stack_top_p[-2] = result;
    #####: 4918:          return ECMA_VALUE_UNDEFINED;
        -: 4919:        }
        -: 4920:#endif /* JERRY_ESNEXT */
    #####: 4921:        default:
        -: 4922:        {
    #####: 4923:          goto finish;
        -: 4924:        }
        -: 4925:      }
    #####: 4926:    }
        -: 4927:
    #####: 4928:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4929:
    #####: 4930:    if (!jcontext_has_pending_abort ())
        -: 4931:    {
    #####: 4932:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4933:                                     stack_top_p,
        -: 4934:                                     VM_CONTEXT_FINALLY_THROW,
        -: 4935:                                     0))
        -: 4936:      {
    #####: 4937:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4938:        {
    #####: 4939:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4940:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4941:
    #####: 4942:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4943:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4944:
        -: 4945:#if JERRY_DEBUGGER
        -: 4946:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4947:#endif /* JERRY_DEBUGGER */
        -: 4948:
    #####: 4949:          result = jcontext_take_exception ();
        -: 4950:
    #####: 4951:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4952:          {
    #####: 4953:            stack_top_p[-2] = result;
    #####: 4954:            continue;
        -: 4955:          }
        -: 4956:
    #####: 4957:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4958:
    #####: 4959:          *stack_top_p++ = result;
    #####: 4960:          continue;
        -: 4961:        }
        -: 4962:#if JERRY_ESNEXT
    #####: 4963:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4964:        {
    #####: 4965:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4966:          return ECMA_VALUE_UNDEFINED;
        -: 4967:        }
        -: 4968:#endif /* JERRY_ESNEXT */
    #####: 4969:        default:
        -: 4970:        {
    #####: 4971:          break;
        -: 4972:        }
        -: 4973:      }
        -: 4974:    }
        -: 4975:    else
        -: 4976:    {
        -: 4977:      do
        -: 4978:      {
    #####: 4979:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4980:
    #####: 4981:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4982:      }
    #####: 4983:      while (frame_ctx_p->context_depth > 0);
        -: 4984:    }
        -: 4985:
    #####: 4986:finish:
    #####: 4987:    ecma_free_value (frame_ctx_p->block_result);
    #####: 4988:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4989:    return result;
        -: 4990:  }
        -: 4991:} /* vm_loop */
        -: 4992:
        -: 4993:#if JERRY_MODULE_SYSTEM
        -: 4994:
        -: 4995:/**
        -: 4996: * Create and initialize module scope with all data properties
        -: 4997: *
        -: 4998: * @return ECMA_VALUE_EMPTY on success,
        -: 4999: *         ECMA_VALUE_ERROR on failure
        -: 5000: */
        -: 5001:ecma_value_t
    #####: 5002:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5003:{
        -: 5004:  ecma_object_t *global_object_p;
        -: 5005:#if JERRY_BUILTIN_REALMS
    #####: 5006:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5007:#else /* !JERRY_BUILTIN_REALMS */
        -: 5008:  global_object_p = ecma_builtin_get_global ();
        -: 5009:#endif /* JERRY_BUILTIN_REALMS */
        -: 5010:
    #####: 5011:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5012:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5013:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5014:  ecma_value_t *literal_start_p;
        -: 5015:  uint8_t *byte_code_p;
        -: 5016:  uint16_t encoding_limit;
        -: 5017:  uint16_t encoding_delta;
        -: 5018:
    #####: 5019:  ((ecma_lexical_environment_class_t *) scope_p)->module_p = (ecma_object_t *) module_p;
        -: 5020:
    #####: 5021:  module_p->scope_p = scope_p;
    #####: 5022:  ecma_deref_object (scope_p);
        -: 5023:
    #####: 5024:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5025:  {
    #####: 5026:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5027:
    #####: 5028:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5029:    literal_start_p -= args_p->register_end;
    #####: 5030:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5031:  }
        -: 5032:  else
        -: 5033:  {
    #####: 5034:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5035:
    #####: 5036:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5037:    literal_start_p -= args_p->register_end;
    #####: 5038:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5039:  }
        -: 5040:
        -: 5041:  /* Prepare for byte code execution. */
    #####: 5042:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5043:  {
    #####: 5044:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5045:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5046:  }
        -: 5047:  else
        -: 5048:  {
    #####: 5049:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5050:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5051:  }
        -: 5052:
    #####: 5053:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5054:
    #####: 5055:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5056:
        -: 5057:  while (true)
    #####: 5058:  {
    #####: 5059:    uint8_t opcode = *byte_code_p++;
        -: 5060:
    #####: 5061:    switch (opcode)
        -: 5062:    {
    #####: 5063:      case CBC_CREATE_VAR:
        -: 5064:      case CBC_CREATE_LET:
        -: 5065:      case CBC_CREATE_CONST:
        -: 5066:      {
        -: 5067:        uint32_t literal_index;
        -: 5068:
    #####: 5069:        READ_LITERAL_INDEX (literal_index);
        -: 5070:
    #####: 5071:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5072:
    #####: 5073:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5074:
    #####: 5075:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5076:
    #####: 5077:        if (opcode == CBC_CREATE_LET)
        -: 5078:        {
    #####: 5079:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5080:        }
    #####: 5081:        else if (opcode == CBC_CREATE_CONST)
        -: 5082:        {
    #####: 5083:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5084:        }
        -: 5085:
        -: 5086:        ecma_property_value_t *property_value_p;
    #####: 5087:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5088:
    #####: 5089:        if (opcode != CBC_CREATE_VAR)
        -: 5090:        {
    #####: 5091:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5092:        }
    #####: 5093:        break;
        -: 5094:      }
    #####: 5095:      case CBC_INIT_ARG_OR_FUNC:
        -: 5096:      {
        -: 5097:        uint32_t literal_index;
        -: 5098:
    #####: 5099:        READ_LITERAL_INDEX (literal_index);
        -: 5100:
        -: 5101:        ecma_compiled_code_t *function_bytecode_p;
        -: 5102:#if JERRY_SNAPSHOT_EXEC
    #####: 5103:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5104:        {
        -: 5105:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5106:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5107:                                                                 literal_start_p[literal_index]);
        -: 5108:#if JERRY_SNAPSHOT_EXEC
        -: 5109:        }
        -: 5110:        else
        -: 5111:        {
    #####: 5112:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5113:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5114:        }
        -: 5115:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5116:
    #####: 5117:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5118:
        -: 5119:        ecma_object_t *function_obj_p;
        -: 5120:
    #####: 5121:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5122:        {
    #####: 5123:          function_obj_p = ecma_op_create_arrow_function_object (scope_p,
        -: 5124:                                                                 function_bytecode_p,
        -: 5125:                                                                 ECMA_VALUE_UNDEFINED);
        -: 5126:        }
        -: 5127:        else
        -: 5128:        {
    #####: 5129:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5130:        }
        -: 5131:
    #####: 5132:        READ_LITERAL_INDEX (literal_index);
    #####: 5133:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5134:
    #####: 5135:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5136:
        -: 5137:        ecma_property_value_t *property_value_p;
    #####: 5138:        property_value_p = ecma_create_named_data_property (scope_p,
        -: 5139:                                                            name_p,
        -: 5140:                                                            ECMA_PROPERTY_FLAG_WRITABLE,
        -: 5141:                                                            NULL);
        -: 5142:
    #####: 5143:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5144:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5145:        ecma_deref_object (function_obj_p);
    #####: 5146:        break;
        -: 5147:      }
    #####: 5148:      default:
        -: 5149:      {
    #####: 5150:        JERRY_ASSERT (opcode == CBC_RETURN_WITH_BLOCK);
    #####: 5151:        return ECMA_VALUE_EMPTY;
        -: 5152:      }
        -: 5153:    }
        -: 5154:  }
        -: 5155:} /* vm_init_module_scope */
        -: 5156:
        -: 5157:#endif /* JERRY_MODULE_SYSTEM */
        -: 5158:
        -: 5159:#undef READ_LITERAL
        -: 5160:#undef READ_LITERAL_INDEX
        -: 5161:
        -: 5162:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5163:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5164:
        -: 5165:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5166:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5167:
        -: 5168:/**
        -: 5169: * Initialize code block execution
        -: 5170: *
        -: 5171: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5172: *         ECMA_VALUE_EMPTY - otherwise
        -: 5173: */
        -: 5174:static void JERRY_ATTR_NOINLINE
        8: 5175:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5176:{
        8: 5177:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        8: 5178:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5179:
        8: 5180:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
        8: 5181:  frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        8: 5182:  frame_ctx_p->context_depth = 0;
       16: 5183:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
        8: 5184:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5185:
        -: 5186:  uint16_t argument_end, register_end;
        -: 5187:  ecma_value_t *literal_p;
        -: 5188:
        8: 5189:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5190:  {
    #####: 5191:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5192:
    #####: 5193:    argument_end = args_p->argument_end;
    #####: 5194:    register_end = args_p->register_end;
        -: 5195:
    #####: 5196:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5197:    literal_p -= register_end;
    #####: 5198:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5199:    literal_p += args_p->literal_end;
        -: 5200:  }
        -: 5201:  else
        -: 5202:  {
        8: 5203:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5204:
        8: 5205:    argument_end = args_p->argument_end;
        8: 5206:    register_end = args_p->register_end;
        -: 5207:
        8: 5208:    literal_p = (ecma_value_t *) (args_p + 1);
        8: 5209:    literal_p -= register_end;
        8: 5210:    frame_ctx_p->literal_start_p = literal_p;
        8: 5211:    literal_p += args_p->literal_end;
        -: 5212:  }
        -: 5213:
        8: 5214:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
        8: 5215:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
        8: 5216:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5217:
        8: 5218:  uint32_t arg_list_len = 0;
        -: 5219:
        8: 5220:  if (argument_end > 0)
        -: 5221:  {
        3: 5222:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5223:
        3: 5224:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
        3: 5225:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5226:
        3: 5227:    if (arg_list_len > argument_end)
        -: 5228:    {
    #####: 5229:      arg_list_len = argument_end;
        -: 5230:    }
        -: 5231:
        6: 5232:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5233:    {
        3: 5234:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5235:    }
        -: 5236:  }
        -: 5237:
        -: 5238:  /* The arg_list_len contains the end of the copied arguments.
        -: 5239:   * Fill everything else with undefined. */
        8: 5240:  if (register_end > arg_list_len)
        -: 5241:  {
        1: 5242:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5243:
        3: 5244:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5245:    {
        2: 5246:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5247:    }
        -: 5248:  }
        -: 5249:
        8: 5250:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        8: 5251:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
        8: 5252:} /* vm_init_exec */
        -: 5253:
        -: 5254:/**
        -: 5255: * Resume execution of a code block.
        -: 5256: *
        -: 5257: * @return ecma value
        -: 5258: */
        -: 5259:ecma_value_t JERRY_ATTR_NOINLINE
       10: 5260:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5261:{
        -: 5262:  while (true)
        2: 5263:  {
       10: 5264:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5265:
       10: 5266:    switch (frame_ctx_p->call_operation)
        -: 5267:    {
        2: 5268:      case VM_EXEC_CALL:
        -: 5269:      {
        2: 5270:        opfunc_call (frame_ctx_p);
        2: 5271:        break;
        -: 5272:      }
        -: 5273:#if JERRY_ESNEXT
    #####: 5274:      case VM_EXEC_SUPER_CALL:
        -: 5275:      {
    #####: 5276:        vm_super_call (frame_ctx_p);
    #####: 5277:        break;
        -: 5278:      }
    #####: 5279:      case VM_EXEC_SPREAD_OP:
        -: 5280:      {
    #####: 5281:        vm_spread_operation (frame_ctx_p);
    #####: 5282:        break;
        -: 5283:      }
    #####: 5284:      case VM_EXEC_RETURN:
        -: 5285:      {
    #####: 5286:        return completion_value;
        -: 5287:      }
        -: 5288:#endif /* JERRY_ESNEXT */
    #####: 5289:      case VM_EXEC_CONSTRUCT:
        -: 5290:      {
    #####: 5291:        opfunc_construct (frame_ctx_p);
    #####: 5292:        break;
        -: 5293:      }
        8: 5294:      default:
        -: 5295:      {
        8: 5296:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5297:
        8: 5298:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5299:        uint32_t register_end;
        -: 5300:
        8: 5301:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5302:        {
    #####: 5303:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5304:        }
        -: 5305:        else
        -: 5306:        {
        8: 5307:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5308:        }
        -: 5309:
        -: 5310:        /* Free arguments and registers */
        8: 5311:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
       13: 5312:        for (uint32_t i = 0; i < register_end; i++)
        -: 5313:        {
        5: 5314:          ecma_fast_free_value (registers_p[i]);
        -: 5315:        }
        -: 5316:
        -: 5317:#if JERRY_DEBUGGER
        -: 5318:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5319:        {
        -: 5320:          /* The engine will stop when the next breakpoint is reached. */
        -: 5321:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5322:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5323:        }
        -: 5324:#endif /* JERRY_DEBUGGER */
        -: 5325:
        8: 5326:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
        8: 5327:        return completion_value;
        -: 5328:      }
        -: 5329:    }
        -: 5330:  }
        -: 5331:} /* vm_execute */
        -: 5332:
        -: 5333:/**
        -: 5334: * Run the code.
        -: 5335: *
        -: 5336: * @return ecma value
        -: 5337: */
        -: 5338:ecma_value_t
        8: 5339:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5340:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5341:        ecma_object_t *lex_env_p) /**< lexical environment to use */
        8: 5342:{
        8: 5343:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5344:  vm_frame_ctx_t *frame_ctx_p;
        -: 5345:  size_t frame_size;
        -: 5346:
        8: 5347:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5348:  {
    #####: 5349:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5350:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5351:  }
        -: 5352:  else
        -: 5353:  {
        8: 5354:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        8: 5355:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5356:  }
        -: 5357:
        8: 5358:  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);
        8: 5359:  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);
        -: 5360:
        -: 5361:  /* Use JERRY_MAX() to avoid array declaration with size 0. */
        8: 5362:  JERRY_VLA (uintptr_t, stack, frame_size);
        -: 5363:
        8: 5364:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5365:
        8: 5366:  frame_ctx_p->shared_p = shared_p;
        8: 5367:  frame_ctx_p->lex_env_p = lex_env_p;
        8: 5368:  frame_ctx_p->this_binding = this_binding_value;
        -: 5369:
        8: 5370:  vm_init_exec (frame_ctx_p);
        8: 5371:  return vm_execute (frame_ctx_p);
        -: 5372:} /* vm_run */
        -: 5373:
        -: 5374:/**
        -: 5375: * @}
        -: 5376: * @}
        -: 5377: */
