        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-comparison.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-string-object.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_ARRAY
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_ARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   48:  /* Note: these 2 routine ids must be in this order */
        -:   49:#if !JERRY_ESNEXT
        -:   50:  ECMA_ARRAY_PROTOTYPE_TO_STRING,
        -:   51:#endif /* !JERRY_ESNEXT */
        -:   52:  ECMA_ARRAY_PROTOTYPE_SORT,
        -:   53:  ECMA_ARRAY_PROTOTYPE_CONCAT,
        -:   54:  ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING,
        -:   55:  ECMA_ARRAY_PROTOTYPE_JOIN,
        -:   56:  ECMA_ARRAY_PROTOTYPE_POP,
        -:   57:  ECMA_ARRAY_PROTOTYPE_PUSH,
        -:   58:  ECMA_ARRAY_PROTOTYPE_REVERSE,
        -:   59:  ECMA_ARRAY_PROTOTYPE_SHIFT,
        -:   60:  ECMA_ARRAY_PROTOTYPE_SLICE,
        -:   61:  ECMA_ARRAY_PROTOTYPE_SPLICE,
        -:   62:  ECMA_ARRAY_PROTOTYPE_UNSHIFT,
        -:   63:  ECMA_ARRAY_PROTOTYPE_AT,
        -:   64:  ECMA_ARRAY_PROTOTYPE_INDEX_OF,
        -:   65:  ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF,
        -:   66:  /* Note these 3 routines must be in this order */
        -:   67:  ECMA_ARRAY_PROTOTYPE_EVERY,
        -:   68:  ECMA_ARRAY_PROTOTYPE_SOME,
        -:   69:  ECMA_ARRAY_PROTOTYPE_FOR_EACH,
        -:   70:  ECMA_ARRAY_PROTOTYPE_MAP,
        -:   71:  ECMA_ARRAY_PROTOTYPE_FILTER,
        -:   72:  /* Note these 2 routines must be in this order */
        -:   73:  ECMA_ARRAY_PROTOTYPE_REDUCE,
        -:   74:  ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT,
        -:   75:  ECMA_ARRAY_PROTOTYPE_FIND,
        -:   76:  ECMA_ARRAY_PROTOTYPE_FIND_INDEX,
        -:   77:  ECMA_ARRAY_PROTOTYPE_ENTRIES,
        -:   78:  ECMA_ARRAY_PROTOTYPE_KEYS,
        -:   79:  ECMA_ARRAY_PROTOTYPE_SYMBOL_ITERATOR,
        -:   80:  ECMA_ARRAY_PROTOTYPE_FILL,
        -:   81:  ECMA_ARRAY_PROTOTYPE_COPY_WITHIN,
        -:   82:  ECMA_ARRAY_PROTOTYPE_INCLUDES,
        -:   83:  ECMA_ARRAY_PROTOTYPE_FLAT,
        -:   84:  ECMA_ARRAY_PROTOTYPE_FLATMAP,
        -:   85:};
        -:   86:
        -:   87:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array-prototype.inc.h"
        -:   88:#define BUILTIN_UNDERSCORED_ID array_prototype
        -:   89:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   90:
        -:   91:/** \addtogroup ecma ECMA
        -:   92: * @{
        -:   93: *
        -:   94: * \addtogroup ecmabuiltins
        -:   95: * @{
        -:   96: *
        -:   97: * \addtogroup arrayprototype ECMA Array.prototype object built-in
        -:   98: * @{
        -:   99: */
        -:  100:
        -:  101:/**
        -:  102: * Helper function to set an object's length property
        -:  103: *
        -:  104: * @return ecma value (return value of the [[Put]] method)
        -:  105: *         Calling ecma_free_value on the returned value is optional if it is not abrupt completion.
        -:  106: */
        -:  107:static ecma_value_t
    #####:  108:ecma_builtin_array_prototype_helper_set_length (ecma_object_t *object, /**< object*/
        -:  109:                                                ecma_number_t length) /**< new length */
        -:  110:{
    #####:  111:  ecma_value_t length_value = ecma_make_number_value (length);
    #####:  112:  ecma_value_t ret_value = ecma_op_object_put (object,
        -:  113:                                               ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  114:                                               length_value,
        -:  115:                                               true);
        -:  116:
    #####:  117:  ecma_free_value (length_value);
        -:  118:
    #####:  119:  JERRY_ASSERT (ecma_is_value_boolean (ret_value)
        -:  120:                || ecma_is_value_empty (ret_value)
        -:  121:                || ECMA_IS_VALUE_ERROR (ret_value));
    #####:  122:  return ret_value;
        -:  123:} /* ecma_builtin_array_prototype_helper_set_length */
        -:  124:
        -:  125:/**
        -:  126: * The Array.prototype object's 'toLocaleString' routine
        -:  127: *
        -:  128: * See also:
        -:  129: *          ECMA-262 v5, 15.4.4.3
        -:  130: *
        -:  131: * @return ecma value
        -:  132: *         Returned value must be freed with ecma_free_value.
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_builtin_array_prototype_object_to_locale_string (ecma_object_t *obj_p, /**< object */
        -:  136:                                                      ecma_length_t length) /**< object's length */
        -:  137:{
        -:  138:  /* 5. */
    #####:  139:  if (length == 0)
        -:  140:  {
    #####:  141:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  142:  }
        -:  143:
        -:  144:  /* 7-8. */
    #####:  145:  ecma_string_t *first_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, 0);
        -:  146:
    #####:  147:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  148:  {
    #####:  149:    return ECMA_VALUE_ERROR;
        -:  150:  }
        -:  151:
    #####:  152:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  153:  ecma_deref_ecma_string (first_string_p);
        -:  154:
        -:  155:  /* 9-10. */
    #####:  156:  for (ecma_length_t k = 1; k < length; k++)
        -:  157:  {
        -:  158:    /* 4. Implementation-defined: set the separator to a single comma character. */
    #####:  159:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
        -:  160:
    #####:  161:    ecma_string_t *next_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, k);
        -:  162:
    #####:  163:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  164:    {
    #####:  165:      ecma_stringbuilder_destroy (&builder);
    #####:  166:      return ECMA_VALUE_ERROR;
        -:  167:    }
        -:  168:
    #####:  169:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  170:    ecma_deref_ecma_string (next_string_p);
        -:  171:  }
        -:  172:
    #####:  173:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  174:} /* ecma_builtin_array_prototype_object_to_locale_string */
        -:  175:
        -:  176:/**
        -:  177: * The Array.prototype object's 'concat' routine
        -:  178: *
        -:  179: * See also:
        -:  180: *          ECMA-262 v5, 15.4.4.4
        -:  181: *
        -:  182: * @return ecma value
        -:  183: *         Returned value must be freed with ecma_free_value.
        -:  184: */
        -:  185:static ecma_value_t
    #####:  186:ecma_builtin_array_prototype_object_concat (const ecma_value_t args[], /**< arguments list */
        -:  187:                                            uint32_t args_number, /**< number of arguments */
        -:  188:                                            ecma_object_t *obj_p) /**< array object */
        -:  189:{
        -:  190:  /* 2. */
        -:  191:#if JERRY_ESNEXT
    #####:  192:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -:  193:
    #####:  194:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:#else /* !JERRY_ESNEXT */
    #####:  199:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  200:#endif /* JERRY_ESNEXT */
        -:  201:
    #####:  202:  ecma_length_t new_length = 0;
        -:  203:
        -:  204:  /* 5.b - 5.c for this_arg */
    #####:  205:  ecma_value_t concat_this_value = ecma_builtin_helper_array_concat_value (new_array_p,
        -:  206:                                                                           &new_length,
        -:  207:                                                                           ecma_make_object_value (obj_p));
    #####:  208:  if (ECMA_IS_VALUE_ERROR (concat_this_value))
        -:  209:  {
    #####:  210:    ecma_deref_object (new_array_p);
    #####:  211:    return concat_this_value;
        -:  212:  }
        -:  213:
    #####:  214:  JERRY_ASSERT (ecma_is_value_empty (concat_this_value));
        -:  215:
        -:  216:  /* 5. */
    #####:  217:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:  218:  {
    #####:  219:    ecma_value_t concat_value = ecma_builtin_helper_array_concat_value (new_array_p, &new_length, args[arg_index]);
        -:  220:
    #####:  221:    if (ECMA_IS_VALUE_ERROR (concat_value))
        -:  222:    {
    #####:  223:      ecma_deref_object (new_array_p);
    #####:  224:      return concat_value;
        -:  225:    }
        -:  226:
    #####:  227:    JERRY_ASSERT (ecma_is_value_empty (concat_value));
        -:  228:  }
        -:  229:
    #####:  230:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -:  231:                                                                                  ((ecma_number_t) new_length));
    #####:  232:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  233:  {
    #####:  234:    ecma_deref_object (new_array_p);
    #####:  235:    return set_length_value;
        -:  236:  }
        -:  237:
    #####:  238:  return ecma_make_object_value (new_array_p);
        -:  239:} /* ecma_builtin_array_prototype_object_concat */
        -:  240:
        -:  241:/**
        -:  242: * The Array.prototype.toString's separator creation routine
        -:  243: *
        -:  244: * See also:
        -:  245: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  246: *
        -:  247: * @return NULL - if the conversion fails
        -:  248: *         ecma_string_t * - otherwise
        -:  249: */
        -:  250:
        -:  251:static ecma_string_t *
    #####:  252:ecma_op_array_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  253:{
    #####:  254:  if (ecma_is_value_undefined (separator))
        -:  255:  {
    #####:  256:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  257:  }
        -:  258:
    #####:  259:  return ecma_op_to_string (separator);
        -:  260:} /* ecma_op_array_get_separator_string */
        -:  261:
        -:  262:/**
        -:  263: * The Array.prototype's 'toString' single element operation routine
        -:  264: *
        -:  265: * See also:
        -:  266: *          ECMA-262 v5.1, 15.4.4.2
        -:  267: *
        -:  268: * @return NULL - if the conversion fails
        -:  269: *         ecma_string_t * - otherwise
        -:  270: */
        -:  271:static ecma_string_t *
    #####:  272:ecma_op_array_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  273:                                      ecma_length_t index) /**< array index */
        -:  274:{
    #####:  275:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  276:
    #####:  277:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  278:  {
    #####:  279:    return NULL;
        -:  280:  }
        -:  281:
    #####:  282:  if (ecma_is_value_undefined (index_value)
    #####:  283:      || ecma_is_value_null (index_value))
        -:  284:  {
    #####:  285:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  286:  }
        -:  287:
    #####:  288:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  289:
    #####:  290:  ecma_free_value (index_value);
        -:  291:
    #####:  292:  return ret_str_p;
        -:  293:} /* ecma_op_array_get_to_string_at_index */
        -:  294:
        -:  295:/**
        -:  296: * The Array.prototype object's 'join' routine
        -:  297: *
        -:  298: * See also:
        -:  299: *          ECMA-262 v5, 15.4.4.5
        -:  300: *
        -:  301: * @return ecma value
        -:  302: *         Returned value must be freed with ecma_free_value.
        -:  303: */
        -:  304:static ecma_value_t
    #####:  305:ecma_builtin_array_prototype_join (ecma_value_t separator_arg, /**< separator argument */
        -:  306:                                   ecma_object_t *obj_p, /**< object */
        -:  307:                                   ecma_length_t length) /**< object's length */
        -:  308:{
        -:  309:  /* 4-5. */
    #####:  310:  ecma_string_t *separator_string_p = ecma_op_array_get_separator_string (separator_arg);
        -:  311:
    #####:  312:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  313:  {
    #####:  314:    return ECMA_VALUE_ERROR;
        -:  315:  }
        -:  316:
    #####:  317:  if (length == 0)
        -:  318:  {
        -:  319:    /* 6. */
    #####:  320:    ecma_deref_ecma_string (separator_string_p);
    #####:  321:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  322:  }
        -:  323:
        -:  324:  /* 7-8. */
    #####:  325:  ecma_string_t *first_string_p = ecma_op_array_get_to_string_at_index (obj_p, 0);
        -:  326:
    #####:  327:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  328:  {
    #####:  329:    ecma_deref_ecma_string (separator_string_p);
    #####:  330:    return ECMA_VALUE_ERROR;
        -:  331:  }
        -:  332:
    #####:  333:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  334:  ecma_deref_ecma_string (first_string_p);
        -:  335:
        -:  336:  /* 9-10. */
    #####:  337:  for (ecma_length_t k = 1; k < length; k++)
        -:  338:  {
        -:  339:    /* 10.a */
    #####:  340:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  341:
        -:  342:    /* 10.d */
    #####:  343:    ecma_string_t *next_string_p = ecma_op_array_get_to_string_at_index (obj_p, k);
        -:  344:
    #####:  345:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  346:    {
    #####:  347:      ecma_deref_ecma_string (separator_string_p);
    #####:  348:      ecma_stringbuilder_destroy (&builder);
    #####:  349:      return ECMA_VALUE_ERROR;
        -:  350:    }
        -:  351:
    #####:  352:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  353:    ecma_deref_ecma_string (next_string_p);
        -:  354:  }
        -:  355:
    #####:  356:  ecma_deref_ecma_string (separator_string_p);
    #####:  357:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  358:} /* ecma_builtin_array_prototype_join */
        -:  359:
        -:  360:/**
        -:  361: * The Array.prototype object's 'pop' routine
        -:  362: *
        -:  363: * See also:
        -:  364: *          ECMA-262 v5, 15.4.4.6
        -:  365: *
        -:  366: * @return ecma value
        -:  367: *         Returned value must be freed with ecma_free_value.
        -:  368: */
        -:  369:static ecma_value_t
    #####:  370:ecma_builtin_array_prototype_object_pop (ecma_object_t *obj_p, /**< object */
        -:  371:                                         ecma_length_t len) /**< object's length */
        -:  372:{
        -:  373:   /* 4. */
    #####:  374:  if (len == 0)
        -:  375:  {
        -:  376:    /* 4.a */
    #####:  377:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  378:
        -:  379:    /* 4.b */
    #####:  380:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  381:  }
        -:  382:
        -:  383:  /* 5.b */
    #####:  384:  len--;
    #####:  385:  ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, len);
        -:  386:
    #####:  387:  if (ECMA_IS_VALUE_ERROR (get_value))
        -:  388:  {
    #####:  389:    return get_value;
        -:  390:  }
        -:  391:
    #####:  392:  if (ecma_op_object_is_fast_array (obj_p))
        -:  393:  {
    #####:  394:    ecma_delete_fast_array_properties (obj_p, (uint32_t) len);
        -:  395:
    #####:  396:    return get_value;
        -:  397:  }
        -:  398:
        -:  399:  /* 5.c */
    #####:  400:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, len, true);
        -:  401:
    #####:  402:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  403:  {
    #####:  404:    ecma_free_value (get_value);
    #####:  405:    return del_value;
        -:  406:  }
        -:  407:
    #####:  408:  ecma_free_value (del_value);
        -:  409:
        -:  410:  /* 5.d */
    #####:  411:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  412:
    #####:  413:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  414:  {
    #####:  415:    ecma_free_value (get_value);
    #####:  416:    return set_length_value;
        -:  417:  }
        -:  418:
    #####:  419:  return get_value;
        -:  420:} /* ecma_builtin_array_prototype_object_pop */
        -:  421:
        -:  422:/**
        -:  423: * The Array.prototype object's 'push' routine
        -:  424: *
        -:  425: * See also:
        -:  426: *          ECMA-262 v5, 15.4.4.7
        -:  427: *
        -:  428: * @return ecma value
        -:  429: *         Returned value must be freed with ecma_free_value.
        -:  430: */
        -:  431:static ecma_value_t
    #####:  432:ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */
        -:  433:                                          uint32_t arguments_number, /**< number of arguments */
        -:  434:                                          ecma_object_t *obj_p, /**< object */
        -:  435:                                          ecma_length_t length) /**< object's length */
        -:  436:{
    #####:  437:  if (ecma_op_object_is_fast_array (obj_p))
        -:  438:  {
    #####:  439:    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)
        -:  440:    {
    #####:  441:      return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -:  442:    }
        -:  443:
    #####:  444:    if (arguments_number == 0)
        -:  445:    {
    #####:  446:      return ecma_make_uint32_value ((uint32_t) length);
        -:  447:    }
        -:  448:
    #####:  449:    uint32_t new_length = ((uint32_t) length) + arguments_number;
    #####:  450:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  451:    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;
        -:  452:
    #####:  453:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  454:    {
    #####:  455:      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);
        -:  456:    }
        -:  457:
    #####:  458:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;
        -:  459:
    #####:  460:    return ecma_make_uint32_value (new_length);
        -:  461:  }
        -:  462:
        -:  463:#if JERRY_ESNEXT
        -:  464:  /* 5. */
    #####:  465:  if ((ecma_number_t) (length + arguments_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  466:  {
    #####:  467:    return ecma_raise_type_error (ECMA_ERR_MSG ("Pushing element over 2**53-1 length is disallowed"));
        -:  468:  }
        -:  469:
        -:  470:  /* 6. */
    #####:  471:  for (ecma_length_t index = 0; index < arguments_number; index++, length++)
        -:  472:  {
        -:  473:    /* 6.b */
    #####:  474:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, length, argument_list_p[index], true);
        -:  475:
    #####:  476:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  477:    {
    #####:  478:      return put_value;
        -:  479:    }
        -:  480:  }
        -:  481:
    #####:  482:  ecma_number_t n = (ecma_number_t) length;
        -:  483:#else /* JERRY_ESNEXT */
    #####:  484:  ecma_number_t n = (ecma_number_t) length;
        -:  485:
        -:  486:  /* 5. */
    #####:  487:  for (ecma_length_t index = 0; index < arguments_number; index++, n++)
        -:  488:  {
        -:  489:    /* 5.b */
    #####:  490:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (n);
    #####:  491:    ecma_value_t put_value = ecma_op_object_put (obj_p, index_str_p, argument_list_p[index], true);
    #####:  492:    ecma_deref_ecma_string (index_str_p);
        -:  493:
    #####:  494:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  495:    {
        -:  496:      return put_value;
        -:  497:    }
        -:  498:  }
        -:  499:
        -:  500:#endif /* JERRY_ESNEXT */
        -:  501:  /* 6 - 7. */
    #####:  502:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);
        -:  503:
    #####:  504:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  505:  {
    #####:  506:    return set_length_value;
        -:  507:  }
        -:  508:
    #####:  509:  return ecma_make_number_value (n);
        -:  510:} /* ecma_builtin_array_prototype_object_push */
        -:  511:
        -:  512:/**
        -:  513: * The Array.prototype object's 'reverse' routine
        -:  514: *
        -:  515: * See also:
        -:  516: *          ECMA-262 v5, 15.4.4.8
        -:  517: *
        -:  518: * @return ecma value
        -:  519: *         Returned value must be freed with ecma_free_value.
        -:  520: */
        -:  521:static ecma_value_t
    #####:  522:ecma_builtin_array_prototype_object_reverse (ecma_value_t this_arg, /**< this argument */
        -:  523:                                             ecma_object_t *obj_p, /**< object */
        -:  524:                                             ecma_length_t len) /**< object's length */
        -:  525:{
        -:  526:
    #####:  527:  if (ecma_op_object_is_fast_array (obj_p))
        -:  528:  {
    #####:  529:    uint32_t middle = (uint32_t) len / 2;
    #####:  530:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  531:
    #####:  532:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  533:        && len != 0)
        -:  534:    {
    #####:  535:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  536:
    #####:  537:      for (uint32_t i = 0; i < middle; i++)
        -:  538:      {
    #####:  539:        ecma_value_t tmp = buffer_p[i];
    #####:  540:        buffer_p[i] = buffer_p[len - 1 - i];
    #####:  541:        buffer_p[len - 1 - i] = tmp;
        -:  542:      }
        -:  543:
    #####:  544:      return ecma_copy_value (this_arg);
        -:  545:    }
        -:  546:  }
        -:  547:
    #####:  548:  ecma_length_t middle = len / 2;
    #####:  549:  for (ecma_length_t lower = 0; lower < middle; lower++)
        -:  550:  {
    #####:  551:    ecma_length_t upper = len - lower - 1;
    #####:  552:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  553:
    #####:  554:    ecma_string_t *lower_str_p = ecma_new_ecma_string_from_length (lower);
    #####:  555:    ecma_string_t *upper_str_p = ecma_new_ecma_string_from_length (upper);
        -:  556:
        -:  557:#if JERRY_ESNEXT
    #####:  558:    ecma_value_t lower_value = ECMA_VALUE_EMPTY;
    #####:  559:    ecma_value_t upper_value = ECMA_VALUE_EMPTY;
        -:  560:
    #####:  561:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
        -:  562:
        -:  563:#if JERRY_BUILTIN_PROXY
    #####:  564:    if (ECMA_IS_VALUE_ERROR (has_lower))
        -:  565:    {
    #####:  566:      goto clean_up;
        -:  567:    }
        -:  568:#endif /* JERRY_BUILTIN_PROXY */
        -:  569:
    #####:  570:    bool lower_exist = ecma_is_value_true (has_lower);
        -:  571:
    #####:  572:    if (lower_exist)
        -:  573:    {
    #####:  574:      lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  575:
    #####:  576:      if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  577:      {
    #####:  578:        goto clean_up;
        -:  579:      }
        -:  580:    }
        -:  581:
    #####:  582:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  583:
        -:  584:#if JERRY_BUILTIN_PROXY
    #####:  585:    if (ECMA_IS_VALUE_ERROR (has_upper))
        -:  586:    {
    #####:  587:      goto clean_up;
        -:  588:    }
        -:  589:#endif /* JERRY_BUILTIN_PROXY */
        -:  590:
    #####:  591:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  592:
    #####:  593:    if (upper_exist)
        -:  594:    {
    #####:  595:      upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  596:
    #####:  597:      if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  598:      {
    #####:  599:        goto clean_up;
        -:  600:      }
        -:  601:    }
        -:  602:#else /* !JERRY_ESNEXT */
    #####:  603:    ecma_value_t lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  604:
    #####:  605:    if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  606:    {
    #####:  607:      ecma_deref_ecma_string (lower_str_p);
    #####:  608:      ecma_deref_ecma_string (upper_str_p);
    #####:  609:      return ret_value;
        -:  610:    }
        -:  611:
    #####:  612:    ecma_value_t upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  613:
    #####:  614:    if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  615:    {
        -:  616:      goto clean_up;
        -:  617:    }
        -:  618:
    #####:  619:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
    #####:  620:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  621:
    #####:  622:    bool lower_exist = ecma_is_value_true (has_lower);
    #####:  623:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  624:#endif /* JERRY_ESNEXT */
        -:  625:
    #####:  626:    if (lower_exist && upper_exist)
    #####:  627:    {
    #####:  628:      ecma_value_t outer_put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  629:
    #####:  630:      if (ECMA_IS_VALUE_ERROR (outer_put_value))
        -:  631:      {
    #####:  632:        goto clean_up;
        -:  633:      }
        -:  634:
    #####:  635:      ecma_value_t inner_put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  636:
    #####:  637:      if (ECMA_IS_VALUE_ERROR (inner_put_value))
        -:  638:      {
    #####:  639:        goto clean_up;
        -:  640:      }
        -:  641:    }
    #####:  642:    else if (!lower_exist && upper_exist)
    #####:  643:    {
    #####:  644:      ecma_value_t put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  645:
    #####:  646:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  647:      {
    #####:  648:        goto clean_up;
        -:  649:      }
        -:  650:
    #####:  651:      ecma_value_t del_value = ecma_op_object_delete (obj_p, upper_str_p, true);
        -:  652:
    #####:  653:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  654:      {
    #####:  655:        goto clean_up;
        -:  656:      }
        -:  657:    }
    #####:  658:    else if (lower_exist)
        -:  659:    {
    #####:  660:      ecma_value_t del_value = ecma_op_object_delete (obj_p, lower_str_p, true);
        -:  661:
    #####:  662:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  663:      {
    #####:  664:        goto clean_up;
        -:  665:      }
        -:  666:
    #####:  667:      ecma_value_t put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  668:
    #####:  669:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  670:      {
    #####:  671:        goto clean_up;
        -:  672:      }
        -:  673:    }
        -:  674:
    #####:  675:    ret_value = ECMA_VALUE_EMPTY;
        -:  676:
    #####:  677:clean_up:
    #####:  678:    ecma_free_value (upper_value);
    #####:  679:    ecma_free_value (lower_value);
    #####:  680:    ecma_deref_ecma_string (lower_str_p);
    #####:  681:    ecma_deref_ecma_string (upper_str_p);
        -:  682:
    #####:  683:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  684:    {
    #####:  685:      return ret_value;
        -:  686:    }
        -:  687:  }
        -:  688:
    #####:  689:  return ecma_copy_value (this_arg);
        -:  690:} /* ecma_builtin_array_prototype_object_reverse */
        -:  691:
        -:  692:/**
        -:  693: * The Array.prototype object's 'shift' routine
        -:  694: *
        -:  695: * See also:
        -:  696: *          ECMA-262 v5, 15.4.4.9
        -:  697: *
        -:  698: * @return ecma value
        -:  699: *         Returned value must be freed with ecma_free_value.
        -:  700: */
        -:  701:static ecma_value_t
    #####:  702:ecma_builtin_array_prototype_object_shift (ecma_object_t *obj_p, /**< object */
        -:  703:                                           ecma_length_t len) /**< object's length */
        -:  704:{
        -:  705:  /* 4. */
    #####:  706:  if (len == 0)
        -:  707:  {
    #####:  708:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  709:
    #####:  710:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  711:  }
        -:  712:
    #####:  713:  if (ecma_op_object_is_fast_array (obj_p))
        -:  714:  {
    #####:  715:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  716:
    #####:  717:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  718:        && len != 0)
        -:  719:    {
    #####:  720:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
    #####:  721:      ecma_value_t ret_value = buffer_p[0];
        -:  722:
    #####:  723:      if (ecma_is_value_object (ret_value))
        -:  724:      {
    #####:  725:        ecma_ref_object (ecma_get_object_from_value (ret_value));
        -:  726:      }
        -:  727:
    #####:  728:      memmove (buffer_p, buffer_p + 1, (size_t) (sizeof (ecma_value_t) * (len - 1)));
        -:  729:
    #####:  730:      buffer_p[len - 1] = ECMA_VALUE_UNDEFINED;
    #####:  731:      ecma_delete_fast_array_properties (obj_p, (uint32_t) (len - 1));
        -:  732:
    #####:  733:      return ret_value;
        -:  734:    }
        -:  735:  }
        -:  736:
        -:  737:  /* 5. */
    #####:  738:  ecma_value_t first_value = ecma_op_object_get_by_index (obj_p, 0);
        -:  739:
    #####:  740:  if (ECMA_IS_VALUE_ERROR (first_value))
        -:  741:  {
    #####:  742:    return first_value;
        -:  743:  }
        -:  744:
        -:  745:  /* 6. and 7. */
    #####:  746:  for (ecma_length_t k = 1; k < len; k++)
        -:  747:  {
        -:  748:    /* 7.a - 7.c */
    #####:  749:    ecma_value_t curr_value = ecma_op_object_find_by_index (obj_p, k);
        -:  750:
    #####:  751:    if (ECMA_IS_VALUE_ERROR (curr_value))
        -:  752:    {
    #####:  753:      ecma_free_value (first_value);
    #####:  754:      return curr_value;
        -:  755:    }
        -:  756:
        -:  757:    /* 7.b */
    #####:  758:    ecma_length_t to = k - 1;
        -:  759:    ecma_value_t operation_value;
        -:  760:
    #####:  761:    if (ecma_is_value_found (curr_value))
        -:  762:    {
        -:  763:      /* 7.d.i, 7.d.ii */
    #####:  764:      operation_value = ecma_op_object_put_by_index (obj_p, to, curr_value, true);
    #####:  765:      ecma_free_value (curr_value);
        -:  766:    }
        -:  767:    else
        -:  768:    {
        -:  769:      /* 7.e.i */
    #####:  770:      operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -:  771:    }
        -:  772:
    #####:  773:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -:  774:    {
    #####:  775:      ecma_free_value (first_value);
    #####:  776:      return operation_value;
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  /* 8. */
    #####:  781:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, --len, true);
        -:  782:
    #####:  783:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  784:  {
    #####:  785:    ecma_free_value (first_value);
    #####:  786:    return del_value;
        -:  787:  }
        -:  788:
        -:  789:  /* 9. */
    #####:  790:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  791:
    #####:  792:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  793:  {
    #####:  794:    ecma_free_value (first_value);
    #####:  795:    return set_length_value;
        -:  796:  }
        -:  797:
        -:  798:  /* 10. */
    #####:  799:  return first_value;
        -:  800:} /* ecma_builtin_array_prototype_object_shift */
        -:  801:
        -:  802:/**
        -:  803: * The Array.prototype object's 'slice' routine
        -:  804: *
        -:  805: * See also:
        -:  806: *          ECMA-262 v5, 15.4.4.10
        -:  807: *
        -:  808: * @return ecma value
        -:  809: *         Returned value must be freed with ecma_free_value.
        -:  810: */
        -:  811:static ecma_value_t
    #####:  812:ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */
        -:  813:                                           ecma_value_t arg2, /**< end */
        -:  814:                                           ecma_object_t *obj_p, /**< object */
        -:  815:                                           ecma_length_t len) /**< object's length */
        -:  816:{
    #####:  817:  ecma_length_t start = 0, end = len;
        -:  818:
        -:  819:  /* 5. 6.*/
    #####:  820:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,
        -:  821:                                                                      len,
        -:  822:                                                                      &start)))
        -:  823:  {
    #####:  824:    return ECMA_VALUE_ERROR;
        -:  825:  }
        -:  826:
        -:  827:  /* 7. */
    #####:  828:  if (ecma_is_value_undefined (arg2))
        -:  829:  {
    #####:  830:    end = len;
        -:  831:  }
        -:  832:  else
        -:  833:  {
        -:  834:    /* 7. part 2, 8.*/
    #####:  835:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,
        -:  836:                                                                        len,
        -:  837:                                                                        &end)))
        -:  838:    {
    #####:  839:      return ECMA_VALUE_ERROR;
        -:  840:    }
        -:  841:  }
        -:  842:
    #####:  843:  JERRY_ASSERT (start <= len && end <= len);
        -:  844:
    #####:  845:  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);
    #####:  846:  ecma_length_t copied_length = (end > start) ? end - start : 0;
        -:  847:#if JERRY_ESNEXT
    #####:  848:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);
        -:  849:
    #####:  850:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  851:  {
    #####:  852:    return ECMA_VALUE_ERROR;
        -:  853:  }
        -:  854:
    #####:  855:  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);
        -:  856:#else /* !JERRY_ESNEXT */
    #####:  857:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  858:#endif /* JERRY_ESNEXT */
        -:  859:
    #####:  860:  if (use_fast_path && copied_length > 0)
        -:  861:  {
    #####:  862:    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;
        -:  863:
    #####:  864:    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -:  865:    {
    #####:  866:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -:  867:      {
        -:  868:        /**
        -:  869:         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.
        -:  870:         * There is no need to do any copy.
        -:  871:         */
    #####:  872:        return ecma_make_object_value (new_array_p);
        -:  873:      }
        -:  874:
    #####:  875:      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;
        -:  876:
        -:  877:#if JERRY_ESNEXT
    #####:  878:      uint32_t target_length = ext_to_obj_p->u.array.length;
        -:  879:      ecma_value_t *to_buffer_p;
    #####:  880:      JERRY_ASSERT (copied_length <= UINT32_MAX);
        -:  881:
    #####:  882:      if (copied_length == target_length)
        -:  883:      {
    #####:  884:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  885:      }
    #####:  886:      else if (copied_length > target_length)
        -:  887:      {
    #####:  888:        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);
        -:  889:      }
        -:  890:      else
        -:  891:      {
    #####:  892:        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);
    #####:  893:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  894:      }
        -:  895:#else /* !JERRY_ESNEXT */
    #####:  896:      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  897:#endif /* JERRY_ESNEXT */
        -:  898:
    #####:  899:      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  900:
        -:  901:      /* 9. */
    #####:  902:      uint32_t n = 0;
        -:  903:
    #####:  904:      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)
        -:  905:      {
        -:  906:#if JERRY_ESNEXT
    #####:  907:        ecma_free_value_if_not_object (to_buffer_p[n]);
        -:  908:#endif /* JERRY_ESNEXT */
    #####:  909:        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);
        -:  910:      }
        -:  911:
    #####:  912:      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;
        -:  913:
    #####:  914:      return ecma_make_object_value (new_array_p);
        -:  915:    }
        -:  916:  }
        -:  917:
        -:  918:  /* 9. */
    #####:  919:  ecma_length_t n = 0;
        -:  920:
        -:  921:  /* 10. */
    #####:  922:  for (ecma_length_t k = start; k < end; k++, n++)
        -:  923:  {
        -:  924:    /* 10.c */
    #####:  925:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);
        -:  926:
    #####:  927:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  928:    {
    #####:  929:      ecma_deref_object (new_array_p);
    #####:  930:      return get_value;
        -:  931:    }
        -:  932:
    #####:  933:    if (ecma_is_value_found (get_value))
        -:  934:    {
        -:  935:      /* 10.c.ii */
        -:  936:      ecma_value_t put_comp;
        -:  937:#if JERRY_ESNEXT
    #####:  938:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  939:#else /* !JERRY_ESNEXT */
    #####:  940:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -:  941:#endif /* JERRY_ESNEXT */
    #####:  942:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -:  943:                                                        n,
        -:  944:                                                        get_value,
        -:  945:                                                        prop_flags);
    #####:  946:      ecma_free_value (get_value);
        -:  947:
        -:  948:#if JERRY_ESNEXT
    #####:  949:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  950:      {
    #####:  951:        ecma_deref_object (new_array_p);
    #####:  952:        return put_comp;
        -:  953:      }
        -:  954:#else /* !JERRY_ESNEXT */
        -:  955:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  956:#endif /* JERRY_ESNEXT */
        -:  957:    }
        -:  958:  }
        -:  959:
        -:  960:#if JERRY_ESNEXT
    #####:  961:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));
        -:  962:
    #####:  963:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  964:  {
    #####:  965:    ecma_deref_object (new_array_p);
    #####:  966:    return set_length_value;
        -:  967:  }
        -:  968:#endif /* JERRY_ESNEXT */
        -:  969:
    #####:  970:  return ecma_make_object_value (new_array_p);
        -:  971:} /* ecma_builtin_array_prototype_object_slice */
        -:  972:
        -:  973:/**
        -:  974: * SortCompare abstract method
        -:  975: *
        -:  976: * See also:
        -:  977: *          ECMA-262 v5, 15.4.4.11
        -:  978: *
        -:  979: * @return ecma value
        -:  980: *         Returned value must be freed with ecma_free_value.
        -:  981: */
        -:  982:static ecma_value_t
    #####:  983:ecma_builtin_array_prototype_object_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -:  984:                                                         ecma_value_t rhs, /**< right value */
        -:  985:                                                         ecma_value_t compare_func, /**< compare function */
        -:  986:                                                         ecma_object_t *array_buffer_p) /**< arrayBuffer */
        -:  987:{
        -:  988:  JERRY_UNUSED (array_buffer_p);
        -:  989:  /*
        -:  990:   * ECMA-262 v5, 15.4.4.11 NOTE1: Because non-existent property values always
        -:  991:   * compare greater than undefined property values, and undefined always
        -:  992:   * compares greater than any other value, undefined property values always
        -:  993:   * sort to the end of the result, followed by non-existent property values.
        -:  994:   */
    #####:  995:  bool lhs_is_undef = ecma_is_value_undefined (lhs);
    #####:  996:  bool rhs_is_undef = ecma_is_value_undefined (rhs);
        -:  997:
    #####:  998:  if (lhs_is_undef)
        -:  999:  {
    #####: 1000:    return ecma_make_integer_value (rhs_is_undef ? 0 : 1);
        -: 1001:  }
        -: 1002:
    #####: 1003:  if (rhs_is_undef)
        -: 1004:  {
    #####: 1005:    return ecma_make_integer_value (-1);
        -: 1006:  }
        -: 1007:
    #####: 1008:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1009:
    #####: 1010:  if (ecma_is_value_undefined (compare_func))
        -: 1011:  {
        -: 1012:    /* Default comparison when no compare_func is passed. */
    #####: 1013:    ecma_string_t *lhs_str_p = ecma_op_to_string (lhs);
    #####: 1014:    if (JERRY_UNLIKELY (lhs_str_p == NULL))
        -: 1015:    {
    #####: 1016:      return ECMA_VALUE_ERROR;
        -: 1017:    }
        -: 1018:
    #####: 1019:    ecma_string_t *rhs_str_p = ecma_op_to_string (rhs);
    #####: 1020:    if (JERRY_UNLIKELY (rhs_str_p == NULL))
        -: 1021:    {
    #####: 1022:      ecma_deref_ecma_string (lhs_str_p);
    #####: 1023:      return ECMA_VALUE_ERROR;
        -: 1024:    }
        -: 1025:
    #####: 1026:    if (ecma_compare_ecma_strings_relational (lhs_str_p, rhs_str_p))
        -: 1027:    {
    #####: 1028:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1029:    }
    #####: 1030:    else if (!ecma_compare_ecma_strings (lhs_str_p, rhs_str_p))
        -: 1031:    {
    #####: 1032:      result = ECMA_NUMBER_ONE;
        -: 1033:    }
        -: 1034:    else
        -: 1035:    {
    #####: 1036:      result = ECMA_NUMBER_ZERO;
        -: 1037:    }
        -: 1038:
    #####: 1039:    ecma_deref_ecma_string (rhs_str_p);
    #####: 1040:    ecma_deref_ecma_string (lhs_str_p);
        -: 1041:  }
        -: 1042:  else
        -: 1043:  {
        -: 1044:    /*
        -: 1045:     * compare_func, if not undefined, will always contain a callable function object.
        -: 1046:     * We checked this previously, before this function was called.
        -: 1047:     */
    #####: 1048:    JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1049:    ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1050:
    #####: 1051:    ecma_value_t compare_args[] = { lhs, rhs };
        -: 1052:
    #####: 1053:    ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1054:                                                     ECMA_VALUE_UNDEFINED,
        -: 1055:                                                     compare_args,
        -: 1056:                                                     2);
    #####: 1057:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1058:    {
    #####: 1059:      return call_value;
        -: 1060:    }
        -: 1061:
    #####: 1062:    if (!ecma_is_value_number (call_value))
        -: 1063:    {
    #####: 1064:      ecma_number_t ret_num;
        -: 1065:
    #####: 1066:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (call_value, &ret_num)))
        -: 1067:      {
    #####: 1068:        ecma_free_value (call_value);
    #####: 1069:        return ECMA_VALUE_ERROR;
        -: 1070:      }
        -: 1071:
    #####: 1072:      result = ret_num;
        -: 1073:    }
        -: 1074:    else
        -: 1075:    {
    #####: 1076:      result = ecma_get_number_from_value (call_value);
        -: 1077:    }
        -: 1078:
    #####: 1079:    ecma_free_value (call_value);
        -: 1080:  }
        -: 1081:
    #####: 1082:  return ecma_make_number_value (result);
        -: 1083:} /* ecma_builtin_array_prototype_object_sort_compare_helper */
        -: 1084:
        -: 1085:/**
        -: 1086: * The Array.prototype object's 'sort' routine
        -: 1087: *
        -: 1088: * See also:
        -: 1089: *          ECMA-262 v5, 15.4.4.11
        -: 1090: *
        -: 1091: * @return ecma value
        -: 1092: *         Returned value must be freed with ecma_free_value.
        -: 1093: */
        -: 1094:static ecma_value_t
    #####: 1095:ecma_builtin_array_prototype_object_sort (ecma_value_t this_arg, /**< this argument */
        -: 1096:                                          ecma_value_t arg1, /**< comparefn */
        -: 1097:                                          ecma_object_t *obj_p) /**< object */
        -: 1098:{
        -: 1099:  /* Check if the provided compare function is callable. */
    #####: 1100:  if (!ecma_is_value_undefined (arg1) && !ecma_op_is_callable (arg1))
        -: 1101:  {
    #####: 1102:    return ecma_raise_type_error (ECMA_ERR_MSG ("Compare function is not callable"));
        -: 1103:  }
        -: 1104:
    #####: 1105:  ecma_length_t len;
    #####: 1106:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &len);
        -: 1107:
    #####: 1108:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1109:  {
    #####: 1110:    return len_value;
        -: 1111:  }
    #####: 1112:  ecma_collection_t *array_index_props_p = ecma_new_collection ();
        -: 1113:
    #####: 1114:  for (uint32_t i = 0; i < len; i++)
        -: 1115:  {
    #####: 1116:    ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -: 1117:
    #####: 1118:    ecma_property_descriptor_t prop_desc;
    #####: 1119:    ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 1120:
    #####: 1121:    if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 1122:    {
    #####: 1123:      ecma_collection_free (array_index_props_p);
    #####: 1124:      ecma_deref_ecma_string (prop_name_p);
    #####: 1125:      return get_desc;
        -: 1126:    }
        -: 1127:
    #####: 1128:    if (ecma_is_value_true (get_desc))
        -: 1129:    {
    #####: 1130:      ecma_ref_ecma_string (prop_name_p);
    #####: 1131:      ecma_collection_push_back (array_index_props_p, ecma_make_string_value (prop_name_p));
    #####: 1132:      ecma_free_property_descriptor (&prop_desc);
    #####: 1133:      continue;
        -: 1134:    }
        -: 1135:  }
        -: 1136:
    #####: 1137:  uint32_t defined_prop_count = array_index_props_p->item_count;
        -: 1138:
    #####: 1139:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 1140:  uint32_t copied_num = 0;
    #####: 1141:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, defined_prop_count, ecma_value_t);
        -: 1142:
    #####: 1143:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1144:
        -: 1145:  /* Copy unsorted array into a native c array. */
    #####: 1146:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1147:  {
    #####: 1148:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1149:
    #####: 1150:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1151:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1152:
    #####: 1153:    if (index >= len)
        -: 1154:    {
    #####: 1155:      break;
        -: 1156:    }
        -: 1157:
    #####: 1158:    ecma_value_t index_value = ecma_op_object_get (obj_p, property_name_p);
        -: 1159:
    #####: 1160:    if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1161:    {
    #####: 1162:      goto clean_up;
        -: 1163:    }
        -: 1164:
    #####: 1165:    values_buffer[copied_num++] = index_value;
        -: 1166:  }
        -: 1167:
    #####: 1168:  JERRY_ASSERT (copied_num == defined_prop_count);
        -: 1169:
        -: 1170:  /* Sorting. */
    #####: 1171:  if (copied_num > 1)
        -: 1172:  {
    #####: 1173:    const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_array_prototype_object_sort_compare_helper;
    #####: 1174:    ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
        -: 1175:                                                                           (uint32_t) (copied_num),
        -: 1176:                                                                           arg1,
        -: 1177:                                                                           sort_cb,
        -: 1178:                                                                           NULL);
    #####: 1179:    if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1180:    {
    #####: 1181:      goto clean_up;
        -: 1182:    }
        -: 1183:
    #####: 1184:    ecma_free_value (sort_value);
        -: 1185:  }
        -: 1186:
        -: 1187:  /* Put sorted values to the front of the array. */
    #####: 1188:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1189:  {
    #####: 1190:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, index, values_buffer[index], true);
        -: 1191:
    #####: 1192:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1193:    {
    #####: 1194:      goto clean_up;
        -: 1195:    }
        -: 1196:  }
        -: 1197:
    #####: 1198:  ret_value = ECMA_VALUE_EMPTY;
        -: 1199:
    #####: 1200:clean_up:
        -: 1201:  /* Free values that were copied to the local array. */
    #####: 1202:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1203:  {
    #####: 1204:    ecma_free_value (values_buffer[index]);
        -: 1205:  }
        -: 1206:
    #####: 1207:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1208:
    #####: 1209:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1210:  {
    #####: 1211:    ecma_collection_free (array_index_props_p);
    #####: 1212:    return ret_value;
        -: 1213:  }
        -: 1214:
    #####: 1215:  JERRY_ASSERT (ecma_is_value_empty (ret_value));
        -: 1216:
        -: 1217:  /* Undefined properties should be in the back of the array. */
    #####: 1218:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1219:
    #####: 1220:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1221:  {
    #####: 1222:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1223:
    #####: 1224:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1225:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1226:
    #####: 1227:    if (index >= copied_num && index < len)
        -: 1228:    {
    #####: 1229:      ecma_value_t del_value = ecma_op_object_delete (obj_p, property_name_p, true);
        -: 1230:
    #####: 1231:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1232:      {
    #####: 1233:        ecma_collection_free (array_index_props_p);
    #####: 1234:        return del_value;
        -: 1235:      }
        -: 1236:    }
        -: 1237:  }
        -: 1238:
    #####: 1239:  ecma_collection_free (array_index_props_p);
        -: 1240:
    #####: 1241:  return ecma_copy_value (this_arg);
        -: 1242:} /* ecma_builtin_array_prototype_object_sort */
        -: 1243:
        -: 1244:/**
        -: 1245: * The Array.prototype object's 'splice' routine
        -: 1246: *
        -: 1247: * See also:
        -: 1248: *          ECMA-262 v11, 22.1.3.28
        -: 1249: *          ECMA-262 v5, 15.4.4.12
        -: 1250: *
        -: 1251: * @return ecma value
        -: 1252: *         Returned value must be freed with ecma_free_value.
        -: 1253: */
        -: 1254:static ecma_value_t
    #####: 1255:ecma_builtin_array_prototype_object_splice (const ecma_value_t args[], /**< arguments list */
        -: 1256:                                            uint32_t args_number, /**< number of arguments */
        -: 1257:                                            ecma_object_t *obj_p, /**< object */
        -: 1258:                                            ecma_length_t len) /**< object's length */
        -: 1259:{
    #####: 1260:  ecma_length_t actual_start = 0;
    #####: 1261:  ecma_length_t actual_delete_count = 0;
    #####: 1262:  ecma_length_t insert_count = 0;
        -: 1263:
    #####: 1264:  if (args_number > 0)
        -: 1265:  {
        -: 1266:    /* ES5.1: 6, ES11: 4. */
    #####: 1267:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1268:                                                                        len,
        -: 1269:                                                                        &actual_start)))
        -: 1270:    {
    #####: 1271:      return ECMA_VALUE_ERROR;
        -: 1272:    }
        -: 1273:
        -: 1274:    /* ES11: 6. */
    #####: 1275:    if (args_number == 1)
        -: 1276:    {
    #####: 1277:      actual_delete_count = len - actual_start;
        -: 1278:    }
        -: 1279:    /* ES11: 7. */
        -: 1280:    else
        -: 1281:    {
    #####: 1282:      insert_count = args_number - 2;
        -: 1283:
    #####: 1284:      ecma_number_t delete_num;
    #####: 1285:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &delete_num)))
        -: 1286:      {
    #####: 1287:        return ECMA_VALUE_ERROR;
        -: 1288:      }
        -: 1289:
        -: 1290:      /* ES5.1: 7 */
    #####: 1291:      actual_delete_count = (ecma_length_t) (JERRY_MIN (JERRY_MAX (delete_num, 0),
        -: 1292:                                                        (ecma_number_t) (len - actual_start)));
        -: 1293:    }
        -: 1294:  }
        -: 1295:
    #####: 1296:  ecma_length_t new_length = len + insert_count - actual_delete_count;
        -: 1297:
        -: 1298:#if JERRY_ESNEXT
        -: 1299:  /* ES11: 8. */
    #####: 1300:  if ((ecma_number_t) new_length > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1301:  {
    #####: 1302:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid new Array length"));
        -: 1303:  }
        -: 1304:
        -: 1305:  /* ES11: 9. */
    #####: 1306:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, actual_delete_count);
        -: 1307:
    #####: 1308:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1309:  {
    #####: 1310:    return ECMA_VALUE_ERROR;
        -: 1311:  }
        -: 1312:#else /* !JERRY_ESNEXT */
        -: 1313:  /* ES5.1: 2. */
    #####: 1314:  ecma_object_t *new_array_p = ecma_op_new_array_object (actual_delete_count);
        -: 1315:#endif /* JERRY_ESNEXT */
        -: 1316:
        -: 1317:  /* ES5.1: 8, ES11: 10. */
    #####: 1318:  ecma_length_t k = 0;
        -: 1319:
        -: 1320:  /* ES5.1: 9, ES11: 11. */
    #####: 1321:  for (; k < actual_delete_count; k++)
        -: 1322:  {
    #####: 1323:    ecma_length_t from = actual_start + k;
    #####: 1324:    ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1325:
    #####: 1326:    if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1327:    {
    #####: 1328:      ecma_deref_object (new_array_p);
    #####: 1329:      return from_present;
        -: 1330:    }
        -: 1331:
    #####: 1332:    if (ecma_is_value_found (from_present))
        -: 1333:    {
        -: 1334:#if JERRY_ESNEXT
    #####: 1335:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 1336:#else /* !JERRY_ESNEXT */
    #####: 1337:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 1338:#endif /* JERRY_ESNEXT */
        -: 1339:
    #####: 1340:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 1341:                                                                     k,
        -: 1342:                                                                     from_present,
        -: 1343:                                                                     prop_flags);
    #####: 1344:      ecma_free_value (from_present);
        -: 1345:
        -: 1346:#if JERRY_ESNEXT
    #####: 1347:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 1348:      {
    #####: 1349:        ecma_deref_object (new_array_p);
    #####: 1350:        return put_comp;
        -: 1351:      }
        -: 1352:#else /* !JERRY_ESNEXT */
        -: 1353:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 1354:#endif /* JERRY_ESNEXT */
        -: 1355:    }
        -: 1356:  }
        -: 1357:
        -: 1358:#if JERRY_ESNEXT
        -: 1359:  /* ES11: 12. */
    #####: 1360:  ecma_value_t set_length = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -: 1361:                                                                            ((ecma_number_t) actual_delete_count));
        -: 1362:
    #####: 1363:  if (ECMA_IS_VALUE_ERROR (set_length))
        -: 1364:  {
    #####: 1365:    ecma_deref_object (new_array_p);
    #####: 1366:    return set_length;
        -: 1367:  }
        -: 1368:#endif /* JERRY_ESNEXT */
        -: 1369:
        -: 1370:  /* ES5.1: 12, ES11: 15. */
    #####: 1371:  if (insert_count < actual_delete_count)
        -: 1372:  {
    #####: 1373:    for (k = actual_start; k < len - actual_delete_count; k++)
        -: 1374:    {
    #####: 1375:      ecma_length_t from = k + actual_delete_count;
    #####: 1376:      ecma_length_t to = k + insert_count;
        -: 1377:
    #####: 1378:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1379:
    #####: 1380:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1381:      {
    #####: 1382:        ecma_deref_object (new_array_p);
    #####: 1383:        return from_present;
        -: 1384:      }
        -: 1385:
        -: 1386:      ecma_value_t operation_value;
        -: 1387:
    #####: 1388:      if (ecma_is_value_found (from_present))
        -: 1389:      {
    #####: 1390:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1391:        ecma_free_value (from_present);
        -: 1392:      }
        -: 1393:      else
        -: 1394:      {
    #####: 1395:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1396:      }
        -: 1397:
    #####: 1398:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1399:      {
    #####: 1400:        ecma_deref_object (new_array_p);
    #####: 1401:        return operation_value;
        -: 1402:      }
        -: 1403:    }
        -: 1404:
    #####: 1405:    k = len;
        -: 1406:
    #####: 1407:    for (k = len; k > new_length; k--)
        -: 1408:    {
    #####: 1409:      ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, k - 1, true);
        -: 1410:
    #####: 1411:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1412:      {
    #####: 1413:        ecma_deref_object (new_array_p);
    #####: 1414:        return del_value;
        -: 1415:      }
        -: 1416:    }
        -: 1417:  }
        -: 1418:  /* ES5.1: 13, ES11: 16. */
    #####: 1419:  else if (insert_count > actual_delete_count)
        -: 1420:  {
    #####: 1421:    for (k = len - actual_delete_count; k > actual_start; k--)
        -: 1422:    {
    #####: 1423:      ecma_length_t from = k + actual_delete_count - 1;
    #####: 1424:      ecma_length_t to = k + insert_count - 1;
        -: 1425:
    #####: 1426:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1427:
    #####: 1428:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1429:      {
    #####: 1430:        ecma_deref_object (new_array_p);
    #####: 1431:        return from_present;
        -: 1432:      }
        -: 1433:
        -: 1434:      ecma_value_t operation_value;
        -: 1435:
    #####: 1436:      if (ecma_is_value_found (from_present))
        -: 1437:      {
    #####: 1438:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1439:        ecma_free_value (from_present);
        -: 1440:      }
        -: 1441:      else
        -: 1442:      {
    #####: 1443:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1444:      }
        -: 1445:
    #####: 1446:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1447:      {
    #####: 1448:        ecma_deref_object (new_array_p);
    #####: 1449:        return operation_value;
        -: 1450:      }
        -: 1451:    }
        -: 1452:  }
        -: 1453:
        -: 1454:  /* ES5.1: 14, ES11: 17. */
    #####: 1455:  k = actual_start;
        -: 1456:
        -: 1457:  /* ES5.1: 15, ES11: 18. */
    #####: 1458:  uint32_t idx = 0;
    #####: 1459:  for (uint32_t arg_index = 2; arg_index < args_number; arg_index++, idx++)
        -: 1460:  {
    #####: 1461:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p,
        -: 1462:                                                          actual_start + idx,
    #####: 1463:                                                          args[arg_index],
        -: 1464:                                                          true);
        -: 1465:
    #####: 1466:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1467:    {
    #####: 1468:      ecma_deref_object (new_array_p);
    #####: 1469:      return put_value;
        -: 1470:    }
        -: 1471:  }
        -: 1472:
        -: 1473:  /* ES5.1: 16, ES11: 19. */
    #####: 1474:  ecma_value_t set_new_length = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) new_length));
        -: 1475:
    #####: 1476:  if (ECMA_IS_VALUE_ERROR (set_new_length))
        -: 1477:  {
    #####: 1478:    ecma_deref_object (new_array_p);
    #####: 1479:    return set_new_length;
        -: 1480:  }
        -: 1481:
        -: 1482:  /* ES5.1: 17, ES11: 20. */
    #####: 1483:  return ecma_make_object_value (new_array_p);
        -: 1484:} /* ecma_builtin_array_prototype_object_splice */
        -: 1485:
        -: 1486:/**
        -: 1487: * The Array.prototype object's 'unshift' routine
        -: 1488: *
        -: 1489: * See also:
        -: 1490: *          ECMA-262  v5, 15.4.4.13
        -: 1491: *          ECMA-262 v11, 22.1.3.31
        -: 1492: *
        -: 1493: * @return ecma value
        -: 1494: *         Returned value must be freed with ecma_free_value.
        -: 1495: */
        -: 1496:static ecma_value_t
    #####: 1497:ecma_builtin_array_prototype_object_unshift (const ecma_value_t args[], /**< arguments list */
        -: 1498:                                             uint32_t args_number, /**< number of arguments */
        -: 1499:                                             ecma_object_t *obj_p, /**< object */
        -: 1500:                                             ecma_length_t len) /**< object's length */
        -: 1501:{
        -: 1502:
    #####: 1503:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1504:  {
    #####: 1505:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1506:
    #####: 1507:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1508:        && len != 0)
        -: 1509:    {
    #####: 1510:      if (args_number > UINT32_MAX - len)
        -: 1511:      {
    #####: 1512:        return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -: 1513:      }
        -: 1514:
    #####: 1515:      if (args_number == 0)
        -: 1516:      {
    #####: 1517:        return ecma_make_uint32_value ((uint32_t) len);
        -: 1518:      }
        -: 1519:
    #####: 1520:      uint32_t new_length = ((uint32_t) len) + args_number;
    #####: 1521:      ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length);
    #####: 1522:      memmove (buffer_p + args_number, buffer_p, (size_t) (sizeof (ecma_value_t) * len));
        -: 1523:
    #####: 1524:      uint32_t index = 0;
        -: 1525:
    #####: 1526:      while (index < args_number)
        -: 1527:      {
    #####: 1528:        buffer_p[index] = ecma_copy_value_if_not_object (args[index]);
    #####: 1529:        index++;
        -: 1530:      }
        -: 1531:
    #####: 1532:      ext_obj_p->u.array.length_prop_and_hole_count -= args_number * ECMA_FAST_ARRAY_HOLE_ONE;
        -: 1533:
    #####: 1534:      return ecma_make_uint32_value (new_length);
        -: 1535:    }
        -: 1536:  }
        -: 1537:
        -: 1538:#if JERRY_ESNEXT
    #####: 1539:  const bool should_iterate = args_number > 0;
        -: 1540:#else /* !JERRY_ESNEXT */
        -: 1541:  const bool should_iterate = true;
        -: 1542:#endif /* JERRY_ESNEXT */
    #####: 1543:  if (should_iterate)
        -: 1544:  {
        -: 1545:#if JERRY_ESNEXT
        -: 1546:    /* ES11:4.a. */
    #####: 1547:    if ((ecma_number_t) (len + args_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1548:    {
    #####: 1549:      return ecma_raise_type_error (ECMA_ERR_MSG ("Unshift elements over 2**53-1 length is disallowed"));
        -: 1550:    }
        -: 1551:#endif /* JERRY_ESNEXT */
        -: 1552:
        -: 1553:    /* ES5.1:5.,6. ES11: 4.b, 4.c */
    #####: 1554:    for (ecma_length_t k = len; k > 0; k--)
        -: 1555:    {
        -: 1556:      /* ES5.1:6.a, 6.c, ES11:4.c.i., 4.c.iii.  */
    #####: 1557:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k - 1);
        -: 1558:
    #####: 1559:      if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1560:      {
    #####: 1561:        return get_value;
        -: 1562:      }
        -: 1563:
        -: 1564:      /* ES5.1:6.b, ES11:4.c.ii. */
    #####: 1565:      ecma_number_t new_idx = ((ecma_number_t) k) + ((ecma_number_t) args_number) - 1;
    #####: 1566:      ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (new_idx);
        -: 1567:      ecma_value_t operation_value;
        -: 1568:
    #####: 1569:      if (ecma_is_value_found (get_value))
        -: 1570:      {
        -: 1571:        /* ES5.1:6.d.i, 6.d.ii, ES11:4.c.iv. */
    #####: 1572:        operation_value = ecma_op_object_put (obj_p, index_str_p, get_value, true);
    #####: 1573:        ecma_free_value (get_value);
        -: 1574:      }
        -: 1575:      else
        -: 1576:      {
        -: 1577:        /* ES5.1:6.e.i, ES11:4.c.v. */
    #####: 1578:        operation_value = ecma_op_object_delete (obj_p, index_str_p, true);
        -: 1579:      }
        -: 1580:
    #####: 1581:      ecma_deref_ecma_string (index_str_p);
        -: 1582:
    #####: 1583:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1584:      {
    #####: 1585:        return operation_value;
        -: 1586:      }
        -: 1587:    }
        -: 1588:
    #####: 1589:    for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -: 1590:    {
        -: 1591:      /* ES5.1:9.b, ES11:4.f.ii.  */
    #####: 1592:      ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, arg_index, args[arg_index], true);
        -: 1593:
    #####: 1594:      if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1595:      {
    #####: 1596:        return put_value;
        -: 1597:      }
        -: 1598:    }
        -: 1599:  }
        -: 1600:
        -: 1601:  /* ES5.1:10., ES11:5. */
    #####: 1602:  ecma_number_t new_len = ((ecma_number_t) len) + ((ecma_number_t) args_number);
    #####: 1603:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, new_len);
        -: 1604:
    #####: 1605:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1606:  {
    #####: 1607:    return set_length_value;
        -: 1608:  }
        -: 1609:
    #####: 1610:  return ecma_make_number_value (new_len);
        -: 1611:} /* ecma_builtin_array_prototype_object_unshift */
        -: 1612:
        -: 1613:/**
        -: 1614: * The Array.prototype object's 'at' routine
        -: 1615: *
        -: 1616: * See also:
        -: 1617: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1618: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1619: *
        -: 1620: * @return ecma value
        -: 1621: *         Returned value must be freed with ecma_free_value.
        -: 1622: */
        -: 1623:static ecma_value_t
    #####: 1624:ecma_builtin_array_prototype_object_at (const ecma_value_t index, /**< index argument */
        -: 1625:                                        ecma_object_t *obj_p, /**< object */
        -: 1626:                                        ecma_length_t len) /**< object's length */
        -: 1627:{
    #####: 1628:  ecma_length_t res_index;
    #####: 1629:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1630:
    #####: 1631:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1632:  {
    #####: 1633:    return return_value;
        -: 1634:  }
        -: 1635:
    #####: 1636:  return ecma_op_object_get_by_index (obj_p, res_index);
        -: 1637:} /* ecma_builtin_array_prototype_object_at */
        -: 1638:
        -: 1639:/**
        -: 1640: * The Array.prototype object's 'indexOf' routine
        -: 1641: *
        -: 1642: * See also:
        -: 1643: *          ECMA-262 v5, 15.4.4.14
        -: 1644: *
        -: 1645: * @return ecma value
        -: 1646: *         Returned value must be freed with ecma_free_value.
        -: 1647: */
        -: 1648:static ecma_value_t
    #####: 1649:ecma_builtin_array_prototype_object_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1650:                                              uint32_t args_number, /**< number of arguments */
        -: 1651:                                              ecma_object_t *obj_p, /**< object */
        -: 1652:                                              ecma_length_t len) /**< object's length */
        -: 1653:{
        -: 1654:  /* 4. */
    #####: 1655:  if (len == 0)
        -: 1656:  {
    #####: 1657:    return ecma_make_integer_value (-1);
        -: 1658:  }
        -: 1659:
        -: 1660:  /* 5. */
    #####: 1661:  ecma_number_t idx = 0;
    #####: 1662:  if (args_number > 1)
        -: 1663:  {
    #####: 1664:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1665:    {
    #####: 1666:      return ECMA_VALUE_ERROR;
        -: 1667:    }
        -: 1668:  }
        -: 1669:
        -: 1670:  /* 6. */
    #####: 1671:  if (idx >= (ecma_number_t) len)
        -: 1672:  {
    #####: 1673:    return ecma_make_number_value (-1);
        -: 1674:  }
        -: 1675:
        -: 1676:  /* 7. */
    #####: 1677:  ecma_length_t from_idx = (ecma_length_t) idx;
        -: 1678:
        -: 1679:  /* 8. */
    #####: 1680:  if (idx < 0)
        -: 1681:  {
    #####: 1682:    from_idx = (ecma_length_t) JERRY_MAX ((ecma_number_t) len + idx, 0);
        -: 1683:  }
        -: 1684:
    #####: 1685:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1686:  {
    #####: 1687:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1688:
    #####: 1689:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1690:    {
    #####: 1691:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1692:      {
    #####: 1693:        return ecma_make_integer_value (-1);
        -: 1694:      }
        -: 1695:
    #####: 1696:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1697:
    #####: 1698:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1699:
    #####: 1700:      while (from_idx < len)
        -: 1701:      {
    #####: 1702:        if (ecma_op_strict_equality_compare (args[0], buffer_p[from_idx]))
        -: 1703:        {
    #####: 1704:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1705:        }
        -: 1706:
    #####: 1707:        from_idx++;
        -: 1708:      }
        -: 1709:
    #####: 1710:      return ecma_make_integer_value (-1);
        -: 1711:    }
        -: 1712:  }
        -: 1713:
        -: 1714:  /* 6. */
    #####: 1715:  while (from_idx < len)
        -: 1716:  {
        -: 1717:    /* 9.a */
    #####: 1718:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1719:
    #####: 1720:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1721:    {
    #####: 1722:      return get_value;
        -: 1723:    }
        -: 1724:
        -: 1725:    /* 9.b.i, 9.b.ii */
    #####: 1726:    if (ecma_is_value_found (get_value)
    #####: 1727:        && ecma_op_strict_equality_compare (args[0], get_value))
        -: 1728:    {
    #####: 1729:      ecma_free_value (get_value);
    #####: 1730:      return ecma_make_length_value (from_idx);
        -: 1731:    }
        -: 1732:
    #####: 1733:    from_idx++;
        -: 1734:
    #####: 1735:    ecma_free_value (get_value);
        -: 1736:  }
        -: 1737:
    #####: 1738:  return ecma_make_integer_value (-1);
        -: 1739:} /* ecma_builtin_array_prototype_object_index_of */
        -: 1740:
        -: 1741:/**
        -: 1742: * The Array.prototype object's 'lastIndexOf' routine
        -: 1743: *
        -: 1744: * See also:
        -: 1745: *          ECMA-262 v5, 15.4.4.15
        -: 1746: *
        -: 1747: * @return ecma value
        -: 1748: *         Returned value must be freed with ecma_free_value.
        -: 1749: */
        -: 1750:static ecma_value_t
    #####: 1751:ecma_builtin_array_prototype_object_last_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1752:                                                   uint32_t args_number, /**< number of arguments */
        -: 1753:                                                   ecma_object_t *obj_p, /**< object */
        -: 1754:                                                   ecma_length_t len) /**< object's length */
        -: 1755:{
        -: 1756:  /* 4. */
    #####: 1757:  if (len == 0)
        -: 1758:  {
    #####: 1759:    return ecma_make_integer_value (-1);
        -: 1760:  }
        -: 1761:
        -: 1762:  /* 5. */
    #####: 1763:  ecma_number_t idx = (ecma_number_t) len - 1;
    #####: 1764:  if (args_number > 1)
        -: 1765:  {
    #####: 1766:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1767:    {
    #####: 1768:      return ECMA_VALUE_ERROR;
        -: 1769:    }
        -: 1770:  }
        -: 1771:
        -: 1772:  ecma_length_t from_idx;
        -: 1773:
        -: 1774:  /* 6 */
    #####: 1775:  if (idx >= 0)
        -: 1776:  {
    #####: 1777:    from_idx = (ecma_length_t) (JERRY_MIN (idx, (ecma_number_t) (len - 1)));
        -: 1778:  }
        -: 1779:  else
        -: 1780:  {
    #####: 1781:    ecma_number_t k = (ecma_number_t) len + idx;
    #####: 1782:    if (k < 0)
        -: 1783:    {
    #####: 1784:      return ecma_make_integer_value (-1);
        -: 1785:    }
    #####: 1786:    from_idx = (ecma_length_t) k;
        -: 1787:  }
        -: 1788:
    #####: 1789:  ecma_value_t search_element = (args_number > 0) ? args[0] : ECMA_VALUE_UNDEFINED;
        -: 1790:
    #####: 1791:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1792:  {
    #####: 1793:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1794:
    #####: 1795:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1796:    {
    #####: 1797:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1798:      {
    #####: 1799:        return ecma_make_integer_value (-1);
        -: 1800:      }
        -: 1801:
    #####: 1802:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1803:
    #####: 1804:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1805:
    #####: 1806:      while (from_idx < len)
        -: 1807:      {
    #####: 1808:        if (ecma_op_strict_equality_compare (search_element, buffer_p[from_idx]))
        -: 1809:        {
    #####: 1810:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1811:        }
    #####: 1812:        from_idx--;
        -: 1813:      }
    #####: 1814:      return ecma_make_integer_value (-1);
        -: 1815:    }
        -: 1816:  }
        -: 1817:
        -: 1818:    /* 8. */
    #####: 1819:  while (from_idx < len)
        -: 1820:  {
        -: 1821:    /* 8.a */
    #####: 1822:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1823:
    #####: 1824:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1825:    {
    #####: 1826:      return get_value;
        -: 1827:    }
        -: 1828:
        -: 1829:    /* 8.b.i, 8.b.ii */
    #####: 1830:    if (ecma_is_value_found (get_value)
    #####: 1831:        && ecma_op_strict_equality_compare (search_element, get_value))
        -: 1832:    {
    #####: 1833:      ecma_free_value (get_value);
    #####: 1834:      return ecma_make_length_value (from_idx);
        -: 1835:    }
        -: 1836:
    #####: 1837:    from_idx--;
        -: 1838:
    #####: 1839:    ecma_free_value (get_value);
        -: 1840:  }
        -: 1841:
    #####: 1842:  return ecma_make_integer_value (-1);
        -: 1843:} /* ecma_builtin_array_prototype_object_last_index_of */
        -: 1844:
        -: 1845:/**
        -: 1846: * Type of array routine.
        -: 1847: */
        -: 1848:typedef enum
        -: 1849:{
        -: 1850:  ARRAY_ROUTINE_EVERY, /**< Array.every: ECMA-262 v5, 15.4.4.16 */
        -: 1851:  ARRAY_ROUTINE_SOME, /**< Array.some: ECMA-262 v5, 15.4.4.17 */
        -: 1852:  ARRAY_ROUTINE_FOREACH, /**< Array.forEach: ECMA-262 v5, 15.4.4.18 */
        -: 1853:  ARRAY_ROUTINE__COUNT /**< count of the modes */
        -: 1854:} array_routine_mode;
        -: 1855:
        -: 1856:/**
        -: 1857: * Applies the provided function to each element of the array as long as
        -: 1858: * the return value stays empty. The common function for 'every', 'some'
        -: 1859: * and 'forEach' of the Array prototype.
        -: 1860: *
        -: 1861: * See also:
        -: 1862: *          ECMA-262 v5, 15.4.4.16
        -: 1863: *          ECMA-262 v5, 15.4.4.17
        -: 1864: *          ECMA-262 v5, 15.4.4.18
        -: 1865: *
        -: 1866: * @return ecma value
        -: 1867: *         Returned value must be freed with ecma_free_value.
        -: 1868: */
        -: 1869:static ecma_value_t
    #####: 1870:ecma_builtin_array_apply (ecma_value_t arg1, /**< callbackfn */
        -: 1871:                          ecma_value_t arg2, /**< thisArg */
        -: 1872:                          array_routine_mode mode, /**< array routine mode */
        -: 1873:                          ecma_object_t *obj_p, /**< object */
        -: 1874:                          ecma_length_t len) /**< object's length */
        -: 1875:
        -: 1876:{
    #####: 1877:  JERRY_ASSERT (mode < ARRAY_ROUTINE__COUNT);
        -: 1878:
        -: 1879:  /* 4. */
    #####: 1880:  if (!ecma_op_is_callable (arg1))
        -: 1881:  {
    #####: 1882:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1883:  }
        -: 1884:
        -: 1885:  /* We already checked that arg1 is callable */
    #####: 1886:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1887:  ecma_value_t current_index;
        -: 1888:
        -: 1889:  /* 7. */
    #####: 1890:  for (ecma_length_t index = 0; index < len; index++)
        -: 1891:  {
        -: 1892:    /* 7.a - 7.c */
    #####: 1893:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1894:
    #####: 1895:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1896:    {
    #####: 1897:      return get_value;
        -: 1898:    }
        -: 1899:
    #####: 1900:    if (ecma_is_value_found (get_value))
        -: 1901:    {
        -: 1902:      /* 7.c.i */
    #####: 1903:      current_index = ecma_make_length_value (index);
        -: 1904:
    #####: 1905:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 1906:      /* 7.c.ii */
    #####: 1907:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1908:
    #####: 1909:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1910:      {
    #####: 1911:        ecma_free_value (get_value);
    #####: 1912:        return call_value;
        -: 1913:      }
        -: 1914:
    #####: 1915:      bool to_boolean = ecma_op_to_boolean (call_value);
        -: 1916:
    #####: 1917:      ecma_free_value (call_value);
    #####: 1918:      ecma_free_value (get_value);
        -: 1919:
        -: 1920:      /* 7.c.iii */
    #####: 1921:      if (mode == ARRAY_ROUTINE_EVERY && !to_boolean)
        -: 1922:      {
    #####: 1923:        return ECMA_VALUE_FALSE;
        -: 1924:      }
    #####: 1925:      else if (mode == ARRAY_ROUTINE_SOME && to_boolean)
        -: 1926:      {
    #####: 1927:        return ECMA_VALUE_TRUE;
        -: 1928:      }
        -: 1929:    }
        -: 1930:  }
        -: 1931:
        -: 1932:  /* 8. */
        -: 1933:
    #####: 1934:  if (mode == ARRAY_ROUTINE_EVERY)
        -: 1935:  {
    #####: 1936:    return ECMA_VALUE_TRUE;
        -: 1937:  }
    #####: 1938:  else if (mode == ARRAY_ROUTINE_SOME)
        -: 1939:  {
    #####: 1940:    return ECMA_VALUE_FALSE;
        -: 1941:  }
        -: 1942:
    #####: 1943:  JERRY_ASSERT (mode == ARRAY_ROUTINE_FOREACH);
    #####: 1944:  return ECMA_VALUE_UNDEFINED;
        -: 1945:} /* ecma_builtin_array_apply */
        -: 1946:
        -: 1947:/**
        -: 1948: * The Array.prototype object's 'map' routine
        -: 1949: *
        -: 1950: * See also:
        -: 1951: *          ECMA-262 v5, 15.4.4.19
        -: 1952: *
        -: 1953: * @return ecma value
        -: 1954: *         Returned value must be freed with ecma_free_value.
        -: 1955: */
        -: 1956:static ecma_value_t
    #####: 1957:ecma_builtin_array_prototype_object_map (ecma_value_t arg1, /**< callbackfn */
        -: 1958:                                         ecma_value_t arg2, /**< thisArg */
        -: 1959:                                         ecma_object_t *obj_p, /**< object */
        -: 1960:                                         ecma_length_t len) /**< object's length */
        -: 1961:{
        -: 1962:  /* 4. */
    #####: 1963:  if (!ecma_op_is_callable (arg1))
        -: 1964:  {
    #####: 1965:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1966:  }
        -: 1967:
        -: 1968:  /* 6. */
        -: 1969:#if JERRY_ESNEXT
    #####: 1970:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, len);
        -: 1971:
    #####: 1972:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1973:  {
    #####: 1974:    return ECMA_VALUE_ERROR;
        -: 1975:  }
        -: 1976:#else /* !JERRY_ESNEXT */
    #####: 1977:  ecma_object_t *new_array_p = ecma_op_new_array_object (len);
        -: 1978:#endif /* JERRY_ESNEXT */
        -: 1979:
    #####: 1980:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 1981:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1982:
        -: 1983:  /* 7-8. */
        -: 1984:  ecma_value_t current_index;
        -: 1985:
    #####: 1986:  for (ecma_length_t index = 0; index < len; index++)
        -: 1987:  {
        -: 1988:    /* 8.a - 8.b */
    #####: 1989:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1990:
    #####: 1991:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1992:    {
    #####: 1993:      ecma_deref_object (new_array_p);
    #####: 1994:      return current_value;
        -: 1995:    }
        -: 1996:
    #####: 1997:    if (ecma_is_value_found (current_value))
        -: 1998:    {
        -: 1999:      /* 8.c.i, 8.c.ii */
    #####: 2000:      current_index = ecma_make_length_value (index);
    #####: 2001:      ecma_value_t call_args[] = { current_value, current_index, ecma_make_object_value (obj_p) };
        -: 2002:
    #####: 2003:      ecma_value_t mapped_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2004:
    #####: 2005:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -: 2006:      {
    #####: 2007:        ecma_free_value (current_value);
    #####: 2008:        ecma_deref_object (new_array_p);
    #####: 2009:        return mapped_value;
        -: 2010:      }
        -: 2011:
        -: 2012:      /* 8.c.iii */
        -: 2013:      ecma_value_t put_comp;
        -: 2014:#if JERRY_ESNEXT
    #####: 2015:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2016:#else /* !JERRY_ESNEXT */
    #####: 2017:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2018:#endif /* JERRY_ESNEXT */
    #####: 2019:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2020:                                                        index,
        -: 2021:                                                        mapped_value,
        -: 2022:                                                        prop_flags);
        -: 2023:
    #####: 2024:      ecma_free_value (mapped_value);
    #####: 2025:      ecma_free_value (current_value);
        -: 2026:#if JERRY_ESNEXT
    #####: 2027:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2028:      {
    #####: 2029:        ecma_deref_object (new_array_p);
    #####: 2030:        return put_comp;
        -: 2031:      }
        -: 2032:#else /* !JERRY_ESNEXT */
        -: 2033:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2034:#endif /* JERRY_ESNEXT */
        -: 2035:    }
        -: 2036:  }
        -: 2037:
    #####: 2038:  return ecma_make_object_value (new_array_p);
        -: 2039:} /* ecma_builtin_array_prototype_object_map */
        -: 2040:
        -: 2041:/**
        -: 2042: * The Array.prototype object's 'filter' routine
        -: 2043: *
        -: 2044: * See also:
        -: 2045: *          ECMA-262 v5, 15.4.4.20
        -: 2046: *
        -: 2047: * @return ecma value
        -: 2048: *         Returned value must be freed with ecma_free_value.
        -: 2049: */
        -: 2050:static ecma_value_t
    #####: 2051:ecma_builtin_array_prototype_object_filter (ecma_value_t arg1, /**< callbackfn */
        -: 2052:                                            ecma_value_t arg2, /**< thisArg */
        -: 2053:                                            ecma_object_t *obj_p, /**< object */
        -: 2054:                                            ecma_length_t len) /**< object's length */
        -: 2055:{
        -: 2056:  /* 4. */
    #####: 2057:  if (!ecma_op_is_callable (arg1))
        -: 2058:  {
    #####: 2059:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2060:  }
        -: 2061:
        -: 2062:  /* 6. */
        -: 2063:#if JERRY_ESNEXT
    #####: 2064:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2065:
    #####: 2066:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2067:  {
    #####: 2068:    return ECMA_VALUE_ERROR;
        -: 2069:  }
        -: 2070:
        -: 2071:  /* ES11: 22.1.3.7. 7.c.iii.1 */
    #####: 2072:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2073:#else /* !JERRY_ESNEXT */
    #####: 2074:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -: 2075:
        -: 2076:  /* ES5.1: 15.4.4.20. 9.c.iii.1 */
    #####: 2077:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2078:#endif /* JERRY_ESNEXT */
        -: 2079:
        -: 2080:  /* We already checked that arg1 is callable, so it will always be an object. */
    #####: 2081:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 2082:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 2083:
        -: 2084:  /* 8. */
    #####: 2085:  ecma_length_t new_array_index = 0;
        -: 2086:  ecma_value_t current_index;
        -: 2087:
        -: 2088:  /* 9. */
    #####: 2089:  for (ecma_length_t index = 0; index < len; index++)
        -: 2090:  {
        -: 2091:    /* 9.a - 9.c */
    #####: 2092:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 2093:
    #####: 2094:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2095:    {
    #####: 2096:      ecma_deref_object (new_array_p);
    #####: 2097:      return get_value;
        -: 2098:    }
        -: 2099:
    #####: 2100:    if (ecma_is_value_found (get_value))
        -: 2101:    {
        -: 2102:      /* 9.c.i */
    #####: 2103:      current_index = ecma_make_length_value (index);
        -: 2104:
    #####: 2105:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2106:      /* 9.c.ii */
    #####: 2107:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2108:
    #####: 2109:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2110:      {
    #####: 2111:        ecma_free_value (get_value);
    #####: 2112:        ecma_deref_object (new_array_p);
    #####: 2113:        return call_value;
        -: 2114:      }
        -: 2115:
        -: 2116:      /* 9.c.iii */
    #####: 2117:      if (ecma_op_to_boolean (call_value))
        -: 2118:      {
        -: 2119:        ecma_value_t put_comp;
    #####: 2120:        put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2121:                                                          new_array_index,
        -: 2122:                                                          get_value,
        -: 2123:                                                          prop_flags);
        -: 2124:#if JERRY_ESNEXT
    #####: 2125:        if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2126:        {
    #####: 2127:          ecma_free_value (call_value);
    #####: 2128:          ecma_free_value (get_value);
    #####: 2129:          ecma_deref_object (new_array_p);
        -: 2130:
    #####: 2131:          return put_comp;
        -: 2132:        }
        -: 2133:#else /* !JERRY_ESNEXT */
        -: 2134:        JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2135:#endif /* JERRY_ESNEXT */
    #####: 2136:        new_array_index++;
        -: 2137:      }
        -: 2138:
    #####: 2139:      ecma_free_value (call_value);
    #####: 2140:      ecma_free_value (get_value);
        -: 2141:    }
        -: 2142:  }
        -: 2143:
    #####: 2144:  return ecma_make_object_value (new_array_p);
        -: 2145:} /* ecma_builtin_array_prototype_object_filter */
        -: 2146:
        -: 2147:/**
        -: 2148: * The Array.prototype object's 'reduce' and 'reduceRight' routine
        -: 2149: *
        -: 2150: * See also:
        -: 2151: *         ECMA-262 v5, 15.4.4.21
        -: 2152: *         ECMA-262 v5, 15.4.4.22
        -: 2153: *
        -: 2154: * @return ecma value
        -: 2155: *         Returned value must be freed with ecma_free_value.
        -: 2156: */
        -: 2157:static ecma_value_t
    #####: 2158:ecma_builtin_array_reduce_from (const ecma_value_t args_p[], /**< routine's arguments */
        -: 2159:                                uint32_t args_number, /**< arguments list length */
        -: 2160:                                bool start_from_left, /**< whether the reduce starts from left or right */
        -: 2161:                                ecma_object_t *obj_p, /**< object */
        -: 2162:                                ecma_length_t len) /**< object's length */
        -: 2163:{
        -: 2164:  /* 4. */
    #####: 2165:  if (!ecma_op_is_callable (args_p[0]))
        -: 2166:  {
    #####: 2167:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2168:  }
        -: 2169:
        -: 2170:  /* 5. */
    #####: 2171:  if (len == 0 && args_number == 1)
        -: 2172:  {
    #####: 2173:    return ecma_raise_type_error (ECMA_ERR_MSG ("Reduce of empty Array with no initial value"));
        -: 2174:  }
        -: 2175:
    #####: 2176:  JERRY_ASSERT (ecma_is_value_object (args_p[0]));
    #####: 2177:  ecma_object_t *func_object_p = ecma_get_object_from_value (args_p[0]);
        -: 2178:
    #####: 2179:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
        -: 2180:
        -: 2181:  /* 6. */
    #####: 2182:  ecma_length_t index = 0;
    #####: 2183:  const ecma_length_t last_index = len - 1;
        -: 2184:
        -: 2185:  /* 7.a */
    #####: 2186:  if (args_number > 1)
        -: 2187:  {
    #####: 2188:    accumulator = ecma_copy_value (args_p[1]);
        -: 2189:  }
        -: 2190:  else
        -: 2191:  {
        -: 2192:    /* 8.a */
    #####: 2193:    bool k_present = false;
        -: 2194:
        -: 2195:    /* 8.b */
    #####: 2196:    while (!k_present && index < len)
        -: 2197:    {
        -: 2198:      /* 8.b.i */
    #####: 2199:      k_present = true;
        -: 2200:
        -: 2201:      /* 8.b.ii-iii */
    #####: 2202:      ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, start_from_left ? index
        -: 2203:                                                                                                  : last_index - index);
        -: 2204:
    #####: 2205:      if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2206:      {
    #####: 2207:        return current_value;
        -: 2208:      }
        -: 2209:
    #####: 2210:      if (ecma_is_value_found (current_value))
        -: 2211:      {
    #####: 2212:        accumulator = current_value;
        -: 2213:      }
        -: 2214:      else
        -: 2215:      {
    #####: 2216:        k_present = false;
        -: 2217:      }
        -: 2218:
        -: 2219:      /* 8.b.iv */
    #####: 2220:      index++;
        -: 2221:    }
        -: 2222:
        -: 2223:    /* 8.c */
    #####: 2224:    if (!k_present)
        -: 2225:    {
    #####: 2226:      return ecma_raise_type_error (ECMA_ERR_MSG ("Missing Array element"));
        -: 2227:    }
        -: 2228:  }
        -: 2229:  /* 9. */
        -: 2230:  ecma_value_t current_index;
        -: 2231:
    #####: 2232:  for (; index < len; index++)
        -: 2233:  {
    #####: 2234:    const ecma_length_t corrected_index = start_from_left ? index : last_index - index;
        -: 2235:
        -: 2236:    /* 9.a - 9.b */
    #####: 2237:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, corrected_index);
        -: 2238:
    #####: 2239:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2240:    {
    #####: 2241:      ecma_free_value (accumulator);
    #####: 2242:      return current_value;
        -: 2243:    }
        -: 2244:
    #####: 2245:    if (ecma_is_value_found (current_value))
        -: 2246:    {
        -: 2247:      /* 9.c.i, 9.c.ii */
    #####: 2248:      current_index = ecma_make_length_value (corrected_index);
    #####: 2249:      ecma_value_t call_args[] = {accumulator, current_value, current_index, ecma_make_object_value (obj_p)};
        -: 2250:
    #####: 2251:      ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -: 2252:                                                       ECMA_VALUE_UNDEFINED,
        -: 2253:                                                       call_args,
        -: 2254:                                                       4);
    #####: 2255:      ecma_free_value (current_index);
    #####: 2256:      ecma_free_value (accumulator);
    #####: 2257:      ecma_free_value (current_value);
        -: 2258:
    #####: 2259:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2260:      {
    #####: 2261:        return call_value;
        -: 2262:      }
        -: 2263:
    #####: 2264:      accumulator = call_value;
        -: 2265:    }
        -: 2266:  }
        -: 2267:
    #####: 2268:  return accumulator;
        -: 2269:} /* ecma_builtin_array_reduce_from */
        -: 2270:
        -: 2271:#if JERRY_ESNEXT
        -: 2272:
        -: 2273:/**
        -: 2274: * The Array.prototype object's 'fill' routine
        -: 2275: *
        -: 2276: * Note: this method only supports length up to uint32, instead of max_safe_integer
        -: 2277: *
        -: 2278: * See also:
        -: 2279: *          ECMA-262 v6, 22.1.3.6
        -: 2280: *
        -: 2281: * @return ecma value
        -: 2282: *         Returned value must be freed with ecma_free_value.
        -: 2283: */
        -: 2284:static ecma_value_t
    #####: 2285:ecma_builtin_array_prototype_fill (ecma_value_t value, /**< value */
        -: 2286:                                   ecma_value_t start_val, /**< start value */
        -: 2287:                                   ecma_value_t end_val, /**< end value */
        -: 2288:                                   ecma_object_t *obj_p, /**< object */
        -: 2289:                                   ecma_length_t len) /**< object's length */
        -: 2290:{
    #####: 2291:  ecma_length_t k, final;
        -: 2292:
        -: 2293:  /* 5. 6. 7. */
    #####: 2294:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (start_val,
        -: 2295:                                                                      len,
        -: 2296:                                                                      &k)))
        -: 2297:  {
    #####: 2298:    return ECMA_VALUE_ERROR;
        -: 2299:  }
        -: 2300:
        -: 2301:  /* 8. */
    #####: 2302:  if (ecma_is_value_undefined (end_val))
        -: 2303:  {
    #####: 2304:    final = len;
        -: 2305:  }
        -: 2306:  else
        -: 2307:  {
        -: 2308:    /* 8 part 2, 9, 10 */
    #####: 2309:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end_val,
        -: 2310:                                                                        len,
        -: 2311:                                                                        &final)))
        -: 2312:    {
    #####: 2313:      return ECMA_VALUE_ERROR;
        -: 2314:    }
        -: 2315:  }
        -: 2316:
    #####: 2317:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2318:  {
    #####: 2319:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2320:
    #####: 2321:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2322:    {
    #####: 2323:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 2324:      {
    #####: 2325:        ecma_ref_object (obj_p);
    #####: 2326:        return ecma_make_object_value (obj_p);
        -: 2327:      }
        -: 2328:
    #####: 2329:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2330:
    #####: 2331:      while (k < final)
        -: 2332:      {
    #####: 2333:        ecma_free_value_if_not_object (buffer_p[k]);
    #####: 2334:        buffer_p[k] = ecma_copy_value_if_not_object (value);
    #####: 2335:        k++;
        -: 2336:      }
        -: 2337:
    #####: 2338:      ecma_ref_object (obj_p);
    #####: 2339:      return ecma_make_object_value (obj_p);
        -: 2340:    }
        -: 2341:  }
        -: 2342:
        -: 2343:  /* 11. */
    #####: 2344:  while (k < final)
        -: 2345:  {
        -: 2346:    /* 11.a - 11.b */
    #####: 2347:    ecma_value_t put_val = ecma_op_object_put_by_index (obj_p, k, value, true);
        -: 2348:
        -: 2349:    /* 11. c */
    #####: 2350:    if (ECMA_IS_VALUE_ERROR (put_val))
        -: 2351:    {
    #####: 2352:      return put_val;
        -: 2353:    }
        -: 2354:
        -: 2355:    /* 11.d */
    #####: 2356:    k++;
        -: 2357:  }
        -: 2358:
    #####: 2359:  ecma_ref_object (obj_p);
    #####: 2360:  return ecma_make_object_value (obj_p);
        -: 2361:} /* ecma_builtin_array_prototype_fill */
        -: 2362:
        -: 2363:/**
        -: 2364: * The Array.prototype object's 'find' and 'findIndex' routine
        -: 2365: *
        -: 2366: * See also:
        -: 2367: *          ECMA-262 v6, 22.1.3.8
        -: 2368: *          ECMA-262 v6, 22.1.3.9
        -: 2369: *
        -: 2370: * @return ecma value
        -: 2371: *         Returned value must be freed with ecma_free_value.
        -: 2372: */
        -: 2373:static ecma_value_t
    #####: 2374:ecma_builtin_array_prototype_object_find (ecma_value_t predicate, /**< callback function */
        -: 2375:                                          ecma_value_t predicate_this_arg, /**< this argument for
        -: 2376:                                                                            *   invoke predicate */
        -: 2377:                                          bool is_find, /**< true - find routine
        -: 2378:                                                         *   false - findIndex routine */
        -: 2379:                                          ecma_object_t *obj_p, /**< object */
        -: 2380:                                          ecma_length_t len) /**< object's length */
        -: 2381:{
        -: 2382:  /* 5. */
    #####: 2383:  if (!ecma_op_is_callable (predicate))
        -: 2384:  {
    #####: 2385:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2386:  }
        -: 2387:
        -: 2388:  /* We already checked that predicate is callable, so it will always be an object. */
    #####: 2389:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 2390:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 2391:
        -: 2392:  /* 7 - 8. */
    #####: 2393:  for (ecma_length_t index = 0; index < len; index++)
        -: 2394:  {
        -: 2395:    /* 8.a - 8.c */
    #####: 2396:    ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, index);
        -: 2397:
    #####: 2398:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2399:    {
    #####: 2400:      return get_value;
        -: 2401:    }
        -: 2402:
        -: 2403:    /* 8.d - 8.e */
    #####: 2404:    ecma_value_t current_index = ecma_make_length_value (index);
        -: 2405:
    #####: 2406:    ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2407:
    #####: 2408:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 2409:
    #####: 2410:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2411:    {
    #####: 2412:      ecma_free_value (get_value);
    #####: 2413:      return call_value;
        -: 2414:    }
        -: 2415:
    #####: 2416:    bool call_value_to_bool = ecma_op_to_boolean (call_value);
        -: 2417:
    #####: 2418:    ecma_free_value (call_value);
        -: 2419:
    #####: 2420:    if (call_value_to_bool)
        -: 2421:    {
        -: 2422:      /* 8.f */
    #####: 2423:      if (is_find)
        -: 2424:      {
    #####: 2425:        ecma_free_value (current_index);
    #####: 2426:        return get_value;
        -: 2427:      }
        -: 2428:
    #####: 2429:      ecma_free_value (get_value);
    #####: 2430:      return current_index;
        -: 2431:    }
        -: 2432:
    #####: 2433:    ecma_free_value (get_value);
    #####: 2434:    ecma_free_value (current_index);
        -: 2435:  }
        -: 2436:
        -: 2437:  /* 9. */
    #####: 2438:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 2439:} /* ecma_builtin_array_prototype_object_find */
        -: 2440:
        -: 2441:/**
        -: 2442: * The Array.prototype object's 'copyWithin' routine
        -: 2443: *
        -: 2444: * See also:
        -: 2445: *          ECMA-262 v6, 22.1.3.3
        -: 2446: *
        -: 2447: * @return ecma value
        -: 2448: *         Returned value must be freed with ecma_free_value.
        -: 2449: */
        -: 2450:static ecma_value_t
    #####: 2451:ecma_builtin_array_prototype_object_copy_within (const ecma_value_t args[], /**< arguments list */
        -: 2452:                                                 uint32_t args_number, /**< number of arguments */
        -: 2453:                                                 ecma_object_t *obj_p, /**< object */
        -: 2454:                                                 ecma_length_t len) /**< object's length */
        -: 2455:{
    #####: 2456:  if (args_number == 0)
        -: 2457:  {
    #####: 2458:    return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2459:  }
        -: 2460:
        -: 2461:  /* 5 - 7 */
    #####: 2462:  ecma_length_t target;
        -: 2463:
    #####: 2464:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &target)))
        -: 2465:  {
    #####: 2466:    return ECMA_VALUE_ERROR;
        -: 2467:  }
        -: 2468:
    #####: 2469:  ecma_length_t start = 0;
    #####: 2470:  ecma_length_t end = len;
        -: 2471:
    #####: 2472:  if (args_number > 1)
        -: 2473:  {
        -: 2474:    /* 8 - 10 */
    #####: 2475:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &start)))
        -: 2476:    {
    #####: 2477:      return ECMA_VALUE_ERROR;
        -: 2478:    }
        -: 2479:
    #####: 2480:    if (args_number > 2)
        -: 2481:    {
        -: 2482:      /* 11 */
    #####: 2483:      if (ecma_is_value_undefined (args[2]))
        -: 2484:      {
    #####: 2485:        end = len;
        -: 2486:      }
        -: 2487:      else
        -: 2488:      {
        -: 2489:        /* 11 part 2, 12, 13 */
    #####: 2490:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2], len, &end)))
        -: 2491:        {
    #####: 2492:          return ECMA_VALUE_ERROR;
        -: 2493:        }
        -: 2494:      }
        -: 2495:    }
        -: 2496:  }
        -: 2497:
    #####: 2498:  ecma_length_t count = JERRY_MIN (end - start, len - target);
    #####: 2499:  if (end <= start || len <= target) /* count <= 0 check, but variables are unsigned */
        -: 2500:  {
    #####: 2501:    ecma_ref_object (obj_p);
    #####: 2502:    return ecma_make_object_value (obj_p);
        -: 2503:  }
        -: 2504:
    #####: 2505:  bool forward = true;
        -: 2506:
    #####: 2507:  if (start < target && target < start + count)
        -: 2508:  {
    #####: 2509:    start = start + count - 1;
    #####: 2510:    target = target + count - 1;
    #####: 2511:    forward = false;
        -: 2512:  }
        -: 2513:
    #####: 2514:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2515:  {
    #####: 2516:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####: 2517:    const uint32_t actual_length = ext_obj_p->u.array.length;
        -: 2518:
    #####: 2519:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 2520:        && ((forward && (target + count - 1 < actual_length)) || (!forward && (target < actual_length))))
        -: 2521:    {
    #####: 2522:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2523:      {
    #####: 2524:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2525:
    #####: 2526:        for (; count > 0; count--)
        -: 2527:        {
    #####: 2528:          ecma_value_t copy_value = ecma_copy_value_if_not_object (buffer_p[start]);
        -: 2529:
    #####: 2530:          ecma_free_value_if_not_object (buffer_p[target]);
        -: 2531:
    #####: 2532:          buffer_p[target] = copy_value;
        -: 2533:
    #####: 2534:          if (forward)
        -: 2535:          {
    #####: 2536:            start++;
    #####: 2537:            target++;
        -: 2538:          }
        -: 2539:          else
        -: 2540:          {
    #####: 2541:            start--;
    #####: 2542:            target--;
        -: 2543:          }
        -: 2544:        }
        -: 2545:      }
        -: 2546:
    #####: 2547:      ecma_ref_object (obj_p);
    #####: 2548:      return ecma_make_object_value (obj_p);
        -: 2549:    }
        -: 2550:  }
        -: 2551:
    #####: 2552:  while (count > 0)
        -: 2553:  {
    #####: 2554:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, start);
        -: 2555:
    #####: 2556:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2557:    {
    #####: 2558:      return get_value;
        -: 2559:    }
        -: 2560:
        -: 2561:    ecma_value_t op_value;
        -: 2562:
    #####: 2563:    if (ecma_is_value_found (get_value))
        -: 2564:    {
    #####: 2565:      op_value = ecma_op_object_put_by_index (obj_p, target, get_value, true);
        -: 2566:    }
        -: 2567:    else
        -: 2568:    {
    #####: 2569:      op_value = ecma_op_object_delete_by_index (obj_p, target, true);
        -: 2570:    }
        -: 2571:
    #####: 2572:    ecma_free_value (get_value);
        -: 2573:
    #####: 2574:    if (ECMA_IS_VALUE_ERROR (op_value))
        -: 2575:    {
    #####: 2576:      return op_value;
        -: 2577:    }
        -: 2578:
    #####: 2579:    ecma_free_value (op_value);
        -: 2580:
    #####: 2581:    if (forward)
        -: 2582:    {
    #####: 2583:      start++;
    #####: 2584:      target++;
        -: 2585:    }
        -: 2586:    else
        -: 2587:    {
    #####: 2588:      start--;
    #####: 2589:      target--;
        -: 2590:    }
        -: 2591:
    #####: 2592:    count--;
        -: 2593:  }
        -: 2594:
    #####: 2595:  return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2596:} /* ecma_builtin_array_prototype_object_copy_within */
        -: 2597:
        -: 2598:/**
        -: 2599: * The Array.prototype object's 'includes' routine
        -: 2600: *
        -: 2601: * See also:
        -: 2602: *          ECMA-262 v11, 22.1.3.13
        -: 2603: *
        -: 2604: * @return ECMA_VALUE_ERROR -if the operation fails
        -: 2605: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the search element is in the array or not
        -: 2606: */
        -: 2607:static ecma_value_t
    #####: 2608:ecma_builtin_array_prototype_includes (const ecma_value_t args[], /**< arguments list */
        -: 2609:                                       uint32_t args_number, /**< number of arguments */
        -: 2610:                                       ecma_object_t *obj_p, /**< object */
        -: 2611:                                       ecma_length_t len) /**< object's length */
        -: 2612:{
        -: 2613:  /* 3. */
    #####: 2614:  if (len == 0)
        -: 2615:  {
    #####: 2616:    return ECMA_VALUE_FALSE;
        -: 2617:  }
        -: 2618:
    #####: 2619:  ecma_length_t from_index = 0;
        -: 2620:
        -: 2621:  /* 4-7. */
    #####: 2622:  if (args_number > 1)
        -: 2623:  {
    #####: 2624:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &from_index)))
        -: 2625:    {
    #####: 2626:      return ECMA_VALUE_ERROR;
        -: 2627:    }
        -: 2628:  }
        -: 2629:
        -: 2630:  /* Fast array path */
    #####: 2631:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2632:  {
    #####: 2633:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2634:
    #####: 2635:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2636:    {
    #####: 2637:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2638:      {
    #####: 2639:        len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 2640:
    #####: 2641:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2642:
    #####: 2643:        while (from_index < len)
        -: 2644:        {
    #####: 2645:          if (ecma_op_same_value_zero (buffer_p[from_index], args[0], false))
        -: 2646:          {
    #####: 2647:            return ECMA_VALUE_TRUE;
        -: 2648:          }
        -: 2649:
    #####: 2650:          from_index++;
        -: 2651:        }
        -: 2652:      }
        -: 2653:
    #####: 2654:      return ECMA_VALUE_FALSE;
        -: 2655:    }
        -: 2656:  }
        -: 2657:
        -: 2658:  /* 8. */
    #####: 2659:  while (from_index < len)
        -: 2660:  {
    #####: 2661:    ecma_value_t element = ecma_op_object_get_by_index (obj_p, from_index);
        -: 2662:
    #####: 2663:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2664:    {
    #####: 2665:      return element;
        -: 2666:    }
        -: 2667:
    #####: 2668:    if (ecma_op_same_value_zero (element, args[0], false))
        -: 2669:    {
    #####: 2670:      ecma_free_value (element);
    #####: 2671:      return ECMA_VALUE_TRUE;
        -: 2672:    }
        -: 2673:
    #####: 2674:    ecma_free_value (element);
    #####: 2675:    from_index++;
        -: 2676:  }
        -: 2677:
        -: 2678:  /* 9. */
    #####: 2679:  return ECMA_VALUE_FALSE;
        -: 2680:} /* ecma_builtin_array_prototype_includes */
        -: 2681:
        -: 2682:/**
        -: 2683: * Abstract operation: FlattenIntoArray
        -: 2684: *
        -: 2685: * See also:
        -: 2686: *          ECMA-262 v10, 22.1.3.10.1
        -: 2687: *
        -: 2688: * @return  ECMA_VALUE_ERROR -if the operation fails
        -: 2689: *          ecma value which contains target_index
        -: 2690: */
        -: 2691:static ecma_value_t
    #####: 2692:ecma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */
        -: 2693:                                       ecma_object_t *source, /**< source object */
        -: 2694:                                       ecma_length_t source_len, /**< source object length */
        -: 2695:                                       ecma_length_t start, /**< remaining recursion depth */
        -: 2696:                                       ecma_number_t depth, /**< start index offset */
        -: 2697:                                       ecma_value_t mapped_value, /**< mapped value  */
        -: 2698:                                       ecma_value_t thisArg) /**< this arg */
        -: 2699:{
        -: 2700:  /* 7. */
    #####: 2701:  ecma_length_t target_index = start;
        -: 2702:
        -: 2703:  /* 9. */
    #####: 2704:  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)
        -: 2705:  {
        -: 2706:    /* a. */
    #####: 2707:    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);
        -: 2708:
    #####: 2709:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2710:    {
    #####: 2711:      return element;
        -: 2712:    }
        -: 2713:
    #####: 2714:    if (!ecma_is_value_found (element))
        -: 2715:    {
    #####: 2716:      continue;
        -: 2717:    }
        -: 2718:
        -: 2719:    /* b-c. */
    #####: 2720:    if (!ecma_is_value_undefined (mapped_value))
        -: 2721:    {
        -: 2722:      /* i-ii. */
    #####: 2723:      ecma_value_t source_val = ecma_make_length_value (source_index);
    #####: 2724:      ecma_value_t args[] = {element, source_val, ecma_make_object_value (source)};
    #####: 2725:      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);
        -: 2726:
    #####: 2727:      ecma_free_value (element);
    #####: 2728:      ecma_free_value (source_val);
        -: 2729:
    #####: 2730:      if (ECMA_IS_VALUE_ERROR (temp_element))
        -: 2731:      {
    #####: 2732:        return temp_element;
        -: 2733:      }
        -: 2734:
    #####: 2735:      element = temp_element;
        -: 2736:    }
        -: 2737:
        -: 2738:    /* iv-v. */
    #####: 2739:    if (depth > 0)
        -: 2740:    {
    #####: 2741:      ecma_value_t is_array = ecma_is_value_array (element);
        -: 2742:
    #####: 2743:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 2744:      {
    #####: 2745:        ecma_free_value (element);
    #####: 2746:        return is_array;
        -: 2747:      }
        -: 2748:
    #####: 2749:      if (ecma_is_value_true (is_array))
        -: 2750:      {
    #####: 2751:        ecma_object_t *element_obj = ecma_get_object_from_value (element);
    #####: 2752:        ecma_length_t element_len;
    #####: 2753:        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);
        -: 2754:
    #####: 2755:        if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2756:        {
    #####: 2757:          ecma_deref_object (element_obj);
    #####: 2758:          return len_value;
        -: 2759:        }
        -: 2760:
    #####: 2761:        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,
        -: 2762:                                                                               element_obj,
        -: 2763:                                                                               element_len,
        -: 2764:                                                                               target_index,
        -: 2765:                                                                               depth - 1,
        -: 2766:                                                                               ECMA_VALUE_UNDEFINED,
        -: 2767:                                                                               ECMA_VALUE_UNDEFINED);
        -: 2768:
    #####: 2769:        ecma_deref_object (element_obj);
        -: 2770:
    #####: 2771:        if (ECMA_IS_VALUE_ERROR (target_index_val))
        -: 2772:        {
    #####: 2773:          return target_index_val;
        -: 2774:        }
        -: 2775:
    #####: 2776:        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);
    #####: 2777:        continue;
        -: 2778:      }
        -: 2779:    }
        -: 2780:
        -: 2781:    /* vi. */
    #####: 2782:    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 2783:    ecma_value_t element_temp = ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target),
        -: 2784:                                                                       target_index,
        -: 2785:                                                                       element,
        -: 2786:                                                                       flags);
        -: 2787:
    #####: 2788:    ecma_free_value (element);
        -: 2789:
    #####: 2790:    if (ECMA_IS_VALUE_ERROR (element_temp))
        -: 2791:    {
    #####: 2792:      return element_temp;
        -: 2793:    }
        -: 2794:
    #####: 2795:    target_index++;
        -: 2796:  }
        -: 2797:  /* 10. */
    #####: 2798:  return ecma_make_length_value (target_index);
        -: 2799:} /* ecma_builtin_array_flatten_into_array */
        -: 2800:
        -: 2801:/**
        -: 2802: * The Array.prototype object's 'flat' routine
        -: 2803: *
        -: 2804: * See also:
        -: 2805: *          ECMA-262 v10, 22.1.3.10
        -: 2806: *
        -: 2807: * @return ecma value
        -: 2808: *         Returned value must be freed with ecma_free_value.
        -: 2809: */
        -: 2810:static ecma_value_t
    #####: 2811:ecma_builtin_array_prototype_object_flat (const ecma_value_t args[], /**< arguments list */
        -: 2812:                                          uint32_t args_number, /**< number of arguments */
        -: 2813:                                          ecma_object_t *obj_p, /**< array object */
        -: 2814:                                          ecma_length_t len) /**< array object's length */
        -: 2815:{
        -: 2816:  /* 3. */
    #####: 2817:  ecma_number_t depth_num = 1;
        -: 2818:
        -: 2819:  /* 4. */
    #####: 2820:  if (args_number > 0 && ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[0], &depth_num)))
        -: 2821:  {
    #####: 2822:    return ECMA_VALUE_ERROR;
        -: 2823:  }
        -: 2824:
        -: 2825:  /* 5. */
    #####: 2826:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2827:
    #####: 2828:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2829:  {
    #####: 2830:    return ECMA_VALUE_ERROR;
        -: 2831:  }
        -: 2832:
        -: 2833:  /* 6. */
    #####: 2834:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2835:                                                                    obj_p,
        -: 2836:                                                                    len,
        -: 2837:                                                                    0,
        -: 2838:                                                                    depth_num,
        -: 2839:                                                                    ECMA_VALUE_UNDEFINED,
        -: 2840:                                                                    ECMA_VALUE_UNDEFINED);
        -: 2841:
    #####: 2842:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2843:  {
    #####: 2844:    ecma_deref_object (new_array_p);
    #####: 2845:    return flatten_val;
        -: 2846:  }
        -: 2847:
        -: 2848:  /* 7. */
    #####: 2849:  return ecma_make_object_value (new_array_p);
        -: 2850:} /* ecma_builtin_array_prototype_object_flat */
        -: 2851:
        -: 2852:/**
        -: 2853: * The Array.prototype object's 'flatMap' routine
        -: 2854: *
        -: 2855: * See also:
        -: 2856: *          ECMA-262 v10, 22.1.3.11
        -: 2857: *
        -: 2858: * @return ecma value
        -: 2859: *         Returned value must be freed with ecma_free_value.
        -: 2860: */
        -: 2861:static ecma_value_t
    #####: 2862:ecma_builtin_array_prototype_object_flat_map (ecma_value_t callback, /**< callbackFn */
        -: 2863:                                              ecma_value_t this_arg, /**< thisArg */
        -: 2864:                                              ecma_object_t *obj_p, /**< array object */
        -: 2865:                                              ecma_length_t len) /**< array object's length */
        -: 2866:{
    #####: 2867:  if (!ecma_op_is_callable (callback))
        -: 2868:  {
    #####: 2869:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2870:  }
        -: 2871:
        -: 2872:  /* 4. */
    #####: 2873:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2874:
    #####: 2875:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2876:  {
    #####: 2877:    return ECMA_VALUE_ERROR;
        -: 2878:  }
        -: 2879:
        -: 2880:  /* 5. */
    #####: 2881:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2882:                                                                    obj_p,
        -: 2883:                                                                    len,
        -: 2884:                                                                    0,
        -: 2885:                                                                    1,
        -: 2886:                                                                    callback,
        -: 2887:                                                                    this_arg);
    #####: 2888:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2889:  {
    #####: 2890:    ecma_deref_object (new_array_p);
    #####: 2891:    return flatten_val;
        -: 2892:  }
        -: 2893:
        -: 2894:  /* 6. */
    #####: 2895:  return ecma_make_object_value (new_array_p);
        -: 2896:} /* ecma_builtin_array_prototype_object_flat_map */
        -: 2897:#endif /* JERRY_ESNEXT */
        -: 2898:
        -: 2899:/**
        -: 2900: * Dispatcher of the built-in's routines
        -: 2901: *
        -: 2902: * @return ecma value
        -: 2903: *         Returned value must be freed with ecma_free_value.
        -: 2904: */
        -: 2905:ecma_value_t
    #####: 2906:ecma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 2907:                                               ecma_value_t this_arg, /**< 'this' argument value */
        -: 2908:                                               const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 2909:                                                                                       *   passed to routine */
        -: 2910:                                               uint32_t arguments_number) /**< length of arguments' list */
        -: 2911:{
    #####: 2912:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -: 2913:
    #####: 2914:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -: 2915:  {
    #####: 2916:    return obj_this;
        -: 2917:  }
        -: 2918:
    #####: 2919:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -: 2920:
    #####: 2921:  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))
        -: 2922:  {
    #####: 2923:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 2924:
        -: 2925:#if !JERRY_ESNEXT
    #####: 2926:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)
        -: 2927:    {
    #####: 2928:      ret_value = ecma_array_object_to_string (obj_this);
        -: 2929:    }
        -: 2930:#endif /* !JERRY_ESNEXT */
    #####: 2931:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_SORT)
        -: 2932:    {
    #####: 2933:      ret_value = ecma_builtin_array_prototype_object_sort (this_arg,
        -: 2934:                                                            arguments_list_p[0],
        -: 2935:                                                            obj_p);
        -: 2936:
        -: 2937:    }
    #####: 2938:    else if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT)
        -: 2939:    {
    #####: 2940:      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p,
        -: 2941:                                                              arguments_number,
        -: 2942:                                                              obj_p);
        -: 2943:    }
        -: 2944:
    #####: 2945:    ecma_deref_object (obj_p);
    #####: 2946:    return ret_value;
        -: 2947:  }
        -: 2948:
        -: 2949:#if JERRY_ESNEXT
    #####: 2950:  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES
        -: 2951:                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))
        -: 2952:  {
        -: 2953:    ecma_value_t ret_value;
        -: 2954:
    #####: 2955:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)
        -: 2956:    {
    #####: 2957:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_ENTRIES);
        -: 2958:    }
        -: 2959:    else
        -: 2960:    {
    #####: 2961:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);
    #####: 2962:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);
        -: 2963:    }
        -: 2964:
    #####: 2965:    ecma_deref_object (obj_p);
    #####: 2966:    return ret_value;
        -: 2967:  }
        -: 2968:#endif /* JERRY_ESNEXT */
        -: 2969:
    #####: 2970:  ecma_length_t length;
    #####: 2971:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -: 2972:
    #####: 2973:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2974:  {
    #####: 2975:    ecma_deref_object (obj_p);
    #####: 2976:    return len_value;
        -: 2977:  }
        -: 2978:
        -: 2979:  ecma_value_t ret_value;
        -: 2980:
    #####: 2981:  switch (builtin_routine_id)
        -: 2982:  {
    #####: 2983:    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:
        -: 2984:    {
    #####: 2985:      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);
    #####: 2986:      break;
        -: 2987:    }
    #####: 2988:    case ECMA_ARRAY_PROTOTYPE_JOIN:
        -: 2989:    {
    #####: 2990:      ret_value = ecma_builtin_array_prototype_join (arguments_list_p[0], obj_p, length);
    #####: 2991:      break;
        -: 2992:    }
    #####: 2993:    case ECMA_ARRAY_PROTOTYPE_POP:
        -: 2994:    {
    #####: 2995:      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);
    #####: 2996:      break;
        -: 2997:    }
    #####: 2998:    case ECMA_ARRAY_PROTOTYPE_PUSH:
        -: 2999:    {
    #####: 3000:      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p,
        -: 3001:                                                            arguments_number,
        -: 3002:                                                            obj_p,
        -: 3003:                                                            length);
    #####: 3004:      break;
        -: 3005:    }
    #####: 3006:    case ECMA_ARRAY_PROTOTYPE_REVERSE:
        -: 3007:    {
    #####: 3008:      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);
    #####: 3009:      break;
        -: 3010:    }
    #####: 3011:    case ECMA_ARRAY_PROTOTYPE_SHIFT:
        -: 3012:    {
    #####: 3013:      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);
    #####: 3014:      break;
        -: 3015:    }
    #####: 3016:    case ECMA_ARRAY_PROTOTYPE_SLICE:
        -: 3017:    {
    #####: 3018:      ret_value = ecma_builtin_array_prototype_object_slice (arguments_list_p[0],
    #####: 3019:                                                             arguments_list_p[1],
        -: 3020:                                                             obj_p,
        -: 3021:                                                             length);
    #####: 3022:      break;
        -: 3023:    }
    #####: 3024:    case ECMA_ARRAY_PROTOTYPE_SPLICE:
        -: 3025:    {
    #####: 3026:      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p,
        -: 3027:                                                              arguments_number,
        -: 3028:                                                              obj_p,
        -: 3029:                                                              length);
    #####: 3030:      break;
        -: 3031:    }
    #####: 3032:    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:
        -: 3033:    {
    #####: 3034:      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p,
        -: 3035:                                                               arguments_number,
        -: 3036:                                                               obj_p,
        -: 3037:                                                               length);
    #####: 3038:      break;
        -: 3039:    }
    #####: 3040:    case ECMA_ARRAY_PROTOTYPE_AT:
        -: 3041:    {
    #####: 3042:      ret_value = ecma_builtin_array_prototype_object_at (arguments_list_p[0],
        -: 3043:                                                          obj_p,
        -: 3044:                                                          length);
    #####: 3045:      break;
        -: 3046:    }
    #####: 3047:    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:
        -: 3048:    {
    #####: 3049:      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p,
        -: 3050:                                                                arguments_number,
        -: 3051:                                                                obj_p,
        -: 3052:                                                                length);
    #####: 3053:      break;
        -: 3054:    }
    #####: 3055:    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:
        -: 3056:    {
    #####: 3057:      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p,
        -: 3058:                                                                     arguments_number,
        -: 3059:                                                                     obj_p,
        -: 3060:                                                                     length);
    #####: 3061:      break;
        -: 3062:    }
    #####: 3063:    case ECMA_ARRAY_PROTOTYPE_EVERY:
        -: 3064:    case ECMA_ARRAY_PROTOTYPE_SOME:
        -: 3065:    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:
        -: 3066:    {
    #####: 3067:      ret_value = ecma_builtin_array_apply (arguments_list_p[0],
    #####: 3068:                                            arguments_list_p[1],
    #####: 3069:                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,
        -: 3070:                                            obj_p,
        -: 3071:                                            length);
    #####: 3072:      break;
        -: 3073:    }
    #####: 3074:    case ECMA_ARRAY_PROTOTYPE_MAP:
        -: 3075:    {
    #####: 3076:      ret_value = ecma_builtin_array_prototype_object_map (arguments_list_p[0],
    #####: 3077:                                                           arguments_list_p[1],
        -: 3078:                                                           obj_p,
        -: 3079:                                                           length);
    #####: 3080:      break;
        -: 3081:    }
    #####: 3082:    case ECMA_ARRAY_PROTOTYPE_REDUCE:
        -: 3083:    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:
        -: 3084:    {
    #####: 3085:      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,
        -: 3086:                                                  arguments_number,
        -: 3087:                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,
        -: 3088:                                                  obj_p,
        -: 3089:                                                  length);
    #####: 3090:      break;
        -: 3091:    }
        -: 3092:#if JERRY_ESNEXT
    #####: 3093:    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:
        -: 3094:    {
    #####: 3095:      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p,
        -: 3096:                                                                   arguments_number,
        -: 3097:                                                                   obj_p,
        -: 3098:                                                                   length);
    #####: 3099:      break;
        -: 3100:    }
    #####: 3101:    case ECMA_ARRAY_PROTOTYPE_FIND:
        -: 3102:    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:
        -: 3103:    {
    #####: 3104:      ret_value = ecma_builtin_array_prototype_object_find (arguments_list_p[0],
    #####: 3105:                                                            arguments_list_p[1],
        -: 3106:                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,
        -: 3107:                                                            obj_p,
        -: 3108:                                                            length);
    #####: 3109:      break;
        -: 3110:    }
    #####: 3111:    case ECMA_ARRAY_PROTOTYPE_FILL:
        -: 3112:    {
    #####: 3113:      ret_value = ecma_builtin_array_prototype_fill (arguments_list_p[0],
    #####: 3114:                                                     arguments_list_p[1],
    #####: 3115:                                                     arguments_list_p[2],
        -: 3116:                                                     obj_p,
        -: 3117:                                                     length);
    #####: 3118:      break;
        -: 3119:    }
    #####: 3120:    case ECMA_ARRAY_PROTOTYPE_INCLUDES:
        -: 3121:    {
    #####: 3122:      ret_value = ecma_builtin_array_prototype_includes (arguments_list_p,
        -: 3123:                                                         arguments_number,
        -: 3124:                                                         obj_p,
        -: 3125:                                                         length);
    #####: 3126:      break;
        -: 3127:    }
    #####: 3128:    case ECMA_ARRAY_PROTOTYPE_FLAT:
        -: 3129:    {
    #####: 3130:      ret_value = ecma_builtin_array_prototype_object_flat (arguments_list_p,
        -: 3131:                                                            arguments_number,
        -: 3132:                                                            obj_p,
        -: 3133:                                                            length);
    #####: 3134:      break;
        -: 3135:    }
    #####: 3136:    case ECMA_ARRAY_PROTOTYPE_FLATMAP:
        -: 3137:    {
    #####: 3138:      ret_value = ecma_builtin_array_prototype_object_flat_map (arguments_list_p[0],
    #####: 3139:                                                                arguments_list_p[1],
        -: 3140:                                                                obj_p,
        -: 3141:                                                                length);
    #####: 3142:      break;
        -: 3143:    }
        -: 3144:#endif /* JERRY_ESNEXT */
    #####: 3145:    default:
        -: 3146:    {
    #####: 3147:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);
        -: 3148:
    #####: 3149:      ret_value = ecma_builtin_array_prototype_object_filter (arguments_list_p[0],
    #####: 3150:                                                              arguments_list_p[1],
        -: 3151:                                                              obj_p,
        -: 3152:                                                              length);
    #####: 3153:      break;
        -: 3154:    }
        -: 3155:  }
        -: 3156:
    #####: 3157:  ecma_free_value (len_value);
    #####: 3158:  ecma_deref_object (obj_p);
        -: 3159:
    #####: 3160:  return ret_value;
        -: 3161:} /* ecma_builtin_array_prototype_dispatch_routine */
        -: 3162:
        -: 3163:/**
        -: 3164: * @}
        -: 3165: * @}
        -: 3166: * @}
        -: 3167: */
        -: 3168:
        -: 3169:#endif /* JERRY_BUILTIN_ARRAY */
