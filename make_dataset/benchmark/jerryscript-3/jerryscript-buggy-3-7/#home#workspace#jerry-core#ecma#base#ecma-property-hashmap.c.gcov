        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-property-hashmap.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-globals.h"
        -:   17:#include "ecma-helpers.h"
        -:   18:#include "ecma-property-hashmap.h"
        -:   19:#include "jrt-libc-includes.h"
        -:   20:#include "jcontext.h"
        -:   21:
        -:   22:/** \addtogroup ecma ECMA
        -:   23: * @{
        -:   24: *
        -:   25: * \addtogroup ecmapropertyhashmap Property hashmap
        -:   26: * @{
        -:   27: */
        -:   28:
        -:   29:#if JERRY_PROPERTY_HASHMAP
        -:   30:
        -:   31:/**
        -:   32: * Compute the total size of the property hashmap.
        -:   33: */
        -:   34:#define ECMA_PROPERTY_HASHMAP_GET_TOTAL_SIZE(max_property_count) \
        -:   35:  (sizeof (ecma_property_hashmap_t) + (max_property_count * sizeof (jmem_cpointer_t)) + (max_property_count >> 3))
        -:   36:
        -:   37:/**
        -:   38: * Number of items in the stepping table.
        -:   39: */
        -:   40:#define ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS 8
        -:   41:
        -:   42:/**
        -:   43: * Stepping values for searching items in the hashmap.
        -:   44: */
        -:   45:static const uint8_t ecma_property_hashmap_steps[ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS] JERRY_ATTR_CONST_DATA =
        -:   46:{
        -:   47:  3, 5, 7, 11, 13, 17, 19, 23
        -:   48:};
        -:   49:
        -:   50:/**
        -:   51: * Get the value of a bit in a bitmap.
        -:   52: */
        -:   53:#define ECMA_PROPERTY_HASHMAP_GET_BIT(byte_p, index) \
        -:   54:  ((byte_p)[(index) >> 3] & (1 << ((index) & 0x7)))
        -:   55:
        -:   56:/**
        -:   57: * Clear the value of a bit in a bitmap.
        -:   58: */
        -:   59:#define ECMA_PROPERTY_HASHMAP_CLEAR_BIT(byte_p, index) \
        -:   60:  ((byte_p)[(index) >> 3] = (uint8_t) ((byte_p)[(index) >> 3] & ~(1 << ((index) & 0x7))))
        -:   61:
        -:   62:/**
        -:   63: * Set the value of a bit in a bitmap.
        -:   64: */
        -:   65:#define ECMA_PROPERTY_HASHMAP_SET_BIT(byte_p, index) \
        -:   66:  ((byte_p)[(index) >> 3] = (uint8_t) ((byte_p)[(index) >> 3] | (1 << ((index) & 0x7))))
        -:   67:
        -:   68:/**
        -:   69: * Create a new property hashmap for the object.
        -:   70: * The object must not have a property hashmap.
        -:   71: */
        -:   72:void
    #####:   73:ecma_property_hashmap_create (ecma_object_t *object_p) /**< object */
        -:   74:{
    #####:   75:  if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) != ECMA_PROP_HASHMAP_ALLOC_ON)
        -:   76:  {
    #####:   77:    return;
        -:   78:  }
        -:   79:
    #####:   80:  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;
        -:   81:
    #####:   82:  if (prop_iter_cp == JMEM_CP_NULL)
        -:   83:  {
    #####:   84:    return;
        -:   85:  }
        -:   86:
    #####:   87:  uint32_t named_property_count = 0;
        -:   88:
    #####:   89:  while (prop_iter_cp != JMEM_CP_NULL)
        -:   90:  {
    #####:   91:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####:   92:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:   93:
    #####:   94:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:   95:    {
    #####:   96:      if (prop_iter_p->types[i] != ECMA_PROPERTY_TYPE_DELETED)
        -:   97:      {
    #####:   98:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[i]));
    #####:   99:        named_property_count++;
        -:  100:      }
        -:  101:    }
    #####:  102:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  103:  }
        -:  104:
    #####:  105:  if (named_property_count < (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))
        -:  106:  {
    #####:  107:    return;
        -:  108:  }
        -:  109:
        -:  110:  /* The max_property_count must be power of 2. */
    #####:  111:  uint32_t max_property_count = ECMA_PROPERTY_HASMAP_MINIMUM_SIZE;
        -:  112:
        -:  113:  /* At least 1/3 items must be NULL. */
    #####:  114:  while (max_property_count < (named_property_count + (named_property_count >> 1)))
        -:  115:  {
    #####:  116:    max_property_count <<= 1;
        -:  117:  }
        -:  118:
    #####:  119:  size_t total_size = ECMA_PROPERTY_HASHMAP_GET_TOTAL_SIZE (max_property_count);
        -:  120:
    #####:  121:  ecma_property_hashmap_t *hashmap_p = (ecma_property_hashmap_t *) jmem_heap_alloc_block_null_on_error (total_size);
        -:  122:
    #####:  123:  if (hashmap_p == NULL)
        -:  124:  {
    #####:  125:    return;
        -:  126:  }
        -:  127:
    #####:  128:  memset (hashmap_p, 0, total_size);
        -:  129:
    #####:  130:  hashmap_p->header.types[0] = ECMA_PROPERTY_TYPE_HASHMAP;
    #####:  131:  hashmap_p->header.next_property_cp = object_p->u1.property_list_cp;
    #####:  132:  hashmap_p->max_property_count = max_property_count;
    #####:  133:  hashmap_p->null_count = max_property_count - named_property_count;
    #####:  134:  hashmap_p->unused_count = max_property_count - named_property_count;
        -:  135:
    #####:  136:  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);
    #####:  137:  uint8_t *bits_p = (uint8_t *) (pair_list_p + max_property_count);
    #####:  138:  uint32_t mask = max_property_count - 1;
        -:  139:
    #####:  140:  prop_iter_cp = object_p->u1.property_list_cp;
    #####:  141:  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, hashmap_p);
        -:  142:
    #####:  143:  while (prop_iter_cp != JMEM_CP_NULL)
        -:  144:  {
    #####:  145:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####:  146:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  147:
    #####:  148:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  149:    {
    #####:  150:      if (prop_iter_p->types[i] == ECMA_PROPERTY_TYPE_DELETED)
        -:  151:      {
    #####:  152:        continue;
        -:  153:      }
        -:  154:
    #####:  155:      JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[i]));
        -:  156:
    #####:  157:      ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  158:
    #####:  159:      uint32_t entry_index = ecma_string_get_property_name_hash (prop_iter_p->types[i],
    #####:  160:                                                                 property_pair_p->names_cp[i]);
    #####:  161:      uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];
        -:  162:
    #####:  163:      entry_index &= mask;
        -:  164:#ifndef JERRY_NDEBUG
        -:  165:      /* Because max_property_count (power of 2) and step (a prime
        -:  166:       * number) are relative primes, all entries of the hasmap are
        -:  167:       * visited exactly once before the start entry index is reached
        -:  168:       * again. Furthermore because at least one NULL is present in
        -:  169:       * the hashmap, the while loop must be terminated before the
        -:  170:       * the starting index is reached again. */
    #####:  171:      uint32_t start_entry_index = entry_index;
        -:  172:#endif /* !JERRY_NDEBUG */
        -:  173:
    #####:  174:      while (pair_list_p[entry_index] != ECMA_NULL_POINTER)
        -:  175:      {
    #####:  176:        entry_index = (entry_index + step) & mask;
        -:  177:
        -:  178:#ifndef JERRY_NDEBUG
    #####:  179:        JERRY_ASSERT (entry_index != start_entry_index);
        -:  180:#endif /* !JERRY_NDEBUG */
        -:  181:      }
        -:  182:
    #####:  183:      ECMA_SET_NON_NULL_POINTER (pair_list_p[entry_index], property_pair_p);
        -:  184:
    #####:  185:      if (i != 0)
        -:  186:      {
    #####:  187:        ECMA_PROPERTY_HASHMAP_SET_BIT (bits_p, entry_index);
        -:  188:      }
        -:  189:    }
        -:  190:
    #####:  191:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  192:  }
        -:  193:} /* ecma_property_hashmap_create */
        -:  194:
        -:  195:/**
        -:  196: * Free the hashmap of the object.
        -:  197: * The object must have a property hashmap.
        -:  198: */
        -:  199:void
    #####:  200:ecma_property_hashmap_free (ecma_object_t *object_p) /**< object */
        -:  201:{
        -:  202:  /* Property hash must be exists and must be the first property. */
    #####:  203:  JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  204:
    #####:  205:  ecma_property_header_t *property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  206:                                                                  object_p->u1.property_list_cp);
        -:  207:
    #####:  208:  JERRY_ASSERT (property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP);
        -:  209:
    #####:  210:  ecma_property_hashmap_t *hashmap_p = (ecma_property_hashmap_t *) property_p;
        -:  211:
    #####:  212:  object_p->u1.property_list_cp = property_p->next_property_cp;
        -:  213:
    #####:  214:  jmem_heap_free_block (hashmap_p,
    #####:  215:                        ECMA_PROPERTY_HASHMAP_GET_TOTAL_SIZE (hashmap_p->max_property_count));
    #####:  216:} /* ecma_property_hashmap_free */
        -:  217:
        -:  218:/**
        -:  219: * Insert named property into the hashmap.
        -:  220: */
        -:  221:void
    #####:  222:ecma_property_hashmap_insert (ecma_object_t *object_p, /**< object */
        -:  223:                              ecma_string_t *name_p, /**< name of the property */
        -:  224:                              ecma_property_pair_t *property_pair_p, /**< property pair */
        -:  225:                              int property_index) /**< property index in the pair (0 or 1) */
        -:  226:{
    #####:  227:  JERRY_ASSERT (property_pair_p != NULL);
        -:  228:
    #####:  229:  ecma_property_hashmap_t *hashmap_p = ECMA_GET_NON_NULL_POINTER (ecma_property_hashmap_t,
        -:  230:                                                                  object_p->u1.property_list_cp);
        -:  231:
    #####:  232:  JERRY_ASSERT (hashmap_p->header.types[0] == ECMA_PROPERTY_TYPE_HASHMAP);
        -:  233:
        -:  234:  /* The NULLs are reduced below 1/8 of the hashmap. */
    #####:  235:  if (hashmap_p->null_count < (hashmap_p->max_property_count >> 3))
        -:  236:  {
    #####:  237:    ecma_property_hashmap_free (object_p);
    #####:  238:    ecma_property_hashmap_create (object_p);
    #####:  239:    return;
        -:  240:  }
        -:  241:
    #####:  242:  JERRY_ASSERT (property_index < ECMA_PROPERTY_PAIR_ITEM_COUNT);
        -:  243:
    #####:  244:  uint32_t entry_index = ecma_string_hash (name_p);
    #####:  245:  uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];
    #####:  246:  uint32_t mask = hashmap_p->max_property_count - 1;
    #####:  247:  entry_index &= mask;
        -:  248:
        -:  249:#ifndef JERRY_NDEBUG
        -:  250:  /* See the comment for this variable in ecma_property_hashmap_create. */
    #####:  251:  uint32_t start_entry_index = entry_index;
        -:  252:#endif /* !JERRY_NDEBUG */
        -:  253:
    #####:  254:  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);
        -:  255:
    #####:  256:  while (pair_list_p[entry_index] != ECMA_NULL_POINTER)
        -:  257:  {
    #####:  258:    entry_index = (entry_index + step) & mask;
        -:  259:
        -:  260:#ifndef JERRY_NDEBUG
    #####:  261:    JERRY_ASSERT (entry_index != start_entry_index);
        -:  262:#endif /* !JERRY_NDEBUG */
        -:  263:  }
        -:  264:
    #####:  265:  ECMA_SET_NON_NULL_POINTER (pair_list_p[entry_index], property_pair_p);
        -:  266:
    #####:  267:  uint8_t *bits_p = (uint8_t *) (pair_list_p + hashmap_p->max_property_count);
    #####:  268:  bits_p += (entry_index >> 3);
    #####:  269:  mask = (uint32_t) (1 << (entry_index & 0x7));
        -:  270:
    #####:  271:  if (!(*bits_p & mask))
        -:  272:  {
        -:  273:    /* Deleted entries also has ECMA_NULL_POINTER
        -:  274:     * value, but they are not NULL values. */
    #####:  275:    hashmap_p->null_count--;
    #####:  276:    JERRY_ASSERT (hashmap_p->null_count > 0);
        -:  277:  }
        -:  278:
    #####:  279:  hashmap_p->unused_count--;
    #####:  280:  JERRY_ASSERT (hashmap_p->unused_count > 0);
        -:  281:
    #####:  282:  if (property_index == 0)
        -:  283:  {
    #####:  284:    *bits_p = (uint8_t) ((*bits_p) & ~mask);
        -:  285:  }
        -:  286:  else
        -:  287:  {
    #####:  288:    *bits_p = (uint8_t) ((*bits_p) | mask);
        -:  289:  }
        -:  290:} /* ecma_property_hashmap_insert */
        -:  291:
        -:  292:/**
        -:  293: * Delete named property from the hashmap.
        -:  294: *
        -:  295: * @return ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP if hashmap should be recreated
        -:  296: *         ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP otherwise
        -:  297: */
        -:  298:ecma_property_hashmap_delete_status
    #####:  299:ecma_property_hashmap_delete (ecma_object_t *object_p, /**< object */
        -:  300:                              jmem_cpointer_t name_cp, /**< property name */
        -:  301:                              ecma_property_t *property_p) /**< property */
        -:  302:{
    #####:  303:  ecma_property_hashmap_t *hashmap_p = ECMA_GET_NON_NULL_POINTER (ecma_property_hashmap_t,
        -:  304:                                                                  object_p->u1.property_list_cp);
        -:  305:
    #####:  306:  JERRY_ASSERT (hashmap_p->header.types[0] == ECMA_PROPERTY_TYPE_HASHMAP);
        -:  307:
    #####:  308:  hashmap_p->unused_count++;
        -:  309:
        -:  310:  /* The NULLs are above 3/4 of the hashmap. */
    #####:  311:  if (hashmap_p->unused_count > ((hashmap_p->max_property_count * 3) >> 2))
        -:  312:  {
    #####:  313:    return ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP;
        -:  314:  }
        -:  315:
    #####:  316:  uint32_t entry_index = ecma_string_get_property_name_hash (*property_p, name_cp);
    #####:  317:  uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];
    #####:  318:  uint32_t mask = hashmap_p->max_property_count - 1;
    #####:  319:  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);
    #####:  320:  uint8_t *bits_p = (uint8_t *) (pair_list_p + hashmap_p->max_property_count);
        -:  321:
    #####:  322:  entry_index &= mask;
        -:  323:
        -:  324:#ifndef JERRY_NDEBUG
        -:  325:  /* See the comment for this variable in ecma_property_hashmap_create. */
    #####:  326:  uint32_t start_entry_index = entry_index;
        -:  327:#endif /* !JERRY_NDEBUG */
        -:  328:
        -:  329:  while (true)
        -:  330:  {
    #####:  331:    if (pair_list_p[entry_index] != ECMA_NULL_POINTER)
        -:  332:    {
    #####:  333:      size_t offset = 0;
        -:  334:
    #####:  335:      if (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))
        -:  336:      {
    #####:  337:        offset = 1;
        -:  338:      }
        -:  339:
    #####:  340:      ecma_property_pair_t *property_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_property_pair_t,
        -:  341:                                                                         pair_list_p[entry_index]);
        -:  342:
    #####:  343:      if ((property_pair_p->header.types + offset) == property_p)
        -:  344:      {
    #####:  345:        JERRY_ASSERT (property_pair_p->names_cp[offset] == name_cp);
        -:  346:
    #####:  347:        pair_list_p[entry_index] = ECMA_NULL_POINTER;
    #####:  348:        ECMA_PROPERTY_HASHMAP_SET_BIT (bits_p, entry_index);
    #####:  349:        return ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  350:      }
        -:  351:    }
        -:  352:    else
        -:  353:    {
        -:  354:      /* Must be a deleted entry. */
    #####:  355:      JERRY_ASSERT (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index));
        -:  356:    }
        -:  357:
    #####:  358:    entry_index = (entry_index + step) & mask;
        -:  359:
        -:  360:#ifndef JERRY_NDEBUG
    #####:  361:    JERRY_ASSERT (entry_index != start_entry_index);
        -:  362:#endif /* !JERRY_NDEBUG */
        -:  363:  }
        -:  364:} /* ecma_property_hashmap_delete */
        -:  365:
        -:  366:/**
        -:  367: * Find a named property.
        -:  368: *
        -:  369: * @return pointer to the property if found or NULL otherwise
        -:  370: */
        -:  371:ecma_property_t *
    #####:  372:ecma_property_hashmap_find (ecma_property_hashmap_t *hashmap_p, /**< hashmap */
        -:  373:                            ecma_string_t *name_p, /**< property name */
        -:  374:                            jmem_cpointer_t *property_real_name_cp) /**< [out] property real name */
        -:  375:{
        -:  376:#ifndef JERRY_NDEBUG
        -:  377:  /* A sanity check in debug mode: a named property must be present
        -:  378:   * in both the property hashmap and in the property chain, or missing
        -:  379:   * from both data collection. The following code checks the property
        -:  380:   * chain, and sets the property_found variable. */
    #####:  381:  bool property_found = false;
        -:  382:
    #####:  383:  jmem_cpointer_t prop_iter_cp = hashmap_p->header.next_property_cp;
        -:  384:
    #####:  385:  while (prop_iter_cp != JMEM_CP_NULL && !property_found)
        -:  386:  {
    #####:  387:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####:  388:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  389:
    #####:  390:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  391:
    #####:  392:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  393:    {
    #####:  394:      if (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[i]))
        -:  395:      {
    #####:  396:        if (ecma_string_compare_to_property_name (prop_iter_p->types[i],
    #####:  397:                                                  prop_pair_p->names_cp[i],
        -:  398:                                                  name_p))
        -:  399:        {
        -:  400:          /* Property is found */
    #####:  401:          property_found = true;
    #####:  402:          break;
        -:  403:        }
        -:  404:      }
        -:  405:    }
        -:  406:
    #####:  407:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  408:  }
        -:  409:#endif /* !JERRY_NDEBUG */
        -:  410:
    #####:  411:  uint32_t entry_index = ecma_string_hash (name_p);
    #####:  412:  uint32_t step = ecma_property_hashmap_steps[entry_index & (ECMA_PROPERTY_HASHMAP_NUMBER_OF_STEPS - 1)];
    #####:  413:  uint32_t mask = hashmap_p->max_property_count - 1;
    #####:  414:  jmem_cpointer_t *pair_list_p = (jmem_cpointer_t *) (hashmap_p + 1);
    #####:  415:  uint8_t *bits_p = (uint8_t *) (pair_list_p + hashmap_p->max_property_count);
    #####:  416:  entry_index &= mask;
        -:  417:
        -:  418:#ifndef JERRY_NDEBUG
        -:  419:  /* See the comment for this variable in ecma_property_hashmap_create. */
    #####:  420:  uint32_t start_entry_index = entry_index;
        -:  421:#endif /* !JERRY_NDEBUG */
        -:  422:
    #####:  423:  if (ECMA_IS_DIRECT_STRING (name_p))
        -:  424:  {
    #####:  425:    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);
    #####:  426:    jmem_cpointer_t property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);
        -:  427:
    #####:  428:    JERRY_ASSERT (prop_name_type > 0);
        -:  429:
        -:  430:    while (true)
        -:  431:    {
    #####:  432:      if (pair_list_p[entry_index] != ECMA_NULL_POINTER)
        -:  433:      {
    #####:  434:        size_t offset = 0;
    #####:  435:        if (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))
        -:  436:        {
    #####:  437:          offset = 1;
        -:  438:        }
        -:  439:
    #####:  440:        ecma_property_pair_t *property_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_property_pair_t,
        -:  441:                                                                           pair_list_p[entry_index]);
        -:  442:
    #####:  443:        ecma_property_t *property_p = property_pair_p->header.types + offset;
        -:  444:
    #####:  445:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));
        -:  446:
    #####:  447:        if (property_pair_p->names_cp[offset] == property_name_cp
    #####:  448:            && ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == prop_name_type)
        -:  449:        {
        -:  450:#ifndef JERRY_NDEBUG
    #####:  451:          JERRY_ASSERT (property_found);
        -:  452:#endif /* !JERRY_NDEBUG */
        -:  453:
    #####:  454:          *property_real_name_cp = property_name_cp;
    #####:  455:          return property_p;
        -:  456:        }
        -:  457:      }
        -:  458:      else
        -:  459:      {
    #####:  460:        if (!ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))
        -:  461:        {
        -:  462:#ifndef JERRY_NDEBUG
    #####:  463:          JERRY_ASSERT (!property_found);
        -:  464:#endif /* !JERRY_NDEBUG */
        -:  465:
    #####:  466:          return NULL;
        -:  467:        }
        -:  468:        /* Otherwise it is a deleted entry. */
        -:  469:      }
        -:  470:
    #####:  471:      entry_index = (entry_index + step) & mask;
        -:  472:
        -:  473:#ifndef JERRY_NDEBUG
    #####:  474:      JERRY_ASSERT (entry_index != start_entry_index);
        -:  475:#endif /* !JERRY_NDEBUG */
        -:  476:    }
        -:  477:  }
        -:  478:
        -:  479:  while (true)
        -:  480:  {
    #####:  481:    if (pair_list_p[entry_index] != ECMA_NULL_POINTER)
        -:  482:    {
    #####:  483:      size_t offset = 0;
    #####:  484:      if (ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))
        -:  485:      {
    #####:  486:        offset = 1;
        -:  487:      }
        -:  488:
    #####:  489:      ecma_property_pair_t *property_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_property_pair_t,
        -:  490:                                                                         pair_list_p[entry_index]);
        -:  491:
    #####:  492:      ecma_property_t *property_p = property_pair_p->header.types + offset;
        -:  493:
    #####:  494:      JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));
        -:  495:
    #####:  496:      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_PTR)
        -:  497:      {
    #####:  498:        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_pair_p->names_cp[offset]);
        -:  499:
    #####:  500:        if (ecma_compare_ecma_non_direct_strings (prop_name_p, name_p))
        -:  501:        {
        -:  502:#ifndef JERRY_NDEBUG
    #####:  503:          JERRY_ASSERT (property_found);
        -:  504:#endif /* !JERRY_NDEBUG */
        -:  505:
    #####:  506:          *property_real_name_cp = property_pair_p->names_cp[offset];
    #####:  507:          return property_p;
        -:  508:        }
        -:  509:      }
        -:  510:    }
        -:  511:    else
        -:  512:    {
    #####:  513:      if (!ECMA_PROPERTY_HASHMAP_GET_BIT (bits_p, entry_index))
        -:  514:      {
        -:  515:#ifndef JERRY_NDEBUG
    #####:  516:        JERRY_ASSERT (!property_found);
        -:  517:#endif /* !JERRY_NDEBUG */
        -:  518:
    #####:  519:        return NULL;
        -:  520:      }
        -:  521:      /* Otherwise it is a deleted entry. */
        -:  522:    }
        -:  523:
    #####:  524:    entry_index = (entry_index + step) & mask;
        -:  525:
        -:  526:#ifndef JERRY_NDEBUG
    #####:  527:    JERRY_ASSERT (entry_index != start_entry_index);
        -:  528:#endif /* !JERRY_NDEBUG */
        -:  529:  }
        -:  530:} /* ecma_property_hashmap_find */
        -:  531:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  532:
        -:  533:/**
        -:  534: * @}
        -:  535: * @}
        -:  536: */
