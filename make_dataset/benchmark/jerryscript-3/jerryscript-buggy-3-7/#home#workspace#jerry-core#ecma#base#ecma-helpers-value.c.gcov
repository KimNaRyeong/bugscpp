        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-value.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-exceptions.h"
        -:   18:#include "ecma-gc.h"
        -:   19:#include "ecma-globals.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "jrt.h"
        -:   22:#include "jrt-bit-fields.h"
        -:   23:#include "vm-defines.h"
        -:   24:
        -:   25:#include "ecma-function-object.h"
        -:   26:
        -:   27:JERRY_STATIC_ASSERT (ECMA_TYPE___MAX <= ECMA_VALUE_TYPE_MASK,
        -:   28:                     ecma_types_must_be_less_than_mask);
        -:   29:
        -:   30:JERRY_STATIC_ASSERT ((ECMA_VALUE_TYPE_MASK + 1) == (1 << ECMA_VALUE_SHIFT),
        -:   31:                     ecma_value_part_must_start_after_flags);
        -:   32:
        -:   33:JERRY_STATIC_ASSERT (ECMA_VALUE_SHIFT <= JMEM_ALIGNMENT_LOG,
        -:   34:                     ecma_value_shift_must_be_less_than_or_equal_than_mem_alignment_log);
        -:   35:
        -:   36:JERRY_STATIC_ASSERT (sizeof (jmem_cpointer_t) <= sizeof (ecma_value_t),
        -:   37:                     size_of_jmem_cpointer_t_must_be_less_or_equal_to_the_size_of_ecma_value_t);
        -:   38:
        -:   39:JERRY_STATIC_ASSERT (sizeof (jmem_cpointer_t) <= sizeof (jmem_cpointer_tag_t),
        -:   40:                     size_of_jmem_cpointer_t_must_be_less_or_equal_to_the_size_of_jmem_cpointer_tag_t);
        -:   41:
        -:   42:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
        -:   43:
        -:   44:/* cppcheck-suppress zerodiv */
        -:   45:JERRY_STATIC_ASSERT (sizeof (uintptr_t) <= sizeof (ecma_value_t),
        -:   46:                     uintptr_t_must_fit_in_ecma_value_t);
        -:   47:
        -:   48:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:   49:
        -:   50:JERRY_STATIC_ASSERT (sizeof (uintptr_t) > sizeof (ecma_value_t),
        -:   51:                     uintptr_t_must_not_fit_in_ecma_value_t);
        -:   52:
        -:   53:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:   54:
        -:   55:JERRY_STATIC_ASSERT ((ECMA_VALUE_FALSE | (1 << ECMA_DIRECT_SHIFT)) == ECMA_VALUE_TRUE
        -:   56:                     && ECMA_VALUE_FALSE != ECMA_VALUE_TRUE,
        -:   57:                     only_the_lowest_bit_must_be_different_for_simple_value_true_and_false);
        -:   58:
        -:   59:#if JERRY_BUILTIN_BIGINT
        -:   60:
        -:   61:JERRY_STATIC_ASSERT (ECMA_NULL_POINTER == (ECMA_BIGINT_ZERO & ~(ecma_value_t) ECMA_VALUE_TYPE_MASK),
        -:   62:                     ecma_bigint_zero_must_be_encoded_as_null_pointer);
        -:   63:
        -:   64:#endif /* JERRY_BUILTIN_BIGINT */
        -:   65:
        -:   66:/** \addtogroup ecma ECMA
        -:   67: * @{
        -:   68: *
        -:   69: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   70: * @{
        -:   71: */
        -:   72:
        -:   73:/**
        -:   74: * Get type field of ecma value
        -:   75: *
        -:   76: * @return type field
        -:   77: */
        -:   78:extern inline ecma_type_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:   79:ecma_get_value_type_field (ecma_value_t value) /**< ecma value */
        -:   80:{
      502:   81:  return value & ECMA_VALUE_TYPE_MASK;
        -:   82:} /* ecma_get_value_type_field */
        -:   83:
        -:   84:/**
        -:   85: * Convert a pointer into an ecma value.
        -:   86: *
        -:   87: * @return ecma value
        -:   88: */
        -:   89:static inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        -:   90:ecma_pointer_to_ecma_value (const void *ptr) /**< pointer */
        -:   91:{
        -:   92:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
        -:   93:
        -:   94:  JERRY_ASSERT (ptr != NULL);
        -:   95:  uintptr_t uint_ptr = (uintptr_t) ptr;
        -:   96:  JERRY_ASSERT ((uint_ptr & ECMA_VALUE_TYPE_MASK) == 0);
        -:   97:  return (ecma_value_t) uint_ptr;
        -:   98:
        -:   99:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:  100:
        -:  101:  jmem_cpointer_t ptr_cp;
       72:  102:  ECMA_SET_NON_NULL_POINTER (ptr_cp, ptr);
       72:  103:  return ((ecma_value_t) ptr_cp) << ECMA_VALUE_SHIFT;
        -:  104:
        -:  105:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:  106:} /* ecma_pointer_to_ecma_value */
        -:  107:
        -:  108:/**
        -:  109: * Get a pointer from an ecma value
        -:  110: *
        -:  111: * @return pointer
        -:  112: */
        -:  113:static inline void * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        -:  114:ecma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */
        -:  115:{
        -:  116:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
        -:  117:  void *ptr = (void *) (uintptr_t) ((value) & ~ECMA_VALUE_TYPE_MASK);
        -:  118:  JERRY_ASSERT (ptr != NULL);
        -:  119:  return ptr;
        -:  120:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
      113:  121:  return ECMA_GET_NON_NULL_POINTER (void, value >> ECMA_VALUE_SHIFT);
        -:  122:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:  123:} /* ecma_get_pointer_from_ecma_value */
        -:  124:
        -:  125:/**
        -:  126: * Check if the value is direct ecma-value.
        -:  127: *
        -:  128: * @return true - if the value is a direct value,
        -:  129: *         false - otherwise
        -:  130: */
        -:  131:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  132:ecma_is_value_direct (ecma_value_t value) /**< ecma value */
        -:  133:{
    #####:  134:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT);
        -:  135:} /* ecma_is_value_direct */
        -:  136:
        -:  137:/**
        -:  138: * Check if the value is simple ecma-value.
        -:  139: *
        -:  140: * @return true - if the value is a simple value,
        -:  141: *         false - otherwise
        -:  142: */
        -:  143:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        4:  144:ecma_is_value_simple (ecma_value_t value) /**< ecma value */
        -:  145:{
        4:  146:  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_SIMPLE_VALUE;
        -:  147:} /* ecma_is_value_simple */
        -:  148:
        -:  149:/**
        -:  150: * Check whether the value is a given simple value.
        -:  151: *
        -:  152: * @return true - if the value is equal to the given simple value,
        -:  153: *         false - otherwise
        -:  154: */
        -:  155:static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        -:  156:ecma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */
        -:  157:                                     ecma_value_t simple_value) /**< simple value */
        -:  158:{
       57:  159:  return value == simple_value;
        -:  160:} /* ecma_is_value_equal_to_simple_value */
        -:  161:
        -:  162:/**
        -:  163: * Check if the value is empty.
        -:  164: *
        -:  165: * @return true - if the value contains implementation-defined empty simple value,
        -:  166: *         false - otherwise
        -:  167: */
        -:  168:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  169:ecma_is_value_empty (ecma_value_t value) /**< ecma value */
        -:  170:{
    #####:  171:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_EMPTY);
        -:  172:} /* ecma_is_value_empty */
        -:  173:
        -:  174:/**
        -:  175: * Check if the value is undefined.
        -:  176: *
        -:  177: * @return true - if the value contains ecma-undefined simple value,
        -:  178: *         false - otherwise
        -:  179: */
        -:  180:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       13:  181:ecma_is_value_undefined (ecma_value_t value) /**< ecma value */
        -:  182:{
       19:  183:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_UNDEFINED);
        -:  184:} /* ecma_is_value_undefined */
        -:  185:
        -:  186:/**
        -:  187: * Check if the value is null.
        -:  188: *
        -:  189: * @return true - if the value contains ecma-null simple value,
        -:  190: *         false - otherwise
        -:  191: */
        -:  192:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        7:  193:ecma_is_value_null (ecma_value_t value) /**< ecma value */
        -:  194:{
       12:  195:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_NULL);
        -:  196:} /* ecma_is_value_null */
        -:  197:
        -:  198:/**
        -:  199: * Check if the value is boolean.
        -:  200: *
        -:  201: * @return true - if the value contains ecma-true or ecma-false simple values,
        -:  202: *         false - otherwise
        -:  203: */
        -:  204:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        8:  205:ecma_is_value_boolean (ecma_value_t value) /**< ecma value */
        -:  206:{
       26:  207:  return ecma_is_value_true (value | (1 << ECMA_DIRECT_SHIFT));
        -:  208:} /* ecma_is_value_boolean */
        -:  209:
        -:  210:/**
        -:  211: * Check if the value is true.
        -:  212: *
        -:  213: * @return true - if the value contains ecma-true simple value,
        -:  214: *         false - otherwise
        -:  215: */
        -:  216:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       10:  217:ecma_is_value_true (ecma_value_t value) /**< ecma value */
        -:  218:{
       23:  219:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_TRUE);
        -:  220:} /* ecma_is_value_true */
        -:  221:
        -:  222:/**
        -:  223: * Check if the value is false.
        -:  224: *
        -:  225: * @return true - if the value contains ecma-false simple value,
        -:  226: *         false - otherwise
        -:  227: */
        -:  228:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  229:ecma_is_value_false (ecma_value_t value) /**< ecma value */
        -:  230:{
        1:  231:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_FALSE);
        -:  232:} /* ecma_is_value_false */
        -:  233:
        -:  234:/**
        -:  235: * Check if the value is not found.
        -:  236: *
        -:  237: * @return true - if the value contains ecma-not-found simple value,
        -:  238: *         false - otherwise
        -:  239: */
        -:  240:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       18:  241:ecma_is_value_found (ecma_value_t value) /**< ecma value */
        -:  242:{
       18:  243:  return value != ECMA_VALUE_NOT_FOUND;
        -:  244:} /* ecma_is_value_found */
        -:  245:
        -:  246:/**
        -:  247: * Check if the value is array hole.
        -:  248: *
        -:  249: * @return true - if the value contains ecma-array-hole simple value,
        -:  250: *         false - otherwise
        -:  251: */
        -:  252:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        2:  253:ecma_is_value_array_hole (ecma_value_t value) /**< ecma value */
        -:  254:{
        2:  255:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_ARRAY_HOLE);
        -:  256:} /* ecma_is_value_array_hole */
        -:  257:
        -:  258:/**
        -:  259: * Check if the value is integer ecma-number.
        -:  260: *
        -:  261: * @return true - if the value contains an integer ecma-number value,
        -:  262: *         false - otherwise
        -:  263: */
        -:  264:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        8:  265:ecma_is_value_integer_number (ecma_value_t value) /**< ecma value */
        -:  266:{
       11:  267:  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  268:} /* ecma_is_value_integer_number */
        -:  269:
        -:  270:/**
        -:  271: * Check if both values are integer ecma-numbers.
        -:  272: *
        -:  273: * @return true - if both values contain integer ecma-number values,
        -:  274: *         false - otherwise
        -:  275: */
        -:  276:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  277:ecma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */
        -:  278:                                 ecma_value_t second_value) /**< second ecma value */
        -:  279:{
        -:  280:  JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_INTEGER_VALUE == 0,
        -:  281:                       ecma_direct_type_integer_value_must_be_zero);
        -:  282:
        1:  283:  return ((first_value | second_value) & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  284:} /* ecma_are_values_integer_numbers */
        -:  285:
        -:  286:/**
        -:  287: * Check if the value is floating-point ecma-number.
        -:  288: *
        -:  289: * @return true - if the value contains a floating-point ecma-number value,
        -:  290: *         false - otherwise
        -:  291: */
        -:  292:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  293:ecma_is_value_float_number (ecma_value_t value) /**< ecma value */
        -:  294:{
        6:  295:  return (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  296:} /* ecma_is_value_float_number */
        -:  297:
        -:  298:/**
        -:  299: * Check if the value is ecma-number.
        -:  300: *
        -:  301: * @return true - if the value contains ecma-number value,
        -:  302: *         false - otherwise
        -:  303: */
        -:  304:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  305:ecma_is_value_number (ecma_value_t value) /**< ecma value */
        -:  306:{
        2:  307:  return (ecma_is_value_integer_number (value)
        4:  308:          || ecma_is_value_float_number (value));
        -:  309:} /* ecma_is_value_number */
        -:  310:
        -:  311:JERRY_STATIC_ASSERT ((ECMA_TYPE_STRING | 0x4) == ECMA_TYPE_DIRECT_STRING,
        -:  312:                     ecma_type_string_and_direct_string_must_have_one_bit_difference);
        -:  313:
        -:  314:/**
        -:  315: * Check if the value is ecma-string.
        -:  316: *
        -:  317: * @return true - if the value contains ecma-string value,
        -:  318: *         false - otherwise
        -:  319: */
        -:  320:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        8:  321:ecma_is_value_string (ecma_value_t value) /**< ecma value */
        -:  322:{
       46:  323:  return ((value & (ECMA_VALUE_TYPE_MASK - 0x4)) == ECMA_TYPE_STRING);
        -:  324:} /* ecma_is_value_string */
        -:  325:
        -:  326:/**
        -:  327: * Check if the value is symbol.
        -:  328: *
        -:  329: * @return true - if the value contains symbol value,
        -:  330: *         false - otherwise
        -:  331: */
        -:  332:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        5:  333:ecma_is_value_symbol (ecma_value_t value) /**< ecma value */
        -:  334:{
        -:  335:#if JERRY_ESNEXT
        6:  336:  return (ecma_get_value_type_field (value) == ECMA_TYPE_SYMBOL);
        -:  337:#else /* JERRY_ESNEXT */
        -:  338:  JERRY_UNUSED (value);
    #####:  339:  return false;
        -:  340:#endif /* JERRY_ESNEXT */
        -:  341:} /* ecma_is_value_symbol */
        -:  342:
        -:  343:/**
        -:  344: * Check if the value is a specific magic string.
        -:  345: *
        -:  346: * @return true - if the value the magic string value,
        -:  347: *         false - otherwise
        -:  348: */
        -:  349:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        5:  350:ecma_is_value_magic_string (ecma_value_t value, /**< ecma value */
        -:  351:                            lit_magic_string_id_t id) /**< magic string id */
        -:  352:{
        5:  353:  return value == ecma_make_magic_string_value (id);
        -:  354:} /* ecma_is_value_magic_string */
        -:  355:
        -:  356:/**
        -:  357: * Check if the value is bigint.
        -:  358: *
        -:  359: * @return true - if the value contains bigint value,
        -:  360: *         false - otherwise
        -:  361: */
        -:  362:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  363:ecma_is_value_bigint (ecma_value_t value) /**< ecma value */
        -:  364:{
        -:  365:  #if JERRY_BUILTIN_BIGINT
    #####:  366:  return (ecma_get_value_type_field (value) == ECMA_TYPE_BIGINT);
        -:  367:  #else /* !JERRY_BUILTIN_BIGINT */
        -:  368:  JERRY_UNUSED (value);
    #####:  369:  return false;
        -:  370:  #endif /* JERRY_BUILTIN_BIGINT */
        -:  371:} /* ecma_is_value_bigint */
        -:  372:
        -:  373:/**
        -:  374: * Check if the value can be property name.
        -:  375: *
        -:  376: * @return true - if the value can be property name value,
        -:  377: *         false - otherwise
        -:  378: */
        -:  379:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        9:  380:ecma_is_value_prop_name (ecma_value_t value) /**< ecma value */
        -:  381:{
        -:  382:#if JERRY_ESNEXT
       18:  383:  return ecma_is_value_string (value) || ecma_is_value_symbol (value);
        -:  384:#else /* !JERRY_ESNEXT */
    #####:  385:  return ecma_is_value_string (value);
        -:  386:#endif /* JERRY_ESNEXT */
        -:  387:} /* ecma_is_value_prop_name */
        -:  388:
        -:  389:/**
        -:  390: * Check if the value is direct ecma-string.
        -:  391: *
        -:  392: * @return true - if the value contains direct ecma-string value,
        -:  393: *         false - otherwise
        -:  394: */
        -:  395:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  396:ecma_is_value_direct_string (ecma_value_t value) /**< ecma value */
        -:  397:{
    #####:  398:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -:  399:} /* ecma_is_value_direct_string */
        -:  400:
        -:  401:/**
        -:  402: * Check if the value is non-direct ecma-string.
        -:  403: *
        -:  404: * @return true - if the value contains non-direct ecma-string value,
        -:  405: *         false - otherwise
        -:  406: */
        -:  407:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  408:ecma_is_value_non_direct_string (ecma_value_t value) /**< ecma value */
        -:  409:{
    #####:  410:  return (ecma_get_value_type_field (value) == ECMA_TYPE_STRING);
        -:  411:} /* ecma_is_value_non_direct_string */
        -:  412:
        -:  413:/**
        -:  414: * Check if the value is object.
        -:  415: *
        -:  416: * @return true - if the value contains object value,
        -:  417: *         false - otherwise
        -:  418: */
        -:  419:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       34:  420:ecma_is_value_object (ecma_value_t value) /**< ecma value */
        -:  421:{
      137:  422:  return (ecma_get_value_type_field (value) == ECMA_TYPE_OBJECT);
        -:  423:} /* ecma_is_value_object */
        -:  424:
        -:  425:/**
        -:  426: * Check if the value is error reference.
        -:  427: *
        -:  428: * @return true - if the value contains an error reference,
        -:  429: *         false - otherwise
        -:  430: */
        -:  431:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       37:  432:ecma_is_value_error_reference (ecma_value_t value) /**< ecma value */
        -:  433:{
       37:  434:  return (ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);
        -:  435:} /* ecma_is_value_error_reference */
        -:  436:
        -:  437:/**
        -:  438: * Debug assertion that specified value's type is one of ECMA-defined
        -:  439: * script-visible types, i.e.: undefined, null, boolean, number, string, object.
        -:  440: */
        -:  441:void
        6:  442:ecma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */
        -:  443:{
       20:  444:  JERRY_ASSERT (ecma_is_value_undefined (value)
        -:  445:                || ecma_is_value_null (value)
        -:  446:                || ecma_is_value_boolean (value)
        -:  447:                || ecma_is_value_number (value)
        -:  448:                || ecma_is_value_string (value)
        -:  449:                || ecma_is_value_bigint (value)
        -:  450:                || ecma_is_value_symbol (value)
        -:  451:                || ecma_is_value_object (value));
        6:  452:} /* ecma_check_value_type_is_spec_defined */
        -:  453:
        -:  454:/**
        -:  455: * Checks if the given argument is an array or not.
        -:  456: *
        -:  457: * @return ECMA_VALUE_ERROR- if the operation fails
        -:  458: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether 'arg' is an array object
        -:  459: */
        -:  460:ecma_value_t
    #####:  461:ecma_is_value_array (ecma_value_t arg) /**< argument */
        -:  462:{
    #####:  463:  if (!ecma_is_value_object (arg))
        -:  464:  {
    #####:  465:    return ECMA_VALUE_FALSE;
        -:  466:  }
        -:  467:
    #####:  468:  ecma_object_t *arg_obj_p = ecma_get_object_from_value (arg);
        -:  469:
    #####:  470:  if (ecma_get_object_base_type (arg_obj_p) == ECMA_OBJECT_BASE_TYPE_ARRAY)
        -:  471:  {
    #####:  472:    return ECMA_VALUE_TRUE;
        -:  473:  }
        -:  474:
        -:  475:#if JERRY_BUILTIN_PROXY
    #####:  476:  if (ECMA_OBJECT_IS_PROXY (arg_obj_p))
        -:  477:  {
    #####:  478:    ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) arg_obj_p;
        -:  479:
    #####:  480:    if (proxy_obj_p->handler == ECMA_VALUE_NULL)
        -:  481:    {
    #####:  482:      return ecma_raise_type_error (ECMA_ERR_MSG ("Proxy handler is null for 'isArray' operation"));
        -:  483:    }
        -:  484:
    #####:  485:    return ecma_is_value_array (proxy_obj_p->target);
        -:  486:  }
        -:  487:#endif /* JERRY_BUILTIN_PROXY */
        -:  488:
    #####:  489:  return ECMA_VALUE_FALSE;
        -:  490:} /* ecma_is_value_array */
        -:  491:
        -:  492:/**
        -:  493: * Creates an ecma value from the given raw boolean.
        -:  494: *
        -:  495: * @return boolean ecma_value
        -:  496: */
        -:  497:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  498:ecma_make_boolean_value (bool boolean_value) /**< raw bool value from which the ecma value will be created */
        -:  499:{
    #####:  500:  return boolean_value ? ECMA_VALUE_TRUE : ECMA_VALUE_FALSE;
        -:  501:} /* ecma_make_boolean_value */
        -:  502:
        -:  503:/**
        -:  504: * Encode an integer number into an ecma-value without allocating memory
        -:  505: *
        -:  506: * Note:
        -:  507: *   The value must fit into the range of allowed ecma integer values
        -:  508: *
        -:  509: * @return ecma-value
        -:  510: */
        -:  511:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        3:  512:ecma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */
        -:  513:{
        5:  514:  JERRY_ASSERT (ECMA_IS_INTEGER_NUMBER (integer_value));
        -:  515:
        5:  516:  return (((ecma_value_t) integer_value) << ECMA_DIRECT_SHIFT) | ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  517:} /* ecma_make_integer_value */
        -:  518:
        -:  519:/**
        -:  520: * Allocate and initialize a new float number without checks.
        -:  521: *
        -:  522: * @return ecma-value
        -:  523: */
        -:  524:static ecma_value_t
        2:  525:ecma_create_float_number (ecma_number_t ecma_number) /**< value of the float number */
        -:  526:{
        2:  527:  ecma_number_t *ecma_num_p = ecma_alloc_number ();
        -:  528:
        2:  529:  *ecma_num_p = ecma_number;
        -:  530:
        2:  531:  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;
        -:  532:} /* ecma_create_float_number */
        -:  533:
        -:  534:/**
        -:  535: * Encode float number without checks.
        -:  536: *
        -:  537: * @return ecma-value
        -:  538: */
        -:  539:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  540:ecma_make_float_value (ecma_number_t *ecma_num_p) /**< pointer to the float number */
        -:  541:{
        1:  542:  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;
        -:  543:} /* ecma_make_float_value */
        -:  544:
        -:  545:/**
        -:  546: * Create a new NaN value.
        -:  547: *
        -:  548: * @return ecma-value
        -:  549: */
        -:  550:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  551:ecma_make_nan_value (void)
        -:  552:{
    #####:  553:  return ecma_create_float_number (ecma_number_make_nan ());
        -:  554:} /* ecma_make_nan_value */
        -:  555:
        -:  556:/**
        -:  557: * Checks whether the passed number is +0.0
        -:  558: *
        -:  559: * @return true, if it is +0.0, false otherwise
        -:  560: */
        -:  561:static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        -:  562:ecma_is_number_equal_to_positive_zero (ecma_number_t ecma_number) /**< number */
        -:  563:{
        -:  564:  ecma_number_accessor_t u;
    #####:  565:  u.as_ecma_number_t = ecma_number;
        -:  566:#if !JERRY_NUMBER_TYPE_FLOAT64
        -:  567:  return u.as_uint32_t == 0;
        -:  568:#else /* JERRY_NUMBER_TYPE_FLOAT64 */
    #####:  569:  return u.as_uint64_t == 0;
        -:  570:#endif /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  571:} /* ecma_is_number_equal_to_positive_zero */
        -:  572:
        -:  573:/**
        -:  574: * Encode a property length number into an ecma-value
        -:  575: *
        -:  576: * @return ecma-value
        -:  577: */
        -:  578:ecma_value_t
        2:  579:ecma_make_length_value (ecma_length_t number) /**< number to be encoded */
        -:  580:{
        2:  581:  if (number <= ECMA_INTEGER_NUMBER_MAX)
        -:  582:  {
    #####:  583:    return ecma_make_integer_value ((ecma_integer_value_t) number);
        -:  584:  }
        -:  585:
        2:  586:  return ecma_create_float_number ((ecma_number_t) number);
        -:  587:} /* ecma_make_length_value */
        -:  588:
        -:  589:/**
        -:  590: * Encode a number into an ecma-value
        -:  591: *
        -:  592: * @return ecma-value
        -:  593: */
        -:  594:ecma_value_t
        1:  595:ecma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */
        -:  596:{
        1:  597:  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;
        -:  598:
        1:  599:  if ((ecma_number_t) integer_value == ecma_number
        2:  600:      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)
        1:  601:                               : ECMA_IS_INTEGER_NUMBER (integer_value)))
        -:  602:  {
        1:  603:    return ecma_make_integer_value (integer_value);
        -:  604:  }
        -:  605:
    #####:  606:  return ecma_create_float_number (ecma_number);
        -:  607:} /* ecma_make_number_value */
        -:  608:
        -:  609:/**
        -:  610: * Encode an int32 number into an ecma-value
        -:  611: *
        -:  612: * @return ecma-value
        -:  613: */
        -:  614:ecma_value_t
    #####:  615:ecma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */
        -:  616:{
    #####:  617:  if (ECMA_IS_INTEGER_NUMBER (int32_number))
        -:  618:  {
    #####:  619:    return ecma_make_integer_value ((ecma_integer_value_t) int32_number);
        -:  620:  }
        -:  621:
    #####:  622:  return ecma_create_float_number ((ecma_number_t) int32_number);
        -:  623:} /* ecma_make_int32_value */
        -:  624:
        -:  625:/**
        -:  626: * Encode an unsigned int32 number into an ecma-value
        -:  627: *
        -:  628: * @return ecma-value
        -:  629: */
        -:  630:ecma_value_t
        1:  631:ecma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */
        -:  632:{
        1:  633:  if (uint32_number <= ECMA_INTEGER_NUMBER_MAX)
        -:  634:  {
        2:  635:    return ecma_make_integer_value ((ecma_integer_value_t) uint32_number);
        -:  636:  }
        -:  637:
    #####:  638:  return ecma_create_float_number ((ecma_number_t) uint32_number);
        -:  639:} /* ecma_make_uint32_value */
        -:  640:
        -:  641:/**
        -:  642: * String value constructor
        -:  643: *
        -:  644: * @return ecma-value representation of the string argument
        -:  645: */
        -:  646:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
       30:  647:ecma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */
        -:  648:{
       30:  649:  JERRY_ASSERT (ecma_string_p != NULL);
        -:  650:#if JERRY_ESNEXT
       30:  651:  JERRY_ASSERT (!ecma_prop_name_is_symbol ((ecma_string_t *) ecma_string_p));
        -:  652:#endif /* JERRY_ESNEXT */
        -:  653:
       30:  654:  if ((((uintptr_t) ecma_string_p) & ECMA_VALUE_TYPE_MASK) != 0)
        -:  655:  {
       13:  656:    return (ecma_value_t) (uintptr_t) ecma_string_p;
        -:  657:  }
        -:  658:
       17:  659:  return ecma_pointer_to_ecma_value (ecma_string_p) | ECMA_TYPE_STRING;
        -:  660:} /* ecma_make_string_value */
        -:  661:
        -:  662:#if JERRY_ESNEXT
        -:  663:/**
        -:  664: * Symbol value constructor
        -:  665: *
        -:  666: * @return ecma-value representation of the string argument
        -:  667: */
        -:  668:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        1:  669:ecma_make_symbol_value (const ecma_string_t *ecma_symbol_p) /**< symbol to reference in value */
        -:  670:{
        1:  671:  JERRY_ASSERT (ecma_symbol_p != NULL);
        1:  672:  JERRY_ASSERT (ecma_prop_name_is_symbol ((ecma_string_t *) ecma_symbol_p));
        -:  673:
        1:  674:  return ecma_pointer_to_ecma_value (ecma_symbol_p) | ECMA_TYPE_SYMBOL;
        -:  675:} /* ecma_make_symbol_value */
        -:  676:#endif /* JERRY_ESNEXT */
        -:  677:
        -:  678:/**
        -:  679: * Property-name value constructor
        -:  680: *
        -:  681: * @return ecma-value representation of a property name argument
        -:  682: */
        -:  683:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  684:ecma_make_prop_name_value (const ecma_string_t *ecma_prop_name_p) /**< property name to reference in value */
        -:  685:{
    #####:  686:  JERRY_ASSERT (ecma_prop_name_p != NULL);
        -:  687:
        -:  688:#if JERRY_ESNEXT
    #####:  689:  if (ecma_prop_name_is_symbol ((ecma_string_t *) ecma_prop_name_p))
        -:  690:  {
    #####:  691:    return ecma_make_symbol_value (ecma_prop_name_p);
        -:  692:  }
        -:  693:#endif /* JERRY_ESNEXT */
        -:  694:
    #####:  695:  return ecma_make_string_value (ecma_prop_name_p);
        -:  696:} /* ecma_make_prop_name_value */
        -:  697:
        -:  698:/**
        -:  699: * String value constructor
        -:  700: *
        -:  701: * @return ecma-value representation of the string argument
        -:  702: */
        -:  703:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        7:  704:ecma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */
        -:  705:{
       12:  706:  return (ecma_value_t) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);
        -:  707:} /* ecma_make_magic_string_value */
        -:  708:
        -:  709:/**
        -:  710: * Object value constructor
        -:  711: *
        -:  712: * @return ecma-value representation of the object argument
        -:  713: */
        -:  714:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
       51:  715:ecma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */
        -:  716:{
       51:  717:  JERRY_ASSERT (object_p != NULL);
        -:  718:
       51:  719:  return ecma_pointer_to_ecma_value (object_p) | ECMA_TYPE_OBJECT;
        -:  720:} /* ecma_make_object_value */
        -:  721:
        -:  722:/**
        -:  723: * Error reference constructor
        -:  724: *
        -:  725: * @return ecma-value representation of the Error reference
        -:  726: */
        -:  727:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  728:ecma_make_extended_primitive_value (const ecma_extended_primitive_t *primitve_p, /**< extended primitve value */
        -:  729:                                    uint32_t type) /**< ecma type of extended primitve value */
        -:  730:{
    #####:  731:  JERRY_ASSERT (primitve_p != NULL);
        -:  732:#if JERRY_BUILTIN_BIGINT
    #####:  733:  JERRY_ASSERT (primitve_p != ECMA_BIGINT_POINTER_TO_ZERO);
        -:  734:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  735:  JERRY_ASSERT (type == ECMA_TYPE_BIGINT || type == ECMA_TYPE_ERROR);
        -:  736:
    #####:  737:  return ecma_pointer_to_ecma_value (primitve_p) | type;
        -:  738:} /* ecma_make_extended_primitive_value */
        -:  739:
        -:  740:/**
        -:  741: * Get integer value from an integer ecma value
        -:  742: *
        -:  743: * @return integer value
        -:  744: */
        -:  745:extern inline ecma_integer_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  746:ecma_get_integer_from_value (ecma_value_t value) /**< ecma value */
        -:  747:{
        1:  748:  JERRY_ASSERT (ecma_is_value_integer_number (value));
        -:  749:
        1:  750:  return ((ecma_integer_value_t) value) >> ECMA_DIRECT_SHIFT;
        -:  751:} /* ecma_get_integer_from_value */
        -:  752:
        -:  753:/**
        -:  754: * Get floating point value from an ecma value
        -:  755: *
        -:  756: * @return floating point value
        -:  757: */
        -:  758:extern inline ecma_number_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  759:ecma_get_float_from_value (ecma_value_t value) /**< ecma value */
        -:  760:{
    #####:  761:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  762:
    #####:  763:  return *(ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        -:  764:} /* ecma_get_float_from_value */
        -:  765:
        -:  766:/**
        -:  767: * Get floating point value pointer from an ecma value
        -:  768: *
        -:  769: * @return floating point value
        -:  770: */
        -:  771:extern inline ecma_number_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  772:ecma_get_pointer_from_float_value (ecma_value_t value) /**< ecma value */
        -:  773:{
    #####:  774:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  775:
    #####:  776:  return (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        -:  777:} /* ecma_get_pointer_from_float_value */
        -:  778:
        -:  779:/**
        -:  780: * Get floating point value from an ecma value
        -:  781: *
        -:  782: * @return floating point value
        -:  783: */
        -:  784:ecma_number_t JERRY_ATTR_PURE
    #####:  785:ecma_get_number_from_value (ecma_value_t value) /**< ecma value */
        -:  786:{
    #####:  787:  if (ecma_is_value_integer_number (value))
        -:  788:  {
    #####:  789:    return (ecma_number_t) ecma_get_integer_from_value (value);
        -:  790:  }
        -:  791:
    #####:  792:  return ecma_get_float_from_value (value);
        -:  793:} /* ecma_get_number_from_value */
        -:  794:
        -:  795:/**
        -:  796: * Get pointer to ecma-string from ecma value
        -:  797: *
        -:  798: * @return the string pointer
        -:  799: */
        -:  800:extern inline ecma_string_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
       18:  801:ecma_get_string_from_value (ecma_value_t value) /**< ecma value */
        -:  802:{
       18:  803:  JERRY_ASSERT (ecma_is_value_string (value));
        -:  804:
       18:  805:  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)
        -:  806:  {
        8:  807:    return (ecma_string_t *) (uintptr_t) value;
        -:  808:  }
        -:  809:
       10:  810:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  811:} /* ecma_get_string_from_value */
        -:  812:
        -:  813:#if JERRY_ESNEXT
        -:  814:/**
        -:  815: * Get pointer to ecma-string from ecma value
        -:  816: *
        -:  817: * @return the string pointer
        -:  818: */
        -:  819:extern inline ecma_string_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        1:  820:ecma_get_symbol_from_value (ecma_value_t value) /**< ecma value */
        -:  821:{
        1:  822:  JERRY_ASSERT (ecma_is_value_symbol (value));
        -:  823:
        1:  824:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  825:} /* ecma_get_symbol_from_value */
        -:  826:#endif /* JERRY_ESNEXT */
        -:  827:
        -:  828:/**
        -:  829: * Get pointer to a property name from ecma value
        -:  830: *
        -:  831: * @return the string pointer
        -:  832: */
        -:  833:extern inline ecma_string_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        9:  834:ecma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */
        -:  835:{
        9:  836:  JERRY_ASSERT (ecma_is_value_prop_name (value));
        -:  837:
        9:  838:  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)
        -:  839:  {
        4:  840:    return (ecma_string_t *) (uintptr_t) value;
        -:  841:  }
        -:  842:
        5:  843:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  844:} /* ecma_get_prop_name_from_value */
        -:  845:
        -:  846:/**
        -:  847: * Get pointer to ecma-object from ecma value
        -:  848: *
        -:  849: * @return the pointer
        -:  850: */
        -:  851:extern inline ecma_object_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
       43:  852:ecma_get_object_from_value (ecma_value_t value) /**< ecma value */
        -:  853:{
       82:  854:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  855:
       82:  856:  return (ecma_object_t *) ecma_get_pointer_from_ecma_value (value);
        -:  857:} /* ecma_get_object_from_value */
        -:  858:
        -:  859:/**
        -:  860: * Get pointer to error reference from ecma value
        -:  861: *
        -:  862: * @return the pointer
        -:  863: */
        -:  864:extern inline ecma_extended_primitive_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  865:ecma_get_extended_primitive_from_value (ecma_value_t value) /**< ecma value */
        -:  866:{
        -:  867:#if JERRY_BUILTIN_BIGINT
    #####:  868:  JERRY_ASSERT (value != ECMA_BIGINT_ZERO);
        -:  869:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  870:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_BIGINT
        -:  871:                || ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);
        -:  872:
    #####:  873:  return (ecma_extended_primitive_t *) ecma_get_pointer_from_ecma_value (value);
        -:  874:} /* ecma_get_extended_primitive_from_value */
        -:  875:
        -:  876:/**
        -:  877: * Invert a boolean value
        -:  878: *
        -:  879: * @return ecma value
        -:  880: */
        -:  881:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  882:ecma_invert_boolean_value (ecma_value_t value) /**< ecma value */
        -:  883:{
    #####:  884:  JERRY_ASSERT (ecma_is_value_boolean (value));
        -:  885:
    #####:  886:  return (value ^ (1 << ECMA_DIRECT_SHIFT));
        -:  887:} /* ecma_invert_boolean_value */
        -:  888:
        -:  889:/**
        -:  890: * Copy ecma value.
        -:  891: *
        -:  892: * @return copy of the given value
        -:  893: */
        -:  894:ecma_value_t
       26:  895:ecma_copy_value (ecma_value_t value)  /**< value description */
        -:  896:{
       26:  897:  switch (ecma_get_value_type_field (value))
        -:  898:  {
        1:  899:    case ECMA_TYPE_FLOAT:
        -:  900:    {
        1:  901:      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        1:  902:      ecma_number_t *new_num_p = ecma_alloc_number ();
        -:  903:
        1:  904:      *new_num_p = *num_p;
        -:  905:
        1:  906:      return ecma_make_float_value (new_num_p);
        -:  907:    }
        -:  908:#if JERRY_ESNEXT
        2:  909:    case ECMA_TYPE_SYMBOL:
        -:  910:#endif /* JERRY_ESNEXT */
    #####:  911:    case ECMA_TYPE_STRING:
        -:  912:    {
        2:  913:      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        2:  914:      ecma_ref_ecma_string_non_direct (string_p);
        2:  915:      return value;
        -:  916:    }
        -:  917:#if JERRY_BUILTIN_BIGINT
    #####:  918:    case ECMA_TYPE_BIGINT:
        -:  919:    {
    #####:  920:      if (value != ECMA_BIGINT_ZERO)
        -:  921:      {
    #####:  922:        ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
        -:  923:      }
    #####:  924:      return value;
        -:  925:    }
        -:  926:#endif /* JERRY_BUILTIN_BIGINT */
        9:  927:    case ECMA_TYPE_OBJECT:
        -:  928:    {
        9:  929:      ecma_ref_object_inline (ecma_get_object_from_value (value));
        9:  930:      return value;
        -:  931:    }
       14:  932:    default:
        -:  933:    {
       24:  934:      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT
        -:  935:                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -:  936:
       14:  937:      return value;
        -:  938:    }
        -:  939:  }
        -:  940:} /* ecma_copy_value */
        -:  941:
        -:  942:/**
        -:  943: * Copy ecma value.
        -:  944: *
        -:  945: * Note:
        -:  946: *   this function is similar to ecma_copy_value, but it is
        -:  947: *   faster for direct values since no function call is performed.
        -:  948: *   It also increases the binary size so it is recommended for
        -:  949: *   critical code paths only.
        -:  950: *
        -:  951: * @return copy of the given value
        -:  952: */
        -:  953:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
       29:  954:ecma_fast_copy_value (ecma_value_t value)  /**< value description */
        -:  955:{
       29:  956:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT) ? value : ecma_copy_value (value);
        -:  957:} /* ecma_fast_copy_value */
        -:  958:
        -:  959:/**
        -:  960: * Copy the ecma value if not an object
        -:  961: *
        -:  962: * @return copy of the given value
        -:  963: */
        -:  964:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        9:  965:ecma_copy_value_if_not_object (ecma_value_t value) /**< value description */
        -:  966:{
       13:  967:  if (!ecma_is_value_object (value))
        -:  968:  {
        5:  969:    return ecma_copy_value (value);
        -:  970:  }
        -:  971:
        8:  972:  return value;
        -:  973:} /* ecma_copy_value_if_not_object */
        -:  974:
        -:  975:/**
        -:  976: * Increase reference counter of a value if it is an object.
        -:  977: */
        -:  978:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  979:ecma_ref_if_object (ecma_value_t value) /**< value description */
        -:  980:{
    #####:  981:  if (ecma_is_value_object (value))
        -:  982:  {
    #####:  983:    ecma_ref_object (ecma_get_object_from_value (value));
        -:  984:  }
    #####:  985:} /* ecma_ref_if_object */
        -:  986:
        -:  987:/**
        -:  988: * Decrease reference counter of a value if it is an object.
        -:  989: */
        -:  990:extern inline void JERRY_ATTR_ALWAYS_INLINE
        8:  991:ecma_deref_if_object (ecma_value_t value) /**< value description */
        -:  992:{
        8:  993:  if (ecma_is_value_object (value))
        -:  994:  {
        5:  995:    ecma_deref_object (ecma_get_object_from_value (value));
        -:  996:  }
        8:  997:} /* ecma_deref_if_object */
        -:  998:
        -:  999:/**
        -: 1000: * Assign a new value to an ecma-value
        -: 1001: *
        -: 1002: * Note:
        -: 1003: *      value previously stored in the property is freed
        -: 1004: */
        -: 1005:void
        4: 1006:ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */
        -: 1007:                         ecma_value_t ecma_value) /**< value to assign */
        -: 1008:{
        -: 1009:  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0,
        -: 1010:                       ecma_type_direct_must_be_zero_for_the_next_check);
        -: 1011:
        4: 1012:  if (*value_p == ecma_value)
        -: 1013:  {
    #####: 1014:    return;
        -: 1015:  }
        -: 1016:
        8: 1017:  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)
        -: 1018:  {
    #####: 1019:    *value_p = ecma_value;
        -: 1020:  }
        4: 1021:  else if (ecma_is_value_float_number (ecma_value)
    #####: 1022:           && ecma_is_value_float_number (*value_p))
    #####: 1023:  {
    #####: 1024:    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);
    #####: 1025:    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);
        -: 1026:
    #####: 1027:    *num_dst_p = *num_src_p;
        -: 1028:  }
        -: 1029:  else
        -: 1030:  {
        4: 1031:    ecma_free_value_if_not_object (*value_p);
        4: 1032:    *value_p = ecma_copy_value_if_not_object (ecma_value);
        -: 1033:  }
        -: 1034:} /* ecma_value_assign_value */
        -: 1035:
        -: 1036:/**
        -: 1037: * Update the value of a float number to a new value
        -: 1038: *
        -: 1039: * Note:
        -: 1040: *   The original value is destroyed.
        -: 1041: *
        -: 1042: * @return updated ecma value
        -: 1043: */
        -: 1044:ecma_value_t
    #####: 1045:ecma_update_float_number (ecma_value_t float_value, /**< original float value */
        -: 1046:                          ecma_number_t new_number) /**< updated number value */
        -: 1047:{
    #####: 1048:  JERRY_ASSERT (ecma_is_value_float_number (float_value));
        -: 1049:
    #####: 1050:  ecma_integer_value_t integer_number = (ecma_integer_value_t) new_number;
    #####: 1051:  ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (float_value);
        -: 1052:
    #####: 1053:  if ((ecma_number_t) integer_number == new_number
    #####: 1054:      && ((integer_number == 0) ? ecma_is_number_equal_to_positive_zero (new_number)
    #####: 1055:                                : ECMA_IS_INTEGER_NUMBER (integer_number)))
        -: 1056:  {
    #####: 1057:    ecma_dealloc_number (number_p);
    #####: 1058:    return ecma_make_integer_value (integer_number);
        -: 1059:  }
        -: 1060:
    #####: 1061:  *number_p = new_number;
    #####: 1062:  return float_value;
        -: 1063:} /* ecma_update_float_number */
        -: 1064:
        -: 1065:/**
        -: 1066: * Assign a float number to an ecma-value
        -: 1067: *
        -: 1068: * Note:
        -: 1069: *      value previously stored in the property is freed
        -: 1070: */
        -: 1071:static void
    #####: 1072:ecma_value_assign_float_number (ecma_value_t *value_p, /**< [in, out] ecma value */
        -: 1073:                                ecma_number_t ecma_number) /**< number to assign */
        -: 1074:{
    #####: 1075:  if (ecma_is_value_float_number (*value_p))
        -: 1076:  {
    #####: 1077:    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);
        -: 1078:
    #####: 1079:    *num_dst_p = ecma_number;
    #####: 1080:    return;
        -: 1081:  }
        -: 1082:
    #####: 1083:  if (ecma_get_value_type_field (*value_p) != ECMA_TYPE_DIRECT
    #####: 1084:      && ecma_get_value_type_field (*value_p) != ECMA_TYPE_OBJECT)
        -: 1085:  {
    #####: 1086:    ecma_free_value (*value_p);
        -: 1087:  }
        -: 1088:
    #####: 1089:  *value_p = ecma_create_float_number (ecma_number);
        -: 1090:} /* ecma_value_assign_float_number */
        -: 1091:
        -: 1092:/**
        -: 1093: * Assign a number to an ecma-value
        -: 1094: *
        -: 1095: * Note:
        -: 1096: *      value previously stored in the property is freed
        -: 1097: */
        -: 1098:void
    #####: 1099:ecma_value_assign_number (ecma_value_t *value_p, /**< [in, out] ecma value */
        -: 1100:                          ecma_number_t ecma_number) /**< number to assign */
        -: 1101:{
    #####: 1102:  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;
        -: 1103:
    #####: 1104:  if ((ecma_number_t) integer_value == ecma_number
    #####: 1105:      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)
    #####: 1106:                               : ECMA_IS_INTEGER_NUMBER (integer_value)))
        -: 1107:  {
    #####: 1108:    if (ecma_get_value_type_field (*value_p) != ECMA_TYPE_DIRECT
    #####: 1109:        && ecma_get_value_type_field (*value_p) != ECMA_TYPE_OBJECT)
        -: 1110:    {
    #####: 1111:      ecma_free_value (*value_p);
        -: 1112:    }
    #####: 1113:    *value_p = ecma_make_integer_value (integer_value);
    #####: 1114:    return;
        -: 1115:  }
        -: 1116:
    #####: 1117:  ecma_value_assign_float_number (value_p, ecma_number);
        -: 1118:} /* ecma_value_assign_number */
        -: 1119:
        -: 1120:/**
        -: 1121: * Free the ecma value
        -: 1122: */
        -: 1123:void
       78: 1124:ecma_free_value (ecma_value_t value) /**< value description */
        -: 1125:{
       78: 1126:  switch (ecma_get_value_type_field (value))
        -: 1127:  {
        2: 1128:    case ECMA_TYPE_FLOAT:
        -: 1129:    {
        2: 1130:      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        2: 1131:      ecma_dealloc_number (number_p);
        2: 1132:      break;
        -: 1133:    }
        -: 1134:#if JERRY_ESNEXT
       10: 1135:    case ECMA_TYPE_SYMBOL:
        -: 1136:#endif /* JERRY_ESNEXT */
    #####: 1137:    case ECMA_TYPE_STRING:
        -: 1138:    {
       10: 1139:      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
       10: 1140:      ecma_deref_ecma_string_non_direct (string_p);
       10: 1141:      break;
        -: 1142:    }
       24: 1143:    case ECMA_TYPE_OBJECT:
        -: 1144:    {
       24: 1145:      ecma_deref_object (ecma_get_object_from_value (value));
       24: 1146:      break;
        -: 1147:    }
        -: 1148:#if JERRY_BUILTIN_BIGINT
    #####: 1149:    case ECMA_TYPE_BIGINT:
        -: 1150:    {
    #####: 1151:      if (value != ECMA_BIGINT_ZERO)
        -: 1152:      {
    #####: 1153:        ecma_deref_bigint (ecma_get_extended_primitive_from_value (value));
        -: 1154:      }
        -: 1155:
    #####: 1156:      break;
        -: 1157:    }
        -: 1158:#endif /* JERRY_BUILTIN_BIGINT */
       42: 1159:    default:
        -: 1160:    {
       52: 1161:      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT
        -: 1162:                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -: 1163:
        -: 1164:      /* no memory is allocated */
       42: 1165:      break;
        -: 1166:    }
        -: 1167:  }
       78: 1168:} /* ecma_free_value */
        -: 1169:
        -: 1170:/**
        -: 1171: * Free the ecma value
        -: 1172: *
        -: 1173: * Note:
        -: 1174: *   this function is similar to ecma_free_value, but it is
        -: 1175: *   faster for direct values since no function call is performed.
        -: 1176: *   It also increases the binary size so it is recommended for
        -: 1177: *   critical code paths only.
        -: 1178: */
        -: 1179:extern inline void JERRY_ATTR_ALWAYS_INLINE
       66: 1180:ecma_fast_free_value (ecma_value_t value) /**< value description */
        -: 1181:{
       66: 1182:  if (ecma_get_value_type_field (value) != ECMA_TYPE_DIRECT)
        -: 1183:  {
       19: 1184:    ecma_free_value (value);
        -: 1185:  }
       66: 1186:} /* ecma_fast_free_value */
        -: 1187:
        -: 1188:/**
        -: 1189: * Free the ecma value if not an object
        -: 1190: */
        -: 1191:void
       37: 1192:ecma_free_value_if_not_object (ecma_value_t value) /**< value description */
        -: 1193:{
       37: 1194:  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)
        -: 1195:  {
       24: 1196:    ecma_free_value (value);
        -: 1197:  }
       37: 1198:} /* ecma_free_value_if_not_object */
        -: 1199:
        -: 1200:/**
        -: 1201: * Free an ecma-value object
        -: 1202: */
        -: 1203:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1: 1204:ecma_free_object (ecma_value_t value) /**< value description */
        -: 1205:{
        1: 1206:  ecma_deref_object (ecma_get_object_from_value (value));
        1: 1207:} /* ecma_free_object */
        -: 1208:
        -: 1209:/**
        -: 1210: * Free an ecma-value number
        -: 1211: */
        -: 1212:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1213:ecma_free_number (ecma_value_t value) /**< value description */
        -: 1214:{
    #####: 1215:  JERRY_ASSERT (ecma_is_value_number (value));
        -: 1216:
    #####: 1217:  if (ecma_is_value_float_number (value))
        -: 1218:  {
    #####: 1219:    ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
    #####: 1220:    ecma_dealloc_number (number_p);
        -: 1221:  }
    #####: 1222:} /* ecma_free_number */
        -: 1223:
        -: 1224:/**
        -: 1225: * Get the literal id associated with the given ecma_value type.
        -: 1226: * This operation is equivalent to the JavaScript 'typeof' operator.
        -: 1227: *
        -: 1228: * @returns one of the following value:
        -: 1229: *          - LIT_MAGIC_STRING_UNDEFINED
        -: 1230: *          - LIT_MAGIC_STRING_OBJECT
        -: 1231: *          - LIT_MAGIC_STRING_BOOLEAN
        -: 1232: *          - LIT_MAGIC_STRING_NUMBER
        -: 1233: *          - LIT_MAGIC_STRING_STRING
        -: 1234: *          - LIT_MAGIC_STRING_FUNCTION
        -: 1235: */
        -: 1236:lit_magic_string_id_t
    #####: 1237:ecma_get_typeof_lit_id (ecma_value_t value) /**< input ecma value */
        -: 1238:{
    #####: 1239:  lit_magic_string_id_t ret_value = LIT_MAGIC_STRING__EMPTY;
        -: 1240:
    #####: 1241:  if (ecma_is_value_undefined (value))
        -: 1242:  {
    #####: 1243:    ret_value = LIT_MAGIC_STRING_UNDEFINED;
        -: 1244:  }
    #####: 1245:  else if (ecma_is_value_null (value))
        -: 1246:  {
    #####: 1247:    ret_value = LIT_MAGIC_STRING_OBJECT;
        -: 1248:  }
    #####: 1249:  else if (ecma_is_value_boolean (value))
        -: 1250:  {
    #####: 1251:    ret_value = LIT_MAGIC_STRING_BOOLEAN;
        -: 1252:  }
    #####: 1253:  else if (ecma_is_value_number (value))
        -: 1254:  {
    #####: 1255:    ret_value = LIT_MAGIC_STRING_NUMBER;
        -: 1256:  }
    #####: 1257:  else if (ecma_is_value_string (value))
        -: 1258:  {
    #####: 1259:    ret_value = LIT_MAGIC_STRING_STRING;
        -: 1260:  }
        -: 1261:#if JERRY_ESNEXT
    #####: 1262:  else if (ecma_is_value_symbol (value))
        -: 1263:  {
    #####: 1264:    ret_value = LIT_MAGIC_STRING_SYMBOL;
        -: 1265:  }
        -: 1266:#endif /* JERRY_ESNEXT */
        -: 1267:#if JERRY_BUILTIN_BIGINT
    #####: 1268:  else if (ecma_is_value_bigint (value))
        -: 1269:  {
    #####: 1270:    ret_value = LIT_MAGIC_STRING_BIGINT;
        -: 1271:  }
        -: 1272:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1273:  else
        -: 1274:  {
    #####: 1275:    JERRY_ASSERT (ecma_is_value_object (value));
        -: 1276:
    #####: 1277:    ret_value = ecma_op_is_callable (value) ? LIT_MAGIC_STRING_FUNCTION : LIT_MAGIC_STRING_OBJECT;
        -: 1278:  }
        -: 1279:
    #####: 1280:  JERRY_ASSERT (ret_value != LIT_MAGIC_STRING__EMPTY);
        -: 1281:
    #####: 1282:  return ret_value;
        -: 1283:} /* ecma_get_typeof_lit_id */
        -: 1284:
        -: 1285:/**
        -: 1286: * @}
        -: 1287: * @}
        -: 1288: */
