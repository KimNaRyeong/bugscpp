        -:    0:Source:/home/workspace/jerry-main/main-jerry.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <assert.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:#include "jerryscript.h"
        -:   22:#include "jerryscript-ext/debugger.h"
        -:   23:#include "jerryscript-ext/handler.h"
        -:   24:#include "jerryscript-port.h"
        -:   25:#include "jerryscript-port-default.h"
        -:   26:
        -:   27:#include "main-utils.h"
        -:   28:#include "main-options.h"
        -:   29:
        -:   30:/**
        -:   31: * Temporal buffer size.
        -:   32: */
        -:   33:#define JERRY_BUFFER_SIZE 256u
        -:   34:
        -:   35:#if defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:   36:/**
        -:   37: * The alloc function passed to jerry_create_context
        -:   38: */
        -:   39:static void *
        -:   40:context_alloc (size_t size,
        -:   41:               void *cb_data_p)
        -:   42:{
        -:   43:  (void) cb_data_p; /* unused */
        -:   44:  return malloc (size);
        -:   45:} /* context_alloc */
        -:   46:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:   47:
        -:   48:#ifdef DPP_ENABLE_GCOV
        -:   49:#include <signal.h>
        -:   50:#include <gcov.h>
        -:   51:void dpp_sighandler(int signum);
        -:   52:static struct sigaction dpp_gcov_sigaction;
        -:   53:static struct sigaction dpp_orig_sigaction;
        1:   54:void dpp_sighandler(int signum) {
        1:   55:  __gcov_flush();
    #####:   56:  sigaction(signum, &dpp_orig_sigaction, NULL);
    #####:   57:  raise(signum);
    #####:   58:}
        -:   59:void __asan_on_error(void);
    #####:   60:void __asan_on_error(void){
    #####:   61:  __gcov_flush();
    #####:   62:}
        -:   63:#endif
        -:   64:
        -:   65:int
        1:   66:main (int argc,
        -:   67:      char **argv)
        1:   68:{
        -:   69:#ifdef DPP_ENABLE_GCOV
        -:   70:  {
        1:   71:   dpp_gcov_sigaction.sa_handler = dpp_sighandler;
        1:   72:   sigemptyset(&dpp_gcov_sigaction.sa_mask);
        1:   73:   dpp_gcov_sigaction.sa_flags = 0;
        1:   74:   sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        -:   75:  }
        -:   76:#endif
        -:   77:  union
        -:   78:  {
        -:   79:    double d;
        -:   80:    unsigned u;
        1:   81:  } now = { .d = jerry_port_get_current_time () };
        1:   82:  srand (now.u);
        -:   83:
        1:   84:  JERRY_VLA (main_source_t, sources_p, argc);
        -:   85:
        1:   86:  main_args_t arguments;
        1:   87:  arguments.sources_p = sources_p;
        -:   88:
        1:   89:  main_parse_args (argc, argv, &arguments);
        -:   90:
        -:   91:#if defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:   92:  jerry_context_t *context_p = jerry_create_context (JERRY_GLOBAL_HEAP_SIZE * 1024, context_alloc, NULL);
        -:   93:  jerry_port_default_set_current_context (context_p);
        -:   94:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:   95:
        1:   96:restart:
        1:   97:  main_init_engine (&arguments);
        1:   98:  int return_code = JERRY_STANDALONE_EXIT_CODE_FAIL;
        1:   99:  jerry_value_t ret_value;
        -:  100:
        2:  101:  for (uint32_t source_index = 0; source_index < arguments.source_count; source_index++)
        -:  102:  {
        1:  103:    main_source_t *source_file_p = sources_p + source_index;
        1:  104:    const char *file_path_p = argv[source_file_p->path_index];
        -:  105:
        1:  106:    if (source_file_p->type == SOURCE_MODULE)
        -:  107:    {
    #####:  108:      jerry_value_t specifier = jerry_create_string_from_utf8 ((const jerry_char_t *) file_path_p);
    #####:  109:      jerry_value_t referrer = jerry_create_undefined ();
    #####:  110:      ret_value = jerry_port_module_resolve (specifier, referrer, NULL);
    #####:  111:      jerry_release_value (referrer);
    #####:  112:      jerry_release_value (specifier);
        -:  113:
    #####:  114:      if (!jerry_value_is_error (ret_value))
        -:  115:      {
    #####:  116:        if (jerry_module_get_state (ret_value) != JERRY_MODULE_STATE_UNLINKED)
        -:  117:        {
        -:  118:          /* A module can be evaluated only once. */
    #####:  119:          jerry_release_value (ret_value);
    #####:  120:          continue;
        -:  121:        }
        -:  122:
    #####:  123:        jerry_value_t link_val = jerry_module_link (ret_value, NULL, NULL);
        -:  124:
    #####:  125:        if (jerry_value_is_error (link_val))
        -:  126:        {
    #####:  127:          jerry_release_value (ret_value);
    #####:  128:          ret_value = link_val;
        -:  129:        }
        -:  130:        else
        -:  131:        {
    #####:  132:          jerry_release_value (link_val);
        -:  133:
    #####:  134:          jerry_value_t module_val = ret_value;
    #####:  135:          ret_value = jerry_module_evaluate (module_val);
    #####:  136:          jerry_release_value (module_val);
        -:  137:        }
        -:  138:      }
        -:  139:
    #####:  140:      if (jerry_value_is_error (ret_value))
        -:  141:      {
    #####:  142:        main_print_unhandled_exception (ret_value);
    #####:  143:        goto exit;
        -:  144:      }
        -:  145:
    #####:  146:      jerry_release_value (ret_value);
    #####:  147:      continue;
        -:  148:    }
        -:  149:
        1:  150:    size_t source_size;
        1:  151:    uint8_t *source_p = jerry_port_read_source (file_path_p, &source_size);
        -:  152:
        1:  153:    if (source_p == NULL)
        -:  154:    {
    #####:  155:      goto exit;
        -:  156:    }
        -:  157:
        1:  158:    switch (source_file_p->type)
        -:  159:    {
    #####:  160:      case SOURCE_SNAPSHOT:
        -:  161:      {
    #####:  162:        ret_value = jerry_exec_snapshot ((uint32_t *) source_p,
        -:  163:                                         source_size,
    #####:  164:                                         source_file_p->snapshot_index,
        -:  165:                                         JERRY_SNAPSHOT_EXEC_COPY_DATA,
        -:  166:                                         NULL);
        -:  167:
    #####:  168:        jerry_port_release_source (source_p);
    #####:  169:        break;
        -:  170:      }
        1:  171:      default:
        -:  172:      {
        1:  173:        assert (source_file_p->type == SOURCE_SCRIPT
        -:  174:                || source_file_p->type == SOURCE_MODULE);
        -:  175:
        1:  176:        if (!jerry_is_valid_utf8_string ((jerry_char_t *) source_p, (jerry_size_t) source_size))
        -:  177:        {
    #####:  178:          jerry_port_release_source (source_p);
    #####:  179:          jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Input must be a valid UTF-8 string.");
    #####:  180:          goto exit;
        -:  181:        }
        -:  182:
        1:  183:        jerry_parse_options_t parse_options;
        1:  184:        parse_options.options = JERRY_PARSE_HAS_RESOURCE;
        1:  185:        parse_options.resource_name = jerry_create_string_sz ((const jerry_char_t *) file_path_p,
        1:  186:                                                              (jerry_size_t) strlen (file_path_p));
        -:  187:
        1:  188:        ret_value = jerry_parse (source_p,
        -:  189:                                 source_size,
        -:  190:                                 &parse_options);
        -:  191:
        1:  192:        jerry_release_value (parse_options.resource_name);
        1:  193:        jerry_port_release_source (source_p);
        -:  194:
        1:  195:        if (!jerry_value_is_error (ret_value) && !(arguments.option_flags & OPT_FLAG_PARSE_ONLY))
        -:  196:        {
        1:  197:          jerry_value_t func_val = ret_value;
        1:  198:          ret_value = jerry_run (func_val);
        1:  199:          jerry_release_value (func_val);
        -:  200:        }
        -:  201:
        1:  202:        break;
        -:  203:      }
        -:  204:    }
        -:  205:
        1:  206:    if (jerry_value_is_error (ret_value))
        -:  207:    {
    #####:  208:      if (main_is_value_reset (ret_value))
        -:  209:      {
    #####:  210:        jerry_cleanup ();
        -:  211:
    #####:  212:        goto restart;
        -:  213:      }
        -:  214:
    #####:  215:      main_print_unhandled_exception (ret_value);
    #####:  216:      goto exit;
        -:  217:    }
        -:  218:
        1:  219:    jerry_release_value (ret_value);
        -:  220:  }
        -:  221:
        1:  222:  if (arguments.option_flags & OPT_FLAG_WAIT_SOURCE)
        -:  223:  {
        -:  224:    while (true)
    #####:  225:    {
        -:  226:      jerry_debugger_wait_for_source_status_t receive_status;
    #####:  227:      receive_status = jerry_debugger_wait_for_client_source (main_wait_for_source_callback,
        -:  228:                                                              NULL,
        -:  229:                                                              &ret_value);
        -:  230:
    #####:  231:      if (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVE_FAILED)
        -:  232:      {
    #####:  233:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Connection aborted before source arrived.");
    #####:  234:        goto exit;
        -:  235:      }
        -:  236:
    #####:  237:      if (receive_status == JERRY_DEBUGGER_SOURCE_END)
        -:  238:      {
    #####:  239:        jerry_port_log (JERRY_LOG_LEVEL_DEBUG, "No more client source.\n");
    #####:  240:        break;
        -:  241:      }
        -:  242:
    #####:  243:      assert (receive_status == JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED
        -:  244:              || receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);
        -:  245:
    #####:  246:      if (receive_status == JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED
    #####:  247:          || main_is_value_reset (ret_value))
        -:  248:      {
    #####:  249:        jerry_cleanup ();
    #####:  250:        goto restart;
        -:  251:      }
        -:  252:
    #####:  253:      assert (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);
    #####:  254:      jerry_release_value (ret_value);
        -:  255:    }
        -:  256:  }
        1:  257:  else if (arguments.option_flags & OPT_FLAG_USE_STDIN)
        -:  258:  {
    #####:  259:    char buffer[JERRY_BUFFER_SIZE];
    #####:  260:    char *source_p = NULL;
    #####:  261:    size_t source_size = 0;
        -:  262:
    #####:  263:    while (!feof (stdin))
        -:  264:    {
    #####:  265:      size_t read_bytes = fread (buffer, 1u, JERRY_BUFFER_SIZE, stdin);
        -:  266:
    #####:  267:      size_t new_size = source_size + read_bytes;
    #####:  268:      source_p = realloc (source_p, new_size);
        -:  269:
    #####:  270:      memcpy (source_p + source_size, buffer, read_bytes);
    #####:  271:      source_size = new_size;
        -:  272:    }
        -:  273:
    #####:  274:    ret_value = jerry_parse ((jerry_char_t *) source_p, source_size, NULL);
    #####:  275:    free (source_p);
        -:  276:
    #####:  277:    if (jerry_value_is_error (ret_value))
        -:  278:    {
    #####:  279:      main_print_unhandled_exception (ret_value);
    #####:  280:      goto exit;
        -:  281:    }
        -:  282:
    #####:  283:    jerry_value_t func_val = ret_value;
    #####:  284:    ret_value = jerry_run (func_val);
    #####:  285:    jerry_release_value (func_val);
        -:  286:
    #####:  287:    if (jerry_value_is_error (ret_value))
        -:  288:    {
    #####:  289:      main_print_unhandled_exception (ret_value);
    #####:  290:      goto exit;
        -:  291:    }
        -:  292:
    #####:  293:    jerry_release_value (ret_value);
        -:  294:  }
        1:  295:  else if (arguments.source_count == 0)
        -:  296:  {
    #####:  297:    const char *prompt = (arguments.option_flags & OPT_FLAG_NO_PROMPT) ? "" : "jerry> ";
    #####:  298:    char buffer[JERRY_BUFFER_SIZE];
        -:  299:
        -:  300:    while (true)
    #####:  301:    {
    #####:  302:      printf ("%s", prompt);
    #####:  303:      char *str_p = fgets (buffer, JERRY_BUFFER_SIZE, stdin);
        -:  304:
    #####:  305:      if (str_p == NULL)
        -:  306:      {
    #####:  307:        printf ("\n");
    #####:  308:        break;
        -:  309:      }
        -:  310:
    #####:  311:      size_t len = strlen (str_p);
        -:  312:
    #####:  313:      if (len == 0)
        -:  314:      {
    #####:  315:        continue;
        -:  316:      }
        -:  317:
    #####:  318:      if (!jerry_is_valid_utf8_string ((jerry_char_t *) str_p, (jerry_size_t) len))
        -:  319:      {
    #####:  320:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Input must be a valid UTF-8 string.\n");
    #####:  321:        continue;
        -:  322:      }
        -:  323:
    #####:  324:      ret_value = jerry_parse ((jerry_char_t *) str_p, len, NULL);
        -:  325:
    #####:  326:      if (jerry_value_is_error (ret_value))
        -:  327:      {
    #####:  328:        main_print_unhandled_exception (ret_value);
    #####:  329:        continue;
        -:  330:      }
        -:  331:
    #####:  332:      jerry_value_t func_val = ret_value;
    #####:  333:      ret_value = jerry_run (func_val);
    #####:  334:      jerry_release_value (func_val);
        -:  335:
    #####:  336:      if (jerry_value_is_error (ret_value))
        -:  337:      {
    #####:  338:        main_print_unhandled_exception (ret_value);
    #####:  339:        continue;
        -:  340:      }
        -:  341:
    #####:  342:      const jerry_value_t args[] = { ret_value };
    #####:  343:      jerry_value_t ret_val_print = jerryx_handler_print (NULL, args, 1);
    #####:  344:      jerry_release_value (ret_val_print);
    #####:  345:      jerry_release_value (ret_value);
    #####:  346:      ret_value = jerry_run_all_enqueued_jobs ();
        -:  347:
    #####:  348:      if (jerry_value_is_error (ret_value))
        -:  349:      {
    #####:  350:        main_print_unhandled_exception (ret_value);
    #####:  351:        continue;
        -:  352:      }
        -:  353:
    #####:  354:      jerry_release_value (ret_value);
        -:  355:    }
        -:  356:  }
        -:  357:
        1:  358:  ret_value = jerry_run_all_enqueued_jobs ();
        -:  359:
        1:  360:  if (jerry_value_is_error (ret_value))
        -:  361:  {
    #####:  362:    main_print_unhandled_exception (ret_value);
    #####:  363:    goto exit;
        -:  364:  }
        -:  365:
        1:  366:  jerry_release_value (ret_value);
        -:  367:
        1:  368:  if (arguments.exit_cb_name_p != NULL)
        -:  369:  {
    #####:  370:    jerry_value_t global = jerry_get_global_object ();
    #####:  371:    jerry_value_t name_str = jerry_create_string ((jerry_char_t *) arguments.exit_cb_name_p);
    #####:  372:    jerry_value_t callback_fn = jerry_get_property (global, name_str);
        -:  373:
    #####:  374:    jerry_release_value (global);
    #####:  375:    jerry_release_value (name_str);
        -:  376:
    #####:  377:    if (jerry_value_is_function (callback_fn))
        -:  378:    {
    #####:  379:      ret_value = jerry_call_function (callback_fn, jerry_create_undefined (), NULL, 0);
        -:  380:
    #####:  381:      if (jerry_value_is_error (ret_value))
        -:  382:      {
    #####:  383:        main_print_unhandled_exception (ret_value);
    #####:  384:        goto exit;
        -:  385:      }
        -:  386:
    #####:  387:      jerry_release_value (ret_value);
        -:  388:    }
        -:  389:
    #####:  390:    jerry_release_value (callback_fn);
        -:  391:  }
        -:  392:
        1:  393:  return_code = JERRY_STANDALONE_EXIT_CODE_OK;
        -:  394:
        1:  395:exit:
        1:  396:  jerry_cleanup ();
        -:  397:
        -:  398:#if defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:  399:  free (context_p);
        -:  400:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:  401:
    #####:  402:  return return_code;
        -:  403:} /* main */
