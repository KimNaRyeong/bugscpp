        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-bigint.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-bigint.h"
        -:   17:#include "ecma-big-uint.h"
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-helpers.h"
        -:   20:#include "ecma-objects.h"
        -:   21:#include "lit-char-helpers.h"
        -:   22:
        -:   23:#if JERRY_BUILTIN_BIGINT
        -:   24:
        -:   25:/**
        -:   26: * Raise a not enough memory error
        -:   27: *
        -:   28: * @return ECMA_VALUE_ERROR
        -:   29: *         Returned value must be freed with ecma_free_value.
        -:   30: */
        -:   31:static ecma_value_t
    #####:   32:ecma_bigint_raise_memory_error (void)
        -:   33:{
    #####:   34:  return ecma_raise_range_error (ECMA_ERR_MSG ("Cannot allocate memory for a BigInt value"));
        -:   35:} /* ecma_bigint_raise_memory_error */
        -:   36:
        -:   37:/**
        -:   38: * Create a single digit long BigInt value
        -:   39: *
        -:   40: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:   41: *         Returned value must be freed with ecma_free_value.
        -:   42: */
        -:   43:static ecma_value_t
    #####:   44:ecma_bigint_create_from_digit (ecma_bigint_digit_t digit, /* single digit */
        -:   45:                               bool sign) /* set ECMA_BIGINT_SIGN if true */
        -:   46:{
    #####:   47:  JERRY_ASSERT (digit != 0);
        -:   48:
    #####:   49:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:   50:
    #####:   51:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:   52:  {
    #####:   53:    return ecma_bigint_raise_memory_error ();
        -:   54:  }
        -:   55:
    #####:   56:  if (sign)
        -:   57:  {
    #####:   58:    result_value_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:   59:  }
        -:   60:
    #####:   61:  *ECMA_BIGINT_GET_DIGITS (result_value_p, 0) = digit;
    #####:   62:  return ecma_make_extended_primitive_value (result_value_p, ECMA_TYPE_BIGINT);
        -:   63:} /* ecma_bigint_create_from_digit */
        -:   64:
        -:   65:/**
        -:   66: * Parse a string and create a BigInt value
        -:   67: *
        -:   68: * @return ecma BigInt value or a special value allowed by the option flags
        -:   69: *         Returned value must be freed with ecma_free_value.
        -:   70: */
        -:   71:ecma_value_t
    #####:   72:ecma_bigint_parse_string (const lit_utf8_byte_t *string_p, /**< string represenation of the BigInt */
        -:   73:                          lit_utf8_size_t size, /**< string size */
        -:   74:                          uint32_t options) /**< ecma_bigint_parse_string_options_t option bits */
        -:   75:{
    #####:   76:  ecma_bigint_digit_t radix = 10;
    #####:   77:  uint32_t sign = (options & ECMA_BIGINT_PARSE_SET_NEGATIVE) ? ECMA_BIGINT_SIGN : 0;
    #####:   78:  bool allow_underscore = options & ECMA_BIGINT_PARSE_ALLOW_UNDERSCORE;
        -:   79:
    #####:   80:  const lit_utf8_byte_t *string_end_p = string_p + size;
    #####:   81:  string_p = ecma_string_trim_front (string_p, string_p + size);
    #####:   82:  size = (lit_utf8_size_t) (string_end_p - string_p);
        -:   83:
    #####:   84:  if (size >= 3 && string_p[0] == LIT_CHAR_0)
        -:   85:  {
    #####:   86:    if (string_p[1] == LIT_CHAR_LOWERCASE_X || string_p[1] == LIT_CHAR_UPPERCASE_X)
        -:   87:    {
    #####:   88:      radix = 16;
    #####:   89:      string_p += 2;
    #####:   90:      size -= 2;
        -:   91:    }
    #####:   92:    else if (string_p[1] == LIT_CHAR_LOWERCASE_O || string_p[1] == LIT_CHAR_UPPERCASE_O)
        -:   93:    {
    #####:   94:      radix = 8;
    #####:   95:      string_p += 2;
    #####:   96:      size -= 2;
        -:   97:    }
    #####:   98:    else if (string_p[1] == LIT_CHAR_LOWERCASE_B || string_p[1] == LIT_CHAR_UPPERCASE_B)
        -:   99:    {
    #####:  100:      radix = 2;
    #####:  101:      string_p += 2;
    #####:  102:      size -= 2;
        -:  103:    }
        -:  104:  }
    #####:  105:  else if (size >= 2)
        -:  106:  {
    #####:  107:    if (string_p[0] == LIT_CHAR_PLUS)
        -:  108:    {
    #####:  109:      size--;
    #####:  110:      string_p++;
        -:  111:    }
    #####:  112:    else if (string_p[0] == LIT_CHAR_MINUS)
        -:  113:    {
    #####:  114:      sign = ECMA_BIGINT_SIGN;
    #####:  115:      size--;
    #####:  116:      string_p++;
        -:  117:    }
        -:  118:  }
    #####:  119:  else if (size == 0)
        -:  120:  {
    #####:  121:    return ECMA_BIGINT_ZERO;
        -:  122:  }
        -:  123:
    #####:  124:  while (string_p < string_end_p && (*string_p == LIT_CHAR_0 || (*string_p == LIT_CHAR_UNDERSCORE && allow_underscore)))
        -:  125:  {
    #####:  126:    string_p++;
        -:  127:  }
        -:  128:
    #####:  129:  ecma_extended_primitive_t *result_p = NULL;
        -:  130:
    #####:  131:  if (string_p == string_end_p)
        -:  132:  {
    #####:  133:    return ECMA_BIGINT_ZERO;
        -:  134:  }
        -:  135:
        -:  136:  do
        -:  137:  {
    #####:  138:    ecma_bigint_digit_t digit = radix;
        -:  139:
    #####:  140:    if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)
        -:  141:    {
    #####:  142:      digit = (ecma_bigint_digit_t) (*string_p - LIT_CHAR_0);
        -:  143:    }
    #####:  144:    else if (*string_p == LIT_CHAR_UNDERSCORE && allow_underscore)
        -:  145:    {
    #####:  146:      continue;
        -:  147:    }
        -:  148:    else
        -:  149:    {
    #####:  150:      lit_utf8_byte_t character = (lit_utf8_byte_t) LEXER_TO_ASCII_LOWERCASE (*string_p);
        -:  151:
    #####:  152:      if (character >= LIT_CHAR_LOWERCASE_A && character <= LIT_CHAR_LOWERCASE_F)
        -:  153:      {
    #####:  154:        digit = (ecma_bigint_digit_t) (character - (LIT_CHAR_LOWERCASE_A - 10));
        -:  155:      }
    #####:  156:      else if (ecma_string_trim_front (string_p, string_end_p) == string_end_p)
        -:  157:      {
    #####:  158:        string_p = string_end_p;
    #####:  159:        break;
        -:  160:      }
        -:  161:    }
    #####:  162:    if (digit >= radix)
        -:  163:    {
    #####:  164:      if (result_p != NULL)
        -:  165:      {
    #####:  166:        ecma_deref_bigint (result_p);
        -:  167:      }
        -:  168:
    #####:  169:      if (options & ECMA_BIGINT_PARSE_DISALLOW_SYNTAX_ERROR)
        -:  170:      {
    #####:  171:        return ECMA_VALUE_FALSE;
        -:  172:      }
    #####:  173:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("String cannot be converted to BigInt value"));
        -:  174:    }
        -:  175:
    #####:  176:    result_p = ecma_big_uint_mul_digit (result_p, radix, digit);
        -:  177:
    #####:  178:    if (JERRY_UNLIKELY (result_p == NULL))
        -:  179:    {
    #####:  180:      break;
        -:  181:    }
        -:  182:  }
    #####:  183:  while (++string_p < string_end_p);
        -:  184:
    #####:  185:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  186:  {
    #####:  187:    if (options & ECMA_BIGINT_PARSE_DISALLOW_MEMORY_ERROR)
        -:  188:    {
    #####:  189:      return ECMA_VALUE_NULL;
        -:  190:    }
    #####:  191:    return ecma_bigint_raise_memory_error ();
        -:  192:  }
        -:  193:
    #####:  194:  result_p->u.bigint_sign_and_size |= sign;
    #####:  195:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -:  196:} /* ecma_bigint_parse_string */
        -:  197:
        -:  198:/**
        -:  199: * Parse a string value and create a BigInt value
        -:  200: *
        -:  201: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  202: *         Returned value must be freed with ecma_free_value.
        -:  203: */
        -:  204:ecma_value_t
    #####:  205:ecma_bigint_parse_string_value (ecma_value_t string, /**< ecma string */
        -:  206:                                uint32_t options) /**< ecma_bigint_parse_string_options_t option bits */
        -:  207:{
    #####:  208:  JERRY_ASSERT (ecma_is_value_string (string));
        -:  209:
    #####:  210:  ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (string), string_buffer_p, string_buffer_size);
        -:  211:
    #####:  212:  ecma_value_t result = ecma_bigint_parse_string (string_buffer_p, string_buffer_size, options);
    #####:  213:  ECMA_FINALIZE_UTF8_STRING (string_buffer_p, string_buffer_size);
        -:  214:
    #####:  215:  return result;
        -:  216:} /* ecma_bigint_parse_string_value */
        -:  217:
        -:  218:/**
        -:  219: * Create a string representation for a BigInt value
        -:  220: *
        -:  221: * @return ecma string or ECMA_VALUE_ERROR
        -:  222: *         Returned value must be freed with ecma_free_value.
        -:  223: */
        -:  224:ecma_string_t *
    #####:  225:ecma_bigint_to_string (ecma_value_t value, /**< BigInt value */
        -:  226:                       ecma_bigint_digit_t radix) /**< conversion radix */
        -:  227:{
    #####:  228:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  229:
    #####:  230:  if (value == ECMA_BIGINT_ZERO)
        -:  231:  {
    #####:  232:    return ecma_new_ecma_string_from_code_unit (LIT_CHAR_0);
        -:  233:  }
        -:  234:
    #####:  235:  uint32_t char_start_p, char_size_p;
    #####:  236:  ecma_extended_primitive_t *bigint_p = ecma_get_extended_primitive_from_value (value);
    #####:  237:  lit_utf8_byte_t *string_buffer_p = ecma_big_uint_to_string (bigint_p, radix, &char_start_p, &char_size_p);
        -:  238:
    #####:  239:  if (JERRY_UNLIKELY (string_buffer_p == NULL))
        -:  240:  {
    #####:  241:    ecma_raise_range_error (ECMA_ERR_MSG ("Cannot allocate memory for a string representation of a BigInt value"));
    #####:  242:    return NULL;
        -:  243:  }
        -:  244:
    #####:  245:  JERRY_ASSERT (char_start_p > 0);
        -:  246:
    #####:  247:  if (bigint_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -:  248:  {
    #####:  249:    string_buffer_p[--char_start_p] = LIT_CHAR_MINUS;
        -:  250:  }
        -:  251:
        -:  252:  ecma_string_t *string_p;
    #####:  253:  string_p = ecma_new_ecma_string_from_ascii (string_buffer_p + char_start_p, char_size_p - char_start_p);
        -:  254:
    #####:  255:  jmem_heap_free_block (string_buffer_p, char_size_p);
    #####:  256:  return string_p;
        -:  257:} /* ecma_bigint_to_string */
        -:  258:
        -:  259:/**
        -:  260: * Get the size of zero digits from the result of ecma_bigint_number_to_digits
        -:  261: */
        -:  262:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE(value) \
        -:  263:  (((value) & 0xffff) * (uint32_t) sizeof (ecma_bigint_digit_t))
        -:  264:
        -:  265:/**
        -:  266: * Get the number of digits from the result of ecma_bigint_number_to_digits
        -:  267: */
        -:  268:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS(value) ((value) >> 20)
        -:  269:
        -:  270:/**
        -:  271: * Get the size of digits from the result of ecma_bigint_number_to_digits
        -:  272: */
        -:  273:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE(value) \
        -:  274:  (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (value) * (uint32_t) sizeof (ecma_bigint_digit_t))
        -:  275:
        -:  276:/**
        -:  277: * Set number of digits in the result of ecma_bigint_number_to_digits
        -:  278: */
        -:  279:#define ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS(value) ((uint32_t) (value) << 20)
        -:  280:
        -:  281:/**
        -:  282: * This flag is set when the number passed to ecma_bigint_number_to_digits has fraction part
        -:  283: */
        -:  284:#define ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION 0x10000
        -:  285:
        -:  286:/**
        -:  287: * Convert a number to maximum of 3 digits and left shift
        -:  288: *
        -:  289: * @return packed value, ECMA_BIGINT_NUMBER_TO_DIGITS* macros can be used to decode it
        -:  290: */
        -:  291:static uint32_t
    #####:  292:ecma_bigint_number_to_digits (ecma_number_t number, /**< ecma number */
        -:  293:                              ecma_bigint_digit_t *digits_p) /**< [out] BigInt digits */
        -:  294:{
    #####:  295:  uint32_t biased_exp;
    #####:  296:  uint64_t fraction;
        -:  297:
    #####:  298:  ecma_number_unpack (number, NULL, &biased_exp, &fraction);
        -:  299:
    #####:  300:  if (biased_exp == 0 && fraction == 0)
        -:  301:  {
        -:  302:    /* Number is zero. */
    #####:  303:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (0);
        -:  304:  }
        -:  305:
    #####:  306:  if (biased_exp < ((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1))
        -:  307:  {
        -:  308:    /* Number is less than 1. */
    #####:  309:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (0) | ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION;
        -:  310:  }
        -:  311:
    #####:  312:  biased_exp -= ((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1);
    #####:  313:  fraction |= ((uint64_t) 1) << ECMA_NUMBER_FRACTION_WIDTH;
        -:  314:
    #####:  315:  if (biased_exp <= ECMA_NUMBER_FRACTION_WIDTH)
        -:  316:  {
    #####:  317:    uint32_t has_fraction = 0;
        -:  318:
    #####:  319:    if (biased_exp < ECMA_NUMBER_FRACTION_WIDTH
    #####:  320:        && (fraction << (biased_exp + ((8 * sizeof (uint64_t)) - ECMA_NUMBER_FRACTION_WIDTH))) != 0)
        -:  321:    {
    #####:  322:      has_fraction |= ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION;
        -:  323:    }
        -:  324:
    #####:  325:    fraction >>= ECMA_NUMBER_FRACTION_WIDTH - biased_exp;
    #####:  326:    digits_p[0] = (ecma_bigint_digit_t) fraction;
        -:  327:
        -:  328:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  329:    digits_p[1] = (ecma_bigint_digit_t) (fraction >> (8 * sizeof (ecma_bigint_digit_t)));
    #####:  330:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[1] == 0 ? 1 : 2) | has_fraction;
        -:  331:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  332:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (1) | has_fraction;
        -:  333:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  334:  }
        -:  335:
    #####:  336:  digits_p[0] = (ecma_bigint_digit_t) fraction;
        -:  337:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  338:  digits_p[1] = (ecma_bigint_digit_t) (fraction >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  339:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  340:
    #####:  341:  biased_exp -= ECMA_NUMBER_FRACTION_WIDTH;
        -:  342:
    #####:  343:  uint32_t shift_left = biased_exp & ((8 * sizeof (ecma_bigint_digit_t)) - 1);
    #####:  344:  biased_exp = biased_exp >> ECMA_BIGINT_DIGIT_SHIFT;
        -:  345:
    #####:  346:  if (shift_left == 0)
        -:  347:  {
        -:  348:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  349:    return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (2);
        -:  350:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  351:    return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (1);
        -:  352:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  353:  }
        -:  354:
    #####:  355:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -:  356:
        -:  357:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  358:  digits_p[2] = digits_p[1] >> shift_right;
    #####:  359:  digits_p[1] = (digits_p[1] << shift_left) | (digits_p[0] >> shift_right);
    #####:  360:  digits_p[0] <<= shift_left;
        -:  361:
    #####:  362:  return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[2] == 0 ? 2 : 3);
        -:  363:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  364:  digits_p[1] = digits_p[0] >> shift_right;
        -:  365:  digits_p[0] <<= shift_left;
        -:  366:
        -:  367:  return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[1] == 0 ? 1 : 2);
        -:  368:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  369:} /* ecma_bigint_number_to_digits */
        -:  370:
        -:  371:/**
        -:  372: * Convert an ecma number to BigInt value
        -:  373: *
        -:  374: * See also:
        -:  375: *          ECMA-262 v11, 20.2.1.1.1
        -:  376: *
        -:  377: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  378: *         Returned value must be freed with ecma_free_value.
        -:  379: */
        -:  380:static ecma_value_t
    #####:  381:ecma_bigint_number_to_bigint (ecma_number_t number) /**< ecma number */
        -:  382:{
    #####:  383:  if (ecma_number_is_nan (number) || ecma_number_is_infinity (number))
        -:  384:  {
    #####:  385:    return ecma_raise_range_error (ECMA_ERR_MSG ("Infinity or NaN cannot be converted to BigInt"));
        -:  386:  }
        -:  387:
    #####:  388:  ecma_bigint_digit_t digits[3];
    #####:  389:  uint32_t result = ecma_bigint_number_to_digits (number, digits);
        -:  390:
    #####:  391:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -:  392:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -:  393:
    #####:  394:  if (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION)
        -:  395:  {
    #####:  396:    return ecma_raise_range_error (ECMA_ERR_MSG ("Only integer numbers can be converted to BigInt"));
        -:  397:  }
        -:  398:
    #####:  399:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
        -:  400:
    #####:  401:  if (digits_size == 0)
        -:  402:  {
    #####:  403:    return ECMA_BIGINT_ZERO;
        -:  404:  }
        -:  405:
    #####:  406:  uint32_t zero_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -:  407:
    #####:  408:  ecma_extended_primitive_t *result_p = ecma_bigint_create (digits_size + zero_size);
        -:  409:
    #####:  410:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  411:  {
    #####:  412:    return ecma_bigint_raise_memory_error ();
        -:  413:  }
        -:  414:
    #####:  415:  uint8_t *data_p = (uint8_t *) ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  416:  memset (data_p, 0, zero_size);
    #####:  417:  memcpy (data_p + zero_size, digits, digits_size);
        -:  418:
    #####:  419:  if (number < 0)
        -:  420:  {
    #####:  421:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:  422:  }
        -:  423:
    #####:  424:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -:  425:} /* ecma_bigint_number_to_bigint */
        -:  426:
        -:  427:/**
        -:  428: * Convert a value to BigInt value
        -:  429: *
        -:  430: * See also:
        -:  431: *          ECMA-262 v11, 7.1.13
        -:  432: *
        -:  433: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  434: *         Returned value must be freed with ecma_free_value.
        -:  435: */
        -:  436:ecma_value_t
    #####:  437:ecma_bigint_to_bigint (ecma_value_t value, /**< any value */
        -:  438:                       bool allow_numbers) /**< converting ecma numbers is allowed */
        -:  439:{
    #####:  440:  bool free_value = false;
        -:  441:
    #####:  442:  if (ecma_is_value_object (value))
        -:  443:  {
    #####:  444:    value = ecma_op_object_default_value (ecma_get_object_from_value (value), ECMA_PREFERRED_TYPE_NUMBER);
    #####:  445:    free_value = true;
        -:  446:
    #####:  447:    if (ECMA_IS_VALUE_ERROR (value))
        -:  448:    {
    #####:  449:      return value;
        -:  450:    }
        -:  451:  }
        -:  452:
        -:  453:  ecma_value_t result;
        -:  454:
    #####:  455:  if (ecma_is_value_string (value))
        -:  456:  {
    #####:  457:    result = ecma_bigint_parse_string_value (value, ECMA_BIGINT_PARSE_NO_OPTIONS);
        -:  458:  }
    #####:  459:  else if (ecma_is_value_bigint (value))
        -:  460:  {
    #####:  461:    result = value;
        -:  462:
    #####:  463:    if (!free_value && value != ECMA_BIGINT_ZERO)
        -:  464:    {
    #####:  465:      ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
        -:  466:    }
        -:  467:    else
        -:  468:    {
    #####:  469:      free_value = false;
        -:  470:    }
        -:  471:  }
    #####:  472:  else if (allow_numbers && ecma_is_value_number (value))
        -:  473:  {
    #####:  474:    result = ecma_bigint_number_to_bigint (ecma_get_number_from_value (value));
        -:  475:  }
    #####:  476:  else if (ecma_is_value_false (value))
        -:  477:  {
    #####:  478:    result = ECMA_BIGINT_ZERO;
        -:  479:  }
    #####:  480:  else if (ecma_is_value_true (value))
        -:  481:  {
    #####:  482:    result = ecma_bigint_create_from_digit (1, false);
        -:  483:  }
        -:  484:  else
        -:  485:  {
    #####:  486:    result = ecma_raise_type_error (ECMA_ERR_MSG ("Value cannot be converted to BigInt"));
        -:  487:  }
        -:  488:
    #####:  489:  if (free_value)
        -:  490:  {
    #####:  491:    ecma_free_value (value);
        -:  492:  }
        -:  493:
    #####:  494:  return result;
        -:  495:} /* ecma_bigint_to_bigint */
        -:  496:
        -:  497:/**
        -:  498: * Convert a BigInt value to number value
        -:  499: *
        -:  500: * @return ecma number value or ECMA_VALUE_ERROR
        -:  501: *         Returned value must be freed with ecma_free_value.
        -:  502: */
        -:  503:ecma_value_t
    #####:  504:ecma_bigint_to_number (ecma_value_t value) /**< BigInt value */
        -:  505:{
    #####:  506:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  507:
    #####:  508:  if (value == ECMA_BIGINT_ZERO)
        -:  509:  {
    #####:  510:    return ecma_make_integer_value (0);
        -:  511:  }
        -:  512:
    #####:  513:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
    #####:  514:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
    #####:  515:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  516:
    #####:  517:  if (size == sizeof (ecma_bigint_digit_t))
        -:  518:  {
    #####:  519:    if (!(value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -:  520:    {
    #####:  521:      if (digits_p[-1] <= ECMA_INTEGER_NUMBER_MAX)
        -:  522:      {
    #####:  523:        return ecma_make_integer_value ((ecma_integer_value_t) digits_p[-1]);
        -:  524:      }
        -:  525:    }
    #####:  526:    else if (digits_p[-1] <= -ECMA_INTEGER_NUMBER_MIN)
        -:  527:    {
    #####:  528:      return ecma_make_integer_value (-(ecma_integer_value_t) digits_p[-1]);
        -:  529:    }
        -:  530:  }
        -:  531:
    #####:  532:  uint64_t fraction = 0;
        -:  533:  ecma_bigint_digit_t shift_left;
        -:  534:
    #####:  535:  if (digits_p[-1] == 1)
        -:  536:  {
    #####:  537:    JERRY_ASSERT (size > sizeof (ecma_bigint_digit_t));
        -:  538:
    #####:  539:    fraction = ((uint64_t) digits_p[-2]) << (8 * sizeof (ecma_bigint_digit_t));
    #####:  540:    shift_left = (uint32_t) (8 * sizeof (ecma_bigint_digit_t));
        -:  541:
    #####:  542:    if (size >= 3 * sizeof (ecma_bigint_digit_t))
        -:  543:    {
    #####:  544:      fraction |= (uint64_t) digits_p[-3];
        -:  545:    }
        -:  546:  }
        -:  547:  else
        -:  548:  {
    #####:  549:    shift_left = ecma_big_uint_count_leading_zero (digits_p[-1]) + 1;
        -:  550:
    #####:  551:    fraction = ((uint64_t) digits_p[-1]) << (8 * sizeof (ecma_bigint_digit_t) + shift_left);
        -:  552:
    #####:  553:    if (size >= 2 * sizeof (ecma_bigint_digit_t))
        -:  554:    {
    #####:  555:      fraction |= ((uint64_t) digits_p[-2]) << shift_left;
        -:  556:    }
        -:  557:
    #####:  558:    if (size >= 3 * sizeof (ecma_bigint_digit_t))
        -:  559:    {
    #####:  560:      fraction |= ((uint64_t) digits_p[-3]) >> (8 * sizeof (ecma_bigint_digit_t) - shift_left);
        -:  561:    }
        -:  562:  }
        -:  563:
    #####:  564:  uint32_t biased_exp = (uint32_t) (((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1) + (size * 8 - shift_left));
        -:  565:
        -:  566:  /* Rounding result. */
    #####:  567:  const uint64_t rounding_bit = (((uint64_t) 1) << (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH - 1));
    #####:  568:  bool round_up = false;
        -:  569:
    #####:  570:  if (fraction & rounding_bit)
        -:  571:  {
    #####:  572:    round_up = true;
        -:  573:
        -:  574:    /* IEEE_754 roundTiesToEven mode: when rounding_bit is set, and all the remaining bits
        -:  575:     * are zero, the number needs to be rounded down the bit before rounding_bit is zero. */
    #####:  576:    if ((fraction & ((rounding_bit << 2) - 1)) == rounding_bit)
        -:  577:    {
    #####:  578:      round_up = false;
        -:  579:
    #####:  580:      if ((size >= (3 * sizeof (ecma_bigint_digit_t)))
    #####:  581:          && (shift_left == (8 * sizeof (ecma_bigint_digit_t))
    #####:  582:              || (digits_p[-3] & ((((ecma_bigint_digit_t) 1) << shift_left) - 1)) == 0))
        -:  583:      {
    #####:  584:        ecma_bigint_digit_t *digits_start_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  585:
    #####:  586:        digits_p -= 3;
        -:  587:
    #####:  588:        while (digits_p > digits_start_p)
        -:  589:        {
    #####:  590:          if (digits_p[-1] != 0)
        -:  591:          {
    #####:  592:            round_up = true;
    #####:  593:            break;
        -:  594:          }
    #####:  595:          digits_p--;
        -:  596:        }
        -:  597:      }
        -:  598:    }
        -:  599:  }
        -:  600:
    #####:  601:  if (round_up)
        -:  602:  {
    #####:  603:    fraction += rounding_bit;
    #####:  604:    fraction >>= (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH);
        -:  605:
    #####:  606:    if (fraction == 0)
        -:  607:    {
    #####:  608:      biased_exp++;
        -:  609:    }
        -:  610:  }
        -:  611:  else
        -:  612:  {
    #####:  613:    fraction >>= (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH);
        -:  614:  }
        -:  615:
    #####:  616:  bool sign = (value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -:  617:  ecma_number_t result;
        -:  618:
    #####:  619:  if (biased_exp < (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)
        -:  620:  {
    #####:  621:    result = ecma_number_pack (sign, biased_exp, fraction);
        -:  622:  }
        -:  623:  else
        -:  624:  {
    #####:  625:    result = ecma_number_make_infinity (sign);
        -:  626:  }
        -:  627:
    #####:  628:  return ecma_make_number_value (result);
        -:  629:} /* ecma_bigint_to_number */
        -:  630:
        -:  631:/**
        -:  632: * Returns with a BigInt if the value is BigInt,
        -:  633: * or the value is object, and its default value is BigInt
        -:  634: *
        -:  635: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  636: *         Returned value must be freed with ecma_free_value.
        -:  637: */
        -:  638:ecma_value_t
    #####:  639:ecma_bigint_get_bigint (ecma_value_t value, /**< any value */
        -:  640:                        bool *free_result_p) /**< [out] result should be freed */
        -:  641:{
    #####:  642:  *free_result_p = false;
        -:  643:
    #####:  644:  if (ecma_is_value_bigint (value))
        -:  645:  {
    #####:  646:    return value;
        -:  647:  }
        -:  648:
    #####:  649:  if (ecma_is_value_object (value))
        -:  650:  {
    #####:  651:    ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####:  652:    ecma_value_t default_value = ecma_op_object_default_value (object_p, ECMA_PREFERRED_TYPE_NUMBER);
        -:  653:
    #####:  654:    if (ECMA_IS_VALUE_ERROR (default_value))
        -:  655:    {
    #####:  656:      return default_value;
        -:  657:    }
        -:  658:
    #####:  659:    if (ecma_is_value_bigint (default_value))
        -:  660:    {
    #####:  661:      *free_result_p = (default_value != ECMA_BIGINT_ZERO);
    #####:  662:      return default_value;
        -:  663:    }
        -:  664:
    #####:  665:    ecma_free_value (default_value);
        -:  666:  }
        -:  667:
    #####:  668:  return ecma_raise_type_error (ECMA_ERR_MSG ("Cannot convert a BigInt value to a number"));
        -:  669:} /* ecma_bigint_get_bigint */
        -:  670:
        -:  671:/**
        -:  672: * Create BigInt value from uint64 digits
        -:  673: *
        -:  674: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  675: *         Returned value must be freed with ecma_free_value.
        -:  676: */
        -:  677:ecma_value_t
    #####:  678:ecma_bigint_create_from_digits (const uint64_t *digits_p, /**< BigInt digits */
        -:  679:                                uint32_t size, /**< number of BigInt digits */
        -:  680:                                bool sign) /**< sign bit, true if the result should be negative */
        -:  681:{
    #####:  682:  const uint64_t *digits_end_p = digits_p + size;
        -:  683:
    #####:  684:  while (digits_end_p > digits_p && digits_end_p[-1] == 0)
        -:  685:  {
    #####:  686:    digits_end_p--;
        -:  687:  }
        -:  688:
    #####:  689:  if (digits_p == digits_end_p)
        -:  690:  {
    #####:  691:    return ECMA_BIGINT_ZERO;
        -:  692:  }
        -:  693:
    #####:  694:  size = (uint32_t) (digits_end_p - digits_p);
        -:  695:
    #####:  696:  if (size < ECMA_BIGINT_MAX_SIZE)
        -:  697:  {
    #####:  698:    size *= (uint32_t) sizeof (uint64_t);
        -:  699:  }
        -:  700:
    #####:  701:  if ((digits_end_p[-1] >> (8 * sizeof (ecma_bigint_digit_t))) == 0)
        -:  702:  {
    #####:  703:    size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  704:  }
        -:  705:
    #####:  706:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  707:
    #####:  708:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  709:  {
    #####:  710:    return ecma_bigint_raise_memory_error ();
        -:  711:  }
        -:  712:
    #####:  713:  if (sign)
        -:  714:  {
    #####:  715:    result_value_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:  716:  }
        -:  717:
    #####:  718:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  719:
    #####:  720:  while (digits_p < digits_end_p)
        -:  721:  {
    #####:  722:    uint64_t digit = *digits_p++;
        -:  723:
    #####:  724:    result_p[0] = (ecma_bigint_digit_t) digit;
    #####:  725:    result_p[1] = (ecma_bigint_digit_t) (digit >> (8 * sizeof (ecma_bigint_digit_t)));
    #####:  726:    result_p+= 2;
        -:  727:  }
        -:  728:
    #####:  729:  return ecma_make_extended_primitive_value (result_value_p, ECMA_TYPE_BIGINT);
        -:  730:} /* ecma_bigint_create_from_digits */
        -:  731:
        -:  732:/**
        -:  733: * Get the number of uint64 digits of a BigInt value
        -:  734: *
        -:  735: * @return number of uint64 digits
        -:  736: */
        -:  737:uint32_t
    #####:  738:ecma_bigint_get_size_in_digits (ecma_value_t value) /**< BigInt value */
        -:  739:{
    #####:  740:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  741:
    #####:  742:  if (value == ECMA_BIGINT_ZERO)
        -:  743:  {
    #####:  744:    return 0;
        -:  745:  }
        -:  746:
    #####:  747:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
    #####:  748:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  749:
    #####:  750:  return (size + (uint32_t) sizeof (ecma_bigint_digit_t)) / sizeof (uint64_t);
        -:  751:} /* ecma_bigint_get_size_in_digits */
        -:  752:
        -:  753:/**
        -:  754: * Get the uint64 digits of a BigInt value
        -:  755: */
        -:  756:void
    #####:  757:ecma_bigint_get_digits_and_sign (ecma_value_t value, /**< BigInt value */
        -:  758:                                 uint64_t *digits_p, /**< [out] buffer for digits */
        -:  759:                                 uint32_t size, /**< buffer size in digits */
        -:  760:                                 bool *sign_p) /**< [out] sign of BigInt */
        -:  761:{
    #####:  762:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  763:
    #####:  764:  if (value == ECMA_BIGINT_ZERO)
        -:  765:  {
    #####:  766:    if (sign_p != NULL)
        -:  767:    {
    #####:  768:      *sign_p = false;
        -:  769:    }
    #####:  770:    memset (digits_p, 0, size * sizeof (uint64_t));
    #####:  771:    return;
        -:  772:  }
        -:  773:
    #####:  774:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
        -:  775:
    #####:  776:  if (sign_p != NULL)
        -:  777:  {
    #####:  778:    *sign_p = (value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) != 0;
        -:  779:  }
        -:  780:
    #####:  781:  uint32_t bigint_size = ECMA_BIGINT_GET_SIZE (value_p);
    #####:  782:  uint32_t copy_size = bigint_size / sizeof (uint64_t);
        -:  783:
    #####:  784:  if (copy_size > size)
        -:  785:  {
    #####:  786:    copy_size = size;
        -:  787:  }
        -:  788:
    #####:  789:  const uint64_t *digits_end_p = digits_p + copy_size;
    #####:  790:  ecma_bigint_digit_t *source_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  791:
    #####:  792:  while (digits_p < digits_end_p)
        -:  793:  {
    #####:  794:    *digits_p++ = source_p[0] | (((uint64_t) source_p[1]) << (8 * sizeof (ecma_bigint_digit_t)));
    #####:  795:    source_p += 2;
        -:  796:  }
        -:  797:
    #####:  798:  size -= copy_size;
        -:  799:
    #####:  800:  if (size == 0)
        -:  801:  {
    #####:  802:    return;
        -:  803:  }
        -:  804:
    #####:  805:  if (ECMA_BIGINT_SIZE_IS_ODD (bigint_size))
        -:  806:  {
    #####:  807:    *digits_p++ = source_p[0];
    #####:  808:    size--;
        -:  809:  }
        -:  810:
    #####:  811:  if (size > 0)
        -:  812:  {
    #####:  813:    memset (digits_p, 0, size * sizeof (uint64_t));
        -:  814:  }
        -:  815:} /* ecma_bigint_get_digits_and_sign */
        -:  816:
        -:  817:/**
        -:  818: * Compare two BigInt values
        -:  819: *
        -:  820: * @return true if they are the same, false otherwise
        -:  821: */
        -:  822:bool
    #####:  823:ecma_bigint_is_equal_to_bigint (ecma_value_t left_value, /**< left BigInt value */
        -:  824:                                ecma_value_t right_value) /**< right BigInt value */
        -:  825:{
    #####:  826:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -:  827:
    #####:  828:  if (left_value == ECMA_BIGINT_ZERO)
        -:  829:  {
    #####:  830:    return right_value == ECMA_BIGINT_ZERO;
        -:  831:  }
    #####:  832:  else if (right_value == ECMA_BIGINT_ZERO)
        -:  833:  {
    #####:  834:    return false;
        -:  835:  }
        -:  836:
    #####:  837:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####:  838:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -:  839:
    #####:  840:  if (left_p->u.bigint_sign_and_size != right_p->u.bigint_sign_and_size)
        -:  841:  {
    #####:  842:    return false;
        -:  843:  }
        -:  844:
    #####:  845:  uint32_t size = ECMA_BIGINT_GET_SIZE (left_p);
    #####:  846:  return memcmp (ECMA_BIGINT_GET_DIGITS (left_p, 0), ECMA_BIGINT_GET_DIGITS (right_p, 0), size) == 0;
        -:  847:} /* ecma_bigint_is_equal_to_bigint */
        -:  848:
        -:  849:/**
        -:  850: * Compare a BigInt value and a number
        -:  851: *
        -:  852: * @return true if they are the same, false otherwise
        -:  853: */
        -:  854:bool
    #####:  855:ecma_bigint_is_equal_to_number (ecma_value_t left_value, /**< left BigInt value */
        -:  856:                                ecma_number_t right_value) /**< right number value */
        -:  857:{
    #####:  858:  JERRY_ASSERT (ecma_is_value_bigint (left_value));
        -:  859:
    #####:  860:  if (ecma_number_is_nan (right_value) || ecma_number_is_infinity (right_value))
        -:  861:  {
    #####:  862:    return false;
        -:  863:  }
        -:  864:
    #####:  865:  if (left_value == ECMA_BIGINT_ZERO)
        -:  866:  {
    #####:  867:    return right_value == 0;
        -:  868:  }
        -:  869:
    #####:  870:  ecma_extended_primitive_t *left_value_p = ecma_get_extended_primitive_from_value (left_value);
        -:  871:
        -:  872:  /* Sign must be the same. */
    #####:  873:  if (left_value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -:  874:  {
    #####:  875:    if (right_value > 0)
        -:  876:    {
    #####:  877:      return false;
        -:  878:    }
        -:  879:  }
    #####:  880:  else if (right_value < 0)
        -:  881:  {
    #####:  882:    return false;
        -:  883:  }
        -:  884:
    #####:  885:  ecma_bigint_digit_t digits[3];
    #####:  886:  uint32_t result = ecma_bigint_number_to_digits (right_value, digits);
        -:  887:
    #####:  888:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -:  889:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -:  890:
    #####:  891:  if (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION)
        -:  892:  {
    #####:  893:    return false;
        -:  894:  }
        -:  895:
    #####:  896:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
    #####:  897:  uint32_t zero_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -:  898:
    #####:  899:  if (ECMA_BIGINT_GET_SIZE (left_value_p) != digits_size + zero_size)
        -:  900:  {
    #####:  901:    return false;
        -:  902:  }
        -:  903:
    #####:  904:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  905:  ecma_bigint_digit_t *left_end_p = (ecma_bigint_digit_t *) (((uint8_t *) left_p) + zero_size);
        -:  906:
        -:  907:  /* Check value bits first. */
    #####:  908:  if (memcmp (left_end_p, digits, digits_size) != 0)
        -:  909:  {
    #####:  910:    return false;
        -:  911:  }
        -:  912:
    #####:  913:  while (left_p < left_end_p)
        -:  914:  {
    #####:  915:    if (*left_p++ != 0)
        -:  916:    {
    #####:  917:      return false;
        -:  918:    }
        -:  919:  }
        -:  920:
    #####:  921:  return true;
        -:  922:} /* ecma_bigint_is_equal_to_number */
        -:  923:
        -:  924:/**
        -:  925: * Convert 0 to 1, and 1 to -1. Useful for getting sign.
        -:  926: */
        -:  927:#define ECMA_BIGINT_TO_SIGN(value) (1 - (((int) (value)) << 1))
        -:  928:
        -:  929:/**
        -:  930: * Convert 0 to -1, and 1 to 1. Useful for getting negated sign.
        -:  931: */
        -:  932:#define ECMA_BIGINT_TO_NEGATED_SIGN(value) (-1 + (((int) (value)) << 1))
        -:  933:
        -:  934:/**
        -:  935: * Compare two BigInt values
        -:  936: *
        -:  937: * return -1, if left value < right value, 0 if they are equal, 1 otherwise
        -:  938: */
        -:  939:int
    #####:  940:ecma_bigint_compare_to_bigint (ecma_value_t left_value, /**< left BigInt value */
        -:  941:                               ecma_value_t right_value) /**< right BigInt value */
        -:  942:{
    #####:  943:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -:  944:
    #####:  945:  if (left_value == ECMA_BIGINT_ZERO)
        -:  946:  {
    #####:  947:    if (right_value == ECMA_BIGINT_ZERO)
        -:  948:    {
    #####:  949:      return 0;
        -:  950:    }
        -:  951:
    #####:  952:    ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####:  953:    return ECMA_BIGINT_TO_NEGATED_SIGN (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -:  954:  }
        -:  955:
    #####:  956:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####:  957:  uint32_t left_sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -:  958:
    #####:  959:  if (right_value == ECMA_BIGINT_ZERO)
        -:  960:  {
    #####:  961:    return ECMA_BIGINT_TO_SIGN (left_sign);
        -:  962:  }
        -:  963:
    #####:  964:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####:  965:  uint32_t right_sign = right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -:  966:
    #####:  967:  if ((left_sign ^ right_sign) != 0)
        -:  968:  {
    #####:  969:    return ECMA_BIGINT_TO_SIGN (left_sign);
        -:  970:  }
        -:  971:
    #####:  972:  if (left_sign == 0)
        -:  973:  {
    #####:  974:    return ecma_big_uint_compare (left_p, right_p);
        -:  975:  }
        -:  976:
    #####:  977:  return -ecma_big_uint_compare (left_p, right_p);
        -:  978:} /* ecma_bigint_compare_to_bigint */
        -:  979:
        -:  980:/**
        -:  981: * Compare a BigInt value and a number
        -:  982: *
        -:  983: * return -1, if left value < right value, 0 if they are equal, 1 otherwise
        -:  984: */
        -:  985:int
    #####:  986:ecma_bigint_compare_to_number (ecma_value_t left_value, /**< left BigInt value */
        -:  987:                               ecma_number_t right_value) /**< right number value */
        -:  988:{
    #####:  989:  JERRY_ASSERT (ecma_is_value_bigint (left_value));
    #####:  990:  JERRY_ASSERT (!ecma_number_is_nan (right_value));
        -:  991:
    #####:  992:  int right_invert_sign = ECMA_BIGINT_TO_SIGN (right_value > 0);
        -:  993:
    #####:  994:  if (left_value == ECMA_BIGINT_ZERO)
        -:  995:  {
    #####:  996:    if (right_value == 0)
        -:  997:    {
    #####:  998:      return 0;
        -:  999:    }
        -: 1000:
    #####: 1001:    return right_invert_sign;
        -: 1002:  }
        -: 1003:
    #####: 1004:  ecma_extended_primitive_t *left_value_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1005:  int left_sign = ECMA_BIGINT_TO_SIGN (left_value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -: 1006:
    #####: 1007:  if (right_value == 0 || left_sign == right_invert_sign)
        -: 1008:  {
        -: 1009:    /* Second condition: a positive BigInt is always greater than any negative number, and the opposite is true. */
    #####: 1010:    return left_sign;
        -: 1011:  }
        -: 1012:
    #####: 1013:  if (ecma_number_is_infinity (right_value))
        -: 1014:  {
        -: 1015:    /* Infinity is always bigger than any BigInt number. */
    #####: 1016:    return right_invert_sign;
        -: 1017:  }
        -: 1018:
    #####: 1019:  ecma_bigint_digit_t digits[3];
    #####: 1020:  uint32_t result = ecma_bigint_number_to_digits (right_value, digits);
        -: 1021:
    #####: 1022:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -: 1023:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -: 1024:
    #####: 1025:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
        -: 1026:
    #####: 1027:  if (digits_size == 0)
        -: 1028:  {
    #####: 1029:    JERRY_ASSERT (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION);
        -: 1030:    /* The number is between [-1 .. 1] exclusive. */
    #####: 1031:    return left_sign;
        -: 1032:  }
        -: 1033:
    #####: 1034:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1035:  uint32_t right_size = digits_size + ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -: 1036:
    #####: 1037:  if (left_size != right_size)
        -: 1038:  {
    #####: 1039:    return left_size > right_size ? left_sign : -left_sign;
        -: 1040:  }
        -: 1041:
    #####: 1042:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, right_size);
    #####: 1043:  ecma_bigint_digit_t *left_end_p = (ecma_bigint_digit_t *) (((uint8_t *) left_p) - digits_size);
    #####: 1044:  ecma_bigint_digit_t *digits_p = (ecma_bigint_digit_t *) (((uint8_t *) digits) + digits_size);
        -: 1045:
        -: 1046:  do
        -: 1047:  {
    #####: 1048:    ecma_bigint_digit_t left = *(--left_p);
    #####: 1049:    ecma_bigint_digit_t right = *(--digits_p);
        -: 1050:
    #####: 1051:    if (left != right)
        -: 1052:    {
    #####: 1053:      return left > right ? left_sign : -left_sign;
        -: 1054:    }
        -: 1055:  }
    #####: 1056:  while (left_p > left_end_p);
        -: 1057:
    #####: 1058:  left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
        -: 1059:
    #####: 1060:  while (left_p > left_end_p)
        -: 1061:  {
    #####: 1062:    if (*(--left_p) != 0)
        -: 1063:    {
    #####: 1064:      return left_sign;
        -: 1065:    }
        -: 1066:  }
        -: 1067:
    #####: 1068:  return (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION) ? -left_sign : 0;
        -: 1069:} /* ecma_bigint_compare_to_number */
        -: 1070:
        -: 1071:#undef ECMA_BIGINT_TO_SIGN
        -: 1072:
        -: 1073:/**
        -: 1074: * Negate a non-zero BigInt value
        -: 1075: *
        -: 1076: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1077: *         Returned value must be freed with ecma_free_value.
        -: 1078: */
        -: 1079:ecma_value_t
    #####: 1080:ecma_bigint_negate (ecma_extended_primitive_t *value_p) /**< BigInt value */
        -: 1081:{
    #####: 1082:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -: 1083:
    #####: 1084:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -: 1085:
    #####: 1086:  ecma_extended_primitive_t *result_p = ecma_bigint_create (size);
        -: 1087:
    #####: 1088:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1089:  {
    #####: 1090:    return ecma_bigint_raise_memory_error ();
        -: 1091:  }
        -: 1092:
    #####: 1093:  memcpy (result_p + 1, value_p + 1, size);
    #####: 1094:  result_p->refs_and_type = ECMA_EXTENDED_PRIMITIVE_REF_ONE | ECMA_TYPE_BIGINT;
    #####: 1095:  result_p->u.bigint_sign_and_size = value_p->u.bigint_sign_and_size ^ ECMA_BIGINT_SIGN;
        -: 1096:
    #####: 1097:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1098:} /* ecma_bigint_negate */
        -: 1099:
        -: 1100:/**
        -: 1101: * Invert all bits of a BigInt value
        -: 1102: *
        -: 1103: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1104: *         Returned value must be freed with ecma_free_value.
        -: 1105: */
        -: 1106:ecma_value_t
    #####: 1107:ecma_bigint_unary (ecma_value_t value, /**< BigInt value */
        -: 1108:                   ecma_bigint_unary_operation_type type) /**< type of unary operation */
        -: 1109:{
    #####: 1110:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -: 1111:
    #####: 1112:  if (value == ECMA_BIGINT_ZERO)
        -: 1113:  {
    #####: 1114:    return ecma_bigint_create_from_digit (1, type != ECMA_BIGINT_UNARY_INCREASE);
        -: 1115:  }
        -: 1116:
    #####: 1117:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
        -: 1118:
    #####: 1119:  uint32_t sign = (type != ECMA_BIGINT_UNARY_DECREASE) ? ECMA_BIGINT_SIGN : 0;
        -: 1120:
    #####: 1121:  if ((value_p->u.bigint_sign_and_size == (uint32_t) (sizeof (ecma_bigint_digit_t) | sign))
    #####: 1122:      && *ECMA_BIGINT_GET_DIGITS (value_p, 0) == 1)
        -: 1123:  {
    #####: 1124:    return ECMA_BIGINT_ZERO;
        -: 1125:  }
        -: 1126:
        -: 1127:  ecma_extended_primitive_t *result_p;
        -: 1128:
    #####: 1129:  if ((value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) == (sign ^ ECMA_BIGINT_SIGN))
        -: 1130:  {
    #####: 1131:    result_p = ecma_big_uint_increase (value_p);
        -: 1132:
    #####: 1133:    if (type != ECMA_BIGINT_UNARY_INCREASE && result_p != NULL)
        -: 1134:    {
    #####: 1135:      result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1136:    }
        -: 1137:  }
        -: 1138:  else
        -: 1139:  {
    #####: 1140:    result_p = ecma_big_uint_decrease (value_p);
        -: 1141:
    #####: 1142:    if (type == ECMA_BIGINT_UNARY_INCREASE && result_p != NULL)
        -: 1143:    {
    #####: 1144:      result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1145:    }
        -: 1146:  }
        -: 1147:
    #####: 1148:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1149:  {
    #####: 1150:    return ecma_bigint_raise_memory_error ();
        -: 1151:  }
        -: 1152:
    #####: 1153:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1154:} /* ecma_bigint_unary */
        -: 1155:
        -: 1156:/**
        -: 1157: * Add/subtract right BigInt value to/from left BigInt value
        -: 1158: *
        -: 1159: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1160: *         Returned value must be freed with ecma_free_value.
        -: 1161: */
        -: 1162:ecma_value_t
    #####: 1163:ecma_bigint_add_sub (ecma_value_t left_value, /**< left BigInt value */
        -: 1164:                     ecma_value_t right_value, /**< right BigInt value */
        -: 1165:                     bool is_add) /**< true if add operation should be performed */
        -: 1166:{
    #####: 1167:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1168:
    #####: 1169:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1170:  {
    #####: 1171:    return ecma_copy_value (left_value);
        -: 1172:  }
        -: 1173:
    #####: 1174:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1175:
    #####: 1176:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1177:  {
    #####: 1178:    if (!is_add)
        -: 1179:    {
    #####: 1180:      return ecma_bigint_negate (right_p);
        -: 1181:    }
        -: 1182:
    #####: 1183:    ecma_ref_extended_primitive (right_p);
    #####: 1184:    return right_value;
        -: 1185:  }
        -: 1186:
    #####: 1187:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1188:  uint32_t sign = is_add ? 0 : ECMA_BIGINT_SIGN;
        -: 1189:
    #####: 1190:  if (((left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN) == sign)
        -: 1191:  {
    #####: 1192:    ecma_extended_primitive_t *result_p = ecma_big_uint_add (left_p, right_p);
        -: 1193:
    #####: 1194:    if (JERRY_UNLIKELY (result_p == NULL))
        -: 1195:    {
    #####: 1196:      return ecma_bigint_raise_memory_error ();
        -: 1197:    }
        -: 1198:
    #####: 1199:    result_p->u.bigint_sign_and_size |= left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
    #####: 1200:    return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1201:  }
        -: 1202:
    #####: 1203:  int compare_result = ecma_big_uint_compare (left_p, right_p);
        -: 1204:  ecma_extended_primitive_t *result_p;
        -: 1205:
    #####: 1206:  if (compare_result == 0)
        -: 1207:  {
    #####: 1208:    return ECMA_BIGINT_ZERO;
        -: 1209:  }
        -: 1210:
    #####: 1211:  if (compare_result > 0)
        -: 1212:  {
    #####: 1213:    sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
    #####: 1214:    result_p = ecma_big_uint_sub (left_p, right_p);
        -: 1215:  }
        -: 1216:  else
        -: 1217:  {
    #####: 1218:    sign = right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1219:
    #####: 1220:    if (!is_add)
        -: 1221:    {
    #####: 1222:      sign ^= ECMA_BIGINT_SIGN;
        -: 1223:    }
        -: 1224:
    #####: 1225:    result_p = ecma_big_uint_sub (right_p, left_p);
        -: 1226:  }
        -: 1227:
    #####: 1228:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1229:  {
    #####: 1230:    return ecma_bigint_raise_memory_error ();
        -: 1231:  }
        -: 1232:
    #####: 1233:  result_p->u.bigint_sign_and_size |= sign;
    #####: 1234:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1235:} /* ecma_bigint_add_sub */
        -: 1236:
        -: 1237:/**
        -: 1238: * Multiply two BigInt values
        -: 1239: *
        -: 1240: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1241: *         Returned value must be freed with ecma_free_value.
        -: 1242: */
        -: 1243:ecma_value_t
    #####: 1244:ecma_bigint_mul (ecma_value_t left_value, /**< left BigInt value */
        -: 1245:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1246:{
    #####: 1247:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1248:
    #####: 1249:  if (left_value == ECMA_BIGINT_ZERO || right_value == ECMA_BIGINT_ZERO)
        -: 1250:  {
    #####: 1251:    return ECMA_BIGINT_ZERO;
        -: 1252:  }
        -: 1253:
    #####: 1254:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1255:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####: 1256:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_p);
    #####: 1257:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_p);
        -: 1258:
    #####: 1259:  if (left_size == sizeof (ecma_bigint_digit_t)
    #####: 1260:      && ECMA_BIGINT_GET_LAST_DIGIT (left_p, sizeof (ecma_bigint_digit_t)) == 1)
        -: 1261:  {
    #####: 1262:    if (left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1263:    {
    #####: 1264:      return ecma_bigint_negate (right_p);
        -: 1265:    }
        -: 1266:
    #####: 1267:    ecma_ref_extended_primitive (right_p);
    #####: 1268:    return right_value;
        -: 1269:  }
        -: 1270:
    #####: 1271:  if (right_size == sizeof (ecma_bigint_digit_t)
    #####: 1272:      && ECMA_BIGINT_GET_LAST_DIGIT (right_p, sizeof (ecma_bigint_digit_t)) == 1)
        -: 1273:  {
    #####: 1274:    if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1275:    {
    #####: 1276:      return ecma_bigint_negate (left_p);
        -: 1277:    }
        -: 1278:
    #####: 1279:    ecma_ref_extended_primitive (left_p);
    #####: 1280:    return left_value;
        -: 1281:  }
        -: 1282:
    #####: 1283:  ecma_extended_primitive_t *result_p = ecma_big_uint_mul (left_p, right_p);
        -: 1284:
    #####: 1285:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1286:  {
    #####: 1287:    return ecma_bigint_raise_memory_error ();
        -: 1288:  }
        -: 1289:
    #####: 1290:  uint32_t sign = (left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN;
    #####: 1291:  result_p->u.bigint_sign_and_size |= sign;
    #####: 1292:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1293:} /* ecma_bigint_mul */
        -: 1294:
        -: 1295:/**
        -: 1296: * Divide two BigInt values
        -: 1297: *
        -: 1298: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1299: *         Returned value must be freed with ecma_free_value.
        -: 1300: */
        -: 1301:ecma_value_t
    #####: 1302:ecma_bigint_div_mod (ecma_value_t left_value, /**< left BigInt value */
        -: 1303:                     ecma_value_t right_value, /**< right BigInt value */
        -: 1304:                     bool is_mod) /**< true if return with remainder */
        -: 1305:{
    #####: 1306:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1307:
    #####: 1308:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1309:  {
    #####: 1310:    return ecma_raise_range_error (ECMA_ERR_MSG ("BigInt division by zero"));
        -: 1311:  }
        -: 1312:
    #####: 1313:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1314:  {
    #####: 1315:    return left_value;
        -: 1316:  }
        -: 1317:
    #####: 1318:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1319:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1320:
    #####: 1321:  int compare_result = ecma_big_uint_compare (left_p, right_p);
        -: 1322:  ecma_extended_primitive_t *result_p;
        -: 1323:
    #####: 1324:  if (compare_result < 0)
        -: 1325:  {
    #####: 1326:    if (!is_mod)
        -: 1327:    {
    #####: 1328:      return ECMA_BIGINT_ZERO;
        -: 1329:    }
        -: 1330:
    #####: 1331:    ecma_ref_extended_primitive (left_p);
    #####: 1332:    return left_value;
        -: 1333:  }
    #####: 1334:  else if (compare_result == 0)
        -: 1335:  {
    #####: 1336:    if (is_mod)
        -: 1337:    {
    #####: 1338:      return ECMA_BIGINT_ZERO;
        -: 1339:    }
        -: 1340:
    #####: 1341:    result_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -: 1342:
    #####: 1343:    if (result_p != NULL)
        -: 1344:    {
    #####: 1345:      *ECMA_BIGINT_GET_DIGITS (result_p, 0) = 1;
        -: 1346:    }
        -: 1347:  }
        -: 1348:  else
        -: 1349:  {
    #####: 1350:    result_p = ecma_big_uint_div_mod (left_p, right_p, is_mod);
        -: 1351:
    #####: 1352:    if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1353:    {
    #####: 1354:      return ECMA_BIGINT_ZERO;
        -: 1355:    }
        -: 1356:  }
        -: 1357:
    #####: 1358:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1359:  {
    #####: 1360:    return ecma_bigint_raise_memory_error ();
        -: 1361:  }
        -: 1362:
    #####: 1363:  if (is_mod)
        -: 1364:  {
    #####: 1365:    result_p->u.bigint_sign_and_size |= left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1366:  }
        -: 1367:  else
        -: 1368:  {
    #####: 1369:    uint32_t sign = (left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN;
    #####: 1370:    result_p->u.bigint_sign_and_size |= sign;
        -: 1371:  }
        -: 1372:
    #####: 1373:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1374:} /* ecma_bigint_div_mod */
        -: 1375:
        -: 1376:/**
        -: 1377: * Shift left BigInt value to left or right
        -: 1378: *
        -: 1379: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1380: *         Returned value must be freed with ecma_free_value.
        -: 1381: */
        -: 1382:ecma_value_t
    #####: 1383:ecma_bigint_shift (ecma_value_t left_value, /**< left BigInt value */
        -: 1384:                   ecma_value_t right_value, /**< right BigInt value */
        -: 1385:                   bool is_left) /**< true if left shift operation should be performed */
        -: 1386:{
    #####: 1387:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1388:
    #####: 1389:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1390:  {
    #####: 1391:    return ECMA_BIGINT_ZERO;
        -: 1392:  }
        -: 1393:
    #####: 1394:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
        -: 1395:
    #####: 1396:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1397:  {
    #####: 1398:    ecma_ref_extended_primitive (left_p);
    #####: 1399:    return left_value;
        -: 1400:  }
        -: 1401:
    #####: 1402:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1403:
    #####: 1404:  if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1405:  {
    #####: 1406:    is_left = !is_left;
        -: 1407:  }
        -: 1408:
    #####: 1409:  if (ECMA_BIGINT_GET_SIZE (right_p) > sizeof (ecma_bigint_digit_t))
        -: 1410:  {
    #####: 1411:    if (is_left)
        -: 1412:    {
    #####: 1413:      return ecma_bigint_raise_memory_error ();
        -: 1414:    }
    #####: 1415:    else if (left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1416:    {
        -: 1417:      /* Shifting a negative value with a very big number to the right should be -1. */
    #####: 1418:      return ecma_bigint_create_from_digit (1, true);
        -: 1419:    }
        -: 1420:
    #####: 1421:    return ECMA_BIGINT_ZERO;
        -: 1422:  }
        -: 1423:
        -: 1424:  ecma_extended_primitive_t *result_p;
    #####: 1425:  ecma_bigint_digit_t shift = ECMA_BIGINT_GET_LAST_DIGIT (right_p, sizeof (ecma_bigint_digit_t));
    #####: 1426:  uint32_t left_sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1427:
    #####: 1428:  if (is_left)
        -: 1429:  {
    #####: 1430:    result_p = ecma_big_uint_shift_left (left_p, shift);
        -: 1431:  }
        -: 1432:  else
        -: 1433:  {
        -: 1434:    /* -x >> y == ~(x - 1) >> y == ~((x - 1) >> y) == -(((x - 1) >> y) + 1)
        -: 1435:     * When a non-zero bit is shifted out: (x - 1) >> y == x >> y, so the formula is -((x >> y) + 1)
        -: 1436:     * When only zero bits are shifted out: (((x - 1) >> y) + 1) == x >> y so the formula is: -(x >> y) */
    #####: 1437:    result_p = ecma_big_uint_shift_right (left_p, shift, left_sign != 0);
        -: 1438:
    #####: 1439:    if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1440:    {
    #####: 1441:      return ECMA_BIGINT_ZERO;
        -: 1442:    }
        -: 1443:  }
        -: 1444:
    #####: 1445:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1446:  {
    #####: 1447:    return ecma_bigint_raise_memory_error ();
        -: 1448:  }
        -: 1449:
    #####: 1450:  result_p->u.bigint_sign_and_size |= left_sign;
    #####: 1451:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1452:} /* ecma_bigint_shift */
        -: 1453:
        -: 1454:#if JERRY_ESNEXT
        -: 1455:
        -: 1456:/**
        -: 1457: * Compute the left value raised to the power of right value
        -: 1458: *
        -: 1459: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1460: *         Returned value must be freed with ecma_free_value.
        -: 1461: */
        -: 1462:ecma_value_t
    #####: 1463:ecma_bigint_pow (ecma_value_t left_value, /**< left BigInt value */
        -: 1464:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1465:{
    #####: 1466:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1467:
    #####: 1468:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1469:  {
    #####: 1470:    return ecma_bigint_create_from_digit (1, false);
        -: 1471:  }
        -: 1472:
    #####: 1473:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1474:
    #####: 1475:  if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1476:  {
    #####: 1477:    return ecma_raise_range_error (ECMA_ERR_MSG ("Negative exponent is not allowed for BigInts"));
        -: 1478:  }
        -: 1479:
    #####: 1480:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1481:  {
    #####: 1482:    return ECMA_BIGINT_ZERO;
        -: 1483:  }
        -: 1484:
    #####: 1485:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1486:  ecma_bigint_digit_t base = 0;
        -: 1487:
    #####: 1488:  if (ECMA_BIGINT_GET_SIZE (left_p) == sizeof (ecma_bigint_digit_t))
        -: 1489:  {
    #####: 1490:    base = *ECMA_BIGINT_GET_DIGITS (left_p, 0);
        -: 1491:
    #####: 1492:    JERRY_ASSERT (base != 0);
        -: 1493:
    #####: 1494:    if (base == 1)
        -: 1495:    {
    #####: 1496:      if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
    #####: 1497:          || ECMA_BIGINT_NUMBER_IS_ODD (*ECMA_BIGINT_GET_DIGITS (right_p, 0)))
        -: 1498:      {
    #####: 1499:        ecma_ref_extended_primitive (left_p);
    #####: 1500:        return left_value;
        -: 1501:      }
        -: 1502:
    #####: 1503:      return ecma_bigint_create_from_digit (1, false);
        -: 1504:    }
        -: 1505:  }
        -: 1506:
    #####: 1507:  if (JERRY_UNLIKELY (ECMA_BIGINT_GET_SIZE (right_p) > sizeof (ecma_bigint_digit_t)))
        -: 1508:  {
    #####: 1509:    return ecma_bigint_raise_memory_error ();
        -: 1510:  }
        -: 1511:
    #####: 1512:  ecma_bigint_digit_t power = *ECMA_BIGINT_GET_DIGITS (right_p, 0);
        -: 1513:
    #####: 1514:  if (power == 1)
        -: 1515:  {
    #####: 1516:    ecma_ref_extended_primitive (left_p);
    #####: 1517:    return left_value;
        -: 1518:  }
        -: 1519:
        -: 1520:  ecma_extended_primitive_t *result_p;
        -: 1521:
    #####: 1522:  if (base == 2)
        -: 1523:  {
    #####: 1524:    result_p = ecma_big_uint_shift_left (left_p, power - 1);
        -: 1525:  }
        -: 1526:  else
        -: 1527:  {
    #####: 1528:    result_p = ecma_big_uint_pow (left_p, power);
        -: 1529:  }
        -: 1530:
    #####: 1531:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1532:  {
    #####: 1533:    return ecma_bigint_raise_memory_error ();
        -: 1534:  }
        -: 1535:
    #####: 1536:  if ((left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) && ECMA_BIGINT_NUMBER_IS_ODD (power))
        -: 1537:  {
    #####: 1538:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1539:  }
        -: 1540:
    #####: 1541:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1542:} /* ecma_bigint_pow */
        -: 1543:
        -: 1544:#endif /* JERRY_ESNEXT */
        -: 1545:
        -: 1546:/**
        -: 1547: * Convert the result to an ecma value
        -: 1548: *
        -: 1549: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1550: *         Returned value must be freed with ecma_free_value.
        -: 1551: */
        -: 1552:static ecma_value_t
    #####: 1553:ecma_bigint_bitwise_op (uint32_t operation_and_options, /**< bitwise operation type and options */
        -: 1554:                        ecma_extended_primitive_t *left_value_p, /**< left BigInt value */
        -: 1555:                        ecma_extended_primitive_t *right_value_p) /**< right BigInt value */
        -: 1556:{
        -: 1557:  ecma_extended_primitive_t *result_p;
    #####: 1558:  result_p = ecma_big_uint_bitwise_op (operation_and_options, left_value_p, right_value_p);
        -: 1559:
    #####: 1560:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1561:  {
    #####: 1562:    return ecma_bigint_raise_memory_error ();
        -: 1563:  }
        -: 1564:
    #####: 1565:  if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1566:  {
    #####: 1567:    return ECMA_BIGINT_ZERO;
        -: 1568:  }
        -: 1569:
    #####: 1570:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1571:  {
    #####: 1572:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1573:  }
        -: 1574:
    #####: 1575:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1576:} /* ecma_bigint_bitwise_op */
        -: 1577:
        -: 1578:/**
        -: 1579: * Perform bitwise 'and' operations on two BigUInt numbers
        -: 1580: *
        -: 1581: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1582: *         Returned value must be freed with ecma_free_value.
        -: 1583: */
        -: 1584:ecma_value_t
    #####: 1585:ecma_bigint_and (ecma_value_t left_value, /**< left BigInt value */
        -: 1586:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1587:{
    #####: 1588:  if (left_value == ECMA_BIGINT_ZERO || right_value == ECMA_BIGINT_ZERO)
        -: 1589:  {
    #####: 1590:    return ECMA_BIGINT_ZERO;
        -: 1591:  }
        -: 1592:
    #####: 1593:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1594:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1595:
    #####: 1596:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1597:  {
    #####: 1598:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1599:    {
    #####: 1600:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_AND, left_p, right_p);
        -: 1601:    }
        -: 1602:
        -: 1603:    /* x & (-y) == x & ~(y-1) == x &~ (y-1) */
    #####: 1604:    uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT;
    #####: 1605:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1606:  }
        -: 1607:
    #####: 1608:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1609:  {
        -: 1610:    /* (-x) & y == ~(x-1) & y == y &~ (x-1) */
    #####: 1611:    uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT;
    #####: 1612:    return ecma_bigint_bitwise_op (operation_and_options, right_p, left_p);
        -: 1613:  }
        -: 1614:
        -: 1615:  /* (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1) */
    #####: 1616:  uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_OR
        -: 1617:                                    | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH
        -: 1618:                                    | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1619:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1620:} /* ecma_bigint_and */
        -: 1621:
        -: 1622:/**
        -: 1623: * Perform bitwise 'or' operations on two BigUInt numbers
        -: 1624: *
        -: 1625: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1626: *         Returned value must be freed with ecma_free_value.
        -: 1627: */
        -: 1628:ecma_value_t
    #####: 1629:ecma_bigint_or (ecma_value_t left_value, /**< left BigInt value */
        -: 1630:                ecma_value_t right_value) /**< right BigInt value */
        -: 1631:{
    #####: 1632:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1633:  {
    #####: 1634:    return ecma_copy_value (right_value);
        -: 1635:  }
        -: 1636:
    #####: 1637:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1638:  {
    #####: 1639:    return ecma_copy_value (left_value);
        -: 1640:  }
        -: 1641:
    #####: 1642:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1643:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1644:
    #####: 1645:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1646:  {
    #####: 1647:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1648:    {
    #####: 1649:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_OR, left_p, right_p);
        -: 1650:    }
        -: 1651:
        -: 1652:    /* x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1) */
    #####: 1653:    uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_AND_NOT
        -: 1654:                                      | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT
        -: 1655:                                      | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1656:    return ecma_bigint_bitwise_op (operation_and_options, right_p, left_p);
        -: 1657:  }
        -: 1658:
    #####: 1659:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1660:  {
        -: 1661:    /* (-x) | y == ~(x-1) | y == ~((x-1) &~ y) == -(((x-1) &~ y) + 1) */
    #####: 1662:    uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_AND_NOT
        -: 1663:                                      | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT
        -: 1664:                                      | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1665:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1666:  }
        -: 1667:
        -: 1668:  /* (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1)) = -(((x-1) & (y-1)) + 1) */
    #####: 1669:  uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_AND
        -: 1670:                                    | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH
        -: 1671:                                    | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1672:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1673:} /* ecma_bigint_or */
        -: 1674:
        -: 1675:/**
        -: 1676: * Perform bitwise 'xor' operations on two BigUInt numbers
        -: 1677: *
        -: 1678: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1679: *         Returned value must be freed with ecma_free_value.
        -: 1680: */
        -: 1681:ecma_value_t
    #####: 1682:ecma_bigint_xor (ecma_value_t left_value, /**< left BigInt value */
        -: 1683:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1684:{
    #####: 1685:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1686:  {
    #####: 1687:    return ecma_copy_value (right_value);
        -: 1688:  }
        -: 1689:
    #####: 1690:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1691:  {
    #####: 1692:    return ecma_copy_value (left_value);
        -: 1693:  }
        -: 1694:
    #####: 1695:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1696:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1697:
    #####: 1698:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1699:  {
    #####: 1700:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1701:    {
    #####: 1702:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_XOR, left_p, right_p);
        -: 1703:    }
        -: 1704:
        -: 1705:    /* x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1) */
    #####: 1706:    uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_XOR
        -: 1707:                                      | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT
        -: 1708:                                      | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1709:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1710:  }
        -: 1711:
    #####: 1712:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1713:  {
        -: 1714:    /* (-x) | y == ~(x-1) ^ y == ~((x-1) ^ y) == -(((x-1) ^ y) + 1) */
    #####: 1715:    uint32_t operation_and_options = (ECMA_BIG_UINT_BITWISE_XOR
        -: 1716:                                      | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT
        -: 1717:                                      | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1718:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1719:  }
        -: 1720:
        -: 1721:  /* (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1) */
    #####: 1722:  uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_XOR | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH;
    #####: 1723:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1724:} /* ecma_bigint_xor */
        -: 1725:
        -: 1726:#endif /* JERRY_BUILTIN_BIGINT */
