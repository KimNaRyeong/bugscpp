        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-typedarray-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-iterator-object.h"
        -:   19:#include "ecma-typedarray-object.h"
        -:   20:#include "ecma-arraybuffer-object.h"
        -:   21:#include "ecma-shared-arraybuffer-object.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-big-uint.h"
        -:   25:#include "ecma-builtin-helpers.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "ecma-builtins.h"
        -:   29:#include "ecma-exceptions.h"
        -:   30:#include "ecma-gc.h"
        -:   31:#include "ecma-globals.h"
        -:   32:#include "ecma-helpers.h"
        -:   33:#include "jcontext.h"
        -:   34:
        -:   35:#if JERRY_BUILTIN_TYPEDARRAY
        -:   36:
        -:   37:/** \addtogroup ecma ECMA
        -:   38: * @{
        -:   39: *
        -:   40: * \addtogroup ecmatypedarrayobject ECMA TypedArray object related routines
        -:   41: * @{
        -:   42: */
        -:   43:
        -:   44:/**
        -:   45: * Read and copy a number from a given buffer to a value.
        -:   46: **/
        -:   47:#define ECMA_TYPEDARRAY_GET_ELEMENT(src_p, num, type) \
        -:   48:    do \
        -:   49:    { \
        -:   50:      if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   51:      { \
        -:   52:        num = *(type *) ((void*) src_p); \
        -:   53:      } \
        -:   54:      else \
        -:   55:      { \
        -:   56:        memcpy (&num, (void *) src_p, sizeof (type)); \
        -:   57:      } \
        -:   58:    } \
        -:   59:    while (0)
        -:   60:
        -:   61:/**
        -:   62: * Copy a number from a value to the given buffer
        -:   63: **/
        -:   64:#define ECMA_TYPEDARRAY_SET_ELEMENT(src_p, num, type) \
        -:   65:    do \
        -:   66:    { \
        -:   67:      if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   68:      { \
        -:   69:        *(type *) ((void*) src_p) = num; \
        -:   70:      } \
        -:   71:      else \
        -:   72:      { \
        -:   73:        memcpy ((void*) src_p, &num, sizeof (type)); \
        -:   74:      } \
        -:   75:    } \
        -:   76:    while (0)
        -:   77:
        -:   78:/**
        -:   79: * Read an int8_t value from the given arraybuffer
        -:   80: */
        -:   81:static ecma_value_t
    #####:   82:ecma_typedarray_get_int8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   83:{
    #####:   84:  int8_t num = (int8_t) *src;
    #####:   85:  return ecma_make_integer_value (num);
        -:   86:} /* ecma_typedarray_get_int8_element */
        -:   87:
        -:   88:/**
        -:   89: * Read an uint8_t value from the given arraybuffer
        -:   90: */
        -:   91:static ecma_value_t
    #####:   92:ecma_typedarray_get_uint8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   93:{
    #####:   94:  uint8_t num = (uint8_t) *src;
    #####:   95:  return ecma_make_integer_value (num);
        -:   96:} /* ecma_typedarray_get_uint8_element */
        -:   97:
        -:   98:/**
        -:   99: * Read an int16_t value from the given arraybuffer
        -:  100: */
        -:  101:static ecma_value_t
    #####:  102:ecma_typedarray_get_int16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  103:{
    #####:  104:  int16_t num;
    #####:  105:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int16_t);
    #####:  106:  return ecma_make_integer_value (num);
        -:  107:} /* ecma_typedarray_get_int16_element */
        -:  108:
        -:  109:/**
        -:  110: * Read an uint16_t value from the given arraybuffer
        -:  111: */
        -:  112:static ecma_value_t
    #####:  113:ecma_typedarray_get_uint16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  114:{
    #####:  115:  uint16_t num;
    #####:  116:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint16_t);
    #####:  117:  return ecma_make_integer_value (num);
        -:  118:} /* ecma_typedarray_get_uint16_element */
        -:  119:
        -:  120:/**
        -:  121: * Read an int32_t value from the given arraybuffer
        -:  122: */
        -:  123:static ecma_value_t
    #####:  124:ecma_typedarray_get_int32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  125:{
    #####:  126:  int32_t num;
    #####:  127:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int32_t);
    #####:  128:  return ecma_make_number_value (num);
        -:  129:} /* ecma_typedarray_get_int32_element */
        -:  130:
        -:  131:/**
        -:  132: * Read an uint32_t value from the given arraybuffer
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_typedarray_get_uint32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  136:{
    #####:  137:  uint32_t num;
    #####:  138:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint32_t);
    #####:  139:  return ecma_make_number_value (num);
        -:  140:} /* ecma_typedarray_get_uint32_element */
        -:  141:
        -:  142:/**
        -:  143: * Read a float value from the given arraybuffer
        -:  144: */
        -:  145:static ecma_value_t
    #####:  146:ecma_typedarray_get_float_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  147:{
    #####:  148:  float num;
    #####:  149:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, float);
    #####:  150:  return ecma_make_number_value (num);
        -:  151:} /* ecma_typedarray_get_float_element */
        -:  152:
        -:  153:/**
        -:  154: * Read a double value from the given arraybuffer
        -:  155: */
        -:  156:static ecma_value_t
    #####:  157:ecma_typedarray_get_double_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  158:{
    #####:  159:  double num;
    #####:  160:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, double);
    #####:  161:  return ecma_make_number_value (num);
        -:  162:} /* ecma_typedarray_get_double_element */
        -:  163:
        -:  164:#if JERRY_BUILTIN_BIGINT
        -:  165:/**
        -:  166: * Read a bigint64 value from the given arraybuffer
        -:  167: */
        -:  168:static ecma_value_t
    #####:  169:ecma_typedarray_get_bigint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  170:{
    #####:  171:  uint64_t num;
    #####:  172:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  173:  bool sign = (num >> 63) != 0;
        -:  174:
    #####:  175:  if (sign)
        -:  176:  {
    #####:  177:    num = (uint64_t) (-(int64_t) num);
        -:  178:  }
        -:  179:
    #####:  180:  return ecma_bigint_create_from_digits (&num, 1, sign);
        -:  181:} /* ecma_typedarray_get_bigint64_element */
        -:  182:
        -:  183:/**
        -:  184: * Read a biguint64 value from the given arraybuffer
        -:  185: */
        -:  186:static ecma_value_t
    #####:  187:ecma_typedarray_get_biguint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  188:{
    #####:  189:  uint64_t num;
    #####:  190:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  191:  return ecma_bigint_create_from_digits (&num, 1, false);
        -:  192:} /* ecma_typedarray_get_biguint64_element */
        -:  193:#endif /* JERRY_BUILTIN_BIGINT */
        -:  194:
        -:  195:/**
        -:  196: * Normalize the given ecma_number_t to an uint32_t value
        -:  197: */
        -:  198:static uint32_t
    #####:  199:ecma_typedarray_setter_number_to_uint32 (ecma_number_t value) /**< the number value to normalize */
        -:  200:{
    #####:  201:  uint32_t uint32_value = 0;
        -:  202:
    #####:  203:  if (!ecma_number_is_nan (value) && !ecma_number_is_infinity (value))
        -:  204:  {
    #####:  205:    bool is_negative = false;
        -:  206:
    #####:  207:    if (value < 0)
        -:  208:    {
    #####:  209:      is_negative = true;
    #####:  210:      value = -value;
        -:  211:    }
        -:  212:
    #####:  213:    if (value > ((ecma_number_t) 0xffffffff))
        -:  214:    {
    #####:  215:      value = (ecma_number_t) (fmod (value, (ecma_number_t) 0x100000000));
        -:  216:    }
        -:  217:
    #####:  218:    uint32_value = (uint32_t) value;
        -:  219:
    #####:  220:    if (is_negative)
        -:  221:    {
    #####:  222:      uint32_value = (uint32_t) (-(int32_t) uint32_value);
        -:  223:    }
        -:  224:  }
        -:  225:
    #####:  226:  return uint32_value;
        -:  227:} /* ecma_typedarray_setter_number_to_uint32 */
        -:  228:
        -:  229:/**
        -:  230: * Write an int8_t value into the given arraybuffer
        -:  231: *
        -:  232: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  233: *         ECMA_VALUE_TRUE - otherwise
        -:  234: */
        -:  235:static ecma_value_t
    #####:  236:ecma_typedarray_set_int8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  237:                                  ecma_value_t value) /**< the number value to set */
        -:  238:{
    #####:  239:  ecma_number_t result_num;
    #####:  240:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  241:
    #####:  242:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  243:  {
    #####:  244:    return to_num;
        -:  245:  }
        -:  246:
    #####:  247:  int8_t num = (int8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  248:  *dst_p = (lit_utf8_byte_t) num;
    #####:  249:  return ECMA_VALUE_TRUE;
        -:  250:} /* ecma_typedarray_set_int8_element */
        -:  251:
        -:  252:/**
        -:  253: * Write an uint8_t value into the given arraybuffer
        -:  254: *
        -:  255: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  256: *         ECMA_VALUE_TRUE - otherwise
        -:  257: */
        -:  258:static ecma_value_t
    #####:  259:ecma_typedarray_set_uint8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  260:                                   ecma_value_t value) /**< the number value to set */
        -:  261:{
    #####:  262:  ecma_number_t result_num;
    #####:  263:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  264:
    #####:  265:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  266:  {
    #####:  267:    return to_num;
        -:  268:  }
        -:  269:
    #####:  270:  uint8_t num = (uint8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  271:  *dst_p = (lit_utf8_byte_t) num;
    #####:  272:  return ECMA_VALUE_TRUE;
        -:  273:} /* ecma_typedarray_set_uint8_element */
        -:  274:
        -:  275:/**
        -:  276: * Write an uint8_t clamped value into the given arraybuffer
        -:  277: *
        -:  278: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  279: *         ECMA_VALUE_TRUE - otherwise
        -:  280: */
        -:  281:static ecma_value_t
    #####:  282:ecma_typedarray_set_uint8_clamped_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  283:                                           ecma_value_t value) /**< the number value to set */
        -:  284:{
    #####:  285:  ecma_number_t result_num;
    #####:  286:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  287:
    #####:  288:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  289:  {
    #####:  290:    return to_num;
        -:  291:  }
        -:  292:
        -:  293:  uint8_t clamped;
        -:  294:
    #####:  295:  if (result_num > 255)
        -:  296:  {
    #####:  297:    clamped = 255;
        -:  298:  }
    #####:  299:  else if (result_num <= 0)
        -:  300:  {
    #####:  301:    clamped = 0;
        -:  302:  }
        -:  303:  else
        -:  304:  {
    #####:  305:    clamped = (uint8_t) result_num;
        -:  306:
    #####:  307:    if (clamped + 0.5 < result_num
    #####:  308:        || (clamped + 0.5 == result_num && (clamped % 2) == 1))
        -:  309:    {
    #####:  310:      clamped ++;
        -:  311:    }
        -:  312:  }
        -:  313:
    #####:  314:  *dst_p = (lit_utf8_byte_t) clamped;
    #####:  315:  return ECMA_VALUE_TRUE;
        -:  316:} /* ecma_typedarray_set_uint8_clamped_element */
        -:  317:
        -:  318:/**
        -:  319: * Write an int16_t value into the given arraybuffer
        -:  320: *
        -:  321: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  322: *         ECMA_VALUE_TRUE - otherwise
        -:  323: */
        -:  324:static ecma_value_t
    #####:  325:ecma_typedarray_set_int16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  326:                                   ecma_value_t value) /**< the number value to set */
        -:  327:{
    #####:  328:  ecma_number_t resut_num;
    #####:  329:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  330:
    #####:  331:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  332:  {
    #####:  333:    return to_num;
        -:  334:  }
        -:  335:
    #####:  336:  int16_t num = (int16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  337:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int16_t);
    #####:  338:  return ECMA_VALUE_TRUE;
        -:  339:} /* ecma_typedarray_set_int16_element */
        -:  340:
        -:  341:/**
        -:  342: * Write an uint8_t value into the given arraybuffer
        -:  343: *
        -:  344: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  345: *         ECMA_VALUE_TRUE - otherwise
        -:  346: */
        -:  347:static ecma_value_t
    #####:  348:ecma_typedarray_set_uint16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  349:                                    ecma_value_t value) /**< the number value to set */
        -:  350:{
    #####:  351:  ecma_number_t resut_num;
    #####:  352:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  353:
    #####:  354:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  355:  {
    #####:  356:    return to_num;
        -:  357:  }
        -:  358:
    #####:  359:  uint16_t num = (uint16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  360:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint16_t);
    #####:  361:  return ECMA_VALUE_TRUE;
        -:  362:} /* ecma_typedarray_set_uint16_element */
        -:  363:
        -:  364:/**
        -:  365: * Write an int32_t value into the given arraybuffer
        -:  366: *
        -:  367: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  368: *         ECMA_VALUE_TRUE - otherwise
        -:  369: */
        -:  370:static ecma_value_t
    #####:  371:ecma_typedarray_set_int32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  372:                                   ecma_value_t value) /**< the number value to set */
        -:  373:{
    #####:  374:  ecma_number_t resut_num;
    #####:  375:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  376:
    #####:  377:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  378:  {
    #####:  379:    return to_num;
        -:  380:  }
        -:  381:
    #####:  382:  int32_t num = (int32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  383:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int32_t);
    #####:  384:  return ECMA_VALUE_TRUE;
        -:  385:} /* ecma_typedarray_set_int32_element */
        -:  386:
        -:  387:/**
        -:  388: * Write an uint32_t value into the given arraybuffer
        -:  389: *
        -:  390: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  391: *         ECMA_VALUE_TRUE - otherwise
        -:  392: */
        -:  393:static ecma_value_t
    #####:  394:ecma_typedarray_set_uint32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  395:                                    ecma_value_t value) /**< the number value to set */
        -:  396:{
    #####:  397:  ecma_number_t resut_num;
    #####:  398:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  399:
    #####:  400:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  401:  {
    #####:  402:    return to_num;
        -:  403:  }
        -:  404:
    #####:  405:  uint32_t num = (uint32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  406:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint32_t);
    #####:  407:  return ECMA_VALUE_TRUE;
        -:  408:} /* ecma_typedarray_set_uint32_element */
        -:  409:
        -:  410:/**
        -:  411: * Write a float value into the given arraybuffer
        -:  412: *
        -:  413: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  414: *         ECMA_VALUE_TRUE - otherwise
        -:  415: */
        -:  416:static ecma_value_t
    #####:  417:ecma_typedarray_set_float_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  418:                                   ecma_value_t value) /**< the number value to set */
        -:  419:{
    #####:  420:  ecma_number_t result_num;
    #####:  421:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  422:
    #####:  423:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  424:  {
    #####:  425:    return to_num;
        -:  426:  }
        -:  427:
    #####:  428:  float num = (float) result_num;
    #####:  429:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, float);
    #####:  430:  return ECMA_VALUE_TRUE;
        -:  431:} /* ecma_typedarray_set_float_element */
        -:  432:
        -:  433:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  434:/**
        -:  435: * Write a double value into the given arraybuffer
        -:  436: *
        -:  437: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  438: *         ECMA_VALUE_TRUE - otherwise
        -:  439: */
        -:  440:static ecma_value_t
    #####:  441:ecma_typedarray_set_double_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  442:                                    ecma_value_t value) /**< the number value to set */
        -:  443:{
    #####:  444:  ecma_number_t result_num;
    #####:  445:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  446:
    #####:  447:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  448:  {
    #####:  449:    return to_num;
        -:  450:  }
        -:  451:
    #####:  452:  double num = (double) result_num;
    #####:  453:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, double);
    #####:  454:  return ECMA_VALUE_TRUE;
        -:  455:} /* ecma_typedarray_set_double_element */
        -:  456:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  457:
        -:  458:#if JERRY_BUILTIN_BIGINT
        -:  459:/**
        -:  460: * Write a bigint64/biguint64 value into the given arraybuffer
        -:  461: *
        -:  462: * @return ECMA_VALUE_ERROR - if the ToBigInt operation fails
        -:  463: *         ECMA_VALUE_TRUE - otherwise
        -:  464: */
        -:  465:static ecma_value_t
    #####:  466:ecma_typedarray_set_bigint_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  467:                                    ecma_value_t value) /**< the bigint value to set */
        -:  468:{
    #####:  469:  ecma_value_t bigint = ecma_bigint_to_bigint (value, false);
        -:  470:
    #####:  471:  if (ECMA_IS_VALUE_ERROR (bigint))
        -:  472:  {
    #####:  473:    return bigint;
        -:  474:  }
        -:  475:
    #####:  476:  uint64_t num;
    #####:  477:  bool sign;
    #####:  478:  ecma_bigint_get_digits_and_sign (bigint, &num, 1, &sign);
        -:  479:
    #####:  480:  if (sign)
        -:  481:  {
    #####:  482:    num = (uint64_t) (-(int64_t) num);
        -:  483:  }
        -:  484:
    #####:  485:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint64_t);
        -:  486:
    #####:  487:  ecma_free_value (bigint);
        -:  488:
    #####:  489:  return ECMA_VALUE_TRUE;
        -:  490:} /* ecma_typedarray_set_bigint_element */
        -:  491:#endif /* JERRY_BUILTIN_BIGINT */
        -:  492:
        -:  493:/**
        -:  494: * Builtin id of the first %TypedArray% builtin routine intrinsic object
        -:  495: */
        -:  496:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_INT8ARRAY
        -:  497:
        -:  498:#if JERRY_BUILTIN_BIGINT
        -:  499:/**
        -:  500: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  501: */
        -:  502:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_BIGUINT64ARRAY
        -:  503:#elif !JERRY_BUILTIN_BIGINT && JERRY_NUMBER_TYPE_FLOAT64
        -:  504:/**
        -:  505: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  506: */
        -:  507:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT64ARRAY
        -:  508:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  509:/**
        -:  510: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  511: */
        -:  512:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT32ARRAY
        -:  513:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  514:
        -:  515:/**
        -:  516: * Builtin id of the first %TypedArray% builtin prototype intrinsic object
        -:  517: */
        -:  518:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE
        -:  519:
        -:  520:/**
        -:  521: * List of typedarray getters based on their builtin id
        -:  522: */
        -:  523:static const ecma_typedarray_getter_fn_t ecma_typedarray_getters[] =
        -:  524:{
        -:  525:  ecma_typedarray_get_int8_element,   /**< Int8Array */
        -:  526:  ecma_typedarray_get_uint8_element,  /**< Uint8Array */
        -:  527:  ecma_typedarray_get_uint8_element,  /**< Uint8ClampedArray */
        -:  528:  ecma_typedarray_get_int16_element,  /**< Int16Array */
        -:  529:  ecma_typedarray_get_uint16_element, /**< Int32Array */
        -:  530:  ecma_typedarray_get_int32_element,  /**< Uint32Array */
        -:  531:  ecma_typedarray_get_uint32_element, /**< Uint32Array */
        -:  532:  ecma_typedarray_get_float_element,  /**< Float32Array */
        -:  533:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  534:  ecma_typedarray_get_double_element, /**< Float64Array */
        -:  535:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  536:#if JERRY_BUILTIN_BIGINT
        -:  537:  ecma_typedarray_get_bigint64_element,  /**< BigInt64Array*/
        -:  538:  ecma_typedarray_get_biguint64_element, /**< BigUint64Array */
        -:  539:#endif /* JERRY_BUILTIN_BIGINT */
        -:  540:};
        -:  541:
        -:  542:/**
        -:  543: * List of typedarray setters based on their builtin id
        -:  544: */
        -:  545:static const ecma_typedarray_setter_fn_t ecma_typedarray_setters[] =
        -:  546:{
        -:  547:  ecma_typedarray_set_int8_element,          /**< Int8Array */
        -:  548:  ecma_typedarray_set_uint8_element,         /**< Uint8Array */
        -:  549:  ecma_typedarray_set_uint8_clamped_element, /**< Uint8ClampedArray */
        -:  550:  ecma_typedarray_set_int16_element,         /**< Int16Array */
        -:  551:  ecma_typedarray_set_uint16_element,        /**< Int32Array */
        -:  552:  ecma_typedarray_set_int32_element,         /**< Uint32Array */
        -:  553:  ecma_typedarray_set_uint32_element,        /**< Uint32Array */
        -:  554:  ecma_typedarray_set_float_element,         /**< Float32Array */
        -:  555:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  556:  ecma_typedarray_set_double_element,        /**< Float64Array */
        -:  557:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  558:#if JERRY_BUILTIN_BIGINT
        -:  559:  ecma_typedarray_set_bigint_element,      /**< BigInt64Array */
        -:  560:  ecma_typedarray_set_bigint_element,     /**< BigUInt64Array */
        -:  561:#endif /* JERRY_BUILTIN_BIGINT */
        -:  562:};
        -:  563:
        -:  564:/**
        -:  565: * List of typedarray element shift sizes based on their builtin id
        -:  566: */
        -:  567:static const uint8_t ecma_typedarray_element_shift_sizes[] =
        -:  568:{
        -:  569:  0, /**< Int8Array */
        -:  570:  0, /**< Uint8Array */
        -:  571:  0, /**< Uint8ClampedArray */
        -:  572:  1, /**< Int16Array */
        -:  573:  1, /**< Uint16Array */
        -:  574:  2, /**< Int32Array */
        -:  575:  2, /**< Uint32Array */
        -:  576:  2, /**< Float32Array */
        -:  577:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  578:  3, /**< Float64Array */
        -:  579:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  580:#if JERRY_BUILTIN_BIGINT
        -:  581:  3, /**< BigInt64Array */
        -:  582:  3, /**< BigUInt64Array */
        -:  583:#endif /* JERRY_BUILTIN_BIGINT */
        -:  584:};
        -:  585:
        -:  586:/**
        -:  587: * List of typedarray class magic strings based on their builtin id
        -:  588: */
        -:  589:static const uint16_t ecma_typedarray_magic_string_list[] =
        -:  590:{
        -:  591:  (uint16_t) LIT_MAGIC_STRING_INT8_ARRAY_UL,          /**< Int8Array */
        -:  592:  (uint16_t) LIT_MAGIC_STRING_UINT8_ARRAY_UL,         /**< Uint8Array */
        -:  593:  (uint16_t) LIT_MAGIC_STRING_UINT8_CLAMPED_ARRAY_UL, /**< Uint8ClampedArray */
        -:  594:  (uint16_t) LIT_MAGIC_STRING_INT16_ARRAY_UL,         /**< Int16Array */
        -:  595:  (uint16_t) LIT_MAGIC_STRING_UINT16_ARRAY_UL,        /**< Uint16Array */
        -:  596:  (uint16_t) LIT_MAGIC_STRING_INT32_ARRAY_UL,         /**< Int32Array */
        -:  597:  (uint16_t) LIT_MAGIC_STRING_UINT32_ARRAY_UL,        /**< Uint32Array */
        -:  598:  (uint16_t) LIT_MAGIC_STRING_FLOAT32_ARRAY_UL,       /**< Float32Array */
        -:  599:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  600:  (uint16_t) LIT_MAGIC_STRING_FLOAT64_ARRAY_UL,       /**< Float64Array */
        -:  601:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  602:#if JERRY_BUILTIN_BIGINT
        -:  603:  (uint16_t) LIT_MAGIC_STRING_BIGINT64_ARRAY_UL,      /**< BigInt64Array */
        -:  604:  (uint16_t) LIT_MAGIC_STRING_BIGUINT64_ARRAY_UL,     /**< BigUInt64Array */
        -:  605:#endif /* JERRY_BUILTIN_BIGINT */
        -:  606:};
        -:  607:
        -:  608:/**
        -:  609: * Get the magic string id of a typedarray
        -:  610: *
        -:  611: * @return magic string
        -:  612: */
        -:  613:extern inline lit_magic_string_id_t JERRY_ATTR_ALWAYS_INLINE
    #####:  614:ecma_get_typedarray_magic_string_id (ecma_typedarray_type_t typedarray_id)
        -:  615:{
    #####:  616:  return (lit_magic_string_id_t) ecma_typedarray_magic_string_list[typedarray_id];
        -:  617:} /* ecma_get_typedarray_magic_string_id */
        -:  618:
        -:  619:/**
        -:  620: * Get typedarray's getter function callback
        -:  621: *
        -:  622: * @return ecma_typedarray_getter_fn_t: the getter function for the given builtin TypedArray id
        -:  623: */
        -:  624:extern inline ecma_typedarray_getter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  625:ecma_get_typedarray_getter_fn (ecma_typedarray_type_t typedarray_id)
        -:  626:{
    #####:  627:  return ecma_typedarray_getters[typedarray_id];
        -:  628:} /* ecma_get_typedarray_getter_fn */
        -:  629:
        -:  630:/**
        -:  631: * get typedarray's element value
        -:  632: *
        -:  633: * @return ecma_number_t: the value of the element
        -:  634: */
        -:  635:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  636:ecma_get_typedarray_element (ecma_typedarray_info_t *info_p,
        -:  637:                             ecma_number_t num)
        -:  638:{
    #####:  639:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  640:  {
    #####:  641:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  642:  }
        -:  643:
    #####:  644:  if (!ecma_op_is_integer (num)
    #####:  645:      || num >= info_p->length
    #####:  646:      || num < 0
    #####:  647:      || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -:  648:  {
    #####:  649:    return ECMA_VALUE_UNDEFINED;
        -:  650:  }
    #####:  651:  uint32_t byte_pos = (uint32_t) num << info_p->shift;
    #####:  652:  return ecma_typedarray_getters[info_p->id](info_p->buffer_p + byte_pos);
        -:  653:} /* ecma_get_typedarray_element */
        -:  654:
        -:  655:/**
        -:  656: * Get typedarray's setter function callback
        -:  657: *
        -:  658: * @return ecma_typedarray_setter_fn_t: the setter function for the given builtin TypedArray id
        -:  659: */
        -:  660:extern inline ecma_typedarray_setter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  661:ecma_get_typedarray_setter_fn (ecma_typedarray_type_t typedarray_id)
        -:  662:{
    #####:  663:  return ecma_typedarray_setters[typedarray_id];
        -:  664:} /* ecma_get_typedarray_setter_fn */
        -:  665:
        -:  666:/**
        -:  667: * set typedarray's element value
        -:  668: */
        -:  669:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  670:ecma_set_typedarray_element (ecma_typedarray_info_t *info_p,
        -:  671:                             ecma_value_t value,
        -:  672:                             ecma_number_t num)
        -:  673:{
        -:  674:  ecma_value_t to_num;
    #####:  675:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -:  676:  {
    #####:  677:    to_num = ecma_bigint_to_bigint (value, false);
        -:  678:
    #####:  679:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  680:    {
    #####:  681:      return to_num;
        -:  682:    }
        -:  683:  }
        -:  684:  else
        -:  685:  {
    #####:  686:    ecma_number_t result_num;
    #####:  687:    to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  688:
    #####:  689:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  690:    {
    #####:  691:      return to_num;
        -:  692:    }
        -:  693:  }
        -:  694:
    #####:  695:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  696:  {
    #####:  697:    ecma_free_value (to_num);
    #####:  698:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  699:  }
        -:  700:
    #####:  701:  if (!ecma_op_is_integer (num)
    #####:  702:      || num >= info_p->length
    #####:  703:      || num < 0
    #####:  704:      || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -:  705:  {
    #####:  706:    ecma_free_value (to_num);
    #####:  707:    return ECMA_VALUE_FALSE;
        -:  708:  }
    #####:  709:  ecma_free_value (to_num);
    #####:  710:  lit_utf8_byte_t *src_buffer = info_p->buffer_p + ((uint32_t) num << info_p->shift);
    #####:  711:  return ecma_typedarray_setters[info_p->id](src_buffer, value);
        -:  712:} /* ecma_set_typedarray_element */
        -:  713:
        -:  714:/**
        -:  715: * Get the element shift size of a TypedArray type.
        -:  716: *
        -:  717: * @return uint8_t
        -:  718: */
        -:  719:extern inline uint8_t JERRY_ATTR_ALWAYS_INLINE
    #####:  720:ecma_typedarray_helper_get_shift_size (ecma_typedarray_type_t typedarray_id)
        -:  721:{
    #####:  722:  return ecma_typedarray_element_shift_sizes[typedarray_id];
        -:  723:} /* ecma_typedarray_helper_get_shift_size */
        -:  724:
        -:  725:/**
        -:  726: * Check if the builtin is a TypedArray type.
        -:  727: *
        -:  728: * @return bool: - true if based on the given id it is a TypedArray
        -:  729: *               - false if based on the given id it is not a TypedArray
        -:  730: */
        -:  731:bool
    #####:  732:ecma_typedarray_helper_is_typedarray (ecma_builtin_id_t builtin_id) /**< the builtin id of a type **/
        -:  733:{
        -:  734:  return ((builtin_id >= ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID)
    #####:  735:          && (builtin_id <= ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID));
        -:  736:} /* ecma_typedarray_helper_is_typedarray */
        -:  737:
        -:  738:/**
        -:  739: * Get the prototype ID of a TypedArray type.
        -:  740: *
        -:  741: * @return ecma_builtin_id_t
        -:  742: */
        -:  743:ecma_builtin_id_t
    #####:  744:ecma_typedarray_helper_get_prototype_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  745:{
    #####:  746:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID + typedarray_id);
        -:  747:} /* ecma_typedarray_helper_get_prototype_id */
        -:  748:
        -:  749:/**
        -:  750: * Get the constructor ID of a TypedArray type.
        -:  751: *
        -:  752: * @return ecma_builtin_id_t
        -:  753: */
        -:  754:ecma_builtin_id_t
    #####:  755:ecma_typedarray_helper_get_constructor_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  756:{
    #####:  757:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID + typedarray_id);
        -:  758:} /* ecma_typedarray_helper_get_constructor_id */
        -:  759:
        -:  760:/**
        -:  761: * Get the built-in TypedArray type of the given object.
        -:  762: *
        -:  763: * @return ecma_typedarray_type_t
        -:  764: */
        -:  765:ecma_typedarray_type_t
    #####:  766:ecma_get_typedarray_id (ecma_object_t *obj_p) /**< typedarray object **/
        -:  767:{
    #####:  768:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -:  769:
    #####:  770:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  771:
    #####:  772:  return (ecma_typedarray_type_t) ext_object_p->u.cls.u1.typedarray_type;
        -:  773:} /* ecma_get_typedarray_id */
        -:  774:
        -:  775:/**
        -:  776: * Get the built-in TypedArray type of the given object.
        -:  777: *
        -:  778: * @return ecma_typedarray_type_t
        -:  779: */
        -:  780:ecma_typedarray_type_t
    #####:  781:ecma_typedarray_helper_builtin_to_typedarray_id (ecma_builtin_id_t builtin_id)
        -:  782:{
    #####:  783:  JERRY_ASSERT (ecma_typedarray_helper_is_typedarray (builtin_id));
        -:  784:
    #####:  785:  return (ecma_typedarray_type_t) (builtin_id - ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID);
        -:  786:} /* ecma_typedarray_helper_builtin_to_typedarray_id */
        -:  787:
        -:  788:/**
        -:  789: * Create a TypedArray object by given array_length
        -:  790: *
        -:  791: * See also: ES2015 22.2.1.2.1
        -:  792: *
        -:  793: * @return ecma value of the new typedarray object
        -:  794: *         Returned value must be freed with ecma_free_value
        -:  795: */
        -:  796:ecma_value_t
    #####:  797:ecma_typedarray_create_object_with_length (uint32_t array_length, /**< length of the typedarray */
        -:  798:                                           ecma_object_t *src_buffer_p, /**< source buffer */
        -:  799:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  800:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  801:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  802:{
    #####:  803:  uint32_t byte_length = UINT32_MAX;
        -:  804:
    #####:  805:  if (array_length <= (UINT32_MAX >> element_size_shift))
        -:  806:  {
    #####:  807:    byte_length = array_length << element_size_shift;
        -:  808:  }
        -:  809:
    #####:  810:  if (byte_length > UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1)
        -:  811:  {
        -:  812:#if JERRY_ERROR_MESSAGES
    #####:  813:    ecma_value_t array_length_value = ecma_make_number_value (array_length);
        -:  814:
    #####:  815:    ecma_value_t result = ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE,
        -:  816:                                                                 "Invalid typed array length: %",
        -:  817:                                                                 array_length_value);
    #####:  818:    ecma_free_value (array_length_value);
    #####:  819:    return result;
        -:  820:#else /* !JERRY_ERROR_MESSAGES */
        -:  821:    return ecma_raise_range_error (NULL);
        -:  822:#endif /* JERRY_ERROR_MESSAGES */
        -:  823:  }
        -:  824:
    #####:  825:  ecma_object_t *new_arraybuffer_p = NULL;
    #####:  826:  if (src_buffer_p == NULL)
        -:  827:  {
    #####:  828:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  829:  }
        -:  830:  else
        -:  831:  {
    #####:  832:    ecma_value_t ctor_proto = ecma_op_species_constructor (src_buffer_p, ECMA_BUILTIN_ID_ARRAYBUFFER);
    #####:  833:    if (ECMA_IS_VALUE_ERROR (ctor_proto))
        -:  834:    {
    #####:  835:      return ctor_proto;
        -:  836:    }
        -:  837:
    #####:  838:    ecma_object_t *ctor_proto_p = ecma_get_object_from_value (ctor_proto);
        -:  839:
    #####:  840:    ecma_object_t *prototype_p = ecma_op_get_prototype_from_constructor (ctor_proto_p,
        -:  841:                                                                         ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
        -:  842:
    #####:  843:    ecma_deref_object (ctor_proto_p);
        -:  844:
    #####:  845:    if (JERRY_UNLIKELY (prototype_p == NULL))
        -:  846:    {
    #####:  847:      return ECMA_VALUE_ERROR;
        -:  848:    }
        -:  849:
    #####:  850:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  851:
    #####:  852:    ECMA_SET_NON_NULL_POINTER (new_arraybuffer_p->u2.prototype_cp, prototype_p);
        -:  853:
    #####:  854:    ecma_deref_object (prototype_p);
        -:  855:
    #####:  856:    if (ecma_arraybuffer_is_detached (src_buffer_p))
        -:  857:    {
    #####:  858:      ecma_deref_object (new_arraybuffer_p);
    #####:  859:      return ecma_raise_type_error (ECMA_ERR_MSG ("Maximum TypedArray size is reached"));
        -:  860:    }
        -:  861:  }
        -:  862:
    #####:  863:  ecma_object_t *object_p = ecma_create_object (proto_p,
        -:  864:                                                sizeof (ecma_extended_object_t),
        -:  865:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  866:
    #####:  867:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  868:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
    #####:  869:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
    #####:  870:  ext_object_p->u.cls.u2.typedarray_flags = 0;
    #####:  871:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (new_arraybuffer_p);
        -:  872:
    #####:  873:  ecma_deref_object (new_arraybuffer_p);
        -:  874:
    #####:  875:  return ecma_make_object_value (object_p);
        -:  876:} /* ecma_typedarray_create_object_with_length */
        -:  877:
        -:  878:/**
        -:  879: * Create a TypedArray object by given buffer, offset, and array_length
        -:  880: *
        -:  881: * See also: ES2015 22.2.1.5
        -:  882: *
        -:  883: * @return ecma value of the new typedarray object
        -:  884: *         Returned value must be freed with ecma_free_value
        -:  885: */
        -:  886:static ecma_value_t
    #####:  887:ecma_typedarray_create_object_with_buffer (ecma_object_t *arraybuffer_p, /**< the arraybuffer inside */
        -:  888:                                           uint32_t byte_offset, /**< the byte offset of the arraybuffer */
        -:  889:                                           uint32_t array_length, /**< length of the typedarray */
        -:  890:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  891:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  892:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  893:{
    #####:  894:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  895:  {
    #####:  896:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  897:  }
    #####:  898:  uint32_t expected_length = (ecma_arraybuffer_get_length (arraybuffer_p) >> element_size_shift);
        -:  899:
    #####:  900:  bool needs_ext_typedarray_obj = (byte_offset != 0 || array_length != expected_length);
        -:  901:
    #####:  902:  size_t object_size = (needs_ext_typedarray_obj ? sizeof (ecma_extended_typedarray_object_t)
    #####:  903:                                                 : sizeof (ecma_extended_object_t));
        -:  904:
    #####:  905:  ecma_object_t *object_p = ecma_create_object (proto_p, object_size, ECMA_OBJECT_TYPE_CLASS);
        -:  906:
    #####:  907:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  908:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
    #####:  909:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
    #####:  910:  ext_object_p->u.cls.u2.typedarray_flags = 0;
    #####:  911:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (arraybuffer_p);
        -:  912:
    #####:  913:  if (needs_ext_typedarray_obj)
        -:  914:  {
    #####:  915:    ext_object_p->u.cls.u2.typedarray_flags |= ECMA_TYPEDARRAY_IS_EXTENDED;
        -:  916:
    #####:  917:    ecma_extended_typedarray_object_t *typedarray_info_p = (ecma_extended_typedarray_object_t *) object_p;
    #####:  918:    typedarray_info_p->array_length = array_length;
    #####:  919:    typedarray_info_p->byte_offset = byte_offset;
        -:  920:  }
        -:  921:
    #####:  922:  return ecma_make_object_value (object_p);
        -:  923:} /* ecma_typedarray_create_object_with_buffer */
        -:  924:
        -:  925:/**
        -:  926: * Create a TypedArray object by given another TypedArray object
        -:  927: *
        -:  928: * See also: ES2015 22.2.1.3
        -:  929: *
        -:  930: * @return ecma value of the new typedarray object
        -:  931: *         Returned value must be freed with ecma_free_value
        -:  932: */
        -:  933:static ecma_value_t
    #####:  934:ecma_typedarray_create_object_with_typedarray (ecma_object_t *typedarray_p, /**< a typedarray object */
        -:  935:                                               ecma_object_t *proto_p, /**< prototype object */
        -:  936:                                               uint8_t element_size_shift, /**< the size shift of the element length */
        -:  937:                                               ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  938:{
    #####:  939:  uint32_t array_length = ecma_typedarray_get_length (typedarray_p);
    #####:  940:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####:  941:  if (ecma_arraybuffer_is_detached (src_arraybuffer_p))
        -:  942:  {
    #####:  943:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid detached ArrayBuffer"));
        -:  944:  }
        -:  945:
    #####:  946:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (array_length,
        -:  947:                                                                           src_arraybuffer_p,
        -:  948:                                                                           proto_p,
        -:  949:                                                                           element_size_shift,
        -:  950:                                                                           typedarray_id);
        -:  951:
    #####:  952:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  953:  {
    #####:  954:    return new_typedarray;
        -:  955:  }
        -:  956:
    #####:  957:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
        -:  958:
    #####:  959:  lit_utf8_byte_t *src_buf_p = ecma_arraybuffer_get_buffer (src_arraybuffer_p);
        -:  960:
    #####:  961:  ecma_object_t *dst_arraybuffer_p = ecma_typedarray_get_arraybuffer (new_typedarray_p);
    #####:  962:  lit_utf8_byte_t *dst_buf_p = ecma_arraybuffer_get_buffer (dst_arraybuffer_p);
        -:  963:
    #####:  964:  src_buf_p += ecma_typedarray_get_offset (typedarray_p);
        -:  965:
    #####:  966:  ecma_typedarray_type_t src_id = ecma_get_typedarray_id (typedarray_p);
        -:  967:
    #####:  968:  if (src_id == typedarray_id)
        -:  969:  {
    #####:  970:    memcpy (dst_buf_p, src_buf_p, array_length << element_size_shift);
        -:  971:  }
        -:  972:  else
        -:  973:  {
        -:  974:#if JERRY_BUILTIN_BIGINT
    #####:  975:    if ((ECMA_TYPEDARRAY_IS_BIGINT_TYPE (src_id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (typedarray_id)) == 1)
        -:  976:    {
    #####:  977:      ecma_deref_object (new_typedarray_p);
    #####:  978:      return ecma_raise_type_error (ECMA_ERR_MSG ("Incompatible TypedArray types"));
        -:  979:    }
        -:  980:#endif /* JERRY_BUILTIN_BIGINT */
        -:  981:
    #####:  982:    uint32_t src_element_size = 1u << ecma_typedarray_get_element_size_shift (typedarray_p);
    #####:  983:    uint32_t dst_element_size = 1u << element_size_shift;
    #####:  984:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_id);
    #####:  985:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (typedarray_id);
        -:  986:
    #####:  987:    for (uint32_t i = 0; i < array_length; i++)
        -:  988:    {
        -:  989:      /* Convert values from source to destination format. */
    #####:  990:      ecma_value_t tmp = src_typedarray_getter_cb (src_buf_p);
    #####:  991:      ecma_value_t set_element = target_typedarray_setter_cb (dst_buf_p, tmp);
        -:  992:
    #####:  993:      ecma_free_value (tmp);
        -:  994:
    #####:  995:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  996:      {
    #####:  997:        ecma_deref_object (new_typedarray_p);
    #####:  998:        return set_element;
        -:  999:      }
        -: 1000:
    #####: 1001:      src_buf_p += src_element_size;
    #####: 1002:      dst_buf_p += dst_element_size;
        -: 1003:    }
        -: 1004:  }
        -: 1005:
    #####: 1006:  return new_typedarray;
        -: 1007:} /* ecma_typedarray_create_object_with_typedarray */
        -: 1008:
        -: 1009:/**
        -: 1010: * Helper method for ecma_op_typedarray_from
        -: 1011: *
        -: 1012: * @return ECMA_VALUE_TRUE - if setting the given value to the new typedarray was successful
        -: 1013: *         ECMA_VALUE_ERROR - otherwise
        -: 1014: */
        -: 1015:static ecma_value_t
    #####: 1016:ecma_op_typedarray_from_helper (ecma_value_t this_val, /**< this_arg for the above from function */
        -: 1017:                                ecma_value_t current_value, /**< given value to set */
        -: 1018:                                uint32_t index, /**< currrent index */
        -: 1019:                                ecma_object_t *func_object_p, /**< map function object */
        -: 1020:                                ecma_typedarray_info_t *info_p, /**< typedarray info */
        -: 1021:                                ecma_typedarray_setter_fn_t setter_cb) /**< setter callback function */
        -: 1022:{
        -: 1023:  ecma_value_t mapped_value;
        -: 1024:
    #####: 1025:  if (!ecma_is_value_found (current_value))
        -: 1026:  {
    #####: 1027:    current_value = ECMA_VALUE_UNDEFINED;
        -: 1028:  }
        -: 1029:
    #####: 1030:  if (func_object_p != NULL)
        -: 1031:  {
        -: 1032:    /* 17.d 17.f */
    #####: 1033:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####: 1034:    ecma_value_t call_args[] = { current_value, current_index };
        -: 1035:
    #####: 1036:    ecma_value_t cb_value = ecma_op_function_call (func_object_p, this_val, call_args, 2);
        -: 1037:
    #####: 1038:    ecma_free_value (current_value);
    #####: 1039:    ecma_free_value (current_index);
        -: 1040:
    #####: 1041:    if (ECMA_IS_VALUE_ERROR (cb_value))
        -: 1042:    {
    #####: 1043:      return cb_value;
        -: 1044:    }
        -: 1045:
    #####: 1046:    mapped_value = cb_value;
        -: 1047:  }
        -: 1048:  else
        -: 1049:  {
    #####: 1050:    mapped_value = current_value;
        -: 1051:  }
        -: 1052:
    #####: 1053:  if (index >= info_p->length)
        -: 1054:  {
    #####: 1055:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid argument type"));
        -: 1056:  }
        -: 1057:
    #####: 1058:  ecma_value_t set_element = setter_cb (info_p->buffer_p + (index << info_p->shift), mapped_value);
    #####: 1059:  ecma_free_value (mapped_value);
        -: 1060:
    #####: 1061:  if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1062:  {
    #####: 1063:    return set_element;
        -: 1064:  }
        -: 1065:
    #####: 1066:  return ECMA_VALUE_TRUE;
        -: 1067:} /* ecma_op_typedarray_from_helper */
        -: 1068:
        -: 1069:/**
        -: 1070: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1071: *
        -: 1072: * See also: ES11 22.2.4.4
        -: 1073: *
        -: 1074: * @return ecma value of the new typedarray object
        -: 1075: *         Returned value must be freed with ecma_free_value
        -: 1076: */
        -: 1077:ecma_value_t
    #####: 1078:ecma_typedarray_create_object_with_object (ecma_value_t items_val, /**< the source array-like object */
        -: 1079:                                           ecma_object_t *proto_p, /**< prototype object */
        -: 1080:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1081:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1082:{
        -: 1083:
        -: 1084:  /* 5 */
    #####: 1085:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (items_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1086:
    #####: 1087:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1088:  {
    #####: 1089:    return using_iterator;
        -: 1090:  }
        -: 1091:
        -: 1092:  /* 6 */
    #####: 1093:  if (!ecma_is_value_undefined (using_iterator))
        -: 1094:  {
        -: 1095:    /* 6.a */
    #####: 1096:    ecma_value_t next_method;
    #####: 1097:    ecma_value_t iterator = ecma_op_get_iterator (items_val, using_iterator, &next_method);
    #####: 1098:    ecma_free_value (using_iterator);
        -: 1099:
    #####: 1100:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1101:    {
    #####: 1102:      return iterator;
        -: 1103:    }
        -: 1104:
    #####: 1105:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1106:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1107:
        -: 1108:    while (true)
    #####: 1109:    {
    #####: 1110:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1111:
    #####: 1112:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1113:      {
    #####: 1114:        ret_value = next;
    #####: 1115:        break;
        -: 1116:      }
        -: 1117:
    #####: 1118:      if (next == ECMA_VALUE_FALSE)
        -: 1119:      {
    #####: 1120:        break;
        -: 1121:      }
        -: 1122:
    #####: 1123:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1124:      ecma_free_value (next);
        -: 1125:
    #####: 1126:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1127:      {
    #####: 1128:        ret_value = next_value;
    #####: 1129:        break;
        -: 1130:      }
        -: 1131:
    #####: 1132:      ecma_collection_push_back (values_p, next_value);
        -: 1133:    }
        -: 1134:
    #####: 1135:    ecma_free_value (iterator);
    #####: 1136:    ecma_free_value (next_method);
        -: 1137:
    #####: 1138:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1139:    {
    #####: 1140:      ecma_collection_free (values_p);
    #####: 1141:      return ret_value;
        -: 1142:    }
        -: 1143:
        -: 1144:    /* 8.c */
    #####: 1145:    ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (values_p->item_count,
        -: 1146:                                                                             NULL,
        -: 1147:                                                                             proto_p,
        -: 1148:                                                                             element_size_shift,
        -: 1149:                                                                             typedarray_id);
        -: 1150:
    #####: 1151:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1152:    {
    #####: 1153:      ecma_collection_free (values_p);
    #####: 1154:      return new_typedarray;
        -: 1155:    }
        -: 1156:
    #####: 1157:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1158:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1159:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1160:
    #####: 1161:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1162:
        -: 1163:    /* 8.e */
    #####: 1164:    for (uint32_t index = 0; index < values_p->item_count; index++)
        -: 1165:    {
    #####: 1166:      ecma_value_t set_value = ecma_op_typedarray_from_helper (ECMA_VALUE_UNDEFINED,
    #####: 1167:                                                               values_p->buffer_p[index],
        -: 1168:                                                               index,
        -: 1169:                                                               NULL,
        -: 1170:                                                               &info,
        -: 1171:                                                               setter_cb);
        -: 1172:
    #####: 1173:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1174:      {
    #####: 1175:        for (uint32_t j = index + 1; j < values_p->item_count; j++)
        -: 1176:        {
    #####: 1177:          ecma_free_value (values_p->buffer_p[j]);
        -: 1178:        }
        -: 1179:
    #####: 1180:        ret_value = set_value;
    #####: 1181:        break;
        -: 1182:      }
        -: 1183:    }
        -: 1184:
    #####: 1185:    ecma_collection_destroy (values_p);
        -: 1186:
    #####: 1187:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1188:    {
    #####: 1189:      ecma_deref_object (new_typedarray_p);
        -: 1190:    }
        -: 1191:
    #####: 1192:    return ret_value;
        -: 1193:  }
        -: 1194:
        -: 1195:  /* 8 */
    #####: 1196:  ecma_value_t arraylike_object_val = ecma_op_to_object (items_val);
        -: 1197:
    #####: 1198:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1199:  {
    #####: 1200:    return arraylike_object_val;
        -: 1201:  }
        -: 1202:
    #####: 1203:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1204:
        -: 1205:  /* 9 */
    #####: 1206:  ecma_length_t length_index;
    #####: 1207:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1208:
    #####: 1209:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1210:  {
    #####: 1211:    ecma_deref_object (arraylike_object_p);
    #####: 1212:    return len_value;
        -: 1213:  }
        -: 1214:
    #####: 1215:  if (length_index >= UINT32_MAX)
        -: 1216:  {
    #####: 1217:    ecma_deref_object (arraylike_object_p);
    #####: 1218:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid TypedArray length"));
        -: 1219:  }
        -: 1220:
    #####: 1221:  uint32_t len = (uint32_t) length_index;
        -: 1222:
        -: 1223:  /* 10 */
    #####: 1224:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (len,
        -: 1225:                                                                           NULL,
        -: 1226:                                                                           proto_p,
        -: 1227:                                                                           element_size_shift,
        -: 1228:                                                                           typedarray_id);
        -: 1229:
    #####: 1230:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1231:  {
    #####: 1232:    ecma_deref_object (arraylike_object_p);
    #####: 1233:    return new_typedarray;
        -: 1234:  }
        -: 1235:
    #####: 1236:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1237:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1238:  ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1239:  ecma_value_t ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1240:
        -: 1241:  /* 12 */
    #####: 1242:  for (uint32_t index = 0; index < len; index++)
        -: 1243:  {
    #####: 1244:    ecma_value_t current_value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1245:
    #####: 1246:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1247:    {
    #####: 1248:      ret_value = current_value;
    #####: 1249:      break;
        -: 1250:    }
        -: 1251:
    #####: 1252:    ecma_value_t set_value = ecma_op_typedarray_from_helper (ECMA_VALUE_UNDEFINED,
        -: 1253:                                                             current_value,
        -: 1254:                                                             index,
        -: 1255:                                                             NULL,
        -: 1256:                                                             &info,
        -: 1257:                                                             setter_cb);
        -: 1258:
    #####: 1259:    if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1260:    {
    #####: 1261:      ret_value = set_value;
    #####: 1262:      break;
        -: 1263:    }
        -: 1264:  }
        -: 1265:
    #####: 1266:  ecma_deref_object (arraylike_object_p);
        -: 1267:
    #####: 1268:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1269:  {
    #####: 1270:    ecma_deref_object (new_typedarray_p);
        -: 1271:  }
        -: 1272:
    #####: 1273:  return ret_value;
        -: 1274:} /* ecma_typedarray_create_object_with_object */
        -: 1275:
        -: 1276:/**
        -: 1277: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1278: *
        -: 1279: * See also: ES11 22.2.2.1
        -: 1280: *
        -: 1281: * @return ecma value of the new typedarray object
        -: 1282: *         Returned value must be freed with ecma_free_value
        -: 1283: */
        -: 1284:ecma_value_t
    #####: 1285:ecma_op_typedarray_from (ecma_value_t this_val, /**< this value */
        -: 1286:                         ecma_value_t source_val, /**< source value */
        -: 1287:                         ecma_value_t map_fn_val, /**< mapped function value */
        -: 1288:                         ecma_value_t this_arg) /**< this argument */
        -: 1289:{
        -: 1290:  JERRY_UNUSED (this_arg);
        -: 1291:  /* 3 */
    #####: 1292:  JERRY_ASSERT (ecma_op_is_callable (map_fn_val) || ecma_is_value_undefined (map_fn_val));
        -: 1293:
        -: 1294:  /* 4 */
    #####: 1295:  ecma_object_t *func_object_p = NULL;
        -: 1296:
    #####: 1297:  if (!ecma_is_value_undefined (map_fn_val))
        -: 1298:  {
    #####: 1299:    func_object_p = ecma_get_object_from_value (map_fn_val);
        -: 1300:  }
        -: 1301:
        -: 1302:  /* 5 */
    #####: 1303:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (source_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1304:
    #####: 1305:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1306:  {
    #####: 1307:    return using_iterator;
        -: 1308:  }
        -: 1309:
        -: 1310:  /* 6 */
    #####: 1311:  if (!ecma_is_value_undefined (using_iterator))
        -: 1312:  {
        -: 1313:    /* 6.a */
    #####: 1314:    ecma_value_t next_method;
    #####: 1315:    ecma_value_t iterator = ecma_op_get_iterator (source_val, using_iterator, &next_method);
    #####: 1316:    ecma_free_value (using_iterator);
        -: 1317:
        -: 1318:    /* 6.b */
    #####: 1319:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1320:    {
    #####: 1321:      return iterator;
        -: 1322:    }
        -: 1323:
        -: 1324:    /* 6.c */
    #####: 1325:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1326:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1327:
        -: 1328:    /* 6.e */
        -: 1329:    while (true)
    #####: 1330:    {
    #####: 1331:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1332:
    #####: 1333:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1334:      {
    #####: 1335:        ret_value = next;
    #####: 1336:        break;
        -: 1337:      }
        -: 1338:
    #####: 1339:      if (next == ECMA_VALUE_FALSE)
        -: 1340:      {
    #####: 1341:        break;
        -: 1342:      }
        -: 1343:
    #####: 1344:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1345:      ecma_free_value (next);
        -: 1346:
    #####: 1347:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1348:      {
    #####: 1349:        ret_value = next_value;
    #####: 1350:        break;
        -: 1351:      }
        -: 1352:
    #####: 1353:      ecma_collection_push_back (values_p, next_value);
        -: 1354:    }
        -: 1355:
    #####: 1356:    ecma_free_value (iterator);
    #####: 1357:    ecma_free_value (next_method);
        -: 1358:
    #####: 1359:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1360:    {
    #####: 1361:      ecma_collection_free (values_p);
    #####: 1362:      return ret_value;
        -: 1363:    }
        -: 1364:
        -: 1365:    /* 6.c */
    #####: 1366:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1367:    ecma_value_t len_val = ecma_make_uint32_value (values_p->item_count);
    #####: 1368:    ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1369:    ecma_free_value (len_val);
        -: 1370:
    #####: 1371:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1372:    {
    #####: 1373:      ecma_collection_free (values_p);
    #####: 1374:      return new_typedarray;
        -: 1375:    }
        -: 1376:
    #####: 1377:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1378:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1379:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1380:
    #####: 1381:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1382:
        -: 1383:    /* 6.e */
    #####: 1384:    for (uint32_t index = 0; index < values_p->item_count; index++)
        -: 1385:    {
    #####: 1386:      ecma_value_t set_value = ecma_op_typedarray_from_helper (this_arg,
    #####: 1387:                                                               values_p->buffer_p[index],
        -: 1388:                                                               index,
        -: 1389:                                                               func_object_p,
        -: 1390:                                                               &info,
        -: 1391:                                                               setter_cb);
        -: 1392:
    #####: 1393:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1394:      {
    #####: 1395:        for (uint32_t j = index + 1; j < values_p->item_count; j++)
        -: 1396:        {
    #####: 1397:          ecma_free_value (values_p->buffer_p[j]);
        -: 1398:        }
        -: 1399:
    #####: 1400:        ret_value = set_value;
    #####: 1401:        break;
        -: 1402:      }
        -: 1403:    }
        -: 1404:
    #####: 1405:    ecma_collection_destroy (values_p);
        -: 1406:
    #####: 1407:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1408:    {
    #####: 1409:      ecma_deref_object (new_typedarray_p);
        -: 1410:    }
        -: 1411:
    #####: 1412:    return ret_value;
        -: 1413:  }
        -: 1414:
        -: 1415:  /* 8 */
    #####: 1416:  ecma_value_t arraylike_object_val = ecma_op_to_object (source_val);
        -: 1417:
    #####: 1418:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1419:  {
    #####: 1420:    return arraylike_object_val;
        -: 1421:  }
        -: 1422:
    #####: 1423:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1424:
        -: 1425:  /* 9 */
    #####: 1426:  ecma_length_t length_index;
    #####: 1427:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1428:
    #####: 1429:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1430:  {
    #####: 1431:    ecma_deref_object (arraylike_object_p);
    #####: 1432:    return len_value;
        -: 1433:  }
        -: 1434:
    #####: 1435:  if (length_index >= UINT32_MAX)
        -: 1436:  {
    #####: 1437:    ecma_deref_object (arraylike_object_p);
    #####: 1438:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid TypedArray length"));
        -: 1439:  }
        -: 1440:
    #####: 1441:  uint32_t len = (uint32_t) length_index;
        -: 1442:
        -: 1443:  /* 10 */
    #####: 1444:  ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1445:  ecma_value_t len_val = ecma_make_uint32_value (len);
    #####: 1446:  ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1447:  ecma_free_value (len_val);
        -: 1448:
    #####: 1449:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1450:  {
    #####: 1451:    ecma_deref_object (arraylike_object_p);
    #####: 1452:    return new_typedarray;
        -: 1453:  }
        -: 1454:
    #####: 1455:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1456:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1457:  ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1458:  ecma_value_t ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1459:
        -: 1460:  /* 12 */
    #####: 1461:  for (uint32_t index = 0; index < len; index++)
        -: 1462:  {
    #####: 1463:    ecma_value_t current_value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1464:
    #####: 1465:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1466:    {
    #####: 1467:      ret_value = current_value;
    #####: 1468:      break;
        -: 1469:    }
        -: 1470:
    #####: 1471:    ecma_value_t set_value = ecma_op_typedarray_from_helper (this_arg,
        -: 1472:                                                             current_value,
        -: 1473:                                                             index,
        -: 1474:                                                             func_object_p,
        -: 1475:                                                             &info,
        -: 1476:                                                             setter_cb);
        -: 1477:
    #####: 1478:    if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1479:    {
    #####: 1480:      ret_value = set_value;
    #####: 1481:      break;
        -: 1482:    }
        -: 1483:  }
        -: 1484:
    #####: 1485:  ecma_deref_object (arraylike_object_p);
        -: 1486:
    #####: 1487:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1488:  {
    #####: 1489:    ecma_deref_object (new_typedarray_p);
        -: 1490:  }
        -: 1491:
    #####: 1492:  return ret_value;
        -: 1493:} /* ecma_op_typedarray_from */
        -: 1494:
        -: 1495:/**
        -: 1496: * Get the arraybuffer of the typedarray object
        -: 1497: *
        -: 1498: * @return the pointer to the internal arraybuffer
        -: 1499: */
        -: 1500:extern inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE
    #####: 1501:ecma_typedarray_get_arraybuffer (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1502:{
    #####: 1503:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1504:
    #####: 1505:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1506:
    #####: 1507:  return ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
        -: 1508:} /* ecma_typedarray_get_arraybuffer */
        -: 1509:
        -: 1510:/**
        -: 1511: * Get the element size shift in the typedarray object
        -: 1512: *
        -: 1513: * @return the size shift of the element, size is 1 << shift
        -: 1514: */
        -: 1515:uint8_t
    #####: 1516:ecma_typedarray_get_element_size_shift (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1517:{
    #####: 1518:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1519:
    #####: 1520:  return ecma_typedarray_helper_get_shift_size (ecma_get_typedarray_id (typedarray_p));
        -: 1521:} /* ecma_typedarray_get_element_size_shift */
        -: 1522:
        -: 1523:/**
        -: 1524: * Get the array length of the typedarray object
        -: 1525: *
        -: 1526: * @return the array length
        -: 1527: */
        -: 1528:uint32_t
    #####: 1529:ecma_typedarray_get_length (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1530:{
    #####: 1531:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1532:
    #####: 1533:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1534:
    #####: 1535:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1536:  {
    #####: 1537:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
    #####: 1538:    ecma_extended_object_t *arraybuffer_object_p = (ecma_extended_object_t *) arraybuffer_p;
    #####: 1539:    uint32_t buffer_length = arraybuffer_object_p->u.cls.u3.length;
    #####: 1540:    uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        -: 1541:
    #####: 1542:    return buffer_length >> shift;
        -: 1543:  }
        -: 1544:
    #####: 1545:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1546:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1547:  {
    #####: 1548:    return 0;
        -: 1549:  }
        -: 1550:
    #####: 1551:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1552:
    #####: 1553:  return info_p->array_length;
        -: 1554:} /* ecma_typedarray_get_length */
        -: 1555:
        -: 1556:/**
        -: 1557: * Get the offset of the internal arraybuffer
        -: 1558: *
        -: 1559: * @return the offset
        -: 1560: */
        -: 1561:uint32_t
    #####: 1562:ecma_typedarray_get_offset (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1563:{
    #####: 1564:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1565:
    #####: 1566:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1567:
    #####: 1568:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1569:  {
    #####: 1570:    return 0;
        -: 1571:  }
        -: 1572:
    #####: 1573:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1574:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1575:  {
    #####: 1576:    return 0;
        -: 1577:  }
        -: 1578:
    #####: 1579:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1580:
    #####: 1581:  return info_p->byte_offset;
        -: 1582:} /* ecma_typedarray_get_offset */
        -: 1583:
        -: 1584:/**
        -: 1585: * Utility function: return the pointer of the data buffer referenced by the typed array
        -: 1586: *
        -: 1587: * @return pointer to the data buffer
        -: 1588: */
        -: 1589:lit_utf8_byte_t *
    #####: 1590:ecma_typedarray_get_buffer (ecma_object_t *typedarray_p) /**< the pointer to the typed array object */
        -: 1591:{
    #####: 1592:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1593:
    #####: 1594:  return ecma_arraybuffer_get_buffer (arraybuffer_p) + ecma_typedarray_get_offset (typedarray_p);
        -: 1595:} /* ecma_typedarray_get_buffer */
        -: 1596:
        -: 1597:/**
        -: 1598: * Create a new typedarray object.
        -: 1599: *
        -: 1600: * The struct of the typedarray object
        -: 1601: *   ecma_object_t
        -: 1602: *   extend_part
        -: 1603: *   typedarray_info
        -: 1604: *
        -: 1605: * @return ecma value of the new typedarray object
        -: 1606: *         Returned value must be freed with ecma_free_value
        -: 1607: */
        -: 1608:ecma_value_t
    #####: 1609:ecma_op_create_typedarray (const ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 1610:                           uint32_t arguments_list_len, /**< the length of the arguments_list_p */
        -: 1611:                           ecma_object_t *proto_p, /**< prototype object */
        -: 1612:                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1613:                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1614:{
    #####: 1615:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -: 1616:
    #####: 1617:  ecma_value_t ret = ECMA_VALUE_EMPTY;
        -: 1618:
    #####: 1619:  if (arguments_list_len == 0)
        -: 1620:  {
        -: 1621:    /* 22.2.1.1 */
    #####: 1622:    ret = ecma_typedarray_create_object_with_length (0, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1623:  }
    #####: 1624:  else if (!ecma_is_value_object (arguments_list_p[0]))
        -: 1625:  {
    #####: 1626:    ecma_number_t num = 0;
        -: 1627:
    #####: 1628:    if (!ecma_is_value_undefined (arguments_list_p[0])
    #####: 1629:        && ECMA_IS_VALUE_ERROR (ecma_op_to_index (arguments_list_p[0], &num)))
        -: 1630:    {
    #####: 1631:      return ECMA_VALUE_ERROR;
        -: 1632:    }
        -: 1633:
    #####: 1634:    JERRY_ASSERT (num >= 0 && num <= ECMA_NUMBER_MAX_SAFE_INTEGER);
        -: 1635:
    #####: 1636:    if (num > UINT32_MAX)
        -: 1637:    {
        -: 1638:#if JERRY_ERROR_MESSAGES
    #####: 1639:      ret = ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE,
        -: 1640:                                                   "Invalid typed array length: %",
        -: 1641:                                                   arguments_list_p[0]);
        -: 1642:#else /* !JERRY_ERROR_MESSAGES */
        -: 1643:      ret = ecma_raise_range_error (NULL);
        -: 1644:#endif /* JERRY_ERROR_MESSAGES */
        -: 1645:    }
        -: 1646:    else
        -: 1647:    {
    #####: 1648:      ret = ecma_typedarray_create_object_with_length ((uint32_t) num,
        -: 1649:                                                       NULL,
        -: 1650:                                                       proto_p,
        -: 1651:                                                       element_size_shift,
        -: 1652:                                                       typedarray_id);
        -: 1653:    }
        -: 1654:  }
    #####: 1655:  else if (ecma_is_value_object (arguments_list_p[0]))
        -: 1656:  {
    #####: 1657:    ecma_object_t *obj_p = ecma_get_object_from_value (arguments_list_p[0]);
    #####: 1658:    if (ecma_object_is_typedarray (obj_p))
        -: 1659:    {
        -: 1660:      /* 22.2.1.3 */
    #####: 1661:      ecma_object_t *typedarray_p = obj_p;
    #####: 1662:      ret = ecma_typedarray_create_object_with_typedarray (typedarray_p,
        -: 1663:                                                           proto_p,
        -: 1664:                                                           element_size_shift,
        -: 1665:                                                           typedarray_id);
        -: 1666:    }
    #####: 1667:    else if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####: 1668:             || ecma_object_is_shared_arraybuffer (obj_p))
    #####: 1669:    {
        -: 1670:      /* 22.2.1.5 */
    #####: 1671:      ecma_object_t *arraybuffer_p = obj_p;
    #####: 1672:      ecma_value_t arg2 = ((arguments_list_len > 1) ? arguments_list_p[1]
    #####: 1673:                                                    : ECMA_VALUE_UNDEFINED);
        -: 1674:
    #####: 1675:      ecma_value_t arg3 = ((arguments_list_len > 2) ? arguments_list_p[2]
    #####: 1676:                                                    : ECMA_VALUE_UNDEFINED);
        -: 1677:
    #####: 1678:      ecma_number_t offset;
    #####: 1679:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (arg2, &offset)))
        -: 1680:      {
    #####: 1681:        return ECMA_VALUE_ERROR;
        -: 1682:      }
        -: 1683:
    #####: 1684:      if (ecma_number_is_negative (offset) && ecma_number_is_zero (offset))
        -: 1685:      {
    #####: 1686:        offset = 0;
        -: 1687:      }
    #####: 1688:      if (ecma_number_is_negative (offset) || fmod (offset, (1 << element_size_shift)) != 0)
        -: 1689:      {
        -: 1690:        /* ES2015 22.2.1.5: 9 - 10. */
    #####: 1691:        ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -: 1692:      }
    #####: 1693:      else if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1694:      {
    #####: 1695:        ret = ecma_raise_type_error (ECMA_ERR_MSG ("Invalid detached ArrayBuffer"));
        -: 1696:      }
        -: 1697:      else
        -: 1698:      {
    #####: 1699:        uint32_t buf_byte_length = ecma_arraybuffer_get_length (arraybuffer_p);
    #####: 1700:        uint32_t new_byte_length = 0;
        -: 1701:
    #####: 1702:        if (ecma_is_value_undefined (arg3))
        -: 1703:        {
    #####: 1704:          if ((buf_byte_length % (uint32_t) (1 << element_size_shift) != 0)
    #####: 1705:              || (buf_byte_length < offset))
        -: 1706:          {
    #####: 1707:            ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid length"));
        -: 1708:          }
        -: 1709:          else
        -: 1710:          {
    #####: 1711:            new_byte_length = (uint32_t) (buf_byte_length - offset);
        -: 1712:          }
        -: 1713:        }
        -: 1714:        else
        -: 1715:        {
    #####: 1716:          ecma_number_t new_length;
    #####: 1717:          if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (arg3, &new_length)))
        -: 1718:          {
    #####: 1719:            return ECMA_VALUE_ERROR;
        -: 1720:          }
        -: 1721:
    #####: 1722:          if (new_length > (UINT32_MAX >> element_size_shift))
        -: 1723:          {
    #####: 1724:            ret = ecma_raise_range_error (ECMA_ERR_MSG ("Maximum TypedArray size is reached"));
        -: 1725:          }
        -: 1726:          else
        -: 1727:          {
    #####: 1728:            new_byte_length = (uint32_t) new_length << element_size_shift;
        -: 1729:
    #####: 1730:            if (((ecma_number_t) new_byte_length + offset) > buf_byte_length)
        -: 1731:            {
    #####: 1732:              ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid length"));
        -: 1733:            }
        -: 1734:          }
        -: 1735:        }
        -: 1736:
    #####: 1737:        if (ecma_is_value_empty (ret))
        -: 1738:        {
    #####: 1739:          uint32_t array_length = new_byte_length >> element_size_shift;
    #####: 1740:          ret = ecma_typedarray_create_object_with_buffer (arraybuffer_p,
        -: 1741:                                                           (uint32_t) offset,
        -: 1742:                                                           array_length,
        -: 1743:                                                           proto_p,
        -: 1744:                                                           element_size_shift,
        -: 1745:                                                           typedarray_id);
        -: 1746:        }
        -: 1747:      }
        -: 1748:    }
        -: 1749:    else
        -: 1750:    {
        -: 1751:      /* 22.2.1.4 */
    #####: 1752:      ret = ecma_typedarray_create_object_with_object (arguments_list_p[0],
        -: 1753:                                                       proto_p,
        -: 1754:                                                       element_size_shift,
        -: 1755:                                                       typedarray_id);
        -: 1756:    }
        -: 1757:  }
        -: 1758:
    #####: 1759:  return ret;
        -: 1760:} /* ecma_op_create_typedarray */
        -: 1761:
        -: 1762:/**
        -: 1763: * Helper function for typedArray.prototype object's {'keys', 'values', 'entries', '@@iterator'}
        -: 1764: * routines common parts.
        -: 1765: *
        -: 1766: * See also:
        -: 1767: *          ECMA-262 v6, 22.2.3.15
        -: 1768: *          ECMA-262 v6, 22.2.3.29
        -: 1769: *          ECMA-262 v6, 22.2.3.6
        -: 1770: *          ECMA-262 v6, 22.1.3.30
        -: 1771: *
        -: 1772: * Note:
        -: 1773: *      Returned value must be freed with ecma_free_value.
        -: 1774: *
        -: 1775: * @return iterator result object, if success
        -: 1776: *         error - otherwise
        -: 1777: */
        -: 1778:ecma_value_t
    #####: 1779:ecma_typedarray_iterators_helper (ecma_value_t this_arg, /**< this argument */
        -: 1780:                                  ecma_iterator_kind_t kind) /**< iterator kind */
        -: 1781:{
    #####: 1782:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
    #####: 1783:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -: 1784:
    #####: 1785:  return ecma_op_create_iterator_object (this_arg,
        -: 1786:                                         prototype_obj_p,
        -: 1787:                                         ECMA_OBJECT_CLASS_ARRAY_ITERATOR,
        -: 1788:                                         kind);
        -: 1789:} /* ecma_typedarray_iterators_helper */
        -: 1790:
        -: 1791:/**
        -: 1792: * Check if the object is typedarray
        -: 1793: *
        -: 1794: * @return true - if object is a TypedArray object
        -: 1795: *         false - otherwise
        -: 1796: */
        -: 1797:bool
        3: 1798:ecma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */
        -: 1799:{
        3: 1800:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -: 1801:
        3: 1802:  return ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_TYPEDARRAY);
        -: 1803:} /* ecma_object_is_typedarray */
        -: 1804:
        -: 1805:/**
        -: 1806: * Check if the value is typedarray
        -: 1807: *
        -: 1808: * @return true - if value is a TypedArray object
        -: 1809: *         false - otherwise
        -: 1810: */
        -: 1811:bool
    #####: 1812:ecma_is_typedarray (ecma_value_t value) /**< the target need to be checked */
        -: 1813:{
    #####: 1814:  if (!ecma_is_value_object (value))
        -: 1815:  {
    #####: 1816:    return false;
        -: 1817:  }
        -: 1818:
    #####: 1819:  return ecma_object_is_typedarray (ecma_get_object_from_value (value));
        -: 1820:} /* ecma_is_typedarray */
        -: 1821:
        -: 1822:/**
        -: 1823: * List names of a TypedArray object's integer indexed properties
        -: 1824: *
        -: 1825: * @return void
        -: 1826: */
        -: 1827:void
    #####: 1828:ecma_op_typedarray_list_lazy_property_names (ecma_object_t *obj_p, /**< a TypedArray object */
        -: 1829:                                             ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 1830:                                             ecma_property_counter_t *prop_counter_p,  /**< property counters */
        -: 1831:                                             jerry_property_filter_t filter) /**< property name filter options */
        -: 1832:{
    #####: 1833:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1834:
    #####: 1835:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
        -: 1836:  {
    #####: 1837:    return;
        -: 1838:  }
        -: 1839:
    #####: 1840:  uint32_t array_length = ecma_typedarray_get_length (obj_p);
        -: 1841:
    #####: 1842:  for (uint32_t i = 0; i < array_length; i++)
        -: 1843:  {
    #####: 1844:    ecma_string_t *name_p = ecma_new_ecma_string_from_uint32 (i);
    #####: 1845:    ecma_collection_push_back (prop_names_p, ecma_make_string_value (name_p));
        -: 1846:  }
        -: 1847:
    #####: 1848:  prop_counter_p->array_index_named_props += array_length;
        -: 1849:} /* ecma_op_typedarray_list_lazy_property_names */
        -: 1850:
        -: 1851:/**
        -: 1852: * [[DefineOwnProperty]] operation for TypedArray objects
        -: 1853: *
        -: 1854: * See also: ES2015 9.4.5.3
        -: 1855: *
        -: 1856: * @return ECMA_VALUE_TRUE - if the property is successfully defined
        -: 1857: *         ECMA_VALUE_FALSE - if is JERRY_PROP_SHOULD_THROW is not set
        -: 1858: *         raised TypeError - otherwise
        -: 1859: */
        -: 1860:ecma_value_t
    #####: 1861:ecma_op_typedarray_define_own_property (ecma_object_t *obj_p, /**< TypedArray object */
        -: 1862:                                        ecma_string_t *prop_name_p, /**< property name */
        -: 1863:                                        const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1864:{
    #####: 1865:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1866:
    #####: 1867:  if (!ecma_prop_name_is_symbol (prop_name_p))
        -: 1868:  {
    #####: 1869:    ecma_number_t num = ecma_string_to_number (prop_name_p);
        -: 1870:    bool is_same;
    #####: 1871:    if (num <= 0)
        -: 1872:    {
    #####: 1873:      is_same = true;
        -: 1874:    }
        -: 1875:    else
        -: 1876:    {
    #####: 1877:      ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####: 1878:      is_same = ecma_compare_ecma_strings (prop_name_p, num_to_str);
    #####: 1879:      ecma_deref_ecma_string (num_to_str);
        -: 1880:    }
        -: 1881:
    #####: 1882:    if (is_same)
        -: 1883:    {
    #####: 1884:      if ((property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
    #####: 1885:          || ((property_desc_p->flags & (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
        -: 1886:              == (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
    #####: 1887:          || ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
    #####: 1888:              && !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE))
    #####: 1889:          || ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
    #####: 1890:              && !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE)))
        -: 1891:      {
    #####: 1892:        return ecma_raise_property_redefinition (prop_name_p, property_desc_p->flags);
        -: 1893:      }
        -: 1894:
    #####: 1895:      ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -: 1896:
    #####: 1897:      if (!ecma_op_is_integer (num)
    #####: 1898:          || num >= info.length
    #####: 1899:          || num < 0
    #####: 1900:          || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -: 1901:      {
    #####: 1902:        return ECMA_VALUE_FALSE;
        -: 1903:      }
        -: 1904:
    #####: 1905:      if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1906:      {
    #####: 1907:        ecma_value_t set_element = ecma_set_typedarray_element (&info, property_desc_p->value, num);
        -: 1908:
    #####: 1909:        if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1910:        {
    #####: 1911:          return set_element;
        -: 1912:        }
        -: 1913:
        -: 1914:      }
        -: 1915:
    #####: 1916:      return ECMA_VALUE_TRUE;
        -: 1917:    }
        -: 1918:  }
        -: 1919:
    #####: 1920:  return ecma_op_general_object_define_own_property (obj_p, prop_name_p, property_desc_p);
        -: 1921:} /* ecma_op_typedarray_define_own_property */
        -: 1922:
        -: 1923:/**
        -: 1924: * Specify the creation of a new TypedArray
        -: 1925: * object using a constructor function.
        -: 1926: *
        -: 1927: * See also: ES11 22.2.4.6
        -: 1928: *
        -: 1929: * Used by:
        -: 1930: *        - ecma_typedarray_species_create
        -: 1931: *
        -: 1932: * @return ecma_value_t function object from created from constructor_p argument
        -: 1933: */
        -: 1934:
        -: 1935:ecma_value_t
    #####: 1936:ecma_typedarray_create (ecma_object_t *constructor_p, /**< constructor function */
        -: 1937:                        ecma_value_t *arguments_list_p, /**< argument list */
        -: 1938:                        uint32_t arguments_list_len) /**< length of argument list */
        -: 1939:{
    #####: 1940:  ecma_value_t ret_val = ecma_op_function_construct (constructor_p,
        -: 1941:                                                     constructor_p,
        -: 1942:                                                     arguments_list_p,
        -: 1943:                                                     arguments_list_len);
    #####: 1944:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -: 1945:  {
    #####: 1946:    return ret_val;
        -: 1947:  }
        -: 1948:
    #####: 1949:  if (!ecma_is_typedarray (ret_val))
        -: 1950:  {
    #####: 1951:    ecma_free_value (ret_val);
    #####: 1952:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constructed object is not TypedArray"));
        -: 1953:  }
        -: 1954:
    #####: 1955:  ecma_object_t *typedarray_p = ecma_get_object_from_value (ret_val);
        -: 1956:
    #####: 1957:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (ecma_get_object_from_value (ret_val));
    #####: 1958:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1959:  {
    #####: 1960:    ecma_deref_object (typedarray_p);
    #####: 1961:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1962:  }
        -: 1963:
    #####: 1964:  if ((arguments_list_len == 1) && (ecma_is_value_number (arguments_list_p[0])))
        -: 1965:  {
    #####: 1966:    ecma_number_t num = ecma_get_number_from_value (arguments_list_p[0]);
    #####: 1967:    ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1968:
    #####: 1969:    if (info.length < num)
        -: 1970:    {
    #####: 1971:      ecma_free_value (ret_val);
    #####: 1972:      return ecma_raise_type_error (ECMA_ERR_MSG ("Constructed TypedArray is smaller than filter call result"));
        -: 1973:    }
        -: 1974:  }
    #####: 1975:  return ret_val;
        -: 1976:} /* ecma_typedarray_create */
        -: 1977:
        -: 1978:/* Specify the creation of a new TypedArray object
        -: 1979: * using a constructor function that is derived from this_arg.
        -: 1980: *
        -: 1981: * See also: ES11 22.2.4.7
        -: 1982: *
        -: 1983: * @return ecma value of the new typedarray object, constructed by default or species constructor
        -: 1984: */
        -: 1985:ecma_value_t
    #####: 1986:ecma_typedarray_species_create (ecma_value_t this_arg, /**< this argument */
        -: 1987:                                ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 1988:                                uint32_t arguments_list_len) /**< length of the the arg list */
        -: 1989:{
    #####: 1990:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1991:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1992:
    #####: 1993:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
        -: 1994:
    #####: 1995:  ecma_builtin_id_t default_constructor = ecma_typedarray_helper_get_constructor_id (info.id);
        -: 1996:
    #####: 1997:  ecma_value_t constructor = ecma_op_species_constructor (typedarray_p, default_constructor);
        -: 1998:
    #####: 1999:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2000:  {
    #####: 2001:    return constructor;
        -: 2002:  }
        -: 2003:
    #####: 2004:  ecma_object_t *constructor_proto_p = ecma_get_object_from_value (constructor);
        -: 2005:
    #####: 2006:  ecma_value_t result = ecma_typedarray_create (constructor_proto_p, arguments_list_p, arguments_list_len);
    #####: 2007:  ecma_deref_object (constructor_proto_p);
        -: 2008:
    #####: 2009:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2010:  {
    #####: 2011:    return result;
        -: 2012:  }
        -: 2013:
        -: 2014:#if JERRY_BUILTIN_BIGINT
    #####: 2015:  ecma_object_t *result_p = ecma_get_object_from_value (result);
    #####: 2016:  ecma_typedarray_info_t result_info = ecma_typedarray_get_info (result_p);
        -: 2017:  /*
        -: 2018:   * Check result_info.id to to be either bigint type if info.id is one
        -: 2019:   * or be neither of them is info.id is none of them as well.
        -: 2020:   */
    #####: 2021:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info.id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (result_info.id))
        -: 2022:  {
    #####: 2023:    ecma_free_value (result);
    #####: 2024:    return ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray returned by [[ContentType]] does not match source"));
        -: 2025:  }
        -: 2026:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2027:
    #####: 2028:  return result;
        -: 2029:} /* ecma_typedarray_species_create */
        -: 2030:
        -: 2031:/**
        -: 2032: * Create a typedarray object based on the "type" and arraylength
        -: 2033: * The "type" is same with arg1
        -: 2034: *
        -: 2035: * @return ecma_value_t
        -: 2036: */
        -: 2037:ecma_value_t
    #####: 2038:ecma_op_create_typedarray_with_type_and_length (ecma_typedarray_type_t typedarray_id, /** TypedArray id  */
        -: 2039:                                                uint32_t array_length) /**< length of the typedarray */
        -: 2040:{
        -: 2041:  // TODO: assert validate typedarray_id
    #####: 2042:  ecma_object_t *proto_p = ecma_builtin_get (ecma_typedarray_helper_get_prototype_id (typedarray_id));
    #####: 2043:  uint8_t element_size_shift = ecma_typedarray_helper_get_shift_size (typedarray_id);
        -: 2044:
    #####: 2045:  ecma_value_t new_obj = ecma_typedarray_create_object_with_length (array_length,
        -: 2046:                                                                    NULL,
        -: 2047:                                                                    proto_p,
        -: 2048:                                                                    element_size_shift,
        -: 2049:                                                                    typedarray_id);
        -: 2050:
    #####: 2051:  return new_obj;
        -: 2052:} /* ecma_op_create_typedarray_with_type_and_length */
        -: 2053:
        -: 2054:/**
        -: 2055: * Method for getting the additional typedArray informations.
        -: 2056: */
        -: 2057:ecma_typedarray_info_t
    #####: 2058:ecma_typedarray_get_info (ecma_object_t *typedarray_p)
        -: 2059:{
        -: 2060:  ecma_typedarray_info_t info;
        -: 2061:
    #####: 2062:  info.id = ecma_get_typedarray_id (typedarray_p);
    #####: 2063:  info.length = ecma_typedarray_get_length (typedarray_p);
    #####: 2064:  info.shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 2065:  info.element_size = (uint8_t) (1 << info.shift);
    #####: 2066:  info.offset = ecma_typedarray_get_offset (typedarray_p);
    #####: 2067:  info.array_buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 2068:  info.buffer_p = ecma_arraybuffer_get_buffer (info.array_buffer_p) + info.offset;
        -: 2069:
    #####: 2070:  return info;
        -: 2071:} /* ecma_typedarray_get_info */
        -: 2072:
        -: 2073:/**
        -: 2074: * @}
        -: 2075: * @}
        -: 2076: */
        -: 2077:#endif /* JERRY_BUILTIN_TYPEDARRAY */
