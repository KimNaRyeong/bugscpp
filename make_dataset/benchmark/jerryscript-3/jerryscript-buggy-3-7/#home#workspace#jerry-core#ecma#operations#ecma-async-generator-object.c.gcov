        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-async-generator-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-async-generator-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-function-object.h"
        -:   21:#include "ecma-gc.h"
        -:   22:#include "ecma-globals.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "ecma-iterator-object.h"
        -:   25:#include "ecma-objects.h"
        -:   26:#include "ecma-promise-object.h"
        -:   27:#include "jcontext.h"
        -:   28:#include "opcodes.h"
        -:   29:#include "vm.h"
        -:   30:#include "vm-stack.h"
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:
        -:   34:/** \addtogroup ecma ECMA
        -:   35: * @{
        -:   36: *
        -:   37: * \addtogroup ecmaasyncgeneratorobject ECMA AsyncGenerator object related routines
        -:   38: * @{
        -:   39: */
        -:   40:
        -:   41:/**
        -:   42: * Enqueue a task into the command queue of an async generator
        -:   43: *
        -:   44: * @return ecma Promise value
        -:   45: *         Returned value must be freed with ecma_free_value.
        -:   46: */
        -:   47:ecma_value_t
    #####:   48:ecma_async_generator_enqueue (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:   49:                              ecma_async_generator_operation_type_t operation, /**< operation */
        -:   50:                              ecma_value_t value) /**< value argument of operation */
        -:   51:{
    #####:   52:  ecma_async_generator_task_t *task_p = jmem_heap_alloc_block (sizeof (ecma_async_generator_task_t));
        -:   53:
    #####:   54:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (task_p->next, NULL);
    #####:   55:  task_p->operation_value = ecma_copy_value_if_not_object (value);
    #####:   56:  task_p->operation_type = (uint8_t) operation;
        -:   57:
    #####:   58:  ecma_value_t result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
    #####:   59:  task_p->promise = result;
        -:   60:
    #####:   61:  ecma_value_t head = async_generator_object_p->extended_object.u.cls.u3.head;
        -:   62:
    #####:   63:  if (ECMA_IS_INTERNAL_VALUE_NULL (head))
        -:   64:  {
    #####:   65:    ECMA_SET_INTERNAL_VALUE_POINTER (async_generator_object_p->extended_object.u.cls.u3.head, task_p);
        -:   66:
    #####:   67:    if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_ASYNC_GENERATOR_CALLED)
        -:   68:    {
    #####:   69:      ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:   70:      ecma_enqueue_promise_async_generator_job (executable_object);
    #####:   71:      return result;
        -:   72:    }
        -:   73:
    #####:   74:    async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_ASYNC_GENERATOR_CALLED;
    #####:   75:    ecma_async_generator_run (async_generator_object_p);
    #####:   76:    return result;
        -:   77:  }
        -:   78:
        -:   79:  /* Append the new task at the end. */
        -:   80:  ecma_async_generator_task_t *prev_task_p;
    #####:   81:  prev_task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, head);
        -:   82:
    #####:   83:  while (!ECMA_IS_INTERNAL_VALUE_NULL (prev_task_p->next))
        -:   84:  {
    #####:   85:    prev_task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, prev_task_p->next);
        -:   86:  }
        -:   87:
    #####:   88:  ECMA_SET_INTERNAL_VALUE_POINTER (prev_task_p->next, task_p);
    #####:   89:  return result;
        -:   90:} /* ecma_async_generator_enqueue */
        -:   91:
        -:   92:/**
        -:   93: * Call a function and await its return value
        -:   94: *
        -:   95: * @return ECMA_VALUE_UNDEFINED on success, error otherwise
        -:   96: */
        -:   97:static ecma_value_t
    #####:   98:ecma_async_yield_call (ecma_value_t function, /**< function (takes reference) */
        -:   99:                       vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  100:                       ecma_value_t argument, /**< argument passed to the function */
        -:  101:                       const char *error_msg_p) /**< error message when the function is not callable */
        -:  102:{
    #####:  103:  if (!ecma_is_value_object (function) || !ecma_op_is_callable (function))
        -:  104:  {
    #####:  105:    ecma_free_value (function);
    #####:  106:    return ecma_raise_type_error (error_msg_p);
        -:  107:  }
        -:  108:
    #####:  109:  ecma_object_t *return_obj_p = ecma_get_object_from_value (function);
    #####:  110:  ecma_value_t iterator = async_generator_object_p->frame_ctx.block_result;
        -:  111:  ecma_value_t result;
        -:  112:
    #####:  113:  if (argument == ECMA_VALUE_EMPTY)
        -:  114:  {
    #####:  115:    result = ecma_op_function_call (return_obj_p, iterator, NULL, 0);
        -:  116:  }
        -:  117:  else
        -:  118:  {
    #####:  119:    result = ecma_op_function_call (return_obj_p, iterator, &argument, 1);
        -:  120:  }
        -:  121:
    #####:  122:  ecma_deref_object (return_obj_p);
        -:  123:
    #####:  124:  if (ECMA_IS_VALUE_ERROR (result))
        -:  125:  {
    #####:  126:    return result;
        -:  127:  }
        -:  128:
    #####:  129:  return ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  130:} /* ecma_async_yield_call */
        -:  131:
        -:  132:/**
        -:  133: * Perform an exception throw and call the approprite handler
        -:  134: */
        -:  135:static ecma_value_t
    #####:  136:ecma_async_yield_throw (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  137:                        ecma_value_t value) /**< thrown value */
        -:  138:{
    #####:  139:  ecma_object_t *obj_p = ecma_get_object_from_value (async_generator_object_p->frame_ctx.block_result);
    #####:  140:  ecma_value_t result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_THROW);
        -:  141:
    #####:  142:  if (ECMA_IS_VALUE_ERROR (result))
        -:  143:  {
    #####:  144:    return result;
        -:  145:  }
        -:  146:
    #####:  147:  if (result == ECMA_VALUE_UNDEFINED)
        -:  148:  {
    #####:  149:    result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_RETURN);
        -:  150:
    #####:  151:    if (result == ECMA_VALUE_UNDEFINED)
        -:  152:    {
    #####:  153:      return ecma_raise_type_error (ECMA_ERR_MSG ("Iterator 'throw' is not available"));
        -:  154:    }
        -:  155:
    #####:  156:    result = ecma_async_yield_call (result,
        -:  157:                                    async_generator_object_p,
        -:  158:                                    ECMA_VALUE_EMPTY,
        -:  159:                                    ECMA_ERR_MSG ("Iterator 'return' is not callable"));
        -:  160:
    #####:  161:    if (ECMA_IS_VALUE_ERROR (result))
        -:  162:    {
    #####:  163:      return result;
        -:  164:    }
        -:  165:
    #####:  166:    ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_CLOSE);
    #####:  167:    return ECMA_VALUE_UNDEFINED;
        -:  168:  }
        -:  169:
    #####:  170:  result = ecma_async_yield_call (result,
        -:  171:                                  async_generator_object_p,
        -:  172:                                  value,
        -:  173:                                  ECMA_ERR_MSG ("Iterator 'throw' is not callable"));
        -:  174:
    #####:  175:  if (ECMA_IS_VALUE_ERROR (result))
        -:  176:  {
    #####:  177:    return result;
        -:  178:  }
        -:  179:
    #####:  180:  ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_NEXT);
    #####:  181:  return ECMA_VALUE_UNDEFINED;
        -:  182:} /* ecma_async_yield_throw */
        -:  183:
        -:  184:/**
        -:  185: * Execute the next task in the command queue of the async generator
        -:  186: *
        -:  187: * @return ecma value
        -:  188: *         Returned value must be freed with ecma_free_value.
        -:  189: */
        -:  190:ecma_value_t
    #####:  191:ecma_async_generator_run (vm_executable_object_t *async_generator_object_p) /**< async generator */
        -:  192:{
    #####:  193:  JERRY_ASSERT (async_generator_object_p->extended_object.u.cls.type == ECMA_OBJECT_CLASS_ASYNC_GENERATOR);
    #####:  194:  JERRY_ASSERT (!ECMA_IS_INTERNAL_VALUE_NULL (async_generator_object_p->extended_object.u.cls.u3.head));
        -:  195:
    #####:  196:  ecma_value_t head = async_generator_object_p->extended_object.u.cls.u3.head;
    #####:  197:  ecma_async_generator_task_t *task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, head);
        -:  198:  ecma_value_t result;
        -:  199:
    #####:  200:  if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags
    #####:  201:      & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD)
        -:  202:  {
    #####:  203:    switch (task_p->operation_type)
        -:  204:    {
    #####:  205:      case ECMA_ASYNC_GENERATOR_DO_NEXT:
        -:  206:      {
    #####:  207:        result = ecma_op_iterator_next (async_generator_object_p->frame_ctx.block_result,
    #####:  208:                                        async_generator_object_p->frame_ctx.stack_top_p[-1],
        -:  209:                                        task_p->operation_value);
        -:  210:
    #####:  211:        if (ECMA_IS_VALUE_ERROR (result))
        -:  212:        {
    #####:  213:          break;
        -:  214:        }
        -:  215:
    #####:  216:        result = ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  217:
    #####:  218:        if (ECMA_IS_VALUE_ERROR (result))
        -:  219:        {
    #####:  220:          break;
        -:  221:        }
        -:  222:
    #####:  223:        ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_NEXT);
    #####:  224:        break;
        -:  225:      }
    #####:  226:      case ECMA_ASYNC_GENERATOR_DO_THROW:
        -:  227:      {
    #####:  228:        result = ecma_async_yield_throw (async_generator_object_p, task_p->operation_value);
    #####:  229:        break;
        -:  230:      }
    #####:  231:      default:
        -:  232:      {
    #####:  233:        JERRY_ASSERT (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_RETURN);
        -:  234:
    #####:  235:        result = ecma_copy_value (task_p->operation_value);
    #####:  236:        result = ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  237:
    #####:  238:        if (ECMA_IS_VALUE_ERROR (result))
        -:  239:        {
    #####:  240:          break;
        -:  241:        }
        -:  242:
    #####:  243:        ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_RETURN);
    #####:  244:        break;
        -:  245:      }
        -:  246:    }
        -:  247:
    #####:  248:    ecma_free_value_if_not_object (task_p->operation_value);
    #####:  249:    task_p->operation_value = ECMA_VALUE_UNDEFINED;
        -:  250:
    #####:  251:    if (result == ECMA_VALUE_UNDEFINED)
        -:  252:    {
    #####:  253:      return ECMA_VALUE_UNDEFINED;
        -:  254:    }
        -:  255:
    #####:  256:    JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
        -:  257:
    #####:  258:    async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags &= ECMA_AWAIT_CLEAR_MASK;
    #####:  259:    async_generator_object_p->frame_ctx.block_result = ECMA_VALUE_UNDEFINED;
    #####:  260:    async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  261:
    #####:  262:    JERRY_ASSERT (async_generator_object_p->frame_ctx.stack_top_p[-1] == ECMA_VALUE_UNDEFINED
        -:  263:                  || ecma_is_value_object (async_generator_object_p->frame_ctx.stack_top_p[-1]));
    #####:  264:    async_generator_object_p->frame_ctx.stack_top_p--;
        -:  265:
    #####:  266:    result = jcontext_take_exception ();
        -:  267:  }
        -:  268:  else
        -:  269:  {
    #####:  270:    if (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_RETURN)
        -:  271:    {
    #####:  272:      async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
        -:  273:    }
    #####:  274:    else if (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_THROW)
        -:  275:    {
    #####:  276:      async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  277:    }
        -:  278:
    #####:  279:    result = task_p->operation_value;
    #####:  280:    ecma_ref_if_object (result);
    #####:  281:    task_p->operation_value = ECMA_VALUE_UNDEFINED;
        -:  282:  }
        -:  283:
    #####:  284:  result = opfunc_resume_executable_object (async_generator_object_p, result);
        -:  285:
    #####:  286:  if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_COMPLETED)
        -:  287:  {
    #####:  288:    JERRY_ASSERT (head == async_generator_object_p->extended_object.u.cls.u3.head);
    #####:  289:    ecma_async_generator_finalize (async_generator_object_p, result);
    #####:  290:    result = ECMA_VALUE_UNDEFINED;
        -:  291:  }
        -:  292:
    #####:  293:  return result;
        -:  294:} /* ecma_async_generator_run */
        -:  295:
        -:  296:/**
        -:  297: * Finalize the promises of an executable generator
        -:  298: */
        -:  299:void
    #####:  300:ecma_async_generator_finalize (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  301:                               ecma_value_t value) /**< final value (takes reference) */
        -:  302:{
    #####:  303:  ecma_value_t next = async_generator_object_p->extended_object.u.cls.u3.head;
    #####:  304:  ecma_async_generator_task_t *task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, next);
        -:  305:
    #####:  306:  if (ECMA_IS_VALUE_ERROR (value))
        -:  307:  {
    #####:  308:    value = jcontext_take_exception ();
    #####:  309:    ecma_reject_promise (task_p->promise, value);
        -:  310:  }
        -:  311:  else
        -:  312:  {
    #####:  313:    ecma_value_t result = ecma_create_iter_result_object (value, ECMA_VALUE_TRUE);
    #####:  314:    ecma_fulfill_promise (task_p->promise, result);
    #####:  315:    ecma_free_value (result);
        -:  316:  }
        -:  317:
    #####:  318:  ecma_free_value (value);
        -:  319:
    #####:  320:  next = task_p->next;
    #####:  321:  async_generator_object_p->extended_object.u.cls.u3.head = next;
    #####:  322:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  323:
    #####:  324:  while (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  325:  {
    #####:  326:    task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, next);
        -:  327:
    #####:  328:    if (task_p->operation_type != ECMA_ASYNC_GENERATOR_DO_THROW)
        -:  329:    {
    #####:  330:      value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
    #####:  331:      ecma_fulfill_promise (task_p->promise, value);
    #####:  332:      ecma_free_value (value);
        -:  333:    }
        -:  334:    else
        -:  335:    {
    #####:  336:      ecma_reject_promise (task_p->promise, task_p->operation_value);
        -:  337:    }
        -:  338:
    #####:  339:    ecma_free_value_if_not_object (task_p->operation_value);
        -:  340:
    #####:  341:    next = task_p->next;
    #####:  342:    async_generator_object_p->extended_object.u.cls.u3.head = next;
    #####:  343:    jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  344:  }
    #####:  345:} /* ecma_async_generator_finalize */
        -:  346:
        -:  347:/**
        -:  348: * Continue after an await operation is completed.
        -:  349: *
        -:  350: * @return an updated value for the value argument
        -:  351: */
        -:  352:ecma_value_t
    #####:  353:ecma_await_continue (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  354:                     ecma_value_t value) /**< job value (takes reference) */
        -:  355:{
    #####:  356:  ecma_await_states_t state = (ecma_await_states_t) ECMA_AWAIT_GET_STATE (executable_object_p);
        -:  357:
    #####:  358:  switch (state)
        -:  359:  {
    #####:  360:    case ECMA_AWAIT_YIELD_NEXT:
        -:  361:    case ECMA_AWAIT_YIELD_NEXT_RETURN:
        -:  362:    {
    #####:  363:      if (!ecma_is_value_object (value))
        -:  364:      {
    #####:  365:        ecma_free_value (value);
    #####:  366:        return ecma_raise_type_error (ECMA_ERR_MSG ("Value received by yield* is not object"));
        -:  367:      }
        -:  368:
    #####:  369:      ecma_object_t *result_obj_p = ecma_get_object_from_value (value);
    #####:  370:      ecma_value_t result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_DONE);
        -:  371:
    #####:  372:      if (ECMA_IS_VALUE_ERROR (result))
        -:  373:      {
    #####:  374:        ecma_deref_object (result_obj_p);
    #####:  375:        return result;
        -:  376:      }
        -:  377:
    #####:  378:      bool done = ecma_op_to_boolean (result);
    #####:  379:      ecma_free_value (result);
    #####:  380:      result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_VALUE);
    #####:  381:      ecma_deref_object (result_obj_p);
        -:  382:
    #####:  383:      if (ECMA_IS_VALUE_ERROR (result))
        -:  384:      {
    #####:  385:        return result;
        -:  386:      }
        -:  387:
    #####:  388:      if (!done)
        -:  389:      {
    #####:  390:        ECMA_AWAIT_SET_STATE (executable_object_p, YIELD_NEXT_VALUE);
    #####:  391:        return ecma_promise_async_await ((ecma_extended_object_t *) executable_object_p, result);
        -:  392:      }
        -:  393:
    #####:  394:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
        -:  395:
    #####:  396:      if (state == ECMA_AWAIT_YIELD_NEXT_RETURN)
        -:  397:      {
    #####:  398:        executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
        -:  399:      }
    #####:  400:      return result;
        -:  401:    }
    #####:  402:    case ECMA_AWAIT_YIELD_RETURN:
        -:  403:    {
    #####:  404:      ecma_object_t *obj_p = ecma_get_object_from_value (executable_object_p->frame_ctx.block_result);
    #####:  405:      ecma_value_t result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_RETURN);
        -:  406:
    #####:  407:      if (ECMA_IS_VALUE_ERROR (result))
        -:  408:      {
    #####:  409:        ecma_free_value (value);
    #####:  410:        return result;
        -:  411:      }
        -:  412:
    #####:  413:      if (result == ECMA_VALUE_UNDEFINED)
        -:  414:      {
    #####:  415:        ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  416:        executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
    #####:  417:        return value;
        -:  418:      }
        -:  419:
    #####:  420:      result = ecma_async_yield_call (result,
        -:  421:                                      executable_object_p,
        -:  422:                                      value,
        -:  423:                                      ECMA_ERR_MSG ("Iterator 'return' is not callable"));
    #####:  424:      ecma_free_value (value);
        -:  425:
    #####:  426:      if (ECMA_IS_VALUE_ERROR (result))
        -:  427:      {
    #####:  428:        return result;
        -:  429:      }
        -:  430:
    #####:  431:      JERRY_ASSERT (result == ECMA_VALUE_UNDEFINED);
    #####:  432:      ECMA_AWAIT_CHANGE_STATE (executable_object_p, YIELD_RETURN, YIELD_NEXT_RETURN);
    #####:  433:      return ECMA_VALUE_UNDEFINED;
        -:  434:    }
    #####:  435:    case ECMA_AWAIT_YIELD_NEXT_VALUE:
        -:  436:    {
    #####:  437:      ECMA_AWAIT_CHANGE_STATE (executable_object_p, YIELD_NEXT_VALUE, YIELD_OPERATION);
    #####:  438:      opfunc_async_generator_yield ((ecma_extended_object_t *) executable_object_p, value);
    #####:  439:      return ECMA_VALUE_UNDEFINED;
        -:  440:    }
    #####:  441:    case ECMA_AWAIT_YIELD_OPERATION:
        -:  442:    {
        -:  443:      /* Currently this is always a throw exception case. */
    #####:  444:      ecma_value_t result = ecma_async_yield_throw (executable_object_p, value);
    #####:  445:      ecma_free_value (value);
    #####:  446:      return result;
        -:  447:    }
    #####:  448:    case ECMA_AWAIT_YIELD_CLOSE:
        -:  449:    {
    #####:  450:      const char *msg_p = (ecma_is_value_object (value) ? ECMA_ERR_MSG ("Iterator 'throw' is not available")
    #####:  451:                                                        : ECMA_ERR_MSG ("Value received by yield* is not object"));
        -:  452:
    #####:  453:      ecma_free_value (value);
    #####:  454:      return ecma_raise_type_error (msg_p);
        -:  455:    }
    #####:  456:    case ECMA_AWAIT_FOR_CLOSE:
        -:  457:    {
    #####:  458:      bool is_value_object = ecma_is_value_object (value);
    #####:  459:      ecma_free_value (value);
    #####:  460:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
        -:  461:
    #####:  462:      if (!is_value_object
    #####:  463:          && VM_GET_CONTEXT_TYPE (executable_object_p->frame_ctx.stack_top_p[-1]) != VM_CONTEXT_FINALLY_THROW)
        -:  464:      {
    #####:  465:        return ecma_raise_type_error (ECMA_ERR_MSG ("Iterator 'return' result is not object"));
        -:  466:      }
    #####:  467:      return ECMA_VALUE_EMPTY;
        -:  468:    }
    #####:  469:    default:
        -:  470:    {
    #####:  471:      JERRY_ASSERT (state == ECMA_AWAIT_FOR_NEXT);
    #####:  472:      JERRY_ASSERT (VM_GET_CONTEXT_TYPE (executable_object_p->frame_ctx.stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####:  473:      JERRY_ASSERT (!(executable_object_p->frame_ctx.stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -:  474:
    #####:  475:      if (!ecma_is_value_object (value))
        -:  476:      {
    #####:  477:        ecma_free_value (value);
    #####:  478:        return ecma_raise_type_error (ECMA_ERR_MSG ("Value received by for-async-of is not object"));
        -:  479:      }
        -:  480:
    #####:  481:      ecma_object_t *result_obj_p = ecma_get_object_from_value (value);
    #####:  482:      ecma_value_t result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_DONE);
        -:  483:
    #####:  484:      if (ECMA_IS_VALUE_ERROR (result))
        -:  485:      {
    #####:  486:        ecma_deref_object (result_obj_p);
    #####:  487:        return result;
        -:  488:      }
        -:  489:
    #####:  490:      bool done = ecma_op_to_boolean (result);
    #####:  491:      ecma_free_value (result);
        -:  492:
    #####:  493:      ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
    #####:  494:      JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####:  495:      JERRY_ASSERT (ecma_is_value_object (stack_top_p[-3]));
    #####:  496:      JERRY_ASSERT (stack_top_p[-4] == ECMA_VALUE_UNDEFINED || ecma_is_value_object (stack_top_p[-4]));
        -:  497:
    #####:  498:      if (!done)
        -:  499:      {
    #####:  500:        result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_VALUE);
    #####:  501:        ecma_deref_object (result_obj_p);
        -:  502:
    #####:  503:        if (ECMA_IS_VALUE_ERROR (result))
        -:  504:        {
    #####:  505:          return result;
        -:  506:        }
        -:  507:
        -:  508:        /* It seems browsers call Await(result) here, although the standard does not
        -:  509:         * requests to do so. The following code might follow browsers in the future. */
    #####:  510:        ecma_deref_if_object (result);
    #####:  511:        stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####:  512:        stack_top_p[-2] = result;
    #####:  513:        ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  514:        return ECMA_VALUE_EMPTY;
        -:  515:      }
        -:  516:
    #####:  517:      ecma_deref_object (result_obj_p);
        -:  518:
        -:  519:      /* This code jumps to the end regardless of the byte code which triggered this await. */
    #####:  520:      uint32_t context_end = VM_GET_CONTEXT_END (stack_top_p[-1]);
    #####:  521:      executable_object_p->frame_ctx.byte_code_p = executable_object_p->frame_ctx.byte_code_start_p + context_end;
        -:  522:
    #####:  523:      VM_MINUS_EQUAL_U16 (executable_object_p->frame_ctx.context_depth,
        -:  524:                          PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####:  525:      stack_top_p -= PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####:  526:      executable_object_p->frame_ctx.stack_top_p = stack_top_p;
        -:  527:
    #####:  528:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  529:      return ECMA_VALUE_EMPTY;
        -:  530:    }
        -:  531:  }
        -:  532:} /* ecma_await_continue */
        -:  533:
        -:  534:#endif /* JERRY_ESNEXT */
        -:  535:
        -:  536:/**
        -:  537: * @}
        -:  538: * @}
        -:  539: */
