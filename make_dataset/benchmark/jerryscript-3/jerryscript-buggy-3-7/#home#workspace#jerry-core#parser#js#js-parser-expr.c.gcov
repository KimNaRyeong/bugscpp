        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-expr.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:#include "jcontext.h"
        -:   20:
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:#include "js-parser-tagged-template-literal.h"
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_expr Expression parser
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Maximum precedence for right-to-left binary operation evaluation.
        -:   37: */
        -:   38:#define PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE 7
        -:   39:
        -:   40:/**
        -:   41: * Precedence for ternary operation.
        -:   42: */
        -:   43:#define PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE 4
        -:   44:
        -:   45:/**
        -:   46: * Precedence for exponentiation operation.
        -:   47: */
        -:   48:#define PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION 16
        -:   49:
        -:   50:/**
        -:   51: * Value of grouping level increase and decrease.
        -:   52: */
        -:   53:#define PARSER_GROUPING_LEVEL_INCREASE 2
        -:   54:
        -:   55:/**
        -:   56: * Precedence of the binary tokens.
        -:   57: *
        -:   58: * See also:
        -:   59: *    lexer_token_type_t
        -:   60: */
        -:   61:static const uint8_t parser_binary_precedence_table[] =
        -:   62:{
        -:   63:  3, /**< "=" */
        -:   64:  3, /**< "+=" */
        -:   65:  3, /**< "-=" */
        -:   66:  3, /**< "*=" */
        -:   67:  3, /**< "/=" */
        -:   68:  3, /**< "=" */
        -:   69:  3, /**< "<<=" */
        -:   70:  3, /**< ">>=" */
        -:   71:  3, /**< ">>>=" */
        -:   72:  3, /**< "&=" */
        -:   73:  3, /**< "|=" */
        -:   74:  3, /**< "^=" */
        -:   75:#if JERRY_ESNEXT
        -:   76:  3, /**< "**=" */
        -:   77:#endif /* JERRY_ESNEXT */
        -:   78:  4, /**< "?"*/
        -:   79:#if JERRY_ESNEXT
        -:   80:  5, /**< "??" */
        -:   81:#endif /* JERRY_ESNEXT */
        -:   82:  6, /**< "||" */
        -:   83:  7, /**< "&&" */
        -:   84:  8, /**< "|" */
        -:   85:  9, /**< "^" */
        -:   86:  10, /**< "&" */
        -:   87:  11, /**< "==" */
        -:   88:  11, /**< "!=" */
        -:   89:  11, /**< "===" */
        -:   90:  11, /**< "!==" */
        -:   91:  12, /**< "<" */
        -:   92:  12, /**< ">" */
        -:   93:  12, /**< "<=" */
        -:   94:  12, /**< ">=" */
        -:   95:  12, /**< in */
        -:   96:  12, /**< instanceof */
        -:   97:  13, /**< "<<" */
        -:   98:  13, /**< ">>" */
        -:   99:  13, /**< ">>>" */
        -:  100:  14, /**< "+" */
        -:  101:  14, /**< "-" */
        -:  102:  15, /**< "*" */
        -:  103:  15, /**< "/" */
        -:  104:  15, /**< "%" */
        -:  105:#if JERRY_ESNEXT
        -:  106:  16, /**< "**" */
        -:  107:#endif /* JERRY_ESNEXT */
        -:  108:};
        -:  109:
        -:  110:#if JERRY_ESNEXT
        -:  111:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 39,
        -:  112:                     parser_binary_precedence_table_should_have_39_values_in_es2015);
        -:  113:#else /* !JERRY_ESNEXT */
        -:  114:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 36,
        -:  115:                     parser_binary_precedence_table_should_have_36_values_in_es51);
        -:  116:#endif /* JERRY_ESNEXT */
        -:  117:
        -:  118:/**
        -:  119: * Generate byte code for operators with lvalue.
        -:  120: */
        -:  121:static inline void
       24:  122:parser_push_result (parser_context_t *context_p) /**< context */
        -:  123:{
       24:  124:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -:  125:  {
        1:  126:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));
        -:  127:
        1:  128:    if ((context_p->last_cbc_opcode == CBC_POST_INCR
        1:  129:         || context_p->last_cbc_opcode == CBC_POST_DECR)
    #####:  130:        && context_p->stack_depth >= context_p->stack_limit)
        -:  131:    {
        -:  132:      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT
        -:  133:       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */
    #####:  134:      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -:  135:
    #####:  136:      context_p->stack_limit++;
        -:  137:
    #####:  138:      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  139:      {
    #####:  140:        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  141:      }
        -:  142:    }
        -:  143:
        1:  144:    context_p->last_cbc_opcode++;
        1:  145:    parser_flush_cbc (context_p);
        -:  146:  }
       24:  147:} /* parser_push_result */
        -:  148:
        -:  149:/**
        -:  150: * Check for invalid assignment for "eval" and "arguments"
        -:  151: */
        -:  152:static void
        1:  153:parser_check_invalid_assign (parser_context_t *context_p) /**< context */
        -:  154:{
        1:  155:  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);
        -:  156:
        1:  157:  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  158:  {
    #####:  159:    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)
        -:  160:    {
    #####:  161:      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);
        -:  162:    }
    #####:  163:    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)
        -:  164:    {
    #####:  165:      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);
        -:  166:    }
        -:  167:  }
        1:  168:} /* parser_check_invalid_assign */
        -:  169:
        -:  170:#if JERRY_ESNEXT
        -:  171:
        -:  172:/**
        -:  173: * Check and throw an error if the "new.target" is invalid as a left-hand side expression.
        -:  174: */
        -:  175:static void
    #####:  176:parser_check_invalid_new_target (parser_context_t *context_p, /**< parser context */
        -:  177:                                 cbc_opcode_t opcode) /**< current opcode under parsing */
        -:  178:{
        -:  179:  /* new.target is an invalid left-hand side target */
    #####:  180:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NEW_TARGET))
        -:  181:  {
        -:  182:    /* Make sure that the call side is a post/pre increment or an assignment expression.
        -:  183:     * There should be no other ways the "new.target" expression should be here. */
    #####:  184:    JERRY_ASSERT ((opcode >= CBC_PRE_INCR && opcode <= CBC_POST_DECR)
        -:  185:                  || (opcode == CBC_ASSIGN
        -:  186:                      && (context_p->token.type == LEXER_ASSIGN
        -:  187:                          || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->token.type))));
        -:  188:
    #####:  189:    parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -:  190:  }
    #####:  191:} /* parser_check_invalid_new_target */
        -:  192:
        -:  193:#endif /* JERRY_ESNEXT */
        -:  194:
        -:  195:/**
        -:  196: * Emit identifier reference
        -:  197: */
        -:  198:static void
        1:  199:parser_emit_ident_reference (parser_context_t *context_p, /**< context */
        -:  200:                             uint16_t opcode) /* opcode */
        -:  201:{
        1:  202:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  203:  {
        1:  204:    context_p->last_cbc_opcode = opcode;
        1:  205:    return;
        -:  206:  }
        -:  207:
        -:  208:  uint16_t literal_index;
        -:  209:
    #####:  210:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  211:  {
    #####:  212:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  213:    literal_index = context_p->last_cbc.value;
        -:  214:  }
    #####:  215:  else if (context_p->last_cbc_opcode == CBC_PUSH_THIS_LITERAL)
        -:  216:  {
    #####:  217:    context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####:  218:    literal_index = context_p->last_cbc.literal_index;
        -:  219:  }
        -:  220:  else
        -:  221:  {
    #####:  222:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####:  223:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  224:    literal_index = context_p->last_cbc.third_literal_index;
        -:  225:  }
        -:  226:
    #####:  227:  parser_emit_cbc_literal (context_p, opcode, literal_index);
        -:  228:} /* parser_emit_ident_reference */
        -:  229:
        -:  230:/**
        -:  231: * Generate byte code for operators with lvalue.
        -:  232: */
        -:  233:static void
        1:  234:parser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */
        -:  235:                                 cbc_opcode_t opcode) /**< opcode */
        -:  236:{
        1:  237:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        1:  238:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -:  239:  {
        1:  240:    parser_check_invalid_assign (context_p);
        -:  241:
        -:  242:    uint16_t unary_opcode;
        -:  243:
        1:  244:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  245:    {
    #####:  246:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  247:      {
    #####:  248:        parser_raise_error (context_p, PARSER_ERR_DELETE_IDENT_NOT_ALLOWED);
        -:  249:      }
        -:  250:
    #####:  251:      unary_opcode = CBC_DELETE_IDENT_PUSH_RESULT;
        -:  252:    }
        -:  253:    else
        -:  254:    {
        1:  255:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, opcode + CBC_UNARY_LVALUE_WITH_IDENT));
        1:  256:      unary_opcode = (uint16_t) (opcode + CBC_UNARY_LVALUE_WITH_IDENT);
        -:  257:    }
        -:  258:
        1:  259:    parser_emit_ident_reference (context_p, unary_opcode);
        -:  260:
        -:  261:#if JERRY_ESNEXT
        1:  262:    if (unary_opcode != CBC_DELETE_IDENT_PUSH_RESULT
        1:  263:        && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -:  264:    {
        -:  265:      /* The current value must be read, but it cannot be changed. */
    #####:  266:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  267:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -:  268:    }
        -:  269:#endif /* JERRY_ESNEXT */
        1:  270:    return;
        -:  271:  }
        -:  272:
    #####:  273:  if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -:  274:  {
    #####:  275:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, opcode));
    #####:  276:    context_p->last_cbc_opcode = (uint16_t) opcode;
    #####:  277:    return;
        -:  278:  }
        -:  279:
    #####:  280:  if (PARSER_IS_PUSH_PROP_LITERAL (context_p->last_cbc_opcode))
        -:  281:  {
    #####:  282:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_LITERAL_TO_PUSH_LITERAL (context_p->last_cbc_opcode);
        -:  283:  }
        -:  284:  else
        -:  285:  {
        -:  286:    /* Invalid LeftHandSide expression. */
    #####:  287:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  288:    {
        -:  289:#if JERRY_ESNEXT
    #####:  290:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL)
    #####:  291:          || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -:  292:      {
    #####:  293:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
    #####:  294:        parser_emit_cbc (context_p, CBC_POP);
    #####:  295:        return;
        -:  296:      }
        -:  297:#endif /* JERRY_ESNEXT */
    #####:  298:      parser_emit_cbc (context_p, CBC_POP);
    #####:  299:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####:  300:      return;
        -:  301:    }
        -:  302:
        -:  303:#if JERRY_ESNEXT
    #####:  304:    parser_check_invalid_new_target (context_p, opcode);
    #####:  305:    if (opcode == CBC_PRE_INCR || opcode == CBC_PRE_DECR)
        -:  306:    {
    #####:  307:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_PREFIX_OP);
        -:  308:    }
        -:  309:    else
        -:  310:    {
    #####:  311:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_POSTFIX_OP);
        -:  312:    }
        -:  313:#else /* JERRY_ESNEXT */
    #####:  314:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -:  315:#endif /* JERRY_ESNEXT */
        -:  316:  }
        -:  317:
    #####:  318:  parser_emit_cbc (context_p, (uint16_t) opcode);
        -:  319:} /* parser_emit_unary_lvalue_opcode */
        -:  320:
        -:  321:/**
        -:  322: * Parse array literal.
        -:  323: */
        -:  324:static void
        1:  325:parser_parse_array_literal (parser_context_t *context_p) /**< context */
        -:  326:{
        1:  327:  uint32_t pushed_items = 0;
        1:  328:  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  329:
        1:  330:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
        -:  331:
        1:  332:  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);
        1:  333:  lexer_next_token (context_p);
        -:  334:
        -:  335:  while (true)
        -:  336:  {
        3:  337:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  338:    {
        1:  339:      if (pushed_items > 0)
        -:  340:      {
        1:  341:        parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  342:      }
        2:  343:      return;
        -:  344:    }
        -:  345:
        1:  346:    pushed_items++;
        -:  347:
        1:  348:    if (context_p->token.type == LEXER_COMMA)
        -:  349:    {
    #####:  350:      parser_emit_cbc (context_p, CBC_PUSH_ELISION);
    #####:  351:      lexer_next_token (context_p);
        -:  352:    }
        -:  353:    else
        -:  354:    {
        -:  355:#if JERRY_ESNEXT
        1:  356:      if (context_p->token.type == LEXER_THREE_DOTS)
        -:  357:      {
    #####:  358:        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));
    #####:  359:        pushed_items++;
    #####:  360:        lexer_next_token (context_p);
    #####:  361:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
        -:  362:      }
        -:  363:#endif /* JERRY_ESNEXT */
        -:  364:
        1:  365:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  366:
        1:  367:      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -:  368:      {
    #####:  369:        parser_flush_cbc (context_p);
        -:  370:      }
        -:  371:
        1:  372:      if (context_p->token.type == LEXER_COMMA)
        -:  373:      {
    #####:  374:        lexer_next_token (context_p);
        -:  375:      }
        1:  376:      else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -:  377:      {
    #####:  378:        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);
        -:  379:      }
        -:  380:    }
        -:  381:
        1:  382:    if (pushed_items >= 64)
        -:  383:    {
    #####:  384:      parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  385:#if JERRY_ESNEXT
    #####:  386:      opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  387:#endif /* JERRY_ESNEXT */
    #####:  388:      pushed_items = 0;
        -:  389:    }
        -:  390:  }
        -:  391:} /* parser_parse_array_literal */
        -:  392:
        -:  393:#if !JERRY_ESNEXT
        -:  394:/**
        -:  395: * Object literal item types.
        -:  396: */
        -:  397:typedef enum
        -:  398:{
        -:  399:  PARSER_OBJECT_PROPERTY_START,                /**< marks the start of the property list */
        -:  400:  PARSER_OBJECT_PROPERTY_VALUE,                /**< value property */
        -:  401:  PARSER_OBJECT_PROPERTY_GETTER,               /**< getter property */
        -:  402:  PARSER_OBJECT_PROPERTY_SETTER,               /**< setter property */
        -:  403:  PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS,       /**< both getter and setter properties are set */
        -:  404:} parser_object_literal_item_types_t;
        -:  405:
        -:  406:/**
        -:  407: * Parse object literal.
        -:  408: */
        -:  409:static void
    #####:  410:parser_append_object_literal_item (parser_context_t *context_p, /**< context */
        -:  411:                                   uint16_t item_index, /**< index of the item name */
        -:  412:                                   parser_object_literal_item_types_t item_type) /**< type of the item */
        -:  413:{
        -:  414:  parser_stack_iterator_t iterator;
        -:  415:  uint8_t *current_item_type_p;
        -:  416:
    #####:  417:  iterator.current_p = context_p->stack.first_p;
    #####:  418:  iterator.current_position = context_p->stack.last_position;
        -:  419:
        -:  420:  while (true)
        -:  421:  {
    #####:  422:    current_item_type_p = iterator.current_p->bytes + iterator.current_position - 1;
        -:  423:
    #####:  424:    if (*current_item_type_p == PARSER_OBJECT_PROPERTY_START)
        -:  425:    {
    #####:  426:      parser_stack_push_uint16 (context_p, item_index);
    #####:  427:      parser_stack_push_uint8 (context_p, (uint8_t) item_type);
    #####:  428:      return;
        -:  429:    }
        -:  430:
    #####:  431:    iterator.current_position--;
    #####:  432:    if (iterator.current_position == 0)
        -:  433:    {
    #####:  434:      iterator.current_p = iterator.current_p->next_p;
    #####:  435:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  436:    }
        -:  437:
    #####:  438:    uint32_t current_item_index = iterator.current_p->bytes[iterator.current_position - 1];
        -:  439:
    #####:  440:    iterator.current_position--;
    #####:  441:    if (iterator.current_position == 0)
        -:  442:    {
    #####:  443:      iterator.current_p = iterator.current_p->next_p;
    #####:  444:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  445:    }
        -:  446:
    #####:  447:    current_item_index |= ((uint32_t) iterator.current_p->bytes[iterator.current_position - 1]) << 8;
        -:  448:
    #####:  449:    iterator.current_position--;
    #####:  450:    if (iterator.current_position == 0)
        -:  451:    {
    #####:  452:      iterator.current_p = iterator.current_p->next_p;
    #####:  453:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  454:    }
        -:  455:
    #####:  456:    if (current_item_index == item_index)
        -:  457:    {
    #####:  458:      if (item_type == PARSER_OBJECT_PROPERTY_VALUE
    #####:  459:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_VALUE
    #####:  460:          && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  461:      {
        -:  462:        return;
        -:  463:      }
        -:  464:
    #####:  465:      if (item_type == PARSER_OBJECT_PROPERTY_GETTER
    #####:  466:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_SETTER)
        -:  467:      {
        -:  468:        break;
        -:  469:      }
        -:  470:
    #####:  471:      if (item_type == PARSER_OBJECT_PROPERTY_SETTER
    #####:  472:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_GETTER)
        -:  473:      {
        -:  474:        break;
        -:  475:      }
        -:  476:
    #####:  477:      parser_raise_error (context_p, PARSER_ERR_OBJECT_PROPERTY_REDEFINED);
        -:  478:    }
        -:  479:  }
        -:  480:
    #####:  481:  uint8_t *last_page_p = context_p->stack.first_p->bytes;
        -:  482:
    #####:  483:  *current_item_type_p = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  484:
    #####:  485:  if (current_item_type_p == (last_page_p + context_p->stack.last_position - 1))
        -:  486:  {
    #####:  487:    context_p->stack_top_uint8 = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  488:  }
        -:  489:} /* parser_append_object_literal_item */
        -:  490:#endif /* !JERRY_ESNEXT */
        -:  491:
        -:  492:#if JERRY_ESNEXT
        -:  493:/** Forward definition of parse array initializer. */
        -:  494:static void
        -:  495:parser_parse_array_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  496:
        -:  497:/** Forward definition of parse object initializer. */
        -:  498:static void
        -:  499:parser_parse_object_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  500:
        -:  501:/**
        -:  502: * Class literal parsing options.
        -:  503: */
        -:  504:typedef enum
        -:  505:{
        -:  506:  PARSER_CLASS_LITERAL_NO_OPTS = 0,                   /**< no options are provided */
        -:  507:  PARSER_CLASS_LITERAL_CTOR_PRESENT = (1 << 0),       /**< class constructor is present */
        -:  508:  PARSER_CLASS_LITERAL_HERTIAGE_PRESENT = (1 << 1),   /**< class heritage is present */
        -:  509:} parser_class_literal_opts_t;
        -:  510:
        -:  511:/**
        -:  512: * Checks whether the current string or identifier literal is constructor
        -:  513: *
        -:  514: * @return true, if constructor and false otherwise
        -:  515: */
        -:  516:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  517:parser_is_constructor_literal (parser_context_t *context_p) /**< context */
        -:  518:{
    #####:  519:  return (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  520:          && lexer_compare_literal_to_string (context_p, "constructor", 11));
        -:  521:} /* parser_is_constructor_literal */
        -:  522:
        -:  523:/**
        -:  524: * Parse class literal.
        -:  525: *
        -:  526: * @return true - if the class has static fields, false - otherwise
        -:  527: */
        -:  528:static bool
    #####:  529:parser_parse_class_body (parser_context_t *context_p, /**< context */
        -:  530:                         parser_class_literal_opts_t opts) /**< class literal parsing options */
        -:  531:{
    #####:  532:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -:  533:
    #####:  534:  lexer_literal_t *ctor_literal_p = NULL;
    #####:  535:  lexer_literal_t *static_fields_literal_p = NULL;
        -:  536:
    #####:  537:  if (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT)
        -:  538:  {
    #####:  539:    ctor_literal_p = lexer_construct_unused_literal (context_p);
    #####:  540:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, (uint16_t) (context_p->literal_count++));
        -:  541:  }
    #####:  542:  else if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  543:  {
    #####:  544:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE);
        -:  545:  }
        -:  546:  else
        -:  547:  {
    #####:  548:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR);
        -:  549:  }
        -:  550:
    #####:  551:  parser_emit_cbc_ext (context_p, CBC_EXT_INIT_CLASS);
        -:  552:
    #####:  553:  bool is_static = false;
    #####:  554:  size_t fields_size = 0;
    #####:  555:  uint32_t computed_field_count = 0;
        -:  556:
        -:  557:  while (true)
    #####:  558:  {
    #####:  559:    if (!is_static)
        -:  560:    {
    #####:  561:      lexer_skip_empty_statements (context_p);
        -:  562:    }
        -:  563:
    #####:  564:    lexer_expect_object_literal_id (context_p, (LEXER_OBJ_IDENT_CLASS_IDENTIFIER
        -:  565:                                                | LEXER_OBJ_IDENT_SET_FUNCTION_START
        -:  566:                                                | (is_static ? 0 : LEXER_OBJ_IDENT_CLASS_NO_STATIC)));
        -:  567:
    #####:  568:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -:  569:    {
    #####:  570:      JERRY_ASSERT (!is_static);
    #####:  571:      break;
        -:  572:    }
        -:  573:
    #####:  574:    if (context_p->token.type == LEXER_KEYW_STATIC)
        -:  575:    {
    #####:  576:      JERRY_ASSERT (!is_static);
    #####:  577:      is_static = true;
    #####:  578:      continue;
        -:  579:    }
        -:  580:
    #####:  581:    if (!is_static && context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p))
        -:  582:    {
    #####:  583:      JERRY_ASSERT (!is_static);
    #####:  584:      JERRY_ASSERT (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT);
    #####:  585:      JERRY_ASSERT (ctor_literal_p != NULL);
        -:  586:
    #####:  587:      if (ctor_literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  588:      {
        -:  589:        /* 14.5.1 */
    #####:  590:        parser_raise_error (context_p, PARSER_ERR_MULTIPLE_CLASS_CONSTRUCTORS);
        -:  591:      }
        -:  592:
    #####:  593:      uint32_t constructor_status_flags = (PARSER_FUNCTION_CLOSURE
        -:  594:                                           | PARSER_ALLOW_SUPER
        -:  595:                                           | PARSER_CLASS_CONSTRUCTOR
        -:  596:                                           | PARSER_LEXICAL_ENV_NEEDED);
        -:  597:
    #####:  598:      if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  599:      {
    #####:  600:        constructor_status_flags |= PARSER_ALLOW_SUPER_CALL;
        -:  601:      }
        -:  602:
    #####:  603:      if (context_p->status_flags & PARSER_INSIDE_WITH)
        -:  604:      {
    #####:  605:        constructor_status_flags |= PARSER_INSIDE_WITH;
        -:  606:      }
        -:  607:
    #####:  608:      parser_flush_cbc (context_p);
    #####:  609:      ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, constructor_status_flags);
    #####:  610:      ctor_literal_p->u.bytecode_p = compiled_code_p;
    #####:  611:      ctor_literal_p->type = LEXER_FUNCTION_LITERAL;
    #####:  612:      continue;
        -:  613:    }
        -:  614:
    #####:  615:    bool is_computed = false;
        -:  616:
    #####:  617:    if (context_p->token.type == LEXER_PROPERTY_GETTER || context_p->token.type == LEXER_PROPERTY_SETTER)
        -:  618:    {
        -:  619:      uint16_t literal_index, function_literal_index;
    #####:  620:      bool is_getter = (context_p->token.type == LEXER_PROPERTY_GETTER);
        -:  621:
    #####:  622:      uint32_t accessor_status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
    #####:  623:      accessor_status_flags |= (is_getter ? PARSER_IS_PROPERTY_GETTER : PARSER_IS_PROPERTY_SETTER);
        -:  624:
    #####:  625:      lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
    #####:  626:      literal_index = context_p->lit_object.index;
        -:  627:
    #####:  628:      if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  629:      {
    #####:  630:        is_computed = true;
        -:  631:      }
    #####:  632:      else if (is_static)
        -:  633:      {
    #####:  634:        if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  635:            && lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  636:        {
    #####:  637:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  638:        }
        -:  639:      }
    #####:  640:      else if (parser_is_constructor_literal (context_p))
        -:  641:      {
    #####:  642:        JERRY_ASSERT (!is_static);
    #####:  643:        parser_raise_error (context_p, PARSER_ERR_CLASS_CONSTRUCTOR_AS_ACCESSOR);
        -:  644:      }
        -:  645:
    #####:  646:      function_literal_index = lexer_construct_function_object (context_p, accessor_status_flags);
        -:  647:
    #####:  648:      parser_emit_cbc_literal (context_p,
        -:  649:                               CBC_PUSH_LITERAL,
        -:  650:                               literal_index);
        -:  651:
    #####:  652:      JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  653:
        -:  654:      cbc_ext_opcode_t opcode;
        -:  655:
    #####:  656:      if (is_computed)
        -:  657:      {
    #####:  658:        context_p->last_cbc.literal_index = function_literal_index;
        -:  659:
    #####:  660:        if (is_getter)
        -:  661:        {
    #####:  662:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_GETTER;
        -:  663:        }
        -:  664:        else
        -:  665:        {
    #####:  666:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_SETTER : CBC_EXT_SET_COMPUTED_SETTER;
        -:  667:        }
        -:  668:      }
        -:  669:      else
        -:  670:      {
    #####:  671:        context_p->last_cbc.value = function_literal_index;
        -:  672:
    #####:  673:        if (is_getter)
        -:  674:        {
    #####:  675:          opcode = is_static ? CBC_EXT_SET_STATIC_GETTER : CBC_EXT_SET_GETTER;
        -:  676:        }
        -:  677:        else
        -:  678:        {
    #####:  679:          opcode = is_static ? CBC_EXT_SET_STATIC_SETTER : CBC_EXT_SET_SETTER;
        -:  680:        }
        -:  681:      }
        -:  682:
    #####:  683:      if (is_computed)
        -:  684:      {
    #####:  685:        parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME
        -:  686:                                                  : CBC_EXT_SET_COMPUTED_SETTER_NAME);
    #####:  687:        parser_emit_cbc_ext (context_p, opcode);
        -:  688:      }
        -:  689:      else
        -:  690:      {
    #####:  691:        parser_set_function_name (context_p, function_literal_index, literal_index, accessor_status_flags);
    #####:  692:        context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
        -:  693:      }
        -:  694:
    #####:  695:      is_static = false;
    #####:  696:      continue;
        -:  697:    }
        -:  698:
    #####:  699:    uint32_t status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
        -:  700:
    #####:  701:    if (context_p->token.type == LEXER_KEYW_ASYNC)
        -:  702:    {
    #####:  703:      status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  704:
    #####:  705:      if (!lexer_consume_generator (context_p))
        -:  706:      {
    #####:  707:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -:  708:      }
        -:  709:    }
        -:  710:
    #####:  711:    if (context_p->token.type == LEXER_MULTIPLY)
        -:  712:    {
    #####:  713:      lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
    #####:  714:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  715:    }
        -:  716:
    #####:  717:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  718:    {
    #####:  719:      is_computed = true;
        -:  720:    }
    #####:  721:    else if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type))
        -:  722:    {
    #####:  723:      if (is_static)
        -:  724:      {
    #####:  725:        if (lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  726:        {
    #####:  727:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  728:        }
        -:  729:      }
    #####:  730:      else if ((status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION))
    #####:  731:               && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -:  732:      {
    #####:  733:        parser_raise_error (context_p, PARSER_ERR_INVALID_CLASS_CONSTRUCTOR);
        -:  734:      }
        -:  735:    }
        -:  736:
    #####:  737:    if (!(status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION)))
        -:  738:    {
    #####:  739:      if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  740:      {
        -:  741:        /* Class field. */
    #####:  742:        if (fields_size == 0)
        -:  743:        {
    #####:  744:          parser_stack_push_uint8 (context_p, PARSER_CLASS_FIELD_END);
        -:  745:        }
        -:  746:
    #####:  747:        scanner_range_t range;
    #####:  748:        uint8_t class_field_type = is_static ? PARSER_CLASS_FIELD_STATIC : 0;
        -:  749:
    #####:  750:        if (!is_computed)
        -:  751:        {
    #####:  752:          if (is_static && parser_is_constructor_literal (context_p))
        -:  753:          {
    #####:  754:            parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -:  755:          }
        -:  756:
    #####:  757:          range.start_location.source_p = context_p->token.lit_location.char_p;
    #####:  758:          range.start_location.line = context_p->token.line;
    #####:  759:          range.start_location.column = context_p->token.column;
    #####:  760:          class_field_type |= PARSER_CLASS_FIELD_NORMAL;
        -:  761:
    #####:  762:          if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  763:          {
    #####:  764:            range.start_location.source_p--;
        -:  765:          }
        -:  766:        }
        -:  767:        else
        -:  768:        {
    #####:  769:          if (++computed_field_count > ECMA_INTEGER_NUMBER_MAX)
        -:  770:          {
    #####:  771:            parser_raise_error (context_p, PARSER_ERR_TOO_MANY_CLASS_FIELDS);
        -:  772:          }
        -:  773:
    #####:  774:          if (is_static && static_fields_literal_p == NULL)
        -:  775:          {
    #####:  776:            static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####:  777:            parser_emit_cbc_ext_literal (context_p,
        -:  778:                                         CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC,
        -:  779:                                         (uint16_t) (context_p->literal_count++));
        -:  780:          }
        -:  781:          else
        -:  782:          {
    #####:  783:            parser_emit_cbc_ext (context_p, (is_static ? CBC_EXT_ADD_STATIC_COMPUTED_FIELD
        -:  784:                                                       : CBC_EXT_ADD_COMPUTED_FIELD));
        -:  785:          }
        -:  786:        }
        -:  787:
    #####:  788:        if (lexer_consume_assign (context_p))
        -:  789:        {
    #####:  790:          class_field_type |= PARSER_CLASS_FIELD_INITIALIZED;
        -:  791:
    #####:  792:          if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -:  793:          {
    #####:  794:            lexer_next_token (context_p);
    #####:  795:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####:  796:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  797:          }
        -:  798:
    #####:  799:          if (is_computed)
        -:  800:          {
    #####:  801:            scanner_get_location (&range.start_location, context_p);
        -:  802:          }
        -:  803:
    #####:  804:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END);
    #####:  805:          range.source_end_p = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location.source_p;
        -:  806:
    #####:  807:          scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####:  808:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####:  809:          scanner_seek (context_p);
        -:  810:
    #####:  811:          parser_stack_push (context_p, &range, sizeof (scanner_range_t));
    #####:  812:          fields_size += sizeof (scanner_range_t);
        -:  813:        }
        -:  814:        else
        -:  815:        {
    #####:  816:          if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####:  817:              && !lexer_check_next_characters (context_p, LIT_CHAR_SEMICOLON, LIT_CHAR_RIGHT_BRACE))
        -:  818:          {
    #####:  819:            lexer_next_token (context_p);
    #####:  820:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  821:          }
        -:  822:
    #####:  823:          if (!is_computed)
        -:  824:          {
    #####:  825:            parser_stack_push (context_p, &range.start_location, sizeof (scanner_location_t));
    #####:  826:            fields_size += sizeof (scanner_location_t);
        -:  827:          }
        -:  828:        }
        -:  829:
    #####:  830:        parser_stack_push_uint8 (context_p, class_field_type);
    #####:  831:        fields_size++;
    #####:  832:        is_static = false;
    #####:  833:        continue;
        -:  834:      }
        -:  835:
    #####:  836:      if (!is_computed)
        -:  837:      {
    #####:  838:        if (context_p->token.lit_location.type != LEXER_NUMBER_LITERAL)
        -:  839:        {
    #####:  840:          JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
        -:  841:                        || context_p->token.lit_location.type == LEXER_STRING_LITERAL);
    #####:  842:          lexer_construct_literal_object (context_p,
    #####:  843:                                          &context_p->token.lit_location,
        -:  844:                                          LEXER_STRING_LITERAL);
        -:  845:        }
        -:  846:        else
        -:  847:        {
    #####:  848:          lexer_construct_number_object (context_p, false, false);
        -:  849:        }
        -:  850:      }
        -:  851:    }
        -:  852:
    #####:  853:    uint16_t literal_index = context_p->lit_object.index;
    #####:  854:    uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags | PARSER_IS_METHOD);
        -:  855:
    #####:  856:    parser_emit_cbc_literal (context_p,
        -:  857:                             CBC_PUSH_LITERAL,
        -:  858:                             function_literal_index);
        -:  859:
    #####:  860:    if (is_computed)
        -:  861:    {
    #####:  862:      parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####:  863:      parser_emit_cbc_ext (context_p, is_static ? CBC_EXT_SET_STATIC_COMPUTED_PROPERTY
        -:  864:                                                : CBC_EXT_SET_COMPUTED_PROPERTY);
    #####:  865:      is_static = false;
    #####:  866:      continue;
        -:  867:    }
        -:  868:
    #####:  869:    parser_set_function_name (context_p, function_literal_index, literal_index, 0);
        -:  870:
    #####:  871:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  872:
    #####:  873:    context_p->last_cbc.value = literal_index;
        -:  874:
    #####:  875:    if (is_static)
        -:  876:    {
    #####:  877:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_STATIC_PROPERTY_LITERAL);
    #####:  878:      is_static = false;
        -:  879:    }
        -:  880:    else
        -:  881:    {
    #####:  882:      context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
        -:  883:    }
        -:  884:  }
        -:  885:
    #####:  886:  if (fields_size == 0)
        -:  887:  {
    #####:  888:    return false;
        -:  889:  }
        -:  890:
    #####:  891:  parser_reverse_class_fields (context_p, fields_size);
        -:  892:
        -:  893:  /* Since PARSER_IS_ARROW_FUNCTION and PARSER_CLASS_CONSTRUCTOR bits cannot
        -:  894:   * be set at the same time, this bit combination triggers class field parsing. */
        -:  895:
    #####:  896:  if (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC))
        -:  897:  {
    #####:  898:    lexer_literal_t *literal_p = lexer_construct_unused_literal (context_p);
        -:  899:
    #####:  900:    uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####:  901:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_FIELD_INIT, function_literal_index);
    #####:  902:    parser_flush_cbc (context_p);
        -:  903:
    #####:  904:    literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####:  905:    literal_p->type = LEXER_FUNCTION_LITERAL;
        -:  906:  }
        -:  907:
    #####:  908:  bool has_static_field = false;
        -:  909:
    #####:  910:  if (context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC)
        -:  911:  {
    #####:  912:    if (static_fields_literal_p == NULL)
        -:  913:    {
    #####:  914:      static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####:  915:      uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####:  916:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_STATIC_FIELD_FUNC, function_literal_index);
        -:  917:    }
        -:  918:
    #####:  919:    parser_flush_cbc (context_p);
    #####:  920:    static_fields_literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####:  921:    static_fields_literal_p->type = LEXER_FUNCTION_LITERAL;
        -:  922:
    #####:  923:    has_static_field = true;
        -:  924:  }
        -:  925:
    #####:  926:  parser_stack_pop_uint8 (context_p);
    #####:  927:  return has_static_field;
        -:  928:} /* parser_parse_class_body */
        -:  929:
        -:  930:/**
        -:  931: * Parse class statement or expression.
        -:  932: */
        -:  933:void
    #####:  934:parser_parse_class (parser_context_t *context_p, /**< context */
        -:  935:                    bool is_statement) /**< true - if class is parsed as a statement
        -:  936:                                        *   false - otherwise (as an expression) */
        -:  937:{
    #####:  938:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -:  939:
    #####:  940:  uint16_t class_ident_index = PARSER_INVALID_LITERAL_INDEX;
    #####:  941:  uint16_t class_name_index = PARSER_INVALID_LITERAL_INDEX;
    #####:  942:  parser_class_literal_opts_t opts = PARSER_CLASS_LITERAL_NO_OPTS;
        -:  943:
    #####:  944:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  945:  {
    #####:  946:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR);
    #####:  947:    scanner_release_next (context_p, sizeof (scanner_info_t));
    #####:  948:    opts |= PARSER_CLASS_LITERAL_CTOR_PRESENT;
        -:  949:  }
        -:  950:
    #####:  951:  if (is_statement)
        -:  952:  {
        -:  953:    /* Class statement must contain an identifier. */
    #####:  954:    lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
    #####:  955:    JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  956:                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  957:
    #####:  958:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  959:    {
    #####:  960:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####:  961:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  962:    }
    #####:  963:    class_ident_index = context_p->lit_object.index;
        -:  964:
    #####:  965:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
    #####:  966:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####:  967:    class_name_index = context_p->lit_object.index;
        -:  968:
        -:  969:#if JERRY_MODULE_SYSTEM
    #####:  970:    parser_module_append_export_name (context_p);
    #####:  971:    context_p->status_flags &= (uint32_t) ~PARSER_MODULE_STORE_IDENT;
        -:  972:#endif /* JERRY_MODULE_SYSTEM */
        -:  973:
    #####:  974:    lexer_next_token (context_p);
        -:  975:  }
        -:  976:  else
        -:  977:  {
    #####:  978:    lexer_next_token (context_p);
        -:  979:
        -:  980:    /* Class expression may contain an identifier. */
    #####:  981:    if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  982:    {
    #####:  983:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
    #####:  984:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####:  985:      class_name_index = context_p->lit_object.index;
    #####:  986:      lexer_next_token (context_p);
        -:  987:    }
        -:  988:  }
        -:  989:
    #####:  990:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -:  991:  {
    #####:  992:    if (JERRY_UNLIKELY (context_p->scope_stack_top >= context_p->scope_stack_size))
        -:  993:    {
    #####:  994:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####:  995:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -:  996:    }
        -:  997:
    #####:  998:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -:  999:
    #####: 1000:    PARSER_PLUS_EQUAL_U16 (context_p->scope_stack_top, 1);
    #####: 1001:    scope_stack_p->map_from = class_name_index;
    #####: 1002:    scope_stack_p->map_to = 0;
        -: 1003:
    #####: 1004:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_NAMED_CLASS_ENV, class_name_index);
        -: 1005:  }
        -: 1006:  else
        -: 1007:  {
    #####: 1008:    parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 1009:  }
        -: 1010:
    #####: 1011:  bool is_strict = (context_p->status_flags & PARSER_IS_STRICT) != 0;
        -: 1012:
        -: 1013:  /* 14.5. A ClassBody is always strict code. */
    #####: 1014:  context_p->status_flags |= PARSER_IS_STRICT;
        -: 1015:
    #####: 1016:  if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 1017:  {
    #####: 1018:    lexer_next_token (context_p);
    #####: 1019:    parser_parse_expression (context_p, PARSE_EXPR | PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 1020:    opts |= PARSER_CLASS_LITERAL_HERTIAGE_PRESENT;
        -: 1021:  }
        -: 1022:  else
        -: 1023:  {
        -: 1024:    /* Elisions represents that the classHeritage is not present */
    #####: 1025:    parser_emit_cbc (context_p, CBC_PUSH_ELISION);
        -: 1026:  }
        -: 1027:
    #####: 1028:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1029:  {
    #####: 1030:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 1031:  }
        -: 1032:
        -: 1033:  /* ClassDeclaration is parsed. Continue with class body. */
    #####: 1034:  bool has_static_field = parser_parse_class_body (context_p, opts);
        -: 1035:
    #####: 1036:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 1037:  {
    #####: 1038:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_FINALIZE_NAMED_CLASS, class_name_index);
    #####: 1039:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, class_name_index);
    #####: 1040:    PARSER_MINUS_EQUAL_U16 (context_p->scope_stack_top, 1);
        -: 1041:  }
        -: 1042:  else
        -: 1043:  {
    #####: 1044:    parser_emit_cbc_ext (context_p, CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 1045:  }
        -: 1046:
    #####: 1047:  if (has_static_field)
        -: 1048:  {
    #####: 1049:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_STATIC_FIELD_INIT);
        -: 1050:  }
        -: 1051:
    #####: 1052:  if (is_statement)
        -: 1053:  {
    #####: 1054:    cbc_opcode_t opcode = CBC_MOV_IDENT;
        -: 1055:
    #####: 1056:    if (class_ident_index < PARSER_REGISTER_START)
        -: 1057:    {
    #####: 1058:      opcode = (scanner_literal_is_created (context_p, class_ident_index) ? CBC_ASSIGN_LET_CONST
    #####: 1059:                                                                          : CBC_INIT_LET);
        -: 1060:    }
        -: 1061:
    #####: 1062:    parser_emit_cbc_literal (context_p, (uint16_t) opcode, class_ident_index);
    #####: 1063:    parser_flush_cbc (context_p);
        -: 1064:  }
        -: 1065:
    #####: 1066:  if (!is_strict)
        -: 1067:  {
        -: 1068:    /* Restore flag */
    #####: 1069:    context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1070:  }
    #####: 1071:  context_p->status_flags &= (uint32_t) ~PARSER_ALLOW_SUPER;
        -: 1072:
    #####: 1073:  lexer_next_token (context_p);
    #####: 1074:} /* parser_parse_class */
        -: 1075:#endif /* JERRY_ESNEXT */
        -: 1076:
        -: 1077:#if JERRY_ESNEXT
        -: 1078:/**
        -: 1079: * Parse object initializer method definition.
        -: 1080: *
        -: 1081: * See also: ES2015 14.3
        -: 1082: */
        -: 1083:static void
    #####: 1084:parser_parse_object_method (parser_context_t *context_p) /**< context */
        -: 1085:{
    #####: 1086:  context_p->source_p--;
    #####: 1087:  context_p->column--;
    #####: 1088:  uint16_t function_literal_index = lexer_construct_function_object (context_p, (PARSER_FUNCTION_CLOSURE
        -: 1089:                                                                                 | PARSER_ALLOW_SUPER
        -: 1090:                                                                                 | PARSER_IS_METHOD));
        -: 1091:
    #####: 1092:  parser_emit_cbc_literal (context_p,
        -: 1093:                           CBC_PUSH_LITERAL,
        -: 1094:                           function_literal_index);
        -: 1095:
    #####: 1096:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
        -: 1097:
    #####: 1098:  lexer_next_token (context_p);
    #####: 1099:} /* parser_parse_object_method */
        -: 1100:
        -: 1101:/**
        -: 1102: * Reparse the current literal as a common identifier.
        -: 1103: */
        -: 1104:static void
    #####: 1105:parser_reparse_as_common_identifier (parser_context_t *context_p, /**< context */
        -: 1106:                                     parser_line_counter_t start_line, /**< start line */
        -: 1107:                                     parser_line_counter_t start_column) /**< start column */
        -: 1108:{
        -: 1109:  /* context_p->token.lit_location.char_p is showing the character after the string start,
        -: 1110:     so it is not suitable for reparsing as identifier.
        -: 1111:     e.g.: { 'foo' } */
    #####: 1112:  if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1113:  {
    #####: 1114:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1115:  }
        -: 1116:
    #####: 1117:  context_p->source_p = context_p->token.lit_location.char_p;
    #####: 1118:  context_p->line = start_line;
    #####: 1119:  context_p->column = start_column;
        -: 1120:
    #####: 1121:  lexer_next_token (context_p);
        -: 1122:
    #####: 1123:  if (context_p->token.type != LEXER_LITERAL)
        -: 1124:  {
    #####: 1125:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1126:  }
        -: 1127:
    #####: 1128:  JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1129:
    #####: 1130:  lexer_construct_literal_object (context_p,
    #####: 1131:                                  &context_p->token.lit_location,
        -: 1132:                                  LEXER_IDENT_LITERAL);
        -: 1133:
    #####: 1134:} /* parser_reparse_as_common_identifier */
        -: 1135:#endif /* JERRY_ESNEXT */
        -: 1136:
        -: 1137:/**
        -: 1138: * Parse object literal.
        -: 1139: */
        -: 1140:static void
        1: 1141:parser_parse_object_literal (parser_context_t *context_p) /**< context */
        -: 1142:{
        1: 1143:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -: 1144:
        1: 1145:  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);
        -: 1146:
        -: 1147:#if !JERRY_ESNEXT
    #####: 1148:  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);
        -: 1149:#endif /* !JERRY_ESNEXT */
        -: 1150:
        -: 1151:#if JERRY_ESNEXT
        1: 1152:  bool proto_seen = false;
        1: 1153:  bool has_super_env = false;
        -: 1154:
        1: 1155:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1156:  {
    #####: 1157:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 1158:
    #####: 1159:    if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_SUPER)
        -: 1160:    {
    #####: 1161:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT);
    #####: 1162:      has_super_env = true;
        -: 1163:    }
        -: 1164:
    #####: 1165:    scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1166:  }
        -: 1167:#endif /* JERRY_ESNEXT */
        -: 1168:
        -: 1169:  while (true)
        -: 1170:  {
        7: 1171:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_SET_FUNCTION_START);
        -: 1172:
        4: 1173:    switch (context_p->token.type)
        -: 1174:    {
    #####: 1175:      case LEXER_RIGHT_BRACE:
        -: 1176:      {
    #####: 1177:        break;
        -: 1178:      }
        3: 1179:      case LEXER_PROPERTY_GETTER:
        -: 1180:      case LEXER_PROPERTY_SETTER:
        -: 1181:      {
        -: 1182:        uint32_t status_flags;
        -: 1183:        cbc_ext_opcode_t opcode;
        -: 1184:#if !JERRY_ESNEXT
        -: 1185:        parser_object_literal_item_types_t item_type;
        -: 1186:#endif /* !JERRY_ESNEXT */
        3: 1187:        bool is_getter = context_p->token.type == LEXER_PROPERTY_GETTER;
        -: 1188:
        3: 1189:        if (is_getter)
        -: 1190:        {
        2: 1191:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;
        2: 1192:          opcode = CBC_EXT_SET_GETTER;
        -: 1193:#if !JERRY_ESNEXT
        -: 1194:          item_type = PARSER_OBJECT_PROPERTY_GETTER;
        -: 1195:#endif /* !JERRY_ESNEXT */
        -: 1196:        }
        -: 1197:        else
        -: 1198:        {
        1: 1199:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;
        1: 1200:          opcode = CBC_EXT_SET_SETTER;
        -: 1201:#if !JERRY_ESNEXT
    #####: 1202:          item_type = PARSER_OBJECT_PROPERTY_SETTER;
        -: 1203:#endif /* !JERRY_ESNEXT */
        -: 1204:        }
        -: 1205:
        -: 1206:#if JERRY_ESNEXT
        3: 1207:        status_flags |= PARSER_ALLOW_SUPER;
        -: 1208:#endif /* !JERRY_ESNEXT */
        -: 1209:
        3: 1210:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1211:
        -: 1212:        /* This assignment is a nop for computed getters/setters. */
        3: 1213:        uint16_t literal_index = context_p->lit_object.index;
        -: 1214:
        -: 1215:#if JERRY_ESNEXT
        3: 1216:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1217:
        3: 1218:        if (is_computed)
        -: 1219:        {
    #####: 1220:          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER
    #####: 1221:                                                   : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1222:        }
        -: 1223:#else /* !JERRY_ESNEXT */
    #####: 1224:        parser_append_object_literal_item (context_p, literal_index, item_type);
        -: 1225:#endif /* JERRY_ESNEXT */
        -: 1226:
        3: 1227:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1228:
        -: 1229:#if JERRY_ESNEXT
        3: 1230:        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)
        -: 1231:        {
    #####: 1232:          literal_index = function_literal_index;
        -: 1233:        }
        -: 1234:#endif /* JERRY_ESNEXT */
        -: 1235:
        3: 1236:        parser_emit_cbc_literal (context_p,
        -: 1237:                                 CBC_PUSH_LITERAL,
        -: 1238:                                 literal_index);
        -: 1239:
        3: 1240:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1241:
        -: 1242:#if JERRY_ESNEXT
        3: 1243:        if (is_computed)
        -: 1244:        {
    #####: 1245:          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME
        -: 1246:                                                    : CBC_EXT_SET_COMPUTED_SETTER_NAME);
        -: 1247:
    #####: 1248:          if (has_super_env)
        -: 1249:          {
    #####: 1250:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1251:          }
    #####: 1252:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1253:          lexer_next_token (context_p);
    #####: 1254:          break;
        -: 1255:        }
        -: 1256:
        3: 1257:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1258:
        3: 1259:        if (has_super_env)
        -: 1260:        {
    #####: 1261:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1262:          context_p->last_cbc.value = function_literal_index;
    #####: 1263:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
    #####: 1264:          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER
        -: 1265:                                                    : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1266:        }
        -: 1267:        else
        -: 1268:#endif /* JERRY_ESNEXT */
        -: 1269:        {
        3: 1270:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
        3: 1271:          context_p->last_cbc.value = function_literal_index;
        -: 1272:        }
        -: 1273:
        3: 1274:        lexer_next_token (context_p);
        3: 1275:        break;
        -: 1276:      }
        -: 1277:#if JERRY_ESNEXT
    #####: 1278:      case LEXER_RIGHT_SQUARE:
        -: 1279:      {
    #####: 1280:        lexer_next_token (context_p);
        -: 1281:
    #####: 1282:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1283:        {
    #####: 1284:          parser_parse_object_method (context_p);
    #####: 1285:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1286:
    #####: 1287:          if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1288:          {
    #####: 1289:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1290:            if (has_super_env)
        -: 1291:            {
    #####: 1292:              parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1293:            }
    #####: 1294:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1295:          }
        -: 1296:          else
        -: 1297:          {
    #####: 1298:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1299:          }
        -: 1300:
    #####: 1301:          break;
        -: 1302:        }
        -: 1303:
    #####: 1304:        if (context_p->token.type != LEXER_COLON)
        -: 1305:        {
    #####: 1306:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1307:        }
        -: 1308:
    #####: 1309:        lexer_next_token (context_p);
    #####: 1310:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1311:
    #####: 1312:        if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1313:        {
    #####: 1314:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
        -: 1315:        }
        -: 1316:
    #####: 1317:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1318:        {
    #####: 1319:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1320:        }
        -: 1321:        else
        -: 1322:        {
    #####: 1323:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1324:        }
    #####: 1325:        break;
        -: 1326:      }
    #####: 1327:      case LEXER_THREE_DOTS:
        -: 1328:      {
    #####: 1329:        lexer_next_token (context_p);
    #####: 1330:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 1331:        parser_emit_cbc_ext (context_p, CBC_EXT_COPY_DATA_PROPERTIES);
    #####: 1332:        break;
        -: 1333:      }
    #####: 1334:      case LEXER_KEYW_ASYNC:
        -: 1335:      case LEXER_MULTIPLY:
        -: 1336:      {
    #####: 1337:        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -: 1338:
    #####: 1339:        if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 1340:        {
    #####: 1341:          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1342:          lexer_consume_generator (context_p);
        -: 1343:        }
        -: 1344:
    #####: 1345:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1346:        {
    #####: 1347:          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1348:        }
        -: 1349:
    #####: 1350:        if (has_super_env)
        -: 1351:        {
    #####: 1352:          status_flags |= PARSER_ALLOW_SUPER;
        -: 1353:        }
        -: 1354:
    #####: 1355:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1356:
    #####: 1357:        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1358:        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */
    #####: 1359:        uint16_t literal_index = context_p->lit_object.index;
    #####: 1360:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1361:
    #####: 1362:        if (is_computed)
        -: 1363:        {
    #####: 1364:          opcode = CBC_EXT_SET_COMPUTED_PROPERTY;
        -: 1365:        }
        -: 1366:
    #####: 1367:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1368:
    #####: 1369:        parser_emit_cbc_literal (context_p,
        -: 1370:                                 CBC_PUSH_LITERAL,
        -: 1371:                                 function_literal_index);
        -: 1372:
    #####: 1373:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1374:
    #####: 1375:        if (is_computed)
        -: 1376:        {
    #####: 1377:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1378:          if (has_super_env)
        -: 1379:          {
    #####: 1380:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1381:          }
    #####: 1382:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1383:          lexer_next_token (context_p);
    #####: 1384:          break;
        -: 1385:        }
        -: 1386:
    #####: 1387:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1388:
    #####: 1389:        if (has_super_env)
        -: 1390:        {
    #####: 1391:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1392:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1393:        }
        -: 1394:        else
        -: 1395:        {
    #####: 1396:          context_p->last_cbc_opcode = opcode;
    #####: 1397:          context_p->last_cbc.value = literal_index;
        -: 1398:        }
        -: 1399:
    #####: 1400:        lexer_next_token (context_p);
    #####: 1401:        break;
        -: 1402:      }
        -: 1403:#endif /* JERRY_ESNEXT */
        1: 1404:      default:
        -: 1405:      {
        -: 1406:#if JERRY_ESNEXT
        1: 1407:        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;
        2: 1408:        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1409:                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        1: 1410:                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) "__proto__", 9)
        1: 1411:                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));
        1: 1412:        if (is_proto)
        -: 1413:        {
    #####: 1414:          if (proto_seen)
        -: 1415:          {
    #####: 1416:            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);
        -: 1417:          }
        -: 1418:
    #####: 1419:          proto_seen = true;
        -: 1420:        }
        -: 1421:#endif /* JERRY_ESNEXT */
        -: 1422:
        1: 1423:        uint16_t literal_index = context_p->lit_object.index;
        -: 1424:
        -: 1425:#if JERRY_ESNEXT
        1: 1426:        parser_line_counter_t start_line = context_p->token.line;
        1: 1427:        parser_line_counter_t start_column = context_p->token.column;
        -: 1428:#else /* !JERRY_ESNEXT */
    #####: 1429:        parser_append_object_literal_item (context_p,
        -: 1430:                                           literal_index,
        -: 1431:                                           PARSER_OBJECT_PROPERTY_VALUE);
        -: 1432:#endif /* JERRY_ESNEXT */
        -: 1433:
        1: 1434:        lexer_next_token (context_p);
        -: 1435:
        -: 1436:#if JERRY_ESNEXT
        1: 1437:        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)
        -: 1438:        {
    #####: 1439:          parser_parse_object_method (context_p);
        -: 1440:
    #####: 1441:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 1442:          parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1443:
    #####: 1444:          if (has_super_env)
        -: 1445:          {
    #####: 1446:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1447:            parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
    #####: 1448:            break;
        -: 1449:          }
        -: 1450:
    #####: 1451:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1452:          context_p->last_cbc.value = literal_index;
    #####: 1453:          break;
        -: 1454:        }
        -: 1455:
        1: 1456:        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA)
    #####: 1457:            && !is_proto)
        -: 1458:        {
    #####: 1459:          parser_reparse_as_common_identifier (context_p, start_line, start_column);
    #####: 1460:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1461:
    #####: 1462:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1463:          context_p->last_cbc.value = literal_index;
        -: 1464:
    #####: 1465:          lexer_next_token (context_p);
    #####: 1466:          break;
        -: 1467:        }
        -: 1468:#endif /* JERRY_ESNEXT */
        -: 1469:
        1: 1470:        if (context_p->token.type != LEXER_COLON)
        -: 1471:        {
    #####: 1472:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1473:        }
        -: 1474:
        1: 1475:        lexer_next_token (context_p);
        1: 1476:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1477:
        -: 1478:#if JERRY_ESNEXT
        1: 1479:        if (is_proto)
        -: 1480:        {
    #####: 1481:          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);
    #####: 1482:          break;
        -: 1483:        }
        -: 1484:#endif /* JERRY_ESNEXT */
        -: 1485:
        1: 1486:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1487:        {
        -: 1488:#if JERRY_ESNEXT
        1: 1489:          if (context_p->last_cbc.literal_type == LEXER_FUNCTION_LITERAL)
        -: 1490:          {
        1: 1491:            parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1492:          }
        -: 1493:#endif /* JERRY_ESNEXT */
        1: 1494:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
        1: 1495:          context_p->last_cbc.value = literal_index;
        -: 1496:        }
        -: 1497:        else
        -: 1498:        {
        -: 1499:#if JERRY_ESNEXT
    #####: 1500:          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 1501:          {
    #####: 1502:            uint16_t name_index = scanner_save_literal (context_p, literal_index);
    #####: 1503:            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 1504:          }
        -: 1505:#endif /* JERRY_ESNEXT */
    #####: 1506:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1507:        }
        -: 1508:
        1: 1509:        break;
        -: 1510:      }
        -: 1511:    }
        -: 1512:
        4: 1513:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1514:    {
        1: 1515:      break;
        -: 1516:    }
        3: 1517:    else if (context_p->token.type != LEXER_COMMA)
        -: 1518:    {
    #####: 1519:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 1520:    }
        -: 1521:  }
        -: 1522:
        -: 1523:#if !JERRY_ESNEXT
    #####: 1524:  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)
        -: 1525:  {
    #####: 1526:    parser_stack_pop (context_p, NULL, 3);
        -: 1527:  }
        -: 1528:
    #####: 1529:  parser_stack_pop_uint8 (context_p);
        -: 1530:#else /* JERRY_ESNEXT */
        1: 1531:  if (has_super_env)
        -: 1532:  {
    #####: 1533:    parser_emit_cbc_ext (context_p, CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
        -: 1534:  }
        -: 1535:#endif /* !JERRY_ESNEXT */
        1: 1536:} /* parser_parse_object_literal */
        -: 1537:
        -: 1538:/**
        -: 1539: * Parse function literal.
        -: 1540: */
        -: 1541:static void
        1: 1542:parser_parse_function_expression (parser_context_t *context_p, /**< context */
        -: 1543:                                  uint32_t status_flags) /**< function status flags */
        -: 1544:{
        1: 1545:  int literals = 0;
        1: 1546:  uint16_t literal1 = 0;
        1: 1547:  uint16_t literal2 = 0;
        -: 1548:  uint16_t function_literal_index;
        1: 1549:  int32_t function_name_index = -1;
        -: 1550:
        -: 1551:#if !JERRY_ESNEXT
        -: 1552:  JERRY_ASSERT (status_flags & PARSER_IS_FUNC_EXPRESSION);
        -: 1553:#endif /* !JERRY_ESNEXT */
        -: 1554:
        -: 1555:#if JERRY_ESNEXT
        1: 1556:  if (status_flags & PARSER_IS_FUNC_EXPRESSION)
        -: 1557:  {
        -: 1558:#endif /* !JERRY_ESNEXT */
        -: 1559:
        -: 1560:#if JERRY_DEBUGGER
        -: 1561:    parser_line_counter_t debugger_line = context_p->token.line;
        -: 1562:    parser_line_counter_t debugger_column = context_p->token.column;
        -: 1563:#endif /* JERRY_DEBUGGER */
        -: 1564:
        -: 1565:#if JERRY_ESNEXT
    #####: 1566:    uint32_t parent_status_flags = context_p->status_flags;
        -: 1567:
    #####: 1568:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_ASYNC_FUNCTION
        -: 1569:                                            | PARSER_IS_GENERATOR_FUNCTION
        -: 1570:                                            | PARSER_DISALLOW_AWAIT_YIELD);
        -: 1571:
    #####: 1572:    if (status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1573:    {
        -: 1574:      /* The name of the function cannot be await. */
    #####: 1575:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1576:    }
        -: 1577:
    #####: 1578:    if (lexer_consume_generator (context_p))
        -: 1579:    {
        -: 1580:      /* The name of the function cannot be yield. */
    #####: 1581:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1582:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1583:    }
        -: 1584:#endif /* JERRY_ESNEXT */
        -: 1585:
    #####: 1586:    if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1587:    {
    #####: 1588:      lexer_next_token (context_p);
        -: 1589:
    #####: 1590:      if (context_p->token.type != LEXER_LITERAL
    #####: 1591:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1592:      {
    #####: 1593:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1594:      }
        -: 1595:
    #####: 1596:      parser_flush_cbc (context_p);
        -: 1597:
    #####: 1598:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -: 1599:
        -: 1600:#if JERRY_DEBUGGER
        -: 1601:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1602:      {
        -: 1603:        jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -: 1604:                                    JERRY_DEBUGGER_NO_SUBTYPE,
        -: 1605:                                    context_p->lit_object.literal_p->u.char_p,
        -: 1606:                                    context_p->lit_object.literal_p->prop.length);
        -: 1607:
        -: 1608:        /* Reset token position for the function. */
        -: 1609:        context_p->token.line = debugger_line;
        -: 1610:        context_p->token.column = debugger_column;
        -: 1611:      }
        -: 1612:#endif /* JERRY_DEBUGGER */
        -: 1613:
    #####: 1614:      if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1615:      {
    #####: 1616:        status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1617:      }
        -: 1618:
    #####: 1619:      function_name_index = context_p->lit_object.index;
        -: 1620:    }
        -: 1621:
        -: 1622:#if JERRY_ESNEXT
    #####: 1623:    context_p->status_flags = parent_status_flags;
        -: 1624:  }
        -: 1625:#endif /* JERRY_ESNEXT */
        -: 1626:
        1: 1627:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1628:  {
    #####: 1629:    literals = 1;
    #####: 1630:    literal1 = context_p->last_cbc.literal_index;
    #####: 1631:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1632:  }
        1: 1633:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1634:  {
    #####: 1635:    literals = 2;
    #####: 1636:    literal1 = context_p->last_cbc.literal_index;
    #####: 1637:    literal2 = context_p->last_cbc.value;
    #####: 1638:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1639:  }
        -: 1640:
        1: 1641:  function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1642:
        1: 1643:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1644:
        -: 1645:#if JERRY_ESNEXT
        1: 1646:  if (function_name_index != -1)
        -: 1647:  {
    #####: 1648:    parser_set_function_name (context_p, function_literal_index, (uint16_t) function_name_index, 0);
        -: 1649:  }
        -: 1650:#endif /* JERRY_ESNEXT */
        -: 1651:
        1: 1652:  if (literals == 1)
        -: 1653:  {
    #####: 1654:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1655:    context_p->last_cbc.literal_index = literal1;
    #####: 1656:    context_p->last_cbc.value = function_literal_index;
        -: 1657:  }
        1: 1658:  else if (literals == 2)
        -: 1659:  {
    #####: 1660:    context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 1661:    context_p->last_cbc.literal_index = literal1;
    #####: 1662:    context_p->last_cbc.value = literal2;
    #####: 1663:    context_p->last_cbc.third_literal_index = function_literal_index;
        -: 1664:  }
        -: 1665:  else
        -: 1666:  {
        1: 1667:    parser_emit_cbc_literal (context_p,
        -: 1668:                             CBC_PUSH_LITERAL,
        -: 1669:                             function_literal_index);
        -: 1670:
        1: 1671:    if (function_name_index != -1)
        -: 1672:    {
    #####: 1673:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NAMED_FUNC_EXPRESSION);
    #####: 1674:      context_p->last_cbc.value = (uint16_t) function_name_index;
        -: 1675:    }
        -: 1676:  }
        -: 1677:
        1: 1678:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
        1: 1679:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
        1: 1680:} /* parser_parse_function_expression */
        -: 1681:
        -: 1682:#if JERRY_ESNEXT
        -: 1683:
        -: 1684:/**
        -: 1685: * Parse template literal.
        -: 1686: */
        -: 1687:static void
    #####: 1688:parser_parse_template_literal (parser_context_t *context_p) /**< context */
        -: 1689:{
    #####: 1690:  bool is_empty_head = true;
        -: 1691:
    #####: 1692:  if (context_p->token.lit_location.length > 0)
        -: 1693:  {
    #####: 1694:    is_empty_head = false;
        -: 1695:
    #####: 1696:    lexer_construct_literal_object (context_p,
    #####: 1697:                                    &context_p->token.lit_location,
    #####: 1698:                                    context_p->token.lit_location.type);
        -: 1699:
    #####: 1700:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1701:  }
        -: 1702:
    #####: 1703:  lexer_next_token (context_p);
    #####: 1704:  parser_parse_expression (context_p, PARSE_EXPR);
        -: 1705:
    #####: 1706:  if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1707:  {
    #####: 1708:    parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1709:  }
        -: 1710:
    #####: 1711:  if (!is_empty_head)
        -: 1712:  {
    #####: 1713:    if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1714:    {
    #####: 1715:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
        -: 1716:    }
    #####: 1717:    else if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1718:    {
    #####: 1719:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1720:    }
        -: 1721:    else
        -: 1722:    {
    #####: 1723:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1724:    }
        -: 1725:  }
        -: 1726:
    #####: 1727:  context_p->source_p--;
    #####: 1728:  context_p->column--;
    #####: 1729:  lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1730:
    #####: 1731:  if (is_empty_head || context_p->token.lit_location.length > 0)
        -: 1732:  {
    #####: 1733:    lexer_construct_literal_object (context_p,
    #####: 1734:                                    &context_p->token.lit_location,
    #####: 1735:                                    context_p->token.lit_location.type);
        -: 1736:
    #####: 1737:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1738:    {
    #####: 1739:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
    #####: 1740:      context_p->last_cbc.value = context_p->lit_object.index;
    #####: 1741:      context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 1742:      context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        -: 1743:    }
        -: 1744:    else
        -: 1745:    {
    #####: 1746:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1747:    }
        -: 1748:  }
        -: 1749:
    #####: 1750:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1751:  {
    #####: 1752:    lexer_next_token (context_p);
        -: 1753:
    #####: 1754:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1755:
    #####: 1756:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1757:    {
    #####: 1758:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1759:    }
        -: 1760:
    #####: 1761:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1762:    {
    #####: 1763:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1764:    }
        -: 1765:    else
        -: 1766:    {
    #####: 1767:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1768:    }
        -: 1769:
    #####: 1770:    context_p->source_p--;
    #####: 1771:    context_p->column--;
    #####: 1772:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1773:
    #####: 1774:    if (context_p->token.lit_location.length > 0)
        -: 1775:    {
    #####: 1776:      lexer_construct_literal_object (context_p,
    #####: 1777:                                      &context_p->token.lit_location,
    #####: 1778:                                      context_p->token.lit_location.type);
        -: 1779:
    #####: 1780:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1781:    }
        -: 1782:  }
    #####: 1783:} /* parser_parse_template_literal */
        -: 1784:
        -: 1785:/**
        -: 1786: * Parse tagged template literal.
        -: 1787: */
        -: 1788:static size_t
    #####: 1789:parser_parse_tagged_template_literal (parser_context_t *context_p) /**< context */
        -: 1790:{
    #####: 1791:  JERRY_ASSERT (context_p->token.type == LEXER_TEMPLATE_LITERAL);
        -: 1792:
    #####: 1793:  uint32_t call_arguments = 0;
        -: 1794:  ecma_collection_t *collection_p;
        -: 1795:
    #####: 1796:  if (context_p->tagged_template_literal_cp == JMEM_CP_NULL)
        -: 1797:  {
    #####: 1798:    collection_p = ecma_new_collection ();
    #####: 1799:    ECMA_SET_INTERNAL_VALUE_POINTER (context_p->tagged_template_literal_cp, collection_p);
        -: 1800:  }
        -: 1801:  else
        -: 1802:  {
    #####: 1803:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 1804:    if (collection_p->item_count > CBC_MAXIMUM_BYTE_VALUE)
        -: 1805:    {
    #####: 1806:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1807:    }
        -: 1808:  }
        -: 1809:
    #####: 1810:  const uint32_t tagged_id = collection_p->item_count;
    #####: 1811:  uint32_t prop_idx = 0;
    #####: 1812:  ecma_object_t *raw_strings_p;
    #####: 1813:  ecma_object_t *template_obj_p = parser_new_tagged_template_literal (&raw_strings_p);
    #####: 1814:  ecma_collection_push_back (collection_p, ecma_make_object_value (template_obj_p));
        -: 1815:
    #####: 1816:  parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1817:
    #####: 1818:  call_arguments++;
    #####: 1819:  parser_emit_cbc_ext_call (context_p, CBC_EXT_GET_TAGGED_TEMPLATE_LITERAL, tagged_id);
        -: 1820:
    #####: 1821:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1822:  {
    #####: 1823:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LEFT_BRACE);
    #####: 1824:    lexer_next_token (context_p);
        -: 1825:
    #####: 1826:    if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 1827:    {
    #####: 1828:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1829:    }
        -: 1830:
    #####: 1831:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1832:
    #####: 1833:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1834:    {
    #####: 1835:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1836:    }
        -: 1837:
    #####: 1838:    context_p->source_p--;
    #####: 1839:    context_p->column--;
    #####: 1840:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1841:
    #####: 1842:    parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1843:  }
        -: 1844:
    #####: 1845:  parser_tagged_template_literal_finalize (template_obj_p, raw_strings_p);
        -: 1846:
    #####: 1847:  return call_arguments;
        -: 1848:} /* parser_parse_tagged_template_literal */
        -: 1849:
        -: 1850:/**
        -: 1851: * Checks wheteher the current expression can be an assignment expression.
        -: 1852: *
        -: 1853: * @return true if the current expression can be an assignment expression, false otherwise
        -: 1854: */
        -: 1855:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 1856:parser_is_assignment_expr (parser_context_t *context_p)
        -: 1857:{
        1: 1858:  return (context_p->stack_top_uint8 == LEXER_EXPRESSION_START
    #####: 1859:          || context_p->stack_top_uint8 == LEXER_LEFT_PAREN
    #####: 1860:          || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST
        1: 1861:          || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->stack_top_uint8));
        -: 1862:} /* parser_is_assignment_expr */
        -: 1863:
        -: 1864:/**
        -: 1865: * Throws an error if the current expression is not an assignment expression.
        -: 1866: */
        -: 1867:static inline void JERRY_ATTR_ALWAYS_INLINE
        -: 1868:parser_check_assignment_expr (parser_context_t *context_p)
        -: 1869:{
        1: 1870:  if (!parser_is_assignment_expr (context_p))
        -: 1871:  {
    #####: 1872:    parser_raise_error (context_p, PARSER_ERR_ASSIGNMENT_EXPECTED);
        -: 1873:  }
        -: 1874:} /* parser_check_assignment_expr */
        -: 1875:
        -: 1876:/**
        -: 1877: * Checks whether the next token is a valid continuation token after an AssignmentExpression.
        -: 1878: */
        -: 1879:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 1880:parser_abort_parsing_after_assignment_expression (parser_context_t *context_p)
        -: 1881:{
        1: 1882:  return (context_p->token.type != LEXER_RIGHT_PAREN
        1: 1883:          && context_p->token.type != LEXER_COMMA);
        -: 1884:} /* parser_abort_parsing_after_assignment_expression */
        -: 1885:
        -: 1886:#endif /* JERRY_ESNEXT */
        -: 1887:
        -: 1888:/**
        -: 1889: * Parse and record unary operators, and parse the primary literal.
        -: 1890: *
        -: 1891: * @return true if parsing should be aborted, true otherwise
        -: 1892: */
        -: 1893:static bool
       17: 1894:parser_parse_unary_expression (parser_context_t *context_p, /**< context */
        -: 1895:                               size_t *grouping_level_p) /**< grouping level */
        -: 1896:{
       17: 1897:  bool new_was_seen = false;
        -: 1898:
        -: 1899:  /* Collect unary operators. */
        -: 1900:  while (true)
        -: 1901:  {
        -: 1902:    /* Convert plus and minus binary operators to unary operators. */
       19: 1903:    switch (context_p->token.type)
        -: 1904:    {
    #####: 1905:      case LEXER_ADD:
        -: 1906:      {
    #####: 1907:        context_p->token.type = LEXER_PLUS;
    #####: 1908:        break;
        -: 1909:      }
        1: 1910:      case LEXER_SUBTRACT:
        -: 1911:      {
        1: 1912:        context_p->token.type = LEXER_NEGATE;
        1: 1913:        break;
        -: 1914:      }
        -: 1915:#if JERRY_ESNEXT
    #####: 1916:      case LEXER_KEYW_AWAIT:
        -: 1917:      {
        -: 1918:#if JERRY_MODULE_SYSTEM
    #####: 1919:        if ((context_p->global_status_flags & ECMA_PARSE_MODULE)
    #####: 1920:            && !(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION))
        -: 1921:        {
    #####: 1922:          parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);
        -: 1923:        }
        -: 1924:#endif /* JERRY_MODULE_SYSTEM */
        -: 1925:
    #####: 1926:        if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 1927:        {
    #####: 1928:          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 1929:        }
    #####: 1930:        break;
        -: 1931:      }
        -: 1932:#endif /* JERRY_ESNEXT */
        -: 1933:    }
        -: 1934:
        -: 1935:    /* Bracketed expressions are primary expressions. At this
        -: 1936:     * point their left paren is pushed onto the stack and
        -: 1937:     * they are processed when their closing paren is reached. */
       18: 1938:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1939:    {
        -: 1940:#if JERRY_ESNEXT
        1: 1941:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1942:      {
        1: 1943:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        1: 1944:        break;
        -: 1945:      }
        -: 1946:#endif /* JERRY_ESNEXT */
    #####: 1947:      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;
    #####: 1948:      new_was_seen = false;
        -: 1949:    }
       17: 1950:    else if (context_p->token.type == LEXER_KEYW_NEW)
        -: 1951:    {
        -: 1952:      /* After 'new' unary operators are not allowed. */
    #####: 1953:      new_was_seen = true;
        -: 1954:
        -: 1955:#if JERRY_ESNEXT
        -: 1956:      /* Check if "new.target" is written here. */
    #####: 1957:      if (scanner_try_scan_new_target (context_p))
        -: 1958:      {
    #####: 1959:        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))
        -: 1960:        {
    #####: 1961:          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -: 1962:        }
        -: 1963:
    #####: 1964:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);
    #####: 1965:        lexer_next_token (context_p);
        -: 1966:        /* Found "new.target" return here */
    #####: 1967:        return false;
        -: 1968:      }
        -: 1969:#endif /* JERRY_ESNEXT */
        -: 1970:    }
       17: 1971:    else if (new_was_seen
       17: 1972:             || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)
       17: 1973:             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))
        -: 1974:    {
        -: 1975:      break;
        -: 1976:    }
        -: 1977:
        1: 1978:    parser_stack_push_uint8 (context_p, context_p->token.type);
        1: 1979:    lexer_next_token (context_p);
        -: 1980:  }
        -: 1981:
        -: 1982:  /* Parse primary expression. */
       17: 1983:  switch (context_p->token.type)
        -: 1984:  {
        -: 1985:#if JERRY_ESNEXT
    #####: 1986:    case LEXER_TEMPLATE_LITERAL:
        -: 1987:    {
    #####: 1988:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1989:      {
    #####: 1990:        parser_parse_template_literal (context_p);
    #####: 1991:        break;
        -: 1992:      }
        -: 1993:
        -: 1994:      /* The string is a normal string literal. */
        -: 1995:      /* FALLTHRU */
        -: 1996:    }
        -: 1997:#endif /* JERRY_ESNEXT */
    #####: 1998:    case LEXER_LITERAL:
        -: 1999:    {
        -: 2000:#if JERRY_ESNEXT
       12: 2001:      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))
        -: 2002:      {
    #####: 2003:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2004:
        -: 2005:#if JERRY_FUNCTION_TO_STRING
    #####: 2006:        context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2007:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2008:
    #####: 2009:        uint32_t arrow_status_flags = (PARSER_IS_FUNCTION
        -: 2010:                                       | PARSER_IS_ARROW_FUNCTION
    #####: 2011:                                       | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));
        -: 2012:
    #####: 2013:        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -: 2014:        {
    #####: 2015:          JERRY_ASSERT (lexer_token_is_async (context_p));
    #####: 2016:          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));
        -: 2017:
    #####: 2018:          uint32_t saved_status_flags = context_p->status_flags;
        -: 2019:
    #####: 2020:          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 2021:          lexer_next_token (context_p);
    #####: 2022:          context_p->status_flags = saved_status_flags;
        -: 2023:
    #####: 2024:          if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 2025:          {
    #####: 2026:            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE
        -: 2027:                                     | PARSER_IS_FUNC_EXPRESSION
        -: 2028:                                     | PARSER_IS_ASYNC_FUNCTION
        -: 2029:                                     | PARSER_DISALLOW_AWAIT_YIELD);
    #####: 2030:            parser_parse_function_expression (context_p, status_flags);
    #####: 2031:            break;
        -: 2032:          }
        -: 2033:
    #####: 2034:          arrow_status_flags = (PARSER_IS_FUNCTION
        -: 2035:                                | PARSER_IS_ARROW_FUNCTION
        -: 2036:                                | PARSER_IS_ASYNC_FUNCTION
        -: 2037:                                | PARSER_DISALLOW_AWAIT_YIELD);
        -: 2038:        }
        -: 2039:
    #####: 2040:        parser_check_assignment_expr (context_p);
    #####: 2041:        parser_parse_function_expression (context_p, arrow_status_flags);
    #####: 2042:        return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2043:      }
        -: 2044:#endif /* JERRY_ESNEXT */
        -: 2045:
       12: 2046:      uint8_t type = context_p->token.lit_location.type;
        -: 2047:
       12: 2048:      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)
        -: 2049:      {
       16: 2050:        lexer_construct_literal_object (context_p,
        8: 2051:                                        &context_p->token.lit_location,
        8: 2052:                                        context_p->token.lit_location.type);
        -: 2053:      }
        4: 2054:      else if (type == LEXER_NUMBER_LITERAL)
        -: 2055:      {
        4: 2056:        bool is_negative_number = false;
        -: 2057:
        4: 2058:        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)
        1: 2059:            && !lexer_check_post_primary_exp (context_p))
        -: 2060:        {
        -: 2061:          do
        -: 2062:          {
        1: 2063:            if (context_p->stack_top_uint8 == LEXER_NEGATE)
        -: 2064:            {
        1: 2065:              is_negative_number = !is_negative_number;
        -: 2066:            }
        -: 2067:#if JERRY_BUILTIN_BIGINT
    #####: 2068:            else if (JERRY_LIKELY (context_p->token.extra_value == LEXER_NUMBER_BIGINT))
        -: 2069:            {
    #####: 2070:              break;
        -: 2071:            }
        -: 2072:#endif /* JERRY_BUILTIN_BIGINT */
        1: 2073:            parser_stack_pop_uint8 (context_p);
        -: 2074:          }
        1: 2075:          while (context_p->stack_top_uint8 == LEXER_PLUS
        1: 2076:                 || context_p->stack_top_uint8 == LEXER_NEGATE);
        -: 2077:        }
        -: 2078:
        4: 2079:        if (lexer_construct_number_object (context_p, true, is_negative_number))
        -: 2080:        {
        3: 2081:          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -: 2082:
        3: 2083:          parser_emit_cbc_push_number (context_p, is_negative_number);
        3: 2084:          break;
        -: 2085:        }
        -: 2086:      }
        -: 2087:
        9: 2088:      cbc_opcode_t opcode = CBC_PUSH_LITERAL;
        -: 2089:
        9: 2090:      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)
        -: 2091:      {
        9: 2092:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2093:        {
        2: 2094:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        2: 2095:          context_p->last_cbc.value = context_p->lit_object.index;
        2: 2096:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        2: 2097:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        2: 2098:          break;
        -: 2099:        }
        -: 2100:
        7: 2101:        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2102:        {
    #####: 2103:          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2104:          context_p->last_cbc.third_literal_index = context_p->lit_object.index;
    #####: 2105:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 2106:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
    #####: 2107:          break;
        -: 2108:        }
        -: 2109:
        7: 2110:        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2111:        {
    #####: 2112:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2113:          opcode = CBC_PUSH_THIS_LITERAL;
        -: 2114:        }
        -: 2115:      }
        -: 2116:
        7: 2117:      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);
        7: 2118:      break;
        -: 2119:    }
    #####: 2120:    case LEXER_KEYW_FUNCTION:
        -: 2121:    {
        -: 2122:#if JERRY_FUNCTION_TO_STRING
    #####: 2123:      context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2124:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 2125:      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);
    #####: 2126:      break;
        -: 2127:    }
        1: 2128:    case LEXER_LEFT_BRACE:
        -: 2129:    {
        -: 2130:#if JERRY_ESNEXT
        1: 2131:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 2132:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2133:      {
    #####: 2134:        if (parser_is_assignment_expr (context_p))
        -: 2135:        {
    #####: 2136:          uint32_t flags = PARSER_PATTERN_NO_OPTS;
        -: 2137:
    #####: 2138:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 2139:          {
    #####: 2140:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 2141:          }
        -: 2142:
    #####: 2143:          parser_parse_object_initializer (context_p, flags);
    #####: 2144:          return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2145:        }
        -: 2146:
    #####: 2147:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2148:      }
        -: 2149:#endif /* JERRY_ESNEXT */
        -: 2150:
        1: 2151:      parser_parse_object_literal (context_p);
        1: 2152:      break;
        -: 2153:    }
        1: 2154:    case LEXER_LEFT_SQUARE:
        -: 2155:    {
        -: 2156:#if JERRY_ESNEXT
        1: 2157:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2158:      {
    #####: 2159:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2160:        {
    #####: 2161:          if (parser_is_assignment_expr (context_p))
        -: 2162:          {
    #####: 2163:            parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);
    #####: 2164:            return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2165:          }
        -: 2166:
    #####: 2167:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2168:        }
        -: 2169:        else
        -: 2170:        {
    #####: 2171:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 2172:                        && context_p->next_scanner_info_p->u8_arg == SCANNER_LITERAL_NO_DESTRUCTURING);
        -: 2173:
    #####: 2174:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 2175:        }
        -: 2176:      }
        -: 2177:#endif /* JERRY_ESNEXT */
        -: 2178:
        1: 2179:      parser_parse_array_literal (context_p);
        1: 2180:      break;
        -: 2181:    }
    #####: 2182:    case LEXER_DIVIDE:
        -: 2183:    case LEXER_ASSIGN_DIVIDE:
        -: 2184:    {
    #####: 2185:      lexer_construct_regexp_object (context_p, false);
    #####: 2186:      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);
        -: 2187:
    #####: 2188:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2189:      {
    #####: 2190:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 2191:        context_p->last_cbc.value = literal_index;
        -: 2192:      }
    #####: 2193:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2194:      {
    #####: 2195:        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2196:        context_p->last_cbc.third_literal_index = literal_index;
        -: 2197:      }
        -: 2198:      else
        -: 2199:      {
    #####: 2200:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 2201:      }
        -: 2202:
    #####: 2203:      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;
    #####: 2204:      context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 2205:      break;
        -: 2206:    }
    #####: 2207:    case LEXER_KEYW_THIS:
        -: 2208:    {
        -: 2209:#if JERRY_ESNEXT
    #####: 2210:      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)
        -: 2211:      {
    #####: 2212:        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);
        -: 2213:      }
        -: 2214:      else
        -: 2215:      {
        -: 2216:#endif /* JERRY_ESNEXT */
    #####: 2217:        parser_emit_cbc (context_p, CBC_PUSH_THIS);
        -: 2218:#if JERRY_ESNEXT
        -: 2219:      }
        -: 2220:#endif /* JERRY_ESNEXT */
    #####: 2221:      break;
        -: 2222:    }
        1: 2223:    case LEXER_LIT_TRUE:
        -: 2224:    {
        1: 2225:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
        1: 2226:      break;
        -: 2227:    }
    #####: 2228:    case LEXER_LIT_FALSE:
        -: 2229:    {
    #####: 2230:      parser_emit_cbc (context_p, CBC_PUSH_FALSE);
    #####: 2231:      break;
        -: 2232:    }
        1: 2233:    case LEXER_LIT_NULL:
        -: 2234:    {
        1: 2235:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
        1: 2236:      break;
        -: 2237:    }
        -: 2238:#if JERRY_ESNEXT
    #####: 2239:    case LEXER_KEYW_CLASS:
        -: 2240:    {
    #####: 2241:      parser_parse_class (context_p, false);
    #####: 2242:      return false;
        -: 2243:    }
    #####: 2244:    case LEXER_KEYW_SUPER:
        -: 2245:    {
    #####: 2246:      if (context_p->status_flags & PARSER_ALLOW_SUPER)
        -: 2247:      {
    #####: 2248:        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))
        -: 2249:        {
    #####: 2250:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);
    #####: 2251:          break;
        -: 2252:        }
        -: 2253:
    #####: 2254:        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)
    #####: 2255:            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))
        -: 2256:        {
    #####: 2257:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);
    #####: 2258:          break;
        -: 2259:        }
        -: 2260:      }
        -: 2261:
    #####: 2262:      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);
        -: 2263:    }
        1: 2264:    case LEXER_LEFT_PAREN:
        -: 2265:    {
        1: 2266:      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 2267:                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2268:
    #####: 2269:      parser_check_assignment_expr (context_p);
        -: 2270:
        -: 2271:#if JERRY_FUNCTION_TO_STRING
    #####: 2272:      context_p->function_start_p = context_p->source_p - 1;
        -: 2273:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2274:
        1: 2275:      uint32_t arrow_status_flags = (PARSER_IS_FUNCTION
        -: 2276:                                     | PARSER_IS_ARROW_FUNCTION
        1: 2277:                                     | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));
        1: 2278:      parser_parse_function_expression (context_p, arrow_status_flags);
        1: 2279:      return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2280:    }
    #####: 2281:    case LEXER_KEYW_YIELD:
        -: 2282:    {
    #####: 2283:      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2284:                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));
        -: 2285:
    #####: 2286:      if (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 2287:      {
    #####: 2288:        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 2289:      }
        -: 2290:
    #####: 2291:      parser_check_assignment_expr (context_p);
    #####: 2292:      lexer_next_token (context_p);
        -: 2293:
    #####: 2294:      cbc_ext_opcode_t opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD
    #####: 2295:                                                                                      : CBC_EXT_YIELD);
    #####: 2296:      if (!lexer_check_yield_no_arg (context_p))
        -: 2297:      {
    #####: 2298:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 2299:        {
    #####: 2300:          lexer_next_token (context_p);
    #####: 2301:          opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD_ITERATOR
    #####: 2302:                                                                         : CBC_EXT_YIELD_ITERATOR);
        -: 2303:        }
        -: 2304:
    #####: 2305:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2306:      }
        -: 2307:      else
        -: 2308:      {
    #####: 2309:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 2310:      }
        -: 2311:
    #####: 2312:      parser_emit_cbc_ext (context_p, opcode);
        -: 2313:
    #####: 2314:      return (context_p->token.type != LEXER_RIGHT_PAREN
    #####: 2315:              && context_p->token.type != LEXER_COMMA);
        -: 2316:    }
        -: 2317:#endif /* JERRY_ESNEXT */
        -: 2318:#if JERRY_MODULE_SYSTEM
    #####: 2319:    case LEXER_KEYW_IMPORT:
        -: 2320:    {
    #####: 2321:      lexer_next_token (context_p);
        -: 2322:
    #####: 2323:      if (context_p->token.type == LEXER_DOT)
        -: 2324:      {
    #####: 2325:        lexer_next_token (context_p);
        -: 2326:
    #####: 2327:        if (context_p->token.type != LEXER_LITERAL
    #####: 2328:            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL
    #####: 2329:            || context_p->token.keyword_type != LEXER_KEYW_META
    #####: 2330:            || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 2331:        {
    #####: 2332:          parser_raise_error (context_p, PARSER_ERR_META_EXPECTED);
        -: 2333:        }
        -: 2334:
    #####: 2335:        if (!(context_p->global_status_flags & ECMA_PARSE_MODULE))
        -: 2336:        {
    #####: 2337:          parser_raise_error (context_p, PARSER_ERR_IMPORT_META_REQUIRE_MODULE);
        -: 2338:        }
        -: 2339:
    #####: 2340:        JERRY_ASSERT (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META);
        -: 2341:
    #####: 2342:        parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT_META);
    #####: 2343:        break;
        -: 2344:      }
        -: 2345:
    #####: 2346:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2347:      {
    #####: 2348:        parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 2349:      }
        -: 2350:
    #####: 2351:      if (new_was_seen)
        -: 2352:      {
    #####: 2353:        parser_raise_error (context_p, PARSER_ERR_IMPORT_AFTER_NEW);
        -: 2354:      }
        -: 2355:
    #####: 2356:      lexer_next_token (context_p);
    #####: 2357:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2358:
    #####: 2359:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2360:      {
    #####: 2361:        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2362:      }
        -: 2363:
    #####: 2364:      parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT);
    #####: 2365:      break;
        -: 2366:    }
        -: 2367:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2368:    default:
        -: 2369:    {
    #####: 2370:      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 2371:      parser_raise_error (context_p, (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED
        -: 2372:                                                        : PARSER_ERR_UNEXPECTED_END));
    #####: 2373:      break;
        -: 2374:    }
        -: 2375:  }
       16: 2376:  lexer_next_token (context_p);
       16: 2377:  return false;
        -: 2378:} /* parser_parse_unary_expression */
        -: 2379:
        -: 2380:/**
        -: 2381: * Parse the postfix part of unary operators, and
        -: 2382: * generate byte code for the whole expression.
        -: 2383: */
        -: 2384:static void
       23: 2385:parser_process_unary_expression (parser_context_t *context_p, /**< context */
        -: 2386:                                 size_t grouping_level) /**< grouping level */
        -: 2387:{
        -: 2388:  /* Parse postfix part of a primary expression. */
        -: 2389:  while (true)
        -: 2390:  {
        -: 2391:    /* Since break would only break the switch, we use
        -: 2392:     * continue to continue this loop. Without continue,
        -: 2393:     * the code abandons the loop. */
       29: 2394:    switch (context_p->token.type)
        -: 2395:    {
        3: 2396:      case LEXER_DOT:
        -: 2397:      {
        3: 2398:        parser_push_result (context_p);
        -: 2399:
        3: 2400:        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);
        3: 2401:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 2402:                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);
        3: 2403:        context_p->token.lit_location.type = LEXER_STRING_LITERAL;
        -: 2404:
        3: 2405:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2406:        {
        2: 2407:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL,
        -: 2408:                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        2: 2409:          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;
        2: 2410:          context_p->last_cbc.value = context_p->lit_object.index;
        -: 2411:        }
        1: 2412:        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2413:        {
    #####: 2414:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2415:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);
        -: 2416:        }
        -: 2417:#if JERRY_ESNEXT
        1: 2418:        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2419:        {
    #####: 2420:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);
    #####: 2421:          context_p->last_cbc.literal_index = context_p->lit_object.index;
        -: 2422:        }
        -: 2423:#endif /* JERRY_ESNEXT */
        -: 2424:        else
        -: 2425:        {
        1: 2426:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);
        -: 2427:        }
        3: 2428:        lexer_next_token (context_p);
        3: 2429:        continue;
        -: 2430:      }
        -: 2431:
        1: 2432:      case LEXER_LEFT_SQUARE:
        -: 2433:      {
        1: 2434:        parser_push_result (context_p);
        -: 2435:
        -: 2436:#if JERRY_ESNEXT
        1: 2437:        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
        -: 2438:
        1: 2439:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2440:        {
    #####: 2441:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2442:        }
        -: 2443:#endif /* JERRY_ESNEXT */
        -: 2444:
        1: 2445:        lexer_next_token (context_p);
        1: 2446:        parser_parse_expression (context_p, PARSE_EXPR);
        1: 2447:        if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 2448:        {
    #####: 2449:          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);
        -: 2450:        }
        1: 2451:        lexer_next_token (context_p);
        -: 2452:
        -: 2453:#if JERRY_ESNEXT
        1: 2454:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2455:        {
    #####: 2456:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);
    #####: 2457:          continue;
        -: 2458:        }
        -: 2459:#endif /* JERRY_ESNEXT */
        -: 2460:
        1: 2461:        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))
        -: 2462:        {
    #####: 2463:          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);
        -: 2464:        }
        -: 2465:        else
        -: 2466:        {
        1: 2467:          parser_emit_cbc (context_p, CBC_PUSH_PROP);
        -: 2468:        }
        1: 2469:        continue;
        -: 2470:      }
        -: 2471:
        -: 2472:#if JERRY_ESNEXT
        2: 2473:      case LEXER_TEMPLATE_LITERAL:
        -: 2474:#endif /* JERRY_ESNEXT */
    #####: 2475:      case LEXER_LEFT_PAREN:
        -: 2476:      {
        2: 2477:        size_t call_arguments = 0;
        2: 2478:        uint16_t opcode = CBC_CALL;
        2: 2479:        bool is_eval = false;
        -: 2480:
        2: 2481:        parser_push_result (context_p);
        -: 2482:
        2: 2483:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2484:        {
        -: 2485:#if JERRY_ESNEXT
    #####: 2486:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2487:#endif /* JERRY_ESNEXT */
        -: 2488:          {
    #####: 2489:            parser_stack_pop_uint8 (context_p);
    #####: 2490:            opcode = CBC_NEW;
        -: 2491:          }
        -: 2492:        }
        -: 2493:        else
        -: 2494:        {
        2: 2495:          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
        1: 2496:              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL
    #####: 2497:              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2498:          {
    #####: 2499:            is_eval = true;
        -: 2500:          }
        -: 2501:
        2: 2502:          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2503:          {
        1: 2504:            opcode = CBC_CALL_PROP;
        1: 2505:            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 2506:          }
        -: 2507:#if JERRY_ESNEXT
        1: 2508:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))
        -: 2509:          {
    #####: 2510:            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);
        -: 2511:          }
        1: 2512:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2513:          {
    #####: 2514:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);
    #####: 2515:            opcode = CBC_CALL_PROP;
        -: 2516:          }
        1: 2517:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2518:          {
    #####: 2519:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);
    #####: 2520:            opcode = CBC_CALL_PROP;
        -: 2521:          }
        -: 2522:#endif /* JERRY_ESNEXT */
        1: 2523:          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)
    #####: 2524:                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2525:                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2526:          {
    #####: 2527:            opcode = CBC_CALL_PROP;
    #####: 2528:            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
    #####: 2529:            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);
        -: 2530:          }
        -: 2531:        }
        -: 2532:
        -: 2533:#if JERRY_ESNEXT
        2: 2534:        bool has_spread_element = false;
        -: 2535:
        2: 2536:        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)
        -: 2537:        {
    #####: 2538:          call_arguments = parser_parse_tagged_template_literal (context_p);
        -: 2539:        }
        -: 2540:        else
        -: 2541:        {
        2: 2542:          lexer_next_token (context_p);
        -: 2543:
        2: 2544:          while (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2545:          {
        3: 2546:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2547:            {
    #####: 2548:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2549:            }
        -: 2550:
        3: 2551:            if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2552:            {
    #####: 2553:              has_spread_element = true;
    #####: 2554:              call_arguments++;
    #####: 2555:              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
    #####: 2556:              lexer_next_token (context_p);
        -: 2557:            }
        -: 2558:
        3: 2559:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2560:
        3: 2561:            if (context_p->token.type == LEXER_COMMA)
        -: 2562:            {
        1: 2563:              lexer_next_token (context_p);
        1: 2564:              continue;
        -: 2565:            }
        -: 2566:
        2: 2567:            if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2568:            {
    #####: 2569:              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2570:            }
        -: 2571:
        2: 2572:            break;
        -: 2573:          }
        -: 2574:        }
        -: 2575:#else /* !JERRY_ESNEXT */
    #####: 2576:        lexer_next_token (context_p);
        -: 2577:
    #####: 2578:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2579:        {
        -: 2580:          while (true)
        -: 2581:          {
    #####: 2582:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2583:            {
    #####: 2584:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2585:            }
        -: 2586:
    #####: 2587:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2588:
    #####: 2589:            if (context_p->token.type != LEXER_COMMA)
        -: 2590:            {
        -: 2591:              break;
        -: 2592:            }
    #####: 2593:            lexer_next_token (context_p);
        -: 2594:          }
        -: 2595:
    #####: 2596:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2597:          {
    #####: 2598:            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2599:          }
        -: 2600:        }
        -: 2601:#endif /* JERRY_ESNEXT */
        -: 2602:
        2: 2603:        lexer_next_token (context_p);
        -: 2604:
        2: 2605:        if (is_eval)
        -: 2606:        {
    #####: 2607:          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2608:
        -: 2609:#if JERRY_ESNEXT
    #####: 2610:          uint16_t eval_flags = PARSER_SAVE_STATUS_FLAGS (context_p->status_flags);
    #####: 2611:          const uint32_t required_flags = PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2612:
    #####: 2613:          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2614:          {
    #####: 2615:            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2616:          }
    #####: 2617:          else if (((context_p->status_flags & (required_flags | PARSER_IS_STRICT)) == required_flags)
    #####: 2618:                   || ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2619:                       && !(context_p->status_flags & PARSER_IS_FUNCTION)))
        -: 2620:          {
    #####: 2621:            eval_flags |= PARSER_GET_EVAL_FLAG (ECMA_PARSE_FUNCTION_CONTEXT);
        -: 2622:          }
        -: 2623:
    #####: 2624:          if (eval_flags != 0)
        -: 2625:          {
    #####: 2626:            parser_emit_cbc_ext_call (context_p, CBC_EXT_LOCAL_EVAL, eval_flags);
        -: 2627:          }
        -: 2628:          else
        -: 2629:          {
        -: 2630:#endif /* JERRY_ESNEXT */
    #####: 2631:            parser_emit_cbc (context_p, CBC_EVAL);
        -: 2632:#if JERRY_ESNEXT
        -: 2633:          }
        -: 2634:#endif /* JERRY_ESNEXT */
        -: 2635:        }
        -: 2636:
        -: 2637:#if JERRY_ESNEXT
        2: 2638:        if (has_spread_element)
        -: 2639:        {
        -: 2640:          uint16_t spread_opcode;
        -: 2641:
    #####: 2642:          if (opcode == CBC_CALL)
        -: 2643:          {
    #####: 2644:            spread_opcode = CBC_EXT_SPREAD_CALL;
        -: 2645:          }
    #####: 2646:          else if (opcode == CBC_CALL_PROP)
        -: 2647:          {
    #####: 2648:            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;
        -: 2649:          }
    #####: 2650:          else if (opcode == CBC_NEW)
        -: 2651:          {
    #####: 2652:            spread_opcode = CBC_EXT_SPREAD_NEW;
        -: 2653:          }
        -: 2654:          else
        -: 2655:          {
        -: 2656:            /* opcode is unchanged */
    #####: 2657:            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));
    #####: 2658:            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;
        -: 2659:          }
        -: 2660:
    #####: 2661:          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);
    #####: 2662:          continue;
        -: 2663:        }
        -: 2664:#endif /* JERRY_ESNEXT */
        -: 2665:
        2: 2666:        if (call_arguments <= 1)
        -: 2667:        {
        1: 2668:          if (opcode == CBC_CALL)
        -: 2669:          {
        1: 2670:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));
        1: 2671:            continue;
        -: 2672:          }
    #####: 2673:          if (opcode == CBC_CALL_PROP)
        -: 2674:          {
    #####: 2675:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));
    #####: 2676:            continue;
        -: 2677:          }
    #####: 2678:          if (opcode == CBC_NEW)
        -: 2679:          {
    #####: 2680:            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));
    #####: 2681:            continue;
        -: 2682:          }
        -: 2683:        }
        1: 2684:        else if (call_arguments == 2)
        -: 2685:        {
        1: 2686:          if (opcode == CBC_CALL)
        -: 2687:          {
    #####: 2688:            parser_emit_cbc (context_p, CBC_CALL2);
    #####: 2689:            continue;
        -: 2690:          }
        1: 2691:          if (opcode == CBC_CALL_PROP)
        -: 2692:          {
        1: 2693:            parser_flush_cbc (context_p);
        -: 2694:            /* Manually adjusting stack usage. */
        1: 2695:            JERRY_ASSERT (context_p->stack_depth > 0);
        1: 2696:            context_p->stack_depth--;
        1: 2697:            parser_emit_cbc (context_p, CBC_CALL2_PROP);
        1: 2698:            continue;
        -: 2699:          }
        -: 2700:        }
        -: 2701:
    #####: 2702:        parser_emit_cbc_call (context_p, opcode, call_arguments);
    #####: 2703:        continue;
        -: 2704:      }
        -: 2705:
       17: 2706:      default:
        -: 2707:      {
       17: 2708:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2709:        {
    #####: 2710:          parser_push_result (context_p);
    #####: 2711:          parser_emit_cbc (context_p, CBC_NEW0);
    #####: 2712:          parser_stack_pop_uint8 (context_p);
    #####: 2713:          continue;
        -: 2714:        }
        -: 2715:
       17: 2716:        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
       17: 2717:            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)
        1: 2718:            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)
        -: 2719:        {
        1: 2720:          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;
        1: 2721:          parser_push_result (context_p);
        1: 2722:          parser_emit_unary_lvalue_opcode (context_p, opcode);
        1: 2723:          lexer_next_token (context_p);
        -: 2724:        }
       17: 2725:        break;
        -: 2726:      }
        -: 2727:    }
       17: 2728:    break;
        -: 2729:  }
        -: 2730:
        -: 2731:#if JERRY_ESNEXT
       17: 2732:  uint8_t last_unary_token = LEXER_INCREASE;
        -: 2733:#endif /* JERRY_ESNEXT */
        -: 2734:
        -: 2735:  /* Generate byte code for the unary operators. */
        -: 2736:  while (true)
    #####: 2737:  {
       17: 2738:    uint8_t token = context_p->stack_top_uint8;
       17: 2739:    if (!LEXER_IS_UNARY_OP_TOKEN (token))
        -: 2740:    {
        -: 2741:#if JERRY_ESNEXT
       17: 2742:      if (context_p->token.type == LEXER_EXPONENTIATION
    #####: 2743:          && last_unary_token != LEXER_INCREASE
    #####: 2744:          && last_unary_token != LEXER_DECREASE)
        -: 2745:      {
    #####: 2746:        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);
        -: 2747:      }
        -: 2748:#endif /* JERRY_ESNEXT */
       17: 2749:      break;
        -: 2750:    }
        -: 2751:
        -: 2752:#if JERRY_ESNEXT
    #####: 2753:    last_unary_token = token;
        -: 2754:#endif /* JERRY_ESNEXT */
        -: 2755:
    #####: 2756:    parser_push_result (context_p);
    #####: 2757:    parser_stack_pop_uint8 (context_p);
        -: 2758:
    #####: 2759:    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))
        -: 2760:    {
    #####: 2761:      if (token == LEXER_KEYW_DELETE)
        -: 2762:      {
    #####: 2763:        token = CBC_DELETE_PUSH_RESULT;
        -: 2764:      }
        -: 2765:      else
        -: 2766:      {
    #####: 2767:        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));
        -: 2768:      }
    #####: 2769:      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);
        -: 2770:    }
        -: 2771:#if JERRY_ESNEXT
    #####: 2772:    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))
        -: 2773:    {
    #####: 2774:      cbc_ext_opcode_t opcode = ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION) ? CBC_EXT_GENERATOR_AWAIT
    #####: 2775:                                                                                          : CBC_EXT_AWAIT);
    #####: 2776:      parser_emit_cbc_ext (context_p, opcode);
        -: 2777:    }
        -: 2778:#endif /* JERRY_ESNEXT */
        -: 2779:    else
        -: 2780:    {
    #####: 2781:      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));
        -: 2782:
    #####: 2783:      if (token == CBC_TYPEOF)
        -: 2784:      {
    #####: 2785:        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2786:            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2787:        {
    #####: 2788:          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);
        -: 2789:        }
        -: 2790:        else
        -: 2791:        {
    #####: 2792:          parser_emit_cbc (context_p, token);
        -: 2793:        }
        -: 2794:      }
        -: 2795:      else
        -: 2796:      {
    #####: 2797:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2798:        {
        -: 2799:          /* It is not worth to combine with push multiple literals
        -: 2800:           * since the byte code size will not decrease. */
    #####: 2801:          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));
    #####: 2802:          context_p->last_cbc_opcode = (uint16_t) (token + 1);
        -: 2803:        }
        -: 2804:        else
        -: 2805:        {
    #####: 2806:          parser_emit_cbc (context_p, token);
        -: 2807:        }
        -: 2808:      }
        -: 2809:    }
        -: 2810:  }
       17: 2811:} /* parser_process_unary_expression */
        -: 2812:
        -: 2813:/**
        -: 2814: * Append a binary '=' token.
        -: 2815: *
        -: 2816: * @return - pushed assignment opcode onto the parser stack
        -: 2817: */
        -: 2818:static void
    #####: 2819:parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */
        -: 2820:                                              uint32_t pattern_flags) /**< pattern flags */
        -: 2821:{
        -: 2822:  JERRY_UNUSED (pattern_flags);
        -: 2823:
        -: 2824:  /* Unlike other tokens, the whole byte code is saved for binary
        -: 2825:   * assignment, since it has multiple forms depending on the
        -: 2826:   * previous instruction. */
        -: 2827:
    #####: 2828:  uint8_t assign_opcode = CBC_ASSIGN;
        -: 2829:
    #####: 2830:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2831:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
    #####: 2832:  {
    #####: 2833:    parser_check_invalid_assign (context_p);
        -: 2834:
        -: 2835:    uint16_t literal_index;
        -: 2836:
    #####: 2837:    switch (context_p->last_cbc_opcode)
        -: 2838:    {
    #####: 2839:      case CBC_PUSH_LITERAL:
        -: 2840:      {
    #####: 2841:        literal_index = context_p->last_cbc.literal_index;
    #####: 2842:        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2843:        break;
        -: 2844:      }
    #####: 2845:      case CBC_PUSH_TWO_LITERALS:
        -: 2846:      {
    #####: 2847:        literal_index = context_p->last_cbc.value;
    #####: 2848:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 2849:        break;
        -: 2850:      }
    #####: 2851:      case CBC_PUSH_THIS_LITERAL:
        -: 2852:      {
    #####: 2853:        literal_index = context_p->last_cbc.literal_index;
    #####: 2854:        context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####: 2855:        parser_flush_cbc (context_p);
    #####: 2856:        break;
        -: 2857:      }
    #####: 2858:      default:
        -: 2859:      {
    #####: 2860:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####: 2861:        literal_index = context_p->last_cbc.third_literal_index;
    #####: 2862:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 2863:        break;
        -: 2864:      }
        -: 2865:    }
        -: 2866:
    #####: 2867:    assign_opcode = CBC_ASSIGN_SET_IDENT;
        -: 2868:
        -: 2869:#if JERRY_ESNEXT
    #####: 2870:    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))
        -: 2871:    {
    #####: 2872:      if (scanner_literal_is_const_reg (context_p, literal_index))
        -: 2873:      {
    #####: 2874:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 2875:      }
        -: 2876:    }
    #####: 2877:    else if (literal_index < PARSER_REGISTER_START)
        -: 2878:    {
    #####: 2879:      assign_opcode = CBC_INIT_LET;
        -: 2880:
    #####: 2881:      if (scanner_literal_is_created (context_p, literal_index))
        -: 2882:      {
    #####: 2883:        assign_opcode = CBC_ASSIGN_LET_CONST;
        -: 2884:      }
    #####: 2885:      else if (pattern_flags & PARSER_PATTERN_CONST)
        -: 2886:      {
    #####: 2887:        assign_opcode = CBC_INIT_CONST;
        -: 2888:      }
    #####: 2889:      else if (pattern_flags & PARSER_PATTERN_LOCAL)
        -: 2890:      {
    #####: 2891:        assign_opcode = CBC_INIT_ARG_OR_CATCH;
        -: 2892:      }
        -: 2893:    }
        -: 2894:#endif /* JERRY_ESNEXT */
        -: 2895:
    #####: 2896:    parser_stack_push_uint16 (context_p, literal_index);
    #####: 2897:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));
        -: 2898:  }
    #####: 2899:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -: 2900:  {
    #####: 2901:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));
    #####: 2902:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2903:  }
    #####: 2904:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)
        -: 2905:  {
    #####: 2906:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 2907:    {
    #####: 2908:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));
    #####: 2909:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 2910:      assign_opcode = CBC_ASSIGN_PROP_LITERAL;
    #####: 2911:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2912:    }
        -: 2913:    else
        -: 2914:    {
    #####: 2915:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
        -: 2916:    }
        -: 2917:  }
    #####: 2918:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 2919:  {
    #####: 2920:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));
    #####: 2921:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        -: 2922:  }
    #####: 2923:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 2924:  {
    #####: 2925:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 2926:    {
    #####: 2927:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));
    #####: 2928:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 2929:      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;
    #####: 2930:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2931:    }
        -: 2932:    else
        -: 2933:    {
    #####: 2934:      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
        -: 2935:    }
        -: 2936:  }
        -: 2937:#if JERRY_ESNEXT
    #####: 2938:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2939:  {
    #####: 2940:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 2941:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
    #####: 2942:    assign_opcode = CBC_EXT_OPCODE;
        -: 2943:  }
    #####: 2944:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2945:  {
    #####: 2946:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);
    #####: 2947:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
    #####: 2948:    assign_opcode = CBC_EXT_OPCODE;
        -: 2949:  }
        -: 2950:#endif /* JERRY_ESNEXT */
        -: 2951:  else
        -: 2952:  {
        -: 2953:    /* Invalid LeftHandSide expression. */ //3820, 3815
        -: 2954:#if JERRY_ESNEXT
    #####: 2955:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 2956:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 2957:#else /* !JERRY_ESNEXT */
    #####: 2958:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 2959:#endif /* JERRY_ESNEXT */
        -: 2960:  }
        -: 2961:
    #####: 2962:  parser_stack_push_uint8 (context_p, assign_opcode);
    #####: 2963:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 2964:} /* parser_append_binary_single_assignment_token */
        -: 2965:
        -: 2966:#if JERRY_ESNEXT
        -: 2967:
        -: 2968:/**
        -: 2969: * Check for invalid chain of logical operators
        -: 2970: */
        -: 2971:static void
    #####: 2972:parser_check_invalid_logical_op (parser_context_t *context_p, /**< context */
        -: 2973:                                 uint8_t invalid_token1, /**< token id of first invalid token */
        -: 2974:                                 uint8_t invalid_token2) /**< token id of second invalid token */
        -: 2975:{
    #####: 2976:  parser_stack_iterator_t iterator;
    #####: 2977:  parser_stack_iterator_init (context_p, &iterator);
        -: 2978:
        -: 2979:  while (true)
    #####: 2980:  {
    #####: 2981:    uint8_t token = parser_stack_iterator_read_uint8 (&iterator);
        -: 2982:
    #####: 2983:    if (!LEXER_IS_BINARY_NON_LVALUE_OP_TOKEN (token))
        -: 2984:    {
    #####: 2985:      return;
        -: 2986:    }
        -: 2987:
    #####: 2988:    if (token == invalid_token1 || token == invalid_token2)
        -: 2989:    {
    #####: 2990:      parser_raise_error (context_p, PARSER_ERR_INVALID_NULLISH_COALESCING);
        -: 2991:    }
        -: 2992:
        -: 2993:    /* If a logical operator is found, and there is no SyntaxError, the scan can be terminated
        -: 2994:     * since there was no SyntaxError when the logical operator was pushed onto the stack. */
    #####: 2995:    if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND || token == LEXER_NULLISH_COALESCING)
        -: 2996:    {
    #####: 2997:      return;
        -: 2998:    }
        -: 2999:
    #####: 3000:    parser_stack_iterator_skip (&iterator, sizeof (uint8_t));
        -: 3001:  }
        -: 3002:} /* parser_check_invalid_logical_op */
        -: 3003:
        -: 3004:#endif /* JERRY_ESNEXT */
        -: 3005:
        -: 3006:/**
        -: 3007: * Append a binary token.
        -: 3008: */
        -: 3009:static void
        1: 3010:parser_append_binary_token (parser_context_t *context_p) /**< context */
        -: 3011:{
        1: 3012:  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));
        1: 3013:  parser_push_result (context_p);
        -: 3014:
        1: 3015:  if (context_p->token.type == LEXER_ASSIGN)
        -: 3016:  {
    #####: 3017:    parser_append_binary_single_assignment_token (context_p, 0);
    #####: 3018:    return;
        -: 3019:  }
        -: 3020:
        1: 3021:  if (LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->token.type))
        -: 3022:  {
    #####: 3023:    if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 3024:        && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 3025:    {
    #####: 3026:      parser_check_invalid_assign (context_p);
        -: 3027:
    #####: 3028:      parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
        -: 3029:
        -: 3030:#if JERRY_ESNEXT
    #####: 3031:      if (scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -: 3032:      {
    #####: 3033:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 3034:      }
        -: 3035:#endif /* JERRY_ESNEXT */
        -: 3036:    }
    #####: 3037:    else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3038:    {
    #####: 3039:      context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 3040:    }
        -: 3041:    else
        -: 3042:    {
        -: 3043:      /* Invalid LeftHandSide expression. */
        -: 3044:#if JERRY_ESNEXT
    #####: 3045:      parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 3046:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3047:#else /* !JERRY_ESNEXT */
    #####: 3048:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 3049:#endif /* JERRY_ESNEXT */
        -: 3050:
    #####: 3051:      parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);
        -: 3052:    }
        -: 3053:  }
        1: 3054:  else if (context_p->token.type == LEXER_LOGICAL_OR
        1: 3055:           || context_p->token.type == LEXER_LOGICAL_AND)
        -: 3056:  {
    #####: 3057:    parser_branch_t branch;
    #####: 3058:    uint16_t opcode = CBC_BRANCH_IF_LOGICAL_TRUE;
        -: 3059:
    #####: 3060:    if (context_p->token.type == LEXER_LOGICAL_AND)
        -: 3061:    {
    #####: 3062:      opcode = CBC_BRANCH_IF_LOGICAL_FALSE;
        -: 3063:    }
        -: 3064:
        -: 3065:#if JERRY_ESNEXT
    #####: 3066:    parser_check_invalid_logical_op (context_p, LEXER_NULLISH_COALESCING, LEXER_NULLISH_COALESCING);
        -: 3067:#endif /* JERRY_ESNEXT */
        -: 3068:
    #####: 3069:    parser_emit_cbc_forward_branch (context_p, opcode, &branch);
    #####: 3070:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
    #####: 3071:    parser_stack_push_uint8 (context_p, context_p->token.type);
    #####: 3072:    return;
        -: 3073:  }
        -: 3074:#if JERRY_ESNEXT
        1: 3075:  else if (context_p->token.type == LEXER_NULLISH_COALESCING)
        -: 3076:  {
    #####: 3077:    parser_branch_t branch;
        -: 3078:
    #####: 3079:    uint16_t opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH);
    #####: 3080:    parser_emit_cbc_forward_branch (context_p, opcode, &branch);
    #####: 3081:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
    #####: 3082:    parser_stack_push_uint8 (context_p, context_p->token.type);
    #####: 3083:    return;
        -: 3084:  }
        -: 3085:#endif /* JERRY_ESNEXT */
        -: 3086:
        1: 3087:  parser_stack_push_uint8 (context_p, context_p->token.type);
        -: 3088:} /* parser_append_binary_token */
        -: 3089:
        -: 3090:/**
        -: 3091: * Emit opcode for binary computations.
        -: 3092: */
        -: 3093:static void
       19: 3094:parser_process_binary_opcodes (parser_context_t *context_p, /**< context */
        -: 3095:                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */
        -: 3096:{
        -: 3097:  while (true)
        1: 3098:  {
       19: 3099:    uint8_t token = context_p->stack_top_uint8;
        -: 3100:    uint16_t opcode;
        -: 3101:
        -: 3102:    /* For left-to-right operators (all binary operators except assignment
        -: 3103:     * and logical operators), the byte code is flushed if the precedence
        -: 3104:     * of the next operator is less or equal than the current operator. For
        -: 3105:     * assignment and logical operators, we add 1 to the min precendence to
        -: 3106:     * force right-to-left evaluation order. */
        -: 3107:
       19: 3108:    if (!LEXER_IS_BINARY_OP_TOKEN (token)
        1: 3109:        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)
        -: 3110:    {
       36: 3111:      return;
        -: 3112:    }
        -: 3113:
        1: 3114:    parser_push_result (context_p);
        1: 3115:    parser_stack_pop_uint8 (context_p);
        -: 3116:
        1: 3117:    if (token == LEXER_ASSIGN)
        -: 3118:    {
    #####: 3119:      uint16_t index = PARSER_INVALID_LITERAL_INDEX;
    #####: 3120:      opcode = context_p->stack_top_uint8;
        -: 3121:
        -: 3122:#if JERRY_ESNEXT
    #####: 3123:      if (JERRY_UNLIKELY (opcode == CBC_EXT_OPCODE))
        -: 3124:      {
    #####: 3125:        parser_stack_pop_uint8 (context_p);
    #####: 3126:        JERRY_ASSERT (context_p->stack_top_uint8 == CBC_EXT_ASSIGN_SUPER);
    #####: 3127:        opcode = PARSER_TO_EXT_OPCODE (context_p->stack_top_uint8);
    #####: 3128:        parser_stack_pop_uint8 (context_p);
        -: 3129:      }
        -: 3130:      else
        -: 3131:#endif /* JERRY_ESNEXT */
        -: 3132:      {
    #####: 3133:        parser_stack_pop_uint8 (context_p);
        -: 3134:
    #####: 3135:        if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)
        -: 3136:        {
    #####: 3137:          JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT
        -: 3138:                        || opcode == CBC_ASSIGN_PROP_LITERAL
        -: 3139:                        || opcode == CBC_ASSIGN_PROP_THIS_LITERAL
        -: 3140:                        || opcode == CBC_ASSIGN_LET_CONST
        -: 3141:                        || opcode == CBC_INIT_ARG_OR_CATCH
        -: 3142:                        || opcode == CBC_INIT_LET
        -: 3143:                        || opcode == CBC_INIT_CONST);
        -: 3144:
    #####: 3145:          index = parser_stack_pop_uint16 (context_p);
        -: 3146:        }
        -: 3147:      }
        -: 3148:
        -: 3149:#if JERRY_ESNEXT
    #####: 3150:      bool group_expr_assingment = false;
        -: 3151:
    #####: 3152:      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_GROUP_EXPR))
        -: 3153:      {
    #####: 3154:        group_expr_assingment = true;
    #####: 3155:        parser_stack_pop_uint8 (context_p);
        -: 3156:      }
        -: 3157:
    #####: 3158:      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))
        -: 3159:      {
    #####: 3160:        parser_stack_pop_uint8 (context_p);
    #####: 3161:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -: 3162:      }
        -: 3163:#endif /* JERRY_ESNEXT */
        -: 3164:
    #####: 3165:      if (index != PARSER_INVALID_LITERAL_INDEX)
        -: 3166:      {
        -: 3167:#if JERRY_ESNEXT
    #####: 3168:        if (!group_expr_assingment)
        -: 3169:        {
    #####: 3170:          uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3171:
    #####: 3172:          if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3173:          {
    #####: 3174:            uint16_t name_index = scanner_save_literal (context_p, index);
    #####: 3175:            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3176:          }
    #####: 3177:          else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3178:          {
    #####: 3179:            parser_set_function_name (context_p, function_literal_index, (uint16_t) index, 0);
        -: 3180:          }
        -: 3181:        }
        -: 3182:#endif /* JERRY_ESNEXT */
        -: 3183:
    #####: 3184:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
    #####: 3185:            && opcode == CBC_ASSIGN_SET_IDENT)
        -: 3186:        {
    #####: 3187:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT,
        -: 3188:                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -: 3189:
    #####: 3190:          context_p->last_cbc.value = index;
    #####: 3191:          context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;
    #####: 3192:          continue;
        -: 3193:        }
        -: 3194:
    #####: 3195:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -: 3196:
    #####: 3197:        if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL
    #####: 3198:            && (context_p->stack_depth >= context_p->stack_limit))
        -: 3199:        {
        -: 3200:          /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */
    #####: 3201:          JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -: 3202:
    #####: 3203:          context_p->stack_limit++;
        -: 3204:
    #####: 3205:          if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3206:          {
    #####: 3207:            parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3208:          }
        -: 3209:        }
    #####: 3210:        continue;
        -: 3211:      }
        -: 3212:    }
        1: 3213:    else if (LEXER_IS_BINARY_LVALUE_OP_TOKEN (token))
        -: 3214:    {
    #####: 3215:      parser_stack_push_uint8 (context_p, CBC_ASSIGN);
    #####: 3216:      parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 3217:      parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));
    #####: 3218:      continue;
        -: 3219:    }
        1: 3220:    else if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND)
        -: 3221:    {
    #####: 3222:      parser_branch_t branch;
    #####: 3223:      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####: 3224:      parser_set_branch_to_current_position (context_p, &branch);
    #####: 3225:      continue;
        -: 3226:    }
        -: 3227:#if JERRY_ESNEXT
        1: 3228:    else if (token == LEXER_NULLISH_COALESCING)
        -: 3229:    {
    #####: 3230:      parser_branch_t branch;
    #####: 3231:      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####: 3232:      parser_set_branch_to_current_position (context_p, &branch);
    #####: 3233:      continue;
        -: 3234:    }
        -: 3235:#endif /* JERRY_ESNEXT */
        -: 3236:    else
        -: 3237:    {
        1: 3238:      opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);
        -: 3239:
        1: 3240:      if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))
        -: 3241:      {
        1: 3242:        lexer_convert_push_number_to_push_literal (context_p);
        -: 3243:      }
        -: 3244:
        1: 3245:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3246:      {
        1: 3247:        JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));
        1: 3248:        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);
        1: 3249:        continue;
        -: 3250:      }
    #####: 3251:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3252:      {
    #####: 3253:        JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS,
        -: 3254:                                   CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
    #####: 3255:        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);
    #####: 3256:        continue;
        -: 3257:      }
        -: 3258:    }
    #####: 3259:    parser_emit_cbc (context_p, opcode);
        -: 3260:  }
        -: 3261:} /* parser_process_binary_opcodes */
        -: 3262:
        -: 3263:#if JERRY_ESNEXT
        -: 3264:/**
        -: 3265: * End position marker of a pattern.
        -: 3266: */
        -: 3267:typedef struct
        -: 3268:{
        -: 3269:  scanner_location_t location; /**< end position of the pattern */
        -: 3270:  lexer_token_t token; /**< token at the end position */
        -: 3271:} parser_pattern_end_marker_t;
        -: 3272:
        -: 3273:/**
        -: 3274: * Literal index should not be emitted while processing rhs target value
        -: 3275: */
        -: 3276:#define PARSER_PATTERN_RHS_NO_LIT PARSER_INVALID_LITERAL_INDEX
        -: 3277:
        -: 3278:/**
        -: 3279: * Process the target of an initializer pattern.
        -: 3280: */
        -: 3281:static parser_pattern_end_marker_t
    #####: 3282:parser_pattern_get_target (parser_context_t *context_p, /**< context */
        -: 3283:                           parser_pattern_flags_t flags) /**< flags */
        -: 3284:{
    #####: 3285:  parser_pattern_end_marker_t end_marker;
    #####: 3286:  end_marker.token.type = LEXER_INVALID_PATTERN;
    #####: 3287:  parser_branch_t skip_init;
        -: 3288:
    #####: 3289:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3290:  {
    #####: 3291:    JERRY_ASSERT (flags & PARSER_PATTERN_TARGET_ON_STACK);
        -: 3292:
    #####: 3293:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3294:  }
        -: 3295:
    #####: 3296:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3297:  {
    #####: 3298:    scanner_location_t start_location;
        -: 3299:
    #####: 3300:    if (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3301:        || context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
    #####: 3302:        || (flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3303:    {
        -: 3304:      /* Found invalid pattern, push null value to fake the rhs target. */
    #####: 3305:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
        -: 3306:    }
        -: 3307:    else
        -: 3308:    {
    #####: 3309:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
    #####: 3310:      scanner_get_location (&start_location, context_p);
        -: 3311:
    #####: 3312:      scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 3313:      scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 3314:      scanner_seek (context_p);
    #####: 3315:      lexer_next_token (context_p);
        -: 3316:
    #####: 3317:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 3318:      scanner_get_location (&(end_marker.location), context_p);
    #####: 3319:      end_marker.token = context_p->token;
        -: 3320:
    #####: 3321:      scanner_set_location (context_p, &start_location);
    #####: 3322:      scanner_seek (context_p);
    #####: 3323:      parser_flush_cbc (context_p);
        -: 3324:    }
        -: 3325:  }
        -: 3326:
    #####: 3327:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3328:  {
    #####: 3329:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3330:  }
        -: 3331:
    #####: 3332:  return end_marker;
        -: 3333:} /* parser_pattern_get_target */
        -: 3334:
        -: 3335:/**
        -: 3336: * Finalize an assignment/binding pattern.
        -: 3337: */
        -: 3338:static void
    #####: 3339:parser_pattern_finalize (parser_context_t *context_p, /**< context */
        -: 3340:                         parser_pattern_flags_t flags, /**< flags */
        -: 3341:                         parser_pattern_end_marker_t *end_marker_p) /**< pattern end position  */
        -: 3342:{
    #####: 3343:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3344:  {
    #####: 3345:    if (end_marker_p->token.type == LEXER_INVALID_PATTERN)
        -: 3346:    {
    #####: 3347:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3348:    }
        -: 3349:
    #####: 3350:    scanner_set_location (context_p, &(end_marker_p->location));
    #####: 3351:    context_p->token = end_marker_p->token;
        -: 3352:  }
        -: 3353:  else
        -: 3354:  {
    #####: 3355:    JERRY_ASSERT (!(flags & PARSER_PATTERN_TARGET_DEFAULT));
    #####: 3356:    lexer_next_token (context_p);
        -: 3357:  }
        -: 3358:
    #####: 3359:  if ((flags & (PARSER_PATTERN_BINDING | PARSER_PATTERN_NESTED_PATTERN)) == PARSER_PATTERN_BINDING)
        -: 3360:  {
        -: 3361:    /* Pop the result of the expression. */
    #####: 3362:    parser_emit_cbc (context_p, CBC_POP);
        -: 3363:  }
        -: 3364:
    #####: 3365:  parser_flush_cbc (context_p);
    #####: 3366:} /* parser_pattern_finalize */
        -: 3367:
        -: 3368:/**
        -: 3369: * Emit right-hand-side target value.
        -: 3370: */
        -: 3371:static void
    #####: 3372:parser_pattern_emit_rhs (parser_context_t *context_p, /**< context */
        -: 3373:                         uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3374:                         uint16_t literal_index) /**< literal index for object pattern */
        -: 3375:{
    #####: 3376:  if (literal_index != PARSER_PATTERN_RHS_NO_LIT)
        -: 3377:  {
    #####: 3378:    parser_emit_cbc_ext_literal (context_p, rhs_opcode, literal_index);
        -: 3379:  }
        -: 3380:  else
        -: 3381:  {
    #####: 3382:    parser_emit_cbc_ext (context_p, rhs_opcode);
        -: 3383:  }
    #####: 3384:} /* parser_pattern_emit_rhs */
        -: 3385:
        -: 3386:/**
        -: 3387: * Form an assignment from a pattern.
        -: 3388: */
        -: 3389:static void
    #####: 3390:parser_pattern_form_assignment (parser_context_t *context_p, /**< context */
        -: 3391:                                parser_pattern_flags_t flags, /**< flags */
        -: 3392:                                uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3393:                                uint16_t literal_index, /**< literal index for object pattern */
        -: 3394:                                parser_line_counter_t ident_line_counter) /**< identifier line counter */
        -: 3395:{
        -: 3396:  JERRY_UNUSED (ident_line_counter);
        -: 3397:
    #####: 3398:  uint16_t name_index = PARSER_INVALID_LITERAL_INDEX;
        -: 3399:
    #####: 3400:  if ((flags & PARSER_PATTERN_BINDING)
    #####: 3401:      || (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
    #####: 3402:          && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL))
        -: 3403:  {
    #####: 3404:    name_index = context_p->lit_object.index;
        -: 3405:  }
        -: 3406:
    #####: 3407:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
    #####: 3408:  parser_append_binary_single_assignment_token (context_p, flags);
    #####: 3409:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3410:
    #####: 3411:  if (context_p->token.type == LEXER_ASSIGN && !(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3412:  {
    #####: 3413:    parser_branch_t skip_init;
    #####: 3414:    lexer_next_token (context_p);
    #####: 3415:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3416:
    #####: 3417:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 3418:
    #####: 3419:    if (name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 3420:    {
    #####: 3421:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3422:
    #####: 3423:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3424:      {
    #####: 3425:        name_index = scanner_save_literal (context_p, name_index);
    #####: 3426:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3427:      }
    #####: 3428:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3429:      {
    #####: 3430:        parser_set_function_name (context_p, function_literal_index, name_index, 0);
        -: 3431:      }
        -: 3432:    }
    #####: 3433:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3434:  }
        -: 3435:
    #####: 3436:  parser_process_binary_opcodes (context_p, 0);
        -: 3437:
    #####: 3438:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
    #####: 3439:  parser_stack_pop_uint8 (context_p);
        -: 3440:
        -: 3441:#if JERRY_DEBUGGER
        -: 3442:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3443:      && ident_line_counter != context_p->last_breakpoint_line)
        -: 3444:  {
        -: 3445:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 3446:    parser_flush_cbc (context_p);
        -: 3447:
        -: 3448:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -: 3449:
        -: 3450:    context_p->last_breakpoint_line = ident_line_counter;
        -: 3451:  }
        -: 3452:#endif /* JERRY_DEBUGGER */
    #####: 3453:} /* parser_pattern_form_assignment */
        -: 3454:
        -: 3455:/**
        -: 3456: * Parse pattern inside a pattern.
        -: 3457: */
        -: 3458:static void
    #####: 3459:parser_pattern_process_nested_pattern (parser_context_t *context_p, /**< context */
        -: 3460:                                       parser_pattern_flags_t flags, /**< flags */
        -: 3461:                                       uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3462:                                       uint16_t literal_index) /**< literal index for object pattern */
        -: 3463:{
    #####: 3464:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE);
        -: 3465:
    #####: 3466:  parser_pattern_flags_t options = (PARSER_PATTERN_NESTED_PATTERN
        -: 3467:                                    | PARSER_PATTERN_TARGET_ON_STACK
    #####: 3468:                                    | (flags & (PARSER_PATTERN_BINDING
        -: 3469:                                                | PARSER_PATTERN_LET
        -: 3470:                                                | PARSER_PATTERN_CONST
        -: 3471:                                                | PARSER_PATTERN_LOCAL
        -: 3472:                                                | PARSER_PATTERN_ARGUMENTS)));
        -: 3473:
    #####: 3474:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 3475:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 3476:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 3477:
    #####: 3478:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3479:  {
    #####: 3480:    if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 3481:    {
    #####: 3482:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3483:      {
    #####: 3484:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3485:      }
        -: 3486:
    #####: 3487:      if (!(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3488:      {
    #####: 3489:        options |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 3490:      }
        -: 3491:      else
        -: 3492:      {
    #####: 3493:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 3494:      }
        -: 3495:    }
        -: 3496:    else
        -: 3497:    {
    #####: 3498:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3499:      {
    #####: 3500:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3501:      }
    #####: 3502:      scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3503:    }
        -: 3504:  }
        -: 3505:
    #####: 3506:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3507:
    #####: 3508:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 3509:  {
    #####: 3510:    parser_parse_object_initializer (context_p, options);
        -: 3511:  }
        -: 3512:  else
        -: 3513:  {
    #####: 3514:    parser_parse_array_initializer (context_p, options);
        -: 3515:  }
        -: 3516:
    #####: 3517:  parser_emit_cbc (context_p, CBC_POP);
    #####: 3518:} /* parser_pattern_process_nested_pattern */
        -: 3519:
        -: 3520:/**
        -: 3521: * Process the current {Binding, Assignment}Property
        -: 3522: *
        -: 3523: * @return true, if a nested pattern is processed, false otherwise
        -: 3524: */
        -: 3525:static bool
    #####: 3526:parser_pattern_process_assignment (parser_context_t *context_p, /**< context */
        -: 3527:                                   parser_pattern_flags_t flags, /**< flags */
        -: 3528:                                   uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3529:                                   uint16_t literal_index, /**< literal index for object pattern */
        -: 3530:                                   lexer_token_type_t end_type) /**< end type token */
        -: 3531:{
    #####: 3532:  if ((context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE)
    #####: 3533:      && (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3534:          || !(context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_NO_DESTRUCTURING)))
        -: 3535:  {
    #####: 3536:    parser_pattern_process_nested_pattern (context_p, flags, rhs_opcode, literal_index);
    #####: 3537:    return true;
        -: 3538:  }
        -: 3539:
    #####: 3540:  parser_line_counter_t ident_line_counter = context_p->token.line;
        -: 3541:#if JERRY_LINE_INFO
    #####: 3542:  parser_line_counter_t ident_column_counter = context_p->token.column;
        -: 3543:#endif /* JERRY_LINE_INFO */
        -: 3544:
    #####: 3545:  if (flags & PARSER_PATTERN_BINDING)
        -: 3546:  {
    #####: 3547:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3548:    {
    #####: 3549:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 3550:    }
        -: 3551:
    #####: 3552:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 3553:
    #####: 3554:    if (flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST)
    #####: 3555:        && context_p->token.keyword_type == LEXER_KEYW_LET)
        -: 3556:    {
    #####: 3557:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 3558:    }
        -: 3559:
    #####: 3560:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3561:    {
    #####: 3562:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 3563:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3564:    }
        -: 3565:
    #####: 3566:    if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 3567:    {
    #####: 3568:      if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 3569:      {
    #####: 3570:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3571:      }
    #####: 3572:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 3573:    }
        -: 3574:#if JERRY_MODULE_SYSTEM
    #####: 3575:    parser_module_append_export_name (context_p);
        -: 3576:#endif /* JERRY_MODULE_SYSTEM */
        -: 3577:
    #####: 3578:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 3579:    lexer_next_token (context_p);
        -: 3580:
    #####: 3581:    if (context_p->token.type != end_type
    #####: 3582:        && context_p->token.type != LEXER_ASSIGN
    #####: 3583:        && context_p->token.type != LEXER_COMMA)
        -: 3584:    {
    #####: 3585:      parser_raise_error (context_p, PARSER_ERR_ILLEGAL_PROPERTY_IN_DECLARATION);
        -: 3586:    }
        -: 3587:  }
        -: 3588:  else
        -: 3589:  {
    #####: 3590:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_LEFT_HAND_SIDE);
        -: 3591:
    #####: 3592:    if (!PARSER_IS_PUSH_LITERAL (context_p->last_cbc_opcode) && !PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3593:    {
    #####: 3594:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3595:    }
        -: 3596:  }
        -: 3597:
    #####: 3598:  parser_pattern_form_assignment (context_p, flags, rhs_opcode, literal_index, ident_line_counter);
        -: 3599:#if JERRY_LINE_INFO
    #####: 3600:  parser_line_info_append (context_p, ident_line_counter, ident_column_counter);
        -: 3601:#endif /* JERRY_LINE_INFO */
    #####: 3602:  return false;
        -: 3603:} /* parser_pattern_process_assignment */
        -: 3604:
        -: 3605:/**
        -: 3606: * Parse array initializer.
        -: 3607: */
        -: 3608:static void
    #####: 3609:parser_parse_array_initializer (parser_context_t *context_p, /**< context */
        -: 3610:                                parser_pattern_flags_t flags) /**< flags */
        -: 3611:{
    #####: 3612:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 3613:
    #####: 3614:  lexer_next_token (context_p);
    #####: 3615:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_CREATE);
        -: 3616:
    #####: 3617:  while (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 3618:  {
    #####: 3619:    uint16_t rhs_opcode = CBC_EXT_ITERATOR_STEP;
        -: 3620:
    #####: 3621:    if (context_p->token.type == LEXER_COMMA)
        -: 3622:    {
    #####: 3623:      parser_emit_cbc_ext (context_p, rhs_opcode);
    #####: 3624:      parser_emit_cbc (context_p, CBC_POP);
    #####: 3625:      lexer_next_token (context_p);
    #####: 3626:      continue;
        -: 3627:    }
        -: 3628:
    #####: 3629:    parser_pattern_flags_t options = flags;
        -: 3630:
    #####: 3631:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3632:    {
    #####: 3633:      lexer_next_token (context_p);
    #####: 3634:      rhs_opcode = CBC_EXT_REST_INITIALIZER;
    #####: 3635:      options |= PARSER_PATTERN_REST_ELEMENT;
        -: 3636:    }
        -: 3637:
    #####: 3638:    parser_pattern_process_assignment (context_p, options, rhs_opcode, PARSER_PATTERN_RHS_NO_LIT, LEXER_RIGHT_SQUARE);
        -: 3639:
    #####: 3640:    if (context_p->token.type == LEXER_COMMA && rhs_opcode != CBC_EXT_REST_INITIALIZER)
        -: 3641:    {
    #####: 3642:      lexer_next_token (context_p);
        -: 3643:    }
    #####: 3644:    else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 3645:    {
    #####: 3646:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3647:    }
        -: 3648:  }
        -: 3649:
        -: 3650:  /* close the iterator */
    #####: 3651:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_END);
        -: 3652:
    #####: 3653:  parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 3654:} /* parser_parse_array_initializer */
        -: 3655:
        -: 3656:/**
        -: 3657: * Parse object initializer.
        -: 3658: */
        -: 3659:static void
    #####: 3660:parser_parse_object_initializer (parser_context_t *context_p, /**< context */
        -: 3661:                                 parser_pattern_flags_t flags) /**< flags */
        -: 3662:{
    #####: 3663:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 3664:
        -: 3665:  /* 12.14.5.2:  ObjectAssignmentPattern : { } */
    #####: 3666:  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))
        -: 3667:  {
    #####: 3668:    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);
    #####: 3669:    lexer_consume_next_character (context_p);
    #####: 3670:    parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 3671:    return;
        -: 3672:  }
        -: 3673:
    #####: 3674:  cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;
        -: 3675:
    #####: 3676:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 3677:  {
    #####: 3678:    context_opcode = CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE;
        -: 3679:  }
        -: 3680:
    #####: 3681:  parser_emit_cbc_ext (context_p, context_opcode);
        -: 3682:
        -: 3683:  while (true)
    #####: 3684:  {
    #####: 3685:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);
        -: 3686:
    #####: 3687:    uint16_t prop_index = context_p->lit_object.index;
    #####: 3688:    parser_line_counter_t start_line = context_p->token.line;
    #####: 3689:    parser_line_counter_t start_column = context_p->token.column;
    #####: 3690:    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;
        -: 3691:
    #####: 3692:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3693:    {
    #####: 3694:      break;
        -: 3695:    }
        -: 3696:
    #####: 3697:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3698:    {
    #####: 3699:      lexer_next_token (context_p);
        -: 3700:
    #####: 3701:      flags |= PARSER_PATTERN_REST_ELEMENT;
        -: 3702:
    #####: 3703:      if (parser_pattern_process_assignment (context_p,
        -: 3704:                                             flags,
        -: 3705:                                             CBC_EXT_OBJ_INIT_PUSH_REST,
        -: 3706:                                             PARSER_PATTERN_RHS_NO_LIT,
        -: 3707:                                             LEXER_RIGHT_BRACE))
        -: 3708:      {
    #####: 3709:        parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3710:      }
        -: 3711:
    #####: 3712:      if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 3713:      {
    #####: 3714:        parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 3715:      }
        -: 3716:
        -: 3717:      /* Checked at the end because there might be syntax errors before. */
    #####: 3718:      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);
    #####: 3719:      break;
        -: 3720:    }
        -: 3721:
    #####: 3722:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -: 3723:    {
    #####: 3724:      prop_index = PARSER_PATTERN_RHS_NO_LIT;
    #####: 3725:      push_prop_opcode = ((flags & PARSER_PATTERN_HAS_REST_ELEMENT) ? CBC_EXT_INITIALIZER_PUSH_NAME
        -: 3726:                                                                    : CBC_EXT_INITIALIZER_PUSH_PROP);
        -: 3727:    }
    #####: 3728:    else if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 3729:    {
    #####: 3730:      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_NAME_LITERAL;
        -: 3731:    }
        -: 3732:
    #####: 3733:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3734:    {
    #####: 3735:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 3736:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3737:    }
        -: 3738:
    #####: 3739:    lexer_next_token (context_p);
        -: 3740:
    #####: 3741:    if (context_p->token.type == LEXER_COLON)
        -: 3742:    {
    #####: 3743:      lexer_next_token (context_p);
    #####: 3744:      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);
        -: 3745:    }
        -: 3746:    else
        -: 3747:    {
    #####: 3748:      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_NAME
    #####: 3749:          || push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 3750:      {
    #####: 3751:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 3752:      }
        -: 3753:
    #####: 3754:      if (context_p->token.type != LEXER_RIGHT_BRACE
    #####: 3755:          && context_p->token.type != LEXER_ASSIGN
    #####: 3756:          && context_p->token.type != LEXER_COMMA)
        -: 3757:      {
    #####: 3758:        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 3759:      }
        -: 3760:
    #####: 3761:      parser_reparse_as_common_identifier (context_p, start_line, start_column);
        -: 3762:
    #####: 3763:      if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 3764:      {
    #####: 3765:        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 3766:        {
    #####: 3767:          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3768:        }
    #####: 3769:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 3770:      }
        -: 3771:
        -: 3772:#if JERRY_MODULE_SYSTEM
    #####: 3773:      parser_module_append_export_name (context_p);
        -: 3774:#endif /* JERRY_MODULE_SYSTEM */
        -: 3775:
    #####: 3776:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 3777:
    #####: 3778:      lexer_next_token (context_p);
    #####: 3779:      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE
        -: 3780:                    || context_p->token.type == LEXER_ASSIGN
        -: 3781:                    || context_p->token.type == LEXER_COMMA);
        -: 3782:
    #####: 3783:      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);
        -: 3784:#if JERRY_LINE_INFO
    #####: 3785:      parser_line_info_append (context_p, start_line, start_column);
        -: 3786:#endif /* JERRY_LINE_INFO */
        -: 3787:    }
        -: 3788:
    #####: 3789:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3790:    {
    #####: 3791:      break;
        -: 3792:    }
    #####: 3793:    else if (context_p->token.type != LEXER_COMMA)
        -: 3794:    {
    #####: 3795:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 3796:    }
        -: 3797:  }
        -: 3798:
    #####: 3799:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 3800:  {
    #####: 3801:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, (PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION
        -: 3802:                                                     - PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION));
        -: 3803:  }
        -: 3804:
    #####: 3805:  parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);
        -: 3806:
    #####: 3807:  parser_pattern_finalize (context_p, flags, &end_pos);
        -: 3808:} /* parser_parse_object_initializer */
        -: 3809:
        -: 3810:/**
        -: 3811: * Parse an initializer.
        -: 3812: */
        -: 3813:void
    #####: 3814:parser_parse_initializer (parser_context_t *context_p, /**< context */
        -: 3815:                          parser_pattern_flags_t flags) /**< flags */
        -: 3816:{
    #####: 3817:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 3818:  {
    #####: 3819:    parser_parse_object_initializer (context_p, flags);
        -: 3820:  }
        -: 3821:  else
        -: 3822:  {
    #####: 3823:    JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
    #####: 3824:    parser_parse_array_initializer (context_p, flags);
        -: 3825:  }
    #####: 3826:} /* parser_parse_initializer */
        -: 3827:
        -: 3828:/**
        -: 3829: * Parse an initializer using the next character.
        -: 3830: */
        -: 3831:void
    #####: 3832:parser_parse_initializer_by_next_char (parser_context_t *context_p, /**< context */
        -: 3833:                                       parser_pattern_flags_t flags) /**< flags */
        -: 3834:{
    #####: 3835:  JERRY_ASSERT (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE));
        -: 3836:
    #####: 3837:  if (lexer_consume_next_character (context_p) == LIT_CHAR_LEFT_BRACE)
        -: 3838:  {
    #####: 3839:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3840:    {
    #####: 3841:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 3842:                    || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 3843:
    #####: 3844:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3845:      {
    #####: 3846:        flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3847:      }
        -: 3848:
    #####: 3849:      if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 3850:      {
    #####: 3851:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3852:      }
        -: 3853:    }
        -: 3854:
    #####: 3855:    parser_parse_object_initializer (context_p, flags);
        -: 3856:  }
        -: 3857:  else
        -: 3858:  {
    #####: 3859:    parser_parse_array_initializer (context_p, flags);
        -: 3860:  }
    #####: 3861:} /* parser_parse_initializer_by_next_char */
        -: 3862:
        -: 3863:#endif /* JERRY_ESNEXT */
        -: 3864:
        -: 3865:/**
        -: 3866: * Process ternary expression.
        -: 3867: */
        -: 3868:static void
        1: 3869:parser_process_ternary_expression (parser_context_t *context_p) /**< context */
        -: 3870:{
        1: 3871:  JERRY_ASSERT (context_p->token.type == LEXER_QUESTION_MARK);
        -: 3872:
        1: 3873:  cbc_opcode_t opcode = CBC_BRANCH_IF_FALSE_FORWARD;
        1: 3874:  parser_branch_t cond_branch;
        1: 3875:  parser_branch_t uncond_branch;
        -: 3876:
        1: 3877:  parser_push_result (context_p);
        -: 3878:
        1: 3879:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 3880:  {
    #####: 3881:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 3882:    opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 3883:  }
        -: 3884:
        1: 3885:  parser_emit_cbc_forward_branch (context_p, (uint16_t) opcode, &cond_branch);
        -: 3886:
        1: 3887:  lexer_next_token (context_p);
        1: 3888:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        1: 3889:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &uncond_branch);
        1: 3890:  parser_set_branch_to_current_position (context_p, &cond_branch);
        -: 3891:
        -: 3892:  /* Although byte code is constructed for two branches,
        -: 3893:   * only one of them will be executed. To reflect this
        -: 3894:   * the stack is manually adjusted. */
        1: 3895:  JERRY_ASSERT (context_p->stack_depth > 0);
        1: 3896:  context_p->stack_depth--;
        -: 3897:
        1: 3898:  if (context_p->token.type != LEXER_COLON)
        -: 3899:  {
    #####: 3900:    parser_raise_error (context_p, PARSER_ERR_COLON_FOR_CONDITIONAL_EXPECTED);
        -: 3901:  }
        -: 3902:
        1: 3903:  lexer_next_token (context_p);
        -: 3904:
        1: 3905:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        1: 3906:  parser_set_branch_to_current_position (context_p, &uncond_branch);
        -: 3907:
        -: 3908:  /* Last opcode rewrite is not allowed because
        -: 3909:   * the result may come from the first branch. */
        1: 3910:  parser_flush_cbc (context_p);
        -: 3911:
        1: 3912:  parser_process_binary_opcodes (context_p, 0);
        1: 3913:} /* parser_process_ternary_expression */
        -: 3914:
        -: 3915:/**
        -: 3916: * Process expression sequence.
        -: 3917: */
        -: 3918:static void
    #####: 3919:parser_process_expression_sequence (parser_context_t *context_p) /**< context */
        -: 3920:{
    #####: 3921:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 3922:  {
    #####: 3923:    parser_emit_cbc (context_p, CBC_POP);
        -: 3924:  }
        -: 3925:
    #####: 3926:  if (context_p->stack_top_uint8 == LEXER_LEFT_PAREN)
        -: 3927:  {
    #####: 3928:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -: 3929:
    #####: 3930:    JERRY_ASSERT (page_p != NULL);
        -: 3931:
    #####: 3932:    page_p->bytes[context_p->stack.last_position - 1] = LEXER_COMMA_SEP_LIST;
    #####: 3933:    context_p->stack_top_uint8 = LEXER_COMMA_SEP_LIST;
        -: 3934:  }
        -: 3935:
    #####: 3936:  lexer_next_token (context_p);
    #####: 3937:} /* parser_process_expression_sequence */
        -: 3938:
        -: 3939:/**
        -: 3940: * Process group expression.
        -: 3941: */
        -: 3942:static void
    #####: 3943:parser_process_group_expression (parser_context_t *context_p, /**< context */
        -: 3944:                                 size_t *grouping_level_p) /**< grouping level */
        -: 3945:{
    #####: 3946:  JERRY_ASSERT (*grouping_level_p >= PARSER_GROUPING_LEVEL_INCREASE);
    #####: 3947:  (*grouping_level_p) -= PARSER_GROUPING_LEVEL_INCREASE;
        -: 3948:
    #####: 3949:  uint8_t token = context_p->stack_top_uint8;
        -: 3950:
    #####: 3951:  if (token == LEXER_COMMA_SEP_LIST)
        -: 3952:  {
    #####: 3953:    parser_push_result (context_p);
    #####: 3954:    parser_flush_cbc (context_p);
        -: 3955:  }
        -: 3956:
    #####: 3957:  parser_stack_pop_uint8 (context_p);
    #####: 3958:  lexer_next_token (context_p);
        -: 3959:
        -: 3960:#if JERRY_ESNEXT
        -: 3961:  /* Lookahead for anonymous function declaration after '=' token when the assignment base is LHS expression
        -: 3962:     with a single indentifier in it. e.g.: (a) = function () {} */
    #####: 3963:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_ASSIGN
        -: 3964:                      && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        -: 3965:                      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL
        -: 3966:                      && parser_is_assignment_expr (context_p)
        -: 3967:                      && *grouping_level_p != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 3968:  {
    #####: 3969:    parser_stack_push_uint8 (context_p, LEXER_ASSIGN_GROUP_EXPR);
        -: 3970:  }
        -: 3971:#endif /* JERRY_ESNEXT */
    #####: 3972:} /* parser_process_group_expression */
        -: 3973:
        -: 3974:/**
        -: 3975: * Parse block expression.
        -: 3976: */
        -: 3977:void
        1: 3978:parser_parse_block_expression (parser_context_t *context_p, /**< context */
        -: 3979:                               int options) /**< option flags */
        -: 3980:{
        1: 3981:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 3982:
        1: 3983:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 3984:  {
        1: 3985:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));
        1: 3986:    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);
        1: 3987:    parser_flush_cbc (context_p);
        -: 3988:  }
        -: 3989:  else
        -: 3990:  {
    #####: 3991:    parser_emit_cbc (context_p, CBC_POP_BLOCK);
        -: 3992:  }
        1: 3993:} /* parser_parse_block_expression */
        -: 3994:
        -: 3995:/**
        -: 3996: * Parse expression statement.
        -: 3997: */
        -: 3998:void
        1: 3999:parser_parse_expression_statement (parser_context_t *context_p, /**< context */
        -: 4000:                                   int options) /**< option flags */
        -: 4001:{
        1: 4002:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 4003:
        1: 4004:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4005:  {
    #####: 4006:    parser_emit_cbc (context_p, CBC_POP);
        -: 4007:  }
        1: 4008:} /* parser_parse_expression_statement */
        -: 4009:
        -: 4010:JERRY_STATIC_ASSERT (PARSE_EXPR_LEFT_HAND_SIDE == 0x1,
        -: 4011:                     value_of_parse_expr_left_hand_side_must_be_1);
        -: 4012:
        -: 4013:/**
        -: 4014: * Parse expression.
        -: 4015: */
        -: 4016:void
       16: 4017:parser_parse_expression (parser_context_t *context_p, /**< context */
        -: 4018:                         int options) /**< option flags */
        -: 4019:{
       16: 4020:  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);
        -: 4021:
       16: 4022:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
        -: 4023:
       16: 4024:  if (options & PARSE_EXPR_HAS_LITERAL)
        -: 4025:  {
    #####: 4026:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 4027:    goto process_unary_expression;
        -: 4028:  }
        -: 4029:
        -: 4030:  while (true)
        -: 4031:  {
       18: 4032:    if (parser_parse_unary_expression (context_p, &grouping_level))
        -: 4033:    {
    #####: 4034:      parser_process_binary_opcodes (context_p, 0);
    #####: 4035:      break;
        -: 4036:    }
        -: 4037:
        -: 4038:    while (true)
        -: 4039:    {
       17: 4040:process_unary_expression:
       17: 4041:      parser_process_unary_expression (context_p, grouping_level);
        -: 4042:
       17: 4043:      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 4044:      {
       17: 4045:        uint8_t min_prec_treshold = 0;
        -: 4046:
       17: 4047:        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4048:        {
        -: 4049:#if JERRY_ESNEXT
        2: 4050:          if (JERRY_UNLIKELY (context_p->token.type == LEXER_NULLISH_COALESCING))
        -: 4051:          {
    #####: 4052:            parser_check_invalid_logical_op (context_p, LEXER_LOGICAL_OR, LEXER_LOGICAL_AND);
        -: 4053:          }
        -: 4054:#endif /* JERRY_ESNEXT */
        -: 4055:
        2: 4056:          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];
        -: 4057:
        -: 4058:#if JERRY_ESNEXT
        -: 4059:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */
        2: 4060:          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)
        2: 4061:              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
        1: 4062:                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))
        -: 4063:          {
        -: 4064:            /* Right-to-left evaluation order. */
    #####: 4065:            min_prec_treshold++;
        -: 4066:          }
        -: 4067:#else /* !JERRY_ESNEXT */
        -: 4068:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */
    #####: 4069:          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
    #####: 4070:              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)
        -: 4071:          {
        -: 4072:            /* Right-to-left evaluation order. */
    #####: 4073:            min_prec_treshold++;
        -: 4074:          }
        -: 4075:#endif /* JERRY_ESNEXT */
        -: 4076:        }
        -: 4077:
       17: 4078:        parser_process_binary_opcodes (context_p, min_prec_treshold);
        -: 4079:      }
       17: 4080:      if (context_p->token.type == LEXER_RIGHT_PAREN
        2: 4081:          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN
        2: 4082:              || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))
        -: 4083:      {
    #####: 4084:        parser_process_group_expression (context_p, &grouping_level);
    #####: 4085:        continue;
        -: 4086:      }
        -: 4087:
       17: 4088:      break;
        -: 4089:    }
        -: 4090:
       17: 4091:    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)
        -: 4092:    {
    #####: 4093:      break;
        -: 4094:    }
        -: 4095:
       17: 4096:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK))
        -: 4097:    {
        1: 4098:      parser_process_ternary_expression (context_p);
        -: 4099:
        1: 4100:      if (context_p->token.type == LEXER_RIGHT_PAREN)
        -: 4101:      {
    #####: 4102:        goto process_unary_expression;
        -: 4103:      }
        -: 4104:    }
       16: 4105:    else if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4106:    {
        1: 4107:      parser_append_binary_token (context_p);
        1: 4108:      lexer_next_token (context_p);
        1: 4109:      continue;
        -: 4110:    }
        -: 4111:
       16: 4112:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)
        2: 4113:        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))
        -: 4114:    {
    #####: 4115:      parser_process_expression_sequence (context_p);
    #####: 4116:      continue;
        -: 4117:    }
        -: 4118:
       16: 4119:    break;
        -: 4120:  }
        -: 4121:
       16: 4122:  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)
        -: 4123:  {
    #####: 4124:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 4125:  }
        -: 4126:
       16: 4127:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
       16: 4128:  parser_stack_pop_uint8 (context_p);
        -: 4129:
       16: 4130:  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))
        -: 4131:  {
       14: 4132:    parser_push_result (context_p);
        -: 4133:  }
       16: 4134:} /* parser_parse_expression */
        -: 4135:
        -: 4136:/**
        -: 4137: * @}
        -: 4138: * @}
        -: 4139: * @}
        -: 4140: */
        -: 4141:
        -: 4142:#endif /* JERRY_PARSER */
