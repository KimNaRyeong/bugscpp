        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/libyara/exec.gcno
        -:    0:Data:/home/workspace/libyara/exec.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <string.h>
        -:   33:#include <assert.h>
        -:   34:#include <math.h>
        -:   35:#include <float.h>
        -:   36:
        -:   37:#include <yara/globals.h>
        -:   38:#include <yara/arena.h>
        -:   39:#include <yara/endian.h>
        -:   40:#include <yara/exec.h>
        -:   41:#include <yara/limits.h>
        -:   42:#include <yara/error.h>
        -:   43:#include <yara/object.h>
        -:   44:#include <yara/modules.h>
        -:   45:#include <yara/re.h>
        -:   46:#include <yara/strutils.h>
        -:   47:#include <yara/utils.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/stopwatch.h>
        -:   50:
        -:   51:
        -:   52:#include <yara.h>
        -:   53:
        -:   54:
        -:   55:// Turn on paranoid mode by default if not defined otherwise. In paranoid
        -:   56:// mode additional checks are performed in order to mitigate the effects of
        -:   57:// malicious tampering with compiled rules. Such checks are not necessary
        -:   58:// when you can ensure that the compiled rules are executed exactly as they
        -:   59:// were generated by YARA, without any further modification. Check issue #891
        -:   60:// (https://github.com/VirusTotal/yara/issues/891) for more context.
        -:   61://
        -:   62:// Paranoid mode does not guarantee that it's safe to load compiled rules from
        -:   63:// third parties, it only prevents severe security issues. Maliciously crafted
        -:   64:// compiled rules can still crash YARA. Loading third-party compiled rules is
        -:   65:// *highly* undiscouraged. If you need to distribute YARA rules in compiled
        -:   66:// form you should encapsulate them in some digitally-signed package that
        -:   67:// ensure that they haven't been modified by someone else.
        -:   68:
        -:   69:#if !defined(PARANOID_EXEC)
        -:   70:#define PARANOID_EXEC   1
        -:   71:#endif
        -:   72:
        -:   73:
        -:   74:#define MEM_SIZE   YR_MAX_LOOP_NESTING * LOOP_LOCAL_VARS
        -:   75:
        -:   76:
        -:   77:#define push(x)  \
        -:   78:    if (sp < stack_size) \
        -:   79:    { \
        -:   80:      stack[sp++] = (x); \
        -:   81:    } \
        -:   82:    else \
        -:   83:    { \
        -:   84:      result = ERROR_EXEC_STACK_OVERFLOW; \
        -:   85:      stop = true; \
        -:   86:      break; \
        -:   87:    } \
        -:   88:
        -:   89:
        -:   90:#define pop(x) { assert(sp > 0); x = stack[--sp]; }
        -:   91:
        -:   92:#define is_undef(x) IS_UNDEFINED((x).i)
        -:   93:
        -:   94:#define ensure_defined(x) \
        -:   95:    if (is_undef(x)) \
        -:   96:    { \
        -:   97:      r1.i = UNDEFINED; \
        -:   98:      push(r1); \
        -:   99:      break; \
        -:  100:    }
        -:  101:
        -:  102:#define ensure_within_mem(x) \
        -:  103:    if (x < 0 || x >= MEM_SIZE) \
        -:  104:    { \
        -:  105:      stop = true; \
        -:  106:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  107:      break; \
        -:  108:    }
        -:  109:
        -:  110:#define check_object_canary(o) \
        -:  111:    if (o->canary != context->canary) \
        -:  112:    { \
        -:  113:      stop = true; \
        -:  114:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  115:      break; \
        -:  116:    }
        -:  117:
        -:  118:#define little_endian_uint8_t(x)     (x)
        -:  119:#define little_endian_int8_t(x)      (x)
        -:  120:#define little_endian_uint16_t(x)    yr_le16toh(x)
        -:  121:#define little_endian_int16_t(x)     yr_le16toh(x)
        -:  122:#define little_endian_uint32_t(x)    yr_le32toh(x)
        -:  123:#define little_endian_int32_t(x)     yr_le32toh(x)
        -:  124:
        -:  125:#define big_endian_uint8_t(x)        (x)
        -:  126:#define big_endian_int8_t(x)         (x)
        -:  127:#define big_endian_uint16_t(x)       yr_be16toh(x)
        -:  128:#define big_endian_int16_t(x)        yr_be16toh(x)
        -:  129:#define big_endian_uint32_t(x)       yr_be32toh(x)
        -:  130:#define big_endian_int32_t(x)        yr_be32toh(x)
        -:  131:
        -:  132:
        -:  133:#define function_read(type, endianess) \
        -:  134:    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \
        -:  135:    { \
        -:  136:      YR_MEMORY_BLOCK* block = iterator->first(iterator); \
        -:  137:      while (block != NULL) \
        -:  138:      { \
        -:  139:        if (offset >= block->base && \
        -:  140:            block->size >= sizeof(type) && \
        -:  141:            offset <= block->base + block->size - sizeof(type)) \
        -:  142:        { \
        -:  143:          type result; \
        -:  144:          const uint8_t* data = block->fetch_data(block); \
        -:  145:          if (data == NULL) \
        -:  146:            return UNDEFINED; \
        -:  147:          result = *(type *)(data + offset - block->base); \
        -:  148:          result = endianess##_##type(result); \
        -:  149:          return result; \
        -:  150:        } \
        -:  151:        block = iterator->next(iterator); \
        -:  152:      } \
        -:  153:      return UNDEFINED; \
        -:  154:    };
        -:  155:
        -:  156:
    #####:  157:function_read(uint8_t, little_endian)
    #####:  158:function_read(uint16_t, little_endian)
    #####:  159:function_read(uint32_t, little_endian)
    #####:  160:function_read(int8_t, little_endian)
    #####:  161:function_read(int16_t, little_endian)
    #####:  162:function_read(int32_t, little_endian)
    #####:  163:function_read(uint8_t, big_endian)
    #####:  164:function_read(uint16_t, big_endian)
    #####:  165:function_read(uint32_t, big_endian)
    #####:  166:function_read(int8_t, big_endian)
    #####:  167:function_read(int16_t, big_endian)
    #####:  168:function_read(int32_t, big_endian)
        -:  169:
        -:  170:
    #####:  171:static const uint8_t* jmp_if(
        -:  172:    int condition,
        -:  173:    const uint8_t* ip)
        -:  174:{
        -:  175:  const uint8_t* result;
        -:  176:
    #####:  177:  if (condition)
        -:  178:  {
    #####:  179:    result = *(const uint8_t**)(ip);
        -:  180:  }
        -:  181:  else
        -:  182:  {
    #####:  183:    result = ip + sizeof(uint64_t);
        -:  184:  }
        -:  185:
    #####:  186:  return result;
        -:  187:}
        -:  188:
        -:  189:
      280:  190:int yr_execute_code(
        -:  191:    YR_SCAN_CONTEXT* context)
        -:  192:{
        -:  193:  int64_t mem[MEM_SIZE];
      280:  194:  int32_t sp = 0;
        -:  195:
      280:  196:  const uint8_t* ip = context->rules->code_start;
        -:  197:
        -:  198:  YR_VALUE args[YR_MAX_FUNCTION_ARGS];
        -:  199:  YR_VALUE *stack;
        -:  200:  YR_VALUE r1;
        -:  201:  YR_VALUE r2;
        -:  202:  YR_VALUE r3;
        -:  203:  YR_VALUE r4;
        -:  204:
        -:  205:  uint64_t elapsed_time;
        -:  206:
        -:  207:  #ifdef PROFILING_ENABLED
        -:  208:  uint64_t start_time;
        -:  209:  YR_RULE* current_rule = NULL;
        -:  210:  #endif
        -:  211:
        -:  212:  YR_INIT_RULE_ARGS init_rule_args;
        -:  213:
        -:  214:  YR_RULE* rule;
        -:  215:  YR_MATCH* match;
        -:  216:  YR_OBJECT_FUNCTION* function;
        -:  217:  YR_OBJECT** obj_ptr;
        -:  218:  YR_ARENA* obj_arena;
        -:  219:
        -:  220:  char* identifier;
        -:  221:  char* args_fmt;
        -:  222:
        -:  223:  int i;
        -:  224:  int found;
        -:  225:  int count;
      280:  226:  int result = ERROR_SUCCESS;
      280:  227:  int cycle = 0;
      280:  228:  int tidx = context->tidx;
        -:  229:  int stack_size;
        -:  230:
      280:  231:  bool stop = false;
        -:  232:
        -:  233:  uint8_t opcode;
        -:  234:
      280:  235:  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
        -:  236:
      280:  237:  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
        -:  238:
      280:  239:  if (stack == NULL)
    #####:  240:    return ERROR_INSUFFICIENT_MEMORY;
        -:  241:
     280*:  242:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  243:      yr_arena_create(1024, 0, &obj_arena),
        -:  244:      yr_free(stack));
        -:  245:
        -:  246:  #ifdef PROFILING_ENABLED
        -:  247:  start_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  248:  #endif
        -:  249:
        -:  250:  #if PARANOID_EXEC
      280:  251:  memset(mem, 0, MEM_SIZE * sizeof(mem[0]));
        -:  252:  #endif
        -:  253:
     1972:  254:  while(!stop)
        -:  255:  {
     1692:  256:    opcode = *ip;
     1692:  257:    ip++;
        -:  258:
     1692:  259:    switch(opcode)
        -:  260:    {
      280:  261:      case OP_NOP:
      280:  262:        break;
        -:  263:
      280:  264:      case OP_HALT:
     280*:  265:        assert(sp == 0); // When HALT is reached the stack should be empty.
      280:  266:        stop = true;
      280:  267:        break;
        -:  268:
      288:  269:      case OP_PUSH:
      288:  270:        r1.i = *(uint64_t*)(ip);
      288:  271:        ip += sizeof(uint64_t);
     288*:  272:        push(r1);
      288:  273:        break;
        -:  274:
    #####:  275:      case OP_POP:
    #####:  276:        pop(r1);
    #####:  277:        break;
        -:  278:
    #####:  279:      case OP_CLEAR_M:
    #####:  280:        r1.i = *(uint64_t*)(ip);
    #####:  281:        ip += sizeof(uint64_t);
        -:  282:        #if PARANOID_EXEC
    #####:  283:        ensure_within_mem(r1.i);
        -:  284:        #endif
    #####:  285:        mem[r1.i] = 0;
    #####:  286:        break;
        -:  287:
    #####:  288:      case OP_ADD_M:
    #####:  289:        r1.i = *(uint64_t*)(ip);
    #####:  290:        ip += sizeof(uint64_t);
        -:  291:        #if PARANOID_EXEC
    #####:  292:        ensure_within_mem(r1.i);
        -:  293:        #endif
    #####:  294:        pop(r2);
    #####:  295:        if (!is_undef(r2))
    #####:  296:          mem[r1.i] += r2.i;
    #####:  297:        break;
        -:  298:
    #####:  299:      case OP_INCR_M:
    #####:  300:        r1.i = *(uint64_t*)(ip);
    #####:  301:        ip += sizeof(uint64_t);
        -:  302:        #if PARANOID_EXEC
    #####:  303:        ensure_within_mem(r1.i);
        -:  304:        #endif
    #####:  305:        mem[r1.i]++;
    #####:  306:        break;
        -:  307:
    #####:  308:      case OP_PUSH_M:
    #####:  309:        r1.i = *(uint64_t*)(ip);
    #####:  310:        ip += sizeof(uint64_t);
        -:  311:        #if PARANOID_EXEC
    #####:  312:        ensure_within_mem(r1.i);
        -:  313:        #endif
    #####:  314:        r1.i = mem[r1.i];
    #####:  315:        push(r1);
    #####:  316:        break;
        -:  317:
    #####:  318:      case OP_POP_M:
    #####:  319:        r1.i = *(uint64_t*)(ip);
    #####:  320:        ip += sizeof(uint64_t);
        -:  321:        #if PARANOID_EXEC
    #####:  322:        ensure_within_mem(r1.i);
        -:  323:        #endif
    #####:  324:        pop(r2);
    #####:  325:        mem[r1.i] = r2.i;
    #####:  326:        break;
        -:  327:
    #####:  328:      case OP_SET_M:
    #####:  329:        r1.i = *(uint64_t*)(ip);
    #####:  330:        ip += sizeof(uint64_t);
        -:  331:        #if PARANOID_EXEC
    #####:  332:        ensure_within_mem(r1.i);
        -:  333:        #endif
    #####:  334:        pop(r2);
    #####:  335:        push(r2);
    #####:  336:        if (!is_undef(r2))
    #####:  337:          mem[r1.i] = r2.i;
    #####:  338:        break;
        -:  339:
    #####:  340:      case OP_SWAPUNDEF:
    #####:  341:        r1.i = *(uint64_t*)(ip);
    #####:  342:        ip += sizeof(uint64_t);
        -:  343:        #if PARANOID_EXEC
    #####:  344:        ensure_within_mem(r1.i);
        -:  345:        #endif
    #####:  346:        pop(r2);
        -:  347:
    #####:  348:        if (is_undef(r2))
        -:  349:        {
    #####:  350:          r1.i = mem[r1.i];
    #####:  351:          push(r1);
        -:  352:        }
        -:  353:        else
        -:  354:        {
    #####:  355:          push(r2);
        -:  356:        }
    #####:  357:        break;
        -:  358:
    #####:  359:      case OP_JNUNDEF:
    #####:  360:        pop(r1);
    #####:  361:        push(r1);
    #####:  362:        ip = jmp_if(!is_undef(r1), ip);
    #####:  363:        break;
        -:  364:
    #####:  365:      case OP_JLE_P:
    #####:  366:        pop(r2);
    #####:  367:        pop(r1);
    #####:  368:        ip = jmp_if(r1.i <= r2.i, ip);
    #####:  369:        break;
        -:  370:
    #####:  371:      case OP_JTRUE:
    #####:  372:        pop(r1);
    #####:  373:        push(r1);
    #####:  374:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  375:        break;
        -:  376:
    #####:  377:      case OP_JFALSE:
    #####:  378:        pop(r1);
    #####:  379:        push(r1);
    #####:  380:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  381:        break;
        -:  382:
    #####:  383:      case OP_JFALSE_P:
    #####:  384:        pop(r1);
    #####:  385:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  386:        break;
        -:  387:
    #####:  388:      case OP_AND:
    #####:  389:        pop(r2);
    #####:  390:        pop(r1);
        -:  391:
    #####:  392:        if (is_undef(r1) || is_undef(r2))
    #####:  393:          r1.i = 0;
        -:  394:        else
    #####:  395:          r1.i = r1.i && r2.i;
        -:  396:
    #####:  397:        push(r1);
    #####:  398:        break;
        -:  399:
    #####:  400:      case OP_OR:
    #####:  401:        pop(r2);
    #####:  402:        pop(r1);
        -:  403:
    #####:  404:        if (is_undef(r1))
        -:  405:        {
    #####:  406:          push(r2);
        -:  407:        }
    #####:  408:        else if (is_undef(r2))
        -:  409:        {
    #####:  410:          push(r1);
        -:  411:        }
        -:  412:        else
        -:  413:        {
    #####:  414:          r1.i = r1.i || r2.i;
    #####:  415:          push(r1);
        -:  416:        }
    #####:  417:        break;
        -:  418:
    #####:  419:      case OP_NOT:
    #####:  420:        pop(r1);
        -:  421:
    #####:  422:        if (is_undef(r1))
    #####:  423:          r1.i = UNDEFINED;
        -:  424:        else
    #####:  425:          r1.i = !r1.i;
        -:  426:
    #####:  427:        push(r1);
    #####:  428:        break;
        -:  429:
    #####:  430:      case OP_MOD:
    #####:  431:        pop(r2);
    #####:  432:        pop(r1);
    #####:  433:        ensure_defined(r2);
    #####:  434:        ensure_defined(r1);
    #####:  435:        if (r2.i != 0)
    #####:  436:          r1.i = r1.i % r2.i;
        -:  437:        else
    #####:  438:          r1.i = UNDEFINED;
    #####:  439:        push(r1);
    #####:  440:        break;
        -:  441:
    #####:  442:      case OP_SHR:
    #####:  443:        pop(r2);
    #####:  444:        pop(r1);
    #####:  445:        ensure_defined(r2);
    #####:  446:        ensure_defined(r1);
    #####:  447:        if (r2.i < 0)
    #####:  448:          r1.i = UNDEFINED;
    #####:  449:        else if (r2.i < 64)
    #####:  450:          r1.i = r1.i >> r2.i;
        -:  451:        else
    #####:  452:          r1.i = 0;
    #####:  453:        push(r1);
    #####:  454:        break;
        -:  455:
    #####:  456:      case OP_SHL:
    #####:  457:        pop(r2);
    #####:  458:        pop(r1);
    #####:  459:        ensure_defined(r2);
    #####:  460:        ensure_defined(r1);
    #####:  461:        if (r2.i < 0)
    #####:  462:          r1.i = UNDEFINED;
    #####:  463:        else if (r2.i < 64)
    #####:  464:          r1.i = r1.i << r2.i;
        -:  465:        else
    #####:  466:          r1.i = 0;
    #####:  467:        push(r1);
    #####:  468:        break;
        -:  469:
    #####:  470:      case OP_BITWISE_NOT:
    #####:  471:        pop(r1);
    #####:  472:        ensure_defined(r1);
    #####:  473:        r1.i = ~r1.i;
    #####:  474:        push(r1);
    #####:  475:        break;
        -:  476:
    #####:  477:      case OP_BITWISE_AND:
    #####:  478:        pop(r2);
    #####:  479:        pop(r1);
    #####:  480:        ensure_defined(r2);
    #####:  481:        ensure_defined(r1);
    #####:  482:        r1.i = r1.i & r2.i;
    #####:  483:        push(r1);
    #####:  484:        break;
        -:  485:
    #####:  486:      case OP_BITWISE_OR:
    #####:  487:        pop(r2);
    #####:  488:        pop(r1);
    #####:  489:        ensure_defined(r2);
    #####:  490:        ensure_defined(r1);
    #####:  491:        r1.i = r1.i | r2.i;
    #####:  492:        push(r1);
    #####:  493:        break;
        -:  494:
    #####:  495:      case OP_BITWISE_XOR:
    #####:  496:        pop(r2);
    #####:  497:        pop(r1);
    #####:  498:        ensure_defined(r2);
    #####:  499:        ensure_defined(r1);
    #####:  500:        r1.i = r1.i ^ r2.i;
    #####:  501:        push(r1);
    #####:  502:        break;
        -:  503:
    #####:  504:      case OP_PUSH_RULE:
    #####:  505:        rule = *(YR_RULE**)(ip);
    #####:  506:        ip += sizeof(uint64_t);
    #####:  507:        if (RULE_IS_DISABLED(rule))
    #####:  508:          r1.i = UNDEFINED;
        -:  509:        else
    #####:  510:          r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
    #####:  511:        push(r1);
    #####:  512:        break;
        -:  513:
      280:  514:      case OP_INIT_RULE:
      280:  515:        memcpy(&init_rule_args, ip, sizeof(init_rule_args));
        -:  516:        #ifdef PROFILING_ENABLED
        -:  517:        current_rule = init_rule_args.rule;
        -:  518:        #endif
      280:  519:        if (RULE_IS_DISABLED(init_rule_args.rule))
    #####:  520:          ip = init_rule_args.jmp_addr;
        -:  521:        else
      280:  522:          ip += sizeof(init_rule_args);
      280:  523:        break;
        -:  524:
      280:  525:      case OP_MATCH_RULE:
     280*:  526:        pop(r1);
      280:  527:        rule = *(YR_RULE**)(ip);
        -:  528:
        -:  529:        #if PARANOID_EXEC
        -:  530:        // Make sure that the string pointer is within the rules arena.
      280:  531:        if (yr_arena_page_for_address(context->rules->arena, rule) == NULL)
    #####:  532:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  533:        #endif
        -:  534:
      280:  535:        ip += sizeof(uint64_t);
        -:  536:
      280:  537:        if (!is_undef(r1) && r1.i)
      209:  538:          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
       71:  539:        else if (RULE_IS_GLOBAL(rule))
    #####:  540:          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
        -:  541:
        -:  542:        #ifdef PROFILING_ENABLED
        -:  543:        elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  544:        rule->time_cost_per_thread[tidx] += (elapsed_time - start_time);
        -:  545:        start_time = elapsed_time;
        -:  546:        #endif
        -:  547:
     280*:  548:        assert(sp == 0); // at this point the stack should be empty.
      280:  549:        break;
        -:  550:
    #####:  551:      case OP_OBJ_LOAD:
    #####:  552:        identifier = *(char**)(ip);
    #####:  553:        ip += sizeof(uint64_t);
        -:  554:
    #####:  555:        r1.o = (YR_OBJECT*) yr_hash_table_lookup(
        -:  556:            context->objects_table,
        -:  557:            identifier,
        -:  558:            NULL);
        -:  559:
    #####:  560:        assert(r1.o != NULL);
    #####:  561:        push(r1);
    #####:  562:        break;
        -:  563:
    #####:  564:      case OP_OBJ_FIELD:
    #####:  565:        identifier = *(char**)(ip);
    #####:  566:        ip += sizeof(uint64_t);
        -:  567:
    #####:  568:        pop(r1);
    #####:  569:        ensure_defined(r1);
        -:  570:
    #####:  571:        r1.o = yr_object_lookup_field(r1.o, identifier);
        -:  572:
    #####:  573:        assert(r1.o != NULL);
    #####:  574:        push(r1);
    #####:  575:        break;
        -:  576:
    #####:  577:      case OP_OBJ_VALUE:
    #####:  578:        pop(r1);
    #####:  579:        ensure_defined(r1);
        -:  580:
        -:  581:        #if PARANOID_EXEC
    #####:  582:        check_object_canary(r1.o);
        -:  583:        #endif
        -:  584:
    #####:  585:        switch(r1.o->type)
        -:  586:        {
    #####:  587:          case OBJECT_TYPE_INTEGER:
    #####:  588:            r1.i = r1.o->value.i;
    #####:  589:            break;
        -:  590:
    #####:  591:          case OBJECT_TYPE_FLOAT:
    #####:  592:            if (isnan(r1.o->value.d))
    #####:  593:              r1.i = UNDEFINED;
        -:  594:            else
    #####:  595:              r1.d = r1.o->value.d;
    #####:  596:            break;
        -:  597:
    #####:  598:          case OBJECT_TYPE_STRING:
    #####:  599:            if (r1.o->value.ss == NULL)
    #####:  600:              r1.i = UNDEFINED;
        -:  601:            else
    #####:  602:              r1.ss = r1.o->value.ss;
    #####:  603:            break;
        -:  604:
    #####:  605:          default:
    #####:  606:            assert(false);
        -:  607:        }
        -:  608:
    #####:  609:        push(r1);
    #####:  610:        break;
        -:  611:
    #####:  612:      case OP_INDEX_ARRAY:
    #####:  613:        pop(r1);  // index
    #####:  614:        pop(r2);  // array
        -:  615:
    #####:  616:        ensure_defined(r1);
    #####:  617:        ensure_defined(r2);
        -:  618:
    #####:  619:        assert(r2.o->type == OBJECT_TYPE_ARRAY);
        -:  620:
        -:  621:        #if PARANOID_EXEC
    #####:  622:        check_object_canary(r2.o);
        -:  623:        #endif
        -:  624:
    #####:  625:        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
        -:  626:
    #####:  627:        if (r1.o == NULL)
    #####:  628:          r1.i = UNDEFINED;
        -:  629:
    #####:  630:        push(r1);
    #####:  631:        break;
        -:  632:
    #####:  633:      case OP_LOOKUP_DICT:
    #####:  634:        pop(r1);  // key
    #####:  635:        pop(r2);  // dictionary
        -:  636:
    #####:  637:        ensure_defined(r1);
    #####:  638:        ensure_defined(r2);
        -:  639:
    #####:  640:        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
        -:  641:
        -:  642:        #if PARANOID_EXEC
    #####:  643:        check_object_canary(r2.o);
        -:  644:        #endif
        -:  645:
    #####:  646:        r1.o = yr_object_dict_get_item(
    #####:  647:            r2.o, 0, r1.ss->c_string);
        -:  648:
    #####:  649:        if (r1.o == NULL)
    #####:  650:          r1.i = UNDEFINED;
        -:  651:
    #####:  652:        push(r1);
    #####:  653:        break;
        -:  654:
    #####:  655:      case OP_CALL:
    #####:  656:        args_fmt = *(char**)(ip);
    #####:  657:        ip += sizeof(uint64_t);
        -:  658:
    #####:  659:        i = (int) strlen(args_fmt);
    #####:  660:        count = 0;
        -:  661:
        -:  662:        #if PARANOID_EXEC
    #####:  663:        if (i > YR_MAX_FUNCTION_ARGS)
        -:  664:        {
    #####:  665:          stop = true;
    #####:  666:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####:  667:          break;
        -:  668:        }
        -:  669:        #endif
        -:  670:
        -:  671:        // pop arguments from stack and copy them to args array
        -:  672:
    #####:  673:        while (i > 0)
        -:  674:        {
    #####:  675:          pop(r1);
        -:  676:
    #####:  677:          if (is_undef(r1))  // count the number of undefined args
    #####:  678:            count++;
        -:  679:
    #####:  680:          args[i - 1] = r1;
    #####:  681:          i--;
        -:  682:        }
        -:  683:
    #####:  684:        pop(r2);
    #####:  685:        ensure_defined(r2);
        -:  686:
        -:  687:        #if PARANOID_EXEC
    #####:  688:        check_object_canary(r2.o);
        -:  689:        #endif
        -:  690:
    #####:  691:        if (count > 0)
        -:  692:        {
        -:  693:          // if there are undefined args, result for function call
        -:  694:          // is undefined as well.
        -:  695:
    #####:  696:          r1.i = UNDEFINED;
    #####:  697:          push(r1);
    #####:  698:          break;
        -:  699:        }
        -:  700:
    #####:  701:        function = object_as_function(r2.o);
    #####:  702:        result = ERROR_INTERNAL_FATAL_ERROR;
        -:  703:
    #####:  704:        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  705:        {
    #####:  706:          if (function->prototypes[i].arguments_fmt == NULL)
    #####:  707:            break;
        -:  708:
    #####:  709:          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
        -:  710:          {
    #####:  711:            result = function->prototypes[i].code(args, context, function);
    #####:  712:            break;
        -:  713:          }
        -:  714:        }
        -:  715:
        -:  716:        // if i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching
        -:  717:        // prototype was found, but this shouldn't happen.
        -:  718:
    #####:  719:        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);
        -:  720:
        -:  721:        // make a copy of the returned object and push the copy into the stack
        -:  722:        // function->return_obj can't be pushed because it can change in
        -:  723:        // subsequent calls to the same function.
        -:  724:
    #####:  725:        if (result == ERROR_SUCCESS)
    #####:  726:          result = yr_object_copy(function->return_obj, &r1.o);
        -:  727:
        -:  728:        // a pointer to the copied object is stored in a arena in order to
        -:  729:        // free the object before exiting yr_execute_code
        -:  730:
    #####:  731:        if (result == ERROR_SUCCESS)
    #####:  732:          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);
        -:  733:
    #####:  734:        stop = (result != ERROR_SUCCESS);
    #####:  735:        push(r1);
    #####:  736:        break;
        -:  737:
      276:  738:      case OP_FOUND:
     276*:  739:        pop(r1);
        -:  740:
      276:  741:        if (STRING_IS_PRIVATE(r1.s))
    #####:  742:          r2.i = r1.s->private_matches[tidx].tail != NULL ? 1 : 0;
        -:  743:        else
      276:  744:          r2.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
        -:  745:
     276*:  746:        push(r2);
      276:  747:        break;
        -:  748:
    #####:  749:      case OP_FOUND_AT:
    #####:  750:        pop(r2);
    #####:  751:        pop(r1);
        -:  752:
    #####:  753:        if (is_undef(r1))
        -:  754:        {
    #####:  755:          r1.i = 0;
    #####:  756:          push(r1);
    #####:  757:          break;
        -:  758:        }
        -:  759:
        -:  760:        #if PARANOID_EXEC
        -:  761:        // Make sure that the string pointer is within the rules arena.
    #####:  762:        if (yr_arena_page_for_address(context->rules->arena, r2.p) == NULL)
    #####:  763:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  764:        #endif
        -:  765:
    #####:  766:        if (STRING_IS_PRIVATE(r2.s))
    #####:  767:          match = r2.s->private_matches[tidx].head;
        -:  768:        else
    #####:  769:          match = r2.s->matches[tidx].head;
        -:  770:
    #####:  771:        r3.i = false;
        -:  772:
    #####:  773:        while (match != NULL)
        -:  774:        {
    #####:  775:          if (r1.i == match->base + match->offset)
        -:  776:          {
    #####:  777:            r3.i = true;
    #####:  778:            break;
        -:  779:          }
        -:  780:
    #####:  781:          if (r1.i < match->base + match->offset)
    #####:  782:            break;
        -:  783:
    #####:  784:          match = match->next;
        -:  785:        }
        -:  786:
    #####:  787:        push(r3);
    #####:  788:        break;
        -:  789:
    #####:  790:      case OP_FOUND_IN:
    #####:  791:        pop(r3);
    #####:  792:        pop(r2);
    #####:  793:        pop(r1);
        -:  794:
    #####:  795:        ensure_defined(r1);
    #####:  796:        ensure_defined(r2);
        -:  797:
        -:  798:        #if PARANOID_EXEC
        -:  799:        // Make sure that the string pointer is within the rules arena.
    #####:  800:        if (yr_arena_page_for_address(context->rules->arena, r3.p) == NULL)
    #####:  801:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  802:        #endif
        -:  803:
    #####:  804:        if (STRING_IS_PRIVATE(r3.s))
    #####:  805:          match = r3.s->private_matches[tidx].head;
        -:  806:        else
    #####:  807:          match = r3.s->matches[tidx].head;
        -:  808:
    #####:  809:        r4.i = false;
        -:  810:
    #####:  811:        while (match != NULL && !r4.i)
        -:  812:        {
    #####:  813:          if (match->base + match->offset >= r1.i &&
    #####:  814:              match->base + match->offset <= r2.i)
        -:  815:          {
    #####:  816:            r4.i = true;
        -:  817:          }
        -:  818:
    #####:  819:          if (match->base + match->offset > r2.i)
    #####:  820:            break;
        -:  821:
    #####:  822:          match = match->next;
        -:  823:        }
        -:  824:
    #####:  825:        push(r4);
    #####:  826:        break;
        -:  827:
    #####:  828:      case OP_COUNT:
    #####:  829:        pop(r1);
        -:  830:
        -:  831:        #if PARANOID_EXEC
        -:  832:        // Make sure that the string pointer is within the rules arena.
    #####:  833:        if (yr_arena_page_for_address(context->rules->arena, r1.p) == NULL)
    #####:  834:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  835:        #endif
        -:  836:
    #####:  837:        if (STRING_IS_PRIVATE(r1.s))
    #####:  838:          r2.i = r1.s->private_matches[tidx].count;
        -:  839:        else
    #####:  840:          r2.i = r1.s->matches[tidx].count;
        -:  841:
    #####:  842:        push(r2);
    #####:  843:        break;
        -:  844:
    #####:  845:      case OP_OFFSET:
    #####:  846:        pop(r2);
    #####:  847:        pop(r1);
        -:  848:
    #####:  849:        ensure_defined(r1);
        -:  850:
        -:  851:        #if PARANOID_EXEC
        -:  852:        // Make sure that the string pointer is within the rules arena.
    #####:  853:        if (yr_arena_page_for_address(context->rules->arena, r2.p) == NULL)
    #####:  854:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  855:        #endif
        -:  856:
    #####:  857:        if (STRING_IS_PRIVATE(r2.s))
    #####:  858:          match = r2.s->private_matches[tidx].head;
        -:  859:        else
    #####:  860:          match = r2.s->matches[tidx].head;
        -:  861:
    #####:  862:        i = 1;
    #####:  863:        r3.i = UNDEFINED;
        -:  864:
    #####:  865:        while (match != NULL && r3.i == UNDEFINED)
        -:  866:        {
    #####:  867:          if (r1.i == i)
    #####:  868:            r3.i = match->base + match->offset;
        -:  869:
    #####:  870:          i++;
    #####:  871:          match = match->next;
        -:  872:        }
        -:  873:
    #####:  874:        push(r3);
    #####:  875:        break;
        -:  876:
        4:  877:      case OP_LENGTH:
       4*:  878:        pop(r2);
       4*:  879:        pop(r1);
        -:  880:
       4*:  881:        ensure_defined(r1);
        -:  882:
        -:  883:        #if PARANOID_EXEC
        -:  884:        // Make sure that the string pointer is within the rules arena.
        4:  885:        if (yr_arena_page_for_address(context->rules->arena, r2.p) == NULL)
    #####:  886:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  887:        #endif
        -:  888:
        4:  889:        if (STRING_IS_PRIVATE(r2.s))
    #####:  890:          match = r2.s->private_matches[tidx].head;
        -:  891:        else
        4:  892:          match = r2.s->matches[tidx].head;
        -:  893:
        4:  894:        i = 1;
        4:  895:        r3.i = UNDEFINED;
        -:  896:
        8:  897:        while (match != NULL && r3.i == UNDEFINED)
        -:  898:        {
        4:  899:          if (r1.i == i)
        4:  900:            r3.i = match->match_length;
        -:  901:
        4:  902:          i++;
        4:  903:          match = match->next;
        -:  904:        }
        -:  905:
       4*:  906:        push(r3);
        4:  907:        break;
        -:  908:
    #####:  909:      case OP_OF:
    #####:  910:        found = 0;
    #####:  911:        count = 0;
    #####:  912:        pop(r1);
        -:  913:
    #####:  914:        while (!is_undef(r1))
        -:  915:        {
    #####:  916:          if (r1.s->matches[tidx].tail != NULL || r1.s->private_matches[tidx].tail != NULL)
    #####:  917:            found++;
    #####:  918:          count++;
    #####:  919:          pop(r1);
        -:  920:        }
        -:  921:
    #####:  922:        pop(r2);
        -:  923:
    #####:  924:        if (is_undef(r2))
    #####:  925:          r1.i = found >= count ? 1 : 0;
        -:  926:        else
    #####:  927:          r1.i = found >= r2.i ? 1 : 0;
        -:  928:
    #####:  929:        push(r1);
    #####:  930:        break;
        -:  931:
    #####:  932:      case OP_FILESIZE:
    #####:  933:        r1.i = context->file_size;
    #####:  934:        push(r1);
    #####:  935:        break;
        -:  936:
    #####:  937:      case OP_ENTRYPOINT:
    #####:  938:        r1.i = context->entry_point;
    #####:  939:        push(r1);
    #####:  940:        break;
        -:  941:
    #####:  942:      case OP_INT8:
    #####:  943:        pop(r1);
    #####:  944:        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  945:        push(r1);
    #####:  946:        break;
        -:  947:
    #####:  948:      case OP_INT16:
    #####:  949:        pop(r1);
    #####:  950:        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  951:        push(r1);
    #####:  952:        break;
        -:  953:
    #####:  954:      case OP_INT32:
    #####:  955:        pop(r1);
    #####:  956:        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  957:        push(r1);
    #####:  958:        break;
        -:  959:
    #####:  960:      case OP_UINT8:
    #####:  961:        pop(r1);
    #####:  962:        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  963:        push(r1);
    #####:  964:        break;
        -:  965:
    #####:  966:      case OP_UINT16:
    #####:  967:        pop(r1);
    #####:  968:        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  969:        push(r1);
    #####:  970:        break;
        -:  971:
    #####:  972:      case OP_UINT32:
    #####:  973:        pop(r1);
    #####:  974:        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  975:        push(r1);
    #####:  976:        break;
        -:  977:
    #####:  978:      case OP_INT8BE:
    #####:  979:        pop(r1);
    #####:  980:        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  981:        push(r1);
    #####:  982:        break;
        -:  983:
    #####:  984:      case OP_INT16BE:
    #####:  985:        pop(r1);
    #####:  986:        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  987:        push(r1);
    #####:  988:        break;
        -:  989:
    #####:  990:      case OP_INT32BE:
    #####:  991:        pop(r1);
    #####:  992:        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  993:        push(r1);
    #####:  994:        break;
        -:  995:
    #####:  996:      case OP_UINT8BE:
    #####:  997:        pop(r1);
    #####:  998:        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  999:        push(r1);
    #####: 1000:        break;
        -: 1001:
    #####: 1002:      case OP_UINT16BE:
    #####: 1003:        pop(r1);
    #####: 1004:        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1005:        push(r1);
    #####: 1006:        break;
        -: 1007:
    #####: 1008:      case OP_UINT32BE:
    #####: 1009:        pop(r1);
    #####: 1010:        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1011:        push(r1);
    #####: 1012:        break;
        -: 1013:
    #####: 1014:      case OP_CONTAINS:
    #####: 1015:        pop(r2);
    #####: 1016:        pop(r1);
        -: 1017:
    #####: 1018:        ensure_defined(r1);
    #####: 1019:        ensure_defined(r2);
        -: 1020:
    #####: 1021:        r1.i = memmem(r1.ss->c_string, r1.ss->length,
    #####: 1022:                      r2.ss->c_string, r2.ss->length) != NULL;
    #####: 1023:        push(r1);
    #####: 1024:        break;
        -: 1025:
    #####: 1026:      case OP_IMPORT:
    #####: 1027:        r1.i = *(uint64_t*)(ip);
    #####: 1028:        ip += sizeof(uint64_t);
        -: 1029:
    #####: 1030:        result = yr_modules_load((char*) r1.p, context);
        -: 1031:
    #####: 1032:        if (result != ERROR_SUCCESS)
    #####: 1033:          stop = true;
        -: 1034:
    #####: 1035:        break;
        -: 1036:
    #####: 1037:      case OP_MATCHES:
        -: 1038:
    #####: 1039:        pop(r2);
    #####: 1040:        pop(r1);
        -: 1041:
    #####: 1042:        ensure_defined(r2);
    #####: 1043:        ensure_defined(r1);
        -: 1044:
    #####: 1045:        if (r1.ss->length == 0)
        -: 1046:        {
    #####: 1047:          r1.i = false;
    #####: 1048:          push(r1);
    #####: 1049:          break;
        -: 1050:        }
        -: 1051:
    #####: 1052:        result = yr_re_exec(
        -: 1053:          context,
    #####: 1054:          (uint8_t*) r2.re->code,
    #####: 1055:          (uint8_t*) r1.ss->c_string,
    #####: 1056:          r1.ss->length,
        -: 1057:          0,
    #####: 1058:          r2.re->flags | RE_FLAGS_SCAN,
        -: 1059:          NULL,
        -: 1060:          NULL,
        -: 1061:          &found);
        -: 1062:
    #####: 1063:        if (result != ERROR_SUCCESS)
    #####: 1064:          stop = true;
        -: 1065:
    #####: 1066:        r1.i = found >= 0;
    #####: 1067:        push(r1);
    #####: 1068:        break;
        -: 1069:
    #####: 1070:      case OP_INT_TO_DBL:
        -: 1071:
    #####: 1072:        r1.i = *(uint64_t*)(ip);
    #####: 1073:        ip += sizeof(uint64_t);
        -: 1074:
        -: 1075:        #if PARANOID_EXEC
    #####: 1076:        if (r1.i > sp || sp - r1.i >= stack_size)
        -: 1077:        {
    #####: 1078:          stop = true;
    #####: 1079:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1080:          break;
        -: 1081:        }
        -: 1082:        #endif
        -: 1083:
    #####: 1084:        r2 = stack[sp - r1.i];
        -: 1085:
    #####: 1086:        if (is_undef(r2))
    #####: 1087:          stack[sp - r1.i].i = UNDEFINED;
        -: 1088:        else
    #####: 1089:          stack[sp - r1.i].d = (double) r2.i;
    #####: 1090:        break;
        -: 1091:
    #####: 1092:      case OP_STR_TO_BOOL:
    #####: 1093:        pop(r1);
    #####: 1094:        ensure_defined(r1);
    #####: 1095:        r1.i = r1.ss->length > 0;
    #####: 1096:        push(r1);
    #####: 1097:        break;
        -: 1098:
        4: 1099:      case OP_INT_EQ:
       4*: 1100:        pop(r2);
       4*: 1101:        pop(r1);
       4*: 1102:        ensure_defined(r2);
       4*: 1103:        ensure_defined(r1);
        4: 1104:        r1.i = r1.i == r2.i;
       4*: 1105:        push(r1);
        4: 1106:        break;
        -: 1107:
    #####: 1108:      case OP_INT_NEQ:
    #####: 1109:        pop(r2);
    #####: 1110:        pop(r1);
    #####: 1111:        ensure_defined(r2);
    #####: 1112:        ensure_defined(r1);
    #####: 1113:        r1.i = r1.i != r2.i;
    #####: 1114:        push(r1);
    #####: 1115:        break;
        -: 1116:
    #####: 1117:      case OP_INT_LT:
    #####: 1118:        pop(r2);
    #####: 1119:        pop(r1);
    #####: 1120:        ensure_defined(r2);
    #####: 1121:        ensure_defined(r1);
    #####: 1122:        r1.i = r1.i < r2.i;
    #####: 1123:        push(r1);
    #####: 1124:        break;
        -: 1125:
    #####: 1126:      case OP_INT_GT:
    #####: 1127:        pop(r2);
    #####: 1128:        pop(r1);
    #####: 1129:        ensure_defined(r2);
    #####: 1130:        ensure_defined(r1);
    #####: 1131:        r1.i = r1.i > r2.i;
    #####: 1132:        push(r1);
    #####: 1133:        break;
        -: 1134:
    #####: 1135:      case OP_INT_LE:
    #####: 1136:        pop(r2);
    #####: 1137:        pop(r1);
    #####: 1138:        ensure_defined(r2);
    #####: 1139:        ensure_defined(r1);
    #####: 1140:        r1.i = r1.i <= r2.i;
    #####: 1141:        push(r1);
    #####: 1142:        break;
        -: 1143:
    #####: 1144:      case OP_INT_GE:
    #####: 1145:        pop(r2);
    #####: 1146:        pop(r1);
    #####: 1147:        ensure_defined(r2);
    #####: 1148:        ensure_defined(r1);
    #####: 1149:        r1.i = r1.i >= r2.i;
    #####: 1150:        push(r1);
    #####: 1151:        break;
        -: 1152:
    #####: 1153:      case OP_INT_ADD:
    #####: 1154:        pop(r2);
    #####: 1155:        pop(r1);
    #####: 1156:        ensure_defined(r2);
    #####: 1157:        ensure_defined(r1);
    #####: 1158:        r1.i = r1.i + r2.i;
    #####: 1159:        push(r1);
    #####: 1160:        break;
        -: 1161:
    #####: 1162:      case OP_INT_SUB:
    #####: 1163:        pop(r2);
    #####: 1164:        pop(r1);
    #####: 1165:        ensure_defined(r2);
    #####: 1166:        ensure_defined(r1);
    #####: 1167:        r1.i = r1.i - r2.i;
    #####: 1168:        push(r1);
    #####: 1169:        break;
        -: 1170:
    #####: 1171:      case OP_INT_MUL:
    #####: 1172:        pop(r2);
    #####: 1173:        pop(r1);
    #####: 1174:        ensure_defined(r2);
    #####: 1175:        ensure_defined(r1);
    #####: 1176:        r1.i = r1.i * r2.i;
    #####: 1177:        push(r1);
    #####: 1178:        break;
        -: 1179:
    #####: 1180:      case OP_INT_DIV:
    #####: 1181:        pop(r2);
    #####: 1182:        pop(r1);
    #####: 1183:        ensure_defined(r2);
    #####: 1184:        ensure_defined(r1);
    #####: 1185:        if (r2.i != 0)
    #####: 1186:          r1.i = r1.i / r2.i;
        -: 1187:        else
    #####: 1188:          r1.i = UNDEFINED;
    #####: 1189:        push(r1);
    #####: 1190:        break;
        -: 1191:
    #####: 1192:      case OP_INT_MINUS:
    #####: 1193:        pop(r1);
    #####: 1194:        ensure_defined(r1);
    #####: 1195:        r1.i = -r1.i;
    #####: 1196:        push(r1);
    #####: 1197:        break;
        -: 1198:
    #####: 1199:      case OP_DBL_LT:
    #####: 1200:        pop(r2);
    #####: 1201:        pop(r1);
    #####: 1202:        ensure_defined(r2);
    #####: 1203:        ensure_defined(r1);
    #####: 1204:        r1.i = r1.d < r2.d;
    #####: 1205:        push(r1);
    #####: 1206:        break;
        -: 1207:
    #####: 1208:      case OP_DBL_GT:
    #####: 1209:        pop(r2);
    #####: 1210:        pop(r1);
    #####: 1211:        ensure_defined(r2);
    #####: 1212:        ensure_defined(r1);
    #####: 1213:        r1.i = r1.d > r2.d;
    #####: 1214:        push(r1);
    #####: 1215:        break;
        -: 1216:
    #####: 1217:      case OP_DBL_LE:
    #####: 1218:        pop(r2);
    #####: 1219:        pop(r1);
    #####: 1220:        ensure_defined(r2);
    #####: 1221:        ensure_defined(r1);
    #####: 1222:        r1.i = r1.d <= r2.d;
    #####: 1223:        push(r1);
    #####: 1224:        break;
        -: 1225:
    #####: 1226:      case OP_DBL_GE:
    #####: 1227:        pop(r2);
    #####: 1228:        pop(r1);
    #####: 1229:        ensure_defined(r2);
    #####: 1230:        ensure_defined(r1);
    #####: 1231:        r1.i = r1.d >= r2.d;
    #####: 1232:        push(r1);
    #####: 1233:        break;
        -: 1234:
    #####: 1235:      case OP_DBL_EQ:
    #####: 1236:        pop(r2);
    #####: 1237:        pop(r1);
    #####: 1238:        ensure_defined(r2);
    #####: 1239:        ensure_defined(r1);
    #####: 1240:        r1.i = fabs(r1.d - r2.d) < DBL_EPSILON;
    #####: 1241:        push(r1);
    #####: 1242:        break;
        -: 1243:
    #####: 1244:      case OP_DBL_NEQ:
    #####: 1245:        pop(r2);
    #####: 1246:        pop(r1);
    #####: 1247:        ensure_defined(r2);
    #####: 1248:        ensure_defined(r1);
    #####: 1249:        r1.i = fabs(r1.d - r2.d) >= DBL_EPSILON;
    #####: 1250:        push(r1);
    #####: 1251:        break;
        -: 1252:
    #####: 1253:      case OP_DBL_ADD:
    #####: 1254:        pop(r2);
    #####: 1255:        pop(r1);
    #####: 1256:        ensure_defined(r2);
    #####: 1257:        ensure_defined(r1);
    #####: 1258:        r1.d = r1.d + r2.d;
    #####: 1259:        push(r1);
    #####: 1260:        break;
        -: 1261:
    #####: 1262:      case OP_DBL_SUB:
    #####: 1263:        pop(r2);
    #####: 1264:        pop(r1);
    #####: 1265:        ensure_defined(r2);
    #####: 1266:        ensure_defined(r1);
    #####: 1267:        r1.d = r1.d - r2.d;
    #####: 1268:        push(r1);
    #####: 1269:        break;
        -: 1270:
    #####: 1271:      case OP_DBL_MUL:
    #####: 1272:        pop(r2);
    #####: 1273:        pop(r1);
    #####: 1274:        ensure_defined(r2);
    #####: 1275:        ensure_defined(r1);
    #####: 1276:        r1.d = r1.d * r2.d;
    #####: 1277:        push(r1);
    #####: 1278:        break;
        -: 1279:
    #####: 1280:      case OP_DBL_DIV:
    #####: 1281:        pop(r2);
    #####: 1282:        pop(r1);
    #####: 1283:        ensure_defined(r2);
    #####: 1284:        ensure_defined(r1);
    #####: 1285:        r1.d = r1.d / r2.d;
    #####: 1286:        push(r1);
    #####: 1287:        break;
        -: 1288:
    #####: 1289:      case OP_DBL_MINUS:
    #####: 1290:        pop(r1);
    #####: 1291:        ensure_defined(r1);
    #####: 1292:        r1.d = -r1.d;
    #####: 1293:        push(r1);
    #####: 1294:        break;
        -: 1295:
    #####: 1296:      case OP_STR_EQ:
        -: 1297:      case OP_STR_NEQ:
        -: 1298:      case OP_STR_LT:
        -: 1299:      case OP_STR_LE:
        -: 1300:      case OP_STR_GT:
        -: 1301:      case OP_STR_GE:
        -: 1302:
    #####: 1303:        pop(r2);
    #####: 1304:        pop(r1);
        -: 1305:
    #####: 1306:        ensure_defined(r1);
    #####: 1307:        ensure_defined(r2);
        -: 1308:
    #####: 1309:        switch(opcode)
        -: 1310:        {
    #####: 1311:          case OP_STR_EQ:
    #####: 1312:            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
    #####: 1313:            break;
    #####: 1314:          case OP_STR_NEQ:
    #####: 1315:            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
    #####: 1316:            break;
    #####: 1317:          case OP_STR_LT:
    #####: 1318:            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
    #####: 1319:            break;
    #####: 1320:          case OP_STR_LE:
    #####: 1321:            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
    #####: 1322:            break;
    #####: 1323:          case OP_STR_GT:
    #####: 1324:            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
    #####: 1325:            break;
    #####: 1326:          case OP_STR_GE:
    #####: 1327:            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
    #####: 1328:            break;
        -: 1329:        }
        -: 1330:
    #####: 1331:        push(r1);
    #####: 1332:        break;
        -: 1333:
    #####: 1334:      default:
        -: 1335:        // Unknown instruction, this shouldn't happen.
    #####: 1336:        assert(false);
        -: 1337:    }
        -: 1338:
        -: 1339:    // Check for timeout every 10 instruction cycles. If timeout == 0 it means
        -: 1340:    // no timeout at all.
        -: 1341:
    1692*: 1342:    if (context->timeout > 0L && ++cycle == 10)
        -: 1343:    {
    #####: 1344:      elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -: 1345:
    #####: 1346:      if (elapsed_time > context->timeout)
        -: 1347:      {
        -: 1348:        #ifdef PROFILING_ENABLED
        -: 1349:        assert(current_rule != NULL);
        -: 1350:        current_rule->time_cost_per_thread[tidx] += elapsed_time - start_time;
        -: 1351:        #endif
    #####: 1352:        result = ERROR_SCAN_TIMEOUT;
    #####: 1353:        stop = true;
        -: 1354:      }
        -: 1355:
    #####: 1356:      cycle = 0;
        -: 1357:    }
        -: 1358:  }
        -: 1359:
      280: 1360:  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);
        -: 1361:
      280: 1362:  while (obj_ptr != NULL)
        -: 1363:  {
    #####: 1364:    yr_object_destroy(*obj_ptr);
        -: 1365:
    #####: 1366:    obj_ptr = (YR_OBJECT**) yr_arena_next_address(
        -: 1367:        obj_arena, obj_ptr, sizeof(YR_OBJECT*));
        -: 1368:  }
        -: 1369:
      280: 1370:  yr_arena_destroy(obj_arena);
      280: 1371:  yr_modules_unload_all(context);
      280: 1372:  yr_free(stack);
        -: 1373:
      280: 1374:  return result;
        -: 1375:}
