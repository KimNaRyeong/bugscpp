        -:    0:Source:grammar.y
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:%{
        -:   31:
        -:   32:
        -:   33:#include <assert.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <limits.h>
        -:   37:#include <stdlib.h>
        -:   38:#include <stddef.h>
        -:   39:
        -:   40:#include <yara/integers.h>
        -:   41:#include <yara/utils.h>
        -:   42:#include <yara/strutils.h>
        -:   43:#include <yara/compiler.h>
        -:   44:#include <yara/object.h>
        -:   45:#include <yara/sizedstr.h>
        -:   46:#include <yara/exec.h>
        -:   47:#include <yara/error.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/lexer.h>
        -:   50:#include <yara/parser.h>
        -:   51:
        -:   52:#if defined(_MSC_VER)
        -:   53:#define llabs _abs64
        -:   54:#endif
        -:   55:
        -:   56:#define YYERROR_VERBOSE
        -:   57:
        -:   58:#define YYMALLOC yr_malloc
        -:   59:#define YYFREE yr_free
        -:   60:
        -:   61:#define INTEGER_SET_ENUMERATION   1
        -:   62:#define INTEGER_SET_RANGE         2
        -:   63:
        -:   64:#define FOR_EXPRESSION_ALL 1
        -:   65:#define FOR_EXPRESSION_ANY 2
        -:   66:
        -:   67:#define fail_if_error(e) \
        -:   68:    if (e != ERROR_SUCCESS) \
        -:   69:    { \
        -:   70:      compiler->last_error = e; \
        -:   71:      yyerror(yyscanner, compiler, NULL); \
        -:   72:      YYERROR; \
        -:   73:    } \
        -:   74:
        -:   75:
        -:   76:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:   77:    if (((expression.type) & (expected_type)) == 0) \
        -:   78:    { \
        -:   79:      switch(expression.type) \
        -:   80:      { \
        -:   81:        case EXPRESSION_TYPE_INTEGER: \
        -:   82:          yr_compiler_set_error_extra_info( \
        -:   83:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:   84:          break; \
        -:   85:        case EXPRESSION_TYPE_FLOAT: \
        -:   86:          yr_compiler_set_error_extra_info( \
        -:   87:              compiler, "wrong type \"float\" for " op " operator"); \
        -:   88:          break; \
        -:   89:        case EXPRESSION_TYPE_STRING: \
        -:   90:          yr_compiler_set_error_extra_info( \
        -:   91:              compiler, "wrong type \"string\" for " op " operator"); \
        -:   92:          break; \
        -:   93:        case EXPRESSION_TYPE_BOOLEAN: \
        -:   94:          yr_compiler_set_error_extra_info( \
        -:   95:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:   96:          break; \
        -:   97:      } \
        -:   98:      cleanup; \
        -:   99:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  100:      yyerror(yyscanner, compiler, NULL); \
        -:  101:      YYERROR; \
        -:  102:    }
        -:  103:
        -:  104:
        -:  105:#define check_type(expression, expected_type, op) \
        -:  106:    check_type_with_cleanup(expression, expected_type, op, )
        -:  107:
        -:  108:%}
        -:  109:
        -:  110:
        -:  111:%expect 1   // expect 1 shift/reduce conflicts
        -:  112:
        -:  113:// Uncomment this line to print parsing information that can be useful to
        -:  114:// debug YARA's grammar.
        -:  115:
        -:  116:// %debug
        -:  117:
        -:  118:%name-prefix "yara_yy"
        -:  119:%pure-parser
        -:  120:%parse-param {void *yyscanner}
        -:  121:%parse-param {YR_COMPILER* compiler}
        -:  122:%lex-param {yyscan_t yyscanner}
        -:  123:%lex-param {YR_COMPILER* compiler}
        -:  124:
        -:  125:// Token that marks the end of the original file.
        -:  126:%token _END_OF_FILE_  0                                "end of file"
        -:  127:
        -:  128:// Token that marks the end of included files, we can't use  _END_OF_FILE_
        -:  129:// because bison stops parsing when it sees _END_OF_FILE_, we want to be
        -:  130:// be able to identify the point where an included file ends, but continuing
        -:  131:// parsing any content that follows.
        -:  132:%token _END_OF_INCLUDED_FILE_                          "end of included file"
        -:  133:
        -:  134:%token _DOT_DOT_                                       ".."
        -:  135:%token _RULE_                                          "<rule>"
        -:  136:%token _PRIVATE_                                       "<private>"
        -:  137:%token _GLOBAL_                                        "<global>"
        -:  138:%token _META_                                          "<meta>"
        -:  139:%token <string> _STRINGS_                              "<strings>"
        -:  140:%token _CONDITION_                                     "<condition>"
        -:  141:%token <c_string> _IDENTIFIER_                         "identifier"
        -:  142:%token <c_string> _STRING_IDENTIFIER_                  "string identifier"
        -:  143:%token <c_string> _STRING_COUNT_                       "string count"
        -:  144:%token <c_string> _STRING_OFFSET_                      "string offset"
        -:  145:%token <c_string> _STRING_LENGTH_                      "string length"
        -:  146:%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_
        -:  147:    "string identifier with wildcard"
        -:  148:%token <integer> _NUMBER_                              "integer number"
        -:  149:%token <double_> _DOUBLE_                              "floating point number"
        -:  150:%token <integer> _INTEGER_FUNCTION_                    "integer function"
        -:  151:%token <sized_string> _TEXT_STRING_                    "text string"
        -:  152:%token <sized_string> _HEX_STRING_                     "hex string"
        -:  153:%token <sized_string> _REGEXP_                         "regular expression"
        -:  154:%token _ASCII_                                         "<ascii>"
        -:  155:%token _WIDE_                                          "<wide>"
        -:  156:%token _XOR_                                           "<xor>"
        -:  157:%token _NOCASE_                                        "<nocase>"
        -:  158:%token _FULLWORD_                                      "<fullword>"
        -:  159:%token _AT_                                            "<at>"
        -:  160:%token _FILESIZE_                                      "<filesize>"
        -:  161:%token _ENTRYPOINT_                                    "<entrypoint>"
        -:  162:%token _ALL_                                           "<all>"
        -:  163:%token _ANY_                                           "<any>"
        -:  164:%token _IN_                                            "<in>"
        -:  165:%token _OF_                                            "<of>"
        -:  166:%token _FOR_                                           "<for>"
        -:  167:%token _THEM_                                          "<them>"
        -:  168:%token _MATCHES_                                       "<matches>"
        -:  169:%token _CONTAINS_                                      "<contains>"
        -:  170:%token _IMPORT_                                        "<import>"
        -:  171:%token _TRUE_                                          "<true>"
        -:  172:%token _FALSE_                                         "<false"
        -:  173:%token _OR_                                            "<or>"
        -:  174:%token _AND_                                           "<and>"
        -:  175:%token _NOT_                                           "<not>"
        -:  176:%token _EQ_                                            "=="
        -:  177:%token _NEQ_                                           "!="
        -:  178:%token _LT_                                            "<"
        -:  179:%token _LE_                                            "<="
        -:  180:%token _GT_                                            ">"
        -:  181:%token _GE_                                            ">="
        -:  182:%token _SHIFT_LEFT_                                    "<<"
        -:  183:%token _SHIFT_RIGHT_                                   ">>"
        -:  184:
        -:  185:%left _OR_
        -:  186:%left _AND_
        -:  187:%left '|'
        -:  188:%left '^'
        -:  189:%left '&'
        -:  190:%left _EQ_ _NEQ_
        -:  191:%left _LT_ _LE_ _GT_ _GE_
        -:  192:%left _SHIFT_LEFT_ _SHIFT_RIGHT_
        -:  193:%left '+' '-'
        -:  194:%left '*' '\\' '%'
        -:  195:%right _NOT_ '~' UNARY_MINUS
        -:  196:
        -:  197:%type <rule>   rule
        -:  198:
        -:  199:%type <string> strings
        -:  200:%type <string> string_declaration
        -:  201:%type <string> string_declarations
        -:  202:
        -:  203:%type <meta> meta
        -:  204:%type <meta> meta_declaration
        -:  205:%type <meta> meta_declarations
        -:  206:
        -:  207:%type <c_string> tags
        -:  208:%type <c_string> tag_list
        -:  209:
        -:  210:%type <integer> string_modifier
        -:  211:%type <integer> string_modifiers
        -:  212:
        -:  213:%type <integer> regexp_modifier
        -:  214:%type <integer> regexp_modifiers
        -:  215:
        -:  216:%type <integer> hex_modifier
        -:  217:%type <integer> hex_modifiers
        -:  218:
        -:  219:%type <integer> integer_set
        -:  220:
        -:  221:%type <integer> for_expression
        -:  222:
        -:  223:%type <integer> rule_modifier
        -:  224:%type <integer> rule_modifiers
        -:  225:
        -:  226:%type <expression> primary_expression
        -:  227:%type <expression> boolean_expression
        -:  228:%type <expression> expression
        -:  229:%type <expression> identifier
        -:  230:%type <expression> regexp
        -:  231:
        -:  232:%type <c_string> arguments
        -:  233:%type <c_string> arguments_list
        -:  234:
       16:  235:%destructor { yr_free($$); $$ = NULL; } _IDENTIFIER_
    #####:  236:%destructor { yr_free($$); $$ = NULL; } _STRING_COUNT_
    #####:  237:%destructor { yr_free($$); $$ = NULL; } _STRING_OFFSET_
    #####:  238:%destructor { yr_free($$); $$ = NULL; } _STRING_LENGTH_
       15:  239:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_
    #####:  240:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_WITH_WILDCARD_
    #####:  241:%destructor { yr_free($$); $$ = NULL; } _TEXT_STRING_
    #####:  242:%destructor { yr_free($$); $$ = NULL; } _HEX_STRING_
    #####:  243:%destructor { yr_free($$); $$ = NULL; } _REGEXP_
        -:  244:
    #####:  245:%destructor { yr_free($$); $$ = NULL; } arguments
    #####:  246:%destructor { yr_free($$); $$ = NULL; } arguments_list
        -:  247:
        -:  248:%union {
        -:  249:  EXPRESSION      expression;
        -:  250:  SIZED_STRING*   sized_string;
        -:  251:  char*           c_string;
        -:  252:  int64_t         integer;
        -:  253:  double          double_;
        -:  254:  YR_STRING*      string;
        -:  255:  YR_META*        meta;
        -:  256:  YR_RULE*        rule;
        -:  257:}
        -:  258:
        -:  259:
        -:  260:%%
        -:  261:
        -:  262:rules
        -:  263:    : /* empty */
        -:  264:    | rules rule
        -:  265:    | rules import
        -:  266:    | rules error rule      /* on error skip until next rule..*/
        -:  267:    | rules error import    /* .. or import statement */
        -:  268:    | rules error "include" /* .. or include statement */
        -:  269:    | rules _END_OF_INCLUDED_FILE_
        -:  270:      {
    #####:  271:        _yr_compiler_pop_file_name(compiler);
        -:  272:      }
        -:  273:    ;
        -:  274:
        -:  275:
        -:  276:import
        -:  277:    : _IMPORT_ _TEXT_STRING_
        -:  278:      {
    #####:  279:        int result = yr_parser_reduce_import(yyscanner, $2);
        -:  280:
    #####:  281:        yr_free($2);
        -:  282:
    #####:  283:        fail_if_error(result);
        -:  284:      }
        -:  285:    ;
        -:  286:
        -:  287:
        -:  288:rule
        -:  289:    : rule_modifiers _RULE_ _IDENTIFIER_
        -:  290:      {
     296*:  291:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -:  292:            yyscanner, (int32_t) $1, $3, &$<rule>$));
        -:  293:      }
        -:  294:      tags '{' meta strings
        -:  295:      {
      281:  296:        YR_RULE* rule = $<rule>4; // rule created in phase 1
        -:  297:
      281:  298:        rule->tags = $5;
      281:  299:        rule->metas = $7;
      281:  300:        rule->strings = $8;
        -:  301:      }
        -:  302:      condition '}'
        -:  303:      {
      280:  304:        int result = yr_parser_reduce_rule_declaration_phase_2(
      280:  305:            yyscanner, $<rule>4); // rule created in phase 1
        -:  306:
      280:  307:        yr_free($3);
        -:  308:
     280*:  309:        fail_if_error(result);
        -:  310:      }
        -:  311:    ;
        -:  312:
        -:  313:
        -:  314:meta
        -:  315:    : /* empty */
        -:  316:      {
      296:  317:        $$ = NULL;
        -:  318:      }
        -:  319:    | _META_ ':' meta_declarations
        -:  320:      {
        -:  321:        int result;
        -:  322:
        -:  323:        // Each rule have a list of meta-data info, consisting in a
        -:  324:        // sequence of YR_META structures. The last YR_META structure does
        -:  325:        // not represent a real meta-data, it's just a end-of-list marker
        -:  326:        // identified by a specific type (META_TYPE_NULL). Here we
        -:  327:        // write the end-of-list marker.
        -:  328:
        -:  329:        YR_META null_meta;
        -:  330:
    #####:  331:        memset(&null_meta, 0xFF, sizeof(YR_META));
    #####:  332:        null_meta.type = META_TYPE_NULL;
        -:  333:
    #####:  334:        result = yr_arena_write_data(
        -:  335:            compiler->metas_arena,
        -:  336:            &null_meta,
        -:  337:            sizeof(YR_META),
        -:  338:            NULL);
        -:  339:
    #####:  340:        $$ = $3;
        -:  341:
    #####:  342:        fail_if_error(result);
        -:  343:      }
        -:  344:    ;
        -:  345:
        -:  346:
        -:  347:strings
        -:  348:    : /* empty */
        -:  349:      {
    #####:  350:        $$ = NULL;
        -:  351:      }
        -:  352:    | _STRINGS_ ':' string_declarations
        -:  353:      {
        -:  354:        // Each rule have a list of strings, consisting in a sequence
        -:  355:        // of YR_STRING structures. The last YR_STRING structure does not
        -:  356:        // represent a real string, it's just a end-of-list marker
        -:  357:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -:  358:        // write the end-of-list marker.
        -:  359:
        -:  360:        YR_STRING null_string;
        -:  361:
      281:  362:        memset(&null_string, 0xFF, sizeof(YR_STRING));
      281:  363:        null_string.g_flags = STRING_GFLAGS_NULL;
        -:  364:
     281*:  365:        fail_if_error(yr_arena_write_data(
        -:  366:            compiler->strings_arena,
        -:  367:            &null_string,
        -:  368:            sizeof(YR_STRING),
        -:  369:            NULL));
        -:  370:
      281:  371:        $$ = $3;
        -:  372:      }
        -:  373:    ;
        -:  374:
        -:  375:
        -:  376:condition
        -:  377:    : _CONDITION_ ':' boolean_expression
        -:  378:    ;
        -:  379:
        -:  380:
        -:  381:rule_modifiers
      364:  382:    : /* empty */                      { $$ = 0;  }
    #####:  383:    | rule_modifiers rule_modifier     { $$ = $1 | $2; }
        -:  384:    ;
        -:  385:
        -:  386:
        -:  387:rule_modifier
    #####:  388:    : _PRIVATE_      { $$ = RULE_GFLAGS_PRIVATE; }
    #####:  389:    | _GLOBAL_       { $$ = RULE_GFLAGS_GLOBAL; }
        -:  390:    ;
        -:  391:
        -:  392:
        -:  393:tags
        -:  394:    : /* empty */
        -:  395:      {
      296:  396:        $$ = NULL;
        -:  397:      }
        -:  398:    | ':' tag_list
        -:  399:      {
        -:  400:        // Tags list is represented in the arena as a sequence
        -:  401:        // of null-terminated strings, the sequence ends with an
        -:  402:        // additional null character. Here we write the ending null
        -:  403:        //character. Example: tag1\0tag2\0tag3\0\0
        -:  404:
    #####:  405:        int result = yr_arena_write_string(
    #####:  406:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -:  407:
    #####:  408:        fail_if_error(result);
        -:  409:
    #####:  410:        $$ = $2;
        -:  411:      }
        -:  412:    ;
        -:  413:
        -:  414:
        -:  415:tag_list
        -:  416:    : _IDENTIFIER_
        -:  417:      {
    #####:  418:        int result = yr_arena_write_string(
    #####:  419:            yyget_extra(yyscanner)->sz_arena, $1, &$$);
        -:  420:
    #####:  421:        yr_free($1);
        -:  422:
    #####:  423:        fail_if_error(result);
        -:  424:      }
        -:  425:    | tag_list _IDENTIFIER_
        -:  426:      {
    #####:  427:        int result = ERROR_SUCCESS;
        -:  428:
    #####:  429:        char* tag_name = $1;
    #####:  430:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  431:
    #####:  432:        while (tag_length > 0)
        -:  433:        {
    #####:  434:          if (strcmp(tag_name, $2) == 0)
        -:  435:          {
    #####:  436:            yr_compiler_set_error_extra_info(compiler, tag_name);
    #####:  437:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
    #####:  438:            break;
        -:  439:          }
        -:  440:
    #####:  441:          tag_name = (char*) yr_arena_next_address(
    #####:  442:              yyget_extra(yyscanner)->sz_arena,
        -:  443:              tag_name,
        -:  444:              tag_length + 1);
        -:  445:
    #####:  446:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  447:        }
        -:  448:
    #####:  449:        if (result == ERROR_SUCCESS)
    #####:  450:          result = yr_arena_write_string(
    #####:  451:              yyget_extra(yyscanner)->sz_arena, $2, NULL);
        -:  452:
    #####:  453:        yr_free($2);
        -:  454:
    #####:  455:        fail_if_error(result);
        -:  456:
    #####:  457:        $$ = $1;
        -:  458:      }
        -:  459:    ;
        -:  460:
        -:  461:
        -:  462:
        -:  463:meta_declarations
    #####:  464:    : meta_declaration                    {  $$ = $1; }
    #####:  465:    | meta_declarations meta_declaration  {  $$ = $1; }
        -:  466:    ;
        -:  467:
        -:  468:
        -:  469:meta_declaration
        -:  470:    : _IDENTIFIER_ '=' _TEXT_STRING_
        -:  471:      {
    #####:  472:        SIZED_STRING* sized_string = $3;
        -:  473:
    #####:  474:        int result = yr_parser_reduce_meta_declaration(
        -:  475:            yyscanner,
        -:  476:            META_TYPE_STRING,
    #####:  477:            $1,
    #####:  478:            sized_string->c_string,
        -:  479:            0,
        -:  480:            &$$);
        -:  481:
    #####:  482:        yr_free($1);
    #####:  483:        yr_free($3);
        -:  484:
    #####:  485:        fail_if_error(result);
        -:  486:      }
        -:  487:    | _IDENTIFIER_ '=' _NUMBER_
        -:  488:      {
    #####:  489:        int result = yr_parser_reduce_meta_declaration(
        -:  490:            yyscanner,
        -:  491:            META_TYPE_INTEGER,
    #####:  492:            $1,
        -:  493:            NULL,
        -:  494:            $3,
        -:  495:            &$$);
        -:  496:
    #####:  497:        yr_free($1);
        -:  498:
    #####:  499:        fail_if_error(result);
        -:  500:      }
        -:  501:    | _IDENTIFIER_ '=' '-' _NUMBER_
        -:  502:      {
    #####:  503:        int result = yr_parser_reduce_meta_declaration(
        -:  504:            yyscanner,
        -:  505:            META_TYPE_INTEGER,
    #####:  506:            $1,
        -:  507:            NULL,
    #####:  508:            -$4,
        -:  509:            &$$);
        -:  510:
    #####:  511:        yr_free($1);
        -:  512:
    #####:  513:        fail_if_error(result);
        -:  514:      }
        -:  515:    | _IDENTIFIER_ '=' _TRUE_
        -:  516:      {
    #####:  517:        int result = yr_parser_reduce_meta_declaration(
        -:  518:            yyscanner,
        -:  519:            META_TYPE_BOOLEAN,
    #####:  520:            $1,
        -:  521:            NULL,
        -:  522:            true,
        -:  523:            &$$);
        -:  524:
    #####:  525:        yr_free($1);
        -:  526:
    #####:  527:        fail_if_error(result);
        -:  528:      }
        -:  529:    | _IDENTIFIER_ '=' _FALSE_
        -:  530:      {
    #####:  531:        int result = yr_parser_reduce_meta_declaration(
        -:  532:            yyscanner,
        -:  533:            META_TYPE_BOOLEAN,
    #####:  534:            $1,
        -:  535:            NULL,
        -:  536:            false,
        -:  537:            &$$);
        -:  538:
    #####:  539:        yr_free($1);
        -:  540:
    #####:  541:        fail_if_error(result);
        -:  542:      }
        -:  543:    ;
        -:  544:
        -:  545:
        -:  546:string_declarations
      281:  547:    : string_declaration                      { $$ = $1; }
    #####:  548:    | string_declarations string_declaration  { $$ = $1; }
        -:  549:    ;
        -:  550:
        -:  551:
        -:  552:string_declaration
        -:  553:    : _STRING_IDENTIFIER_ '='
        -:  554:      {
        3:  555:        compiler->current_line = yyget_lineno(yyscanner);
        -:  556:      }
        -:  557:      _TEXT_STRING_ string_modifiers
        -:  558:      {
        1:  559:        int result = yr_parser_reduce_string_declaration(
        1:  560:            yyscanner, (int32_t) $5, $1, $4, &$$);
        -:  561:
        1:  562:        yr_free($1);
        1:  563:        yr_free($4);
        -:  564:
       1*:  565:        fail_if_error(result);
        1:  566:        compiler->current_line = 0;
        -:  567:      }
        -:  568:    | _STRING_IDENTIFIER_ '='
        -:  569:      {
      293:  570:        compiler->current_line = yyget_lineno(yyscanner);
        -:  571:      }
        -:  572:      _REGEXP_ regexp_modifiers
        -:  573:      {
      293:  574:        int result = yr_parser_reduce_string_declaration(
      293:  575:            yyscanner, (int32_t) $5 | STRING_GFLAGS_REGEXP, $1, $4, &$$);
        -:  576:
      293:  577:        yr_free($1);
      293:  578:        yr_free($4);
        -:  579:
      293:  580:        fail_if_error(result);
        -:  581:
      280:  582:        compiler->current_line = 0;
        -:  583:      }
        -:  584:    | _STRING_IDENTIFIER_ '='
        -:  585:      {
    #####:  586:        compiler->current_line = yyget_lineno(yyscanner);
        -:  587:      }
        -:  588:      _HEX_STRING_ hex_modifiers
        -:  589:      {
    #####:  590:        int result = yr_parser_reduce_string_declaration(
    #####:  591:            yyscanner, (int32_t) $5 | STRING_GFLAGS_HEXADECIMAL, $1, $4, &$$);
        -:  592:
    #####:  593:        yr_free($1);
    #####:  594:        yr_free($4);
        -:  595:
    #####:  596:        fail_if_error(result);
        -:  597:
    #####:  598:        compiler->current_line = 0;
        -:  599:      }
        -:  600:    ;
        -:  601:
        -:  602:
        -:  603:string_modifiers
        1:  604:    : /* empty */                         { $$ = 0; }
        2:  605:    | string_modifiers string_modifier    { $$ = $1 | $2; }
        -:  606:    ;
        -:  607:
        -:  608:
        -:  609:string_modifier
        1:  610:    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }
    #####:  611:    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }
        1:  612:    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }
    #####:  613:    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }
    #####:  614:    | _XOR_         { $$ = STRING_GFLAGS_XOR; }
    #####:  615:    | _PRIVATE_     { $$ = STRING_GFLAGS_PRIVATE; }
        -:  616:    ;
        -:  617:
        -:  618:regexp_modifiers
      293:  619:    : /* empty */                         { $$ = 0; }
       24:  620:    | regexp_modifiers regexp_modifier    { $$ = $1 | $2; }
        -:  621:    ;
        -:  622:
        -:  623:regexp_modifier
       13:  624:    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }
    #####:  625:    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }
        9:  626:    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }
        2:  627:    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }
    #####:  628:    | _PRIVATE_     { $$ = STRING_GFLAGS_PRIVATE; }
        -:  629:    ;
        -:  630:
        -:  631:hex_modifiers
    #####:  632:    : /* empty */                         { $$ = 0; }
    #####:  633:    | hex_modifiers hex_modifier          { $$ = $1 | $2; }
        -:  634:    ;
        -:  635:
        -:  636:hex_modifier
    #####:  637:    : _PRIVATE_     { $$ = STRING_GFLAGS_PRIVATE; }
        -:  638:    ;
        -:  639:
        -:  640:identifier
        -:  641:    : _IDENTIFIER_
        -:  642:      {
    #####:  643:        int result = ERROR_SUCCESS;
    #####:  644:        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1);
        -:  645:
    #####:  646:        if (var_index >= 0)
        -:  647:        {
    #####:  648:          result = yr_parser_emit_with_arg(
        -:  649:              yyscanner,
        -:  650:              OP_PUSH_M,
    #####:  651:              LOOP_LOCAL_VARS * var_index,
        -:  652:              NULL,
        -:  653:              NULL);
        -:  654:
    #####:  655:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####:  656:          $$.value.integer = UNDEFINED;
    #####:  657:          $$.identifier = compiler->loop_identifier[var_index];
        -:  658:        }
        -:  659:        else
        -:  660:        {
        -:  661:          // Search for identifier within the global namespace, where the
        -:  662:          // externals variables reside.
        -:  663:
    #####:  664:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  665:              compiler->objects_table, $1, NULL);
        -:  666:
    #####:  667:          if (object == NULL)
        -:  668:          {
        -:  669:            // If not found, search within the current namespace.
    #####:  670:            char* ns = compiler->current_namespace->name;
        -:  671:
    #####:  672:            object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  673:                compiler->objects_table, $1, ns);
        -:  674:          }
        -:  675:
    #####:  676:          if (object != NULL)
        -:  677:          {
        -:  678:            char* id;
        -:  679:
    #####:  680:            result = yr_arena_write_string(
    #####:  681:                compiler->sz_arena, $1, &id);
        -:  682:
    #####:  683:            if (result == ERROR_SUCCESS)
    #####:  684:              result = yr_parser_emit_with_arg_reloc(
        -:  685:                  yyscanner,
        -:  686:                  OP_OBJ_LOAD,
        -:  687:                  id,
        -:  688:                  NULL,
        -:  689:                  NULL);
        -:  690:
    #####:  691:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  692:            $$.value.object = object;
    #####:  693:            $$.identifier = object->identifier;
        -:  694:          }
        -:  695:          else
        -:  696:          {
    #####:  697:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -:  698:                compiler->rules_table,
    #####:  699:                $1,
    #####:  700:                compiler->current_namespace->name);
        -:  701:
    #####:  702:            if (rule != NULL)
        -:  703:            {
    #####:  704:              result = yr_parser_emit_with_arg_reloc(
        -:  705:                  yyscanner,
        -:  706:                  OP_PUSH_RULE,
        -:  707:                  rule,
        -:  708:                  NULL,
        -:  709:                  NULL);
        -:  710:
    #####:  711:              $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####:  712:              $$.value.integer = UNDEFINED;
    #####:  713:              $$.identifier = rule->identifier;
        -:  714:            }
        -:  715:            else
        -:  716:            {
    #####:  717:              yr_compiler_set_error_extra_info(compiler, $1);
    #####:  718:              result = ERROR_UNDEFINED_IDENTIFIER;
        -:  719:            }
        -:  720:          }
        -:  721:        }
        -:  722:
    #####:  723:        yr_free($1);
        -:  724:
    #####:  725:        fail_if_error(result);
        -:  726:      }
        -:  727:    | identifier '.' _IDENTIFIER_
        -:  728:      {
    #####:  729:        int result = ERROR_SUCCESS;
    #####:  730:        YR_OBJECT* field = NULL;
        -:  731:
    #####:  732:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  733:            $1.value.object->type == OBJECT_TYPE_STRUCTURE)
        -:  734:        {
    #####:  735:          field = yr_object_lookup_field($1.value.object, $3);
        -:  736:
    #####:  737:          if (field != NULL)
        -:  738:          {
        -:  739:            char* ident;
        -:  740:
    #####:  741:            result = yr_arena_write_string(
    #####:  742:                compiler->sz_arena, $3, &ident);
        -:  743:
    #####:  744:            if (result == ERROR_SUCCESS)
    #####:  745:              result = yr_parser_emit_with_arg_reloc(
        -:  746:                  yyscanner,
        -:  747:                  OP_OBJ_FIELD,
        -:  748:                  ident,
        -:  749:                  NULL,
        -:  750:                  NULL);
        -:  751:
    #####:  752:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  753:            $$.value.object = field;
    #####:  754:            $$.identifier = field->identifier;
        -:  755:          }
        -:  756:          else
        -:  757:          {
    #####:  758:            yr_compiler_set_error_extra_info(compiler, $3);
    #####:  759:            result = ERROR_INVALID_FIELD_NAME;
        -:  760:          }
        -:  761:        }
        -:  762:        else
        -:  763:        {
    #####:  764:          yr_compiler_set_error_extra_info(
        -:  765:              compiler, $1.identifier);
        -:  766:
    #####:  767:          result = ERROR_NOT_A_STRUCTURE;
        -:  768:        }
        -:  769:
    #####:  770:        yr_free($3);
        -:  771:
    #####:  772:        fail_if_error(result);
        -:  773:      }
        -:  774:    | identifier '[' primary_expression ']'
        -:  775:      {
    #####:  776:        int result = ERROR_SUCCESS;
        -:  777:        YR_OBJECT_ARRAY* array;
        -:  778:        YR_OBJECT_DICTIONARY* dict;
        -:  779:
    #####:  780:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  781:            $1.value.object->type == OBJECT_TYPE_ARRAY)
        -:  782:        {
    #####:  783:          if ($3.type != EXPRESSION_TYPE_INTEGER)
        -:  784:          {
    #####:  785:            yr_compiler_set_error_extra_info(
        -:  786:                compiler, "array indexes must be of integer type");
    #####:  787:            result = ERROR_WRONG_TYPE;
        -:  788:          }
        -:  789:
    #####:  790:          fail_if_error(result);
        -:  791:
    #####:  792:          result = yr_parser_emit(
        -:  793:              yyscanner, OP_INDEX_ARRAY, NULL);
        -:  794:
    #####:  795:          array = object_as_array($1.value.object);
        -:  796:
    #####:  797:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  798:          $$.value.object = array->prototype_item;
    #####:  799:          $$.identifier = array->identifier;
        -:  800:        }
    #####:  801:        else if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  802:                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)
        -:  803:        {
    #####:  804:          if ($3.type != EXPRESSION_TYPE_STRING)
        -:  805:          {
    #####:  806:            yr_compiler_set_error_extra_info(
        -:  807:                compiler, "dictionary keys must be of string type");
    #####:  808:            result = ERROR_WRONG_TYPE;
        -:  809:          }
        -:  810:
    #####:  811:          fail_if_error(result);
        -:  812:
    #####:  813:          result = yr_parser_emit(
        -:  814:              yyscanner, OP_LOOKUP_DICT, NULL);
        -:  815:
    #####:  816:          dict = object_as_dictionary($1.value.object);
        -:  817:
    #####:  818:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  819:          $$.value.object = dict->prototype_item;
    #####:  820:          $$.identifier = dict->identifier;
        -:  821:        }
        -:  822:        else
        -:  823:        {
    #####:  824:          yr_compiler_set_error_extra_info(
        -:  825:              compiler, $1.identifier);
        -:  826:
    #####:  827:          result = ERROR_NOT_INDEXABLE;
        -:  828:        }
        -:  829:
    #####:  830:        fail_if_error(result);
        -:  831:      }
        -:  832:
        -:  833:    | identifier '(' arguments ')'
        -:  834:      {
    #####:  835:        int result = ERROR_SUCCESS;
        -:  836:        YR_OBJECT_FUNCTION* function;
        -:  837:        char* args_fmt;
        -:  838:
    #####:  839:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  840:            $1.value.object->type == OBJECT_TYPE_FUNCTION)
        -:  841:        {
    #####:  842:          result = yr_parser_check_types(
    #####:  843:              compiler, object_as_function($1.value.object), $3);
        -:  844:
    #####:  845:          if (result == ERROR_SUCCESS)
    #####:  846:            result = yr_arena_write_string(
    #####:  847:                compiler->sz_arena, $3, &args_fmt);
        -:  848:
    #####:  849:          if (result == ERROR_SUCCESS)
    #####:  850:            result = yr_parser_emit_with_arg_reloc(
        -:  851:                yyscanner,
        -:  852:                OP_CALL,
        -:  853:                args_fmt,
        -:  854:                NULL,
        -:  855:                NULL);
        -:  856:
    #####:  857:          function = object_as_function($1.value.object);
        -:  858:
    #####:  859:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  860:          $$.value.object = function->return_obj;
    #####:  861:          $$.identifier = function->identifier;
        -:  862:        }
        -:  863:        else
        -:  864:        {
    #####:  865:          yr_compiler_set_error_extra_info(
        -:  866:              compiler, $1.identifier);
        -:  867:
    #####:  868:          result = ERROR_NOT_A_FUNCTION;
        -:  869:        }
        -:  870:
    #####:  871:        yr_free($3);
        -:  872:
    #####:  873:        fail_if_error(result);
        -:  874:      }
        -:  875:    ;
        -:  876:
        -:  877:
        -:  878:arguments
    #####:  879:    : /* empty */     { $$ = yr_strdup(""); }
    #####:  880:    | arguments_list  { $$ = $1; }
        -:  881:
        -:  882:
        -:  883:arguments_list
        -:  884:    : expression
        -:  885:      {
    #####:  886:        $$ = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -:  887:
    #####:  888:        if ($$ == NULL)
    #####:  889:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -:  890:
    #####:  891:        switch($1.type)
        -:  892:        {
    #####:  893:          case EXPRESSION_TYPE_INTEGER:
    #####:  894:            strlcpy($$, "i", YR_MAX_FUNCTION_ARGS);
    #####:  895:            break;
    #####:  896:          case EXPRESSION_TYPE_FLOAT:
    #####:  897:            strlcpy($$, "f", YR_MAX_FUNCTION_ARGS);
    #####:  898:            break;
    #####:  899:          case EXPRESSION_TYPE_BOOLEAN:
    #####:  900:            strlcpy($$, "b", YR_MAX_FUNCTION_ARGS);
    #####:  901:            break;
    #####:  902:          case EXPRESSION_TYPE_STRING:
    #####:  903:            strlcpy($$, "s", YR_MAX_FUNCTION_ARGS);
    #####:  904:            break;
    #####:  905:          case EXPRESSION_TYPE_REGEXP:
    #####:  906:            strlcpy($$, "r", YR_MAX_FUNCTION_ARGS);
    #####:  907:            break;
    #####:  908:          default:
    #####:  909:            assert(false);
        -:  910:        }
        -:  911:      }
        -:  912:    | arguments_list ',' expression
        -:  913:      {
    #####:  914:        int result = ERROR_SUCCESS;
        -:  915:
    #####:  916:        if (strlen($1) == YR_MAX_FUNCTION_ARGS)
        -:  917:        {
    #####:  918:          result = ERROR_TOO_MANY_ARGUMENTS;
        -:  919:        }
        -:  920:        else
        -:  921:        {
    #####:  922:          switch($3.type)
        -:  923:          {
    #####:  924:            case EXPRESSION_TYPE_INTEGER:
    #####:  925:              strlcat($1, "i", YR_MAX_FUNCTION_ARGS);
    #####:  926:              break;
    #####:  927:            case EXPRESSION_TYPE_FLOAT:
    #####:  928:              strlcat($1, "f", YR_MAX_FUNCTION_ARGS);
    #####:  929:              break;
    #####:  930:            case EXPRESSION_TYPE_BOOLEAN:
    #####:  931:              strlcat($1, "b", YR_MAX_FUNCTION_ARGS);
    #####:  932:              break;
    #####:  933:            case EXPRESSION_TYPE_STRING:
    #####:  934:              strlcat($1, "s", YR_MAX_FUNCTION_ARGS);
    #####:  935:              break;
    #####:  936:            case EXPRESSION_TYPE_REGEXP:
    #####:  937:              strlcat($1, "r", YR_MAX_FUNCTION_ARGS);
    #####:  938:              break;
    #####:  939:            default:
    #####:  940:              assert(false);
        -:  941:          }
        -:  942:        }
        -:  943:
    #####:  944:        fail_if_error(result);
        -:  945:
    #####:  946:        $$ = $1;
        -:  947:      }
        -:  948:    ;
        -:  949:
        -:  950:
        -:  951:regexp
        -:  952:    : _REGEXP_
        -:  953:      {
    #####:  954:        SIZED_STRING* sized_string = $1;
        -:  955:        RE* re;
        -:  956:        RE_ERROR error;
        -:  957:
    #####:  958:        int result = ERROR_SUCCESS;
    #####:  959:        int re_flags = 0;
        -:  960:
    #####:  961:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  962:          re_flags |= RE_FLAGS_NO_CASE;
        -:  963:
    #####:  964:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####:  965:          re_flags |= RE_FLAGS_DOT_ALL;
        -:  966:
    #####:  967:        result = yr_re_compile(
    #####:  968:            sized_string->c_string,
        -:  969:            re_flags,
        -:  970:            compiler->re_code_arena,
        -:  971:            &re,
        -:  972:            &error);
        -:  973:
    #####:  974:        yr_free($1);
        -:  975:
    #####:  976:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
    #####:  977:          yr_compiler_set_error_extra_info(compiler, error.message);
        -:  978:
    #####:  979:        if (result == ERROR_SUCCESS)
    #####:  980:          result = yr_parser_emit_with_arg_reloc(
        -:  981:              yyscanner,
        -:  982:              OP_PUSH,
        -:  983:              re,
        -:  984:              NULL,
        -:  985:              NULL);
        -:  986:
    #####:  987:        fail_if_error(result);
        -:  988:
    #####:  989:        $$.type = EXPRESSION_TYPE_REGEXP;
        -:  990:      }
        -:  991:    ;
        -:  992:
        -:  993:
        -:  994:boolean_expression
        -:  995:    : expression
        -:  996:      {
      280:  997:        if ($1.type == EXPRESSION_TYPE_STRING)
        -:  998:        {
    #####:  999:          if ($1.value.sized_string != NULL)
        -: 1000:          {
    #####: 1001:            yywarning(yyscanner,
        -: 1002:              "Using literal string \"%s\" in a boolean operation.",
    #####: 1003:              $1.value.sized_string->c_string);
        -: 1004:          }
        -: 1005:
    #####: 1006:          fail_if_error(yr_parser_emit(
        -: 1007:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 1008:        }
        -: 1009:
      280: 1010:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1011:      }
        -: 1012:    ;
        -: 1013:
        -: 1014:expression
        -: 1015:    : _TRUE_
        -: 1016:      {
    #####: 1017:        fail_if_error(yr_parser_emit_with_arg(
        -: 1018:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 1019:
    #####: 1020:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1021:      }
        -: 1022:    | _FALSE_
        -: 1023:      {
    #####: 1024:        fail_if_error(yr_parser_emit_with_arg(
        -: 1025:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 1026:
    #####: 1027:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1028:      }
        -: 1029:    | primary_expression _MATCHES_ regexp
        -: 1030:      {
    #####: 1031:        check_type($1, EXPRESSION_TYPE_STRING, "matches");
    #####: 1032:        check_type($3, EXPRESSION_TYPE_REGEXP, "matches");
        -: 1033:
    #####: 1034:        fail_if_error(yr_parser_emit(
        -: 1035:            yyscanner,
        -: 1036:            OP_MATCHES,
        -: 1037:            NULL));
        -: 1038:
    #####: 1039:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1040:      }
        -: 1041:    | primary_expression _CONTAINS_ primary_expression
        -: 1042:      {
    #####: 1043:        check_type($1, EXPRESSION_TYPE_STRING, "contains");
    #####: 1044:        check_type($3, EXPRESSION_TYPE_STRING, "contains");
        -: 1045:
    #####: 1046:        fail_if_error(yr_parser_emit(
        -: 1047:            yyscanner, OP_CONTAINS, NULL));
        -: 1048:
    #####: 1049:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1050:      }
        -: 1051:    | _STRING_IDENTIFIER_
        -: 1052:      {
      276: 1053:        int result = yr_parser_reduce_string_identifier(
        -: 1054:            yyscanner,
      276: 1055:            $1,
        -: 1056:            OP_FOUND,
        -: 1057:            UNDEFINED);
        -: 1058:
      276: 1059:        yr_free($1);
        -: 1060:
     276*: 1061:        fail_if_error(result);
        -: 1062:
      276: 1063:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1064:      }
        -: 1065:    | _STRING_IDENTIFIER_ _AT_ primary_expression
        -: 1066:      {
        -: 1067:        int result;
        -: 1068:
    #####: 1069:        check_type_with_cleanup($3, EXPRESSION_TYPE_INTEGER, "at", yr_free($1));
        -: 1070:
    #####: 1071:        result = yr_parser_reduce_string_identifier(
    #####: 1072:            yyscanner, $1, OP_FOUND_AT, $3.value.integer);
        -: 1073:
    #####: 1074:        yr_free($1);
        -: 1075:
    #####: 1076:        fail_if_error(result);
        -: 1077:
    #####: 1078:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1079:      }
        -: 1080:    | _STRING_IDENTIFIER_ _IN_ range
        -: 1081:      {
    #####: 1082:        int result = yr_parser_reduce_string_identifier(
    #####: 1083:            yyscanner, $1, OP_FOUND_IN, UNDEFINED);
        -: 1084:
    #####: 1085:        yr_free($1);
        -: 1086:
    #####: 1087:        fail_if_error(result);
        -: 1088:
    #####: 1089:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1090:      }
        -: 1091:    | _FOR_ for_expression error
        -: 1092:      {
    #####: 1093:        if (compiler->loop_depth > 0)
        -: 1094:        {
    #####: 1095:          compiler->loop_depth--;
    #####: 1096:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 1097:        }
        -: 1098:
    #####: 1099:        YYERROR;
        -: 1100:      }
        -: 1101:    | _FOR_ for_expression _IDENTIFIER_ _IN_
        -: 1102:      {
        -: 1103:        // for all i in (N..M) : (<expr>)
        -: 1104:        //
        -: 1105:        // 1       PUSH UNDEF  ; "all"
        -: 1106:        // 2       PUSH UNDEF  ; "end of list"
        -: 1107:        // 3       PUSH N      ; integer range lower bound
        -: 1108:        // 4       PUSH M      ; integer range upper bound
        -: 1109:        // 5       CLEAR_M 1   ; clear <expr> result accumulator
        -: 1110:        // 6       CLEAR_M 2   ; clear loop iteration counter
        -: 1111:        // 7       POP_M 3     ; store range upper bound
        -: 1112:        // 8       POP_M 0     ; store range lower bound
        -: 1113:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 1114:        //      |  <expr>      ; here goes the code for <expr>, its result will
        -: 1115:        //      |                be at the top of the stack
        -: 1116:        // 10   |  SET_M 4     ; store boolean expression result in memory 4
        -: 1117:        // 11   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 1118:        // 12   |  INCR_M 0    ; increment range lower bound (more like current bound)
        -: 1119:        // 13   |  PUSH_M 4    ; boolean expression result
        -: 1120:        // 14 .-+--JFALSE_P    ; jump out of loop if last result is false
        -: 1121:        // 15 | |  PUSH_M 0    ; lower (current) bound
        -: 1122:        // 16 | |  PUSH_M 3    ; upper bound
        -: 1123:        // 17 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 1124:        // 18 `--->POP         ; pop end of list
        -: 1125:        // 19      SWAPUNDEF 2 ; swap the UNDEF ("all") with loop iteration
        -: 1126:        //                       counter (memory 2)
        -: 1127:        // 20      PUSH_M 1    ; push the boolean_expression accumulator
        -: 1128:        // 21      INT_LE      ; compare boolean_expression accumulator to loop
        -: 1129:        //                       iteration counter
        -: 1130:
        -: 1131:        // for X i in (N..M) : (<expr>)
        -: 1132:        //
        -: 1133:        // 1       PUSH X      ;
        -: 1134:        // 2       SET_M 4     ; store primary_expression in m4
        -: 1135:        // 3       PUSH UNDEF  ; "end of list"
        -: 1136:        // 4       PUSH 0      ; integer range lower bound
        -: 1137:        // 5       PUSH 5      ; integer range upper bound
        -: 1138:        // 6       CLEAR_M 1   ; clear <expr> result accumulator
        -: 1139:        // 7       CLEAR_M 2   ; clear loop iteration counter
        -: 1140:        // 8       POP_M 3     ; store upper bound
        -: 1141:        // 9       POP_M 0     ; store lower bound
        -: 1142:        // 10   .->INCR_M 2    ; increment loop iteration counter
        -: 1143:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 1144:        //      |              ; be at the  top of the stack
        -: 1145:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 1146:        // 13   |  INCR_M 0    ; increment lower bound (more like current bound)
        -: 1147:        // 14   |  PUSH_M 4    ; primary expression minimum
        -: 1148:        // 15   |  PUSH_M 1    ; boolean_expression accumulator
        -: 1149:        // 16 .-+--JLE_P       ; jump out of loop if (minimum <= accumulator)
        -: 1150:        // 17 | |  PUSH_M 0    ; lower (current) bound
        -: 1151:        // 18 | |  PUSH_M 3    ; upper bound
        -: 1152:        // 19 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 1153:        // 20 `--->POP         ; pop end of list
        -: 1154:        // 21      SWAPUNDEF 2 ; at this point only our "any" is on the stack,
        -: 1155:        //                       this is effectively a NOP
        -: 1156:        // 22      PUSH_M 1    ; push the boolean_expression accumulator
        -: 1157:        // 23      INT_LE      ; compare boolean_expression accumulator to X
        -: 1158:
        -: 1159:        // for X i in (A, B, C) : (<expr>)
        -: 1160:        //
        -: 1161:        // 1       PUSH X      ;
        -: 1162:        // 2       SET_M 4     ; store primary_expression in m4
        -: 1163:        // 3       PUSH UNDEF  ; "end of list"
        -: 1164:        // 4       PUSH A
        -: 1165:        // 5       PUSH B
        -: 1166:        // 6       PUSH C
        -: 1167:        // 7       CLEAR_M 1   ; clear <expr> result accumulator
        -: 1168:        // 8       CLEAR_M 2   ; clear loop iteration counter
        -: 1169:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 1170:        // 10   |  POP_M 0     ; store current item in M[0]
        -: 1171:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 1172:        //      |              ; be at the  top of the stack
        -: 1173:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 1174:        // 13   `--JNUNDEF     ; if "end of list" was not reached, repeat.
        -: 1175:        // 14      POP         ; pop end of list
        -: 1176:        // 15      SWAPUNDEF 2 ; swap the UNDEF with loop iteration counter M[2]
        -: 1177:        // 16      PUSH_M 1    ; push boolean_expression result accumulator
        -: 1178:        // 17      INT_LE      ; compare boolean_expression accumulator to X
        -: 1179:
        -: 1180:
    #####: 1181:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
    #####: 1182:        int result = ERROR_SUCCESS;
        -: 1183:        int var_index;
        -: 1184:
    #####: 1185:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1186:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1187:
    #####: 1188:        fail_if_error(result);
        -: 1189:
    #####: 1190:        var_index = yr_parser_lookup_loop_variable(
    #####: 1191:            yyscanner, $3);
        -: 1192:
    #####: 1193:        if (var_index >= 0)
        -: 1194:        {
    #####: 1195:          yr_compiler_set_error_extra_info(
        -: 1196:              compiler, $3);
        -: 1197:
    #####: 1198:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 1199:        }
        -: 1200:
    #####: 1201:        fail_if_error(result);
        -: 1202:
        -: 1203:        // "any" loops require us to store the primary expression for
        -: 1204:        // later evaluation, but "all" loops do not. The OP_SWAPUNDEF after the
        -: 1205:        // loop ensures we evaluate the proper values.
    #####: 1206:        if ($2 == FOR_EXPRESSION_ANY)
        -: 1207:        {
    #####: 1208:          yr_parser_emit_with_arg(
    #####: 1209:            yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 1210:        }
        -: 1211:
        -: 1212:        // Push end-of-list marker
    #####: 1213:        result = yr_parser_emit_with_arg(
        -: 1214:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1215:
    #####: 1216:        fail_if_error(result);
        -: 1217:      }
        -: 1218:      integer_set ':'
        -: 1219:      {
    #####: 1220:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1221:        uint8_t* addr;
        -: 1222:
        -: 1223:        // Clear counter for number of expressions evaluating
        -: 1224:        // to true.
    #####: 1225:        yr_parser_emit_with_arg(
    #####: 1226:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1227:
        -: 1228:        // Clear iterations counter
    #####: 1229:        yr_parser_emit_with_arg(
    #####: 1230:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1231:
    #####: 1232:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1233:        {
        -: 1234:          // Increment iterations counter
    #####: 1235:          yr_parser_emit_with_arg(
    #####: 1236:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 1237:
        -: 1238:          // Pop the first integer
    #####: 1239:          yr_parser_emit_with_arg(
        -: 1240:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 1241:        }
        -: 1242:        else // INTEGER_SET_RANGE
        -: 1243:        {
        -: 1244:          // Pop higher bound of set range
    #####: 1245:          yr_parser_emit_with_arg(
    #####: 1246:              yyscanner, OP_POP_M, mem_offset + 3, NULL, NULL);
        -: 1247:
        -: 1248:          // Pop lower bound of set range
    #####: 1249:          yr_parser_emit_with_arg(
        -: 1250:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 1251:
        -: 1252:          // Increment iterations counter
    #####: 1253:          yr_parser_emit_with_arg(
    #####: 1254:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 1255:        }
        -: 1256:
    #####: 1257:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1258:        compiler->loop_identifier[compiler->loop_depth] = $3;
    #####: 1259:        compiler->loop_depth++;
        -: 1260:      }
        -: 1261:      '(' boolean_expression ')'
        -: 1262:      {
        -: 1263:        int mem_offset;
        -: 1264:        YR_FIXUP* fixup;
        -: 1265:        void* jmp_destination_addr;
        -: 1266:        uint8_t* pop_addr;
        -: 1267:
    #####: 1268:        compiler->loop_depth--;
    #####: 1269:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1270:
        -: 1271:        // The value at the top of the stack is the result of
        -: 1272:        // evaluating the boolean expression, so it could be
        -: 1273:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 1274:        // keeping the number of expressions evaluating to true.
        -: 1275:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 1276:        // does nothing.
        -: 1277:
    #####: 1278:        if ($2 == FOR_EXPRESSION_ALL)
        -: 1279:        {
        -: 1280:          // Store the last result for checking after we have incremented the
        -: 1281:          // counters. We want to keep the value on the stack though.
    #####: 1282:          yr_parser_emit_with_arg(
    #####: 1283:              yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 1284:        }
        -: 1285:
    #####: 1286:        yr_parser_emit_with_arg(
    #####: 1287:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1288:
    #####: 1289:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1290:        {
    #####: 1291:          yr_parser_emit_with_arg_reloc(
        -: 1292:              yyscanner,
        -: 1293:              OP_JNUNDEF,
    #####: 1294:              compiler->loop_address[compiler->loop_depth],
        -: 1295:              NULL,
        -: 1296:              NULL);
        -: 1297:
        -: 1298:          // Pop end-of-list marker.
    #####: 1299:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1300:        }
        -: 1301:        else // INTEGER_SET_RANGE
        -: 1302:        {
        -: 1303:          // Increment lower bound of integer set
    #####: 1304:          yr_parser_emit_with_arg(
        -: 1305:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 1306:
        -: 1307:          // Push loop quantifier
    #####: 1308:          yr_parser_emit_with_arg(
    #####: 1309:              yyscanner, OP_PUSH_M, mem_offset + 4, NULL, NULL);
        -: 1310:
    #####: 1311:          if ($2 == FOR_EXPRESSION_ALL)
        -: 1312:          {
    #####: 1313:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1314:                yyscanner,
        -: 1315:                OP_JFALSE_P,
        -: 1316:                0, // Don't know the jump destination yet
        -: 1317:                NULL,
        -: 1318:                &jmp_destination_addr));
        -: 1319:
        -: 1320:            // create a fixup entry for the jump and push it in the stack
    #####: 1321:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1322:
    #####: 1323:            if (fixup == NULL)
    #####: 1324:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1325:
    #####: 1326:            fixup->address = jmp_destination_addr;
    #####: 1327:            fixup->next = compiler->fixup_stack_head;
    #####: 1328:            compiler->fixup_stack_head = fixup;
        -: 1329:          }
    #####: 1330:          else if ($2 == FOR_EXPRESSION_ANY)
        -: 1331:          {
        -: 1332:            // Push the number of expressions evaluating to true
    #####: 1333:            yr_parser_emit_with_arg(
    #####: 1334:                yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1335:
        -: 1336:            // Compare the loop quantifier to number of expressions that evaluate
        -: 1337:            // to true, in order to eliminate extraneous loop iterations.
    #####: 1338:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1339:                yyscanner,
        -: 1340:                OP_JLE_P,
        -: 1341:                0, // Don't know the jump destination yet
        -: 1342:                NULL,
        -: 1343:                &jmp_destination_addr));
        -: 1344:
    #####: 1345:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1346:
    #####: 1347:            if (fixup == NULL)
    #####: 1348:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1349:
    #####: 1350:            fixup->address = jmp_destination_addr;
    #####: 1351:            fixup->next = compiler->fixup_stack_head;
    #####: 1352:            compiler->fixup_stack_head = fixup;
        -: 1353:          }
        -: 1354:
        -: 1355:          // Push lower bound of integer set
    #####: 1356:          yr_parser_emit_with_arg(
        -: 1357:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 1358:
        -: 1359:          // Push higher bound of integer set
    #####: 1360:          yr_parser_emit_with_arg(
    #####: 1361:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 1362:
        -: 1363:          // Compare higher bound with lower bound, do loop again
        -: 1364:          // if lower bound is still lower or equal than higher bound
    #####: 1365:          yr_parser_emit_with_arg_reloc(
        -: 1366:              yyscanner,
        -: 1367:              OP_JLE_P,
    #####: 1368:              compiler->loop_address[compiler->loop_depth],
        -: 1369:              NULL,
        -: 1370:              NULL);
        -: 1371:
        -: 1372:          // Pop end-of-list marker.
    #####: 1373:          yr_parser_emit(yyscanner, OP_POP, &pop_addr);
        -: 1374:
    #####: 1375:          fixup = compiler->fixup_stack_head;
    #####: 1376:          *(void**)(fixup->address) = (void*)(pop_addr);
    #####: 1377:          compiler->fixup_stack_head = fixup->next;
    #####: 1378:          yr_free(fixup);
        -: 1379:        }
        -: 1380:
        -: 1381:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1382:        // is at the top of the stack. Check if the quantifier
        -: 1383:        // is undefined (meaning "all") and replace it with the
        -: 1384:        // iterations counter in that case.
    #####: 1385:        yr_parser_emit_with_arg(
    #####: 1386:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1387:
        -: 1388:        // Compare the loop quantifier with the number of
        -: 1389:        // expressions evaluating to true.
    #####: 1390:        yr_parser_emit_with_arg(
    #####: 1391:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1392:
    #####: 1393:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1394:
    #####: 1395:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1396:        yr_free($3);
        -: 1397:
    #####: 1398:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1399:      }
        -: 1400:    | _FOR_ for_expression _OF_ string_set ':'
        -: 1401:      {
    #####: 1402:        int result = ERROR_SUCCESS;
    #####: 1403:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1404:        uint8_t* addr;
        -: 1405:
    #####: 1406:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1407:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1408:
    #####: 1409:        if (compiler->loop_for_of_mem_offset != -1)
    #####: 1410:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 1411:
    #####: 1412:        fail_if_error(result);
        -: 1413:
    #####: 1414:        yr_parser_emit_with_arg(
    #####: 1415:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1416:
    #####: 1417:        yr_parser_emit_with_arg(
    #####: 1418:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1419:
        -: 1420:        // Pop the first string.
    #####: 1421:        yr_parser_emit_with_arg(
        -: 1422:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 1423:
    #####: 1424:        compiler->loop_for_of_mem_offset = mem_offset;
    #####: 1425:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1426:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1427:        compiler->loop_depth++;
        -: 1428:      }
        -: 1429:      '(' boolean_expression ')'
        -: 1430:      {
        -: 1431:        int mem_offset;
        -: 1432:
    #####: 1433:        compiler->loop_depth--;
    #####: 1434:        compiler->loop_for_of_mem_offset = -1;
        -: 1435:
    #####: 1436:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1437:
        -: 1438:        // Increment counter by the value returned by the
        -: 1439:        // boolean expression (0 or 1). If the boolean expression
        -: 1440:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 1441:
    #####: 1442:        yr_parser_emit_with_arg(
    #####: 1443:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1444:
        -: 1445:        // Increment iterations counter.
    #####: 1446:        yr_parser_emit_with_arg(
    #####: 1447:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 1448:
        -: 1449:        // If next string is not undefined, go back to the
        -: 1450:        // beginning of the loop.
    #####: 1451:        yr_parser_emit_with_arg_reloc(
        -: 1452:            yyscanner,
        -: 1453:            OP_JNUNDEF,
    #####: 1454:            compiler->loop_address[compiler->loop_depth],
        -: 1455:            NULL,
        -: 1456:            NULL);
        -: 1457:
        -: 1458:        // Pop end-of-list marker.
    #####: 1459:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1460:
        -: 1461:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1462:        // is at top of the stack. Check if the quantifier is
        -: 1463:        // undefined (meaning "all") and replace it with the
        -: 1464:        // iterations counter in that case.
    #####: 1465:        yr_parser_emit_with_arg(
    #####: 1466:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1467:
        -: 1468:        // Compare the loop quantifier with the number of
        -: 1469:        // expressions evaluating to true.
    #####: 1470:        yr_parser_emit_with_arg(
    #####: 1471:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1472:
    #####: 1473:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1474:
    #####: 1475:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1476:
        -: 1477:      }
        -: 1478:    | for_expression _OF_ string_set
        -: 1479:      {
    #####: 1480:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 1481:
    #####: 1482:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1483:      }
        -: 1484:    | _NOT_ boolean_expression
        -: 1485:      {
    #####: 1486:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 1487:
    #####: 1488:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1489:      }
        -: 1490:    | boolean_expression _AND_
        -: 1491:      {
        -: 1492:        YR_FIXUP* fixup;
        -: 1493:        void* jmp_destination_addr;
        -: 1494:
    #####: 1495:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1496:            yyscanner,
        -: 1497:            OP_JFALSE,
        -: 1498:            0,          // still don't know the jump destination
        -: 1499:            NULL,
        -: 1500:            &jmp_destination_addr));
        -: 1501:
        -: 1502:        // create a fixup entry for the jump and push it in the stack
    #####: 1503:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1504:
    #####: 1505:        if (fixup == NULL)
    #####: 1506:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1507:
    #####: 1508:        fixup->address = jmp_destination_addr;
    #####: 1509:        fixup->next = compiler->fixup_stack_head;
    #####: 1510:        compiler->fixup_stack_head = fixup;
        -: 1511:      }
        -: 1512:      boolean_expression
        -: 1513:      {
        -: 1514:        YR_FIXUP* fixup;
        -: 1515:        uint8_t* nop_addr;
        -: 1516:
    #####: 1517:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 1518:
        -: 1519:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1520:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1521:        // use the address of the OP_AND instruction +1 because we can't be
        -: 1522:        // sure that the instruction following the OP_AND is going to be in
        -: 1523:        // the same arena page. As we don't have a reliable way of getting the
        -: 1524:        // address of the next instruction we generate the OP_NOP.
        -: 1525:
    #####: 1526:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1527:
    #####: 1528:        fixup = compiler->fixup_stack_head;
    #####: 1529:        *(void**)(fixup->address) = (void*) nop_addr;
    #####: 1530:        compiler->fixup_stack_head = fixup->next;
    #####: 1531:        yr_free(fixup);
        -: 1532:
    #####: 1533:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1534:      }
        -: 1535:    | boolean_expression _OR_
        -: 1536:      {
        -: 1537:        YR_FIXUP* fixup;
        -: 1538:        void* jmp_destination_addr;
        -: 1539:
    #####: 1540:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1541:            yyscanner,
        -: 1542:            OP_JTRUE,
        -: 1543:            0,         // still don't know the jump destination
        -: 1544:            NULL,
        -: 1545:            &jmp_destination_addr));
        -: 1546:
    #####: 1547:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1548:
    #####: 1549:        if (fixup == NULL)
    #####: 1550:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1551:
    #####: 1552:        fixup->address = jmp_destination_addr;
    #####: 1553:        fixup->next = compiler->fixup_stack_head;
    #####: 1554:        compiler->fixup_stack_head = fixup;
        -: 1555:      }
        -: 1556:      boolean_expression
        -: 1557:      {
        -: 1558:        YR_FIXUP* fixup;
        -: 1559:        uint8_t* nop_addr;
        -: 1560:
    #####: 1561:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 1562:
        -: 1563:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1564:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1565:        // use the address of the OP_OR instruction +1 because we can't be
        -: 1566:        // sure that the instruction following the OP_AND is going to be in
        -: 1567:        // the same arena page. As we don't have a reliable way of getting the
        -: 1568:        // address of the next instruction we generate the OP_NOP.
        -: 1569:
    #####: 1570:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1571:
    #####: 1572:        fixup = compiler->fixup_stack_head;
    #####: 1573:        *(void**)(fixup->address) = (void*)(nop_addr);
    #####: 1574:        compiler->fixup_stack_head = fixup->next;
    #####: 1575:        yr_free(fixup);
        -: 1576:
    #####: 1577:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1578:      }
        -: 1579:    | primary_expression _LT_ primary_expression
        -: 1580:      {
    #####: 1581:        fail_if_error(yr_parser_reduce_operation(
        -: 1582:            yyscanner, "<", $1, $3));
        -: 1583:
    #####: 1584:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1585:      }
        -: 1586:    | primary_expression _GT_ primary_expression
        -: 1587:      {
    #####: 1588:        fail_if_error(yr_parser_reduce_operation(
        -: 1589:            yyscanner, ">", $1, $3));
        -: 1590:
    #####: 1591:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1592:      }
        -: 1593:    | primary_expression _LE_ primary_expression
        -: 1594:      {
    #####: 1595:        fail_if_error(yr_parser_reduce_operation(
        -: 1596:            yyscanner, "<=", $1, $3));
        -: 1597:
    #####: 1598:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1599:      }
        -: 1600:    | primary_expression _GE_ primary_expression
        -: 1601:      {
    #####: 1602:        fail_if_error(yr_parser_reduce_operation(
        -: 1603:            yyscanner, ">=", $1, $3));
        -: 1604:
    #####: 1605:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1606:      }
        -: 1607:    | primary_expression _EQ_ primary_expression
        -: 1608:      {
       4*: 1609:        fail_if_error(yr_parser_reduce_operation(
        -: 1610:            yyscanner, "==", $1, $3));
        -: 1611:
        4: 1612:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1613:      }
        -: 1614:    | primary_expression _NEQ_ primary_expression
        -: 1615:      {
    #####: 1616:        fail_if_error(yr_parser_reduce_operation(
        -: 1617:            yyscanner, "!=", $1, $3));
        -: 1618:
    #####: 1619:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1620:      }
        -: 1621:    | primary_expression
        -: 1622:      {
    #####: 1623:        $$ = $1;
        -: 1624:      }
        -: 1625:    |'(' expression ')'
        -: 1626:      {
    #####: 1627:        $$ = $2;
        -: 1628:      }
        -: 1629:    ;
        -: 1630:
        -: 1631:
        -: 1632:integer_set
    #####: 1633:    : '(' integer_enumeration ')'  { $$ = INTEGER_SET_ENUMERATION; }
    #####: 1634:    | range                        { $$ = INTEGER_SET_RANGE; }
        -: 1635:    ;
        -: 1636:
        -: 1637:
        -: 1638:range
        -: 1639:    : '(' primary_expression _DOT_DOT_  primary_expression ')'
        -: 1640:      {
    #####: 1641:        int result = ERROR_SUCCESS;
        -: 1642:
    #####: 1643:        if ($2.type != EXPRESSION_TYPE_INTEGER)
        -: 1644:        {
    #####: 1645:          yr_compiler_set_error_extra_info(
        -: 1646:              compiler, "wrong type for range's lower bound");
    #####: 1647:          result = ERROR_WRONG_TYPE;
        -: 1648:        }
        -: 1649:
    #####: 1650:        if ($4.type != EXPRESSION_TYPE_INTEGER)
        -: 1651:        {
    #####: 1652:          yr_compiler_set_error_extra_info(
        -: 1653:              compiler, "wrong type for range's upper bound");
    #####: 1654:          result = ERROR_WRONG_TYPE;
        -: 1655:        }
        -: 1656:
    #####: 1657:        fail_if_error(result);
        -: 1658:      }
        -: 1659:    ;
        -: 1660:
        -: 1661:
        -: 1662:integer_enumeration
        -: 1663:    : primary_expression
        -: 1664:      {
    #####: 1665:        int result = ERROR_SUCCESS;
        -: 1666:
    #####: 1667:        if ($1.type != EXPRESSION_TYPE_INTEGER)
        -: 1668:        {
    #####: 1669:          yr_compiler_set_error_extra_info(
        -: 1670:              compiler, "wrong type for enumeration item");
    #####: 1671:          result = ERROR_WRONG_TYPE;
        -: 1672:        }
        -: 1673:
    #####: 1674:        fail_if_error(result);
        -: 1675:      }
        -: 1676:    | integer_enumeration ',' primary_expression
        -: 1677:      {
    #####: 1678:        int result = ERROR_SUCCESS;
        -: 1679:
    #####: 1680:        if ($3.type != EXPRESSION_TYPE_INTEGER)
        -: 1681:        {
    #####: 1682:          yr_compiler_set_error_extra_info(
        -: 1683:              compiler, "wrong type for enumeration item");
    #####: 1684:          result = ERROR_WRONG_TYPE;
        -: 1685:        }
        -: 1686:
    #####: 1687:        fail_if_error(result);
        -: 1688:      }
        -: 1689:    ;
        -: 1690:
        -: 1691:
        -: 1692:string_set
        -: 1693:    : '('
        -: 1694:      {
        -: 1695:        // Push end-of-list marker
    #####: 1696:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1697:      }
        -: 1698:      string_enumeration ')'
        -: 1699:    | _THEM_
        -: 1700:      {
    #####: 1701:        fail_if_error(yr_parser_emit_with_arg(
        -: 1702:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 1703:
    #####: 1704:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 1705:            yyscanner, "$*"));
        -: 1706:      }
        -: 1707:    ;
        -: 1708:
        -: 1709:
        -: 1710:string_enumeration
        -: 1711:    : string_enumeration_item
        -: 1712:    | string_enumeration ',' string_enumeration_item
        -: 1713:    ;
        -: 1714:
        -: 1715:
        -: 1716:string_enumeration_item
        -: 1717:    : _STRING_IDENTIFIER_
        -: 1718:      {
    #####: 1719:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1720:        yr_free($1);
        -: 1721:
    #####: 1722:        fail_if_error(result);
        -: 1723:      }
        -: 1724:    | _STRING_IDENTIFIER_WITH_WILDCARD_
        -: 1725:      {
    #####: 1726:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1727:        yr_free($1);
        -: 1728:
    #####: 1729:        fail_if_error(result);
        -: 1730:      }
        -: 1731:    ;
        -: 1732:
        -: 1733:
        -: 1734:for_expression
        -: 1735:    : primary_expression
        -: 1736:      {
    #####: 1737:        $$ = FOR_EXPRESSION_ANY;
        -: 1738:      }
        -: 1739:    | _ALL_
        -: 1740:      {
    #####: 1741:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
    #####: 1742:        $$ = FOR_EXPRESSION_ALL;
        -: 1743:      }
        -: 1744:    | _ANY_
        -: 1745:      {
    #####: 1746:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
    #####: 1747:        $$ = FOR_EXPRESSION_ANY;
        -: 1748:      }
        -: 1749:    ;
        -: 1750:
        -: 1751:
        -: 1752:primary_expression
        -: 1753:    : '(' primary_expression ')'
        -: 1754:      {
    #####: 1755:        $$ = $2;
        -: 1756:      }
        -: 1757:    | _FILESIZE_
        -: 1758:      {
    #####: 1759:        fail_if_error(yr_parser_emit(
        -: 1760:            yyscanner, OP_FILESIZE, NULL));
        -: 1761:
    #####: 1762:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1763:        $$.value.integer = UNDEFINED;
        -: 1764:      }
        -: 1765:    | _ENTRYPOINT_
        -: 1766:      {
    #####: 1767:        yywarning(yyscanner,
        -: 1768:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 1769:            "function from PE module instead.");
        -: 1770:
    #####: 1771:        fail_if_error(yr_parser_emit(
        -: 1772:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 1773:
    #####: 1774:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1775:        $$.value.integer = UNDEFINED;
        -: 1776:      }
        -: 1777:    | _INTEGER_FUNCTION_ '(' primary_expression ')'
        -: 1778:      {
    #####: 1779:        check_type($3, EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 1780:
        -: 1781:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 1782:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 1783:        // in the proper OP_INTXX opcode.
        -: 1784:
    #####: 1785:        fail_if_error(yr_parser_emit(
        -: 1786:            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL));
        -: 1787:
    #####: 1788:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1789:        $$.value.integer = UNDEFINED;
        -: 1790:      }
        -: 1791:    | _NUMBER_
        -: 1792:      {
       4*: 1793:        fail_if_error(yr_parser_emit_with_arg(
        -: 1794:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1795:
        4: 1796:        $$.type = EXPRESSION_TYPE_INTEGER;
        4: 1797:        $$.value.integer = $1;
        -: 1798:      }
        -: 1799:    | _DOUBLE_
        -: 1800:      {
    #####: 1801:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 1802:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1803:
    #####: 1804:        $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1805:      }
        -: 1806:    | _TEXT_STRING_
        -: 1807:      {
        -: 1808:        SIZED_STRING* sized_string;
        -: 1809:
    #####: 1810:        int result = yr_arena_write_data(
        -: 1811:            compiler->sz_arena,
    #####: 1812:            $1,
    #####: 1813:            $1->length + sizeof(SIZED_STRING),
        -: 1814:            (void**) &sized_string);
        -: 1815:
    #####: 1816:        yr_free($1);
        -: 1817:
    #####: 1818:        if (result == ERROR_SUCCESS)
    #####: 1819:          result = yr_parser_emit_with_arg_reloc(
        -: 1820:              yyscanner,
        -: 1821:              OP_PUSH,
        -: 1822:              sized_string,
        -: 1823:              NULL,
        -: 1824:              NULL);
        -: 1825:
    #####: 1826:        fail_if_error(result);
        -: 1827:
    #####: 1828:        $$.type = EXPRESSION_TYPE_STRING;
    #####: 1829:        $$.value.sized_string = sized_string;
        -: 1830:      }
        -: 1831:    | _STRING_COUNT_
        -: 1832:      {
    #####: 1833:        int result = yr_parser_reduce_string_identifier(
    #####: 1834:            yyscanner, $1, OP_COUNT, UNDEFINED);
        -: 1835:
    #####: 1836:        yr_free($1);
        -: 1837:
    #####: 1838:        fail_if_error(result);
        -: 1839:
    #####: 1840:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1841:        $$.value.integer = UNDEFINED;
        -: 1842:      }
        -: 1843:    | _STRING_OFFSET_ '[' primary_expression ']'
        -: 1844:      {
    #####: 1845:        int result = yr_parser_reduce_string_identifier(
    #####: 1846:            yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1847:
    #####: 1848:        yr_free($1);
        -: 1849:
    #####: 1850:        fail_if_error(result);
        -: 1851:
    #####: 1852:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1853:        $$.value.integer = UNDEFINED;
        -: 1854:      }
        -: 1855:    | _STRING_OFFSET_
        -: 1856:      {
    #####: 1857:        int result = yr_parser_emit_with_arg(
        -: 1858:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1859:
    #####: 1860:        if (result == ERROR_SUCCESS)
    #####: 1861:          result = yr_parser_reduce_string_identifier(
    #####: 1862:              yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1863:
    #####: 1864:        yr_free($1);
        -: 1865:
    #####: 1866:        fail_if_error(result);
        -: 1867:
    #####: 1868:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1869:        $$.value.integer = UNDEFINED;
        -: 1870:      }
        -: 1871:    | _STRING_LENGTH_ '[' primary_expression ']'
        -: 1872:      {
    #####: 1873:        int result = yr_parser_reduce_string_identifier(
    #####: 1874:            yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1875:
    #####: 1876:        yr_free($1);
        -: 1877:
    #####: 1878:        fail_if_error(result);
        -: 1879:
    #####: 1880:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1881:        $$.value.integer = UNDEFINED;
        -: 1882:      }
        -: 1883:    | _STRING_LENGTH_
        -: 1884:      {
        4: 1885:        int result = yr_parser_emit_with_arg(
        -: 1886:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1887:
        4: 1888:        if (result == ERROR_SUCCESS)
        4: 1889:          result = yr_parser_reduce_string_identifier(
        4: 1890:              yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1891:
        4: 1892:        yr_free($1);
        -: 1893:
       4*: 1894:        fail_if_error(result);
        -: 1895:
        4: 1896:        $$.type = EXPRESSION_TYPE_INTEGER;
        4: 1897:        $$.value.integer = UNDEFINED;
        -: 1898:      }
        -: 1899:    | identifier
        -: 1900:      {
    #####: 1901:        int result = ERROR_SUCCESS;
        -: 1902:
    #####: 1903:        if ($1.type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 1904:        {
    #####: 1905:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1906:          $$.value.integer = UNDEFINED;
        -: 1907:        }
    #####: 1908:        else if ($1.type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 1909:        {
    #####: 1910:          $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####: 1911:          $$.value.integer = UNDEFINED;
        -: 1912:        }
    #####: 1913:        else if ($1.type == EXPRESSION_TYPE_OBJECT)
        -: 1914:        {
    #####: 1915:          result = yr_parser_emit(
        -: 1916:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 1917:
    #####: 1918:          switch($1.value.object->type)
        -: 1919:          {
    #####: 1920:            case OBJECT_TYPE_INTEGER:
    #####: 1921:              $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1922:              $$.value.integer = UNDEFINED;
    #####: 1923:              break;
    #####: 1924:            case OBJECT_TYPE_FLOAT:
    #####: 1925:              $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1926:              break;
    #####: 1927:            case OBJECT_TYPE_STRING:
    #####: 1928:              $$.type = EXPRESSION_TYPE_STRING;
    #####: 1929:              $$.value.sized_string = NULL;
    #####: 1930:              break;
    #####: 1931:            default:
    #####: 1932:              yr_compiler_set_error_extra_info_fmt(
        -: 1933:                  compiler,
        -: 1934:                  "wrong usage of identifier \"%s\"",
        -: 1935:                  $1.identifier);
    #####: 1936:              result = ERROR_WRONG_TYPE;
        -: 1937:          }
        -: 1938:        }
        -: 1939:        else
        -: 1940:        {
    #####: 1941:          assert(false);
        -: 1942:        }
        -: 1943:
    #####: 1944:        fail_if_error(result);
        -: 1945:      }
        -: 1946:    | '-' primary_expression %prec UNARY_MINUS
        -: 1947:      {
    #####: 1948:        int result = ERROR_SUCCESS;
        -: 1949:
    #####: 1950:        check_type($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 1951:
    #####: 1952:        if ($2.type == EXPRESSION_TYPE_INTEGER)
        -: 1953:        {
    #####: 1954:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1955:          $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 1956:              UNDEFINED : -($2.value.integer);
    #####: 1957:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 1958:        }
    #####: 1959:        else if ($2.type == EXPRESSION_TYPE_FLOAT)
        -: 1960:        {
    #####: 1961:          $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1962:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 1963:        }
        -: 1964:
    #####: 1965:        fail_if_error(result);
        -: 1966:      }
        -: 1967:    | primary_expression '+' primary_expression
        -: 1968:      {
    #####: 1969:        int result = yr_parser_reduce_operation(
    #####: 1970:            yyscanner, "+", $1, $3);
        -: 1971:
    #####: 1972:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1973:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1974:        {
    #####: 1975:          int64_t i1 = $1.value.integer;
    #####: 1976:          int64_t i2 = $3.value.integer;
        -: 1977:
    #####: 1978:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1979:              (
    #####: 1980:                (i2 > 0 && i1 > INT64_MAX - i2) ||
    #####: 1981:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 1982:              ))
        -: 1983:          {
    #####: 1984:            yr_compiler_set_error_extra_info_fmt(
        -: 1985:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 1986:
    #####: 1987:            result = ERROR_INTEGER_OVERFLOW;
        -: 1988:          }
        -: 1989:          else
        -: 1990:          {
    #####: 1991:            $$.value.integer = OPERATION(+, i1, i2);
    #####: 1992:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1993:          }
        -: 1994:        }
        -: 1995:        else
        -: 1996:        {
    #####: 1997:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1998:        }
        -: 1999:
    #####: 2000:        fail_if_error(result);
        -: 2001:      }
        -: 2002:    | primary_expression '-' primary_expression
        -: 2003:      {
    #####: 2004:        int result = yr_parser_reduce_operation(
    #####: 2005:            yyscanner, "-", $1, $3);
        -: 2006:
    #####: 2007:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2008:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 2009:        {
    #####: 2010:          int64_t i1 = $1.value.integer;
    #####: 2011:          int64_t i2 = $3.value.integer;
        -: 2012:
    #####: 2013:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 2014:              (
    #####: 2015:                (i2 < 0 && i1 > INT64_MAX + i2) ||
    #####: 2016:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 2017:              ))
        -: 2018:          {
    #####: 2019:            yr_compiler_set_error_extra_info_fmt(
        -: 2020:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 2021:
    #####: 2022:            result = ERROR_INTEGER_OVERFLOW;
        -: 2023:          }
        -: 2024:          else
        -: 2025:          {
    #####: 2026:            $$.value.integer = OPERATION(-, i1, i2);
    #####: 2027:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2028:          }
        -: 2029:        }
        -: 2030:        else
        -: 2031:        {
    #####: 2032:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2033:        }
        -: 2034:
    #####: 2035:        fail_if_error(result);
        -: 2036:      }
        -: 2037:    | primary_expression '*' primary_expression
        -: 2038:      {
    #####: 2039:        int result = yr_parser_reduce_operation(
    #####: 2040:            yyscanner, "*", $1, $3);
        -: 2041:
    #####: 2042:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2043:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 2044:        {
    #####: 2045:          int64_t i1 = $1.value.integer;
    #####: 2046:          int64_t i2 = $3.value.integer;
        -: 2047:
    #####: 2048:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 2049:              (
    #####: 2050:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 2051:              ))
        -: 2052:          {
    #####: 2053:            yr_compiler_set_error_extra_info_fmt(
        -: 2054:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 2055:
    #####: 2056:            result = ERROR_INTEGER_OVERFLOW;
        -: 2057:          }
        -: 2058:          else
        -: 2059:          {
    #####: 2060:            $$.value.integer = OPERATION(*, i1, i2);
    #####: 2061:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2062:          }
        -: 2063:        }
        -: 2064:        else
        -: 2065:        {
    #####: 2066:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2067:        }
        -: 2068:
    #####: 2069:        fail_if_error(result);
        -: 2070:      }
        -: 2071:    | primary_expression '\\' primary_expression
        -: 2072:      {
    #####: 2073:        int result = yr_parser_reduce_operation(
    #####: 2074:            yyscanner, "\\", $1, $3);
        -: 2075:
    #####: 2076:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2077:            $3.type == EXPRESSION_TYPE_INTEGER)
        -: 2078:        {
    #####: 2079:          if ($3.value.integer != 0)
        -: 2080:          {
    #####: 2081:            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);
    #####: 2082:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2083:          }
        -: 2084:          else
        -: 2085:          {
    #####: 2086:            result = ERROR_DIVISION_BY_ZERO;
        -: 2087:          }
        -: 2088:        }
        -: 2089:        else
        -: 2090:        {
    #####: 2091:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2092:        }
        -: 2093:
    #####: 2094:        fail_if_error(result);
        -: 2095:      }
        -: 2096:    | primary_expression '%' primary_expression
        -: 2097:      {
    #####: 2098:        check_type($1, EXPRESSION_TYPE_INTEGER, "%");
    #####: 2099:        check_type($3, EXPRESSION_TYPE_INTEGER, "%");
        -: 2100:
    #####: 2101:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 2102:
    #####: 2103:        if ($3.value.integer != 0)
        -: 2104:        {
    #####: 2105:          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);
    #####: 2106:          $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2107:        }
        -: 2108:        else
        -: 2109:        {
    #####: 2110:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 2111:        }
        -: 2112:      }
        -: 2113:    | primary_expression '^' primary_expression
        -: 2114:      {
    #####: 2115:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 2116:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 2117:
    #####: 2118:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 2119:
    #####: 2120:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2121:        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);
        -: 2122:      }
        -: 2123:    | primary_expression '&' primary_expression
        -: 2124:      {
    #####: 2125:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 2126:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 2127:
    #####: 2128:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 2129:
    #####: 2130:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2131:        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);
        -: 2132:      }
        -: 2133:    | primary_expression '|' primary_expression
        -: 2134:      {
    #####: 2135:        check_type($1, EXPRESSION_TYPE_INTEGER, "|");
    #####: 2136:        check_type($3, EXPRESSION_TYPE_INTEGER, "|");
        -: 2137:
    #####: 2138:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 2139:
    #####: 2140:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2141:        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);
        -: 2142:      }
        -: 2143:    | '~' primary_expression
        -: 2144:      {
    #####: 2145:        check_type($2, EXPRESSION_TYPE_INTEGER, "~");
        -: 2146:
    #####: 2147:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 2148:
    #####: 2149:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2150:        $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 2151:            UNDEFINED : ~($2.value.integer);
        -: 2152:      }
        -: 2153:    | primary_expression _SHIFT_LEFT_ primary_expression
        -: 2154:      {
        -: 2155:        int result;
        -: 2156:
    #####: 2157:        check_type($1, EXPRESSION_TYPE_INTEGER, "<<");
    #####: 2158:        check_type($3, EXPRESSION_TYPE_INTEGER, "<<");
        -: 2159:
    #####: 2160:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 2161:
    #####: 2162:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 2163:          result = ERROR_INVALID_OPERAND;
    #####: 2164:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 2165:          $$.value.integer = 0;
        -: 2166:        else
    #####: 2167:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 2168:
    #####: 2169:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2170:
    #####: 2171:        fail_if_error(result);
        -: 2172:      }
        -: 2173:    | primary_expression _SHIFT_RIGHT_ primary_expression
        -: 2174:      {
        -: 2175:        int result;
        -: 2176:
    #####: 2177:        check_type($1, EXPRESSION_TYPE_INTEGER, ">>");
    #####: 2178:        check_type($3, EXPRESSION_TYPE_INTEGER, ">>");
        -: 2179:
    #####: 2180:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 2181:
    #####: 2182:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 2183:          result = ERROR_INVALID_OPERAND;
    #####: 2184:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 2185:          $$.value.integer = 0;
        -: 2186:        else
    #####: 2187:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 2188:
    #####: 2189:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2190:
    #####: 2191:        fail_if_error(result);
        -: 2192:      }
        -: 2193:    | regexp
        -: 2194:      {
    #####: 2195:        $$ = $1;
        -: 2196:      }
        -: 2197:    ;
        -: 2198:
        -: 2199:%%
