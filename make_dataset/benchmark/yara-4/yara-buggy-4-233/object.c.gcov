        -:    0:Source:object.c
        -:    0:Graph:/home/workspace/libyara/object.gcno
        -:    0:Data:/home/workspace/libyara/object.gcda
        -:    0:Runs:9
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:
        -:   31:#include <assert.h>
        -:   32:#include <ctype.h>
        -:   33:#include <stdarg.h>
        -:   34:#include <stdio.h>
        -:   35:#include <stdlib.h>
        -:   36:#include <string.h>
        -:   37:#include <math.h>
        -:   38:
        -:   39:#include <yara/globals.h>
        -:   40:#include <yara/mem.h>
        -:   41:#include <yara/error.h>
        -:   42:#include <yara/object.h>
        -:   43:#include <yara/exec.h>
        -:   44:#include <yara/utils.h>
        -:   45:
        -:   46:
    #####:   47:int yr_object_create(
        -:   48:    int8_t type,
        -:   49:    const char* identifier,
        -:   50:    YR_OBJECT* parent,
        -:   51:    YR_OBJECT** object)
        -:   52:{
        -:   53:  YR_OBJECT* obj;
        -:   54:  int i;
    #####:   55:  size_t object_size = 0;
        -:   56:
    #####:   57:  assert(parent != NULL || object != NULL);
        -:   58:
    #####:   59:  switch (type)
        -:   60:  {
    #####:   61:    case OBJECT_TYPE_STRUCTURE:
    #####:   62:      object_size = sizeof(YR_OBJECT_STRUCTURE);
    #####:   63:      break;
    #####:   64:    case OBJECT_TYPE_ARRAY:
    #####:   65:      object_size = sizeof(YR_OBJECT_ARRAY);
    #####:   66:      break;
    #####:   67:    case OBJECT_TYPE_DICTIONARY:
    #####:   68:      object_size = sizeof(YR_OBJECT_DICTIONARY);
    #####:   69:      break;
    #####:   70:    case OBJECT_TYPE_INTEGER:
    #####:   71:      object_size = sizeof(YR_OBJECT);
    #####:   72:      break;
    #####:   73:    case OBJECT_TYPE_FLOAT:
    #####:   74:      object_size = sizeof(YR_OBJECT);
    #####:   75:      break;
    #####:   76:    case OBJECT_TYPE_STRING:
    #####:   77:      object_size = sizeof(YR_OBJECT);
    #####:   78:      break;
    #####:   79:    case OBJECT_TYPE_FUNCTION:
    #####:   80:      object_size = sizeof(YR_OBJECT_FUNCTION);
    #####:   81:      break;
    #####:   82:    default:
    #####:   83:      assert(false);
        -:   84:  }
        -:   85:
    #####:   86:  obj = (YR_OBJECT*) yr_malloc(object_size);
        -:   87:
    #####:   88:  if (obj == NULL)
    #####:   89:    return ERROR_INSUFFICIENT_MEMORY;
        -:   90:
    #####:   91:  obj->type = type;
    #####:   92:  obj->identifier = yr_strdup(identifier);
    #####:   93:  obj->parent = parent;
    #####:   94:  obj->data = NULL;
        -:   95:
    #####:   96:  switch(type)
        -:   97:  {
    #####:   98:    case OBJECT_TYPE_INTEGER:
    #####:   99:      obj->value.i = UNDEFINED;
    #####:  100:      break;
    #####:  101:    case OBJECT_TYPE_FLOAT:
    #####:  102:      obj->value.d = NAN;
    #####:  103:      break;
    #####:  104:    case OBJECT_TYPE_STRING:
    #####:  105:      obj->value.ss = NULL;
    #####:  106:      break;
    #####:  107:    case OBJECT_TYPE_STRUCTURE:
    #####:  108:      object_as_structure(obj)->members = NULL;
    #####:  109:      break;
    #####:  110:    case OBJECT_TYPE_ARRAY:
    #####:  111:      object_as_array(obj)->items = NULL;
    #####:  112:      object_as_array(obj)->prototype_item = NULL;
    #####:  113:      break;
    #####:  114:    case OBJECT_TYPE_DICTIONARY:
    #####:  115:      object_as_dictionary(obj)->items = NULL;
    #####:  116:      object_as_dictionary(obj)->prototype_item = NULL;
    #####:  117:      break;
    #####:  118:    case OBJECT_TYPE_FUNCTION:
    #####:  119:      object_as_function(obj)->return_obj = NULL;
    #####:  120:      for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  121:      {
    #####:  122:        object_as_function(obj)->prototypes[i].arguments_fmt = NULL;
    #####:  123:        object_as_function(obj)->prototypes[i].code = NULL;
        -:  124:      }
    #####:  125:      break;
        -:  126:  }
        -:  127:
    #####:  128:  if (obj->identifier == NULL)
        -:  129:  {
    #####:  130:    yr_free(obj);
    #####:  131:    return ERROR_INSUFFICIENT_MEMORY;
        -:  132:  }
        -:  133:
    #####:  134:  if (parent != NULL)
        -:  135:  {
    #####:  136:    assert(parent->type == OBJECT_TYPE_STRUCTURE ||
        -:  137:           parent->type == OBJECT_TYPE_ARRAY ||
        -:  138:           parent->type == OBJECT_TYPE_DICTIONARY ||
        -:  139:           parent->type == OBJECT_TYPE_FUNCTION);
        -:  140:
        -:  141:    // Objects with a parent take the canary from it.
    #####:  142:    obj->canary = parent->canary;
        -:  143:
    #####:  144:    switch(parent->type)
        -:  145:    {
    #####:  146:      case OBJECT_TYPE_STRUCTURE:
    #####:  147:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  148:            yr_object_structure_set_member(parent, obj),
        -:  149:            {
        -:  150:              yr_free((void*) obj->identifier);
        -:  151:              yr_free(obj);
        -:  152:            });
    #####:  153:        break;
        -:  154:
    #####:  155:      case OBJECT_TYPE_ARRAY:
    #####:  156:        object_as_array(parent)->prototype_item = obj;
    #####:  157:        break;
        -:  158:
    #####:  159:      case OBJECT_TYPE_DICTIONARY:
    #####:  160:        object_as_dictionary(parent)->prototype_item = obj;
    #####:  161:        break;
        -:  162:
    #####:  163:      case OBJECT_TYPE_FUNCTION:
    #####:  164:        object_as_function(parent)->return_obj = obj;
    #####:  165:        break;
        -:  166:    }
    #####:  167:  }
        -:  168:
    #####:  169:  if (object != NULL)
    #####:  170:    *object = obj;
        -:  171:
    #####:  172:  return ERROR_SUCCESS;
        -:  173:}
        -:  174:
        -:  175:
    #####:  176:void yr_object_set_canary(
        -:  177:    YR_OBJECT* object,
        -:  178:    int canary)
        -:  179:{
    #####:  180:  object->canary = canary;
    #####:  181:}
        -:  182:
        -:  183:
    #####:  184:int yr_object_function_create(
        -:  185:    const char* identifier,
        -:  186:    const char* arguments_fmt,
        -:  187:    const char* return_fmt,
        -:  188:    YR_MODULE_FUNC code,
        -:  189:    YR_OBJECT* parent,
        -:  190:    YR_OBJECT** function)
        -:  191:{
        -:  192:  YR_OBJECT* return_obj;
    #####:  193:  YR_OBJECT* o = NULL;
    #####:  194:  YR_OBJECT_FUNCTION* f = NULL;
        -:  195:
        -:  196:  int8_t return_type;
        -:  197:  int i;
        -:  198:
        -:  199:  // The parent of a function must be a structure.
    #####:  200:  assert(parent != NULL && parent->type == OBJECT_TYPE_STRUCTURE);
        -:  201:
    #####:  202:  switch (*return_fmt)
        -:  203:  {
    #####:  204:    case 'i':
    #####:  205:      return_type = OBJECT_TYPE_INTEGER;
    #####:  206:      break;
    #####:  207:    case 's':
    #####:  208:      return_type = OBJECT_TYPE_STRING;
    #####:  209:      break;
    #####:  210:    case 'f':
    #####:  211:      return_type = OBJECT_TYPE_FLOAT;
    #####:  212:      break;
    #####:  213:    default:
    #####:  214:      return ERROR_INVALID_FORMAT;
        -:  215:  }
        -:  216:
        -:  217:  // Try to find if the structure already has a function
        -:  218:  // with that name. In that case this is a function overload.
    #####:  219:  f = object_as_function(yr_object_lookup_field(parent, identifier));
        -:  220:
        -:  221:  // Overloaded functions must have the same return type.
    #####:  222:  if (f != NULL && return_type != f->return_obj->type)
    #####:  223:    return ERROR_WRONG_RETURN_TYPE;
        -:  224:
    #####:  225:  if (f == NULL) // Function doesn't exist yet
        -:  226:  {
    #####:  227:    FAIL_ON_ERROR(
        -:  228:        yr_object_create(
        -:  229:            OBJECT_TYPE_FUNCTION,
        -:  230:            identifier,
        -:  231:            parent,
        -:  232:            &o));
        -:  233:
    #####:  234:    FAIL_ON_ERROR_WITH_CLEANUP(
        -:  235:        yr_object_create(
        -:  236:            return_type,
        -:  237:            "result",
        -:  238:            o,
        -:  239:            &return_obj),
        -:  240:        yr_object_destroy(o));
        -:  241:
    #####:  242:    f = object_as_function(o);
        -:  243:  }
        -:  244:
    #####:  245:  for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  246:  {
    #####:  247:    if (f->prototypes[i].arguments_fmt == NULL)
        -:  248:    {
    #####:  249:      f->prototypes[i].arguments_fmt = arguments_fmt;
    #####:  250:      f->prototypes[i].code = code;
        -:  251:
    #####:  252:      break;
        -:  253:    }
        -:  254:  }
        -:  255:
    #####:  256:  if (function != NULL)
    #####:  257:    *function = (YR_OBJECT*) f;
        -:  258:
    #####:  259:  return ERROR_SUCCESS;
        -:  260:}
        -:  261:
        -:  262:
    #####:  263:int yr_object_from_external_variable(
        -:  264:    YR_EXTERNAL_VARIABLE* external,
        -:  265:    YR_OBJECT** object)
        -:  266:{
        -:  267:  YR_OBJECT* obj;
        -:  268:  int result;
    #####:  269:  uint8_t obj_type = 0;
        -:  270:
    #####:  271:  switch(external->type)
        -:  272:  {
    #####:  273:    case EXTERNAL_VARIABLE_TYPE_INTEGER:
        -:  274:    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:
    #####:  275:      obj_type = OBJECT_TYPE_INTEGER;
    #####:  276:      break;
        -:  277:
    #####:  278:    case EXTERNAL_VARIABLE_TYPE_FLOAT:
    #####:  279:      obj_type = OBJECT_TYPE_FLOAT;
    #####:  280:      break;
        -:  281:
    #####:  282:    case EXTERNAL_VARIABLE_TYPE_STRING:
        -:  283:    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:
    #####:  284:      obj_type = OBJECT_TYPE_STRING;
    #####:  285:      break;
        -:  286:
    #####:  287:    default:
    #####:  288:      assert(false);
        -:  289:  }
        -:  290:
    #####:  291:  result = yr_object_create(
        -:  292:      obj_type,
        -:  293:      external->identifier,
        -:  294:      NULL,
        -:  295:      &obj);
        -:  296:
    #####:  297:  if (result == ERROR_SUCCESS)
        -:  298:  {
    #####:  299:    switch(external->type)
        -:  300:    {
    #####:  301:      case EXTERNAL_VARIABLE_TYPE_INTEGER:
        -:  302:      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:
    #####:  303:        result = yr_object_set_integer(external->value.i, obj, NULL);
    #####:  304:        break;
        -:  305:
    #####:  306:      case EXTERNAL_VARIABLE_TYPE_FLOAT:
    #####:  307:        result = yr_object_set_float(external->value.f, obj, NULL);
    #####:  308:        break;
        -:  309:
    #####:  310:      case EXTERNAL_VARIABLE_TYPE_STRING:
        -:  311:      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:
    #####:  312:        result = yr_object_set_string(
    #####:  313:            external->value.s, strlen(external->value.s), obj, NULL);
    #####:  314:        break;
        -:  315:    }
        -:  316:
    #####:  317:    *object = obj;
        -:  318:  }
        -:  319:
    #####:  320:  return result;
        -:  321:}
        -:  322:
        -:  323:
    #####:  324:void yr_object_destroy(
        -:  325:    YR_OBJECT* object)
        -:  326:{
        -:  327:  YR_STRUCTURE_MEMBER* member;
        -:  328:  YR_STRUCTURE_MEMBER* next_member;
        -:  329:  YR_ARRAY_ITEMS* array_items;
        -:  330:  YR_DICTIONARY_ITEMS* dict_items;
        -:  331:
        -:  332:  int i;
        -:  333:
    #####:  334:  if (object == NULL)
    #####:  335:    return;
        -:  336:
    #####:  337:  switch(object->type)
        -:  338:  {
    #####:  339:    case OBJECT_TYPE_STRUCTURE:
    #####:  340:      member = object_as_structure(object)->members;
        -:  341:
    #####:  342:      while (member != NULL)
        -:  343:      {
    #####:  344:        next_member = member->next;
    #####:  345:        yr_object_destroy(member->object);
    #####:  346:        yr_free(member);
    #####:  347:        member = next_member;
        -:  348:      }
    #####:  349:      break;
        -:  350:
    #####:  351:    case OBJECT_TYPE_STRING:
    #####:  352:      if (object->value.ss != NULL)
    #####:  353:        yr_free(object->value.ss);
    #####:  354:      break;
        -:  355:
    #####:  356:    case OBJECT_TYPE_ARRAY:
    #####:  357:      if (object_as_array(object)->prototype_item != NULL)
    #####:  358:        yr_object_destroy(object_as_array(object)->prototype_item);
        -:  359:
    #####:  360:      array_items = object_as_array(object)->items;
        -:  361:
    #####:  362:      if (array_items != NULL)
        -:  363:      {
    #####:  364:        for (i = 0; i < array_items->count; i++)
    #####:  365:          if (array_items->objects[i] != NULL)
    #####:  366:            yr_object_destroy(array_items->objects[i]);
        -:  367:      }
        -:  368:
    #####:  369:      yr_free(array_items);
    #####:  370:      break;
        -:  371:
    #####:  372:    case OBJECT_TYPE_DICTIONARY:
    #####:  373:      if (object_as_dictionary(object)->prototype_item != NULL)
    #####:  374:        yr_object_destroy(object_as_dictionary(object)->prototype_item);
        -:  375:
    #####:  376:      dict_items = object_as_dictionary(object)->items;
        -:  377:
    #####:  378:      if (dict_items != NULL)
        -:  379:      {
    #####:  380:        for (i = 0; i < dict_items->used; i++)
        -:  381:        {
    #####:  382:          if (dict_items->objects[i].key != NULL)
    #####:  383:            yr_free(dict_items->objects[i].key);
        -:  384:
    #####:  385:          if (dict_items->objects[i].obj != NULL)
    #####:  386:            yr_object_destroy(dict_items->objects[i].obj);
        -:  387:        }
        -:  388:      }
        -:  389:
    #####:  390:      yr_free(dict_items);
    #####:  391:      break;
        -:  392:
    #####:  393:    case OBJECT_TYPE_FUNCTION:
    #####:  394:      yr_object_destroy(object_as_function(object)->return_obj);
    #####:  395:      break;
        -:  396:  }
        -:  397:
    #####:  398:  yr_free((void*) object->identifier);
    #####:  399:  yr_free(object);
        -:  400:}
        -:  401:
        -:  402:
    #####:  403:YR_OBJECT* yr_object_lookup_field(
        -:  404:    YR_OBJECT* object,
        -:  405:    const char* field_name)
        -:  406:{
        -:  407:  YR_STRUCTURE_MEMBER* member;
        -:  408:
    #####:  409:  assert(object != NULL);
    #####:  410:  assert(object->type == OBJECT_TYPE_STRUCTURE);
        -:  411:
    #####:  412:  member = object_as_structure(object)->members;
        -:  413:
    #####:  414:  while (member != NULL)
        -:  415:  {
    #####:  416:    if (strcmp(member->object->identifier, field_name) == 0)
    #####:  417:      return member->object;
        -:  418:
    #####:  419:    member = member->next;
        -:  420:  }
        -:  421:
    #####:  422:  return NULL;
        -:  423:}
        -:  424:
        -:  425:
    #####:  426:static YR_OBJECT* _yr_object_lookup(
        -:  427:    YR_OBJECT* object,
        -:  428:    int flags,
        -:  429:    const char* pattern,
        -:  430:    va_list args)
        -:  431:{
    #####:  432:  YR_OBJECT* obj = object;
        -:  433:
    #####:  434:  const char* p = pattern;
    #####:  435:  const char* key = NULL;
        -:  436:
        -:  437:  char str[256];
        -:  438:
        -:  439:  int i;
    #####:  440:  int index = -1;
        -:  441:
    #####:  442:  while (obj != NULL)
        -:  443:  {
    #####:  444:    i = 0;
        -:  445:
    #####:  446:    while (*p != '\0' && *p != '.' && *p != '[' && i < sizeof(str) - 1)
        -:  447:    {
    #####:  448:      str[i++] = *p++;
        -:  449:    }
        -:  450:
    #####:  451:    str[i] = '\0';
        -:  452:
    #####:  453:    if (obj->type != OBJECT_TYPE_STRUCTURE)
    #####:  454:      return NULL;
        -:  455:
    #####:  456:    obj = yr_object_lookup_field(obj, str);
        -:  457:
    #####:  458:    if (obj == NULL)
    #####:  459:      return NULL;
        -:  460:
    #####:  461:    if (*p == '[')
        -:  462:    {
    #####:  463:      p++;
        -:  464:
    #####:  465:      if (*p == '%')
        -:  466:      {
    #####:  467:        p++;
        -:  468:
    #####:  469:        switch(*p++)
        -:  470:        {
    #####:  471:          case 'i':
    #####:  472:            index = va_arg(args, int);
    #####:  473:            break;
    #####:  474:          case 's':
    #####:  475:            key = va_arg(args, const char*);
    #####:  476:            break;
        -:  477:
    #####:  478:          default:
    #####:  479:            return NULL;
        -:  480:        }
        -:  481:      }
    #####:  482:      else if (*p >= '0' && *p <= '9')
        -:  483:      {
    #####:  484:        index = (int) strtol(p, (char**) &p, 10);
        -:  485:      }
    #####:  486:      else if (*p == '"')
        -:  487:      {
    #####:  488:        i = 0;
    #####:  489:        p++;              // skip the opening quotation mark
        -:  490:
    #####:  491:        while (*p != '"' && *p != '\0' && i < sizeof(str) - 1)
    #####:  492:          str[i++] = *p++;
        -:  493:
    #####:  494:        str[i] = '\0';
    #####:  495:        p++;              // skip the closing quotation mark
    #####:  496:        key = str;
        -:  497:      }
        -:  498:      else
        -:  499:      {
    #####:  500:        return NULL;
        -:  501:      }
        -:  502:
    #####:  503:      assert(*p == ']');
    #####:  504:      p++;
    #####:  505:      assert(*p == '.' || *p == '\0');
        -:  506:
    #####:  507:      switch(obj->type)
        -:  508:      {
    #####:  509:        case OBJECT_TYPE_ARRAY:
    #####:  510:          assert(index != -1);
    #####:  511:          obj = yr_object_array_get_item(obj, flags, index);
    #####:  512:          break;
        -:  513:
    #####:  514:        case OBJECT_TYPE_DICTIONARY:
    #####:  515:          assert(key != NULL);
    #####:  516:          obj = yr_object_dict_get_item(obj, flags, key);
    #####:  517:          break;
        -:  518:      }
    #####:  519:    }
        -:  520:
    #####:  521:    if (*p == '\0')
    #####:  522:      break;
        -:  523:
    #####:  524:    p++;
        -:  525:  }
        -:  526:
    #####:  527:  return obj;
        -:  528:}
        -:  529:
        -:  530:
    #####:  531:YR_OBJECT* yr_object_lookup(
        -:  532:    YR_OBJECT* object,
        -:  533:    int flags,
        -:  534:    const char* pattern,
        -:  535:    ...)
        -:  536:{
        -:  537:  YR_OBJECT* result;
        -:  538:
        -:  539:  va_list args;
    #####:  540:  va_start(args, pattern);
        -:  541:
    #####:  542:  result = _yr_object_lookup(object, flags, pattern, args);
        -:  543:
    #####:  544:  va_end(args);
        -:  545:
    #####:  546:  return result;
        -:  547:
        -:  548:}
        -:  549:
        -:  550:
    #####:  551:int yr_object_copy(
        -:  552:    YR_OBJECT* object,
        -:  553:    YR_OBJECT** object_copy)
        -:  554:{
        -:  555:  YR_OBJECT* copy;
        -:  556:  YR_OBJECT* o;
        -:  557:
        -:  558:  YR_STRUCTURE_MEMBER* structure_member;
        -:  559:
        -:  560:  int i;
        -:  561:
    #####:  562:  *object_copy = NULL;
        -:  563:
    #####:  564:  FAIL_ON_ERROR(yr_object_create(
        -:  565:      object->type,
        -:  566:      object->identifier,
        -:  567:      NULL,
        -:  568:      &copy));
        -:  569:
    #####:  570:  copy->canary = object->canary;
        -:  571:
    #####:  572:  switch(object->type)
        -:  573:  {
    #####:  574:    case OBJECT_TYPE_INTEGER:
    #####:  575:      copy->value.i = object->value.i;
    #####:  576:      break;
        -:  577:
    #####:  578:    case OBJECT_TYPE_FLOAT:
    #####:  579:      copy->value.d = object->value.d;
    #####:  580:      break;
        -:  581:
    #####:  582:    case OBJECT_TYPE_STRING:
        -:  583:
    #####:  584:      if (object->value.ss != NULL)
    #####:  585:        copy->value.ss = sized_string_dup(object->value.ss);
        -:  586:      else
    #####:  587:        copy->value.ss = NULL;
        -:  588:
    #####:  589:      break;
        -:  590:
    #####:  591:    case OBJECT_TYPE_FUNCTION:
        -:  592:
    #####:  593:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  594:          yr_object_copy(
        -:  595:              object_as_function(object)->return_obj,
        -:  596:              &object_as_function(copy)->return_obj),
        -:  597:          yr_object_destroy(copy));
        -:  598:
    #####:  599:      for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
    #####:  600:        object_as_function(copy)->prototypes[i] = \
        -:  601:            object_as_function(object)->prototypes[i];
        -:  602:
    #####:  603:      break;
        -:  604:
    #####:  605:    case OBJECT_TYPE_STRUCTURE:
        -:  606:
    #####:  607:      structure_member = object_as_structure(object)->members;
        -:  608:
    #####:  609:      while (structure_member != NULL)
        -:  610:      {
    #####:  611:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  612:            yr_object_copy(structure_member->object, &o),
        -:  613:            yr_object_destroy(copy));
        -:  614:
    #####:  615:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  616:            yr_object_structure_set_member(copy, o),
        -:  617:            yr_free(o);
        -:  618:            yr_object_destroy(copy));
        -:  619:
    #####:  620:        structure_member = structure_member->next;
        -:  621:      }
        -:  622:
    #####:  623:      break;
        -:  624:
    #####:  625:    case OBJECT_TYPE_ARRAY:
        -:  626:
    #####:  627:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  628:          yr_object_copy(object_as_array(object)->prototype_item, &o),
        -:  629:          yr_object_destroy(copy));
        -:  630:
    #####:  631:      object_as_array(copy)->prototype_item = o;
        -:  632:
    #####:  633:      break;
        -:  634:
    #####:  635:    case OBJECT_TYPE_DICTIONARY:
        -:  636:
    #####:  637:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  638:          yr_object_copy(object_as_dictionary(object)->prototype_item, &o),
        -:  639:          yr_object_destroy(copy));
        -:  640:
    #####:  641:      object_as_dictionary(copy)->prototype_item = o;
        -:  642:
    #####:  643:      break;
        -:  644:
    #####:  645:    default:
    #####:  646:      assert(false);
        -:  647:
        -:  648:  }
        -:  649:
    #####:  650:  *object_copy = copy;
        -:  651:
    #####:  652:  return ERROR_SUCCESS;
        -:  653:}
        -:  654:
        -:  655:
    #####:  656:int yr_object_structure_set_member(
        -:  657:    YR_OBJECT* object,
        -:  658:    YR_OBJECT* member)
        -:  659:{
        -:  660:  YR_STRUCTURE_MEMBER* sm;
        -:  661:
    #####:  662:  assert(object->type == OBJECT_TYPE_STRUCTURE);
        -:  663:
        -:  664:  // Check if the object already have a member with the same identifier
        -:  665:
    #####:  666:  if (yr_object_lookup_field(object,  member->identifier) != NULL)
    #####:  667:    return ERROR_DUPLICATED_STRUCTURE_MEMBER;
        -:  668:
    #####:  669:  sm = (YR_STRUCTURE_MEMBER*) yr_malloc(sizeof(YR_STRUCTURE_MEMBER));
        -:  670:
    #####:  671:  if (sm == NULL)
    #####:  672:    return ERROR_INSUFFICIENT_MEMORY;
        -:  673:
    #####:  674:  member->parent = object;
    #####:  675:  sm->object = member;
    #####:  676:  sm->next = object_as_structure(object)->members;
        -:  677:
    #####:  678:  object_as_structure(object)->members = sm;
        -:  679:
    #####:  680:  return ERROR_SUCCESS;
        -:  681:}
        -:  682:
        -:  683:
    #####:  684:YR_OBJECT* yr_object_array_get_item(
        -:  685:    YR_OBJECT* object,
        -:  686:    int flags,
        -:  687:    int index)
        -:  688:{
    #####:  689:  YR_OBJECT* result = NULL;
        -:  690:  YR_OBJECT_ARRAY* array;
        -:  691:
    #####:  692:  assert(object->type == OBJECT_TYPE_ARRAY);
        -:  693:
    #####:  694:  if (index < 0)
    #####:  695:    return NULL;
        -:  696:
    #####:  697:  array = object_as_array(object);
        -:  698:
    #####:  699:  if (array->items != NULL && array->items->count > index)
    #####:  700:      result = array->items->objects[index];
        -:  701:
    #####:  702:  if (result == NULL && flags & OBJECT_CREATE)
        -:  703:  {
    #####:  704:    yr_object_copy(array->prototype_item, &result);
        -:  705:
    #####:  706:    if (result != NULL)
    #####:  707:      yr_object_array_set_item(object, result, index);
        -:  708:  }
        -:  709:
    #####:  710:  return result;
        -:  711:}
        -:  712:
        -:  713:
    #####:  714:int yr_object_array_set_item(
        -:  715:    YR_OBJECT* object,
        -:  716:    YR_OBJECT* item,
        -:  717:    int index)
        -:  718:{
        -:  719:  YR_OBJECT_ARRAY* array;
        -:  720:
        -:  721:  int i;
        -:  722:  int count;
        -:  723:
    #####:  724:  assert(index >= 0);
    #####:  725:  assert(object->type == OBJECT_TYPE_ARRAY);
        -:  726:
    #####:  727:  array = object_as_array(object);
        -:  728:
    #####:  729:  if (array->items == NULL)
        -:  730:  {
    #####:  731:    count = 64;
        -:  732:
    #####:  733:    while (count <= index)
    #####:  734:      count *= 2;
        -:  735:
    #####:  736:    array->items = (YR_ARRAY_ITEMS*) yr_malloc(
    #####:  737:        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
        -:  738:
    #####:  739:    if (array->items == NULL)
    #####:  740:      return ERROR_INSUFFICIENT_MEMORY;
        -:  741:
    #####:  742:    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));
        -:  743:
    #####:  744:    array->items->count = count;
        -:  745:  }
    #####:  746:  else if (index >= array->items->count)
        -:  747:  {
    #####:  748:    count = array->items->count * 2;
        -:  749:
    #####:  750:    while (count <= index)
    #####:  751:      count *= 2;
        -:  752:
    #####:  753:    array->items = (YR_ARRAY_ITEMS*) yr_realloc(
    #####:  754:        array->items,
    #####:  755:        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
        -:  756:
    #####:  757:    if (array->items == NULL)
    #####:  758:      return ERROR_INSUFFICIENT_MEMORY;
        -:  759:
    #####:  760:    for (i = array->items->count; i < count; i++)
    #####:  761:      array->items->objects[i] = NULL;
        -:  762:
    #####:  763:    array->items->count = count;
        -:  764:  }
        -:  765:
    #####:  766:  item->parent = object;
    #####:  767:  array->items->objects[index] = item;
        -:  768:
    #####:  769:  return ERROR_SUCCESS;
        -:  770:}
        -:  771:
        -:  772:
    #####:  773:YR_OBJECT* yr_object_dict_get_item(
        -:  774:    YR_OBJECT* object,
        -:  775:    int flags,
        -:  776:    const char* key)
        -:  777:{
        -:  778:  int i;
        -:  779:
    #####:  780:  YR_OBJECT* result = NULL;
        -:  781:  YR_OBJECT_DICTIONARY* dict;
        -:  782:
    #####:  783:  assert(object->type == OBJECT_TYPE_DICTIONARY);
        -:  784:
    #####:  785:  dict = object_as_dictionary(object);
        -:  786:
    #####:  787:  if (dict->items != NULL)
        -:  788:  {
    #####:  789:    for (i = 0; i < dict->items->used; i++)
        -:  790:    {
    #####:  791:      if (strcmp(dict->items->objects[i].key, key) == 0)
    #####:  792:        result = dict->items->objects[i].obj;
        -:  793:    }
        -:  794:  }
        -:  795:
    #####:  796:  if (result == NULL && flags & OBJECT_CREATE)
        -:  797:  {
    #####:  798:    yr_object_copy(dict->prototype_item, &result);
        -:  799:
    #####:  800:    if (result != NULL)
    #####:  801:      yr_object_dict_set_item(object, result, key);
        -:  802:  }
        -:  803:
    #####:  804:  return result;
        -:  805:}
        -:  806:
        -:  807:
    #####:  808:int yr_object_dict_set_item(
        -:  809:    YR_OBJECT* object,
        -:  810:    YR_OBJECT* item,
        -:  811:    const char* key)
        -:  812:{
        -:  813:  YR_OBJECT_DICTIONARY* dict;
        -:  814:
        -:  815:  int i;
        -:  816:  int count;
        -:  817:
    #####:  818:  assert(object->type == OBJECT_TYPE_DICTIONARY);
        -:  819:
    #####:  820:  dict = object_as_dictionary(object);
        -:  821:
    #####:  822:  if (dict->items == NULL)
        -:  823:  {
    #####:  824:    count = 64;
        -:  825:
    #####:  826:    dict->items = (YR_DICTIONARY_ITEMS*) yr_malloc(
    #####:  827:        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));
        -:  828:
    #####:  829:    if (dict->items == NULL)
    #####:  830:      return ERROR_INSUFFICIENT_MEMORY;
        -:  831:
    #####:  832:    memset(dict->items->objects, 0, count * sizeof(dict->items->objects[0]));
        -:  833:
    #####:  834:    dict->items->free = count;
    #####:  835:    dict->items->used = 0;
        -:  836:  }
    #####:  837:  else if (dict->items->free == 0)
        -:  838:  {
    #####:  839:    count = dict->items->used * 2;
    #####:  840:    dict->items = (YR_DICTIONARY_ITEMS*) yr_realloc(
    #####:  841:        dict->items,
    #####:  842:        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));
        -:  843:
    #####:  844:    if (dict->items == NULL)
    #####:  845:      return ERROR_INSUFFICIENT_MEMORY;
        -:  846:
    #####:  847:    for (i = dict->items->used; i < count; i++)
        -:  848:    {
    #####:  849:      dict->items->objects[i].key = NULL;
    #####:  850:      dict->items->objects[i].obj = NULL;
        -:  851:    }
        -:  852:
    #####:  853:    dict->items->free = dict->items->used;
        -:  854:  }
        -:  855:
    #####:  856:  item->parent = object;
        -:  857:
    #####:  858:  dict->items->objects[dict->items->used].key = yr_strdup(key);
    #####:  859:  dict->items->objects[dict->items->used].obj = item;
        -:  860:
    #####:  861:  dict->items->used++;
    #####:  862:  dict->items->free--;
        -:  863:
    #####:  864:  return ERROR_SUCCESS;
        -:  865:}
        -:  866:
        -:  867:
    #####:  868:bool yr_object_has_undefined_value(
        -:  869:    YR_OBJECT* object,
        -:  870:    const char* field,
        -:  871:    ...)
        -:  872:{
        -:  873:  YR_OBJECT* field_obj;
        -:  874:
        -:  875:  va_list args;
    #####:  876:  va_start(args, field);
        -:  877:
    #####:  878:  if (field != NULL)
    #####:  879:    field_obj = _yr_object_lookup(object, 0, field, args);
        -:  880:  else
    #####:  881:    field_obj = object;
        -:  882:
    #####:  883:  va_end(args);
        -:  884:
    #####:  885:  if (field_obj == NULL)
    #####:  886:    return true;
        -:  887:
    #####:  888:  switch(field_obj->type)
        -:  889:  {
    #####:  890:    case OBJECT_TYPE_FLOAT:
    #####:  891:      return isnan(field_obj->value.d);
    #####:  892:    case OBJECT_TYPE_STRING:
    #####:  893:      return field_obj->value.ss == NULL;
    #####:  894:    case OBJECT_TYPE_INTEGER:
    #####:  895:      return field_obj->value.i == UNDEFINED;
        -:  896:  }
        -:  897:
    #####:  898:  return false;
        -:  899:}
        -:  900:
        -:  901:
    #####:  902:int64_t yr_object_get_integer(
        -:  903:    YR_OBJECT* object,
        -:  904:    const char* field,
        -:  905:    ...)
        -:  906:{
        -:  907:  YR_OBJECT* integer_obj;
        -:  908:
        -:  909:  va_list args;
    #####:  910:  va_start(args, field);
        -:  911:
    #####:  912:  if (field != NULL)
    #####:  913:    integer_obj = _yr_object_lookup(object, 0, field, args);
        -:  914:  else
    #####:  915:    integer_obj = object;
        -:  916:
    #####:  917:  va_end(args);
        -:  918:
    #####:  919:  if (integer_obj == NULL)
    #####:  920:    return UNDEFINED;
        -:  921:
    #####:  922:  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,
        -:  923:          "type of \"%s\" is not integer\n", field);
        -:  924:
    #####:  925:  return integer_obj->value.i;
        -:  926:}
        -:  927:
        -:  928:
    #####:  929:double yr_object_get_float(
        -:  930:    YR_OBJECT* object,
        -:  931:    const char* field,
        -:  932:    ...)
        -:  933:{
        -:  934:  YR_OBJECT* double_obj;
        -:  935:
        -:  936:  va_list args;
    #####:  937:  va_start(args, field);
        -:  938:
    #####:  939:  if (field != NULL)
    #####:  940:    double_obj = _yr_object_lookup(object, 0, field, args);
        -:  941:  else
    #####:  942:    double_obj = object;
        -:  943:
    #####:  944:  va_end(args);
        -:  945:
    #####:  946:  if (double_obj == NULL)
    #####:  947:    return NAN;
        -:  948:
    #####:  949:  assertf(double_obj->type == OBJECT_TYPE_FLOAT,
        -:  950:          "type of \"%s\" is not double\n", field);
        -:  951:
    #####:  952:  return double_obj->value.d;
        -:  953:}
        -:  954:
        -:  955:
    #####:  956:SIZED_STRING* yr_object_get_string(
        -:  957:    YR_OBJECT* object,
        -:  958:    const char* field,
        -:  959:    ...)
        -:  960:{
        -:  961:  YR_OBJECT* string_obj;
        -:  962:
        -:  963:  va_list args;
    #####:  964:  va_start(args, field);
        -:  965:
    #####:  966:  if (field != NULL)
    #####:  967:    string_obj = _yr_object_lookup(object, 0, field, args);
        -:  968:  else
    #####:  969:    string_obj = object;
        -:  970:
    #####:  971:  va_end(args);
        -:  972:
    #####:  973:  if (string_obj == NULL)
    #####:  974:    return NULL;
        -:  975:
    #####:  976:  assertf(string_obj->type == OBJECT_TYPE_STRING,
        -:  977:          "type of \"%s\" is not string\n", field);
        -:  978:
    #####:  979:  return string_obj->value.ss;
        -:  980:}
        -:  981:
        -:  982:
    #####:  983:int yr_object_set_integer(
        -:  984:    int64_t value,
        -:  985:    YR_OBJECT* object,
        -:  986:    const char* field,
        -:  987:    ...)
        -:  988:{
        -:  989:  YR_OBJECT* integer_obj;
        -:  990:
        -:  991:  va_list args;
    #####:  992:  va_start(args, field);
        -:  993:
    #####:  994:  if (field != NULL)
    #####:  995:    integer_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -:  996:  else
    #####:  997:    integer_obj = object;
        -:  998:
    #####:  999:  va_end(args);
        -: 1000:
    #####: 1001:  if (integer_obj == NULL)
        -: 1002:  {
    #####: 1003:    if (field != NULL)
    #####: 1004:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1005:    else
    #####: 1006:      return ERROR_INVALID_ARGUMENT;
        -: 1007:  }
        -: 1008:
    #####: 1009:  assert(integer_obj->type == OBJECT_TYPE_INTEGER);
        -: 1010:
    #####: 1011:  integer_obj->value.i = value;
        -: 1012:
    #####: 1013:  return ERROR_SUCCESS;
        -: 1014:}
        -: 1015:
        -: 1016:
    #####: 1017:int yr_object_set_float(
        -: 1018:    double value,
        -: 1019:    YR_OBJECT* object,
        -: 1020:    const char* field,
        -: 1021:    ...)
        -: 1022:{
        -: 1023:  YR_OBJECT* double_obj;
        -: 1024:
        -: 1025:  va_list args;
    #####: 1026:  va_start(args, field);
        -: 1027:
    #####: 1028:  if (field != NULL)
    #####: 1029:    double_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -: 1030:  else
    #####: 1031:    double_obj = object;
        -: 1032:
    #####: 1033:  va_end(args);
        -: 1034:
    #####: 1035:  if (double_obj == NULL)
        -: 1036:  {
    #####: 1037:    if (field != NULL)
    #####: 1038:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1039:    else
    #####: 1040:      return ERROR_INVALID_ARGUMENT;
        -: 1041:  }
        -: 1042:
    #####: 1043:  assert(double_obj->type == OBJECT_TYPE_FLOAT);
        -: 1044:
    #####: 1045:  double_obj->value.d = value;
        -: 1046:
    #####: 1047:  return ERROR_SUCCESS;
        -: 1048:}
        -: 1049:
        -: 1050:
    #####: 1051:int yr_object_set_string(
        -: 1052:    const char* value,
        -: 1053:    size_t len,
        -: 1054:    YR_OBJECT* object,
        -: 1055:    const char* field,
        -: 1056:    ...)
        -: 1057:{
        -: 1058:  YR_OBJECT* string_obj;
        -: 1059:
        -: 1060:  va_list args;
    #####: 1061:  va_start(args, field);
        -: 1062:
    #####: 1063:  if (field != NULL)
    #####: 1064:    string_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -: 1065:  else
    #####: 1066:    string_obj = object;
        -: 1067:
    #####: 1068:  va_end(args);
        -: 1069:
    #####: 1070:  if (string_obj == NULL)
        -: 1071:  {
    #####: 1072:    if (field != NULL)
    #####: 1073:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1074:    else
    #####: 1075:      return ERROR_INVALID_ARGUMENT;
        -: 1076:  }
        -: 1077:
    #####: 1078:  assert(string_obj->type == OBJECT_TYPE_STRING);
        -: 1079:
    #####: 1080:  if (string_obj->value.ss != NULL)
    #####: 1081:    yr_free(string_obj->value.ss);
        -: 1082:
    #####: 1083:  if (value != NULL)
        -: 1084:  {
    #####: 1085:    string_obj->value.ss = (SIZED_STRING*) yr_malloc(
        -: 1086:        len + sizeof(SIZED_STRING));
        -: 1087:
    #####: 1088:    if (string_obj->value.ss == NULL)
    #####: 1089:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1090:
    #####: 1091:    string_obj->value.ss->length = (uint32_t) len;
    #####: 1092:    string_obj->value.ss->flags = 0;
        -: 1093:
    #####: 1094:    memcpy(string_obj->value.ss->c_string, value, len);
    #####: 1095:    string_obj->value.ss->c_string[len] = '\0';
        -: 1096:  }
        -: 1097:  else
        -: 1098:  {
    #####: 1099:    string_obj->value.ss = NULL;
        -: 1100:  }
        -: 1101:
    #####: 1102:  return ERROR_SUCCESS;
        -: 1103:}
        -: 1104:
        -: 1105:
    #####: 1106:YR_OBJECT* yr_object_get_root(
        -: 1107:    YR_OBJECT* object)
        -: 1108:{
    #####: 1109:  YR_OBJECT* o = object;
        -: 1110:
    #####: 1111:  while (o->parent != NULL)
    #####: 1112:    o = o->parent;
        -: 1113:
    #####: 1114:  return o;
        -: 1115:}
        -: 1116:
    #####: 1117:YR_API void yr_object_print_data(
        -: 1118:    YR_OBJECT* object,
        -: 1119:    int indent,
        -: 1120:    int print_identifier)
        -: 1121:{
        -: 1122:  YR_DICTIONARY_ITEMS* dict_items;
        -: 1123:  YR_ARRAY_ITEMS* array_items;
        -: 1124:  YR_STRUCTURE_MEMBER* member;
        -: 1125:
        -: 1126:  char indent_spaces[32];
        -: 1127:  int i;
        -: 1128:
    #####: 1129:  indent = yr_min(indent, sizeof(indent_spaces) - 1);
        -: 1130:
    #####: 1131:  memset(indent_spaces, '\t', indent);
    #####: 1132:  indent_spaces[indent] = '\0';
        -: 1133:
    #####: 1134:  if (print_identifier && object->type != OBJECT_TYPE_FUNCTION)
    #####: 1135:    printf("%s%s", indent_spaces, object->identifier);
        -: 1136:
    #####: 1137:  switch(object->type)
        -: 1138:  {
    #####: 1139:    case OBJECT_TYPE_INTEGER:
        -: 1140:
    #####: 1141:      if (object->value.i != UNDEFINED)
    #####: 1142:        printf(" = %" PRId64, object->value.i);
        -: 1143:      else
    #####: 1144:        printf(" = UNDEFINED");
        -: 1145:
    #####: 1146:      break;
        -: 1147:
    #####: 1148:    case OBJECT_TYPE_STRING:
        -: 1149:
    #####: 1150:      if (object->value.ss != NULL)
        -: 1151:      {
        -: 1152:        size_t l;
    #####: 1153:        printf(" = \"");
        -: 1154:
    #####: 1155:        for (l = 0; l < object->value.ss->length; l++)
        -: 1156:        {
    #####: 1157:          char c = object->value.ss->c_string[l];
        -: 1158:
    #####: 1159:          if (isprint((unsigned char) c))
    #####: 1160:            printf("%c", c);
        -: 1161:          else
    #####: 1162:            printf("\\x%02x", (unsigned char) c);
        -: 1163:        }
        -: 1164:
    #####: 1165:        printf("\"");
        -: 1166:      }
        -: 1167:      else
        -: 1168:      {
    #####: 1169:        printf(" = UNDEFINED");
        -: 1170:      }
        -: 1171:
    #####: 1172:      break;
        -: 1173:
    #####: 1174:    case OBJECT_TYPE_STRUCTURE:
        -: 1175:
    #####: 1176:      member = object_as_structure(object)->members;
        -: 1177:
    #####: 1178:      while (member != NULL)
        -: 1179:      {
    #####: 1180:        if (member->object->type != OBJECT_TYPE_FUNCTION)
        -: 1181:        {
    #####: 1182:          printf("\n");
    #####: 1183:          yr_object_print_data(member->object, indent + 1, 1);
        -: 1184:        }
    #####: 1185:        member = member->next;
        -: 1186:      }
        -: 1187:
    #####: 1188:      break;
        -: 1189:
    #####: 1190:    case OBJECT_TYPE_ARRAY:
        -: 1191:
    #####: 1192:      array_items = object_as_array(object)->items;
        -: 1193:
    #####: 1194:      if (array_items != NULL)
        -: 1195:      {
    #####: 1196:        for (i = 0; i < array_items->count; i++)
        -: 1197:        {
    #####: 1198:          if (array_items->objects[i] != NULL)
        -: 1199:          {
    #####: 1200:            printf("\n%s\t[%d]", indent_spaces, i);
    #####: 1201:            yr_object_print_data(array_items->objects[i], indent + 1, 0);
        -: 1202:          }
        -: 1203:        }
        -: 1204:      }
        -: 1205:
    #####: 1206:      break;
        -: 1207:
    #####: 1208:    case OBJECT_TYPE_DICTIONARY:
        -: 1209:
    #####: 1210:      dict_items = object_as_dictionary(object)->items;
        -: 1211:
    #####: 1212:      if (dict_items != NULL)
        -: 1213:      {
    #####: 1214:        for (i = 0; i < dict_items->used; i++)
        -: 1215:        {
    #####: 1216:          printf("\n%s\t%s", indent_spaces, dict_items->objects[i].key);
    #####: 1217:          yr_object_print_data(dict_items->objects[i].obj, indent + 1, 0);
        -: 1218:        }
        -: 1219:      }
        -: 1220:
    #####: 1221:      break;
        -: 1222:  }
    #####: 1223:}
