        -:    0:Source:modules/pe.c
        -:    0:Graph:/home/workspace/libyara/modules/pe.gcno
        -:    0:Data:/home/workspace/libyara/modules/pe.gcda
        -:    0:Runs:9
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <stdio.h>
        -:   33:#include <ctype.h>
        -:   34:#include <time.h>
        -:   35:
        -:   36:#include "../crypto.h"
        -:   37:#if defined(HAVE_LIBCRYPTO)
        -:   38:#include <openssl/safestack.h>
        -:   39:#include <openssl/asn1.h>
        -:   40:#include <openssl/bio.h>
        -:   41:#include <openssl/pkcs7.h>
        -:   42:#include <openssl/x509.h>
        -:   43:#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
        -:   44:#define X509_get_signature_nid(o) OBJ_obj2nid((o)->sig_alg->algorithm)
        -:   45:#define X509_getm_notBefore X509_get_notBefore
        -:   46:#define X509_getm_notAfter X509_get_notAfter
        -:   47:#endif
        -:   48:#endif
        -:   49:
        -:   50:#include <yara/endian.h>
        -:   51:#include <yara/pe.h>
        -:   52:#include <yara/modules.h>
        -:   53:#include <yara/mem.h>
        -:   54:#include <yara/strutils.h>
        -:   55:#include <yara/utils.h>
        -:   56:
        -:   57:
        -:   58:#include <yara/pe_utils.h>
        -:   59:
        -:   60:#define MODULE_NAME pe
        -:   61:
        -:   62:// http://msdn.microsoft.com/en-us/library/ms648009(v=vs.85).aspx
        -:   63:#define RESOURCE_TYPE_CURSOR       1
        -:   64:#define RESOURCE_TYPE_BITMAP       2
        -:   65:#define RESOURCE_TYPE_ICON         3
        -:   66:#define RESOURCE_TYPE_MENU         4
        -:   67:#define RESOURCE_TYPE_DIALOG       5
        -:   68:#define RESOURCE_TYPE_STRING       6
        -:   69:#define RESOURCE_TYPE_FONTDIR      7
        -:   70:#define RESOURCE_TYPE_FONT         8
        -:   71:#define RESOURCE_TYPE_ACCELERATOR  9
        -:   72:#define RESOURCE_TYPE_RCDATA       10
        -:   73:#define RESOURCE_TYPE_MESSAGETABLE 11
        -:   74:#define RESOURCE_TYPE_GROUP_CURSOR 12 // MAKEINTRESOURCE((ULONG_PTR)(RT_CURSOR) + 11)
        -:   75:#define RESOURCE_TYPE_GROUP_ICON   14 // MAKEINTRESOURCE((ULONG_PTR)(RT_ICON) + 11)
        -:   76:#define RESOURCE_TYPE_VERSION      16
        -:   77:#define RESOURCE_TYPE_DLGINCLUDE   17
        -:   78:#define RESOURCE_TYPE_PLUGPLAY     19
        -:   79:#define RESOURCE_TYPE_VXD          20
        -:   80:#define RESOURCE_TYPE_ANICURSOR    21
        -:   81:#define RESOURCE_TYPE_ANIICON      22
        -:   82:#define RESOURCE_TYPE_HTML         23
        -:   83:#define RESOURCE_TYPE_MANIFEST     24
        -:   84:
        -:   85:
        -:   86:#define RESOURCE_CALLBACK_CONTINUE   0
        -:   87:#define RESOURCE_CALLBACK_ABORT      1
        -:   88:
        -:   89:
        -:   90:#define RESOURCE_ITERATOR_FINISHED   0
        -:   91:#define RESOURCE_ITERATOR_ABORTED    1
        -:   92:
        -:   93:
        -:   94:#define MAX_PE_IMPORTS               16384
        -:   95:#define MAX_PE_EXPORTS               8192
        -:   96:#define MAX_EXPORT_NAME_LENGTH       512
        -:   97:
        -:   98:
        -:   99:#define IS_RESOURCE_SUBDIRECTORY(entry) \
        -:  100:    ((entry)->OffsetToData & 0x80000000)
        -:  101:
        -:  102:
        -:  103:#define RESOURCE_OFFSET(entry) \
        -:  104:    ((entry)->OffsetToData & 0x7FFFFFFF)
        -:  105:
        -:  106:
        -:  107:typedef int (*RESOURCE_CALLBACK_FUNC) ( \
        -:  108:     PIMAGE_RESOURCE_DATA_ENTRY rsrc_data, \
        -:  109:     int rsrc_type, \
        -:  110:     int rsrc_id, \
        -:  111:     int rsrc_language, \
        -:  112:     const uint8_t* type_string, \
        -:  113:     const uint8_t* name_string, \
        -:  114:     const uint8_t* lang_string, \
        -:  115:     void* cb_data);
        -:  116:
        -:  117:
    #####:  118:static size_t available_space(
        -:  119:    PE* pe,
        -:  120:    void* pointer)
        -:  121:{
    #####:  122:  if ((uint8_t*) pointer < pe->data)
    #####:  123:    return 0;
        -:  124:
    #####:  125:  if ((uint8_t*) pointer >= pe->data + pe->data_size)
    #####:  126:    return 0;
        -:  127:
    #####:  128:  return pe->data + pe->data_size - (uint8_t*) pointer;
        -:  129:}
        -:  130:
        -:  131:
    #####:  132:static int wide_string_fits_in_pe(
        -:  133:    PE* pe,
        -:  134:    char* data)
        -:  135:{
    #####:  136:  size_t i = 0;
    #####:  137:  size_t space_left = available_space(pe, data);
        -:  138:
    #####:  139:  while (space_left >= 2)
        -:  140:  {
    #####:  141:    if (data[i] == 0 && data[i + 1] == 0)
    #####:  142:      return 1;
    #####:  143:    space_left -= 2;
    #####:  144:    i += 2;
        -:  145:  }
        -:  146:
    #####:  147:  return 0;
        -:  148:}
        -:  149:
        -:  150:
        -:  151:// Parse the rich signature.
        -:  152:// http://www.ntcore.com/files/richsign.htm
        -:  153:
    #####:  154:static void pe_parse_rich_signature(
        -:  155:    PE* pe,
        -:  156:    uint64_t base_address)
        -:  157:{
        -:  158:  PIMAGE_DOS_HEADER mz_header;
        -:  159:  PIMAGE_NT_HEADERS32 pe_header;
        -:  160:  PRICH_SIGNATURE rich_signature;
        -:  161:  DWORD* rich_ptr;
        -:  162:
    #####:  163:  BYTE* raw_data = NULL;
    #####:  164:  BYTE* clear_data = NULL;
    #####:  165:  size_t headers_size = 0;
    #####:  166:  size_t rich_len = 0;
        -:  167:
    #####:  168:  if (pe->data_size < sizeof(IMAGE_DOS_HEADER))
    #####:  169:    return;
        -:  170:
    #####:  171:  mz_header = (PIMAGE_DOS_HEADER) pe->data;
        -:  172:
    #####:  173:  if (yr_le16toh(mz_header->e_magic) != IMAGE_DOS_SIGNATURE)
    #####:  174:    return;
        -:  175:
    #####:  176:  if (yr_le32toh(mz_header->e_lfanew) < 0)
    #####:  177:    return;
        -:  178:
    #####:  179:  headers_size = yr_le32toh(mz_header->e_lfanew) + \
        -:  180:                 sizeof(pe_header->Signature) + \
        -:  181:                 sizeof(IMAGE_FILE_HEADER);
        -:  182:
    #####:  183:  if (pe->data_size < headers_size)
    #####:  184:    return;
        -:  185:
        -:  186:  // From offset 0x80 until the start of the PE header should be the Rich
        -:  187:  // signature. The three key values must all be equal and the first dword
        -:  188:  // XORs to "DanS". Then walk the buffer looking for "Rich" which marks the
        -:  189:  // end. Technically the XOR key should be right after "Rich" but it's not
        -:  190:  // important.
        -:  191:
    #####:  192:  rich_signature = (PRICH_SIGNATURE) (pe->data + 0x80);
        -:  193:
    #####:  194:  if (yr_le32toh(rich_signature->key1) != yr_le32toh(rich_signature->key2) ||
    #####:  195:      yr_le32toh(rich_signature->key2) != yr_le32toh(rich_signature->key3) ||
    #####:  196:      (yr_le32toh(rich_signature->dans) ^ yr_le32toh(rich_signature->key1)) != RICH_DANS)
        -:  197:  {
    #####:  198:    return;
        -:  199:  }
        -:  200:
    #####:  201:  for (rich_ptr = (DWORD*) rich_signature;
    #####:  202:       rich_ptr <= (DWORD*) (pe->data + headers_size);
    #####:  203:       rich_ptr++)
        -:  204:  {
    #####:  205:    if (yr_le32toh(*rich_ptr) == RICH_RICH)
        -:  206:    {
        -:  207:      // Multiple by 4 because we are counting in DWORDs.
    #####:  208:      rich_len = (rich_ptr - (DWORD*) rich_signature) * 4;
    #####:  209:      raw_data = (BYTE*) yr_malloc(rich_len);
        -:  210:
    #####:  211:      if (!raw_data)
    #####:  212:        return;
        -:  213:
    #####:  214:      memcpy(raw_data, rich_signature, rich_len);
        -:  215:
    #####:  216:      set_integer(
        -:  217:          base_address + 0x80, pe->object, "rich_signature.offset");
        -:  218:
    #####:  219:      set_integer(
        -:  220:          rich_len, pe->object, "rich_signature.length");
        -:  221:
    #####:  222:      set_integer(
        -:  223:          rich_signature->key1, pe->object, "rich_signature.key");
        -:  224:
    #####:  225:      break;
        -:  226:    }
        -:  227:  }
        -:  228:
        -:  229:  // Walk the entire block and apply the XOR key.
    #####:  230:  if (raw_data)
        -:  231:  {
    #####:  232:    clear_data = (BYTE*) yr_malloc(rich_len);
        -:  233:
    #####:  234:    if (!clear_data)
        -:  235:    {
    #####:  236:      yr_free(raw_data);
    #####:  237:      return;
        -:  238:    }
        -:  239:
        -:  240:    // Copy the entire block here to be XORed.
    #####:  241:    memcpy(clear_data, raw_data, rich_len);
        -:  242:
    #####:  243:    for (rich_ptr = (DWORD*) clear_data;
    #####:  244:         rich_ptr < (DWORD*) (clear_data + rich_len);
    #####:  245:         rich_ptr++)
        -:  246:    {
    #####:  247:      *rich_ptr ^= rich_signature->key1;
        -:  248:    }
        -:  249:
    #####:  250:    set_sized_string(
        -:  251:        (char*) raw_data, rich_len, pe->object, "rich_signature.raw_data");
        -:  252:
    #####:  253:    set_sized_string(
        -:  254:        (char*) clear_data, rich_len, pe->object, "rich_signature.clear_data");
        -:  255:
    #####:  256:    yr_free(raw_data);
    #####:  257:    yr_free(clear_data);
    #####:  258:    return;
        -:  259:  }
        -:  260:
    #####:  261:  return;
        -:  262:}
        -:  263:
        -:  264:
        -:  265:// Return a pointer to the resource directory string or NULL.
        -:  266:// The callback function will parse this and call set_sized_string().
        -:  267:// The pointer is guaranteed to have enough space to contain the entire string.
        -:  268:
    #####:  269:static const uint8_t* parse_resource_name(
        -:  270:    PE* pe,
        -:  271:    const uint8_t* rsrc_data,
        -:  272:    PIMAGE_RESOURCE_DIRECTORY_ENTRY entry)
        -:  273:{
        -:  274:
        -:  275:  // If high bit is set it is an offset relative to rsrc_data, which contains
        -:  276:  // a resource directory string.
        -:  277:
    #####:  278:  if (yr_le32toh(entry->Name) & 0x80000000)
        -:  279:  {
        -:  280:    DWORD length;
        -:  281:
    #####:  282:    const uint8_t* rsrc_str_ptr = rsrc_data + \
    #####:  283:        (yr_le32toh(entry->Name) & 0x7FFFFFFF);
        -:  284:
        -:  285:    // A resource directory string is 2 bytes for the length and then a variable
        -:  286:    // length Unicode string. Make sure we have at least 2 bytes.
        -:  287:
    #####:  288:    if (!fits_in_pe(pe, rsrc_str_ptr, 2))
    #####:  289:      return NULL;
        -:  290:
    #####:  291:    length = *rsrc_str_ptr;
        -:  292:
        -:  293:    // Move past the length and make sure we have enough bytes for the string.
    #####:  294:    if (!fits_in_pe(pe, rsrc_str_ptr + 2, length * 2))
    #####:  295:      return NULL;
        -:  296:
    #####:  297:    return rsrc_str_ptr;
        -:  298:  }
        -:  299:
    #####:  300:  return NULL;
        -:  301:}
        -:  302:
        -:  303:
    #####:  304:static int _pe_iterate_resources(
        -:  305:    PE* pe,
        -:  306:    PIMAGE_RESOURCE_DIRECTORY resource_dir,
        -:  307:    const uint8_t* rsrc_data,
        -:  308:    int rsrc_tree_level,
        -:  309:    int* type,
        -:  310:    int* id,
        -:  311:    int* language,
        -:  312:    const uint8_t* type_string,
        -:  313:    const uint8_t* name_string,
        -:  314:    const uint8_t* lang_string,
        -:  315:    RESOURCE_CALLBACK_FUNC callback,
        -:  316:    void* callback_data)
        -:  317:{
    #####:  318:  int i, result = RESOURCE_ITERATOR_FINISHED;
        -:  319:  int total_entries;
        -:  320:
        -:  321:  PIMAGE_RESOURCE_DIRECTORY_ENTRY entry;
        -:  322:
        -:  323:  // A few sanity checks to avoid corrupt files
        -:  324:
    #####:  325:  if (yr_le32toh(resource_dir->Characteristics) != 0 ||
    #####:  326:      yr_le16toh(resource_dir->NumberOfNamedEntries) > 32768 ||
    #####:  327:      yr_le16toh(resource_dir->NumberOfIdEntries) > 32768)
        -:  328:  {
    #####:  329:    return result;
        -:  330:  }
        -:  331:
    #####:  332:  total_entries = yr_le16toh(resource_dir->NumberOfNamedEntries) +
    #####:  333:                  yr_le16toh(resource_dir->NumberOfIdEntries);
        -:  334:
        -:  335:  // The first directory entry is just after the resource directory,
        -:  336:  // by incrementing resource_dir we skip sizeof(resource_dir) bytes
        -:  337:  // and get a pointer to the end of the resource directory.
        -:  338:
    #####:  339:  entry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY) (resource_dir + 1);
        -:  340:
    #####:  341:  for (i = 0; i < total_entries; i++)
        -:  342:  {
    #####:  343:    if (!struct_fits_in_pe(pe, entry, IMAGE_RESOURCE_DIRECTORY_ENTRY))
        -:  344:    {
    #####:  345:      result = RESOURCE_ITERATOR_ABORTED;
    #####:  346:      break;
        -:  347:    }
        -:  348:
    #####:  349:    switch(rsrc_tree_level)
        -:  350:    {
    #####:  351:      case 0:
    #####:  352:        *type = yr_le32toh(entry->Name);
    #####:  353:        type_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  354:        break;
    #####:  355:      case 1:
    #####:  356:        *id = yr_le32toh(entry->Name);
    #####:  357:        name_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  358:        break;
    #####:  359:      case 2:
    #####:  360:        *language = yr_le32toh(entry->Name);
    #####:  361:        lang_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  362:        break;
        -:  363:    }
        -:  364:
    #####:  365:    if (IS_RESOURCE_SUBDIRECTORY(entry) && rsrc_tree_level < 2)
    #####:  366:    {
    #####:  367:      PIMAGE_RESOURCE_DIRECTORY directory = (PIMAGE_RESOURCE_DIRECTORY) \
    #####:  368:          (rsrc_data + RESOURCE_OFFSET(entry));
        -:  369:
    #####:  370:      if (struct_fits_in_pe(pe, directory, IMAGE_RESOURCE_DIRECTORY))
        -:  371:      {
    #####:  372:        result = _pe_iterate_resources(
        -:  373:            pe,
        -:  374:            directory,
        -:  375:            rsrc_data,
        -:  376:            rsrc_tree_level + 1,
        -:  377:            type,
        -:  378:            id,
        -:  379:            language,
        -:  380:            type_string,
        -:  381:            name_string,
        -:  382:            lang_string,
        -:  383:            callback,
        -:  384:            callback_data);
        -:  385:      }
        -:  386:      else
        -:  387:      {
    #####:  388:        result = RESOURCE_ITERATOR_ABORTED;
        -:  389:      }
        -:  390:    }
        -:  391:    else
        -:  392:    {
    #####:  393:      PIMAGE_RESOURCE_DATA_ENTRY data_entry = (PIMAGE_RESOURCE_DATA_ENTRY) \
    #####:  394:          (rsrc_data + RESOURCE_OFFSET(entry));
        -:  395:
    #####:  396:      if (struct_fits_in_pe(pe, data_entry, IMAGE_RESOURCE_DATA_ENTRY))
        -:  397:      {
    #####:  398:        if (callback(
        -:  399:            data_entry,
        -:  400:            *type,
        -:  401:            *id,
        -:  402:            *language,
        -:  403:            type_string,
        -:  404:            name_string,
        -:  405:            lang_string,
        -:  406:            callback_data) == RESOURCE_CALLBACK_ABORT)
        -:  407:        {
    #####:  408:          result = RESOURCE_ITERATOR_ABORTED;
        -:  409:        }
        -:  410:      }
        -:  411:      else
        -:  412:      {
    #####:  413:        result = RESOURCE_ITERATOR_ABORTED;
        -:  414:      }
        -:  415:    }
        -:  416:
    #####:  417:    if (result == RESOURCE_ITERATOR_ABORTED)
    #####:  418:      break;
        -:  419:
    #####:  420:    entry++;
        -:  421:  }
        -:  422:
    #####:  423:  return result;
        -:  424:}
        -:  425:
        -:  426:
    #####:  427:static int pe_iterate_resources(
        -:  428:    PE* pe,
        -:  429:    RESOURCE_CALLBACK_FUNC callback,
        -:  430:    void* callback_data)
        -:  431:{
        -:  432:  int64_t offset;
        -:  433:
    #####:  434:  int type = -1;
    #####:  435:  int id = -1;
    #####:  436:  int language = -1;
        -:  437:
    #####:  438:  uint8_t* type_string = NULL;
    #####:  439:  uint8_t* name_string = NULL;
    #####:  440:  uint8_t* lang_string = NULL;
        -:  441:
    #####:  442:  PIMAGE_DATA_DIRECTORY directory = pe_get_directory_entry(
        -:  443:      pe, IMAGE_DIRECTORY_ENTRY_RESOURCE);
        -:  444:
    #####:  445:  if (directory == NULL)
    #####:  446:     return 0;
        -:  447:
    #####:  448:  if (yr_le32toh(directory->VirtualAddress) != 0)
        -:  449:  {
        -:  450:    PIMAGE_RESOURCE_DIRECTORY rsrc_dir;
        -:  451:
    #####:  452:    offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -:  453:
    #####:  454:    if (offset < 0)
    #####:  455:      return 0;
        -:  456:
    #####:  457:    rsrc_dir = (PIMAGE_RESOURCE_DIRECTORY) (pe->data + offset);
        -:  458:
    #####:  459:    if (struct_fits_in_pe(pe, rsrc_dir, IMAGE_RESOURCE_DIRECTORY))
        -:  460:    {
    #####:  461:      set_integer(yr_le32toh(rsrc_dir->TimeDateStamp),
        -:  462:          pe->object,
        -:  463:          "resource_timestamp");
        -:  464:
    #####:  465:      set_integer(yr_le16toh(rsrc_dir->MajorVersion),
        -:  466:                  pe->object,
        -:  467:                  "resource_version.major");
    #####:  468:      set_integer(yr_le16toh(rsrc_dir->MinorVersion),
        -:  469:                  pe->object,
        -:  470:                  "resource_version.minor");
        -:  471:
    #####:  472:      _pe_iterate_resources(
        -:  473:          pe,
        -:  474:          rsrc_dir,
    #####:  475:          pe->data + offset,
        -:  476:          0,
        -:  477:          &type,
        -:  478:          &id,
        -:  479:          &language,
        -:  480:          type_string,
        -:  481:          name_string,
        -:  482:          lang_string,
        -:  483:          callback,
        -:  484:          callback_data);
        -:  485:
    #####:  486:      return 1;
        -:  487:    }
        -:  488:  }
        -:  489:
    #####:  490:  return 0;
        -:  491:}
        -:  492:
        -:  493:
        -:  494:// Align offset to a 32-bit boundary and add it to a pointer
        -:  495:
        -:  496:#define ADD_OFFSET(ptr, offset) \
        -:  497:    (PVERSION_INFO) ((uint8_t*) (ptr) + ((offset + 3) & ~3))
        -:  498:
        -:  499:
    #####:  500:static void pe_parse_version_info(
        -:  501:    PIMAGE_RESOURCE_DATA_ENTRY rsrc_data,
        -:  502:    PE* pe)
        -:  503:{
        -:  504:  PVERSION_INFO version_info;
        -:  505:
    #####:  506:  int64_t version_info_offset = pe_rva_to_offset(
    #####:  507:      pe, yr_le32toh(rsrc_data->OffsetToData));
        -:  508:
    #####:  509:  if (version_info_offset < 0)
    #####:  510:    return;
        -:  511:
    #####:  512:  version_info = (PVERSION_INFO) (pe->data + version_info_offset);
        -:  513:
    #####:  514:  if (!struct_fits_in_pe(pe, version_info, VERSION_INFO))
    #####:  515:    return;
        -:  516:
    #####:  517:  if (!fits_in_pe(pe, version_info->Key, sizeof("VS_VERSION_INFO") * 2))
    #####:  518:    return;
        -:  519:
    #####:  520:  if (strcmp_w(version_info->Key, "VS_VERSION_INFO") != 0)
    #####:  521:    return;
        -:  522:
    #####:  523:  version_info = ADD_OFFSET(
        -:  524:      version_info, sizeof(VERSION_INFO) + 86);
        -:  525:
    #####:  526:  while(fits_in_pe(pe, version_info->Key, sizeof("VarFileInfo") * 2) &&
    #####:  527:        strcmp_w(version_info->Key, "VarFileInfo") == 0 &&
    #####:  528:        yr_le16toh(version_info->Length) != 0)
        -:  529:  {
    #####:  530:    version_info = ADD_OFFSET(
        -:  531:        version_info,
        -:  532:        yr_le16toh(version_info->Length));
        -:  533:  }
        -:  534:
    #####:  535:  while(fits_in_pe(pe, version_info->Key, sizeof("StringFileInfo") * 2) &&
    #####:  536:        strcmp_w(version_info->Key, "StringFileInfo") == 0 &&
    #####:  537:        yr_le16toh(version_info->Length) != 0)
        -:  538:  {
    #####:  539:    PVERSION_INFO string_table = ADD_OFFSET(
        -:  540:        version_info,
        -:  541:        sizeof(VERSION_INFO) + 30);
        -:  542:
    #####:  543:    version_info = ADD_OFFSET(
        -:  544:        version_info,
        -:  545:        yr_le16toh(version_info->Length));
        -:  546:
    #####:  547:    while (struct_fits_in_pe(pe, string_table, VERSION_INFO) &&
    #####:  548:           wide_string_fits_in_pe(pe, string_table->Key) &&
    #####:  549:           yr_le16toh(string_table->Length) != 0 &&
        -:  550:           string_table < version_info)
        -:  551:    {
    #####:  552:      PVERSION_INFO string = ADD_OFFSET(
        -:  553:          string_table,
        -:  554:          sizeof(VERSION_INFO) + 2 * (strnlen_w(string_table->Key) + 1));
        -:  555:
    #####:  556:      string_table = ADD_OFFSET(
        -:  557:          string_table,
        -:  558:          yr_le16toh(string_table->Length));
        -:  559:
    #####:  560:      while (struct_fits_in_pe(pe, string, VERSION_INFO) &&
    #####:  561:             wide_string_fits_in_pe(pe, string->Key) &&
    #####:  562:             yr_le16toh(string->Length) != 0 &&
        -:  563:             string < string_table)
        -:  564:      {
    #####:  565:        if (yr_le16toh(string->ValueLength) > 0)
        -:  566:        {
    #####:  567:          char* string_value = (char*) ADD_OFFSET(string,
        -:  568:              sizeof(VERSION_INFO) + 2 * (strnlen_w(string->Key) + 1));
        -:  569:
    #####:  570:          if (wide_string_fits_in_pe(pe, string_value))
        -:  571:          {
        -:  572:            char key[64];
        -:  573:            char value[256];
        -:  574:
    #####:  575:            strlcpy_w(key, string->Key, sizeof(key));
    #####:  576:            strlcpy_w(value, string_value, sizeof(value));
        -:  577:
    #####:  578:            set_string(value, pe->object, "version_info[%s]", key);
        -:  579:          }
        -:  580:        }
        -:  581:
    #####:  582:        string = ADD_OFFSET(string, yr_le16toh(string->Length));
        -:  583:      }
        -:  584:    }
        -:  585:  }
        -:  586:}
        -:  587:
        -:  588:
    #####:  589:static int pe_collect_resources(
        -:  590:    PIMAGE_RESOURCE_DATA_ENTRY rsrc_data,
        -:  591:    int rsrc_type,
        -:  592:    int rsrc_id,
        -:  593:    int rsrc_language,
        -:  594:    uint8_t* type_string,
        -:  595:    uint8_t* name_string,
        -:  596:    uint8_t* lang_string,
        -:  597:    PE* pe)
        -:  598:{
        -:  599:  DWORD length;
        -:  600:
    #####:  601:  int64_t offset = pe_rva_to_offset(pe, yr_le32toh(rsrc_data->OffsetToData));
        -:  602:
    #####:  603:  if (offset < 0)
    #####:  604:    return RESOURCE_CALLBACK_CONTINUE;
        -:  605:
    #####:  606:  if (!fits_in_pe(pe, pe->data + offset, yr_le32toh(rsrc_data->Size)))
    #####:  607:    return RESOURCE_CALLBACK_CONTINUE;
        -:  608:
    #####:  609:  set_integer(
        -:  610:        offset,
        -:  611:        pe->object,
        -:  612:        "resources[%i].offset",
        -:  613:        pe->resources);
        -:  614:
    #####:  615:  set_integer(
        -:  616:        yr_le32toh(rsrc_data->Size),
        -:  617:        pe->object,
        -:  618:        "resources[%i].length",
        -:  619:        pe->resources);
        -:  620:
    #####:  621:  if (type_string)
        -:  622:  {
        -:  623:    // Multiply by 2 because it is a Unicode string.
    #####:  624:    length = ((DWORD) *type_string) * 2;
    #####:  625:    type_string += 2;
        -:  626:
    #####:  627:    set_sized_string(
        -:  628:        (char*) type_string, length, pe->object,
        -:  629:        "resources[%i].type_string", pe->resources);
        -:  630:  }
        -:  631:  else
        -:  632:  {
    #####:  633:    set_integer(
        -:  634:          rsrc_type,
        -:  635:          pe->object,
        -:  636:          "resources[%i].type",
        -:  637:          pe->resources);
        -:  638:  }
        -:  639:
    #####:  640:  if (name_string)
        -:  641:  {
        -:  642:    // Multiply by 2 because it is a Unicode string.
    #####:  643:    length = ((DWORD) *name_string) * 2;
    #####:  644:    name_string += 2;
    #####:  645:    set_sized_string(
        -:  646:        (char*) name_string, length, pe->object,
        -:  647:        "resources[%i].name_string", pe->resources);
        -:  648:  }
        -:  649:  else
        -:  650:  {
    #####:  651:    set_integer(
        -:  652:        rsrc_id,
        -:  653:        pe->object,
        -:  654:        "resources[%i].id",
        -:  655:        pe->resources);
        -:  656:  }
        -:  657:
    #####:  658:  if (lang_string)
        -:  659:  {
        -:  660:    // Multiply by 2 because it is a Unicode string.
    #####:  661:    length = ((DWORD) *lang_string) * 2;
    #####:  662:    lang_string += 2;
    #####:  663:    set_sized_string(
        -:  664:        (char*) lang_string, length, pe->object,
        -:  665:        "resources[%i].language_string", pe->resources);
        -:  666:  }
        -:  667:  else
        -:  668:  {
    #####:  669:    set_integer(
        -:  670:        rsrc_language,
        -:  671:        pe->object,
        -:  672:        "resources[%i].language",
        -:  673:        pe->resources);
        -:  674:  }
        -:  675:
        -:  676:  // Resources we do extra parsing on
    #####:  677:  if (rsrc_type == RESOURCE_TYPE_VERSION)
    #####:  678:    pe_parse_version_info(rsrc_data, pe);
        -:  679:
    #####:  680:  pe->resources += 1;
    #####:  681:  return RESOURCE_CALLBACK_CONTINUE;
        -:  682:}
        -:  683:
        -:  684:
    #####:  685:static IMPORT_FUNCTION* pe_parse_import_descriptor(
        -:  686:    PE* pe,
        -:  687:    PIMAGE_IMPORT_DESCRIPTOR import_descriptor,
        -:  688:    char* dll_name,
        -:  689:    int* num_function_imports)
        -:  690:{
    #####:  691:  IMPORT_FUNCTION* head = NULL;
    #####:  692:  IMPORT_FUNCTION* tail = NULL;
        -:  693:
    #####:  694:  int64_t offset = pe_rva_to_offset(
    #####:  695:      pe, yr_le32toh(import_descriptor->OriginalFirstThunk));
        -:  696:
        -:  697:  // I've seen binaries where OriginalFirstThunk is zero. In this case
        -:  698:  // use FirstThunk.
        -:  699:
    #####:  700:  if (offset <= 0)
    #####:  701:    offset = pe_rva_to_offset(pe, yr_le32toh(import_descriptor->FirstThunk));
        -:  702:
    #####:  703:  if (offset < 0)
    #####:  704:    return NULL;
        -:  705:
    #####:  706:  if (IS_64BITS_PE(pe))
        -:  707:  {
    #####:  708:    PIMAGE_THUNK_DATA64 thunks64 = (PIMAGE_THUNK_DATA64)(pe->data + offset);
        -:  709:
    #####:  710:    while (struct_fits_in_pe(pe, thunks64, IMAGE_THUNK_DATA64) &&
    #####:  711:           yr_le64toh(thunks64->u1.Ordinal) != 0 &&
    #####:  712:           *num_function_imports < MAX_PE_IMPORTS)
        -:  713:    {
    #####:  714:      char* name = NULL;
    #####:  715:      uint16_t ordinal = 0;
    #####:  716:      uint8_t has_ordinal = 0;
        -:  717:
    #####:  718:      if (!(yr_le64toh(thunks64->u1.Ordinal) & IMAGE_ORDINAL_FLAG64))
        -:  719:      {
        -:  720:        // If imported by name
    #####:  721:        offset = pe_rva_to_offset(pe, yr_le64toh(thunks64->u1.Function));
        -:  722:
    #####:  723:        if (offset >= 0)
        -:  724:        {
    #####:  725:          PIMAGE_IMPORT_BY_NAME import = (PIMAGE_IMPORT_BY_NAME) \
    #####:  726:              (pe->data + offset);
        -:  727:
    #####:  728:          if (struct_fits_in_pe(pe, import, IMAGE_IMPORT_BY_NAME))
        -:  729:          {
    #####:  730:            name = (char *) yr_strndup(
    #####:  731:                (char*) import->Name,
    #####:  732:                yr_min(available_space(pe, import->Name), 512));
        -:  733:          }
        -:  734:        }
        -:  735:      }
        -:  736:      else
        -:  737:      {
        -:  738:        // If imported by ordinal. Lookup the ordinal.
    #####:  739:        name = ord_lookup(dll_name, yr_le64toh(thunks64->u1.Ordinal) & 0xFFFF);
        -:  740:        // Also store the ordinal.
    #####:  741:        ordinal = yr_le64toh(thunks64->u1.Ordinal) & 0xFFFF;
    #####:  742:        has_ordinal = 1;
        -:  743:      }
        -:  744:
    #####:  745:      if (name != NULL || has_ordinal == 1)
        -:  746:      {
        -:  747:        IMPORT_FUNCTION* imported_func = (IMPORT_FUNCTION*)
    #####:  748:            yr_calloc(1, sizeof(IMPORT_FUNCTION));
        -:  749:
    #####:  750:        if (imported_func == NULL)
        -:  751:        {
    #####:  752:          yr_free(name);
    #####:  753:          continue;
        -:  754:        }
        -:  755:
    #####:  756:        imported_func->name = name;
    #####:  757:        imported_func->ordinal = ordinal;
    #####:  758:        imported_func->has_ordinal = has_ordinal;
    #####:  759:        imported_func->next = NULL;
        -:  760:
    #####:  761:        if (head == NULL)
    #####:  762:          head = imported_func;
        -:  763:
    #####:  764:        if (tail != NULL)
    #####:  765:          tail->next = imported_func;
        -:  766:
    #####:  767:        tail = imported_func;
        -:  768:      }
        -:  769:
    #####:  770:      (*num_function_imports)++;
    #####:  771:      thunks64++;
        -:  772:    }
        -:  773:  }
        -:  774:  else
        -:  775:  {
    #####:  776:    PIMAGE_THUNK_DATA32 thunks32 = (PIMAGE_THUNK_DATA32)(pe->data + offset);
        -:  777:
    #####:  778:    while (struct_fits_in_pe(pe, thunks32, IMAGE_THUNK_DATA32) &&
    #####:  779:           yr_le32toh(thunks32->u1.Ordinal) != 0 && *num_function_imports < MAX_PE_IMPORTS)
        -:  780:    {
    #####:  781:      char* name = NULL;
    #####:  782:      uint16_t ordinal = 0;
    #####:  783:      uint8_t has_ordinal = 0;
        -:  784:
    #####:  785:      if (!(yr_le32toh(thunks32->u1.Ordinal) & IMAGE_ORDINAL_FLAG32))
        -:  786:      {
        -:  787:        // If imported by name
    #####:  788:        offset = pe_rva_to_offset(pe, yr_le32toh(thunks32->u1.Function));
        -:  789:
    #####:  790:        if (offset >= 0)
        -:  791:        {
    #####:  792:          PIMAGE_IMPORT_BY_NAME import = (PIMAGE_IMPORT_BY_NAME) \
    #####:  793:              (pe->data + offset);
        -:  794:
    #####:  795:          if (struct_fits_in_pe(pe, import, IMAGE_IMPORT_BY_NAME))
        -:  796:          {
    #####:  797:            name = (char *) yr_strndup(
    #####:  798:                (char*) import->Name,
    #####:  799:                yr_min(available_space(pe, import->Name), 512));
        -:  800:          }
        -:  801:        }
        -:  802:      }
        -:  803:      else
        -:  804:      {
        -:  805:        // If imported by ordinal. Lookup the ordinal.
    #####:  806:        name = ord_lookup(dll_name, yr_le32toh(thunks32->u1.Ordinal) & 0xFFFF);
        -:  807:        // Also store the ordinal.
    #####:  808:        ordinal = yr_le32toh(thunks32->u1.Ordinal) & 0xFFFF;
    #####:  809:        has_ordinal = 1;
        -:  810:      }
        -:  811:
    #####:  812:      if (name != NULL || has_ordinal == 1)
        -:  813:      {
        -:  814:        IMPORT_FUNCTION* imported_func = (IMPORT_FUNCTION*)
    #####:  815:            yr_calloc(1, sizeof(IMPORT_FUNCTION));
        -:  816:
    #####:  817:        if (imported_func == NULL)
        -:  818:        {
    #####:  819:          yr_free(name);
    #####:  820:          continue;
        -:  821:        }
        -:  822:
    #####:  823:        imported_func->name = name;
    #####:  824:        imported_func->ordinal = ordinal;
    #####:  825:        imported_func->has_ordinal = has_ordinal;
    #####:  826:        imported_func->next = NULL;
        -:  827:
    #####:  828:        if (head == NULL)
    #####:  829:          head = imported_func;
        -:  830:
    #####:  831:        if (tail != NULL)
    #####:  832:          tail->next = imported_func;
        -:  833:
    #####:  834:        tail = imported_func;
        -:  835:      }
        -:  836:
    #####:  837:      (*num_function_imports)++;
    #####:  838:      thunks32++;
        -:  839:    }
        -:  840:  }
        -:  841:
    #####:  842:  return head;
        -:  843:}
        -:  844:
        -:  845:
    #####:  846:static int pe_valid_dll_name(
        -:  847:    const char* dll_name,
        -:  848:    size_t n)
        -:  849:{
    #####:  850:  const char* c = dll_name;
    #####:  851:  size_t l = 0;
        -:  852:
    #####:  853:  while (l < n && *c != '\0')
        -:  854:  {
    #####:  855:    if ((*c >= 'a' && *c <= 'z') ||
    #####:  856:        (*c >= 'A' && *c <= 'Z') ||
    #####:  857:        (*c >= '0' && *c <= '9') ||
    #####:  858:        (*c == '_' || *c == '.' || *c == '-'))
        -:  859:    {
    #####:  860:      c++;
    #####:  861:      l++;
        -:  862:    }
        -:  863:    else
        -:  864:    {
    #####:  865:      return false;
        -:  866:    }
        -:  867:  }
        -:  868:
    #####:  869:  return (l > 0 && l < n);
        -:  870:}
        -:  871:
        -:  872:
        -:  873://
        -:  874:// Walk the imports and collect relevant information. It is used in the
        -:  875:// "imports" function for comparison and in the "imphash" function for
        -:  876:// calculation.
        -:  877://
        -:  878:
    #####:  879:static IMPORTED_DLL* pe_parse_imports(
        -:  880:    PE* pe)
        -:  881:{
        -:  882:  int64_t offset;
    #####:  883:  int num_imports = 0;           // Number of imported DLLs
    #####:  884:  int num_function_imports = 0;  // Total number of functions imported
        -:  885:
    #####:  886:  IMPORTED_DLL* head = NULL;
    #####:  887:  IMPORTED_DLL* tail = NULL;
        -:  888:
        -:  889:  PIMAGE_IMPORT_DESCRIPTOR imports;
        -:  890:  PIMAGE_DATA_DIRECTORY directory;
        -:  891:
        -:  892:  // Default to 0 imports until we know there are any
    #####:  893:  set_integer(0, pe->object, "number_of_imports");
        -:  894:
    #####:  895:  directory = pe_get_directory_entry(
        -:  896:      pe, IMAGE_DIRECTORY_ENTRY_IMPORT);
        -:  897:
    #####:  898:  if (directory == NULL)
    #####:  899:    return NULL;
        -:  900:
    #####:  901:  if (yr_le32toh(directory->VirtualAddress) == 0)
    #####:  902:    return NULL;
        -:  903:
    #####:  904:  offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -:  905:
    #####:  906:  if (offset < 0)
    #####:  907:    return NULL;
        -:  908:
    #####:  909:  imports = (PIMAGE_IMPORT_DESCRIPTOR) \
    #####:  910:      (pe->data + offset);
        -:  911:
    #####:  912:  while (struct_fits_in_pe(pe, imports, IMAGE_IMPORT_DESCRIPTOR) &&
    #####:  913:         yr_le32toh(imports->Name) != 0 && num_imports < MAX_PE_IMPORTS)
        -:  914:  {
    #####:  915:    int64_t offset = pe_rva_to_offset(pe, yr_le32toh(imports->Name));
        -:  916:
    #####:  917:    if (offset >= 0)
        -:  918:    {
        -:  919:      IMPORTED_DLL* imported_dll;
        -:  920:
    #####:  921:      char* dll_name = (char *) (pe->data + offset);
        -:  922:
    #####:  923:      if (!pe_valid_dll_name(dll_name, pe->data_size - (size_t) offset))
        -:  924:      {
    #####:  925:          imports++;
    #####:  926:          continue;
        -:  927:      }
        -:  928:
    #####:  929:      imported_dll = (IMPORTED_DLL*) yr_calloc(1, sizeof(IMPORTED_DLL));
        -:  930:
    #####:  931:      if (imported_dll != NULL)
        -:  932:      {
    #####:  933:        IMPORT_FUNCTION* functions = pe_parse_import_descriptor(
        -:  934:            pe, imports, dll_name, &num_function_imports);
        -:  935:
    #####:  936:        if (functions != NULL)
        -:  937:        {
    #####:  938:          imported_dll->name = yr_strdup(dll_name);;
    #####:  939:          imported_dll->functions = functions;
    #####:  940:          imported_dll->next = NULL;
        -:  941:
    #####:  942:          if (head == NULL)
    #####:  943:            head = imported_dll;
        -:  944:
    #####:  945:          if (tail != NULL)
    #####:  946:            tail->next = imported_dll;
        -:  947:
    #####:  948:          tail = imported_dll;
        -:  949:        }
        -:  950:        else
        -:  951:        {
    #####:  952:          yr_free(imported_dll);
        -:  953:        }
        -:  954:      }
        -:  955:    }
        -:  956:
    #####:  957:    num_imports++;
    #####:  958:    imports++;
        -:  959:  }
        -:  960:
    #####:  961:  set_integer(num_imports, pe->object, "number_of_imports");
    #####:  962:  return head;
        -:  963:}
        -:  964:
        -:  965://
        -:  966:// Walk the exports and collect relevant information. It is used in the
        -:  967:// "exports" function for comparison.
        -:  968://
        -:  969:
    #####:  970:static EXPORT_FUNCTIONS* pe_parse_exports(
        -:  971:    PE* pe)
        -:  972:{
        -:  973:  PIMAGE_DATA_DIRECTORY directory;
        -:  974:  PIMAGE_EXPORT_DIRECTORY exports;
        -:  975:  EXPORT_FUNCTIONS* exported_functions;
        -:  976:
        -:  977:  uint32_t i;
        -:  978:  uint32_t number_of_exports;
        -:  979:  uint32_t number_of_names;
        -:  980:  uint16_t ordinal;
        -:  981:  int64_t offset;
        -:  982:  size_t remaining;
        -:  983:
    #####:  984:  DWORD* names = NULL;
    #####:  985:  WORD* ordinals = NULL;
        -:  986:
        -:  987:  // If not a PE file, return UNDEFINED
        -:  988:
    #####:  989:  if (pe == NULL)
    #####:  990:    return NULL;
        -:  991:
        -:  992:  // Default to 0 exports until we know there are any
    #####:  993:  set_integer(0, pe->object, "number_of_exports");
        -:  994:
    #####:  995:  directory = pe_get_directory_entry(
        -:  996:      pe, IMAGE_DIRECTORY_ENTRY_EXPORT);
        -:  997:
    #####:  998:  if (directory == NULL)
    #####:  999:    return NULL;
        -: 1000:
    #####: 1001:  if (yr_le32toh(directory->VirtualAddress) == 0)
    #####: 1002:    return NULL;
        -: 1003:
    #####: 1004:  offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -: 1005:
    #####: 1006:  if (offset < 0)
    #####: 1007:    return NULL;
        -: 1008:
    #####: 1009:  exports = (PIMAGE_EXPORT_DIRECTORY) (pe->data + offset);
        -: 1010:
    #####: 1011:  if (!struct_fits_in_pe(pe, exports, IMAGE_EXPORT_DIRECTORY))
    #####: 1012:    return NULL;
        -: 1013:
    #####: 1014:  number_of_exports = yr_min(
        -: 1015:      yr_le32toh(exports->NumberOfFunctions),
        -: 1016:      MAX_PE_EXPORTS);
        -: 1017:
    #####: 1018:  if (number_of_exports * sizeof(DWORD) > pe->data_size - offset)
    #####: 1019:    return NULL;
        -: 1020:
    #####: 1021:  if (yr_le32toh(exports->NumberOfNames) > 0)
        -: 1022:  {
    #####: 1023:    offset = pe_rva_to_offset(pe, yr_le32toh(exports->AddressOfNames));
        -: 1024:
    #####: 1025:    if (offset < 0)
    #####: 1026:      return NULL;
        -: 1027:
    #####: 1028:    if (yr_le32toh(exports->NumberOfNames) * sizeof(DWORD) > pe->data_size - offset)
    #####: 1029:      return NULL;
        -: 1030:
    #####: 1031:    names = (DWORD*)(pe->data + offset);
        -: 1032:
    #####: 1033:    offset = pe_rva_to_offset(pe, yr_le32toh(exports->AddressOfNameOrdinals));
        -: 1034:
    #####: 1035:    if (offset < 0)
    #####: 1036:      return NULL;
        -: 1037:
    #####: 1038:    ordinals = (WORD*)(pe->data + offset);
        -: 1039:  }
        -: 1040:
    #####: 1041:  exported_functions = (EXPORT_FUNCTIONS*) yr_malloc(sizeof(EXPORT_FUNCTIONS));
        -: 1042:
    #####: 1043:  if (exported_functions == NULL)
    #####: 1044:    return NULL;
        -: 1045:
    #####: 1046:  exported_functions->number_of_exports = number_of_exports;
    #####: 1047:  exported_functions->functions = (EXPORT_FUNCTION*) yr_malloc(
        -: 1048:      number_of_exports * sizeof(EXPORT_FUNCTION));
        -: 1049:
    #####: 1050:  if (exported_functions->functions == NULL)
        -: 1051:  {
    #####: 1052:    yr_free(exported_functions);
    #####: 1053:    return NULL;
        -: 1054:  }
        -: 1055:
        -: 1056:  // At first, iterate through Functions array and create representation for
        -: 1057:  // each exported function. Ordinal is just array index that starts from 1
    #####: 1058:  for (i = 0; i < exported_functions->number_of_exports; i++)
        -: 1059:  {
    #####: 1060:    exported_functions->functions[i].name = NULL;
    #####: 1061:    exported_functions->functions[i].ordinal = i + 1;
        -: 1062:  }
        -: 1063:
        -: 1064:  // Now, we can iterate through Names and NameOrdinals arrays to obtain
        -: 1065:  // function names. Not all functions have names.
    #####: 1066:  number_of_names = yr_min(
        -: 1067:      yr_le32toh(exports->NumberOfNames),
        -: 1068:      exported_functions->number_of_exports);
        -: 1069:
    #####: 1070:  for (i = 0; i < number_of_names; i++)
        -: 1071:  {
    #####: 1072:    if (available_space(pe, names + i) < sizeof(DWORD) ||
    #####: 1073:        available_space(pe, ordinals + i) < sizeof(WORD))
        -: 1074:    {
        -: 1075:      break;
        -: 1076:    }
        -: 1077:
    #####: 1078:    offset = pe_rva_to_offset(pe, names[i]);
        -: 1079:
    #####: 1080:    if (offset < 0)
    #####: 1081:      continue;
        -: 1082:
        -: 1083:    // Even though it is called ordinal, it is just index to Functions array
        -: 1084:    // If it was ordinal it would start from 1 but it starts from 0
    #####: 1085:    ordinal = yr_le16toh(ordinals[i]);
        -: 1086:
    #####: 1087:    if (ordinal >= exported_functions->number_of_exports)
    #####: 1088:      continue;
        -: 1089:
    #####: 1090:    remaining = pe->data_size - (size_t) offset;
        -: 1091:
    #####: 1092:    if (exported_functions->functions[ordinal].name == NULL)
        -: 1093:    {
    #####: 1094:      exported_functions->functions[ordinal].name = yr_strndup(
    #####: 1095:          (char*) (pe->data + offset),
        -: 1096:          yr_min(remaining, MAX_EXPORT_NAME_LENGTH));
        -: 1097:    }
        -: 1098:  }
        -: 1099:
    #####: 1100:  set_integer(
        -: 1101:      exported_functions->number_of_exports,
        -: 1102:      pe->object, "number_of_exports");
        -: 1103:
    #####: 1104:  return exported_functions;
        -: 1105:}
        -: 1106:
        -: 1107:// BoringSSL (https://boringssl.googlesource.com/boringssl/) doesn't support
        -: 1108:// some features used in pe_parse_certificates, if you are using BoringSSL
        -: 1109:// instead of OpenSSL you should define BORINGSSL for YARA to compile properly,
        -: 1110:// but you won't have signature-related features in the PE module.
        -: 1111:#if defined(HAVE_LIBCRYPTO) && !defined(BORINGSSL)
        -: 1112:
    #####: 1113:static void pe_parse_certificates(
        -: 1114:    PE* pe)
        -: 1115:{
    #####: 1116:  int i, counter = 0;
        -: 1117:
        -: 1118:  const uint8_t* eod;
        -: 1119:  uintptr_t end;
        -: 1120:
        -: 1121:  PWIN_CERTIFICATE win_cert;
        -: 1122:
    #####: 1123:  PIMAGE_DATA_DIRECTORY directory = pe_get_directory_entry(
        -: 1124:      pe, IMAGE_DIRECTORY_ENTRY_SECURITY);
        -: 1125:
    #####: 1126:  if (directory == NULL)
    #####: 1127:    return;
        -: 1128:
        -: 1129:  // Default to 0 signatures until we know otherwise.
    #####: 1130:  set_integer(0, pe->object, "number_of_signatures");
        -: 1131:
        -: 1132:  // directory->VirtualAddress is a file offset. Don't call pe_rva_to_offset().
    #####: 1133:  if (yr_le32toh(directory->VirtualAddress) == 0 ||
    #####: 1134:      yr_le32toh(directory->VirtualAddress) > pe->data_size ||
    #####: 1135:      yr_le32toh(directory->Size) > pe->data_size ||
    #####: 1136:      yr_le32toh(directory->VirtualAddress) + yr_le32toh(directory->Size) > pe->data_size)
        -: 1137:  {
    #####: 1138:    return;
        -: 1139:  }
        -: 1140:
        -: 1141:  // Store the end of directory, making comparisons easier.
    #####: 1142:  eod = pe->data + \
    #####: 1143:      yr_le32toh(directory->VirtualAddress) + \
    #####: 1144:      yr_le32toh(directory->Size);
        -: 1145:
    #####: 1146:  win_cert = (PWIN_CERTIFICATE) \
    #####: 1147:      (pe->data + yr_le32toh(directory->VirtualAddress));
        -: 1148:
        -: 1149:  //
        -: 1150:  // Walk the directory, pulling out certificates.
        -: 1151:  //
        -: 1152:  // Make sure WIN_CERTIFICATE fits within the directory.
        -: 1153:  // Make sure the Length specified fits within directory too.
        -: 1154:  //
        -: 1155:  // The docs say that the length is only for the Certificate, but the next
        -: 1156:  // paragraph contradicts that. All the binaries I've seen have the Length
        -: 1157:  // being the entire structure (Certificate included).
        -: 1158:  //
        -: 1159:
    #####: 1160:  while (struct_fits_in_pe(pe, win_cert, WIN_CERTIFICATE) &&
    #####: 1161:         yr_le32toh(win_cert->Length) > sizeof(WIN_CERTIFICATE) &&
    #####: 1162:         fits_in_pe(pe, win_cert, yr_le32toh(win_cert->Length)) &&
    #####: 1163:         (uint8_t*) win_cert + sizeof(WIN_CERTIFICATE) < eod &&
    #####: 1164:         (uint8_t*) win_cert + yr_le32toh(win_cert->Length) <= eod)
        -: 1165:  {
        -: 1166:    BIO* cert_bio;
        -: 1167:    PKCS7* pkcs7;
        -: 1168:    STACK_OF(X509)* certs;
        -: 1169:
        -: 1170:    // Some sanity checks
        -: 1171:
    #####: 1172:    if (yr_le32toh(win_cert->Length) == 0 ||
    #####: 1173:        (yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_1_0 &&
    #####: 1174:         yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_2_0))
        -: 1175:    {
        -: 1176:      break;
        -: 1177:    }
        -: 1178:
        -: 1179:    // Don't support legacy revision for now.
        -: 1180:    // Make sure type is PKCS#7 too.
        -: 1181:
    #####: 1182:    if (yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_2_0 ||
    #####: 1183:        yr_le16toh(win_cert->CertificateType) != WIN_CERT_TYPE_PKCS_SIGNED_DATA)
        -: 1184:    {
    #####: 1185:      uintptr_t end = (uintptr_t)
    #####: 1186:          ((uint8_t *) win_cert) + yr_le32toh(win_cert->Length);
        -: 1187:
    #####: 1188:      win_cert = (PWIN_CERTIFICATE) (end + (end % 8));
    #####: 1189:      continue;
        -: 1190:    }
        -: 1191:
    #####: 1192:    cert_bio = BIO_new_mem_buf(
    #####: 1193:        win_cert->Certificate,
    #####: 1194:        yr_le32toh(win_cert->Length) - WIN_CERTIFICATE_HEADER_SIZE);
        -: 1195:
    #####: 1196:    if (!cert_bio)
    #####: 1197:      break;
        -: 1198:
    #####: 1199:    pkcs7 = d2i_PKCS7_bio(cert_bio, NULL);
    #####: 1200:    certs = PKCS7_get0_signers(pkcs7, NULL, 0);
        -: 1201:
    #####: 1202:    if (!certs)
        -: 1203:    {
    #####: 1204:      BIO_free(cert_bio);
    #####: 1205:      PKCS7_free(pkcs7);
    #####: 1206:      break;
        -: 1207:    }
        -: 1208:
    #####: 1209:    for (i = 0; i < sk_X509_num(certs); i++)
        -: 1210:    {
        -: 1211:      time_t date_time;
        -: 1212:      const char* sig_alg;
        -: 1213:      char buffer[256];
        -: 1214:      int bytes;
    #####: 1215:      const EVP_MD* sha1_digest = EVP_sha1();
        -: 1216:      unsigned char thumbprint[YR_SHA1_LEN];
        -: 1217:      char thumbprint_ascii[YR_SHA1_LEN * 2 + 1];
        -: 1218:
        -: 1219:      ASN1_INTEGER* serial;
        -: 1220:
    #####: 1221:      X509* cert = sk_X509_value(certs, i);
        -: 1222:
    #####: 1223:      X509_digest(cert, sha1_digest, thumbprint, NULL);
        -: 1224:
    #####: 1225:      for (i = 0; i < YR_SHA1_LEN; i++)
    #####: 1226:        sprintf(thumbprint_ascii + (i * 2), "%02x", thumbprint[i]);
        -: 1227:
    #####: 1228:      set_string(
        -: 1229:          (char*) thumbprint_ascii,
        -: 1230:          pe->object,
        -: 1231:          "signatures[%i].thumbprint",
        -: 1232:          counter);
        -: 1233:
    #####: 1234:      X509_NAME_oneline(
    #####: 1235:          X509_get_issuer_name(cert), buffer, sizeof(buffer));
        -: 1236:
    #####: 1237:      set_string(buffer, pe->object, "signatures[%i].issuer", counter);
        -: 1238:
    #####: 1239:      X509_NAME_oneline(
    #####: 1240:          X509_get_subject_name(cert), buffer, sizeof(buffer));
        -: 1241:
    #####: 1242:      set_string(buffer, pe->object, "signatures[%i].subject", counter);
        -: 1243:
    #####: 1244:      set_integer(
        -: 1245:          X509_get_version(cert) + 1, // Versions are zero based, so add one.
        -: 1246:          pe->object,
        -: 1247:          "signatures[%i].version", counter);
        -: 1248:
    #####: 1249:      sig_alg = OBJ_nid2ln(X509_get_signature_nid(cert));
        -: 1250:
    #####: 1251:      set_string(sig_alg, pe->object, "signatures[%i].algorithm", counter);
        -: 1252:
    #####: 1253:      serial = X509_get_serialNumber(cert);
        -: 1254:
    #####: 1255:      if (serial)
        -: 1256:      {
        -: 1257:        // ASN1_INTEGER can be negative (serial->type & V_ASN1_NEG_INTEGER),
        -: 1258:        // in which case the serial number will be stored in 2's complement.
        -: 1259:        //
        -: 1260:        // Handle negative serial numbers, which are technically not allowed
        -: 1261:        // by RFC5280, but do exist. An example binary which has a negative
        -: 1262:        // serial number is: 4bfe05f182aa273e113db6ed7dae4bb8.
        -: 1263:        //
        -: 1264:        // Negative serial numbers are handled by calling i2d_ASN1_INTEGER()
        -: 1265:        // with a NULL second parameter. This will return the size of the
        -: 1266:        // buffer necessary to store the proper serial number.
        -: 1267:        //
        -: 1268:        // Do this even for positive serial numbers because it makes the code
        -: 1269:        // cleaner and easier to read.
        -: 1270:
    #####: 1271:        bytes = i2d_ASN1_INTEGER(serial, NULL);
        -: 1272:
        -: 1273:        // According to X.509 specification the maximum length for the
        -: 1274:        // serial number is 20 octets. Add two bytes to account for
        -: 1275:        // DER type and length information.
        -: 1276:
    #####: 1277:        if (bytes > 2 && bytes <= 22)
        -: 1278:        {
        -: 1279:          // Now that we know the size of the serial number allocate enough
        -: 1280:          // space to hold it, and use i2d_ASN1_INTEGER() one last time to
        -: 1281:          // hold it in the allocated buffer.
        -: 1282:
    #####: 1283:          unsigned char* serial_der = (unsigned char*) yr_malloc(bytes);
        -: 1284:
    #####: 1285:          if (serial_der != NULL)
        -: 1286:          {
        -: 1287:            unsigned char* serial_bytes;
        -: 1288:            char *serial_ascii;
        -: 1289:
    #####: 1290:            bytes = i2d_ASN1_INTEGER(serial, &serial_der);
        -: 1291:
        -: 1292:            // i2d_ASN1_INTEGER() moves the pointer as it writes into
        -: 1293:            // serial_bytes. Move it back.
        -: 1294:
    #####: 1295:            serial_der -= bytes;
        -: 1296:
        -: 1297:            // Skip over DER type, length information
    #####: 1298:            serial_bytes = serial_der + 2;
    #####: 1299:            bytes -= 2;
        -: 1300:
        -: 1301:            // Also allocate space to hold the "common" string format:
        -: 1302:            // 00:01:02:03:04...
        -: 1303:            //
        -: 1304:            // For each byte in the serial to convert to hexlified format we
        -: 1305:            // need three bytes, two for the byte itself and one for colon.
        -: 1306:            // The last one doesn't have the colon, but the extra byte is used
        -: 1307:            // for the NULL terminator.
        -: 1308:
    #####: 1309:            serial_ascii = (char*) yr_malloc(bytes * 3);
        -: 1310:
    #####: 1311:            if (serial_ascii)
        -: 1312:            {
        -: 1313:              int j;
        -: 1314:
    #####: 1315:              for (j = 0; j < bytes; j++)
        -: 1316:              {
        -: 1317:                // Don't put the colon on the last one.
    #####: 1318:                if (j < bytes - 1)
    #####: 1319:                  snprintf(
    #####: 1320:                    serial_ascii + 3 * j, 4, "%02x:", serial_bytes[j]);
        -: 1321:                else
    #####: 1322:                  snprintf(
    #####: 1323:                    serial_ascii + 3 * j, 3, "%02x", serial_bytes[j]);
        -: 1324:              }
        -: 1325:
    #####: 1326:              set_string(
        -: 1327:                  serial_ascii,
        -: 1328:                  pe->object,
        -: 1329:                  "signatures[%i].serial",
        -: 1330:                  counter);
        -: 1331:
    #####: 1332:              yr_free(serial_ascii);
        -: 1333:            }
        -: 1334:
    #####: 1335:            yr_free(serial_der);
        -: 1336:          }
        -: 1337:        }
        -: 1338:      }
        -: 1339:
    #####: 1340:      date_time = ASN1_get_time_t(X509_getm_notBefore(cert));
    #####: 1341:      set_integer(date_time, pe->object, "signatures[%i].not_before", counter);
        -: 1342:
    #####: 1343:      date_time = ASN1_get_time_t(X509_getm_notAfter(cert));
    #####: 1344:      set_integer(date_time, pe->object, "signatures[%i].not_after", counter);
        -: 1345:
    #####: 1346:      counter++;
        -: 1347:    }
        -: 1348:
    #####: 1349:    end = (uintptr_t)((uint8_t *) win_cert) + yr_le32toh(win_cert->Length);
    #####: 1350:    win_cert = (PWIN_CERTIFICATE)(end + (end % 8));
        -: 1351:
    #####: 1352:    BIO_free(cert_bio);
    #####: 1353:    PKCS7_free(pkcs7);
    #####: 1354:    sk_X509_free(certs);
        -: 1355:  }
        -: 1356:
    #####: 1357:  set_integer(counter, pe->object, "number_of_signatures");
        -: 1358:}
        -: 1359:
        -: 1360:#endif  // defined(HAVE_LIBCRYPTO)
        -: 1361:
        -: 1362:
    #####: 1363:static void pe_parse_header(
        -: 1364:    PE* pe,
        -: 1365:    uint64_t base_address,
        -: 1366:    int flags)
        -: 1367:{
        -: 1368:  PIMAGE_SECTION_HEADER section;
        -: 1369:  PIMAGE_DATA_DIRECTORY data_dir;
        -: 1370:
        -: 1371:  char section_name[IMAGE_SIZEOF_SHORT_NAME + 1];
        -: 1372:  int i, scount, ddcount;
        -: 1373:
    #####: 1374:  uint64_t highest_sec_siz = 0;
    #####: 1375:  uint64_t highest_sec_ofs = 0;
        -: 1376:  uint64_t section_end;
        -: 1377:  uint64_t last_section_end;
        -: 1378:
        -: 1379:
    #####: 1380:  set_integer(1, pe->object, "is_pe");
        -: 1381:
    #####: 1382:  set_integer(
        -: 1383:      yr_le16toh(pe->header->FileHeader.Machine),
        -: 1384:      pe->object, "machine");
        -: 1385:
    #####: 1386:  set_integer(
        -: 1387:      yr_le16toh(pe->header->FileHeader.NumberOfSections),
        -: 1388:      pe->object, "number_of_sections");
        -: 1389:
    #####: 1390:  set_integer(
        -: 1391:      yr_le32toh(pe->header->FileHeader.TimeDateStamp),
        -: 1392:      pe->object, "timestamp");
        -: 1393:
    #####: 1394:  set_integer(
        -: 1395:      yr_le32toh(pe->header->FileHeader.PointerToSymbolTable),
        -: 1396:      pe->object, "pointer_to_symbol_table");
        -: 1397:
    #####: 1398:  set_integer(
        -: 1399:      yr_le32toh(pe->header->FileHeader.NumberOfSymbols),
        -: 1400:      pe->object, "number_of_symbols");
        -: 1401:
    #####: 1402:  set_integer(
        -: 1403:      yr_le32toh(pe->header->FileHeader.SizeOfOptionalHeader),
        -: 1404:      pe->object, "size_of_optional_header");
        -: 1405:
    #####: 1406:  set_integer(
        -: 1407:      yr_le16toh(pe->header->FileHeader.Characteristics),
        -: 1408:      pe->object, "characteristics");
        -: 1409:
    #####: 1410:  set_integer(
        -: 1411:      flags & SCAN_FLAGS_PROCESS_MEMORY ?
        -: 1412:      base_address + yr_le32toh(OptionalHeader(pe, AddressOfEntryPoint)) :
        -: 1413:      pe_rva_to_offset(pe, yr_le32toh(OptionalHeader(pe, AddressOfEntryPoint))),
        -: 1414:      pe->object, "entry_point");
        -: 1415:
    #####: 1416:  set_integer(
        -: 1417:      IS_64BITS_PE(pe) ?
        -: 1418:      yr_le64toh(OptionalHeader(pe, ImageBase)) :
        -: 1419:      yr_le32toh(OptionalHeader(pe, ImageBase)),
        -: 1420:      pe->object, "image_base");
        -: 1421:
    #####: 1422:  set_integer(
        -: 1423:      yr_le32toh(OptionalHeader(pe, NumberOfRvaAndSizes)),
        -: 1424:      pe->object, "number_of_rva_and_sizes");
        -: 1425:
    #####: 1426:  set_integer(
        -: 1427:      yr_le32toh(OptionalHeader(pe, Magic)),
        -: 1428:      pe->object, "opthdr_magic");
        -: 1429:
    #####: 1430:  set_integer(
        -: 1431:      OptionalHeader(pe, MajorLinkerVersion),
        -: 1432:      pe->object, "linker_version.major");
        -: 1433:
    #####: 1434:  set_integer(
        -: 1435:      OptionalHeader(pe, MinorLinkerVersion),
        -: 1436:      pe->object, "linker_version.minor");
        -: 1437:
    #####: 1438:  set_integer(
        -: 1439:      yr_le32toh(OptionalHeader(pe, SizeOfCode)),
        -: 1440:      pe->object, "size_of_code");
        -: 1441:
    #####: 1442:  set_integer(
        -: 1443:      yr_le32toh(OptionalHeader(pe, SizeOfInitializedData)),
        -: 1444:      pe->object, "size_of_initialized_data");
        -: 1445:
    #####: 1446:  set_integer(
        -: 1447:      yr_le32toh(OptionalHeader(pe, SizeOfUninitializedData)),
        -: 1448:      pe->object, "size_of_uninitialized_data");
        -: 1449:
    #####: 1450:  set_integer(
        -: 1451:      yr_le32toh(OptionalHeader(pe, BaseOfCode)),
        -: 1452:      pe->object, "base_of_code");
        -: 1453:
    #####: 1454:  if (!IS_64BITS_PE(pe))
        -: 1455:  {
    #####: 1456:      set_integer(
        -: 1457:        yr_le32toh(pe->header->OptionalHeader.BaseOfData),
        -: 1458:        pe->object, "base_of_data");
        -: 1459:  }
        -: 1460:
    #####: 1461:  set_integer(
        -: 1462:      yr_le32toh(OptionalHeader(pe, SectionAlignment)),
        -: 1463:      pe->object, "section_alignment");
        -: 1464:
    #####: 1465:  set_integer(
        -: 1466:      yr_le32toh(OptionalHeader(pe, FileAlignment)),
        -: 1467:      pe->object, "file_alignment");
        -: 1468:
    #####: 1469:  set_integer(
        -: 1470:      yr_le16toh(OptionalHeader(pe, MajorOperatingSystemVersion)),
        -: 1471:      pe->object, "os_version.major");
        -: 1472:
    #####: 1473:  set_integer(
        -: 1474:      yr_le16toh(OptionalHeader(pe, MinorOperatingSystemVersion)),
        -: 1475:      pe->object, "os_version.minor");
        -: 1476:
    #####: 1477:  set_integer(
        -: 1478:      yr_le16toh(OptionalHeader(pe, MajorImageVersion)),
        -: 1479:      pe->object, "image_version.major");
        -: 1480:
    #####: 1481:  set_integer(
        -: 1482:      yr_le16toh(OptionalHeader(pe, MinorImageVersion)),
        -: 1483:      pe->object, "image_version.minor");
        -: 1484:
    #####: 1485:  set_integer(
        -: 1486:      yr_le16toh(OptionalHeader(pe, MajorSubsystemVersion)),
        -: 1487:      pe->object, "subsystem_version.major");
        -: 1488:
    #####: 1489:  set_integer(
        -: 1490:      yr_le16toh(OptionalHeader(pe, MinorSubsystemVersion)),
        -: 1491:      pe->object, "subsystem_version.minor");
        -: 1492:
    #####: 1493:  set_integer(
        -: 1494:      yr_le32toh(OptionalHeader(pe, Win32VersionValue)),
        -: 1495:      pe->object, "win32_version_value");
        -: 1496:
    #####: 1497:  set_integer(
        -: 1498:      yr_le32toh(OptionalHeader(pe, SizeOfImage)),
        -: 1499:      pe->object, "size_of_image");
        -: 1500:
    #####: 1501:  set_integer(
        -: 1502:      yr_le32toh(OptionalHeader(pe, SizeOfHeaders)),
        -: 1503:      pe->object, "size_of_headers");
        -: 1504:
    #####: 1505:  set_integer(
        -: 1506:      yr_le32toh(OptionalHeader(pe, CheckSum)),
        -: 1507:      pe->object, "checksum");
        -: 1508:
    #####: 1509:  set_integer(
        -: 1510:      yr_le16toh(OptionalHeader(pe, Subsystem)),
        -: 1511:      pe->object, "subsystem");
        -: 1512:
    #####: 1513:  set_integer(
        -: 1514:      OptionalHeader(pe, DllCharacteristics),
        -: 1515:      pe->object, "dll_characteristics");
        -: 1516:
    #####: 1517:  set_integer(
        -: 1518:      IS_64BITS_PE(pe) ?
        -: 1519:      yr_le64toh(OptionalHeader(pe, SizeOfStackReserve)) :
        -: 1520:      yr_le32toh(OptionalHeader(pe, SizeOfStackReserve)),
        -: 1521:      pe->object, "size_of_stack_reserve");
        -: 1522:
    #####: 1523:  set_integer(
        -: 1524:      IS_64BITS_PE(pe) ?
        -: 1525:      yr_le64toh(OptionalHeader(pe, SizeOfStackCommit)) :
        -: 1526:      yr_le32toh(OptionalHeader(pe, SizeOfStackCommit)),
        -: 1527:      pe->object, "size_of_stack_commit");
        -: 1528:
    #####: 1529:  set_integer(
        -: 1530:      IS_64BITS_PE(pe) ?
        -: 1531:      yr_le64toh(OptionalHeader(pe, SizeOfHeapReserve)) :
        -: 1532:      yr_le32toh(OptionalHeader(pe, SizeOfHeapReserve)),
        -: 1533:      pe->object, "size_of_heap_reserve");
        -: 1534:
    #####: 1535:  set_integer(
        -: 1536:      IS_64BITS_PE(pe) ?
        -: 1537:      yr_le64toh(OptionalHeader(pe, SizeOfHeapCommit)) :
        -: 1538:      yr_le32toh(OptionalHeader(pe, SizeOfHeapCommit)),
        -: 1539:      pe->object, "size_of_heap_commit");
        -: 1540:
    #####: 1541:  set_integer(
        -: 1542:      yr_le32toh(OptionalHeader(pe, LoaderFlags)),
        -: 1543:      pe->object, "loader_flags");
        -: 1544:
    #####: 1545:  data_dir = IS_64BITS_PE(pe) ?
    #####: 1546:      pe->header64->OptionalHeader.DataDirectory:
    #####: 1547:      pe->header->OptionalHeader.DataDirectory;
        -: 1548:
    #####: 1549:  ddcount = yr_le16toh(OptionalHeader(pe, NumberOfRvaAndSizes));
    #####: 1550:  ddcount = yr_min(ddcount, IMAGE_NUMBEROF_DIRECTORY_ENTRIES);
        -: 1551:
    #####: 1552:  for (i = 0; i < ddcount; i++)
        -: 1553:  {
    #####: 1554:    if (!struct_fits_in_pe(pe, data_dir, IMAGE_DATA_DIRECTORY))
        -: 1555:      break;
        -: 1556:
    #####: 1557:    set_integer(
        -: 1558:      yr_le32toh(data_dir->VirtualAddress),
        -: 1559:      pe->object, "data_directories[%i].virtual_address", i);
        -: 1560:
    #####: 1561:    set_integer(
        -: 1562:      yr_le32toh(data_dir->Size),
        -: 1563:      pe->object, "data_directories[%i].size", i);
        -: 1564:
    #####: 1565:    data_dir++;
        -: 1566:  }
        -: 1567:
    #####: 1568:  pe_iterate_resources(
        -: 1569:      pe,
        -: 1570:      (RESOURCE_CALLBACK_FUNC) pe_collect_resources,
        -: 1571:      (void*) pe);
        -: 1572:
    #####: 1573:  set_integer(pe->resources, pe->object, "number_of_resources");
        -: 1574:
    #####: 1575:  section = IMAGE_FIRST_SECTION(pe->header);
        -: 1576:
    #####: 1577:  scount = yr_min(
        -: 1578:      yr_le16toh(pe->header->FileHeader.NumberOfSections), MAX_PE_SECTIONS);
        -: 1579:
    #####: 1580:  for (i = 0; i < scount; i++)
        -: 1581:  {
    #####: 1582:    if (!struct_fits_in_pe(pe, section, IMAGE_SECTION_HEADER))
        -: 1583:      break;
        -: 1584:
    #####: 1585:    strncpy(section_name, (char*) section->Name, IMAGE_SIZEOF_SHORT_NAME);
    #####: 1586:    section_name[IMAGE_SIZEOF_SHORT_NAME] = '\0';
        -: 1587:
    #####: 1588:    set_string(
        -: 1589:        section_name,
        -: 1590:        pe->object, "sections[%i].name", i);
        -: 1591:
    #####: 1592:    set_integer(
        -: 1593:        yr_le32toh(section->Characteristics),
        -: 1594:        pe->object, "sections[%i].characteristics", i);
        -: 1595:
    #####: 1596:    set_integer(
        -: 1597:        yr_le32toh(section->SizeOfRawData),
        -: 1598:        pe->object, "sections[%i].raw_data_size", i);
        -: 1599:
    #####: 1600:    set_integer(
        -: 1601:        yr_le32toh(section->PointerToRawData),
        -: 1602:        pe->object, "sections[%i].raw_data_offset", i);
        -: 1603:
    #####: 1604:    set_integer(
        -: 1605:        yr_le32toh(section->VirtualAddress),
        -: 1606:        pe->object, "sections[%i].virtual_address", i);
        -: 1607:
    #####: 1608:    set_integer(
        -: 1609:        yr_le32toh(section->Misc.VirtualSize),
        -: 1610:        pe->object, "sections[%i].virtual_size", i);
        -: 1611:
    #####: 1612:    set_integer(
        -: 1613:      yr_le32toh(section->PointerToRelocations),
        -: 1614:      pe->object, "sections[%i].pointer_to_relocations", i);
        -: 1615:
    #####: 1616:    set_integer(
        -: 1617:      yr_le32toh(section->PointerToLinenumbers),
        -: 1618:      pe->object, "sections[%i].pointer_to_line_numbers", i);
        -: 1619:
    #####: 1620:    set_integer(
        -: 1621:      yr_le32toh(section->NumberOfRelocations),
        -: 1622:      pe->object, "sections[%i].number_of_relocations", i);
        -: 1623:
    #####: 1624:    set_integer(
        -: 1625:      yr_le32toh(section->NumberOfLinenumbers),
        -: 1626:      pe->object, "sections[%i].number_of_line_numbers", i);
        -: 1627:
        -: 1628:    // This will catch the section with the highest raw offset to help checking
        -: 1629:    // if overlay data is present. If two sections have the same raw pointer
        -: 1630:    // but different raw sizes the largest one is used. An example of this case
        -: 1631:    // is file: cf62bf1815a93e68e6c5189f689286b66c4088b9507cf3ecf835e4ac3f9ededa
        -: 1632:
    #####: 1633:    section_end = yr_le32toh(section->PointerToRawData) +
    #####: 1634:                  yr_le32toh(section->SizeOfRawData);
        -: 1635:
    #####: 1636:    if (section_end > highest_sec_ofs + highest_sec_siz)
        -: 1637:    {
    #####: 1638:      highest_sec_ofs = yr_le32toh(section->PointerToRawData);
    #####: 1639:      highest_sec_siz = yr_le32toh(section->SizeOfRawData);
        -: 1640:    }
        -: 1641:
    #####: 1642:    section++;
        -: 1643:  }
        -: 1644:
        -: 1645:  // An overlay is data appended to a PE file. Its location is at
        -: 1646:  // RawData + RawOffset of the last section on the physical file
    #####: 1647:  last_section_end = highest_sec_siz + highest_sec_ofs;
        -: 1648:
        -: 1649:  // "overlay.offset" is set to UNDEFINED for files that do not have an overlay
    #####: 1650:  if (last_section_end && (pe->data_size > last_section_end))
    #####: 1651:    set_integer(last_section_end, pe->object, "overlay.offset");
        -: 1652:
        -: 1653:  // "overlay.size" is zero for well formed PE files that don not have an
        -: 1654:  // overlay and UNDEFINED for malformed PE files or non-PE files.
    #####: 1655:  if (last_section_end && (pe->data_size >= last_section_end))
    #####: 1656:    set_integer(pe->data_size - last_section_end, pe->object, "overlay.size");
    #####: 1657:}
        -: 1658:
        -: 1659://
        -: 1660:// Given a posix timestamp argument, make sure not_before <= arg <= not_after
        -: 1661://
        -: 1662:
    #####: 1663:define_function(valid_on)
        -: 1664:{
        -: 1665:  int64_t timestamp;
        -: 1666:  int64_t not_before;
        -: 1667:  int64_t not_after;
        -: 1668:
    #####: 1669:  if (is_undefined(parent(), "not_before") ||
    #####: 1670:      is_undefined(parent(), "not_after"))
        -: 1671:  {
    #####: 1672:    return_integer(UNDEFINED);
        -: 1673:  }
        -: 1674:
    #####: 1675:  timestamp = integer_argument(1);
        -: 1676:
    #####: 1677:  not_before = get_integer(parent(), "not_before");
    #####: 1678:  not_after = get_integer(parent(), "not_after");
        -: 1679:
    #####: 1680:  return_integer(timestamp >= not_before  && timestamp <= not_after);
        -: 1681:}
        -: 1682:
        -: 1683:
    #####: 1684:define_function(section_index_addr)
        -: 1685:{
    #####: 1686:  YR_OBJECT* module = module();
    #####: 1687:  YR_SCAN_CONTEXT* context = scan_context();
        -: 1688:
        -: 1689:  int i;
        -: 1690:  int64_t offset;
        -: 1691:  int64_t size;
        -: 1692:
    #####: 1693:  int64_t addr = integer_argument(1);
    #####: 1694:  int64_t n = get_integer(module, "number_of_sections");
        -: 1695:
    #####: 1696:  if (is_undefined(module, "number_of_sections"))
    #####: 1697:    return_integer(UNDEFINED);
        -: 1698:
    #####: 1699:  for (i = 0; i < yr_min(n, MAX_PE_SECTIONS); i++)
        -: 1700:  {
    #####: 1701:    if (context->flags & SCAN_FLAGS_PROCESS_MEMORY)
        -: 1702:    {
    #####: 1703:      offset = get_integer(module, "sections[%i].virtual_address", i);
    #####: 1704:      size = get_integer(module, "sections[%i].virtual_size", i);
        -: 1705:    }
        -: 1706:    else
        -: 1707:    {
    #####: 1708:      offset = get_integer(module, "sections[%i].raw_data_offset", i);
    #####: 1709:      size = get_integer(module, "sections[%i].raw_data_size", i);
        -: 1710:    }
        -: 1711:
    #####: 1712:    if (addr >= offset && addr < offset + size)
    #####: 1713:      return_integer(i);
        -: 1714:  }
        -: 1715:
    #####: 1716:  return_integer(UNDEFINED);
        -: 1717:}
        -: 1718:
        -: 1719:
    #####: 1720:define_function(section_index_name)
        -: 1721:{
    #####: 1722:  YR_OBJECT* module = module();
        -: 1723:
    #####: 1724:  char* name = string_argument(1);
        -: 1725:
    #####: 1726:  int64_t n = get_integer(module, "number_of_sections");
        -: 1727:  int i;
        -: 1728:
    #####: 1729:  if (is_undefined(module, "number_of_sections"))
    #####: 1730:    return_integer(UNDEFINED);
        -: 1731:
    #####: 1732:  for (i = 0; i < yr_min(n, MAX_PE_SECTIONS); i++)
        -: 1733:  {
    #####: 1734:    SIZED_STRING* sect = get_string(module, "sections[%i].name", i);
        -: 1735:
    #####: 1736:    if (sect != NULL && strcmp(name, sect->c_string) == 0)
    #####: 1737:      return_integer(i);
        -: 1738:  }
        -: 1739:
    #####: 1740:  return_integer(UNDEFINED);
        -: 1741:}
        -: 1742:
        -: 1743:
    #####: 1744:define_function(exports)
        -: 1745:{
    #####: 1746:  SIZED_STRING* function_name = sized_string_argument(1);
        -: 1747:
    #####: 1748:  YR_OBJECT* module = module();
    #####: 1749:  PE* pe = (PE*) module->data;
        -: 1750:
        -: 1751:  int i;
        -: 1752:
        -: 1753:  // If not a PE, return UNDEFINED.
    #####: 1754:  if (pe == NULL)
    #####: 1755:    return_integer(UNDEFINED);
        -: 1756:
        -: 1757:  // If PE, but not exported functions, return false.
    #####: 1758:  if (pe->exported_functions == NULL)
    #####: 1759:    return_integer(0);
        -: 1760:
    #####: 1761:  for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 1762:  {
    #####: 1763:    if (pe->exported_functions->functions[i].name &&
    #####: 1764:        strcasecmp(pe->exported_functions->functions[i].name, function_name->c_string) == 0)
        -: 1765:    {
    #####: 1766:      return_integer(1);
        -: 1767:    }
        -: 1768:  }
        -: 1769:
    #####: 1770:  return_integer(0);
        -: 1771:}
        -: 1772:
        -: 1773:
    #####: 1774:define_function(exports_regexp)
        -: 1775:{
    #####: 1776:  RE* regex = regexp_argument(1);
        -: 1777:
    #####: 1778:  YR_OBJECT* module = module();
    #####: 1779:  PE* pe = (PE*) module->data;
        -: 1780:
        -: 1781:  int i;
        -: 1782:
        -: 1783:  // If not a PE, return UNDEFINED.
    #####: 1784:  if (pe == NULL)
    #####: 1785:    return_integer(UNDEFINED);
        -: 1786:
        -: 1787:  // If PE, but not exported functions, return false.
    #####: 1788:  if (pe->exported_functions == NULL)
    #####: 1789:    return_integer(0);
        -: 1790:
    #####: 1791:  for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 1792:  {
    #####: 1793:    if (pe->exported_functions->functions[i].name &&
    #####: 1794:        yr_re_match(scan_context(), regex, pe->exported_functions->functions[i].name) != -1)
        -: 1795:    {
    #####: 1796:      return_integer(1);
        -: 1797:    }
        -: 1798:  }
        -: 1799:
    #####: 1800:  return_integer(0);
        -: 1801:}
        -: 1802:
        -: 1803:
    #####: 1804:define_function(exports_ordinal)
        -: 1805:{
    #####: 1806:  uint64_t ordinal = integer_argument(1);
        -: 1807:
    #####: 1808:  YR_OBJECT* module = module();
    #####: 1809:  PE* pe = (PE*) module->data;
        -: 1810:
        -: 1811:  // If not a PE, return UNDEFINED.
    #####: 1812:  if (pe == NULL)
    #####: 1813:    return_integer(UNDEFINED);
        -: 1814:
        -: 1815:  // If PE, but not exported functions, return false.
    #####: 1816:  if (pe->exported_functions == NULL)
    #####: 1817:    return_integer(0);
        -: 1818:
    #####: 1819:  if (ordinal == 0 || ordinal > pe->exported_functions->number_of_exports)
    #####: 1820:    return_integer(0);
        -: 1821:
        -: 1822:  // Just in case, this should always be true
    #####: 1823:  if (pe->exported_functions->functions[ordinal - 1].ordinal == ordinal)
    #####: 1824:    return_integer(1);
        -: 1825:
    #####: 1826:  return_integer(0);
        -: 1827:}
        -: 1828:
        -: 1829:#if defined(HAVE_LIBCRYPTO) || \
        -: 1830:    defined(HAVE_WINCRYPT_H) || \
        -: 1831:    defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
        -: 1832:
        -: 1833://
        -: 1834:// Generate an import hash:
        -: 1835:// https://www.mandiant.com/blog/tracking-malware-import-hashing/
        -: 1836:// It is important to make duplicates of the strings as we don't want
        -: 1837:// to alter the contents of the parsed import structures.
        -: 1838://
        -: 1839:
    #####: 1840:define_function(imphash)
        -: 1841:{
    #####: 1842:  YR_OBJECT* module = module();
        -: 1843:
        -: 1844:  IMPORTED_DLL* dll;
        -: 1845:  yr_md5_ctx ctx;
        -: 1846:
        -: 1847:  unsigned char digest[YR_MD5_LEN];
        -: 1848:  char* digest_ascii;
        -: 1849:
        -: 1850:  size_t i;
    #####: 1851:  bool first = true;
        -: 1852:
    #####: 1853:  PE* pe = (PE*) module->data;
        -: 1854:
        -: 1855:  // If not a PE, return UNDEFINED.
        -: 1856:
    #####: 1857:  if (!pe)
    #####: 1858:    return_string(UNDEFINED);
        -: 1859:
        -: 1860:  // Lookup in cache first.
    #####: 1861:  digest_ascii = (char*) yr_hash_table_lookup(
        -: 1862:      pe->hash_table,
        -: 1863:      "imphash",
        -: 1864:      NULL);
        -: 1865:
    #####: 1866:  if (digest_ascii != NULL)
    #####: 1867:    return_string(digest_ascii);
        -: 1868:
    #####: 1869:  yr_md5_init(&ctx);
        -: 1870:
    #####: 1871:  dll = pe->imported_dlls;
        -: 1872:
    #####: 1873:  while (dll)
        -: 1874:  {
        -: 1875:    IMPORT_FUNCTION* func;
        -: 1876:
        -: 1877:    size_t dll_name_len;
        -: 1878:    char* dll_name;
        -: 1879:
        -: 1880:    // If extension is 'ocx', 'sys' or 'dll', chop it.
        -: 1881:
    #####: 1882:    char* ext = strstr(dll->name, ".");
        -: 1883:
    #####: 1884:    if (ext && (strncasecmp(ext, ".ocx", 4) == 0 ||
    #####: 1885:                strncasecmp(ext, ".sys", 4) == 0 ||
    #####: 1886:                strncasecmp(ext, ".dll", 4) == 0))
        -: 1887:    {
    #####: 1888:      dll_name_len = (ext - dll->name);
        -: 1889:    }
        -: 1890:    else
        -: 1891:    {
    #####: 1892:      dll_name_len = strlen(dll->name);
        -: 1893:    }
        -: 1894:
        -: 1895:    // Allocate a new string to hold the dll name.
        -: 1896:
    #####: 1897:    dll_name = (char *) yr_malloc(dll_name_len + 1);
        -: 1898:
    #####: 1899:    if (!dll_name)
    #####: 1900:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1901:
    #####: 1902:    strlcpy(dll_name, dll->name, dll_name_len + 1);
        -: 1903:
    #####: 1904:    func = dll->functions;
        -: 1905:
    #####: 1906:    while (func)
        -: 1907:    {
        -: 1908:      char* final_name;
    #####: 1909:      size_t final_name_len = dll_name_len + strlen(func->name) + 1;
        -: 1910:
    #####: 1911:      if (!first)
    #####: 1912:        final_name_len++;   // Additional byte to accommodate the extra comma
        -: 1913:
    #####: 1914:      final_name = (char*) yr_malloc(final_name_len + 1);
        -: 1915:
    #####: 1916:      if (final_name == NULL)
    #####: 1917:        break;
        -: 1918:
    #####: 1919:      sprintf(final_name, first ? "%s.%s": ",%s.%s", dll_name, func->name);
        -: 1920:
        -: 1921:      // Lowercase the whole thing.
        -: 1922:
    #####: 1923:      for (i = 0; i < final_name_len; i++)
    #####: 1924:        final_name[i] = tolower(final_name[i]);
        -: 1925:
    #####: 1926:      yr_md5_update(&ctx, final_name, final_name_len);
        -: 1927:
    #####: 1928:      yr_free(final_name);
        -: 1929:
    #####: 1930:      func = func->next;
    #####: 1931:      first = false;
        -: 1932:    }
        -: 1933:
    #####: 1934:    yr_free(dll_name);
        -: 1935:
    #####: 1936:    dll = dll->next;
        -: 1937:  }
        -: 1938:
    #####: 1939:  yr_md5_final(digest, &ctx);
        -: 1940:
    #####: 1941:  digest_ascii = (char*) yr_malloc(YR_MD5_LEN * 2 + 1);
        -: 1942:
    #####: 1943:  if (digest_ascii == NULL)
    #####: 1944:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1945:
        -: 1946:  // Transform the binary digest to ascii
        -: 1947:
    #####: 1948:  for (i = 0; i < YR_MD5_LEN; i++)
        -: 1949:  {
    #####: 1950:    sprintf(digest_ascii + (i * 2), "%02x", digest[i]);
        -: 1951:  }
        -: 1952:
    #####: 1953:  digest_ascii[YR_MD5_LEN * 2] = '\0';
        -: 1954:
    #####: 1955:  yr_hash_table_add(pe->hash_table, "imphash", NULL, digest_ascii);
        -: 1956:
    #####: 1957:  return_string(digest_ascii);
        -: 1958:}
        -: 1959:
        -: 1960:#endif  // defined(HAVE_LIBCRYPTO) || defined(HAVE_WINCRYPT_H)
        -: 1961:
        -: 1962:
    #####: 1963:define_function(imports)
        -: 1964:{
    #####: 1965:  char* dll_name = string_argument(1);
    #####: 1966:  char* function_name = string_argument(2);
        -: 1967:
    #####: 1968:  YR_OBJECT* module = module();
    #####: 1969:  PE* pe = (PE*) module->data;
        -: 1970:
        -: 1971:  IMPORTED_DLL* imported_dll;
        -: 1972:
    #####: 1973:  if (!pe)
    #####: 1974:    return_integer(UNDEFINED);
        -: 1975:
    #####: 1976:  imported_dll = pe->imported_dlls;
        -: 1977:
    #####: 1978:  while (imported_dll != NULL)
        -: 1979:  {
    #####: 1980:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 1981:    {
    #####: 1982:      IMPORT_FUNCTION* imported_func = imported_dll->functions;
        -: 1983:
    #####: 1984:      while (imported_func != NULL)
        -: 1985:      {
    #####: 1986:        if (imported_func->name &&
    #####: 1987:            strcasecmp(imported_func->name, function_name) == 0)
    #####: 1988:          return_integer(1);
        -: 1989:
    #####: 1990:        imported_func = imported_func->next;
        -: 1991:      }
        -: 1992:    }
        -: 1993:
    #####: 1994:    imported_dll = imported_dll->next;
        -: 1995:  }
        -: 1996:
    #####: 1997:  return_integer(0);
        -: 1998:}
        -: 1999:
    #####: 2000:define_function(imports_ordinal)
        -: 2001:{
    #####: 2002:  char* dll_name = string_argument(1);
    #####: 2003:  uint64_t ordinal = integer_argument(2);
        -: 2004:
    #####: 2005:  YR_OBJECT* module = module();
    #####: 2006:  PE* pe = (PE*) module->data;
        -: 2007:
        -: 2008:  IMPORTED_DLL* imported_dll;
        -: 2009:
    #####: 2010:  if (!pe)
    #####: 2011:    return_integer(UNDEFINED);
        -: 2012:
    #####: 2013:  imported_dll = pe->imported_dlls;
        -: 2014:
    #####: 2015:  while (imported_dll != NULL)
        -: 2016:  {
    #####: 2017:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 2018:    {
    #####: 2019:      IMPORT_FUNCTION* imported_func = imported_dll->functions;
        -: 2020:
    #####: 2021:      while (imported_func != NULL)
        -: 2022:      {
    #####: 2023:        if (imported_func->has_ordinal && imported_func->ordinal == ordinal)
    #####: 2024:          return_integer(1);
        -: 2025:
    #####: 2026:        imported_func = imported_func->next;
        -: 2027:      }
        -: 2028:    }
        -: 2029:
    #####: 2030:    imported_dll = imported_dll->next;
        -: 2031:  }
        -: 2032:
    #####: 2033:  return_integer(0);
        -: 2034:}
        -: 2035:
    #####: 2036:define_function(imports_regex)
        -: 2037:{
    #####: 2038:  YR_OBJECT* module = module();
    #####: 2039:  PE* pe = (PE*)module->data;
        -: 2040:
        -: 2041:  IMPORTED_DLL* imported_dll;
        -: 2042:
    #####: 2043:  if (!pe)
    #####: 2044:    return_integer(UNDEFINED);
        -: 2045:
    #####: 2046:  imported_dll = pe->imported_dlls;
        -: 2047:
    #####: 2048:  while (imported_dll != NULL)
        -: 2049:  {
    #####: 2050:    if (yr_re_match(scan_context(), regexp_argument(1), imported_dll->name) > 0)
        -: 2051:    {
    #####: 2052:      IMPORT_FUNCTION* imported_func = imported_dll->functions;
        -: 2053:
    #####: 2054:      while (imported_func != NULL)
        -: 2055:      {
    #####: 2056:        if (yr_re_match(scan_context(), regexp_argument(2), imported_func->name) > 0)
    #####: 2057:          return_integer(1);
    #####: 2058:        imported_func = imported_func->next;
        -: 2059:      }
        -: 2060:    }
        -: 2061:
    #####: 2062:    imported_dll = imported_dll->next;
        -: 2063:  }
        -: 2064:
    #####: 2065:  return_integer(0);
        -: 2066:}
        -: 2067:
    #####: 2068:define_function(imports_dll)
        -: 2069:{
    #####: 2070:  char* dll_name = string_argument(1);
        -: 2071:
    #####: 2072:  YR_OBJECT* module = module();
    #####: 2073:  PE* pe = (PE*) module->data;
        -: 2074:
        -: 2075:  IMPORTED_DLL* imported_dll;
        -: 2076:
    #####: 2077:  if (!pe)
    #####: 2078:    return_integer(UNDEFINED);
        -: 2079:
    #####: 2080:  imported_dll = pe->imported_dlls;
        -: 2081:
    #####: 2082:  while (imported_dll != NULL)
        -: 2083:  {
    #####: 2084:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 2085:    {
    #####: 2086:      return_integer(1);
        -: 2087:    }
        -: 2088:
    #####: 2089:    imported_dll = imported_dll->next;
        -: 2090:  }
        -: 2091:
    #####: 2092:  return_integer(0);
        -: 2093:}
        -: 2094:
    #####: 2095:define_function(locale)
        -: 2096:{
    #####: 2097:  YR_OBJECT* module = module();
    #####: 2098:  PE* pe = (PE*) module->data;
        -: 2099:
    #####: 2100:  uint64_t locale = integer_argument(1);
        -: 2101:  int n, i;
        -: 2102:
    #####: 2103:  if (is_undefined(module, "number_of_resources"))
    #####: 2104:    return_integer(UNDEFINED);
        -: 2105:
        -: 2106:  // If not a PE file, return UNDEFINED
        -: 2107:
    #####: 2108:  if (pe == NULL)
    #####: 2109:    return_integer(UNDEFINED);
        -: 2110:
    #####: 2111:  n = get_integer(module, "number_of_resources");
        -: 2112:
    #####: 2113:  for (i = 0; i < n; i++)
        -: 2114:  {
    #####: 2115:    uint64_t rsrc_language = get_integer(module, "resources[%i].language", i);
        -: 2116:
    #####: 2117:    if ((rsrc_language & 0xFFFF) == locale)
    #####: 2118:      return_integer(1);
        -: 2119:  }
        -: 2120:
    #####: 2121:  return_integer(0);
        -: 2122:}
        -: 2123:
        -: 2124:
    #####: 2125:define_function(language)
        -: 2126:{
    #####: 2127:  YR_OBJECT* module = module();
    #####: 2128:  PE* pe = (PE*) module->data;
        -: 2129:
    #####: 2130:  uint64_t language = integer_argument(1);
        -: 2131:  int n, i;
        -: 2132:
    #####: 2133:  if (is_undefined(module, "number_of_resources"))
    #####: 2134:    return_integer(UNDEFINED);
        -: 2135:
        -: 2136:  // If not a PE file, return UNDEFINED
        -: 2137:
    #####: 2138:  if (pe == NULL)
    #####: 2139:    return_integer(UNDEFINED);
        -: 2140:
    #####: 2141:  n = get_integer(module, "number_of_resources");
        -: 2142:
    #####: 2143:  for (i = 0; i < n; i++)
        -: 2144:  {
    #####: 2145:    uint64_t rsrc_language = get_integer(module, "resources[%i].language", i);
        -: 2146:
    #####: 2147:    if ((rsrc_language & 0xFF) == language)
    #####: 2148:      return_integer(1);
        -: 2149:  }
        -: 2150:
    #####: 2151:  return_integer(0);
        -: 2152:}
        -: 2153:
        -: 2154:
    #####: 2155:define_function(is_dll)
        -: 2156:{
        -: 2157:  int64_t characteristics;
    #####: 2158:  YR_OBJECT* module = module();
        -: 2159:
    #####: 2160:  if (is_undefined(module, "characteristics"))
    #####: 2161:    return_integer(UNDEFINED);
        -: 2162:
    #####: 2163:  characteristics = get_integer(module, "characteristics");
    #####: 2164:  return_integer(characteristics & IMAGE_FILE_DLL);
        -: 2165:}
        -: 2166:
        -: 2167:
    #####: 2168:define_function(is_32bit)
        -: 2169:{
    #####: 2170:  YR_OBJECT* module = module();
    #####: 2171:  PE* pe = (PE*) module->data;
        -: 2172:
    #####: 2173:  if (pe == NULL)
    #####: 2174:    return_integer(UNDEFINED);
        -: 2175:
    #####: 2176:  return_integer(IS_64BITS_PE(pe) ? 0 : 1);
        -: 2177:}
        -: 2178:
        -: 2179:
    #####: 2180:define_function(is_64bit)
        -: 2181:{
    #####: 2182:  YR_OBJECT* module = module();
    #####: 2183:  PE* pe = (PE*) module->data;
        -: 2184:
    #####: 2185:  if (pe == NULL)
    #####: 2186:    return_integer(UNDEFINED);
        -: 2187:
    #####: 2188:  return_integer(IS_64BITS_PE(pe) ? 1 : 0);
        -: 2189:}
        -: 2190:
        -: 2191:
    #####: 2192:static uint64_t rich_internal(
        -: 2193:    YR_OBJECT* module,
        -: 2194:    uint64_t version,
        -: 2195:    uint64_t toolid)
        -: 2196:{
        -: 2197:  int64_t rich_length;
        -: 2198:  int64_t rich_count;
        -: 2199:  int i;
        -: 2200:
        -: 2201:  PRICH_SIGNATURE clear_rich_signature;
        -: 2202:  SIZED_STRING* rich_string;
        -: 2203:
        -: 2204:  // Check if the required fields are set
    #####: 2205:  if (is_undefined(module, "rich_signature.length"))
    #####: 2206:      return UNDEFINED;
        -: 2207:
    #####: 2208:  rich_length = get_integer(module, "rich_signature.length");
    #####: 2209:  rich_string = get_string(module, "rich_signature.clear_data");
        -: 2210:
        -: 2211:  // If the clear_data was not set, return UNDEFINED
    #####: 2212:  if (rich_string == NULL)
    #####: 2213:      return UNDEFINED;
        -: 2214:
    #####: 2215:  if (version == UNDEFINED && toolid == UNDEFINED)
    #####: 2216:      return false;
        -: 2217:
    #####: 2218:  clear_rich_signature = (PRICH_SIGNATURE) rich_string->c_string;
        -: 2219:
        -: 2220:  // Loop over the versions in the rich signature
        -: 2221:
    #####: 2222:  rich_count = \
    #####: 2223:      (rich_length - sizeof(RICH_SIGNATURE)) / sizeof(RICH_VERSION_INFO);
        -: 2224:
    #####: 2225:  for (i = 0; i < rich_count; i++)
        -: 2226:  {
    #####: 2227:    DWORD id_version = yr_le32toh(clear_rich_signature->versions[i].id_version);
        -: 2228:
    #####: 2229:    int match_version = (version == RICH_VERSION_VERSION(id_version));
    #####: 2230:    int match_toolid = (toolid == RICH_VERSION_ID(id_version));
        -: 2231:
    #####: 2232:    if (version != UNDEFINED && toolid != UNDEFINED)
        -: 2233:    {
        -: 2234:      // check version and toolid
    #####: 2235:      if (match_version && match_toolid)
    #####: 2236:        return true;
        -: 2237:    }
    #####: 2238:    else if (version != UNDEFINED)
        -: 2239:    {
        -: 2240:      // check only version
    #####: 2241:      if (match_version)
    #####: 2242:        return true;
        -: 2243:    }
    #####: 2244:    else if (toolid != UNDEFINED)
        -: 2245:    {
        -: 2246:      // check only toolid
    #####: 2247:      if (match_toolid)
    #####: 2248:        return true;
        -: 2249:    }
        -: 2250:  }
        -: 2251:
    #####: 2252:  return false;
        -: 2253:}
        -: 2254:
        -: 2255:
    #####: 2256:define_function(rich_version)
        -: 2257:{
    #####: 2258:  return_integer(
        -: 2259:      rich_internal(module(), integer_argument(1), UNDEFINED));
        -: 2260:}
        -: 2261:
        -: 2262:
    #####: 2263:define_function(rich_version_toolid)
        -: 2264:{
    #####: 2265:  return_integer(
        -: 2266:      rich_internal(module(), integer_argument(1), integer_argument(2)));
        -: 2267:}
        -: 2268:
        -: 2269:
    #####: 2270:define_function(rich_toolid)
        -: 2271:{
    #####: 2272:  return_integer(
        -: 2273:      rich_internal(module(), UNDEFINED, integer_argument(1)));
        -: 2274:}
        -: 2275:
        -: 2276:
    #####: 2277:define_function(rich_toolid_version)
        -: 2278:{
    #####: 2279:  return_integer(
        -: 2280:      rich_internal(module(), integer_argument(2), integer_argument(1)));
        -: 2281:}
        -: 2282:
        -: 2283:
    #####: 2284:define_function(calculate_checksum)
        -: 2285:{
    #####: 2286:  YR_OBJECT* module = module();
    #####: 2287:  PE* pe = (PE*) module->data;
        -: 2288:
    #####: 2289:  uint64_t csum = 0;
        -: 2290:  size_t csum_offset;
        -: 2291:  size_t i, j;
        -: 2292:
    #####: 2293:  if (pe == NULL)
    #####: 2294:    return_integer(UNDEFINED);
        -: 2295:
    #####: 2296:  csum_offset = ((uint8_t*) &(pe->header->OptionalHeader) +
    #####: 2297:      offsetof(IMAGE_OPTIONAL_HEADER32, CheckSum)) - pe->data;
        -: 2298:
    #####: 2299:  for (i = 0; i <= pe->data_size / 4; i++)
        -: 2300:  {
        -: 2301:    // Treat the CheckSum field as 0 -- the offset is the same for
        -: 2302:    // PE32 and PE64.
        -: 2303:
    #####: 2304:    if (4 * i == csum_offset)
    #####: 2305:      continue;
        -: 2306:
    #####: 2307:    if (4 * i + 4 <= pe->data_size)
        -: 2308:    {
    #####: 2309:      csum += ((uint64_t) pe->data[4 * i] +
    #####: 2310:          ((uint64_t) pe->data[4 * i + 1] << 8)  +
    #####: 2311:          ((uint64_t) pe->data[4 * i + 2] << 16) +
    #####: 2312:          ((uint64_t) pe->data[4 * i + 3] << 24));
        -: 2313:    }
        -: 2314:    else
        -: 2315:    {
    #####: 2316:      for (j = 0; j < pe->data_size % 4; j++)
    #####: 2317:        csum += (uint64_t) pe->data[4 * i + j] << (8 * j);
        -: 2318:    }
        -: 2319:
    #####: 2320:    if (csum > 0xffffffff)
    #####: 2321:      csum = (csum & 0xffffffff) + (csum >> 32);
        -: 2322:  }
        -: 2323:
    #####: 2324:  csum = (csum & 0xffff) + (csum >> 16);
    #####: 2325:  csum += (csum >> 16);
    #####: 2326:  csum &= 0xffff;
    #####: 2327:  csum += pe->data_size;
        -: 2328:
    #####: 2329:  return_integer(csum);
        -: 2330:}
        -: 2331:
        -: 2332:
    #####: 2333:define_function(rva_to_offset)
        -: 2334:{
    #####: 2335:  YR_OBJECT* module = module();
    #####: 2336:  PE* pe = (PE*) module->data;
        -: 2337:
        -: 2338:  uint64_t rva, offset;
        -: 2339:
    #####: 2340:  if (pe == NULL)
    #####: 2341:    return_integer(UNDEFINED);
        -: 2342:
    #####: 2343:  rva = integer_argument(1);
    #####: 2344:  offset = pe_rva_to_offset(pe, rva);
    #####: 2345:  if (offset == -1)
    #####: 2346:    return_integer(UNDEFINED);
        -: 2347:
    #####: 2348:  return_integer(offset);
        -: 2349:}
        -: 2350:
        -: 2351:
    #####: 2352:begin_declarations;
        -: 2353:
    #####: 2354:  declare_integer("MACHINE_UNKNOWN");
    #####: 2355:  declare_integer("MACHINE_AM33");
    #####: 2356:  declare_integer("MACHINE_AMD64");
    #####: 2357:  declare_integer("MACHINE_ARM");
    #####: 2358:  declare_integer("MACHINE_ARMNT");
    #####: 2359:  declare_integer("MACHINE_ARM64");
    #####: 2360:  declare_integer("MACHINE_EBC");
    #####: 2361:  declare_integer("MACHINE_I386");
    #####: 2362:  declare_integer("MACHINE_IA64");
    #####: 2363:  declare_integer("MACHINE_M32R");
    #####: 2364:  declare_integer("MACHINE_MIPS16");
    #####: 2365:  declare_integer("MACHINE_MIPSFPU");
    #####: 2366:  declare_integer("MACHINE_MIPSFPU16");
    #####: 2367:  declare_integer("MACHINE_POWERPC");
    #####: 2368:  declare_integer("MACHINE_POWERPCFP");
    #####: 2369:  declare_integer("MACHINE_R4000");
    #####: 2370:  declare_integer("MACHINE_SH3");
    #####: 2371:  declare_integer("MACHINE_SH3DSP");
    #####: 2372:  declare_integer("MACHINE_SH4");
    #####: 2373:  declare_integer("MACHINE_SH5");
    #####: 2374:  declare_integer("MACHINE_THUMB");
    #####: 2375:  declare_integer("MACHINE_WCEMIPSV2");
        -: 2376:
    #####: 2377:  declare_integer("SUBSYSTEM_UNKNOWN");
    #####: 2378:  declare_integer("SUBSYSTEM_NATIVE");
    #####: 2379:  declare_integer("SUBSYSTEM_WINDOWS_GUI");
    #####: 2380:  declare_integer("SUBSYSTEM_WINDOWS_CUI");
    #####: 2381:  declare_integer("SUBSYSTEM_OS2_CUI");
    #####: 2382:  declare_integer("SUBSYSTEM_POSIX_CUI");
    #####: 2383:  declare_integer("SUBSYSTEM_NATIVE_WINDOWS");
    #####: 2384:  declare_integer("SUBSYSTEM_WINDOWS_CE_GUI");
    #####: 2385:  declare_integer("SUBSYSTEM_EFI_APPLICATION");
    #####: 2386:  declare_integer("SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER");
    #####: 2387:  declare_integer("SUBSYSTEM_EFI_RUNTIME_DRIVER");
    #####: 2388:  declare_integer("SUBSYSTEM_XBOX");
    #####: 2389:  declare_integer("SUBSYSTEM_WINDOWS_BOOT_APPLICATION");
        -: 2390:
    #####: 2391:  declare_integer("DYNAMIC_BASE");
    #####: 2392:  declare_integer("FORCE_INTEGRITY");
    #####: 2393:  declare_integer("NX_COMPAT");
    #####: 2394:  declare_integer("NO_ISOLATION");
    #####: 2395:  declare_integer("NO_SEH");
    #####: 2396:  declare_integer("NO_BIND");
    #####: 2397:  declare_integer("WDM_DRIVER");
    #####: 2398:  declare_integer("TERMINAL_SERVER_AWARE");
        -: 2399:
    #####: 2400:  declare_integer("RELOCS_STRIPPED");
    #####: 2401:  declare_integer("EXECUTABLE_IMAGE");
    #####: 2402:  declare_integer("LINE_NUMS_STRIPPED");
    #####: 2403:  declare_integer("LOCAL_SYMS_STRIPPED");
    #####: 2404:  declare_integer("AGGRESIVE_WS_TRIM");
    #####: 2405:  declare_integer("LARGE_ADDRESS_AWARE");
    #####: 2406:  declare_integer("BYTES_REVERSED_LO");
    #####: 2407:  declare_integer("MACHINE_32BIT");
    #####: 2408:  declare_integer("DEBUG_STRIPPED");
    #####: 2409:  declare_integer("REMOVABLE_RUN_FROM_SWAP");
    #####: 2410:  declare_integer("NET_RUN_FROM_SWAP");
    #####: 2411:  declare_integer("SYSTEM");
    #####: 2412:  declare_integer("DLL");
    #####: 2413:  declare_integer("UP_SYSTEM_ONLY");
    #####: 2414:  declare_integer("BYTES_REVERSED_HI");
        -: 2415:
    #####: 2416:  declare_integer("IMAGE_DIRECTORY_ENTRY_EXPORT");
    #####: 2417:  declare_integer("IMAGE_DIRECTORY_ENTRY_IMPORT");
    #####: 2418:  declare_integer("IMAGE_DIRECTORY_ENTRY_RESOURCE");
    #####: 2419:  declare_integer("IMAGE_DIRECTORY_ENTRY_EXCEPTION");
    #####: 2420:  declare_integer("IMAGE_DIRECTORY_ENTRY_SECURITY");
    #####: 2421:  declare_integer("IMAGE_DIRECTORY_ENTRY_BASERELOC");
    #####: 2422:  declare_integer("IMAGE_DIRECTORY_ENTRY_DEBUG");
    #####: 2423:  declare_integer("IMAGE_DIRECTORY_ENTRY_ARCHITECTURE");
    #####: 2424:  declare_integer("IMAGE_DIRECTORY_ENTRY_GLOBALPTR");
    #####: 2425:  declare_integer("IMAGE_DIRECTORY_ENTRY_TLS");
    #####: 2426:  declare_integer("IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG");
    #####: 2427:  declare_integer("IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT");
    #####: 2428:  declare_integer("IMAGE_DIRECTORY_ENTRY_IAT");
    #####: 2429:  declare_integer("IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT");
    #####: 2430:  declare_integer("IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR");
        -: 2431:
    #####: 2432:  declare_integer("SECTION_CNT_CODE");
    #####: 2433:  declare_integer("SECTION_CNT_INITIALIZED_DATA");
    #####: 2434:  declare_integer("SECTION_CNT_UNINITIALIZED_DATA");
    #####: 2435:  declare_integer("SECTION_GPREL");
    #####: 2436:  declare_integer("SECTION_MEM_16BIT");
    #####: 2437:  declare_integer("SECTION_LNK_NRELOC_OVFL");
    #####: 2438:  declare_integer("SECTION_MEM_DISCARDABLE");
    #####: 2439:  declare_integer("SECTION_MEM_NOT_CACHED");
    #####: 2440:  declare_integer("SECTION_MEM_NOT_PAGED");
    #####: 2441:  declare_integer("SECTION_MEM_SHARED");
    #####: 2442:  declare_integer("SECTION_MEM_EXECUTE");
    #####: 2443:  declare_integer("SECTION_MEM_READ");
    #####: 2444:  declare_integer("SECTION_MEM_WRITE");
        -: 2445:
    #####: 2446:  declare_integer("RESOURCE_TYPE_CURSOR");
    #####: 2447:  declare_integer("RESOURCE_TYPE_BITMAP");
    #####: 2448:  declare_integer("RESOURCE_TYPE_ICON");
    #####: 2449:  declare_integer("RESOURCE_TYPE_MENU");
    #####: 2450:  declare_integer("RESOURCE_TYPE_DIALOG");
    #####: 2451:  declare_integer("RESOURCE_TYPE_STRING");
    #####: 2452:  declare_integer("RESOURCE_TYPE_FONTDIR");
    #####: 2453:  declare_integer("RESOURCE_TYPE_FONT");
    #####: 2454:  declare_integer("RESOURCE_TYPE_ACCELERATOR");
    #####: 2455:  declare_integer("RESOURCE_TYPE_RCDATA");
    #####: 2456:  declare_integer("RESOURCE_TYPE_MESSAGETABLE");
    #####: 2457:  declare_integer("RESOURCE_TYPE_GROUP_CURSOR");
    #####: 2458:  declare_integer("RESOURCE_TYPE_GROUP_ICON");
    #####: 2459:  declare_integer("RESOURCE_TYPE_VERSION");
    #####: 2460:  declare_integer("RESOURCE_TYPE_DLGINCLUDE");
    #####: 2461:  declare_integer("RESOURCE_TYPE_PLUGPLAY");
    #####: 2462:  declare_integer("RESOURCE_TYPE_VXD");
    #####: 2463:  declare_integer("RESOURCE_TYPE_ANICURSOR");
    #####: 2464:  declare_integer("RESOURCE_TYPE_ANIICON");
    #####: 2465:  declare_integer("RESOURCE_TYPE_HTML");
    #####: 2466:  declare_integer("RESOURCE_TYPE_MANIFEST");
        -: 2467:
        -: 2468:
    #####: 2469:  declare_integer("is_pe");
    #####: 2470:  declare_integer("machine");
    #####: 2471:  declare_integer("number_of_sections");
    #####: 2472:  declare_integer("timestamp");
    #####: 2473:  declare_integer("pointer_to_symbol_table");
    #####: 2474:  declare_integer("number_of_symbols");
    #####: 2475:  declare_integer("size_of_optional_header");
    #####: 2476:  declare_integer("characteristics");
        -: 2477:
    #####: 2478:  declare_integer("entry_point");
    #####: 2479:  declare_integer("image_base");
    #####: 2480:  declare_integer("number_of_rva_and_sizes");
        -: 2481:
    #####: 2482:  declare_string_dictionary("version_info");
        -: 2483:
    #####: 2484:  declare_integer("opthdr_magic");
    #####: 2485:  declare_integer("size_of_code");
    #####: 2486:  declare_integer("size_of_initialized_data");
    #####: 2487:  declare_integer("size_of_uninitialized_data");
    #####: 2488:  declare_integer("base_of_code");
    #####: 2489:  declare_integer("base_of_data");
    #####: 2490:  declare_integer("section_alignment");
    #####: 2491:  declare_integer("file_alignment");
        -: 2492:
    #####: 2493:  begin_struct("linker_version");
    #####: 2494:    declare_integer("major");
    #####: 2495:    declare_integer("minor");
    #####: 2496:  end_struct("linker_version");
        -: 2497:
    #####: 2498:  begin_struct("os_version");
    #####: 2499:    declare_integer("major");
    #####: 2500:    declare_integer("minor");
    #####: 2501:  end_struct("os_version");
        -: 2502:
    #####: 2503:  begin_struct("image_version");
    #####: 2504:    declare_integer("major");
    #####: 2505:    declare_integer("minor");
    #####: 2506:  end_struct("image_version");
        -: 2507:
    #####: 2508:  begin_struct("subsystem_version");
    #####: 2509:    declare_integer("major");
    #####: 2510:    declare_integer("minor");
    #####: 2511:  end_struct("subsystem_version");
        -: 2512:
    #####: 2513:  declare_integer("win32_version_value");
    #####: 2514:  declare_integer("size_of_image");
    #####: 2515:  declare_integer("size_of_headers");
        -: 2516:
    #####: 2517:  declare_integer("checksum");
    #####: 2518:  declare_function("calculate_checksum", "", "i", calculate_checksum);
    #####: 2519:  declare_integer("subsystem");
        -: 2520:
    #####: 2521:  declare_integer("dll_characteristics");
    #####: 2522:  declare_integer("size_of_stack_reserve");
    #####: 2523:  declare_integer("size_of_stack_commit");
    #####: 2524:  declare_integer("size_of_heap_reserve");
    #####: 2525:  declare_integer("size_of_heap_commit");
    #####: 2526:  declare_integer("loader_flags");
        -: 2527:
    #####: 2528:  begin_struct_array("data_directories");
    #####: 2529:    declare_integer("virtual_address");
    #####: 2530:    declare_integer("size");
    #####: 2531:  end_struct_array("data_directories");
        -: 2532:
    #####: 2533:  begin_struct_array("sections");
    #####: 2534:    declare_string("name");
    #####: 2535:    declare_integer("characteristics");
    #####: 2536:    declare_integer("virtual_address");
    #####: 2537:    declare_integer("virtual_size");
    #####: 2538:    declare_integer("raw_data_offset");
    #####: 2539:    declare_integer("raw_data_size");
    #####: 2540:    declare_integer("pointer_to_relocations");
    #####: 2541:    declare_integer("pointer_to_line_numbers");
    #####: 2542:    declare_integer("number_of_relocations");
    #####: 2543:    declare_integer("number_of_line_numbers");
    #####: 2544:  end_struct_array("sections");
        -: 2545:
    #####: 2546:  begin_struct("overlay");
    #####: 2547:    declare_integer("offset");
    #####: 2548:    declare_integer("size");
    #####: 2549:  end_struct("overlay");
        -: 2550:
    #####: 2551:  begin_struct("rich_signature");
    #####: 2552:    declare_integer("offset");
    #####: 2553:    declare_integer("length");
    #####: 2554:    declare_integer("key");
    #####: 2555:    declare_string("raw_data");
    #####: 2556:    declare_string("clear_data");
    #####: 2557:    declare_function("version", "i", "i", rich_version);
    #####: 2558:    declare_function("version", "ii", "i", rich_version_toolid);
    #####: 2559:    declare_function("toolid", "i", "i", rich_toolid);
    #####: 2560:    declare_function("toolid", "ii", "i", rich_toolid_version);
    #####: 2561:  end_struct("rich_signature");
        -: 2562:
        -: 2563:  #if defined(HAVE_LIBCRYPTO) || \
        -: 2564:      defined(HAVE_WINCRYPT_H) || \
        -: 2565:      defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
    #####: 2566:  declare_function("imphash", "", "s", imphash);
        -: 2567:  #endif
        -: 2568:
    #####: 2569:  declare_function("section_index", "s", "i", section_index_name);
    #####: 2570:  declare_function("section_index", "i", "i", section_index_addr);
    #####: 2571:  declare_function("exports", "s", "i", exports);
    #####: 2572:  declare_function("exports", "r", "i", exports_regexp);
    #####: 2573:  declare_function("exports", "i", "i", exports_ordinal);
    #####: 2574:  declare_function("imports", "ss", "i", imports);
    #####: 2575:  declare_function("imports", "si", "i", imports_ordinal);
    #####: 2576:  declare_function("imports", "s", "i", imports_dll);
    #####: 2577:  declare_function("imports", "rr", "i", imports_regex);
    #####: 2578:  declare_function("locale", "i", "i", locale);
    #####: 2579:  declare_function("language", "i", "i", language);
    #####: 2580:  declare_function("is_dll", "", "i", is_dll);
    #####: 2581:  declare_function("is_32bit", "", "i", is_32bit);
    #####: 2582:  declare_function("is_64bit", "", "i", is_64bit);
        -: 2583:
    #####: 2584:  declare_integer("number_of_imports");
    #####: 2585:  declare_integer("number_of_exports");
        -: 2586:
    #####: 2587:  declare_integer("resource_timestamp");
        -: 2588:
    #####: 2589:  begin_struct("resource_version");
    #####: 2590:    declare_integer("major");
    #####: 2591:    declare_integer("minor");
    #####: 2592:  end_struct("resource_version");
        -: 2593:
    #####: 2594:  begin_struct_array("resources");
    #####: 2595:    declare_integer("offset");
    #####: 2596:    declare_integer("length");
    #####: 2597:    declare_integer("type");
    #####: 2598:    declare_integer("id");
    #####: 2599:    declare_integer("language");
    #####: 2600:    declare_string("type_string");
    #####: 2601:    declare_string("name_string");
    #####: 2602:    declare_string("language_string");
    #####: 2603:  end_struct_array("resources");
        -: 2604:
    #####: 2605:  declare_integer("number_of_resources");
        -: 2606:
        -: 2607:  #if defined(HAVE_LIBCRYPTO) && !defined(BORINGSSL)
    #####: 2608:  begin_struct_array("signatures");
    #####: 2609:    declare_string("thumbprint");
    #####: 2610:    declare_string("issuer");
    #####: 2611:    declare_string("subject");
    #####: 2612:    declare_integer("version");
    #####: 2613:    declare_string("algorithm");
    #####: 2614:    declare_string("serial");
    #####: 2615:    declare_integer("not_before");
    #####: 2616:    declare_integer("not_after");
    #####: 2617:    declare_function("valid_on", "i", "i", valid_on);
    #####: 2618:  end_struct_array("signatures");
        -: 2619:
    #####: 2620:  declare_integer("number_of_signatures");
        -: 2621:  #endif
        -: 2622:
    #####: 2623:  declare_function("rva_to_offset", "i", "i", rva_to_offset);
        -: 2624:
    #####: 2625:end_declarations;
        -: 2626:
        -: 2627:
        7: 2628:int module_initialize(
        -: 2629:    YR_MODULE* module)
        -: 2630:{
        7: 2631:  return ERROR_SUCCESS;
        -: 2632:}
        -: 2633:
        -: 2634:
        3: 2635:int module_finalize(
        -: 2636:    YR_MODULE* module)
        -: 2637:{
        3: 2638:  return ERROR_SUCCESS;
        -: 2639:}
        -: 2640:
        -: 2641:
    #####: 2642:int module_load(
        -: 2643:    YR_SCAN_CONTEXT* context,
        -: 2644:    YR_OBJECT* module_object,
        -: 2645:    void* module_data,
        -: 2646:    size_t module_data_size)
        -: 2647:{
        -: 2648:  YR_MEMORY_BLOCK* block;
    #####: 2649:  YR_MEMORY_BLOCK_ITERATOR* iterator = context->iterator;
        -: 2650:
        -: 2651:  PIMAGE_NT_HEADERS32 pe_header;
    #####: 2652:  const uint8_t* block_data = NULL;
    #####: 2653:  PE* pe = NULL;
        -: 2654:
    #####: 2655:  set_integer(
        -: 2656:      IMAGE_FILE_MACHINE_UNKNOWN, module_object,
        -: 2657:      "MACHINE_UNKNOWN");
    #####: 2658:  set_integer(
        -: 2659:      IMAGE_FILE_MACHINE_AM33, module_object,
        -: 2660:      "MACHINE_AM33");
    #####: 2661:  set_integer(
        -: 2662:      IMAGE_FILE_MACHINE_AMD64, module_object,
        -: 2663:      "MACHINE_AMD64");
    #####: 2664:  set_integer(
        -: 2665:      IMAGE_FILE_MACHINE_ARM, module_object,
        -: 2666:      "MACHINE_ARM");
    #####: 2667:  set_integer(
        -: 2668:      IMAGE_FILE_MACHINE_ARMNT, module_object,
        -: 2669:      "MACHINE_ARMNT");
    #####: 2670:  set_integer(
        -: 2671:      IMAGE_FILE_MACHINE_ARM64, module_object,
        -: 2672:      "MACHINE_ARM64");
    #####: 2673:  set_integer(
        -: 2674:      IMAGE_FILE_MACHINE_EBC, module_object,
        -: 2675:      "MACHINE_EBC");
    #####: 2676:  set_integer(
        -: 2677:      IMAGE_FILE_MACHINE_I386, module_object,
        -: 2678:      "MACHINE_I386");
    #####: 2679:  set_integer(
        -: 2680:      IMAGE_FILE_MACHINE_IA64, module_object,
        -: 2681:      "MACHINE_IA64");
    #####: 2682:  set_integer(
        -: 2683:      IMAGE_FILE_MACHINE_M32R, module_object,
        -: 2684:      "MACHINE_M32R");
    #####: 2685:  set_integer(
        -: 2686:      IMAGE_FILE_MACHINE_MIPS16, module_object,
        -: 2687:      "MACHINE_MIPS16");
    #####: 2688:  set_integer(
        -: 2689:      IMAGE_FILE_MACHINE_MIPSFPU, module_object,
        -: 2690:      "MACHINE_MIPSFPU");
    #####: 2691:  set_integer(
        -: 2692:      IMAGE_FILE_MACHINE_MIPSFPU16, module_object,
        -: 2693:      "MACHINE_MIPSFPU16");
    #####: 2694:  set_integer(
        -: 2695:      IMAGE_FILE_MACHINE_POWERPC, module_object,
        -: 2696:      "MACHINE_POWERPC");
    #####: 2697:  set_integer(
        -: 2698:      IMAGE_FILE_MACHINE_POWERPCFP, module_object,
        -: 2699:      "MACHINE_POWERPCFP");
    #####: 2700:  set_integer(
        -: 2701:      IMAGE_FILE_MACHINE_R4000, module_object,
        -: 2702:      "MACHINE_R4000");
    #####: 2703:  set_integer(
        -: 2704:      IMAGE_FILE_MACHINE_SH3, module_object,
        -: 2705:      "MACHINE_SH3");
    #####: 2706:  set_integer(
        -: 2707:      IMAGE_FILE_MACHINE_SH3DSP, module_object,
        -: 2708:      "MACHINE_SH3DSP");
    #####: 2709:  set_integer(
        -: 2710:      IMAGE_FILE_MACHINE_SH4, module_object,
        -: 2711:      "MACHINE_SH4");
    #####: 2712:  set_integer(
        -: 2713:      IMAGE_FILE_MACHINE_SH5, module_object,
        -: 2714:      "MACHINE_SH5");
    #####: 2715:  set_integer(
        -: 2716:      IMAGE_FILE_MACHINE_THUMB, module_object,
        -: 2717:      "MACHINE_THUMB");
    #####: 2718:  set_integer(
        -: 2719:      IMAGE_FILE_MACHINE_WCEMIPSV2, module_object,
        -: 2720:      "MACHINE_WCEMIPSV2");
        -: 2721:
    #####: 2722:  set_integer(
        -: 2723:      IMAGE_SUBSYSTEM_UNKNOWN, module_object,
        -: 2724:      "SUBSYSTEM_UNKNOWN");
    #####: 2725:  set_integer(
        -: 2726:      IMAGE_SUBSYSTEM_NATIVE, module_object,
        -: 2727:      "SUBSYSTEM_NATIVE");
    #####: 2728:  set_integer(
        -: 2729:      IMAGE_SUBSYSTEM_WINDOWS_GUI, module_object,
        -: 2730:      "SUBSYSTEM_WINDOWS_GUI");
    #####: 2731:  set_integer(
        -: 2732:      IMAGE_SUBSYSTEM_WINDOWS_CUI, module_object,
        -: 2733:      "SUBSYSTEM_WINDOWS_CUI");
    #####: 2734:  set_integer(
        -: 2735:      IMAGE_SUBSYSTEM_OS2_CUI, module_object,
        -: 2736:      "SUBSYSTEM_OS2_CUI");
    #####: 2737:  set_integer(
        -: 2738:      IMAGE_SUBSYSTEM_POSIX_CUI, module_object,
        -: 2739:      "SUBSYSTEM_POSIX_CUI");
    #####: 2740:  set_integer(
        -: 2741:      IMAGE_SUBSYSTEM_NATIVE_WINDOWS, module_object,
        -: 2742:      "SUBSYSTEM_NATIVE_WINDOWS");
    #####: 2743:  set_integer(
        -: 2744:      IMAGE_SUBSYSTEM_WINDOWS_CE_GUI, module_object,
        -: 2745:      "SUBSYSTEM_WINDOWS_CE_GUI");
    #####: 2746:  set_integer(
        -: 2747:      IMAGE_SUBSYSTEM_EFI_APPLICATION, module_object,
        -: 2748:      "SUBSYSTEM_EFI_APPLICATION");
    #####: 2749:  set_integer(
        -: 2750:      IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER, module_object,
        -: 2751:      "SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER");
    #####: 2752:  set_integer(
        -: 2753:      IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER, module_object,
        -: 2754:      "SUBSYSTEM_EFI_RUNTIME_DRIVER");
    #####: 2755:  set_integer(
        -: 2756:      IMAGE_SUBSYSTEM_XBOX, module_object,
        -: 2757:      "SUBSYSTEM_XBOX");
    #####: 2758:  set_integer(
        -: 2759:      IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION, module_object,
        -: 2760:      "SUBSYSTEM_WINDOWS_BOOT_APPLICATION");
        -: 2761:
    #####: 2762:  set_integer(
        -: 2763:      IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE, module_object,
        -: 2764:      "DYNAMIC_BASE");
    #####: 2765:  set_integer(
        -: 2766:      IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY, module_object,
        -: 2767:      "FORCE_INTEGRITY");
    #####: 2768:  set_integer(
        -: 2769:      IMAGE_DLLCHARACTERISTICS_NX_COMPAT, module_object,
        -: 2770:      "NX_COMPAT");
    #####: 2771:  set_integer(
        -: 2772:      IMAGE_DLLCHARACTERISTICS_NO_ISOLATION, module_object,
        -: 2773:      "NO_ISOLATION");
    #####: 2774:  set_integer(
        -: 2775:      IMAGE_DLLCHARACTERISTICS_NO_SEH, module_object,
        -: 2776:      "NO_SEH");
    #####: 2777:  set_integer(
        -: 2778:      IMAGE_DLLCHARACTERISTICS_NO_BIND, module_object,
        -: 2779:      "NO_BIND");
    #####: 2780:  set_integer(
        -: 2781:      IMAGE_DLLCHARACTERISTICS_WDM_DRIVER, module_object,
        -: 2782:      "WDM_DRIVER");
    #####: 2783:  set_integer(
        -: 2784:      IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE, module_object,
        -: 2785:      "TERMINAL_SERVER_AWARE");
        -: 2786:
    #####: 2787:  set_integer(
        -: 2788:      IMAGE_FILE_RELOCS_STRIPPED, module_object,
        -: 2789:      "RELOCS_STRIPPED");
    #####: 2790:  set_integer(
        -: 2791:      IMAGE_FILE_EXECUTABLE_IMAGE, module_object,
        -: 2792:      "EXECUTABLE_IMAGE");
    #####: 2793:  set_integer(
        -: 2794:      IMAGE_FILE_LINE_NUMS_STRIPPED, module_object,
        -: 2795:      "LINE_NUMS_STRIPPED");
    #####: 2796:  set_integer(
        -: 2797:      IMAGE_FILE_LOCAL_SYMS_STRIPPED, module_object,
        -: 2798:      "LOCAL_SYMS_STRIPPED");
    #####: 2799:  set_integer(
        -: 2800:      IMAGE_FILE_AGGRESIVE_WS_TRIM, module_object,
        -: 2801:      "AGGRESIVE_WS_TRIM");
    #####: 2802:  set_integer(
        -: 2803:      IMAGE_FILE_LARGE_ADDRESS_AWARE, module_object,
        -: 2804:      "LARGE_ADDRESS_AWARE");
    #####: 2805:  set_integer(
        -: 2806:      IMAGE_FILE_BYTES_REVERSED_LO, module_object,
        -: 2807:      "BYTES_REVERSED_LO");
    #####: 2808:  set_integer(
        -: 2809:      IMAGE_FILE_32BIT_MACHINE, module_object,
        -: 2810:      "MACHINE_32BIT");
    #####: 2811:  set_integer(
        -: 2812:      IMAGE_FILE_DEBUG_STRIPPED, module_object,
        -: 2813:      "DEBUG_STRIPPED");
    #####: 2814:  set_integer(
        -: 2815:      IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP, module_object,
        -: 2816:      "REMOVABLE_RUN_FROM_SWAP");
    #####: 2817:  set_integer(
        -: 2818:      IMAGE_FILE_NET_RUN_FROM_SWAP, module_object,
        -: 2819:      "NET_RUN_FROM_SWAP");
    #####: 2820:  set_integer(
        -: 2821:      IMAGE_FILE_SYSTEM, module_object,
        -: 2822:      "SYSTEM");
    #####: 2823:  set_integer(
        -: 2824:      IMAGE_FILE_DLL, module_object,
        -: 2825:      "DLL");
    #####: 2826:  set_integer(
        -: 2827:      IMAGE_FILE_UP_SYSTEM_ONLY, module_object,
        -: 2828:      "UP_SYSTEM_ONLY");
    #####: 2829:  set_integer(
        -: 2830:      IMAGE_FILE_BYTES_REVERSED_HI, module_object,
        -: 2831:      "BYTES_REVERSED_HI");
        -: 2832:
    #####: 2833:  set_integer(
        -: 2834:      IMAGE_DIRECTORY_ENTRY_EXPORT, module_object,
        -: 2835:      "IMAGE_DIRECTORY_ENTRY_EXPORT");
    #####: 2836:  set_integer(
        -: 2837:      IMAGE_DIRECTORY_ENTRY_IMPORT, module_object,
        -: 2838:      "IMAGE_DIRECTORY_ENTRY_IMPORT");
    #####: 2839:  set_integer(
        -: 2840:      IMAGE_DIRECTORY_ENTRY_RESOURCE, module_object,
        -: 2841:      "IMAGE_DIRECTORY_ENTRY_RESOURCE");
    #####: 2842:  set_integer(
        -: 2843:      IMAGE_DIRECTORY_ENTRY_EXCEPTION, module_object,
        -: 2844:      "IMAGE_DIRECTORY_ENTRY_EXCEPTION");
    #####: 2845:  set_integer(
        -: 2846:      IMAGE_DIRECTORY_ENTRY_SECURITY, module_object,
        -: 2847:      "IMAGE_DIRECTORY_ENTRY_SECURITY");
    #####: 2848:  set_integer(
        -: 2849:      IMAGE_DIRECTORY_ENTRY_BASERELOC, module_object,
        -: 2850:      "IMAGE_DIRECTORY_ENTRY_BASERELOC");
    #####: 2851:  set_integer(
        -: 2852:      IMAGE_DIRECTORY_ENTRY_DEBUG, module_object,
        -: 2853:      "IMAGE_DIRECTORY_ENTRY_DEBUG");
    #####: 2854:  set_integer(
        -: 2855:      IMAGE_DIRECTORY_ENTRY_ARCHITECTURE, module_object,
        -: 2856:      "IMAGE_DIRECTORY_ENTRY_ARCHITECTURE");
    #####: 2857:  set_integer(
        -: 2858:      IMAGE_DIRECTORY_ENTRY_GLOBALPTR, module_object,
        -: 2859:      "IMAGE_DIRECTORY_ENTRY_GLOBALPTR");
    #####: 2860:  set_integer(
        -: 2861:      IMAGE_DIRECTORY_ENTRY_TLS, module_object,
        -: 2862:      "IMAGE_DIRECTORY_ENTRY_TLS");
    #####: 2863:  set_integer(
        -: 2864:      IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, module_object,
        -: 2865:      "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG");
    #####: 2866:  set_integer(
        -: 2867:      IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, module_object,
        -: 2868:      "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT");
    #####: 2869:  set_integer(
        -: 2870:      IMAGE_DIRECTORY_ENTRY_IAT, module_object,
        -: 2871:      "IMAGE_DIRECTORY_ENTRY_IAT");
    #####: 2872:  set_integer(
        -: 2873:      IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, module_object,
        -: 2874:      "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT");
    #####: 2875:  set_integer(
        -: 2876:      IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, module_object,
        -: 2877:      "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR");
        -: 2878:
    #####: 2879:  set_integer(
        -: 2880:      IMAGE_SCN_CNT_CODE, module_object,
        -: 2881:      "SECTION_CNT_CODE");
    #####: 2882:  set_integer(
        -: 2883:      IMAGE_SCN_CNT_INITIALIZED_DATA, module_object,
        -: 2884:      "SECTION_CNT_INITIALIZED_DATA");
    #####: 2885:  set_integer(
        -: 2886:      IMAGE_SCN_CNT_UNINITIALIZED_DATA, module_object,
        -: 2887:      "SECTION_CNT_UNINITIALIZED_DATA");
    #####: 2888:  set_integer(
        -: 2889:      IMAGE_SCN_GPREL, module_object,
        -: 2890:      "SECTION_GPREL");
    #####: 2891:  set_integer(
        -: 2892:      IMAGE_SCN_MEM_16BIT, module_object,
        -: 2893:      "SECTION_MEM_16BIT");
    #####: 2894:  set_integer(
        -: 2895:      IMAGE_SCN_LNK_NRELOC_OVFL, module_object,
        -: 2896:      "SECTION_LNK_NRELOC_OVFL");
    #####: 2897:  set_integer(
        -: 2898:      IMAGE_SCN_MEM_DISCARDABLE, module_object,
        -: 2899:      "SECTION_MEM_DISCARDABLE");
    #####: 2900:  set_integer(
        -: 2901:      IMAGE_SCN_MEM_NOT_CACHED, module_object,
        -: 2902:      "SECTION_MEM_NOT_CACHED");
    #####: 2903:  set_integer(
        -: 2904:      IMAGE_SCN_MEM_NOT_PAGED, module_object,
        -: 2905:      "SECTION_MEM_NOT_PAGED");
    #####: 2906:  set_integer(
        -: 2907:      IMAGE_SCN_MEM_SHARED, module_object,
        -: 2908:      "SECTION_MEM_SHARED");
    #####: 2909:  set_integer(
        -: 2910:      IMAGE_SCN_MEM_EXECUTE, module_object,
        -: 2911:      "SECTION_MEM_EXECUTE");
    #####: 2912:  set_integer(
        -: 2913:      IMAGE_SCN_MEM_READ, module_object,
        -: 2914:      "SECTION_MEM_READ");
    #####: 2915:  set_integer(
        -: 2916:      IMAGE_SCN_MEM_WRITE, module_object,
        -: 2917:      "SECTION_MEM_WRITE");
        -: 2918:
    #####: 2919:  set_integer(
        -: 2920:      RESOURCE_TYPE_CURSOR, module_object,
        -: 2921:      "RESOURCE_TYPE_CURSOR");
    #####: 2922:  set_integer(
        -: 2923:      RESOURCE_TYPE_BITMAP, module_object,
        -: 2924:      "RESOURCE_TYPE_BITMAP");
    #####: 2925:  set_integer(
        -: 2926:      RESOURCE_TYPE_ICON, module_object,
        -: 2927:      "RESOURCE_TYPE_ICON");
    #####: 2928:  set_integer(
        -: 2929:      RESOURCE_TYPE_MENU, module_object,
        -: 2930:      "RESOURCE_TYPE_MENU");
    #####: 2931:  set_integer(
        -: 2932:      RESOURCE_TYPE_DIALOG, module_object,
        -: 2933:      "RESOURCE_TYPE_DIALOG");
    #####: 2934:  set_integer(
        -: 2935:      RESOURCE_TYPE_STRING, module_object,
        -: 2936:      "RESOURCE_TYPE_STRING");
    #####: 2937:  set_integer(
        -: 2938:      RESOURCE_TYPE_FONTDIR, module_object,
        -: 2939:      "RESOURCE_TYPE_FONTDIR");
    #####: 2940:  set_integer(
        -: 2941:      RESOURCE_TYPE_FONT, module_object,
        -: 2942:      "RESOURCE_TYPE_FONT");
    #####: 2943:  set_integer(
        -: 2944:      RESOURCE_TYPE_ACCELERATOR, module_object,
        -: 2945:      "RESOURCE_TYPE_ACCELERATOR");
    #####: 2946:  set_integer(
        -: 2947:      RESOURCE_TYPE_RCDATA, module_object,
        -: 2948:      "RESOURCE_TYPE_RCDATA");
    #####: 2949:  set_integer(
        -: 2950:      RESOURCE_TYPE_MESSAGETABLE, module_object,
        -: 2951:      "RESOURCE_TYPE_MESSAGETABLE");
    #####: 2952:  set_integer(
        -: 2953:      RESOURCE_TYPE_GROUP_CURSOR, module_object,
        -: 2954:      "RESOURCE_TYPE_GROUP_CURSOR");
    #####: 2955:  set_integer(
        -: 2956:      RESOURCE_TYPE_GROUP_ICON, module_object,
        -: 2957:      "RESOURCE_TYPE_GROUP_ICON");
    #####: 2958:  set_integer(
        -: 2959:      RESOURCE_TYPE_VERSION, module_object,
        -: 2960:      "RESOURCE_TYPE_VERSION");
    #####: 2961:  set_integer(
        -: 2962:      RESOURCE_TYPE_DLGINCLUDE, module_object,
        -: 2963:      "RESOURCE_TYPE_DLGINCLUDE");
    #####: 2964:  set_integer(
        -: 2965:      RESOURCE_TYPE_PLUGPLAY, module_object,
        -: 2966:      "RESOURCE_TYPE_PLUGPLAY");
    #####: 2967:  set_integer(
        -: 2968:      RESOURCE_TYPE_VXD, module_object,
        -: 2969:      "RESOURCE_TYPE_VXD");
    #####: 2970:  set_integer(
        -: 2971:      RESOURCE_TYPE_ANICURSOR, module_object,
        -: 2972:      "RESOURCE_TYPE_ANICURSOR");
    #####: 2973:  set_integer(
        -: 2974:      RESOURCE_TYPE_ANIICON, module_object,
        -: 2975:      "RESOURCE_TYPE_ANIICON");
    #####: 2976:  set_integer(
        -: 2977:      RESOURCE_TYPE_HTML, module_object,
        -: 2978:      "RESOURCE_TYPE_HTML");
    #####: 2979:  set_integer(
        -: 2980:      RESOURCE_TYPE_MANIFEST, module_object,
        -: 2981:      "RESOURCE_TYPE_MANIFEST");
    #####: 2982:  set_integer(0, module_object, "is_pe");
        -: 2983:
    #####: 2984:  foreach_memory_block(iterator, block)
        -: 2985:  {
    #####: 2986:    block_data = block->fetch_data(block);
        -: 2987:
    #####: 2988:    if (block_data == NULL)
    #####: 2989:      continue;
        -: 2990:
    #####: 2991:    pe_header = pe_get_header(block_data, block->size);
        -: 2992:
    #####: 2993:    if (pe_header != NULL)
        -: 2994:    {
        -: 2995:      // Ignore DLLs while scanning a process
        -: 2996:
    #####: 2997:      if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####: 2998:          !(yr_le16toh(pe_header->FileHeader.Characteristics) & IMAGE_FILE_DLL))
        -: 2999:      {
    #####: 3000:        pe = (PE*) yr_malloc(sizeof(PE));
        -: 3001:
    #####: 3002:        if (pe == NULL)
    #####: 3003:          return ERROR_INSUFFICIENT_MEMORY;
        -: 3004:
    #####: 3005:        FAIL_ON_ERROR_WITH_CLEANUP(
        -: 3006:            yr_hash_table_create(17, &pe->hash_table),
        -: 3007:            yr_free(pe));
        -: 3008:
    #####: 3009:        pe->data = block_data;
    #####: 3010:        pe->data_size = block->size;
    #####: 3011:        pe->header = pe_header;
    #####: 3012:        pe->object = module_object;
    #####: 3013:        pe->resources = 0;
        -: 3014:
    #####: 3015:        module_object->data = pe;
        -: 3016:
    #####: 3017:        pe_parse_header(pe, block->base, context->flags);
    #####: 3018:        pe_parse_rich_signature(pe, block->base);
        -: 3019:
        -: 3020:        #if defined(HAVE_LIBCRYPTO) && !defined(BORINGSSL)
    #####: 3021:        pe_parse_certificates(pe);
        -: 3022:        #endif
        -: 3023:
    #####: 3024:        pe->imported_dlls = pe_parse_imports(pe);
    #####: 3025:        pe->exported_functions = pe_parse_exports(pe);
        -: 3026:
    #####: 3027:        break;
        -: 3028:      }
        -: 3029:    }
        -: 3030:  }
        -: 3031:
    #####: 3032:  return ERROR_SUCCESS;
        -: 3033:}
        -: 3034:
        -: 3035:
    #####: 3036:int module_unload(
        -: 3037:    YR_OBJECT* module_object)
        -: 3038:{
    #####: 3039:  IMPORTED_DLL* dll = NULL;
    #####: 3040:  IMPORTED_DLL* next_dll = NULL;
    #####: 3041:  IMPORT_FUNCTION* func = NULL;
    #####: 3042:  IMPORT_FUNCTION* next_func = NULL;
    #####: 3043:  int i = 0;
        -: 3044:
    #####: 3045:  PE* pe = (PE *) module_object->data;
        -: 3046:
    #####: 3047:  if (pe == NULL)
    #####: 3048:    return ERROR_SUCCESS;
        -: 3049:
    #####: 3050:  if (pe->hash_table != NULL)
    #####: 3051:    yr_hash_table_destroy(
        -: 3052:        pe->hash_table,
        -: 3053:        (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_free);
        -: 3054:
    #####: 3055:  dll = pe->imported_dlls;
        -: 3056:
    #####: 3057:  while (dll)
        -: 3058:  {
    #####: 3059:    if (dll->name)
    #####: 3060:      yr_free(dll->name);
        -: 3061:
    #####: 3062:    func = dll->functions;
        -: 3063:
    #####: 3064:    while (func)
        -: 3065:    {
    #####: 3066:      if (func->name)
    #####: 3067:        yr_free(func->name);
        -: 3068:
    #####: 3069:      next_func = func->next;
    #####: 3070:      yr_free(func);
    #####: 3071:      func = next_func;
        -: 3072:    }
        -: 3073:
    #####: 3074:    next_dll = dll->next;
    #####: 3075:    yr_free(dll);
    #####: 3076:    dll = next_dll;
        -: 3077:  }
        -: 3078:
    #####: 3079:  if (pe->exported_functions)
        -: 3080:  {
    #####: 3081:    for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 3082:    {
    #####: 3083:      if (pe->exported_functions->functions[i].name)
    #####: 3084:        yr_free(pe->exported_functions->functions[i].name);
        -: 3085:    }
        -: 3086:
    #####: 3087:    yr_free(pe->exported_functions->functions);
    #####: 3088:    yr_free(pe->exported_functions);
        -: 3089:  }
        -: 3090:
    #####: 3091:  yr_free(pe);
        -: 3092:
    #####: 3093:  return ERROR_SUCCESS;
        -: 3094:}
