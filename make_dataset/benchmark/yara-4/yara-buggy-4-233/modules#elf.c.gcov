        -:    0:Source:modules/elf.c
        -:    0:Graph:/home/workspace/libyara/modules/elf.gcno
        -:    0:Data:/home/workspace/libyara/modules/elf.gcda
        -:    0:Runs:9
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <limits.h>
        -:   33:#include <string.h>
        -:   34:
        -:   35:#include <yara/elf.h>
        -:   36:#include <yara/endian.h>
        -:   37:#include <yara/modules.h>
        -:   38:#include <yara/mem.h>
        -:   39:#include <yara/utils.h>
        -:   40:
        -:   41:
        -:   42:#define MODULE_NAME elf
        -:   43:
        -:   44:#define CLASS_DATA(c,d) ((c << 8) | d)
        -:   45:
    #####:   46:int get_elf_class_data(
        -:   47:    const uint8_t* buffer,
        -:   48:    size_t buffer_length)
        -:   49:{
        -:   50:  elf_ident_t* elf_ident;
        -:   51:
    #####:   52:  if (buffer_length < sizeof(elf_ident_t))
    #####:   53:    return 0;
        -:   54:
    #####:   55:  elf_ident = (elf_ident_t*) buffer;
        -:   56:
    #####:   57:  if (yr_le32toh(elf_ident->magic) == ELF_MAGIC)
        -:   58:  {
    #####:   59:    return CLASS_DATA(elf_ident->_class, elf_ident->data);
        -:   60:  }
        -:   61:  else
        -:   62:  {
    #####:   63:    return 0;
        -:   64:  }
        -:   65:}
        -:   66:
    #####:   67:static bool is_valid_ptr(
        -:   68:    const void* base,
        -:   69:    size_t size,
        -:   70:    const void* ptr,
        -:   71:    uint64_t ptr_size)  // ptr_size can be 64bit even in 32bit systems.
        -:   72:{
    #####:   73:  return ptr >= base && ptr_size <= size &&
    #####:   74:      ((char*) ptr) + ptr_size <= ((char*) base) + size;
        -:   75:}
        -:   76:
        -:   77:#define IS_VALID_PTR(base, size, ptr) \
        -:   78:    is_valid_ptr(base, size, ptr, sizeof(*ptr))
        -:   79:
        -:   80://
        -:   81:// Returns a string table entry for the index or NULL if the entry is out
        -:   82:// of bounds. A non-null return value will be a null-terminated C string.
        -:   83://
    #####:   84:static const char* str_table_entry(
        -:   85:    const char* str_table_base,
        -:   86:    const char* str_table_limit,
        -:   87:    int index)
        -:   88:{
        -:   89:  size_t len;
        -:   90:  const char* str_entry;
        -:   91:
    #####:   92:  if (str_table_base >= str_table_limit)
    #####:   93:    return NULL;
        -:   94:
        -:   95:  // The first entry in the string table must be a null character, if not the
        -:   96:  // string table is probably corrupted.
    #####:   97:  if (*str_table_base != '\0')
    #####:   98:    return NULL;
        -:   99:
    #####:  100:  if (index < 0)
    #####:  101:    return NULL;
        -:  102:
    #####:  103:  str_entry = str_table_base + index;
        -:  104:
    #####:  105:  if (str_entry >= str_table_limit)
    #####:  106:    return NULL;
        -:  107:
    #####:  108:  len = strnlen(str_entry, str_table_limit - str_entry);
        -:  109:
        -:  110:  // Entry is clamped by extent of string table, not null-terminated.
    #####:  111:  if (str_entry + len == str_table_limit)
    #####:  112:    return NULL;
        -:  113:
    #####:  114:  return str_entry;
        -:  115:}
        -:  116:
        -:  117:#define ELF_SIZE_OF_SECTION_TABLE(bits,bo,h)       \
        -:  118:  (sizeof(elf##bits##_section_header_t) * yr_##bo##16toh(h->sh_entry_count))
        -:  119:
        -:  120:#define ELF_SIZE_OF_PROGRAM_TABLE(bits,bo,h)       \
        -:  121:  (sizeof(elf##bits##_program_header_t) * yr_##bo##16toh(h->ph_entry_count))
        -:  122:
        -:  123:#define ELF_RVA_TO_OFFSET(bits,bo)                                             \
        -:  124:uint64_t elf_rva_to_offset_##bits##_##bo(                                      \
        -:  125:    elf##bits##_header_t* elf_header,                                          \
        -:  126:    uint64_t rva,                                                              \
        -:  127:    size_t elf_size)                                                           \
        -:  128:{                                                                              \
        -:  129:  if (yr_##bo##16toh(elf_header->type) == ELF_ET_EXEC)                         \
        -:  130:  {                                                                            \
        -:  131:    int i;                                                                     \
        -:  132:                                                                               \
        -:  133:    elf##bits##_program_header_t* program;                                     \
        -:  134:                                                                               \
        -:  135:    /* check that ph_offset doesn't wrap when added to SIZE_OF_PROGRAM_TABLE */\
        -:  136:                                                                               \
        -:  137:    if(ULONG_MAX - yr_##bo##bits##toh(elf_header->ph_offset) <                 \
        -:  138:       ELF_SIZE_OF_PROGRAM_TABLE(bits,bo,elf_header))                          \
        -:  139:    {                                                                          \
        -:  140:      return UNDEFINED;                                                        \
        -:  141:    }                                                                          \
        -:  142:                                                                               \
        -:  143:    if (yr_##bo##bits##toh(elf_header->ph_offset) == 0 ||                      \
        -:  144:        yr_##bo##bits##toh(elf_header->ph_offset) > elf_size ||                \
        -:  145:        yr_##bo##bits##toh(elf_header->ph_offset) +                            \
        -:  146:         ELF_SIZE_OF_PROGRAM_TABLE(bits,bo,elf_header) > elf_size ||           \
        -:  147:        yr_##bo##16toh(elf_header->ph_entry_count) == 0)                       \
        -:  148:    {                                                                          \
        -:  149:      return UNDEFINED;                                                        \
        -:  150:    }                                                                          \
        -:  151:                                                                               \
        -:  152:    program = (elf##bits##_program_header_t*)                                  \
        -:  153:        ((uint8_t*) elf_header + yr_##bo##bits##toh(elf_header->ph_offset));   \
        -:  154:                                                                               \
        -:  155:    for (i = 0; i < yr_##bo##16toh(elf_header->ph_entry_count); i++)           \
        -:  156:    {                                                                          \
        -:  157:      if (rva >= yr_##bo##bits##toh(program->virt_addr) &&                     \
        -:  158:          rva < yr_##bo##bits##toh(program->virt_addr) +                       \
        -:  159:          yr_##bo##bits##toh(program->mem_size))                               \
        -:  160:      {                                                                        \
        -:  161:        return yr_##bo##bits##toh(program->offset) +                           \
        -:  162:          (rva - yr_##bo##bits##toh(program->virt_addr));                      \
        -:  163:      }                                                                        \
        -:  164:                                                                               \
        -:  165:      program++;                                                               \
        -:  166:    }                                                                          \
        -:  167:  }                                                                            \
        -:  168:  else                                                                         \
        -:  169:  {                                                                            \
        -:  170:    int i;                                                                     \
        -:  171:                                                                               \
        -:  172:    elf##bits##_section_header_t* section;                                     \
        -:  173:                                                                               \
        -:  174:    /* check that sh_offset doesn't wrap when added to SIZE_OF_SECTION_TABLE */\
        -:  175:                                                                               \
        -:  176:    if(ULONG_MAX - yr_##bo##bits##toh(elf_header->sh_offset) <                 \
        -:  177:       ELF_SIZE_OF_SECTION_TABLE(bits,bo,elf_header))                          \
        -:  178:    {                                                                          \
        -:  179:      return UNDEFINED;                                                        \
        -:  180:    }                                                                          \
        -:  181:                                                                               \
        -:  182:    if (yr_##bo##bits##toh(elf_header->sh_offset) == 0 ||                      \
        -:  183:        yr_##bo##bits##toh(elf_header->sh_offset) > elf_size ||                \
        -:  184:        yr_##bo##bits##toh(elf_header->sh_offset) +                            \
        -:  185:         ELF_SIZE_OF_SECTION_TABLE(bits,bo,elf_header) > elf_size ||           \
        -:  186:        yr_##bo##16toh(elf_header->sh_entry_count) == 0)                       \
        -:  187:    {                                                                          \
        -:  188:      return UNDEFINED;                                                        \
        -:  189:    }                                                                          \
        -:  190:                                                                               \
        -:  191:    section = (elf##bits##_section_header_t*)                                  \
        -:  192:        ((uint8_t*) elf_header + yr_##bo##bits##toh(elf_header->sh_offset));   \
        -:  193:                                                                               \
        -:  194:    for (i = 0; i < yr_##bo##16toh(elf_header->sh_entry_count); i++)           \
        -:  195:    {                                                                          \
        -:  196:      if (yr_##bo##32toh(section->type) != ELF_SHT_NULL &&                     \
        -:  197:          yr_##bo##32toh(section->type) != ELF_SHT_NOBITS &&                   \
        -:  198:          rva >= yr_##bo##bits##toh(section->addr) &&                          \
        -:  199:          rva < yr_##bo##bits##toh(section->addr) +                            \
        -:  200:          yr_##bo##bits##toh(section->size))                                   \
        -:  201:      {                                                                        \
        -:  202:        return yr_##bo##bits##toh(section->offset) +                           \
        -:  203:          (rva - yr_##bo##bits##toh(section->addr));                           \
        -:  204:      }                                                                        \
        -:  205:                                                                               \
        -:  206:      section++;                                                               \
        -:  207:    }                                                                          \
        -:  208:  }                                                                            \
        -:  209:  return UNDEFINED;                                                            \
        -:  210:}
        -:  211:
        -:  212:#define PARSE_ELF_HEADER(bits,bo)                                              \
        -:  213:void parse_elf_header_##bits##_##bo(                                           \
        -:  214:  elf##bits##_header_t* elf,                                                   \
        -:  215:  uint64_t base_address,                                                       \
        -:  216:  size_t elf_size,                                                             \
        -:  217:  int flags,                                                                   \
        -:  218:  YR_OBJECT* elf_obj)                                                          \
        -:  219:{                                                                              \
        -:  220:  unsigned int i, j;                                                           \
        -:  221:  const char* elf_raw = (const char*) elf;                                     \
        -:  222:  uint16_t str_table_index = yr_##bo##16toh(elf->sh_str_table_index);          \
        -:  223:                                                                               \
        -:  224:  const char* sym_table = NULL;                                                \
        -:  225:  const char* sym_str_table = NULL;                                            \
        -:  226:                                                                               \
        -:  227:  uint##bits##_t sym_table_size = 0;                                           \
        -:  228:  uint##bits##_t sym_str_table_size = 0;                                       \
        -:  229:                                                                               \
        -:  230:  elf##bits##_section_header_t* section_table;                                 \
        -:  231:  elf##bits##_section_header_t* section;                                       \
        -:  232:  elf##bits##_program_header_t* segment;                                       \
        -:  233:                                                                               \
        -:  234:  set_integer(yr_##bo##16toh(elf->type), elf_obj, "type");                     \
        -:  235:  set_integer(yr_##bo##16toh(elf->machine), elf_obj, "machine");               \
        -:  236:  set_integer(yr_##bo##bits##toh(elf->sh_offset), elf_obj,                     \
        -:  237:              "sh_offset");                                                    \
        -:  238:  set_integer(yr_##bo##16toh(elf->sh_entry_size), elf_obj,                     \
        -:  239:              "sh_entry_size");                                                \
        -:  240:  set_integer(yr_##bo##16toh(elf->sh_entry_count), elf_obj,                    \
        -:  241:              "number_of_sections");                                           \
        -:  242:  set_integer(yr_##bo##bits##toh(elf->ph_offset), elf_obj,                     \
        -:  243:              "ph_offset");                                                    \
        -:  244:  set_integer(yr_##bo##16toh(elf->ph_entry_size), elf_obj,                     \
        -:  245:              "ph_entry_size");                                                \
        -:  246:  set_integer(yr_##bo##16toh(elf->ph_entry_count), elf_obj,                    \
        -:  247:              "number_of_segments");                                           \
        -:  248:                                                                               \
        -:  249:  if (yr_##bo##bits##toh(elf->entry) != 0)                                     \
        -:  250:  {                                                                            \
        -:  251:    set_integer(                                                               \
        -:  252:        flags & SCAN_FLAGS_PROCESS_MEMORY ?                                    \
        -:  253:        base_address + yr_##bo##bits##toh(elf->entry) :                        \
        -:  254:        elf_rva_to_offset_##bits##_##bo(                                       \
        -:  255:            elf, yr_##bo##bits##toh(elf->entry), elf_size),                    \
        -:  256:        elf_obj, "entry_point");                                               \
        -:  257:  }                                                                            \
        -:  258:                                                                               \
        -:  259:  if (yr_##bo##16toh(elf->sh_entry_count) < ELF_SHN_LORESERVE &&               \
        -:  260:      str_table_index < yr_##bo##16toh(elf->sh_entry_count) &&                 \
        -:  261:      yr_##bo##bits##toh(elf->sh_offset) < elf_size &&                         \
        -:  262:      yr_##bo##bits##toh(elf->sh_offset) +                                     \
        -:  263:        yr_##bo##16toh(elf->sh_entry_count) *                                  \
        -:  264:        sizeof(elf##bits##_section_header_t) <= elf_size)                      \
        -:  265:  {                                                                            \
        -:  266:    const char* str_table = NULL;                                              \
        -:  267:                                                                               \
        -:  268:    section_table = (elf##bits##_section_header_t*)                            \
        -:  269:        (elf_raw + yr_##bo##bits##toh(elf->sh_offset));                        \
        -:  270:                                                                               \
        -:  271:    if (yr_##bo##bits##toh(section_table[str_table_index].offset) < elf_size)  \
        -:  272:    {                                                                          \
        -:  273:      str_table = elf_raw + yr_##bo##bits##toh(                                \
        -:  274:          section_table[str_table_index].offset);                              \
        -:  275:    }                                                                          \
        -:  276:                                                                               \
        -:  277:    section = section_table;                                                   \
        -:  278:                                                                               \
        -:  279:    for (i = 0; i < yr_##bo##16toh(elf->sh_entry_count); i++, section++)       \
        -:  280:    {                                                                          \
        -:  281:      set_integer(yr_##bo##32toh(section->type), elf_obj,                      \
        -:  282:                  "sections[%i].type", i);                                     \
        -:  283:      set_integer(yr_##bo##bits##toh(section->flags), elf_obj,                 \
        -:  284:                  "sections[%i].flags", i);                                    \
        -:  285:      set_integer(yr_##bo##bits##toh(section->addr), elf_obj,                  \
        -:  286:                  "sections[%i].address", i);                                  \
        -:  287:      set_integer(yr_##bo##bits##toh(section->size), elf_obj,                  \
        -:  288:                  "sections[%i].size", i);                                     \
        -:  289:      set_integer(yr_##bo##bits##toh(section->offset), elf_obj,                \
        -:  290:                  "sections[%i].offset", i);                                   \
        -:  291:                                                                               \
        -:  292:      if (yr_##bo##32toh(section->name) < elf_size && str_table > elf_raw)     \
        -:  293:      {                                                                        \
        -:  294:        const char* section_name = str_table_entry(                            \
        -:  295:            str_table,                                                         \
        -:  296:            elf_raw + elf_size,                                                \
        -:  297:            yr_##bo##32toh(section->name));                                    \
        -:  298:                                                                               \
        -:  299:        if (section_name)                                                      \
        -:  300:          set_string(section_name, elf_obj, "sections[%i].name", i);           \
        -:  301:      }                                                                        \
        -:  302:                                                                               \
        -:  303:      if (yr_##bo##32toh(section->type) == ELF_SHT_SYMTAB &&                   \
        -:  304:          yr_##bo##32toh(section->link) < elf->sh_entry_count)                 \
        -:  305:      {                                                                        \
        -:  306:        elf##bits##_section_header_t* string_section =                         \
        -:  307:            section_table + yr_##bo##32toh(section->link);                     \
        -:  308:                                                                               \
        -:  309:        if (IS_VALID_PTR(elf, elf_size, string_section) &&                     \
        -:  310:            yr_##bo##32toh(string_section->type) == ELF_SHT_STRTAB)            \
        -:  311:        {                                                                      \
        -:  312:          sym_table = elf_raw + yr_##bo##bits##toh(section->offset);           \
        -:  313:          sym_str_table = elf_raw + yr_##bo##bits##toh(string_section->offset);\
        -:  314:          sym_table_size = yr_##bo##bits##toh(section->size);                  \
        -:  315:          sym_str_table_size = yr_##bo##bits##toh(string_section->size);       \
        -:  316:        }                                                                      \
        -:  317:      }                                                                        \
        -:  318:    }                                                                          \
        -:  319:                                                                               \
        -:  320:    if (is_valid_ptr(elf, elf_size, sym_str_table, sym_str_table_size) &&      \
        -:  321:        is_valid_ptr(elf, elf_size, sym_table, sym_table_size))                \
        -:  322:    {                                                                          \
        -:  323:      elf##bits##_sym_t* sym = (elf##bits##_sym_t*) sym_table;                 \
        -:  324:                                                                               \
        -:  325:      for (j = 0; j < sym_table_size / sizeof(elf##bits##_sym_t); j++, sym++)  \
        -:  326:      {                                                                        \
        -:  327:        const char* sym_name = str_table_entry(                                \
        -:  328:            sym_str_table,                                                     \
        -:  329:            sym_str_table + sym_str_table_size,                                \
        -:  330:            yr_##bo##32toh(sym->name));                                        \
        -:  331:                                                                               \
        -:  332:        if (sym_name)                                                          \
        -:  333:          set_string(sym_name, elf_obj, "symtab[%i].name", j);                 \
        -:  334:                                                                               \
        -:  335:        set_integer(sym->info >> 4, elf_obj,                                   \
        -:  336:            "symtab[%i].bind", j);                                             \
        -:  337:        set_integer(sym->info & 0xf, elf_obj,                                  \
        -:  338:            "symtab[%i].type", j);                                             \
        -:  339:        set_integer(yr_##bo##16toh(sym->shndx), elf_obj,                       \
        -:  340:           "symtab[%i].shndx", j);                                             \
        -:  341:        set_integer(yr_##bo##bits##toh(sym->value), elf_obj,                   \
        -:  342:           "symtab[%i].value", j);                                             \
        -:  343:        set_integer(yr_##bo##bits##toh(sym->size), elf_obj,                    \
        -:  344:           "symtab[%i].size", j);                                              \
        -:  345:      }                                                                        \
        -:  346:                                                                               \
        -:  347:      set_integer(j, elf_obj, "symtab_entries");                               \
        -:  348:    }                                                                          \
        -:  349:  }                                                                            \
        -:  350:                                                                               \
        -:  351:  if (yr_##bo##16toh(elf->ph_entry_count) > 0 &&                               \
        -:  352:      yr_##bo##16toh(elf->ph_entry_count) < ELF_PN_XNUM &&                     \
        -:  353:      yr_##bo##bits##toh(elf->ph_offset) < elf_size &&                         \
        -:  354:      yr_##bo##bits##toh(elf->ph_offset) +                                     \
        -:  355:        yr_##bo##16toh(elf->ph_entry_count) *                                  \
        -:  356:        sizeof(elf##bits##_program_header_t) <= elf_size)                      \
        -:  357:  {                                                                            \
        -:  358:    segment = (elf##bits##_program_header_t*)                                  \
        -:  359:        (elf_raw + yr_##bo##bits##toh(elf->ph_offset));                        \
        -:  360:                                                                               \
        -:  361:    for (i = 0; i < yr_##bo##16toh(elf->ph_entry_count); i++, segment++)       \
        -:  362:    {                                                                          \
        -:  363:      set_integer(                                                             \
        -:  364:          yr_##bo##32toh(segment->type), elf_obj, "segments[%i].type", i);     \
        -:  365:      set_integer(                                                             \
        -:  366:          yr_##bo##32toh(segment->flags), elf_obj, "segments[%i].flags", i);   \
        -:  367:      set_integer(                                                             \
        -:  368:          yr_##bo##bits##toh(segment->offset), elf_obj,                        \
        -:  369:          "segments[%i].offset", i);                                           \
        -:  370:      set_integer(                                                             \
        -:  371:          yr_##bo##bits##toh(segment->virt_addr), elf_obj,                     \
        -:  372:          "segments[%i].virtual_address", i);                                  \
        -:  373:      set_integer(                                                             \
        -:  374:          yr_##bo##bits##toh(segment->phys_addr), elf_obj,                     \
        -:  375:          "segments[%i].physical_address", i);                                 \
        -:  376:      set_integer(                                                             \
        -:  377:          yr_##bo##bits##toh(segment->file_size), elf_obj,                     \
        -:  378:          "segments[%i].file_size", i);                                        \
        -:  379:      set_integer(                                                             \
        -:  380:          yr_##bo##bits##toh(segment->mem_size), elf_obj,                      \
        -:  381:          "segments[%i].memory_size", i);                                      \
        -:  382:      set_integer(                                                             \
        -:  383:          yr_##bo##bits##toh(segment->alignment), elf_obj,                     \
        -:  384:          "segments[%i].alignment", i);                                        \
        -:  385:                                                                               \
        -:  386:      if (yr_##bo##32toh(segment->type) == ELF_PT_DYNAMIC)                     \
        -:  387:      {                                                                        \
        -:  388:        elf##bits##_dyn_t* dyn = (elf##bits##_dyn_t*)                          \
        -:  389:            (elf_raw + yr_##bo##bits##toh(segment->offset));                   \
        -:  390:                                                                               \
        -:  391:        for (j = 0; IS_VALID_PTR(elf, elf_size, dyn); dyn++, j++)              \
        -:  392:        {                                                                      \
        -:  393:          set_integer(                                                         \
        -:  394:              yr_##bo##bits##toh(dyn->tag), elf_obj, "dynamic[%i].type", j);   \
        -:  395:          set_integer(                                                         \
        -:  396:              yr_##bo##bits##toh(dyn->val), elf_obj, "dynamic[%i].val", j);    \
        -:  397:                                                                               \
        -:  398:          if (dyn->tag == ELF_DT_NULL)                                         \
        -:  399:          {                                                                    \
        -:  400:            j++;                                                               \
        -:  401:            break;                                                             \
        -:  402:          }                                                                    \
        -:  403:        }                                                                      \
        -:  404:        set_integer(j, elf_obj, "dynamic_section_entries");                    \
        -:  405:      }                                                                        \
        -:  406:    }                                                                          \
        -:  407:  }                                                                            \
        -:  408:}
        -:  409:
    #####:  410:ELF_RVA_TO_OFFSET(32,le);
    #####:  411:ELF_RVA_TO_OFFSET(64,le);
    #####:  412:ELF_RVA_TO_OFFSET(32,be);
    #####:  413:ELF_RVA_TO_OFFSET(64,be);
        -:  414:
    #####:  415:PARSE_ELF_HEADER(32,le);
    #####:  416:PARSE_ELF_HEADER(64,le);
    #####:  417:PARSE_ELF_HEADER(32,be);
    #####:  418:PARSE_ELF_HEADER(64,be);
        -:  419:
        -:  420:
    #####:  421:begin_declarations;
        -:  422:
    #####:  423:  declare_integer("ET_NONE");
    #####:  424:  declare_integer("ET_REL");
    #####:  425:  declare_integer("ET_EXEC");
    #####:  426:  declare_integer("ET_DYN");
    #####:  427:  declare_integer("ET_CORE");
        -:  428:
    #####:  429:  declare_integer("EM_NONE");
    #####:  430:  declare_integer("EM_M32");
    #####:  431:  declare_integer("EM_SPARC");
    #####:  432:  declare_integer("EM_386");
    #####:  433:  declare_integer("EM_68K");
    #####:  434:  declare_integer("EM_88K");
    #####:  435:  declare_integer("EM_860");
    #####:  436:  declare_integer("EM_MIPS");
    #####:  437:  declare_integer("EM_MIPS_RS3_LE");
    #####:  438:  declare_integer("EM_PPC");
    #####:  439:  declare_integer("EM_PPC64");
    #####:  440:  declare_integer("EM_ARM");
    #####:  441:  declare_integer("EM_X86_64");
    #####:  442:  declare_integer("EM_AARCH64");
        -:  443:
    #####:  444:  declare_integer("SHT_NULL");
    #####:  445:  declare_integer("SHT_PROGBITS");
    #####:  446:  declare_integer("SHT_SYMTAB");
    #####:  447:  declare_integer("SHT_STRTAB");
    #####:  448:  declare_integer("SHT_RELA");
    #####:  449:  declare_integer("SHT_HASH");
    #####:  450:  declare_integer("SHT_DYNAMIC");
    #####:  451:  declare_integer("SHT_NOTE");
    #####:  452:  declare_integer("SHT_NOBITS");
    #####:  453:  declare_integer("SHT_REL");
    #####:  454:  declare_integer("SHT_SHLIB");
    #####:  455:  declare_integer("SHT_DYNSYM");
        -:  456:
    #####:  457:  declare_integer("SHF_WRITE");
    #####:  458:  declare_integer("SHF_ALLOC");
    #####:  459:  declare_integer("SHF_EXECINSTR");
        -:  460:
    #####:  461:  declare_integer("type");
    #####:  462:  declare_integer("machine");
    #####:  463:  declare_integer("entry_point");
        -:  464:
    #####:  465:  declare_integer("number_of_sections");
    #####:  466:  declare_integer("sh_offset");
    #####:  467:  declare_integer("sh_entry_size");
        -:  468:
    #####:  469:  declare_integer("number_of_segments");
    #####:  470:  declare_integer("ph_offset");
    #####:  471:  declare_integer("ph_entry_size");
        -:  472:
    #####:  473:  begin_struct_array("sections");
    #####:  474:    declare_integer("type");
    #####:  475:    declare_integer("flags");
    #####:  476:    declare_integer("address");
    #####:  477:    declare_string("name");
    #####:  478:    declare_integer("size");
    #####:  479:    declare_integer("offset");
    #####:  480:  end_struct_array("sections");
        -:  481:
    #####:  482:  declare_integer("PT_NULL");
    #####:  483:  declare_integer("PT_LOAD");
    #####:  484:  declare_integer("PT_DYNAMIC");
    #####:  485:  declare_integer("PT_INTERP");
    #####:  486:  declare_integer("PT_NOTE");
    #####:  487:  declare_integer("PT_SHLIB");
    #####:  488:  declare_integer("PT_PHDR");
    #####:  489:  declare_integer("PT_TLS");
    #####:  490:  declare_integer("PT_GNU_EH_FRAME");
    #####:  491:  declare_integer("PT_GNU_STACK");
        -:  492:
    #####:  493:  declare_integer("DT_NULL");
    #####:  494:  declare_integer("DT_NEEDED");
    #####:  495:  declare_integer("DT_PLTRELSZ");
    #####:  496:  declare_integer("DT_PLTGOT");
    #####:  497:  declare_integer("DT_HASH");
    #####:  498:  declare_integer("DT_STRTAB");
    #####:  499:  declare_integer("DT_SYMTAB");
    #####:  500:  declare_integer("DT_RELA");
    #####:  501:  declare_integer("DT_RELASZ");
    #####:  502:  declare_integer("DT_RELAENT");
    #####:  503:  declare_integer("DT_STRSZ");
    #####:  504:  declare_integer("DT_SYMENT");
    #####:  505:  declare_integer("DT_INIT");
    #####:  506:  declare_integer("DT_FINI");
    #####:  507:  declare_integer("DT_SONAME");
    #####:  508:  declare_integer("DT_RPATH");
    #####:  509:  declare_integer("DT_SYMBOLIC");
    #####:  510:  declare_integer("DT_REL");
    #####:  511:  declare_integer("DT_RELSZ");
    #####:  512:  declare_integer("DT_RELENT");
    #####:  513:  declare_integer("DT_PLTREL");
    #####:  514:  declare_integer("DT_DEBUG");
    #####:  515:  declare_integer("DT_TEXTREL");
    #####:  516:  declare_integer("DT_JMPREL");
    #####:  517:  declare_integer("DT_BIND_NOW");
    #####:  518:  declare_integer("DT_INIT_ARRAY");
    #####:  519:  declare_integer("DT_FINI_ARRAY");
    #####:  520:  declare_integer("DT_INIT_ARRAYSZ");
    #####:  521:  declare_integer("DT_FINI_ARRAYSZ");
    #####:  522:  declare_integer("DT_RUNPATH");
    #####:  523:  declare_integer("DT_FLAGS");
    #####:  524:  declare_integer("DT_ENCODING");
        -:  525:
    #####:  526:  declare_integer("STT_NOTYPE");
    #####:  527:  declare_integer("STT_OBJECT");
    #####:  528:  declare_integer("STT_FUNC");
    #####:  529:  declare_integer("STT_SECTION");
    #####:  530:  declare_integer("STT_FILE");
    #####:  531:  declare_integer("STT_COMMON");
    #####:  532:  declare_integer("STT_TLS");
        -:  533:
    #####:  534:  declare_integer("STB_LOCAL");
    #####:  535:  declare_integer("STB_GLOBAL");
    #####:  536:  declare_integer("STB_WEAK");
        -:  537:
    #####:  538:  declare_integer("PF_X");
    #####:  539:  declare_integer("PF_W");
    #####:  540:  declare_integer("PF_R");
        -:  541:
    #####:  542:  begin_struct_array("segments");
    #####:  543:    declare_integer("type");
    #####:  544:    declare_integer("flags");
    #####:  545:    declare_integer("offset");
    #####:  546:    declare_integer("virtual_address");
    #####:  547:    declare_integer("physical_address");
    #####:  548:    declare_integer("file_size");
    #####:  549:    declare_integer("memory_size");
    #####:  550:    declare_integer("alignment");
    #####:  551:  end_struct_array("segments");
        -:  552:
    #####:  553:  declare_integer("dynamic_section_entries");
    #####:  554:  begin_struct_array("dynamic");
    #####:  555:    declare_integer("type");
    #####:  556:    declare_integer("val");
    #####:  557:  end_struct_array("dynamic");
        -:  558:
    #####:  559:  declare_integer("symtab_entries");
    #####:  560:  begin_struct_array("symtab");
    #####:  561:    declare_string("name");
    #####:  562:    declare_integer("value");
    #####:  563:    declare_integer("size");
    #####:  564:    declare_integer("type");
    #####:  565:    declare_integer("bind");
    #####:  566:    declare_integer("shndx");
    #####:  567:  end_struct_array("symtab");
        -:  568:
    #####:  569:end_declarations;
        -:  570:
        -:  571:
        7:  572:int module_initialize(
        -:  573:    YR_MODULE* module)
        -:  574:{
        7:  575:  return ERROR_SUCCESS;
        -:  576:}
        -:  577:
        -:  578:
        3:  579:int module_finalize(
        -:  580:    YR_MODULE* module)
        -:  581:{
        3:  582:  return ERROR_SUCCESS;
        -:  583:}
        -:  584:
        -:  585:
    #####:  586:int module_load(
        -:  587:    YR_SCAN_CONTEXT* context,
        -:  588:    YR_OBJECT* module_object,
        -:  589:    void* module_data,
        -:  590:    size_t module_data_size)
        -:  591:{
        -:  592:  YR_MEMORY_BLOCK* block;
    #####:  593:  YR_MEMORY_BLOCK_ITERATOR* iterator = context->iterator;
        -:  594:
        -:  595:  elf32_header_t* elf_header32;
        -:  596:  elf64_header_t* elf_header64;
        -:  597:
    #####:  598:  set_integer(ELF_ET_NONE, module_object, "ET_NONE");
    #####:  599:  set_integer(ELF_ET_REL, module_object, "ET_REL");
    #####:  600:  set_integer(ELF_ET_EXEC, module_object, "ET_EXEC");
    #####:  601:  set_integer(ELF_ET_DYN, module_object, "ET_DYN");
    #####:  602:  set_integer(ELF_ET_CORE, module_object, "ET_CORE");
        -:  603:
    #####:  604:  set_integer(ELF_EM_NONE, module_object, "EM_NONE");
    #####:  605:  set_integer(ELF_EM_M32, module_object, "EM_M32");
    #####:  606:  set_integer(ELF_EM_SPARC, module_object, "EM_SPARC");
    #####:  607:  set_integer(ELF_EM_386, module_object, "EM_386");
    #####:  608:  set_integer(ELF_EM_68K, module_object, "EM_68K");
    #####:  609:  set_integer(ELF_EM_88K, module_object, "EM_88K");
    #####:  610:  set_integer(ELF_EM_860, module_object, "EM_860");
    #####:  611:  set_integer(ELF_EM_MIPS, module_object, "EM_MIPS");
    #####:  612:  set_integer(ELF_EM_MIPS_RS3_LE, module_object, "EM_MIPS_RS3_LE");
    #####:  613:  set_integer(ELF_EM_PPC, module_object, "EM_PPC");
    #####:  614:  set_integer(ELF_EM_PPC64, module_object, "EM_PPC64");
    #####:  615:  set_integer(ELF_EM_ARM, module_object, "EM_ARM");
    #####:  616:  set_integer(ELF_EM_X86_64, module_object, "EM_X86_64");
    #####:  617:  set_integer(ELF_EM_AARCH64, module_object, "EM_AARCH64");
        -:  618:
    #####:  619:  set_integer(ELF_SHT_NULL, module_object, "SHT_NULL");
    #####:  620:  set_integer(ELF_SHT_PROGBITS, module_object, "SHT_PROGBITS");
    #####:  621:  set_integer(ELF_SHT_SYMTAB, module_object, "SHT_SYMTAB");
    #####:  622:  set_integer(ELF_SHT_STRTAB, module_object, "SHT_STRTAB");
    #####:  623:  set_integer(ELF_SHT_RELA, module_object, "SHT_RELA");
    #####:  624:  set_integer(ELF_SHT_HASH, module_object, "SHT_HASH");
    #####:  625:  set_integer(ELF_SHT_DYNAMIC, module_object, "SHT_DYNAMIC");
    #####:  626:  set_integer(ELF_SHT_NOTE, module_object, "SHT_NOTE");
    #####:  627:  set_integer(ELF_SHT_NOBITS, module_object, "SHT_NOBITS");
    #####:  628:  set_integer(ELF_SHT_REL, module_object, "SHT_REL");
    #####:  629:  set_integer(ELF_SHT_SHLIB, module_object, "SHT_SHLIB");
    #####:  630:  set_integer(ELF_SHT_DYNSYM, module_object, "SHT_DYNSYM");
        -:  631:
    #####:  632:  set_integer(ELF_SHF_WRITE, module_object, "SHF_WRITE");
    #####:  633:  set_integer(ELF_SHF_ALLOC, module_object, "SHF_ALLOC");
    #####:  634:  set_integer(ELF_SHF_EXECINSTR, module_object, "SHF_EXECINSTR");
        -:  635:
    #####:  636:  set_integer(ELF_PT_NULL, module_object, "PT_NULL");
    #####:  637:  set_integer(ELF_PT_LOAD, module_object, "PT_LOAD");
    #####:  638:  set_integer(ELF_PT_DYNAMIC, module_object, "PT_DYNAMIC");
    #####:  639:  set_integer(ELF_PT_INTERP, module_object, "PT_INTERP");
    #####:  640:  set_integer(ELF_PT_NOTE, module_object, "PT_NOTE");
    #####:  641:  set_integer(ELF_PT_SHLIB, module_object, "PT_SHLIB");
    #####:  642:  set_integer(ELF_PT_PHDR, module_object, "PT_PHDR");
    #####:  643:  set_integer(ELF_PT_TLS, module_object, "PT_TLS");
    #####:  644:  set_integer(ELF_PT_GNU_EH_FRAME, module_object, "PT_GNU_EH_FRAME");
    #####:  645:  set_integer(ELF_PT_GNU_STACK, module_object, "PT_GNU_STACK");
        -:  646:
    #####:  647:  set_integer(ELF_DT_NULL, module_object, "DT_NULL");
    #####:  648:  set_integer(ELF_DT_NEEDED, module_object, "DT_NEEDED");
    #####:  649:  set_integer(ELF_DT_PLTRELSZ, module_object, "DT_PLTRELSZ");
    #####:  650:  set_integer(ELF_DT_PLTGOT, module_object, "DT_PLTGOT");
    #####:  651:  set_integer(ELF_DT_HASH, module_object, "DT_HASH");
    #####:  652:  set_integer(ELF_DT_STRTAB, module_object, "DT_STRTAB");
    #####:  653:  set_integer(ELF_DT_SYMTAB, module_object, "DT_SYMTAB");
    #####:  654:  set_integer(ELF_DT_RELA, module_object, "DT_RELA");
    #####:  655:  set_integer(ELF_DT_RELASZ, module_object, "DT_RELASZ");
    #####:  656:  set_integer(ELF_DT_RELAENT, module_object, "DT_RELAENT");
    #####:  657:  set_integer(ELF_DT_STRSZ, module_object, "DT_STRSZ");
    #####:  658:  set_integer(ELF_DT_SYMENT, module_object, "DT_SYMENT");
    #####:  659:  set_integer(ELF_DT_INIT, module_object, "DT_INIT");
    #####:  660:  set_integer(ELF_DT_FINI, module_object, "DT_FINI");
    #####:  661:  set_integer(ELF_DT_SONAME, module_object, "DT_SONAME");
    #####:  662:  set_integer(ELF_DT_RPATH, module_object, "DT_RPATH");
    #####:  663:  set_integer(ELF_DT_SYMBOLIC, module_object, "DT_SYMBOLIC");
    #####:  664:  set_integer(ELF_DT_REL, module_object, "DT_REL");
    #####:  665:  set_integer(ELF_DT_RELSZ, module_object, "DT_RELSZ");
    #####:  666:  set_integer(ELF_DT_RELENT, module_object, "DT_RELENT");
    #####:  667:  set_integer(ELF_DT_PLTREL, module_object, "DT_PLTREL");
    #####:  668:  set_integer(ELF_DT_DEBUG, module_object, "DT_DEBUG");
    #####:  669:  set_integer(ELF_DT_TEXTREL, module_object, "DT_TEXTREL");
    #####:  670:  set_integer(ELF_DT_JMPREL, module_object, "DT_JMPREL");
    #####:  671:  set_integer(ELF_DT_BIND_NOW, module_object, "DT_BIND_NOW");
    #####:  672:  set_integer(ELF_DT_INIT_ARRAY, module_object, "DT_INIT_ARRAY");
    #####:  673:  set_integer(ELF_DT_FINI_ARRAY, module_object, "DT_FINI_ARRAY");
    #####:  674:  set_integer(ELF_DT_INIT_ARRAYSZ, module_object, "DT_INIT_ARRAYSZ");
    #####:  675:  set_integer(ELF_DT_FINI_ARRAYSZ, module_object, "DT_FINI_ARRAYSZ");
    #####:  676:  set_integer(ELF_DT_RUNPATH, module_object, "DT_RUNPATH");
    #####:  677:  set_integer(ELF_DT_FLAGS, module_object, "DT_FLAGS");
    #####:  678:  set_integer(ELF_DT_ENCODING, module_object, "DT_ENCODING");
        -:  679:
    #####:  680:  set_integer(ELF_STT_NOTYPE, module_object, "STT_NOTYPE");
    #####:  681:  set_integer(ELF_STT_OBJECT, module_object, "STT_OBJECT");
    #####:  682:  set_integer(ELF_STT_FUNC, module_object, "STT_FUNC");
    #####:  683:  set_integer(ELF_STT_SECTION, module_object, "STT_SECTION");
    #####:  684:  set_integer(ELF_STT_FILE, module_object, "STT_FILE");
    #####:  685:  set_integer(ELF_STT_COMMON, module_object, "STT_COMMON");
    #####:  686:  set_integer(ELF_STT_TLS, module_object, "STT_TLS");
        -:  687:
    #####:  688:  set_integer(ELF_STB_LOCAL, module_object, "STB_LOCAL");
    #####:  689:  set_integer(ELF_STB_GLOBAL, module_object, "STB_GLOBAL");
    #####:  690:  set_integer(ELF_STB_WEAK, module_object, "STB_WEAK");
        -:  691:
    #####:  692:  set_integer(ELF_PF_X, module_object, "PF_X");
    #####:  693:  set_integer(ELF_PF_W, module_object, "PF_W");
    #####:  694:  set_integer(ELF_PF_R, module_object, "PF_R");
        -:  695:
    #####:  696:  foreach_memory_block(iterator, block)
        -:  697:  {
    #####:  698:    const uint8_t* block_data = block->fetch_data(block);
        -:  699:
    #####:  700:    if (block_data == NULL)
    #####:  701:      continue;
        -:  702:
    #####:  703:    switch(get_elf_class_data(block_data, block->size))
        -:  704:    {
    #####:  705:      case CLASS_DATA(ELF_CLASS_32, ELF_DATA_2LSB):
        -:  706:
    #####:  707:        if (block->size > sizeof(elf32_header_t))
        -:  708:        {
    #####:  709:          elf_header32 = (elf32_header_t*) block_data;
        -:  710:
    #####:  711:          if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####:  712:              yr_le16toh(elf_header32->type) == ELF_ET_EXEC)
        -:  713:          {
    #####:  714:            parse_elf_header_32_le(
        -:  715:                elf_header32,
        -:  716:                block->base,
        -:  717:                block->size,
        -:  718:                context->flags,
        -:  719:                module_object);
        -:  720:          }
        -:  721:        }
        -:  722:
    #####:  723:        break;
        -:  724:
    #####:  725:      case CLASS_DATA(ELF_CLASS_32, ELF_DATA_2MSB):
        -:  726:
    #####:  727:        if (block->size > sizeof(elf32_header_t))
        -:  728:        {
    #####:  729:          elf_header32 = (elf32_header_t*) block_data;
        -:  730:
    #####:  731:          if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####:  732:              yr_be16toh(elf_header32->type) == ELF_ET_EXEC)
        -:  733:          {
    #####:  734:            parse_elf_header_32_be(
        -:  735:                elf_header32,
        -:  736:                block->base,
        -:  737:                block->size,
        -:  738:                context->flags,
        -:  739:                module_object);
        -:  740:          }
        -:  741:        }
        -:  742:
    #####:  743:        break;
        -:  744:
    #####:  745:      case CLASS_DATA(ELF_CLASS_64,ELF_DATA_2LSB):
        -:  746:
    #####:  747:        if (block->size > sizeof(elf64_header_t))
        -:  748:        {
    #####:  749:          elf_header64 = (elf64_header_t*) block_data;
        -:  750:
    #####:  751:          if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####:  752:              yr_le16toh(elf_header64->type) == ELF_ET_EXEC)
        -:  753:          {
    #####:  754:            parse_elf_header_64_le(
        -:  755:                elf_header64,
        -:  756:                block->base,
        -:  757:                block->size,
        -:  758:                context->flags,
        -:  759:                module_object);
        -:  760:          }
        -:  761:        }
        -:  762:
    #####:  763:        break;
        -:  764:
    #####:  765:      case CLASS_DATA(ELF_CLASS_64,ELF_DATA_2MSB):
        -:  766:
    #####:  767:        if (block->size > sizeof(elf64_header_t))
        -:  768:        {
    #####:  769:          elf_header64 = (elf64_header_t*) block_data;
        -:  770:
    #####:  771:          if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####:  772:              yr_be16toh(elf_header64->type) == ELF_ET_EXEC)
        -:  773:          {
    #####:  774:            parse_elf_header_64_be(
        -:  775:                elf_header64,
        -:  776:                block->base,
        -:  777:                block->size,
        -:  778:                context->flags,
        -:  779:                module_object);
        -:  780:          }
        -:  781:        }
        -:  782:
    #####:  783:        break;
        -:  784:    }
    #####:  785:  }
        -:  786:
    #####:  787:  return ERROR_SUCCESS;
        -:  788:}
        -:  789:
        -:  790:
    #####:  791:int module_unload(YR_OBJECT* module_object)
        -:  792:{
    #####:  793:  return ERROR_SUCCESS;
        -:  794:}
