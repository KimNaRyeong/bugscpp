        -:    0:Source:atoms.c
        -:    0:Graph:/home/workspace/libyara/atoms.gcno
        -:    0:Data:/home/workspace/libyara/atoms.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013-2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/*
        -:   31:
        -:   32:This module handles atom extraction from regexps and hex strings. Atoms are
        -:   33:undivided substrings found in a regexps and hex strings. Let's consider this
        -:   34:hex string:
        -:   35:
        -:   36:{ 01 02 03 04 05 ?? 06 07 08 [1-2] 09 0A }
        -:   37:
        -:   38:In the above string, byte sequences 0102030405, 060708 and 090A are atoms.
        -:   39:Similarly, in this regexp:
        -:   40:
        -:   41:/abc.*ed[0-9]+fgh/
        -:   42:
        -:   43:The strings "abc", "ed" and "fgh" are atoms.
        -:   44:
        -:   45:When searching for regexps/hex strings matching a file, YARA uses these
        -:   46:atoms to find locations inside the file where the regexp/hex string could
        -:   47:match. If the atom "abc" is found somewhere inside the file, there is a chance
        -:   48:for /abc.*ed[0-9]+fgh/ to match the file, if "abc" doesn't appear in the file
        -:   49:there's no chance for the regexp to match. When the atom is found in the file
        -:   50:YARA proceeds to fully evaluate the regexp/hex string to determine if it's
        -:   51:actually a match.
        -:   52:
        -:   53:For each regexp/hex string YARA extracts one or more atoms. Sometimes a
        -:   54:single atom is enough (like in the previous example "abc" is enough for finding
        -:   55:/abc.*ed[0-9]+fgh/), but sometimes a single atom isn't enough like in the
        -:   56:regexp /(abc|efg)/. In this case YARA must search for both "abc" AND "efg" and
        -:   57:fully evaluate the regexp whenever one of these atoms is found.
        -:   58:
        -:   59:In the regexp /Look(at|into)this/ YARA can search for "Look", or search for
        -:   60:"this", or search for both "at" and "into". This is what we call an atoms tree,
        -:   61:because it can be represented by the following tree structure:
        -:   62:
        -:   63:-OR
        -:   64:  |- "Look"
        -:   65:  |
        -:   66:  |- AND
        -:   67:  |   |
        -:   68:  |   |- "at"
        -:   69:  |    - "into"
        -:   70:  |
        -:   71:   - "this"
        -:   72:
        -:   73:From an atom tree YARA chooses the best combination, trying to minimize the
        -:   74:number of required atoms, but also using high quality atoms (long atoms with
        -:   75:not too many zeroes and a bit of byte diversity). In the previous example YARA
        -:   76:will end up using the "Look" atom alone, but in /a(bcd|efg)h/ atoms "bcd" and
        -:   77:"efg" will be used because "a" and "h" are too short.
        -:   78:
        -:   79:*/
        -:   80:
        -:   81:#include <assert.h>
        -:   82:#include <string.h>
        -:   83:
        -:   84:#include <yara/globals.h>
        -:   85:#include <yara/utils.h>
        -:   86:#include <yara/atoms.h>
        -:   87:#include <yara/limits.h>
        -:   88:#include <yara/mem.h>
        -:   89:#include <yara/error.h>
        -:   90:#include <yara/types.h>
        -:   91:#include <yara/stack.h>
        -:   92:
        -:   93:
        -:   94://
        -:   95:// yr_atoms_heuristic_quality
        -:   96://
        -:   97:// Returns a numeric value indicating the quality of an atom. The quality
        -:   98:// depends on some characteristics of the atom, including its length, number
        -:   99:// of very common bytes like 00 and FF and number of unique distinct bytes.
        -:  100:// Atom 00 00 has a very low quality, because it's only two bytes long and
        -:  101:// both bytes are zeroes. Atom 01 01 01 01 is better but still not optimal,
        -:  102:// because the same byte is repeated. Atom 01 02 03 04 is an optimal one.
        -:  103://
        -:  104:// Args:
        -:  105://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  106://    YR_ATOM* atom             - Pointer to YR_ATOM struct.
        -:  107://
        -:  108:// Returns:
        -:  109://    An integer indicating the atom's quality
        -:  110://
        -:  111:
     1004:  112:int yr_atoms_heuristic_quality(
        -:  113:    YR_ATOMS_CONFIG* config,
        -:  114:    YR_ATOM* atom)
        -:  115:{
        -:  116:  YR_BITMASK seen_bytes[YR_BITMASK_SIZE(256)];
        -:  117:
     1004:  118:  int quality = 0;
     1004:  119:  int unique_bytes = 0;
     1004:  120:  int masked_nibbles = 0;
        -:  121:  int i;
        -:  122:
    1004*:  123:  assert(atom->length <= YR_MAX_ATOM_LENGTH);
        -:  124:
     1004:  125:  yr_bitmask_clear_all(seen_bytes);
        -:  126:
     3049:  127:  for (i = 0; i < atom->length; i++)
        -:  128:  {
     2045:  129:    switch (atom->mask[i])
        -:  130:    {
       16:  131:      case 0x00:
       16:  132:        masked_nibbles += 2;
       16:  133:        break;
        4:  134:      case 0x0F:
        4:  135:        masked_nibbles += 1;
        4:  136:        quality += 4;
        4:  137:        break;
    #####:  138:      case 0xF0:
    #####:  139:        masked_nibbles += 1;
    #####:  140:        quality += 4;
    #####:  141:        break;
     2025:  142:      case 0xFF:
     2025:  143:        switch (atom->bytes[i])
        -:  144:        {
       40:  145:          case 0x00:
        -:  146:          case 0x20:
        -:  147:          case 0xCC:
        -:  148:          case 0xFF:
        -:  149:            // Common bytes contribute less to the quality than the rest.
       40:  150:            quality += 15;
       40:  151:            break;
     1985:  152:          default:
        -:  153:            // Bytes in the a-z and A-Z ranges have a slightly lower quality
        -:  154:            // than the rest. We want to favor atoms that contain bytes outside
        -:  155:            // those ranges because they generate less additional atoms during
        -:  156:            // calls to _yr_atoms_case_combinations.
     1985:  157:            if ( yr_lowercase[atom->bytes[i]] >= 'a' &&
     1903:  158:                 yr_lowercase[atom->bytes[i]] <= 'z')
     1899:  159:              quality += 19;
        -:  160:            else
       86:  161:              quality += 20;
        -:  162:        };
     2025:  163:        if (!yr_bitmask_isset(seen_bytes, atom->bytes[i]))
        -:  164:        {
     1626:  165:          yr_bitmask_set(seen_bytes, atom->bytes[i]);
     1626:  166:          unique_bytes++;
        -:  167:        }
        -:  168:    }
        -:  169:  }
        -:  170:
        -:  171:  // If all the bytes in the atom are equal and very common, let's penalize
        -:  172:  // it heavily.
        -:  173:
     1004:  174:  if (unique_bytes == 1 &&
      566:  175:      (yr_bitmask_isset(seen_bytes, 0x00) ||
      565:  176:       yr_bitmask_isset(seen_bytes, 0x20) ||
      562:  177:       yr_bitmask_isset(seen_bytes, 0xCC) ||
      562:  178:       yr_bitmask_isset(seen_bytes, 0xFF)))
        -:  179:  {
        4:  180:    quality -= 10 * atom->length;
        -:  181:  }
        -:  182:
     1004:  183:  quality -= masked_nibbles * 3;
        -:  184:
     1004:  185:  return YR_MAX_ATOM_QUALITY - 20 * YR_MAX_ATOM_LENGTH + quality;
        -:  186:}
        -:  187:
        -:  188:
        -:  189://
        -:  190:// _yr_atoms_cmp
        -:  191://
        -:  192:// Compares the byte sequence in a1 with the YR_ATOM in a2, taking atom's mask
        -:  193:// into account.
        -:  194://
        -:  195:// Returns:
        -:  196://   < 0 if the first byte that does not match has a lower value in a1 than
        -:  197://       in a2.
        -:  198://   > 0 if the first byte that does not match has a greater value in a1 than
        -:  199://       in a2.
        -:  200://   = 0 if a1 is equal or matches a2.
        -:  201://
        -:  202:
    #####:  203:static int _yr_atoms_cmp(
        -:  204:    const uint8_t* a1,
        -:  205:    YR_ATOM* a2)
        -:  206:{
    #####:  207:  int result = 0;
    #####:  208:  int i =  0;
        -:  209:
    #####:  210:  while (result == 0 && i < a2->length)
        -:  211:  {
    #####:  212:    switch (a2->mask[i])
        -:  213:    {
    #####:  214:      case 0xFF:
        -:  215:      case 0x0F:
        -:  216:      case 0xF0:
        -:  217:      case 0x00:
    #####:  218:        result = (a1[i] & a2->mask[i]) - a2->bytes[i];
    #####:  219:        break;
    #####:  220:      default:
    #####:  221:        assert(false);
        -:  222:    }
        -:  223:
    #####:  224:    i++;
        -:  225:  }
        -:  226:
    #####:  227:  return result;
        -:  228:}
        -:  229:
        -:  230://
        -:  231:// yr_atoms_table_quality
        -:  232://
        -:  233:// Returns a numeric value indicating the quality of an atom. The quality is
        -:  234:// based in the atom quality table passed in "config". Very common atoms
        -:  235:// (i.e: those with greater quality) have lower quality than those that are
        -:  236:// uncommon. See the comment for yr_compiler_set_atom_quality_table for
        -:  237:// details about the quality table's format.
        -:  238://
        -:  239:// Args:
        -:  240://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  241://    YR_ATOM* atom             - Pointer to YR_ATOM struct.
        -:  242://
        -:  243:// Returns:
        -:  244://    An integer indicating the atom's quality
        -:  245://
        -:  246:
    #####:  247:int yr_atoms_table_quality(
        -:  248:    YR_ATOMS_CONFIG* config,
        -:  249:    YR_ATOM* atom)
        -:  250:{
    #####:  251:  YR_ATOM_QUALITY_TABLE_ENTRY* table = config->quality_table;
        -:  252:
    #####:  253:  int begin = 0;
    #####:  254:  int end = config->quality_table_entries;
        -:  255:
    #####:  256:  assert(atom->length <= YR_MAX_ATOM_LENGTH);
        -:  257:
    #####:  258:  while (end > begin)
        -:  259:  {
    #####:  260:    int middle = begin + (end - begin) / 2;
    #####:  261:    int c = _yr_atoms_cmp(table[middle].atom, atom);
        -:  262:
    #####:  263:    if (c < 0)
        -:  264:    {
    #####:  265:      begin = middle + 1;
        -:  266:    }
    #####:  267:    else if (c > 0)
        -:  268:    {
    #####:  269:      end = middle;
        -:  270:    }
        -:  271:    else
        -:  272:    {
    #####:  273:      int i = middle + 1;
    #####:  274:      int quality = table[middle].quality;
    #####:  275:      int min_quality = quality;
        -:  276:
    #####:  277:      while (i < end && _yr_atoms_cmp(table[i].atom, atom) == 0)
        -:  278:      {
    #####:  279:        if (min_quality > table[i].quality)
    #####:  280:          min_quality = table[i].quality;
        -:  281:
    #####:  282:        i++;
        -:  283:      }
        -:  284:
    #####:  285:      i = middle - 1;
        -:  286:
    #####:  287:      while (i >= begin && _yr_atoms_cmp(table[i].atom, atom) == 0)
        -:  288:      {
    #####:  289:        if (min_quality > table[i].quality)
    #####:  290:          min_quality = table[i].quality;
        -:  291:
    #####:  292:        i--;
        -:  293:      }
        -:  294:
    #####:  295:      return min_quality >> (YR_MAX_ATOM_LENGTH - atom->length);
        -:  296:    }
        -:  297:  }
        -:  298:
    #####:  299:  return YR_MAX_ATOM_QUALITY;
        -:  300:}
        -:  301:
        -:  302:
        -:  303://
        -:  304:// yr_atoms_min_quality
        -:  305://
        -:  306:// Returns the quality for the worst quality atom in a list.
        -:  307://
        -:  308:
    #####:  309:int yr_atoms_min_quality(
        -:  310:    YR_ATOMS_CONFIG* config,
        -:  311:    YR_ATOM_LIST_ITEM* atom_list)
        -:  312:{
        -:  313:  YR_ATOM_LIST_ITEM* atom;
        -:  314:
        -:  315:  int quality;
    #####:  316:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  317:
    #####:  318:  if (atom_list == NULL)
    #####:  319:    return YR_MIN_ATOM_QUALITY;
        -:  320:
    #####:  321:  atom = atom_list;
        -:  322:
    #####:  323:  while (atom != NULL)
        -:  324:  {
    #####:  325:    quality = config->get_atom_quality(config, &atom->atom);
        -:  326:
    #####:  327:    if (quality < min_quality)
    #####:  328:      min_quality = quality;
        -:  329:
    #####:  330:    atom = atom->next;
        -:  331:  }
        -:  332:
    #####:  333:  return min_quality;
        -:  334:}
        -:  335:
        -:  336:
        -:  337://
        -:  338:// _yr_atoms_tree_node_create
        -:  339://
        -:  340:// Creates a new node for an atoms tree.
        -:  341://
        -:  342:
      862:  343:static YR_ATOM_TREE_NODE* _yr_atoms_tree_node_create(
        -:  344:    uint8_t type)
        -:  345:{
        -:  346:  YR_ATOM_TREE_NODE* new_node = (YR_ATOM_TREE_NODE*) \
      862:  347:      yr_malloc(sizeof(YR_ATOM_TREE_NODE));
        -:  348:
      862:  349:  if (new_node != NULL)
        -:  350:  {
      862:  351:    new_node->type = type;
      862:  352:    new_node->atom.length = 0;
      862:  353:    new_node->next_sibling = NULL;
      862:  354:    new_node->children_head = NULL;
      862:  355:    new_node->children_tail = NULL;
        -:  356:  }
        -:  357:
      862:  358:  return new_node;
        -:  359:}
        -:  360:
        -:  361:
        -:  362://
        -:  363:// _yr_atoms_tree_node_destroy
        -:  364://
        -:  365:// Destroys a node from an atoms tree.
        -:  366://
        -:  367:
      862:  368:static void _yr_atoms_tree_node_destroy(
        -:  369:    YR_ATOM_TREE_NODE* node)
        -:  370:{
        -:  371:  YR_ATOM_TREE_NODE* child;
        -:  372:  YR_ATOM_TREE_NODE* next_child;
        -:  373:
      862:  374:  if (node == NULL)
    #####:  375:    return;
        -:  376:
      862:  377:  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)
        -:  378:  {
      412:  379:    child = node->children_head;
        -:  380:
     1009:  381:    while (child != NULL)
        -:  382:    {
      597:  383:      next_child = child->next_sibling;
      597:  384:      _yr_atoms_tree_node_destroy(child);
      597:  385:      child = next_child;
        -:  386:    }
        -:  387:  }
        -:  388:
      862:  389:  yr_free(node);
        -:  390:}
        -:  391:
        -:  392:
        -:  393://
        -:  394:// _yr_atoms_tree_node_append
        -:  395://
        -:  396:// Appends a new child node to another atoms tree node.
        -:  397://
        -:  398:
      499:  399:static void _yr_atoms_tree_node_append(
        -:  400:    YR_ATOM_TREE_NODE* dest,
        -:  401:    YR_ATOM_TREE_NODE* node)
        -:  402:{
      499:  403:  if (dest->children_head == NULL)
      329:  404:    dest->children_head = node;
        -:  405:
      499:  406:  if (dest->children_tail != NULL)
      170:  407:    dest->children_tail->next_sibling = node;
        -:  408:
      499:  409:  dest->children_tail = node;
      499:  410:}
        -:  411:
        -:  412:
        -:  413://
        -:  414:// _yr_atoms_tree_destroy
        -:  415://
        -:  416:// Destroys an atoms tree.
        -:  417://
        -:  418:
      265:  419:static void _yr_atoms_tree_destroy(
        -:  420:    YR_ATOM_TREE* atom_tree)
        -:  421:{
      265:  422:  _yr_atoms_tree_node_destroy(atom_tree->root_node);
      265:  423:  yr_free(atom_tree);
      265:  424:}
        -:  425:
        -:  426:
        -:  427://
        -:  428:// yr_atoms_list_destroy
        -:  429://
        -:  430:// Destroys an atoms list.
        -:  431://
        -:  432:
      795:  433:void yr_atoms_list_destroy(
        -:  434:    YR_ATOM_LIST_ITEM* list_head)
        -:  435:{
      795:  436:  YR_ATOM_LIST_ITEM* item = list_head;
        -:  437:  YR_ATOM_LIST_ITEM* next;
        -:  438:
     2408:  439:  while (item != NULL)
        -:  440:  {
     1613:  441:    next = item->next;
     1613:  442:    yr_free(item);
     1613:  443:    item = next;
        -:  444:  }
      795:  445:}
        -:  446:
        -:  447:
        -:  448://
        -:  449:// yr_atoms_list_destroy
        -:  450://
        -:  451:// Concats two atoms lists.
        -:  452://
        -:  453:
       10:  454:static YR_ATOM_LIST_ITEM* _yr_atoms_list_concat(
        -:  455:    YR_ATOM_LIST_ITEM* list1,
        -:  456:    YR_ATOM_LIST_ITEM* list2)
        -:  457:{
        -:  458:  YR_ATOM_LIST_ITEM* item;
        -:  459:
       10:  460:  if (list1 == NULL)
    #####:  461:    return list2;
        -:  462:
       10:  463:  item = list1;
        -:  464:
       10:  465:  while (item->next != NULL)
        -:  466:  {
    #####:  467:    item = item->next;
        -:  468:  }
        -:  469:
       10:  470:  item->next = list2;
       10:  471:  return list1;
        -:  472:}
        -:  473:
        -:  474:
        -:  475://
        -:  476:// _yr_atoms_trim
        -:  477://
        -:  478:// If the atom starts or ends with an unknown byte (mask == 0x00), trim
        -:  479:// those bytes out of the atom. We don't want to expand an atom like
        -:  480:// { ?? 01 02 } into { 00 01 02 }, { 01 01 02}, { 02 01 02} .. { FF 01 02}
        -:  481:// in those cases it's better to simply have a shorter atom { 01 02 }.
        -:  482://
        -:  483:// Args:
        -:  484://   atom     - Pointer to the YR_ATOM to be trimmed.
        -:  485://
        -:  486:// Returns:
        -:  487://   The number of bytes that were trimmed from the beginning of the atom.
        -:  488://
        -:  489:
      962:  490:int _yr_atoms_trim(
        -:  491:    YR_ATOM* atom)
        -:  492:{
      962:  493:  int mask_00 = 0;
      962:  494:  int mask_ff = 0;
        -:  495:
      962:  496:  int i, trim_left = 0;
        -:  497:
      975:  498:  while (trim_left < atom->length && atom->mask[trim_left] == 0)
       13:  499:    trim_left++;
        -:  500:
      970:  501:  while (atom->length > trim_left && atom->mask[atom->length - 1] == 0)
        8:  502:    atom->length--;
        -:  503:
      962:  504:  atom->length -= trim_left;
        -:  505:
      962:  506:  if (atom->length == 0)
        6:  507:    return 0;
        -:  508:
        -:  509:  // The trimmed atom goes from trim_left to trim_left + atom->length and the
        -:  510:  // first and last byte in the atom are known (mask == 0xFF). Now count the
        -:  511:  // number of known and unknown bytes in the atom (mask == 0xFF and
        -:  512:  // mask == 0x00 respectively).
        -:  513:
     2850:  514:  for (i = 0; i < atom->length; i++)
        -:  515:  {
     1894:  516:    if (atom->mask[trim_left + i] == 0xFF)
     1880:  517:      mask_ff++;
       14:  518:    else if (atom->mask[trim_left + i] == 0x00)
       14:  519:      mask_00++;
        -:  520:  }
        -:  521:
        -:  522:  // If the number of unknown bytes is >= than the number of known bytes
        -:  523:  // it doesn't make sense the to use this atom, so we use a single byte atpm
        -:  524:  // containing the first known byte. If YR_MAX_ATOM_LENGTH == 4 this happens
        -:  525:  // only when the atom is like { XX ?? ?? YY }, so using the first known
        -:  526:  // byte is good enough. For larger values of YR_MAX_ATOM_LENGTH this is not
        -:  527:  // the most efficient solution, as better atoms could be choosen. For
        -:  528:  // example, in { XX ?? ?? ?? YY ZZ } the best atom is { YY ZZ } not { XX }.
        -:  529:  // But let's keep it like this for simplicity.
        -:  530:
      956:  531:  if (mask_00 >= mask_ff)
    #####:  532:    atom->length = 1;
        -:  533:
      956:  534:  if (trim_left == 0)
      946:  535:    return 0;
        -:  536:
        -:  537:  // Shift bytes and mask trim_left positions to the left.
        -:  538:
       40:  539:  for (i = 0; i < YR_MAX_ATOM_LENGTH - trim_left; i++)
        -:  540:  {
       30:  541:    atom->bytes[i] = atom->bytes[trim_left + i];
       30:  542:    atom->mask[i] = atom->mask[trim_left + i];
        -:  543:  }
        -:  544:
       10:  545:  return trim_left;
        -:  546:}
        -:  547:
        -:  548:
        -:  549://
        -:  550:// _yr_atoms_choose
        -:  551://
        -:  552:// This function receives an atom tree and returns a list of atoms to be added
        -:  553:// to the Aho-Corasick automaton.
        -:  554://
        -:  555:
      862:  556:static int _yr_atoms_choose(
        -:  557:    YR_ATOMS_CONFIG* config,
        -:  558:    YR_ATOM_TREE_NODE* node,
        -:  559:    YR_ATOM_LIST_ITEM** chosen_atoms,
        -:  560:    int* atoms_quality)
        -:  561:{
        -:  562:  YR_ATOM_TREE_NODE* child;
        -:  563:  YR_ATOM_LIST_ITEM* item;
        -:  564:  YR_ATOM_LIST_ITEM* tail;
        -:  565:
        -:  566:  int shift, quality;
        -:  567:
      862:  568:  int max_quality = YR_MIN_ATOM_QUALITY;
      862:  569:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  570:
      862:  571:  *chosen_atoms = NULL;
      862:  572:  *atoms_quality = YR_MIN_ATOM_QUALITY;
        -:  573:
      862:  574:  switch (node->type)
        -:  575:  {
      450:  576:  case ATOM_TREE_LEAF:
        -:  577:
      450:  578:    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  579:
      450:  580:    if (item == NULL)
    #####:  581:      return ERROR_INSUFFICIENT_MEMORY;
        -:  582:
      450:  583:    memcpy(&item->atom, &node->atom, sizeof(YR_ATOM));
        -:  584:
      450:  585:    shift = _yr_atoms_trim(&item->atom);
        -:  586:
      450:  587:    if (item->atom.length > 0)
        -:  588:    {
      447:  589:      item->forward_code = node->re_nodes[shift]->forward_code;
      447:  590:      item->backward_code = node->re_nodes[shift]->backward_code;
      447:  591:      item->backtrack = 0;
      447:  592:      item->next = NULL;
        -:  593:
      447:  594:      *chosen_atoms = item;
      447:  595:      *atoms_quality = config->get_atom_quality(config, &item->atom);
        -:  596:    }
        -:  597:    else
        -:  598:    {
        3:  599:      yr_free(item);
        -:  600:    }
        -:  601:
      450:  602:    break;
        -:  603:
      363:  604:  case ATOM_TREE_OR:
        -:  605:
        -:  606:    // The choosen nodes are those coming from the highest quality child.
        -:  607:
      363:  608:    child = node->children_head;
        -:  609:
      862:  610:    while (child != NULL)
        -:  611:    {
     499*:  612:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
        -:  613:
      499:  614:      if (quality > max_quality)
        -:  615:      {
      351:  616:        max_quality = quality;
      351:  617:        yr_atoms_list_destroy(*chosen_atoms);
      351:  618:        *chosen_atoms = item;
        -:  619:      }
        -:  620:      else
        -:  621:      {
      148:  622:        yr_atoms_list_destroy(item);
        -:  623:      }
        -:  624:
      499:  625:      if (max_quality == YR_MAX_ATOM_QUALITY)
    #####:  626:        break;
        -:  627:
      499:  628:      child = child->next_sibling;
        -:  629:    }
        -:  630:
      363:  631:    *atoms_quality = max_quality;
      363:  632:    break;
        -:  633:
       49:  634:  case ATOM_TREE_AND:
        -:  635:
        -:  636:    // The choosen nodes are the concatenation of the the nodes choosen from
        -:  637:    // all the children.
        -:  638:
       49:  639:    child = node->children_head;
        -:  640:
      147:  641:    while (child != NULL)
        -:  642:    {
      98*:  643:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
        -:  644:
       98:  645:      if (quality < min_quality)
       62:  646:        min_quality = quality;
        -:  647:
       98:  648:      if (item != NULL)
        -:  649:      {
       94:  650:        tail = item;
      118:  651:        while (tail->next != NULL)
       24:  652:          tail = tail->next;
        -:  653:
       94:  654:        tail->next = *chosen_atoms;
       94:  655:        *chosen_atoms = item;
        -:  656:      }
        -:  657:
       98:  658:      child = child->next_sibling;
        -:  659:    }
        -:  660:
       49:  661:    *atoms_quality = min_quality;
       49:  662:    break;
        -:  663:  }
        -:  664:
      862:  665:  return ERROR_SUCCESS;
        -:  666:}
        -:  667:
        -:  668:
        -:  669://
        -:  670:// _yr_atoms_case_combinations
        -:  671://
        -:  672:// Returns all combinations of lower and upper cases for a given atom. For
        -:  673:// atom "abc" the output would be "abc" "abC" "aBC" and so on. Resulting
        -:  674:// atoms are written into the output buffer in this format:
        -:  675://
        -:  676://  [size of atom 1] [atom 1]  ... [size of atom N] [atom N] [0]
        -:  677://
        -:  678:// Notice the zero at the end to indicate where the output ends.
        -:  679://
        -:  680:// The caller is responsible of providing a buffer large enough to hold the
        -:  681:// returned atoms.
        -:  682://
        -:  683:
       88:  684:static uint8_t* _yr_atoms_case_combinations(
        -:  685:    uint8_t* atom,
        -:  686:    int atom_length,
        -:  687:    int atom_offset,
        -:  688:    uint8_t* output_buffer)
        -:  689:{
        -:  690:  uint8_t c;
        -:  691:  uint8_t* new_atom;
        -:  692:
       88:  693:  if (atom_offset + 1 < atom_length)
       40:  694:    output_buffer = _yr_atoms_case_combinations(
        -:  695:        atom,
        -:  696:        atom_length,
        -:  697:        atom_offset + 1,
        -:  698:        output_buffer);
        -:  699:
       88:  700:  c = atom[atom_offset];
        -:  701:
       88:  702:  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
        -:  703:  {
        -:  704:    // Write atom length.
       82:  705:    *output_buffer = atom_length;
       82:  706:    output_buffer++;
        -:  707:
       82:  708:    memcpy(output_buffer, atom, atom_length);
        -:  709:
       82:  710:    new_atom = output_buffer;
       82:  711:    output_buffer += atom_length;
        -:  712:
        -:  713:    // Swap character case.
       82:  714:    if (c >= 'a' && c <= 'z')
       81:  715:      new_atom[atom_offset] -= 32;
        -:  716:    else
        1:  717:      new_atom[atom_offset] += 32;
        -:  718:
       82:  719:    if (atom_offset + 1 < atom_length)
       38:  720:      output_buffer = _yr_atoms_case_combinations(
        -:  721:          new_atom,
        -:  722:          atom_length,
        -:  723:          atom_offset + 1,
        -:  724:          output_buffer);
        -:  725:  }
        -:  726:
       88:  727:  if (atom_offset == 0)
       10:  728:    *output_buffer = 0;
        -:  729:
       88:  730:  return output_buffer;
        -:  731:}
        -:  732:
        -:  733:// Size of buffer used in _yr_atoms_case_insensitive for storing the all
        -:  734:// the possible combinations for an atom. Each atom has up to YR_MAX_ATOM_LENGTH
        -:  735:// characters and each character has two possible values (upper and lower case).
        -:  736:// That means 2 ^ YR_MAX_ATOM_LENGTH combinations for an atom, where each atom
        -:  737:// occupies YR_MAX_ATOM_LENGTH + 1 bytes (the atom itself +1 byte for its length)
        -:  738:// One extra bytes is allocated for the zero value indicating the end.
        -:  739:
        -:  740:#define CASE_COMBINATIONS_BUFFER_SIZE \
        -:  741:    (1 << YR_MAX_ATOM_LENGTH) * (YR_MAX_ATOM_LENGTH + 1) + 1
        -:  742:
        -:  743://
        -:  744:// _yr_atoms_case_insensitive
        -:  745://
        -:  746:// For a given list of atoms returns another list of atoms
        -:  747:// with every case combination.
        -:  748://
        -:  749:
       10:  750:static int _yr_atoms_case_insensitive(
        -:  751:    YR_ATOM_LIST_ITEM* atoms,
        -:  752:    YR_ATOM_LIST_ITEM** case_insensitive_atoms)
        -:  753:{
        -:  754:  YR_ATOM_LIST_ITEM* atom;
        -:  755:  YR_ATOM_LIST_ITEM* new_atom;
        -:  756:
        -:  757:  uint8_t buffer[CASE_COMBINATIONS_BUFFER_SIZE];
        -:  758:  uint8_t atom_length;
        -:  759:  uint8_t* atoms_cursor;
        -:  760:
        -:  761:  int i;
        -:  762:
       10:  763:  *case_insensitive_atoms = NULL;
       10:  764:  atom = atoms;
        -:  765:
       20:  766:  while (atom != NULL)
        -:  767:  {
       10:  768:    _yr_atoms_case_combinations(
       10:  769:        atom->atom.bytes,
       10:  770:        atom->atom.length,
        -:  771:        0,
        -:  772:        buffer);
        -:  773:
       10:  774:    atoms_cursor = buffer;
       10:  775:    atom_length = *atoms_cursor;
       10:  776:    atoms_cursor++;
        -:  777:
       92:  778:    while (atom_length != 0)
        -:  779:    {
       82:  780:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  781:
       82:  782:      if (new_atom == NULL)
    #####:  783:        return ERROR_INSUFFICIENT_MEMORY;
        -:  784:
      361:  785:      for (i = 0; i < atom_length; i++)
        -:  786:      {
      279:  787:        new_atom->atom.bytes[i] = atoms_cursor[i];
      279:  788:        new_atom->atom.mask[i] = 0xFF;
        -:  789:      }
        -:  790:
       82:  791:      new_atom->atom.length = atom_length;
       82:  792:      new_atom->forward_code = atom->forward_code;
       82:  793:      new_atom->backward_code = atom->backward_code;
       82:  794:      new_atom->backtrack = atom->backtrack;
       82:  795:      new_atom->next = *case_insensitive_atoms;
        -:  796:
       82:  797:      *case_insensitive_atoms = new_atom;
        -:  798:
       82:  799:      atoms_cursor += atom_length;
       82:  800:      atom_length = *atoms_cursor;
       82:  801:      atoms_cursor++;
        -:  802:    }
        -:  803:
       10:  804:    atom = atom->next;
        -:  805:  }
        -:  806:
       10:  807:  return ERROR_SUCCESS;
        -:  808:}
        -:  809:
        -:  810:
        -:  811://
        -:  812:// _yr_atoms_xor
        -:  813://
        -:  814:// For a given list of atoms returns another list after a single byte xor
        -:  815:// has been applied to it.
        -:  816://
        -:  817:
    #####:  818:static int _yr_atoms_xor(
        -:  819:    YR_ATOM_LIST_ITEM* atoms,
        -:  820:    YR_ATOM_LIST_ITEM** xor_atoms)
        -:  821:{
        -:  822:  YR_ATOM_LIST_ITEM* atom;
        -:  823:  YR_ATOM_LIST_ITEM* new_atom;
        -:  824:
        -:  825:  int i, j;
    #####:  826:  *xor_atoms = NULL;
    #####:  827:  atom = atoms;
        -:  828:
    #####:  829:  while (atom != NULL)
        -:  830:  {
    #####:  831:    for (j = 1; j <= 255; j++)
        -:  832:    {
    #####:  833:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  834:
    #####:  835:      if (new_atom == NULL)
    #####:  836:        return ERROR_INSUFFICIENT_MEMORY;
        -:  837:
    #####:  838:      for (i = 0; i < atom->atom.length; i++)
        -:  839:      {
    #####:  840:        new_atom->atom.bytes[i] = atom->atom.bytes[i] ^ j;
    #####:  841:        new_atom->atom.mask[i] = 0xFF;
        -:  842:      }
        -:  843:
    #####:  844:      new_atom->atom.length = yr_min(atom->atom.length, YR_MAX_ATOM_LENGTH);
    #####:  845:      new_atom->forward_code = atom->forward_code;
    #####:  846:      new_atom->backward_code = atom->backward_code;
    #####:  847:      new_atom->backtrack = atom->backtrack;
    #####:  848:      new_atom->next = *xor_atoms;
        -:  849:
    #####:  850:      *xor_atoms = new_atom;
        -:  851:    }
        -:  852:
    #####:  853:    atom = atom->next;
        -:  854:  }
    #####:  855:  return ERROR_SUCCESS;
        -:  856:}
        -:  857:
        -:  858:
        -:  859://
        -:  860:// _yr_atoms_wide
        -:  861://
        -:  862:// For a given list of atoms returns another list with the corresponding
        -:  863:// wide atoms. Wide atoms are just the original atoms with interleaved zeroes,
        -:  864:// for example: 01 02 -> 01 00 02 00
        -:  865://
        -:  866:
       14:  867:static int _yr_atoms_wide(
        -:  868:    YR_ATOM_LIST_ITEM* atoms,
        -:  869:    YR_ATOM_LIST_ITEM** wide_atoms)
        -:  870:{
        -:  871:  YR_ATOM_LIST_ITEM* atom;
        -:  872:  YR_ATOM_LIST_ITEM* new_atom;
        -:  873:
        -:  874:  int i;
        -:  875:
       14:  876:  *wide_atoms = NULL;
       14:  877:  atom = atoms;
        -:  878:
       27:  879:  while (atom != NULL)
        -:  880:  {
       13:  881:    new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  882:
       13:  883:    if (new_atom == NULL)
    #####:  884:      return ERROR_INSUFFICIENT_MEMORY;
        -:  885:
       65:  886:    for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
        -:  887:    {
       52:  888:      new_atom->atom.bytes[i] = 0;
       52:  889:      new_atom->atom.mask[i] = 0xFF;
        -:  890:    }
        -:  891:
       37:  892:    for (i = 0; i < atom->atom.length; i++)
        -:  893:    {
       35:  894:      if (i * 2 < YR_MAX_ATOM_LENGTH)
       24:  895:        new_atom->atom.bytes[i * 2] = atom->atom.bytes[i];
        -:  896:      else
       11:  897:        break;
        -:  898:    }
        -:  899:
       13:  900:    new_atom->atom.length = yr_min(atom->atom.length * 2, YR_MAX_ATOM_LENGTH);
       13:  901:    new_atom->forward_code = atom->forward_code;
       13:  902:    new_atom->backward_code = atom->backward_code;
       13:  903:    new_atom->backtrack = atom->backtrack * 2;
       13:  904:    new_atom->next = *wide_atoms;
        -:  905:
       13:  906:    *wide_atoms = new_atom;
        -:  907:
       13:  908:    atom = atom->next;
        -:  909:  }
        -:  910:
       14:  911:  return ERROR_SUCCESS;
        -:  912:}
        -:  913:
        -:  914:
        -:  915:struct STACK_ITEM
        -:  916:{
        -:  917:  RE_NODE*             re_node;
        -:  918:  YR_ATOM_TREE_NODE*   new_appending_node;
        -:  919:};
        -:  920:
        -:  921:
        -:  922:#define make_atom_from_re_nodes(atom, nodes_length, nodes) \
        -:  923:    { \
        -:  924:      atom.length = nodes_length; \
        -:  925:      for (i = 0; i < atom.length; i++) \
        -:  926:      { \
        -:  927:        atom.bytes[i] = (uint8_t) (recent_re_nodes)[i]->value; \
        -:  928:        atom.mask[i] = (uint8_t) (recent_re_nodes)[i]->mask; \
        -:  929:      } \
        -:  930:    }
        -:  931:
        -:  932:
        -:  933://
        -:  934:// _yr_atoms_extract_from_re
        -:  935://
        -:  936:// Extract atoms from a regular expression. This is a helper function used by
        -:  937:// yr_atoms_extract_from_re that receives the abstract syntax tree for a regexp
        -:  938:// (or hex pattern) and builds an atom tree. The appending_node argument is a
        -:  939:// pointer to the ATOM_TREE_OR node at the root of the atom tree. This function
        -:  940:// creates the tree by appending new nodes to it.
        -:  941://
        -:  942:
      265:  943:static int _yr_atoms_extract_from_re(
        -:  944:    YR_ATOMS_CONFIG* config,
        -:  945:    RE_AST* re_ast,
        -:  946:    YR_ATOM_TREE_NODE* appending_node)
        -:  947:{
        -:  948:  YR_STACK* stack;
        -:  949:  RE_NODE* re_node;
        -:  950:
        -:  951:  YR_ATOM atom;
        -:  952:  YR_ATOM best_atom;
        -:  953:
        -:  954:  struct STACK_ITEM si;
        -:  955:
        -:  956:  int i, shift;
        -:  957:  int quality;
      265:  958:  int best_quality = -1;
      265:  959:  int n = 0;
        -:  960:
        -:  961:  YR_ATOM_TREE_NODE* and_node;
        -:  962:  YR_ATOM_TREE_NODE* left_node;
        -:  963:  YR_ATOM_TREE_NODE* right_node;
        -:  964:
        -:  965:  // The RE_NODEs most recently visited that can conform an atom (ie:
        -:  966:  // RE_NODE_LITERAL, RE_NODE_MASKED_LITERAL and RE_NODE_ANY). The number of
        -:  967:  // items in this array is n.
        -:  968:  RE_NODE* recent_re_nodes[YR_MAX_ATOM_LENGTH];
        -:  969:
        -:  970:  // The RE_NODEs corresponding to the best atom found so far for the current
        -:  971:  // appending node.
        -:  972:  RE_NODE* best_atom_re_nodes[YR_MAX_ATOM_LENGTH];
        -:  973:
        -:  974:  // This holds the ATOM_TREE_OR node where leaves (ATOM_TREE_LEAF) are
        -:  975:  // currently being appended.
      265:  976:  YR_ATOM_TREE_NODE* current_appending_node = NULL;
        -:  977:
        -:  978:  // This holds the ATOM_TREE_LEAF node whose atom is currently being updated.
      265:  979:  YR_ATOM_TREE_NODE* leaf = NULL;
        -:  980:
     265*:  981:  FAIL_ON_ERROR(yr_stack_create(1024, sizeof(si), &stack));
        -:  982:
        -:  983:  // This first item pushed in the stack is the last one to be poped out, the
        -:  984:  // sole purpose of this item is forcing that any pending leaf is appended to
        -:  985:  // current_appending_node during the last iteration of the loop.
      265:  986:  si.re_node = NULL;
      265:  987:  si.new_appending_node = appending_node;
        -:  988:
     265*:  989:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  990:      yr_stack_push(stack, (void*) &si),
        -:  991:      yr_stack_destroy(stack));
        -:  992:
        -:  993:  // Start processing the root node.
      265:  994:  si.re_node = re_ast->root_node;
        -:  995:
        -:  996:  // Leaf nodes are initially appended to the node passed in the appending_node,
        -:  997:  // argument which is the root ATOM_TREE_OR node that is empty at this point.
      265:  998:  si.new_appending_node = appending_node;
        -:  999:
     265*: 1000:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1001:      yr_stack_push(stack, (void*) &si),
        -: 1002:      yr_stack_destroy(stack));
        -: 1003:
     2663: 1004:  while (yr_stack_pop(stack, (void*) &si))
        -: 1005:  {
        -: 1006:    // Change the appending node if the item poped from the stack says so.
     2398: 1007:    if (si.new_appending_node != NULL)
        -: 1008:    {
        -: 1009:      // Before changing the appending node let's append any pending leaf to
        -: 1010:      // the current appending node.
     1046: 1011:      if (n > 0)
        -: 1012:      {
     1291: 1013:        make_atom_from_re_nodes(atom, n, recent_re_nodes);
      450: 1014:        shift = _yr_atoms_trim(&atom);
      450: 1015:        quality = config->get_atom_quality(config, &atom);
        -: 1016:
     450*: 1017:        FAIL_ON_NULL_WITH_CLEANUP(
        -: 1018:            leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF),
        -: 1019:            yr_stack_destroy(stack));
        -: 1020:
      450: 1021:        if (quality > best_quality)
        -: 1022:        {
      414: 1023:          memcpy(&leaf->atom, &atom, sizeof(atom));
      414: 1024:          memcpy(
      414: 1025:              &leaf->re_nodes,
      414: 1026:              &recent_re_nodes[shift],
      414: 1027:              sizeof(recent_re_nodes) - shift * sizeof(recent_re_nodes[0]));
        -: 1028:        }
        -: 1029:        else
        -: 1030:        {
       36: 1031:          memcpy(&leaf->atom, &best_atom, sizeof(best_atom));
       36: 1032:          memcpy(
       36: 1033:              &leaf->re_nodes,
        -: 1034:              &best_atom_re_nodes,
        -: 1035:              sizeof(best_atom_re_nodes));
        -: 1036:        }
        -: 1037:
      450: 1038:        _yr_atoms_tree_node_append(current_appending_node, leaf);
      450: 1039:        n = 0;
        -: 1040:      }
        -: 1041:
     1046: 1042:      current_appending_node = si.new_appending_node;
        -: 1043:    }
        -: 1044:
     2398: 1045:    if (si.re_node != NULL)
        -: 1046:    {
     1715: 1047:      switch(si.re_node->type)
        -: 1048:      {
      903: 1049:        case RE_NODE_LITERAL:
        -: 1050:        case RE_NODE_MASKED_LITERAL:
        -: 1051:        case RE_NODE_ANY:
        -: 1052:
      903: 1053:          if (n < YR_MAX_ATOM_LENGTH)
        -: 1054:          {
      841: 1055:            recent_re_nodes[n] = si.re_node;
      841: 1056:            best_atom_re_nodes[n] = si.re_node;
      841: 1057:            best_atom.bytes[n] = (uint8_t) si.re_node->value;
      841: 1058:            best_atom.mask[n] = (uint8_t) si.re_node->mask;
      841: 1059:            best_atom.length = ++n;
        -: 1060:          }
       62: 1061:          else if (best_quality < YR_MAX_ATOM_QUALITY)
        -: 1062:          {
      310: 1063:            make_atom_from_re_nodes(atom, n, recent_re_nodes);
       62: 1064:            shift = _yr_atoms_trim(&atom);
       62: 1065:            quality = config->get_atom_quality(config, &atom);
        -: 1066:
       62: 1067:            if (quality > best_quality)
        -: 1068:            {
       80: 1069:              for (i = 0; i < atom.length; i++)
        -: 1070:              {
       64: 1071:                best_atom.bytes[i] = atom.bytes[i];
       64: 1072:                best_atom.mask[i] = atom.mask[i];
       64: 1073:                best_atom_re_nodes[i] = recent_re_nodes[i + shift];
        -: 1074:              }
        -: 1075:
       16: 1076:              best_atom.length = atom.length;
       16: 1077:              best_quality = quality;
        -: 1078:            }
        -: 1079:
      248: 1080:            for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)
      186: 1081:              recent_re_nodes[i - 1] = recent_re_nodes[i];
        -: 1082:
       62: 1083:            recent_re_nodes[YR_MAX_ATOM_LENGTH - 1] = si.re_node;
        -: 1084:          }
        -: 1085:
      903: 1086:          break;
        -: 1087:
      394: 1088:        case RE_NODE_CONCAT:
        -: 1089:
      394: 1090:          re_node = si.re_node->children_tail;
        -: 1091:
        -: 1092:          // Push children right to left, they are poped left to right.
     1485: 1093:          while (re_node != NULL)
        -: 1094:          {
     1091: 1095:            si.new_appending_node = NULL;
     1091: 1096:            si.re_node = re_node;
        -: 1097:
    1091*: 1098:            FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1099:                yr_stack_push(stack, &si),
        -: 1100:                yr_stack_destroy(stack));
        -: 1101:
     1091: 1102:            re_node = re_node->prev_sibling;
        -: 1103:          }
        -: 1104:
      394: 1105:          break;
        -: 1106:
       49: 1107:        case RE_NODE_ALT:
        -: 1108:
        -: 1109:          // Create ATOM_TREE_AND node with two ATOM_TREE_OR children nodes.
       49: 1110:          and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);
       49: 1111:          left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
       49: 1112:          right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
        -: 1113:
       49: 1114:          if (and_node == NULL || left_node == NULL || right_node == NULL)
        -: 1115:          {
    #####: 1116:            _yr_atoms_tree_node_destroy(and_node);
    #####: 1117:            _yr_atoms_tree_node_destroy(left_node);
    #####: 1118:            _yr_atoms_tree_node_destroy(right_node);
        -: 1119:
    #####: 1120:            yr_stack_destroy(stack);
        -: 1121:
    #####: 1122:            return ERROR_INSUFFICIENT_MEMORY;
        -: 1123:          }
        -: 1124:
       49: 1125:          and_node->children_head = left_node;
       49: 1126:          and_node->children_tail = right_node;
       49: 1127:          left_node->next_sibling = right_node;
        -: 1128:
        -: 1129:          // Add the ATOM_TREE_AND as children of the current node.
       49: 1130:          _yr_atoms_tree_node_append(current_appending_node, and_node);
        -: 1131:
       49: 1132:          re_node = si.re_node;
        -: 1133:
       49: 1134:          si.new_appending_node = current_appending_node;
       49: 1135:          si.re_node = NULL;
        -: 1136:
      49*: 1137:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1138:              yr_stack_push(stack, &si),
        -: 1139:              yr_stack_destroy(stack));
        -: 1140:
        -: 1141:          // RE_NODE_ALT nodes has only two children, so children_head is the
        -: 1142:          // left one, and children_tail is right one.
       49: 1143:          si.new_appending_node = right_node;
       49: 1144:          si.re_node = re_node->children_tail;
        -: 1145:
      49*: 1146:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1147:              yr_stack_push(stack, &si),
        -: 1148:              yr_stack_destroy(stack));
        -: 1149:
       49: 1150:          si.new_appending_node = left_node;
       49: 1151:          si.re_node = re_node->children_head;
        -: 1152:
      49*: 1153:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1154:              yr_stack_push(stack, &si),
        -: 1155:              yr_stack_destroy(stack));
        -: 1156:
       49: 1157:          break;
        -: 1158:
       29: 1159:        case RE_NODE_PLUS:
        -: 1160:
       29: 1161:          re_node = si.re_node;
        -: 1162:
       29: 1163:          si.new_appending_node = current_appending_node;
       29: 1164:          si.re_node = NULL;
        -: 1165:
      29*: 1166:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1167:              yr_stack_push(stack, &si),
        -: 1168:              yr_stack_destroy(stack));
        -: 1169:
       29: 1170:          si.new_appending_node = NULL;
        -: 1171:          // RE_NODE_PLUS nodes has a single child, which is children_head.
       29: 1172:          si.re_node = re_node->children_head;
        -: 1173:
      29*: 1174:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1175:              yr_stack_push(stack, &si),
        -: 1176:              yr_stack_destroy(stack));
        -: 1177:
       29: 1178:          break;
        -: 1179:
      124: 1180:        case RE_NODE_RANGE:
        -: 1181:
      124: 1182:          re_node = si.re_node;
        -: 1183:
      124: 1184:          si.new_appending_node = current_appending_node;
      124: 1185:          si.re_node = NULL;
        -: 1186:
     124*: 1187:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1188:              yr_stack_push(stack, &si),
        -: 1189:              yr_stack_destroy(stack));
        -: 1190:
      124: 1191:          si.new_appending_node = NULL;
        -: 1192:          // RE_NODE_RANGE nodes has a single child, which is children_head.
      124: 1193:          si.re_node = re_node->children_head;
        -: 1194:
        -: 1195:          // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming
        -: 1196:          // that YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear
        -: 1197:          // at least 10 times in the matching string. Each call in the loop
        -: 1198:          // will append one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations
        -: 1199:          // are enough.
        -: 1200:
      356: 1201:          for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)
        -: 1202:          {
     232*: 1203:            FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1204:                yr_stack_push(stack, &si),
        -: 1205:                yr_stack_destroy(stack));
        -: 1206:          }
        -: 1207:
      124: 1208:          break;
        -: 1209:
      216: 1210:        case RE_NODE_RANGE_ANY:
        -: 1211:        case RE_NODE_STAR:
        -: 1212:        case RE_NODE_CLASS:
        -: 1213:        case RE_NODE_WORD_CHAR:
        -: 1214:        case RE_NODE_NON_WORD_CHAR:
        -: 1215:        case RE_NODE_SPACE:
        -: 1216:        case RE_NODE_NON_SPACE:
        -: 1217:        case RE_NODE_DIGIT:
        -: 1218:        case RE_NODE_NON_DIGIT:
        -: 1219:        case RE_NODE_EMPTY:
        -: 1220:        case RE_NODE_ANCHOR_START:
        -: 1221:        case RE_NODE_ANCHOR_END:
        -: 1222:        case RE_NODE_WORD_BOUNDARY:
        -: 1223:        case RE_NODE_NON_WORD_BOUNDARY:
        -: 1224:
      216: 1225:          si.new_appending_node = current_appending_node;
      216: 1226:          si.re_node = NULL;
        -: 1227:
     216*: 1228:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1229:              yr_stack_push(stack, &si),
        -: 1230:              yr_stack_destroy(stack));
        -: 1231:
      216: 1232:          break;
        -: 1233:
    #####: 1234:        default:
    #####: 1235:          assert(false);
        -: 1236:      }
        -: 1237:    }
        -: 1238:  }
        -: 1239:
      265: 1240:  yr_stack_destroy(stack);
        -: 1241:
      265: 1242:  return ERROR_SUCCESS;
        -: 1243:}
        -: 1244:
        -: 1245:
        -: 1246:
        -: 1247://
        -: 1248:// _yr_atoms_clone_list_item
        -: 1249://
        -: 1250:// Makes an exact copy of an YR_ATOM_LIST_ITEM.
        -: 1251://
        -: 1252:
     1020: 1253:static YR_ATOM_LIST_ITEM* _yr_atoms_clone_list_item(
        -: 1254:    YR_ATOM_LIST_ITEM* item)
        -: 1255:{
     1020: 1256:  YR_ATOM_LIST_ITEM* clone = (YR_ATOM_LIST_ITEM*) yr_malloc(
        -: 1257:      sizeof(YR_ATOM_LIST_ITEM));
        -: 1258:
     1020: 1259:  if (clone == NULL)
    #####: 1260:    return NULL;
        -: 1261:
     1020: 1262:  memcpy(clone, item, sizeof(YR_ATOM_LIST_ITEM));
        -: 1263:
     1020: 1264:  return clone;
        -: 1265:}
        -: 1266:
        -: 1267:
        -: 1268://
        -: 1269:// _yr_atoms_expand_wildcards
        -: 1270://
        -: 1271:// Given list of atoms that may contain wildcards, replace those wildcarded
        -: 1272:// atoms with a list of non-wildcarded atoms covering all the combinations
        -: 1273:// allowed by the wildcarded atom. For example, the atom {01 ?2 03} will be
        -: 1274:// replaced by {01 02 03}, {01 12 03}, {01 22 03} .. {01 F2 03}. The list
        -: 1275:// is modified in-place.
        -: 1276://
        -: 1277:// Args:
        -: 1278://   YR_ATOM_LIST_ITEM* atoms   -  Pointer to first element of the list.
        -: 1279://
        -: 1280:// Returns:
        -: 1281://   ERROR_SUCCESS or ERROR_INSUFFICIENT_MEMORY.
        -: 1282://
        -: 1283:
      265: 1284:static int _yr_atoms_expand_wildcards(
        -: 1285:    YR_ATOM_LIST_ITEM* atoms)
        -: 1286:{
        -: 1287:  int i;
        -: 1288:
      265: 1289:  YR_ATOM_LIST_ITEM* atom = atoms;
        -: 1290:  YR_ATOM_LIST_ITEM* new_atom;
        -: 1291:  YR_ATOM_LIST_ITEM* prev_atom;
        -: 1292:  YR_ATOM_LIST_ITEM* next_atom;
        -: 1293:
     1558: 1294:  while (atom != NULL)
        -: 1295:  {
     1293: 1296:    bool expanded = false;
        -: 1297:
     5183: 1298:    for (i = 0; i < atom->atom.length; i++)
        -: 1299:    {
     3890: 1300:      uint16_t a, s, e, incr = 1;
        -: 1301:
     3890: 1302:      switch(atom->atom.mask[i])
        -: 1303:      {
        4: 1304:        case 0x00:
        4: 1305:          expanded = true;
        4: 1306:          s = 0x00;
        4: 1307:          e = 0xFF;
        4: 1308:          break;
        -: 1309:
    #####: 1310:        case 0x0F:
    #####: 1311:          expanded = true;
    #####: 1312:          s = atom->atom.bytes[i];
    #####: 1313:          e = atom->atom.bytes[i] | 0xF0;
    #####: 1314:          incr = 0x10;
    #####: 1315:          break;
        -: 1316:
    #####: 1317:        case 0xF0:
    #####: 1318:          expanded = true;
    #####: 1319:          s = atom->atom.bytes[i];
    #####: 1320:          e = atom->atom.bytes[i] | 0x0F;
    #####: 1321:          break;
        -: 1322:
     3886: 1323:        default:
     3886: 1324:          s = 0;
     3886: 1325:          e = 0;
        -: 1326:      }
        -: 1327:
     3890: 1328:      if (s != e)
        -: 1329:      {
        4: 1330:        atom->atom.bytes[i] = (uint8_t) s;
        4: 1331:        atom->atom.mask[i] = 0xFF;
        -: 1332:      }
        -: 1333:
     3890: 1334:      prev_atom = atom;
     3890: 1335:      next_atom = atom->next;
        -: 1336:
     4910: 1337:      for (a = s + incr; a <= e; a += incr)
        -: 1338:      {
     1020: 1339:        new_atom = _yr_atoms_clone_list_item(atom);
        -: 1340:
     1020: 1341:        if (new_atom == NULL)
    #####: 1342:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1343:
     1020: 1344:        new_atom->atom.bytes[i] = (uint8_t) a;
     1020: 1345:        new_atom->atom.mask[i] = 0xFF;
     1020: 1346:        new_atom->next = next_atom;
     1020: 1347:        prev_atom->next = new_atom;
     1020: 1348:        prev_atom = new_atom;
        -: 1349:      }
        -: 1350:    }
        -: 1351:
     1293: 1352:    if (!expanded)
     1289: 1353:      atom = atom->next;
        -: 1354:  }
        -: 1355:
      265: 1356:  return ERROR_SUCCESS;
        -: 1357:}
        -: 1358:
        -: 1359:
        -: 1360://
        -: 1361:// yr_atoms_extract_from_re
        -: 1362://
        -: 1363:// Extract atoms from a regular expression. This function receives the abstract
        -: 1364:// syntax tree for a regexp (or hex pattern) and returns a list of atoms that
        -: 1365:// should be added to the Aho-Corasick automaton.
        -: 1366://
        -: 1367:
      265: 1368:int yr_atoms_extract_from_re(
        -: 1369:    YR_ATOMS_CONFIG* config,
        -: 1370:    RE_AST* re_ast,
        -: 1371:    int flags,
        -: 1372:    YR_ATOM_LIST_ITEM** atoms,
        -: 1373:    int* min_atom_quality)
        -: 1374:{
      265: 1375:  YR_ATOM_TREE* atom_tree = (YR_ATOM_TREE*) yr_malloc(sizeof(YR_ATOM_TREE));
        -: 1376:
        -: 1377:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1378:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1379:
      265: 1380:  if (atom_tree == NULL)
    #####: 1381:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1382:
      265: 1383:  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
        -: 1384:
      265: 1385:  if (atom_tree->root_node == NULL)
        -: 1386:  {
    #####: 1387:    _yr_atoms_tree_destroy(atom_tree);
    #####: 1388:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1389:  }
        -: 1390:
     265*: 1391:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1392:      _yr_atoms_extract_from_re(config, re_ast, atom_tree->root_node),
        -: 1393:      _yr_atoms_tree_destroy(atom_tree));
        -: 1394:
        -: 1395:  // Initialize atom list
      265: 1396:  *atoms = NULL;
        -: 1397:
        -: 1398:  // Choose the atoms that will be used.
     265*: 1399:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1400:      _yr_atoms_choose(config, atom_tree->root_node, atoms, min_atom_quality),
        -: 1401:      _yr_atoms_tree_destroy(atom_tree));
        -: 1402:
      265: 1403:  _yr_atoms_tree_destroy(atom_tree);
        -: 1404:
     265*: 1405:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1406:      _yr_atoms_expand_wildcards(*atoms),
        -: 1407:      {
        -: 1408:        yr_atoms_list_destroy(*atoms);
        -: 1409:        *atoms = NULL;
        -: 1410:      });
        -: 1411:
      265: 1412:  if (flags & STRING_GFLAGS_WIDE)
        -: 1413:  {
      13*: 1414:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1415:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1416:        {
        -: 1417:          yr_atoms_list_destroy(*atoms);
        -: 1418:          yr_atoms_list_destroy(wide_atoms);
        -: 1419:          *atoms = NULL;
        -: 1420:        });
        -: 1421:
       13: 1422:    if (flags & STRING_GFLAGS_ASCII)
        -: 1423:    {
    #####: 1424:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1425:    }
        -: 1426:    else
        -: 1427:    {
       13: 1428:      yr_atoms_list_destroy(*atoms);
       13: 1429:      *atoms = wide_atoms;
        -: 1430:    }
        -: 1431:  }
        -: 1432:
      265: 1433:  if (flags & STRING_GFLAGS_NO_CASE)
        -: 1434:  {
       8*: 1435:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1436:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1437:        {
        -: 1438:          yr_atoms_list_destroy(*atoms);
        -: 1439:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1440:          *atoms = NULL;
        -: 1441:        });
        -: 1442:
        8: 1443:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1444:  }
        -: 1445:
        -: 1446:  // No atoms has been extracted, let's add a zero-length atom.
        -: 1447:
      265: 1448:  if (*atoms == NULL)
        -: 1449:  {
       34: 1450:    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1451:
       34: 1452:    if (*atoms == NULL)
    #####: 1453:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1454:
       34: 1455:    (*atoms)->atom.length = 0;
       34: 1456:    (*atoms)->backtrack = 0;
       34: 1457:    (*atoms)->forward_code = re_ast->root_node->forward_code;
       34: 1458:    (*atoms)->backward_code = NULL;
       34: 1459:    (*atoms)->next = NULL;
        -: 1460:  }
        -: 1461:
      265: 1462:  return ERROR_SUCCESS;
        -: 1463:}
        -: 1464:
        -: 1465:
        -: 1466://
        -: 1467:// yr_atoms_extract_from_string
        -: 1468://
        -: 1469:// Extract atoms from a string.
        -: 1470://
        -: 1471:
       17: 1472:int yr_atoms_extract_from_string(
        -: 1473:    YR_ATOMS_CONFIG* config,
        -: 1474:    uint8_t* string,
        -: 1475:    int32_t string_length,
        -: 1476:    int flags,
        -: 1477:    YR_ATOM_LIST_ITEM** atoms,
        -: 1478:    int* min_atom_quality)
        -: 1479:{
        -: 1480:  YR_ATOM_LIST_ITEM* item;
        -: 1481:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1482:  YR_ATOM_LIST_ITEM* xor_atoms;
        -: 1483:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1484:
        -: 1485:  YR_ATOM atom;
        -: 1486:
        -: 1487:  int quality, max_quality;
        -: 1488:  int i;
        -: 1489:
       17: 1490:  item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1491:
       17: 1492:  if (item == NULL)
    #####: 1493:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1494:
       17: 1495:  item->forward_code = NULL;
       17: 1496:  item->backward_code = NULL;
       17: 1497:  item->next = NULL;
       17: 1498:  item->backtrack = 0;
        -: 1499:
       17: 1500:  item->atom.length = yr_min(string_length, YR_MAX_ATOM_LENGTH);
        -: 1501:
       70: 1502:  for (i = 0; i < item->atom.length; i++)
        -: 1503:  {
       53: 1504:    item->atom.bytes[i] = string[i];
       53: 1505:    item->atom.mask[i] = 0xFF;
        -: 1506:  }
        -: 1507:
       17: 1508:  max_quality = config->get_atom_quality(config, &item->atom);
        -: 1509:
       17: 1510:  atom.length = YR_MAX_ATOM_LENGTH;
       17: 1511:  memset(atom.mask, 0xFF, atom.length);
        -: 1512:
       28: 1513:  for (i = YR_MAX_ATOM_LENGTH;
       12: 1514:       i < string_length && max_quality < YR_MAX_ATOM_QUALITY;
       11: 1515:       i++)
        -: 1516:  {
       11: 1517:    atom.length = YR_MAX_ATOM_LENGTH;
       11: 1518:    memcpy(atom.bytes, string + i - YR_MAX_ATOM_LENGTH + 1, atom.length);
        -: 1519:
       11: 1520:    quality = config->get_atom_quality(config, &atom);
        -: 1521:
       11: 1522:    if (quality > max_quality)
        -: 1523:    {
        1: 1524:      memcpy(&item->atom, &atom, sizeof(atom));
        1: 1525:      item->backtrack = i - YR_MAX_ATOM_LENGTH + 1;
        1: 1526:      max_quality = quality;
        -: 1527:    }
        -: 1528:  }
        -: 1529:
       17: 1530:  *atoms = item;
       17: 1531:  *min_atom_quality = max_quality;
        -: 1532:
       17: 1533:  if (flags & STRING_GFLAGS_WIDE)
        -: 1534:  {
       1*: 1535:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1536:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1537:        {
        -: 1538:          yr_atoms_list_destroy(*atoms);
        -: 1539:          yr_atoms_list_destroy(wide_atoms);
        -: 1540:          *atoms = NULL;
        -: 1541:        });
        -: 1542:
        1: 1543:    if (flags & STRING_GFLAGS_ASCII)
        -: 1544:    {
    #####: 1545:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1546:    }
        -: 1547:    else
        -: 1548:    {
        1: 1549:      yr_atoms_list_destroy(*atoms);
        1: 1550:      *atoms = wide_atoms;
        -: 1551:    }
        -: 1552:  }
        -: 1553:
       17: 1554:  if (flags & STRING_GFLAGS_NO_CASE)
        -: 1555:  {
       2*: 1556:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1557:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1558:        {
        -: 1559:          yr_atoms_list_destroy(*atoms);
        -: 1560:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1561:          *atoms = NULL;
        -: 1562:        });
        -: 1563:
        2: 1564:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1565:  }
        -: 1566:
       17: 1567:  if (flags & STRING_GFLAGS_XOR)
        -: 1568:  {
    #####: 1569:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1570:      _yr_atoms_xor(*atoms, &xor_atoms),
        -: 1571:      {
        -: 1572:        yr_atoms_list_destroy(*atoms);
        -: 1573:        yr_atoms_list_destroy(xor_atoms);
        -: 1574:        *atoms = NULL;
        -: 1575:      });
        -: 1576:
    #####: 1577:    *atoms = _yr_atoms_list_concat(*atoms, xor_atoms);
        -: 1578:  }
        -: 1579:
       17: 1580:  return ERROR_SUCCESS;
        -: 1581:}
        -: 1582:
        -: 1583:
        -: 1584://
        -: 1585:// yr_atoms_tree_node_print
        -: 1586://
        -: 1587:// Prints an atom tree node. Used only for debugging purposes.
        -: 1588://
        -: 1589:
    #####: 1590:void yr_atoms_tree_node_print(
        -: 1591:    YR_ATOM_TREE_NODE* node)
        -: 1592:{
        -: 1593:  YR_ATOM_TREE_NODE* child;
        -: 1594:  int i;
        -: 1595:
    #####: 1596:  if (node == NULL)
        -: 1597:  {
    #####: 1598:    printf("Empty tree node\n");
    #####: 1599:    return;
        -: 1600:  }
        -: 1601:
    #####: 1602:  switch(node->type)
        -: 1603:  {
    #####: 1604:  case ATOM_TREE_LEAF:
    #####: 1605:    for (i = 0; i < node->atom.length; i++)
    #####: 1606:      printf("%02X", node->atom.bytes[i]);
    #####: 1607:    break;
        -: 1608:
    #####: 1609:  case ATOM_TREE_AND:
        -: 1610:  case ATOM_TREE_OR:
    #####: 1611:    if (node->type == ATOM_TREE_AND)
    #####: 1612:      printf("AND");
        -: 1613:    else
    #####: 1614:      printf("OR");
    #####: 1615:    printf("(");
    #####: 1616:    child = node->children_head;
    #####: 1617:    while (child != NULL)
        -: 1618:    {
    #####: 1619:      yr_atoms_tree_node_print(child);
    #####: 1620:      child = child->next_sibling;
    #####: 1621:      if (child != NULL)
    #####: 1622:        printf(",");
        -: 1623:    }
    #####: 1624:    printf(")");
    #####: 1625:    break;
        -: 1626:  }
        -: 1627:}
