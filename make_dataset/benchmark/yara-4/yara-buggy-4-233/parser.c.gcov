        -:    0:Source:parser.c
        -:    0:Graph:/home/workspace/libyara/parser.gcno
        -:    0:Data:/home/workspace/libyara/parser.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <stddef.h>
        -:   31:#include <string.h>
        -:   32:
        -:   33:#include <yara/ahocorasick.h>
        -:   34:#include <yara/arena.h>
        -:   35:#include <yara/re.h>
        -:   36:#include <yara/error.h>
        -:   37:#include <yara/exec.h>
        -:   38:#include <yara/object.h>
        -:   39:#include <yara/strutils.h>
        -:   40:#include <yara/utils.h>
        -:   41:#include <yara/modules.h>
        -:   42:#include <yara/parser.h>
        -:   43:#include <yara/mem.h>
        -:   44:
        -:   45:#define todigit(x)  ((x) >='A'&& (x) <='F')? \
        -:   46:                    ((uint8_t) (x - 'A' + 10)) : \
        -:   47:                    ((uint8_t) (x - '0'))
        -:   48:
        -:   49:
      860:   50:int yr_parser_emit(
        -:   51:    yyscan_t yyscanner,
        -:   52:    uint8_t instruction,
        -:   53:    uint8_t** instruction_address)
        -:   54:{
      860:   55:  return yr_arena_write_data(
      860:   56:      yyget_extra(yyscanner)->code_arena,
        -:   57:      &instruction,
        -:   58:      sizeof(int8_t),
        -:   59:      (void**) instruction_address);
        -:   60:}
        -:   61:
        -:   62:
    #####:   63:int yr_parser_emit_with_arg_double(
        -:   64:    yyscan_t yyscanner,
        -:   65:    uint8_t instruction,
        -:   66:    double argument,
        -:   67:    uint8_t** instruction_address,
        -:   68:    double** argument_address)
        -:   69:{
    #####:   70:  int result = yr_arena_write_data(
    #####:   71:      yyget_extra(yyscanner)->code_arena,
        -:   72:      &instruction,
        -:   73:      sizeof(uint8_t),
        -:   74:      (void**) instruction_address);
        -:   75:
    #####:   76:  if (result == ERROR_SUCCESS)
    #####:   77:    result = yr_arena_write_data(
    #####:   78:        yyget_extra(yyscanner)->code_arena,
        -:   79:        &argument,
        -:   80:        sizeof(double),
        -:   81:        (void**) argument_address);
        -:   82:
    #####:   83:  return result;
        -:   84:}
        -:   85:
        -:   86:
        8:   87:int yr_parser_emit_with_arg(
        -:   88:    yyscan_t yyscanner,
        -:   89:    uint8_t instruction,
        -:   90:    int64_t argument,
        -:   91:    uint8_t** instruction_address,
        -:   92:    int64_t** argument_address)
        -:   93:{
        8:   94:  int result = yr_arena_write_data(
        8:   95:      yyget_extra(yyscanner)->code_arena,
        -:   96:      &instruction,
        -:   97:      sizeof(uint8_t),
        -:   98:      (void**) instruction_address);
        -:   99:
        8:  100:  if (result == ERROR_SUCCESS)
        8:  101:    result = yr_arena_write_data(
        8:  102:        yyget_extra(yyscanner)->code_arena,
        -:  103:        &argument,
        -:  104:        sizeof(int64_t),
        -:  105:        (void**) argument_address);
        -:  106:
        8:  107:  return result;
        -:  108:}
        -:  109:
        -:  110:
      560:  111:int yr_parser_emit_with_arg_reloc(
        -:  112:    yyscan_t yyscanner,
        -:  113:    uint8_t instruction,
        -:  114:    void* argument,
        -:  115:    uint8_t** instruction_address,
        -:  116:    void** argument_address)
        -:  117:{
      560:  118:  int64_t* ptr = NULL;
        -:  119:  int result;
        -:  120:
        -:  121:  DECLARE_REFERENCE(void*, ptr) arg;
        -:  122:
      560:  123:  memset(&arg, 0, sizeof(arg));
      560:  124:  arg.ptr = argument;
        -:  125:
      560:  126:  result = yr_arena_write_data(
      560:  127:      yyget_extra(yyscanner)->code_arena,
        -:  128:      &instruction,
        -:  129:      sizeof(uint8_t),
        -:  130:      (void**) instruction_address);
        -:  131:
      560:  132:  if (result == ERROR_SUCCESS)
      560:  133:    result = yr_arena_write_data(
      560:  134:        yyget_extra(yyscanner)->code_arena,
        -:  135:        &arg,
        -:  136:        sizeof(arg),
        -:  137:        (void**) &ptr);
        -:  138:
      560:  139:  if (result == ERROR_SUCCESS)
      560:  140:    result = yr_arena_make_ptr_relocatable(
      560:  141:        yyget_extra(yyscanner)->code_arena,
        -:  142:        ptr,
        -:  143:        0,
        -:  144:        EOL);
        -:  145:
      560:  146:  if (argument_address != NULL)
    #####:  147:    *argument_address = (void*) ptr;
        -:  148:
      560:  149:  return result;
        -:  150:}
        -:  151:
        -:  152:
    #####:  153:int yr_parser_emit_pushes_for_strings(
        -:  154:    yyscan_t yyscanner,
        -:  155:    const char* identifier)
        -:  156:{
    #####:  157:  YR_COMPILER* compiler = yyget_extra(yyscanner);
    #####:  158:  YR_STRING* string = compiler->current_rule->strings;
        -:  159:
        -:  160:  const char* string_identifier;
        -:  161:  const char* target_identifier;
        -:  162:
    #####:  163:  int matching = 0;
        -:  164:
    #####:  165:  while(!STRING_IS_NULL(string))
        -:  166:  {
        -:  167:    // Don't generate pushes for strings chained to another one, we are
        -:  168:    // only interested in non-chained strings or the head of the chain.
        -:  169:
    #####:  170:    if (string->chained_to == NULL)
        -:  171:    {
    #####:  172:      string_identifier = string->identifier;
    #####:  173:      target_identifier = identifier;
        -:  174:
    #####:  175:      while (*target_identifier != '\0' &&
    #####:  176:             *string_identifier != '\0' &&
    #####:  177:             *target_identifier == *string_identifier)
        -:  178:      {
    #####:  179:        target_identifier++;
    #####:  180:        string_identifier++;
        -:  181:      }
        -:  182:
    #####:  183:      if ((*target_identifier == '\0' && *string_identifier == '\0') ||
    #####:  184:           *target_identifier == '*')
        -:  185:      {
    #####:  186:        yr_parser_emit_with_arg_reloc(
        -:  187:            yyscanner,
        -:  188:            OP_PUSH,
        -:  189:            string,
        -:  190:            NULL,
        -:  191:            NULL);
        -:  192:
    #####:  193:        string->g_flags |= STRING_GFLAGS_REFERENCED;
    #####:  194:        string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
    #####:  195:        matching++;
        -:  196:      }
        -:  197:    }
        -:  198:
    #####:  199:    string = (YR_STRING*) yr_arena_next_address(
        -:  200:        compiler->strings_arena,
        -:  201:        string,
        -:  202:        sizeof(YR_STRING));
        -:  203:  }
        -:  204:
    #####:  205:  if (matching == 0)
        -:  206:  {
    #####:  207:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  208:    return ERROR_UNDEFINED_STRING;
        -:  209:  }
        -:  210:
    #####:  211:  return ERROR_SUCCESS;
        -:  212:}
        -:  213:
        -:  214:
    #####:  215:int yr_parser_check_types(
        -:  216:    YR_COMPILER* compiler,
        -:  217:    YR_OBJECT_FUNCTION* function,
        -:  218:    const char* actual_args_fmt)
        -:  219:{
        -:  220:  int i;
        -:  221:
    #####:  222:  for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  223:  {
    #####:  224:    if (function->prototypes[i].arguments_fmt == NULL)
    #####:  225:      break;
        -:  226:
    #####:  227:    if (strcmp(function->prototypes[i].arguments_fmt, actual_args_fmt) == 0)
    #####:  228:      return ERROR_SUCCESS;
        -:  229:  }
        -:  230:
    #####:  231:  yr_compiler_set_error_extra_info(compiler, function->identifier);
        -:  232:
    #####:  233:  return ERROR_WRONG_ARGUMENTS;
        -:  234:}
        -:  235:
        -:  236:
      280:  237:int yr_parser_lookup_string(
        -:  238:    yyscan_t yyscanner,
        -:  239:    const char* identifier,
        -:  240:    YR_STRING** string)
        -:  241:{
      280:  242:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  243:
      280:  244:  *string = compiler->current_rule->strings;
        -:  245:
      280:  246:  while(!STRING_IS_NULL(*string))
        -:  247:  {
        -:  248:    // If some string $a gets fragmented into multiple chained
        -:  249:    // strings, all those fragments have the same $a identifier
        -:  250:    // but we are interested in the heading fragment, which is
        -:  251:    // that with chained_to == NULL
        -:  252:
      280:  253:    if (strcmp((*string)->identifier, identifier) == 0 &&
      280:  254:        (*string)->chained_to == NULL)
        -:  255:    {
      280:  256:      return ERROR_SUCCESS;
        -:  257:    }
        -:  258:
    #####:  259:    *string = (YR_STRING*) yr_arena_next_address(
        -:  260:        compiler->strings_arena,
        -:  261:        *string,
        -:  262:        sizeof(YR_STRING));
        -:  263:  }
        -:  264:
    #####:  265:  yr_compiler_set_error_extra_info(compiler, identifier);
        -:  266:
    #####:  267:  *string = NULL;
        -:  268:
    #####:  269:  return ERROR_UNDEFINED_STRING;
        -:  270:}
        -:  271:
        -:  272:
    #####:  273:int yr_parser_lookup_loop_variable(
        -:  274:    yyscan_t yyscanner,
        -:  275:    const char* identifier)
        -:  276:{
    #####:  277:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  278:  int i;
        -:  279:
    #####:  280:  for (i = 0; i < compiler->loop_depth; i++)
        -:  281:  {
    #####:  282:    if (compiler->loop_identifier[i] != NULL &&
    #####:  283:        strcmp(identifier, compiler->loop_identifier[i]) == 0)
    #####:  284:      return i;
        -:  285:  }
        -:  286:
    #####:  287:  return -1;
        -:  288:}
        -:  289:
        -:  290:
      282:  291:static int _yr_parser_write_string(
        -:  292:    const char* identifier,
        -:  293:    int flags,
        -:  294:    YR_COMPILER* compiler,
        -:  295:    SIZED_STRING* str,
        -:  296:    RE_AST* re_ast,
        -:  297:    YR_STRING** string,
        -:  298:    int* min_atom_quality,
        -:  299:    int* num_atom)
        -:  300:{
        -:  301:  SIZED_STRING* literal_string;
        -:  302:  YR_ATOM_LIST_ITEM* atom;
      282:  303:  YR_ATOM_LIST_ITEM* atom_list = NULL;
        -:  304:
        -:  305:  int c, result;
        -:  306:  int max_string_len;
      282:  307:  bool free_literal = false;
        -:  308:
      282:  309:  *string = NULL;
        -:  310:
      282:  311:  result = yr_arena_allocate_struct(
        -:  312:      compiler->strings_arena,
        -:  313:      sizeof(YR_STRING),
        -:  314:      (void**) string,
        -:  315:      offsetof(YR_STRING, identifier),
        -:  316:      offsetof(YR_STRING, string),
        -:  317:      offsetof(YR_STRING, chained_to),
        -:  318:      offsetof(YR_STRING, rule),
        -:  319:      EOL);
        -:  320:
      282:  321:  if (result != ERROR_SUCCESS)
    #####:  322:    return result;
        -:  323:
      282:  324:  result = yr_arena_write_string(
        -:  325:      compiler->sz_arena,
        -:  326:      identifier,
      282:  327:      &(*string)->identifier);
        -:  328:
      282:  329:  if (result != ERROR_SUCCESS)
    #####:  330:    return result;
        -:  331:
      282:  332:  if (flags & STRING_GFLAGS_HEXADECIMAL ||
      282:  333:      flags & STRING_GFLAGS_REGEXP)
        -:  334:  {
      281:  335:    literal_string = yr_re_ast_extract_literal(re_ast);
        -:  336:
      281:  337:    if (literal_string != NULL)
        -:  338:    {
       16:  339:      flags |= STRING_GFLAGS_LITERAL;
       16:  340:      free_literal = true;
        -:  341:    }
        -:  342:    else
        -:  343:    {
        -:  344:      // Non-literal strings can't be marked as fixed offset because once we
        -:  345:      // find a string atom in the scanned data we don't know the offset where
        -:  346:      // the string should start, as the non-literal strings can contain
        -:  347:      // variable-length portions.
        -:  348:
      265:  349:      flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  350:    }
        -:  351:  }
        -:  352:  else
        -:  353:  {
        1:  354:    literal_string = str;
        1:  355:    flags |= STRING_GFLAGS_LITERAL;
        -:  356:  }
        -:  357:
      282:  358:  (*string)->g_flags = flags;
      282:  359:  (*string)->chained_to = NULL;
      282:  360:  (*string)->fixed_offset = UNDEFINED;
      282:  361:  (*string)->rule = compiler->current_rule;
        -:  362:
      282:  363:  memset((*string)->matches, 0,
        -:  364:         sizeof((*string)->matches));
        -:  365:
      282:  366:  memset((*string)->private_matches, 0,
        -:  367:         sizeof((*string)->private_matches));
        -:  368:
      282:  369:  memset((*string)->unconfirmed_matches, 0,
        -:  370:         sizeof((*string)->unconfirmed_matches));
        -:  371:
      282:  372:  if (flags & STRING_GFLAGS_LITERAL)
        -:  373:  {
       17:  374:    (*string)->length = (uint32_t) literal_string->length;
        -:  375:
       17:  376:    result = yr_arena_write_data(
        -:  377:        compiler->sz_arena,
       17:  378:        literal_string->c_string,
       17:  379:        literal_string->length + 1,   // +1 to include terminating NULL
       17:  380:        (void**) &(*string)->string);
        -:  381:
       17:  382:    if (result == ERROR_SUCCESS)
        -:  383:    {
       17:  384:      result = yr_atoms_extract_from_string(
        -:  385:          &compiler->atoms_config,
       17:  386:          (uint8_t*) literal_string->c_string,
       17:  387:          (int32_t) literal_string->length,
        -:  388:          flags,
        -:  389:          &atom_list,
        -:  390:          min_atom_quality);
        -:  391:    }
        -:  392:  }
        -:  393:  else
        -:  394:  {
        -:  395:    // Emit forwards code
      265:  396:    result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, false);
        -:  397:
        -:  398:    // Emit backwards code
      265:  399:    if (result == ERROR_SUCCESS)
      265:  400:      result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, true);
        -:  401:
      265:  402:    if (result == ERROR_SUCCESS)
      265:  403:      result = yr_atoms_extract_from_re(
        -:  404:          &compiler->atoms_config,
        -:  405:          re_ast,
        -:  406:          flags,
        -:  407:          &atom_list,
        -:  408:          min_atom_quality);
        -:  409:  }
        -:  410:
      282:  411:  if (result == ERROR_SUCCESS)
        -:  412:  {
        -:  413:    // Add the string to Aho-Corasick automaton.
      282:  414:    result = yr_ac_add_string(
        -:  415:        compiler->automaton,
        -:  416:        *string,
        -:  417:        atom_list,
        -:  418:        compiler->matches_arena);
        -:  419:  }
        -:  420:
      282:  421:  if (flags & STRING_GFLAGS_LITERAL)
        -:  422:  {
       17:  423:    if (flags & STRING_GFLAGS_WIDE)
        1:  424:      max_string_len = (*string)->length * 2;
        -:  425:    else
       16:  426:      max_string_len = (*string)->length;
        -:  427:
       17:  428:    if (max_string_len <= YR_MAX_ATOM_LENGTH)
       12:  429:      (*string)->g_flags |= STRING_GFLAGS_FITS_IN_ATOM;
        -:  430:  }
        -:  431:
      282:  432:  atom = atom_list;
      282:  433:  c = 0;
        -:  434:
     1704:  435:  while (atom != NULL)
        -:  436:  {
     1422:  437:    atom = atom->next;
     1422:  438:    c++;
        -:  439:  }
        -:  440:
      282:  441:  (*num_atom) += c;
        -:  442:
      282:  443:  if (free_literal)
       16:  444:    yr_free(literal_string);
        -:  445:
      282:  446:  if (atom_list != NULL)
      282:  447:    yr_atoms_list_destroy(atom_list);
        -:  448:
      282:  449:  return result;
        -:  450:}
        -:  451:
        -:  452:#include <limits.h>
        -:  453:
        -:  454:#include <yara/integers.h>
        -:  455:
        -:  456:
      294:  457:int yr_parser_reduce_string_declaration(
        -:  458:    yyscan_t yyscanner,
        -:  459:    int32_t string_flags,
        -:  460:    const char* identifier,
        -:  461:    SIZED_STRING* str,
        -:  462:    YR_STRING** string)
        -:  463:{
      294:  464:  int min_atom_quality = YR_MAX_ATOM_QUALITY;
        -:  465:  int atom_quality;
        -:  466:
      294:  467:  int32_t min_gap = 0;
      294:  468:  int32_t max_gap = 0;
        -:  469:  int32_t prev_min_gap;
        -:  470:  int32_t prev_max_gap;
        -:  471:
        -:  472:  char message[512];
        -:  473:
      294:  474:  YR_COMPILER* compiler = yyget_extra(yyscanner);
      294:  475:  YR_STRING* prev_string = NULL;
        -:  476:
      294:  477:  RE_AST* re_ast = NULL;
      294:  478:  RE_AST* remainder_re_ast = NULL;
        -:  479:
        -:  480:  RE_ERROR re_error;
        -:  481:
      294:  482:  int result = ERROR_SUCCESS;
        -:  483:
        -:  484:  // Determine if a string with the same identifier was already defined
        -:  485:  // by searching for the identifier in string_table.
        -:  486:
      294:  487:  YR_STRING* new_string= (YR_STRING*) yr_hash_table_lookup(
        -:  488:      compiler->strings_table,
        -:  489:      identifier,
        -:  490:      NULL);
        -:  491:
      294:  492:  if (new_string != NULL)
        -:  493:  {
    #####:  494:    result = ERROR_DUPLICATED_STRING_IDENTIFIER;
    #####:  495:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  496:    goto _exit;
        -:  497:  }
        -:  498:
        -:  499:  // Empty strings are not allowed
        -:  500:
      294:  501:  if (str->length == 0)
        -:  502:  {
    #####:  503:    result = ERROR_EMPTY_STRING;
    #####:  504:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  505:    goto _exit;
        -:  506:  }
        -:  507:
      294:  508:  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  509:    string_flags |= STRING_GFLAGS_NO_CASE;
        -:  510:
      294:  511:  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)
        1:  512:    string_flags |= STRING_GFLAGS_DOT_ALL;
        -:  513:
      294:  514:  if (strcmp(identifier,"$") == 0)
        1:  515:    string_flags |= STRING_GFLAGS_ANONYMOUS;
        -:  516:
      294:  517:  if (!(string_flags & STRING_GFLAGS_WIDE) &&
      280:  518:      !(string_flags & STRING_GFLAGS_XOR))
      280:  519:    string_flags |= STRING_GFLAGS_ASCII;
        -:  520:
        -:  521:  // Hex strings are always handled as DOT_ALL regexps.
        -:  522:
      294:  523:  if (string_flags & STRING_GFLAGS_HEXADECIMAL)
    #####:  524:    string_flags |= STRING_GFLAGS_DOT_ALL;
        -:  525:
        -:  526:  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding
        -:  527:  // a single match for the string is enough. This is true in
        -:  528:  // most cases, except when the string count (#) and string offset (@)
        -:  529:  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH
        -:  530:  // initially, and unmarked later if required.
        -:  531:
      294:  532:  string_flags |= STRING_GFLAGS_SINGLE_MATCH;
        -:  533:
        -:  534:  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't
        -:  535:  // need to be searched all over the file because the user is using the
        -:  536:  // "at" operator. The string must be searched at a fixed offset in the
        -:  537:  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,
        -:  538:  // and unmarked later if required.
        -:  539:
      294:  540:  string_flags |= STRING_GFLAGS_FIXED_OFFSET;
        -:  541:
      294:  542:  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||
      294:  543:      string_flags & STRING_GFLAGS_REGEXP)
        -:  544:  {
      293:  545:    if (string_flags & STRING_GFLAGS_HEXADECIMAL)
    #####:  546:      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);
        -:  547:    else
      293:  548:      result = yr_re_parse(str->c_string, &re_ast, &re_error);
        -:  549:
      293:  550:    if (result != ERROR_SUCCESS)
        -:  551:    {
      13*:  552:      snprintf(
        -:  553:          message,
        -:  554:          sizeof(message),
        -:  555:          "invalid %s \"%s\": %s",
       13:  556:          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?
        -:  557:              "hex string" : "regular expression",
        -:  558:          identifier,
        -:  559:          re_error.message);
        -:  560:
       13:  561:      yr_compiler_set_error_extra_info(
        -:  562:          compiler, message);
        -:  563:
       13:  564:      goto _exit;
        -:  565:    }
        -:  566:
      280:  567:    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)
    #####:  568:      string_flags |= STRING_GFLAGS_FAST_REGEXP;
        -:  569:
        -:  570:    // Regular expressions in the strings section can't mix greedy and ungreedy
        -:  571:    // quantifiers like .* and .*?. That's because these regular expressions can
        -:  572:    // be matched forwards and/or backwards depending on the atom found, and we
        -:  573:    // need the regexp to be all-greedy or all-ungreedy to be able to properly
        -:  574:    // calculate the length of the match.
        -:  575:
      280:  576:    if ((re_ast->flags & RE_FLAGS_GREEDY) &&
      120:  577:        (re_ast->flags & RE_FLAGS_UNGREEDY))
        -:  578:    {
    #####:  579:      result = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  580:
    #####:  581:      yr_compiler_set_error_extra_info(compiler,
        -:  582:          "greedy and ungreedy quantifiers can't be mixed in a regular "
        -:  583:          "expression");
        -:  584:
    #####:  585:      goto _exit;
        -:  586:    }
        -:  587:
      280:  588:    if (re_ast->flags & RE_FLAGS_GREEDY)
      120:  589:      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;
        -:  590:
      280:  591:    if (yr_re_ast_contains_dot_star(re_ast))
        -:  592:    {
        8:  593:      yywarning(
        -:  594:          yyscanner,
        -:  595:          "%s contains .* or .+, consider using .{,N} or .{1,N} with a reasonable value for N",
        -:  596:          identifier);
        -:  597:    }
        -:  598:
      280:  599:    if (compiler->re_ast_callback != NULL)
        -:  600:    {
    #####:  601:      compiler->re_ast_callback(
    #####:  602:          compiler->current_rule,
        -:  603:          identifier,
        -:  604:          re_ast,
        -:  605:          compiler->re_ast_clbk_user_data);
        -:  606:    }
        -:  607:
      561:  608:    while (re_ast != NULL)
        -:  609:    {
      281:  610:      prev_string = new_string;
      281:  611:      prev_min_gap = min_gap;
      281:  612:      prev_max_gap = max_gap;
        -:  613:
      281:  614:      result = yr_re_ast_split_at_chaining_point(
        -:  615:          re_ast, &remainder_re_ast, &min_gap, &max_gap);
        -:  616:
      281:  617:      if (result != ERROR_SUCCESS)
    #####:  618:        goto _exit;
        -:  619:
      281:  620:      result = _yr_parser_write_string(
        -:  621:          identifier,
        -:  622:          string_flags,
        -:  623:          compiler,
        -:  624:          NULL,
        -:  625:          re_ast,
        -:  626:          &new_string,
        -:  627:          &atom_quality,
      281:  628:          &compiler->current_rule->num_atoms);
        -:  629:
      281:  630:      if (result != ERROR_SUCCESS)
    #####:  631:        goto _exit;
        -:  632:
      281:  633:      if (atom_quality < min_atom_quality)
      280:  634:        min_atom_quality = atom_quality;
        -:  635:
      281:  636:      if (prev_string != NULL)
        -:  637:      {
        1:  638:        new_string->chained_to = prev_string;
        1:  639:        new_string->chain_gap_min = prev_min_gap;
        1:  640:        new_string->chain_gap_max = prev_max_gap;
        -:  641:
        -:  642:        // A string chained to another one can't have a fixed offset, only the
        -:  643:        // head of the string chain can have a fixed offset.
        1:  644:        new_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  645:
        -:  646:        // There is a previous string, but that string wasn't marked as part of
        -:  647:        // a chain because we can't do that until knowing there will be another
        -:  648:        // string, let's flag it now the we know.
        1:  649:        prev_string->g_flags |= STRING_GFLAGS_CHAIN_PART;
        -:  650:
        -:  651:        // There is a previous string, so this string is part of a chain, but
        -:  652:        // there will be no more strings because there are no more AST to split,
        -:  653:        // which means that this is the chain's tail.
        1:  654:        if (remainder_re_ast == NULL)
        1:  655:          new_string->g_flags |= STRING_GFLAGS_CHAIN_PART |
        -:  656:                                 STRING_GFLAGS_CHAIN_TAIL;
        -:  657:      }
        -:  658:
      281:  659:      yr_re_ast_destroy(re_ast);
      281:  660:      re_ast = remainder_re_ast;
        -:  661:    }
        -:  662:
        -:  663:    // Walk the chain of strings from the tail to the head, we want to return
        -:  664:    // the string at the head of the chain.
      281:  665:    while (new_string->chained_to != NULL)
        1:  666:      new_string = new_string->chained_to;
        -:  667:  }
        -:  668:  else  // not a STRING_GFLAGS_HEXADECIMAL or STRING_GFLAGS_REGEXP
        -:  669:  {
        1:  670:    result = _yr_parser_write_string(
        -:  671:        identifier,
        -:  672:        string_flags,
        -:  673:        compiler,
        -:  674:        str,
        -:  675:        NULL,
        -:  676:        &new_string,
        -:  677:        &min_atom_quality,
        1:  678:        &compiler->current_rule->num_atoms);
        -:  679:
        1:  680:    if (result != ERROR_SUCCESS)
    #####:  681:      goto _exit;
        -:  682:  }
        -:  683:
      281:  684:  if (!STRING_IS_ANONYMOUS(new_string))
        -:  685:  {
      280:  686:    result = yr_hash_table_add(
        -:  687:      compiler->strings_table,
        -:  688:      identifier,
        -:  689:      NULL,
        -:  690:      new_string);
        -:  691:
      280:  692:    if (result != ERROR_SUCCESS)
    #####:  693:      goto _exit;
        -:  694:  }
        -:  695:
      281:  696:  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)
        -:  697:  {
      125:  698:    yywarning(
        -:  699:        yyscanner,
        -:  700:        "%s in rule %s is slowing down scanning",
      125:  701:        new_string->identifier,
      125:  702:        compiler->current_rule->identifier);
        -:  703:  }
        -:  704:
      156:  705:_exit:
        -:  706:
      294:  707:  if (re_ast != NULL)
    #####:  708:    yr_re_ast_destroy(re_ast);
        -:  709:
      294:  710:  if (remainder_re_ast != NULL)
    #####:  711:    yr_re_ast_destroy(remainder_re_ast);
        -:  712:
      294:  713:  *string = new_string;
        -:  714:
      294:  715:  return result;
        -:  716:}
        -:  717:
        -:  718:
      296:  719:int yr_parser_reduce_rule_declaration_phase_1(
        -:  720:    yyscan_t yyscanner,
        -:  721:    int32_t flags,
        -:  722:    const char* identifier,
        -:  723:    YR_RULE** rule)
        -:  724:{
        -:  725:  YR_FIXUP *fixup;
        -:  726:  YR_INIT_RULE_ARGS *init_rule_args;
      296:  727:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  728:
      296:  729:  *rule = NULL;
        -:  730:
      296:  731:  if (yr_hash_table_lookup(
        -:  732:        compiler->rules_table,
        -:  733:        identifier,
      592:  734:        compiler->current_namespace->name) != NULL ||
      296:  735:      yr_hash_table_lookup(
        -:  736:        compiler->objects_table,
        -:  737:        identifier,
        -:  738:        NULL) != NULL)
        -:  739:  {
        -:  740:    // A rule or variable with the same identifier already exists, return the
        -:  741:    // appropriate error.
        -:  742:
    #####:  743:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  744:    return ERROR_DUPLICATED_IDENTIFIER;
        -:  745:  }
        -:  746:
     296*:  747:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  748:      compiler->rules_arena,
        -:  749:      sizeof(YR_RULE),
        -:  750:      (void**) rule,
        -:  751:      offsetof(YR_RULE, identifier),
        -:  752:      offsetof(YR_RULE, tags),
        -:  753:      offsetof(YR_RULE, strings),
        -:  754:      offsetof(YR_RULE, metas),
        -:  755:      offsetof(YR_RULE, ns),
        -:  756:      EOL))
        -:  757:
      296:  758:  (*rule)->g_flags = flags;
      296:  759:  (*rule)->ns = compiler->current_namespace;
      296:  760:  (*rule)->num_atoms = 0;
        -:  761:
        -:  762:  #ifdef PROFILING_ENABLED
        -:  763:  (*rule)->time_cost = 0;
        -:  764:
        -:  765:  memset(
        -:  766:      (*rule)->time_cost_per_thread, 0, sizeof((*rule)->time_cost_per_thread));
        -:  767:  #endif
        -:  768:
     296*:  769:  FAIL_ON_ERROR(yr_arena_write_string(
        -:  770:      compiler->sz_arena,
        -:  771:      identifier,
        -:  772:      (char**) &(*rule)->identifier));
        -:  773:
     296*:  774:  FAIL_ON_ERROR(yr_parser_emit(
        -:  775:      yyscanner,
        -:  776:      OP_INIT_RULE,
        -:  777:      NULL));
        -:  778:
     296*:  779:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  780:      compiler->code_arena,
        -:  781:      sizeof(YR_INIT_RULE_ARGS),
        -:  782:      (void**) &init_rule_args,
        -:  783:      offsetof(YR_INIT_RULE_ARGS, rule),
        -:  784:      offsetof(YR_INIT_RULE_ARGS, jmp_addr),
        -:  785:      EOL));
        -:  786:
      296:  787:  init_rule_args->rule = *rule;
        -:  788:
        -:  789:  // jmp_addr holds the address to jump to when we want to skip the code for
        -:  790:  // the rule. It is iniatialized as NULL at this point because we don't know
        -:  791:  // the address until emmiting the code for the rule's condition. The address
        -:  792:  // is set in yr_parser_reduce_rule_declaration_phase_2.
      296:  793:  init_rule_args->jmp_addr = NULL;
        -:  794:
        -:  795:  // Create a fixup entry for the jump and push it in the stack
      296:  796:  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -:  797:
      296:  798:  if (fixup == NULL)
    #####:  799:    return ERROR_INSUFFICIENT_MEMORY;
        -:  800:
      296:  801:  fixup->address = (void*) &(init_rule_args->jmp_addr);
      296:  802:  fixup->next = compiler->fixup_stack_head;
      296:  803:  compiler->fixup_stack_head = fixup;
        -:  804:
        -:  805:  // Clean strings_table as we are starting to parse a new rule.
      296:  806:  yr_hash_table_clean(compiler->strings_table, NULL);
        -:  807:
     296*:  808:  FAIL_ON_ERROR(yr_hash_table_add(
        -:  809:      compiler->rules_table,
        -:  810:      identifier,
        -:  811:      compiler->current_namespace->name,
        -:  812:      (void*) *rule));
        -:  813:
      296:  814:  compiler->current_rule = *rule;
        -:  815:
      296:  816:  return ERROR_SUCCESS;
        -:  817:}
        -:  818:
      280:  819:int yr_parser_reduce_rule_declaration_phase_2(
        -:  820:    yyscan_t yyscanner,
        -:  821:    YR_RULE* rule)
        -:  822:{
        -:  823:  uint32_t max_strings_per_rule;
      280:  824:  uint32_t strings_in_rule = 0;
      280:  825:  uint8_t* nop_inst_addr = NULL;
        -:  826:
        -:  827:  int result;
        -:  828:
        -:  829:  YR_FIXUP *fixup;
        -:  830:  YR_STRING* string;
      280:  831:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  832:
      280:  833:  yr_get_configuration(
        -:  834:      YR_CONFIG_MAX_STRINGS_PER_RULE,
        -:  835:      (void*) &max_strings_per_rule);
        -:  836:
        -:  837:  // Show warning if the rule is generating too many atoms. The warning is
        -:  838:  // shown if the number of atoms is greater than 20 times the maximum number
        -:  839:  // of strings allowed for a rule, as 20 is minimum number of atoms generated
        -:  840:  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneosly.
        -:  841:
      280:  842:  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)
        -:  843:  {
    #####:  844:    yywarning(
        -:  845:        yyscanner,
        -:  846:        "rule %s is slowing down scanning",
        -:  847:        rule->identifier);
        -:  848:  }
        -:  849:
        -:  850:  // Check for unreferenced (unused) strings.
      280:  851:  string = rule->strings;
        -:  852:
      561:  853:  while (!STRING_IS_NULL(string))
        -:  854:  {
        -:  855:    // Only the heading fragment in a chain of strings (the one with
        -:  856:    // chained_to == NULL) must be referenced. All other fragments
        -:  857:    // are never marked as referenced.
        -:  858:
      281:  859:    if (!STRING_IS_REFERENCED(string) &&
        1:  860:        string->chained_to == NULL)
        -:  861:    {
    #####:  862:      yr_compiler_set_error_extra_info(compiler, string->identifier);
    #####:  863:      return ERROR_UNREFERENCED_STRING;
        -:  864:    }
        -:  865:
      281:  866:    strings_in_rule++;
        -:  867:
      281:  868:    if (strings_in_rule > max_strings_per_rule)
        -:  869:    {
    #####:  870:      yr_compiler_set_error_extra_info(compiler, rule->identifier);
    #####:  871:      return ERROR_TOO_MANY_STRINGS;
        -:  872:    }
        -:  873:
      281:  874:    string = (YR_STRING*) yr_arena_next_address(
        -:  875:        compiler->strings_arena,
        -:  876:        string,
        -:  877:        sizeof(YR_STRING));
        -:  878:  }
        -:  879:
      280:  880:  result = yr_parser_emit_with_arg_reloc(
        -:  881:      yyscanner,
        -:  882:      OP_MATCH_RULE,
        -:  883:      rule,
        -:  884:      NULL,
        -:  885:      NULL);
        -:  886:
        -:  887:  // Generate a do-nothing instruction (NOP) in order to get its address
        -:  888:  // and use it as the destination for the OP_INIT_RULE skip jump. We can not
        -:  889:  // simply use the address of the OP_MATCH_RULE instruction +1 because we
        -:  890:  // can't be sure that the instruction following the OP_MATCH_RULE is going to
        -:  891:  // be in the same arena page. As we don't have a reliable way of getting the
        -:  892:  // address of the next instruction we generate the OP_NOP.
        -:  893:
      280:  894:  if (result == ERROR_SUCCESS)
      280:  895:    result = yr_parser_emit(yyscanner, OP_NOP, &nop_inst_addr);
        -:  896:
      280:  897:  fixup = compiler->fixup_stack_head;
      280:  898:  *(void**)(fixup->address) = (void*) nop_inst_addr;
      280:  899:  compiler->fixup_stack_head = fixup->next;
      280:  900:  yr_free(fixup);
        -:  901:
      280:  902:  return result;
        -:  903:}
        -:  904:
        -:  905:
      280:  906:int yr_parser_reduce_string_identifier(
        -:  907:    yyscan_t yyscanner,
        -:  908:    const char* identifier,
        -:  909:    uint8_t instruction,
        -:  910:    uint64_t at_offset)
        -:  911:{
        -:  912:  YR_STRING* string;
      280:  913:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  914:
      280:  915:  if (strcmp(identifier, "$") == 0) // is an anonymous string ?
        -:  916:  {
    #####:  917:    if (compiler->loop_for_of_mem_offset >= 0) // inside a loop ?
        -:  918:    {
    #####:  919:      yr_parser_emit_with_arg(
        -:  920:          yyscanner,
        -:  921:          OP_PUSH_M,
    #####:  922:          compiler->loop_for_of_mem_offset,
        -:  923:          NULL,
        -:  924:          NULL);
        -:  925:
    #####:  926:      yr_parser_emit(yyscanner, instruction, NULL);
        -:  927:
    #####:  928:      string = compiler->current_rule->strings;
        -:  929:
    #####:  930:      while(!STRING_IS_NULL(string))
        -:  931:      {
    #####:  932:        if (instruction != OP_FOUND)
    #####:  933:          string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;
        -:  934:
    #####:  935:        if (instruction == OP_FOUND_AT)
        -:  936:        {
        -:  937:          // Avoid overwriting any previous fixed offset
        -:  938:
    #####:  939:          if (string->fixed_offset == UNDEFINED)
    #####:  940:            string->fixed_offset = at_offset;
        -:  941:
        -:  942:          // If a previous fixed offset was different, disable
        -:  943:          // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -:  944:          // have room to store a single fixed offset value
        -:  945:
    #####:  946:          if (string->fixed_offset != at_offset)
    #####:  947:            string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  948:        }
        -:  949:        else
        -:  950:        {
    #####:  951:          string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  952:        }
        -:  953:
    #####:  954:        string = (YR_STRING*) yr_arena_next_address(
        -:  955:            compiler->strings_arena,
        -:  956:            string,
        -:  957:            sizeof(YR_STRING));
        -:  958:      }
        -:  959:    }
        -:  960:    else
        -:  961:    {
        -:  962:      // Anonymous strings not allowed outside of a loop
    #####:  963:      return ERROR_MISPLACED_ANONYMOUS_STRING;
        -:  964:    }
        -:  965:  }
        -:  966:  else
        -:  967:  {
     280*:  968:    FAIL_ON_ERROR(yr_parser_lookup_string(
        -:  969:        yyscanner, identifier, &string));
        -:  970:
     280*:  971:    FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -:  972:        yyscanner,
        -:  973:        OP_PUSH,
        -:  974:        string,
        -:  975:        NULL,
        -:  976:        NULL));
        -:  977:
      280:  978:    if (instruction != OP_FOUND)
        4:  979:      string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;
        -:  980:
      280:  981:    if (instruction == OP_FOUND_AT)
        -:  982:    {
        -:  983:      // Avoid overwriting any previous fixed offset
        -:  984:
    #####:  985:      if (string->fixed_offset == UNDEFINED)
    #####:  986:        string->fixed_offset = at_offset;
        -:  987:
        -:  988:      // If a previous fixed offset was different, disable
        -:  989:      // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -:  990:      // have room to store a single fixed offset value
        -:  991:
    #####:  992:      if (string->fixed_offset == UNDEFINED ||
    #####:  993:          string->fixed_offset != at_offset)
        -:  994:      {
    #####:  995:        string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  996:      }
        -:  997:    }
        -:  998:    else
        -:  999:    {
      280: 1000:      string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -: 1001:    }
        -: 1002:
     280*: 1003:    FAIL_ON_ERROR(yr_parser_emit(yyscanner, instruction, NULL));
        -: 1004:
      280: 1005:    string->g_flags |= STRING_GFLAGS_REFERENCED;
        -: 1006:  }
        -: 1007:
      280: 1008:  return ERROR_SUCCESS;
        -: 1009:}
        -: 1010:
        -: 1011:
    #####: 1012:int yr_parser_reduce_meta_declaration(
        -: 1013:    yyscan_t yyscanner,
        -: 1014:    int32_t type,
        -: 1015:    const char* identifier,
        -: 1016:    const char* string,
        -: 1017:    int64_t integer,
        -: 1018:    YR_META** meta)
        -: 1019:{
    #####: 1020:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1021:
    #####: 1022:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -: 1023:      compiler->metas_arena,
        -: 1024:      sizeof(YR_META),
        -: 1025:      (void**) meta,
        -: 1026:      offsetof(YR_META, identifier),
        -: 1027:      offsetof(YR_META, string),
        -: 1028:      EOL));
        -: 1029:
    #####: 1030:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1031:      compiler->sz_arena,
        -: 1032:      identifier,
        -: 1033:      (char**) &(*meta)->identifier));
        -: 1034:
    #####: 1035:  if (string != NULL)
        -: 1036:  {
    #####: 1037:    FAIL_ON_ERROR(yr_arena_write_string(
        -: 1038:        compiler->sz_arena,
        -: 1039:        string,
        -: 1040:        &(*meta)->string));
        -: 1041:  }
        -: 1042:  else
        -: 1043:  {
    #####: 1044:    (*meta)->string = NULL;
        -: 1045:  }
        -: 1046:
    #####: 1047:  (*meta)->integer = integer;
    #####: 1048:  (*meta)->type = type;
        -: 1049:
    #####: 1050:  return ERROR_SUCCESS;
        -: 1051:}
        -: 1052:
        -: 1053:
    #####: 1054:static int _yr_parser_valid_module_name(
        -: 1055:    SIZED_STRING* module_name)
        -: 1056:{
    #####: 1057:  if (module_name->length == 0)
    #####: 1058:    return false;
        -: 1059:
    #####: 1060:  if (strlen(module_name->c_string) != module_name->length)
    #####: 1061:    return false;
        -: 1062:
    #####: 1063:  return true;
        -: 1064:}
        -: 1065:
        -: 1066:
    #####: 1067:int yr_parser_reduce_import(
        -: 1068:    yyscan_t yyscanner,
        -: 1069:    SIZED_STRING* module_name)
        -: 1070:{
        -: 1071:  int result;
        -: 1072:
    #####: 1073:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1074:  YR_OBJECT* module_structure;
        -: 1075:
        -: 1076:  char* name;
        -: 1077:
    #####: 1078:  if (!_yr_parser_valid_module_name(module_name))
        -: 1079:  {
    #####: 1080:    yr_compiler_set_error_extra_info(compiler, module_name->c_string);
    #####: 1081:    return ERROR_INVALID_MODULE_NAME;
        -: 1082:  }
        -: 1083:
    #####: 1084:  module_structure = (YR_OBJECT*) yr_hash_table_lookup(
        -: 1085:      compiler->objects_table,
    #####: 1086:      module_name->c_string,
    #####: 1087:      compiler->current_namespace->name);
        -: 1088:
        -: 1089:  // if module already imported, do nothing
        -: 1090:
    #####: 1091:  if (module_structure != NULL)
    #####: 1092:    return ERROR_SUCCESS;
        -: 1093:
    #####: 1094:  FAIL_ON_ERROR(yr_object_create(
        -: 1095:      OBJECT_TYPE_STRUCTURE,
        -: 1096:      module_name->c_string,
        -: 1097:      NULL,
        -: 1098:      &module_structure));
        -: 1099:
    #####: 1100:  FAIL_ON_ERROR(yr_hash_table_add(
        -: 1101:      compiler->objects_table,
        -: 1102:      module_name->c_string,
        -: 1103:      compiler->current_namespace->name,
        -: 1104:      module_structure));
        -: 1105:
    #####: 1106:  result = yr_modules_do_declarations(
    #####: 1107:      module_name->c_string,
        -: 1108:      module_structure);
        -: 1109:
    #####: 1110:  if (result == ERROR_UNKNOWN_MODULE)
    #####: 1111:    yr_compiler_set_error_extra_info(compiler, module_name->c_string);
        -: 1112:
    #####: 1113:  if (result != ERROR_SUCCESS)
    #####: 1114:    return result;
        -: 1115:
    #####: 1116:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1117:      compiler->sz_arena,
        -: 1118:      module_name->c_string,
        -: 1119:      &name));
        -: 1120:
    #####: 1121:  FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -: 1122:        yyscanner,
        -: 1123:        OP_IMPORT,
        -: 1124:        name,
        -: 1125:        NULL,
        -: 1126:        NULL));
        -: 1127:
    #####: 1128:  return ERROR_SUCCESS;
        -: 1129:}
        -: 1130:
        -: 1131:
        4: 1132:static int _yr_parser_operator_to_opcode(
        -: 1133:    const char* op,
        -: 1134:    int expression_type)
        -: 1135:{
        4: 1136:  int opcode = 0;
        -: 1137:
        4: 1138:  switch(expression_type)
        -: 1139:  {
        4: 1140:    case EXPRESSION_TYPE_INTEGER:
        4: 1141:      opcode = OP_INT_BEGIN;
        4: 1142:      break;
    #####: 1143:    case EXPRESSION_TYPE_FLOAT:
    #####: 1144:      opcode = OP_DBL_BEGIN;
    #####: 1145:      break;
    #####: 1146:    case EXPRESSION_TYPE_STRING:
    #####: 1147:      opcode = OP_STR_BEGIN;
    #####: 1148:      break;
    #####: 1149:    default:
    #####: 1150:      assert(false);
        -: 1151:  }
        -: 1152:
        4: 1153:  if (op[0] == '<')
        -: 1154:  {
    #####: 1155:    if (op[1] == '=')
    #####: 1156:      opcode += _OP_LE;
        -: 1157:    else
    #####: 1158:      opcode += _OP_LT;
        -: 1159:  }
        4: 1160:  else if (op[0] == '>')
        -: 1161:  {
    #####: 1162:    if (op[1] == '=')
    #####: 1163:      opcode += _OP_GE;
        -: 1164:    else
    #####: 1165:      opcode += _OP_GT;
        -: 1166:  }
        4: 1167:  else if (op[1] == '=')
        -: 1168:  {
        4: 1169:    if (op[0] == '=')
        4: 1170:      opcode += _OP_EQ;
        -: 1171:    else
    #####: 1172:      opcode += _OP_NEQ;
        -: 1173:  }
    #####: 1174:  else if (op[0] == '+')
        -: 1175:  {
    #####: 1176:    opcode += _OP_ADD;
        -: 1177:  }
    #####: 1178:  else if (op[0] == '-')
        -: 1179:  {
    #####: 1180:    opcode += _OP_SUB;
        -: 1181:  }
    #####: 1182:  else if (op[0] == '*')
        -: 1183:  {
    #####: 1184:    opcode += _OP_MUL;
        -: 1185:  }
    #####: 1186:  else if (op[0] == '\\')
        -: 1187:  {
    #####: 1188:    opcode += _OP_DIV;
        -: 1189:  }
        -: 1190:
       4*: 1191:  if (IS_INT_OP(opcode) || IS_DBL_OP(opcode) || IS_STR_OP(opcode))
        -: 1192:  {
        4: 1193:    return opcode;
        -: 1194:  }
        -: 1195:
    #####: 1196:  return OP_ERROR;
        -: 1197:}
        -: 1198:
        -: 1199:
        4: 1200:int yr_parser_reduce_operation(
        -: 1201:    yyscan_t yyscanner,
        -: 1202:    const char* op,
        -: 1203:    EXPRESSION left_operand,
        -: 1204:    EXPRESSION right_operand)
        -: 1205:{
        -: 1206:  int expression_type;
        -: 1207:
        4: 1208:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1209:
       4*: 1210:  if ((left_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1211:       left_operand.type == EXPRESSION_TYPE_FLOAT) &&
       4*: 1212:      (right_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1213:       right_operand.type == EXPRESSION_TYPE_FLOAT))
        -: 1214:  {
        4: 1215:    if (left_operand.type != right_operand.type)
        -: 1216:    {
        -: 1217:      // One operand is double and the other is integer,
        -: 1218:      // cast the integer to double
        -: 1219:
    #####: 1220:      FAIL_ON_ERROR(yr_parser_emit_with_arg(
        -: 1221:          yyscanner,
        -: 1222:          OP_INT_TO_DBL,
        -: 1223:          (left_operand.type == EXPRESSION_TYPE_INTEGER) ? 2 : 1,
        -: 1224:          NULL,
        -: 1225:          NULL));
        -: 1226:    }
        -: 1227:
        4: 1228:    expression_type = EXPRESSION_TYPE_FLOAT;
        -: 1229:
        4: 1230:    if (left_operand.type == EXPRESSION_TYPE_INTEGER &&
        4: 1231:        right_operand.type == EXPRESSION_TYPE_INTEGER)
        -: 1232:    {
        4: 1233:      expression_type = EXPRESSION_TYPE_INTEGER;
        -: 1234:    }
        -: 1235:
       4*: 1236:    FAIL_ON_ERROR(yr_parser_emit(
        -: 1237:        yyscanner,
        -: 1238:        _yr_parser_operator_to_opcode(op, expression_type),
        -: 1239:        NULL));
        -: 1240:  }
    #####: 1241:  else if (left_operand.type == EXPRESSION_TYPE_STRING &&
    #####: 1242:           right_operand.type == EXPRESSION_TYPE_STRING)
    #####: 1243:  {
    #####: 1244:    int opcode = _yr_parser_operator_to_opcode(op, EXPRESSION_TYPE_STRING);
        -: 1245:
    #####: 1246:    if (opcode != OP_ERROR)
        -: 1247:    {
    #####: 1248:      FAIL_ON_ERROR(yr_parser_emit(
        -: 1249:          yyscanner,
        -: 1250:          opcode,
        -: 1251:          NULL));
        -: 1252:    }
        -: 1253:    else
        -: 1254:    {
    #####: 1255:      yr_compiler_set_error_extra_info_fmt(
        -: 1256:          compiler, "strings don't support \"%s\" operation", op);
        -: 1257:
    #####: 1258:      return ERROR_WRONG_TYPE;
        -: 1259:    }
        -: 1260:  }
        -: 1261:  else
        -: 1262:  {
    #####: 1263:    yr_compiler_set_error_extra_info(compiler, "type mismatch");
        -: 1264:
    #####: 1265:    return ERROR_WRONG_TYPE;
        -: 1266:  }
        -: 1267:
        4: 1268:  return ERROR_SUCCESS;
        -: 1269:}
