        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         yara_yyparse
        -:   68:#define yylex           yara_yylex
        -:   69:#define yyerror         yara_yyerror
        -:   70:#define yydebug         yara_yydebug
        -:   71:#define yynerrs         yara_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "grammar.y"
        -:   75:
        -:   76:
        -:   77:
        -:   78:#include <assert.h>
        -:   79:#include <stdio.h>
        -:   80:#include <string.h>
        -:   81:#include <limits.h>
        -:   82:#include <stdlib.h>
        -:   83:#include <stddef.h>
        -:   84:
        -:   85:#include <yara/integers.h>
        -:   86:#include <yara/utils.h>
        -:   87:#include <yara/strutils.h>
        -:   88:#include <yara/compiler.h>
        -:   89:#include <yara/object.h>
        -:   90:#include <yara/sizedstr.h>
        -:   91:#include <yara/exec.h>
        -:   92:#include <yara/error.h>
        -:   93:#include <yara/mem.h>
        -:   94:#include <yara/lexer.h>
        -:   95:#include <yara/parser.h>
        -:   96:
        -:   97:#if defined(_MSC_VER)
        -:   98:#define llabs _abs64
        -:   99:#endif
        -:  100:
        -:  101:#define YYERROR_VERBOSE
        -:  102:
        -:  103:#define YYMALLOC yr_malloc
        -:  104:#define YYFREE yr_free
        -:  105:
        -:  106:#define INTEGER_SET_ENUMERATION   1
        -:  107:#define INTEGER_SET_RANGE         2
        -:  108:
        -:  109:#define FOR_EXPRESSION_ALL 1
        -:  110:#define FOR_EXPRESSION_ANY 2
        -:  111:
        -:  112:#define fail_if_error(e) \
        -:  113:    if (e != ERROR_SUCCESS) \
        -:  114:    { \
        -:  115:      compiler->last_error = e; \
        -:  116:      yyerror(yyscanner, compiler, NULL); \
        -:  117:      YYERROR; \
        -:  118:    } \
        -:  119:
        -:  120:
        -:  121:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  122:    if (((expression.type) & (expected_type)) == 0) \
        -:  123:    { \
        -:  124:      switch(expression.type) \
        -:  125:      { \
        -:  126:        case EXPRESSION_TYPE_INTEGER: \
        -:  127:          yr_compiler_set_error_extra_info( \
        -:  128:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  129:          break; \
        -:  130:        case EXPRESSION_TYPE_FLOAT: \
        -:  131:          yr_compiler_set_error_extra_info( \
        -:  132:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  133:          break; \
        -:  134:        case EXPRESSION_TYPE_STRING: \
        -:  135:          yr_compiler_set_error_extra_info( \
        -:  136:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  137:          break; \
        -:  138:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  139:          yr_compiler_set_error_extra_info( \
        -:  140:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  141:          break; \
        -:  142:      } \
        -:  143:      cleanup; \
        -:  144:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  145:      yyerror(yyscanner, compiler, NULL); \
        -:  146:      YYERROR; \
        -:  147:    }
        -:  148:
        -:  149:
        -:  150:#define check_type(expression, expected_type, op) \
        -:  151:    check_type_with_cleanup(expression, expected_type, op, )
        -:  152:
        -:  153:
        -:  154:#line 155 "grammar.c"
        -:  155:
        -:  156:# ifndef YY_CAST
        -:  157:#  ifdef __cplusplus
        -:  158:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  159:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  160:#  else
        -:  161:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  162:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  163:#  endif
        -:  164:# endif
        -:  165:# ifndef YY_NULLPTR
        -:  166:#  if defined __cplusplus
        -:  167:#   if 201103L <= __cplusplus
        -:  168:#    define YY_NULLPTR nullptr
        -:  169:#   else
        -:  170:#    define YY_NULLPTR 0
        -:  171:#   endif
        -:  172:#  else
        -:  173:#   define YY_NULLPTR ((void*)0)
        -:  174:#  endif
        -:  175:# endif
        -:  176:
        -:  177:/* Enabling verbose error messages.  */
        -:  178:#ifdef YYERROR_VERBOSE
        -:  179:# undef YYERROR_VERBOSE
        -:  180:# define YYERROR_VERBOSE 1
        -:  181:#else
        -:  182:# define YYERROR_VERBOSE 0
        -:  183:#endif
        -:  184:
        -:  185:/* Use api.header.include to #include this header
        -:  186:   instead of duplicating it here.  */
        -:  187:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  188:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  189:/* Debug traces.  */
        -:  190:#ifndef YYDEBUG
        -:  191:# define YYDEBUG 0
        -:  192:#endif
        -:  193:#if YYDEBUG
        -:  194:extern int yara_yydebug;
        -:  195:#endif
        -:  196:
        -:  197:/* Token type.  */
        -:  198:#ifndef YYTOKENTYPE
        -:  199:# define YYTOKENTYPE
        -:  200:  enum yytokentype
        -:  201:  {
        -:  202:    _END_OF_FILE_ = 0,
        -:  203:    _END_OF_INCLUDED_FILE_ = 258,
        -:  204:    _DOT_DOT_ = 259,
        -:  205:    _RULE_ = 260,
        -:  206:    _PRIVATE_ = 261,
        -:  207:    _GLOBAL_ = 262,
        -:  208:    _META_ = 263,
        -:  209:    _STRINGS_ = 264,
        -:  210:    _CONDITION_ = 265,
        -:  211:    _IDENTIFIER_ = 266,
        -:  212:    _STRING_IDENTIFIER_ = 267,
        -:  213:    _STRING_COUNT_ = 268,
        -:  214:    _STRING_OFFSET_ = 269,
        -:  215:    _STRING_LENGTH_ = 270,
        -:  216:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 271,
        -:  217:    _NUMBER_ = 272,
        -:  218:    _DOUBLE_ = 273,
        -:  219:    _INTEGER_FUNCTION_ = 274,
        -:  220:    _TEXT_STRING_ = 275,
        -:  221:    _HEX_STRING_ = 276,
        -:  222:    _REGEXP_ = 277,
        -:  223:    _ASCII_ = 278,
        -:  224:    _WIDE_ = 279,
        -:  225:    _XOR_ = 280,
        -:  226:    _NOCASE_ = 281,
        -:  227:    _FULLWORD_ = 282,
        -:  228:    _AT_ = 283,
        -:  229:    _FILESIZE_ = 284,
        -:  230:    _ENTRYPOINT_ = 285,
        -:  231:    _ALL_ = 286,
        -:  232:    _ANY_ = 287,
        -:  233:    _IN_ = 288,
        -:  234:    _OF_ = 289,
        -:  235:    _FOR_ = 290,
        -:  236:    _THEM_ = 291,
        -:  237:    _MATCHES_ = 292,
        -:  238:    _CONTAINS_ = 293,
        -:  239:    _IMPORT_ = 294,
        -:  240:    _TRUE_ = 295,
        -:  241:    _FALSE_ = 296,
        -:  242:    _OR_ = 297,
        -:  243:    _AND_ = 298,
        -:  244:    _NOT_ = 299,
        -:  245:    _EQ_ = 300,
        -:  246:    _NEQ_ = 301,
        -:  247:    _LT_ = 302,
        -:  248:    _LE_ = 303,
        -:  249:    _GT_ = 304,
        -:  250:    _GE_ = 305,
        -:  251:    _SHIFT_LEFT_ = 306,
        -:  252:    _SHIFT_RIGHT_ = 307,
        -:  253:    UNARY_MINUS = 308
        -:  254:  };
        -:  255:#endif
        -:  256:/* Tokens.  */
        -:  257:#define _END_OF_FILE_ 0
        -:  258:#define _END_OF_INCLUDED_FILE_ 258
        -:  259:#define _DOT_DOT_ 259
        -:  260:#define _RULE_ 260
        -:  261:#define _PRIVATE_ 261
        -:  262:#define _GLOBAL_ 262
        -:  263:#define _META_ 263
        -:  264:#define _STRINGS_ 264
        -:  265:#define _CONDITION_ 265
        -:  266:#define _IDENTIFIER_ 266
        -:  267:#define _STRING_IDENTIFIER_ 267
        -:  268:#define _STRING_COUNT_ 268
        -:  269:#define _STRING_OFFSET_ 269
        -:  270:#define _STRING_LENGTH_ 270
        -:  271:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 271
        -:  272:#define _NUMBER_ 272
        -:  273:#define _DOUBLE_ 273
        -:  274:#define _INTEGER_FUNCTION_ 274
        -:  275:#define _TEXT_STRING_ 275
        -:  276:#define _HEX_STRING_ 276
        -:  277:#define _REGEXP_ 277
        -:  278:#define _ASCII_ 278
        -:  279:#define _WIDE_ 279
        -:  280:#define _XOR_ 280
        -:  281:#define _NOCASE_ 281
        -:  282:#define _FULLWORD_ 282
        -:  283:#define _AT_ 283
        -:  284:#define _FILESIZE_ 284
        -:  285:#define _ENTRYPOINT_ 285
        -:  286:#define _ALL_ 286
        -:  287:#define _ANY_ 287
        -:  288:#define _IN_ 288
        -:  289:#define _OF_ 289
        -:  290:#define _FOR_ 290
        -:  291:#define _THEM_ 291
        -:  292:#define _MATCHES_ 292
        -:  293:#define _CONTAINS_ 293
        -:  294:#define _IMPORT_ 294
        -:  295:#define _TRUE_ 295
        -:  296:#define _FALSE_ 296
        -:  297:#define _OR_ 297
        -:  298:#define _AND_ 298
        -:  299:#define _NOT_ 299
        -:  300:#define _EQ_ 300
        -:  301:#define _NEQ_ 301
        -:  302:#define _LT_ 302
        -:  303:#define _LE_ 303
        -:  304:#define _GT_ 304
        -:  305:#define _GE_ 305
        -:  306:#define _SHIFT_LEFT_ 306
        -:  307:#define _SHIFT_RIGHT_ 307
        -:  308:#define UNARY_MINUS 308
        -:  309:
        -:  310:/* Value type.  */
        -:  311:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  312:union YYSTYPE
        -:  313:{
        -:  314:#line 248 "grammar.y"
        -:  315:
        -:  316:  EXPRESSION      expression;
        -:  317:  SIZED_STRING*   sized_string;
        -:  318:  char*           c_string;
        -:  319:  int64_t         integer;
        -:  320:  double          double_;
        -:  321:  YR_STRING*      string;
        -:  322:  YR_META*        meta;
        -:  323:  YR_RULE*        rule;
        -:  324:
        -:  325:#line 326 "grammar.c"
        -:  326:
        -:  327:};
        -:  328:typedef union YYSTYPE YYSTYPE;
        -:  329:# define YYSTYPE_IS_TRIVIAL 1
        -:  330:# define YYSTYPE_IS_DECLARED 1
        -:  331:#endif
        -:  332:
        -:  333:
        -:  334:
        -:  335:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  336:
        -:  337:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  338:
        -:  339:
        -:  340:
        -:  341:#ifdef short
        -:  342:# undef short
        -:  343:#endif
        -:  344:
        -:  345:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  346:   <limits.h> and (if available) <stdint.h> are included
        -:  347:   so that the code can choose integer types of a good width.  */
        -:  348:
        -:  349:#ifndef __PTRDIFF_MAX__
        -:  350:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  351:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  352:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  353:#  define YY_STDINT_H
        -:  354:# endif
        -:  355:#endif
        -:  356:
        -:  357:/* Narrow types that promote to a signed type and that can represent a
        -:  358:   signed or unsigned integer of at least N bits.  In tables they can
        -:  359:   save space and decrease cache pressure.  Promoting to a signed type
        -:  360:   helps avoid bugs in integer arithmetic.  */
        -:  361:
        -:  362:#ifdef __INT_LEAST8_MAX__
        -:  363:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  364:#elif defined YY_STDINT_H
        -:  365:typedef int_least8_t yytype_int8;
        -:  366:#else
        -:  367:typedef signed char yytype_int8;
        -:  368:#endif
        -:  369:
        -:  370:#ifdef __INT_LEAST16_MAX__
        -:  371:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  372:#elif defined YY_STDINT_H
        -:  373:typedef int_least16_t yytype_int16;
        -:  374:#else
        -:  375:typedef short yytype_int16;
        -:  376:#endif
        -:  377:
        -:  378:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  379:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  380:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  381:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  382:typedef uint_least8_t yytype_uint8;
        -:  383:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  384:typedef unsigned char yytype_uint8;
        -:  385:#else
        -:  386:typedef short yytype_uint8;
        -:  387:#endif
        -:  388:
        -:  389:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  390:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  391:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  392:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  393:typedef uint_least16_t yytype_uint16;
        -:  394:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  395:typedef unsigned short yytype_uint16;
        -:  396:#else
        -:  397:typedef int yytype_uint16;
        -:  398:#endif
        -:  399:
        -:  400:#ifndef YYPTRDIFF_T
        -:  401:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  402:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  403:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  404:# elif defined PTRDIFF_MAX
        -:  405:#  ifndef ptrdiff_t
        -:  406:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  407:#  endif
        -:  408:#  define YYPTRDIFF_T ptrdiff_t
        -:  409:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  410:# else
        -:  411:#  define YYPTRDIFF_T long
        -:  412:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  413:# endif
        -:  414:#endif
        -:  415:
        -:  416:#ifndef YYSIZE_T
        -:  417:# ifdef __SIZE_TYPE__
        -:  418:#  define YYSIZE_T __SIZE_TYPE__
        -:  419:# elif defined size_t
        -:  420:#  define YYSIZE_T size_t
        -:  421:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  422:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  423:#  define YYSIZE_T size_t
        -:  424:# else
        -:  425:#  define YYSIZE_T unsigned
        -:  426:# endif
        -:  427:#endif
        -:  428:
        -:  429:#define YYSIZE_MAXIMUM                                  \
        -:  430:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  431:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  432:            ? YYPTRDIFF_MAXIMUM                         \
        -:  433:            : YY_CAST (YYSIZE_T, -1)))
        -:  434:
        -:  435:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  436:
        -:  437:/* Stored state numbers (used for stacks). */
        -:  438:typedef yytype_uint8 yy_state_t;
        -:  439:
        -:  440:/* State numbers in computations.  */
        -:  441:typedef int yy_state_fast_t;
        -:  442:
        -:  443:#ifndef YY_
        -:  444:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  445:#  if ENABLE_NLS
        -:  446:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  447:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  448:#  endif
        -:  449:# endif
        -:  450:# ifndef YY_
        -:  451:#  define YY_(Msgid) Msgid
        -:  452:# endif
        -:  453:#endif
        -:  454:
        -:  455:#ifndef YY_ATTRIBUTE_PURE
        -:  456:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  457:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  458:# else
        -:  459:#  define YY_ATTRIBUTE_PURE
        -:  460:# endif
        -:  461:#endif
        -:  462:
        -:  463:#ifndef YY_ATTRIBUTE_UNUSED
        -:  464:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  465:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  466:# else
        -:  467:#  define YY_ATTRIBUTE_UNUSED
        -:  468:# endif
        -:  469:#endif
        -:  470:
        -:  471:/* Suppress unused-variable warnings by "using" E.  */
        -:  472:#if ! defined lint || defined __GNUC__
        -:  473:# define YYUSE(E) ((void) (E))
        -:  474:#else
        -:  475:# define YYUSE(E) /* empty */
        -:  476:#endif
        -:  477:
        -:  478:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  479:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  480:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  481:    _Pragma ("GCC diagnostic push")                                     \
        -:  482:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  483:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  484:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  485:    _Pragma ("GCC diagnostic pop")
        -:  486:#else
        -:  487:# define YY_INITIAL_VALUE(Value) Value
        -:  488:#endif
        -:  489:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  490:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  491:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  492:#endif
        -:  493:#ifndef YY_INITIAL_VALUE
        -:  494:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  495:#endif
        -:  496:
        -:  497:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  498:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  499:    _Pragma ("GCC diagnostic push")                            \
        -:  500:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  501:# define YY_IGNORE_USELESS_CAST_END            \
        -:  502:    _Pragma ("GCC diagnostic pop")
        -:  503:#endif
        -:  504:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  505:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  506:# define YY_IGNORE_USELESS_CAST_END
        -:  507:#endif
        -:  508:
        -:  509:
        -:  510:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  511:
        -:  512:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  513:
        -:  514:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  515:
        -:  516:# ifdef YYSTACK_USE_ALLOCA
        -:  517:#  if YYSTACK_USE_ALLOCA
        -:  518:#   ifdef __GNUC__
        -:  519:#    define YYSTACK_ALLOC __builtin_alloca
        -:  520:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  521:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  522:#   elif defined _AIX
        -:  523:#    define YYSTACK_ALLOC __alloca
        -:  524:#   elif defined _MSC_VER
        -:  525:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  526:#    define alloca _alloca
        -:  527:#   else
        -:  528:#    define YYSTACK_ALLOC alloca
        -:  529:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  530:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  531:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  532:#     ifndef EXIT_SUCCESS
        -:  533:#      define EXIT_SUCCESS 0
        -:  534:#     endif
        -:  535:#    endif
        -:  536:#   endif
        -:  537:#  endif
        -:  538:# endif
        -:  539:
        -:  540:# ifdef YYSTACK_ALLOC
        -:  541:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  542:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  543:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  544:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  545:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  546:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  547:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  548:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  549:#  endif
        -:  550:# else
        -:  551:#  define YYSTACK_ALLOC YYMALLOC
        -:  552:#  define YYSTACK_FREE YYFREE
        -:  553:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  554:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  555:#  endif
        -:  556:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  557:       && ! ((defined YYMALLOC || defined malloc) \
        -:  558:             && (defined YYFREE || defined free)))
        -:  559:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  560:#   ifndef EXIT_SUCCESS
        -:  561:#    define EXIT_SUCCESS 0
        -:  562:#   endif
        -:  563:#  endif
        -:  564:#  ifndef YYMALLOC
        -:  565:#   define YYMALLOC malloc
        -:  566:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  567:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  568:#   endif
        -:  569:#  endif
        -:  570:#  ifndef YYFREE
        -:  571:#   define YYFREE free
        -:  572:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  573:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  574:#   endif
        -:  575:#  endif
        -:  576:# endif
        -:  577:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  578:
        -:  579:
        -:  580:#if (! defined yyoverflow \
        -:  581:     && (! defined __cplusplus \
        -:  582:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  583:
        -:  584:/* A type that is properly aligned for any stack member.  */
        -:  585:union yyalloc
        -:  586:{
        -:  587:  yy_state_t yyss_alloc;
        -:  588:  YYSTYPE yyvs_alloc;
        -:  589:};
        -:  590:
        -:  591:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  592:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  593:
        -:  594:/* The size of an array large to enough to hold all stacks, each with
        -:  595:   N elements.  */
        -:  596:# define YYSTACK_BYTES(N) \
        -:  597:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  598:      + YYSTACK_GAP_MAXIMUM)
        -:  599:
        -:  600:# define YYCOPY_NEEDED 1
        -:  601:
        -:  602:/* Relocate STACK from its old location to the new one.  The
        -:  603:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  604:   elements in the stack, and YYPTR gives the new location of the
        -:  605:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  606:   stack.  */
        -:  607:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  608:    do                                                                  \
        -:  609:      {                                                                 \
        -:  610:        YYPTRDIFF_T yynewbytes;                                         \
        -:  611:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  612:        Stack = &yyptr->Stack_alloc;                                    \
        -:  613:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  614:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  615:      }                                                                 \
        -:  616:    while (0)
        -:  617:
        -:  618:#endif
        -:  619:
        -:  620:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  621:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  622:   not overlap.  */
        -:  623:# ifndef YYCOPY
        -:  624:#  if defined __GNUC__ && 1 < __GNUC__
        -:  625:#   define YYCOPY(Dst, Src, Count) \
        -:  626:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  627:#  else
        -:  628:#   define YYCOPY(Dst, Src, Count)              \
        -:  629:      do                                        \
        -:  630:        {                                       \
        -:  631:          YYPTRDIFF_T yyi;                      \
        -:  632:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  633:            (Dst)[yyi] = (Src)[yyi];            \
        -:  634:        }                                       \
        -:  635:      while (0)
        -:  636:#  endif
        -:  637:# endif
        -:  638:#endif /* !YYCOPY_NEEDED */
        -:  639:
        -:  640:/* YYFINAL -- State number of the termination state.  */
        -:  641:#define YYFINAL  2
        -:  642:/* YYLAST -- Last index in YYTABLE.  */
        -:  643:#define YYLAST   395
        -:  644:
        -:  645:/* YYNTOKENS -- Number of terminals.  */
        -:  646:#define YYNTOKENS  74
        -:  647:/* YYNNTS -- Number of nonterminals.  */
        -:  648:#define YYNNTS  46
        -:  649:/* YYNRULES -- Number of rules.  */
        -:  650:#define YYNRULES  136
        -:  651:/* YYNSTATES -- Number of states.  */
        -:  652:#define YYNSTATES  223
        -:  653:
        -:  654:#define YYUNDEFTOK  2
        -:  655:#define YYMAXUTOK   309
        -:  656:
        -:  657:
        -:  658:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  659:   as returned by yylex, with out-of-bounds checking.  */
        -:  660:#define YYTRANSLATE(YYX)                                                \
        -:  661:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  662:
        -:  663:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  664:   as returned by yylex.  */
        -:  665:static const yytype_int8 yytranslate[] =
        -:  666:{
        -:  667:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  668:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  669:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  670:       2,     2,     2,     2,     2,     2,     2,    60,    55,     2,
        -:  671:      71,    72,    58,    56,    73,    57,    68,     2,     2,     2,
        -:  672:       2,     2,     2,     2,     2,     2,     2,     2,    66,     2,
        -:  673:       2,    67,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  674:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  675:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  676:       2,    69,    59,    70,    54,     2,     2,     2,     2,     2,
        -:  677:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  678:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  679:       2,     2,     2,    64,    53,    65,    61,     2,     2,     2,
        -:  680:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  681:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  682:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  683:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  684:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  685:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  686:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  687:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  688:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  689:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  690:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  691:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  692:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  693:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  694:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  695:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  696:      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
        -:  697:      45,    46,    47,    48,    49,    50,    51,    52,    62,    63
        -:  698:};
        -:  699:
        -:  700:#if YYDEBUG
        -:  701:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  702:static const yytype_int16 yyrline[] =
        -:  703:{
        -:  704:       0,   263,   263,   264,   265,   266,   267,   268,   269,   277,
        -:  705:     290,   295,   289,   316,   319,   349,   352,   377,   382,   383,
        -:  706:     388,   389,   395,   398,   416,   425,   464,   465,   470,   487,
        -:  707:     501,   515,   529,   547,   548,   554,   553,   569,   568,   585,
        -:  708:     584,   604,   605,   610,   611,   612,   613,   614,   615,   619,
        -:  709:     620,   624,   625,   626,   627,   628,   632,   633,   637,   641,
        -:  710:     727,   774,   833,   879,   880,   884,   912,   952,   995,  1015,
        -:  711:    1022,  1029,  1041,  1051,  1065,  1080,  1091,  1102,  1219,  1101,
        -:  712:    1401,  1400,  1478,  1484,  1491,  1490,  1536,  1535,  1579,  1586,
        -:  713:    1593,  1600,  1607,  1614,  1621,  1625,  1633,  1634,  1639,  1663,
        -:  714:    1676,  1694,  1693,  1699,  1711,  1712,  1717,  1724,  1735,  1739,
        -:  715:    1744,  1753,  1757,  1765,  1777,  1791,  1799,  1806,  1831,  1843,
        -:  716:    1855,  1871,  1883,  1899,  1946,  1967,  2002,  2037,  2071,  2096,
        -:  717:    2113,  2123,  2133,  2143,  2153,  2173,  2193
        -:  718:};
        -:  719:#endif
        -:  720:
        -:  721:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  722:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  723:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  724:static const char *const yytname[] =
        -:  725:{
        -:  726:  "\"end of file\"", "error", "$undefined", "\"end of included file\"",
        -:  727:  "\"..\"", "\"<rule>\"", "\"<private>\"", "\"<global>\"", "\"<meta>\"",
        -:  728:  "\"<strings>\"", "\"<condition>\"", "\"identifier\"",
        -:  729:  "\"string identifier\"", "\"string count\"", "\"string offset\"",
        -:  730:  "\"string length\"", "\"string identifier with wildcard\"",
        -:  731:  "\"integer number\"", "\"floating point number\"",
        -:  732:  "\"integer function\"", "\"text string\"", "\"hex string\"",
        -:  733:  "\"regular expression\"", "\"<ascii>\"", "\"<wide>\"", "\"<xor>\"",
        -:  734:  "\"<nocase>\"", "\"<fullword>\"", "\"<at>\"", "\"<filesize>\"",
        -:  735:  "\"<entrypoint>\"", "\"<all>\"", "\"<any>\"", "\"<in>\"", "\"<of>\"",
        -:  736:  "\"<for>\"", "\"<them>\"", "\"<matches>\"", "\"<contains>\"",
        -:  737:  "\"<import>\"", "\"<true>\"", "\"<false\"", "\"<or>\"", "\"<and>\"",
        -:  738:  "\"<not>\"", "\"==\"", "\"!=\"", "\"<\"", "\"<=\"", "\">\"", "\">=\"",
        -:  739:  "\"<<\"", "\">>\"", "'|'", "'^'", "'&'", "'+'", "'-'", "'*'", "'\\\\'",
        -:  740:  "'%'", "'~'", "UNARY_MINUS", "\"include\"", "'{'", "'}'", "':'", "'='",
        -:  741:  "'.'", "'['", "']'", "'('", "')'", "','", "$accept", "rules", "import",
        -:  742:  "rule", "@1", "$@2", "meta", "strings", "condition", "rule_modifiers",
        -:  743:  "rule_modifier", "tags", "tag_list", "meta_declarations",
        -:  744:  "meta_declaration", "string_declarations", "string_declaration", "$@3",
        -:  745:  "$@4", "$@5", "string_modifiers", "string_modifier", "regexp_modifiers",
        -:  746:  "regexp_modifier", "hex_modifiers", "hex_modifier", "identifier",
        -:  747:  "arguments", "arguments_list", "regexp", "boolean_expression",
        -:  748:  "expression", "$@6", "$@7", "$@8", "$@9", "$@10", "integer_set", "range",
        -:  749:  "integer_enumeration", "string_set", "$@11", "string_enumeration",
        -:  750:  "string_enumeration_item", "for_expression", "primary_expression", YY_NULLPTR
        -:  751:};
        -:  752:#endif
        -:  753:
        -:  754:# ifdef YYPRINT
        -:  755:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  756:   (internal) symbol number NUM (which must be that of a token).  */
        -:  757:static const yytype_int16 yytoknum[] =
        -:  758:{
        -:  759:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  760:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  761:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  762:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  763:     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
        -:  764:     305,   306,   307,   124,    94,    38,    43,    45,    42,    92,
        -:  765:      37,   126,   308,   309,   123,   125,    58,    61,    46,    91,
        -:  766:      93,    40,    41,    44
        -:  767:};
        -:  768:# endif
        -:  769:
        -:  770:#define YYPACT_NINF (-74)
        -:  771:
        -:  772:#define yypact_value_is_default(Yyn) \
        -:  773:  ((Yyn) == YYPACT_NINF)
        -:  774:
        -:  775:#define YYTABLE_NINF (-109)
        -:  776:
        -:  777:#define yytable_value_is_error(Yyn) \
        -:  778:  0
        -:  779:
        -:  780:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  781:     STATE-NUM.  */
        -:  782:static const yytype_int16 yypact[] =
        -:  783:{
        -:  784:     -74,   191,   -74,   -36,   -74,    -4,   -74,   -74,    80,   -74,
        -:  785:     -74,   -74,   -74,     7,   -74,   -74,   -74,   -74,   -42,    18,
        -:  786:     -33,   -74,    47,    62,   -74,     6,    74,    77,    26,   -74,
        -:  787:      40,    77,   -74,    93,   105,    16,   -74,    52,    93,   -74,
        -:  788:      55,    57,   -74,   -74,   -74,   -74,   121,    13,   -74,    49,
        -:  789:     -74,   -74,   123,   126,   128,   -74,   -20,   -74,    81,    86,
        -:  790:     -74,   -74,    88,   -74,   -74,   -74,   -74,   -74,   -74,   122,
        -:  791:     -74,   -74,    49,   147,   147,    49,   -59,   -74,    34,   -74,
        -:  792:     134,   223,   -74,   -74,   -74,   147,   100,   147,   147,   147,
        -:  793:     147,     3,   335,   -74,   -74,   -74,    34,    84,   195,   146,
        -:  794:     147,    49,   -74,   -74,    -6,   151,   147,   147,   147,   147,
        -:  795:     147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
        -:  796:     147,   147,   147,    76,    85,   169,   335,   147,   -74,   275,
        -:  797:     295,   233,   243,   -74,   141,    -6,   -74,   -74,   -74,   315,
        -:  798:     106,   109,    71,    49,    49,   -74,   -74,   -74,   -74,   335,
        -:  799:     335,   335,   335,   335,   335,   335,   143,   143,    72,   129,
        -:  800:     154,    38,    38,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  801:     -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  802:     -74,   168,   -74,   -74,   -74,   -74,   124,   -74,   -74,    49,
        -:  803:     152,   -74,    -1,   147,   136,   -74,    71,   -74,   -74,    45,
        -:  804:     -74,   265,   147,   149,   -74,   138,   -74,    -1,   -74,    73,
        -:  805:     168,   -74,    49,   -74,   -74,   147,   145,   -17,   335,    49,
        -:  806:     -74,    32,   -74
        -:  807:};
        -:  808:
        -:  809:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  810:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  811:     means the default is an error.  */
        -:  812:static const yytype_uint8 yydefact[] =
        -:  813:{
        -:  814:       2,     0,     1,    18,     8,     0,     4,     3,     0,     7,
        -:  815:       6,     5,     9,     0,    20,    21,    19,    10,    22,     0,
        -:  816:       0,    24,    23,    13,    25,     0,    15,     0,     0,    11,
        -:  817:       0,    14,    26,     0,     0,     0,    27,     0,    16,    33,
        -:  818:       0,     0,    29,    28,    31,    32,     0,    35,    34,     0,
        -:  819:      12,    30,     0,     0,     0,    59,    73,   118,   120,   122,
        -:  820:     115,   116,     0,   117,    67,   112,   113,   109,   110,     0,
        -:  821:      69,    70,     0,     0,     0,     0,   123,   136,    17,    68,
        -:  822:       0,    94,    41,    49,    56,     0,     0,     0,     0,     0,
        -:  823:       0,     0,   108,    83,   124,   133,     0,    68,    94,     0,
        -:  824:       0,    63,    86,    84,     0,     0,     0,     0,     0,     0,
        -:  825:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  826:       0,     0,     0,    36,    38,    40,    74,     0,    75,     0,
        -:  827:       0,     0,     0,    76,     0,     0,    95,   111,    60,     0,
        -:  828:       0,    64,    65,     0,     0,   103,   101,    82,    71,    72,
        -:  829:      92,    93,    88,    90,    89,    91,   134,   135,   132,   130,
        -:  830:     131,   125,   126,   127,   128,   129,    48,    44,    43,    47,
        -:  831:      45,    46,    42,    55,    52,    51,    53,    54,    50,    58,
        -:  832:      57,     0,   119,   121,   114,    77,     0,    61,    62,     0,
        -:  833:      87,    85,     0,     0,     0,    80,    66,   106,   107,     0,
        -:  834:     104,     0,     0,     0,    97,     0,   102,     0,    98,     0,
        -:  835:      99,    78,     0,   105,    96,     0,     0,     0,   100,     0,
        -:  836:      81,     0,    79
        -:  837:};
        -:  838:
        -:  839:  /* YYPGOTO[NTERM-NUM].  */
        -:  840:static const yytype_int16 yypgoto[] =
        -:  841:{
        -:  842:     -74,   -74,   214,   228,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  843:     -74,   -74,   -74,   -74,   203,   -74,   197,   -74,   -74,   -74,
        -:  844:     -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   131,
        -:  845:     -49,   -73,   -74,   -74,   -74,   -74,   -74,   -74,    43,   -74,
        -:  846:     103,   -74,   -74,    51,   170,   -68
        -:  847:};
        -:  848:
        -:  849:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  850:static const yytype_int16 yydefgoto[] =
        -:  851:{
        -:  852:      -1,     1,     6,     7,    18,    34,    26,    29,    41,     8,
        -:  853:      16,    20,    22,    31,    32,    38,    39,    52,    53,    54,
        -:  854:     123,   172,   124,   178,   125,   180,    76,   140,   141,    77,
        -:  855:      96,    79,   194,   216,   205,   144,   143,   203,   128,   209,
        -:  856:     147,   192,   199,   200,    80,    81
        -:  857:};
        -:  858:
        -:  859:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  860:     positive, shift that token.  If negative, reduce the rule whose
        -:  861:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  862:static const yytype_int16 yytable[] =
        -:  863:{
        -:  864:      78,    92,    97,     5,   133,    94,    95,    98,    85,    99,
        -:  865:     100,   197,   101,    86,   134,   198,    12,   126,    17,   129,
        -:  866:     130,   131,   132,    93,    19,   102,   103,     9,   142,    21,
        -:  867:     145,    23,   139,    42,   -39,   -37,    43,   135,   149,   150,
        -:  868:     151,   152,   153,   154,   155,   156,   157,   158,   159,   160,
        -:  869:     161,   162,   163,   164,   165,   220,    44,    45,    24,   181,
        -:  870:      55,    56,    57,    58,    59,   146,    60,    61,    62,    63,
        -:  871:      25,    64,    27,    46,   102,   103,   102,   103,    65,    66,
        -:  872:      67,    68,   166,    28,    69,    13,    14,    15,    30,    70,
        -:  873:      71,   173,    33,    72,   190,   191,   120,   121,   122,   167,
        -:  874:     168,   169,   170,   171,   222,    37,    73,    35,   174,   175,
        -:  875:      74,   176,   177,   -68,   -68,    40,   196,   206,   207,    47,
        -:  876:      75,    49,    50,   113,   114,   201,   116,   117,   118,   119,
        -:  877:     120,   121,   122,    55,   210,    57,    58,    59,    51,    60,
        -:  878:      61,    62,    63,    82,    64,   214,   215,   218,    83,    84,
        -:  879:      87,    65,    66,    67,    68,    88,   136,   138,    55,    89,
        -:  880:      57,    58,    59,   217,    60,    61,    62,    63,   104,    64,
        -:  881:     221,   127,   193,    64,   185,   179,    65,    66,   188,    73,
        -:  882:     113,   114,   189,    74,   117,   118,   119,   120,   121,   122,
        -:  883:     195,     2,     3,    90,     4,   103,   -18,   -18,   -18,   118,
        -:  884:     119,   120,   121,   122,    73,   113,   114,   202,    74,   212,
        -:  885:     118,   119,   120,   121,   122,   211,   219,    10,    90,   113,
        -:  886:     114,   115,   116,   117,   118,   119,   120,   121,   122,  -108,
        -:  887:       5,    11,   105,   106,    36,    48,   148,   204,   186,    91,
        -:  888:     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
        -:  889:     117,   118,   119,   120,   121,   122,     0,  -108,   213,     0,
        -:  890:     105,   106,     0,     0,     0,     0,     0,   137,   107,   108,
        -:  891:     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
        -:  892:     119,   120,   121,   122,   113,   114,   115,   116,   117,   118,
        -:  893:     119,   120,   121,   122,   113,   114,   115,   116,   117,   118,
        -:  894:     119,   120,   121,   122,     0,   184,     0,     0,     0,     0,
        -:  895:       0,     0,     0,     0,     0,   137,   113,   114,   115,   116,
        -:  896:     117,   118,   119,   120,   121,   122,   113,   114,   115,   116,
        -:  897:     117,   118,   119,   120,   121,   122,     0,   208,     0,     0,
        -:  898:       0,     0,     0,     0,     0,   182,   113,   114,   115,   116,
        -:  899:     117,   118,   119,   120,   121,   122,     0,     0,     0,     0,
        -:  900:       0,     0,     0,     0,     0,   183,   113,   114,   115,   116,
        -:  901:     117,   118,   119,   120,   121,   122,     0,     0,     0,     0,
        -:  902:       0,     0,     0,     0,     0,   187,   113,   114,   115,   116,
        -:  903:     117,   118,   119,   120,   121,   122
        -:  904:};
        -:  905:
        -:  906:static const yytype_int16 yycheck[] =
        -:  907:{
        -:  908:      49,    69,    75,    39,     1,    73,    74,    75,    28,    68,
        -:  909:      69,    12,    71,    33,    11,    16,    20,    85,    11,    87,
        -:  910:      88,    89,    90,    72,    66,    42,    43,    63,   101,    11,
        -:  911:      36,    64,   100,    17,    21,    22,    20,    34,   106,   107,
        -:  912:     108,   109,   110,   111,   112,   113,   114,   115,   116,   117,
        -:  913:     118,   119,   120,   121,   122,    72,    40,    41,    11,   127,
        -:  914:      11,    12,    13,    14,    15,    71,    17,    18,    19,    20,
        -:  915:       8,    22,    66,    57,    42,    43,    42,    43,    29,    30,
        -:  916:      31,    32,     6,     9,    35,     5,     6,     7,    11,    40,
        -:  917:      41,     6,    66,    44,   143,   144,    58,    59,    60,    23,
        -:  918:      24,    25,    26,    27,    72,    12,    57,    67,    23,    24,
        -:  919:      61,    26,    27,    42,    43,    10,   189,    72,    73,    67,
        -:  920:      71,    66,    65,    51,    52,   193,    54,    55,    56,    57,
        -:  921:      58,    59,    60,    11,   202,    13,    14,    15,    17,    17,
        -:  922:      18,    19,    20,    20,    22,    72,    73,   215,    22,    21,
        -:  923:      69,    29,    30,    31,    32,    69,    72,    11,    11,    71,
        -:  924:      13,    14,    15,   212,    17,    18,    19,    20,    34,    22,
        -:  925:     219,    71,     4,    22,    33,     6,    29,    30,    72,    57,
        -:  926:      51,    52,    73,    61,    55,    56,    57,    58,    59,    60,
        -:  927:      66,     0,     1,    71,     3,    43,     5,     6,     7,    56,
        -:  928:      57,    58,    59,    60,    57,    51,    52,    71,    61,    71,
        -:  929:      56,    57,    58,    59,    60,    66,    71,     3,    71,    51,
        -:  930:      52,    53,    54,    55,    56,    57,    58,    59,    60,    34,
        -:  931:      39,     3,    37,    38,    31,    38,   105,   194,   135,    69,
        -:  932:      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
        -:  933:      55,    56,    57,    58,    59,    60,    -1,    34,   207,    -1,
        -:  934:      37,    38,    -1,    -1,    -1,    -1,    -1,    72,    45,    46,
        -:  935:      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
        -:  936:      57,    58,    59,    60,    51,    52,    53,    54,    55,    56,
        -:  937:      57,    58,    59,    60,    51,    52,    53,    54,    55,    56,
        -:  938:      57,    58,    59,    60,    -1,    72,    -1,    -1,    -1,    -1,
        -:  939:      -1,    -1,    -1,    -1,    -1,    72,    51,    52,    53,    54,
        -:  940:      55,    56,    57,    58,    59,    60,    51,    52,    53,    54,
        -:  941:      55,    56,    57,    58,    59,    60,    -1,    72,    -1,    -1,
        -:  942:      -1,    -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,
        -:  943:      55,    56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,
        -:  944:      -1,    -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,
        -:  945:      55,    56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,
        -:  946:      -1,    -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,
        -:  947:      55,    56,    57,    58,    59,    60
        -:  948:};
        -:  949:
        -:  950:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  951:     symbol of state STATE-NUM.  */
        -:  952:static const yytype_int8 yystos[] =
        -:  953:{
        -:  954:       0,    75,     0,     1,     3,    39,    76,    77,    83,    63,
        -:  955:      76,    77,    20,     5,     6,     7,    84,    11,    78,    66,
        -:  956:      85,    11,    86,    64,    11,     8,    80,    66,     9,    81,
        -:  957:      11,    87,    88,    66,    79,    67,    88,    12,    89,    90,
        -:  958:      10,    82,    17,    20,    40,    41,    57,    67,    90,    66,
        -:  959:      65,    17,    91,    92,    93,    11,    12,    13,    14,    15,
        -:  960:      17,    18,    19,    20,    22,    29,    30,    31,    32,    35,
        -:  961:      40,    41,    44,    57,    61,    71,   100,   103,   104,   105,
        -:  962:     118,   119,    20,    22,    21,    28,    33,    69,    69,    71,
        -:  963:      71,   118,   119,   104,   119,   119,   104,   105,   119,    68,
        -:  964:      69,    71,    42,    43,    34,    37,    38,    45,    46,    47,
        -:  965:      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
        -:  966:      58,    59,    60,    94,    96,    98,   119,    71,   112,   119,
        -:  967:     119,   119,   119,     1,    11,    34,    72,    72,    11,   119,
        -:  968:     101,   102,   105,   110,   109,    36,    71,   114,   103,   119,
        -:  969:     119,   119,   119,   119,   119,   119,   119,   119,   119,   119,
        -:  970:     119,   119,   119,   119,   119,   119,     6,    23,    24,    25,
        -:  971:      26,    27,    95,     6,    23,    24,    26,    27,    97,     6,
        -:  972:      99,   119,    70,    70,    72,    33,   114,    70,    72,    73,
        -:  973:     104,   104,   115,     4,   106,    66,   105,    12,    16,   116,
        -:  974:     117,   119,    71,   111,   112,   108,    72,    73,    72,   113,
        -:  975:     119,    66,    71,   117,    72,    73,   107,   104,   119,    71,
        -:  976:      72,   104,    72
        -:  977:};
        -:  978:
        -:  979:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  980:static const yytype_int8 yyr1[] =
        -:  981:{
        -:  982:       0,    74,    75,    75,    75,    75,    75,    75,    75,    76,
        -:  983:      78,    79,    77,    80,    80,    81,    81,    82,    83,    83,
        -:  984:      84,    84,    85,    85,    86,    86,    87,    87,    88,    88,
        -:  985:      88,    88,    88,    89,    89,    91,    90,    92,    90,    93,
        -:  986:      90,    94,    94,    95,    95,    95,    95,    95,    95,    96,
        -:  987:      96,    97,    97,    97,    97,    97,    98,    98,    99,   100,
        -:  988:     100,   100,   100,   101,   101,   102,   102,   103,   104,   105,
        -:  989:     105,   105,   105,   105,   105,   105,   105,   106,   107,   105,
        -:  990:     108,   105,   105,   105,   109,   105,   110,   105,   105,   105,
        -:  991:     105,   105,   105,   105,   105,   105,   111,   111,   112,   113,
        -:  992:     113,   115,   114,   114,   116,   116,   117,   117,   118,   118,
        -:  993:     118,   119,   119,   119,   119,   119,   119,   119,   119,   119,
        -:  994:     119,   119,   119,   119,   119,   119,   119,   119,   119,   119,
        -:  995:     119,   119,   119,   119,   119,   119,   119
        -:  996:};
        -:  997:
        -:  998:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  999:static const yytype_int8 yyr2[] =
        -: 1000:{
        -: 1001:       0,     2,     0,     2,     2,     3,     3,     3,     2,     2,
        -: 1002:       0,     0,    11,     0,     3,     0,     3,     3,     0,     2,
        -: 1003:       1,     1,     0,     2,     1,     2,     1,     2,     3,     3,
        -: 1004:       4,     3,     3,     1,     2,     0,     5,     0,     5,     0,
        -: 1005:       5,     0,     2,     1,     1,     1,     1,     1,     1,     0,
        -: 1006:       2,     1,     1,     1,     1,     1,     0,     2,     1,     1,
        -: 1007:       3,     4,     4,     0,     1,     1,     3,     1,     1,     1,
        -: 1008:       1,     3,     3,     1,     3,     3,     3,     0,     0,    11,
        -: 1009:       0,     9,     3,     2,     0,     4,     0,     4,     3,     3,
        -: 1010:       3,     3,     3,     3,     1,     3,     3,     1,     5,     1,
        -: 1011:       3,     0,     4,     1,     1,     3,     1,     1,     1,     1,
        -: 1012:       1,     3,     1,     1,     4,     1,     1,     1,     1,     4,
        -: 1013:       1,     4,     1,     1,     2,     3,     3,     3,     3,     3,
        -: 1014:       3,     3,     3,     2,     3,     3,     1
        -: 1015:};
        -: 1016:
        -: 1017:
        -: 1018:#define yyerrok         (yyerrstatus = 0)
        -: 1019:#define yyclearin       (yychar = YYEMPTY)
        -: 1020:#define YYEMPTY         (-2)
        -: 1021:#define YYEOF           0
        -: 1022:
        -: 1023:#define YYACCEPT        goto yyacceptlab
        -: 1024:#define YYABORT         goto yyabortlab
        -: 1025:#define YYERROR         goto yyerrorlab
        -: 1026:
        -: 1027:
        -: 1028:#define YYRECOVERING()  (!!yyerrstatus)
        -: 1029:
        -: 1030:#define YYBACKUP(Token, Value)                                    \
        -: 1031:  do                                                              \
        -: 1032:    if (yychar == YYEMPTY)                                        \
        -: 1033:      {                                                           \
        -: 1034:        yychar = (Token);                                         \
        -: 1035:        yylval = (Value);                                         \
        -: 1036:        YYPOPSTACK (yylen);                                       \
        -: 1037:        yystate = *yyssp;                                         \
        -: 1038:        goto yybackup;                                            \
        -: 1039:      }                                                           \
        -: 1040:    else                                                          \
        -: 1041:      {                                                           \
        -: 1042:        yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -: 1043:        YYERROR;                                                  \
        -: 1044:      }                                                           \
        -: 1045:  while (0)
        -: 1046:
        -: 1047:/* Error token number */
        -: 1048:#define YYTERROR        1
        -: 1049:#define YYERRCODE       256
        -: 1050:
        -: 1051:
        -: 1052:
        -: 1053:/* Enable debugging if requested.  */
        -: 1054:#if YYDEBUG
        -: 1055:
        -: 1056:# ifndef YYFPRINTF
        -: 1057:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -: 1058:#  define YYFPRINTF fprintf
        -: 1059:# endif
        -: 1060:
        -: 1061:# define YYDPRINTF(Args)                        \
        -: 1062:do {                                            \
        -: 1063:  if (yydebug)                                  \
        -: 1064:    YYFPRINTF Args;                             \
        -: 1065:} while (0)
        -: 1066:
        -: 1067:/* This macro is provided for backward compatibility. */
        -: 1068:#ifndef YY_LOCATION_PRINT
        -: 1069:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -: 1070:#endif
        -: 1071:
        -: 1072:
        -: 1073:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -: 1074:do {                                                                      \
        -: 1075:  if (yydebug)                                                            \
        -: 1076:    {                                                                     \
        -: 1077:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -: 1078:      yy_symbol_print (stderr,                                            \
        -: 1079:                  Type, Value, yyscanner, compiler); \
        -: 1080:      YYFPRINTF (stderr, "\n");                                           \
        -: 1081:    }                                                                     \
        -: 1082:} while (0)
        -: 1083:
        -: 1084:
        -: 1085:/*-----------------------------------.
        -: 1086:| Print this symbol's value on YYO.  |
        -: 1087:`-----------------------------------*/
        -: 1088:
        -: 1089:static void
        -: 1090:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1091:{
        -: 1092:  FILE *yyoutput = yyo;
        -: 1093:  YYUSE (yyoutput);
        -: 1094:  YYUSE (yyscanner);
        -: 1095:  YYUSE (compiler);
        -: 1096:  if (!yyvaluep)
        -: 1097:    return;
        -: 1098:# ifdef YYPRINT
        -: 1099:  if (yytype < YYNTOKENS)
        -: 1100:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -: 1101:# endif
        -: 1102:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -: 1103:  YYUSE (yytype);
        -: 1104:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1105:}
        -: 1106:
        -: 1107:
        -: 1108:/*---------------------------.
        -: 1109:| Print this symbol on YYO.  |
        -: 1110:`---------------------------*/
        -: 1111:
        -: 1112:static void
        -: 1113:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1114:{
        -: 1115:  YYFPRINTF (yyo, "%s %s (",
        -: 1116:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1117:
        -: 1118:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, compiler);
        -: 1119:  YYFPRINTF (yyo, ")");
        -: 1120:}
        -: 1121:
        -: 1122:/*------------------------------------------------------------------.
        -: 1123:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1124:| TOP (included).                                                   |
        -: 1125:`------------------------------------------------------------------*/
        -: 1126:
        -: 1127:static void
        -: 1128:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -: 1129:{
        -: 1130:  YYFPRINTF (stderr, "Stack now");
        -: 1131:  for (; yybottom <= yytop; yybottom++)
        -: 1132:    {
        -: 1133:      int yybot = *yybottom;
        -: 1134:      YYFPRINTF (stderr, " %d", yybot);
        -: 1135:    }
        -: 1136:  YYFPRINTF (stderr, "\n");
        -: 1137:}
        -: 1138:
        -: 1139:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1140:do {                                                            \
        -: 1141:  if (yydebug)                                                  \
        -: 1142:    yy_stack_print ((Bottom), (Top));                           \
        -: 1143:} while (0)
        -: 1144:
        -: 1145:
        -: 1146:/*------------------------------------------------.
        -: 1147:| Report that the YYRULE is going to be reduced.  |
        -: 1148:`------------------------------------------------*/
        -: 1149:
        -: 1150:static void
        -: 1151:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1152:{
        -: 1153:  int yylno = yyrline[yyrule];
        -: 1154:  int yynrhs = yyr2[yyrule];
        -: 1155:  int yyi;
        -: 1156:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -: 1157:             yyrule - 1, yylno);
        -: 1158:  /* The symbols being reduced.  */
        -: 1159:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1160:    {
        -: 1161:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1162:      yy_symbol_print (stderr,
        -: 1163:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -: 1164:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -: 1165:                                              , yyscanner, compiler);
        -: 1166:      YYFPRINTF (stderr, "\n");
        -: 1167:    }
        -: 1168:}
        -: 1169:
        -: 1170:# define YY_REDUCE_PRINT(Rule)          \
        -: 1171:do {                                    \
        -: 1172:  if (yydebug)                          \
        -: 1173:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1174:} while (0)
        -: 1175:
        -: 1176:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1177:   multiple parsers can coexist.  */
        -: 1178:int yydebug;
        -: 1179:#else /* !YYDEBUG */
        -: 1180:# define YYDPRINTF(Args)
        -: 1181:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1182:# define YY_STACK_PRINT(Bottom, Top)
        -: 1183:# define YY_REDUCE_PRINT(Rule)
        -: 1184:#endif /* !YYDEBUG */
        -: 1185:
        -: 1186:
        -: 1187:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1188:#ifndef YYINITDEPTH
        -: 1189:# define YYINITDEPTH 200
        -: 1190:#endif
        -: 1191:
        -: 1192:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1193:   if the built-in stack extension method is used).
        -: 1194:
        -: 1195:   Do not make this value too large; the results are undefined if
        -: 1196:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1197:   evaluated with infinite-precision integer arithmetic.  */
        -: 1198:
        -: 1199:#ifndef YYMAXDEPTH
        -: 1200:# define YYMAXDEPTH 10000
        -: 1201:#endif
        -: 1202:
        -: 1203:
        -: 1204:#if YYERROR_VERBOSE
        -: 1205:
        -: 1206:# ifndef yystrlen
        -: 1207:#  if defined __GLIBC__ && defined _STRING_H
        -: 1208:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -: 1209:#  else
        -: 1210:/* Return the length of YYSTR.  */
        -: 1211:static YYPTRDIFF_T
        -: 1212:yystrlen (const char *yystr)
        -: 1213:{
        -: 1214:  YYPTRDIFF_T yylen;
        -: 1215:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1216:    continue;
        -: 1217:  return yylen;
        -: 1218:}
        -: 1219:#  endif
        -: 1220:# endif
        -: 1221:
        -: 1222:# ifndef yystpcpy
        -: 1223:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1224:#   define yystpcpy stpcpy
        -: 1225:#  else
        -: 1226:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1227:   YYDEST.  */
        -: 1228:static char *
    #####: 1229:yystpcpy (char *yydest, const char *yysrc)
        -: 1230:{
    #####: 1231:  char *yyd = yydest;
    #####: 1232:  const char *yys = yysrc;
        -: 1233:
    #####: 1234:  while ((*yyd++ = *yys++) != '\0')
    #####: 1235:    continue;
        -: 1236:
    #####: 1237:  return yyd - 1;
        -: 1238:}
        -: 1239:#  endif
        -: 1240:# endif
        -: 1241:
        -: 1242:# ifndef yytnamerr
        -: 1243:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1244:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1245:   heuristic is that double-quoting is unnecessary unless the string
        -: 1246:   contains an apostrophe, a comma, or backslash (other than
        -: 1247:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1248:   null, do not copy; instead, return the length of what the result
        -: 1249:   would have been.  */
        -: 1250:static YYPTRDIFF_T
       12: 1251:yytnamerr (char *yyres, const char *yystr)
        -: 1252:{
       12: 1253:  if (*yystr == '"')
        -: 1254:    {
       12: 1255:      YYPTRDIFF_T yyn = 0;
       12: 1256:      char const *yyp = yystr;
        -: 1257:
        -: 1258:      for (;;)
      144: 1259:        switch (*++yyp)
        -: 1260:          {
    #####: 1261:          case '\'':
        -: 1262:          case ',':
    #####: 1263:            goto do_not_strip_quotes;
        -: 1264:
    #####: 1265:          case '\\':
    #####: 1266:            if (*++yyp != '\\')
    #####: 1267:              goto do_not_strip_quotes;
        -: 1268:            else
    #####: 1269:              goto append;
        -: 1270:
      132: 1271:          append:
        -: 1272:          default:
      132: 1273:            if (yyres)
       66: 1274:              yyres[yyn] = *yyp;
      132: 1275:            yyn++;
      132: 1276:            break;
        -: 1277:
       12: 1278:          case '"':
       12: 1279:            if (yyres)
        6: 1280:              yyres[yyn] = '\0';
       12: 1281:            return yyn;
        -: 1282:          }
    #####: 1283:    do_not_strip_quotes: ;
        -: 1284:    }
        -: 1285:
    #####: 1286:  if (yyres)
    #####: 1287:    return yystpcpy (yyres, yystr) - yyres;
        -: 1288:  else
    #####: 1289:    return yystrlen (yystr);
        -: 1290:}
        -: 1291:# endif
        -: 1292:
        -: 1293:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1294:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1295:   YYSSP.
        -: 1296:
        -: 1297:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1298:   not large enough to hold the message.  In that case, also set
        -: 1299:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1300:   required number of bytes is too large to store.  */
        -: 1301:static int
        3: 1302:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -: 1303:                yy_state_t *yyssp, int yytoken)
        -: 1304:{
        -: 1305:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1306:  /* Internationalized format string. */
        3: 1307:  const char *yyformat = YY_NULLPTR;
        -: 1308:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -: 1309:     one per "expected"). */
        -: 1310:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1311:  /* Actual size of YYARG. */
        3: 1312:  int yycount = 0;
        -: 1313:  /* Cumulated lengths of YYARG.  */
        3: 1314:  YYPTRDIFF_T yysize = 0;
        -: 1315:
        -: 1316:  /* There are many possibilities here to consider:
        -: 1317:     - If this state is a consistent state with a default action, then
        -: 1318:       the only way this function was invoked is if the default action
        -: 1319:       is an error action.  In that case, don't check for expected
        -: 1320:       tokens because there are none.
        -: 1321:     - The only way there can be no lookahead present (in yychar) is if
        -: 1322:       this state is a consistent state with a default action.  Thus,
        -: 1323:       detecting the absence of a lookahead is sufficient to determine
        -: 1324:       that there is no unexpected or expected token to report.  In that
        -: 1325:       case, just report a simple "syntax error".
        -: 1326:     - Don't assume there isn't a lookahead just because this state is a
        -: 1327:       consistent state with a default action.  There might have been a
        -: 1328:       previous inconsistent state, consistent state with a non-default
        -: 1329:       action, or user semantic action that manipulated yychar.
        -: 1330:     - Of course, the expected token list depends on states to have
        -: 1331:       correct lookahead information, and it depends on the parser not
        -: 1332:       to perform extra reductions after fetching a lookahead from the
        -: 1333:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1334:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1335:       token list.  However, the list is correct for canonical LR with
        -: 1336:       one exception: it will still contain any token that will not be
        -: 1337:       accepted due to an error action in a later state.
        -: 1338:  */
        3: 1339:  if (yytoken != YYEMPTY)
        -: 1340:    {
        3: 1341:      int yyn = yypact[+*yyssp];
        3: 1342:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
        3: 1343:      yysize = yysize0;
        3: 1344:      yyarg[yycount++] = yytname[yytoken];
        3: 1345:      if (!yypact_value_is_default (yyn))
        -: 1346:        {
        -: 1347:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1348:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1349:             this state because they are default actions.  */
       3*: 1350:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1351:          /* Stay within bounds of both yycheck and yytname.  */
        3: 1352:          int yychecklim = YYLAST - yyn + 1;
        3: 1353:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1354:          int yyx;
        -: 1355:
      225: 1356:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
      222: 1357:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
        3: 1358:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1359:              {
        3: 1360:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1361:                  {
    #####: 1362:                    yycount = 1;
    #####: 1363:                    yysize = yysize0;
    #####: 1364:                    break;
        -: 1365:                  }
        3: 1366:                yyarg[yycount++] = yytname[yyx];
        -: 1367:                {
        3: 1368:                  YYPTRDIFF_T yysize1
        3: 1369:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
        3: 1370:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        3: 1371:                    yysize = yysize1;
        -: 1372:                  else
    #####: 1373:                    return 2;
        -: 1374:                }
        -: 1375:              }
        -: 1376:        }
        -: 1377:    }
        -: 1378:
        3: 1379:  switch (yycount)
        -: 1380:    {
        -: 1381:# define YYCASE_(N, S)                      \
        -: 1382:      case N:                               \
        -: 1383:        yyformat = S;                       \
        -: 1384:      break
    #####: 1385:    default: /* Avoid compiler warnings. */
    #####: 1386:      YYCASE_(0, YY_("syntax error"));
    #####: 1387:      YYCASE_(1, YY_("syntax error, unexpected %s"));
        3: 1388:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1389:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1390:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1391:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1392:# undef YYCASE_
        -: 1393:    }
        -: 1394:
        -: 1395:  {
        -: 1396:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1397:       the terminator.  */
        3: 1398:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
        3: 1399:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        3: 1400:      yysize = yysize1;
        -: 1401:    else
    #####: 1402:      return 2;
        -: 1403:  }
        -: 1404:
        3: 1405:  if (*yymsg_alloc < yysize)
        -: 1406:    {
    #####: 1407:      *yymsg_alloc = 2 * yysize;
    #####: 1408:      if (! (yysize <= *yymsg_alloc
        -: 1409:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1410:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1411:      return 1;
        -: 1412:    }
        -: 1413:
        -: 1414:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1415:     Don't have undefined behavior even if the translation
        -: 1416:     produced a string with the wrong number of "%s"s.  */
        -: 1417:  {
        3: 1418:    char *yyp = *yymsg;
        3: 1419:    int yyi = 0;
      120: 1420:    while ((*yyp = *yyformat) != '\0')
      117: 1421:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1422:        {
        6: 1423:          yyp += yytnamerr (yyp, yyarg[yyi++]);
        6: 1424:          yyformat += 2;
        -: 1425:        }
        -: 1426:      else
        -: 1427:        {
      111: 1428:          ++yyp;
      111: 1429:          ++yyformat;
        -: 1430:        }
        -: 1431:  }
        3: 1432:  return 0;
        -: 1433:}
        -: 1434:#endif /* YYERROR_VERBOSE */
        -: 1435:
        -: 1436:/*-----------------------------------------------.
        -: 1437:| Release the memory associated to this symbol.  |
        -: 1438:`-----------------------------------------------*/
        -: 1439:
        -: 1440:static void
      930: 1441:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1442:{
        -: 1443:  YYUSE (yyvaluep);
        -: 1444:  YYUSE (yyscanner);
        -: 1445:  YYUSE (compiler);
      930: 1446:  if (!yymsg)
    #####: 1447:    yymsg = "Deleting";
        -: 1448:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1449:
        -: 1450:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
      930: 1451:  switch (yytype)
        -: 1452:    {
       16: 1453:    case 11: /* "identifier"  */
        -: 1454:#line 235 "grammar.y"
        -: 1455:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1456:#line 1457 "grammar.c"
       16: 1457:        break;
        -: 1458:
       15: 1459:    case 12: /* "string identifier"  */
        -: 1460:#line 239 "grammar.y"
        -: 1461:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1462:#line 1463 "grammar.c"
       15: 1463:        break;
        -: 1464:
    #####: 1465:    case 13: /* "string count"  */
        -: 1466:#line 236 "grammar.y"
        -: 1467:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1468:#line 1469 "grammar.c"
    #####: 1469:        break;
        -: 1470:
    #####: 1471:    case 14: /* "string offset"  */
        -: 1472:#line 237 "grammar.y"
        -: 1473:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1474:#line 1475 "grammar.c"
    #####: 1475:        break;
        -: 1476:
    #####: 1477:    case 15: /* "string length"  */
        -: 1478:#line 238 "grammar.y"
        -: 1479:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1480:#line 1481 "grammar.c"
    #####: 1481:        break;
        -: 1482:
    #####: 1483:    case 16: /* "string identifier with wildcard"  */
        -: 1484:#line 240 "grammar.y"
        -: 1485:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1486:#line 1487 "grammar.c"
    #####: 1487:        break;
        -: 1488:
    #####: 1489:    case 20: /* "text string"  */
        -: 1490:#line 241 "grammar.y"
        -: 1491:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1492:#line 1493 "grammar.c"
    #####: 1493:        break;
        -: 1494:
    #####: 1495:    case 21: /* "hex string"  */
        -: 1496:#line 242 "grammar.y"
        -: 1497:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1498:#line 1499 "grammar.c"
    #####: 1499:        break;
        -: 1500:
    #####: 1501:    case 22: /* "regular expression"  */
        -: 1502:#line 243 "grammar.y"
        -: 1503:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1504:#line 1505 "grammar.c"
    #####: 1505:        break;
        -: 1506:
    #####: 1507:    case 101: /* arguments  */
        -: 1508:#line 245 "grammar.y"
        -: 1509:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1510:#line 1511 "grammar.c"
    #####: 1511:        break;
        -: 1512:
    #####: 1513:    case 102: /* arguments_list  */
        -: 1514:#line 246 "grammar.y"
        -: 1515:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1516:#line 1517 "grammar.c"
    #####: 1517:        break;
        -: 1518:
      899: 1519:      default:
      899: 1520:        break;
        -: 1521:    }
        -: 1522:  YY_IGNORE_MAYBE_UNINITIALIZED_END
      930: 1523:}
        -: 1524:
        -: 1525:
        -: 1526:
        -: 1527:
        -: 1528:/*----------.
        -: 1529:| yyparse.  |
        -: 1530:`----------*/
        -: 1531:
        -: 1532:int
      296: 1533:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1534:{
        -: 1535:/* The lookahead symbol.  */
        -: 1536:int yychar;
        -: 1537:
        -: 1538:
        -: 1539:/* The semantic value of the lookahead symbol.  */
        -: 1540:/* Default value used for initialization, for pacifying older GCCs
        -: 1541:   or non-GCC compilers.  */
        -: 1542:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1543:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1544:
        -: 1545:    /* Number of syntax errors so far.  */
        -: 1546:    int yynerrs;
        -: 1547:
        -: 1548:    yy_state_fast_t yystate;
        -: 1549:    /* Number of tokens to shift before error messages enabled.  */
        -: 1550:    int yyerrstatus;
        -: 1551:
        -: 1552:    /* The stacks and their tools:
        -: 1553:       'yyss': related to states.
        -: 1554:       'yyvs': related to semantic values.
        -: 1555:
        -: 1556:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1557:       to reallocate them elsewhere.  */
        -: 1558:
        -: 1559:    /* The state stack.  */
        -: 1560:    yy_state_t yyssa[YYINITDEPTH];
        -: 1561:    yy_state_t *yyss;
        -: 1562:    yy_state_t *yyssp;
        -: 1563:
        -: 1564:    /* The semantic value stack.  */
        -: 1565:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1566:    YYSTYPE *yyvs;
        -: 1567:    YYSTYPE *yyvsp;
        -: 1568:
        -: 1569:    YYPTRDIFF_T yystacksize;
        -: 1570:
        -: 1571:  int yyn;
        -: 1572:  int yyresult;
        -: 1573:  /* Lookahead token as an internal (translated) token number.  */
      296: 1574:  int yytoken = 0;
        -: 1575:  /* The variables used to return semantic value and location from the
        -: 1576:     action routines.  */
        -: 1577:  YYSTYPE yyval;
        -: 1578:
        -: 1579:#if YYERROR_VERBOSE
        -: 1580:  /* Buffer for error messages, and its allocated size.  */
        -: 1581:  char yymsgbuf[128];
      296: 1582:  char *yymsg = yymsgbuf;
      296: 1583:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1584:#endif
        -: 1585:
        -: 1586:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1587:
        -: 1588:  /* The number of symbols on the RHS of the reduced rule.
        -: 1589:     Keep to zero when no symbol should be popped.  */
      296: 1590:  int yylen = 0;
        -: 1591:
      296: 1592:  yyssp = yyss = yyssa;
      296: 1593:  yyvsp = yyvs = yyvsa;
      296: 1594:  yystacksize = YYINITDEPTH;
        -: 1595:
        -: 1596:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1597:
      296: 1598:  yystate = 0;
      296: 1599:  yyerrstatus = 0;
      296: 1600:  yynerrs = 0;
      296: 1601:  yychar = YYEMPTY; /* Cause a token to be read.  */
      296: 1602:  goto yysetstate;
        -: 1603:
        -: 1604:
        -: 1605:/*------------------------------------------------------------.
        -: 1606:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1607:`------------------------------------------------------------*/
     8590: 1608:yynewstate:
        -: 1609:  /* In all cases, when you get here, the value and location stacks
        -: 1610:     have just been pushed.  So pushing a state here evens the stacks.  */
     8590: 1611:  yyssp++;
        -: 1612:
        -: 1613:
        -: 1614:/*--------------------------------------------------------------------.
        -: 1615:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1616:`--------------------------------------------------------------------*/
     8886: 1617:yysetstate:
        -: 1618:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1619:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1620:  YY_IGNORE_USELESS_CAST_BEGIN
     8886: 1621:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1622:  YY_IGNORE_USELESS_CAST_END
        -: 1623:
     8886: 1624:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1625:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1626:    goto yyexhaustedlab;
        -: 1627:#else
        -: 1628:    {
        -: 1629:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1630:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1631:
        -: 1632:# if defined yyoverflow
        -: 1633:      {
        -: 1634:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1635:           these so that the &'s don't force the real ones into
        -: 1636:           memory.  */
        -: 1637:        yy_state_t *yyss1 = yyss;
        -: 1638:        YYSTYPE *yyvs1 = yyvs;
        -: 1639:
        -: 1640:        /* Each stack pointer address is followed by the size of the
        -: 1641:           data in use in that stack, in bytes.  This used to be a
        -: 1642:           conditional around just the two extra args, but that might
        -: 1643:           be undefined if yyoverflow is a macro.  */
        -: 1644:        yyoverflow (YY_("memory exhausted"),
        -: 1645:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1646:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1647:                    &yystacksize);
        -: 1648:        yyss = yyss1;
        -: 1649:        yyvs = yyvs1;
        -: 1650:      }
        -: 1651:# else /* defined YYSTACK_RELOCATE */
        -: 1652:      /* Extend the stack our own way.  */
    #####: 1653:      if (YYMAXDEPTH <= yystacksize)
    #####: 1654:        goto yyexhaustedlab;
    #####: 1655:      yystacksize *= 2;
    #####: 1656:      if (YYMAXDEPTH < yystacksize)
    #####: 1657:        yystacksize = YYMAXDEPTH;
        -: 1658:
        -: 1659:      {
    #####: 1660:        yy_state_t *yyss1 = yyss;
        -: 1661:        union yyalloc *yyptr =
    #####: 1662:          YY_CAST (union yyalloc *,
        -: 1663:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1664:        if (! yyptr)
    #####: 1665:          goto yyexhaustedlab;
    #####: 1666:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1667:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1668:# undef YYSTACK_RELOCATE
    #####: 1669:        if (yyss1 != yyssa)
    #####: 1670:          YYSTACK_FREE (yyss1);
        -: 1671:      }
        -: 1672:# endif
        -: 1673:
    #####: 1674:      yyssp = yyss + yysize - 1;
    #####: 1675:      yyvsp = yyvs + yysize - 1;
        -: 1676:
        -: 1677:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1678:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1679:                  YY_CAST (long, yystacksize)));
        -: 1680:      YY_IGNORE_USELESS_CAST_END
        -: 1681:
    #####: 1682:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1683:        YYABORT;
        -: 1684:    }
        -: 1685:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1686:
     8886: 1687:  if (yystate == YYFINAL)
      280: 1688:    YYACCEPT;
        -: 1689:
     8606: 1690:  goto yybackup;
        -: 1691:
        -: 1692:
        -: 1693:/*-----------.
        -: 1694:| yybackup.  |
        -: 1695:`-----------*/
     8606: 1696:yybackup:
        -: 1697:  /* Do appropriate processing given the current state.  Read a
        -: 1698:     lookahead token if we need one and don't already have one.  */
        -: 1699:
        -: 1700:  /* First try to decide what to do without reference to lookahead token.  */
     8606: 1701:  yyn = yypact[yystate];
     8606: 1702:  if (yypact_value_is_default (yyn))
     2344: 1703:    goto yydefault;
        -: 1704:
        -: 1705:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1706:
        -: 1707:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
     6262: 1708:  if (yychar == YYEMPTY)
        -: 1709:    {
        -: 1710:      YYDPRINTF ((stderr, "Reading a token: "));
     3868: 1711:      yychar = yylex (&yylval, yyscanner, compiler);
        -: 1712:    }
        -: 1713:
     6262: 1714:  if (yychar <= YYEOF)
        -: 1715:    {
      319: 1716:      yychar = yytoken = YYEOF;
        -: 1717:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1718:    }
        -: 1719:  else
        -: 1720:    {
    5943*: 1721:      yytoken = YYTRANSLATE (yychar);
        -: 1722:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1723:    }
        -: 1724:
        -: 1725:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1726:     detect an error, take that action.  */
     6262: 1727:  yyn += yytoken;
     6262: 1728:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     1873: 1729:    goto yydefault;
     4389: 1730:  yyn = yytable[yyn];
     4389: 1731:  if (yyn <= 0)
        -: 1732:    {
        -: 1733:      if (yytable_value_is_error (yyn))
        -: 1734:        goto yyerrlab;
      589: 1735:      yyn = -yyn;
      589: 1736:      goto yyreduce;
        -: 1737:    }
        -: 1738:
        -: 1739:  /* Count tokens shifted since error; after three, turn off error
        -: 1740:     status.  */
     3800: 1741:  if (yyerrstatus)
    #####: 1742:    yyerrstatus--;
        -: 1743:
        -: 1744:  /* Shift the lookahead token.  */
        -: 1745:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
     3800: 1746:  yystate = yyn;
        -: 1747:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
     3800: 1748:  *++yyvsp = yylval;
        -: 1749:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1750:
        -: 1751:  /* Discard the shifted token.  */
     3800: 1752:  yychar = YYEMPTY;
     3800: 1753:  goto yynewstate;
        -: 1754:
        -: 1755:
        -: 1756:/*-----------------------------------------------------------.
        -: 1757:| yydefault -- do the default action for the current state.  |
        -: 1758:`-----------------------------------------------------------*/
     4217: 1759:yydefault:
     4217: 1760:  yyn = yydefact[yystate];
     4217: 1761:  if (yyn == 0)
       71: 1762:    goto yyerrlab;
     4146: 1763:  goto yyreduce;
        -: 1764:
        -: 1765:
        -: 1766:/*-----------------------------.
        -: 1767:| yyreduce -- do a reduction.  |
        -: 1768:`-----------------------------*/
     4735: 1769:yyreduce:
        -: 1770:  /* yyn is the number of a rule to reduce with.  */
     4735: 1771:  yylen = yyr2[yyn];
        -: 1772:
        -: 1773:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1774:     '$$ = $1'.
        -: 1775:
        -: 1776:     Otherwise, the following line sets YYVAL to garbage.
        -: 1777:     This behavior is undocumented and Bison
        -: 1778:     users should not rely upon it.  Assigning to YYVAL
        -: 1779:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1780:     GCC warning that YYVAL may be used uninitialized.  */
     4735: 1781:  yyval = yyvsp[1-yylen];
        -: 1782:
        -: 1783:
        -: 1784:  YY_REDUCE_PRINT (yyn);
     4735: 1785:  switch (yyn)
        -: 1786:    {
    #####: 1787:  case 8:
        -: 1788:#line 270 "grammar.y"
        -: 1789:      {
        -: 1790:        _yr_compiler_pop_file_name(compiler);
        -: 1791:      }
        -: 1792:#line 1793 "grammar.c"
    #####: 1793:    break;
        -: 1794:
    #####: 1795:  case 9:
        -: 1796:#line 278 "grammar.y"
        -: 1797:      {
        -: 1798:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1799:
        -: 1800:        yr_free((yyvsp[0].sized_string));
        -: 1801:
        -: 1802:        fail_if_error(result);
        -: 1803:      }
        -: 1804:#line 1805 "grammar.c"
    #####: 1805:    break;
        -: 1806:
      296: 1807:  case 10:
        -: 1808:#line 290 "grammar.y"
        -: 1809:      {
        -: 1810:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1811:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1812:      }
        -: 1813:#line 1814 "grammar.c"
      296: 1814:    break;
        -: 1815:
      281: 1816:  case 11:
        -: 1817:#line 295 "grammar.y"
        -: 1818:      {
        -: 1819:        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1
        -: 1820:
        -: 1821:        rule->tags = (yyvsp[-3].c_string);
        -: 1822:        rule->metas = (yyvsp[-1].meta);
        -: 1823:        rule->strings = (yyvsp[0].string);
        -: 1824:      }
        -: 1825:#line 1826 "grammar.c"
      281: 1826:    break;
        -: 1827:
      280: 1828:  case 12:
        -: 1829:#line 303 "grammar.y"
        -: 1830:      {
        -: 1831:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1832:            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1
        -: 1833:
        -: 1834:        yr_free((yyvsp[-8].c_string));
        -: 1835:
        -: 1836:        fail_if_error(result);
        -: 1837:      }
        -: 1838:#line 1839 "grammar.c"
      280: 1839:    break;
        -: 1840:
      296: 1841:  case 13:
        -: 1842:#line 316 "grammar.y"
        -: 1843:      {
        -: 1844:        (yyval.meta) = NULL;
        -: 1845:      }
        -: 1846:#line 1847 "grammar.c"
      296: 1847:    break;
        -: 1848:
    #####: 1849:  case 14:
        -: 1850:#line 320 "grammar.y"
        -: 1851:      {
        -: 1852:        int result;
        -: 1853:
        -: 1854:        // Each rule have a list of meta-data info, consisting in a
        -: 1855:        // sequence of YR_META structures. The last YR_META structure does
        -: 1856:        // not represent a real meta-data, it's just a end-of-list marker
        -: 1857:        // identified by a specific type (META_TYPE_NULL). Here we
        -: 1858:        // write the end-of-list marker.
        -: 1859:
        -: 1860:        YR_META null_meta;
        -: 1861:
        -: 1862:        memset(&null_meta, 0xFF, sizeof(YR_META));
        -: 1863:        null_meta.type = META_TYPE_NULL;
        -: 1864:
        -: 1865:        result = yr_arena_write_data(
        -: 1866:            compiler->metas_arena,
        -: 1867:            &null_meta,
        -: 1868:            sizeof(YR_META),
        -: 1869:            NULL);
        -: 1870:
        -: 1871:        (yyval.meta) = (yyvsp[0].meta);
        -: 1872:
        -: 1873:        fail_if_error(result);
        -: 1874:      }
        -: 1875:#line 1876 "grammar.c"
    #####: 1876:    break;
        -: 1877:
    #####: 1878:  case 15:
        -: 1879:#line 349 "grammar.y"
        -: 1880:      {
        -: 1881:        (yyval.string) = NULL;
        -: 1882:      }
        -: 1883:#line 1884 "grammar.c"
    #####: 1884:    break;
        -: 1885:
      281: 1886:  case 16:
        -: 1887:#line 353 "grammar.y"
        -: 1888:      {
        -: 1889:        // Each rule have a list of strings, consisting in a sequence
        -: 1890:        // of YR_STRING structures. The last YR_STRING structure does not
        -: 1891:        // represent a real string, it's just a end-of-list marker
        -: 1892:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -: 1893:        // write the end-of-list marker.
        -: 1894:
        -: 1895:        YR_STRING null_string;
        -: 1896:
        -: 1897:        memset(&null_string, 0xFF, sizeof(YR_STRING));
        -: 1898:        null_string.g_flags = STRING_GFLAGS_NULL;
        -: 1899:
        -: 1900:        fail_if_error(yr_arena_write_data(
        -: 1901:            compiler->strings_arena,
        -: 1902:            &null_string,
        -: 1903:            sizeof(YR_STRING),
        -: 1904:            NULL));
        -: 1905:
        -: 1906:        (yyval.string) = (yyvsp[0].string);
        -: 1907:      }
        -: 1908:#line 1909 "grammar.c"
      281: 1909:    break;
        -: 1910:
      364: 1911:  case 18:
        -: 1912:#line 382 "grammar.y"
        -: 1913:                                       { (yyval.integer) = 0;  }
        -: 1914:#line 1915 "grammar.c"
      364: 1915:    break;
        -: 1916:
    #####: 1917:  case 19:
        -: 1918:#line 383 "grammar.y"
        -: 1919:                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1920:#line 1921 "grammar.c"
    #####: 1921:    break;
        -: 1922:
    #####: 1923:  case 20:
        -: 1924:#line 388 "grammar.y"
        -: 1925:                     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
        -: 1926:#line 1927 "grammar.c"
    #####: 1927:    break;
        -: 1928:
    #####: 1929:  case 21:
        -: 1930:#line 389 "grammar.y"
        -: 1931:                     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
        -: 1932:#line 1933 "grammar.c"
    #####: 1933:    break;
        -: 1934:
      296: 1935:  case 22:
        -: 1936:#line 395 "grammar.y"
        -: 1937:      {
        -: 1938:        (yyval.c_string) = NULL;
        -: 1939:      }
        -: 1940:#line 1941 "grammar.c"
      296: 1941:    break;
        -: 1942:
    #####: 1943:  case 23:
        -: 1944:#line 399 "grammar.y"
        -: 1945:      {
        -: 1946:        // Tags list is represented in the arena as a sequence
        -: 1947:        // of null-terminated strings, the sequence ends with an
        -: 1948:        // additional null character. Here we write the ending null
        -: 1949:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 1950:
        -: 1951:        int result = yr_arena_write_string(
        -: 1952:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -: 1953:
        -: 1954:        fail_if_error(result);
        -: 1955:
        -: 1956:        (yyval.c_string) = (yyvsp[0].c_string);
        -: 1957:      }
        -: 1958:#line 1959 "grammar.c"
    #####: 1959:    break;
        -: 1960:
    #####: 1961:  case 24:
        -: 1962:#line 417 "grammar.y"
        -: 1963:      {
        -: 1964:        int result = yr_arena_write_string(
        -: 1965:            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));
        -: 1966:
        -: 1967:        yr_free((yyvsp[0].c_string));
        -: 1968:
        -: 1969:        fail_if_error(result);
        -: 1970:      }
        -: 1971:#line 1972 "grammar.c"
    #####: 1972:    break;
        -: 1973:
    #####: 1974:  case 25:
        -: 1975:#line 426 "grammar.y"
        -: 1976:      {
        -: 1977:        int result = ERROR_SUCCESS;
        -: 1978:
        -: 1979:        char* tag_name = (yyvsp[-1].c_string);
        -: 1980:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1981:
        -: 1982:        while (tag_length > 0)
        -: 1983:        {
        -: 1984:          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
        -: 1985:          {
        -: 1986:            yr_compiler_set_error_extra_info(compiler, tag_name);
        -: 1987:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
        -: 1988:            break;
        -: 1989:          }
        -: 1990:
        -: 1991:          tag_name = (char*) yr_arena_next_address(
        -: 1992:              yyget_extra(yyscanner)->sz_arena,
        -: 1993:              tag_name,
        -: 1994:              tag_length + 1);
        -: 1995:
        -: 1996:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1997:        }
        -: 1998:
        -: 1999:        if (result == ERROR_SUCCESS)
        -: 2000:          result = yr_arena_write_string(
        -: 2001:              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
        -: 2002:
        -: 2003:        yr_free((yyvsp[0].c_string));
        -: 2004:
        -: 2005:        fail_if_error(result);
        -: 2006:
        -: 2007:        (yyval.c_string) = (yyvsp[-1].c_string);
        -: 2008:      }
        -: 2009:#line 2010 "grammar.c"
    #####: 2010:    break;
        -: 2011:
    #####: 2012:  case 26:
        -: 2013:#line 464 "grammar.y"
        -: 2014:                                          {  (yyval.meta) = (yyvsp[0].meta); }
        -: 2015:#line 2016 "grammar.c"
    #####: 2016:    break;
        -: 2017:
    #####: 2018:  case 27:
        -: 2019:#line 465 "grammar.y"
        -: 2020:                                          {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 2021:#line 2022 "grammar.c"
    #####: 2022:    break;
        -: 2023:
    #####: 2024:  case 28:
        -: 2025:#line 471 "grammar.y"
        -: 2026:      {
        -: 2027:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2028:
        -: 2029:        int result = yr_parser_reduce_meta_declaration(
        -: 2030:            yyscanner,
        -: 2031:            META_TYPE_STRING,
        -: 2032:            (yyvsp[-2].c_string),
        -: 2033:            sized_string->c_string,
        -: 2034:            0,
        -: 2035:            &(yyval.meta));
        -: 2036:
        -: 2037:        yr_free((yyvsp[-2].c_string));
        -: 2038:        yr_free((yyvsp[0].sized_string));
        -: 2039:
        -: 2040:        fail_if_error(result);
        -: 2041:      }
        -: 2042:#line 2043 "grammar.c"
    #####: 2043:    break;
        -: 2044:
    #####: 2045:  case 29:
        -: 2046:#line 488 "grammar.y"
        -: 2047:      {
        -: 2048:        int result = yr_parser_reduce_meta_declaration(
        -: 2049:            yyscanner,
        -: 2050:            META_TYPE_INTEGER,
        -: 2051:            (yyvsp[-2].c_string),
        -: 2052:            NULL,
        -: 2053:            (yyvsp[0].integer),
        -: 2054:            &(yyval.meta));
        -: 2055:
        -: 2056:        yr_free((yyvsp[-2].c_string));
        -: 2057:
        -: 2058:        fail_if_error(result);
        -: 2059:      }
        -: 2060:#line 2061 "grammar.c"
    #####: 2061:    break;
        -: 2062:
    #####: 2063:  case 30:
        -: 2064:#line 502 "grammar.y"
        -: 2065:      {
        -: 2066:        int result = yr_parser_reduce_meta_declaration(
        -: 2067:            yyscanner,
        -: 2068:            META_TYPE_INTEGER,
        -: 2069:            (yyvsp[-3].c_string),
        -: 2070:            NULL,
        -: 2071:            -(yyvsp[0].integer),
        -: 2072:            &(yyval.meta));
        -: 2073:
        -: 2074:        yr_free((yyvsp[-3].c_string));
        -: 2075:
        -: 2076:        fail_if_error(result);
        -: 2077:      }
        -: 2078:#line 2079 "grammar.c"
    #####: 2079:    break;
        -: 2080:
    #####: 2081:  case 31:
        -: 2082:#line 516 "grammar.y"
        -: 2083:      {
        -: 2084:        int result = yr_parser_reduce_meta_declaration(
        -: 2085:            yyscanner,
        -: 2086:            META_TYPE_BOOLEAN,
        -: 2087:            (yyvsp[-2].c_string),
        -: 2088:            NULL,
        -: 2089:            true,
        -: 2090:            &(yyval.meta));
        -: 2091:
        -: 2092:        yr_free((yyvsp[-2].c_string));
        -: 2093:
        -: 2094:        fail_if_error(result);
        -: 2095:      }
        -: 2096:#line 2097 "grammar.c"
    #####: 2097:    break;
        -: 2098:
    #####: 2099:  case 32:
        -: 2100:#line 530 "grammar.y"
        -: 2101:      {
        -: 2102:        int result = yr_parser_reduce_meta_declaration(
        -: 2103:            yyscanner,
        -: 2104:            META_TYPE_BOOLEAN,
        -: 2105:            (yyvsp[-2].c_string),
        -: 2106:            NULL,
        -: 2107:            false,
        -: 2108:            &(yyval.meta));
        -: 2109:
        -: 2110:        yr_free((yyvsp[-2].c_string));
        -: 2111:
        -: 2112:        fail_if_error(result);
        -: 2113:      }
        -: 2114:#line 2115 "grammar.c"
    #####: 2115:    break;
        -: 2116:
      281: 2117:  case 33:
        -: 2118:#line 547 "grammar.y"
        -: 2119:                                              { (yyval.string) = (yyvsp[0].string); }
        -: 2120:#line 2121 "grammar.c"
      281: 2121:    break;
        -: 2122:
    #####: 2123:  case 34:
        -: 2124:#line 548 "grammar.y"
        -: 2125:                                              { (yyval.string) = (yyvsp[-1].string); }
        -: 2126:#line 2127 "grammar.c"
    #####: 2127:    break;
        -: 2128:
        3: 2129:  case 35:
        -: 2130:#line 554 "grammar.y"
        -: 2131:      {
        -: 2132:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2133:      }
        -: 2134:#line 2135 "grammar.c"
        3: 2135:    break;
        -: 2136:
        1: 2137:  case 36:
        -: 2138:#line 558 "grammar.y"
        -: 2139:      {
        -: 2140:        int result = yr_parser_reduce_string_declaration(
        -: 2141:            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2142:
        -: 2143:        yr_free((yyvsp[-4].c_string));
        -: 2144:        yr_free((yyvsp[-1].sized_string));
        -: 2145:
        -: 2146:        fail_if_error(result);
        -: 2147:        compiler->current_line = 0;
        -: 2148:      }
        -: 2149:#line 2150 "grammar.c"
        1: 2150:    break;
        -: 2151:
      293: 2152:  case 37:
        -: 2153:#line 569 "grammar.y"
        -: 2154:      {
        -: 2155:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2156:      }
        -: 2157:#line 2158 "grammar.c"
      293: 2158:    break;
        -: 2159:
      293: 2160:  case 38:
        -: 2161:#line 573 "grammar.y"
        -: 2162:      {
        -: 2163:        int result = yr_parser_reduce_string_declaration(
        -: 2164:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2165:
        -: 2166:        yr_free((yyvsp[-4].c_string));
        -: 2167:        yr_free((yyvsp[-1].sized_string));
        -: 2168:
        -: 2169:        fail_if_error(result);
        -: 2170:
        -: 2171:        compiler->current_line = 0;
        -: 2172:      }
        -: 2173:#line 2174 "grammar.c"
      280: 2174:    break;
        -: 2175:
    #####: 2176:  case 39:
        -: 2177:#line 585 "grammar.y"
        -: 2178:      {
        -: 2179:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2180:      }
        -: 2181:#line 2182 "grammar.c"
    #####: 2182:    break;
        -: 2183:
    #####: 2184:  case 40:
        -: 2185:#line 589 "grammar.y"
        -: 2186:      {
        -: 2187:        int result = yr_parser_reduce_string_declaration(
        -: 2188:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_HEXADECIMAL, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2189:
        -: 2190:        yr_free((yyvsp[-4].c_string));
        -: 2191:        yr_free((yyvsp[-1].sized_string));
        -: 2192:
        -: 2193:        fail_if_error(result);
        -: 2194:
        -: 2195:        compiler->current_line = 0;
        -: 2196:      }
        -: 2197:#line 2198 "grammar.c"
    #####: 2198:    break;
        -: 2199:
        1: 2200:  case 41:
        -: 2201:#line 604 "grammar.y"
        -: 2202:                                          { (yyval.integer) = 0; }
        -: 2203:#line 2204 "grammar.c"
        1: 2204:    break;
        -: 2205:
        2: 2206:  case 42:
        -: 2207:#line 605 "grammar.y"
        -: 2208:                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2209:#line 2210 "grammar.c"
        2: 2210:    break;
        -: 2211:
        1: 2212:  case 43:
        -: 2213:#line 610 "grammar.y"
        -: 2214:                    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2215:#line 2216 "grammar.c"
        1: 2216:    break;
        -: 2217:
    #####: 2218:  case 44:
        -: 2219:#line 611 "grammar.y"
        -: 2220:                    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2221:#line 2222 "grammar.c"
    #####: 2222:    break;
        -: 2223:
        1: 2224:  case 45:
        -: 2225:#line 612 "grammar.y"
        -: 2226:                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2227:#line 2228 "grammar.c"
        1: 2228:    break;
        -: 2229:
    #####: 2230:  case 46:
        -: 2231:#line 613 "grammar.y"
        -: 2232:                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2233:#line 2234 "grammar.c"
    #####: 2234:    break;
        -: 2235:
    #####: 2236:  case 47:
        -: 2237:#line 614 "grammar.y"
        -: 2238:                    { (yyval.integer) = STRING_GFLAGS_XOR; }
        -: 2239:#line 2240 "grammar.c"
    #####: 2240:    break;
        -: 2241:
    #####: 2242:  case 48:
        -: 2243:#line 615 "grammar.y"
        -: 2244:                    { (yyval.integer) = STRING_GFLAGS_PRIVATE; }
        -: 2245:#line 2246 "grammar.c"
    #####: 2246:    break;
        -: 2247:
      293: 2248:  case 49:
        -: 2249:#line 619 "grammar.y"
        -: 2250:                                          { (yyval.integer) = 0; }
        -: 2251:#line 2252 "grammar.c"
      293: 2252:    break;
        -: 2253:
       24: 2254:  case 50:
        -: 2255:#line 620 "grammar.y"
        -: 2256:                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2257:#line 2258 "grammar.c"
       24: 2258:    break;
        -: 2259:
       13: 2260:  case 51:
        -: 2261:#line 624 "grammar.y"
        -: 2262:                    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2263:#line 2264 "grammar.c"
       13: 2264:    break;
        -: 2265:
    #####: 2266:  case 52:
        -: 2267:#line 625 "grammar.y"
        -: 2268:                    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2269:#line 2270 "grammar.c"
    #####: 2270:    break;
        -: 2271:
        9: 2272:  case 53:
        -: 2273:#line 626 "grammar.y"
        -: 2274:                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2275:#line 2276 "grammar.c"
        9: 2276:    break;
        -: 2277:
        2: 2278:  case 54:
        -: 2279:#line 627 "grammar.y"
        -: 2280:                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2281:#line 2282 "grammar.c"
        2: 2282:    break;
        -: 2283:
    #####: 2284:  case 55:
        -: 2285:#line 628 "grammar.y"
        -: 2286:                    { (yyval.integer) = STRING_GFLAGS_PRIVATE; }
        -: 2287:#line 2288 "grammar.c"
    #####: 2288:    break;
        -: 2289:
    #####: 2290:  case 56:
        -: 2291:#line 632 "grammar.y"
        -: 2292:                                          { (yyval.integer) = 0; }
        -: 2293:#line 2294 "grammar.c"
    #####: 2294:    break;
        -: 2295:
    #####: 2296:  case 57:
        -: 2297:#line 633 "grammar.y"
        -: 2298:                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2299:#line 2300 "grammar.c"
    #####: 2300:    break;
        -: 2301:
    #####: 2302:  case 58:
        -: 2303:#line 637 "grammar.y"
        -: 2304:                    { (yyval.integer) = STRING_GFLAGS_PRIVATE; }
        -: 2305:#line 2306 "grammar.c"
    #####: 2306:    break;
        -: 2307:
    #####: 2308:  case 59:
        -: 2309:#line 642 "grammar.y"
        -: 2310:      {
        -: 2311:        int result = ERROR_SUCCESS;
        -: 2312:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
        -: 2313:
        -: 2314:        if (var_index >= 0)
        -: 2315:        {
        -: 2316:          result = yr_parser_emit_with_arg(
        -: 2317:              yyscanner,
        -: 2318:              OP_PUSH_M,
        -: 2319:              LOOP_LOCAL_VARS * var_index,
        -: 2320:              NULL,
        -: 2321:              NULL);
        -: 2322:
        -: 2323:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 2324:          (yyval.expression).value.integer = UNDEFINED;
        -: 2325:          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        -: 2326:        }
        -: 2327:        else
        -: 2328:        {
        -: 2329:          // Search for identifier within the global namespace, where the
        -: 2330:          // externals variables reside.
        -: 2331:
        -: 2332:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2333:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2334:
        -: 2335:          if (object == NULL)
        -: 2336:          {
        -: 2337:            // If not found, search within the current namespace.
        -: 2338:            char* ns = compiler->current_namespace->name;
        -: 2339:
        -: 2340:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2341:                compiler->objects_table, (yyvsp[0].c_string), ns);
        -: 2342:          }
        -: 2343:
        -: 2344:          if (object != NULL)
        -: 2345:          {
        -: 2346:            char* id;
        -: 2347:
        -: 2348:            result = yr_arena_write_string(
        -: 2349:                compiler->sz_arena, (yyvsp[0].c_string), &id);
        -: 2350:
        -: 2351:            if (result == ERROR_SUCCESS)
        -: 2352:              result = yr_parser_emit_with_arg_reloc(
        -: 2353:                  yyscanner,
        -: 2354:                  OP_OBJ_LOAD,
        -: 2355:                  id,
        -: 2356:                  NULL,
        -: 2357:                  NULL);
        -: 2358:
        -: 2359:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2360:            (yyval.expression).value.object = object;
        -: 2361:            (yyval.expression).identifier = object->identifier;
        -: 2362:          }
        -: 2363:          else
        -: 2364:          {
        -: 2365:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -: 2366:                compiler->rules_table,
        -: 2367:                (yyvsp[0].c_string),
        -: 2368:                compiler->current_namespace->name);
        -: 2369:
        -: 2370:            if (rule != NULL)
        -: 2371:            {
        -: 2372:              result = yr_parser_emit_with_arg_reloc(
        -: 2373:                  yyscanner,
        -: 2374:                  OP_PUSH_RULE,
        -: 2375:                  rule,
        -: 2376:                  NULL,
        -: 2377:                  NULL);
        -: 2378:
        -: 2379:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2380:              (yyval.expression).value.integer = UNDEFINED;
        -: 2381:              (yyval.expression).identifier = rule->identifier;
        -: 2382:            }
        -: 2383:            else
        -: 2384:            {
        -: 2385:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2386:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2387:            }
        -: 2388:          }
        -: 2389:        }
        -: 2390:
        -: 2391:        yr_free((yyvsp[0].c_string));
        -: 2392:
        -: 2393:        fail_if_error(result);
        -: 2394:      }
        -: 2395:#line 2396 "grammar.c"
    #####: 2396:    break;
        -: 2397:
    #####: 2398:  case 60:
        -: 2399:#line 728 "grammar.y"
        -: 2400:      {
        -: 2401:        int result = ERROR_SUCCESS;
        -: 2402:        YR_OBJECT* field = NULL;
        -: 2403:
        -: 2404:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2405:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2406:        {
        -: 2407:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2408:
        -: 2409:          if (field != NULL)
        -: 2410:          {
        -: 2411:            char* ident;
        -: 2412:
        -: 2413:            result = yr_arena_write_string(
        -: 2414:                compiler->sz_arena, (yyvsp[0].c_string), &ident);
        -: 2415:
        -: 2416:            if (result == ERROR_SUCCESS)
        -: 2417:              result = yr_parser_emit_with_arg_reloc(
        -: 2418:                  yyscanner,
        -: 2419:                  OP_OBJ_FIELD,
        -: 2420:                  ident,
        -: 2421:                  NULL,
        -: 2422:                  NULL);
        -: 2423:
        -: 2424:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2425:            (yyval.expression).value.object = field;
        -: 2426:            (yyval.expression).identifier = field->identifier;
        -: 2427:          }
        -: 2428:          else
        -: 2429:          {
        -: 2430:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2431:            result = ERROR_INVALID_FIELD_NAME;
        -: 2432:          }
        -: 2433:        }
        -: 2434:        else
        -: 2435:        {
        -: 2436:          yr_compiler_set_error_extra_info(
        -: 2437:              compiler, (yyvsp[-2].expression).identifier);
        -: 2438:
        -: 2439:          result = ERROR_NOT_A_STRUCTURE;
        -: 2440:        }
        -: 2441:
        -: 2442:        yr_free((yyvsp[0].c_string));
        -: 2443:
        -: 2444:        fail_if_error(result);
        -: 2445:      }
        -: 2446:#line 2447 "grammar.c"
    #####: 2447:    break;
        -: 2448:
    #####: 2449:  case 61:
        -: 2450:#line 775 "grammar.y"
        -: 2451:      {
        -: 2452:        int result = ERROR_SUCCESS;
        -: 2453:        YR_OBJECT_ARRAY* array;
        -: 2454:        YR_OBJECT_DICTIONARY* dict;
        -: 2455:
        -: 2456:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2457:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2458:        {
        -: 2459:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2460:          {
        -: 2461:            yr_compiler_set_error_extra_info(
        -: 2462:                compiler, "array indexes must be of integer type");
        -: 2463:            result = ERROR_WRONG_TYPE;
        -: 2464:          }
        -: 2465:
        -: 2466:          fail_if_error(result);
        -: 2467:
        -: 2468:          result = yr_parser_emit(
        -: 2469:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2470:
        -: 2471:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2472:
        -: 2473:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2474:          (yyval.expression).value.object = array->prototype_item;
        -: 2475:          (yyval.expression).identifier = array->identifier;
        -: 2476:        }
        -: 2477:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2478:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2479:        {
        -: 2480:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2481:          {
        -: 2482:            yr_compiler_set_error_extra_info(
        -: 2483:                compiler, "dictionary keys must be of string type");
        -: 2484:            result = ERROR_WRONG_TYPE;
        -: 2485:          }
        -: 2486:
        -: 2487:          fail_if_error(result);
        -: 2488:
        -: 2489:          result = yr_parser_emit(
        -: 2490:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2491:
        -: 2492:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2493:
        -: 2494:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2495:          (yyval.expression).value.object = dict->prototype_item;
        -: 2496:          (yyval.expression).identifier = dict->identifier;
        -: 2497:        }
        -: 2498:        else
        -: 2499:        {
        -: 2500:          yr_compiler_set_error_extra_info(
        -: 2501:              compiler, (yyvsp[-3].expression).identifier);
        -: 2502:
        -: 2503:          result = ERROR_NOT_INDEXABLE;
        -: 2504:        }
        -: 2505:
        -: 2506:        fail_if_error(result);
        -: 2507:      }
        -: 2508:#line 2509 "grammar.c"
    #####: 2509:    break;
        -: 2510:
    #####: 2511:  case 62:
        -: 2512:#line 834 "grammar.y"
        -: 2513:      {
        -: 2514:        int result = ERROR_SUCCESS;
        -: 2515:        YR_OBJECT_FUNCTION* function;
        -: 2516:        char* args_fmt;
        -: 2517:
        -: 2518:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2519:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2520:        {
        -: 2521:          result = yr_parser_check_types(
        -: 2522:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2523:
        -: 2524:          if (result == ERROR_SUCCESS)
        -: 2525:            result = yr_arena_write_string(
        -: 2526:                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
        -: 2527:
        -: 2528:          if (result == ERROR_SUCCESS)
        -: 2529:            result = yr_parser_emit_with_arg_reloc(
        -: 2530:                yyscanner,
        -: 2531:                OP_CALL,
        -: 2532:                args_fmt,
        -: 2533:                NULL,
        -: 2534:                NULL);
        -: 2535:
        -: 2536:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2537:
        -: 2538:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2539:          (yyval.expression).value.object = function->return_obj;
        -: 2540:          (yyval.expression).identifier = function->identifier;
        -: 2541:        }
        -: 2542:        else
        -: 2543:        {
        -: 2544:          yr_compiler_set_error_extra_info(
        -: 2545:              compiler, (yyvsp[-3].expression).identifier);
        -: 2546:
        -: 2547:          result = ERROR_NOT_A_FUNCTION;
        -: 2548:        }
        -: 2549:
        -: 2550:        yr_free((yyvsp[-1].c_string));
        -: 2551:
        -: 2552:        fail_if_error(result);
        -: 2553:      }
        -: 2554:#line 2555 "grammar.c"
    #####: 2555:    break;
        -: 2556:
    #####: 2557:  case 63:
        -: 2558:#line 879 "grammar.y"
        -: 2559:                      { (yyval.c_string) = yr_strdup(""); }
        -: 2560:#line 2561 "grammar.c"
    #####: 2561:    break;
        -: 2562:
    #####: 2563:  case 64:
        -: 2564:#line 880 "grammar.y"
        -: 2565:                      { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2566:#line 2567 "grammar.c"
    #####: 2567:    break;
        -: 2568:
    #####: 2569:  case 65:
        -: 2570:#line 885 "grammar.y"
        -: 2571:      {
        -: 2572:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2573:
        -: 2574:        if ((yyval.c_string) == NULL)
        -: 2575:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2576:
        -: 2577:        switch((yyvsp[0].expression).type)
        -: 2578:        {
        -: 2579:          case EXPRESSION_TYPE_INTEGER:
        -: 2580:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2581:            break;
        -: 2582:          case EXPRESSION_TYPE_FLOAT:
        -: 2583:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2584:            break;
        -: 2585:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2586:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2587:            break;
        -: 2588:          case EXPRESSION_TYPE_STRING:
        -: 2589:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2590:            break;
        -: 2591:          case EXPRESSION_TYPE_REGEXP:
        -: 2592:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2593:            break;
        -: 2594:          default:
        -: 2595:            assert(false);
        -: 2596:        }
        -: 2597:      }
        -: 2598:#line 2599 "grammar.c"
    #####: 2599:    break;
        -: 2600:
    #####: 2601:  case 66:
        -: 2602:#line 913 "grammar.y"
        -: 2603:      {
        -: 2604:        int result = ERROR_SUCCESS;
        -: 2605:
        -: 2606:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2607:        {
        -: 2608:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2609:        }
        -: 2610:        else
        -: 2611:        {
        -: 2612:          switch((yyvsp[0].expression).type)
        -: 2613:          {
        -: 2614:            case EXPRESSION_TYPE_INTEGER:
        -: 2615:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2616:              break;
        -: 2617:            case EXPRESSION_TYPE_FLOAT:
        -: 2618:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2619:              break;
        -: 2620:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2621:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2622:              break;
        -: 2623:            case EXPRESSION_TYPE_STRING:
        -: 2624:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2625:              break;
        -: 2626:            case EXPRESSION_TYPE_REGEXP:
        -: 2627:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2628:              break;
        -: 2629:            default:
        -: 2630:              assert(false);
        -: 2631:          }
        -: 2632:        }
        -: 2633:
        -: 2634:        fail_if_error(result);
        -: 2635:
        -: 2636:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2637:      }
        -: 2638:#line 2639 "grammar.c"
    #####: 2639:    break;
        -: 2640:
    #####: 2641:  case 67:
        -: 2642:#line 953 "grammar.y"
        -: 2643:      {
        -: 2644:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2645:        RE* re;
        -: 2646:        RE_ERROR error;
        -: 2647:
        -: 2648:        int result = ERROR_SUCCESS;
        -: 2649:        int re_flags = 0;
        -: 2650:
        -: 2651:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2652:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2653:
        -: 2654:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2655:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2656:
        -: 2657:        result = yr_re_compile(
        -: 2658:            sized_string->c_string,
        -: 2659:            re_flags,
        -: 2660:            compiler->re_code_arena,
        -: 2661:            &re,
        -: 2662:            &error);
        -: 2663:
        -: 2664:        yr_free((yyvsp[0].sized_string));
        -: 2665:
        -: 2666:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2667:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2668:
        -: 2669:        if (result == ERROR_SUCCESS)
        -: 2670:          result = yr_parser_emit_with_arg_reloc(
        -: 2671:              yyscanner,
        -: 2672:              OP_PUSH,
        -: 2673:              re,
        -: 2674:              NULL,
        -: 2675:              NULL);
        -: 2676:
        -: 2677:        fail_if_error(result);
        -: 2678:
        -: 2679:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2680:      }
        -: 2681:#line 2682 "grammar.c"
    #####: 2682:    break;
        -: 2683:
      280: 2684:  case 68:
        -: 2685:#line 996 "grammar.y"
        -: 2686:      {
        -: 2687:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2688:        {
        -: 2689:          if ((yyvsp[0].expression).value.sized_string != NULL)
        -: 2690:          {
        -: 2691:            yywarning(yyscanner,
        -: 2692:              "Using literal string \"%s\" in a boolean operation.",
        -: 2693:              (yyvsp[0].expression).value.sized_string->c_string);
        -: 2694:          }
        -: 2695:
        -: 2696:          fail_if_error(yr_parser_emit(
        -: 2697:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2698:        }
        -: 2699:
        -: 2700:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2701:      }
        -: 2702:#line 2703 "grammar.c"
      280: 2703:    break;
        -: 2704:
    #####: 2705:  case 69:
        -: 2706:#line 1016 "grammar.y"
        -: 2707:      {
        -: 2708:        fail_if_error(yr_parser_emit_with_arg(
        -: 2709:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 2710:
        -: 2711:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2712:      }
        -: 2713:#line 2714 "grammar.c"
    #####: 2714:    break;
        -: 2715:
    #####: 2716:  case 70:
        -: 2717:#line 1023 "grammar.y"
        -: 2718:      {
        -: 2719:        fail_if_error(yr_parser_emit_with_arg(
        -: 2720:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 2721:
        -: 2722:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2723:      }
        -: 2724:#line 2725 "grammar.c"
    #####: 2725:    break;
        -: 2726:
    #####: 2727:  case 71:
        -: 2728:#line 1030 "grammar.y"
        -: 2729:      {
        -: 2730:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 2731:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 2732:
        -: 2733:        fail_if_error(yr_parser_emit(
        -: 2734:            yyscanner,
        -: 2735:            OP_MATCHES,
        -: 2736:            NULL));
        -: 2737:
        -: 2738:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2739:      }
        -: 2740:#line 2741 "grammar.c"
    #####: 2741:    break;
        -: 2742:
    #####: 2743:  case 72:
        -: 2744:#line 1042 "grammar.y"
        -: 2745:      {
        -: 2746:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2747:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2748:
        -: 2749:        fail_if_error(yr_parser_emit(
        -: 2750:            yyscanner, OP_CONTAINS, NULL));
        -: 2751:
        -: 2752:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2753:      }
        -: 2754:#line 2755 "grammar.c"
    #####: 2755:    break;
        -: 2756:
      276: 2757:  case 73:
        -: 2758:#line 1052 "grammar.y"
        -: 2759:      {
        -: 2760:        int result = yr_parser_reduce_string_identifier(
        -: 2761:            yyscanner,
        -: 2762:            (yyvsp[0].c_string),
        -: 2763:            OP_FOUND,
        -: 2764:            UNDEFINED);
        -: 2765:
        -: 2766:        yr_free((yyvsp[0].c_string));
        -: 2767:
        -: 2768:        fail_if_error(result);
        -: 2769:
        -: 2770:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2771:      }
        -: 2772:#line 2773 "grammar.c"
      276: 2773:    break;
        -: 2774:
    #####: 2775:  case 74:
        -: 2776:#line 1066 "grammar.y"
        -: 2777:      {
        -: 2778:        int result;
        -: 2779:
        -: 2780:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 2781:
        -: 2782:        result = yr_parser_reduce_string_identifier(
        -: 2783:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 2784:
        -: 2785:        yr_free((yyvsp[-2].c_string));
        -: 2786:
        -: 2787:        fail_if_error(result);
        -: 2788:
        -: 2789:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2790:      }
        -: 2791:#line 2792 "grammar.c"
    #####: 2792:    break;
        -: 2793:
    #####: 2794:  case 75:
        -: 2795:#line 1081 "grammar.y"
        -: 2796:      {
        -: 2797:        int result = yr_parser_reduce_string_identifier(
        -: 2798:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
        -: 2799:
        -: 2800:        yr_free((yyvsp[-2].c_string));
        -: 2801:
        -: 2802:        fail_if_error(result);
        -: 2803:
        -: 2804:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2805:      }
        -: 2806:#line 2807 "grammar.c"
    #####: 2807:    break;
        -: 2808:
    #####: 2809:  case 76:
        -: 2810:#line 1092 "grammar.y"
        -: 2811:      {
        -: 2812:        if (compiler->loop_depth > 0)
        -: 2813:        {
        -: 2814:          compiler->loop_depth--;
        -: 2815:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2816:        }
        -: 2817:
        -: 2818:        YYERROR;
        -: 2819:      }
        -: 2820:#line 2821 "grammar.c"
        -: 2821:    break;
        -: 2822:
    #####: 2823:  case 77:
        -: 2824:#line 1102 "grammar.y"
        -: 2825:      {
        -: 2826:        // for all i in (N..M) : (<expr>)
        -: 2827:        //
        -: 2828:        // 1       PUSH UNDEF  ; "all"
        -: 2829:        // 2       PUSH UNDEF  ; "end of list"
        -: 2830:        // 3       PUSH N      ; integer range lower bound
        -: 2831:        // 4       PUSH M      ; integer range upper bound
        -: 2832:        // 5       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2833:        // 6       CLEAR_M 2   ; clear loop iteration counter
        -: 2834:        // 7       POP_M 3     ; store range upper bound
        -: 2835:        // 8       POP_M 0     ; store range lower bound
        -: 2836:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 2837:        //      |  <expr>      ; here goes the code for <expr>, its result will
        -: 2838:        //      |                be at the top of the stack
        -: 2839:        // 10   |  SET_M 4     ; store boolean expression result in memory 4
        -: 2840:        // 11   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2841:        // 12   |  INCR_M 0    ; increment range lower bound (more like current bound)
        -: 2842:        // 13   |  PUSH_M 4    ; boolean expression result
        -: 2843:        // 14 .-+--JFALSE_P    ; jump out of loop if last result is false
        -: 2844:        // 15 | |  PUSH_M 0    ; lower (current) bound
        -: 2845:        // 16 | |  PUSH_M 3    ; upper bound
        -: 2846:        // 17 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 2847:        // 18 `--->POP         ; pop end of list
        -: 2848:        // 19      SWAPUNDEF 2 ; swap the UNDEF ("all") with loop iteration
        -: 2849:        //                       counter (memory 2)
        -: 2850:        // 20      PUSH_M 1    ; push the boolean_expression accumulator
        -: 2851:        // 21      INT_LE      ; compare boolean_expression accumulator to loop
        -: 2852:        //                       iteration counter
        -: 2853:
        -: 2854:        // for X i in (N..M) : (<expr>)
        -: 2855:        //
        -: 2856:        // 1       PUSH X      ;
        -: 2857:        // 2       SET_M 4     ; store primary_expression in m4
        -: 2858:        // 3       PUSH UNDEF  ; "end of list"
        -: 2859:        // 4       PUSH 0      ; integer range lower bound
        -: 2860:        // 5       PUSH 5      ; integer range upper bound
        -: 2861:        // 6       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2862:        // 7       CLEAR_M 2   ; clear loop iteration counter
        -: 2863:        // 8       POP_M 3     ; store upper bound
        -: 2864:        // 9       POP_M 0     ; store lower bound
        -: 2865:        // 10   .->INCR_M 2    ; increment loop iteration counter
        -: 2866:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 2867:        //      |              ; be at the  top of the stack
        -: 2868:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2869:        // 13   |  INCR_M 0    ; increment lower bound (more like current bound)
        -: 2870:        // 14   |  PUSH_M 4    ; primary expression minimum
        -: 2871:        // 15   |  PUSH_M 1    ; boolean_expression accumulator
        -: 2872:        // 16 .-+--JLE_P       ; jump out of loop if (minimum <= accumulator)
        -: 2873:        // 17 | |  PUSH_M 0    ; lower (current) bound
        -: 2874:        // 18 | |  PUSH_M 3    ; upper bound
        -: 2875:        // 19 | `--JLE_P       ; jump to start of loop if we haven't iterated enough
        -: 2876:        // 20 `--->POP         ; pop end of list
        -: 2877:        // 21      SWAPUNDEF 2 ; at this point only our "any" is on the stack,
        -: 2878:        //                       this is effectively a NOP
        -: 2879:        // 22      PUSH_M 1    ; push the boolean_expression accumulator
        -: 2880:        // 23      INT_LE      ; compare boolean_expression accumulator to X
        -: 2881:
        -: 2882:        // for X i in (A, B, C) : (<expr>)
        -: 2883:        //
        -: 2884:        // 1       PUSH X      ;
        -: 2885:        // 2       SET_M 4     ; store primary_expression in m4
        -: 2886:        // 3       PUSH UNDEF  ; "end of list"
        -: 2887:        // 4       PUSH A
        -: 2888:        // 5       PUSH B
        -: 2889:        // 6       PUSH C
        -: 2890:        // 7       CLEAR_M 1   ; clear <expr> result accumulator
        -: 2891:        // 8       CLEAR_M 2   ; clear loop iteration counter
        -: 2892:        // 9    .->INCR_M 2    ; increment loop iteration counter
        -: 2893:        // 10   |  POP_M 0     ; store current item in M[0]
        -: 2894:        // 11   |  <expr>      ; here goes the code for <expr>, its result will
        -: 2895:        //      |              ; be at the  top of the stack
        -: 2896:        // 12   |  ADD_M 1     ; add boolean_expression result to accumulator
        -: 2897:        // 13   `--JNUNDEF     ; if "end of list" was not reached, repeat.
        -: 2898:        // 14      POP         ; pop end of list
        -: 2899:        // 15      SWAPUNDEF 2 ; swap the UNDEF with loop iteration counter M[2]
        -: 2900:        // 16      PUSH_M 1    ; push boolean_expression result accumulator
        -: 2901:        // 17      INT_LE      ; compare boolean_expression accumulator to X
        -: 2902:
        -: 2903:
        -: 2904:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2905:        int result = ERROR_SUCCESS;
        -: 2906:        int var_index;
        -: 2907:
        -: 2908:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2909:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2910:
        -: 2911:        fail_if_error(result);
        -: 2912:
        -: 2913:        var_index = yr_parser_lookup_loop_variable(
        -: 2914:            yyscanner, (yyvsp[-1].c_string));
        -: 2915:
        -: 2916:        if (var_index >= 0)
        -: 2917:        {
        -: 2918:          yr_compiler_set_error_extra_info(
        -: 2919:              compiler, (yyvsp[-1].c_string));
        -: 2920:
        -: 2921:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 2922:        }
        -: 2923:
        -: 2924:        fail_if_error(result);
        -: 2925:
        -: 2926:        // "any" loops require us to store the primary expression for
        -: 2927:        // later evaluation, but "all" loops do not. The OP_SWAPUNDEF after the
        -: 2928:        // loop ensures we evaluate the proper values.
        -: 2929:        if ((yyvsp[-2].integer) == FOR_EXPRESSION_ANY)
        -: 2930:        {
        -: 2931:          yr_parser_emit_with_arg(
        -: 2932:            yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 2933:        }
        -: 2934:
        -: 2935:        // Push end-of-list marker
        -: 2936:        result = yr_parser_emit_with_arg(
        -: 2937:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 2938:
        -: 2939:        fail_if_error(result);
        -: 2940:      }
        -: 2941:#line 2942 "grammar.c"
    #####: 2942:    break;
        -: 2943:
    #####: 2944:  case 78:
        -: 2945:#line 1219 "grammar.y"
        -: 2946:      {
        -: 2947:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2948:        uint8_t* addr;
        -: 2949:
        -: 2950:        // Clear counter for number of expressions evaluating
        -: 2951:        // to true.
        -: 2952:        yr_parser_emit_with_arg(
        -: 2953:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2954:
        -: 2955:        // Clear iterations counter
        -: 2956:        yr_parser_emit_with_arg(
        -: 2957:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2958:
        -: 2959:        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        -: 2960:        {
        -: 2961:          // Increment iterations counter
        -: 2962:          yr_parser_emit_with_arg(
        -: 2963:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 2964:
        -: 2965:          // Pop the first integer
        -: 2966:          yr_parser_emit_with_arg(
        -: 2967:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2968:        }
        -: 2969:        else // INTEGER_SET_RANGE
        -: 2970:        {
        -: 2971:          // Pop higher bound of set range
        -: 2972:          yr_parser_emit_with_arg(
        -: 2973:              yyscanner, OP_POP_M, mem_offset + 3, NULL, NULL);
        -: 2974:
        -: 2975:          // Pop lower bound of set range
        -: 2976:          yr_parser_emit_with_arg(
        -: 2977:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2978:
        -: 2979:          // Increment iterations counter
        -: 2980:          yr_parser_emit_with_arg(
        -: 2981:              yyscanner, OP_INCR_M, mem_offset + 2, &addr, NULL);
        -: 2982:        }
        -: 2983:
        -: 2984:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2985:        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        -: 2986:        compiler->loop_depth++;
        -: 2987:      }
        -: 2988:#line 2989 "grammar.c"
    #####: 2989:    break;
        -: 2990:
    #####: 2991:  case 79:
        -: 2992:#line 1262 "grammar.y"
        -: 2993:      {
        -: 2994:        int mem_offset;
        -: 2995:        YR_FIXUP* fixup;
        -: 2996:        void* jmp_destination_addr;
        -: 2997:        uint8_t* pop_addr;
        -: 2998:
        -: 2999:        compiler->loop_depth--;
        -: 3000:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 3001:
        -: 3002:        // The value at the top of the stack is the result of
        -: 3003:        // evaluating the boolean expression, so it could be
        -: 3004:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 3005:        // keeping the number of expressions evaluating to true.
        -: 3006:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 3007:        // does nothing.
        -: 3008:
        -: 3009:        if ((yyvsp[-9].integer) == FOR_EXPRESSION_ALL)
        -: 3010:        {
        -: 3011:          // Store the last result for checking after we have incremented the
        -: 3012:          // counters. We want to keep the value on the stack though.
        -: 3013:          yr_parser_emit_with_arg(
        -: 3014:              yyscanner, OP_SET_M, mem_offset + 4, NULL, NULL);
        -: 3015:        }
        -: 3016:
        -: 3017:        yr_parser_emit_with_arg(
        -: 3018:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 3019:
        -: 3020:        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        -: 3021:        {
        -: 3022:          yr_parser_emit_with_arg_reloc(
        -: 3023:              yyscanner,
        -: 3024:              OP_JNUNDEF,
        -: 3025:              compiler->loop_address[compiler->loop_depth],
        -: 3026:              NULL,
        -: 3027:              NULL);
        -: 3028:
        -: 3029:          // Pop end-of-list marker.
        -: 3030:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 3031:        }
        -: 3032:        else // INTEGER_SET_RANGE
        -: 3033:        {
        -: 3034:          // Increment lower bound of integer set
        -: 3035:          yr_parser_emit_with_arg(
        -: 3036:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 3037:
        -: 3038:          // Push loop quantifier
        -: 3039:          yr_parser_emit_with_arg(
        -: 3040:              yyscanner, OP_PUSH_M, mem_offset + 4, NULL, NULL);
        -: 3041:
        -: 3042:          if ((yyvsp[-9].integer) == FOR_EXPRESSION_ALL)
        -: 3043:          {
        -: 3044:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3045:                yyscanner,
        -: 3046:                OP_JFALSE_P,
        -: 3047:                0, // Don't know the jump destination yet
        -: 3048:                NULL,
        -: 3049:                &jmp_destination_addr));
        -: 3050:
        -: 3051:            // create a fixup entry for the jump and push it in the stack
        -: 3052:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3053:
        -: 3054:            if (fixup == NULL)
        -: 3055:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3056:
        -: 3057:            fixup->address = jmp_destination_addr;
        -: 3058:            fixup->next = compiler->fixup_stack_head;
        -: 3059:            compiler->fixup_stack_head = fixup;
        -: 3060:          }
        -: 3061:          else if ((yyvsp[-9].integer) == FOR_EXPRESSION_ANY)
        -: 3062:          {
        -: 3063:            // Push the number of expressions evaluating to true
        -: 3064:            yr_parser_emit_with_arg(
        -: 3065:                yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 3066:
        -: 3067:            // Compare the loop quantifier to number of expressions that evaluate
        -: 3068:            // to true, in order to eliminate extraneous loop iterations.
        -: 3069:            fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3070:                yyscanner,
        -: 3071:                OP_JLE_P,
        -: 3072:                0, // Don't know the jump destination yet
        -: 3073:                NULL,
        -: 3074:                &jmp_destination_addr));
        -: 3075:
        -: 3076:            fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3077:
        -: 3078:            if (fixup == NULL)
        -: 3079:              fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3080:
        -: 3081:            fixup->address = jmp_destination_addr;
        -: 3082:            fixup->next = compiler->fixup_stack_head;
        -: 3083:            compiler->fixup_stack_head = fixup;
        -: 3084:          }
        -: 3085:
        -: 3086:          // Push lower bound of integer set
        -: 3087:          yr_parser_emit_with_arg(
        -: 3088:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 3089:
        -: 3090:          // Push higher bound of integer set
        -: 3091:          yr_parser_emit_with_arg(
        -: 3092:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 3093:
        -: 3094:          // Compare higher bound with lower bound, do loop again
        -: 3095:          // if lower bound is still lower or equal than higher bound
        -: 3096:          yr_parser_emit_with_arg_reloc(
        -: 3097:              yyscanner,
        -: 3098:              OP_JLE_P,
        -: 3099:              compiler->loop_address[compiler->loop_depth],
        -: 3100:              NULL,
        -: 3101:              NULL);
        -: 3102:
        -: 3103:          // Pop end-of-list marker.
        -: 3104:          yr_parser_emit(yyscanner, OP_POP, &pop_addr);
        -: 3105:
        -: 3106:          fixup = compiler->fixup_stack_head;
        -: 3107:          *(void**)(fixup->address) = (void*)(pop_addr);
        -: 3108:          compiler->fixup_stack_head = fixup->next;
        -: 3109:          yr_free(fixup);
        -: 3110:        }
        -: 3111:
        -: 3112:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 3113:        // is at the top of the stack. Check if the quantifier
        -: 3114:        // is undefined (meaning "all") and replace it with the
        -: 3115:        // iterations counter in that case.
        -: 3116:        yr_parser_emit_with_arg(
        -: 3117:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 3118:
        -: 3119:        // Compare the loop quantifier with the number of
        -: 3120:        // expressions evaluating to true.
        -: 3121:        yr_parser_emit_with_arg(
        -: 3122:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 3123:
        -: 3124:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 3125:
        -: 3126:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 3127:        yr_free((yyvsp[-8].c_string));
        -: 3128:
        -: 3129:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3130:      }
        -: 3131:#line 3132 "grammar.c"
    #####: 3132:    break;
        -: 3133:
    #####: 3134:  case 80:
        -: 3135:#line 1401 "grammar.y"
        -: 3136:      {
        -: 3137:        int result = ERROR_SUCCESS;
        -: 3138:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 3139:        uint8_t* addr;
        -: 3140:
        -: 3141:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 3142:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 3143:
        -: 3144:        if (compiler->loop_for_of_mem_offset != -1)
        -: 3145:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 3146:
        -: 3147:        fail_if_error(result);
        -: 3148:
        -: 3149:        yr_parser_emit_with_arg(
        -: 3150:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 3151:
        -: 3152:        yr_parser_emit_with_arg(
        -: 3153:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 3154:
        -: 3155:        // Pop the first string.
        -: 3156:        yr_parser_emit_with_arg(
        -: 3157:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 3158:
        -: 3159:        compiler->loop_for_of_mem_offset = mem_offset;
        -: 3160:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 3161:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 3162:        compiler->loop_depth++;
        -: 3163:      }
        -: 3164:#line 3165 "grammar.c"
    #####: 3165:    break;
        -: 3166:
    #####: 3167:  case 81:
        -: 3168:#line 1430 "grammar.y"
        -: 3169:      {
        -: 3170:        int mem_offset;
        -: 3171:
        -: 3172:        compiler->loop_depth--;
        -: 3173:        compiler->loop_for_of_mem_offset = -1;
        -: 3174:
        -: 3175:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 3176:
        -: 3177:        // Increment counter by the value returned by the
        -: 3178:        // boolean expression (0 or 1). If the boolean expression
        -: 3179:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 3180:
        -: 3181:        yr_parser_emit_with_arg(
        -: 3182:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 3183:
        -: 3184:        // Increment iterations counter.
        -: 3185:        yr_parser_emit_with_arg(
        -: 3186:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 3187:
        -: 3188:        // If next string is not undefined, go back to the
        -: 3189:        // beginning of the loop.
        -: 3190:        yr_parser_emit_with_arg_reloc(
        -: 3191:            yyscanner,
        -: 3192:            OP_JNUNDEF,
        -: 3193:            compiler->loop_address[compiler->loop_depth],
        -: 3194:            NULL,
        -: 3195:            NULL);
        -: 3196:
        -: 3197:        // Pop end-of-list marker.
        -: 3198:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 3199:
        -: 3200:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 3201:        // is at top of the stack. Check if the quantifier is
        -: 3202:        // undefined (meaning "all") and replace it with the
        -: 3203:        // iterations counter in that case.
        -: 3204:        yr_parser_emit_with_arg(
        -: 3205:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 3206:
        -: 3207:        // Compare the loop quantifier with the number of
        -: 3208:        // expressions evaluating to true.
        -: 3209:        yr_parser_emit_with_arg(
        -: 3210:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 3211:
        -: 3212:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 3213:
        -: 3214:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3215:
        -: 3216:      }
        -: 3217:#line 3218 "grammar.c"
    #####: 3218:    break;
        -: 3219:
    #####: 3220:  case 82:
        -: 3221:#line 1479 "grammar.y"
        -: 3222:      {
        -: 3223:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 3224:
        -: 3225:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3226:      }
        -: 3227:#line 3228 "grammar.c"
    #####: 3228:    break;
        -: 3229:
    #####: 3230:  case 83:
        -: 3231:#line 1485 "grammar.y"
        -: 3232:      {
        -: 3233:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 3234:
        -: 3235:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3236:      }
        -: 3237:#line 3238 "grammar.c"
    #####: 3238:    break;
        -: 3239:
    #####: 3240:  case 84:
        -: 3241:#line 1491 "grammar.y"
        -: 3242:      {
        -: 3243:        YR_FIXUP* fixup;
        -: 3244:        void* jmp_destination_addr;
        -: 3245:
        -: 3246:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3247:            yyscanner,
        -: 3248:            OP_JFALSE,
        -: 3249:            0,          // still don't know the jump destination
        -: 3250:            NULL,
        -: 3251:            &jmp_destination_addr));
        -: 3252:
        -: 3253:        // create a fixup entry for the jump and push it in the stack
        -: 3254:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3255:
        -: 3256:        if (fixup == NULL)
        -: 3257:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3258:
        -: 3259:        fixup->address = jmp_destination_addr;
        -: 3260:        fixup->next = compiler->fixup_stack_head;
        -: 3261:        compiler->fixup_stack_head = fixup;
        -: 3262:      }
        -: 3263:#line 3264 "grammar.c"
    #####: 3264:    break;
        -: 3265:
    #####: 3266:  case 85:
        -: 3267:#line 1513 "grammar.y"
        -: 3268:      {
        -: 3269:        YR_FIXUP* fixup;
        -: 3270:        uint8_t* nop_addr;
        -: 3271:
        -: 3272:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 3273:
        -: 3274:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3275:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3276:        // use the address of the OP_AND instruction +1 because we can't be
        -: 3277:        // sure that the instruction following the OP_AND is going to be in
        -: 3278:        // the same arena page. As we don't have a reliable way of getting the
        -: 3279:        // address of the next instruction we generate the OP_NOP.
        -: 3280:
        -: 3281:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3282:
        -: 3283:        fixup = compiler->fixup_stack_head;
        -: 3284:        *(void**)(fixup->address) = (void*) nop_addr;
        -: 3285:        compiler->fixup_stack_head = fixup->next;
        -: 3286:        yr_free(fixup);
        -: 3287:
        -: 3288:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3289:      }
        -: 3290:#line 3291 "grammar.c"
    #####: 3291:    break;
        -: 3292:
    #####: 3293:  case 86:
        -: 3294:#line 1536 "grammar.y"
        -: 3295:      {
        -: 3296:        YR_FIXUP* fixup;
        -: 3297:        void* jmp_destination_addr;
        -: 3298:
        -: 3299:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3300:            yyscanner,
        -: 3301:            OP_JTRUE,
        -: 3302:            0,         // still don't know the jump destination
        -: 3303:            NULL,
        -: 3304:            &jmp_destination_addr));
        -: 3305:
        -: 3306:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3307:
        -: 3308:        if (fixup == NULL)
        -: 3309:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3310:
        -: 3311:        fixup->address = jmp_destination_addr;
        -: 3312:        fixup->next = compiler->fixup_stack_head;
        -: 3313:        compiler->fixup_stack_head = fixup;
        -: 3314:      }
        -: 3315:#line 3316 "grammar.c"
    #####: 3316:    break;
        -: 3317:
    #####: 3318:  case 87:
        -: 3319:#line 1557 "grammar.y"
        -: 3320:      {
        -: 3321:        YR_FIXUP* fixup;
        -: 3322:        uint8_t* nop_addr;
        -: 3323:
        -: 3324:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 3325:
        -: 3326:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3327:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3328:        // use the address of the OP_OR instruction +1 because we can't be
        -: 3329:        // sure that the instruction following the OP_AND is going to be in
        -: 3330:        // the same arena page. As we don't have a reliable way of getting the
        -: 3331:        // address of the next instruction we generate the OP_NOP.
        -: 3332:
        -: 3333:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3334:
        -: 3335:        fixup = compiler->fixup_stack_head;
        -: 3336:        *(void**)(fixup->address) = (void*)(nop_addr);
        -: 3337:        compiler->fixup_stack_head = fixup->next;
        -: 3338:        yr_free(fixup);
        -: 3339:
        -: 3340:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3341:      }
        -: 3342:#line 3343 "grammar.c"
    #####: 3343:    break;
        -: 3344:
    #####: 3345:  case 88:
        -: 3346:#line 1580 "grammar.y"
        -: 3347:      {
        -: 3348:        fail_if_error(yr_parser_reduce_operation(
        -: 3349:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3350:
        -: 3351:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3352:      }
        -: 3353:#line 3354 "grammar.c"
    #####: 3354:    break;
        -: 3355:
    #####: 3356:  case 89:
        -: 3357:#line 1587 "grammar.y"
        -: 3358:      {
        -: 3359:        fail_if_error(yr_parser_reduce_operation(
        -: 3360:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3361:
        -: 3362:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3363:      }
        -: 3364:#line 3365 "grammar.c"
    #####: 3365:    break;
        -: 3366:
    #####: 3367:  case 90:
        -: 3368:#line 1594 "grammar.y"
        -: 3369:      {
        -: 3370:        fail_if_error(yr_parser_reduce_operation(
        -: 3371:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3372:
        -: 3373:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3374:      }
        -: 3375:#line 3376 "grammar.c"
    #####: 3376:    break;
        -: 3377:
    #####: 3378:  case 91:
        -: 3379:#line 1601 "grammar.y"
        -: 3380:      {
        -: 3381:        fail_if_error(yr_parser_reduce_operation(
        -: 3382:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3383:
        -: 3384:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3385:      }
        -: 3386:#line 3387 "grammar.c"
    #####: 3387:    break;
        -: 3388:
        4: 3389:  case 92:
        -: 3390:#line 1608 "grammar.y"
        -: 3391:      {
        -: 3392:        fail_if_error(yr_parser_reduce_operation(
        -: 3393:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3394:
        -: 3395:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3396:      }
        -: 3397:#line 3398 "grammar.c"
        4: 3398:    break;
        -: 3399:
    #####: 3400:  case 93:
        -: 3401:#line 1615 "grammar.y"
        -: 3402:      {
        -: 3403:        fail_if_error(yr_parser_reduce_operation(
        -: 3404:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3405:
        -: 3406:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3407:      }
        -: 3408:#line 3409 "grammar.c"
    #####: 3409:    break;
        -: 3410:
    #####: 3411:  case 94:
        -: 3412:#line 1622 "grammar.y"
        -: 3413:      {
        -: 3414:        (yyval.expression) = (yyvsp[0].expression);
        -: 3415:      }
        -: 3416:#line 3417 "grammar.c"
    #####: 3417:    break;
        -: 3418:
    #####: 3419:  case 95:
        -: 3420:#line 1626 "grammar.y"
        -: 3421:      {
        -: 3422:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3423:      }
        -: 3424:#line 3425 "grammar.c"
    #####: 3425:    break;
        -: 3426:
    #####: 3427:  case 96:
        -: 3428:#line 1633 "grammar.y"
        -: 3429:                                   { (yyval.integer) = INTEGER_SET_ENUMERATION; }
        -: 3430:#line 3431 "grammar.c"
    #####: 3431:    break;
        -: 3432:
    #####: 3433:  case 97:
        -: 3434:#line 1634 "grammar.y"
        -: 3435:                                   { (yyval.integer) = INTEGER_SET_RANGE; }
        -: 3436:#line 3437 "grammar.c"
    #####: 3437:    break;
        -: 3438:
    #####: 3439:  case 98:
        -: 3440:#line 1640 "grammar.y"
        -: 3441:      {
        -: 3442:        int result = ERROR_SUCCESS;
        -: 3443:
        -: 3444:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3445:        {
        -: 3446:          yr_compiler_set_error_extra_info(
        -: 3447:              compiler, "wrong type for range's lower bound");
        -: 3448:          result = ERROR_WRONG_TYPE;
        -: 3449:        }
        -: 3450:
        -: 3451:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3452:        {
        -: 3453:          yr_compiler_set_error_extra_info(
        -: 3454:              compiler, "wrong type for range's upper bound");
        -: 3455:          result = ERROR_WRONG_TYPE;
        -: 3456:        }
        -: 3457:
        -: 3458:        fail_if_error(result);
        -: 3459:      }
        -: 3460:#line 3461 "grammar.c"
    #####: 3461:    break;
        -: 3462:
    #####: 3463:  case 99:
        -: 3464:#line 1664 "grammar.y"
        -: 3465:      {
        -: 3466:        int result = ERROR_SUCCESS;
        -: 3467:
        -: 3468:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3469:        {
        -: 3470:          yr_compiler_set_error_extra_info(
        -: 3471:              compiler, "wrong type for enumeration item");
        -: 3472:          result = ERROR_WRONG_TYPE;
        -: 3473:        }
        -: 3474:
        -: 3475:        fail_if_error(result);
        -: 3476:      }
        -: 3477:#line 3478 "grammar.c"
    #####: 3478:    break;
        -: 3479:
    #####: 3480:  case 100:
        -: 3481:#line 1677 "grammar.y"
        -: 3482:      {
        -: 3483:        int result = ERROR_SUCCESS;
        -: 3484:
        -: 3485:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3486:        {
        -: 3487:          yr_compiler_set_error_extra_info(
        -: 3488:              compiler, "wrong type for enumeration item");
        -: 3489:          result = ERROR_WRONG_TYPE;
        -: 3490:        }
        -: 3491:
        -: 3492:        fail_if_error(result);
        -: 3493:      }
        -: 3494:#line 3495 "grammar.c"
    #####: 3495:    break;
        -: 3496:
    #####: 3497:  case 101:
        -: 3498:#line 1694 "grammar.y"
        -: 3499:      {
        -: 3500:        // Push end-of-list marker
        -: 3501:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3502:      }
        -: 3503:#line 3504 "grammar.c"
    #####: 3504:    break;
        -: 3505:
    #####: 3506:  case 103:
        -: 3507:#line 1700 "grammar.y"
        -: 3508:      {
        -: 3509:        fail_if_error(yr_parser_emit_with_arg(
        -: 3510:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 3511:
        -: 3512:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3513:            yyscanner, "$*"));
        -: 3514:      }
        -: 3515:#line 3516 "grammar.c"
    #####: 3516:    break;
        -: 3517:
    #####: 3518:  case 106:
        -: 3519:#line 1718 "grammar.y"
        -: 3520:      {
        -: 3521:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3522:        yr_free((yyvsp[0].c_string));
        -: 3523:
        -: 3524:        fail_if_error(result);
        -: 3525:      }
        -: 3526:#line 3527 "grammar.c"
    #####: 3527:    break;
        -: 3528:
    #####: 3529:  case 107:
        -: 3530:#line 1725 "grammar.y"
        -: 3531:      {
        -: 3532:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3533:        yr_free((yyvsp[0].c_string));
        -: 3534:
        -: 3535:        fail_if_error(result);
        -: 3536:      }
        -: 3537:#line 3538 "grammar.c"
    #####: 3538:    break;
        -: 3539:
    #####: 3540:  case 108:
        -: 3541:#line 1736 "grammar.y"
        -: 3542:      {
        -: 3543:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3544:      }
        -: 3545:#line 3546 "grammar.c"
    #####: 3546:    break;
        -: 3547:
    #####: 3548:  case 109:
        -: 3549:#line 1740 "grammar.y"
        -: 3550:      {
        -: 3551:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3552:        (yyval.integer) = FOR_EXPRESSION_ALL;
        -: 3553:      }
        -: 3554:#line 3555 "grammar.c"
    #####: 3555:    break;
        -: 3556:
    #####: 3557:  case 110:
        -: 3558:#line 1745 "grammar.y"
        -: 3559:      {
        -: 3560:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3561:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3562:      }
        -: 3563:#line 3564 "grammar.c"
    #####: 3564:    break;
        -: 3565:
    #####: 3566:  case 111:
        -: 3567:#line 1754 "grammar.y"
        -: 3568:      {
        -: 3569:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3570:      }
        -: 3571:#line 3572 "grammar.c"
    #####: 3572:    break;
        -: 3573:
    #####: 3574:  case 112:
        -: 3575:#line 1758 "grammar.y"
        -: 3576:      {
        -: 3577:        fail_if_error(yr_parser_emit(
        -: 3578:            yyscanner, OP_FILESIZE, NULL));
        -: 3579:
        -: 3580:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3581:        (yyval.expression).value.integer = UNDEFINED;
        -: 3582:      }
        -: 3583:#line 3584 "grammar.c"
    #####: 3584:    break;
        -: 3585:
    #####: 3586:  case 113:
        -: 3587:#line 1766 "grammar.y"
        -: 3588:      {
        -: 3589:        yywarning(yyscanner,
        -: 3590:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3591:            "function from PE module instead.");
        -: 3592:
        -: 3593:        fail_if_error(yr_parser_emit(
        -: 3594:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3595:
        -: 3596:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3597:        (yyval.expression).value.integer = UNDEFINED;
        -: 3598:      }
        -: 3599:#line 3600 "grammar.c"
    #####: 3600:    break;
        -: 3601:
    #####: 3602:  case 114:
        -: 3603:#line 1778 "grammar.y"
        -: 3604:      {
        -: 3605:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3606:
        -: 3607:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3608:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3609:        // in the proper OP_INTXX opcode.
        -: 3610:
        -: 3611:        fail_if_error(yr_parser_emit(
        -: 3612:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 3613:
        -: 3614:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3615:        (yyval.expression).value.integer = UNDEFINED;
        -: 3616:      }
        -: 3617:#line 3618 "grammar.c"
    #####: 3618:    break;
        -: 3619:
        4: 3620:  case 115:
        -: 3621:#line 1792 "grammar.y"
        -: 3622:      {
        -: 3623:        fail_if_error(yr_parser_emit_with_arg(
        -: 3624:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 3625:
        -: 3626:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3627:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 3628:      }
        -: 3629:#line 3630 "grammar.c"
        4: 3630:    break;
        -: 3631:
    #####: 3632:  case 116:
        -: 3633:#line 1800 "grammar.y"
        -: 3634:      {
        -: 3635:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 3636:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 3637:
        -: 3638:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3639:      }
        -: 3640:#line 3641 "grammar.c"
    #####: 3641:    break;
        -: 3642:
    #####: 3643:  case 117:
        -: 3644:#line 1807 "grammar.y"
        -: 3645:      {
        -: 3646:        SIZED_STRING* sized_string;
        -: 3647:
        -: 3648:        int result = yr_arena_write_data(
        -: 3649:            compiler->sz_arena,
        -: 3650:            (yyvsp[0].sized_string),
        -: 3651:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 3652:            (void**) &sized_string);
        -: 3653:
        -: 3654:        yr_free((yyvsp[0].sized_string));
        -: 3655:
        -: 3656:        if (result == ERROR_SUCCESS)
        -: 3657:          result = yr_parser_emit_with_arg_reloc(
        -: 3658:              yyscanner,
        -: 3659:              OP_PUSH,
        -: 3660:              sized_string,
        -: 3661:              NULL,
        -: 3662:              NULL);
        -: 3663:
        -: 3664:        fail_if_error(result);
        -: 3665:
        -: 3666:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3667:        (yyval.expression).value.sized_string = sized_string;
        -: 3668:      }
        -: 3669:#line 3670 "grammar.c"
    #####: 3670:    break;
        -: 3671:
    #####: 3672:  case 118:
        -: 3673:#line 1832 "grammar.y"
        -: 3674:      {
        -: 3675:        int result = yr_parser_reduce_string_identifier(
        -: 3676:            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
        -: 3677:
        -: 3678:        yr_free((yyvsp[0].c_string));
        -: 3679:
        -: 3680:        fail_if_error(result);
        -: 3681:
        -: 3682:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3683:        (yyval.expression).value.integer = UNDEFINED;
        -: 3684:      }
        -: 3685:#line 3686 "grammar.c"
    #####: 3686:    break;
        -: 3687:
    #####: 3688:  case 119:
        -: 3689:#line 1844 "grammar.y"
        -: 3690:      {
        -: 3691:        int result = yr_parser_reduce_string_identifier(
        -: 3692:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
        -: 3693:
        -: 3694:        yr_free((yyvsp[-3].c_string));
        -: 3695:
        -: 3696:        fail_if_error(result);
        -: 3697:
        -: 3698:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3699:        (yyval.expression).value.integer = UNDEFINED;
        -: 3700:      }
        -: 3701:#line 3702 "grammar.c"
    #####: 3702:    break;
        -: 3703:
    #####: 3704:  case 120:
        -: 3705:#line 1856 "grammar.y"
        -: 3706:      {
        -: 3707:        int result = yr_parser_emit_with_arg(
        -: 3708:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3709:
        -: 3710:        if (result == ERROR_SUCCESS)
        -: 3711:          result = yr_parser_reduce_string_identifier(
        -: 3712:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
        -: 3713:
        -: 3714:        yr_free((yyvsp[0].c_string));
        -: 3715:
        -: 3716:        fail_if_error(result);
        -: 3717:
        -: 3718:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3719:        (yyval.expression).value.integer = UNDEFINED;
        -: 3720:      }
        -: 3721:#line 3722 "grammar.c"
    #####: 3722:    break;
        -: 3723:
    #####: 3724:  case 121:
        -: 3725:#line 1872 "grammar.y"
        -: 3726:      {
        -: 3727:        int result = yr_parser_reduce_string_identifier(
        -: 3728:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
        -: 3729:
        -: 3730:        yr_free((yyvsp[-3].c_string));
        -: 3731:
        -: 3732:        fail_if_error(result);
        -: 3733:
        -: 3734:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3735:        (yyval.expression).value.integer = UNDEFINED;
        -: 3736:      }
        -: 3737:#line 3738 "grammar.c"
    #####: 3738:    break;
        -: 3739:
        4: 3740:  case 122:
        -: 3741:#line 1884 "grammar.y"
        -: 3742:      {
        -: 3743:        int result = yr_parser_emit_with_arg(
        -: 3744:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3745:
        -: 3746:        if (result == ERROR_SUCCESS)
        -: 3747:          result = yr_parser_reduce_string_identifier(
        -: 3748:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
        -: 3749:
        -: 3750:        yr_free((yyvsp[0].c_string));
        -: 3751:
        -: 3752:        fail_if_error(result);
        -: 3753:
        -: 3754:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3755:        (yyval.expression).value.integer = UNDEFINED;
        -: 3756:      }
        -: 3757:#line 3758 "grammar.c"
        4: 3758:    break;
        -: 3759:
    #####: 3760:  case 123:
        -: 3761:#line 1900 "grammar.y"
        -: 3762:      {
        -: 3763:        int result = ERROR_SUCCESS;
        -: 3764:
        -: 3765:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 3766:        {
        -: 3767:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3768:          (yyval.expression).value.integer = UNDEFINED;
        -: 3769:        }
        -: 3770:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 3771:        {
        -: 3772:          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3773:          (yyval.expression).value.integer = UNDEFINED;
        -: 3774:        }
        -: 3775:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3776:        {
        -: 3777:          result = yr_parser_emit(
        -: 3778:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 3779:
        -: 3780:          switch((yyvsp[0].expression).value.object->type)
        -: 3781:          {
        -: 3782:            case OBJECT_TYPE_INTEGER:
        -: 3783:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3784:              (yyval.expression).value.integer = UNDEFINED;
        -: 3785:              break;
        -: 3786:            case OBJECT_TYPE_FLOAT:
        -: 3787:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3788:              break;
        -: 3789:            case OBJECT_TYPE_STRING:
        -: 3790:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3791:              (yyval.expression).value.sized_string = NULL;
        -: 3792:              break;
        -: 3793:            default:
        -: 3794:              yr_compiler_set_error_extra_info_fmt(
        -: 3795:                  compiler,
        -: 3796:                  "wrong usage of identifier \"%s\"",
        -: 3797:                  (yyvsp[0].expression).identifier);
        -: 3798:              result = ERROR_WRONG_TYPE;
        -: 3799:          }
        -: 3800:        }
        -: 3801:        else
        -: 3802:        {
        -: 3803:          assert(false);
        -: 3804:        }
        -: 3805:
        -: 3806:        fail_if_error(result);
        -: 3807:      }
        -: 3808:#line 3809 "grammar.c"
    #####: 3809:    break;
        -: 3810:
    #####: 3811:  case 124:
        -: 3812:#line 1947 "grammar.y"
        -: 3813:      {
        -: 3814:        int result = ERROR_SUCCESS;
        -: 3815:
        -: 3816:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 3817:
        -: 3818:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3819:        {
        -: 3820:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3821:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3822:              UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 3823:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 3824:        }
        -: 3825:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 3826:        {
        -: 3827:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3828:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 3829:        }
        -: 3830:
        -: 3831:        fail_if_error(result);
        -: 3832:      }
        -: 3833:#line 3834 "grammar.c"
    #####: 3834:    break;
        -: 3835:
    #####: 3836:  case 125:
        -: 3837:#line 1968 "grammar.y"
        -: 3838:      {
        -: 3839:        int result = yr_parser_reduce_operation(
        -: 3840:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3841:
        -: 3842:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3843:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3844:        {
        -: 3845:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3846:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3847:
        -: 3848:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3849:              (
        -: 3850:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 3851:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 3852:              ))
        -: 3853:          {
        -: 3854:            yr_compiler_set_error_extra_info_fmt(
        -: 3855:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 3856:
        -: 3857:            result = ERROR_INTEGER_OVERFLOW;
        -: 3858:          }
        -: 3859:          else
        -: 3860:          {
        -: 3861:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 3862:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3863:          }
        -: 3864:        }
        -: 3865:        else
        -: 3866:        {
        -: 3867:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3868:        }
        -: 3869:
        -: 3870:        fail_if_error(result);
        -: 3871:      }
        -: 3872:#line 3873 "grammar.c"
    #####: 3873:    break;
        -: 3874:
    #####: 3875:  case 126:
        -: 3876:#line 2003 "grammar.y"
        -: 3877:      {
        -: 3878:        int result = yr_parser_reduce_operation(
        -: 3879:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3880:
        -: 3881:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3882:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3883:        {
        -: 3884:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3885:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3886:
        -: 3887:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3888:              (
        -: 3889:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 3890:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 3891:              ))
        -: 3892:          {
        -: 3893:            yr_compiler_set_error_extra_info_fmt(
        -: 3894:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 3895:
        -: 3896:            result = ERROR_INTEGER_OVERFLOW;
        -: 3897:          }
        -: 3898:          else
        -: 3899:          {
        -: 3900:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 3901:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3902:          }
        -: 3903:        }
        -: 3904:        else
        -: 3905:        {
        -: 3906:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3907:        }
        -: 3908:
        -: 3909:        fail_if_error(result);
        -: 3910:      }
        -: 3911:#line 3912 "grammar.c"
    #####: 3912:    break;
        -: 3913:
    #####: 3914:  case 127:
        -: 3915:#line 2038 "grammar.y"
        -: 3916:      {
        -: 3917:        int result = yr_parser_reduce_operation(
        -: 3918:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3919:
        -: 3920:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3921:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3922:        {
        -: 3923:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3924:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3925:
        -: 3926:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3927:              (
        -: 3928:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 3929:              ))
        -: 3930:          {
        -: 3931:            yr_compiler_set_error_extra_info_fmt(
        -: 3932:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 3933:
        -: 3934:            result = ERROR_INTEGER_OVERFLOW;
        -: 3935:          }
        -: 3936:          else
        -: 3937:          {
        -: 3938:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 3939:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3940:          }
        -: 3941:        }
        -: 3942:        else
        -: 3943:        {
        -: 3944:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3945:        }
        -: 3946:
        -: 3947:        fail_if_error(result);
        -: 3948:      }
        -: 3949:#line 3950 "grammar.c"
    #####: 3950:    break;
        -: 3951:
    #####: 3952:  case 128:
        -: 3953:#line 2072 "grammar.y"
        -: 3954:      {
        -: 3955:        int result = yr_parser_reduce_operation(
        -: 3956:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3957:
        -: 3958:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3959:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3960:        {
        -: 3961:          if ((yyvsp[0].expression).value.integer != 0)
        -: 3962:          {
        -: 3963:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3964:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3965:          }
        -: 3966:          else
        -: 3967:          {
        -: 3968:            result = ERROR_DIVISION_BY_ZERO;
        -: 3969:          }
        -: 3970:        }
        -: 3971:        else
        -: 3972:        {
        -: 3973:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3974:        }
        -: 3975:
        -: 3976:        fail_if_error(result);
        -: 3977:      }
        -: 3978:#line 3979 "grammar.c"
    #####: 3979:    break;
        -: 3980:
    #####: 3981:  case 129:
        -: 3982:#line 2097 "grammar.y"
        -: 3983:      {
        -: 3984:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3985:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3986:
        -: 3987:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 3988:
        -: 3989:        if ((yyvsp[0].expression).value.integer != 0)
        -: 3990:        {
        -: 3991:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3992:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3993:        }
        -: 3994:        else
        -: 3995:        {
        -: 3996:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 3997:        }
        -: 3998:      }
        -: 3999:#line 4000 "grammar.c"
    #####: 4000:    break;
        -: 4001:
    #####: 4002:  case 130:
        -: 4003:#line 2114 "grammar.y"
        -: 4004:      {
        -: 4005:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4006:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4007:
        -: 4008:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 4009:
        -: 4010:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4011:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4012:      }
        -: 4013:#line 4014 "grammar.c"
    #####: 4014:    break;
        -: 4015:
    #####: 4016:  case 131:
        -: 4017:#line 2124 "grammar.y"
        -: 4018:      {
        -: 4019:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4020:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4021:
        -: 4022:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 4023:
        -: 4024:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4025:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4026:      }
        -: 4027:#line 4028 "grammar.c"
    #####: 4028:    break;
        -: 4029:
    #####: 4030:  case 132:
        -: 4031:#line 2134 "grammar.y"
        -: 4032:      {
        -: 4033:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 4034:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 4035:
        -: 4036:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 4037:
        -: 4038:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4039:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4040:      }
        -: 4041:#line 4042 "grammar.c"
    #####: 4042:    break;
        -: 4043:
    #####: 4044:  case 133:
        -: 4045:#line 2144 "grammar.y"
        -: 4046:      {
        -: 4047:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 4048:
        -: 4049:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 4050:
        -: 4051:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4052:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 4053:            UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 4054:      }
        -: 4055:#line 4056 "grammar.c"
    #####: 4056:    break;
        -: 4057:
    #####: 4058:  case 134:
        -: 4059:#line 2154 "grammar.y"
        -: 4060:      {
        -: 4061:        int result;
        -: 4062:
        -: 4063:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 4064:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 4065:
        -: 4066:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 4067:
        -: 4068:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 4069:          result = ERROR_INVALID_OPERAND;
        -: 4070:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 4071:          (yyval.expression).value.integer = 0;
        -: 4072:        else
        -: 4073:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4074:
        -: 4075:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4076:
        -: 4077:        fail_if_error(result);
        -: 4078:      }
        -: 4079:#line 4080 "grammar.c"
    #####: 4080:    break;
        -: 4081:
    #####: 4082:  case 135:
        -: 4083:#line 2174 "grammar.y"
        -: 4084:      {
        -: 4085:        int result;
        -: 4086:
        -: 4087:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 4088:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 4089:
        -: 4090:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 4091:
        -: 4092:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 4093:          result = ERROR_INVALID_OPERAND;
        -: 4094:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 4095:          (yyval.expression).value.integer = 0;
        -: 4096:        else
        -: 4097:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4098:
        -: 4099:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4100:
        -: 4101:        fail_if_error(result);
        -: 4102:      }
        -: 4103:#line 4104 "grammar.c"
    #####: 4104:    break;
        -: 4105:
    #####: 4106:  case 136:
        -: 4107:#line 2194 "grammar.y"
        -: 4108:      {
        -: 4109:        (yyval.expression) = (yyvsp[0].expression);
        -: 4110:      }
        -: 4111:#line 4112 "grammar.c"
    #####: 4112:    break;
        -: 4113:
        -: 4114:
        -: 4115:#line 4116 "grammar.c"
        -: 4116:
      856: 4117:      default: break;
        -: 4118:    }
        -: 4119:  /* User semantic actions sometimes alter yychar, and that requires
        -: 4120:     that yytoken be updated with the new translation.  We take the
        -: 4121:     approach of translating immediately before every use of yytoken.
        -: 4122:     One alternative is translating here after every semantic action,
        -: 4123:     but that translation would be missed if the semantic action invokes
        -: 4124:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 4125:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 4126:     incorrect destructor might then be invoked immediately.  In the
        -: 4127:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 4128:     to an incorrect destructor call or verbose syntax error message
        -: 4129:     before the lookahead is translated.  */
        -: 4130:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 4131:
     4722: 4132:  YYPOPSTACK (yylen);
     4722: 4133:  yylen = 0;
        -: 4134:  YY_STACK_PRINT (yyss, yyssp);
        -: 4135:
     4722: 4136:  *++yyvsp = yyval;
        -: 4137:
        -: 4138:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 4139:     that goes to, based on the state we popped back to and the rule
        -: 4140:     number reduced by.  */
        -: 4141:  {
     4722: 4142:    const int yylhs = yyr1[yyn] - YYNTOKENS;
     4722: 4143:    const int yyi = yypgoto[yylhs] + *yyssp;
     1191: 4144:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
      284: 4145:               ? yytable[yyi]
     5913: 4146:               : yydefgoto[yylhs]);
        -: 4147:  }
        -: 4148:
     4722: 4149:  goto yynewstate;
        -: 4150:
        -: 4151:
        -: 4152:/*--------------------------------------.
        -: 4153:| yyerrlab -- here on detecting error.  |
        -: 4154:`--------------------------------------*/
       71: 4155:yyerrlab:
        -: 4156:  /* Make sure we have latest lookahead translation.  See comments at
        -: 4157:     user semantic actions for why this is necessary.  */
      71*: 4158:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 4159:
        -: 4160:  /* If not already recovering from an error, report this error.  */
       71: 4161:  if (!yyerrstatus)
        -: 4162:    {
        3: 4163:      ++yynerrs;
        -: 4164:#if ! YYERROR_VERBOSE
        -: 4165:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 4166:#else
        -: 4167:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 4168:                                        yyssp, yytoken)
        -: 4169:      {
        3: 4170:        char const *yymsgp = YY_("syntax error");
        -: 4171:        int yysyntax_error_status;
        3: 4172:        yysyntax_error_status = YYSYNTAX_ERROR;
        3: 4173:        if (yysyntax_error_status == 0)
        3: 4174:          yymsgp = yymsg;
    #####: 4175:        else if (yysyntax_error_status == 1)
        -: 4176:          {
    #####: 4177:            if (yymsg != yymsgbuf)
    #####: 4178:              YYSTACK_FREE (yymsg);
    #####: 4179:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 4180:            if (!yymsg)
        -: 4181:              {
    #####: 4182:                yymsg = yymsgbuf;
    #####: 4183:                yymsg_alloc = sizeof yymsgbuf;
    #####: 4184:                yysyntax_error_status = 2;
        -: 4185:              }
        -: 4186:            else
        -: 4187:              {
    #####: 4188:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 4189:                yymsgp = yymsg;
        -: 4190:              }
        -: 4191:          }
        3: 4192:        yyerror (yyscanner, compiler, yymsgp);
        3: 4193:        if (yysyntax_error_status == 2)
    #####: 4194:          goto yyexhaustedlab;
        -: 4195:      }
        -: 4196:# undef YYSYNTAX_ERROR
        -: 4197:#endif
        -: 4198:    }
        -: 4199:
        -: 4200:
        -: 4201:
       71: 4202:  if (yyerrstatus == 3)
        -: 4203:    {
        -: 4204:      /* If just tried and failed to reuse lookahead token after an
        -: 4205:         error, discard it.  */
        -: 4206:
       68: 4207:      if (yychar <= YYEOF)
        -: 4208:        {
        -: 4209:          /* Return failure if at end of input.  */
       16: 4210:          if (yychar == YYEOF)
       16: 4211:            YYABORT;
        -: 4212:        }
        -: 4213:      else
        -: 4214:        {
       52: 4215:          yydestruct ("Error: discarding",
        -: 4216:                      yytoken, &yylval, yyscanner, compiler);
       52: 4217:          yychar = YYEMPTY;
        -: 4218:        }
        -: 4219:    }
        -: 4220:
        -: 4221:  /* Else will try to reuse lookahead token after shifting the error
        -: 4222:     token.  */
       55: 4223:  goto yyerrlab1;
        -: 4224:
        -: 4225:
        -: 4226:/*---------------------------------------------------.
        -: 4227:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 4228:`---------------------------------------------------*/
       13: 4229:yyerrorlab:
        -: 4230:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 4231:     label yyerrorlab therefore never appears in user code.  */
        -: 4232:  if (0)
        -: 4233:    YYERROR;
        -: 4234:
        -: 4235:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4236:     this YYERROR.  */
       13: 4237:  YYPOPSTACK (yylen);
       13: 4238:  yylen = 0;
        -: 4239:  YY_STACK_PRINT (yyss, yyssp);
       13: 4240:  yystate = *yyssp;
       13: 4241:  goto yyerrlab1;
        -: 4242:
        -: 4243:
        -: 4244:/*-------------------------------------------------------------.
        -: 4245:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 4246:`-------------------------------------------------------------*/
       68: 4247:yyerrlab1:
       68: 4248:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 4249:
        -: 4250:  for (;;)
        -: 4251:    {
      322: 4252:      yyn = yypact[yystate];
      322: 4253:      if (!yypact_value_is_default (yyn))
        -: 4254:        {
      305: 4255:          yyn += YYTERROR;
      305: 4256:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 4257:            {
       68: 4258:              yyn = yytable[yyn];
       68: 4259:              if (0 < yyn)
       68: 4260:                break;
        -: 4261:            }
        -: 4262:        }
        -: 4263:
        -: 4264:      /* Pop the current state because it cannot handle the error token.  */
      254: 4265:      if (yyssp == yyss)
    #####: 4266:        YYABORT;
        -: 4267:
        -: 4268:
      254: 4269:      yydestruct ("Error: popping",
      254: 4270:                  yystos[yystate], yyvsp, yyscanner, compiler);
      254: 4271:      YYPOPSTACK (1);
      254: 4272:      yystate = *yyssp;
        -: 4273:      YY_STACK_PRINT (yyss, yyssp);
        -: 4274:    }
        -: 4275:
        -: 4276:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       68: 4277:  *++yyvsp = yylval;
        -: 4278:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 4279:
        -: 4280:
        -: 4281:  /* Shift the error token.  */
        -: 4282:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 4283:
       68: 4284:  yystate = yyn;
       68: 4285:  goto yynewstate;
        -: 4286:
        -: 4287:
        -: 4288:/*-------------------------------------.
        -: 4289:| yyacceptlab -- YYACCEPT comes here.  |
        -: 4290:`-------------------------------------*/
      280: 4291:yyacceptlab:
      280: 4292:  yyresult = 0;
      280: 4293:  goto yyreturn;
        -: 4294:
        -: 4295:
        -: 4296:/*-----------------------------------.
        -: 4297:| yyabortlab -- YYABORT comes here.  |
        -: 4298:`-----------------------------------*/
       16: 4299:yyabortlab:
       16: 4300:  yyresult = 1;
       16: 4301:  goto yyreturn;
        -: 4302:
        -: 4303:
        -: 4304:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 4305:/*-------------------------------------------------.
        -: 4306:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 4307:`-------------------------------------------------*/
    #####: 4308:yyexhaustedlab:
    #####: 4309:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
    #####: 4310:  yyresult = 2;
        -: 4311:  /* Fall through.  */
        -: 4312:#endif
        -: 4313:
        -: 4314:
        -: 4315:/*-----------------------------------------------------.
        -: 4316:| yyreturn -- parsing is finished, return the result.  |
        -: 4317:`-----------------------------------------------------*/
      296: 4318:yyreturn:
      296: 4319:  if (yychar != YYEMPTY)
        -: 4320:    {
        -: 4321:      /* Make sure we have latest lookahead translation.  See comments at
        -: 4322:         user semantic actions for why this is necessary.  */
      16*: 4323:      yytoken = YYTRANSLATE (yychar);
       16: 4324:      yydestruct ("Cleanup: discarding lookahead",
        -: 4325:                  yytoken, &yylval, yyscanner, compiler);
        -: 4326:    }
        -: 4327:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4328:     this YYABORT or YYACCEPT.  */
      296: 4329:  YYPOPSTACK (yylen);
        -: 4330:  YY_STACK_PRINT (yyss, yyssp);
      904: 4331:  while (yyssp != yyss)
        -: 4332:    {
      608: 4333:      yydestruct ("Cleanup: popping",
      608: 4334:                  yystos[+*yyssp], yyvsp, yyscanner, compiler);
      608: 4335:      YYPOPSTACK (1);
        -: 4336:    }
        -: 4337:#ifndef yyoverflow
      296: 4338:  if (yyss != yyssa)
    #####: 4339:    YYSTACK_FREE (yyss);
        -: 4340:#endif
        -: 4341:#if YYERROR_VERBOSE
      296: 4342:  if (yymsg != yymsgbuf)
    #####: 4343:    YYSTACK_FREE (yymsg);
        -: 4344:#endif
      296: 4345:  return yyresult;
        -: 4346:}
        -: 4347:#line 2199 "grammar.y"
        -: 4348:
