        -:    0:Source:re_lexer.l
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:9
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for regular expressions */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <assert.h>
        -:   48:#include <setjmp.h>
        -:   49:
        -:   50:#include <yara/globals.h>
        -:   51:#include <yara/utils.h>
        -:   52:#include <yara/error.h>
        -:   53:#include <yara/limits.h>
        -:   54:#include <yara/mem.h>
        -:   55:#include <yara/re.h>
        -:   56:#include <yara/re_lexer.h>
        -:   57:#include <yara/threading.h>
        -:   58:#include <yara/strutils.h>
        -:   59:
        -:   60:
        -:   61:#ifdef _WIN32
        -:   62:#define snprintf _snprintf
        -:   63:#endif
        -:   64:
        -:   65:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:   66:// is set to 1 if the corresponding character is alphanumeric or 0 if otherwise.
        -:   67:static uint8_t word_chars[] = {
        -:   68:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:   69:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:   70:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   71:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   72:
        -:   73:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:   74:// is set to 1 if the corresponding character is considered a space. Space
        -:   75:// characters include horizontal and vertical tabs, carriage return, new line
        -:   76:// and form feed (\t, \v, \r, \n, \f).
        -:   77:static uint8_t space_chars[] = {
        -:   78:    0x00, 0x3E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        -:   79:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   80:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   81:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   82:
        -:   83:int escaped_char_value(
        -:   84:    char* text,
        -:   85:    uint8_t* value);
        -:   86:
        -:   87:int read_escaped_char(
        -:   88:    yyscan_t yyscanner,
        -:   89:    uint8_t* escaped_char);
        -:   90:
        -:   91:%}
        -:   92:
        -:   93:%option reentrant bison-bridge
        -:   94:%option noyywrap
        -:   95:%option nounistd
        -:   96:%option nounput
        -:   97:%option never-interactive
        -:   98:%option yylineno
        -:   99:%option prefix="re_yy"
        -:  100:
        -:  101:%option outfile="lex.yy.c"
        -:  102:
        -:  103:%option verbose
        -:  104:%option warn
        -:  105:
        -:  106:%x char_class
        -:  107:
        -:  108:digit         [0-9]
        -:  109:hex_digit     [0-9a-fA-F]
        -:  110:
        -:  111:%%
        -:  112:
        -:  113:\{{digit}*,{digit}*\} {
        -:  114:
        -:  115:  // Examples: {3,8} {0,5} {,5} {7,}
        -:  116:
        -:  117:  int hi_bound;
       80:  118:  int lo_bound = atoi(yytext + 1);
        -:  119:
       80:  120:  char* comma = strchr(yytext, ',');
        -:  121:
       80:  122:  if (comma - yytext == strlen(yytext) - 2)
        -:  123:    // if comma is followed by the closing curly bracket
        -:  124:    // (example: {2,}) set high bound value to maximum.
        8:  125:    hi_bound = INT16_MAX;
        -:  126:  else
       72:  127:    hi_bound = atoi(comma + 1);
        -:  128:
       80:  129:  if (hi_bound > INT16_MAX)
        -:  130:  {
    #####:  131:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  132:    yyterminate();
        -:  133:  }
        -:  134:
       80:  135:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
        -:  136:  {
    #####:  137:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  138:    yyterminate();
        -:  139:  }
        -:  140:
       80:  141:  if (hi_bound == 0 && lo_bound == 0)
        -:  142:  {
        1:  143:    yyerror(yyscanner, lex_env, "bad repeat interval");
        1:  144:    yyterminate();
        -:  145:  }
        -:  146:
       79:  147:  yylval->range = (hi_bound << 16) | lo_bound;
        -:  148:
       79:  149:  return _RANGE_;
        -:  150:}
        -:  151:
       16:  152:
        -:  153:\{{digit}+\} {
        -:  154:
        -:  155:  // Example: {10}
        -:  156:
       16:  157:  int value = atoi(yytext + 1);
        -:  158:
        -:  159:  // atoi can return a negative value if the input string represents a number
        -:  160:  // too large to fit in an integer.
        -:  161:
       16:  162:  if (value > INT16_MAX || value < 0)
        -:  163:  {
        1:  164:    yyerror(yyscanner, lex_env, "repeat interval too large");
        1:  165:    yyterminate();
        -:  166:  }
        -:  167:
       15:  168:  if (value == 0)
        -:  169:  {
        1:  170:    yyerror(yyscanner, lex_env, "bad repeat interval");
        1:  171:    yyterminate();
        -:  172:  }
        -:  173:
       14:  174:  yylval->range = (value << 16) | value;
        -:  175:
       14:  176:  return _RANGE_;
        -:  177:}
        -:  178:
       17:  179:
        -:  180:\[\^ {
        -:  181:
        -:  182:  // Start of a negated character class. Example: [^abcd]
        -:  183:
       17:  184:  BEGIN(char_class);
       17:  185:  memset(LEX_ENV->re_class.bitmap, 0, 32);
       17:  186:  LEX_ENV->re_class.negated = true;
        -:  187:}
       17:  188:
        2:  189:\[\^\] {
        -:  190:
        -:  191:  // Start of character negated class containing a ].
        -:  192:  // Example: [^]abc] this must be interpreted as a class
        -:  193:  // not matching ], a, b, nor c
        -:  194:
        2:  195:  BEGIN(char_class);
        2:  196:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        2:  197:  LEX_ENV->re_class.negated = true;
        2:  198:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  199:}
        2:  200:
        2:  201:
        -:  202:\[\] {
        -:  203:
        -:  204:  // Start of character class containing a ].
        -:  205:  // Example: []abc] this must be interpreted as a class
        -:  206:  // matching ], a, b, or c.
        -:  207:
        2:  208:  BEGIN(char_class);
        2:  209:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        2:  210:  LEX_ENV->re_class.negated = false;
        2:  211:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  212:}
        2:  213:
       50:  214:
        -:  215:\[ {
        -:  216:
        -:  217:  // Start of character class. Example: [abcd]
        -:  218:
       50:  219:  BEGIN(char_class);
       50:  220:  memset(LEX_ENV->re_class.bitmap, 0, 32);
       50:  221:  LEX_ENV->re_class.negated = false;
        -:  222:}
       50:  223:
      827:  224:
        -:  225:[^\\\[\(\)\|\$\.\^\+\*\?] {
        -:  226:
        -:  227:  // Any non-special character is passed as a CHAR token to the scanner.
        -:  228:
      827:  229:  yylval->integer = yytext[0];
      827:  230:  return _CHAR_;
        -:  231:}
        -:  232:
       26:  233:
        -:  234:\\w {
       26:  235:  return _WORD_CHAR_;
        -:  236:}
        -:  237:
    #####:  238:
        -:  239:\\W {
    #####:  240:  return _NON_WORD_CHAR_;
        -:  241:}
        -:  242:
       10:  243:
        -:  244:\\s {
       10:  245:  return _SPACE_;
        -:  246:}
        -:  247:
        6:  248:
        -:  249:\\S {
        6:  250:  return _NON_SPACE_;
        -:  251:}
        -:  252:
    #####:  253:
        -:  254:\\d {
    #####:  255:  return _DIGIT_;
        -:  256:}
        -:  257:
        1:  258:
        -:  259:\\D {
        1:  260:  return _NON_DIGIT_;
        -:  261:}
        -:  262:
       26:  263:
        -:  264:\\b {
       26:  265:  return _WORD_BOUNDARY_;
        -:  266:}
        -:  267:
       10:  268:\\B {
       10:  269:  return _NON_WORD_BOUNDARY_;
        -:  270:}
        -:  271:
    #####:  272:
        -:  273:\\{digit}+ {
        -:  274:
    #####:  275:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
    #####:  276:  yyterminate();
        -:  277:}
        -:  278:
       15:  279:
        -:  280:\\ {
        -:  281:
        -:  282:  uint8_t c;
        -:  283:
       15:  284:  if (read_escaped_char(yyscanner, &c))
        -:  285:  {
       12:  286:    yylval->integer = c;
       12:  287:    return _CHAR_;
        -:  288:  }
        -:  289:  else
        -:  290:  {
        3:  291:    yyerror(yyscanner, lex_env, "illegal escape sequence");
        3:  292:    yyterminate();
        -:  293:  }
        -:  294:}
        -:  295:
       69:  296:
        -:  297:<char_class>\] {
        -:  298:
        -:  299:  // End of character class.
       69:  300:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
       69:  301:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -:  302:
       69:  303:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -:  304:
       69:  305:  BEGIN(INITIAL);
       69:  306:  return _CLASS_;
        -:  307:}
        -:  308:
       20:  309:
        -:  310:
        -:  311:<char_class>(\\x{hex_digit}{2}|\\.|[^\\])\-[^]] {
        -:  312:
        -:  313:  // A range inside a character class.
        -:  314:  //  [abc0-9]
        -:  315:  //      ^- matching here
        -:  316:
        -:  317:  uint16_t c;
       20:  318:  uint8_t start = yytext[0];
       20:  319:  uint8_t end = yytext[2];
        -:  320:
       20:  321:  if (start == '\\')
        -:  322:  {
        5:  323:    if (!escaped_char_value(yytext, &start))
        -:  324:    {
    #####:  325:      yyerror(yyscanner, lex_env, "illegal escape sequence");
       1*:  326:      yyterminate();
        -:  327:    }
        -:  328:
        5:  329:    if (yytext[1] == 'x')
        5:  330:      end = yytext[5];
        -:  331:    else
    #####:  332:      end = yytext[3];
        -:  333:  }
        -:  334:
       20:  335:  if (end == '\\')
        -:  336:  {
        6:  337:    if (!read_escaped_char(yyscanner, &end))
        -:  338:    {
    #####:  339:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  340:      yyterminate();
        -:  341:    }
        -:  342:  }
        -:  343:
       20:  344:  if (end < start)
        -:  345:  {
        1:  346:    yyerror(yyscanner, lex_env, "bad character range");
        1:  347:    yyterminate();
        -:  348:  }
        -:  349:
      142:  350:  for (c = start; c <= end; c++)
        -:  351:  {
      123:  352:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  353:  }
        -:  354:}
       19:  355:
        1:  356:
        -:  357:<char_class>\\w {
        -:  358:
        -:  359:  int i;
        -:  360:
       33:  361:  for (i = 0; i < 32; i++)
       32:  362:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -:  363:}
        1:  364:
    #####:  365:
        -:  366:<char_class>\\W {
        -:  367:
        -:  368:  int i;
        -:  369:
    #####:  370:  for (i = 0; i < 32; i++)
    #####:  371:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -:  372:}
    #####:  373:
        4:  374:
        -:  375:<char_class>\\s {
        -:  376:
        -:  377:  int i;
        -:  378:
      132:  379:  for (i = 0; i < 32; i++)
      128:  380:    LEX_ENV->re_class.bitmap[i] |= space_chars[i];
        -:  381:}
        4:  382:
        2:  383:
        -:  384:<char_class>\\S {
        -:  385:
        -:  386:  int i;
        -:  387:
       66:  388:  for (i = 0; i < 32; i++)
       64:  389:    LEX_ENV->re_class.bitmap[i] |= ~space_chars[i];
        -:  390:}
        2:  391:
        3:  392:
        -:  393:<char_class>\\d {
        -:  394:
        -:  395:  char c;
        -:  396:
       33:  397:  for (c = '0'; c <= '9'; c++)
       30:  398:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  399:}
        3:  400:
        2:  401:
        -:  402:<char_class>\\D {
        -:  403:
        -:  404:  int i;
        -:  405:
       66:  406:  for (i = 0; i < 32; i++)
        -:  407:  {
        -:  408:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
       64:  409:    if (i == 6)
        2:  410:      continue;
        -:  411:
        -:  412:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -:  413:    // vector, let those bits alone.
       62:  414:    if (i == 7)
        2:  415:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -:  416:    else
       60:  417:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  418:  }
        -:  419:}
        2:  420:
       11:  421:
        -:  422:<char_class>\\ {
        -:  423:
        -:  424:  uint8_t c;
        -:  425:
       11:  426:  if (read_escaped_char(yyscanner, &c))
        -:  427:  {
       11:  428:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  429:  }
        -:  430:  else
        -:  431:  {
    #####:  432:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  433:    yyterminate();
        -:  434:  }
        -:  435:}
       11:  436:
       69:  437:
        -:  438:<char_class>. {
        -:  439:
       69:  440:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  441:  {
        -:  442:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -:  443:    // here we set to 1 the vector's bit corresponding to the input character.
        -:  444:
       69:  445:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -:  446:  }
        -:  447:  else
        -:  448:  {
    #####:  449:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  450:    yyterminate();
        -:  451:  }
        -:  452:}
       69:  453:
        1:  454:
        -:  455:<char_class><<EOF>> {
        -:  456:
        -:  457:  // End of regexp reached while scanning a character class.
        -:  458:
        1:  459:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
        1:  460:  yyterminate();
        -:  461:}
        -:  462:
      363:  463:
        -:  464:. {
        -:  465:
      363:  466:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  467:  {
      363:  468:    return yytext[0];
        -:  469:  }
        -:  470:  else
        -:  471:  {
    #####:  472:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  473:    yyterminate();
        -:  474:  }
        -:  475:}
        -:  476:
      285:  477:
        -:  478:<<EOF>> {
        -:  479:
      285:  480:  yyterminate();
        -:  481:}
        -:  482:
    #####:  483:%%
    #####:  484:
       35:  485:int escaped_char_value(
        -:  486:    char* text,
        -:  487:    uint8_t* value)
        -:  488:{
        -:  489:  unsigned int hex_value;
        -:  490:  char hex[3];
        -:  491:
      35*:  492:  assert(text[0] == '\\');
        -:  493:
       35:  494:  switch(text[1])
        -:  495:  {
       16:  496:  case 'x':
       16:  497:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
        1:  498:      return 0;
       15:  499:    hex[0] = text[2];
       15:  500:    hex[1] = text[3];
       15:  501:    hex[2] = '\0';
       15:  502:    sscanf(hex, "%x", &hex_value);
       15:  503:    *value = (uint8_t) hex_value;
       15:  504:    break;
        -:  505:
        2:  506:  case 'n':
        2:  507:    *value = '\n';
        2:  508:    break;
        -:  509:
        3:  510:  case 't':
        3:  511:    *value = '\t';
        3:  512:    break;
        -:  513:
        2:  514:  case 'r':
        2:  515:    *value = '\r';
        2:  516:    break;
        -:  517:
        2:  518:  case 'f':
        2:  519:    *value = '\f';
        2:  520:    break;
        -:  521:
        2:  522:  case 'a':
        2:  523:    *value = '\a';
        2:  524:    break;
        -:  525:
        8:  526:  default:
        8:  527:    *value = text[1];
        -:  528:  }
        -:  529:
       34:  530:  return 1;
        -:  531:}
        -:  532:
        -:  533:
        -:  534:#ifdef __cplusplus
        -:  535:#define RE_YY_INPUT yyinput
        -:  536:#else
        -:  537:#define RE_YY_INPUT input
        -:  538:#endif
        -:  539:
        -:  540:
       32:  541:int read_escaped_char(
        -:  542:    yyscan_t yyscanner,
        -:  543:    uint8_t* escaped_char)
        -:  544:{
       32:  545:  char text[4] = {0, 0, 0, 0};
        -:  546:
       32:  547:  text[0] = '\\';
       32:  548:  text[1] = RE_YY_INPUT(yyscanner);
        -:  549:
       32:  550:  if (text[1] == EOF || text[1] == 0)
    #####:  551:    return 0;
        -:  552:
       32:  553:  if (text[1] == 'x')
        -:  554:  {
       13:  555:    text[2] = RE_YY_INPUT(yyscanner);
        -:  556:
       13:  557:    if (text[2] == EOF || text[2] == 0)
        1:  558:      return 0;
        -:  559:
       12:  560:    text[3] = RE_YY_INPUT(yyscanner);
        -:  561:
       12:  562:    if (text[3] == EOF || text[3] == 0)
        1:  563:      return 0;
        -:  564:  }
        -:  565:
       30:  566:  return escaped_char_value(text, escaped_char);
        -:  567:}
        -:  568:
        -:  569:
    #####:  570:void yyfatal(
        -:  571:    yyscan_t yyscanner,
        -:  572:    const char *error_message)
        -:  573:{
    #####:  574:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
        -:  575:      &yr_recovery_state_key);
        -:  576:
    #####:  577:  longjmp(*recovery_state, 1);
        -:  578:}
        -:  579:
        -:  580:
       17:  581:void yyerror(
        -:  582:    yyscan_t yyscanner,
        -:  583:    RE_LEX_ENVIRONMENT* lex_env,
        -:  584:    const char *error_message)
        -:  585:{
        -:  586:  // if lex_env->last_error was set to some error code before
        -:  587:  // don't overwrite it, we are interested in the first error, not in
        -:  588:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  589:  // early parser termination.
        -:  590:
       17:  591:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  592:  {
       13:  593:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  594:
       13:  595:    strlcpy(
       13:  596:        lex_env->last_error_message,
        -:  597:        error_message,
        -:  598:        sizeof(lex_env->last_error_message));
        -:  599:  }
       17:  600:}
        -:  601:
        -:  602:
      293:  603:int yr_parse_re_string(
        -:  604:  const char* re_string,
        -:  605:  RE_AST** re_ast,
        -:  606:  RE_ERROR* error)
        -:  607:{
        -:  608:  yyscan_t yyscanner;
        -:  609:  jmp_buf recovery_state;
        -:  610:  RE_LEX_ENVIRONMENT lex_env;
        -:  611:
      293:  612:  lex_env.last_error = ERROR_SUCCESS;
      293:  613:  lex_env.last_error_message[0] = '\0';
        -:  614:
      293:  615:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
        -:  616:
      293:  617:  if (setjmp(recovery_state) != 0)
    #####:  618:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  619:
     293*:  620:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  621:
      293:  622:  yylex_init(&yyscanner);
      293:  623:  yyset_extra(*re_ast, yyscanner);
      293:  624:  yy_scan_string(re_string, yyscanner);
      293:  625:  yyparse(yyscanner, &lex_env);
      293:  626:  yylex_destroy(yyscanner);
        -:  627:
      293:  628:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  629:  {
       13:  630:    yr_re_ast_destroy(*re_ast);
       13:  631:    *re_ast = NULL;
        -:  632:
       13:  633:    strlcpy(
       13:  634:        error->message,
        -:  635:        lex_env.last_error_message,
        -:  636:        sizeof(error->message));
        -:  637:
       13:  638:    return lex_env.last_error;
        -:  639:  }
        -:  640:
      280:  641:  return ERROR_SUCCESS;
        -:  642:}
