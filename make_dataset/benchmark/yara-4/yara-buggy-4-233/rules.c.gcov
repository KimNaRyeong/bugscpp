        -:    0:Source:rules.c
        -:    0:Graph:/home/workspace/libyara/rules.gcno
        -:    0:Data:/home/workspace/libyara/rules.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:
        -:   34:#include <yara/error.h>
        -:   35:#include <yara/filemap.h>
        -:   36:#include <yara/mem.h>
        -:   37:#include <yara/proc.h>
        -:   38:#include <yara/rules.h>
        -:   39:#include <yara/utils.h>
        -:   40:#include <yara/globals.h>
        -:   41:#include <yara/scan.h>
        -:   42:#include <yara/scanner.h>
        -:   43:
        -:   44:
    #####:   45:YR_API int yr_rules_define_integer_variable(
        -:   46:    YR_RULES* rules,
        -:   47:    const char* identifier,
        -:   48:    int64_t value)
        -:   49:{
        -:   50:  YR_EXTERNAL_VARIABLE* external;
        -:   51:
    #####:   52:  if (identifier == NULL)
    #####:   53:    return ERROR_INVALID_ARGUMENT;
        -:   54:
    #####:   55:  external = rules->externals_list_head;
        -:   56:
    #####:   57:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   58:  {
    #####:   59:    if (strcmp(external->identifier, identifier) == 0)
        -:   60:    {
    #####:   61:      if (external->type != EXTERNAL_VARIABLE_TYPE_INTEGER)
    #####:   62:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   63:
    #####:   64:      external->value.i = value;
    #####:   65:      return ERROR_SUCCESS;
        -:   66:    }
        -:   67:
    #####:   68:    external++;
        -:   69:  }
        -:   70:
    #####:   71:  return ERROR_INVALID_ARGUMENT;
        -:   72:}
        -:   73:
        -:   74:
    #####:   75:YR_API int yr_rules_define_boolean_variable(
        -:   76:    YR_RULES* rules,
        -:   77:    const char* identifier,
        -:   78:    int value)
        -:   79:{
        -:   80:  YR_EXTERNAL_VARIABLE* external;
        -:   81:
    #####:   82:  if (identifier == NULL)
    #####:   83:    return ERROR_INVALID_ARGUMENT;
        -:   84:
    #####:   85:  external = rules->externals_list_head;
        -:   86:
    #####:   87:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   88:  {
    #####:   89:    if (strcmp(external->identifier, identifier) == 0)
        -:   90:    {
    #####:   91:      if (external->type != EXTERNAL_VARIABLE_TYPE_BOOLEAN)
    #####:   92:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   93:
    #####:   94:      external->value.i = value;
    #####:   95:      return ERROR_SUCCESS;
        -:   96:    }
        -:   97:
    #####:   98:    external++;
        -:   99:  }
        -:  100:
    #####:  101:  return ERROR_INVALID_ARGUMENT;
        -:  102:}
        -:  103:
        -:  104:
    #####:  105:YR_API int yr_rules_define_float_variable(
        -:  106:    YR_RULES* rules,
        -:  107:    const char* identifier,
        -:  108:    double value)
        -:  109:{
        -:  110:  YR_EXTERNAL_VARIABLE* external;
        -:  111:
    #####:  112:  if (identifier == NULL)
    #####:  113:    return ERROR_INVALID_ARGUMENT;
        -:  114:
    #####:  115:  external = rules->externals_list_head;
        -:  116:
    #####:  117:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  118:  {
    #####:  119:    if (strcmp(external->identifier, identifier) == 0)
        -:  120:    {
    #####:  121:      if (external->type != EXTERNAL_VARIABLE_TYPE_FLOAT)
    #####:  122:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  123:
    #####:  124:      external->value.f = value;
    #####:  125:      return ERROR_SUCCESS;
        -:  126:    }
        -:  127:
    #####:  128:    external++;
        -:  129:  }
        -:  130:
    #####:  131:  return ERROR_INVALID_ARGUMENT;
        -:  132:}
        -:  133:
        -:  134:
    #####:  135:YR_API int yr_rules_define_string_variable(
        -:  136:    YR_RULES* rules,
        -:  137:    const char* identifier,
        -:  138:    const char* value)
        -:  139:{
        -:  140:  YR_EXTERNAL_VARIABLE* external;
        -:  141:
    #####:  142:  if (identifier == NULL || value == NULL)
    #####:  143:    return ERROR_INVALID_ARGUMENT;
        -:  144:
    #####:  145:  external = rules->externals_list_head;
        -:  146:
    #####:  147:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  148:  {
    #####:  149:    if (strcmp(external->identifier, identifier) == 0)
        -:  150:    {
    #####:  151:      if (external->type != EXTERNAL_VARIABLE_TYPE_STRING &&
    #####:  152:          external->type != EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  153:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  154:
    #####:  155:      if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING &&
    #####:  156:          external->value.s != NULL)
        -:  157:      {
    #####:  158:        yr_free(external->value.s);
        -:  159:      }
        -:  160:
    #####:  161:      external->type = EXTERNAL_VARIABLE_TYPE_MALLOC_STRING;
    #####:  162:      external->value.s = yr_strdup(value);
        -:  163:
    #####:  164:      if (external->value.s == NULL)
    #####:  165:        return ERROR_INSUFFICIENT_MEMORY;
        -:  166:      else
    #####:  167:        return ERROR_SUCCESS;
        -:  168:    }
        -:  169:
    #####:  170:    external++;
        -:  171:  }
        -:  172:
    #####:  173:  return ERROR_INVALID_ARGUMENT;
        -:  174:}
        -:  175:
        -:  176:
        -:  177:#ifdef PROFILING_ENABLED
        -:  178:YR_API void yr_rules_print_profiling_info(
        -:  179:    YR_RULES* rules)
        -:  180:{
        -:  181:  YR_RULE* rule;
        -:  182:
        -:  183:  printf("\n===== PROFILING INFORMATION =====\n\n");
        -:  184:
        -:  185:  yr_rules_foreach(rules, rule)
        -:  186:  {
        -:  187:    printf(
        -:  188:        "%s:%s: %" PRIu64 " (%0.3f%%)\n",
        -:  189:        rule->ns->name,
        -:  190:        rule->identifier,
        -:  191:        rule->time_cost,
        -:  192:        (float) rule->time_cost / rules->time_cost * 100);
        -:  193:  }
        -:  194:
        -:  195:  printf("\n=================================\n");
        -:  196:}
        -:  197:#endif
        -:  198:
        -:  199:
    #####:  200:YR_API void yr_rules_reset_profiling_info(
        -:  201:    YR_RULES* rules)
        -:  202:{
        -:  203:  #ifdef PROFILING_ENABLED
        -:  204:  YR_RULE* rule;
        -:  205:
        -:  206:  yr_rules_foreach(rules, rule)
        -:  207:  {
        -:  208:    #ifdef _WIN32
        -:  209:    InterlockedExchange64(&rule->time_cost, 0);
        -:  210:    #else
        -:  211:    __sync_fetch_and_and(&rule->time_cost, 0);
        -:  212:    #endif
        -:  213:  }
        -:  214:  #endif
    #####:  215:}
        -:  216:
        -:  217:
      280:  218:YR_API int yr_rules_scan_mem_blocks(
        -:  219:    YR_RULES* rules,
        -:  220:    YR_MEMORY_BLOCK_ITERATOR* iterator,
        -:  221:    int flags,
        -:  222:    YR_CALLBACK_FUNC callback,
        -:  223:    void* user_data,
        -:  224:    int timeout)
        -:  225:{
        -:  226:  YR_SCANNER* scanner;
        -:  227:  int result;
        -:  228:
     280*:  229:  FAIL_ON_ERROR(yr_scanner_create(rules, &scanner));
        -:  230:
      280:  231:  yr_scanner_set_callback(scanner, callback, user_data);
      280:  232:  yr_scanner_set_timeout(scanner, timeout);
      280:  233:  yr_scanner_set_flags(scanner, flags);
        -:  234:
      280:  235:  result = yr_scanner_scan_mem_blocks(scanner, iterator);
        -:  236:
      280:  237:  yr_scanner_destroy(scanner);
        -:  238:
      280:  239:  return result;
        -:  240:}
        -:  241:
        -:  242:
      280:  243:static YR_MEMORY_BLOCK* _yr_get_first_block(
        -:  244:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  245:{
      280:  246:  return (YR_MEMORY_BLOCK*) iterator->context;
        -:  247:}
        -:  248:
        -:  249:
      280:  250:static YR_MEMORY_BLOCK* _yr_get_next_block(
        -:  251:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  252:{
      280:  253:  return NULL;
        -:  254:}
        -:  255:
        -:  256:
      280:  257:static const uint8_t* _yr_fetch_block_data(
        -:  258:    YR_MEMORY_BLOCK* block)
        -:  259:{
      280:  260:  return (const uint8_t*) block->context;
        -:  261:}
        -:  262:
        -:  263:
      280:  264:YR_API int yr_rules_scan_mem(
        -:  265:    YR_RULES* rules,
        -:  266:    const uint8_t* buffer,
        -:  267:    size_t buffer_size,
        -:  268:    int flags,
        -:  269:    YR_CALLBACK_FUNC callback,
        -:  270:    void* user_data,
        -:  271:    int timeout)
        -:  272:{
        -:  273:  YR_MEMORY_BLOCK block;
        -:  274:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  275:
      280:  276:  block.size = buffer_size;
      280:  277:  block.base = 0;
      280:  278:  block.fetch_data = _yr_fetch_block_data;
      280:  279:  block.context = (void*) buffer;
        -:  280:
      280:  281:  iterator.context = &block;
      280:  282:  iterator.first = _yr_get_first_block;
      280:  283:  iterator.next = _yr_get_next_block;
        -:  284:
      280:  285:  return yr_rules_scan_mem_blocks(
        -:  286:      rules,
        -:  287:      &iterator,
        -:  288:      flags,
        -:  289:      callback,
        -:  290:      user_data,
        -:  291:      timeout);
        -:  292:}
        -:  293:
        -:  294:
    #####:  295:YR_API int yr_rules_scan_file(
        -:  296:    YR_RULES* rules,
        -:  297:    const char* filename,
        -:  298:    int flags,
        -:  299:    YR_CALLBACK_FUNC callback,
        -:  300:    void* user_data,
        -:  301:    int timeout)
        -:  302:{
        -:  303:  YR_MAPPED_FILE mfile;
        -:  304:
    #####:  305:  int result = yr_filemap_map(filename, &mfile);
        -:  306:
    #####:  307:  if (result == ERROR_SUCCESS)
        -:  308:  {
    #####:  309:    result = yr_rules_scan_mem(
        -:  310:        rules,
        -:  311:        mfile.data,
        -:  312:        mfile.size,
        -:  313:        flags,
        -:  314:        callback,
        -:  315:        user_data,
        -:  316:        timeout);
        -:  317:
    #####:  318:    yr_filemap_unmap(&mfile);
        -:  319:  }
        -:  320:
    #####:  321:  return result;
        -:  322:}
        -:  323:
        -:  324:
    #####:  325:YR_API int yr_rules_scan_fd(
        -:  326:    YR_RULES* rules,
        -:  327:    YR_FILE_DESCRIPTOR fd,
        -:  328:    int flags,
        -:  329:    YR_CALLBACK_FUNC callback,
        -:  330:    void* user_data,
        -:  331:    int timeout)
        -:  332:{
        -:  333:  YR_MAPPED_FILE mfile;
        -:  334:
    #####:  335:  int result = yr_filemap_map_fd(fd, 0, 0, &mfile);
        -:  336:
    #####:  337:  if (result == ERROR_SUCCESS)
        -:  338:  {
    #####:  339:    result = yr_rules_scan_mem(
        -:  340:        rules,
        -:  341:        mfile.data,
        -:  342:        mfile.size,
        -:  343:        flags,
        -:  344:        callback,
        -:  345:        user_data,
        -:  346:        timeout);
        -:  347:
    #####:  348:    yr_filemap_unmap_fd(&mfile);
        -:  349:  }
        -:  350:
    #####:  351:  return result;
        -:  352:}
        -:  353:
        -:  354:
    #####:  355:YR_API int yr_rules_scan_proc(
        -:  356:    YR_RULES* rules,
        -:  357:    int pid,
        -:  358:    int flags,
        -:  359:    YR_CALLBACK_FUNC callback,
        -:  360:    void* user_data,
        -:  361:    int timeout)
        -:  362:{
        -:  363:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  364:
    #####:  365:  int result = yr_process_open_iterator(
        -:  366:      pid,
        -:  367:      &iterator);
        -:  368:
    #####:  369:  if (result == ERROR_SUCCESS)
        -:  370:  {
    #####:  371:    result = yr_rules_scan_mem_blocks(
        -:  372:        rules,
        -:  373:        &iterator,
        -:  374:        flags | SCAN_FLAGS_PROCESS_MEMORY,
        -:  375:        callback,
        -:  376:        user_data,
        -:  377:        timeout);
        -:  378:
    #####:  379:    yr_process_close_iterator(&iterator);
        -:  380:  }
        -:  381:
    #####:  382:  return result;
        -:  383:}
        -:  384:
        -:  385:
    #####:  386:YR_API int yr_rules_load_stream(
        -:  387:    YR_STREAM* stream,
        -:  388:    YR_RULES** rules)
        -:  389:{
        -:  390:  YARA_RULES_FILE_HEADER* header;
    #####:  391:  YR_RULES* new_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));
        -:  392:
    #####:  393:  if (new_rules == NULL)
    #####:  394:    return ERROR_INSUFFICIENT_MEMORY;
        -:  395:
    #####:  396:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  397:      yr_arena_load_stream(stream, &new_rules->arena),
        -:  398:      // cleanup
        -:  399:      yr_free(new_rules));
        -:  400:
        -:  401:  header = (YARA_RULES_FILE_HEADER*)
    #####:  402:      yr_arena_base_address(new_rules->arena);
        -:  403:
    #####:  404:  new_rules->code_start = header->code_start;
    #####:  405:  new_rules->externals_list_head = header->externals_list_head;
    #####:  406:  new_rules->rules_list_head = header->rules_list_head;
    #####:  407:  new_rules->ac_match_table = header->ac_match_table;
    #####:  408:  new_rules->ac_transition_table = header->ac_transition_table;
    #####:  409:  new_rules->ac_tables_size = header->ac_tables_size;
        -:  410:
    #####:  411:  memset(new_rules->tidx_mask, 0, sizeof(new_rules->tidx_mask));
        -:  412:
    #####:  413:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  414:      yr_mutex_create(&new_rules->mutex),
        -:  415:      // cleanup
        -:  416:      yr_free(new_rules));
        -:  417:
    #####:  418:  *rules = new_rules;
        -:  419:
    #####:  420:  return ERROR_SUCCESS;
        -:  421:}
        -:  422:
        -:  423:
    #####:  424:YR_API int yr_rules_load(
        -:  425:    const char* filename,
        -:  426:    YR_RULES** rules)
        -:  427:{
        -:  428:  int result;
        -:  429:
        -:  430:  YR_STREAM stream;
    #####:  431:  FILE* fh = fopen(filename, "rb");
        -:  432:
    #####:  433:  if (fh == NULL)
    #####:  434:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  435:
    #####:  436:  stream.user_data = fh;
    #####:  437:  stream.read = (YR_STREAM_READ_FUNC) fread;
        -:  438:
    #####:  439:  result = yr_rules_load_stream(&stream, rules);
        -:  440:
    #####:  441:  fclose(fh);
    #####:  442:  return result;
        -:  443:}
        -:  444:
        -:  445:
    #####:  446:YR_API int yr_rules_save_stream(
        -:  447:    YR_RULES* rules,
        -:  448:    YR_STREAM* stream)
        -:  449:{
        -:  450:  int i;
        -:  451:
    #####:  452:  for (i = 0; i < YR_BITARRAY_NCHARS(YR_MAX_THREADS); ++i)
    #####:  453:    assert(rules->tidx_mask[i] == 0);
        -:  454:
    #####:  455:  return yr_arena_save_stream(rules->arena, stream);
        -:  456:}
        -:  457:
        -:  458:
    #####:  459:YR_API int yr_rules_save(
        -:  460:    YR_RULES* rules,
        -:  461:    const char* filename)
        -:  462:{
        -:  463:  int result;
        -:  464:
        -:  465:  YR_STREAM stream;
    #####:  466:  FILE* fh = fopen(filename, "wb");
        -:  467:
    #####:  468:  if (fh == NULL)
    #####:  469:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  470:
    #####:  471:  stream.user_data = fh;
    #####:  472:  stream.write = (YR_STREAM_WRITE_FUNC) fwrite;
        -:  473:
    #####:  474:  result = yr_rules_save_stream(rules, &stream);
        -:  475:
    #####:  476:  fclose(fh);
    #####:  477:  return result;
        -:  478:}
        -:  479:
        -:  480:
    #####:  481:static int _uint32_cmp (
        -:  482:    const void * a,
        -:  483:    const void * b)
        -:  484:{
    #####:  485:   return (*(uint32_t*) a - *(uint32_t*) b);
        -:  486:}
        -:  487:
    #####:  488:YR_API int yr_rules_get_stats(
        -:  489:    YR_RULES* rules,
        -:  490:    YR_RULES_STATS *stats)
        -:  491:{
        -:  492:  YR_RULE* rule;
        -:  493:  YR_STRING* string;
        -:  494:
    #####:  495:  uint32_t* match_list_lengths = (uint32_t*) yr_malloc(
    #####:  496:      sizeof(uint32_t) * rules->ac_tables_size);
        -:  497:
    #####:  498:  float match_list_length_sum = 0;
    #####:  499:  int i, c = 0;
        -:  500:
    #####:  501:  if (match_list_lengths == NULL)
    #####:  502:    return ERROR_INSUFFICIENT_MEMORY;
        -:  503:
    #####:  504:  memset(stats, 0, sizeof(YR_RULES_STATS));
        -:  505:
    #####:  506:  yr_rules_foreach(rules, rule)
        -:  507:  {
    #####:  508:    stats->rules++;
    #####:  509:    yr_rule_strings_foreach(rule, string)
    #####:  510:      stats->strings++;
        -:  511:  }
        -:  512:
    #####:  513:  stats->ac_tables_size = rules->ac_tables_size;
        -:  514:
    #####:  515:  for (i = 0; i < rules->ac_tables_size; i++)
        -:  516:  {
    #####:  517:    YR_AC_MATCH* match = rules->ac_match_table[i].match;
        -:  518:
    #####:  519:    int match_list_length = 0;
        -:  520:
    #####:  521:    while (match != NULL)
        -:  522:    {
    #####:  523:      match_list_length++;
    #####:  524:      stats->ac_matches++;
    #####:  525:      match = match->next;
        -:  526:    }
        -:  527:
    #####:  528:    if (i == 0)
    #####:  529:      stats->ac_root_match_list_length = match_list_length;
        -:  530:
    #####:  531:    match_list_length_sum += match_list_length;
        -:  532:
    #####:  533:    if (match_list_length > 0)
        -:  534:    {
    #####:  535:      match_list_lengths[c] = match_list_length;
    #####:  536:      c++;
        -:  537:    }
        -:  538:  }
        -:  539:
    #####:  540:  if (c == 0)
        -:  541:  {
    #####:  542:    yr_free(match_list_lengths);
    #####:  543:    return ERROR_SUCCESS;
        -:  544:  }
        -:  545:
        -:  546:  // sort match_list_lengths in increasing order for computing percentiles.
    #####:  547:  qsort(match_list_lengths, c, sizeof(match_list_lengths[0]), _uint32_cmp);
        -:  548:
    #####:  549:  for (i = 0; i < 100; i++)
        -:  550:  {
    #####:  551:    if (i < c)
    #####:  552:      stats->top_ac_match_list_lengths[i] = match_list_lengths[c-i-1];
        -:  553:    else
    #####:  554:      stats->top_ac_match_list_lengths[i] = 0;
        -:  555:  }
        -:  556:
    #####:  557:  stats->ac_average_match_list_length = match_list_length_sum / c;
    #####:  558:  stats->ac_match_list_length_pctls[0] = match_list_lengths[0];
    #####:  559:  stats->ac_match_list_length_pctls[100] = match_list_lengths[c-1];
        -:  560:
    #####:  561:  for (i = 1; i < 100; i++)
    #####:  562:    stats->ac_match_list_length_pctls[i] = match_list_lengths[(c * i) / 100];
        -:  563:
    #####:  564:  yr_free(match_list_lengths);
        -:  565:
    #####:  566:  return ERROR_SUCCESS;
        -:  567:}
        -:  568:
        -:  569:
      280:  570:YR_API int yr_rules_destroy(
        -:  571:    YR_RULES* rules)
        -:  572:{
      280:  573:  YR_EXTERNAL_VARIABLE* external = rules->externals_list_head;
        -:  574:
      280:  575:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  576:  {
    #####:  577:    if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  578:      yr_free(external->value.s);
        -:  579:
    #####:  580:    external++;
        -:  581:  }
        -:  582:
      280:  583:  yr_mutex_destroy(&rules->mutex);
      280:  584:  yr_arena_destroy(rules->arena);
      280:  585:  yr_free(rules);
        -:  586:
      280:  587:  return ERROR_SUCCESS;
        -:  588:}
        -:  589:
    #####:  590:YR_API void yr_rule_disable(
        -:  591:    YR_RULE* rule)
        -:  592:{
        -:  593:  YR_STRING* string;
        -:  594:
    #####:  595:  rule->g_flags |= RULE_GFLAGS_DISABLED;
        -:  596:
    #####:  597:  yr_rule_strings_foreach(rule, string)
        -:  598:  {
    #####:  599:    string->g_flags |= STRING_GFLAGS_DISABLED;
        -:  600:  }
    #####:  601:}
        -:  602:
        -:  603:
    #####:  604:YR_API void yr_rule_enable(
        -:  605:    YR_RULE* rule)
        -:  606:{
        -:  607:  YR_STRING* string;
        -:  608:
    #####:  609:  rule->g_flags &= ~RULE_GFLAGS_DISABLED;
        -:  610:
    #####:  611:  yr_rule_strings_foreach(rule, string)
        -:  612:  {
    #####:  613:    string->g_flags &= ~STRING_GFLAGS_DISABLED;
        -:  614:  }
    #####:  615:}
