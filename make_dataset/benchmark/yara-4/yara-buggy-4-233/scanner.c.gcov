        -:    0:Source:scanner.c
        -:    0:Graph:/home/workspace/libyara/scanner.gcno
        -:    0:Data:/home/workspace/libyara/scanner.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <stdlib.h>
        -:   31:
        -:   32:#include <yara/ahocorasick.h>
        -:   33:#include <yara/error.h>
        -:   34:#include <yara/exec.h>
        -:   35:#include <yara/exefiles.h>
        -:   36:#include <yara/mem.h>
        -:   37:#include <yara/object.h>
        -:   38:#include <yara/proc.h>
        -:   39:#include <yara/scanner.h>
        -:   40:#include <yara/types.h>
        -:   41:#include <yara/libyara.h>
        -:   42:
        -:   43:#include "exception.h"
        -:   44:
        -:   45:
      280:   46:static int _yr_scanner_scan_mem_block(
        -:   47:    YR_SCANNER* scanner,
        -:   48:    const uint8_t* block_data,
        -:   49:    YR_MEMORY_BLOCK* block)
        -:   50:{
      280:   51:  YR_RULES* rules = scanner->rules;
      280:   52:  YR_AC_TRANSITION_TABLE transition_table = rules->ac_transition_table;
      280:   53:  YR_AC_MATCH_TABLE match_table = rules->ac_match_table;
        -:   54:
        -:   55:  YR_AC_MATCH* match;
        -:   56:  YR_AC_TRANSITION transition;
        -:   57:
      280:   58:  size_t i = 0;
      280:   59:  uint32_t state = YR_AC_ROOT_STATE;
        -:   60:  uint16_t index;
        -:   61:
     2965:   62:  while (i < block->size)
        -:   63:  {
     2685:   64:    match = match_table[state].match;
        -:   65:
     2685:   66:    if (i % 4096 == 0 && scanner->timeout > 0)
        -:   67:    {
    #####:   68:      if (yr_stopwatch_elapsed_us(&scanner->stopwatch) > scanner->timeout)
    #####:   69:        return ERROR_SCAN_TIMEOUT;
        -:   70:    }
        -:   71:
     3177:   72:    while (match != NULL)
        -:   73:    {
      492:   74:      if (match->backtrack <= i)
        -:   75:      {
     492*:   76:        FAIL_ON_ERROR(yr_scan_verify_match(
        -:   77:            scanner,
        -:   78:            match,
        -:   79:            block_data,
        -:   80:            block->size,
        -:   81:            block->base,
        -:   82:            i - match->backtrack));
        -:   83:      }
        -:   84:
      492:   85:      match = match->next;
        -:   86:    }
        -:   87:
     2685:   88:    index = block_data[i++] + 1;
     2685:   89:    transition = transition_table[state + index];
        -:   90:
     3033:   91:    while (YR_AC_INVALID_TRANSITION(transition, index))
        -:   92:    {
     2110:   93:      if (state != YR_AC_ROOT_STATE)
        -:   94:      {
      348:   95:        state = YR_AC_NEXT_STATE(transition_table[state]);
      348:   96:        transition = transition_table[state + index];
        -:   97:      }
        -:   98:      else
        -:   99:      {
     1762:  100:        transition = 0;
     1762:  101:        break;
        -:  102:      }
        -:  103:    }
        -:  104:
     2685:  105:    state = YR_AC_NEXT_STATE(transition);
        -:  106:  }
        -:  107:
      280:  108:  match = match_table[state].match;
        -:  109:
      368:  110:  while (match != NULL)
        -:  111:  {
       88:  112:    if (match->backtrack <= i)
        -:  113:    {
      88*:  114:      FAIL_ON_ERROR(yr_scan_verify_match(
        -:  115:          scanner,
        -:  116:          match,
        -:  117:          block_data,
        -:  118:          block->size,
        -:  119:          block->base,
        -:  120:          i - match->backtrack));
        -:  121:    }
        -:  122:
       88:  123:    match = match->next;
        -:  124:  }
        -:  125:
      280:  126:  return ERROR_SUCCESS;
        -:  127:}
        -:  128:
        -:  129:
      280:  130:static void _yr_scanner_clean_matches(
        -:  131:    YR_SCANNER* scanner)
        -:  132:{
        -:  133:  YR_RULE* rule;
        -:  134:  YR_STRING** string;
        -:  135:
      280:  136:  int tidx = scanner->tidx;
        -:  137:
      560:  138:  yr_rules_foreach(scanner->rules, rule)
        -:  139:  {
      280:  140:    rule->t_flags[tidx] &= ~RULE_TFLAGS_MATCH;
      280:  141:    rule->ns->t_flags[tidx] &= ~NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
        -:  142:  }
        -:  143:
      280:  144:  if (scanner->matching_strings_arena != NULL)
        -:  145:  {
      280:  146:    string = (YR_STRING**) yr_arena_base_address(
        -:  147:        scanner->matching_strings_arena);
        -:  148:
      489:  149:    while (string != NULL)
        -:  150:    {
      209:  151:      (*string)->matches[tidx].count = 0;
      209:  152:      (*string)->matches[tidx].head = NULL;
      209:  153:      (*string)->matches[tidx].tail = NULL;
      209:  154:      (*string)->private_matches[tidx].count = 0;
      209:  155:      (*string)->private_matches[tidx].head = NULL;
      209:  156:      (*string)->private_matches[tidx].tail = NULL;
      209:  157:      (*string)->unconfirmed_matches[tidx].count = 0;
      209:  158:      (*string)->unconfirmed_matches[tidx].head = NULL;
      209:  159:      (*string)->unconfirmed_matches[tidx].tail = NULL;
        -:  160:
      209:  161:      string = (YR_STRING**) yr_arena_next_address(
        -:  162:          scanner->matching_strings_arena,
        -:  163:          string,
        -:  164:          sizeof(YR_STRING*));
        -:  165:    }
        -:  166:  }
      280:  167:}
        -:  168:
        -:  169:
      280:  170:YR_API int yr_scanner_create(
        -:  171:    YR_RULES* rules,
        -:  172:    YR_SCANNER** scanner)
        -:  173:{
        -:  174:  YR_EXTERNAL_VARIABLE* external;
        -:  175:  YR_SCANNER* new_scanner;
        -:  176:
      280:  177:  new_scanner = (YR_SCANNER*) yr_calloc(1, sizeof(YR_SCANNER));
        -:  178:
      280:  179:  if (new_scanner == NULL)
    #####:  180:    return ERROR_INSUFFICIENT_MEMORY;
        -:  181:
     280*:  182:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  183:      yr_hash_table_create(64, &new_scanner->objects_table),
        -:  184:      yr_scanner_destroy(new_scanner));
        -:  185:
      280:  186:  new_scanner->rules = rules;
      280:  187:  new_scanner->tidx = -1;
      280:  188:  new_scanner->entry_point = UNDEFINED;
      280:  189:  new_scanner->canary = rand();
        -:  190:
      280:  191:  external = rules->externals_list_head;
        -:  192:
      280:  193:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  194:  {
        -:  195:    YR_OBJECT* object;
        -:  196:
    #####:  197:    FAIL_ON_ERROR_WITH_CLEANUP(
        -:  198:        yr_object_from_external_variable(external, &object),
        -:  199:        yr_scanner_destroy(new_scanner));
        -:  200:
    #####:  201:    FAIL_ON_ERROR_WITH_CLEANUP(
        -:  202:        yr_hash_table_add(
        -:  203:            new_scanner->objects_table,
        -:  204:            external->identifier,
        -:  205:            NULL,
        -:  206:            (void*) object),
        -:  207:        yr_scanner_destroy(new_scanner));
        -:  208:
    #####:  209:    yr_object_set_canary(object, new_scanner->canary);
    #####:  210:    external++;
        -:  211:  }
        -:  212:
      280:  213:  *scanner = new_scanner;
        -:  214:
      280:  215:  return ERROR_SUCCESS;
        -:  216:}
        -:  217:
        -:  218:
      280:  219:YR_API void yr_scanner_destroy(
        -:  220:    YR_SCANNER* scanner)
        -:  221:{
        -:  222:  RE_FIBER* fiber;
        -:  223:  RE_FIBER* next_fiber;
        -:  224:
      280:  225:  fiber = scanner->re_fiber_pool.fibers.head;
        -:  226:
      789:  227:  while (fiber != NULL)
        -:  228:  {
      509:  229:    next_fiber = fiber->next;
      509:  230:    yr_free(fiber);
      509:  231:    fiber = next_fiber;
        -:  232:  }
        -:  233:
      280:  234:  if (scanner->objects_table != NULL)
        -:  235:  {
      280:  236:    yr_hash_table_destroy(
        -:  237:        scanner->objects_table,
        -:  238:        (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);
        -:  239:  }
        -:  240:
      280:  241:  yr_free(scanner);
      280:  242:}
        -:  243:
        -:  244:
      280:  245:YR_API void yr_scanner_set_callback(
        -:  246:    YR_SCANNER* scanner,
        -:  247:    YR_CALLBACK_FUNC callback,
        -:  248:    void* user_data)
        -:  249:{
      280:  250:  scanner->callback = callback;
      280:  251:  scanner->user_data = user_data;
      280:  252:}
        -:  253:
        -:  254:
      280:  255:YR_API void yr_scanner_set_timeout(
        -:  256:    YR_SCANNER* scanner,
        -:  257:    int timeout)
        -:  258:{
      280:  259:  scanner->timeout = timeout * 1000000L;  // convert timeout to microseconds.
      280:  260:}
        -:  261:
        -:  262:
      280:  263:YR_API void yr_scanner_set_flags(
        -:  264:    YR_SCANNER* scanner,
        -:  265:    int flags)
        -:  266:{
      280:  267:  scanner->flags = flags;
      280:  268:}
        -:  269:
        -:  270:
    #####:  271:YR_API int yr_scanner_define_integer_variable(
        -:  272:    YR_SCANNER* scanner,
        -:  273:    const char* identifier,
        -:  274:    int64_t value)
        -:  275:{
    #####:  276:  YR_OBJECT* obj = (YR_OBJECT*) yr_hash_table_lookup(
        -:  277:      scanner->objects_table,
        -:  278:      identifier,
        -:  279:      NULL);
        -:  280:
    #####:  281:  if (obj == NULL)
    #####:  282:    return ERROR_INVALID_ARGUMENT;
        -:  283:
    #####:  284:  if (obj->type != OBJECT_TYPE_INTEGER)
    #####:  285:    return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  286:
    #####:  287:  return yr_object_set_integer(value, obj, NULL);
        -:  288:}
        -:  289:
        -:  290:
    #####:  291:YR_API int yr_scanner_define_boolean_variable(
        -:  292:    YR_SCANNER* scanner,
        -:  293:    const char* identifier,
        -:  294:    int value)
        -:  295:{
    #####:  296:  return yr_scanner_define_integer_variable(scanner, identifier, value);
        -:  297:}
        -:  298:
        -:  299:
    #####:  300:YR_API int yr_scanner_define_float_variable(
        -:  301:    YR_SCANNER* scanner,
        -:  302:    const char* identifier,
        -:  303:    double value)
        -:  304:{
    #####:  305:  YR_OBJECT* obj = (YR_OBJECT*) yr_hash_table_lookup(
        -:  306:      scanner->objects_table,
        -:  307:      identifier,
        -:  308:      NULL);
        -:  309:
    #####:  310:  if (obj == NULL)
    #####:  311:    return ERROR_INVALID_ARGUMENT;
        -:  312:
    #####:  313:  if (obj->type != OBJECT_TYPE_FLOAT)
    #####:  314:    return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  315:
    #####:  316:  return yr_object_set_float(value, obj, NULL);
        -:  317:}
        -:  318:
        -:  319:
    #####:  320:YR_API int yr_scanner_define_string_variable(
        -:  321:    YR_SCANNER* scanner,
        -:  322:    const char* identifier,
        -:  323:    const char* value)
        -:  324:{
    #####:  325:  YR_OBJECT* obj = (YR_OBJECT*) yr_hash_table_lookup(
        -:  326:      scanner->objects_table,
        -:  327:      identifier,
        -:  328:      NULL);
        -:  329:
    #####:  330:  if (obj == NULL)
    #####:  331:    return ERROR_INVALID_ARGUMENT;
        -:  332:
    #####:  333:  if (obj->type != OBJECT_TYPE_STRING)
    #####:  334:    return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  335:
    #####:  336:  return yr_object_set_string(value, strlen(value), obj, NULL);
        -:  337:}
        -:  338:
        -:  339:
      280:  340:YR_API int yr_scanner_scan_mem_blocks(
        -:  341:    YR_SCANNER* scanner,
        -:  342:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  343:{
        -:  344:  YR_RULES* rules;
        -:  345:  YR_RULE* rule;
        -:  346:  YR_MEMORY_BLOCK* block;
        -:  347:
      280:  348:  int tidx = 0;
      280:  349:  int result = ERROR_SUCCESS;
        -:  350:
        -:  351:  uint64_t elapsed_time;
        -:  352:
      280:  353:  if (scanner->callback == NULL)
    #####:  354:    return ERROR_CALLBACK_REQUIRED;
        -:  355:
      280:  356:  scanner->iterator = iterator;
      280:  357:  rules = scanner->rules;
      280:  358:  block = iterator->first(iterator);
        -:  359:
      280:  360:  if (block == NULL)
    #####:  361:    return ERROR_SUCCESS;
        -:  362:
      280:  363:  yr_mutex_lock(&rules->mutex);
        -:  364:
      280:  365:  while (tidx < YR_MAX_THREADS && YR_BITARRAY_TEST(rules->tidx_mask, tidx))
        -:  366:  {
    #####:  367:    tidx++;
        -:  368:  }
        -:  369:
      280:  370:  if (tidx < YR_MAX_THREADS)
      280:  371:    YR_BITARRAY_SET(rules->tidx_mask, tidx);
        -:  372:  else
    #####:  373:    result = ERROR_TOO_MANY_SCAN_THREADS;
        -:  374:
      280:  375:  yr_mutex_unlock(&rules->mutex);
        -:  376:
      280:  377:  if (result != ERROR_SUCCESS)
    #####:  378:    return result;
        -:  379:
      280:  380:  scanner->tidx = tidx;
      280:  381:  scanner->file_size = block->size;
        -:  382:
      280:  383:  yr_set_tidx(tidx);
        -:  384:
      280:  385:  result = yr_arena_create(1048576, 0, &scanner->matches_arena);
        -:  386:
      280:  387:  if (result != ERROR_SUCCESS)
    #####:  388:    goto _exit;
        -:  389:
      280:  390:  result = yr_arena_create(4096, 0, &scanner->matching_strings_arena);
        -:  391:
      280:  392:  if (result != ERROR_SUCCESS)
    #####:  393:    goto _exit;
        -:  394:
      280:  395:  yr_stopwatch_start(&scanner->stopwatch);
        -:  396:
      840:  397:  while (block != NULL)
        -:  398:  {
      280:  399:    const uint8_t* data = block->fetch_data(block);
        -:  400:
        -:  401:    // fetch may fail
      280:  402:    if (data == NULL)
        -:  403:    {
    #####:  404:      block = iterator->next(iterator);
    #####:  405:      continue;
        -:  406:    }
        -:  407:
      280:  408:    if (scanner->entry_point == UNDEFINED)
        -:  409:    {
     280*:  410:      YR_TRYCATCH(
        -:  411:        !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
        -:  412:        {
        -:  413:          if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)
        -:  414:            scanner->entry_point = yr_get_entry_point_address(
        -:  415:                data,
        -:  416:                block->size,
        -:  417:                block->base);
        -:  418:          else
        -:  419:            scanner->entry_point = yr_get_entry_point_offset(
        -:  420:                data,
        -:  421:                block->size);
        -:  422:        },{});
        -:  423:    }
        -:  424:
     280*:  425:    YR_TRYCATCH(
        -:  426:      !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
        -:  427:      {
        -:  428:        result = _yr_scanner_scan_mem_block(
        -:  429:            scanner,
        -:  430:            data,
        -:  431:            block);
        -:  432:      },{
        -:  433:        result = ERROR_COULD_NOT_MAP_FILE;
        -:  434:      });
        -:  435:
      280:  436:    if (result != ERROR_SUCCESS)
    #####:  437:      goto _exit;
        -:  438:
      280:  439:    block = iterator->next(iterator);
        -:  440:  }
        -:  441:
     280*:  442:  YR_TRYCATCH(
        -:  443:    !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),
        -:  444:    {
        -:  445:      result = yr_execute_code(scanner);
        -:  446:    },{
        -:  447:      result = ERROR_COULD_NOT_MAP_FILE;
        -:  448:    });
        -:  449:
      280:  450:  if (result != ERROR_SUCCESS)
    #####:  451:    goto _exit;
        -:  452:
      560:  453:  yr_rules_foreach(rules, rule)
        -:  454:  {
        -:  455:    int message;
        -:  456:
      280:  457:    if (rule->t_flags[tidx] & RULE_TFLAGS_MATCH &&
      209:  458:        !(rule->ns->t_flags[tidx] & NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL))
        -:  459:    {
      209:  460:      message = CALLBACK_MSG_RULE_MATCHING;
        -:  461:    }
        -:  462:    else
        -:  463:    {
       71:  464:      message = CALLBACK_MSG_RULE_NOT_MATCHING;
        -:  465:    }
        -:  466:
      280:  467:    if (!RULE_IS_PRIVATE(rule))
        -:  468:    {
      280:  469:      switch (scanner->callback(message, rule, scanner->user_data))
        -:  470:      {
    #####:  471:        case CALLBACK_ABORT:
    #####:  472:          result = ERROR_SUCCESS;
    #####:  473:          goto _exit;
        -:  474:
    #####:  475:        case CALLBACK_ERROR:
    #####:  476:          result = ERROR_CALLBACK_ERROR;
    #####:  477:          goto _exit;
        -:  478:      }
        -:  479:    }
        -:  480:  }
        -:  481:
      280:  482:  scanner->callback(CALLBACK_MSG_SCAN_FINISHED, NULL, scanner->user_data);
        -:  483:
      280:  484:_exit:
        -:  485:
      280:  486:  elapsed_time = yr_stopwatch_elapsed_us(&scanner->stopwatch);
        -:  487:
        -:  488:  #ifdef PROFILING_ENABLED
        -:  489:  yr_rules_foreach(rules, rule)
        -:  490:  {
        -:  491:    #ifdef _WIN32
        -:  492:    InterlockedAdd64(&rule->time_cost, rule->time_cost_per_thread[tidx]);
        -:  493:    #else
        -:  494:    __sync_fetch_and_add(&rule->time_cost, rule->time_cost_per_thread[tidx]);
        -:  495:    #endif
        -:  496:
        -:  497:    rule->time_cost_per_thread[tidx] = 0;
        -:  498:  }
        -:  499:  #endif
        -:  500:
      280:  501:  _yr_scanner_clean_matches(scanner);
        -:  502:
      280:  503:  if (scanner->matches_arena != NULL)
        -:  504:  {
      280:  505:    yr_arena_destroy(scanner->matches_arena);
      280:  506:    scanner->matches_arena = NULL;
        -:  507:  }
        -:  508:
      280:  509:  if (scanner->matching_strings_arena != NULL)
        -:  510:  {
      280:  511:    yr_arena_destroy(scanner->matching_strings_arena);
      280:  512:    scanner->matching_strings_arena = NULL;
        -:  513:  }
        -:  514:
      280:  515:  yr_mutex_lock(&rules->mutex);
      280:  516:  YR_BITARRAY_UNSET(rules->tidx_mask, tidx);
      280:  517:  rules->time_cost += elapsed_time;
      280:  518:  yr_mutex_unlock(&rules->mutex);
        -:  519:
      280:  520:  yr_set_tidx(-1);
        -:  521:
      280:  522:  return result;
        -:  523:}
        -:  524:
        -:  525:
    #####:  526:static YR_MEMORY_BLOCK* _yr_get_first_block(
        -:  527:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  528:{
    #####:  529:  return (YR_MEMORY_BLOCK*) iterator->context;
        -:  530:}
        -:  531:
        -:  532:
    #####:  533:static YR_MEMORY_BLOCK* _yr_get_next_block(
        -:  534:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  535:{
    #####:  536:  return NULL;
        -:  537:}
        -:  538:
        -:  539:
    #####:  540:static const uint8_t* _yr_fetch_block_data(
        -:  541:    YR_MEMORY_BLOCK* block)
        -:  542:{
    #####:  543:  return (const uint8_t*) block->context;
        -:  544:}
        -:  545:
        -:  546:
    #####:  547:YR_API int yr_scanner_scan_mem(
        -:  548:    YR_SCANNER* scanner,
        -:  549:    const uint8_t* buffer,
        -:  550:    size_t buffer_size)
        -:  551:{
        -:  552:  YR_MEMORY_BLOCK block;
        -:  553:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  554:
    #####:  555:  block.size = buffer_size;
    #####:  556:  block.base = 0;
    #####:  557:  block.fetch_data = _yr_fetch_block_data;
    #####:  558:  block.context = (void*) buffer;
        -:  559:
    #####:  560:  iterator.context = &block;
    #####:  561:  iterator.first = _yr_get_first_block;
    #####:  562:  iterator.next = _yr_get_next_block;
        -:  563:
    #####:  564:  return yr_scanner_scan_mem_blocks(scanner, &iterator);
        -:  565:}
        -:  566:
        -:  567:
    #####:  568:YR_API int yr_scanner_scan_file(
        -:  569:    YR_SCANNER* scanner,
        -:  570:    const char* filename)
        -:  571:{
        -:  572:  YR_MAPPED_FILE mfile;
        -:  573:
    #####:  574:  int result = yr_filemap_map(filename, &mfile);
        -:  575:
    #####:  576:  if (result == ERROR_SUCCESS)
        -:  577:  {
    #####:  578:    result = yr_scanner_scan_mem(scanner, mfile.data, mfile.size);
    #####:  579:    yr_filemap_unmap(&mfile);
        -:  580:  }
        -:  581:
    #####:  582:  return result;
        -:  583:}
        -:  584:
        -:  585:
    #####:  586:YR_API int yr_scanner_scan_fd(
        -:  587:    YR_SCANNER* scanner,
        -:  588:    YR_FILE_DESCRIPTOR fd)
        -:  589:{
        -:  590:  YR_MAPPED_FILE mfile;
        -:  591:
    #####:  592:  int result = yr_filemap_map_fd(fd, 0, 0, &mfile);
        -:  593:
    #####:  594:  if (result == ERROR_SUCCESS)
        -:  595:  {
    #####:  596:    result = yr_scanner_scan_mem(scanner, mfile.data, mfile.size);
    #####:  597:    yr_filemap_unmap_fd(&mfile);
        -:  598:  }
        -:  599:
    #####:  600:  return result;
        -:  601:}
        -:  602:
        -:  603:
    #####:  604:YR_API int yr_scanner_scan_proc(
        -:  605:    YR_SCANNER* scanner,
        -:  606:    int pid)
        -:  607:{
        -:  608:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  609:
    #####:  610:  int result = yr_process_open_iterator(pid, &iterator);
        -:  611:
    #####:  612:  if (result == ERROR_SUCCESS)
        -:  613:  {
    #####:  614:    int prev_flags = scanner->flags;
    #####:  615:    scanner->flags |= SCAN_FLAGS_PROCESS_MEMORY;
    #####:  616:    result = yr_scanner_scan_mem_blocks(scanner, &iterator);
    #####:  617:    scanner->flags = prev_flags;
    #####:  618:    yr_process_close_iterator(&iterator);
        -:  619:  }
        -:  620:
    #####:  621:  return result;
        -:  622:}
        -:  623:
        -:  624:
    #####:  625:YR_API YR_STRING* yr_scanner_last_error_string(
        -:  626:    YR_SCANNER* scanner)
        -:  627:{
    #####:  628:  return scanner->last_error_string;
        -:  629:}
        -:  630:
        -:  631:
    #####:  632:YR_API YR_RULE* yr_scanner_last_error_rule(
        -:  633:    YR_SCANNER* scanner)
        -:  634:{
    #####:  635:  if (scanner->last_error_string == NULL)
    #####:  636:    return NULL;
        -:  637:
    #####:  638:  return scanner->last_error_string->rule;
        -:  639:}
