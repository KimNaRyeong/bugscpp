        -:    0:Source:hex_lexer.l
        -:    0:Graph:/home/workspace/libyara/hex_lexer.gcno
        -:    0:Data:/home/workspace/libyara/hex_lexer.gcda
        -:    0:Runs:8
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for hex strings */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function hex_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <setjmp.h>
        -:   48:
        -:   49:#include <yara/globals.h>
        -:   50:#include <yara/limits.h>
        -:   51:#include <yara/error.h>
        -:   52:#include <yara/mem.h>
        -:   53:#include <yara/re.h>
        -:   54:#include <yara/threading.h>
        -:   55:#include <yara/strutils.h>
        -:   56:#include <yara/hex_lexer.h>
        -:   57:
        -:   58:#include "hex_grammar.h"
        -:   59:
        -:   60:#ifdef _WIN32
        -:   61:#define snprintf _snprintf
        -:   62:#endif
        -:   63:
        -:   64:#define ERROR_IF(x, error) \
        -:   65:    if (x) \
        -:   66:    { \
        -:   67:      RE_AST* re_ast = yyget_extra(yyscanner); \
        -:   68:      re_ast->error_code = error; \
        -:   69:      YYABORT; \
        -:   70:    } \
        -:   71:
        -:   72:%}
        -:   73:
        -:   74:%option reentrant bison-bridge
        -:   75:%option noyywrap
        -:   76:%option nounistd
        -:   77:%option noinput
        -:   78:%option nounput
        -:   79:%option never-interactive
        -:   80:%option yylineno
        -:   81:%option prefix="hex_yy"
        -:   82:
        -:   83:%option outfile="lex.yy.c"
        -:   84:
        -:   85:%option verbose
        -:   86:%option warn
        -:   87:
        -:   88:digit         [0-9]
        -:   89:letter        [a-zA-Z]
        -:   90:hexdigit      [a-fA-F0-9]
        -:   91:
        -:   92:%x comment
        -:   93:%x range
        -:   94:
        -:   95:%%
        -:   96:
        -:   97:
        -:   98:<INITIAL>{hexdigit}{2}  {
        -:   99:
    #####:  100:  yylval->integer = xtoi(yytext);
    #####:  101:  return _BYTE_;
        -:  102:}
        -:  103:
    #####:  104:<INITIAL>{hexdigit}\?  {
        -:  105:
    #####:  106:  yytext[1] = '0'; // replace ? by 0
    #####:  107:  yylval->integer = xtoi(yytext) | 0xF000 ;
    #####:  108:  return _MASKED_BYTE_;
        -:  109:}
        -:  110:
    #####:  111:\?{hexdigit}  {
        -:  112:
    #####:  113:  yytext[0] = '0'; // replace ? by 0
    #####:  114:  yylval->integer = xtoi(yytext) | 0x0F00 ;
    #####:  115:  return _MASKED_BYTE_;
        -:  116:}
        -:  117:
    #####:  118:\?\? {
        -:  119:
    #####:  120:  yylval->integer = 0x0000;
    #####:  121:  return _MASKED_BYTE_;
        -:  122:}
        -:  123:
    #####:  124:\[ {
        -:  125:
    #####:  126:  BEGIN(range);
    #####:  127:  return yytext[0];
        -:  128:}
        -:  129:
    #####:  130:"/*"(.|\n)*"*/"    // skip comments
    #####:  131:
    #####:  132:"//".*             // skip single-line comments
    #####:  133:
    #####:  134:<range>\- {
    #####:  135:  return yytext[0];
        -:  136:}
        -:  137:
    #####:  138:<range>{digit}+ {
        -:  139:
    #####:  140:  yylval->integer = atoi(yytext);
    #####:  141:  return _NUMBER_;
        -:  142:}
        -:  143:
    #####:  144:<range>\] {
        -:  145:
    #####:  146:  BEGIN(INITIAL);
    #####:  147:  return yytext[0];
        -:  148:}
        -:  149:
    #####:  150:<range>[ \t\r\n]   // skip whitespaces
    #####:  151:
    #####:  152:<range>. {
        -:  153:
    #####:  154:  yyerror(yyscanner, lex_env, "invalid character in hex string jump");
    #####:  155:  yyterminate();
        -:  156:}
        -:  157:
    #####:  158:[ \t\r\n]         // skip whitespaces
    #####:  159:
    #####:  160:[{}()|]  {        // pass valid characters to the parser
        -:  161:
    #####:  162:  return yytext[0];
        -:  163:}
        -:  164:
    #####:  165:. {               // reject all other characters
        -:  166:
    #####:  167:  yyerror(yyscanner, lex_env, "invalid character in hex string");
    #####:  168:  yyterminate();
        -:  169:}
        -:  170:
    #####:  171:%%
    #####:  172:
    #####:  173:void yyfatal(
        -:  174:    yyscan_t yyscanner,
        -:  175:    const char *error_message)
        -:  176:{
    #####:  177:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
        -:  178:      &yr_recovery_state_key);
        -:  179:
    #####:  180:  longjmp(*recovery_state, 1);
        -:  181:}
        -:  182:
    #####:  183:void yyerror(
        -:  184:    yyscan_t yyscanner,
        -:  185:    HEX_LEX_ENVIRONMENT* lex_env,
        -:  186:    const char *error_message)
        -:  187:{
        -:  188:  // if lex_env->last_error was set to some error code before
        -:  189:  // don't overwrite it, we are interested in the first error, not in
        -:  190:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  191:  // early parser termination.
        -:  192:
    #####:  193:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  194:  {
    #####:  195:    lex_env->last_error = ERROR_INVALID_HEX_STRING;
        -:  196:
    #####:  197:    strlcpy(
    #####:  198:        lex_env->last_error_message,
        -:  199:        error_message,
        -:  200:        sizeof(lex_env->last_error_message));
        -:  201:  }
    #####:  202:}
        -:  203:
        -:  204:
    #####:  205:int yr_parse_hex_string(
        -:  206:    const char* hex_string,
        -:  207:    RE_AST** re_ast,
        -:  208:    RE_ERROR* error)
        -:  209:{
        -:  210:  yyscan_t yyscanner;
        -:  211:  jmp_buf recovery_state;
        -:  212:  HEX_LEX_ENVIRONMENT lex_env;
        -:  213:
    #####:  214:  lex_env.last_error = ERROR_SUCCESS;
    #####:  215:  lex_env.inside_or = 0;
        -:  216:
    #####:  217:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
        -:  218:
    #####:  219:  if (setjmp(recovery_state) != 0)
    #####:  220:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  221:
    #####:  222:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  223:
        -:  224:  // The RE_FLAGS_FAST_REGEXP flag indicates a regular expression can be
        -:  225:  // matched by faster algorithm. These regular expressions come from hex
        -:  226:  // strings that do not contain alternatives, like in:
        -:  227:  //
        -:  228:  // { ( 01 02 | 03 04) 05 06 }.
        -:  229:  //
        -:  230:  // This flag is unset later during parsing if alternatives are used.
        -:  231:
    #####:  232:  (*re_ast)->flags |= RE_FLAGS_FAST_REGEXP;
        -:  233:
        -:  234:  // Set RE_FLAGS_DOT_ALL because in hex strings the "dot" (?? in this case)
        -:  235:  // must match all characters including new-line.
        -:  236:
    #####:  237:  (*re_ast)->flags |= RE_FLAGS_DOT_ALL;
        -:  238:
    #####:  239:  yylex_init(&yyscanner);
    #####:  240:  yyset_extra(*re_ast, yyscanner);
    #####:  241:  yy_scan_string(hex_string, yyscanner);
    #####:  242:  yyparse(yyscanner, &lex_env);
    #####:  243:  yylex_destroy(yyscanner);
        -:  244:
    #####:  245:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  246:  {
    #####:  247:    strlcpy(error->message, lex_env.last_error_message, sizeof(error->message));
    #####:  248:    return lex_env.last_error;
        -:  249:  }
        -:  250:
    #####:  251:  return ERROR_SUCCESS;
        -:  252:}
