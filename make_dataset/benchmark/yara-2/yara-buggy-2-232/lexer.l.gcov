        -:    0:Source:lexer.l
        -:    0:Graph:/home/workspace/libyara/lexer.gcno
        -:    0:Data:/home/workspace/libyara/lexer.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for YARA */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function yara_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <math.h>
        -:   48:#include <stdarg.h>
        -:   49:#include <stdio.h>
        -:   50:#include <stdlib.h>
        -:   51:#include <string.h>
        -:   52:#include <setjmp.h>
        -:   53:
        -:   54:#if defined(_WIN32) || defined(__CYGWIN__)
        -:   55:#include <windows.h>
        -:   56:#else
        -:   57:#include <sys/stat.h>
        -:   58:#include <unistd.h>
        -:   59:#endif
        -:   60:
        -:   61:#if defined(_WIN32)
        -:   62:#define strtoll _strtoi64
        -:   63:#endif
        -:   64:
        -:   65:#include <yara/integers.h>
        -:   66:#include <yara/lexer.h>
        -:   67:#include <yara/sizedstr.h>
        -:   68:#include <yara/error.h>
        -:   69:#include <yara/mem.h>
        -:   70:#include <yara/utils.h>
        -:   71:#include <yara/strutils.h>
        -:   72:
        -:   73:#include "grammar.h"
        -:   74:
        -:   75:#define error(error_code) \
        -:   76:    { \
        -:   77:      compiler->last_error = error_code; \
        -:   78:      yyerror(yyscanner, compiler, NULL); \
        -:   79:      yyterminate(); \
        -:   80:    }
        -:   81:
        -:   82:#define syntax_error(error_msg) \
        -:   83:    { \
        -:   84:      yr_compiler_set_error_extra_info(compiler, error_msg); \
        -:   85:      error(ERROR_SYNTAX_ERROR); \
        -:   86:    }
        -:   87:
        -:   88:#define lex_check_space_ok(data, current_size, max_length) \
        -:   89:    if (strlen(data) + current_size >= max_length - 1) \
        -:   90:    { \
        -:   91:      yyerror(yyscanner, compiler, "out of space in lex_buf"); \
        -:   92:      yyterminate(); \
        -:   93:    }
        -:   94:
        -:   95:#define yytext_to_buffer \
        -:   96:    { \
        -:   97:      char *yptr = yytext; \
        -:   98:      lex_check_space_ok(yptr, yyextra->lex_buf_len, YR_LEX_BUF_SIZE); \
        -:   99:      while(*yptr) \
        -:  100:      { \
        -:  101:        *yyextra->lex_buf_ptr++ = *yptr++; \
        -:  102:        yyextra->lex_buf_len++; \
        -:  103:      } \
        -:  104:    }
        -:  105:
        -:  106:#define alloc_sized_string(str, str_len) \
        -:  107:  SIZED_STRING* str = (SIZED_STRING*) yr_malloc( \
        -:  108:      str_len + sizeof(SIZED_STRING)); \
        -:  109:  if (str == NULL) \
        -:  110:  { \
        -:  111:    yyerror(yyscanner, compiler, "not enough memory"); \
        -:  112:    yyterminate(); \
        -:  113:  } \
        -:  114:  else \
        -:  115:  { \
        -:  116:    str->length = (uint32_t) (str_len); \
        -:  117:    str->flags = 0; \
        -:  118:  } \
        -:  119:
        -:  120:#ifdef _WIN32
        -:  121:#define snprintf _snprintf
        -:  122:#endif
        -:  123:
    #####:  124:static bool is_absolute_path(
        -:  125:    char* path)
        -:  126:{
    #####:  127:  if (path == NULL)
    #####:  128:    return false;
        -:  129:
        -:  130:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  131:  return strlen(path) > 2 &&
        -:  132:      path[1] == ':' && (path[2] == '/' || path[2] == '\\');
        -:  133:  #else
    #####:  134:  return strlen(path) > 0 && path[0] == '/';
        -:  135:  #endif
        -:  136:}
        -:  137:
        -:  138:%}
        -:  139:
        -:  140:%option reentrant bison-bridge
        -:  141:%option noyywrap
        -:  142:%option nounistd
        -:  143:%option noinput
        -:  144:%option nounput
        -:  145:%option never-interactive
        -:  146:%option yylineno
        -:  147:%option prefix="yara_yy"
        -:  148:%option outfile="lex.yy.c"
        -:  149:
        -:  150:%option verbose
        -:  151:%option warn
        -:  152:
        -:  153:%x str
        -:  154:%x regexp
        -:  155:%x include
        -:  156:%x comment
        -:  157:
        -:  158:digit         [0-9]
        -:  159:letter        [a-zA-Z]
        -:  160:hexdigit      [a-fA-F0-9]
        -:  161:octdigit      [0-7]
        -:  162:
        -:  163:%%
        -:  164:
    #####:  165:".."                    { return _DOT_DOT_;     }
    #####:  166:"<"                     { return _LT_;          }
    #####:  167:">"                     { return _GT_;          }
    #####:  168:"<="                    { return _LE_;          }
    #####:  169:">="                    { return _GE_;          }
    #####:  170:"=="                    { return _EQ_;          }
       4*:  171:"!="                    { return _NEQ_;         }
    #####:  172:"<<"                    { return _SHIFT_LEFT_;  }
    #####:  173:">>"                    { return _SHIFT_RIGHT_; }
    #####:  174:"private"               { return _PRIVATE_;     }
    #####:  175:"global"                { return _GLOBAL_;      }
    #####:  176:"rule"                  { return _RULE_;        }
     282*:  177:"meta"                  { return _META_;        }
    #####:  178:"strings"               { return _STRINGS_;     }
     282*:  179:"ascii"                 { return _ASCII_;       }
    #####:  180:"wide"                  { return _WIDE_;        }
      14*:  181:"xor"                   { return _XOR_;         }
    #####:  182:"fullword"              { return _FULLWORD_;    }
        2:  183:"nocase"                { return _NOCASE_;      }
        9:  184:"condition"             { return _CONDITION_;   }
     279*:  185:"true"                  { return _TRUE_;        }
    #####:  186:"false"                 { return _FALSE_;       }
    #####:  187:"not"                   { return _NOT_;         }
    #####:  188:"and"                   { return _AND_;         }
    #####:  189:"or"                    { return _OR_;          }
    #####:  190:"at"                    { return _AT_;          }
    #####:  191:"in"                    { return _IN_;          }
    #####:  192:"of"                    { return _OF_;          }
    #####:  193:"them"                  { return _THEM_;        }
    #####:  194:"for"                   { return _FOR_;         }
    #####:  195:"all"                   { return _ALL_;         }
    #####:  196:"any"                   { return _ANY_;         }
    #####:  197:"entrypoint"            { return _ENTRYPOINT_;  }
    #####:  198:"filesize"              { return _FILESIZE_;    }
    #####:  199:"matches"               { return _MATCHES_;     }
    #####:  200:"contains"              { return _CONTAINS_;    }
    #####:  201:"import"                { return _IMPORT_;      }
    #####:  202:
    #####:  203:
    #####:  204:"/*"                    { BEGIN(comment);       }
    #####:  205:<comment>"*/"           { BEGIN(INITIAL);       }
    #####:  206:<comment>(.|\n)         { /* skip comments */   }
    #####:  207:
    #####:  208:
        -:  209:"//"[^\n]*              { /* skip single-line comments */ }
    #####:  210:
    #####:  211:
        -:  212:include[ \t]+\"         {
    #####:  213:                          yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  214:                          yyextra->lex_buf_len = 0;
    #####:  215:                          BEGIN(include);
        -:  216:                        }
    #####:  217:
    #####:  218:
    #####:  219:<include>[^\"]+         { yytext_to_buffer; }
    #####:  220:
    #####:  221:
        -:  222:<include>\"             {
        -:  223:
    #####:  224:  if (compiler->include_callback != NULL)
        -:  225:  {
        -:  226:    #ifdef _MSC_VER
        -:  227:    char* b = NULL;
        -:  228:    #endif
    #####:  229:    char* s = NULL;
        -:  230:    char* f;
        -:  231:
        -:  232:    char buffer[1024];
        -:  233:    const char* included_rules;
        -:  234:    char* current_file_name;
        -:  235:    char* include_path;
        -:  236:
    #####:  237:    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path
        -:  238:
    #####:  239:    current_file_name = yr_compiler_get_current_file_name(compiler);
        -:  240:
    #####:  241:    if (current_file_name == NULL ||
    #####:  242:        compiler->include_callback != _yr_compiler_default_include_callback ||
    #####:  243:        is_absolute_path(yyextra->lex_buf))
        -:  244:    {
    #####:  245:      include_path = yyextra->lex_buf;
        -:  246:    }
        -:  247:    else
        -:  248:    {
    #####:  249:      strlcpy(buffer, current_file_name, sizeof(buffer));
    #####:  250:      s = strrchr(buffer, '/');
        -:  251:
        -:  252:      #ifdef _MSC_VER
        -:  253:      b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
        -:  254:      #endif
        -:  255:
        -:  256:      #ifdef _MSC_VER
        -:  257:      if (s != NULL || b != NULL)
        -:  258:      #else
    #####:  259:      if (s != NULL)
        -:  260:      #endif
        -:  261:      {
        -:  262:        #ifdef _MSC_VER
        -:  263:        f = (b > s) ? (b + 1) : (s + 1);
        -:  264:        #else
    #####:  265:        f = s + 1;
        -:  266:        #endif
        -:  267:
    #####:  268:        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));
    #####:  269:        include_path = buffer;
        -:  270:      }
        -:  271:      else
        -:  272:      {
    #####:  273:        include_path = yyextra->lex_buf;
        -:  274:      }
        -:  275:    }
        -:  276:
    #####:  277:    included_rules = compiler->include_callback(
        -:  278:        include_path,
        -:  279:        current_file_name,
    #####:  280:        compiler->current_namespace->name,
        -:  281:        compiler->incl_clbk_user_data);
        -:  282:
    #####:  283:    if (included_rules != NULL)
        -:  284:    {
    #####:  285:      int error_code = _yr_compiler_push_file_name(compiler, include_path);
        -:  286:
    #####:  287:      if (error_code != ERROR_SUCCESS)
        -:  288:      {
    #####:  289:        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        -:  290:        {
    #####:  291:          yyerror(yyscanner, compiler, "includes circular reference");
        -:  292:        }
    #####:  293:        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        -:  294:        {
    #####:  295:          yyerror(yyscanner, compiler, "includes depth exceeded");
        -:  296:        }
        -:  297:
    #####:  298:        if (compiler->include_free != NULL)
        -:  299:        {
    #####:  300:          compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  301:        }
        -:  302:
    #####:  303:        yyterminate();
        -:  304:      }
        -:  305:
        -:  306:      // Workaround for flex issue: https://github.com/westes/flex/issues/58
    #####:  307:      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);
    #####:  308:      yy_scan_string(included_rules, yyscanner);
    #####:  309:      yyset_lineno(1, yyscanner);
        -:  310:
    #####:  311:      if (compiler->include_free != NULL)
        -:  312:      {
    #####:  313:        compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  314:      }
        -:  315:    }
        -:  316:    else
        -:  317:    {
        -:  318:      char* err_msg_fmt;
        -:  319:      char err_msg[512];
        -:  320:
    #####:  321:      if (compiler->include_callback == _yr_compiler_default_include_callback)
        -:  322:      {
    #####:  323:        err_msg_fmt = "can't open include file: %s";
        -:  324:      }
        -:  325:      else
        -:  326:      {
    #####:  327:        err_msg_fmt = "callback failed to provide include resource: %s";
        -:  328:      }
        -:  329:
    #####:  330:      snprintf(
        -:  331:          err_msg,
        -:  332:          sizeof(err_msg),
        -:  333:          err_msg_fmt,
    #####:  334:          yyextra->lex_buf);
        -:  335:
    #####:  336:      yyerror(yyscanner, compiler, err_msg);
        -:  337:    }
        -:  338:
        -:  339:  }
        -:  340:  else // not allowing includes
        -:  341:  {
    #####:  342:    yyerror(yyscanner, compiler, "includes are disabled");
        -:  343:  }
        -:  344:
    #####:  345:  BEGIN(INITIAL);
        -:  346:}
    #####:  347:
      282:  348:
        -:  349:<<EOF>> {
        -:  350:
      282:  351:  yypop_buffer_state(yyscanner);
        -:  352:
      282:  353:  if (!YY_CURRENT_BUFFER)
      282:  354:    yyterminate();
        -:  355:
    #####:  356:  return _END_OF_INCLUDED_FILE_;
        -:  357:}
        -:  358:
    #####:  359:
        -:  360:$({letter}|{digit}|_)*"*"  {
        -:  361:
    #####:  362:  yylval->c_string = yr_strdup(yytext);
        -:  363:
    #####:  364:  if (yylval->c_string == NULL)
    #####:  365:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  366:
    #####:  367:  return _STRING_IDENTIFIER_WITH_WILDCARD_;
        -:  368:}
        -:  369:
      557:  370:
        -:  371:$({letter}|{digit}|_)*  {
        -:  372:
      557:  373:  yylval->c_string = yr_strdup(yytext);
        -:  374:
      557:  375:  if (yylval->c_string == NULL)
    #####:  376:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  377:
      557:  378:  return _STRING_IDENTIFIER_;
        -:  379:}
        -:  380:
    #####:  381:
        -:  382:#({letter}|{digit}|_)*  {
        -:  383:
    #####:  384:  yylval->c_string = yr_strdup(yytext);
        -:  385:
    #####:  386:  if (yylval->c_string == NULL)
        -:  387:  {
    #####:  388:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  389:  }
        -:  390:  else
        -:  391:  {
    #####:  392:    yylval->c_string[0] = '$'; /* replace # by $*/
        -:  393:  }
        -:  394:
    #####:  395:  return _STRING_COUNT_;
        -:  396:}
        -:  397:
    #####:  398:
        -:  399:@({letter}|{digit}|_)*  {
        -:  400:
    #####:  401:  yylval->c_string = yr_strdup(yytext);
        -:  402:
    #####:  403:  if (yylval->c_string == NULL)
        -:  404:  {
    #####:  405:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  406:  }
        -:  407:  else
        -:  408:  {
    #####:  409:    yylval->c_string[0] = '$'; /* replace @ by $*/
        -:  410:  }
        -:  411:
    #####:  412:  return _STRING_OFFSET_;
        -:  413:}
        -:  414:
        4:  415:
        -:  416:!({letter}|{digit}|_)*  {
        -:  417:
        4:  418:  yylval->c_string = yr_strdup(yytext);
        -:  419:
        4:  420:  if (yylval->c_string == NULL)
        -:  421:  {
    #####:  422:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  423:  }
        -:  424:  else
        -:  425:  {
        4:  426:    yylval->c_string[0] = '$'; /* replace ! by $*/
        -:  427:  }
        -:  428:
        4:  429:  return _STRING_LENGTH_;
        -:  430:}
        -:  431:
    #####:  432:
        -:  433:u?int(8|16|32)(be)? {
        -:  434:
    #####:  435:  char* text = yytext;
        -:  436:
    #####:  437:  if (*text == 'u')
        -:  438:  {
    #####:  439:    yylval->integer = 3;
    #####:  440:    text++;
        -:  441:  }
        -:  442:  else
        -:  443:  {
    #####:  444:    yylval->integer = 0;
        -:  445:  }
        -:  446:
    #####:  447:  if (strstr(text, "int8") == text)
        -:  448:  {
    #####:  449:    yylval->integer += 0;
    #####:  450:    text += 4;
        -:  451:  }
    #####:  452:  else if (strstr(text, "int16") == text)
        -:  453:  {
    #####:  454:    yylval->integer += 1;
    #####:  455:    text += 5;
        -:  456:  }
    #####:  457:  else if (strstr(text, "int32") == text)
        -:  458:  {
    #####:  459:    yylval->integer += 2;
    #####:  460:    text += 5;
        -:  461:  }
        -:  462:
    #####:  463:  if (strcmp(text, "be") == 0)
        -:  464:  {
    #####:  465:    yylval->integer += 6;
        -:  466:  }
        -:  467:
    #####:  468:  return _INTEGER_FUNCTION_;
        -:  469:}
        -:  470:
      282:  471:
        -:  472:({letter}|_)({letter}|{digit}|_)*  {
        -:  473:
      282:  474:  if (strlen(yytext) > 128)
    #####:  475:    syntax_error("identifier too long");
        -:  476:
      282:  477:  yylval->c_string = yr_strdup(yytext);
        -:  478:
      282:  479:  if (yylval->c_string == NULL)
    #####:  480:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  481:
      282:  482:  return _IDENTIFIER_;
        -:  483:}
        -:  484:
        4:  485:
        -:  486:{digit}+(MB|KB){0,1}  {
        -:  487:
        -:  488:  char *endptr;
        -:  489:
        4:  490:  errno = 0;
        4:  491:  yylval->integer = strtoll(yytext, &endptr, 10);
        -:  492:
       4*:  493:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  494:  {
    #####:  495:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  496:    error(ERROR_INTEGER_OVERFLOW);
        -:  497:  }
        4:  498:  else if (strstr(yytext, "KB") != NULL)
        -:  499:  {
    #####:  500:    if (yylval->integer > LLONG_MAX / 1024)
        -:  501:    {
    #####:  502:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  503:      error(ERROR_INTEGER_OVERFLOW);
        -:  504:    }
        -:  505:    else
        -:  506:    {
    #####:  507:      yylval->integer *= 1024;
        -:  508:    }
        -:  509:  }
        4:  510:  else if (strstr(yytext, "MB") != NULL)
        -:  511:  {
    #####:  512:    if (yylval->integer > LLONG_MAX / 1048576)
        -:  513:    {
    #####:  514:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  515:      error(ERROR_INTEGER_OVERFLOW);
        -:  516:    }
        -:  517:    else
        -:  518:    {
    #####:  519:      yylval->integer *= 1048576;
        -:  520:    }
        -:  521:  }
        -:  522:
        4:  523:  return _NUMBER_;
        -:  524:}
        -:  525:
    #####:  526:{digit}+"."{digit}+  {
    #####:  527:  yylval->double_ = atof(yytext);
    #####:  528:  return _DOUBLE_;
        -:  529:}
        -:  530:
    #####:  531:0x{hexdigit}+  {
        -:  532:
        -:  533:  char *endptr;
        -:  534:
    #####:  535:  errno = 0;
    #####:  536:  yylval->integer = strtoll(yytext, &endptr, 16);
        -:  537:
    #####:  538:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  539:  {
    #####:  540:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  541:    error(ERROR_INTEGER_OVERFLOW);
        -:  542:  }
        -:  543:
    #####:  544:  return _NUMBER_;
        -:  545:}
        -:  546:
    #####:  547:0o{octdigit}+  {
        -:  548:
        -:  549:  char *endptr;
        -:  550:
    #####:  551:  errno = 0;
    #####:  552:  yylval->integer = strtoll(yytext + 2, &endptr, 8);
        -:  553:
    #####:  554:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  555:  {
    #####:  556:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  557:    error(ERROR_INTEGER_OVERFLOW);
        -:  558:  }
        -:  559:
    #####:  560:  return _NUMBER_;
        -:  561:}
        -:  562:
        1:  563:
        -:  564:<str>\"   {     /* saw closing quote - all done */
        -:  565:
       1*:  566:  alloc_sized_string(s, yyextra->lex_buf_len);
        -:  567:
        1:  568:  *yyextra->lex_buf_ptr = '\0';
        1:  569:  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
        1:  570:  yylval->sized_string = s;
        -:  571:
        1:  572:  BEGIN(INITIAL);
        -:  573:
        1:  574:  return _TEXT_STRING_;
        -:  575:}
        -:  576:
    #####:  577:
        -:  578:<str>\\t   {
        -:  579:
    #####:  580:  lex_check_space_ok("\t", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  581:  *yyextra->lex_buf_ptr++ = '\t';
    #####:  582:  yyextra->lex_buf_len++;
        -:  583:}
    #####:  584:
    #####:  585:
        -:  586:<str>\\n   {
        -:  587:
    #####:  588:  lex_check_space_ok("\n", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  589:  *yyextra->lex_buf_ptr++ = '\n';
    #####:  590:  yyextra->lex_buf_len++;
        -:  591:}
    #####:  592:
    #####:  593:
        -:  594:<str>\\\"   {
        -:  595:
    #####:  596:  lex_check_space_ok("\"", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  597:  *yyextra->lex_buf_ptr++ = '\"';
    #####:  598:  yyextra->lex_buf_len++;
        -:  599:}
    #####:  600:
    #####:  601:
        -:  602:<str>\\\\   {
        -:  603:
    #####:  604:  lex_check_space_ok("\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  605:  *yyextra->lex_buf_ptr++ = '\\';
    #####:  606:  yyextra->lex_buf_len++;
        -:  607:}
    #####:  608:
    #####:  609:
        -:  610:<str>\\x{hexdigit}{2} {
        -:  611:
        -:  612:   int result;
        -:  613:
    #####:  614:   sscanf( yytext + 2, "%x", &result );
    #####:  615:   lex_check_space_ok("X", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  616:   *yyextra->lex_buf_ptr++ = result;
    #####:  617:   yyextra->lex_buf_len++;
        -:  618:}
    #####:  619:
        1:  620:
      10*:  621:<str>[^\\\n\"]+   { yytext_to_buffer; }
        1:  622:
    #####:  623:
        -:  624:<str>\n  {
    #####:  625:  syntax_error("unterminated string");
        -:  626:}
        -:  627:
    #####:  628:
        -:  629:<str>\\(.|\n) {
    #####:  630:  syntax_error("illegal escape sequence");
        -:  631:}
        -:  632:
      279:  633:
        -:  634:<regexp>\/i?s?  {
        -:  635:
      279:  636:  if (yyextra->lex_buf_len > 0)
        -:  637:  {
     279*:  638:    alloc_sized_string(s, yyextra->lex_buf_len);
        -:  639:
      279:  640:    if (yytext[1] == 'i')
    #####:  641:      s->flags |= SIZED_STRING_FLAGS_NO_CASE;
        -:  642:
      279:  643:    if (yytext[1] == 's' || yytext[2] == 's')
        1:  644:      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;
        -:  645:
      279:  646:    *yyextra->lex_buf_ptr = '\0';
      279:  647:    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
      279:  648:    yylval->sized_string = s;
        -:  649:  }
        -:  650:  else
        -:  651:  {
    #####:  652:    syntax_error("empty regular expression");
        -:  653:  }
        -:  654:
      279:  655:  BEGIN(INITIAL);
      279:  656:  return _REGEXP_;
        -:  657:}
        -:  658:
        2:  659:
        -:  660:<regexp>\\\/  {
        -:  661:
       2*:  662:  lex_check_space_ok("/", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        2:  663:  *yyextra->lex_buf_ptr++ = '/';
        2:  664:  yyextra->lex_buf_len++ ;
        -:  665:}
        2:  666:
      123:  667:
        -:  668:<regexp>\\. {
        -:  669:
     123*:  670:  lex_check_space_ok("\\.", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -:  671:
      123:  672:  if (yytext[1] == 0)
    #####:  673:    syntax_error("malformed regular expression");
        -:  674:
      123:  675:  *yyextra->lex_buf_ptr++ = yytext[0];
      123:  676:  *yyextra->lex_buf_ptr++ = yytext[1];
      123:  677:  yyextra->lex_buf_len += 2;
        -:  678:}
      123:  679:
      321:  680:
    2149*:  681:<regexp>[^/\n\\]+ { yytext_to_buffer; }
      321:  682:
    #####:  683:
        -:  684:<regexp>\n  {
    #####:  685:  syntax_error("unterminated regular expression");
        -:  686:}
        -:  687:
        1:  688:
        -:  689:\"  {
        -:  690:
        1:  691:  yylval->sized_string = NULL;
        1:  692:  yyextra->lex_buf_ptr = yyextra->lex_buf;
        1:  693:  yyextra->lex_buf_len = 0;
        1:  694:  BEGIN(str);
        -:  695:}
        1:  696:
      281:  697:
        -:  698:"/"  {
        -:  699:
      281:  700:  yylval->sized_string = NULL;
      281:  701:  yyextra->lex_buf_ptr = yyextra->lex_buf;
      281:  702:  yyextra->lex_buf_len = 0;
      281:  703:  BEGIN(regexp);
        -:  704:}
      281:  705:
    #####:  706:
        -:  707:\{(({hexdigit}|[ \-|\?\[\]\(\)\n\r\t]|\/\*[^*]*\*\/)+|\/\/.*)+\}  {
        -:  708:  // Match hex-digits with whitespace or comments. The latter are stripped
        -:  709:  // out by hex_lexer.l
        -:  710:
    #####:  711:  alloc_sized_string(s, strlen(yytext));
        -:  712:
    #####:  713:  strlcpy(s->c_string, yytext, s->length + 1);
    #####:  714:  yylval->sized_string = s;
        -:  715:
    #####:  716:  return _HEX_STRING_;
        -:  717:}
        -:  718:
     2590:  719:
        -:  720:[ \t\r\n]   /* skip whitespace */
     2590:  721:
     1404:  722:.   {
        -:  723:
     1404:  724:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  725:  {
     1404:  726:    return yytext[0];
        -:  727:  }
        -:  728:  else
        -:  729:  {
    #####:  730:    syntax_error("non-ascii character");
        -:  731:  }
        -:  732:}
        -:  733:
    #####:  734:%%
    #####:  735:
        -:  736:
      131:  737:void yywarning(
        -:  738:    yyscan_t yyscanner,
        -:  739:    const char *message_fmt,
        -:  740:    ...)
        -:  741:{
      131:  742:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  743:
        -:  744:  char* file_name;
        -:  745:  char message[512];
        -:  746:  va_list message_args;
        -:  747:
      131:  748:  if (compiler->callback == NULL)
    #####:  749:    return;
        -:  750:
      131:  751:  va_start(message_args, message_fmt);
        -:  752:
      131:  753:  if (compiler->file_name_stack_ptr > 0)
    #####:  754:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  755:  else
      131:  756:    file_name = NULL;
        -:  757:
      131:  758:  vsnprintf(message, sizeof(message), message_fmt, message_args);
        -:  759:
      131:  760:  compiler->callback(
        -:  761:      YARA_ERROR_LEVEL_WARNING,
        -:  762:      file_name,
     131*:  763:      compiler->current_line ? compiler->current_line : yyget_lineno(yyscanner),
        -:  764:      message,
        -:  765:      compiler->user_data);
        -:  766:
      131:  767:  va_end(message_args);
        -:  768:}
        -:  769:
        -:  770:
    #####:  771:void yyfatal(
        -:  772:    yyscan_t yyscanner,
        -:  773:    const char *error_message)
        -:  774:{
    #####:  775:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  776:
    #####:  777:  yyerror(yyscanner, compiler, error_message);
    #####:  778:  longjmp(compiler->error_recovery, 1);
        -:  779:}
        -:  780:
        -:  781:
       16:  782:void yyerror(
        -:  783:    yyscan_t yyscanner,
        -:  784:    YR_COMPILER* compiler,
        -:  785:    const char *error_message)
        -:  786:{
       16:  787:  char message[512] = {'\0'};
       16:  788:  char* file_name = NULL;
        -:  789:
        -:  790:  /*
        -:  791:    if error_message != NULL the error comes from yyparse internal code
        -:  792:    else the error comes from my code and the error code is set in
        -:  793:    compiler->last_error
        -:  794:  */
        -:  795:
       16:  796:  compiler->errors++;
        -:  797:
       16:  798:  if (compiler->current_line != 0)
       13:  799:    compiler->last_error_line = compiler->current_line;
        -:  800:  else
        3:  801:    compiler->last_error_line = yyget_lineno(yyscanner);
        -:  802:
       16:  803:  compiler->current_line = 0;
        -:  804:
       16:  805:  if (compiler->file_name_stack_ptr > 0)
        -:  806:  {
    #####:  807:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  808:  }
        -:  809:  else
        -:  810:  {
       16:  811:    file_name = NULL;
        -:  812:  }
        -:  813:
       16:  814:  if (error_message != NULL)
        -:  815:  {
        3:  816:    yr_compiler_set_error_extra_info(compiler, error_message);
        3:  817:    compiler->last_error = ERROR_SYNTAX_ERROR;
        -:  818:
        3:  819:    if (compiler->callback != NULL)
        -:  820:    {
        3:  821:      compiler->callback(
        -:  822:          YARA_ERROR_LEVEL_ERROR,
        -:  823:          file_name,
        -:  824:          compiler->last_error_line,
        -:  825:          error_message,
        -:  826:          compiler->user_data);
        -:  827:    }
        -:  828:  }
       13:  829:  else if (compiler->callback != NULL)
        -:  830:  {
       13:  831:    yr_compiler_get_error_message(compiler, message, sizeof(message));
        -:  832:
       13:  833:    compiler->callback(
        -:  834:      YARA_ERROR_LEVEL_ERROR,
        -:  835:      file_name,
        -:  836:      compiler->last_error_line,
        -:  837:      message,
        -:  838:      compiler->user_data);
        -:  839:  }
       16:  840:}
        -:  841:
        -:  842:
      282:  843:int yr_lex_parse_rules_string(
        -:  844:    const char* rules_string,
        -:  845:    YR_COMPILER* compiler)
        -:  846:{
        -:  847:  yyscan_t yyscanner;
        -:  848:
      282:  849:  compiler->errors = 0;
        -:  850:
      282:  851:  if (setjmp(compiler->error_recovery) != 0)
    #####:  852:    return compiler->errors;
        -:  853:
      282:  854:  yylex_init(&yyscanner);
        -:  855:
        -:  856:  #if YYDEBUG
        -:  857:  yydebug = 1;
        -:  858:  #endif
        -:  859:
      282:  860:  yyset_extra(compiler, yyscanner);
      282:  861:  yy_scan_string(rules_string, yyscanner);
      282:  862:  yyset_lineno(1, yyscanner);
      282:  863:  yyparse(yyscanner, compiler);
      282:  864:  yylex_destroy(yyscanner);
        -:  865:
      282:  866:  return compiler->errors;
        -:  867:}
        -:  868:
        -:  869:
    #####:  870:int yr_lex_parse_rules_file(
        -:  871:    FILE* rules_file,
        -:  872:    YR_COMPILER* compiler)
        -:  873:{
        -:  874:  yyscan_t yyscanner;
        -:  875:
    #####:  876:  compiler->errors = 0;
        -:  877:
    #####:  878:  if (setjmp(compiler->error_recovery) != 0)
    #####:  879:    return compiler->errors;
        -:  880:
    #####:  881:  yylex_init(&yyscanner);
        -:  882:
        -:  883:  #if YYDEBUG
        -:  884:  yydebug = 1;
        -:  885:  #endif
        -:  886:
    #####:  887:  yyset_in(rules_file, yyscanner);
    #####:  888:  yyset_extra(compiler, yyscanner);
    #####:  889:  yyparse(yyscanner, compiler);
    #####:  890:  yylex_destroy(yyscanner);
        -:  891:
    #####:  892:  return compiler->errors;
        -:  893:}
        -:  894:
        -:  895:
    #####:  896:int yr_lex_parse_rules_fd(
        -:  897:    YR_FILE_DESCRIPTOR rules_fd,
        -:  898:    YR_COMPILER* compiler)
        -:  899:{
        -:  900:  yyscan_t yyscanner;
        -:  901:  size_t file_size;
        -:  902:  void* buffer;
        -:  903:
    #####:  904:  compiler->errors = 0;
        -:  905:
    #####:  906:  if (setjmp(compiler->error_recovery) != 0)
    #####:  907:    return compiler->errors;
        -:  908:
        -:  909:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  910:  file_size = (size_t) GetFileSize(rules_fd, NULL);
        -:  911:  #else
        -:  912:  struct stat fs;
    #####:  913:  if (fstat(rules_fd, &fs) != 0)
        -:  914:  {
    #####:  915:    compiler->errors = 1;
    #####:  916:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  917:    return compiler->errors;
        -:  918:  }
    #####:  919:  file_size = (size_t) fs.st_size;
        -:  920:  #endif
        -:  921:
    #####:  922:  buffer = yr_malloc(file_size);
        -:  923:
    #####:  924:  if (buffer == NULL)
        -:  925:  {
    #####:  926:    compiler->errors = 1;
    #####:  927:    compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
    #####:  928:    return compiler->errors;
        -:  929:  }
        -:  930:
        -:  931:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  932:  if (!ReadFile(rules_fd, buffer, file_size, NULL, NULL))
        -:  933:  #else
    #####:  934:  if (read(rules_fd, buffer, file_size) != file_size)
        -:  935:  #endif
        -:  936:  {
    #####:  937:    yr_free(buffer);
    #####:  938:    compiler->errors = 1;
    #####:  939:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  940:    return compiler->errors;
        -:  941:  }
        -:  942:
    #####:  943:  yylex_init(&yyscanner);
        -:  944:
        -:  945:  #if YYDEBUG
        -:  946:  yydebug = 1;
        -:  947:  #endif
        -:  948:
    #####:  949:  yyset_extra(compiler, yyscanner);
    #####:  950:  yy_scan_bytes((const char*) buffer, file_size, yyscanner);
    #####:  951:  yyparse(yyscanner, compiler);
    #####:  952:  yylex_destroy(yyscanner);
        -:  953:
    #####:  954:  yr_free(buffer);
        -:  955:
    #####:  956:  return compiler->errors;
        -:  957:}
