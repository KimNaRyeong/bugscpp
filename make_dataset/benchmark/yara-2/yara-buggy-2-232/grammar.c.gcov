        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         yara_yyparse
        -:   68:#define yylex           yara_yylex
        -:   69:#define yyerror         yara_yyerror
        -:   70:#define yydebug         yara_yydebug
        -:   71:#define yynerrs         yara_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "grammar.y"
        -:   75:
        -:   76:
        -:   77:
        -:   78:#include <assert.h>
        -:   79:#include <stdio.h>
        -:   80:#include <string.h>
        -:   81:#include <limits.h>
        -:   82:#include <stdlib.h>
        -:   83:#include <stddef.h>
        -:   84:
        -:   85:#include <yara/integers.h>
        -:   86:#include <yara/utils.h>
        -:   87:#include <yara/strutils.h>
        -:   88:#include <yara/compiler.h>
        -:   89:#include <yara/object.h>
        -:   90:#include <yara/sizedstr.h>
        -:   91:#include <yara/exec.h>
        -:   92:#include <yara/error.h>
        -:   93:#include <yara/mem.h>
        -:   94:#include <yara/lexer.h>
        -:   95:#include <yara/parser.h>
        -:   96:
        -:   97:#if defined(_MSC_VER)
        -:   98:#define llabs _abs64
        -:   99:#endif
        -:  100:
        -:  101:#define YYERROR_VERBOSE
        -:  102:
        -:  103:#define YYMALLOC yr_malloc
        -:  104:#define YYFREE yr_free
        -:  105:
        -:  106:#define INTEGER_SET_ENUMERATION   1
        -:  107:#define INTEGER_SET_RANGE         2
        -:  108:
        -:  109:#define fail_if_error(e) \
        -:  110:    if (e != ERROR_SUCCESS) \
        -:  111:    { \
        -:  112:      compiler->last_error = e; \
        -:  113:      yyerror(yyscanner, compiler, NULL); \
        -:  114:      YYERROR; \
        -:  115:    } \
        -:  116:
        -:  117:
        -:  118:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  119:    if (((expression.type) & (expected_type)) == 0) \
        -:  120:    { \
        -:  121:      switch(expression.type) \
        -:  122:      { \
        -:  123:        case EXPRESSION_TYPE_INTEGER: \
        -:  124:          yr_compiler_set_error_extra_info( \
        -:  125:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  126:          break; \
        -:  127:        case EXPRESSION_TYPE_FLOAT: \
        -:  128:          yr_compiler_set_error_extra_info( \
        -:  129:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  130:          break; \
        -:  131:        case EXPRESSION_TYPE_STRING: \
        -:  132:          yr_compiler_set_error_extra_info( \
        -:  133:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  134:          break; \
        -:  135:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  136:          yr_compiler_set_error_extra_info( \
        -:  137:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  138:          break; \
        -:  139:      } \
        -:  140:      cleanup; \
        -:  141:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  142:      yyerror(yyscanner, compiler, NULL); \
        -:  143:      YYERROR; \
        -:  144:    }
        -:  145:
        -:  146:
        -:  147:#define check_type(expression, expected_type, op) \
        -:  148:    check_type_with_cleanup(expression, expected_type, op, )
        -:  149:
        -:  150:
        -:  151:#line 152 "grammar.c"
        -:  152:
        -:  153:# ifndef YY_CAST
        -:  154:#  ifdef __cplusplus
        -:  155:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  156:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  157:#  else
        -:  158:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  159:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  160:#  endif
        -:  161:# endif
        -:  162:# ifndef YY_NULLPTR
        -:  163:#  if defined __cplusplus
        -:  164:#   if 201103L <= __cplusplus
        -:  165:#    define YY_NULLPTR nullptr
        -:  166:#   else
        -:  167:#    define YY_NULLPTR 0
        -:  168:#   endif
        -:  169:#  else
        -:  170:#   define YY_NULLPTR ((void*)0)
        -:  171:#  endif
        -:  172:# endif
        -:  173:
        -:  174:/* Enabling verbose error messages.  */
        -:  175:#ifdef YYERROR_VERBOSE
        -:  176:# undef YYERROR_VERBOSE
        -:  177:# define YYERROR_VERBOSE 1
        -:  178:#else
        -:  179:# define YYERROR_VERBOSE 0
        -:  180:#endif
        -:  181:
        -:  182:/* Use api.header.include to #include this header
        -:  183:   instead of duplicating it here.  */
        -:  184:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  185:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  186:/* Debug traces.  */
        -:  187:#ifndef YYDEBUG
        -:  188:# define YYDEBUG 0
        -:  189:#endif
        -:  190:#if YYDEBUG
        -:  191:extern int yara_yydebug;
        -:  192:#endif
        -:  193:
        -:  194:/* Token type.  */
        -:  195:#ifndef YYTOKENTYPE
        -:  196:# define YYTOKENTYPE
        -:  197:  enum yytokentype
        -:  198:  {
        -:  199:    _END_OF_FILE_ = 0,
        -:  200:    _END_OF_INCLUDED_FILE_ = 258,
        -:  201:    _DOT_DOT_ = 259,
        -:  202:    _RULE_ = 260,
        -:  203:    _PRIVATE_ = 261,
        -:  204:    _GLOBAL_ = 262,
        -:  205:    _META_ = 263,
        -:  206:    _STRINGS_ = 264,
        -:  207:    _CONDITION_ = 265,
        -:  208:    _IDENTIFIER_ = 266,
        -:  209:    _STRING_IDENTIFIER_ = 267,
        -:  210:    _STRING_COUNT_ = 268,
        -:  211:    _STRING_OFFSET_ = 269,
        -:  212:    _STRING_LENGTH_ = 270,
        -:  213:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 271,
        -:  214:    _NUMBER_ = 272,
        -:  215:    _DOUBLE_ = 273,
        -:  216:    _INTEGER_FUNCTION_ = 274,
        -:  217:    _TEXT_STRING_ = 275,
        -:  218:    _HEX_STRING_ = 276,
        -:  219:    _REGEXP_ = 277,
        -:  220:    _ASCII_ = 278,
        -:  221:    _WIDE_ = 279,
        -:  222:    _XOR_ = 280,
        -:  223:    _NOCASE_ = 281,
        -:  224:    _FULLWORD_ = 282,
        -:  225:    _AT_ = 283,
        -:  226:    _FILESIZE_ = 284,
        -:  227:    _ENTRYPOINT_ = 285,
        -:  228:    _ALL_ = 286,
        -:  229:    _ANY_ = 287,
        -:  230:    _IN_ = 288,
        -:  231:    _OF_ = 289,
        -:  232:    _FOR_ = 290,
        -:  233:    _THEM_ = 291,
        -:  234:    _MATCHES_ = 292,
        -:  235:    _CONTAINS_ = 293,
        -:  236:    _IMPORT_ = 294,
        -:  237:    _TRUE_ = 295,
        -:  238:    _FALSE_ = 296,
        -:  239:    _OR_ = 297,
        -:  240:    _AND_ = 298,
        -:  241:    _NOT_ = 299,
        -:  242:    _EQ_ = 300,
        -:  243:    _NEQ_ = 301,
        -:  244:    _LT_ = 302,
        -:  245:    _LE_ = 303,
        -:  246:    _GT_ = 304,
        -:  247:    _GE_ = 305,
        -:  248:    _SHIFT_LEFT_ = 306,
        -:  249:    _SHIFT_RIGHT_ = 307,
        -:  250:    UNARY_MINUS = 308
        -:  251:  };
        -:  252:#endif
        -:  253:/* Tokens.  */
        -:  254:#define _END_OF_FILE_ 0
        -:  255:#define _END_OF_INCLUDED_FILE_ 258
        -:  256:#define _DOT_DOT_ 259
        -:  257:#define _RULE_ 260
        -:  258:#define _PRIVATE_ 261
        -:  259:#define _GLOBAL_ 262
        -:  260:#define _META_ 263
        -:  261:#define _STRINGS_ 264
        -:  262:#define _CONDITION_ 265
        -:  263:#define _IDENTIFIER_ 266
        -:  264:#define _STRING_IDENTIFIER_ 267
        -:  265:#define _STRING_COUNT_ 268
        -:  266:#define _STRING_OFFSET_ 269
        -:  267:#define _STRING_LENGTH_ 270
        -:  268:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 271
        -:  269:#define _NUMBER_ 272
        -:  270:#define _DOUBLE_ 273
        -:  271:#define _INTEGER_FUNCTION_ 274
        -:  272:#define _TEXT_STRING_ 275
        -:  273:#define _HEX_STRING_ 276
        -:  274:#define _REGEXP_ 277
        -:  275:#define _ASCII_ 278
        -:  276:#define _WIDE_ 279
        -:  277:#define _XOR_ 280
        -:  278:#define _NOCASE_ 281
        -:  279:#define _FULLWORD_ 282
        -:  280:#define _AT_ 283
        -:  281:#define _FILESIZE_ 284
        -:  282:#define _ENTRYPOINT_ 285
        -:  283:#define _ALL_ 286
        -:  284:#define _ANY_ 287
        -:  285:#define _IN_ 288
        -:  286:#define _OF_ 289
        -:  287:#define _FOR_ 290
        -:  288:#define _THEM_ 291
        -:  289:#define _MATCHES_ 292
        -:  290:#define _CONTAINS_ 293
        -:  291:#define _IMPORT_ 294
        -:  292:#define _TRUE_ 295
        -:  293:#define _FALSE_ 296
        -:  294:#define _OR_ 297
        -:  295:#define _AND_ 298
        -:  296:#define _NOT_ 299
        -:  297:#define _EQ_ 300
        -:  298:#define _NEQ_ 301
        -:  299:#define _LT_ 302
        -:  300:#define _LE_ 303
        -:  301:#define _GT_ 304
        -:  302:#define _GE_ 305
        -:  303:#define _SHIFT_LEFT_ 306
        -:  304:#define _SHIFT_RIGHT_ 307
        -:  305:#define UNARY_MINUS 308
        -:  306:
        -:  307:/* Value type.  */
        -:  308:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  309:union YYSTYPE
        -:  310:{
        -:  311:#line 237 "grammar.y"
        -:  312:
        -:  313:  EXPRESSION      expression;
        -:  314:  SIZED_STRING*   sized_string;
        -:  315:  char*           c_string;
        -:  316:  int64_t         integer;
        -:  317:  double          double_;
        -:  318:  YR_STRING*      string;
        -:  319:  YR_META*        meta;
        -:  320:  YR_RULE*        rule;
        -:  321:
        -:  322:#line 323 "grammar.c"
        -:  323:
        -:  324:};
        -:  325:typedef union YYSTYPE YYSTYPE;
        -:  326:# define YYSTYPE_IS_TRIVIAL 1
        -:  327:# define YYSTYPE_IS_DECLARED 1
        -:  328:#endif
        -:  329:
        -:  330:
        -:  331:
        -:  332:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  333:
        -:  334:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  335:
        -:  336:
        -:  337:
        -:  338:#ifdef short
        -:  339:# undef short
        -:  340:#endif
        -:  341:
        -:  342:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  343:   <limits.h> and (if available) <stdint.h> are included
        -:  344:   so that the code can choose integer types of a good width.  */
        -:  345:
        -:  346:#ifndef __PTRDIFF_MAX__
        -:  347:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  348:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  349:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  350:#  define YY_STDINT_H
        -:  351:# endif
        -:  352:#endif
        -:  353:
        -:  354:/* Narrow types that promote to a signed type and that can represent a
        -:  355:   signed or unsigned integer of at least N bits.  In tables they can
        -:  356:   save space and decrease cache pressure.  Promoting to a signed type
        -:  357:   helps avoid bugs in integer arithmetic.  */
        -:  358:
        -:  359:#ifdef __INT_LEAST8_MAX__
        -:  360:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  361:#elif defined YY_STDINT_H
        -:  362:typedef int_least8_t yytype_int8;
        -:  363:#else
        -:  364:typedef signed char yytype_int8;
        -:  365:#endif
        -:  366:
        -:  367:#ifdef __INT_LEAST16_MAX__
        -:  368:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  369:#elif defined YY_STDINT_H
        -:  370:typedef int_least16_t yytype_int16;
        -:  371:#else
        -:  372:typedef short yytype_int16;
        -:  373:#endif
        -:  374:
        -:  375:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  376:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  377:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  378:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  379:typedef uint_least8_t yytype_uint8;
        -:  380:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  381:typedef unsigned char yytype_uint8;
        -:  382:#else
        -:  383:typedef short yytype_uint8;
        -:  384:#endif
        -:  385:
        -:  386:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  387:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  388:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  389:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  390:typedef uint_least16_t yytype_uint16;
        -:  391:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  392:typedef unsigned short yytype_uint16;
        -:  393:#else
        -:  394:typedef int yytype_uint16;
        -:  395:#endif
        -:  396:
        -:  397:#ifndef YYPTRDIFF_T
        -:  398:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  399:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  400:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  401:# elif defined PTRDIFF_MAX
        -:  402:#  ifndef ptrdiff_t
        -:  403:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  404:#  endif
        -:  405:#  define YYPTRDIFF_T ptrdiff_t
        -:  406:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  407:# else
        -:  408:#  define YYPTRDIFF_T long
        -:  409:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  410:# endif
        -:  411:#endif
        -:  412:
        -:  413:#ifndef YYSIZE_T
        -:  414:# ifdef __SIZE_TYPE__
        -:  415:#  define YYSIZE_T __SIZE_TYPE__
        -:  416:# elif defined size_t
        -:  417:#  define YYSIZE_T size_t
        -:  418:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  419:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  420:#  define YYSIZE_T size_t
        -:  421:# else
        -:  422:#  define YYSIZE_T unsigned
        -:  423:# endif
        -:  424:#endif
        -:  425:
        -:  426:#define YYSIZE_MAXIMUM                                  \
        -:  427:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  428:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  429:            ? YYPTRDIFF_MAXIMUM                         \
        -:  430:            : YY_CAST (YYSIZE_T, -1)))
        -:  431:
        -:  432:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  433:
        -:  434:/* Stored state numbers (used for stacks). */
        -:  435:typedef yytype_uint8 yy_state_t;
        -:  436:
        -:  437:/* State numbers in computations.  */
        -:  438:typedef int yy_state_fast_t;
        -:  439:
        -:  440:#ifndef YY_
        -:  441:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  442:#  if ENABLE_NLS
        -:  443:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  444:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  445:#  endif
        -:  446:# endif
        -:  447:# ifndef YY_
        -:  448:#  define YY_(Msgid) Msgid
        -:  449:# endif
        -:  450:#endif
        -:  451:
        -:  452:#ifndef YY_ATTRIBUTE_PURE
        -:  453:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  454:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  455:# else
        -:  456:#  define YY_ATTRIBUTE_PURE
        -:  457:# endif
        -:  458:#endif
        -:  459:
        -:  460:#ifndef YY_ATTRIBUTE_UNUSED
        -:  461:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  462:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  463:# else
        -:  464:#  define YY_ATTRIBUTE_UNUSED
        -:  465:# endif
        -:  466:#endif
        -:  467:
        -:  468:/* Suppress unused-variable warnings by "using" E.  */
        -:  469:#if ! defined lint || defined __GNUC__
        -:  470:# define YYUSE(E) ((void) (E))
        -:  471:#else
        -:  472:# define YYUSE(E) /* empty */
        -:  473:#endif
        -:  474:
        -:  475:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  476:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  477:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  478:    _Pragma ("GCC diagnostic push")                                     \
        -:  479:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  480:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  481:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  482:    _Pragma ("GCC diagnostic pop")
        -:  483:#else
        -:  484:# define YY_INITIAL_VALUE(Value) Value
        -:  485:#endif
        -:  486:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  487:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  488:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  489:#endif
        -:  490:#ifndef YY_INITIAL_VALUE
        -:  491:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  492:#endif
        -:  493:
        -:  494:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  495:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  496:    _Pragma ("GCC diagnostic push")                            \
        -:  497:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  498:# define YY_IGNORE_USELESS_CAST_END            \
        -:  499:    _Pragma ("GCC diagnostic pop")
        -:  500:#endif
        -:  501:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  502:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  503:# define YY_IGNORE_USELESS_CAST_END
        -:  504:#endif
        -:  505:
        -:  506:
        -:  507:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  508:
        -:  509:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  510:
        -:  511:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  512:
        -:  513:# ifdef YYSTACK_USE_ALLOCA
        -:  514:#  if YYSTACK_USE_ALLOCA
        -:  515:#   ifdef __GNUC__
        -:  516:#    define YYSTACK_ALLOC __builtin_alloca
        -:  517:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  518:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  519:#   elif defined _AIX
        -:  520:#    define YYSTACK_ALLOC __alloca
        -:  521:#   elif defined _MSC_VER
        -:  522:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  523:#    define alloca _alloca
        -:  524:#   else
        -:  525:#    define YYSTACK_ALLOC alloca
        -:  526:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  527:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  528:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  529:#     ifndef EXIT_SUCCESS
        -:  530:#      define EXIT_SUCCESS 0
        -:  531:#     endif
        -:  532:#    endif
        -:  533:#   endif
        -:  534:#  endif
        -:  535:# endif
        -:  536:
        -:  537:# ifdef YYSTACK_ALLOC
        -:  538:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  539:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  540:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  541:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  542:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  543:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  544:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  545:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  546:#  endif
        -:  547:# else
        -:  548:#  define YYSTACK_ALLOC YYMALLOC
        -:  549:#  define YYSTACK_FREE YYFREE
        -:  550:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  551:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  552:#  endif
        -:  553:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  554:       && ! ((defined YYMALLOC || defined malloc) \
        -:  555:             && (defined YYFREE || defined free)))
        -:  556:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  557:#   ifndef EXIT_SUCCESS
        -:  558:#    define EXIT_SUCCESS 0
        -:  559:#   endif
        -:  560:#  endif
        -:  561:#  ifndef YYMALLOC
        -:  562:#   define YYMALLOC malloc
        -:  563:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  564:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  565:#   endif
        -:  566:#  endif
        -:  567:#  ifndef YYFREE
        -:  568:#   define YYFREE free
        -:  569:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  570:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  571:#   endif
        -:  572:#  endif
        -:  573:# endif
        -:  574:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  575:
        -:  576:
        -:  577:#if (! defined yyoverflow \
        -:  578:     && (! defined __cplusplus \
        -:  579:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  580:
        -:  581:/* A type that is properly aligned for any stack member.  */
        -:  582:union yyalloc
        -:  583:{
        -:  584:  yy_state_t yyss_alloc;
        -:  585:  YYSTYPE yyvs_alloc;
        -:  586:};
        -:  587:
        -:  588:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  589:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  590:
        -:  591:/* The size of an array large to enough to hold all stacks, each with
        -:  592:   N elements.  */
        -:  593:# define YYSTACK_BYTES(N) \
        -:  594:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  595:      + YYSTACK_GAP_MAXIMUM)
        -:  596:
        -:  597:# define YYCOPY_NEEDED 1
        -:  598:
        -:  599:/* Relocate STACK from its old location to the new one.  The
        -:  600:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  601:   elements in the stack, and YYPTR gives the new location of the
        -:  602:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  603:   stack.  */
        -:  604:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  605:    do                                                                  \
        -:  606:      {                                                                 \
        -:  607:        YYPTRDIFF_T yynewbytes;                                         \
        -:  608:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  609:        Stack = &yyptr->Stack_alloc;                                    \
        -:  610:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  611:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  612:      }                                                                 \
        -:  613:    while (0)
        -:  614:
        -:  615:#endif
        -:  616:
        -:  617:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  618:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  619:   not overlap.  */
        -:  620:# ifndef YYCOPY
        -:  621:#  if defined __GNUC__ && 1 < __GNUC__
        -:  622:#   define YYCOPY(Dst, Src, Count) \
        -:  623:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  624:#  else
        -:  625:#   define YYCOPY(Dst, Src, Count)              \
        -:  626:      do                                        \
        -:  627:        {                                       \
        -:  628:          YYPTRDIFF_T yyi;                      \
        -:  629:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  630:            (Dst)[yyi] = (Src)[yyi];            \
        -:  631:        }                                       \
        -:  632:      while (0)
        -:  633:#  endif
        -:  634:# endif
        -:  635:#endif /* !YYCOPY_NEEDED */
        -:  636:
        -:  637:/* YYFINAL -- State number of the termination state.  */
        -:  638:#define YYFINAL  2
        -:  639:/* YYLAST -- Last index in YYTABLE.  */
        -:  640:#define YYLAST   374
        -:  641:
        -:  642:/* YYNTOKENS -- Number of terminals.  */
        -:  643:#define YYNTOKENS  74
        -:  644:/* YYNNTS -- Number of nonterminals.  */
        -:  645:#define YYNNTS  41
        -:  646:/* YYNRULES -- Number of rules.  */
        -:  647:#define YYNRULES  124
        -:  648:/* YYNSTATES -- Number of states.  */
        -:  649:#define YYNSTATES  212
        -:  650:
        -:  651:#define YYUNDEFTOK  2
        -:  652:#define YYMAXUTOK   309
        -:  653:
        -:  654:
        -:  655:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  656:   as returned by yylex, with out-of-bounds checking.  */
        -:  657:#define YYTRANSLATE(YYX)                                                \
        -:  658:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  659:
        -:  660:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  661:   as returned by yylex.  */
        -:  662:static const yytype_int8 yytranslate[] =
        -:  663:{
        -:  664:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  665:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  666:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  667:       2,     2,     2,     2,     2,     2,     2,    60,    55,     2,
        -:  668:      71,    72,    58,    56,    73,    57,    68,     2,     2,     2,
        -:  669:       2,     2,     2,     2,     2,     2,     2,     2,    66,     2,
        -:  670:       2,    67,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  671:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  672:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  673:       2,    69,    59,    70,    54,     2,     2,     2,     2,     2,
        -:  674:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  675:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  676:       2,     2,     2,    64,    53,    65,    61,     2,     2,     2,
        -:  677:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  678:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  679:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  680:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  681:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  682:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  683:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  684:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  685:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  686:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  687:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  688:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  689:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  690:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  691:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  692:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  693:      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
        -:  694:      45,    46,    47,    48,    49,    50,    51,    52,    62,    63
        -:  695:};
        -:  696:
        -:  697:#if YYDEBUG
        -:  698:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  699:static const yytype_int16 yyrline[] =
        -:  700:{
        -:  701:       0,   252,   252,   253,   254,   255,   256,   257,   258,   266,
        -:  702:     279,   284,   278,   305,   308,   338,   341,   366,   371,   372,
        -:  703:     377,   378,   384,   387,   405,   414,   453,   454,   459,   476,
        -:  704:     490,   504,   518,   536,   537,   543,   542,   558,   557,   573,
        -:  705:     587,   588,   593,   594,   595,   596,   597,   602,   688,   735,
        -:  706:     794,   840,   841,   845,   873,   913,   956,   976,   983,   990,
        -:  707:    1002,  1012,  1026,  1041,  1052,  1063,  1092,  1062,  1206,  1205,
        -:  708:    1283,  1289,  1296,  1295,  1341,  1340,  1384,  1391,  1398,  1405,
        -:  709:    1412,  1419,  1426,  1430,  1438,  1439,  1444,  1468,  1481,  1499,
        -:  710:    1498,  1504,  1516,  1517,  1522,  1529,  1540,  1541,  1545,  1553,
        -:  711:    1557,  1565,  1577,  1591,  1599,  1606,  1631,  1643,  1655,  1671,
        -:  712:    1683,  1699,  1746,  1767,  1802,  1837,  1871,  1896,  1913,  1923,
        -:  713:    1933,  1943,  1953,  1973,  1993
        -:  714:};
        -:  715:#endif
        -:  716:
        -:  717:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  718:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  719:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  720:static const char *const yytname[] =
        -:  721:{
        -:  722:  "\"end of file\"", "error", "$undefined", "\"end of included file\"",
        -:  723:  "\"..\"", "\"<rule>\"", "\"<private>\"", "\"<global>\"", "\"<meta>\"",
        -:  724:  "\"<strings>\"", "\"<condition>\"", "\"identifier\"",
        -:  725:  "\"string identifier\"", "\"string count\"", "\"string offset\"",
        -:  726:  "\"string length\"", "\"string identifier with wildcard\"",
        -:  727:  "\"integer number\"", "\"floating point number\"",
        -:  728:  "\"integer function\"", "\"text string\"", "\"hex string\"",
        -:  729:  "\"regular expression\"", "\"<ascii>\"", "\"<wide>\"", "\"<xor>\"",
        -:  730:  "\"<nocase>\"", "\"<fullword>\"", "\"<at>\"", "\"<filesize>\"",
        -:  731:  "\"<entrypoint>\"", "\"<all>\"", "\"<any>\"", "\"<in>\"", "\"<of>\"",
        -:  732:  "\"<for>\"", "\"<them>\"", "\"<matches>\"", "\"<contains>\"",
        -:  733:  "\"<import>\"", "\"<true>\"", "\"<false\"", "\"<or>\"", "\"<and>\"",
        -:  734:  "\"<not>\"", "\"==\"", "\"!=\"", "\"<\"", "\"<=\"", "\">\"", "\">=\"",
        -:  735:  "\"<<\"", "\">>\"", "'|'", "'^'", "'&'", "'+'", "'-'", "'*'", "'\\\\'",
        -:  736:  "'%'", "'~'", "UNARY_MINUS", "\"include\"", "'{'", "'}'", "':'", "'='",
        -:  737:  "'.'", "'['", "']'", "'('", "')'", "','", "$accept", "rules", "import",
        -:  738:  "rule", "@1", "$@2", "meta", "strings", "condition", "rule_modifiers",
        -:  739:  "rule_modifier", "tags", "tag_list", "meta_declarations",
        -:  740:  "meta_declaration", "string_declarations", "string_declaration", "$@3",
        -:  741:  "$@4", "string_modifiers", "string_modifier", "identifier", "arguments",
        -:  742:  "arguments_list", "regexp", "boolean_expression", "expression", "$@5",
        -:  743:  "$@6", "$@7", "$@8", "$@9", "integer_set", "range",
        -:  744:  "integer_enumeration", "string_set", "$@10", "string_enumeration",
        -:  745:  "string_enumeration_item", "for_expression", "primary_expression", YY_NULLPTR
        -:  746:};
        -:  747:#endif
        -:  748:
        -:  749:# ifdef YYPRINT
        -:  750:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  751:   (internal) symbol number NUM (which must be that of a token).  */
        -:  752:static const yytype_int16 yytoknum[] =
        -:  753:{
        -:  754:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  755:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  756:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  757:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  758:     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
        -:  759:     305,   306,   307,   124,    94,    38,    43,    45,    42,    92,
        -:  760:      37,   126,   308,   309,   123,   125,    58,    61,    46,    91,
        -:  761:      93,    40,    41,    44
        -:  762:};
        -:  763:# endif
        -:  764:
        -:  765:#define YYPACT_NINF (-74)
        -:  766:
        -:  767:#define yypact_value_is_default(Yyn) \
        -:  768:  ((Yyn) == YYPACT_NINF)
        -:  769:
        -:  770:#define YYTABLE_NINF (-97)
        -:  771:
        -:  772:#define yytable_value_is_error(Yyn) \
        -:  773:  0
        -:  774:
        -:  775:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  776:     STATE-NUM.  */
        -:  777:static const yytype_int16 yypact[] =
        -:  778:{
        -:  779:     -74,    95,   -74,   -30,   -74,   -12,   -74,   -74,    79,   -74,
        -:  780:     -74,   -74,   -74,    -7,   -74,   -74,   -74,   -74,   -55,     4,
        -:  781:     -42,   -74,    23,    18,   -74,     9,    59,    83,    33,   -74,
        -:  782:      30,    83,   -74,   107,   117,    15,   -74,    65,   107,   -74,
        -:  783:      69,    72,   -74,   -74,   -74,   -74,   121,     8,   -74,    47,
        -:  784:     -74,   -74,   -74,   124,   123,   -74,   -16,   -74,    70,    77,
        -:  785:     -74,   -74,    89,   -74,   -74,   -74,   -74,   -74,   -74,   111,
        -:  786:     -74,   -74,    47,   136,   136,    47,    12,   -74,    28,   -74,
        -:  787:     114,   212,   -74,   -74,   136,    91,   136,   136,   136,   136,
        -:  788:       2,   314,   -74,   -74,   -74,    28,    85,   184,   152,   136,
        -:  789:      47,   -74,   -74,    -8,   142,   136,   136,   136,   136,   136,
        -:  790:     136,   136,   136,   136,   136,   136,   136,   136,   136,   136,
        -:  791:     136,   136,    86,    86,   314,   136,   -74,   254,   274,   132,
        -:  792:     222,   -74,   134,    -8,   -74,   -74,   -74,   294,    97,   108,
        -:  793:      64,    47,    47,   -74,   -74,   -74,   -74,   314,   314,   314,
        -:  794:     314,   314,   314,   314,   195,   195,   119,   143,   168,    57,
        -:  795:      57,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  796:     157,   -74,   -74,   -74,   -74,   130,   -74,   -74,    47,   137,
        -:  797:     -74,    -2,   136,   135,   -74,    64,   -74,   -74,    17,   -74,
        -:  798:     232,   136,   139,   -74,   174,   -74,    -2,   -74,    48,   157,
        -:  799:     -74,    47,   -74,   -74,   136,   176,   -18,   314,    47,   -74,
        -:  800:      31,   -74
        -:  801:};
        -:  802:
        -:  803:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  804:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  805:     means the default is an error.  */
        -:  806:static const yytype_int8 yydefact[] =
        -:  807:{
        -:  808:       2,     0,     1,    18,     8,     0,     4,     3,     0,     7,
        -:  809:       6,     5,     9,     0,    20,    21,    19,    10,    22,     0,
        -:  810:       0,    24,    23,    13,    25,     0,    15,     0,     0,    11,
        -:  811:       0,    14,    26,     0,     0,     0,    27,     0,    16,    33,
        -:  812:       0,     0,    29,    28,    31,    32,     0,    35,    34,     0,
        -:  813:      12,    30,    39,     0,     0,    47,    61,   106,   108,   110,
        -:  814:     103,   104,     0,   105,    55,   100,   101,    97,    98,     0,
        -:  815:      57,    58,     0,     0,     0,     0,   111,   124,    17,    56,
        -:  816:       0,    82,    40,    40,     0,     0,     0,     0,     0,     0,
        -:  817:       0,    96,    71,   112,   121,     0,    56,    82,     0,     0,
        -:  818:      51,    74,    72,     0,     0,     0,     0,     0,     0,     0,
        -:  819:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  820:       0,     0,    36,    38,    62,     0,    63,     0,     0,     0,
        -:  821:       0,    64,     0,     0,    83,    99,    48,     0,     0,    52,
        -:  822:      53,     0,     0,    91,    89,    70,    59,    60,    80,    81,
        -:  823:      76,    78,    77,    79,   122,   123,   120,   118,   119,   113,
        -:  824:     114,   115,   116,   117,    43,    42,    46,    44,    45,    41,
        -:  825:       0,   107,   109,   102,    65,     0,    49,    50,     0,    75,
        -:  826:      73,     0,     0,     0,    68,    54,    94,    95,     0,    92,
        -:  827:       0,     0,     0,    85,     0,    90,     0,    86,     0,    87,
        -:  828:      66,     0,    93,    84,     0,     0,     0,    88,     0,    69,
        -:  829:       0,    67
        -:  830:};
        -:  831:
        -:  832:  /* YYPGOTO[NTERM-NUM].  */
        -:  833:static const yytype_int16 yypgoto[] =
        -:  834:{
        -:  835:     -74,   -74,   220,   245,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  836:     -74,   -74,   -74,   -74,   262,   -74,   257,   -74,   -74,   213,
        -:  837:     -74,   -74,   -74,   -74,   193,   -49,   -73,   -74,   -74,   -74,
        -:  838:     -74,   -74,   -74,   115,   -74,   166,   -74,   -74,   104,   233,
        -:  839:     -68
        -:  840:};
        -:  841:
        -:  842:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  843:static const yytype_int16 yydefgoto[] =
        -:  844:{
        -:  845:      -1,     1,     6,     7,    18,    34,    26,    29,    41,     8,
        -:  846:      16,    20,    22,    31,    32,    38,    39,    53,    54,   122,
        -:  847:     169,    76,   138,   139,    77,    95,    79,   183,   205,   194,
        -:  848:     142,   141,   192,   126,   198,   145,   181,   188,   189,    80,
        -:  849:      81
        -:  850:};
        -:  851:
        -:  852:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  853:     positive, shift that token.  If negative, reduce the rule whose
        -:  854:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  855:static const yytype_int16 yytable[] =
        -:  856:{
        -:  857:      78,    91,    96,   131,    17,    93,    94,    97,    12,     5,
        -:  858:     186,    19,    84,   132,   187,    21,   124,    85,   127,   128,
        -:  859:     129,   130,    23,    92,   101,   102,    25,   140,   143,    52,
        -:  860:     -37,   137,    42,     9,    24,    43,   133,   147,   148,   149,
        -:  861:     150,   151,   152,   153,   154,   155,   156,   157,   158,   159,
        -:  862:     160,   161,   162,   163,   209,    44,    45,   170,    55,    56,
        -:  863:      57,    58,    59,   144,    60,    61,    62,    63,    28,    64,
        -:  864:     101,   102,    46,   101,   102,    27,    65,    66,    67,    68,
        -:  865:      98,    99,    69,   100,    13,    14,    15,    70,    71,   195,
        -:  866:     196,    72,   179,   180,    30,     2,     3,    35,     4,    33,
        -:  867:     -18,   -18,   -18,   211,    73,   185,   -56,   -56,    74,   164,
        -:  868:     165,   166,   167,   168,   190,   119,   120,   121,    75,    37,
        -:  869:     203,   204,    55,   199,    57,    58,    59,    40,    60,    61,
        -:  870:      62,    63,    47,    64,     5,    49,   207,    50,    51,    86,
        -:  871:      65,    66,    67,    68,    82,    83,    87,    55,   103,    57,
        -:  872:      58,    59,   206,    60,    61,    62,    63,   134,    64,   210,
        -:  873:      88,   182,   125,   136,    64,    65,    66,   174,    73,   177,
        -:  874:     112,   113,    74,   115,   116,   117,   118,   119,   120,   121,
        -:  875:     102,   178,    89,   112,   113,   114,   115,   116,   117,   118,
        -:  876:     119,   120,   121,    73,   112,   113,   184,    74,   116,   117,
        -:  877:     118,   119,   120,   121,   173,   200,   191,    89,   112,   113,
        -:  878:     114,   115,   116,   117,   118,   119,   120,   121,   -96,   112,
        -:  879:     113,   104,   105,    10,   117,   118,   119,   120,   121,   106,
        -:  880:     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
        -:  881:     117,   118,   119,   120,   121,   201,   -96,   208,    11,   104,
        -:  882:     105,   117,   118,   119,   120,   121,   135,   106,   107,   108,
        -:  883:     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
        -:  884:     119,   120,   121,   112,   113,   114,   115,   116,   117,   118,
        -:  885:     119,   120,   121,   112,   113,   114,   115,   116,   117,   118,
        -:  886:     119,   120,   121,    36,   135,    48,   123,   146,   193,   175,
        -:  887:     202,     0,    90,     0,   197,   112,   113,   114,   115,   116,
        -:  888:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  889:       0,     0,     0,     0,   171,   112,   113,   114,   115,   116,
        -:  890:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  891:       0,     0,     0,     0,   172,   112,   113,   114,   115,   116,
        -:  892:     117,   118,   119,   120,   121,     0,     0,     0,     0,     0,
        -:  893:       0,     0,     0,     0,   176,   112,   113,   114,   115,   116,
        -:  894:     117,   118,   119,   120,   121
        -:  895:};
        -:  896:
        -:  897:static const yytype_int16 yycheck[] =
        -:  898:{
        -:  899:      49,    69,    75,     1,    11,    73,    74,    75,    20,    39,
        -:  900:      12,    66,    28,    11,    16,    11,    84,    33,    86,    87,
        -:  901:      88,    89,    64,    72,    42,    43,     8,   100,    36,    21,
        -:  902:      22,    99,    17,    63,    11,    20,    34,   105,   106,   107,
        -:  903:     108,   109,   110,   111,   112,   113,   114,   115,   116,   117,
        -:  904:     118,   119,   120,   121,    72,    40,    41,   125,    11,    12,
        -:  905:      13,    14,    15,    71,    17,    18,    19,    20,     9,    22,
        -:  906:      42,    43,    57,    42,    43,    66,    29,    30,    31,    32,
        -:  907:      68,    69,    35,    71,     5,     6,     7,    40,    41,    72,
        -:  908:      73,    44,   141,   142,    11,     0,     1,    67,     3,    66,
        -:  909:       5,     6,     7,    72,    57,   178,    42,    43,    61,    23,
        -:  910:      24,    25,    26,    27,   182,    58,    59,    60,    71,    12,
        -:  911:      72,    73,    11,   191,    13,    14,    15,    10,    17,    18,
        -:  912:      19,    20,    67,    22,    39,    66,   204,    65,    17,    69,
        -:  913:      29,    30,    31,    32,    20,    22,    69,    11,    34,    13,
        -:  914:      14,    15,   201,    17,    18,    19,    20,    72,    22,   208,
        -:  915:      71,     4,    71,    11,    22,    29,    30,    33,    57,    72,
        -:  916:      51,    52,    61,    54,    55,    56,    57,    58,    59,    60,
        -:  917:      43,    73,    71,    51,    52,    53,    54,    55,    56,    57,
        -:  918:      58,    59,    60,    57,    51,    52,    66,    61,    55,    56,
        -:  919:      57,    58,    59,    60,    72,    66,    71,    71,    51,    52,
        -:  920:      53,    54,    55,    56,    57,    58,    59,    60,    34,    51,
        -:  921:      52,    37,    38,     3,    56,    57,    58,    59,    60,    45,
        -:  922:      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
        -:  923:      56,    57,    58,    59,    60,    71,    34,    71,     3,    37,
        -:  924:      38,    56,    57,    58,    59,    60,    72,    45,    46,    47,
        -:  925:      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
        -:  926:      58,    59,    60,    51,    52,    53,    54,    55,    56,    57,
        -:  927:      58,    59,    60,    51,    52,    53,    54,    55,    56,    57,
        -:  928:      58,    59,    60,    31,    72,    38,    83,   104,   183,   133,
        -:  929:     196,    -1,    69,    -1,    72,    51,    52,    53,    54,    55,
        -:  930:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  931:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  932:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  933:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  934:      56,    57,    58,    59,    60,    -1,    -1,    -1,    -1,    -1,
        -:  935:      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
        -:  936:      56,    57,    58,    59,    60
        -:  937:};
        -:  938:
        -:  939:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  940:     symbol of state STATE-NUM.  */
        -:  941:static const yytype_int8 yystos[] =
        -:  942:{
        -:  943:       0,    75,     0,     1,     3,    39,    76,    77,    83,    63,
        -:  944:      76,    77,    20,     5,     6,     7,    84,    11,    78,    66,
        -:  945:      85,    11,    86,    64,    11,     8,    80,    66,     9,    81,
        -:  946:      11,    87,    88,    66,    79,    67,    88,    12,    89,    90,
        -:  947:      10,    82,    17,    20,    40,    41,    57,    67,    90,    66,
        -:  948:      65,    17,    21,    91,    92,    11,    12,    13,    14,    15,
        -:  949:      17,    18,    19,    20,    22,    29,    30,    31,    32,    35,
        -:  950:      40,    41,    44,    57,    61,    71,    95,    98,    99,   100,
        -:  951:     113,   114,    20,    22,    28,    33,    69,    69,    71,    71,
        -:  952:     113,   114,    99,   114,   114,    99,   100,   114,    68,    69,
        -:  953:      71,    42,    43,    34,    37,    38,    45,    46,    47,    48,
        -:  954:      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
        -:  955:      59,    60,    93,    93,   114,    71,   107,   114,   114,   114,
        -:  956:     114,     1,    11,    34,    72,    72,    11,   114,    96,    97,
        -:  957:     100,   105,   104,    36,    71,   109,    98,   114,   114,   114,
        -:  958:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  959:     114,   114,   114,   114,    23,    24,    25,    26,    27,    94,
        -:  960:     114,    70,    70,    72,    33,   109,    70,    72,    73,    99,
        -:  961:      99,   110,     4,   101,    66,   100,    12,    16,   111,   112,
        -:  962:     114,    71,   106,   107,   103,    72,    73,    72,   108,   114,
        -:  963:      66,    71,   112,    72,    73,   102,    99,   114,    71,    72,
        -:  964:      99,    72
        -:  965:};
        -:  966:
        -:  967:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  968:static const yytype_int8 yyr1[] =
        -:  969:{
        -:  970:       0,    74,    75,    75,    75,    75,    75,    75,    75,    76,
        -:  971:      78,    79,    77,    80,    80,    81,    81,    82,    83,    83,
        -:  972:      84,    84,    85,    85,    86,    86,    87,    87,    88,    88,
        -:  973:      88,    88,    88,    89,    89,    91,    90,    92,    90,    90,
        -:  974:      93,    93,    94,    94,    94,    94,    94,    95,    95,    95,
        -:  975:      95,    96,    96,    97,    97,    98,    99,   100,   100,   100,
        -:  976:     100,   100,   100,   100,   100,   101,   102,   100,   103,   100,
        -:  977:     100,   100,   104,   100,   105,   100,   100,   100,   100,   100,
        -:  978:     100,   100,   100,   100,   106,   106,   107,   108,   108,   110,
        -:  979:     109,   109,   111,   111,   112,   112,   113,   113,   113,   114,
        -:  980:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  981:     114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
        -:  982:     114,   114,   114,   114,   114
        -:  983:};
        -:  984:
        -:  985:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  986:static const yytype_int8 yyr2[] =
        -:  987:{
        -:  988:       0,     2,     0,     2,     2,     3,     3,     3,     2,     2,
        -:  989:       0,     0,    11,     0,     3,     0,     3,     3,     0,     2,
        -:  990:       1,     1,     0,     2,     1,     2,     1,     2,     3,     3,
        -:  991:       4,     3,     3,     1,     2,     0,     5,     0,     5,     3,
        -:  992:       0,     2,     1,     1,     1,     1,     1,     1,     3,     4,
        -:  993:       4,     0,     1,     1,     3,     1,     1,     1,     1,     3,
        -:  994:       3,     1,     3,     3,     3,     0,     0,    11,     0,     9,
        -:  995:       3,     2,     0,     4,     0,     4,     3,     3,     3,     3,
        -:  996:       3,     3,     1,     3,     3,     1,     5,     1,     3,     0,
        -:  997:       4,     1,     1,     3,     1,     1,     1,     1,     1,     3,
        -:  998:       1,     1,     4,     1,     1,     1,     1,     4,     1,     4,
        -:  999:       1,     1,     2,     3,     3,     3,     3,     3,     3,     3,
        -: 1000:       3,     2,     3,     3,     1
        -: 1001:};
        -: 1002:
        -: 1003:
        -: 1004:#define yyerrok         (yyerrstatus = 0)
        -: 1005:#define yyclearin       (yychar = YYEMPTY)
        -: 1006:#define YYEMPTY         (-2)
        -: 1007:#define YYEOF           0
        -: 1008:
        -: 1009:#define YYACCEPT        goto yyacceptlab
        -: 1010:#define YYABORT         goto yyabortlab
        -: 1011:#define YYERROR         goto yyerrorlab
        -: 1012:
        -: 1013:
        -: 1014:#define YYRECOVERING()  (!!yyerrstatus)
        -: 1015:
        -: 1016:#define YYBACKUP(Token, Value)                                    \
        -: 1017:  do                                                              \
        -: 1018:    if (yychar == YYEMPTY)                                        \
        -: 1019:      {                                                           \
        -: 1020:        yychar = (Token);                                         \
        -: 1021:        yylval = (Value);                                         \
        -: 1022:        YYPOPSTACK (yylen);                                       \
        -: 1023:        yystate = *yyssp;                                         \
        -: 1024:        goto yybackup;                                            \
        -: 1025:      }                                                           \
        -: 1026:    else                                                          \
        -: 1027:      {                                                           \
        -: 1028:        yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -: 1029:        YYERROR;                                                  \
        -: 1030:      }                                                           \
        -: 1031:  while (0)
        -: 1032:
        -: 1033:/* Error token number */
        -: 1034:#define YYTERROR        1
        -: 1035:#define YYERRCODE       256
        -: 1036:
        -: 1037:
        -: 1038:
        -: 1039:/* Enable debugging if requested.  */
        -: 1040:#if YYDEBUG
        -: 1041:
        -: 1042:# ifndef YYFPRINTF
        -: 1043:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -: 1044:#  define YYFPRINTF fprintf
        -: 1045:# endif
        -: 1046:
        -: 1047:# define YYDPRINTF(Args)                        \
        -: 1048:do {                                            \
        -: 1049:  if (yydebug)                                  \
        -: 1050:    YYFPRINTF Args;                             \
        -: 1051:} while (0)
        -: 1052:
        -: 1053:/* This macro is provided for backward compatibility. */
        -: 1054:#ifndef YY_LOCATION_PRINT
        -: 1055:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -: 1056:#endif
        -: 1057:
        -: 1058:
        -: 1059:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -: 1060:do {                                                                      \
        -: 1061:  if (yydebug)                                                            \
        -: 1062:    {                                                                     \
        -: 1063:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -: 1064:      yy_symbol_print (stderr,                                            \
        -: 1065:                  Type, Value, yyscanner, compiler); \
        -: 1066:      YYFPRINTF (stderr, "\n");                                           \
        -: 1067:    }                                                                     \
        -: 1068:} while (0)
        -: 1069:
        -: 1070:
        -: 1071:/*-----------------------------------.
        -: 1072:| Print this symbol's value on YYO.  |
        -: 1073:`-----------------------------------*/
        -: 1074:
        -: 1075:static void
        -: 1076:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1077:{
        -: 1078:  FILE *yyoutput = yyo;
        -: 1079:  YYUSE (yyoutput);
        -: 1080:  YYUSE (yyscanner);
        -: 1081:  YYUSE (compiler);
        -: 1082:  if (!yyvaluep)
        -: 1083:    return;
        -: 1084:# ifdef YYPRINT
        -: 1085:  if (yytype < YYNTOKENS)
        -: 1086:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -: 1087:# endif
        -: 1088:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -: 1089:  YYUSE (yytype);
        -: 1090:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1091:}
        -: 1092:
        -: 1093:
        -: 1094:/*---------------------------.
        -: 1095:| Print this symbol on YYO.  |
        -: 1096:`---------------------------*/
        -: 1097:
        -: 1098:static void
        -: 1099:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1100:{
        -: 1101:  YYFPRINTF (yyo, "%s %s (",
        -: 1102:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1103:
        -: 1104:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, compiler);
        -: 1105:  YYFPRINTF (yyo, ")");
        -: 1106:}
        -: 1107:
        -: 1108:/*------------------------------------------------------------------.
        -: 1109:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1110:| TOP (included).                                                   |
        -: 1111:`------------------------------------------------------------------*/
        -: 1112:
        -: 1113:static void
        -: 1114:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -: 1115:{
        -: 1116:  YYFPRINTF (stderr, "Stack now");
        -: 1117:  for (; yybottom <= yytop; yybottom++)
        -: 1118:    {
        -: 1119:      int yybot = *yybottom;
        -: 1120:      YYFPRINTF (stderr, " %d", yybot);
        -: 1121:    }
        -: 1122:  YYFPRINTF (stderr, "\n");
        -: 1123:}
        -: 1124:
        -: 1125:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1126:do {                                                            \
        -: 1127:  if (yydebug)                                                  \
        -: 1128:    yy_stack_print ((Bottom), (Top));                           \
        -: 1129:} while (0)
        -: 1130:
        -: 1131:
        -: 1132:/*------------------------------------------------.
        -: 1133:| Report that the YYRULE is going to be reduced.  |
        -: 1134:`------------------------------------------------*/
        -: 1135:
        -: 1136:static void
        -: 1137:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1138:{
        -: 1139:  int yylno = yyrline[yyrule];
        -: 1140:  int yynrhs = yyr2[yyrule];
        -: 1141:  int yyi;
        -: 1142:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -: 1143:             yyrule - 1, yylno);
        -: 1144:  /* The symbols being reduced.  */
        -: 1145:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1146:    {
        -: 1147:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1148:      yy_symbol_print (stderr,
        -: 1149:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -: 1150:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -: 1151:                                              , yyscanner, compiler);
        -: 1152:      YYFPRINTF (stderr, "\n");
        -: 1153:    }
        -: 1154:}
        -: 1155:
        -: 1156:# define YY_REDUCE_PRINT(Rule)          \
        -: 1157:do {                                    \
        -: 1158:  if (yydebug)                          \
        -: 1159:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1160:} while (0)
        -: 1161:
        -: 1162:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1163:   multiple parsers can coexist.  */
        -: 1164:int yydebug;
        -: 1165:#else /* !YYDEBUG */
        -: 1166:# define YYDPRINTF(Args)
        -: 1167:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1168:# define YY_STACK_PRINT(Bottom, Top)
        -: 1169:# define YY_REDUCE_PRINT(Rule)
        -: 1170:#endif /* !YYDEBUG */
        -: 1171:
        -: 1172:
        -: 1173:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1174:#ifndef YYINITDEPTH
        -: 1175:# define YYINITDEPTH 200
        -: 1176:#endif
        -: 1177:
        -: 1178:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1179:   if the built-in stack extension method is used).
        -: 1180:
        -: 1181:   Do not make this value too large; the results are undefined if
        -: 1182:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1183:   evaluated with infinite-precision integer arithmetic.  */
        -: 1184:
        -: 1185:#ifndef YYMAXDEPTH
        -: 1186:# define YYMAXDEPTH 10000
        -: 1187:#endif
        -: 1188:
        -: 1189:
        -: 1190:#if YYERROR_VERBOSE
        -: 1191:
        -: 1192:# ifndef yystrlen
        -: 1193:#  if defined __GLIBC__ && defined _STRING_H
        -: 1194:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -: 1195:#  else
        -: 1196:/* Return the length of YYSTR.  */
        -: 1197:static YYPTRDIFF_T
        -: 1198:yystrlen (const char *yystr)
        -: 1199:{
        -: 1200:  YYPTRDIFF_T yylen;
        -: 1201:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1202:    continue;
        -: 1203:  return yylen;
        -: 1204:}
        -: 1205:#  endif
        -: 1206:# endif
        -: 1207:
        -: 1208:# ifndef yystpcpy
        -: 1209:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1210:#   define yystpcpy stpcpy
        -: 1211:#  else
        -: 1212:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1213:   YYDEST.  */
        -: 1214:static char *
    #####: 1215:yystpcpy (char *yydest, const char *yysrc)
        -: 1216:{
    #####: 1217:  char *yyd = yydest;
    #####: 1218:  const char *yys = yysrc;
        -: 1219:
    #####: 1220:  while ((*yyd++ = *yys++) != '\0')
    #####: 1221:    continue;
        -: 1222:
    #####: 1223:  return yyd - 1;
        -: 1224:}
        -: 1225:#  endif
        -: 1226:# endif
        -: 1227:
        -: 1228:# ifndef yytnamerr
        -: 1229:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1230:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1231:   heuristic is that double-quoting is unnecessary unless the string
        -: 1232:   contains an apostrophe, a comma, or backslash (other than
        -: 1233:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1234:   null, do not copy; instead, return the length of what the result
        -: 1235:   would have been.  */
        -: 1236:static YYPTRDIFF_T
       12: 1237:yytnamerr (char *yyres, const char *yystr)
        -: 1238:{
       12: 1239:  if (*yystr == '"')
        -: 1240:    {
       12: 1241:      YYPTRDIFF_T yyn = 0;
       12: 1242:      char const *yyp = yystr;
        -: 1243:
        -: 1244:      for (;;)
      144: 1245:        switch (*++yyp)
        -: 1246:          {
    #####: 1247:          case '\'':
        -: 1248:          case ',':
    #####: 1249:            goto do_not_strip_quotes;
        -: 1250:
    #####: 1251:          case '\\':
    #####: 1252:            if (*++yyp != '\\')
    #####: 1253:              goto do_not_strip_quotes;
        -: 1254:            else
    #####: 1255:              goto append;
        -: 1256:
      132: 1257:          append:
        -: 1258:          default:
      132: 1259:            if (yyres)
       66: 1260:              yyres[yyn] = *yyp;
      132: 1261:            yyn++;
      132: 1262:            break;
        -: 1263:
       12: 1264:          case '"':
       12: 1265:            if (yyres)
        6: 1266:              yyres[yyn] = '\0';
       12: 1267:            return yyn;
        -: 1268:          }
    #####: 1269:    do_not_strip_quotes: ;
        -: 1270:    }
        -: 1271:
    #####: 1272:  if (yyres)
    #####: 1273:    return yystpcpy (yyres, yystr) - yyres;
        -: 1274:  else
    #####: 1275:    return yystrlen (yystr);
        -: 1276:}
        -: 1277:# endif
        -: 1278:
        -: 1279:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1280:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1281:   YYSSP.
        -: 1282:
        -: 1283:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1284:   not large enough to hold the message.  In that case, also set
        -: 1285:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1286:   required number of bytes is too large to store.  */
        -: 1287:static int
        3: 1288:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -: 1289:                yy_state_t *yyssp, int yytoken)
        -: 1290:{
        -: 1291:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1292:  /* Internationalized format string. */
        3: 1293:  const char *yyformat = YY_NULLPTR;
        -: 1294:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -: 1295:     one per "expected"). */
        -: 1296:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1297:  /* Actual size of YYARG. */
        3: 1298:  int yycount = 0;
        -: 1299:  /* Cumulated lengths of YYARG.  */
        3: 1300:  YYPTRDIFF_T yysize = 0;
        -: 1301:
        -: 1302:  /* There are many possibilities here to consider:
        -: 1303:     - If this state is a consistent state with a default action, then
        -: 1304:       the only way this function was invoked is if the default action
        -: 1305:       is an error action.  In that case, don't check for expected
        -: 1306:       tokens because there are none.
        -: 1307:     - The only way there can be no lookahead present (in yychar) is if
        -: 1308:       this state is a consistent state with a default action.  Thus,
        -: 1309:       detecting the absence of a lookahead is sufficient to determine
        -: 1310:       that there is no unexpected or expected token to report.  In that
        -: 1311:       case, just report a simple "syntax error".
        -: 1312:     - Don't assume there isn't a lookahead just because this state is a
        -: 1313:       consistent state with a default action.  There might have been a
        -: 1314:       previous inconsistent state, consistent state with a non-default
        -: 1315:       action, or user semantic action that manipulated yychar.
        -: 1316:     - Of course, the expected token list depends on states to have
        -: 1317:       correct lookahead information, and it depends on the parser not
        -: 1318:       to perform extra reductions after fetching a lookahead from the
        -: 1319:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1320:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1321:       token list.  However, the list is correct for canonical LR with
        -: 1322:       one exception: it will still contain any token that will not be
        -: 1323:       accepted due to an error action in a later state.
        -: 1324:  */
        3: 1325:  if (yytoken != YYEMPTY)
        -: 1326:    {
        3: 1327:      int yyn = yypact[+*yyssp];
        3: 1328:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
        3: 1329:      yysize = yysize0;
        3: 1330:      yyarg[yycount++] = yytname[yytoken];
        3: 1331:      if (!yypact_value_is_default (yyn))
        -: 1332:        {
        -: 1333:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1334:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1335:             this state because they are default actions.  */
       3*: 1336:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1337:          /* Stay within bounds of both yycheck and yytname.  */
        3: 1338:          int yychecklim = YYLAST - yyn + 1;
        3: 1339:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1340:          int yyx;
        -: 1341:
      225: 1342:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
      222: 1343:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
        3: 1344:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1345:              {
        3: 1346:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1347:                  {
    #####: 1348:                    yycount = 1;
    #####: 1349:                    yysize = yysize0;
    #####: 1350:                    break;
        -: 1351:                  }
        3: 1352:                yyarg[yycount++] = yytname[yyx];
        -: 1353:                {
        3: 1354:                  YYPTRDIFF_T yysize1
        3: 1355:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
        3: 1356:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        3: 1357:                    yysize = yysize1;
        -: 1358:                  else
    #####: 1359:                    return 2;
        -: 1360:                }
        -: 1361:              }
        -: 1362:        }
        -: 1363:    }
        -: 1364:
        3: 1365:  switch (yycount)
        -: 1366:    {
        -: 1367:# define YYCASE_(N, S)                      \
        -: 1368:      case N:                               \
        -: 1369:        yyformat = S;                       \
        -: 1370:      break
    #####: 1371:    default: /* Avoid compiler warnings. */
    #####: 1372:      YYCASE_(0, YY_("syntax error"));
    #####: 1373:      YYCASE_(1, YY_("syntax error, unexpected %s"));
        3: 1374:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1375:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1376:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1377:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1378:# undef YYCASE_
        -: 1379:    }
        -: 1380:
        -: 1381:  {
        -: 1382:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1383:       the terminator.  */
        3: 1384:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
        3: 1385:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        3: 1386:      yysize = yysize1;
        -: 1387:    else
    #####: 1388:      return 2;
        -: 1389:  }
        -: 1390:
        3: 1391:  if (*yymsg_alloc < yysize)
        -: 1392:    {
    #####: 1393:      *yymsg_alloc = 2 * yysize;
    #####: 1394:      if (! (yysize <= *yymsg_alloc
        -: 1395:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1396:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1397:      return 1;
        -: 1398:    }
        -: 1399:
        -: 1400:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1401:     Don't have undefined behavior even if the translation
        -: 1402:     produced a string with the wrong number of "%s"s.  */
        -: 1403:  {
        3: 1404:    char *yyp = *yymsg;
        3: 1405:    int yyi = 0;
      120: 1406:    while ((*yyp = *yyformat) != '\0')
      117: 1407:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1408:        {
        6: 1409:          yyp += yytnamerr (yyp, yyarg[yyi++]);
        6: 1410:          yyformat += 2;
        -: 1411:        }
        -: 1412:      else
        -: 1413:        {
      111: 1414:          ++yyp;
      111: 1415:          ++yyformat;
        -: 1416:        }
        -: 1417:  }
        3: 1418:  return 0;
        -: 1419:}
        -: 1420:#endif /* YYERROR_VERBOSE */
        -: 1421:
        -: 1422:/*-----------------------------------------------.
        -: 1423:| Release the memory associated to this symbol.  |
        -: 1424:`-----------------------------------------------*/
        -: 1425:
        -: 1426:static void
      902: 1427:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1428:{
        -: 1429:  YYUSE (yyvaluep);
        -: 1430:  YYUSE (yyscanner);
        -: 1431:  YYUSE (compiler);
      902: 1432:  if (!yymsg)
    #####: 1433:    yymsg = "Deleting";
        -: 1434:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1435:
        -: 1436:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
      902: 1437:  switch (yytype)
        -: 1438:    {
       16: 1439:    case 11: /* "identifier"  */
        -: 1440:#line 224 "grammar.y"
        -: 1441:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1442:#line 1443 "grammar.c"
       16: 1443:        break;
        -: 1444:
       15: 1445:    case 12: /* "string identifier"  */
        -: 1446:#line 228 "grammar.y"
        -: 1447:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1448:#line 1449 "grammar.c"
       15: 1449:        break;
        -: 1450:
    #####: 1451:    case 13: /* "string count"  */
        -: 1452:#line 225 "grammar.y"
        -: 1453:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1454:#line 1455 "grammar.c"
    #####: 1455:        break;
        -: 1456:
    #####: 1457:    case 14: /* "string offset"  */
        -: 1458:#line 226 "grammar.y"
        -: 1459:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1460:#line 1461 "grammar.c"
    #####: 1461:        break;
        -: 1462:
    #####: 1463:    case 15: /* "string length"  */
        -: 1464:#line 227 "grammar.y"
        -: 1465:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1466:#line 1467 "grammar.c"
    #####: 1467:        break;
        -: 1468:
    #####: 1469:    case 16: /* "string identifier with wildcard"  */
        -: 1470:#line 229 "grammar.y"
        -: 1471:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1472:#line 1473 "grammar.c"
    #####: 1473:        break;
        -: 1474:
    #####: 1475:    case 20: /* "text string"  */
        -: 1476:#line 230 "grammar.y"
        -: 1477:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1478:#line 1479 "grammar.c"
    #####: 1479:        break;
        -: 1480:
    #####: 1481:    case 21: /* "hex string"  */
        -: 1482:#line 231 "grammar.y"
        -: 1483:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1484:#line 1485 "grammar.c"
    #####: 1485:        break;
        -: 1486:
    #####: 1487:    case 22: /* "regular expression"  */
        -: 1488:#line 232 "grammar.y"
        -: 1489:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1490:#line 1491 "grammar.c"
    #####: 1491:        break;
        -: 1492:
    #####: 1493:    case 96: /* arguments  */
        -: 1494:#line 234 "grammar.y"
        -: 1495:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1496:#line 1497 "grammar.c"
    #####: 1497:        break;
        -: 1498:
    #####: 1499:    case 97: /* arguments_list  */
        -: 1500:#line 235 "grammar.y"
        -: 1501:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1502:#line 1503 "grammar.c"
    #####: 1503:        break;
        -: 1504:
      871: 1505:      default:
      871: 1506:        break;
        -: 1507:    }
        -: 1508:  YY_IGNORE_MAYBE_UNINITIALIZED_END
      902: 1509:}
        -: 1510:
        -: 1511:
        -: 1512:
        -: 1513:
        -: 1514:/*----------.
        -: 1515:| yyparse.  |
        -: 1516:`----------*/
        -: 1517:
        -: 1518:int
      282: 1519:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1520:{
        -: 1521:/* The lookahead symbol.  */
        -: 1522:int yychar;
        -: 1523:
        -: 1524:
        -: 1525:/* The semantic value of the lookahead symbol.  */
        -: 1526:/* Default value used for initialization, for pacifying older GCCs
        -: 1527:   or non-GCC compilers.  */
        -: 1528:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1529:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1530:
        -: 1531:    /* Number of syntax errors so far.  */
        -: 1532:    int yynerrs;
        -: 1533:
        -: 1534:    yy_state_fast_t yystate;
        -: 1535:    /* Number of tokens to shift before error messages enabled.  */
        -: 1536:    int yyerrstatus;
        -: 1537:
        -: 1538:    /* The stacks and their tools:
        -: 1539:       'yyss': related to states.
        -: 1540:       'yyvs': related to semantic values.
        -: 1541:
        -: 1542:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1543:       to reallocate them elsewhere.  */
        -: 1544:
        -: 1545:    /* The state stack.  */
        -: 1546:    yy_state_t yyssa[YYINITDEPTH];
        -: 1547:    yy_state_t *yyss;
        -: 1548:    yy_state_t *yyssp;
        -: 1549:
        -: 1550:    /* The semantic value stack.  */
        -: 1551:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1552:    YYSTYPE *yyvs;
        -: 1553:    YYSTYPE *yyvsp;
        -: 1554:
        -: 1555:    YYPTRDIFF_T yystacksize;
        -: 1556:
        -: 1557:  int yyn;
        -: 1558:  int yyresult;
        -: 1559:  /* Lookahead token as an internal (translated) token number.  */
      282: 1560:  int yytoken = 0;
        -: 1561:  /* The variables used to return semantic value and location from the
        -: 1562:     action routines.  */
        -: 1563:  YYSTYPE yyval;
        -: 1564:
        -: 1565:#if YYERROR_VERBOSE
        -: 1566:  /* Buffer for error messages, and its allocated size.  */
        -: 1567:  char yymsgbuf[128];
      282: 1568:  char *yymsg = yymsgbuf;
      282: 1569:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1570:#endif
        -: 1571:
        -: 1572:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1573:
        -: 1574:  /* The number of symbols on the RHS of the reduced rule.
        -: 1575:     Keep to zero when no symbol should be popped.  */
      282: 1576:  int yylen = 0;
        -: 1577:
      282: 1578:  yyssp = yyss = yyssa;
      282: 1579:  yyvsp = yyvs = yyvsa;
      282: 1580:  yystacksize = YYINITDEPTH;
        -: 1581:
        -: 1582:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1583:
      282: 1584:  yystate = 0;
      282: 1585:  yyerrstatus = 0;
      282: 1586:  yynerrs = 0;
      282: 1587:  yychar = YYEMPTY; /* Cause a token to be read.  */
      282: 1588:  goto yysetstate;
        -: 1589:
        -: 1590:
        -: 1591:/*------------------------------------------------------------.
        -: 1592:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1593:`------------------------------------------------------------*/
     8181: 1594:yynewstate:
        -: 1595:  /* In all cases, when you get here, the value and location stacks
        -: 1596:     have just been pushed.  So pushing a state here evens the stacks.  */
     8181: 1597:  yyssp++;
        -: 1598:
        -: 1599:
        -: 1600:/*--------------------------------------------------------------------.
        -: 1601:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1602:`--------------------------------------------------------------------*/
     8463: 1603:yysetstate:
        -: 1604:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1605:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1606:  YY_IGNORE_USELESS_CAST_BEGIN
     8463: 1607:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1608:  YY_IGNORE_USELESS_CAST_END
        -: 1609:
     8463: 1610:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1611:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1612:    goto yyexhaustedlab;
        -: 1613:#else
        -: 1614:    {
        -: 1615:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1616:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1617:
        -: 1618:# if defined yyoverflow
        -: 1619:      {
        -: 1620:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1621:           these so that the &'s don't force the real ones into
        -: 1622:           memory.  */
        -: 1623:        yy_state_t *yyss1 = yyss;
        -: 1624:        YYSTYPE *yyvs1 = yyvs;
        -: 1625:
        -: 1626:        /* Each stack pointer address is followed by the size of the
        -: 1627:           data in use in that stack, in bytes.  This used to be a
        -: 1628:           conditional around just the two extra args, but that might
        -: 1629:           be undefined if yyoverflow is a macro.  */
        -: 1630:        yyoverflow (YY_("memory exhausted"),
        -: 1631:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1632:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1633:                    &yystacksize);
        -: 1634:        yyss = yyss1;
        -: 1635:        yyvs = yyvs1;
        -: 1636:      }
        -: 1637:# else /* defined YYSTACK_RELOCATE */
        -: 1638:      /* Extend the stack our own way.  */
    #####: 1639:      if (YYMAXDEPTH <= yystacksize)
    #####: 1640:        goto yyexhaustedlab;
    #####: 1641:      yystacksize *= 2;
    #####: 1642:      if (YYMAXDEPTH < yystacksize)
    #####: 1643:        yystacksize = YYMAXDEPTH;
        -: 1644:
        -: 1645:      {
    #####: 1646:        yy_state_t *yyss1 = yyss;
        -: 1647:        union yyalloc *yyptr =
    #####: 1648:          YY_CAST (union yyalloc *,
        -: 1649:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1650:        if (! yyptr)
    #####: 1651:          goto yyexhaustedlab;
    #####: 1652:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1653:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1654:# undef YYSTACK_RELOCATE
    #####: 1655:        if (yyss1 != yyssa)
    #####: 1656:          YYSTACK_FREE (yyss1);
        -: 1657:      }
        -: 1658:# endif
        -: 1659:
    #####: 1660:      yyssp = yyss + yysize - 1;
    #####: 1661:      yyvsp = yyvs + yysize - 1;
        -: 1662:
        -: 1663:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1664:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1665:                  YY_CAST (long, yystacksize)));
        -: 1666:      YY_IGNORE_USELESS_CAST_END
        -: 1667:
    #####: 1668:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1669:        YYABORT;
        -: 1670:    }
        -: 1671:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1672:
     8463: 1673:  if (yystate == YYFINAL)
      266: 1674:    YYACCEPT;
        -: 1675:
     8197: 1676:  goto yybackup;
        -: 1677:
        -: 1678:
        -: 1679:/*-----------.
        -: 1680:| yybackup.  |
        -: 1681:`-----------*/
     8197: 1682:yybackup:
        -: 1683:  /* Do appropriate processing given the current state.  Read a
        -: 1684:     lookahead token if we need one and don't already have one.  */
        -: 1685:
        -: 1686:  /* First try to decide what to do without reference to lookahead token.  */
     8197: 1687:  yyn = yypact[yystate];
     8197: 1688:  if (yypact_value_is_default (yyn))
     2230: 1689:    goto yydefault;
        -: 1690:
        -: 1691:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1692:
        -: 1693:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
     5967: 1694:  if (yychar == YYEMPTY)
        -: 1695:    {
        -: 1696:      YYDPRINTF ((stderr, "Reading a token: "));
     3685: 1697:      yychar = yylex (&yylval, yyscanner, compiler);
        -: 1698:    }
        -: 1699:
     5967: 1700:  if (yychar <= YYEOF)
        -: 1701:    {
      305: 1702:      yychar = yytoken = YYEOF;
        -: 1703:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1704:    }
        -: 1705:  else
        -: 1706:    {
    5662*: 1707:      yytoken = YYTRANSLATE (yychar);
        -: 1708:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1709:    }
        -: 1710:
        -: 1711:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1712:     detect an error, take that action.  */
     5967: 1713:  yyn += yytoken;
     5967: 1714:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     1789: 1715:    goto yydefault;
     4178: 1716:  yyn = yytable[yyn];
     4178: 1717:  if (yyn <= 0)
        -: 1718:    {
        -: 1719:      if (yytable_value_is_error (yyn))
        -: 1720:        goto yyerrlab;
      561: 1721:      yyn = -yyn;
      561: 1722:      goto yyreduce;
        -: 1723:    }
        -: 1724:
        -: 1725:  /* Count tokens shifted since error; after three, turn off error
        -: 1726:     status.  */
     3617: 1727:  if (yyerrstatus)
    #####: 1728:    yyerrstatus--;
        -: 1729:
        -: 1730:  /* Shift the lookahead token.  */
        -: 1731:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
     3617: 1732:  yystate = yyn;
        -: 1733:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
     3617: 1734:  *++yyvsp = yylval;
        -: 1735:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1736:
        -: 1737:  /* Discard the shifted token.  */
     3617: 1738:  yychar = YYEMPTY;
     3617: 1739:  goto yynewstate;
        -: 1740:
        -: 1741:
        -: 1742:/*-----------------------------------------------------------.
        -: 1743:| yydefault -- do the default action for the current state.  |
        -: 1744:`-----------------------------------------------------------*/
     4019: 1745:yydefault:
     4019: 1746:  yyn = yydefact[yystate];
     4019: 1747:  if (yyn == 0)
       71: 1748:    goto yyerrlab;
     3948: 1749:  goto yyreduce;
        -: 1750:
        -: 1751:
        -: 1752:/*-----------------------------.
        -: 1753:| yyreduce -- do a reduction.  |
        -: 1754:`-----------------------------*/
     4509: 1755:yyreduce:
        -: 1756:  /* yyn is the number of a rule to reduce with.  */
     4509: 1757:  yylen = yyr2[yyn];
        -: 1758:
        -: 1759:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1760:     '$$ = $1'.
        -: 1761:
        -: 1762:     Otherwise, the following line sets YYVAL to garbage.
        -: 1763:     This behavior is undocumented and Bison
        -: 1764:     users should not rely upon it.  Assigning to YYVAL
        -: 1765:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1766:     GCC warning that YYVAL may be used uninitialized.  */
     4509: 1767:  yyval = yyvsp[1-yylen];
        -: 1768:
        -: 1769:
        -: 1770:  YY_REDUCE_PRINT (yyn);
     4509: 1771:  switch (yyn)
        -: 1772:    {
    #####: 1773:  case 8:
        -: 1774:#line 259 "grammar.y"
        -: 1775:      {
        -: 1776:        _yr_compiler_pop_file_name(compiler);
        -: 1777:      }
        -: 1778:#line 1779 "grammar.c"
    #####: 1779:    break;
        -: 1780:
    #####: 1781:  case 9:
        -: 1782:#line 267 "grammar.y"
        -: 1783:      {
        -: 1784:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1785:
        -: 1786:        yr_free((yyvsp[0].sized_string));
        -: 1787:
        -: 1788:        fail_if_error(result);
        -: 1789:      }
        -: 1790:#line 1791 "grammar.c"
    #####: 1791:    break;
        -: 1792:
      282: 1793:  case 10:
        -: 1794:#line 279 "grammar.y"
        -: 1795:      {
        -: 1796:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1797:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1798:      }
        -: 1799:#line 1800 "grammar.c"
      282: 1800:    break;
        -: 1801:
      267: 1802:  case 11:
        -: 1803:#line 284 "grammar.y"
        -: 1804:      {
        -: 1805:        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1
        -: 1806:
        -: 1807:        rule->tags = (yyvsp[-3].c_string);
        -: 1808:        rule->metas = (yyvsp[-1].meta);
        -: 1809:        rule->strings = (yyvsp[0].string);
        -: 1810:      }
        -: 1811:#line 1812 "grammar.c"
      267: 1812:    break;
        -: 1813:
      266: 1814:  case 12:
        -: 1815:#line 292 "grammar.y"
        -: 1816:      {
        -: 1817:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1818:            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1
        -: 1819:
        -: 1820:        yr_free((yyvsp[-8].c_string));
        -: 1821:
        -: 1822:        fail_if_error(result);
        -: 1823:      }
        -: 1824:#line 1825 "grammar.c"
      266: 1825:    break;
        -: 1826:
      282: 1827:  case 13:
        -: 1828:#line 305 "grammar.y"
        -: 1829:      {
        -: 1830:        (yyval.meta) = NULL;
        -: 1831:      }
        -: 1832:#line 1833 "grammar.c"
      282: 1833:    break;
        -: 1834:
    #####: 1835:  case 14:
        -: 1836:#line 309 "grammar.y"
        -: 1837:      {
        -: 1838:        int result;
        -: 1839:
        -: 1840:        // Each rule have a list of meta-data info, consisting in a
        -: 1841:        // sequence of YR_META structures. The last YR_META structure does
        -: 1842:        // not represent a real meta-data, it's just a end-of-list marker
        -: 1843:        // identified by a specific type (META_TYPE_NULL). Here we
        -: 1844:        // write the end-of-list marker.
        -: 1845:
        -: 1846:        YR_META null_meta;
        -: 1847:
        -: 1848:        memset(&null_meta, 0xFF, sizeof(YR_META));
        -: 1849:        null_meta.type = META_TYPE_NULL;
        -: 1850:
        -: 1851:        result = yr_arena_write_data(
        -: 1852:            compiler->metas_arena,
        -: 1853:            &null_meta,
        -: 1854:            sizeof(YR_META),
        -: 1855:            NULL);
        -: 1856:
        -: 1857:        (yyval.meta) = (yyvsp[0].meta);
        -: 1858:
        -: 1859:        fail_if_error(result);
        -: 1860:      }
        -: 1861:#line 1862 "grammar.c"
    #####: 1862:    break;
        -: 1863:
    #####: 1864:  case 15:
        -: 1865:#line 338 "grammar.y"
        -: 1866:      {
        -: 1867:        (yyval.string) = NULL;
        -: 1868:      }
        -: 1869:#line 1870 "grammar.c"
    #####: 1870:    break;
        -: 1871:
      267: 1872:  case 16:
        -: 1873:#line 342 "grammar.y"
        -: 1874:      {
        -: 1875:        // Each rule have a list of strings, consisting in a sequence
        -: 1876:        // of YR_STRING structures. The last YR_STRING structure does not
        -: 1877:        // represent a real string, it's just a end-of-list marker
        -: 1878:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -: 1879:        // write the end-of-list marker.
        -: 1880:
        -: 1881:        YR_STRING null_string;
        -: 1882:
        -: 1883:        memset(&null_string, 0xFF, sizeof(YR_STRING));
        -: 1884:        null_string.g_flags = STRING_GFLAGS_NULL;
        -: 1885:
        -: 1886:        fail_if_error(yr_arena_write_data(
        -: 1887:            compiler->strings_arena,
        -: 1888:            &null_string,
        -: 1889:            sizeof(YR_STRING),
        -: 1890:            NULL));
        -: 1891:
        -: 1892:        (yyval.string) = (yyvsp[0].string);
        -: 1893:      }
        -: 1894:#line 1895 "grammar.c"
      267: 1895:    break;
        -: 1896:
      350: 1897:  case 18:
        -: 1898:#line 371 "grammar.y"
        -: 1899:                                       { (yyval.integer) = 0;  }
        -: 1900:#line 1901 "grammar.c"
      350: 1901:    break;
        -: 1902:
    #####: 1903:  case 19:
        -: 1904:#line 372 "grammar.y"
        -: 1905:                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1906:#line 1907 "grammar.c"
    #####: 1907:    break;
        -: 1908:
    #####: 1909:  case 20:
        -: 1910:#line 377 "grammar.y"
        -: 1911:                     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
        -: 1912:#line 1913 "grammar.c"
    #####: 1913:    break;
        -: 1914:
    #####: 1915:  case 21:
        -: 1916:#line 378 "grammar.y"
        -: 1917:                     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
        -: 1918:#line 1919 "grammar.c"
    #####: 1919:    break;
        -: 1920:
      282: 1921:  case 22:
        -: 1922:#line 384 "grammar.y"
        -: 1923:      {
        -: 1924:        (yyval.c_string) = NULL;
        -: 1925:      }
        -: 1926:#line 1927 "grammar.c"
      282: 1927:    break;
        -: 1928:
    #####: 1929:  case 23:
        -: 1930:#line 388 "grammar.y"
        -: 1931:      {
        -: 1932:        // Tags list is represented in the arena as a sequence
        -: 1933:        // of null-terminated strings, the sequence ends with an
        -: 1934:        // additional null character. Here we write the ending null
        -: 1935:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 1936:
        -: 1937:        int result = yr_arena_write_string(
        -: 1938:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -: 1939:
        -: 1940:        fail_if_error(result);
        -: 1941:
        -: 1942:        (yyval.c_string) = (yyvsp[0].c_string);
        -: 1943:      }
        -: 1944:#line 1945 "grammar.c"
    #####: 1945:    break;
        -: 1946:
    #####: 1947:  case 24:
        -: 1948:#line 406 "grammar.y"
        -: 1949:      {
        -: 1950:        int result = yr_arena_write_string(
        -: 1951:            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));
        -: 1952:
        -: 1953:        yr_free((yyvsp[0].c_string));
        -: 1954:
        -: 1955:        fail_if_error(result);
        -: 1956:      }
        -: 1957:#line 1958 "grammar.c"
    #####: 1958:    break;
        -: 1959:
    #####: 1960:  case 25:
        -: 1961:#line 415 "grammar.y"
        -: 1962:      {
        -: 1963:        int result = ERROR_SUCCESS;
        -: 1964:
        -: 1965:        char* tag_name = (yyvsp[-1].c_string);
        -: 1966:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1967:
        -: 1968:        while (tag_length > 0)
        -: 1969:        {
        -: 1970:          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
        -: 1971:          {
        -: 1972:            yr_compiler_set_error_extra_info(compiler, tag_name);
        -: 1973:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
        -: 1974:            break;
        -: 1975:          }
        -: 1976:
        -: 1977:          tag_name = (char*) yr_arena_next_address(
        -: 1978:              yyget_extra(yyscanner)->sz_arena,
        -: 1979:              tag_name,
        -: 1980:              tag_length + 1);
        -: 1981:
        -: 1982:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1983:        }
        -: 1984:
        -: 1985:        if (result == ERROR_SUCCESS)
        -: 1986:          result = yr_arena_write_string(
        -: 1987:              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
        -: 1988:
        -: 1989:        yr_free((yyvsp[0].c_string));
        -: 1990:
        -: 1991:        fail_if_error(result);
        -: 1992:
        -: 1993:        (yyval.c_string) = (yyvsp[-1].c_string);
        -: 1994:      }
        -: 1995:#line 1996 "grammar.c"
    #####: 1996:    break;
        -: 1997:
    #####: 1998:  case 26:
        -: 1999:#line 453 "grammar.y"
        -: 2000:                                          {  (yyval.meta) = (yyvsp[0].meta); }
        -: 2001:#line 2002 "grammar.c"
    #####: 2002:    break;
        -: 2003:
    #####: 2004:  case 27:
        -: 2005:#line 454 "grammar.y"
        -: 2006:                                          {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 2007:#line 2008 "grammar.c"
    #####: 2008:    break;
        -: 2009:
    #####: 2010:  case 28:
        -: 2011:#line 460 "grammar.y"
        -: 2012:      {
        -: 2013:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2014:
        -: 2015:        int result = yr_parser_reduce_meta_declaration(
        -: 2016:            yyscanner,
        -: 2017:            META_TYPE_STRING,
        -: 2018:            (yyvsp[-2].c_string),
        -: 2019:            sized_string->c_string,
        -: 2020:            0,
        -: 2021:            &(yyval.meta));
        -: 2022:
        -: 2023:        yr_free((yyvsp[-2].c_string));
        -: 2024:        yr_free((yyvsp[0].sized_string));
        -: 2025:
        -: 2026:        fail_if_error(result);
        -: 2027:      }
        -: 2028:#line 2029 "grammar.c"
    #####: 2029:    break;
        -: 2030:
    #####: 2031:  case 29:
        -: 2032:#line 477 "grammar.y"
        -: 2033:      {
        -: 2034:        int result = yr_parser_reduce_meta_declaration(
        -: 2035:            yyscanner,
        -: 2036:            META_TYPE_INTEGER,
        -: 2037:            (yyvsp[-2].c_string),
        -: 2038:            NULL,
        -: 2039:            (yyvsp[0].integer),
        -: 2040:            &(yyval.meta));
        -: 2041:
        -: 2042:        yr_free((yyvsp[-2].c_string));
        -: 2043:
        -: 2044:        fail_if_error(result);
        -: 2045:      }
        -: 2046:#line 2047 "grammar.c"
    #####: 2047:    break;
        -: 2048:
    #####: 2049:  case 30:
        -: 2050:#line 491 "grammar.y"
        -: 2051:      {
        -: 2052:        int result = yr_parser_reduce_meta_declaration(
        -: 2053:            yyscanner,
        -: 2054:            META_TYPE_INTEGER,
        -: 2055:            (yyvsp[-3].c_string),
        -: 2056:            NULL,
        -: 2057:            -(yyvsp[0].integer),
        -: 2058:            &(yyval.meta));
        -: 2059:
        -: 2060:        yr_free((yyvsp[-3].c_string));
        -: 2061:
        -: 2062:        fail_if_error(result);
        -: 2063:      }
        -: 2064:#line 2065 "grammar.c"
    #####: 2065:    break;
        -: 2066:
    #####: 2067:  case 31:
        -: 2068:#line 505 "grammar.y"
        -: 2069:      {
        -: 2070:        int result = yr_parser_reduce_meta_declaration(
        -: 2071:            yyscanner,
        -: 2072:            META_TYPE_BOOLEAN,
        -: 2073:            (yyvsp[-2].c_string),
        -: 2074:            NULL,
        -: 2075:            true,
        -: 2076:            &(yyval.meta));
        -: 2077:
        -: 2078:        yr_free((yyvsp[-2].c_string));
        -: 2079:
        -: 2080:        fail_if_error(result);
        -: 2081:      }
        -: 2082:#line 2083 "grammar.c"
    #####: 2083:    break;
        -: 2084:
    #####: 2085:  case 32:
        -: 2086:#line 519 "grammar.y"
        -: 2087:      {
        -: 2088:        int result = yr_parser_reduce_meta_declaration(
        -: 2089:            yyscanner,
        -: 2090:            META_TYPE_BOOLEAN,
        -: 2091:            (yyvsp[-2].c_string),
        -: 2092:            NULL,
        -: 2093:            false,
        -: 2094:            &(yyval.meta));
        -: 2095:
        -: 2096:        yr_free((yyvsp[-2].c_string));
        -: 2097:
        -: 2098:        fail_if_error(result);
        -: 2099:      }
        -: 2100:#line 2101 "grammar.c"
    #####: 2101:    break;
        -: 2102:
      267: 2103:  case 33:
        -: 2104:#line 536 "grammar.y"
        -: 2105:                                              { (yyval.string) = (yyvsp[0].string); }
        -: 2106:#line 2107 "grammar.c"
      267: 2107:    break;
        -: 2108:
    #####: 2109:  case 34:
        -: 2110:#line 537 "grammar.y"
        -: 2111:                                              { (yyval.string) = (yyvsp[-1].string); }
        -: 2112:#line 2113 "grammar.c"
    #####: 2113:    break;
        -: 2114:
        3: 2115:  case 35:
        -: 2116:#line 543 "grammar.y"
        -: 2117:      {
        -: 2118:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2119:      }
        -: 2120:#line 2121 "grammar.c"
        3: 2121:    break;
        -: 2122:
        1: 2123:  case 36:
        -: 2124:#line 547 "grammar.y"
        -: 2125:      {
        -: 2126:        int result = yr_parser_reduce_string_declaration(
        -: 2127:            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2128:
        -: 2129:        yr_free((yyvsp[-4].c_string));
        -: 2130:        yr_free((yyvsp[-1].sized_string));
        -: 2131:
        -: 2132:        fail_if_error(result);
        -: 2133:        compiler->current_line = 0;
        -: 2134:      }
        -: 2135:#line 2136 "grammar.c"
        1: 2136:    break;
        -: 2137:
      279: 2138:  case 37:
        -: 2139:#line 558 "grammar.y"
        -: 2140:      {
        -: 2141:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2142:      }
        -: 2143:#line 2144 "grammar.c"
      279: 2144:    break;
        -: 2145:
      279: 2146:  case 38:
        -: 2147:#line 562 "grammar.y"
        -: 2148:      {
        -: 2149:        int result = yr_parser_reduce_string_declaration(
        -: 2150:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2151:
        -: 2152:        yr_free((yyvsp[-4].c_string));
        -: 2153:        yr_free((yyvsp[-1].sized_string));
        -: 2154:
        -: 2155:        fail_if_error(result);
        -: 2156:
        -: 2157:        compiler->current_line = 0;
        -: 2158:      }
        -: 2159:#line 2160 "grammar.c"
      266: 2160:    break;
        -: 2161:
    #####: 2162:  case 39:
        -: 2163:#line 574 "grammar.y"
        -: 2164:      {
        -: 2165:        int result = yr_parser_reduce_string_declaration(
        -: 2166:            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));
        -: 2167:
        -: 2168:        yr_free((yyvsp[-2].c_string));
        -: 2169:        yr_free((yyvsp[0].sized_string));
        -: 2170:
        -: 2171:        fail_if_error(result);
        -: 2172:      }
        -: 2173:#line 2174 "grammar.c"
    #####: 2174:    break;
        -: 2175:
      280: 2176:  case 40:
        -: 2177:#line 587 "grammar.y"
        -: 2178:                                          { (yyval.integer) = 0; }
        -: 2179:#line 2180 "grammar.c"
      280: 2180:    break;
        -: 2181:
       25: 2182:  case 41:
        -: 2183:#line 588 "grammar.y"
        -: 2184:                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2185:#line 2186 "grammar.c"
       25: 2186:    break;
        -: 2187:
       14: 2188:  case 42:
        -: 2189:#line 593 "grammar.y"
        -: 2190:                    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2191:#line 2192 "grammar.c"
       14: 2192:    break;
        -: 2193:
    #####: 2194:  case 43:
        -: 2195:#line 594 "grammar.y"
        -: 2196:                    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2197:#line 2198 "grammar.c"
    #####: 2198:    break;
        -: 2199:
        9: 2200:  case 44:
        -: 2201:#line 595 "grammar.y"
        -: 2202:                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2203:#line 2204 "grammar.c"
        9: 2204:    break;
        -: 2205:
        2: 2206:  case 45:
        -: 2207:#line 596 "grammar.y"
        -: 2208:                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2209:#line 2210 "grammar.c"
        2: 2210:    break;
        -: 2211:
    #####: 2212:  case 46:
        -: 2213:#line 597 "grammar.y"
        -: 2214:                    { (yyval.integer) = STRING_GFLAGS_XOR; }
        -: 2215:#line 2216 "grammar.c"
    #####: 2216:    break;
        -: 2217:
    #####: 2218:  case 47:
        -: 2219:#line 603 "grammar.y"
        -: 2220:      {
        -: 2221:        int result = ERROR_SUCCESS;
        -: 2222:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
        -: 2223:
        -: 2224:        if (var_index >= 0)
        -: 2225:        {
        -: 2226:          result = yr_parser_emit_with_arg(
        -: 2227:              yyscanner,
        -: 2228:              OP_PUSH_M,
        -: 2229:              LOOP_LOCAL_VARS * var_index,
        -: 2230:              NULL,
        -: 2231:              NULL);
        -: 2232:
        -: 2233:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 2234:          (yyval.expression).value.integer = UNDEFINED;
        -: 2235:          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        -: 2236:        }
        -: 2237:        else
        -: 2238:        {
        -: 2239:          // Search for identifier within the global namespace, where the
        -: 2240:          // externals variables reside.
        -: 2241:
        -: 2242:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2243:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2244:
        -: 2245:          if (object == NULL)
        -: 2246:          {
        -: 2247:            // If not found, search within the current namespace.
        -: 2248:            char* ns = compiler->current_namespace->name;
        -: 2249:
        -: 2250:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2251:                compiler->objects_table, (yyvsp[0].c_string), ns);
        -: 2252:          }
        -: 2253:
        -: 2254:          if (object != NULL)
        -: 2255:          {
        -: 2256:            char* id;
        -: 2257:
        -: 2258:            result = yr_arena_write_string(
        -: 2259:                compiler->sz_arena, (yyvsp[0].c_string), &id);
        -: 2260:
        -: 2261:            if (result == ERROR_SUCCESS)
        -: 2262:              result = yr_parser_emit_with_arg_reloc(
        -: 2263:                  yyscanner,
        -: 2264:                  OP_OBJ_LOAD,
        -: 2265:                  id,
        -: 2266:                  NULL,
        -: 2267:                  NULL);
        -: 2268:
        -: 2269:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2270:            (yyval.expression).value.object = object;
        -: 2271:            (yyval.expression).identifier = object->identifier;
        -: 2272:          }
        -: 2273:          else
        -: 2274:          {
        -: 2275:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -: 2276:                compiler->rules_table,
        -: 2277:                (yyvsp[0].c_string),
        -: 2278:                compiler->current_namespace->name);
        -: 2279:
        -: 2280:            if (rule != NULL)
        -: 2281:            {
        -: 2282:              result = yr_parser_emit_with_arg_reloc(
        -: 2283:                  yyscanner,
        -: 2284:                  OP_PUSH_RULE,
        -: 2285:                  rule,
        -: 2286:                  NULL,
        -: 2287:                  NULL);
        -: 2288:
        -: 2289:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2290:              (yyval.expression).value.integer = UNDEFINED;
        -: 2291:              (yyval.expression).identifier = rule->identifier;
        -: 2292:            }
        -: 2293:            else
        -: 2294:            {
        -: 2295:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2296:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2297:            }
        -: 2298:          }
        -: 2299:        }
        -: 2300:
        -: 2301:        yr_free((yyvsp[0].c_string));
        -: 2302:
        -: 2303:        fail_if_error(result);
        -: 2304:      }
        -: 2305:#line 2306 "grammar.c"
    #####: 2306:    break;
        -: 2307:
    #####: 2308:  case 48:
        -: 2309:#line 689 "grammar.y"
        -: 2310:      {
        -: 2311:        int result = ERROR_SUCCESS;
        -: 2312:        YR_OBJECT* field = NULL;
        -: 2313:
        -: 2314:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2315:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2316:        {
        -: 2317:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2318:
        -: 2319:          if (field != NULL)
        -: 2320:          {
        -: 2321:            char* ident;
        -: 2322:
        -: 2323:            result = yr_arena_write_string(
        -: 2324:                compiler->sz_arena, (yyvsp[0].c_string), &ident);
        -: 2325:
        -: 2326:            if (result == ERROR_SUCCESS)
        -: 2327:              result = yr_parser_emit_with_arg_reloc(
        -: 2328:                  yyscanner,
        -: 2329:                  OP_OBJ_FIELD,
        -: 2330:                  ident,
        -: 2331:                  NULL,
        -: 2332:                  NULL);
        -: 2333:
        -: 2334:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2335:            (yyval.expression).value.object = field;
        -: 2336:            (yyval.expression).identifier = field->identifier;
        -: 2337:          }
        -: 2338:          else
        -: 2339:          {
        -: 2340:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2341:            result = ERROR_INVALID_FIELD_NAME;
        -: 2342:          }
        -: 2343:        }
        -: 2344:        else
        -: 2345:        {
        -: 2346:          yr_compiler_set_error_extra_info(
        -: 2347:              compiler, (yyvsp[-2].expression).identifier);
        -: 2348:
        -: 2349:          result = ERROR_NOT_A_STRUCTURE;
        -: 2350:        }
        -: 2351:
        -: 2352:        yr_free((yyvsp[0].c_string));
        -: 2353:
        -: 2354:        fail_if_error(result);
        -: 2355:      }
        -: 2356:#line 2357 "grammar.c"
    #####: 2357:    break;
        -: 2358:
    #####: 2359:  case 49:
        -: 2360:#line 736 "grammar.y"
        -: 2361:      {
        -: 2362:        int result = ERROR_SUCCESS;
        -: 2363:        YR_OBJECT_ARRAY* array;
        -: 2364:        YR_OBJECT_DICTIONARY* dict;
        -: 2365:
        -: 2366:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2367:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2368:        {
        -: 2369:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2370:          {
        -: 2371:            yr_compiler_set_error_extra_info(
        -: 2372:                compiler, "array indexes must be of integer type");
        -: 2373:            result = ERROR_WRONG_TYPE;
        -: 2374:          }
        -: 2375:
        -: 2376:          fail_if_error(result);
        -: 2377:
        -: 2378:          result = yr_parser_emit(
        -: 2379:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2380:
        -: 2381:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2382:
        -: 2383:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2384:          (yyval.expression).value.object = array->prototype_item;
        -: 2385:          (yyval.expression).identifier = array->identifier;
        -: 2386:        }
        -: 2387:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2388:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2389:        {
        -: 2390:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2391:          {
        -: 2392:            yr_compiler_set_error_extra_info(
        -: 2393:                compiler, "dictionary keys must be of string type");
        -: 2394:            result = ERROR_WRONG_TYPE;
        -: 2395:          }
        -: 2396:
        -: 2397:          fail_if_error(result);
        -: 2398:
        -: 2399:          result = yr_parser_emit(
        -: 2400:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2401:
        -: 2402:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2403:
        -: 2404:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2405:          (yyval.expression).value.object = dict->prototype_item;
        -: 2406:          (yyval.expression).identifier = dict->identifier;
        -: 2407:        }
        -: 2408:        else
        -: 2409:        {
        -: 2410:          yr_compiler_set_error_extra_info(
        -: 2411:              compiler, (yyvsp[-3].expression).identifier);
        -: 2412:
        -: 2413:          result = ERROR_NOT_INDEXABLE;
        -: 2414:        }
        -: 2415:
        -: 2416:        fail_if_error(result);
        -: 2417:      }
        -: 2418:#line 2419 "grammar.c"
    #####: 2419:    break;
        -: 2420:
    #####: 2421:  case 50:
        -: 2422:#line 795 "grammar.y"
        -: 2423:      {
        -: 2424:        int result = ERROR_SUCCESS;
        -: 2425:        YR_OBJECT_FUNCTION* function;
        -: 2426:        char* args_fmt;
        -: 2427:
        -: 2428:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2429:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2430:        {
        -: 2431:          result = yr_parser_check_types(
        -: 2432:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2433:
        -: 2434:          if (result == ERROR_SUCCESS)
        -: 2435:            result = yr_arena_write_string(
        -: 2436:                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
        -: 2437:
        -: 2438:          if (result == ERROR_SUCCESS)
        -: 2439:            result = yr_parser_emit_with_arg_reloc(
        -: 2440:                yyscanner,
        -: 2441:                OP_CALL,
        -: 2442:                args_fmt,
        -: 2443:                NULL,
        -: 2444:                NULL);
        -: 2445:
        -: 2446:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2447:
        -: 2448:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2449:          (yyval.expression).value.object = function->return_obj;
        -: 2450:          (yyval.expression).identifier = function->identifier;
        -: 2451:        }
        -: 2452:        else
        -: 2453:        {
        -: 2454:          yr_compiler_set_error_extra_info(
        -: 2455:              compiler, (yyvsp[-3].expression).identifier);
        -: 2456:
        -: 2457:          result = ERROR_NOT_A_FUNCTION;
        -: 2458:        }
        -: 2459:
        -: 2460:        yr_free((yyvsp[-1].c_string));
        -: 2461:
        -: 2462:        fail_if_error(result);
        -: 2463:      }
        -: 2464:#line 2465 "grammar.c"
    #####: 2465:    break;
        -: 2466:
    #####: 2467:  case 51:
        -: 2468:#line 840 "grammar.y"
        -: 2469:                      { (yyval.c_string) = yr_strdup(""); }
        -: 2470:#line 2471 "grammar.c"
    #####: 2471:    break;
        -: 2472:
    #####: 2473:  case 52:
        -: 2474:#line 841 "grammar.y"
        -: 2475:                      { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2476:#line 2477 "grammar.c"
    #####: 2477:    break;
        -: 2478:
    #####: 2479:  case 53:
        -: 2480:#line 846 "grammar.y"
        -: 2481:      {
        -: 2482:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2483:
        -: 2484:        if ((yyval.c_string) == NULL)
        -: 2485:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2486:
        -: 2487:        switch((yyvsp[0].expression).type)
        -: 2488:        {
        -: 2489:          case EXPRESSION_TYPE_INTEGER:
        -: 2490:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2491:            break;
        -: 2492:          case EXPRESSION_TYPE_FLOAT:
        -: 2493:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2494:            break;
        -: 2495:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2496:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2497:            break;
        -: 2498:          case EXPRESSION_TYPE_STRING:
        -: 2499:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2500:            break;
        -: 2501:          case EXPRESSION_TYPE_REGEXP:
        -: 2502:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2503:            break;
        -: 2504:          default:
        -: 2505:            assert(false);
        -: 2506:        }
        -: 2507:      }
        -: 2508:#line 2509 "grammar.c"
    #####: 2509:    break;
        -: 2510:
    #####: 2511:  case 54:
        -: 2512:#line 874 "grammar.y"
        -: 2513:      {
        -: 2514:        int result = ERROR_SUCCESS;
        -: 2515:
        -: 2516:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2517:        {
        -: 2518:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2519:        }
        -: 2520:        else
        -: 2521:        {
        -: 2522:          switch((yyvsp[0].expression).type)
        -: 2523:          {
        -: 2524:            case EXPRESSION_TYPE_INTEGER:
        -: 2525:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2526:              break;
        -: 2527:            case EXPRESSION_TYPE_FLOAT:
        -: 2528:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2529:              break;
        -: 2530:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2531:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2532:              break;
        -: 2533:            case EXPRESSION_TYPE_STRING:
        -: 2534:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2535:              break;
        -: 2536:            case EXPRESSION_TYPE_REGEXP:
        -: 2537:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2538:              break;
        -: 2539:            default:
        -: 2540:              assert(false);
        -: 2541:          }
        -: 2542:        }
        -: 2543:
        -: 2544:        fail_if_error(result);
        -: 2545:
        -: 2546:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2547:      }
        -: 2548:#line 2549 "grammar.c"
    #####: 2549:    break;
        -: 2550:
    #####: 2551:  case 55:
        -: 2552:#line 914 "grammar.y"
        -: 2553:      {
        -: 2554:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2555:        RE* re;
        -: 2556:        RE_ERROR error;
        -: 2557:
        -: 2558:        int result = ERROR_SUCCESS;
        -: 2559:        int re_flags = 0;
        -: 2560:
        -: 2561:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2562:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2563:
        -: 2564:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2565:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2566:
        -: 2567:        result = yr_re_compile(
        -: 2568:            sized_string->c_string,
        -: 2569:            re_flags,
        -: 2570:            compiler->re_code_arena,
        -: 2571:            &re,
        -: 2572:            &error);
        -: 2573:
        -: 2574:        yr_free((yyvsp[0].sized_string));
        -: 2575:
        -: 2576:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2577:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2578:
        -: 2579:        if (result == ERROR_SUCCESS)
        -: 2580:          result = yr_parser_emit_with_arg_reloc(
        -: 2581:              yyscanner,
        -: 2582:              OP_PUSH,
        -: 2583:              re,
        -: 2584:              NULL,
        -: 2585:              NULL);
        -: 2586:
        -: 2587:        fail_if_error(result);
        -: 2588:
        -: 2589:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2590:      }
        -: 2591:#line 2592 "grammar.c"
    #####: 2592:    break;
        -: 2593:
      266: 2594:  case 56:
        -: 2595:#line 957 "grammar.y"
        -: 2596:      {
        -: 2597:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2598:        {
        -: 2599:          if ((yyvsp[0].expression).value.sized_string != NULL)
        -: 2600:          {
        -: 2601:            yywarning(yyscanner,
        -: 2602:              "Using literal string \"%s\" in a boolean operation.",
        -: 2603:              (yyvsp[0].expression).value.sized_string->c_string);
        -: 2604:          }
        -: 2605:
        -: 2606:          fail_if_error(yr_parser_emit(
        -: 2607:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2608:        }
        -: 2609:
        -: 2610:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2611:      }
        -: 2612:#line 2613 "grammar.c"
      266: 2613:    break;
        -: 2614:
    #####: 2615:  case 57:
        -: 2616:#line 977 "grammar.y"
        -: 2617:      {
        -: 2618:        fail_if_error(yr_parser_emit_with_arg(
        -: 2619:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 2620:
        -: 2621:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2622:      }
        -: 2623:#line 2624 "grammar.c"
    #####: 2624:    break;
        -: 2625:
    #####: 2626:  case 58:
        -: 2627:#line 984 "grammar.y"
        -: 2628:      {
        -: 2629:        fail_if_error(yr_parser_emit_with_arg(
        -: 2630:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 2631:
        -: 2632:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2633:      }
        -: 2634:#line 2635 "grammar.c"
    #####: 2635:    break;
        -: 2636:
    #####: 2637:  case 59:
        -: 2638:#line 991 "grammar.y"
        -: 2639:      {
        -: 2640:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 2641:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 2642:
        -: 2643:        fail_if_error(yr_parser_emit(
        -: 2644:            yyscanner,
        -: 2645:            OP_MATCHES,
        -: 2646:            NULL));
        -: 2647:
        -: 2648:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2649:      }
        -: 2650:#line 2651 "grammar.c"
    #####: 2651:    break;
        -: 2652:
    #####: 2653:  case 60:
        -: 2654:#line 1003 "grammar.y"
        -: 2655:      {
        -: 2656:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2657:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2658:
        -: 2659:        fail_if_error(yr_parser_emit(
        -: 2660:            yyscanner, OP_CONTAINS, NULL));
        -: 2661:
        -: 2662:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2663:      }
        -: 2664:#line 2665 "grammar.c"
    #####: 2665:    break;
        -: 2666:
      262: 2667:  case 61:
        -: 2668:#line 1013 "grammar.y"
        -: 2669:      {
        -: 2670:        int result = yr_parser_reduce_string_identifier(
        -: 2671:            yyscanner,
        -: 2672:            (yyvsp[0].c_string),
        -: 2673:            OP_FOUND,
        -: 2674:            UNDEFINED);
        -: 2675:
        -: 2676:        yr_free((yyvsp[0].c_string));
        -: 2677:
        -: 2678:        fail_if_error(result);
        -: 2679:
        -: 2680:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2681:      }
        -: 2682:#line 2683 "grammar.c"
      262: 2683:    break;
        -: 2684:
    #####: 2685:  case 62:
        -: 2686:#line 1027 "grammar.y"
        -: 2687:      {
        -: 2688:        int result;
        -: 2689:
        -: 2690:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 2691:
        -: 2692:        result = yr_parser_reduce_string_identifier(
        -: 2693:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 2694:
        -: 2695:        yr_free((yyvsp[-2].c_string));
        -: 2696:
        -: 2697:        fail_if_error(result);
        -: 2698:
        -: 2699:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2700:      }
        -: 2701:#line 2702 "grammar.c"
    #####: 2702:    break;
        -: 2703:
    #####: 2704:  case 63:
        -: 2705:#line 1042 "grammar.y"
        -: 2706:      {
        -: 2707:        int result = yr_parser_reduce_string_identifier(
        -: 2708:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
        -: 2709:
        -: 2710:        yr_free((yyvsp[-2].c_string));
        -: 2711:
        -: 2712:        fail_if_error(result);
        -: 2713:
        -: 2714:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2715:      }
        -: 2716:#line 2717 "grammar.c"
    #####: 2717:    break;
        -: 2718:
    #####: 2719:  case 64:
        -: 2720:#line 1053 "grammar.y"
        -: 2721:      {
        -: 2722:        if (compiler->loop_depth > 0)
        -: 2723:        {
        -: 2724:          compiler->loop_depth--;
        -: 2725:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2726:        }
        -: 2727:
        -: 2728:        YYERROR;
        -: 2729:      }
        -: 2730:#line 2731 "grammar.c"
        -: 2731:    break;
        -: 2732:
    #####: 2733:  case 65:
        -: 2734:#line 1063 "grammar.y"
        -: 2735:      {
        -: 2736:        int result = ERROR_SUCCESS;
        -: 2737:        int var_index;
        -: 2738:
        -: 2739:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2740:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2741:
        -: 2742:        fail_if_error(result);
        -: 2743:
        -: 2744:        var_index = yr_parser_lookup_loop_variable(
        -: 2745:            yyscanner, (yyvsp[-1].c_string));
        -: 2746:
        -: 2747:        if (var_index >= 0)
        -: 2748:        {
        -: 2749:          yr_compiler_set_error_extra_info(
        -: 2750:              compiler, (yyvsp[-1].c_string));
        -: 2751:
        -: 2752:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 2753:        }
        -: 2754:
        -: 2755:        fail_if_error(result);
        -: 2756:
        -: 2757:        // Push end-of-list marker
        -: 2758:        result = yr_parser_emit_with_arg(
        -: 2759:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 2760:
        -: 2761:        fail_if_error(result);
        -: 2762:      }
        -: 2763:#line 2764 "grammar.c"
    #####: 2764:    break;
        -: 2765:
    #####: 2766:  case 66:
        -: 2767:#line 1092 "grammar.y"
        -: 2768:      {
        -: 2769:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2770:        uint8_t* addr;
        -: 2771:
        -: 2772:        // Clear counter for number of expressions evaluating
        -: 2773:        // to true.
        -: 2774:        yr_parser_emit_with_arg(
        -: 2775:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2776:
        -: 2777:        // Clear iterations counter
        -: 2778:        yr_parser_emit_with_arg(
        -: 2779:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2780:
        -: 2781:        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        -: 2782:        {
        -: 2783:          // Pop the first integer
        -: 2784:          yr_parser_emit_with_arg(
        -: 2785:              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2786:        }
        -: 2787:        else // INTEGER_SET_RANGE
        -: 2788:        {
        -: 2789:          // Pop higher bound of set range
        -: 2790:          yr_parser_emit_with_arg(
        -: 2791:              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
        -: 2792:
        -: 2793:          // Pop lower bound of set range
        -: 2794:          yr_parser_emit_with_arg(
        -: 2795:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2796:        }
        -: 2797:
        -: 2798:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2799:        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        -: 2800:        compiler->loop_depth++;
        -: 2801:      }
        -: 2802:#line 2803 "grammar.c"
    #####: 2803:    break;
        -: 2804:
    #####: 2805:  case 67:
        -: 2806:#line 1127 "grammar.y"
        -: 2807:      {
        -: 2808:        int mem_offset;
        -: 2809:
        -: 2810:        compiler->loop_depth--;
        -: 2811:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2812:
        -: 2813:        // The value at the top of the stack is the result of
        -: 2814:        // evaluating the boolean expression, so it could be
        -: 2815:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 2816:        // keeping the number of expressions evaluating to true.
        -: 2817:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 2818:        // does nothing.
        -: 2819:
        -: 2820:        yr_parser_emit_with_arg(
        -: 2821:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2822:
        -: 2823:        // Increment iterations counter
        -: 2824:        yr_parser_emit_with_arg(
        -: 2825:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2826:
        -: 2827:        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        -: 2828:        {
        -: 2829:          yr_parser_emit_with_arg_reloc(
        -: 2830:              yyscanner,
        -: 2831:              OP_JNUNDEF,
        -: 2832:              compiler->loop_address[compiler->loop_depth],
        -: 2833:              NULL,
        -: 2834:              NULL);
        -: 2835:        }
        -: 2836:        else // INTEGER_SET_RANGE
        -: 2837:        {
        -: 2838:          // Increment lower bound of integer set
        -: 2839:          yr_parser_emit_with_arg(
        -: 2840:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 2841:
        -: 2842:          // Push lower bound of integer set
        -: 2843:          yr_parser_emit_with_arg(
        -: 2844:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 2845:
        -: 2846:          // Push higher bound of integer set
        -: 2847:          yr_parser_emit_with_arg(
        -: 2848:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 2849:
        -: 2850:          // Compare higher bound with lower bound, do loop again
        -: 2851:          // if lower bound is still lower or equal than higher bound
        -: 2852:          yr_parser_emit_with_arg_reloc(
        -: 2853:              yyscanner,
        -: 2854:              OP_JLE,
        -: 2855:              compiler->loop_address[compiler->loop_depth],
        -: 2856:              NULL,
        -: 2857:              NULL);
        -: 2858:
        -: 2859:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2860:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2861:        }
        -: 2862:
        -: 2863:        // Pop end-of-list marker.
        -: 2864:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2865:
        -: 2866:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2867:        // is at the top of the stack. Check if the quantifier
        -: 2868:        // is undefined (meaning "all") and replace it with the
        -: 2869:        // iterations counter in that case.
        -: 2870:        yr_parser_emit_with_arg(
        -: 2871:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2872:
        -: 2873:        // Compare the loop quantifier with the number of
        -: 2874:        // expressions evaluating to true.
        -: 2875:        yr_parser_emit_with_arg(
        -: 2876:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2877:
        -: 2878:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2879:
        -: 2880:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2881:        yr_free((yyvsp[-8].c_string));
        -: 2882:
        -: 2883:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2884:      }
        -: 2885:#line 2886 "grammar.c"
    #####: 2886:    break;
        -: 2887:
    #####: 2888:  case 68:
        -: 2889:#line 1206 "grammar.y"
        -: 2890:      {
        -: 2891:        int result = ERROR_SUCCESS;
        -: 2892:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2893:        uint8_t* addr;
        -: 2894:
        -: 2895:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2896:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2897:
        -: 2898:        if (compiler->loop_for_of_mem_offset != -1)
        -: 2899:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 2900:
        -: 2901:        fail_if_error(result);
        -: 2902:
        -: 2903:        yr_parser_emit_with_arg(
        -: 2904:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2905:
        -: 2906:        yr_parser_emit_with_arg(
        -: 2907:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2908:
        -: 2909:        // Pop the first string.
        -: 2910:        yr_parser_emit_with_arg(
        -: 2911:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2912:
        -: 2913:        compiler->loop_for_of_mem_offset = mem_offset;
        -: 2914:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2915:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2916:        compiler->loop_depth++;
        -: 2917:      }
        -: 2918:#line 2919 "grammar.c"
    #####: 2919:    break;
        -: 2920:
    #####: 2921:  case 69:
        -: 2922:#line 1235 "grammar.y"
        -: 2923:      {
        -: 2924:        int mem_offset;
        -: 2925:
        -: 2926:        compiler->loop_depth--;
        -: 2927:        compiler->loop_for_of_mem_offset = -1;
        -: 2928:
        -: 2929:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2930:
        -: 2931:        // Increment counter by the value returned by the
        -: 2932:        // boolean expression (0 or 1). If the boolean expression
        -: 2933:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 2934:
        -: 2935:        yr_parser_emit_with_arg(
        -: 2936:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2937:
        -: 2938:        // Increment iterations counter.
        -: 2939:        yr_parser_emit_with_arg(
        -: 2940:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2941:
        -: 2942:        // If next string is not undefined, go back to the
        -: 2943:        // beginning of the loop.
        -: 2944:        yr_parser_emit_with_arg_reloc(
        -: 2945:            yyscanner,
        -: 2946:            OP_JNUNDEF,
        -: 2947:            compiler->loop_address[compiler->loop_depth],
        -: 2948:            NULL,
        -: 2949:            NULL);
        -: 2950:
        -: 2951:        // Pop end-of-list marker.
        -: 2952:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2953:
        -: 2954:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2955:        // is at top of the stack. Check if the quantifier is
        -: 2956:        // undefined (meaning "all") and replace it with the
        -: 2957:        // iterations counter in that case.
        -: 2958:        yr_parser_emit_with_arg(
        -: 2959:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2960:
        -: 2961:        // Compare the loop quantifier with the number of
        -: 2962:        // expressions evaluating to true.
        -: 2963:        yr_parser_emit_with_arg(
        -: 2964:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2965:
        -: 2966:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2967:
        -: 2968:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2969:
        -: 2970:      }
        -: 2971:#line 2972 "grammar.c"
    #####: 2972:    break;
        -: 2973:
    #####: 2974:  case 70:
        -: 2975:#line 1284 "grammar.y"
        -: 2976:      {
        -: 2977:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 2978:
        -: 2979:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2980:      }
        -: 2981:#line 2982 "grammar.c"
    #####: 2982:    break;
        -: 2983:
    #####: 2984:  case 71:
        -: 2985:#line 1290 "grammar.y"
        -: 2986:      {
        -: 2987:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 2988:
        -: 2989:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2990:      }
        -: 2991:#line 2992 "grammar.c"
    #####: 2992:    break;
        -: 2993:
    #####: 2994:  case 72:
        -: 2995:#line 1296 "grammar.y"
        -: 2996:      {
        -: 2997:        YR_FIXUP* fixup;
        -: 2998:        void* jmp_destination_addr;
        -: 2999:
        -: 3000:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3001:            yyscanner,
        -: 3002:            OP_JFALSE,
        -: 3003:            0,          // still don't know the jump destination
        -: 3004:            NULL,
        -: 3005:            &jmp_destination_addr));
        -: 3006:
        -: 3007:        // create a fixup entry for the jump and push it in the stack
        -: 3008:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3009:
        -: 3010:        if (fixup == NULL)
        -: 3011:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3012:
        -: 3013:        fixup->address = jmp_destination_addr;
        -: 3014:        fixup->next = compiler->fixup_stack_head;
        -: 3015:        compiler->fixup_stack_head = fixup;
        -: 3016:      }
        -: 3017:#line 3018 "grammar.c"
    #####: 3018:    break;
        -: 3019:
    #####: 3020:  case 73:
        -: 3021:#line 1318 "grammar.y"
        -: 3022:      {
        -: 3023:        YR_FIXUP* fixup;
        -: 3024:        uint8_t* nop_addr;
        -: 3025:
        -: 3026:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 3027:
        -: 3028:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3029:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3030:        // use the address of the OP_AND instruction +1 because we can't be
        -: 3031:        // sure that the instruction following the OP_AND is going to be in
        -: 3032:        // the same arena page. As we don't have a reliable way of getting the
        -: 3033:        // address of the next instruction we generate the OP_NOP.
        -: 3034:
        -: 3035:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3036:
        -: 3037:        fixup = compiler->fixup_stack_head;
        -: 3038:        *(void**)(fixup->address) = (void*) nop_addr;
        -: 3039:        compiler->fixup_stack_head = fixup->next;
        -: 3040:        yr_free(fixup);
        -: 3041:
        -: 3042:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3043:      }
        -: 3044:#line 3045 "grammar.c"
    #####: 3045:    break;
        -: 3046:
    #####: 3047:  case 74:
        -: 3048:#line 1341 "grammar.y"
        -: 3049:      {
        -: 3050:        YR_FIXUP* fixup;
        -: 3051:        void* jmp_destination_addr;
        -: 3052:
        -: 3053:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3054:            yyscanner,
        -: 3055:            OP_JTRUE,
        -: 3056:            0,         // still don't know the jump destination
        -: 3057:            NULL,
        -: 3058:            &jmp_destination_addr));
        -: 3059:
        -: 3060:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3061:
        -: 3062:        if (fixup == NULL)
        -: 3063:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3064:
        -: 3065:        fixup->address = jmp_destination_addr;
        -: 3066:        fixup->next = compiler->fixup_stack_head;
        -: 3067:        compiler->fixup_stack_head = fixup;
        -: 3068:      }
        -: 3069:#line 3070 "grammar.c"
    #####: 3070:    break;
        -: 3071:
    #####: 3072:  case 75:
        -: 3073:#line 1362 "grammar.y"
        -: 3074:      {
        -: 3075:        YR_FIXUP* fixup;
        -: 3076:        uint8_t* nop_addr;
        -: 3077:
        -: 3078:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 3079:
        -: 3080:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3081:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3082:        // use the address of the OP_OR instruction +1 because we can't be
        -: 3083:        // sure that the instruction following the OP_AND is going to be in
        -: 3084:        // the same arena page. As we don't have a reliable way of getting the
        -: 3085:        // address of the next instruction we generate the OP_NOP.
        -: 3086:
        -: 3087:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3088:
        -: 3089:        fixup = compiler->fixup_stack_head;
        -: 3090:        *(void**)(fixup->address) = (void*)(nop_addr);
        -: 3091:        compiler->fixup_stack_head = fixup->next;
        -: 3092:        yr_free(fixup);
        -: 3093:
        -: 3094:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3095:      }
        -: 3096:#line 3097 "grammar.c"
    #####: 3097:    break;
        -: 3098:
    #####: 3099:  case 76:
        -: 3100:#line 1385 "grammar.y"
        -: 3101:      {
        -: 3102:        fail_if_error(yr_parser_reduce_operation(
        -: 3103:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3104:
        -: 3105:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3106:      }
        -: 3107:#line 3108 "grammar.c"
    #####: 3108:    break;
        -: 3109:
    #####: 3110:  case 77:
        -: 3111:#line 1392 "grammar.y"
        -: 3112:      {
        -: 3113:        fail_if_error(yr_parser_reduce_operation(
        -: 3114:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3115:
        -: 3116:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3117:      }
        -: 3118:#line 3119 "grammar.c"
    #####: 3119:    break;
        -: 3120:
    #####: 3121:  case 78:
        -: 3122:#line 1399 "grammar.y"
        -: 3123:      {
        -: 3124:        fail_if_error(yr_parser_reduce_operation(
        -: 3125:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3126:
        -: 3127:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3128:      }
        -: 3129:#line 3130 "grammar.c"
    #####: 3130:    break;
        -: 3131:
    #####: 3132:  case 79:
        -: 3133:#line 1406 "grammar.y"
        -: 3134:      {
        -: 3135:        fail_if_error(yr_parser_reduce_operation(
        -: 3136:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3137:
        -: 3138:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3139:      }
        -: 3140:#line 3141 "grammar.c"
    #####: 3141:    break;
        -: 3142:
        4: 3143:  case 80:
        -: 3144:#line 1413 "grammar.y"
        -: 3145:      {
        -: 3146:        fail_if_error(yr_parser_reduce_operation(
        -: 3147:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3148:
        -: 3149:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3150:      }
        -: 3151:#line 3152 "grammar.c"
        4: 3152:    break;
        -: 3153:
    #####: 3154:  case 81:
        -: 3155:#line 1420 "grammar.y"
        -: 3156:      {
        -: 3157:        fail_if_error(yr_parser_reduce_operation(
        -: 3158:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3159:
        -: 3160:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3161:      }
        -: 3162:#line 3163 "grammar.c"
    #####: 3163:    break;
        -: 3164:
    #####: 3165:  case 82:
        -: 3166:#line 1427 "grammar.y"
        -: 3167:      {
        -: 3168:        (yyval.expression) = (yyvsp[0].expression);
        -: 3169:      }
        -: 3170:#line 3171 "grammar.c"
    #####: 3171:    break;
        -: 3172:
    #####: 3173:  case 83:
        -: 3174:#line 1431 "grammar.y"
        -: 3175:      {
        -: 3176:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3177:      }
        -: 3178:#line 3179 "grammar.c"
    #####: 3179:    break;
        -: 3180:
    #####: 3181:  case 84:
        -: 3182:#line 1438 "grammar.y"
        -: 3183:                                   { (yyval.integer) = INTEGER_SET_ENUMERATION; }
        -: 3184:#line 3185 "grammar.c"
    #####: 3185:    break;
        -: 3186:
    #####: 3187:  case 85:
        -: 3188:#line 1439 "grammar.y"
        -: 3189:                                   { (yyval.integer) = INTEGER_SET_RANGE; }
        -: 3190:#line 3191 "grammar.c"
    #####: 3191:    break;
        -: 3192:
    #####: 3193:  case 86:
        -: 3194:#line 1445 "grammar.y"
        -: 3195:      {
        -: 3196:        int result = ERROR_SUCCESS;
        -: 3197:
        -: 3198:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3199:        {
        -: 3200:          yr_compiler_set_error_extra_info(
        -: 3201:              compiler, "wrong type for range's lower bound");
        -: 3202:          result = ERROR_WRONG_TYPE;
        -: 3203:        }
        -: 3204:
        -: 3205:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3206:        {
        -: 3207:          yr_compiler_set_error_extra_info(
        -: 3208:              compiler, "wrong type for range's upper bound");
        -: 3209:          result = ERROR_WRONG_TYPE;
        -: 3210:        }
        -: 3211:
        -: 3212:        fail_if_error(result);
        -: 3213:      }
        -: 3214:#line 3215 "grammar.c"
    #####: 3215:    break;
        -: 3216:
    #####: 3217:  case 87:
        -: 3218:#line 1469 "grammar.y"
        -: 3219:      {
        -: 3220:        int result = ERROR_SUCCESS;
        -: 3221:
        -: 3222:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3223:        {
        -: 3224:          yr_compiler_set_error_extra_info(
        -: 3225:              compiler, "wrong type for enumeration item");
        -: 3226:          result = ERROR_WRONG_TYPE;
        -: 3227:        }
        -: 3228:
        -: 3229:        fail_if_error(result);
        -: 3230:      }
        -: 3231:#line 3232 "grammar.c"
    #####: 3232:    break;
        -: 3233:
    #####: 3234:  case 88:
        -: 3235:#line 1482 "grammar.y"
        -: 3236:      {
        -: 3237:        int result = ERROR_SUCCESS;
        -: 3238:
        -: 3239:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3240:        {
        -: 3241:          yr_compiler_set_error_extra_info(
        -: 3242:              compiler, "wrong type for enumeration item");
        -: 3243:          result = ERROR_WRONG_TYPE;
        -: 3244:        }
        -: 3245:
        -: 3246:        fail_if_error(result);
        -: 3247:      }
        -: 3248:#line 3249 "grammar.c"
    #####: 3249:    break;
        -: 3250:
    #####: 3251:  case 89:
        -: 3252:#line 1499 "grammar.y"
        -: 3253:      {
        -: 3254:        // Push end-of-list marker
        -: 3255:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3256:      }
        -: 3257:#line 3258 "grammar.c"
    #####: 3258:    break;
        -: 3259:
    #####: 3260:  case 91:
        -: 3261:#line 1505 "grammar.y"
        -: 3262:      {
        -: 3263:        fail_if_error(yr_parser_emit_with_arg(
        -: 3264:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 3265:
        -: 3266:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3267:            yyscanner, "$*"));
        -: 3268:      }
        -: 3269:#line 3270 "grammar.c"
    #####: 3270:    break;
        -: 3271:
    #####: 3272:  case 94:
        -: 3273:#line 1523 "grammar.y"
        -: 3274:      {
        -: 3275:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3276:        yr_free((yyvsp[0].c_string));
        -: 3277:
        -: 3278:        fail_if_error(result);
        -: 3279:      }
        -: 3280:#line 3281 "grammar.c"
    #####: 3281:    break;
        -: 3282:
    #####: 3283:  case 95:
        -: 3284:#line 1530 "grammar.y"
        -: 3285:      {
        -: 3286:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3287:        yr_free((yyvsp[0].c_string));
        -: 3288:
        -: 3289:        fail_if_error(result);
        -: 3290:      }
        -: 3291:#line 3292 "grammar.c"
    #####: 3292:    break;
        -: 3293:
    #####: 3294:  case 97:
        -: 3295:#line 1542 "grammar.y"
        -: 3296:      {
        -: 3297:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3298:      }
        -: 3299:#line 3300 "grammar.c"
    #####: 3300:    break;
        -: 3301:
    #####: 3302:  case 98:
        -: 3303:#line 1546 "grammar.y"
        -: 3304:      {
        -: 3305:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3306:      }
        -: 3307:#line 3308 "grammar.c"
    #####: 3308:    break;
        -: 3309:
    #####: 3310:  case 99:
        -: 3311:#line 1554 "grammar.y"
        -: 3312:      {
        -: 3313:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3314:      }
        -: 3315:#line 3316 "grammar.c"
    #####: 3316:    break;
        -: 3317:
    #####: 3318:  case 100:
        -: 3319:#line 1558 "grammar.y"
        -: 3320:      {
        -: 3321:        fail_if_error(yr_parser_emit(
        -: 3322:            yyscanner, OP_FILESIZE, NULL));
        -: 3323:
        -: 3324:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3325:        (yyval.expression).value.integer = UNDEFINED;
        -: 3326:      }
        -: 3327:#line 3328 "grammar.c"
    #####: 3328:    break;
        -: 3329:
    #####: 3330:  case 101:
        -: 3331:#line 1566 "grammar.y"
        -: 3332:      {
        -: 3333:        yywarning(yyscanner,
        -: 3334:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3335:            "function from PE module instead.");
        -: 3336:
        -: 3337:        fail_if_error(yr_parser_emit(
        -: 3338:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3339:
        -: 3340:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3341:        (yyval.expression).value.integer = UNDEFINED;
        -: 3342:      }
        -: 3343:#line 3344 "grammar.c"
    #####: 3344:    break;
        -: 3345:
    #####: 3346:  case 102:
        -: 3347:#line 1578 "grammar.y"
        -: 3348:      {
        -: 3349:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3350:
        -: 3351:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3352:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3353:        // in the proper OP_INTXX opcode.
        -: 3354:
        -: 3355:        fail_if_error(yr_parser_emit(
        -: 3356:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 3357:
        -: 3358:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3359:        (yyval.expression).value.integer = UNDEFINED;
        -: 3360:      }
        -: 3361:#line 3362 "grammar.c"
    #####: 3362:    break;
        -: 3363:
        4: 3364:  case 103:
        -: 3365:#line 1592 "grammar.y"
        -: 3366:      {
        -: 3367:        fail_if_error(yr_parser_emit_with_arg(
        -: 3368:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 3369:
        -: 3370:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3371:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 3372:      }
        -: 3373:#line 3374 "grammar.c"
        4: 3374:    break;
        -: 3375:
    #####: 3376:  case 104:
        -: 3377:#line 1600 "grammar.y"
        -: 3378:      {
        -: 3379:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 3380:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 3381:
        -: 3382:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3383:      }
        -: 3384:#line 3385 "grammar.c"
    #####: 3385:    break;
        -: 3386:
    #####: 3387:  case 105:
        -: 3388:#line 1607 "grammar.y"
        -: 3389:      {
        -: 3390:        SIZED_STRING* sized_string;
        -: 3391:
        -: 3392:        int result = yr_arena_write_data(
        -: 3393:            compiler->sz_arena,
        -: 3394:            (yyvsp[0].sized_string),
        -: 3395:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 3396:            (void**) &sized_string);
        -: 3397:
        -: 3398:        yr_free((yyvsp[0].sized_string));
        -: 3399:
        -: 3400:        if (result == ERROR_SUCCESS)
        -: 3401:          result = yr_parser_emit_with_arg_reloc(
        -: 3402:              yyscanner,
        -: 3403:              OP_PUSH,
        -: 3404:              sized_string,
        -: 3405:              NULL,
        -: 3406:              NULL);
        -: 3407:
        -: 3408:        fail_if_error(result);
        -: 3409:
        -: 3410:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3411:        (yyval.expression).value.sized_string = sized_string;
        -: 3412:      }
        -: 3413:#line 3414 "grammar.c"
    #####: 3414:    break;
        -: 3415:
    #####: 3416:  case 106:
        -: 3417:#line 1632 "grammar.y"
        -: 3418:      {
        -: 3419:        int result = yr_parser_reduce_string_identifier(
        -: 3420:            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
        -: 3421:
        -: 3422:        yr_free((yyvsp[0].c_string));
        -: 3423:
        -: 3424:        fail_if_error(result);
        -: 3425:
        -: 3426:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3427:        (yyval.expression).value.integer = UNDEFINED;
        -: 3428:      }
        -: 3429:#line 3430 "grammar.c"
    #####: 3430:    break;
        -: 3431:
    #####: 3432:  case 107:
        -: 3433:#line 1644 "grammar.y"
        -: 3434:      {
        -: 3435:        int result = yr_parser_reduce_string_identifier(
        -: 3436:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
        -: 3437:
        -: 3438:        yr_free((yyvsp[-3].c_string));
        -: 3439:
        -: 3440:        fail_if_error(result);
        -: 3441:
        -: 3442:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3443:        (yyval.expression).value.integer = UNDEFINED;
        -: 3444:      }
        -: 3445:#line 3446 "grammar.c"
    #####: 3446:    break;
        -: 3447:
    #####: 3448:  case 108:
        -: 3449:#line 1656 "grammar.y"
        -: 3450:      {
        -: 3451:        int result = yr_parser_emit_with_arg(
        -: 3452:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3453:
        -: 3454:        if (result == ERROR_SUCCESS)
        -: 3455:          result = yr_parser_reduce_string_identifier(
        -: 3456:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
        -: 3457:
        -: 3458:        yr_free((yyvsp[0].c_string));
        -: 3459:
        -: 3460:        fail_if_error(result);
        -: 3461:
        -: 3462:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3463:        (yyval.expression).value.integer = UNDEFINED;
        -: 3464:      }
        -: 3465:#line 3466 "grammar.c"
    #####: 3466:    break;
        -: 3467:
    #####: 3468:  case 109:
        -: 3469:#line 1672 "grammar.y"
        -: 3470:      {
        -: 3471:        int result = yr_parser_reduce_string_identifier(
        -: 3472:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
        -: 3473:
        -: 3474:        yr_free((yyvsp[-3].c_string));
        -: 3475:
        -: 3476:        fail_if_error(result);
        -: 3477:
        -: 3478:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3479:        (yyval.expression).value.integer = UNDEFINED;
        -: 3480:      }
        -: 3481:#line 3482 "grammar.c"
    #####: 3482:    break;
        -: 3483:
        4: 3484:  case 110:
        -: 3485:#line 1684 "grammar.y"
        -: 3486:      {
        -: 3487:        int result = yr_parser_emit_with_arg(
        -: 3488:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3489:
        -: 3490:        if (result == ERROR_SUCCESS)
        -: 3491:          result = yr_parser_reduce_string_identifier(
        -: 3492:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
        -: 3493:
        -: 3494:        yr_free((yyvsp[0].c_string));
        -: 3495:
        -: 3496:        fail_if_error(result);
        -: 3497:
        -: 3498:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3499:        (yyval.expression).value.integer = UNDEFINED;
        -: 3500:      }
        -: 3501:#line 3502 "grammar.c"
        4: 3502:    break;
        -: 3503:
    #####: 3504:  case 111:
        -: 3505:#line 1700 "grammar.y"
        -: 3506:      {
        -: 3507:        int result = ERROR_SUCCESS;
        -: 3508:
        -: 3509:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 3510:        {
        -: 3511:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3512:          (yyval.expression).value.integer = UNDEFINED;
        -: 3513:        }
        -: 3514:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 3515:        {
        -: 3516:          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3517:          (yyval.expression).value.integer = UNDEFINED;
        -: 3518:        }
        -: 3519:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3520:        {
        -: 3521:          result = yr_parser_emit(
        -: 3522:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 3523:
        -: 3524:          switch((yyvsp[0].expression).value.object->type)
        -: 3525:          {
        -: 3526:            case OBJECT_TYPE_INTEGER:
        -: 3527:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3528:              (yyval.expression).value.integer = UNDEFINED;
        -: 3529:              break;
        -: 3530:            case OBJECT_TYPE_FLOAT:
        -: 3531:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3532:              break;
        -: 3533:            case OBJECT_TYPE_STRING:
        -: 3534:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3535:              (yyval.expression).value.sized_string = NULL;
        -: 3536:              break;
        -: 3537:            default:
        -: 3538:              yr_compiler_set_error_extra_info_fmt(
        -: 3539:                  compiler,
        -: 3540:                  "wrong usage of identifier \"%s\"",
        -: 3541:                  (yyvsp[0].expression).identifier);
        -: 3542:              result = ERROR_WRONG_TYPE;
        -: 3543:          }
        -: 3544:        }
        -: 3545:        else
        -: 3546:        {
        -: 3547:          assert(false);
        -: 3548:        }
        -: 3549:
        -: 3550:        fail_if_error(result);
        -: 3551:      }
        -: 3552:#line 3553 "grammar.c"
    #####: 3553:    break;
        -: 3554:
    #####: 3555:  case 112:
        -: 3556:#line 1747 "grammar.y"
        -: 3557:      {
        -: 3558:        int result = ERROR_SUCCESS;
        -: 3559:
        -: 3560:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 3561:
        -: 3562:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3563:        {
        -: 3564:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3565:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3566:              UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 3567:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 3568:        }
        -: 3569:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 3570:        {
        -: 3571:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3572:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 3573:        }
        -: 3574:
        -: 3575:        fail_if_error(result);
        -: 3576:      }
        -: 3577:#line 3578 "grammar.c"
    #####: 3578:    break;
        -: 3579:
    #####: 3580:  case 113:
        -: 3581:#line 1768 "grammar.y"
        -: 3582:      {
        -: 3583:        int result = yr_parser_reduce_operation(
        -: 3584:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3585:
        -: 3586:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3587:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3588:        {
        -: 3589:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3590:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3591:
        -: 3592:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3593:              (
        -: 3594:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 3595:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 3596:              ))
        -: 3597:          {
        -: 3598:            yr_compiler_set_error_extra_info_fmt(
        -: 3599:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 3600:
        -: 3601:            result = ERROR_INTEGER_OVERFLOW;
        -: 3602:          }
        -: 3603:          else
        -: 3604:          {
        -: 3605:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 3606:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3607:          }
        -: 3608:        }
        -: 3609:        else
        -: 3610:        {
        -: 3611:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3612:        }
        -: 3613:
        -: 3614:        fail_if_error(result);
        -: 3615:      }
        -: 3616:#line 3617 "grammar.c"
    #####: 3617:    break;
        -: 3618:
    #####: 3619:  case 114:
        -: 3620:#line 1803 "grammar.y"
        -: 3621:      {
        -: 3622:        int result = yr_parser_reduce_operation(
        -: 3623:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3624:
        -: 3625:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3626:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3627:        {
        -: 3628:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3629:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3630:
        -: 3631:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3632:              (
        -: 3633:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 3634:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 3635:              ))
        -: 3636:          {
        -: 3637:            yr_compiler_set_error_extra_info_fmt(
        -: 3638:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 3639:
        -: 3640:            result = ERROR_INTEGER_OVERFLOW;
        -: 3641:          }
        -: 3642:          else
        -: 3643:          {
        -: 3644:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 3645:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3646:          }
        -: 3647:        }
        -: 3648:        else
        -: 3649:        {
        -: 3650:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3651:        }
        -: 3652:
        -: 3653:        fail_if_error(result);
        -: 3654:      }
        -: 3655:#line 3656 "grammar.c"
    #####: 3656:    break;
        -: 3657:
    #####: 3658:  case 115:
        -: 3659:#line 1838 "grammar.y"
        -: 3660:      {
        -: 3661:        int result = yr_parser_reduce_operation(
        -: 3662:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3663:
        -: 3664:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3665:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3666:        {
        -: 3667:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3668:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3669:
        -: 3670:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3671:              (
        -: 3672:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 3673:              ))
        -: 3674:          {
        -: 3675:            yr_compiler_set_error_extra_info_fmt(
        -: 3676:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 3677:
        -: 3678:            result = ERROR_INTEGER_OVERFLOW;
        -: 3679:          }
        -: 3680:          else
        -: 3681:          {
        -: 3682:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 3683:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3684:          }
        -: 3685:        }
        -: 3686:        else
        -: 3687:        {
        -: 3688:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3689:        }
        -: 3690:
        -: 3691:        fail_if_error(result);
        -: 3692:      }
        -: 3693:#line 3694 "grammar.c"
    #####: 3694:    break;
        -: 3695:
    #####: 3696:  case 116:
        -: 3697:#line 1872 "grammar.y"
        -: 3698:      {
        -: 3699:        int result = yr_parser_reduce_operation(
        -: 3700:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3701:
        -: 3702:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3703:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3704:        {
        -: 3705:          if ((yyvsp[0].expression).value.integer != 0)
        -: 3706:          {
        -: 3707:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3708:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3709:          }
        -: 3710:          else
        -: 3711:          {
        -: 3712:            result = ERROR_DIVISION_BY_ZERO;
        -: 3713:          }
        -: 3714:        }
        -: 3715:        else
        -: 3716:        {
        -: 3717:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3718:        }
        -: 3719:
        -: 3720:        fail_if_error(result);
        -: 3721:      }
        -: 3722:#line 3723 "grammar.c"
    #####: 3723:    break;
        -: 3724:
    #####: 3725:  case 117:
        -: 3726:#line 1897 "grammar.y"
        -: 3727:      {
        -: 3728:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3729:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3730:
        -: 3731:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 3732:
        -: 3733:        if ((yyvsp[0].expression).value.integer != 0)
        -: 3734:        {
        -: 3735:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3736:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3737:        }
        -: 3738:        else
        -: 3739:        {
        -: 3740:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 3741:        }
        -: 3742:      }
        -: 3743:#line 3744 "grammar.c"
    #####: 3744:    break;
        -: 3745:
    #####: 3746:  case 118:
        -: 3747:#line 1914 "grammar.y"
        -: 3748:      {
        -: 3749:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3750:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3751:
        -: 3752:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 3753:
        -: 3754:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3755:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3756:      }
        -: 3757:#line 3758 "grammar.c"
    #####: 3758:    break;
        -: 3759:
    #####: 3760:  case 119:
        -: 3761:#line 1924 "grammar.y"
        -: 3762:      {
        -: 3763:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3764:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3765:
        -: 3766:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 3767:
        -: 3768:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3769:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3770:      }
        -: 3771:#line 3772 "grammar.c"
    #####: 3772:    break;
        -: 3773:
    #####: 3774:  case 120:
        -: 3775:#line 1934 "grammar.y"
        -: 3776:      {
        -: 3777:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3778:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3779:
        -: 3780:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 3781:
        -: 3782:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3783:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3784:      }
        -: 3785:#line 3786 "grammar.c"
    #####: 3786:    break;
        -: 3787:
    #####: 3788:  case 121:
        -: 3789:#line 1944 "grammar.y"
        -: 3790:      {
        -: 3791:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 3792:
        -: 3793:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 3794:
        -: 3795:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3796:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3797:            UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 3798:      }
        -: 3799:#line 3800 "grammar.c"
    #####: 3800:    break;
        -: 3801:
    #####: 3802:  case 122:
        -: 3803:#line 1954 "grammar.y"
        -: 3804:      {
        -: 3805:        int result;
        -: 3806:
        -: 3807:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3808:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3809:
        -: 3810:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 3811:
        -: 3812:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3813:          result = ERROR_INVALID_OPERAND;
        -: 3814:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3815:          (yyval.expression).value.integer = 0;
        -: 3816:        else
        -: 3817:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3818:
        -: 3819:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3820:
        -: 3821:        fail_if_error(result);
        -: 3822:      }
        -: 3823:#line 3824 "grammar.c"
    #####: 3824:    break;
        -: 3825:
    #####: 3826:  case 123:
        -: 3827:#line 1974 "grammar.y"
        -: 3828:      {
        -: 3829:        int result;
        -: 3830:
        -: 3831:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3832:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3833:
        -: 3834:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 3835:
        -: 3836:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3837:          result = ERROR_INVALID_OPERAND;
        -: 3838:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3839:          (yyval.expression).value.integer = 0;
        -: 3840:        else
        -: 3841:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3842:
        -: 3843:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3844:
        -: 3845:        fail_if_error(result);
        -: 3846:      }
        -: 3847:#line 3848 "grammar.c"
    #####: 3848:    break;
        -: 3849:
    #####: 3850:  case 124:
        -: 3851:#line 1994 "grammar.y"
        -: 3852:      {
        -: 3853:        (yyval.expression) = (yyvsp[0].expression);
        -: 3854:      }
        -: 3855:#line 3856 "grammar.c"
    #####: 3856:    break;
        -: 3857:
        -: 3858:
        -: 3859:#line 3860 "grammar.c"
        -: 3860:
      814: 3861:      default: break;
        -: 3862:    }
        -: 3863:  /* User semantic actions sometimes alter yychar, and that requires
        -: 3864:     that yytoken be updated with the new translation.  We take the
        -: 3865:     approach of translating immediately before every use of yytoken.
        -: 3866:     One alternative is translating here after every semantic action,
        -: 3867:     but that translation would be missed if the semantic action invokes
        -: 3868:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 3869:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 3870:     incorrect destructor might then be invoked immediately.  In the
        -: 3871:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 3872:     to an incorrect destructor call or verbose syntax error message
        -: 3873:     before the lookahead is translated.  */
        -: 3874:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 3875:
     4496: 3876:  YYPOPSTACK (yylen);
     4496: 3877:  yylen = 0;
        -: 3878:  YY_STACK_PRINT (yyss, yyssp);
        -: 3879:
     4496: 3880:  *++yyvsp = yyval;
        -: 3881:
        -: 3882:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 3883:     that goes to, based on the state we popped back to and the rule
        -: 3884:     number reduced by.  */
        -: 3885:  {
     4496: 3886:    const int yylhs = yyr1[yyn] - YYNTOKENS;
     4496: 3887:    const int yyi = yypgoto[yylhs] + *yyssp;
     1133: 3888:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
      572: 3889:               ? yytable[yyi]
     5629: 3890:               : yydefgoto[yylhs]);
        -: 3891:  }
        -: 3892:
     4496: 3893:  goto yynewstate;
        -: 3894:
        -: 3895:
        -: 3896:/*--------------------------------------.
        -: 3897:| yyerrlab -- here on detecting error.  |
        -: 3898:`--------------------------------------*/
       71: 3899:yyerrlab:
        -: 3900:  /* Make sure we have latest lookahead translation.  See comments at
        -: 3901:     user semantic actions for why this is necessary.  */
      71*: 3902:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 3903:
        -: 3904:  /* If not already recovering from an error, report this error.  */
       71: 3905:  if (!yyerrstatus)
        -: 3906:    {
        3: 3907:      ++yynerrs;
        -: 3908:#if ! YYERROR_VERBOSE
        -: 3909:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 3910:#else
        -: 3911:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 3912:                                        yyssp, yytoken)
        -: 3913:      {
        3: 3914:        char const *yymsgp = YY_("syntax error");
        -: 3915:        int yysyntax_error_status;
        3: 3916:        yysyntax_error_status = YYSYNTAX_ERROR;
        3: 3917:        if (yysyntax_error_status == 0)
        3: 3918:          yymsgp = yymsg;
    #####: 3919:        else if (yysyntax_error_status == 1)
        -: 3920:          {
    #####: 3921:            if (yymsg != yymsgbuf)
    #####: 3922:              YYSTACK_FREE (yymsg);
    #####: 3923:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 3924:            if (!yymsg)
        -: 3925:              {
    #####: 3926:                yymsg = yymsgbuf;
    #####: 3927:                yymsg_alloc = sizeof yymsgbuf;
    #####: 3928:                yysyntax_error_status = 2;
        -: 3929:              }
        -: 3930:            else
        -: 3931:              {
    #####: 3932:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 3933:                yymsgp = yymsg;
        -: 3934:              }
        -: 3935:          }
        3: 3936:        yyerror (yyscanner, compiler, yymsgp);
        3: 3937:        if (yysyntax_error_status == 2)
    #####: 3938:          goto yyexhaustedlab;
        -: 3939:      }
        -: 3940:# undef YYSYNTAX_ERROR
        -: 3941:#endif
        -: 3942:    }
        -: 3943:
        -: 3944:
        -: 3945:
       71: 3946:  if (yyerrstatus == 3)
        -: 3947:    {
        -: 3948:      /* If just tried and failed to reuse lookahead token after an
        -: 3949:         error, discard it.  */
        -: 3950:
       68: 3951:      if (yychar <= YYEOF)
        -: 3952:        {
        -: 3953:          /* Return failure if at end of input.  */
       16: 3954:          if (yychar == YYEOF)
       16: 3955:            YYABORT;
        -: 3956:        }
        -: 3957:      else
        -: 3958:        {
       52: 3959:          yydestruct ("Error: discarding",
        -: 3960:                      yytoken, &yylval, yyscanner, compiler);
       52: 3961:          yychar = YYEMPTY;
        -: 3962:        }
        -: 3963:    }
        -: 3964:
        -: 3965:  /* Else will try to reuse lookahead token after shifting the error
        -: 3966:     token.  */
       55: 3967:  goto yyerrlab1;
        -: 3968:
        -: 3969:
        -: 3970:/*---------------------------------------------------.
        -: 3971:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 3972:`---------------------------------------------------*/
       13: 3973:yyerrorlab:
        -: 3974:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 3975:     label yyerrorlab therefore never appears in user code.  */
        -: 3976:  if (0)
        -: 3977:    YYERROR;
        -: 3978:
        -: 3979:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 3980:     this YYERROR.  */
       13: 3981:  YYPOPSTACK (yylen);
       13: 3982:  yylen = 0;
        -: 3983:  YY_STACK_PRINT (yyss, yyssp);
       13: 3984:  yystate = *yyssp;
       13: 3985:  goto yyerrlab1;
        -: 3986:
        -: 3987:
        -: 3988:/*-------------------------------------------------------------.
        -: 3989:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 3990:`-------------------------------------------------------------*/
       68: 3991:yyerrlab1:
       68: 3992:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 3993:
        -: 3994:  for (;;)
        -: 3995:    {
      322: 3996:      yyn = yypact[yystate];
      322: 3997:      if (!yypact_value_is_default (yyn))
        -: 3998:        {
      305: 3999:          yyn += YYTERROR;
      305: 4000:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 4001:            {
       68: 4002:              yyn = yytable[yyn];
       68: 4003:              if (0 < yyn)
       68: 4004:                break;
        -: 4005:            }
        -: 4006:        }
        -: 4007:
        -: 4008:      /* Pop the current state because it cannot handle the error token.  */
      254: 4009:      if (yyssp == yyss)
    #####: 4010:        YYABORT;
        -: 4011:
        -: 4012:
      254: 4013:      yydestruct ("Error: popping",
      254: 4014:                  yystos[yystate], yyvsp, yyscanner, compiler);
      254: 4015:      YYPOPSTACK (1);
      254: 4016:      yystate = *yyssp;
        -: 4017:      YY_STACK_PRINT (yyss, yyssp);
        -: 4018:    }
        -: 4019:
        -: 4020:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       68: 4021:  *++yyvsp = yylval;
        -: 4022:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 4023:
        -: 4024:
        -: 4025:  /* Shift the error token.  */
        -: 4026:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 4027:
       68: 4028:  yystate = yyn;
       68: 4029:  goto yynewstate;
        -: 4030:
        -: 4031:
        -: 4032:/*-------------------------------------.
        -: 4033:| yyacceptlab -- YYACCEPT comes here.  |
        -: 4034:`-------------------------------------*/
      266: 4035:yyacceptlab:
      266: 4036:  yyresult = 0;
      266: 4037:  goto yyreturn;
        -: 4038:
        -: 4039:
        -: 4040:/*-----------------------------------.
        -: 4041:| yyabortlab -- YYABORT comes here.  |
        -: 4042:`-----------------------------------*/
       16: 4043:yyabortlab:
       16: 4044:  yyresult = 1;
       16: 4045:  goto yyreturn;
        -: 4046:
        -: 4047:
        -: 4048:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 4049:/*-------------------------------------------------.
        -: 4050:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 4051:`-------------------------------------------------*/
    #####: 4052:yyexhaustedlab:
    #####: 4053:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
    #####: 4054:  yyresult = 2;
        -: 4055:  /* Fall through.  */
        -: 4056:#endif
        -: 4057:
        -: 4058:
        -: 4059:/*-----------------------------------------------------.
        -: 4060:| yyreturn -- parsing is finished, return the result.  |
        -: 4061:`-----------------------------------------------------*/
      282: 4062:yyreturn:
      282: 4063:  if (yychar != YYEMPTY)
        -: 4064:    {
        -: 4065:      /* Make sure we have latest lookahead translation.  See comments at
        -: 4066:         user semantic actions for why this is necessary.  */
      16*: 4067:      yytoken = YYTRANSLATE (yychar);
       16: 4068:      yydestruct ("Cleanup: discarding lookahead",
        -: 4069:                  yytoken, &yylval, yyscanner, compiler);
        -: 4070:    }
        -: 4071:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4072:     this YYABORT or YYACCEPT.  */
      282: 4073:  YYPOPSTACK (yylen);
        -: 4074:  YY_STACK_PRINT (yyss, yyssp);
      862: 4075:  while (yyssp != yyss)
        -: 4076:    {
      580: 4077:      yydestruct ("Cleanup: popping",
      580: 4078:                  yystos[+*yyssp], yyvsp, yyscanner, compiler);
      580: 4079:      YYPOPSTACK (1);
        -: 4080:    }
        -: 4081:#ifndef yyoverflow
      282: 4082:  if (yyss != yyssa)
    #####: 4083:    YYSTACK_FREE (yyss);
        -: 4084:#endif
        -: 4085:#if YYERROR_VERBOSE
      282: 4086:  if (yymsg != yymsgbuf)
    #####: 4087:    YYSTACK_FREE (yymsg);
        -: 4088:#endif
      282: 4089:  return yyresult;
        -: 4090:}
        -: 4091:#line 1999 "grammar.y"
        -: 4092:
