        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/libyara/exec.gcno
        -:    0:Data:/home/workspace/libyara/exec.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <string.h>
        -:   33:#include <assert.h>
        -:   34:#include <math.h>
        -:   35:#include <float.h>
        -:   36:
        -:   37:#include <yara/globals.h>
        -:   38:#include <yara/arena.h>
        -:   39:#include <yara/endian.h>
        -:   40:#include <yara/exec.h>
        -:   41:#include <yara/limits.h>
        -:   42:#include <yara/error.h>
        -:   43:#include <yara/object.h>
        -:   44:#include <yara/modules.h>
        -:   45:#include <yara/re.h>
        -:   46:#include <yara/strutils.h>
        -:   47:#include <yara/utils.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/stopwatch.h>
        -:   50:
        -:   51:
        -:   52:#include <yara.h>
        -:   53:
        -:   54:
        -:   55:// Turn on paranoid mode by default if not defined otherwise. In paranoid
        -:   56:// mode additional checks are performed in order to mitigate the effects of
        -:   57:// malicious tampering with compiled rules. Such checks are not necessary
        -:   58:// when you can ensure that the compiled rules are executed exactly as they
        -:   59:// were generated by YARA, without any further modification. Check issue #891
        -:   60:// (https://github.com/VirusTotal/yara/issues/891) for more context.
        -:   61://
        -:   62:// Paranoid mode does not guarantee that it's safe to load compiled rules from
        -:   63:// third parties, it only prevents severe security issues. Maliciously crafted
        -:   64:// compiled rules can still crash YARA. Loading third-party compiled rules is
        -:   65:// *highly* undiscouraged. If you need to distribute YARA rules in compiled
        -:   66:// form you should encapsulate them in some digitally-signed package that
        -:   67:// ensure that they haven't been modified by someone else.
        -:   68:
        -:   69:#if !defined(PARANOID_EXEC)
        -:   70:#define PARANOID_EXEC   1
        -:   71:#endif
        -:   72:
        -:   73:
        -:   74:#define MEM_SIZE   YR_MAX_LOOP_NESTING * LOOP_LOCAL_VARS
        -:   75:
        -:   76:
        -:   77:#define push(x)  \
        -:   78:    if (sp < stack_size) \
        -:   79:    { \
        -:   80:      stack[sp++] = (x); \
        -:   81:    } \
        -:   82:    else \
        -:   83:    { \
        -:   84:      result = ERROR_EXEC_STACK_OVERFLOW; \
        -:   85:      stop = true; \
        -:   86:      break; \
        -:   87:    } \
        -:   88:
        -:   89:
        -:   90:#define pop(x) { assert(sp > 0); x = stack[--sp]; }
        -:   91:
        -:   92:#define is_undef(x) IS_UNDEFINED((x).i)
        -:   93:
        -:   94:#define ensure_defined(x) \
        -:   95:    if (is_undef(x)) \
        -:   96:    { \
        -:   97:      r1.i = UNDEFINED; \
        -:   98:      push(r1); \
        -:   99:      break; \
        -:  100:    }
        -:  101:
        -:  102:#define ensure_within_mem(x) \
        -:  103:    if (x < 0 || x >= MEM_SIZE) \
        -:  104:    { \
        -:  105:      stop = true; \
        -:  106:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  107:      break; \
        -:  108:    }
        -:  109:
        -:  110:#define check_object_canary(o) \
        -:  111:    if (o->canary != yr_canary) \
        -:  112:    { \
        -:  113:      stop = true; \
        -:  114:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  115:      break; \
        -:  116:    }
        -:  117:
        -:  118:#define little_endian_uint8_t(x)     (x)
        -:  119:#define little_endian_int8_t(x)      (x)
        -:  120:#define little_endian_uint16_t(x)    yr_le16toh(x)
        -:  121:#define little_endian_int16_t(x)     yr_le16toh(x)
        -:  122:#define little_endian_uint32_t(x)    yr_le32toh(x)
        -:  123:#define little_endian_int32_t(x)     yr_le32toh(x)
        -:  124:
        -:  125:#define big_endian_uint8_t(x)        (x)
        -:  126:#define big_endian_int8_t(x)         (x)
        -:  127:#define big_endian_uint16_t(x)       yr_be16toh(x)
        -:  128:#define big_endian_int16_t(x)        yr_be16toh(x)
        -:  129:#define big_endian_uint32_t(x)       yr_be32toh(x)
        -:  130:#define big_endian_int32_t(x)        yr_be32toh(x)
        -:  131:
        -:  132:
        -:  133:#define function_read(type, endianess) \
        -:  134:    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \
        -:  135:    { \
        -:  136:      YR_MEMORY_BLOCK* block = iterator->first(iterator); \
        -:  137:      while (block != NULL) \
        -:  138:      { \
        -:  139:        if (offset >= block->base && \
        -:  140:            block->size >= sizeof(type) && \
        -:  141:            offset <= block->base + block->size - sizeof(type)) \
        -:  142:        { \
        -:  143:          type result; \
        -:  144:          const uint8_t* data = block->fetch_data(block); \
        -:  145:          if (data == NULL) \
        -:  146:            return UNDEFINED; \
        -:  147:          result = *(type *)(data + offset - block->base); \
        -:  148:          result = endianess##_##type(result); \
        -:  149:          return result; \
        -:  150:        } \
        -:  151:        block = iterator->next(iterator); \
        -:  152:      } \
        -:  153:      return UNDEFINED; \
        -:  154:    };
        -:  155:
        -:  156:
    #####:  157:function_read(uint8_t, little_endian)
    #####:  158:function_read(uint16_t, little_endian)
    #####:  159:function_read(uint32_t, little_endian)
    #####:  160:function_read(int8_t, little_endian)
    #####:  161:function_read(int16_t, little_endian)
    #####:  162:function_read(int32_t, little_endian)
    #####:  163:function_read(uint8_t, big_endian)
    #####:  164:function_read(uint16_t, big_endian)
    #####:  165:function_read(uint32_t, big_endian)
    #####:  166:function_read(int8_t, big_endian)
    #####:  167:function_read(int16_t, big_endian)
    #####:  168:function_read(int32_t, big_endian)
        -:  169:
        -:  170:
    #####:  171:static const uint8_t* jmp_if(
        -:  172:    int condition,
        -:  173:    const uint8_t* ip)
        -:  174:{
        -:  175:  const uint8_t* result;
        -:  176:
    #####:  177:  if (condition)
        -:  178:  {
    #####:  179:    result = *(const uint8_t**)(ip);
        -:  180:  }
        -:  181:  else
        -:  182:  {
    #####:  183:    result = ip + sizeof(uint64_t);
        -:  184:  }
        -:  185:
    #####:  186:  return result;
        -:  187:}
        -:  188:
        -:  189:
      266:  190:int yr_execute_code(
        -:  191:    YR_SCAN_CONTEXT* context)
        -:  192:{
        -:  193:  int64_t mem[MEM_SIZE];
      266:  194:  int32_t sp = 0;
        -:  195:
      266:  196:  const uint8_t* ip = context->rules->code_start;
        -:  197:
        -:  198:  YR_VALUE args[YR_MAX_FUNCTION_ARGS];
        -:  199:  YR_VALUE *stack;
        -:  200:  YR_VALUE r1;
        -:  201:  YR_VALUE r2;
        -:  202:  YR_VALUE r3;
        -:  203:
        -:  204:  uint64_t elapsed_time;
        -:  205:
        -:  206:  #ifdef PROFILING_ENABLED
        -:  207:  uint64_t start_time;
        -:  208:  YR_RULE* current_rule = NULL;
        -:  209:  #endif
        -:  210:
        -:  211:  YR_INIT_RULE_ARGS init_rule_args;
        -:  212:
        -:  213:  YR_RULE* rule;
        -:  214:  YR_MATCH* match;
        -:  215:  YR_OBJECT_FUNCTION* function;
        -:  216:  YR_OBJECT** obj_ptr;
        -:  217:  YR_ARENA* obj_arena;
        -:  218:
        -:  219:  char* identifier;
        -:  220:  char* args_fmt;
        -:  221:
        -:  222:  int i;
        -:  223:  int found;
        -:  224:  int count;
      266:  225:  int result = ERROR_SUCCESS;
      266:  226:  int cycle = 0;
      266:  227:  int tidx = context->tidx;
        -:  228:  int stack_size;
        -:  229:
      266:  230:  bool stop = false;
        -:  231:
        -:  232:  uint8_t opcode;
        -:  233:
      266:  234:  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
        -:  235:
      266:  236:  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
        -:  237:
      266:  238:  if (stack == NULL)
    #####:  239:    return ERROR_INSUFFICIENT_MEMORY;
        -:  240:
     266*:  241:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  242:      yr_arena_create(1024, 0, &obj_arena),
        -:  243:      yr_free(stack));
        -:  244:
        -:  245:  #ifdef PROFILING_ENABLED
        -:  246:  start_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  247:  #endif
        -:  248:
        -:  249:  #if PARANOID_EXEC
      266:  250:  memset(mem, 0, MEM_SIZE * sizeof(mem[0]));
        -:  251:  #endif
        -:  252:
     1874:  253:  while(!stop)
        -:  254:  {
     1608:  255:    opcode = *ip;
     1608:  256:    ip++;
        -:  257:
     1608:  258:    switch(opcode)
        -:  259:    {
      266:  260:      case OP_NOP:
      266:  261:        break;
        -:  262:
      266:  263:      case OP_HALT:
     266*:  264:        assert(sp == 0); // When HALT is reached the stack should be empty.
      266:  265:        stop = true;
      266:  266:        break;
        -:  267:
      274:  268:      case OP_PUSH:
      274:  269:        r1.i = *(uint64_t*)(ip);
      274:  270:        ip += sizeof(uint64_t);
     274*:  271:        push(r1);
      274:  272:        break;
        -:  273:
    #####:  274:      case OP_POP:
    #####:  275:        pop(r1);
    #####:  276:        break;
        -:  277:
    #####:  278:      case OP_CLEAR_M:
    #####:  279:        r1.i = *(uint64_t*)(ip);
    #####:  280:        ip += sizeof(uint64_t);
        -:  281:        #if PARANOID_EXEC
    #####:  282:        ensure_within_mem(r1.i);
        -:  283:        #endif
    #####:  284:        mem[r1.i] = 0;
    #####:  285:        break;
        -:  286:
    #####:  287:      case OP_ADD_M:
    #####:  288:        r1.i = *(uint64_t*)(ip);
    #####:  289:        ip += sizeof(uint64_t);
        -:  290:        #if PARANOID_EXEC
    #####:  291:        ensure_within_mem(r1.i);
        -:  292:        #endif
    #####:  293:        pop(r2);
    #####:  294:        if (!is_undef(r2))
    #####:  295:          mem[r1.i] += r2.i;
    #####:  296:        break;
        -:  297:
    #####:  298:      case OP_INCR_M:
    #####:  299:        r1.i = *(uint64_t*)(ip);
    #####:  300:        ip += sizeof(uint64_t);
        -:  301:        #if PARANOID_EXEC
    #####:  302:        ensure_within_mem(r1.i);
        -:  303:        #endif
    #####:  304:        mem[r1.i]++;
    #####:  305:        break;
        -:  306:
    #####:  307:      case OP_PUSH_M:
    #####:  308:        r1.i = *(uint64_t*)(ip);
    #####:  309:        ip += sizeof(uint64_t);
        -:  310:        #if PARANOID_EXEC
    #####:  311:        ensure_within_mem(r1.i);
        -:  312:        #endif
    #####:  313:        r1.i = mem[r1.i];
    #####:  314:        push(r1);
    #####:  315:        break;
        -:  316:
    #####:  317:      case OP_POP_M:
    #####:  318:        r1.i = *(uint64_t*)(ip);
    #####:  319:        ip += sizeof(uint64_t);
        -:  320:        #if PARANOID_EXEC
    #####:  321:        ensure_within_mem(r1.i);
        -:  322:        #endif
    #####:  323:        pop(r2);
    #####:  324:        mem[r1.i] = r2.i;
    #####:  325:        break;
        -:  326:
    #####:  327:      case OP_SWAPUNDEF:
    #####:  328:        r1.i = *(uint64_t*)(ip);
    #####:  329:        ip += sizeof(uint64_t);
        -:  330:        #if PARANOID_EXEC
    #####:  331:        ensure_within_mem(r1.i);
        -:  332:        #endif
    #####:  333:        pop(r2);
        -:  334:
    #####:  335:        if (is_undef(r2))
        -:  336:        {
    #####:  337:          r1.i = mem[r1.i];
    #####:  338:          push(r1);
        -:  339:        }
        -:  340:        else
        -:  341:        {
    #####:  342:          push(r2);
        -:  343:        }
    #####:  344:        break;
        -:  345:
    #####:  346:      case OP_JNUNDEF:
    #####:  347:        pop(r1);
    #####:  348:        push(r1);
        -:  349:
    #####:  350:        ip = jmp_if(!is_undef(r1), ip);
    #####:  351:        break;
        -:  352:
    #####:  353:      case OP_JLE:
    #####:  354:        pop(r2);
    #####:  355:        pop(r1);
    #####:  356:        push(r1);
    #####:  357:        push(r2);
        -:  358:
    #####:  359:        ip = jmp_if(r1.i <= r2.i, ip);
    #####:  360:        break;
        -:  361:
    #####:  362:      case OP_JTRUE:
    #####:  363:        pop(r1);
    #####:  364:        push(r1);
        -:  365:
    #####:  366:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  367:        break;
        -:  368:
    #####:  369:      case OP_JFALSE:
    #####:  370:        pop(r1);
    #####:  371:        push(r1);
        -:  372:
    #####:  373:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  374:        break;
        -:  375:
    #####:  376:      case OP_AND:
    #####:  377:        pop(r2);
    #####:  378:        pop(r1);
        -:  379:
    #####:  380:        if (is_undef(r1) || is_undef(r2))
    #####:  381:          r1.i = 0;
        -:  382:        else
    #####:  383:          r1.i = r1.i && r2.i;
        -:  384:
    #####:  385:        push(r1);
    #####:  386:        break;
        -:  387:
    #####:  388:      case OP_OR:
    #####:  389:        pop(r2);
    #####:  390:        pop(r1);
        -:  391:
    #####:  392:        if (is_undef(r1))
        -:  393:        {
    #####:  394:          push(r2);
        -:  395:        }
    #####:  396:        else if (is_undef(r2))
        -:  397:        {
    #####:  398:          push(r1);
        -:  399:        }
        -:  400:        else
        -:  401:        {
    #####:  402:          r1.i = r1.i || r2.i;
    #####:  403:          push(r1);
        -:  404:        }
    #####:  405:        break;
        -:  406:
    #####:  407:      case OP_NOT:
    #####:  408:        pop(r1);
        -:  409:
    #####:  410:        if (is_undef(r1))
    #####:  411:          r1.i = UNDEFINED;
        -:  412:        else
    #####:  413:          r1.i= !r1.i;
        -:  414:
    #####:  415:        push(r1);
    #####:  416:        break;
        -:  417:
    #####:  418:      case OP_MOD:
    #####:  419:        pop(r2);
    #####:  420:        pop(r1);
    #####:  421:        ensure_defined(r2);
    #####:  422:        ensure_defined(r1);
    #####:  423:        if (r2.i != 0)
    #####:  424:          r1.i = r1.i % r2.i;
        -:  425:        else
    #####:  426:          r1.i = UNDEFINED;
    #####:  427:        push(r1);
    #####:  428:        break;
        -:  429:
    #####:  430:      case OP_SHR:
    #####:  431:        pop(r2);
    #####:  432:        pop(r1);
    #####:  433:        ensure_defined(r2);
    #####:  434:        ensure_defined(r1);
    #####:  435:        if (r2.i < 0)
    #####:  436:          r1.i = UNDEFINED;
    #####:  437:        else if (r2.i < 64)
    #####:  438:          r1.i = r1.i >> r2.i;
        -:  439:        else
    #####:  440:          r1.i = 0;
    #####:  441:        push(r1);
    #####:  442:        break;
        -:  443:
    #####:  444:      case OP_SHL:
    #####:  445:        pop(r2);
    #####:  446:        pop(r1);
    #####:  447:        ensure_defined(r2);
    #####:  448:        ensure_defined(r1);
    #####:  449:        if (r2.i < 0)
    #####:  450:          r1.i = UNDEFINED;
    #####:  451:        else if (r2.i < 64)
    #####:  452:          r1.i = r1.i << r2.i;
        -:  453:        else
    #####:  454:          r1.i = 0;
    #####:  455:        push(r1);
    #####:  456:        break;
        -:  457:
    #####:  458:      case OP_BITWISE_NOT:
    #####:  459:        pop(r1);
    #####:  460:        ensure_defined(r1);
    #####:  461:        r1.i = ~r1.i;
    #####:  462:        push(r1);
    #####:  463:        break;
        -:  464:
    #####:  465:      case OP_BITWISE_AND:
    #####:  466:        pop(r2);
    #####:  467:        pop(r1);
    #####:  468:        ensure_defined(r2);
    #####:  469:        ensure_defined(r1);
    #####:  470:        r1.i = r1.i & r2.i;
    #####:  471:        push(r1);
    #####:  472:        break;
        -:  473:
    #####:  474:      case OP_BITWISE_OR:
    #####:  475:        pop(r2);
    #####:  476:        pop(r1);
    #####:  477:        ensure_defined(r2);
    #####:  478:        ensure_defined(r1);
    #####:  479:        r1.i = r1.i | r2.i;
    #####:  480:        push(r1);
    #####:  481:        break;
        -:  482:
    #####:  483:      case OP_BITWISE_XOR:
    #####:  484:        pop(r2);
    #####:  485:        pop(r1);
    #####:  486:        ensure_defined(r2);
    #####:  487:        ensure_defined(r1);
    #####:  488:        r1.i = r1.i ^ r2.i;
    #####:  489:        push(r1);
    #####:  490:        break;
        -:  491:
    #####:  492:      case OP_PUSH_RULE:
    #####:  493:        rule = *(YR_RULE**)(ip);
    #####:  494:        ip += sizeof(uint64_t);
    #####:  495:        if (RULE_IS_DISABLED(rule))
    #####:  496:          r1.i = UNDEFINED;
        -:  497:        else
    #####:  498:          r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
    #####:  499:        push(r1);
    #####:  500:        break;
        -:  501:
      266:  502:      case OP_INIT_RULE:
      266:  503:        memcpy(&init_rule_args, ip, sizeof(init_rule_args));
        -:  504:        #ifdef PROFILING_ENABLED
        -:  505:        current_rule = init_rule_args.rule;
        -:  506:        #endif
      266:  507:        if (RULE_IS_DISABLED(init_rule_args.rule))
    #####:  508:          ip = init_rule_args.jmp_addr;
        -:  509:        else
      266:  510:          ip += sizeof(init_rule_args);
      266:  511:        break;
        -:  512:
      266:  513:      case OP_MATCH_RULE:
     266*:  514:        pop(r1);
      266:  515:        rule = *(YR_RULE**)(ip);
      266:  516:        ip += sizeof(uint64_t);
        -:  517:
      266:  518:        if (!is_undef(r1) && r1.i)
      199:  519:          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
       67:  520:        else if (RULE_IS_GLOBAL(rule))
    #####:  521:          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
        -:  522:
        -:  523:        #ifdef PROFILING_ENABLED
        -:  524:        elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  525:        rule->time_cost_per_thread[tidx] += (elapsed_time - start_time);
        -:  526:        start_time = elapsed_time;
        -:  527:        #endif
        -:  528:
     266*:  529:        assert(sp == 0); // at this point the stack should be empty.
      266:  530:        break;
        -:  531:
    #####:  532:      case OP_OBJ_LOAD:
    #####:  533:        identifier = *(char**)(ip);
    #####:  534:        ip += sizeof(uint64_t);
        -:  535:
    #####:  536:        r1.o = (YR_OBJECT*) yr_hash_table_lookup(
        -:  537:            context->objects_table,
        -:  538:            identifier,
        -:  539:            NULL);
        -:  540:
    #####:  541:        assert(r1.o != NULL);
    #####:  542:        push(r1);
    #####:  543:        break;
        -:  544:
    #####:  545:      case OP_OBJ_FIELD:
    #####:  546:        identifier = *(char**)(ip);
    #####:  547:        ip += sizeof(uint64_t);
        -:  548:
    #####:  549:        pop(r1);
    #####:  550:        ensure_defined(r1);
        -:  551:
    #####:  552:        r1.o = yr_object_lookup_field(r1.o, identifier);
        -:  553:
    #####:  554:        assert(r1.o != NULL);
    #####:  555:        push(r1);
    #####:  556:        break;
        -:  557:
    #####:  558:      case OP_OBJ_VALUE:
    #####:  559:        pop(r1);
    #####:  560:        ensure_defined(r1);
        -:  561:
        -:  562:        #if PARANOID_EXEC
    #####:  563:        check_object_canary(r1.o);
        -:  564:        #endif
        -:  565:
    #####:  566:        switch(r1.o->type)
        -:  567:        {
    #####:  568:          case OBJECT_TYPE_INTEGER:
    #####:  569:            r1.i = r1.o->value.i;
    #####:  570:            break;
        -:  571:
    #####:  572:          case OBJECT_TYPE_FLOAT:
    #####:  573:            if (isnan(r1.o->value.d))
    #####:  574:              r1.i = UNDEFINED;
        -:  575:            else
    #####:  576:              r1.d = r1.o->value.d;
    #####:  577:            break;
        -:  578:
    #####:  579:          case OBJECT_TYPE_STRING:
    #####:  580:            if (r1.o->value.ss == NULL)
    #####:  581:              r1.i = UNDEFINED;
        -:  582:            else
    #####:  583:              r1.ss = r1.o->value.ss;
    #####:  584:            break;
        -:  585:
    #####:  586:          default:
    #####:  587:            assert(false);
        -:  588:        }
        -:  589:
    #####:  590:        push(r1);
    #####:  591:        break;
        -:  592:
    #####:  593:      case OP_INDEX_ARRAY:
    #####:  594:        pop(r1);  // index
    #####:  595:        pop(r2);  // array
        -:  596:
    #####:  597:        ensure_defined(r1);
    #####:  598:        ensure_defined(r2);
        -:  599:
    #####:  600:        assert(r2.o->type == OBJECT_TYPE_ARRAY);
        -:  601:
        -:  602:        #if PARANOID_EXEC
    #####:  603:        check_object_canary(r2.o);
        -:  604:        #endif
        -:  605:
    #####:  606:        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
        -:  607:
    #####:  608:        if (r1.o == NULL)
    #####:  609:          r1.i = UNDEFINED;
        -:  610:
    #####:  611:        push(r1);
    #####:  612:        break;
        -:  613:
    #####:  614:      case OP_LOOKUP_DICT:
    #####:  615:        pop(r1);  // key
    #####:  616:        pop(r2);  // dictionary
        -:  617:
    #####:  618:        ensure_defined(r1);
    #####:  619:        ensure_defined(r2);
        -:  620:
    #####:  621:        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
        -:  622:
        -:  623:        #if PARANOID_EXEC
    #####:  624:        check_object_canary(r2.o);
        -:  625:        #endif
        -:  626:
    #####:  627:        r1.o = yr_object_dict_get_item(
    #####:  628:            r2.o, 0, r1.ss->c_string);
        -:  629:
    #####:  630:        if (r1.o == NULL)
    #####:  631:          r1.i = UNDEFINED;
        -:  632:
    #####:  633:        push(r1);
    #####:  634:        break;
        -:  635:
    #####:  636:      case OP_CALL:
    #####:  637:        args_fmt = *(char**)(ip);
    #####:  638:        ip += sizeof(uint64_t);
        -:  639:
    #####:  640:        i = (int) strlen(args_fmt);
    #####:  641:        count = 0;
        -:  642:
        -:  643:        #if PARANOID_EXEC
    #####:  644:        if (i > YR_MAX_FUNCTION_ARGS)
        -:  645:        {
    #####:  646:          stop = true;
    #####:  647:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####:  648:          break;
        -:  649:        }
        -:  650:        #endif
        -:  651:
        -:  652:        // pop arguments from stack and copy them to args array
        -:  653:
    #####:  654:        while (i > 0)
        -:  655:        {
    #####:  656:          pop(r1);
        -:  657:
    #####:  658:          if (is_undef(r1))  // count the number of undefined args
    #####:  659:            count++;
        -:  660:
    #####:  661:          args[i - 1] = r1;
    #####:  662:          i--;
        -:  663:        }
        -:  664:
    #####:  665:        pop(r2);
    #####:  666:        ensure_defined(r2);
        -:  667:
        -:  668:        #if PARANOID_EXEC
    #####:  669:        check_object_canary(r2.o);
        -:  670:        #endif
        -:  671:
    #####:  672:        if (count > 0)
        -:  673:        {
        -:  674:          // if there are undefined args, result for function call
        -:  675:          // is undefined as well.
        -:  676:
    #####:  677:          r1.i = UNDEFINED;
    #####:  678:          push(r1);
    #####:  679:          break;
        -:  680:        }
        -:  681:
    #####:  682:        function = object_as_function(r2.o);
    #####:  683:        result = ERROR_INTERNAL_FATAL_ERROR;
        -:  684:
    #####:  685:        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  686:        {
    #####:  687:          if (function->prototypes[i].arguments_fmt == NULL)
    #####:  688:            break;
        -:  689:
    #####:  690:          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
        -:  691:          {
    #####:  692:            result = function->prototypes[i].code(args, context, function);
    #####:  693:            break;
        -:  694:          }
        -:  695:        }
        -:  696:
        -:  697:        // if i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching
        -:  698:        // prototype was found, but this shouldn't happen.
        -:  699:
    #####:  700:        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);
        -:  701:
        -:  702:        // make a copy of the returned object and push the copy into the stack
        -:  703:        // function->return_obj can't be pushed because it can change in
        -:  704:        // subsequent calls to the same function.
        -:  705:
    #####:  706:        if (result == ERROR_SUCCESS)
    #####:  707:          result = yr_object_copy(function->return_obj, &r1.o);
        -:  708:
        -:  709:        // a pointer to the copied object is stored in a arena in order to
        -:  710:        // free the object before exiting yr_execute_code
        -:  711:
    #####:  712:        if (result == ERROR_SUCCESS)
    #####:  713:          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);
        -:  714:
    #####:  715:        stop = (result != ERROR_SUCCESS);
    #####:  716:        push(r1);
    #####:  717:        break;
        -:  718:
      262:  719:      case OP_FOUND:
     262*:  720:        pop(r1);
      262:  721:        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
     262*:  722:        push(r1);
      262:  723:        break;
        -:  724:
    #####:  725:      case OP_FOUND_AT:
    #####:  726:        pop(r2);
    #####:  727:        pop(r1);
        -:  728:
    #####:  729:        if (is_undef(r1))
        -:  730:        {
    #####:  731:          r1.i = 0;
    #####:  732:          push(r1);
    #####:  733:          break;
        -:  734:        }
        -:  735:
    #####:  736:        match = r2.s->matches[tidx].head;
    #####:  737:        r3.i = false;
        -:  738:
    #####:  739:        while (match != NULL)
        -:  740:        {
    #####:  741:          if (r1.i == match->base + match->offset)
        -:  742:          {
    #####:  743:            r3.i = true;
    #####:  744:            break;
        -:  745:          }
        -:  746:
    #####:  747:          if (r1.i < match->base + match->offset)
    #####:  748:            break;
        -:  749:
    #####:  750:          match = match->next;
        -:  751:        }
        -:  752:
    #####:  753:        push(r3);
    #####:  754:        break;
        -:  755:
    #####:  756:      case OP_FOUND_IN:
    #####:  757:        pop(r3);
    #####:  758:        pop(r2);
    #####:  759:        pop(r1);
        -:  760:
    #####:  761:        ensure_defined(r1);
    #####:  762:        ensure_defined(r2);
        -:  763:
    #####:  764:        match = r3.s->matches[tidx].head;
    #####:  765:        r3.i = false;
        -:  766:
    #####:  767:        while (match != NULL && !r3.i)
        -:  768:        {
    #####:  769:          if (match->base + match->offset >= r1.i &&
    #####:  770:              match->base + match->offset <= r2.i)
        -:  771:          {
    #####:  772:            r3.i = true;
        -:  773:          }
        -:  774:
    #####:  775:          if (match->base + match->offset > r2.i)
    #####:  776:            break;
        -:  777:
    #####:  778:          match = match->next;
        -:  779:        }
        -:  780:
    #####:  781:        push(r3);
    #####:  782:        break;
        -:  783:
    #####:  784:      case OP_COUNT:
    #####:  785:        pop(r1);
        -:  786:
        -:  787:        #if PARANOID_EXEC
        -:  788:        // Make sure that the string pointer is within the rules arena.
    #####:  789:        if (yr_arena_page_for_address(context->rules->arena, r1.p) == NULL)
    #####:  790:          return ERROR_INTERNAL_FATAL_ERROR;
        -:  791:        #endif
        -:  792:
    #####:  793:        r1.i = r1.s->matches[tidx].count;
    #####:  794:        push(r1);
    #####:  795:        break;
        -:  796:
    #####:  797:      case OP_OFFSET:
    #####:  798:        pop(r2);
    #####:  799:        pop(r1);
        -:  800:
    #####:  801:        ensure_defined(r1);
        -:  802:
    #####:  803:        match = r2.s->matches[tidx].head;
    #####:  804:        i = 1;
    #####:  805:        r3.i = UNDEFINED;
        -:  806:
    #####:  807:        while (match != NULL && r3.i == UNDEFINED)
        -:  808:        {
    #####:  809:          if (r1.i == i)
    #####:  810:            r3.i = match->base + match->offset;
        -:  811:
    #####:  812:          i++;
    #####:  813:          match = match->next;
        -:  814:        }
        -:  815:
    #####:  816:        push(r3);
    #####:  817:        break;
        -:  818:
        4:  819:      case OP_LENGTH:
       4*:  820:        pop(r2);
       4*:  821:        pop(r1);
        -:  822:
       4*:  823:        ensure_defined(r1);
        -:  824:
        4:  825:        match = r2.s->matches[tidx].head;
        4:  826:        i = 1;
        4:  827:        r3.i = UNDEFINED;
        -:  828:
        8:  829:        while (match != NULL && r3.i == UNDEFINED)
        -:  830:        {
        4:  831:          if (r1.i == i)
        4:  832:            r3.i = match->match_length;
        -:  833:
        4:  834:          i++;
        4:  835:          match = match->next;
        -:  836:        }
        -:  837:
       4*:  838:        push(r3);
        4:  839:        break;
        -:  840:
    #####:  841:      case OP_OF:
    #####:  842:        found = 0;
    #####:  843:        count = 0;
    #####:  844:        pop(r1);
        -:  845:
    #####:  846:        while (!is_undef(r1))
        -:  847:        {
    #####:  848:          if (r1.s->matches[tidx].tail != NULL)
    #####:  849:            found++;
    #####:  850:          count++;
    #####:  851:          pop(r1);
        -:  852:        }
        -:  853:
    #####:  854:        pop(r2);
        -:  855:
    #####:  856:        if (is_undef(r2))
    #####:  857:          r1.i = found >= count ? 1 : 0;
        -:  858:        else
    #####:  859:          r1.i = found >= r2.i ? 1 : 0;
        -:  860:
    #####:  861:        push(r1);
    #####:  862:        break;
        -:  863:
    #####:  864:      case OP_FILESIZE:
    #####:  865:        r1.i = context->file_size;
    #####:  866:        push(r1);
    #####:  867:        break;
        -:  868:
    #####:  869:      case OP_ENTRYPOINT:
    #####:  870:        r1.i = context->entry_point;
    #####:  871:        push(r1);
    #####:  872:        break;
        -:  873:
    #####:  874:      case OP_INT8:
    #####:  875:        pop(r1);
    #####:  876:        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  877:        push(r1);
    #####:  878:        break;
        -:  879:
    #####:  880:      case OP_INT16:
    #####:  881:        pop(r1);
    #####:  882:        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  883:        push(r1);
    #####:  884:        break;
        -:  885:
    #####:  886:      case OP_INT32:
    #####:  887:        pop(r1);
    #####:  888:        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  889:        push(r1);
    #####:  890:        break;
        -:  891:
    #####:  892:      case OP_UINT8:
    #####:  893:        pop(r1);
    #####:  894:        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  895:        push(r1);
    #####:  896:        break;
        -:  897:
    #####:  898:      case OP_UINT16:
    #####:  899:        pop(r1);
    #####:  900:        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  901:        push(r1);
    #####:  902:        break;
        -:  903:
    #####:  904:      case OP_UINT32:
    #####:  905:        pop(r1);
    #####:  906:        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  907:        push(r1);
    #####:  908:        break;
        -:  909:
    #####:  910:      case OP_INT8BE:
    #####:  911:        pop(r1);
    #####:  912:        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  913:        push(r1);
    #####:  914:        break;
        -:  915:
    #####:  916:      case OP_INT16BE:
    #####:  917:        pop(r1);
    #####:  918:        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  919:        push(r1);
    #####:  920:        break;
        -:  921:
    #####:  922:      case OP_INT32BE:
    #####:  923:        pop(r1);
    #####:  924:        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  925:        push(r1);
    #####:  926:        break;
        -:  927:
    #####:  928:      case OP_UINT8BE:
    #####:  929:        pop(r1);
    #####:  930:        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  931:        push(r1);
    #####:  932:        break;
        -:  933:
    #####:  934:      case OP_UINT16BE:
    #####:  935:        pop(r1);
    #####:  936:        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  937:        push(r1);
    #####:  938:        break;
        -:  939:
    #####:  940:      case OP_UINT32BE:
    #####:  941:        pop(r1);
    #####:  942:        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  943:        push(r1);
    #####:  944:        break;
        -:  945:
    #####:  946:      case OP_CONTAINS:
    #####:  947:        pop(r2);
    #####:  948:        pop(r1);
        -:  949:
    #####:  950:        ensure_defined(r1);
    #####:  951:        ensure_defined(r2);
        -:  952:
    #####:  953:        r1.i = memmem(r1.ss->c_string, r1.ss->length,
    #####:  954:                      r2.ss->c_string, r2.ss->length) != NULL;
    #####:  955:        push(r1);
    #####:  956:        break;
        -:  957:
    #####:  958:      case OP_IMPORT:
    #####:  959:        r1.i = *(uint64_t*)(ip);
    #####:  960:        ip += sizeof(uint64_t);
        -:  961:
    #####:  962:        result = yr_modules_load((char*) r1.p, context);
        -:  963:
    #####:  964:        if (result != ERROR_SUCCESS)
    #####:  965:          stop = true;
        -:  966:
    #####:  967:        break;
        -:  968:
    #####:  969:      case OP_MATCHES:
        -:  970:
    #####:  971:        pop(r2);
    #####:  972:        pop(r1);
        -:  973:
    #####:  974:        ensure_defined(r2);
    #####:  975:        ensure_defined(r1);
        -:  976:
    #####:  977:        if (r1.ss->length == 0)
        -:  978:        {
    #####:  979:          r1.i = false;
    #####:  980:          push(r1);
    #####:  981:          break;
        -:  982:        }
        -:  983:
    #####:  984:        result = yr_re_exec(
        -:  985:          context,
    #####:  986:          (uint8_t*) r2.re->code,
    #####:  987:          (uint8_t*) r1.ss->c_string,
    #####:  988:          r1.ss->length,
        -:  989:          0,
    #####:  990:          r2.re->flags | RE_FLAGS_SCAN,
        -:  991:          NULL,
        -:  992:          NULL,
        -:  993:          &found);
        -:  994:
    #####:  995:        if (result != ERROR_SUCCESS)
    #####:  996:          stop = true;
        -:  997:
    #####:  998:        r1.i = found >= 0;
    #####:  999:        push(r1);
    #####: 1000:        break;
        -: 1001:
    #####: 1002:      case OP_INT_TO_DBL:
        -: 1003:
    #####: 1004:        r1.i = *(uint64_t*)(ip);
    #####: 1005:        ip += sizeof(uint64_t);
        -: 1006:
        -: 1007:        #if PARANOID_EXEC
    #####: 1008:        if (r1.i > sp || sp - r1.i >= stack_size)
        -: 1009:        {
    #####: 1010:          stop = true;
    #####: 1011:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1012:          break;
        -: 1013:        }
        -: 1014:        #endif
        -: 1015:
    #####: 1016:        r2 = stack[sp - r1.i];
        -: 1017:
    #####: 1018:        if (is_undef(r2))
    #####: 1019:          stack[sp - r1.i].i = UNDEFINED;
        -: 1020:        else
    #####: 1021:          stack[sp - r1.i].d = (double) r2.i;
    #####: 1022:        break;
        -: 1023:
    #####: 1024:      case OP_STR_TO_BOOL:
    #####: 1025:        pop(r1);
    #####: 1026:        ensure_defined(r1);
    #####: 1027:        r1.i = r1.ss->length > 0;
    #####: 1028:        push(r1);
    #####: 1029:        break;
        -: 1030:
        4: 1031:      case OP_INT_EQ:
       4*: 1032:        pop(r2);
       4*: 1033:        pop(r1);
       4*: 1034:        ensure_defined(r2);
       4*: 1035:        ensure_defined(r1);
        4: 1036:        r1.i = r1.i == r2.i;
       4*: 1037:        push(r1);
        4: 1038:        break;
        -: 1039:
    #####: 1040:      case OP_INT_NEQ:
    #####: 1041:        pop(r2);
    #####: 1042:        pop(r1);
    #####: 1043:        ensure_defined(r2);
    #####: 1044:        ensure_defined(r1);
    #####: 1045:        r1.i = r1.i != r2.i;
    #####: 1046:        push(r1);
    #####: 1047:        break;
        -: 1048:
    #####: 1049:      case OP_INT_LT:
    #####: 1050:        pop(r2);
    #####: 1051:        pop(r1);
    #####: 1052:        ensure_defined(r2);
    #####: 1053:        ensure_defined(r1);
    #####: 1054:        r1.i = r1.i < r2.i;
    #####: 1055:        push(r1);
    #####: 1056:        break;
        -: 1057:
    #####: 1058:      case OP_INT_GT:
    #####: 1059:        pop(r2);
    #####: 1060:        pop(r1);
    #####: 1061:        ensure_defined(r2);
    #####: 1062:        ensure_defined(r1);
    #####: 1063:        r1.i = r1.i > r2.i;
    #####: 1064:        push(r1);
    #####: 1065:        break;
        -: 1066:
    #####: 1067:      case OP_INT_LE:
    #####: 1068:        pop(r2);
    #####: 1069:        pop(r1);
    #####: 1070:        ensure_defined(r2);
    #####: 1071:        ensure_defined(r1);
    #####: 1072:        r1.i = r1.i <= r2.i;
    #####: 1073:        push(r1);
    #####: 1074:        break;
        -: 1075:
    #####: 1076:      case OP_INT_GE:
    #####: 1077:        pop(r2);
    #####: 1078:        pop(r1);
    #####: 1079:        ensure_defined(r2);
    #####: 1080:        ensure_defined(r1);
    #####: 1081:        r1.i = r1.i >= r2.i;
    #####: 1082:        push(r1);
    #####: 1083:        break;
        -: 1084:
    #####: 1085:      case OP_INT_ADD:
    #####: 1086:        pop(r2);
    #####: 1087:        pop(r1);
    #####: 1088:        ensure_defined(r2);
    #####: 1089:        ensure_defined(r1);
    #####: 1090:        r1.i = r1.i + r2.i;
    #####: 1091:        push(r1);
    #####: 1092:        break;
        -: 1093:
    #####: 1094:      case OP_INT_SUB:
    #####: 1095:        pop(r2);
    #####: 1096:        pop(r1);
    #####: 1097:        ensure_defined(r2);
    #####: 1098:        ensure_defined(r1);
    #####: 1099:        r1.i = r1.i - r2.i;
    #####: 1100:        push(r1);
    #####: 1101:        break;
        -: 1102:
    #####: 1103:      case OP_INT_MUL:
    #####: 1104:        pop(r2);
    #####: 1105:        pop(r1);
    #####: 1106:        ensure_defined(r2);
    #####: 1107:        ensure_defined(r1);
    #####: 1108:        r1.i = r1.i * r2.i;
    #####: 1109:        push(r1);
    #####: 1110:        break;
        -: 1111:
    #####: 1112:      case OP_INT_DIV:
    #####: 1113:        pop(r2);
    #####: 1114:        pop(r1);
    #####: 1115:        ensure_defined(r2);
    #####: 1116:        ensure_defined(r1);
    #####: 1117:        if (r2.i != 0)
    #####: 1118:          r1.i = r1.i / r2.i;
        -: 1119:        else
    #####: 1120:          r1.i = UNDEFINED;
    #####: 1121:        push(r1);
    #####: 1122:        break;
        -: 1123:
    #####: 1124:      case OP_INT_MINUS:
    #####: 1125:        pop(r1);
    #####: 1126:        ensure_defined(r1);
    #####: 1127:        r1.i = -r1.i;
    #####: 1128:        push(r1);
    #####: 1129:        break;
        -: 1130:
    #####: 1131:      case OP_DBL_LT:
    #####: 1132:        pop(r2);
    #####: 1133:        pop(r1);
    #####: 1134:        ensure_defined(r2);
    #####: 1135:        ensure_defined(r1);
    #####: 1136:        r1.i = r1.d < r2.d;
    #####: 1137:        push(r1);
    #####: 1138:        break;
        -: 1139:
    #####: 1140:      case OP_DBL_GT:
    #####: 1141:        pop(r2);
    #####: 1142:        pop(r1);
    #####: 1143:        ensure_defined(r2);
    #####: 1144:        ensure_defined(r1);
    #####: 1145:        r1.i = r1.d > r2.d;
    #####: 1146:        push(r1);
    #####: 1147:        break;
        -: 1148:
    #####: 1149:      case OP_DBL_LE:
    #####: 1150:        pop(r2);
    #####: 1151:        pop(r1);
    #####: 1152:        ensure_defined(r2);
    #####: 1153:        ensure_defined(r1);
    #####: 1154:        r1.i = r1.d <= r2.d;
    #####: 1155:        push(r1);
    #####: 1156:        break;
        -: 1157:
    #####: 1158:      case OP_DBL_GE:
    #####: 1159:        pop(r2);
    #####: 1160:        pop(r1);
    #####: 1161:        ensure_defined(r2);
    #####: 1162:        ensure_defined(r1);
    #####: 1163:        r1.i = r1.d >= r2.d;
    #####: 1164:        push(r1);
    #####: 1165:        break;
        -: 1166:
    #####: 1167:      case OP_DBL_EQ:
    #####: 1168:        pop(r2);
    #####: 1169:        pop(r1);
    #####: 1170:        ensure_defined(r2);
    #####: 1171:        ensure_defined(r1);
    #####: 1172:        r1.i = fabs(r1.d - r2.d) < DBL_EPSILON;
    #####: 1173:        push(r1);
    #####: 1174:        break;
        -: 1175:
    #####: 1176:      case OP_DBL_NEQ:
    #####: 1177:        pop(r2);
    #####: 1178:        pop(r1);
    #####: 1179:        ensure_defined(r2);
    #####: 1180:        ensure_defined(r1);
    #####: 1181:        r1.i = fabs(r1.d - r2.d) >= DBL_EPSILON;
    #####: 1182:        push(r1);
    #####: 1183:        break;
        -: 1184:
    #####: 1185:      case OP_DBL_ADD:
    #####: 1186:        pop(r2);
    #####: 1187:        pop(r1);
    #####: 1188:        ensure_defined(r2);
    #####: 1189:        ensure_defined(r1);
    #####: 1190:        r1.d = r1.d + r2.d;
    #####: 1191:        push(r1);
    #####: 1192:        break;
        -: 1193:
    #####: 1194:      case OP_DBL_SUB:
    #####: 1195:        pop(r2);
    #####: 1196:        pop(r1);
    #####: 1197:        ensure_defined(r2);
    #####: 1198:        ensure_defined(r1);
    #####: 1199:        r1.d = r1.d - r2.d;
    #####: 1200:        push(r1);
    #####: 1201:        break;
        -: 1202:
    #####: 1203:      case OP_DBL_MUL:
    #####: 1204:        pop(r2);
    #####: 1205:        pop(r1);
    #####: 1206:        ensure_defined(r2);
    #####: 1207:        ensure_defined(r1);
    #####: 1208:        r1.d = r1.d * r2.d;
    #####: 1209:        push(r1);
    #####: 1210:        break;
        -: 1211:
    #####: 1212:      case OP_DBL_DIV:
    #####: 1213:        pop(r2);
    #####: 1214:        pop(r1);
    #####: 1215:        ensure_defined(r2);
    #####: 1216:        ensure_defined(r1);
    #####: 1217:        r1.d = r1.d / r2.d;
    #####: 1218:        push(r1);
    #####: 1219:        break;
        -: 1220:
    #####: 1221:      case OP_DBL_MINUS:
    #####: 1222:        pop(r1);
    #####: 1223:        ensure_defined(r1);
    #####: 1224:        r1.d = -r1.d;
    #####: 1225:        push(r1);
    #####: 1226:        break;
        -: 1227:
    #####: 1228:      case OP_STR_EQ:
        -: 1229:      case OP_STR_NEQ:
        -: 1230:      case OP_STR_LT:
        -: 1231:      case OP_STR_LE:
        -: 1232:      case OP_STR_GT:
        -: 1233:      case OP_STR_GE:
        -: 1234:
    #####: 1235:        pop(r2);
    #####: 1236:        pop(r1);
        -: 1237:
    #####: 1238:        ensure_defined(r1);
    #####: 1239:        ensure_defined(r2);
        -: 1240:
    #####: 1241:        switch(opcode)
        -: 1242:        {
    #####: 1243:          case OP_STR_EQ:
    #####: 1244:            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
    #####: 1245:            break;
    #####: 1246:          case OP_STR_NEQ:
    #####: 1247:            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
    #####: 1248:            break;
    #####: 1249:          case OP_STR_LT:
    #####: 1250:            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
    #####: 1251:            break;
    #####: 1252:          case OP_STR_LE:
    #####: 1253:            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
    #####: 1254:            break;
    #####: 1255:          case OP_STR_GT:
    #####: 1256:            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
    #####: 1257:            break;
    #####: 1258:          case OP_STR_GE:
    #####: 1259:            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
    #####: 1260:            break;
        -: 1261:        }
        -: 1262:
    #####: 1263:        push(r1);
    #####: 1264:        break;
        -: 1265:
    #####: 1266:      default:
        -: 1267:        // Unknown instruction, this shouldn't happen.
    #####: 1268:        assert(false);
        -: 1269:    }
        -: 1270:
        -: 1271:    // Check for timeout every 10 instruction cycles. If timeout == 0 it means
        -: 1272:    // no timeout at all.
        -: 1273:
    1608*: 1274:    if (context->timeout > 0L && ++cycle == 10)
        -: 1275:    {
    #####: 1276:      elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -: 1277:
    #####: 1278:      if (elapsed_time > context->timeout)
        -: 1279:      {
        -: 1280:        #ifdef PROFILING_ENABLED
        -: 1281:        assert(current_rule != NULL);
        -: 1282:        current_rule->time_cost_per_thread[tidx] += elapsed_time - start_time;
        -: 1283:        #endif
    #####: 1284:        result = ERROR_SCAN_TIMEOUT;
    #####: 1285:        stop = true;
        -: 1286:      }
        -: 1287:
    #####: 1288:      cycle = 0;
        -: 1289:    }
        -: 1290:  }
        -: 1291:
      266: 1292:  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);
        -: 1293:
      266: 1294:  while (obj_ptr != NULL)
        -: 1295:  {
    #####: 1296:    yr_object_destroy(*obj_ptr);
        -: 1297:
    #####: 1298:    obj_ptr = (YR_OBJECT**) yr_arena_next_address(
        -: 1299:        obj_arena, obj_ptr, sizeof(YR_OBJECT*));
        -: 1300:  }
        -: 1301:
      266: 1302:  yr_arena_destroy(obj_arena);
      266: 1303:  yr_modules_unload_all(context);
      266: 1304:  yr_free(stack);
        -: 1305:
      266: 1306:  return result;
        -: 1307:}
