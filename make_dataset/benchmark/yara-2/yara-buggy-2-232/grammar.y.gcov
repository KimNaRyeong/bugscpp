        -:    0:Source:grammar.y
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:%{
        -:   31:
        -:   32:
        -:   33:#include <assert.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <limits.h>
        -:   37:#include <stdlib.h>
        -:   38:#include <stddef.h>
        -:   39:
        -:   40:#include <yara/integers.h>
        -:   41:#include <yara/utils.h>
        -:   42:#include <yara/strutils.h>
        -:   43:#include <yara/compiler.h>
        -:   44:#include <yara/object.h>
        -:   45:#include <yara/sizedstr.h>
        -:   46:#include <yara/exec.h>
        -:   47:#include <yara/error.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/lexer.h>
        -:   50:#include <yara/parser.h>
        -:   51:
        -:   52:#if defined(_MSC_VER)
        -:   53:#define llabs _abs64
        -:   54:#endif
        -:   55:
        -:   56:#define YYERROR_VERBOSE
        -:   57:
        -:   58:#define YYMALLOC yr_malloc
        -:   59:#define YYFREE yr_free
        -:   60:
        -:   61:#define INTEGER_SET_ENUMERATION   1
        -:   62:#define INTEGER_SET_RANGE         2
        -:   63:
        -:   64:#define fail_if_error(e) \
        -:   65:    if (e != ERROR_SUCCESS) \
        -:   66:    { \
        -:   67:      compiler->last_error = e; \
        -:   68:      yyerror(yyscanner, compiler, NULL); \
        -:   69:      YYERROR; \
        -:   70:    } \
        -:   71:
        -:   72:
        -:   73:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:   74:    if (((expression.type) & (expected_type)) == 0) \
        -:   75:    { \
        -:   76:      switch(expression.type) \
        -:   77:      { \
        -:   78:        case EXPRESSION_TYPE_INTEGER: \
        -:   79:          yr_compiler_set_error_extra_info( \
        -:   80:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:   81:          break; \
        -:   82:        case EXPRESSION_TYPE_FLOAT: \
        -:   83:          yr_compiler_set_error_extra_info( \
        -:   84:              compiler, "wrong type \"float\" for " op " operator"); \
        -:   85:          break; \
        -:   86:        case EXPRESSION_TYPE_STRING: \
        -:   87:          yr_compiler_set_error_extra_info( \
        -:   88:              compiler, "wrong type \"string\" for " op " operator"); \
        -:   89:          break; \
        -:   90:        case EXPRESSION_TYPE_BOOLEAN: \
        -:   91:          yr_compiler_set_error_extra_info( \
        -:   92:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:   93:          break; \
        -:   94:      } \
        -:   95:      cleanup; \
        -:   96:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:   97:      yyerror(yyscanner, compiler, NULL); \
        -:   98:      YYERROR; \
        -:   99:    }
        -:  100:
        -:  101:
        -:  102:#define check_type(expression, expected_type, op) \
        -:  103:    check_type_with_cleanup(expression, expected_type, op, )
        -:  104:
        -:  105:%}
        -:  106:
        -:  107:
        -:  108:%expect 1   // expect 1 shift/reduce conflicts
        -:  109:
        -:  110:// Uncomment this line to print parsing information that can be useful to
        -:  111:// debug YARA's grammar.
        -:  112:
        -:  113:// %debug
        -:  114:
        -:  115:%name-prefix "yara_yy"
        -:  116:%pure-parser
        -:  117:%parse-param {void *yyscanner}
        -:  118:%parse-param {YR_COMPILER* compiler}
        -:  119:%lex-param {yyscan_t yyscanner}
        -:  120:%lex-param {YR_COMPILER* compiler}
        -:  121:
        -:  122:// Token that marks the end of the original file.
        -:  123:%token _END_OF_FILE_  0                                "end of file"
        -:  124:
        -:  125:// Token that marks the end of included files, we can't use  _END_OF_FILE_
        -:  126:// because bison stops parsing when it sees _END_OF_FILE_, we want to be
        -:  127:// be able to identify the point where an included file ends, but continuing
        -:  128:// parsing any content that follows.
        -:  129:%token _END_OF_INCLUDED_FILE_                          "end of included file"
        -:  130:
        -:  131:%token _DOT_DOT_                                       ".."
        -:  132:%token _RULE_                                          "<rule>"
        -:  133:%token _PRIVATE_                                       "<private>"
        -:  134:%token _GLOBAL_                                        "<global>"
        -:  135:%token _META_                                          "<meta>"
        -:  136:%token <string> _STRINGS_                              "<strings>"
        -:  137:%token _CONDITION_                                     "<condition>"
        -:  138:%token <c_string> _IDENTIFIER_                         "identifier"
        -:  139:%token <c_string> _STRING_IDENTIFIER_                  "string identifier"
        -:  140:%token <c_string> _STRING_COUNT_                       "string count"
        -:  141:%token <c_string> _STRING_OFFSET_                      "string offset"
        -:  142:%token <c_string> _STRING_LENGTH_                      "string length"
        -:  143:%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_
        -:  144:    "string identifier with wildcard"
        -:  145:%token <integer> _NUMBER_                              "integer number"
        -:  146:%token <double_> _DOUBLE_                              "floating point number"
        -:  147:%token <integer> _INTEGER_FUNCTION_                    "integer function"
        -:  148:%token <sized_string> _TEXT_STRING_                    "text string"
        -:  149:%token <sized_string> _HEX_STRING_                     "hex string"
        -:  150:%token <sized_string> _REGEXP_                         "regular expression"
        -:  151:%token _ASCII_                                         "<ascii>"
        -:  152:%token _WIDE_                                          "<wide>"
        -:  153:%token _XOR_                                           "<xor>"
        -:  154:%token _NOCASE_                                        "<nocase>"
        -:  155:%token _FULLWORD_                                      "<fullword>"
        -:  156:%token _AT_                                            "<at>"
        -:  157:%token _FILESIZE_                                      "<filesize>"
        -:  158:%token _ENTRYPOINT_                                    "<entrypoint>"
        -:  159:%token _ALL_                                           "<all>"
        -:  160:%token _ANY_                                           "<any>"
        -:  161:%token _IN_                                            "<in>"
        -:  162:%token _OF_                                            "<of>"
        -:  163:%token _FOR_                                           "<for>"
        -:  164:%token _THEM_                                          "<them>"
        -:  165:%token _MATCHES_                                       "<matches>"
        -:  166:%token _CONTAINS_                                      "<contains>"
        -:  167:%token _IMPORT_                                        "<import>"
        -:  168:%token _TRUE_                                          "<true>"
        -:  169:%token _FALSE_                                         "<false"
        -:  170:%token _OR_                                            "<or>"
        -:  171:%token _AND_                                           "<and>"
        -:  172:%token _NOT_                                           "<not>"
        -:  173:%token _EQ_                                            "=="
        -:  174:%token _NEQ_                                           "!="
        -:  175:%token _LT_                                            "<"
        -:  176:%token _LE_                                            "<="
        -:  177:%token _GT_                                            ">"
        -:  178:%token _GE_                                            ">="
        -:  179:%token _SHIFT_LEFT_                                    "<<"
        -:  180:%token _SHIFT_RIGHT_                                   ">>"
        -:  181:
        -:  182:%left _OR_
        -:  183:%left _AND_
        -:  184:%left '|'
        -:  185:%left '^'
        -:  186:%left '&'
        -:  187:%left _EQ_ _NEQ_
        -:  188:%left _LT_ _LE_ _GT_ _GE_
        -:  189:%left _SHIFT_LEFT_ _SHIFT_RIGHT_
        -:  190:%left '+' '-'
        -:  191:%left '*' '\\' '%'
        -:  192:%right _NOT_ '~' UNARY_MINUS
        -:  193:
        -:  194:%type <rule>   rule
        -:  195:
        -:  196:%type <string> strings
        -:  197:%type <string> string_declaration
        -:  198:%type <string> string_declarations
        -:  199:
        -:  200:%type <meta> meta
        -:  201:%type <meta> meta_declaration
        -:  202:%type <meta> meta_declarations
        -:  203:
        -:  204:%type <c_string> tags
        -:  205:%type <c_string> tag_list
        -:  206:
        -:  207:%type <integer> string_modifier
        -:  208:%type <integer> string_modifiers
        -:  209:
        -:  210:%type <integer> integer_set
        -:  211:
        -:  212:%type <integer> rule_modifier
        -:  213:%type <integer> rule_modifiers
        -:  214:
        -:  215:%type <expression> primary_expression
        -:  216:%type <expression> boolean_expression
        -:  217:%type <expression> expression
        -:  218:%type <expression> identifier
        -:  219:%type <expression> regexp
        -:  220:
        -:  221:%type <c_string> arguments
        -:  222:%type <c_string> arguments_list
        -:  223:
       16:  224:%destructor { yr_free($$); $$ = NULL; } _IDENTIFIER_
    #####:  225:%destructor { yr_free($$); $$ = NULL; } _STRING_COUNT_
    #####:  226:%destructor { yr_free($$); $$ = NULL; } _STRING_OFFSET_
    #####:  227:%destructor { yr_free($$); $$ = NULL; } _STRING_LENGTH_
       15:  228:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_
    #####:  229:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_WITH_WILDCARD_
    #####:  230:%destructor { yr_free($$); $$ = NULL; } _TEXT_STRING_
    #####:  231:%destructor { yr_free($$); $$ = NULL; } _HEX_STRING_
    #####:  232:%destructor { yr_free($$); $$ = NULL; } _REGEXP_
        -:  233:
    #####:  234:%destructor { yr_free($$); $$ = NULL; } arguments
    #####:  235:%destructor { yr_free($$); $$ = NULL; } arguments_list
        -:  236:
        -:  237:%union {
        -:  238:  EXPRESSION      expression;
        -:  239:  SIZED_STRING*   sized_string;
        -:  240:  char*           c_string;
        -:  241:  int64_t         integer;
        -:  242:  double          double_;
        -:  243:  YR_STRING*      string;
        -:  244:  YR_META*        meta;
        -:  245:  YR_RULE*        rule;
        -:  246:}
        -:  247:
        -:  248:
        -:  249:%%
        -:  250:
        -:  251:rules
        -:  252:    : /* empty */
        -:  253:    | rules rule
        -:  254:    | rules import
        -:  255:    | rules error rule      /* on error skip until next rule..*/
        -:  256:    | rules error import    /* .. or import statement */
        -:  257:    | rules error "include" /* .. or include statement */
        -:  258:    | rules _END_OF_INCLUDED_FILE_
        -:  259:      {
    #####:  260:        _yr_compiler_pop_file_name(compiler);
        -:  261:      }
        -:  262:    ;
        -:  263:
        -:  264:
        -:  265:import
        -:  266:    : _IMPORT_ _TEXT_STRING_
        -:  267:      {
    #####:  268:        int result = yr_parser_reduce_import(yyscanner, $2);
        -:  269:
    #####:  270:        yr_free($2);
        -:  271:
    #####:  272:        fail_if_error(result);
        -:  273:      }
        -:  274:    ;
        -:  275:
        -:  276:
        -:  277:rule
        -:  278:    : rule_modifiers _RULE_ _IDENTIFIER_
        -:  279:      {
     282*:  280:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -:  281:            yyscanner, (int32_t) $1, $3, &$<rule>$));
        -:  282:      }
        -:  283:      tags '{' meta strings
        -:  284:      {
      267:  285:        YR_RULE* rule = $<rule>4; // rule created in phase 1
        -:  286:
      267:  287:        rule->tags = $5;
      267:  288:        rule->metas = $7;
      267:  289:        rule->strings = $8;
        -:  290:      }
        -:  291:      condition '}'
        -:  292:      {
      266:  293:        int result = yr_parser_reduce_rule_declaration_phase_2(
      266:  294:            yyscanner, $<rule>4); // rule created in phase 1
        -:  295:
      266:  296:        yr_free($3);
        -:  297:
     266*:  298:        fail_if_error(result);
        -:  299:      }
        -:  300:    ;
        -:  301:
        -:  302:
        -:  303:meta
        -:  304:    : /* empty */
        -:  305:      {
      282:  306:        $$ = NULL;
        -:  307:      }
        -:  308:    | _META_ ':' meta_declarations
        -:  309:      {
        -:  310:        int result;
        -:  311:
        -:  312:        // Each rule have a list of meta-data info, consisting in a
        -:  313:        // sequence of YR_META structures. The last YR_META structure does
        -:  314:        // not represent a real meta-data, it's just a end-of-list marker
        -:  315:        // identified by a specific type (META_TYPE_NULL). Here we
        -:  316:        // write the end-of-list marker.
        -:  317:
        -:  318:        YR_META null_meta;
        -:  319:
    #####:  320:        memset(&null_meta, 0xFF, sizeof(YR_META));
    #####:  321:        null_meta.type = META_TYPE_NULL;
        -:  322:
    #####:  323:        result = yr_arena_write_data(
        -:  324:            compiler->metas_arena,
        -:  325:            &null_meta,
        -:  326:            sizeof(YR_META),
        -:  327:            NULL);
        -:  328:
    #####:  329:        $$ = $3;
        -:  330:
    #####:  331:        fail_if_error(result);
        -:  332:      }
        -:  333:    ;
        -:  334:
        -:  335:
        -:  336:strings
        -:  337:    : /* empty */
        -:  338:      {
    #####:  339:        $$ = NULL;
        -:  340:      }
        -:  341:    | _STRINGS_ ':' string_declarations
        -:  342:      {
        -:  343:        // Each rule have a list of strings, consisting in a sequence
        -:  344:        // of YR_STRING structures. The last YR_STRING structure does not
        -:  345:        // represent a real string, it's just a end-of-list marker
        -:  346:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -:  347:        // write the end-of-list marker.
        -:  348:
        -:  349:        YR_STRING null_string;
        -:  350:
      267:  351:        memset(&null_string, 0xFF, sizeof(YR_STRING));
      267:  352:        null_string.g_flags = STRING_GFLAGS_NULL;
        -:  353:
     267*:  354:        fail_if_error(yr_arena_write_data(
        -:  355:            compiler->strings_arena,
        -:  356:            &null_string,
        -:  357:            sizeof(YR_STRING),
        -:  358:            NULL));
        -:  359:
      267:  360:        $$ = $3;
        -:  361:      }
        -:  362:    ;
        -:  363:
        -:  364:
        -:  365:condition
        -:  366:    : _CONDITION_ ':' boolean_expression
        -:  367:    ;
        -:  368:
        -:  369:
        -:  370:rule_modifiers
      350:  371:    : /* empty */                      { $$ = 0;  }
    #####:  372:    | rule_modifiers rule_modifier     { $$ = $1 | $2; }
        -:  373:    ;
        -:  374:
        -:  375:
        -:  376:rule_modifier
    #####:  377:    : _PRIVATE_      { $$ = RULE_GFLAGS_PRIVATE; }
    #####:  378:    | _GLOBAL_       { $$ = RULE_GFLAGS_GLOBAL; }
        -:  379:    ;
        -:  380:
        -:  381:
        -:  382:tags
        -:  383:    : /* empty */
        -:  384:      {
      282:  385:        $$ = NULL;
        -:  386:      }
        -:  387:    | ':' tag_list
        -:  388:      {
        -:  389:        // Tags list is represented in the arena as a sequence
        -:  390:        // of null-terminated strings, the sequence ends with an
        -:  391:        // additional null character. Here we write the ending null
        -:  392:        //character. Example: tag1\0tag2\0tag3\0\0
        -:  393:
    #####:  394:        int result = yr_arena_write_string(
    #####:  395:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -:  396:
    #####:  397:        fail_if_error(result);
        -:  398:
    #####:  399:        $$ = $2;
        -:  400:      }
        -:  401:    ;
        -:  402:
        -:  403:
        -:  404:tag_list
        -:  405:    : _IDENTIFIER_
        -:  406:      {
    #####:  407:        int result = yr_arena_write_string(
    #####:  408:            yyget_extra(yyscanner)->sz_arena, $1, &$$);
        -:  409:
    #####:  410:        yr_free($1);
        -:  411:
    #####:  412:        fail_if_error(result);
        -:  413:      }
        -:  414:    | tag_list _IDENTIFIER_
        -:  415:      {
    #####:  416:        int result = ERROR_SUCCESS;
        -:  417:
    #####:  418:        char* tag_name = $1;
    #####:  419:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  420:
    #####:  421:        while (tag_length > 0)
        -:  422:        {
    #####:  423:          if (strcmp(tag_name, $2) == 0)
        -:  424:          {
    #####:  425:            yr_compiler_set_error_extra_info(compiler, tag_name);
    #####:  426:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
    #####:  427:            break;
        -:  428:          }
        -:  429:
    #####:  430:          tag_name = (char*) yr_arena_next_address(
    #####:  431:              yyget_extra(yyscanner)->sz_arena,
        -:  432:              tag_name,
        -:  433:              tag_length + 1);
        -:  434:
    #####:  435:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  436:        }
        -:  437:
    #####:  438:        if (result == ERROR_SUCCESS)
    #####:  439:          result = yr_arena_write_string(
    #####:  440:              yyget_extra(yyscanner)->sz_arena, $2, NULL);
        -:  441:
    #####:  442:        yr_free($2);
        -:  443:
    #####:  444:        fail_if_error(result);
        -:  445:
    #####:  446:        $$ = $1;
        -:  447:      }
        -:  448:    ;
        -:  449:
        -:  450:
        -:  451:
        -:  452:meta_declarations
    #####:  453:    : meta_declaration                    {  $$ = $1; }
    #####:  454:    | meta_declarations meta_declaration  {  $$ = $1; }
        -:  455:    ;
        -:  456:
        -:  457:
        -:  458:meta_declaration
        -:  459:    : _IDENTIFIER_ '=' _TEXT_STRING_
        -:  460:      {
    #####:  461:        SIZED_STRING* sized_string = $3;
        -:  462:
    #####:  463:        int result = yr_parser_reduce_meta_declaration(
        -:  464:            yyscanner,
        -:  465:            META_TYPE_STRING,
    #####:  466:            $1,
    #####:  467:            sized_string->c_string,
        -:  468:            0,
        -:  469:            &$$);
        -:  470:
    #####:  471:        yr_free($1);
    #####:  472:        yr_free($3);
        -:  473:
    #####:  474:        fail_if_error(result);
        -:  475:      }
        -:  476:    | _IDENTIFIER_ '=' _NUMBER_
        -:  477:      {
    #####:  478:        int result = yr_parser_reduce_meta_declaration(
        -:  479:            yyscanner,
        -:  480:            META_TYPE_INTEGER,
    #####:  481:            $1,
        -:  482:            NULL,
        -:  483:            $3,
        -:  484:            &$$);
        -:  485:
    #####:  486:        yr_free($1);
        -:  487:
    #####:  488:        fail_if_error(result);
        -:  489:      }
        -:  490:    | _IDENTIFIER_ '=' '-' _NUMBER_
        -:  491:      {
    #####:  492:        int result = yr_parser_reduce_meta_declaration(
        -:  493:            yyscanner,
        -:  494:            META_TYPE_INTEGER,
    #####:  495:            $1,
        -:  496:            NULL,
    #####:  497:            -$4,
        -:  498:            &$$);
        -:  499:
    #####:  500:        yr_free($1);
        -:  501:
    #####:  502:        fail_if_error(result);
        -:  503:      }
        -:  504:    | _IDENTIFIER_ '=' _TRUE_
        -:  505:      {
    #####:  506:        int result = yr_parser_reduce_meta_declaration(
        -:  507:            yyscanner,
        -:  508:            META_TYPE_BOOLEAN,
    #####:  509:            $1,
        -:  510:            NULL,
        -:  511:            true,
        -:  512:            &$$);
        -:  513:
    #####:  514:        yr_free($1);
        -:  515:
    #####:  516:        fail_if_error(result);
        -:  517:      }
        -:  518:    | _IDENTIFIER_ '=' _FALSE_
        -:  519:      {
    #####:  520:        int result = yr_parser_reduce_meta_declaration(
        -:  521:            yyscanner,
        -:  522:            META_TYPE_BOOLEAN,
    #####:  523:            $1,
        -:  524:            NULL,
        -:  525:            false,
        -:  526:            &$$);
        -:  527:
    #####:  528:        yr_free($1);
        -:  529:
    #####:  530:        fail_if_error(result);
        -:  531:      }
        -:  532:    ;
        -:  533:
        -:  534:
        -:  535:string_declarations
      267:  536:    : string_declaration                      { $$ = $1; }
    #####:  537:    | string_declarations string_declaration  { $$ = $1; }
        -:  538:    ;
        -:  539:
        -:  540:
        -:  541:string_declaration
        -:  542:    : _STRING_IDENTIFIER_ '='
        -:  543:      {
        3:  544:        compiler->current_line = yyget_lineno(yyscanner);
        -:  545:      }
        -:  546:      _TEXT_STRING_ string_modifiers
        -:  547:      {
        1:  548:        int result = yr_parser_reduce_string_declaration(
        1:  549:            yyscanner, (int32_t) $5, $1, $4, &$$);
        -:  550:
        1:  551:        yr_free($1);
        1:  552:        yr_free($4);
        -:  553:
       1*:  554:        fail_if_error(result);
        1:  555:        compiler->current_line = 0;
        -:  556:      }
        -:  557:    | _STRING_IDENTIFIER_ '='
        -:  558:      {
      279:  559:        compiler->current_line = yyget_lineno(yyscanner);
        -:  560:      }
        -:  561:      _REGEXP_ string_modifiers
        -:  562:      {
      279:  563:        int result = yr_parser_reduce_string_declaration(
      279:  564:            yyscanner, (int32_t) $5 | STRING_GFLAGS_REGEXP, $1, $4, &$$);
        -:  565:
      279:  566:        yr_free($1);
      279:  567:        yr_free($4);
        -:  568:
      279:  569:        fail_if_error(result);
        -:  570:
      266:  571:        compiler->current_line = 0;
        -:  572:      }
        -:  573:    | _STRING_IDENTIFIER_ '=' _HEX_STRING_
        -:  574:      {
    #####:  575:        int result = yr_parser_reduce_string_declaration(
    #####:  576:            yyscanner, STRING_GFLAGS_HEXADECIMAL, $1, $3, &$$);
        -:  577:
    #####:  578:        yr_free($1);
    #####:  579:        yr_free($3);
        -:  580:
    #####:  581:        fail_if_error(result);
        -:  582:      }
        -:  583:    ;
        -:  584:
        -:  585:
        -:  586:string_modifiers
      280:  587:    : /* empty */                         { $$ = 0; }
       25:  588:    | string_modifiers string_modifier    { $$ = $1 | $2; }
        -:  589:    ;
        -:  590:
        -:  591:
        -:  592:string_modifier
       14:  593:    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }
    #####:  594:    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }
        9:  595:    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }
        2:  596:    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }
    #####:  597:    | _XOR_         { $$ = STRING_GFLAGS_XOR; }
        -:  598:    ;
        -:  599:
        -:  600:
        -:  601:identifier
        -:  602:    : _IDENTIFIER_
        -:  603:      {
    #####:  604:        int result = ERROR_SUCCESS;
    #####:  605:        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1);
        -:  606:
    #####:  607:        if (var_index >= 0)
        -:  608:        {
    #####:  609:          result = yr_parser_emit_with_arg(
        -:  610:              yyscanner,
        -:  611:              OP_PUSH_M,
    #####:  612:              LOOP_LOCAL_VARS * var_index,
        -:  613:              NULL,
        -:  614:              NULL);
        -:  615:
    #####:  616:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####:  617:          $$.value.integer = UNDEFINED;
    #####:  618:          $$.identifier = compiler->loop_identifier[var_index];
        -:  619:        }
        -:  620:        else
        -:  621:        {
        -:  622:          // Search for identifier within the global namespace, where the
        -:  623:          // externals variables reside.
        -:  624:
    #####:  625:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  626:              compiler->objects_table, $1, NULL);
        -:  627:
    #####:  628:          if (object == NULL)
        -:  629:          {
        -:  630:            // If not found, search within the current namespace.
    #####:  631:            char* ns = compiler->current_namespace->name;
        -:  632:
    #####:  633:            object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  634:                compiler->objects_table, $1, ns);
        -:  635:          }
        -:  636:
    #####:  637:          if (object != NULL)
        -:  638:          {
        -:  639:            char* id;
        -:  640:
    #####:  641:            result = yr_arena_write_string(
    #####:  642:                compiler->sz_arena, $1, &id);
        -:  643:
    #####:  644:            if (result == ERROR_SUCCESS)
    #####:  645:              result = yr_parser_emit_with_arg_reloc(
        -:  646:                  yyscanner,
        -:  647:                  OP_OBJ_LOAD,
        -:  648:                  id,
        -:  649:                  NULL,
        -:  650:                  NULL);
        -:  651:
    #####:  652:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  653:            $$.value.object = object;
    #####:  654:            $$.identifier = object->identifier;
        -:  655:          }
        -:  656:          else
        -:  657:          {
    #####:  658:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -:  659:                compiler->rules_table,
    #####:  660:                $1,
    #####:  661:                compiler->current_namespace->name);
        -:  662:
    #####:  663:            if (rule != NULL)
        -:  664:            {
    #####:  665:              result = yr_parser_emit_with_arg_reloc(
        -:  666:                  yyscanner,
        -:  667:                  OP_PUSH_RULE,
        -:  668:                  rule,
        -:  669:                  NULL,
        -:  670:                  NULL);
        -:  671:
    #####:  672:              $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####:  673:              $$.value.integer = UNDEFINED;
    #####:  674:              $$.identifier = rule->identifier;
        -:  675:            }
        -:  676:            else
        -:  677:            {
    #####:  678:              yr_compiler_set_error_extra_info(compiler, $1);
    #####:  679:              result = ERROR_UNDEFINED_IDENTIFIER;
        -:  680:            }
        -:  681:          }
        -:  682:        }
        -:  683:
    #####:  684:        yr_free($1);
        -:  685:
    #####:  686:        fail_if_error(result);
        -:  687:      }
        -:  688:    | identifier '.' _IDENTIFIER_
        -:  689:      {
    #####:  690:        int result = ERROR_SUCCESS;
    #####:  691:        YR_OBJECT* field = NULL;
        -:  692:
    #####:  693:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  694:            $1.value.object->type == OBJECT_TYPE_STRUCTURE)
        -:  695:        {
    #####:  696:          field = yr_object_lookup_field($1.value.object, $3);
        -:  697:
    #####:  698:          if (field != NULL)
        -:  699:          {
        -:  700:            char* ident;
        -:  701:
    #####:  702:            result = yr_arena_write_string(
    #####:  703:                compiler->sz_arena, $3, &ident);
        -:  704:
    #####:  705:            if (result == ERROR_SUCCESS)
    #####:  706:              result = yr_parser_emit_with_arg_reloc(
        -:  707:                  yyscanner,
        -:  708:                  OP_OBJ_FIELD,
        -:  709:                  ident,
        -:  710:                  NULL,
        -:  711:                  NULL);
        -:  712:
    #####:  713:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  714:            $$.value.object = field;
    #####:  715:            $$.identifier = field->identifier;
        -:  716:          }
        -:  717:          else
        -:  718:          {
    #####:  719:            yr_compiler_set_error_extra_info(compiler, $3);
    #####:  720:            result = ERROR_INVALID_FIELD_NAME;
        -:  721:          }
        -:  722:        }
        -:  723:        else
        -:  724:        {
    #####:  725:          yr_compiler_set_error_extra_info(
        -:  726:              compiler, $1.identifier);
        -:  727:
    #####:  728:          result = ERROR_NOT_A_STRUCTURE;
        -:  729:        }
        -:  730:
    #####:  731:        yr_free($3);
        -:  732:
    #####:  733:        fail_if_error(result);
        -:  734:      }
        -:  735:    | identifier '[' primary_expression ']'
        -:  736:      {
    #####:  737:        int result = ERROR_SUCCESS;
        -:  738:        YR_OBJECT_ARRAY* array;
        -:  739:        YR_OBJECT_DICTIONARY* dict;
        -:  740:
    #####:  741:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  742:            $1.value.object->type == OBJECT_TYPE_ARRAY)
        -:  743:        {
    #####:  744:          if ($3.type != EXPRESSION_TYPE_INTEGER)
        -:  745:          {
    #####:  746:            yr_compiler_set_error_extra_info(
        -:  747:                compiler, "array indexes must be of integer type");
    #####:  748:            result = ERROR_WRONG_TYPE;
        -:  749:          }
        -:  750:
    #####:  751:          fail_if_error(result);
        -:  752:
    #####:  753:          result = yr_parser_emit(
        -:  754:              yyscanner, OP_INDEX_ARRAY, NULL);
        -:  755:
    #####:  756:          array = object_as_array($1.value.object);
        -:  757:
    #####:  758:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  759:          $$.value.object = array->prototype_item;
    #####:  760:          $$.identifier = array->identifier;
        -:  761:        }
    #####:  762:        else if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  763:                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)
        -:  764:        {
    #####:  765:          if ($3.type != EXPRESSION_TYPE_STRING)
        -:  766:          {
    #####:  767:            yr_compiler_set_error_extra_info(
        -:  768:                compiler, "dictionary keys must be of string type");
    #####:  769:            result = ERROR_WRONG_TYPE;
        -:  770:          }
        -:  771:
    #####:  772:          fail_if_error(result);
        -:  773:
    #####:  774:          result = yr_parser_emit(
        -:  775:              yyscanner, OP_LOOKUP_DICT, NULL);
        -:  776:
    #####:  777:          dict = object_as_dictionary($1.value.object);
        -:  778:
    #####:  779:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  780:          $$.value.object = dict->prototype_item;
    #####:  781:          $$.identifier = dict->identifier;
        -:  782:        }
        -:  783:        else
        -:  784:        {
    #####:  785:          yr_compiler_set_error_extra_info(
        -:  786:              compiler, $1.identifier);
        -:  787:
    #####:  788:          result = ERROR_NOT_INDEXABLE;
        -:  789:        }
        -:  790:
    #####:  791:        fail_if_error(result);
        -:  792:      }
        -:  793:
        -:  794:    | identifier '(' arguments ')'
        -:  795:      {
    #####:  796:        int result = ERROR_SUCCESS;
        -:  797:        YR_OBJECT_FUNCTION* function;
        -:  798:        char* args_fmt;
        -:  799:
    #####:  800:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  801:            $1.value.object->type == OBJECT_TYPE_FUNCTION)
        -:  802:        {
    #####:  803:          result = yr_parser_check_types(
    #####:  804:              compiler, object_as_function($1.value.object), $3);
        -:  805:
    #####:  806:          if (result == ERROR_SUCCESS)
    #####:  807:            result = yr_arena_write_string(
    #####:  808:                compiler->sz_arena, $3, &args_fmt);
        -:  809:
    #####:  810:          if (result == ERROR_SUCCESS)
    #####:  811:            result = yr_parser_emit_with_arg_reloc(
        -:  812:                yyscanner,
        -:  813:                OP_CALL,
        -:  814:                args_fmt,
        -:  815:                NULL,
        -:  816:                NULL);
        -:  817:
    #####:  818:          function = object_as_function($1.value.object);
        -:  819:
    #####:  820:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  821:          $$.value.object = function->return_obj;
    #####:  822:          $$.identifier = function->identifier;
        -:  823:        }
        -:  824:        else
        -:  825:        {
    #####:  826:          yr_compiler_set_error_extra_info(
        -:  827:              compiler, $1.identifier);
        -:  828:
    #####:  829:          result = ERROR_NOT_A_FUNCTION;
        -:  830:        }
        -:  831:
    #####:  832:        yr_free($3);
        -:  833:
    #####:  834:        fail_if_error(result);
        -:  835:      }
        -:  836:    ;
        -:  837:
        -:  838:
        -:  839:arguments
    #####:  840:    : /* empty */     { $$ = yr_strdup(""); }
    #####:  841:    | arguments_list  { $$ = $1; }
        -:  842:
        -:  843:
        -:  844:arguments_list
        -:  845:    : expression
        -:  846:      {
    #####:  847:        $$ = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -:  848:
    #####:  849:        if ($$ == NULL)
    #####:  850:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -:  851:
    #####:  852:        switch($1.type)
        -:  853:        {
    #####:  854:          case EXPRESSION_TYPE_INTEGER:
    #####:  855:            strlcpy($$, "i", YR_MAX_FUNCTION_ARGS);
    #####:  856:            break;
    #####:  857:          case EXPRESSION_TYPE_FLOAT:
    #####:  858:            strlcpy($$, "f", YR_MAX_FUNCTION_ARGS);
    #####:  859:            break;
    #####:  860:          case EXPRESSION_TYPE_BOOLEAN:
    #####:  861:            strlcpy($$, "b", YR_MAX_FUNCTION_ARGS);
    #####:  862:            break;
    #####:  863:          case EXPRESSION_TYPE_STRING:
    #####:  864:            strlcpy($$, "s", YR_MAX_FUNCTION_ARGS);
    #####:  865:            break;
    #####:  866:          case EXPRESSION_TYPE_REGEXP:
    #####:  867:            strlcpy($$, "r", YR_MAX_FUNCTION_ARGS);
    #####:  868:            break;
    #####:  869:          default:
    #####:  870:            assert(false);
        -:  871:        }
        -:  872:      }
        -:  873:    | arguments_list ',' expression
        -:  874:      {
    #####:  875:        int result = ERROR_SUCCESS;
        -:  876:
    #####:  877:        if (strlen($1) == YR_MAX_FUNCTION_ARGS)
        -:  878:        {
    #####:  879:          result = ERROR_TOO_MANY_ARGUMENTS;
        -:  880:        }
        -:  881:        else
        -:  882:        {
    #####:  883:          switch($3.type)
        -:  884:          {
    #####:  885:            case EXPRESSION_TYPE_INTEGER:
    #####:  886:              strlcat($1, "i", YR_MAX_FUNCTION_ARGS);
    #####:  887:              break;
    #####:  888:            case EXPRESSION_TYPE_FLOAT:
    #####:  889:              strlcat($1, "f", YR_MAX_FUNCTION_ARGS);
    #####:  890:              break;
    #####:  891:            case EXPRESSION_TYPE_BOOLEAN:
    #####:  892:              strlcat($1, "b", YR_MAX_FUNCTION_ARGS);
    #####:  893:              break;
    #####:  894:            case EXPRESSION_TYPE_STRING:
    #####:  895:              strlcat($1, "s", YR_MAX_FUNCTION_ARGS);
    #####:  896:              break;
    #####:  897:            case EXPRESSION_TYPE_REGEXP:
    #####:  898:              strlcat($1, "r", YR_MAX_FUNCTION_ARGS);
    #####:  899:              break;
    #####:  900:            default:
    #####:  901:              assert(false);
        -:  902:          }
        -:  903:        }
        -:  904:
    #####:  905:        fail_if_error(result);
        -:  906:
    #####:  907:        $$ = $1;
        -:  908:      }
        -:  909:    ;
        -:  910:
        -:  911:
        -:  912:regexp
        -:  913:    : _REGEXP_
        -:  914:      {
    #####:  915:        SIZED_STRING* sized_string = $1;
        -:  916:        RE* re;
        -:  917:        RE_ERROR error;
        -:  918:
    #####:  919:        int result = ERROR_SUCCESS;
    #####:  920:        int re_flags = 0;
        -:  921:
    #####:  922:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  923:          re_flags |= RE_FLAGS_NO_CASE;
        -:  924:
    #####:  925:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####:  926:          re_flags |= RE_FLAGS_DOT_ALL;
        -:  927:
    #####:  928:        result = yr_re_compile(
    #####:  929:            sized_string->c_string,
        -:  930:            re_flags,
        -:  931:            compiler->re_code_arena,
        -:  932:            &re,
        -:  933:            &error);
        -:  934:
    #####:  935:        yr_free($1);
        -:  936:
    #####:  937:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
    #####:  938:          yr_compiler_set_error_extra_info(compiler, error.message);
        -:  939:
    #####:  940:        if (result == ERROR_SUCCESS)
    #####:  941:          result = yr_parser_emit_with_arg_reloc(
        -:  942:              yyscanner,
        -:  943:              OP_PUSH,
        -:  944:              re,
        -:  945:              NULL,
        -:  946:              NULL);
        -:  947:
    #####:  948:        fail_if_error(result);
        -:  949:
    #####:  950:        $$.type = EXPRESSION_TYPE_REGEXP;
        -:  951:      }
        -:  952:    ;
        -:  953:
        -:  954:
        -:  955:boolean_expression
        -:  956:    : expression
        -:  957:      {
      266:  958:        if ($1.type == EXPRESSION_TYPE_STRING)
        -:  959:        {
    #####:  960:          if ($1.value.sized_string != NULL)
        -:  961:          {
    #####:  962:            yywarning(yyscanner,
        -:  963:              "Using literal string \"%s\" in a boolean operation.",
    #####:  964:              $1.value.sized_string->c_string);
        -:  965:          }
        -:  966:
    #####:  967:          fail_if_error(yr_parser_emit(
        -:  968:              yyscanner, OP_STR_TO_BOOL, NULL));
        -:  969:        }
        -:  970:
      266:  971:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  972:      }
        -:  973:    ;
        -:  974:
        -:  975:expression
        -:  976:    : _TRUE_
        -:  977:      {
    #####:  978:        fail_if_error(yr_parser_emit_with_arg(
        -:  979:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -:  980:
    #####:  981:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  982:      }
        -:  983:    | _FALSE_
        -:  984:      {
    #####:  985:        fail_if_error(yr_parser_emit_with_arg(
        -:  986:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -:  987:
    #####:  988:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  989:      }
        -:  990:    | primary_expression _MATCHES_ regexp
        -:  991:      {
    #####:  992:        check_type($1, EXPRESSION_TYPE_STRING, "matches");
    #####:  993:        check_type($3, EXPRESSION_TYPE_REGEXP, "matches");
        -:  994:
    #####:  995:        fail_if_error(yr_parser_emit(
        -:  996:            yyscanner,
        -:  997:            OP_MATCHES,
        -:  998:            NULL));
        -:  999:
    #####: 1000:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1001:      }
        -: 1002:    | primary_expression _CONTAINS_ primary_expression
        -: 1003:      {
    #####: 1004:        check_type($1, EXPRESSION_TYPE_STRING, "contains");
    #####: 1005:        check_type($3, EXPRESSION_TYPE_STRING, "contains");
        -: 1006:
    #####: 1007:        fail_if_error(yr_parser_emit(
        -: 1008:            yyscanner, OP_CONTAINS, NULL));
        -: 1009:
    #####: 1010:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1011:      }
        -: 1012:    | _STRING_IDENTIFIER_
        -: 1013:      {
      262: 1014:        int result = yr_parser_reduce_string_identifier(
        -: 1015:            yyscanner,
      262: 1016:            $1,
        -: 1017:            OP_FOUND,
        -: 1018:            UNDEFINED);
        -: 1019:
      262: 1020:        yr_free($1);
        -: 1021:
     262*: 1022:        fail_if_error(result);
        -: 1023:
      262: 1024:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1025:      }
        -: 1026:    | _STRING_IDENTIFIER_ _AT_ primary_expression
        -: 1027:      {
        -: 1028:        int result;
        -: 1029:
    #####: 1030:        check_type_with_cleanup($3, EXPRESSION_TYPE_INTEGER, "at", yr_free($1));
        -: 1031:
    #####: 1032:        result = yr_parser_reduce_string_identifier(
    #####: 1033:            yyscanner, $1, OP_FOUND_AT, $3.value.integer);
        -: 1034:
    #####: 1035:        yr_free($1);
        -: 1036:
    #####: 1037:        fail_if_error(result);
        -: 1038:
    #####: 1039:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1040:      }
        -: 1041:    | _STRING_IDENTIFIER_ _IN_ range
        -: 1042:      {
    #####: 1043:        int result = yr_parser_reduce_string_identifier(
    #####: 1044:            yyscanner, $1, OP_FOUND_IN, UNDEFINED);
        -: 1045:
    #####: 1046:        yr_free($1);
        -: 1047:
    #####: 1048:        fail_if_error(result);
        -: 1049:
    #####: 1050:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1051:      }
        -: 1052:    | _FOR_ for_expression error
        -: 1053:      {
    #####: 1054:        if (compiler->loop_depth > 0)
        -: 1055:        {
    #####: 1056:          compiler->loop_depth--;
    #####: 1057:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 1058:        }
        -: 1059:
    #####: 1060:        YYERROR;
        -: 1061:      }
        -: 1062:    | _FOR_ for_expression _IDENTIFIER_ _IN_
        -: 1063:      {
    #####: 1064:        int result = ERROR_SUCCESS;
        -: 1065:        int var_index;
        -: 1066:
    #####: 1067:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1068:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1069:
    #####: 1070:        fail_if_error(result);
        -: 1071:
    #####: 1072:        var_index = yr_parser_lookup_loop_variable(
    #####: 1073:            yyscanner, $3);
        -: 1074:
    #####: 1075:        if (var_index >= 0)
        -: 1076:        {
    #####: 1077:          yr_compiler_set_error_extra_info(
        -: 1078:              compiler, $3);
        -: 1079:
    #####: 1080:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 1081:        }
        -: 1082:
    #####: 1083:        fail_if_error(result);
        -: 1084:
        -: 1085:        // Push end-of-list marker
    #####: 1086:        result = yr_parser_emit_with_arg(
        -: 1087:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1088:
    #####: 1089:        fail_if_error(result);
        -: 1090:      }
        -: 1091:      integer_set ':'
        -: 1092:      {
    #####: 1093:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1094:        uint8_t* addr;
        -: 1095:
        -: 1096:        // Clear counter for number of expressions evaluating
        -: 1097:        // to true.
    #####: 1098:        yr_parser_emit_with_arg(
    #####: 1099:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1100:
        -: 1101:        // Clear iterations counter
    #####: 1102:        yr_parser_emit_with_arg(
    #####: 1103:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1104:
    #####: 1105:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1106:        {
        -: 1107:          // Pop the first integer
    #####: 1108:          yr_parser_emit_with_arg(
        -: 1109:              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 1110:        }
        -: 1111:        else // INTEGER_SET_RANGE
        -: 1112:        {
        -: 1113:          // Pop higher bound of set range
    #####: 1114:          yr_parser_emit_with_arg(
    #####: 1115:              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
        -: 1116:
        -: 1117:          // Pop lower bound of set range
    #####: 1118:          yr_parser_emit_with_arg(
        -: 1119:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 1120:        }
        -: 1121:
    #####: 1122:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1123:        compiler->loop_identifier[compiler->loop_depth] = $3;
    #####: 1124:        compiler->loop_depth++;
        -: 1125:      }
        -: 1126:      '(' boolean_expression ')'
        -: 1127:      {
        -: 1128:        int mem_offset;
        -: 1129:
    #####: 1130:        compiler->loop_depth--;
    #####: 1131:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1132:
        -: 1133:        // The value at the top of the stack is the result of
        -: 1134:        // evaluating the boolean expression, so it could be
        -: 1135:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 1136:        // keeping the number of expressions evaluating to true.
        -: 1137:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 1138:        // does nothing.
        -: 1139:
    #####: 1140:        yr_parser_emit_with_arg(
    #####: 1141:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1142:
        -: 1143:        // Increment iterations counter
    #####: 1144:        yr_parser_emit_with_arg(
    #####: 1145:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 1146:
    #####: 1147:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1148:        {
    #####: 1149:          yr_parser_emit_with_arg_reloc(
        -: 1150:              yyscanner,
        -: 1151:              OP_JNUNDEF,
    #####: 1152:              compiler->loop_address[compiler->loop_depth],
        -: 1153:              NULL,
        -: 1154:              NULL);
        -: 1155:        }
        -: 1156:        else // INTEGER_SET_RANGE
        -: 1157:        {
        -: 1158:          // Increment lower bound of integer set
    #####: 1159:          yr_parser_emit_with_arg(
        -: 1160:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 1161:
        -: 1162:          // Push lower bound of integer set
    #####: 1163:          yr_parser_emit_with_arg(
        -: 1164:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 1165:
        -: 1166:          // Push higher bound of integer set
    #####: 1167:          yr_parser_emit_with_arg(
    #####: 1168:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 1169:
        -: 1170:          // Compare higher bound with lower bound, do loop again
        -: 1171:          // if lower bound is still lower or equal than higher bound
    #####: 1172:          yr_parser_emit_with_arg_reloc(
        -: 1173:              yyscanner,
        -: 1174:              OP_JLE,
    #####: 1175:              compiler->loop_address[compiler->loop_depth],
        -: 1176:              NULL,
        -: 1177:              NULL);
        -: 1178:
    #####: 1179:          yr_parser_emit(yyscanner, OP_POP, NULL);
    #####: 1180:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1181:        }
        -: 1182:
        -: 1183:        // Pop end-of-list marker.
    #####: 1184:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1185:
        -: 1186:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1187:        // is at the top of the stack. Check if the quantifier
        -: 1188:        // is undefined (meaning "all") and replace it with the
        -: 1189:        // iterations counter in that case.
    #####: 1190:        yr_parser_emit_with_arg(
    #####: 1191:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1192:
        -: 1193:        // Compare the loop quantifier with the number of
        -: 1194:        // expressions evaluating to true.
    #####: 1195:        yr_parser_emit_with_arg(
    #####: 1196:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1197:
    #####: 1198:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1199:
    #####: 1200:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1201:        yr_free($3);
        -: 1202:
    #####: 1203:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1204:      }
        -: 1205:    | _FOR_ for_expression _OF_ string_set ':'
        -: 1206:      {
    #####: 1207:        int result = ERROR_SUCCESS;
    #####: 1208:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1209:        uint8_t* addr;
        -: 1210:
    #####: 1211:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1212:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1213:
    #####: 1214:        if (compiler->loop_for_of_mem_offset != -1)
    #####: 1215:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 1216:
    #####: 1217:        fail_if_error(result);
        -: 1218:
    #####: 1219:        yr_parser_emit_with_arg(
    #####: 1220:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1221:
    #####: 1222:        yr_parser_emit_with_arg(
    #####: 1223:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1224:
        -: 1225:        // Pop the first string.
    #####: 1226:        yr_parser_emit_with_arg(
        -: 1227:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 1228:
    #####: 1229:        compiler->loop_for_of_mem_offset = mem_offset;
    #####: 1230:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1231:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1232:        compiler->loop_depth++;
        -: 1233:      }
        -: 1234:      '(' boolean_expression ')'
        -: 1235:      {
        -: 1236:        int mem_offset;
        -: 1237:
    #####: 1238:        compiler->loop_depth--;
    #####: 1239:        compiler->loop_for_of_mem_offset = -1;
        -: 1240:
    #####: 1241:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1242:
        -: 1243:        // Increment counter by the value returned by the
        -: 1244:        // boolean expression (0 or 1). If the boolean expression
        -: 1245:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 1246:
    #####: 1247:        yr_parser_emit_with_arg(
    #####: 1248:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1249:
        -: 1250:        // Increment iterations counter.
    #####: 1251:        yr_parser_emit_with_arg(
    #####: 1252:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 1253:
        -: 1254:        // If next string is not undefined, go back to the
        -: 1255:        // beginning of the loop.
    #####: 1256:        yr_parser_emit_with_arg_reloc(
        -: 1257:            yyscanner,
        -: 1258:            OP_JNUNDEF,
    #####: 1259:            compiler->loop_address[compiler->loop_depth],
        -: 1260:            NULL,
        -: 1261:            NULL);
        -: 1262:
        -: 1263:        // Pop end-of-list marker.
    #####: 1264:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1265:
        -: 1266:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1267:        // is at top of the stack. Check if the quantifier is
        -: 1268:        // undefined (meaning "all") and replace it with the
        -: 1269:        // iterations counter in that case.
    #####: 1270:        yr_parser_emit_with_arg(
    #####: 1271:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1272:
        -: 1273:        // Compare the loop quantifier with the number of
        -: 1274:        // expressions evaluating to true.
    #####: 1275:        yr_parser_emit_with_arg(
    #####: 1276:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1277:
    #####: 1278:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1279:
    #####: 1280:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1281:
        -: 1282:      }
        -: 1283:    | for_expression _OF_ string_set
        -: 1284:      {
    #####: 1285:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 1286:
    #####: 1287:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1288:      }
        -: 1289:    | _NOT_ boolean_expression
        -: 1290:      {
    #####: 1291:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 1292:
    #####: 1293:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1294:      }
        -: 1295:    | boolean_expression _AND_
        -: 1296:      {
        -: 1297:        YR_FIXUP* fixup;
        -: 1298:        void* jmp_destination_addr;
        -: 1299:
    #####: 1300:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1301:            yyscanner,
        -: 1302:            OP_JFALSE,
        -: 1303:            0,          // still don't know the jump destination
        -: 1304:            NULL,
        -: 1305:            &jmp_destination_addr));
        -: 1306:
        -: 1307:        // create a fixup entry for the jump and push it in the stack
    #####: 1308:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1309:
    #####: 1310:        if (fixup == NULL)
    #####: 1311:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1312:
    #####: 1313:        fixup->address = jmp_destination_addr;
    #####: 1314:        fixup->next = compiler->fixup_stack_head;
    #####: 1315:        compiler->fixup_stack_head = fixup;
        -: 1316:      }
        -: 1317:      boolean_expression
        -: 1318:      {
        -: 1319:        YR_FIXUP* fixup;
        -: 1320:        uint8_t* nop_addr;
        -: 1321:
    #####: 1322:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 1323:
        -: 1324:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1325:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1326:        // use the address of the OP_AND instruction +1 because we can't be
        -: 1327:        // sure that the instruction following the OP_AND is going to be in
        -: 1328:        // the same arena page. As we don't have a reliable way of getting the
        -: 1329:        // address of the next instruction we generate the OP_NOP.
        -: 1330:
    #####: 1331:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1332:
    #####: 1333:        fixup = compiler->fixup_stack_head;
    #####: 1334:        *(void**)(fixup->address) = (void*) nop_addr;
    #####: 1335:        compiler->fixup_stack_head = fixup->next;
    #####: 1336:        yr_free(fixup);
        -: 1337:
    #####: 1338:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1339:      }
        -: 1340:    | boolean_expression _OR_
        -: 1341:      {
        -: 1342:        YR_FIXUP* fixup;
        -: 1343:        void* jmp_destination_addr;
        -: 1344:
    #####: 1345:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1346:            yyscanner,
        -: 1347:            OP_JTRUE,
        -: 1348:            0,         // still don't know the jump destination
        -: 1349:            NULL,
        -: 1350:            &jmp_destination_addr));
        -: 1351:
    #####: 1352:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1353:
    #####: 1354:        if (fixup == NULL)
    #####: 1355:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1356:
    #####: 1357:        fixup->address = jmp_destination_addr;
    #####: 1358:        fixup->next = compiler->fixup_stack_head;
    #####: 1359:        compiler->fixup_stack_head = fixup;
        -: 1360:      }
        -: 1361:      boolean_expression
        -: 1362:      {
        -: 1363:        YR_FIXUP* fixup;
        -: 1364:        uint8_t* nop_addr;
        -: 1365:
    #####: 1366:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 1367:
        -: 1368:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1369:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1370:        // use the address of the OP_OR instruction +1 because we can't be
        -: 1371:        // sure that the instruction following the OP_AND is going to be in
        -: 1372:        // the same arena page. As we don't have a reliable way of getting the
        -: 1373:        // address of the next instruction we generate the OP_NOP.
        -: 1374:
    #####: 1375:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1376:
    #####: 1377:        fixup = compiler->fixup_stack_head;
    #####: 1378:        *(void**)(fixup->address) = (void*)(nop_addr);
    #####: 1379:        compiler->fixup_stack_head = fixup->next;
    #####: 1380:        yr_free(fixup);
        -: 1381:
    #####: 1382:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1383:      }
        -: 1384:    | primary_expression _LT_ primary_expression
        -: 1385:      {
    #####: 1386:        fail_if_error(yr_parser_reduce_operation(
        -: 1387:            yyscanner, "<", $1, $3));
        -: 1388:
    #####: 1389:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1390:      }
        -: 1391:    | primary_expression _GT_ primary_expression
        -: 1392:      {
    #####: 1393:        fail_if_error(yr_parser_reduce_operation(
        -: 1394:            yyscanner, ">", $1, $3));
        -: 1395:
    #####: 1396:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1397:      }
        -: 1398:    | primary_expression _LE_ primary_expression
        -: 1399:      {
    #####: 1400:        fail_if_error(yr_parser_reduce_operation(
        -: 1401:            yyscanner, "<=", $1, $3));
        -: 1402:
    #####: 1403:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1404:      }
        -: 1405:    | primary_expression _GE_ primary_expression
        -: 1406:      {
    #####: 1407:        fail_if_error(yr_parser_reduce_operation(
        -: 1408:            yyscanner, ">=", $1, $3));
        -: 1409:
    #####: 1410:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1411:      }
        -: 1412:    | primary_expression _EQ_ primary_expression
        -: 1413:      {
       4*: 1414:        fail_if_error(yr_parser_reduce_operation(
        -: 1415:            yyscanner, "==", $1, $3));
        -: 1416:
        4: 1417:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1418:      }
        -: 1419:    | primary_expression _NEQ_ primary_expression
        -: 1420:      {
    #####: 1421:        fail_if_error(yr_parser_reduce_operation(
        -: 1422:            yyscanner, "!=", $1, $3));
        -: 1423:
    #####: 1424:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1425:      }
        -: 1426:    | primary_expression
        -: 1427:      {
    #####: 1428:        $$ = $1;
        -: 1429:      }
        -: 1430:    |'(' expression ')'
        -: 1431:      {
    #####: 1432:        $$ = $2;
        -: 1433:      }
        -: 1434:    ;
        -: 1435:
        -: 1436:
        -: 1437:integer_set
    #####: 1438:    : '(' integer_enumeration ')'  { $$ = INTEGER_SET_ENUMERATION; }
    #####: 1439:    | range                        { $$ = INTEGER_SET_RANGE; }
        -: 1440:    ;
        -: 1441:
        -: 1442:
        -: 1443:range
        -: 1444:    : '(' primary_expression _DOT_DOT_  primary_expression ')'
        -: 1445:      {
    #####: 1446:        int result = ERROR_SUCCESS;
        -: 1447:
    #####: 1448:        if ($2.type != EXPRESSION_TYPE_INTEGER)
        -: 1449:        {
    #####: 1450:          yr_compiler_set_error_extra_info(
        -: 1451:              compiler, "wrong type for range's lower bound");
    #####: 1452:          result = ERROR_WRONG_TYPE;
        -: 1453:        }
        -: 1454:
    #####: 1455:        if ($4.type != EXPRESSION_TYPE_INTEGER)
        -: 1456:        {
    #####: 1457:          yr_compiler_set_error_extra_info(
        -: 1458:              compiler, "wrong type for range's upper bound");
    #####: 1459:          result = ERROR_WRONG_TYPE;
        -: 1460:        }
        -: 1461:
    #####: 1462:        fail_if_error(result);
        -: 1463:      }
        -: 1464:    ;
        -: 1465:
        -: 1466:
        -: 1467:integer_enumeration
        -: 1468:    : primary_expression
        -: 1469:      {
    #####: 1470:        int result = ERROR_SUCCESS;
        -: 1471:
    #####: 1472:        if ($1.type != EXPRESSION_TYPE_INTEGER)
        -: 1473:        {
    #####: 1474:          yr_compiler_set_error_extra_info(
        -: 1475:              compiler, "wrong type for enumeration item");
    #####: 1476:          result = ERROR_WRONG_TYPE;
        -: 1477:        }
        -: 1478:
    #####: 1479:        fail_if_error(result);
        -: 1480:      }
        -: 1481:    | integer_enumeration ',' primary_expression
        -: 1482:      {
    #####: 1483:        int result = ERROR_SUCCESS;
        -: 1484:
    #####: 1485:        if ($3.type != EXPRESSION_TYPE_INTEGER)
        -: 1486:        {
    #####: 1487:          yr_compiler_set_error_extra_info(
        -: 1488:              compiler, "wrong type for enumeration item");
    #####: 1489:          result = ERROR_WRONG_TYPE;
        -: 1490:        }
        -: 1491:
    #####: 1492:        fail_if_error(result);
        -: 1493:      }
        -: 1494:    ;
        -: 1495:
        -: 1496:
        -: 1497:string_set
        -: 1498:    : '('
        -: 1499:      {
        -: 1500:        // Push end-of-list marker
    #####: 1501:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1502:      }
        -: 1503:      string_enumeration ')'
        -: 1504:    | _THEM_
        -: 1505:      {
    #####: 1506:        fail_if_error(yr_parser_emit_with_arg(
        -: 1507:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 1508:
    #####: 1509:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 1510:            yyscanner, "$*"));
        -: 1511:      }
        -: 1512:    ;
        -: 1513:
        -: 1514:
        -: 1515:string_enumeration
        -: 1516:    : string_enumeration_item
        -: 1517:    | string_enumeration ',' string_enumeration_item
        -: 1518:    ;
        -: 1519:
        -: 1520:
        -: 1521:string_enumeration_item
        -: 1522:    : _STRING_IDENTIFIER_
        -: 1523:      {
    #####: 1524:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1525:        yr_free($1);
        -: 1526:
    #####: 1527:        fail_if_error(result);
        -: 1528:      }
        -: 1529:    | _STRING_IDENTIFIER_WITH_WILDCARD_
        -: 1530:      {
    #####: 1531:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1532:        yr_free($1);
        -: 1533:
    #####: 1534:        fail_if_error(result);
        -: 1535:      }
        -: 1536:    ;
        -: 1537:
        -: 1538:
        -: 1539:for_expression
        -: 1540:    : primary_expression
        -: 1541:    | _ALL_
        -: 1542:      {
    #####: 1543:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1544:      }
        -: 1545:    | _ANY_
        -: 1546:      {
    #####: 1547:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1548:      }
        -: 1549:    ;
        -: 1550:
        -: 1551:
        -: 1552:primary_expression
        -: 1553:    : '(' primary_expression ')'
        -: 1554:      {
    #####: 1555:        $$ = $2;
        -: 1556:      }
        -: 1557:    | _FILESIZE_
        -: 1558:      {
    #####: 1559:        fail_if_error(yr_parser_emit(
        -: 1560:            yyscanner, OP_FILESIZE, NULL));
        -: 1561:
    #####: 1562:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1563:        $$.value.integer = UNDEFINED;
        -: 1564:      }
        -: 1565:    | _ENTRYPOINT_
        -: 1566:      {
    #####: 1567:        yywarning(yyscanner,
        -: 1568:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 1569:            "function from PE module instead.");
        -: 1570:
    #####: 1571:        fail_if_error(yr_parser_emit(
        -: 1572:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 1573:
    #####: 1574:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1575:        $$.value.integer = UNDEFINED;
        -: 1576:      }
        -: 1577:    | _INTEGER_FUNCTION_ '(' primary_expression ')'
        -: 1578:      {
    #####: 1579:        check_type($3, EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 1580:
        -: 1581:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 1582:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 1583:        // in the proper OP_INTXX opcode.
        -: 1584:
    #####: 1585:        fail_if_error(yr_parser_emit(
        -: 1586:            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL));
        -: 1587:
    #####: 1588:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1589:        $$.value.integer = UNDEFINED;
        -: 1590:      }
        -: 1591:    | _NUMBER_
        -: 1592:      {
       4*: 1593:        fail_if_error(yr_parser_emit_with_arg(
        -: 1594:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1595:
        4: 1596:        $$.type = EXPRESSION_TYPE_INTEGER;
        4: 1597:        $$.value.integer = $1;
        -: 1598:      }
        -: 1599:    | _DOUBLE_
        -: 1600:      {
    #####: 1601:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 1602:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1603:
    #####: 1604:        $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1605:      }
        -: 1606:    | _TEXT_STRING_
        -: 1607:      {
        -: 1608:        SIZED_STRING* sized_string;
        -: 1609:
    #####: 1610:        int result = yr_arena_write_data(
        -: 1611:            compiler->sz_arena,
    #####: 1612:            $1,
    #####: 1613:            $1->length + sizeof(SIZED_STRING),
        -: 1614:            (void**) &sized_string);
        -: 1615:
    #####: 1616:        yr_free($1);
        -: 1617:
    #####: 1618:        if (result == ERROR_SUCCESS)
    #####: 1619:          result = yr_parser_emit_with_arg_reloc(
        -: 1620:              yyscanner,
        -: 1621:              OP_PUSH,
        -: 1622:              sized_string,
        -: 1623:              NULL,
        -: 1624:              NULL);
        -: 1625:
    #####: 1626:        fail_if_error(result);
        -: 1627:
    #####: 1628:        $$.type = EXPRESSION_TYPE_STRING;
    #####: 1629:        $$.value.sized_string = sized_string;
        -: 1630:      }
        -: 1631:    | _STRING_COUNT_
        -: 1632:      {
    #####: 1633:        int result = yr_parser_reduce_string_identifier(
    #####: 1634:            yyscanner, $1, OP_COUNT, UNDEFINED);
        -: 1635:
    #####: 1636:        yr_free($1);
        -: 1637:
    #####: 1638:        fail_if_error(result);
        -: 1639:
    #####: 1640:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1641:        $$.value.integer = UNDEFINED;
        -: 1642:      }
        -: 1643:    | _STRING_OFFSET_ '[' primary_expression ']'
        -: 1644:      {
    #####: 1645:        int result = yr_parser_reduce_string_identifier(
    #####: 1646:            yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1647:
    #####: 1648:        yr_free($1);
        -: 1649:
    #####: 1650:        fail_if_error(result);
        -: 1651:
    #####: 1652:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1653:        $$.value.integer = UNDEFINED;
        -: 1654:      }
        -: 1655:    | _STRING_OFFSET_
        -: 1656:      {
    #####: 1657:        int result = yr_parser_emit_with_arg(
        -: 1658:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1659:
    #####: 1660:        if (result == ERROR_SUCCESS)
    #####: 1661:          result = yr_parser_reduce_string_identifier(
    #####: 1662:              yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1663:
    #####: 1664:        yr_free($1);
        -: 1665:
    #####: 1666:        fail_if_error(result);
        -: 1667:
    #####: 1668:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1669:        $$.value.integer = UNDEFINED;
        -: 1670:      }
        -: 1671:    | _STRING_LENGTH_ '[' primary_expression ']'
        -: 1672:      {
    #####: 1673:        int result = yr_parser_reduce_string_identifier(
    #####: 1674:            yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1675:
    #####: 1676:        yr_free($1);
        -: 1677:
    #####: 1678:        fail_if_error(result);
        -: 1679:
    #####: 1680:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1681:        $$.value.integer = UNDEFINED;
        -: 1682:      }
        -: 1683:    | _STRING_LENGTH_
        -: 1684:      {
        4: 1685:        int result = yr_parser_emit_with_arg(
        -: 1686:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1687:
        4: 1688:        if (result == ERROR_SUCCESS)
        4: 1689:          result = yr_parser_reduce_string_identifier(
        4: 1690:              yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1691:
        4: 1692:        yr_free($1);
        -: 1693:
       4*: 1694:        fail_if_error(result);
        -: 1695:
        4: 1696:        $$.type = EXPRESSION_TYPE_INTEGER;
        4: 1697:        $$.value.integer = UNDEFINED;
        -: 1698:      }
        -: 1699:    | identifier
        -: 1700:      {
    #####: 1701:        int result = ERROR_SUCCESS;
        -: 1702:
    #####: 1703:        if ($1.type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 1704:        {
    #####: 1705:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1706:          $$.value.integer = UNDEFINED;
        -: 1707:        }
    #####: 1708:        else if ($1.type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 1709:        {
    #####: 1710:          $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####: 1711:          $$.value.integer = UNDEFINED;
        -: 1712:        }
    #####: 1713:        else if ($1.type == EXPRESSION_TYPE_OBJECT)
        -: 1714:        {
    #####: 1715:          result = yr_parser_emit(
        -: 1716:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 1717:
    #####: 1718:          switch($1.value.object->type)
        -: 1719:          {
    #####: 1720:            case OBJECT_TYPE_INTEGER:
    #####: 1721:              $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1722:              $$.value.integer = UNDEFINED;
    #####: 1723:              break;
    #####: 1724:            case OBJECT_TYPE_FLOAT:
    #####: 1725:              $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1726:              break;
    #####: 1727:            case OBJECT_TYPE_STRING:
    #####: 1728:              $$.type = EXPRESSION_TYPE_STRING;
    #####: 1729:              $$.value.sized_string = NULL;
    #####: 1730:              break;
    #####: 1731:            default:
    #####: 1732:              yr_compiler_set_error_extra_info_fmt(
        -: 1733:                  compiler,
        -: 1734:                  "wrong usage of identifier \"%s\"",
        -: 1735:                  $1.identifier);
    #####: 1736:              result = ERROR_WRONG_TYPE;
        -: 1737:          }
        -: 1738:        }
        -: 1739:        else
        -: 1740:        {
    #####: 1741:          assert(false);
        -: 1742:        }
        -: 1743:
    #####: 1744:        fail_if_error(result);
        -: 1745:      }
        -: 1746:    | '-' primary_expression %prec UNARY_MINUS
        -: 1747:      {
    #####: 1748:        int result = ERROR_SUCCESS;
        -: 1749:
    #####: 1750:        check_type($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 1751:
    #####: 1752:        if ($2.type == EXPRESSION_TYPE_INTEGER)
        -: 1753:        {
    #####: 1754:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1755:          $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 1756:              UNDEFINED : -($2.value.integer);
    #####: 1757:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 1758:        }
    #####: 1759:        else if ($2.type == EXPRESSION_TYPE_FLOAT)
        -: 1760:        {
    #####: 1761:          $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1762:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 1763:        }
        -: 1764:
    #####: 1765:        fail_if_error(result);
        -: 1766:      }
        -: 1767:    | primary_expression '+' primary_expression
        -: 1768:      {
    #####: 1769:        int result = yr_parser_reduce_operation(
    #####: 1770:            yyscanner, "+", $1, $3);
        -: 1771:
    #####: 1772:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1773:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1774:        {
    #####: 1775:          int64_t i1 = $1.value.integer;
    #####: 1776:          int64_t i2 = $3.value.integer;
        -: 1777:
    #####: 1778:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1779:              (
    #####: 1780:                (i2 > 0 && i1 > INT64_MAX - i2) ||
    #####: 1781:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 1782:              ))
        -: 1783:          {
    #####: 1784:            yr_compiler_set_error_extra_info_fmt(
        -: 1785:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 1786:
    #####: 1787:            result = ERROR_INTEGER_OVERFLOW;
        -: 1788:          }
        -: 1789:          else
        -: 1790:          {
    #####: 1791:            $$.value.integer = OPERATION(+, i1, i2);
    #####: 1792:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1793:          }
        -: 1794:        }
        -: 1795:        else
        -: 1796:        {
    #####: 1797:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1798:        }
        -: 1799:
    #####: 1800:        fail_if_error(result);
        -: 1801:      }
        -: 1802:    | primary_expression '-' primary_expression
        -: 1803:      {
    #####: 1804:        int result = yr_parser_reduce_operation(
    #####: 1805:            yyscanner, "-", $1, $3);
        -: 1806:
    #####: 1807:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1808:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1809:        {
    #####: 1810:          int64_t i1 = $1.value.integer;
    #####: 1811:          int64_t i2 = $3.value.integer;
        -: 1812:
    #####: 1813:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1814:              (
    #####: 1815:                (i2 < 0 && i1 > INT64_MAX + i2) ||
    #####: 1816:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 1817:              ))
        -: 1818:          {
    #####: 1819:            yr_compiler_set_error_extra_info_fmt(
        -: 1820:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 1821:
    #####: 1822:            result = ERROR_INTEGER_OVERFLOW;
        -: 1823:          }
        -: 1824:          else
        -: 1825:          {
    #####: 1826:            $$.value.integer = OPERATION(-, i1, i2);
    #####: 1827:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1828:          }
        -: 1829:        }
        -: 1830:        else
        -: 1831:        {
    #####: 1832:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1833:        }
        -: 1834:
    #####: 1835:        fail_if_error(result);
        -: 1836:      }
        -: 1837:    | primary_expression '*' primary_expression
        -: 1838:      {
    #####: 1839:        int result = yr_parser_reduce_operation(
    #####: 1840:            yyscanner, "*", $1, $3);
        -: 1841:
    #####: 1842:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1843:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1844:        {
    #####: 1845:          int64_t i1 = $1.value.integer;
    #####: 1846:          int64_t i2 = $3.value.integer;
        -: 1847:
    #####: 1848:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1849:              (
    #####: 1850:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 1851:              ))
        -: 1852:          {
    #####: 1853:            yr_compiler_set_error_extra_info_fmt(
        -: 1854:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 1855:
    #####: 1856:            result = ERROR_INTEGER_OVERFLOW;
        -: 1857:          }
        -: 1858:          else
        -: 1859:          {
    #####: 1860:            $$.value.integer = OPERATION(*, i1, i2);
    #####: 1861:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1862:          }
        -: 1863:        }
        -: 1864:        else
        -: 1865:        {
    #####: 1866:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1867:        }
        -: 1868:
    #####: 1869:        fail_if_error(result);
        -: 1870:      }
        -: 1871:    | primary_expression '\\' primary_expression
        -: 1872:      {
    #####: 1873:        int result = yr_parser_reduce_operation(
    #####: 1874:            yyscanner, "\\", $1, $3);
        -: 1875:
    #####: 1876:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1877:            $3.type == EXPRESSION_TYPE_INTEGER)
        -: 1878:        {
    #####: 1879:          if ($3.value.integer != 0)
        -: 1880:          {
    #####: 1881:            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);
    #####: 1882:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1883:          }
        -: 1884:          else
        -: 1885:          {
    #####: 1886:            result = ERROR_DIVISION_BY_ZERO;
        -: 1887:          }
        -: 1888:        }
        -: 1889:        else
        -: 1890:        {
    #####: 1891:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1892:        }
        -: 1893:
    #####: 1894:        fail_if_error(result);
        -: 1895:      }
        -: 1896:    | primary_expression '%' primary_expression
        -: 1897:      {
    #####: 1898:        check_type($1, EXPRESSION_TYPE_INTEGER, "%");
    #####: 1899:        check_type($3, EXPRESSION_TYPE_INTEGER, "%");
        -: 1900:
    #####: 1901:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 1902:
    #####: 1903:        if ($3.value.integer != 0)
        -: 1904:        {
    #####: 1905:          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);
    #####: 1906:          $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1907:        }
        -: 1908:        else
        -: 1909:        {
    #####: 1910:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 1911:        }
        -: 1912:      }
        -: 1913:    | primary_expression '^' primary_expression
        -: 1914:      {
    #####: 1915:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 1916:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 1917:
    #####: 1918:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 1919:
    #####: 1920:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1921:        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);
        -: 1922:      }
        -: 1923:    | primary_expression '&' primary_expression
        -: 1924:      {
    #####: 1925:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 1926:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 1927:
    #####: 1928:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 1929:
    #####: 1930:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1931:        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);
        -: 1932:      }
        -: 1933:    | primary_expression '|' primary_expression
        -: 1934:      {
    #####: 1935:        check_type($1, EXPRESSION_TYPE_INTEGER, "|");
    #####: 1936:        check_type($3, EXPRESSION_TYPE_INTEGER, "|");
        -: 1937:
    #####: 1938:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 1939:
    #####: 1940:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1941:        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);
        -: 1942:      }
        -: 1943:    | '~' primary_expression
        -: 1944:      {
    #####: 1945:        check_type($2, EXPRESSION_TYPE_INTEGER, "~");
        -: 1946:
    #####: 1947:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 1948:
    #####: 1949:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1950:        $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 1951:            UNDEFINED : ~($2.value.integer);
        -: 1952:      }
        -: 1953:    | primary_expression _SHIFT_LEFT_ primary_expression
        -: 1954:      {
        -: 1955:        int result;
        -: 1956:
    #####: 1957:        check_type($1, EXPRESSION_TYPE_INTEGER, "<<");
    #####: 1958:        check_type($3, EXPRESSION_TYPE_INTEGER, "<<");
        -: 1959:
    #####: 1960:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 1961:
    #####: 1962:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 1963:          result = ERROR_INVALID_OPERAND;
    #####: 1964:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 1965:          $$.value.integer = 0;
        -: 1966:        else
    #####: 1967:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 1968:
    #####: 1969:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1970:
    #####: 1971:        fail_if_error(result);
        -: 1972:      }
        -: 1973:    | primary_expression _SHIFT_RIGHT_ primary_expression
        -: 1974:      {
        -: 1975:        int result;
        -: 1976:
    #####: 1977:        check_type($1, EXPRESSION_TYPE_INTEGER, ">>");
    #####: 1978:        check_type($3, EXPRESSION_TYPE_INTEGER, ">>");
        -: 1979:
    #####: 1980:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 1981:
    #####: 1982:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 1983:          result = ERROR_INVALID_OPERAND;
    #####: 1984:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 1985:          $$.value.integer = 0;
        -: 1986:        else
    #####: 1987:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 1988:
    #####: 1989:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1990:
    #####: 1991:        fail_if_error(result);
        -: 1992:      }
        -: 1993:    | regexp
        -: 1994:      {
    #####: 1995:        $$ = $1;
        -: 1996:      }
        -: 1997:    ;
        -: 1998:
        -: 1999:%%
