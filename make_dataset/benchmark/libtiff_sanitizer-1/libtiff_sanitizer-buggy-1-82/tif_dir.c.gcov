        -:    0:Source:tif_dir.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library.
        -:   29: *
        -:   30: * Directory Tag Get & Set Routines.
        -:   31: * (and also some miscellaneous stuff)
        -:   32: */
        -:   33:#include "tiffiop.h"
        -:   34:
        -:   35:/*
        -:   36: * These are used in the backwards compatibility code...
        -:   37: */
        -:   38:#define DATATYPE_VOID		0       /* !untyped data */
        -:   39:#define DATATYPE_INT		1       /* !signed integer data */
        -:   40:#define DATATYPE_UINT		2       /* !unsigned integer data */
        -:   41:#define DATATYPE_IEEEFP		3       /* !IEEE floating point data */
        -:   42:
        -:   43:static void
        2:   44:setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)
        -:   45:{
        2:   46:	if (*vpp) {
    #####:   47:		_TIFFfree(*vpp);
    #####:   48:		*vpp = 0;
        -:   49:	}
        2:   50:	if (vp) {
        2:   51:		tmsize_t bytes = (tmsize_t)(nmemb * elem_size);
       2*:   52:		if (elem_size && bytes / elem_size == nmemb)
        2:   53:			*vpp = (void*) _TIFFmalloc(bytes);
        2:   54:		if (*vpp)
        2:   55:			_TIFFmemcpy(*vpp, vp, bytes);
        -:   56:	}
        2:   57:}
    #####:   58:void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)
    #####:   59:    { setByteArray(vpp, vp, n, 1); }
    #####:   60:void _TIFFsetString(char** cpp, char* cp)
    #####:   61:    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }
    #####:   62:static void _TIFFsetNString(char** cpp, char* cp, uint32 n)
    #####:   63:    { setByteArray((void**) cpp, (void*) cp, n, 1); }
        1:   64:void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)
        1:   65:    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }
    #####:   66:void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)
    #####:   67:    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }
    #####:   68:static void _TIFFsetLong8Array(uint64** lpp, uint64* lp, uint32 n)
    #####:   69:    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint64)); }
    #####:   70:void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)
    #####:   71:    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }
    #####:   72:void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)
    #####:   73:    { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }
        -:   74:
        -:   75:static void
    #####:   76:setDoubleArrayOneValue(double** vpp, double value, size_t nmemb)
        -:   77:{
    #####:   78:	if (*vpp)
    #####:   79:		_TIFFfree(*vpp);
    #####:   80:	*vpp = _TIFFmalloc(nmemb*sizeof(double));
    #####:   81:	if (*vpp)
        -:   82:	{
    #####:   83:		while (nmemb--)
    #####:   84:			((double*)*vpp)[nmemb] = value;
        -:   85:	}
    #####:   86:}
        -:   87:
        -:   88:/*
        -:   89: * Install extra samples information.
        -:   90: */
        -:   91:static int
        1:   92:setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)
        -:   93:{
        -:   94:/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
        -:   95:#define EXTRASAMPLE_COREL_UNASSALPHA 999 
        -:   96:
        -:   97:	uint16* va;
        -:   98:	uint32 i;
        -:   99:
        1:  100:	*v = (uint16) va_arg(ap, uint16_vap);
        1:  101:	if ((uint16) *v > td->td_samplesperpixel)
    #####:  102:		return 0;
        1:  103:	va = va_arg(ap, uint16*);
        1:  104:	if (*v > 0 && va == NULL)		/* typically missing param */
    #####:  105:		return 0;
        2:  106:	for (i = 0; i < *v; i++) {
        1:  107:		if (va[i] > EXTRASAMPLE_UNASSALPHA) {
        -:  108:			/*
        -:  109:			 * XXX: Corel Draw is known to produce incorrect
        -:  110:			 * ExtraSamples tags which must be patched here if we
        -:  111:			 * want to be able to open some of the damaged TIFF
        -:  112:			 * files: 
        -:  113:			 */
    #####:  114:			if (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)
    #####:  115:				va[i] = EXTRASAMPLE_UNASSALPHA;
        -:  116:			else
    #####:  117:				return 0;
        -:  118:		}
        -:  119:	}
        1:  120:	td->td_extrasamples = (uint16) *v;
        1:  121:	_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);
        1:  122:	return 1;
        -:  123:
        -:  124:#undef EXTRASAMPLE_COREL_UNASSALPHA
        -:  125:}
        -:  126:
        -:  127:/*
        -:  128: * Confirm we have "samplesperpixel" ink names separated by \0.  Returns 
        -:  129: * zero if the ink names are not as expected.
        -:  130: */
        -:  131:static uint32
    #####:  132:checkInkNamesString(TIFF* tif, uint32 slen, const char* s)
        -:  133:{
    #####:  134:	TIFFDirectory* td = &tif->tif_dir;
    #####:  135:	uint16 i = td->td_samplesperpixel;
        -:  136:
    #####:  137:	if (slen > 0) {
    #####:  138:		const char* ep = s+slen;
    #####:  139:		const char* cp = s;
    #####:  140:		for (; i > 0; i--) {
    #####:  141:			for (; cp < ep && *cp != '\0'; cp++) {}
    #####:  142:			if (cp >= ep)
    #####:  143:				goto bad;
    #####:  144:			cp++;				/* skip \0 */
        -:  145:		}
    #####:  146:		return ((uint32)(cp-s));
        -:  147:	}
    #####:  148:bad:
    #####:  149:	TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
        -:  150:	    "%s: Invalid InkNames value; expecting %d names, found %d",
        -:  151:	    tif->tif_name,
    #####:  152:	    td->td_samplesperpixel,
    #####:  153:	    td->td_samplesperpixel-i);
    #####:  154:	return (0);
        -:  155:}
        -:  156:
        -:  157:static int
       15:  158:_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
        -:  159:{
        -:  160:	static const char module[] = "_TIFFVSetField";
        -:  161:
       15:  162:	TIFFDirectory* td = &tif->tif_dir;
       15:  163:	int status = 1;
       15:  164:	uint32 v32, i, v;
        -:  165:    double dblval;
        -:  166:	char* s;
       15:  167:	const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);
       15:  168:	uint32 standard_tag = tag;
       15:  169:	if( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */
    #####:  170:	    return 0;
        -:  171:	/*
        -:  172:	 * We want to force the custom code to be used for custom
        -:  173:	 * fields even if the tag happens to match a well known 
        -:  174:	 * one - important for reinterpreted handling of standard
        -:  175:	 * tag values in custom directories (i.e. EXIF) 
        -:  176:	 */
       15:  177:	if (fip->field_bit == FIELD_CUSTOM) {
        1:  178:		standard_tag = 0;
        -:  179:	}
        -:  180:
       15:  181:	switch (standard_tag) {
    #####:  182:	case TIFFTAG_SUBFILETYPE:
    #####:  183:		td->td_subfiletype = (uint32) va_arg(ap, uint32);
    #####:  184:		break;
        1:  185:	case TIFFTAG_IMAGEWIDTH:
        1:  186:		td->td_imagewidth = (uint32) va_arg(ap, uint32);
        1:  187:		break;
        1:  188:	case TIFFTAG_IMAGELENGTH:
        1:  189:		td->td_imagelength = (uint32) va_arg(ap, uint32);
        1:  190:		break;
        1:  191:	case TIFFTAG_BITSPERSAMPLE:
        1:  192:		td->td_bitspersample = (uint16) va_arg(ap, uint16_vap);
        -:  193:		/*
        -:  194:		 * If the data require post-decoding processing to byte-swap
        -:  195:		 * samples, set it up here.  Note that since tags are required
        -:  196:		 * to be ordered, compression code can override this behaviour
        -:  197:		 * in the setup method if it wants to roll the post decoding
        -:  198:		 * work in with its normal work.
        -:  199:		 */
        1:  200:		if (tif->tif_flags & TIFF_SWAB) {
    #####:  201:			if (td->td_bitspersample == 8)
    #####:  202:				tif->tif_postdecode = _TIFFNoPostDecode;
    #####:  203:			else if (td->td_bitspersample == 16)
    #####:  204:				tif->tif_postdecode = _TIFFSwab16BitData;
    #####:  205:			else if (td->td_bitspersample == 24)
    #####:  206:				tif->tif_postdecode = _TIFFSwab24BitData;
    #####:  207:			else if (td->td_bitspersample == 32)
    #####:  208:				tif->tif_postdecode = _TIFFSwab32BitData;
    #####:  209:			else if (td->td_bitspersample == 64)
    #####:  210:				tif->tif_postdecode = _TIFFSwab64BitData;
    #####:  211:			else if (td->td_bitspersample == 128) /* two 64's */
    #####:  212:				tif->tif_postdecode = _TIFFSwab64BitData;
        -:  213:		}
        1:  214:		break;
        2:  215:	case TIFFTAG_COMPRESSION:
        2:  216:		v = (uint16) va_arg(ap, uint16_vap);
        -:  217:		/*
        -:  218:		 * If we're changing the compression scheme, the notify the
        -:  219:		 * previous module so that it can cleanup any state it's
        -:  220:		 * setup.
        -:  221:		 */
        2:  222:		if (TIFFFieldSet(tif, FIELD_COMPRESSION)) {
        1:  223:			if ((uint32)td->td_compression == v)
        1:  224:				break;
    #####:  225:			(*tif->tif_cleanup)(tif);
    #####:  226:			tif->tif_flags &= ~TIFF_CODERSETUP;
        -:  227:		}
        -:  228:		/*
        -:  229:		 * Setup new compression routine state.
        -:  230:		 */
        1:  231:		if( (status = TIFFSetCompressionScheme(tif, v)) != 0 )
        1:  232:		    td->td_compression = (uint16) v;
        -:  233:		else
    #####:  234:		    status = 0;
        1:  235:		break;
        1:  236:	case TIFFTAG_PHOTOMETRIC:
        1:  237:		td->td_photometric = (uint16) va_arg(ap, uint16_vap);
        1:  238:		break;
    #####:  239:	case TIFFTAG_THRESHHOLDING:
    #####:  240:		td->td_threshholding = (uint16) va_arg(ap, uint16_vap);
    #####:  241:		break;
    #####:  242:	case TIFFTAG_FILLORDER:
    #####:  243:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  244:		if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)
    #####:  245:			goto badvalue;
    #####:  246:		td->td_fillorder = (uint16) v;
    #####:  247:		break;
    #####:  248:	case TIFFTAG_ORIENTATION:
    #####:  249:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  250:		if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)
    #####:  251:			goto badvalue;
        -:  252:		else
    #####:  253:			td->td_orientation = (uint16) v;
    #####:  254:		break;
    #####:  255:	case TIFFTAG_SAMPLESPERPIXEL:
    #####:  256:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  257:		if (v == 0)
    #####:  258:			goto badvalue;
    #####:  259:        if( v != td->td_samplesperpixel )
        -:  260:        {
        -:  261:            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */
    #####:  262:            if( td->td_sminsamplevalue != NULL )
        -:  263:            {
    #####:  264:                TIFFWarningExt(tif->tif_clientdata,module,
        -:  265:                    "SamplesPerPixel tag value is changing, "
        -:  266:                    "but SMinSampleValue tag was read with a different value. Cancelling it");
    #####:  267:                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);
    #####:  268:                _TIFFfree(td->td_sminsamplevalue);
    #####:  269:                td->td_sminsamplevalue = NULL;
        -:  270:            }
    #####:  271:            if( td->td_smaxsamplevalue != NULL )
        -:  272:            {
    #####:  273:                TIFFWarningExt(tif->tif_clientdata,module,
        -:  274:                    "SamplesPerPixel tag value is changing, "
        -:  275:                    "but SMaxSampleValue tag was read with a different value. Cancelling it");
    #####:  276:                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);
    #####:  277:                _TIFFfree(td->td_smaxsamplevalue);
    #####:  278:                td->td_smaxsamplevalue = NULL;
        -:  279:            }
        -:  280:        }
    #####:  281:		td->td_samplesperpixel = (uint16) v;
    #####:  282:		break;
        1:  283:	case TIFFTAG_ROWSPERSTRIP:
        1:  284:		v32 = (uint32) va_arg(ap, uint32);
        1:  285:		if (v32 == 0)
    #####:  286:			goto badvalue32;
        1:  287:		td->td_rowsperstrip = v32;
        1:  288:		if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
        1:  289:			td->td_tilelength = v32;
        1:  290:			td->td_tilewidth = td->td_imagewidth;
        -:  291:		}
        1:  292:		break;
    #####:  293:	case TIFFTAG_MINSAMPLEVALUE:
    #####:  294:		td->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);
    #####:  295:		break;
    #####:  296:	case TIFFTAG_MAXSAMPLEVALUE:
    #####:  297:		td->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);
    #####:  298:		break;
    #####:  299:	case TIFFTAG_SMINSAMPLEVALUE:
    #####:  300:		if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  301:			_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);
        -:  302:		else
    #####:  303:			setDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);
    #####:  304:		break;
    #####:  305:	case TIFFTAG_SMAXSAMPLEVALUE:
    #####:  306:		if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  307:			_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);
        -:  308:		else
    #####:  309:			setDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);
    #####:  310:		break;
        1:  311:	case TIFFTAG_XRESOLUTION:
        1:  312:        dblval = va_arg(ap, double);
        1:  313:        if( dblval < 0 )
    #####:  314:            goto badvaluedouble;
        1:  315:		td->td_xresolution = (float) dblval;
        1:  316:		break;
    #####:  317:	case TIFFTAG_YRESOLUTION:
    #####:  318:        dblval = va_arg(ap, double);
    #####:  319:        if( dblval < 0 )
    #####:  320:            goto badvaluedouble;
    #####:  321:		td->td_yresolution = (float) dblval;
    #####:  322:		break;
        2:  323:	case TIFFTAG_PLANARCONFIG:
        2:  324:		v = (uint16) va_arg(ap, uint16_vap);
       2*:  325:		if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)
    #####:  326:			goto badvalue;
        2:  327:		td->td_planarconfig = (uint16) v;
        2:  328:		break;
    #####:  329:	case TIFFTAG_XPOSITION:
    #####:  330:		td->td_xposition = (float) va_arg(ap, double);
    #####:  331:		break;
    #####:  332:	case TIFFTAG_YPOSITION:
    #####:  333:		td->td_yposition = (float) va_arg(ap, double);
    #####:  334:		break;
        1:  335:	case TIFFTAG_RESOLUTIONUNIT:
        1:  336:		v = (uint16) va_arg(ap, uint16_vap);
        1:  337:		if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)
    #####:  338:			goto badvalue;
        1:  339:		td->td_resolutionunit = (uint16) v;
        1:  340:		break;
        1:  341:	case TIFFTAG_PAGENUMBER:
        1:  342:		td->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);
        1:  343:		td->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);
        1:  344:		break;
    #####:  345:	case TIFFTAG_HALFTONEHINTS:
    #####:  346:		td->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);
    #####:  347:		td->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);
    #####:  348:		break;
    #####:  349:	case TIFFTAG_COLORMAP:
    #####:  350:		v32 = (uint32)(1L<<td->td_bitspersample);
    #####:  351:		_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);
    #####:  352:		_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);
    #####:  353:		_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);
    #####:  354:		break;
        1:  355:	case TIFFTAG_EXTRASAMPLES:
        1:  356:		if (!setExtraSamples(td, ap, &v))
    #####:  357:			goto badvalue;
        1:  358:		break;
    #####:  359:	case TIFFTAG_MATTEING:
    #####:  360:		td->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);
    #####:  361:		if (td->td_extrasamples) {
    #####:  362:			uint16 sv = EXTRASAMPLE_ASSOCALPHA;
    #####:  363:			_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);
        -:  364:		}
    #####:  365:		break;
    #####:  366:	case TIFFTAG_TILEWIDTH:
    #####:  367:		v32 = (uint32) va_arg(ap, uint32);
    #####:  368:		if (v32 % 16) {
    #####:  369:			if (tif->tif_mode != O_RDONLY)
    #####:  370:				goto badvalue32;
    #####:  371:			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -:  372:				"Nonstandard tile width %d, convert file", v32);
        -:  373:		}
    #####:  374:		td->td_tilewidth = v32;
    #####:  375:		tif->tif_flags |= TIFF_ISTILED;
    #####:  376:		break;
    #####:  377:	case TIFFTAG_TILELENGTH:
    #####:  378:		v32 = (uint32) va_arg(ap, uint32);
    #####:  379:		if (v32 % 16) {
    #####:  380:			if (tif->tif_mode != O_RDONLY)
    #####:  381:				goto badvalue32;
    #####:  382:			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -:  383:			    "Nonstandard tile length %d, convert file", v32);
        -:  384:		}
    #####:  385:		td->td_tilelength = v32;
    #####:  386:		tif->tif_flags |= TIFF_ISTILED;
    #####:  387:		break;
    #####:  388:	case TIFFTAG_TILEDEPTH:
    #####:  389:		v32 = (uint32) va_arg(ap, uint32);
    #####:  390:		if (v32 == 0)
    #####:  391:			goto badvalue32;
    #####:  392:		td->td_tiledepth = v32;
    #####:  393:		break;
    #####:  394:	case TIFFTAG_DATATYPE:
    #####:  395:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  396:		switch (v) {
    #####:  397:		case DATATYPE_VOID:	v = SAMPLEFORMAT_VOID;	break;
    #####:  398:		case DATATYPE_INT:	v = SAMPLEFORMAT_INT;	break;
    #####:  399:		case DATATYPE_UINT:	v = SAMPLEFORMAT_UINT;	break;
    #####:  400:		case DATATYPE_IEEEFP:	v = SAMPLEFORMAT_IEEEFP;break;
    #####:  401:		default:		goto badvalue;
        -:  402:		}
    #####:  403:		td->td_sampleformat = (uint16) v;
    #####:  404:		break;
        1:  405:	case TIFFTAG_SAMPLEFORMAT:
        1:  406:		v = (uint16) va_arg(ap, uint16_vap);
        1:  407:		if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)
    #####:  408:			goto badvalue;
        1:  409:		td->td_sampleformat = (uint16) v;
        -:  410:
        -:  411:		/*  Try to fix up the SWAB function for complex data. */
        1:  412:		if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT
    #####:  413:		    && td->td_bitspersample == 32
    #####:  414:		    && tif->tif_postdecode == _TIFFSwab32BitData )
    #####:  415:		    tif->tif_postdecode = _TIFFSwab16BitData;
        1:  416:		else if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT
        1:  417:			  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)
    #####:  418:			 && td->td_bitspersample == 64
    #####:  419:			 && tif->tif_postdecode == _TIFFSwab64BitData )
    #####:  420:		    tif->tif_postdecode = _TIFFSwab32BitData;
        1:  421:		break;
    #####:  422:	case TIFFTAG_IMAGEDEPTH:
    #####:  423:		td->td_imagedepth = (uint32) va_arg(ap, uint32);
    #####:  424:		break;
    #####:  425:	case TIFFTAG_SUBIFD:
    #####:  426:		if ((tif->tif_flags & TIFF_INSUBIFD) == 0) {
    #####:  427:			td->td_nsubifd = (uint16) va_arg(ap, uint16_vap);
    #####:  428:			_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),
    #####:  429:			    (uint32) td->td_nsubifd);
        -:  430:		} else {
    #####:  431:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  432:				     "%s: Sorry, cannot nest SubIFDs",
        -:  433:				     tif->tif_name);
    #####:  434:			status = 0;
        -:  435:		}
    #####:  436:		break;
    #####:  437:	case TIFFTAG_YCBCRPOSITIONING:
    #####:  438:		td->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);
    #####:  439:		break;
    #####:  440:	case TIFFTAG_YCBCRSUBSAMPLING:
    #####:  441:		td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);
    #####:  442:		td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);
    #####:  443:		break;
    #####:  444:	case TIFFTAG_TRANSFERFUNCTION:
    #####:  445:		v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;
    #####:  446:		for (i = 0; i < v; i++)
    #####:  447:			_TIFFsetShortArray(&td->td_transferfunction[i],
    #####:  448:			    va_arg(ap, uint16*), 1U<<td->td_bitspersample);
    #####:  449:		break;
    #####:  450:	case TIFFTAG_REFERENCEBLACKWHITE:
        -:  451:		/* XXX should check for null range */
    #####:  452:		_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);
    #####:  453:		break;
    #####:  454:	case TIFFTAG_INKNAMES:
    #####:  455:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  456:		s = va_arg(ap, char*);
    #####:  457:		v = checkInkNamesString(tif, v, s);
    #####:  458:		status = v > 0;
    #####:  459:		if( v > 0 ) {
    #####:  460:			_TIFFsetNString(&td->td_inknames, s, v);
    #####:  461:			td->td_inknameslen = v;
        -:  462:		}
    #####:  463:		break;
    #####:  464:	case TIFFTAG_PERSAMPLE:
    #####:  465:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  466:		if( v == PERSAMPLE_MULTI )
    #####:  467:			tif->tif_flags |= TIFF_PERSAMPLE;
        -:  468:		else
    #####:  469:			tif->tif_flags &= ~TIFF_PERSAMPLE;
    #####:  470:		break;
        1:  471:	default: {
        -:  472:		TIFFTagValue *tv;
        -:  473:		int tv_size, iCustom;
        -:  474:
        -:  475:		/*
        -:  476:		 * This can happen if multiple images are open with different
        -:  477:		 * codecs which have private tags.  The global tag information
        -:  478:		 * table may then have tags that are valid for one file but not
        -:  479:		 * the other. If the client tries to set a tag that is not valid
        -:  480:		 * for the image's codec then we'll arrive here.  This
        -:  481:		 * happens, for example, when tiffcp is used to convert between
        -:  482:		 * compression schemes and codec-specific tags are blindly copied.
        -:  483:		 */
        1:  484:		if(fip->field_bit != FIELD_CUSTOM) {
    #####:  485:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  486:			    "%s: Invalid %stag \"%s\" (not supported by codec)",
        -:  487:			    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "",
        -:  488:			    fip->field_name);
    #####:  489:			status = 0;
    #####:  490:			break;
        -:  491:		}
        -:  492:
        -:  493:		/*
        -:  494:		 * Find the existing entry for this custom value.
        -:  495:		 */
        1:  496:		tv = NULL;
       1*:  497:		for (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {
    #####:  498:			if (td->td_customValues[iCustom].info->field_tag == tag) {
    #####:  499:				tv = td->td_customValues + iCustom;
    #####:  500:				if (tv->value != NULL) {
    #####:  501:					_TIFFfree(tv->value);
    #####:  502:					tv->value = NULL;
        -:  503:				}
    #####:  504:				break;
        -:  505:			}
        -:  506:		}
        -:  507:
        -:  508:		/*
        -:  509:		 * Grow the custom list if the entry was not found.
        -:  510:		 */
        1:  511:		if(tv == NULL) {
        -:  512:			TIFFTagValue *new_customValues;
        -:  513:
        1:  514:			td->td_customValueCount++;
        -:  515:			new_customValues = (TIFFTagValue *)
        1:  516:			    _TIFFrealloc(td->td_customValues,
        1:  517:			    sizeof(TIFFTagValue) * td->td_customValueCount);
        1:  518:			if (!new_customValues) {
    #####:  519:				TIFFErrorExt(tif->tif_clientdata, module,
        -:  520:				    "%s: Failed to allocate space for list of custom values",
        -:  521:				    tif->tif_name);
    #####:  522:				status = 0;
    #####:  523:				goto end;
        -:  524:			}
        -:  525:
        1:  526:			td->td_customValues = new_customValues;
        -:  527:
        1:  528:			tv = td->td_customValues + (td->td_customValueCount - 1);
        1:  529:			tv->info = fip;
        1:  530:			tv->value = NULL;
        1:  531:			tv->count = 0;
        -:  532:		}
        -:  533:
        -:  534:		/*
        -:  535:		 * Set custom value ... save a copy of the custom tag value.
        -:  536:		 */
        1:  537:		tv_size = _TIFFDataSize(fip->field_type);
        1:  538:		if (tv_size == 0) {
    #####:  539:			status = 0;
    #####:  540:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  541:			    "%s: Bad field type %d for \"%s\"",
    #####:  542:			    tif->tif_name, fip->field_type,
        -:  543:			    fip->field_name);
    #####:  544:			goto end;
        -:  545:		}
        -:  546:
        1:  547:		if (fip->field_type == TIFF_ASCII)
        -:  548:		{
        -:  549:			uint32 ma;
        -:  550:			char* mb;
        1:  551:			if (fip->field_passcount)
        -:  552:			{
    #####:  553:				assert(fip->field_writecount==TIFF_VARIABLE2);
    #####:  554:				ma=(uint32)va_arg(ap,uint32);
    #####:  555:				mb=(char*)va_arg(ap,char*);
        -:  556:			}
        -:  557:			else
        -:  558:			{
        1:  559:				mb=(char*)va_arg(ap,char*);
       1*:  560:				ma=(uint32)(strlen(mb)+1);
        -:  561:			}
        1:  562:			tv->count=ma;
        1:  563:			setByteArray(&tv->value,mb,ma,1);
        -:  564:		}
        -:  565:		else
        -:  566:		{
    #####:  567:			if (fip->field_passcount) {
    #####:  568:				if (fip->field_writecount == TIFF_VARIABLE2)
    #####:  569:					tv->count = (uint32) va_arg(ap, uint32);
        -:  570:				else
    #####:  571:					tv->count = (int) va_arg(ap, int);
    #####:  572:			} else if (fip->field_writecount == TIFF_VARIABLE
    #####:  573:			   || fip->field_writecount == TIFF_VARIABLE2)
    #####:  574:				tv->count = 1;
    #####:  575:			else if (fip->field_writecount == TIFF_SPP)
    #####:  576:				tv->count = td->td_samplesperpixel;
        -:  577:			else
    #####:  578:				tv->count = fip->field_writecount;
        -:  579:
    #####:  580:			if (tv->count == 0) {
    #####:  581:				status = 0;
    #####:  582:				TIFFErrorExt(tif->tif_clientdata, module,
        -:  583:					     "%s: Null count for \"%s\" (type "
        -:  584:					     "%d, writecount %d, passcount %d)",
        -:  585:					     tif->tif_name,
        -:  586:					     fip->field_name,
    #####:  587:					     fip->field_type,
    #####:  588:					     fip->field_writecount,
    #####:  589:					     fip->field_passcount);
    #####:  590:				goto end;
        -:  591:			}
        -:  592:
    #####:  593:			tv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,
        -:  594:			    "custom tag binary object");
    #####:  595:			if (!tv->value) {
    #####:  596:				status = 0;
    #####:  597:				goto end;
        -:  598:			}
        -:  599:
    #####:  600:			if (fip->field_tag == TIFFTAG_DOTRANGE 
    #####:  601:			    && strcmp(fip->field_name,"DotRange") == 0) {
        -:  602:				/* TODO: This is an evil exception and should not have been
        -:  603:				   handled this way ... likely best if we move it into
        -:  604:				   the directory structure with an explicit field in 
        -:  605:				   libtiff 4.1 and assign it a FIELD_ value */
    #####:  606:				uint16 v2[2];
    #####:  607:				v2[0] = (uint16)va_arg(ap, int);
    #####:  608:				v2[1] = (uint16)va_arg(ap, int);
    #####:  609:				_TIFFmemcpy(tv->value, &v2, 4);
        -:  610:			}
        -:  611:
    #####:  612:			else if (fip->field_passcount
    #####:  613:				  || fip->field_writecount == TIFF_VARIABLE
    #####:  614:				  || fip->field_writecount == TIFF_VARIABLE2
    #####:  615:				  || fip->field_writecount == TIFF_SPP
    #####:  616:				  || tv->count > 1) {
    #####:  617:				_TIFFmemcpy(tv->value, va_arg(ap, void *),
    #####:  618:				    tv->count * tv_size);
        -:  619:			} else {
    #####:  620:				char *val = (char *)tv->value;
    #####:  621:				assert( tv->count == 1 );
        -:  622:
    #####:  623:				switch (fip->field_type) {
    #####:  624:				case TIFF_BYTE:
        -:  625:				case TIFF_UNDEFINED:
        -:  626:					{
    #####:  627:						uint8 v2 = (uint8)va_arg(ap, int);
    #####:  628:						_TIFFmemcpy(val, &v2, tv_size);
        -:  629:					}
        -:  630:					break;
    #####:  631:				case TIFF_SBYTE:
        -:  632:					{
    #####:  633:						int8 v2 = (int8)va_arg(ap, int);
    #####:  634:						_TIFFmemcpy(val, &v2, tv_size);
        -:  635:					}
        -:  636:					break;
    #####:  637:				case TIFF_SHORT:
        -:  638:					{
    #####:  639:						uint16 v2 = (uint16)va_arg(ap, int);
    #####:  640:						_TIFFmemcpy(val, &v2, tv_size);
        -:  641:					}
        -:  642:					break;
    #####:  643:				case TIFF_SSHORT:
        -:  644:					{
    #####:  645:						int16 v2 = (int16)va_arg(ap, int);
    #####:  646:						_TIFFmemcpy(val, &v2, tv_size);
        -:  647:					}
        -:  648:					break;
    #####:  649:				case TIFF_LONG:
        -:  650:				case TIFF_IFD:
        -:  651:					{
    #####:  652:						uint32 v2 = va_arg(ap, uint32);
    #####:  653:						_TIFFmemcpy(val, &v2, tv_size);
        -:  654:					}
        -:  655:					break;
    #####:  656:				case TIFF_SLONG:
        -:  657:					{
    #####:  658:						int32 v2 = va_arg(ap, int32);
    #####:  659:						_TIFFmemcpy(val, &v2, tv_size);
        -:  660:					}
        -:  661:					break;
    #####:  662:				case TIFF_LONG8:
        -:  663:				case TIFF_IFD8:
        -:  664:					{
    #####:  665:						uint64 v2 = va_arg(ap, uint64);
    #####:  666:						_TIFFmemcpy(val, &v2, tv_size);
        -:  667:					}
        -:  668:					break;
    #####:  669:				case TIFF_SLONG8:
        -:  670:					{
    #####:  671:						int64 v2 = va_arg(ap, int64);
    #####:  672:						_TIFFmemcpy(val, &v2, tv_size);
        -:  673:					}
        -:  674:					break;
    #####:  675:				case TIFF_RATIONAL:
        -:  676:				case TIFF_SRATIONAL:
        -:  677:				case TIFF_FLOAT:
        -:  678:					{
    #####:  679:						float v2 = (float)va_arg(ap, double);
    #####:  680:						_TIFFmemcpy(val, &v2, tv_size);
        -:  681:					}
        -:  682:					break;
    #####:  683:				case TIFF_DOUBLE:
        -:  684:					{
    #####:  685:						double v2 = va_arg(ap, double);
    #####:  686:						_TIFFmemcpy(val, &v2, tv_size);
        -:  687:					}
        -:  688:					break;
    #####:  689:				default:
    #####:  690:					_TIFFmemset(val, 0, tv_size);
    #####:  691:					status = 0;
    #####:  692:					break;
        -:  693:				}
        -:  694:			}
        -:  695:		}
        -:  696:	}
        -:  697:	}
       15:  698:	if (status) {
       15:  699:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
       15:  700:		if (fip2)                
      15*:  701:			TIFFSetFieldBit(tif, fip2->field_bit);
       15:  702:		tif->tif_flags |= TIFF_DIRTYDIRECT;
        -:  703:	}
        -:  704:
      15*:  705:end:
       15:  706:	va_end(ap);
       15:  707:	return (status);
    #####:  708:badvalue:
        -:  709:        {
    #####:  710:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  711:		TIFFErrorExt(tif->tif_clientdata, module,
        -:  712:		     "%s: Bad value %u for \"%s\" tag",
        -:  713:		     tif->tif_name, v,
        -:  714:		     fip2 ? fip2->field_name : "Unknown");
    #####:  715:		va_end(ap);
        -:  716:        }
    #####:  717:	return (0);
    #####:  718:badvalue32:
        -:  719:        {
    #####:  720:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  721:		TIFFErrorExt(tif->tif_clientdata, module,
        -:  722:		     "%s: Bad value %u for \"%s\" tag",
        -:  723:		     tif->tif_name, v32,
        -:  724:		     fip2 ? fip2->field_name : "Unknown");
    #####:  725:		va_end(ap);
        -:  726:        }
    #####:  727:	return (0);
    #####:  728:badvaluedouble:
        -:  729:        {
    #####:  730:        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  731:        TIFFErrorExt(tif->tif_clientdata, module,
        -:  732:             "%s: Bad value %f for \"%s\" tag",
        -:  733:             tif->tif_name, dblval,
        -:  734:             fip2 ? fip2->field_name : "Unknown");
    #####:  735:        va_end(ap);
        -:  736:        }
    #####:  737:    return (0);
        -:  738:}
        -:  739:
        -:  740:/*
        -:  741: * Return 1/0 according to whether or not
        -:  742: * it is permissible to set the tag's value.
        -:  743: * Note that we allow ImageLength to be changed
        -:  744: * so that we can append and extend to images.
        -:  745: * Any other tag may not be altered once writing
        -:  746: * has commenced, unless its value has no effect
        -:  747: * on the format of the data that is written.
        -:  748: */
        -:  749:static int
       15:  750:OkToChangeTag(TIFF* tif, uint32 tag)
        -:  751:{
       15:  752:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
       15:  753:	if (!fip) {			/* unknown tag */
    #####:  754:		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField", "%s: Unknown %stag %u",
        -:  755:		    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "", tag);
    #####:  756:		return (0);
        -:  757:	}
      15*:  758:	if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&
    #####:  759:	    !fip->field_oktochange) {
        -:  760:		/*
        -:  761:		 * Consult info table to see if tag can be changed
        -:  762:		 * after we've started writing.  We only allow changes
        -:  763:		 * to those tags that don't/shouldn't affect the
        -:  764:		 * compression and/or format of the data.
        -:  765:		 */
    #####:  766:		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
        -:  767:		    "%s: Cannot modify tag \"%s\" while writing",
        -:  768:		    tif->tif_name, fip->field_name);
    #####:  769:		return (0);
        -:  770:	}
       15:  771:	return (1);
        -:  772:}
        -:  773:
        -:  774:/*
        -:  775: * Record the value of a field in the
        -:  776: * internal directory structure.  The
        -:  777: * field will be written to the file
        -:  778: * when/if the directory structure is
        -:  779: * updated.
        -:  780: */
        -:  781:int
       15:  782:TIFFSetField(TIFF* tif, uint32 tag, ...)
        -:  783:{
       15:  784:	va_list ap;
        -:  785:	int status;
        -:  786:
       15:  787:	va_start(ap, tag);
       15:  788:	status = TIFFVSetField(tif, tag, ap);
       15:  789:	va_end(ap);
       15:  790:	return (status);
        -:  791:}
        -:  792:
        -:  793:/*
        -:  794: * Clear the contents of the field in the internal structure.
        -:  795: */
        -:  796:int
    #####:  797:TIFFUnsetField(TIFF* tif, uint32 tag)
        -:  798:{
    #####:  799:    const TIFFField *fip =  TIFFFieldWithTag(tif, tag);
    #####:  800:    TIFFDirectory* td = &tif->tif_dir;
        -:  801:
    #####:  802:    if( !fip )
    #####:  803:        return 0;
        -:  804:
    #####:  805:    if( fip->field_bit != FIELD_CUSTOM )
    #####:  806:        TIFFClrFieldBit(tif, fip->field_bit);
        -:  807:    else
        -:  808:    {
    #####:  809:        TIFFTagValue *tv = NULL;
        -:  810:        int i;
        -:  811:
    #####:  812:        for (i = 0; i < td->td_customValueCount; i++) {
        -:  813:                
    #####:  814:            tv = td->td_customValues + i;
    #####:  815:            if( tv->info->field_tag == tag )
    #####:  816:                break;
        -:  817:        }
        -:  818:
    #####:  819:        if( i < td->td_customValueCount )
        -:  820:        {
    #####:  821:            _TIFFfree(tv->value);
    #####:  822:            for( ; i < td->td_customValueCount-1; i++) {
    #####:  823:                td->td_customValues[i] = td->td_customValues[i+1];
        -:  824:            }
    #####:  825:            td->td_customValueCount--;
        -:  826:        }
        -:  827:    }
        -:  828:        
    #####:  829:    tif->tif_flags |= TIFF_DIRTYDIRECT;
        -:  830:
    #####:  831:    return (1);
        -:  832:}
        -:  833:
        -:  834:/*
        -:  835: * Like TIFFSetField, but taking a varargs
        -:  836: * parameter list.  This routine is useful
        -:  837: * for building higher-level interfaces on
        -:  838: * top of the library.
        -:  839: */
        -:  840:int
       15:  841:TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
        -:  842:{
       15:  843:	return OkToChangeTag(tif, tag) ?
      15*:  844:	    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;
        -:  845:}
        -:  846:
        -:  847:static int
       11:  848:_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
        -:  849:{
       11:  850:	TIFFDirectory* td = &tif->tif_dir;
       11:  851:	int ret_val = 1;
       11:  852:	uint32 standard_tag = tag;
       11:  853:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
       11:  854:	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */
    #####:  855:	    return 0;
        -:  856:	
       11:  857:        if( tag == TIFFTAG_NUMBEROFINKS )
        -:  858:        {
        -:  859:            int i;
    #####:  860:            for (i = 0; i < td->td_customValueCount; i++) {
        -:  861:                uint16 val;
    #####:  862:                TIFFTagValue *tv = td->td_customValues + i;
    #####:  863:                if (tv->info->field_tag != tag)
    #####:  864:                    continue;
    #####:  865:                val = *(uint16 *)tv->value;
        -:  866:                /* Truncate to SamplesPerPixel, since the */
        -:  867:                /* setting code for INKNAMES assume that there are SamplesPerPixel */
        -:  868:                /* inknames. */
        -:  869:                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */
    #####:  870:                if( val > td->td_samplesperpixel )
        -:  871:                {
    #####:  872:                    TIFFWarningExt(tif->tif_clientdata,"_TIFFVGetField",
        -:  873:                                   "Truncating NumberOfInks from %u to %u",
    #####:  874:                                   val, td->td_samplesperpixel);
    #####:  875:                    val = td->td_samplesperpixel;
        -:  876:                }
    #####:  877:                *va_arg(ap, uint16*) = val;
    #####:  878:                return 1;
        -:  879:            }
    #####:  880:            return 0;
        -:  881:        }
        -:  882:
        -:  883:	/*
        -:  884:	 * We want to force the custom code to be used for custom
        -:  885:	 * fields even if the tag happens to match a well known 
        -:  886:	 * one - important for reinterpreted handling of standard
        -:  887:	 * tag values in custom directories (i.e. EXIF) 
        -:  888:	 */
       11:  889:	if (fip->field_bit == FIELD_CUSTOM) {
    #####:  890:		standard_tag = 0;
        -:  891:	}
        -:  892:
       11:  893:	switch (standard_tag) {
    #####:  894:		case TIFFTAG_SUBFILETYPE:
    #####:  895:			*va_arg(ap, uint32*) = td->td_subfiletype;
    #####:  896:			break;
        1:  897:		case TIFFTAG_IMAGEWIDTH:
        1:  898:			*va_arg(ap, uint32*) = td->td_imagewidth;
        1:  899:			break;
        1:  900:		case TIFFTAG_IMAGELENGTH:
        1:  901:			*va_arg(ap, uint32*) = td->td_imagelength;
        1:  902:			break;
        1:  903:		case TIFFTAG_BITSPERSAMPLE:
        1:  904:			*va_arg(ap, uint16*) = td->td_bitspersample;
        1:  905:			break;
        1:  906:		case TIFFTAG_COMPRESSION:
        1:  907:			*va_arg(ap, uint16*) = td->td_compression;
        1:  908:			break;
        1:  909:		case TIFFTAG_PHOTOMETRIC:
        1:  910:			*va_arg(ap, uint16*) = td->td_photometric;
        1:  911:			break;
    #####:  912:		case TIFFTAG_THRESHHOLDING:
    #####:  913:			*va_arg(ap, uint16*) = td->td_threshholding;
    #####:  914:			break;
    #####:  915:		case TIFFTAG_FILLORDER:
    #####:  916:			*va_arg(ap, uint16*) = td->td_fillorder;
    #####:  917:			break;
    #####:  918:		case TIFFTAG_ORIENTATION:
    #####:  919:			*va_arg(ap, uint16*) = td->td_orientation;
    #####:  920:			break;
    #####:  921:		case TIFFTAG_SAMPLESPERPIXEL:
    #####:  922:			*va_arg(ap, uint16*) = td->td_samplesperpixel;
    #####:  923:			break;
        1:  924:		case TIFFTAG_ROWSPERSTRIP:
        1:  925:			*va_arg(ap, uint32*) = td->td_rowsperstrip;
        1:  926:			break;
    #####:  927:		case TIFFTAG_MINSAMPLEVALUE:
    #####:  928:			*va_arg(ap, uint16*) = td->td_minsamplevalue;
    #####:  929:			break;
    #####:  930:		case TIFFTAG_MAXSAMPLEVALUE:
    #####:  931:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;
    #####:  932:			break;
    #####:  933:		case TIFFTAG_SMINSAMPLEVALUE:
    #####:  934:			if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  935:				*va_arg(ap, double**) = td->td_sminsamplevalue;
        -:  936:			else
        -:  937:			{
        -:  938:				/* libtiff historically treats this as a single value. */
        -:  939:				uint16 i;
    #####:  940:				double v = td->td_sminsamplevalue[0];
    #####:  941:				for (i=1; i < td->td_samplesperpixel; ++i)
    #####:  942:					if( td->td_sminsamplevalue[i] < v )
    #####:  943:						v = td->td_sminsamplevalue[i];
    #####:  944:				*va_arg(ap, double*) = v;
        -:  945:			}
    #####:  946:			break;
    #####:  947:		case TIFFTAG_SMAXSAMPLEVALUE:
    #####:  948:			if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  949:				*va_arg(ap, double**) = td->td_smaxsamplevalue;
        -:  950:			else
        -:  951:			{
        -:  952:				/* libtiff historically treats this as a single value. */
        -:  953:				uint16 i;
    #####:  954:				double v = td->td_smaxsamplevalue[0];
    #####:  955:				for (i=1; i < td->td_samplesperpixel; ++i)
    #####:  956:					if( td->td_smaxsamplevalue[i] > v )
    #####:  957:						v = td->td_smaxsamplevalue[i];
    #####:  958:				*va_arg(ap, double*) = v;
        -:  959:			}
    #####:  960:			break;
        1:  961:		case TIFFTAG_XRESOLUTION:
        1:  962:			*va_arg(ap, float*) = td->td_xresolution;
        1:  963:			break;
        1:  964:		case TIFFTAG_YRESOLUTION:
        1:  965:			*va_arg(ap, float*) = td->td_yresolution;
        1:  966:			break;
        1:  967:		case TIFFTAG_PLANARCONFIG:
        1:  968:			*va_arg(ap, uint16*) = td->td_planarconfig;
        1:  969:			break;
    #####:  970:		case TIFFTAG_XPOSITION:
    #####:  971:			*va_arg(ap, float*) = td->td_xposition;
    #####:  972:			break;
    #####:  973:		case TIFFTAG_YPOSITION:
    #####:  974:			*va_arg(ap, float*) = td->td_yposition;
    #####:  975:			break;
        1:  976:		case TIFFTAG_RESOLUTIONUNIT:
        1:  977:			*va_arg(ap, uint16*) = td->td_resolutionunit;
        1:  978:			break;
    #####:  979:		case TIFFTAG_PAGENUMBER:
    #####:  980:			*va_arg(ap, uint16*) = td->td_pagenumber[0];
    #####:  981:			*va_arg(ap, uint16*) = td->td_pagenumber[1];
    #####:  982:			break;
    #####:  983:		case TIFFTAG_HALFTONEHINTS:
    #####:  984:			*va_arg(ap, uint16*) = td->td_halftonehints[0];
    #####:  985:			*va_arg(ap, uint16*) = td->td_halftonehints[1];
    #####:  986:			break;
    #####:  987:		case TIFFTAG_COLORMAP:
    #####:  988:			*va_arg(ap, uint16**) = td->td_colormap[0];
    #####:  989:			*va_arg(ap, uint16**) = td->td_colormap[1];
    #####:  990:			*va_arg(ap, uint16**) = td->td_colormap[2];
    #####:  991:			break;
    #####:  992:		case TIFFTAG_STRIPOFFSETS:
        -:  993:		case TIFFTAG_TILEOFFSETS:
    #####:  994:			_TIFFFillStriles( tif );
    #####:  995:			*va_arg(ap, uint64**) = td->td_stripoffset;
    #####:  996:			break;
    #####:  997:		case TIFFTAG_STRIPBYTECOUNTS:
        -:  998:		case TIFFTAG_TILEBYTECOUNTS:
    #####:  999:			_TIFFFillStriles( tif );
    #####: 1000:			*va_arg(ap, uint64**) = td->td_stripbytecount;
    #####: 1001:			break;
    #####: 1002:		case TIFFTAG_MATTEING:
    #####: 1003:			*va_arg(ap, uint16*) =
    #####: 1004:			    (td->td_extrasamples == 1 &&
    #####: 1005:			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
    #####: 1006:			break;
        1: 1007:		case TIFFTAG_EXTRASAMPLES:
        1: 1008:			*va_arg(ap, uint16*) = td->td_extrasamples;
        1: 1009:			*va_arg(ap, uint16**) = td->td_sampleinfo;
        1: 1010:			break;
    #####: 1011:		case TIFFTAG_TILEWIDTH:
    #####: 1012:			*va_arg(ap, uint32*) = td->td_tilewidth;
    #####: 1013:			break;
    #####: 1014:		case TIFFTAG_TILELENGTH:
    #####: 1015:			*va_arg(ap, uint32*) = td->td_tilelength;
    #####: 1016:			break;
    #####: 1017:		case TIFFTAG_TILEDEPTH:
    #####: 1018:			*va_arg(ap, uint32*) = td->td_tiledepth;
    #####: 1019:			break;
    #####: 1020:		case TIFFTAG_DATATYPE:
    #####: 1021:			switch (td->td_sampleformat) {
    #####: 1022:				case SAMPLEFORMAT_UINT:
    #####: 1023:					*va_arg(ap, uint16*) = DATATYPE_UINT;
    #####: 1024:					break;
    #####: 1025:				case SAMPLEFORMAT_INT:
    #####: 1026:					*va_arg(ap, uint16*) = DATATYPE_INT;
    #####: 1027:					break;
    #####: 1028:				case SAMPLEFORMAT_IEEEFP:
    #####: 1029:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
    #####: 1030:					break;
    #####: 1031:				case SAMPLEFORMAT_VOID:
    #####: 1032:					*va_arg(ap, uint16*) = DATATYPE_VOID;
    #####: 1033:					break;
        -: 1034:			}
    #####: 1035:			break;
    #####: 1036:		case TIFFTAG_SAMPLEFORMAT:
    #####: 1037:			*va_arg(ap, uint16*) = td->td_sampleformat;
    #####: 1038:			break;
    #####: 1039:		case TIFFTAG_IMAGEDEPTH:
    #####: 1040:			*va_arg(ap, uint32*) = td->td_imagedepth;
    #####: 1041:			break;
    #####: 1042:		case TIFFTAG_SUBIFD:
    #####: 1043:			*va_arg(ap, uint16*) = td->td_nsubifd;
    #####: 1044:			*va_arg(ap, uint64**) = td->td_subifd;
    #####: 1045:			break;
    #####: 1046:		case TIFFTAG_YCBCRPOSITIONING:
    #####: 1047:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
    #####: 1048:			break;
    #####: 1049:		case TIFFTAG_YCBCRSUBSAMPLING:
    #####: 1050:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
    #####: 1051:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
    #####: 1052:			break;
    #####: 1053:		case TIFFTAG_TRANSFERFUNCTION:
    #####: 1054:			*va_arg(ap, uint16**) = td->td_transferfunction[0];
    #####: 1055:			if (td->td_samplesperpixel - td->td_extrasamples > 1) {
    #####: 1056:				*va_arg(ap, uint16**) = td->td_transferfunction[1];
    #####: 1057:				*va_arg(ap, uint16**) = td->td_transferfunction[2];
        -: 1058:			}
    #####: 1059:			break;
    #####: 1060:		case TIFFTAG_REFERENCEBLACKWHITE:
    #####: 1061:			*va_arg(ap, float**) = td->td_refblackwhite;
    #####: 1062:			break;
    #####: 1063:		case TIFFTAG_INKNAMES:
    #####: 1064:			*va_arg(ap, char**) = td->td_inknames;
    #####: 1065:			break;
    #####: 1066:		default:
        -: 1067:			{
        -: 1068:				int i;
        -: 1069:
        -: 1070:				/*
        -: 1071:				 * This can happen if multiple images are open
        -: 1072:				 * with different codecs which have private
        -: 1073:				 * tags.  The global tag information table may
        -: 1074:				 * then have tags that are valid for one file
        -: 1075:				 * but not the other. If the client tries to
        -: 1076:				 * get a tag that is not valid for the image's
        -: 1077:				 * codec then we'll arrive here.
        -: 1078:				 */
    #####: 1079:				if( fip->field_bit != FIELD_CUSTOM )
        -: 1080:				{
    #####: 1081:					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
        -: 1082:					    "%s: Invalid %stag \"%s\" "
        -: 1083:					    "(not supported by codec)",
        -: 1084:					    tif->tif_name,
        -: 1085:					    isPseudoTag(tag) ? "pseudo-" : "",
        -: 1086:					    fip->field_name);
    #####: 1087:					ret_val = 0;
    #####: 1088:					break;
        -: 1089:				}
        -: 1090:
        -: 1091:				/*
        -: 1092:				 * Do we have a custom value?
        -: 1093:				 */
    #####: 1094:				ret_val = 0;
    #####: 1095:				for (i = 0; i < td->td_customValueCount; i++) {
    #####: 1096:					TIFFTagValue *tv = td->td_customValues + i;
        -: 1097:
    #####: 1098:					if (tv->info->field_tag != tag)
    #####: 1099:						continue;
        -: 1100:
    #####: 1101:					if (fip->field_passcount) {
    #####: 1102:						if (fip->field_readcount == TIFF_VARIABLE2)
    #####: 1103:							*va_arg(ap, uint32*) = (uint32)tv->count;
        -: 1104:						else  /* Assume TIFF_VARIABLE */
    #####: 1105:							*va_arg(ap, uint16*) = (uint16)tv->count;
    #####: 1106:						*va_arg(ap, void **) = tv->value;
    #####: 1107:						ret_val = 1;
    #####: 1108:					} else if (fip->field_tag == TIFFTAG_DOTRANGE
    #####: 1109:						   && strcmp(fip->field_name,"DotRange") == 0) {
        -: 1110:						/* TODO: This is an evil exception and should not have been
        -: 1111:						   handled this way ... likely best if we move it into
        -: 1112:						   the directory structure with an explicit field in 
        -: 1113:						   libtiff 4.1 and assign it a FIELD_ value */
    #####: 1114:						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
    #####: 1115:						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
    #####: 1116:						ret_val = 1;
        -: 1117:					} else {
    #####: 1118:						if (fip->field_type == TIFF_ASCII
    #####: 1119:						    || fip->field_readcount == TIFF_VARIABLE
    #####: 1120:						    || fip->field_readcount == TIFF_VARIABLE2
    #####: 1121:						    || fip->field_readcount == TIFF_SPP
    #####: 1122:						    || tv->count > 1) {
    #####: 1123:							*va_arg(ap, void **) = tv->value;
    #####: 1124:							ret_val = 1;
        -: 1125:						} else {
    #####: 1126:							char *val = (char *)tv->value;
    #####: 1127:							assert( tv->count == 1 );
    #####: 1128:							switch (fip->field_type) {
    #####: 1129:							case TIFF_BYTE:
        -: 1130:							case TIFF_UNDEFINED:
    #####: 1131:								*va_arg(ap, uint8*) =
    #####: 1132:									*(uint8 *)val;
    #####: 1133:								ret_val = 1;
    #####: 1134:								break;
    #####: 1135:							case TIFF_SBYTE:
    #####: 1136:								*va_arg(ap, int8*) =
    #####: 1137:									*(int8 *)val;
    #####: 1138:								ret_val = 1;
    #####: 1139:								break;
    #####: 1140:							case TIFF_SHORT:
    #####: 1141:								*va_arg(ap, uint16*) =
    #####: 1142:									*(uint16 *)val;
    #####: 1143:								ret_val = 1;
    #####: 1144:								break;
    #####: 1145:							case TIFF_SSHORT:
    #####: 1146:								*va_arg(ap, int16*) =
    #####: 1147:									*(int16 *)val;
    #####: 1148:								ret_val = 1;
    #####: 1149:								break;
    #####: 1150:							case TIFF_LONG:
        -: 1151:							case TIFF_IFD:
    #####: 1152:								*va_arg(ap, uint32*) =
    #####: 1153:									*(uint32 *)val;
    #####: 1154:								ret_val = 1;
    #####: 1155:								break;
    #####: 1156:							case TIFF_SLONG:
    #####: 1157:								*va_arg(ap, int32*) =
    #####: 1158:									*(int32 *)val;
    #####: 1159:								ret_val = 1;
    #####: 1160:								break;
    #####: 1161:							case TIFF_LONG8:
        -: 1162:							case TIFF_IFD8:
    #####: 1163:								*va_arg(ap, uint64*) =
    #####: 1164:									*(uint64 *)val;
    #####: 1165:								ret_val = 1;
    #####: 1166:								break;
    #####: 1167:							case TIFF_SLONG8:
    #####: 1168:								*va_arg(ap, int64*) =
    #####: 1169:									*(int64 *)val;
    #####: 1170:								ret_val = 1;
    #####: 1171:								break;
    #####: 1172:							case TIFF_RATIONAL:
        -: 1173:							case TIFF_SRATIONAL:
        -: 1174:							case TIFF_FLOAT:
    #####: 1175:								*va_arg(ap, float*) =
    #####: 1176:									*(float *)val;
    #####: 1177:								ret_val = 1;
    #####: 1178:								break;
    #####: 1179:							case TIFF_DOUBLE:
    #####: 1180:								*va_arg(ap, double*) =
    #####: 1181:									*(double *)val;
    #####: 1182:								ret_val = 1;
    #####: 1183:								break;
    #####: 1184:							default:
    #####: 1185:								ret_val = 0;
    #####: 1186:								break;
        -: 1187:							}
        -: 1188:						}
        -: 1189:					}
    #####: 1190:					break;
        -: 1191:				}
        -: 1192:			}
        -: 1193:	}
       11: 1194:	return(ret_val);
        -: 1195:}
        -: 1196:
        -: 1197:/*
        -: 1198: * Return the value of a field in the
        -: 1199: * internal directory structure.
        -: 1200: */
        -: 1201:int
        8: 1202:TIFFGetField(TIFF* tif, uint32 tag, ...)
        -: 1203:{
        -: 1204:	int status;
        8: 1205:	va_list ap;
        -: 1206:
        8: 1207:	va_start(ap, tag);
        8: 1208:	status = TIFFVGetField(tif, tag, ap);
        8: 1209:	va_end(ap);
        8: 1210:	return (status);
        -: 1211:}
        -: 1212:
        -: 1213:/*
        -: 1214: * Like TIFFGetField, but taking a varargs
        -: 1215: * parameter list.  This routine is useful
        -: 1216: * for building higher-level interfaces on
        -: 1217: * top of the library.
        -: 1218: */
        -: 1219:int
       14: 1220:TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
        -: 1221:{
       14: 1222:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
      14*: 1223:	return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?
       28: 1224:	    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);
        -: 1225:}
        -: 1226:
        -: 1227:#define	CleanupField(member) {		\
        -: 1228:    if (td->member) {			\
        -: 1229:	_TIFFfree(td->member);		\
        -: 1230:	td->member = 0;			\
        -: 1231:    }					\
        -: 1232:}
        -: 1233:
        -: 1234:/*
        -: 1235: * Release storage associated with a directory.
        -: 1236: */
        -: 1237:void
        1: 1238:TIFFFreeDirectory(TIFF* tif)
        -: 1239:{
        1: 1240:	TIFFDirectory *td = &tif->tif_dir;
        -: 1241:	int            i;
        -: 1242:
        1: 1243:	_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);
       1*: 1244:	CleanupField(td_sminsamplevalue);
       1*: 1245:	CleanupField(td_smaxsamplevalue);
       1*: 1246:	CleanupField(td_colormap[0]);
       1*: 1247:	CleanupField(td_colormap[1]);
       1*: 1248:	CleanupField(td_colormap[2]);
       1*: 1249:	CleanupField(td_sampleinfo);
       1*: 1250:	CleanupField(td_subifd);
       1*: 1251:	CleanupField(td_inknames);
       1*: 1252:	CleanupField(td_refblackwhite);
       1*: 1253:	CleanupField(td_transferfunction[0]);
       1*: 1254:	CleanupField(td_transferfunction[1]);
       1*: 1255:	CleanupField(td_transferfunction[2]);
       1*: 1256:	CleanupField(td_stripoffset);
       1*: 1257:	CleanupField(td_stripbytecount);
        1: 1258:	TIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);
        1: 1259:	TIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);
        -: 1260:
        -: 1261:	/* Cleanup custom tag values */
       1*: 1262:	for( i = 0; i < td->td_customValueCount; i++ ) {
    #####: 1263:		if (td->td_customValues[i].value)
    #####: 1264:			_TIFFfree(td->td_customValues[i].value);
        -: 1265:	}
        -: 1266:
        1: 1267:	td->td_customValueCount = 0;
       1*: 1268:	CleanupField(td_customValues);
        -: 1269:
        -: 1270:#if defined(DEFER_STRILE_LOAD)
        -: 1271:        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));
        -: 1272:        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));
        -: 1273:#endif        
        1: 1274:}
        -: 1275:#undef CleanupField
        -: 1276:
        -: 1277:/*
        -: 1278: * Client Tag extension support (from Niles Ritter).
        -: 1279: */
        -: 1280:static TIFFExtendProc _TIFFextender = (TIFFExtendProc) NULL;
        -: 1281:
        -: 1282:TIFFExtendProc
    #####: 1283:TIFFSetTagExtender(TIFFExtendProc extender)
        -: 1284:{
    #####: 1285:	TIFFExtendProc prev = _TIFFextender;
    #####: 1286:	_TIFFextender = extender;
    #####: 1287:	return (prev);
        -: 1288:}
        -: 1289:
        -: 1290:/*
        -: 1291: * Setup for a new directory.  Should we automatically call
        -: 1292: * TIFFWriteDirectory() if the current one is dirty?
        -: 1293: *
        -: 1294: * The newly created directory will not exist on the file till
        -: 1295: * TIFFWriteDirectory(), TIFFFlush() or TIFFClose() is called.
        -: 1296: */
        -: 1297:int
    #####: 1298:TIFFCreateDirectory(TIFF* tif)
        -: 1299:{
    #####: 1300:	TIFFDefaultDirectory(tif);
    #####: 1301:	tif->tif_diroff = 0;
    #####: 1302:	tif->tif_nextdiroff = 0;
    #####: 1303:	tif->tif_curoff = 0;
    #####: 1304:	tif->tif_row = (uint32) -1;
    #####: 1305:	tif->tif_curstrip = (uint32) -1;
        -: 1306:
    #####: 1307:	return 0;
        -: 1308:}
        -: 1309:
        -: 1310:int
    #####: 1311:TIFFCreateCustomDirectory(TIFF* tif, const TIFFFieldArray* infoarray)
        -: 1312:{
    #####: 1313:	TIFFDefaultDirectory(tif);
        -: 1314:
        -: 1315:	/*
        -: 1316:	 * Reset the field definitions to match the application provided list. 
        -: 1317:	 * Hopefully TIFFDefaultDirectory() won't have done anything irreversable
        -: 1318:	 * based on it's assumption this is an image directory.
        -: 1319:	 */
    #####: 1320:	_TIFFSetupFields(tif, infoarray);
        -: 1321:
    #####: 1322:	tif->tif_diroff = 0;
    #####: 1323:	tif->tif_nextdiroff = 0;
    #####: 1324:	tif->tif_curoff = 0;
    #####: 1325:	tif->tif_row = (uint32) -1;
    #####: 1326:	tif->tif_curstrip = (uint32) -1;
        -: 1327:
    #####: 1328:	return 0;
        -: 1329:}
        -: 1330:
        -: 1331:int
    #####: 1332:TIFFCreateEXIFDirectory(TIFF* tif)
        -: 1333:{
        -: 1334:	const TIFFFieldArray* exifFieldArray;
    #####: 1335:	exifFieldArray = _TIFFGetExifFields();
    #####: 1336:	return TIFFCreateCustomDirectory(tif, exifFieldArray);
        -: 1337:}
        -: 1338:
        -: 1339:/*
        -: 1340: * Setup a default directory structure.
        -: 1341: */
        -: 1342:int
        1: 1343:TIFFDefaultDirectory(TIFF* tif)
        -: 1344:{
        1: 1345:	register TIFFDirectory* td = &tif->tif_dir;
        -: 1346:	const TIFFFieldArray* tiffFieldArray;
        -: 1347:
        1: 1348:	tiffFieldArray = _TIFFGetFields();
        1: 1349:	_TIFFSetupFields(tif, tiffFieldArray);   
        -: 1350:
        1: 1351:	_TIFFmemset(td, 0, sizeof (*td));
        1: 1352:	td->td_fillorder = FILLORDER_MSB2LSB;
        1: 1353:	td->td_bitspersample = 1;
        1: 1354:	td->td_threshholding = THRESHHOLD_BILEVEL;
        1: 1355:	td->td_orientation = ORIENTATION_TOPLEFT;
        1: 1356:	td->td_samplesperpixel = 1;
        1: 1357:	td->td_rowsperstrip = (uint32) -1;
        1: 1358:	td->td_tilewidth = 0;
        1: 1359:	td->td_tilelength = 0;
        1: 1360:	td->td_tiledepth = 1;
        1: 1361:	td->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  
        1: 1362:	td->td_resolutionunit = RESUNIT_INCH;
        1: 1363:	td->td_sampleformat = SAMPLEFORMAT_UINT;
        1: 1364:	td->td_imagedepth = 1;
        1: 1365:	td->td_ycbcrsubsampling[0] = 2;
        1: 1366:	td->td_ycbcrsubsampling[1] = 2;
        1: 1367:	td->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;
        1: 1368:	tif->tif_postdecode = _TIFFNoPostDecode;  
        1: 1369:	tif->tif_foundfield = NULL;
        1: 1370:	tif->tif_tagmethods.vsetfield = _TIFFVSetField;  
        1: 1371:	tif->tif_tagmethods.vgetfield = _TIFFVGetField;
        1: 1372:	tif->tif_tagmethods.printdir = NULL;
        -: 1373:	/*
        -: 1374:	 *  Give client code a chance to install their own
        -: 1375:	 *  tag extensions & methods, prior to compression overloads,
        -: 1376:	 *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)
        -: 1377:	 */
        1: 1378:	if (tif->tif_nfieldscompat > 0) {
        -: 1379:		uint32 i;
        -: 1380:
    #####: 1381:		for (i = 0; i < tif->tif_nfieldscompat; i++) {
    #####: 1382:				if (tif->tif_fieldscompat[i].allocated_size)
    #####: 1383:						_TIFFfree(tif->tif_fieldscompat[i].fields);
        -: 1384:		}
    #####: 1385:		_TIFFfree(tif->tif_fieldscompat);
    #####: 1386:		tif->tif_nfieldscompat = 0;
    #####: 1387:		tif->tif_fieldscompat = NULL;
        -: 1388:	}
        1: 1389:	if (_TIFFextender)
    #####: 1390:		(*_TIFFextender)(tif);
        1: 1391:	(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
        -: 1392:	/*
        -: 1393:	 * NB: The directory is marked dirty as a result of setting
        -: 1394:	 * up the default compression scheme.  However, this really
        -: 1395:	 * isn't correct -- we want TIFF_DIRTYDIRECT to be set only
        -: 1396:	 * if the user does something.  We could just do the setup
        -: 1397:	 * by hand, but it seems better to use the normal mechanism
        -: 1398:	 * (i.e. TIFFSetField).
        -: 1399:	 */
        1: 1400:	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
        -: 1401:
        -: 1402:	/*
        -: 1403:	 * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19
        -: 1404:	 * we clear the ISTILED flag when setting up a new directory.
        -: 1405:	 * Should we also be clearing stuff like INSUBIFD?
        -: 1406:	 */
        1: 1407:	tif->tif_flags &= ~TIFF_ISTILED;
        -: 1408:
        1: 1409:	return (1);
        -: 1410:}
        -: 1411:
        -: 1412:static int
    #####: 1413:TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
        -: 1414:{
        -: 1415:	static const char module[] = "TIFFAdvanceDirectory";
    #####: 1416:	if (isMapped(tif))
        -: 1417:	{
    #####: 1418:		uint64 poff=*nextdir;
    #####: 1419:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1420:		{
        -: 1421:			tmsize_t poffa,poffb,poffc,poffd;
    #####: 1422:			uint16 dircount;
    #####: 1423:			uint32 nextdir32;
    #####: 1424:			poffa=(tmsize_t)poff;
    #####: 1425:			poffb=poffa+sizeof(uint16);
    #####: 1426:			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))
        -: 1427:			{
    #####: 1428:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
    #####: 1429:                                  *nextdir=0;
    #####: 1430:				return(0);
        -: 1431:			}
    #####: 1432:			_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));
    #####: 1433:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1434:				TIFFSwabShort(&dircount);
    #####: 1435:			poffc=poffb+dircount*12;
    #####: 1436:			poffd=poffc+sizeof(uint32);
    #####: 1437:			if ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))
        -: 1438:			{
    #####: 1439:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
    #####: 1440:				return(0);
        -: 1441:			}
    #####: 1442:			if (off!=NULL)
    #####: 1443:				*off=(uint64)poffc;
    #####: 1444:			_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));
    #####: 1445:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1446:				TIFFSwabLong(&nextdir32);
    #####: 1447:			*nextdir=nextdir32;
        -: 1448:		}
        -: 1449:		else
        -: 1450:		{
        -: 1451:			tmsize_t poffa,poffb,poffc,poffd;
    #####: 1452:			uint64 dircount64;
        -: 1453:			uint16 dircount16;
    #####: 1454:			poffa=(tmsize_t)poff;
    #####: 1455:			poffb=poffa+sizeof(uint64);
    #####: 1456:			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))
        -: 1457:			{
    #####: 1458:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
    #####: 1459:				return(0);
        -: 1460:			}
    #####: 1461:			_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));
    #####: 1462:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1463:				TIFFSwabLong8(&dircount64);
    #####: 1464:			if (dircount64>0xFFFF)
        -: 1465:			{
    #####: 1466:				TIFFErrorExt(tif->tif_clientdata,module,"Sanity check on directory count failed");
    #####: 1467:				return(0);
        -: 1468:			}
    #####: 1469:			dircount16=(uint16)dircount64;
    #####: 1470:			poffc=poffb+dircount16*20;
    #####: 1471:			poffd=poffc+sizeof(uint64);
    #####: 1472:			if ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))
        -: 1473:			{
    #####: 1474:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
    #####: 1475:				return(0);
        -: 1476:			}
    #####: 1477:			if (off!=NULL)
    #####: 1478:				*off=(uint64)poffc;
    #####: 1479:			_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));
    #####: 1480:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1481:				TIFFSwabLong8(nextdir);
        -: 1482:		}
    #####: 1483:		return(1);
        -: 1484:	}
        -: 1485:	else
        -: 1486:	{
    #####: 1487:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1488:		{
    #####: 1489:			uint16 dircount;
    #####: 1490:			uint32 nextdir32;
    #####: 1491:			if (!SeekOK(tif, *nextdir) ||
    #####: 1492:			    !ReadOK(tif, &dircount, sizeof (uint16))) {
    #####: 1493:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
        -: 1494:				    tif->tif_name);
    #####: 1495:				return (0);
        -: 1496:			}
    #####: 1497:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1498:				TIFFSwabShort(&dircount);
    #####: 1499:			if (off != NULL)
    #####: 1500:				*off = TIFFSeekFile(tif,
        -: 1501:				    dircount*12, SEEK_CUR);
        -: 1502:			else
    #####: 1503:				(void) TIFFSeekFile(tif,
        -: 1504:				    dircount*12, SEEK_CUR);
    #####: 1505:			if (!ReadOK(tif, &nextdir32, sizeof (uint32))) {
    #####: 1506:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory link",
        -: 1507:				    tif->tif_name);
    #####: 1508:				return (0);
        -: 1509:			}
    #####: 1510:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1511:				TIFFSwabLong(&nextdir32);
    #####: 1512:			*nextdir=nextdir32;
        -: 1513:		}
        -: 1514:		else
        -: 1515:		{
    #####: 1516:			uint64 dircount64;
        -: 1517:			uint16 dircount16;
    #####: 1518:			if (!SeekOK(tif, *nextdir) ||
    #####: 1519:			    !ReadOK(tif, &dircount64, sizeof (uint64))) {
    #####: 1520:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
        -: 1521:				    tif->tif_name);
    #####: 1522:				return (0);
        -: 1523:			}
    #####: 1524:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1525:				TIFFSwabLong8(&dircount64);
    #####: 1526:			if (dircount64>0xFFFF)
        -: 1527:			{
    #####: 1528:				TIFFErrorExt(tif->tif_clientdata, module, "Error fetching directory count");
    #####: 1529:				return(0);
        -: 1530:			}
    #####: 1531:			dircount16 = (uint16)dircount64;
    #####: 1532:			if (off != NULL)
    #####: 1533:				*off = TIFFSeekFile(tif,
        -: 1534:				    dircount16*20, SEEK_CUR);
        -: 1535:			else
    #####: 1536:				(void) TIFFSeekFile(tif,
        -: 1537:				    dircount16*20, SEEK_CUR);
    #####: 1538:			if (!ReadOK(tif, nextdir, sizeof (uint64))) {
    #####: 1539:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 1540:                                             "%s: Error fetching directory link",
        -: 1541:				    tif->tif_name);
    #####: 1542:				return (0);
        -: 1543:			}
    #####: 1544:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1545:				TIFFSwabLong8(nextdir);
        -: 1546:		}
    #####: 1547:		return (1);
        -: 1548:	}
        -: 1549:}
        -: 1550:
        -: 1551:/*
        -: 1552: * Count the number of directories in a file.
        -: 1553: */
        -: 1554:uint16
    #####: 1555:TIFFNumberOfDirectories(TIFF* tif)
        -: 1556:{
        -: 1557:	static const char module[] = "TIFFNumberOfDirectories";
    #####: 1558:	uint64 nextdir;
        -: 1559:	uint16 n;
    #####: 1560:	if (!(tif->tif_flags&TIFF_BIGTIFF))
    #####: 1561:		nextdir = tif->tif_header.classic.tiff_diroff;
        -: 1562:	else
    #####: 1563:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1564:	n = 0;
    #####: 1565:	while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))
        -: 1566:        {
    #####: 1567:                if (n != 65535) {
    #####: 1568:                        ++n;
        -: 1569:                }
        -: 1570:		else
        -: 1571:                {
    #####: 1572:                        TIFFErrorExt(tif->tif_clientdata, module,
        -: 1573:                                     "Directory count exceeded 65535 limit,"
        -: 1574:                                     " giving up on counting.");
    #####: 1575:                        return (65535);
        -: 1576:                }
        -: 1577:        }
    #####: 1578:	return (n);
        -: 1579:}
        -: 1580:
        -: 1581:/*
        -: 1582: * Set the n-th directory as the current directory.
        -: 1583: * NB: Directories are numbered starting at 0.
        -: 1584: */
        -: 1585:int
    #####: 1586:TIFFSetDirectory(TIFF* tif, uint16 dirn)
        -: 1587:{
    #####: 1588:	uint64 nextdir;
        -: 1589:	uint16 n;
        -: 1590:
    #####: 1591:	if (!(tif->tif_flags&TIFF_BIGTIFF))
    #####: 1592:		nextdir = tif->tif_header.classic.tiff_diroff;
        -: 1593:	else
    #####: 1594:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1595:	for (n = dirn; n > 0 && nextdir != 0; n--)
    #####: 1596:		if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
    #####: 1597:			return (0);
    #####: 1598:	tif->tif_nextdiroff = nextdir;
        -: 1599:	/*
        -: 1600:	 * Set curdir to the actual directory index.  The
        -: 1601:	 * -1 is because TIFFReadDirectory will increment
        -: 1602:	 * tif_curdir after successfully reading the directory.
        -: 1603:	 */
    #####: 1604:	tif->tif_curdir = (dirn - n) - 1;
        -: 1605:	/*
        -: 1606:	 * Reset tif_dirnumber counter and start new list of seen directories.
        -: 1607:	 * We need this to prevent IFD loops.
        -: 1608:	 */
    #####: 1609:	tif->tif_dirnumber = 0;
    #####: 1610:	return (TIFFReadDirectory(tif));
        -: 1611:}
        -: 1612:
        -: 1613:/*
        -: 1614: * Set the current directory to be the directory
        -: 1615: * located at the specified file offset.  This interface
        -: 1616: * is used mainly to access directories linked with
        -: 1617: * the SubIFD tag (e.g. thumbnail images).
        -: 1618: */
        -: 1619:int
    #####: 1620:TIFFSetSubDirectory(TIFF* tif, uint64 diroff)
        -: 1621:{
    #####: 1622:	tif->tif_nextdiroff = diroff;
        -: 1623:	/*
        -: 1624:	 * Reset tif_dirnumber counter and start new list of seen directories.
        -: 1625:	 * We need this to prevent IFD loops.
        -: 1626:	 */
    #####: 1627:	tif->tif_dirnumber = 0;
    #####: 1628:	return (TIFFReadDirectory(tif));
        -: 1629:}
        -: 1630:
        -: 1631:/*
        -: 1632: * Return file offset of the current directory.
        -: 1633: */
        -: 1634:uint64
    #####: 1635:TIFFCurrentDirOffset(TIFF* tif)
        -: 1636:{
    #####: 1637:	return (tif->tif_diroff);
        -: 1638:}
        -: 1639:
        -: 1640:/*
        -: 1641: * Return an indication of whether or not we are
        -: 1642: * at the last directory in the file.
        -: 1643: */
        -: 1644:int
    #####: 1645:TIFFLastDirectory(TIFF* tif)
        -: 1646:{
    #####: 1647:	return (tif->tif_nextdiroff == 0);
        -: 1648:}
        -: 1649:
        -: 1650:/*
        -: 1651: * Unlink the specified directory from the directory chain.
        -: 1652: */
        -: 1653:int
    #####: 1654:TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
        -: 1655:{
        -: 1656:	static const char module[] = "TIFFUnlinkDirectory";
    #####: 1657:	uint64 nextdir;
    #####: 1658:	uint64 off;
        -: 1659:	uint16 n;
        -: 1660:
    #####: 1661:	if (tif->tif_mode == O_RDONLY) {
    #####: 1662:		TIFFErrorExt(tif->tif_clientdata, module,
        -: 1663:                             "Can not unlink directory in read-only file");
    #####: 1664:		return (0);
        -: 1665:	}
        -: 1666:	/*
        -: 1667:	 * Go to the directory before the one we want
        -: 1668:	 * to unlink and nab the offset of the link
        -: 1669:	 * field we'll need to patch.
        -: 1670:	 */
    #####: 1671:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1672:	{
    #####: 1673:		nextdir = tif->tif_header.classic.tiff_diroff;
    #####: 1674:		off = 4;
        -: 1675:	}
        -: 1676:	else
        -: 1677:	{
    #####: 1678:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1679:		off = 8;
        -: 1680:	}
    #####: 1681:	for (n = dirn-1; n > 0; n--) {
    #####: 1682:		if (nextdir == 0) {
    #####: 1683:			TIFFErrorExt(tif->tif_clientdata, module, "Directory %d does not exist", dirn);
    #####: 1684:			return (0);
        -: 1685:		}
    #####: 1686:		if (!TIFFAdvanceDirectory(tif, &nextdir, &off))
    #####: 1687:			return (0);
        -: 1688:	}
        -: 1689:	/*
        -: 1690:	 * Advance to the directory to be unlinked and fetch
        -: 1691:	 * the offset of the directory that follows.
        -: 1692:	 */
    #####: 1693:	if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
    #####: 1694:		return (0);
        -: 1695:	/*
        -: 1696:	 * Go back and patch the link field of the preceding
        -: 1697:	 * directory to point to the offset of the directory
        -: 1698:	 * that follows.
        -: 1699:	 */
    #####: 1700:	(void) TIFFSeekFile(tif, off, SEEK_SET);
    #####: 1701:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1702:	{
    #####: 1703:		uint32 nextdir32;
    #####: 1704:		nextdir32=(uint32)nextdir;
    #####: 1705:		assert((uint64)nextdir32==nextdir);
    #####: 1706:		if (tif->tif_flags & TIFF_SWAB)
    #####: 1707:			TIFFSwabLong(&nextdir32);
    #####: 1708:		if (!WriteOK(tif, &nextdir32, sizeof (uint32))) {
    #####: 1709:			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
    #####: 1710:			return (0);
        -: 1711:		}
        -: 1712:	}
        -: 1713:	else
        -: 1714:	{
    #####: 1715:		if (tif->tif_flags & TIFF_SWAB)
    #####: 1716:			TIFFSwabLong8(&nextdir);
    #####: 1717:		if (!WriteOK(tif, &nextdir, sizeof (uint64))) {
    #####: 1718:			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
    #####: 1719:			return (0);
        -: 1720:		}
        -: 1721:	}
        -: 1722:	/*
        -: 1723:	 * Leave directory state setup safely.  We don't have
        -: 1724:	 * facilities for doing inserting and removing directories,
        -: 1725:	 * so it's safest to just invalidate everything.  This
        -: 1726:	 * means that the caller can only append to the directory
        -: 1727:	 * chain.
        -: 1728:	 */
    #####: 1729:	(*tif->tif_cleanup)(tif);
    #####: 1730:	if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {
    #####: 1731:		_TIFFfree(tif->tif_rawdata);
    #####: 1732:		tif->tif_rawdata = NULL;
    #####: 1733:		tif->tif_rawcc = 0;
    #####: 1734:                tif->tif_rawdataoff = 0;
    #####: 1735:                tif->tif_rawdataloaded = 0;
        -: 1736:	}
    #####: 1737:	tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE|TIFF_BUF4WRITE);
    #####: 1738:	TIFFFreeDirectory(tif);
    #####: 1739:	TIFFDefaultDirectory(tif);
    #####: 1740:	tif->tif_diroff = 0;			/* force link on next write */
    #####: 1741:	tif->tif_nextdiroff = 0;		/* next write must be at end */
    #####: 1742:	tif->tif_curoff = 0;
    #####: 1743:	tif->tif_row = (uint32) -1;
    #####: 1744:	tif->tif_curstrip = (uint32) -1;
    #####: 1745:	return (1);
        -: 1746:}
        -: 1747:
        -: 1748:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 1749:/*
        -: 1750: * Local Variables:
        -: 1751: * mode: c
        -: 1752: * c-basic-offset: 8
        -: 1753: * fill-column: 78
        -: 1754: * End:
        -: 1755: */
