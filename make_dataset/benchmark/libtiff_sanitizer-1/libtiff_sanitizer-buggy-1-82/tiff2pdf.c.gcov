        -:    0:Source:tiff2pdf.c
        -:    1:/* $Id$
        -:    2: *
        -:    3: * tiff2pdf - converts a TIFF image to a PDF document
        -:    4: *
        -:    5: * Copyright (c) 2003 Ross Finlayson
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the name of
        -:   11: * Ross Finlayson may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Ross Finlayson.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL ROSS FINLAYSON BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tif_config.h"
        -:   28:
        -:   29:#include <stdio.h>
        -:   30:#include <stdlib.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:#include <time.h>
        -:   34:#include <errno.h>
        -:   35:#include <limits.h>
        -:   36:
        -:   37:#if HAVE_UNISTD_H
        -:   38:# include <unistd.h>
        -:   39:#endif
        -:   40:
        -:   41:#ifdef HAVE_FCNTL_H
        -:   42:# include <fcntl.h>
        -:   43:#endif
        -:   44:
        -:   45:#ifdef HAVE_IO_H
        -:   46:# include <io.h>
        -:   47:#endif
        -:   48:
        -:   49:#ifdef NEED_LIBPORT
        -:   50:# include "libport.h"
        -:   51:#endif
        -:   52:
        -:   53:#include "tiffiop.h"
        -:   54:#include "tiffio.h"
        -:   55:
        -:   56:#ifndef HAVE_GETOPT
        -:   57:extern int getopt(int, char**, char*);
        -:   58:#endif
        -:   59:
        -:   60:#ifndef EXIT_SUCCESS
        -:   61:# define EXIT_SUCCESS	0
        -:   62:#endif
        -:   63:#ifndef EXIT_FAILURE
        -:   64:# define EXIT_FAILURE	1
        -:   65:#endif
        -:   66:
        -:   67:#define TIFF2PDF_MODULE "tiff2pdf"
        -:   68:
        -:   69:#define PS_UNIT_SIZE	72.0F
        -:   70:
        -:   71:/* This type is of PDF color spaces. */
        -:   72:typedef enum {
        -:   73:	T2P_CS_BILEVEL = 0x01,	/* Bilevel, black and white */
        -:   74:	T2P_CS_GRAY = 0x02,	/* Single channel */
        -:   75:	T2P_CS_RGB = 0x04,	/* Three channel tristimulus RGB */
        -:   76:	T2P_CS_CMYK = 0x08,	/* Four channel CMYK print inkset */
        -:   77:	T2P_CS_LAB = 0x10,	/* Three channel L*a*b* color space */
        -:   78:	T2P_CS_PALETTE = 0x1000,/* One of the above with a color map */
        -:   79:	T2P_CS_CALGRAY = 0x20,	/* Calibrated single channel */
        -:   80:	T2P_CS_CALRGB = 0x40,	/* Calibrated three channel tristimulus RGB */
        -:   81:	T2P_CS_ICCBASED = 0x80	/* ICC profile color specification */
        -:   82:} t2p_cs_t;
        -:   83:
        -:   84:/* This type is of PDF compression types.  */
        -:   85:typedef enum{
        -:   86:	T2P_COMPRESS_NONE=0x00
        -:   87:#ifdef CCITT_SUPPORT
        -:   88:	, T2P_COMPRESS_G4=0x01
        -:   89:#endif
        -:   90:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
        -:   91:	, T2P_COMPRESS_JPEG=0x02
        -:   92:#endif
        -:   93:#ifdef ZIP_SUPPORT
        -:   94:	, T2P_COMPRESS_ZIP=0x04
        -:   95:#endif
        -:   96:} t2p_compress_t;
        -:   97:
        -:   98:/* This type is whether TIFF image data can be used in PDF without transcoding. */
        -:   99:typedef enum{
        -:  100:	T2P_TRANSCODE_RAW=0x01, /* The raw data from the input can be used without recompressing */
        -:  101:	T2P_TRANSCODE_ENCODE=0x02 /* The data from the input is perhaps unencoded and reencoded */
        -:  102:} t2p_transcode_t;
        -:  103:
        -:  104:/* This type is of information about the data samples of the input image. */
        -:  105:typedef enum{
        -:  106:	T2P_SAMPLE_NOTHING=0x0000, /* The unencoded samples are normal for the output colorspace */
        -:  107:	T2P_SAMPLE_ABGR_TO_RGB=0x0001, /* The unencoded samples are the result of ReadRGBAImage */
        -:  108:	T2P_SAMPLE_RGBA_TO_RGB=0x0002, /* The unencoded samples are contiguous RGBA */
        -:  109:	T2P_SAMPLE_RGBAA_TO_RGB=0x0004, /* The unencoded samples are RGBA with premultiplied alpha */
        -:  110:	T2P_SAMPLE_YCBCR_TO_RGB=0x0008, 
        -:  111:	T2P_SAMPLE_YCBCR_TO_LAB=0x0010, 
        -:  112:	T2P_SAMPLE_REALIZE_PALETTE=0x0020, /* The unencoded samples are indexes into the color map */
        -:  113:	T2P_SAMPLE_SIGNED_TO_UNSIGNED=0x0040, /* The unencoded samples are signed instead of unsignd */
        -:  114:	T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED=0x0040, /* The L*a*b* samples have a* and b* signed */
        -:  115:	T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG=0x0100 /* The unencoded samples are separate instead of contiguous */
        -:  116:} t2p_sample_t;
        -:  117:
        -:  118:/* This type is of error status of the T2P struct. */
        -:  119:typedef enum{
        -:  120:	T2P_ERR_OK = 0, /* This is the value of t2p->t2p_error when there is no error */
        -:  121:	T2P_ERR_ERROR = 1 /* This is the value of t2p->t2p_error when there was an error */
        -:  122:} t2p_err_t;
        -:  123:
        -:  124:/* This struct defines a logical page of a TIFF. */
        -:  125:typedef struct {
        -:  126:	tdir_t page_directory;
        -:  127:	uint32 page_number;
        -:  128:	ttile_t page_tilecount;
        -:  129:	uint32 page_extra;
        -:  130:} T2P_PAGE;
        -:  131:
        -:  132:/* This struct defines a PDF rectangle's coordinates. */
        -:  133:typedef struct {
        -:  134:	float x1;
        -:  135:	float y1;
        -:  136:	float x2;
        -:  137:	float y2;
        -:  138:	float mat[9];
        -:  139:} T2P_BOX;
        -:  140:
        -:  141:/* This struct defines a tile of a PDF.  */
        -:  142:typedef struct {
        -:  143:	T2P_BOX tile_box;
        -:  144:} T2P_TILE;
        -:  145:
        -:  146:/* This struct defines information about the tiles on a PDF page. */
        -:  147:typedef struct {
        -:  148:	ttile_t tiles_tilecount;
        -:  149:	uint32 tiles_tilewidth;
        -:  150:	uint32 tiles_tilelength;
        -:  151:	uint32 tiles_tilecountx;
        -:  152:	uint32 tiles_tilecounty;
        -:  153:	uint32 tiles_edgetilewidth;
        -:  154:	uint32 tiles_edgetilelength;
        -:  155:	T2P_TILE* tiles_tiles;
        -:  156:} T2P_TILES;
        -:  157:
        -:  158:/* This struct is the context of a function to generate PDF from a TIFF. */
        -:  159:typedef struct {
        -:  160:	t2p_err_t t2p_error;
        -:  161:	T2P_PAGE* tiff_pages;
        -:  162:	T2P_TILES* tiff_tiles;
        -:  163:	tdir_t tiff_pagecount;
        -:  164:	uint16 tiff_compression;
        -:  165:	uint16 tiff_photometric;
        -:  166:	uint16 tiff_fillorder;
        -:  167:	uint16 tiff_bitspersample;
        -:  168:	uint16 tiff_samplesperpixel;
        -:  169:	uint16 tiff_planar;
        -:  170:	uint32 tiff_width;
        -:  171:	uint32 tiff_length;
        -:  172:	float tiff_xres;
        -:  173:	float tiff_yres;
        -:  174:	uint16 tiff_orientation;
        -:  175:	toff_t tiff_dataoffset;
        -:  176:	tsize_t tiff_datasize;
        -:  177:	uint16 tiff_resunit;
        -:  178:	uint16 pdf_centimeters;
        -:  179:	uint16 pdf_overrideres;
        -:  180:	uint16 pdf_overridepagesize;
        -:  181:	float pdf_defaultxres;
        -:  182:	float pdf_defaultyres;
        -:  183:	float pdf_xres;
        -:  184:	float pdf_yres;
        -:  185:	float pdf_defaultpagewidth;
        -:  186:	float pdf_defaultpagelength;
        -:  187:	float pdf_pagewidth;
        -:  188:	float pdf_pagelength;
        -:  189:	float pdf_imagewidth;
        -:  190:	float pdf_imagelength;
        -:  191:	int pdf_image_fillpage; /* 0 (default: no scaling, 1:scale imagesize to pagesize */
        -:  192:	T2P_BOX pdf_mediabox;
        -:  193:	T2P_BOX pdf_imagebox;
        -:  194:	uint16 pdf_majorversion;
        -:  195:	uint16 pdf_minorversion;
        -:  196:	uint32 pdf_catalog;
        -:  197:	uint32 pdf_pages;
        -:  198:	uint32 pdf_info;
        -:  199:	uint32 pdf_palettecs;
        -:  200:	uint16 pdf_fitwindow;
        -:  201:	uint32 pdf_startxref;
        -:  202:#define TIFF2PDF_FILEID_SIZE 33
        -:  203:	char pdf_fileid[TIFF2PDF_FILEID_SIZE];
        -:  204:#define TIFF2PDF_DATETIME_SIZE 17
        -:  205:	char pdf_datetime[TIFF2PDF_DATETIME_SIZE];
        -:  206:#define TIFF2PDF_CREATOR_SIZE 512
        -:  207:	char pdf_creator[TIFF2PDF_CREATOR_SIZE];
        -:  208:#define TIFF2PDF_AUTHOR_SIZE 512
        -:  209:	char pdf_author[TIFF2PDF_AUTHOR_SIZE];
        -:  210:#define TIFF2PDF_TITLE_SIZE 512
        -:  211:	char pdf_title[TIFF2PDF_TITLE_SIZE];
        -:  212:#define TIFF2PDF_SUBJECT_SIZE 512
        -:  213:	char pdf_subject[TIFF2PDF_SUBJECT_SIZE];
        -:  214:#define TIFF2PDF_KEYWORDS_SIZE 512
        -:  215:	char pdf_keywords[TIFF2PDF_KEYWORDS_SIZE];
        -:  216:	t2p_cs_t pdf_colorspace;
        -:  217:	uint16 pdf_colorspace_invert;
        -:  218:	uint16 pdf_switchdecode;
        -:  219:	uint16 pdf_palettesize;
        -:  220:	unsigned char* pdf_palette;
        -:  221:	int pdf_labrange[4];
        -:  222:	t2p_compress_t pdf_defaultcompression;
        -:  223:	uint16 pdf_defaultcompressionquality;
        -:  224:	t2p_compress_t pdf_compression;
        -:  225:	uint16 pdf_compressionquality;
        -:  226:	uint16 pdf_nopassthrough;
        -:  227:	t2p_transcode_t pdf_transcode;
        -:  228:	t2p_sample_t pdf_sample;
        -:  229:	uint32* pdf_xrefoffsets;
        -:  230:	uint32 pdf_xrefcount;
        -:  231:	tdir_t pdf_page;
        -:  232:#ifdef OJPEG_SUPPORT
        -:  233:	tdata_t pdf_ojpegdata;
        -:  234:	uint32 pdf_ojpegdatalength;
        -:  235:	uint32 pdf_ojpegiflength;
        -:  236:#endif
        -:  237:	float tiff_whitechromaticities[2];
        -:  238:	float tiff_primarychromaticities[6];
        -:  239:	float tiff_referenceblackwhite[2];
        -:  240:	float* tiff_transferfunction[3];
        -:  241:	int pdf_image_interpolate;	/* 0 (default) : do not interpolate,
        -:  242:					   1 : interpolate */
        -:  243:	uint16 tiff_transferfunctioncount;
        -:  244:	uint32 pdf_icccs;
        -:  245:	uint32 tiff_iccprofilelength;
        -:  246:	tdata_t tiff_iccprofile;
        -:  247:
        -:  248:	/* fields for custom read/write procedures */
        -:  249:	FILE *outputfile;
        -:  250:	int outputdisable;
        -:  251:	tsize_t outputwritten;
        -:  252:} T2P;
        -:  253:
        -:  254:/* These functions are called by main. */
        -:  255:
        -:  256:void tiff2pdf_usage(void);
        -:  257:int tiff2pdf_match_paper_size(float*, float*, char*);
        -:  258:
        -:  259:/* These functions are used to generate a PDF from a TIFF. */ 
        -:  260:
        -:  261:#ifdef __cplusplus
        -:  262:extern "C" {
        -:  263:#endif
        -:  264:
        -:  265:T2P* t2p_init(void);
        -:  266:void t2p_validate(T2P*);
        -:  267:tsize_t t2p_write_pdf(T2P*, TIFF*, TIFF*);
        -:  268:void t2p_free(T2P*);
        -:  269:
        -:  270:#ifdef __cplusplus
        -:  271:}
        -:  272:#endif
        -:  273:
        -:  274:void t2p_read_tiff_init(T2P*, TIFF*);
        -:  275:int t2p_cmp_t2p_page(const void*, const void*);
        -:  276:void t2p_read_tiff_data(T2P*, TIFF*);
        -:  277:void t2p_read_tiff_size(T2P*, TIFF*);
        -:  278:void t2p_read_tiff_size_tile(T2P*, TIFF*, ttile_t);
        -:  279:int t2p_tile_is_right_edge(T2P_TILES, ttile_t);
        -:  280:int t2p_tile_is_bottom_edge(T2P_TILES, ttile_t);
        -:  281:int t2p_tile_is_edge(T2P_TILES, ttile_t);
        -:  282:int t2p_tile_is_corner_edge(T2P_TILES, ttile_t);
        -:  283:tsize_t t2p_readwrite_pdf_image(T2P*, TIFF*, TIFF*);
        -:  284:tsize_t t2p_readwrite_pdf_image_tile(T2P*, TIFF*, TIFF*, ttile_t);
        -:  285:#ifdef OJPEG_SUPPORT
        -:  286:int t2p_process_ojpeg_tables(T2P*, TIFF*);
        -:  287:#endif
        -:  288:#ifdef JPEG_SUPPORT
        -:  289:int t2p_process_jpeg_strip(unsigned char*, tsize_t*, unsigned char*, tsize_t, tsize_t*, tstrip_t, uint32);
        -:  290:#endif
        -:  291:void t2p_tile_collapse_left(tdata_t, tsize_t, uint32, uint32, uint32);
        -:  292:void t2p_write_advance_directory(T2P*, TIFF*);
        -:  293:tsize_t t2p_sample_planar_separate_to_contig(T2P*, unsigned char*, unsigned char*, tsize_t);
        -:  294:tsize_t t2p_sample_realize_palette(T2P*, unsigned char*);
        -:  295:tsize_t t2p_sample_abgr_to_rgb(tdata_t, uint32);
        -:  296:tsize_t t2p_sample_rgba_to_rgb(tdata_t, uint32);
        -:  297:tsize_t t2p_sample_rgbaa_to_rgb(tdata_t, uint32);
        -:  298:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t, uint32);
        -:  299:tsize_t t2p_write_pdf_header(T2P*, TIFF*);
        -:  300:tsize_t t2p_write_pdf_obj_start(uint32, TIFF*);
        -:  301:tsize_t t2p_write_pdf_obj_end(TIFF*);
        -:  302:tsize_t t2p_write_pdf_name(unsigned char*, TIFF*);
        -:  303:tsize_t t2p_write_pdf_string(char*, TIFF*);
        -:  304:tsize_t t2p_write_pdf_stream(tdata_t, tsize_t, TIFF*);
        -:  305:tsize_t t2p_write_pdf_stream_start(TIFF*);
        -:  306:tsize_t t2p_write_pdf_stream_end(TIFF*);
        -:  307:tsize_t t2p_write_pdf_stream_dict(tsize_t, uint32, TIFF*);
        -:  308:tsize_t t2p_write_pdf_stream_dict_start(TIFF*);
        -:  309:tsize_t t2p_write_pdf_stream_dict_end(TIFF*);
        -:  310:tsize_t t2p_write_pdf_stream_length(tsize_t, TIFF*);
        -:  311:tsize_t t2p_write_pdf_catalog(T2P*, TIFF*);
        -:  312:tsize_t t2p_write_pdf_info(T2P*, TIFF*, TIFF*);
        -:  313:void t2p_pdf_currenttime(T2P*);
        -:  314:void t2p_pdf_tifftime(T2P*, TIFF*);
        -:  315:tsize_t t2p_write_pdf_pages(T2P*, TIFF*);
        -:  316:tsize_t t2p_write_pdf_page(uint32, T2P*, TIFF*);
        -:  317:void t2p_compose_pdf_page(T2P*);
        -:  318:void t2p_compose_pdf_page_orient(T2P_BOX*, uint16);
        -:  319:void t2p_compose_pdf_page_orient_flip(T2P_BOX*, uint16);
        -:  320:tsize_t t2p_write_pdf_page_content(T2P*, TIFF*);
        -:  321:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t, T2P*, TIFF*);
        -:  322:tsize_t t2p_write_pdf_xobject_cs(T2P*, TIFF*);
        -:  323:tsize_t t2p_write_pdf_transfer(T2P*, TIFF*);
        -:  324:tsize_t t2p_write_pdf_transfer_dict(T2P*, TIFF*, uint16);
        -:  325:tsize_t t2p_write_pdf_transfer_stream(T2P*, TIFF*, uint16);
        -:  326:tsize_t t2p_write_pdf_xobject_calcs(T2P*, TIFF*);
        -:  327:tsize_t t2p_write_pdf_xobject_icccs(T2P*, TIFF*);
        -:  328:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P*, TIFF*);
        -:  329:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P*, TIFF*);
        -:  330:tsize_t t2p_write_pdf_xobject_cs_stream(T2P*, TIFF*);
        -:  331:tsize_t t2p_write_pdf_xobject_decode(T2P*, TIFF*);
        -:  332:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t, T2P*, TIFF*);
        -:  333:tsize_t t2p_write_pdf_xreftable(T2P*, TIFF*);
        -:  334:tsize_t t2p_write_pdf_trailer(T2P*, TIFF*);
        -:  335:
        -:  336:#define check_snprintf_ret(t2p, rv, buf) do { \
        -:  337:	if ((rv) < 0) rv = 0; \
        -:  338:	else if((rv) >= (int)sizeof(buf)) (rv) = sizeof(buf) - 1; \
        -:  339:	else break; \
        -:  340:	if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; \
        -:  341:} while(0)
        -:  342:
        -:  343:static void
    #####:  344:t2p_disable(TIFF *tif)
        -:  345:{
    #####:  346:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  347:	t2p->outputdisable = 1;
    #####:  348:}
        -:  349:
        -:  350:static void
    #####:  351:t2p_enable(TIFF *tif)
        -:  352:{
    #####:  353:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  354:	t2p->outputdisable = 0;
    #####:  355:}
        -:  356:
        -:  357:/*
        -:  358: * Procs for TIFFClientOpen
        -:  359: */
        -:  360:
        -:  361:#ifdef OJPEG_SUPPORT
        -:  362:static tmsize_t 
    #####:  363:t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  364:{
    #####:  365:	thandle_t client = TIFFClientdata(tif);
    #####:  366:	TIFFReadWriteProc proc = TIFFGetReadProc(tif);
    #####:  367:	if (proc)
    #####:  368:		return proc(client, data, size);
    #####:  369:	return -1;
        -:  370:}
        -:  371:#endif /* OJPEG_SUPPORT */
        -:  372:
        -:  373:static tmsize_t 
    #####:  374:t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  375:{
    #####:  376:	thandle_t client = TIFFClientdata(tif);
    #####:  377:	TIFFReadWriteProc proc = TIFFGetWriteProc(tif);
    #####:  378:	if (proc)
    #####:  379:		return proc(client, data, size);
    #####:  380:	return -1;
        -:  381:}
        -:  382:
        -:  383:static uint64
    #####:  384:t2pSeekFile(TIFF *tif, toff_t offset, int whence)
        -:  385:{
    #####:  386:	thandle_t client = TIFFClientdata(tif);
    #####:  387:	TIFFSeekProc proc = TIFFGetSeekProc(tif);
    #####:  388:	if (proc)
    #####:  389:		return proc(client, offset, whence);
    #####:  390:	return -1;
        -:  391:}
        -:  392:
        -:  393:static tmsize_t 
    #####:  394:t2p_readproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  395:{
        -:  396:	(void) handle, (void) data, (void) size;
    #####:  397:	return -1;
        -:  398:}
        -:  399:
        -:  400:static tmsize_t 
    #####:  401:t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  402:{
    #####:  403:	T2P *t2p = (T2P*) handle;
    #####:  404:	if (t2p->outputdisable <= 0 && t2p->outputfile) {
    #####:  405:		tsize_t written = fwrite(data, 1, size, t2p->outputfile);
    #####:  406:		t2p->outputwritten += written;
    #####:  407:		return written;
        -:  408:	}
    #####:  409:	return size; 
        -:  410:}
        -:  411:
        -:  412:static uint64 
    #####:  413:t2p_seekproc(thandle_t handle, uint64 offset, int whence) 
        -:  414:{ 
    #####:  415:	T2P *t2p = (T2P*) handle;
    #####:  416:	if (t2p->outputdisable <= 0 && t2p->outputfile)
    #####:  417:		return _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);
    #####:  418:	return offset;
        -:  419:}
        -:  420:
        -:  421:static int 
    #####:  422:t2p_closeproc(thandle_t handle)
        -:  423:{ 
    #####:  424:	T2P *t2p = (T2P*) handle;
    #####:  425:	return fclose(t2p->outputfile);
        -:  426:}
        -:  427:
        -:  428:static uint64 
    #####:  429:t2p_sizeproc(thandle_t handle) 
        -:  430:{
        -:  431:	(void) handle;
    #####:  432:	return -1;
        -:  433:}
        -:  434:
        -:  435:static int 
    #####:  436:t2p_mapproc(thandle_t handle, void **data, toff_t *offset) 
        -:  437:{ 
        -:  438:	(void) handle, (void) data, (void) offset;
    #####:  439:	return -1; 
        -:  440:}
        -:  441:
        -:  442:static void 
    #####:  443:t2p_unmapproc(thandle_t handle, void *data, toff_t offset)
        -:  444:{ 
        -:  445:	(void) handle, (void) data, (void) offset;
    #####:  446:}
        -:  447:
        -:  448:#if defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT)
        -:  449:static uint64
    #####:  450:checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p)
        -:  451:{
    #####:  452:	uint64 bytes = summand1 + summand2;
        -:  453:
    #####:  454:	if (bytes < summand1) {
    #####:  455:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  456:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  457:		bytes = 0;
        -:  458:	}
        -:  459:
    #####:  460:	return bytes;
        -:  461:}
        -:  462:#endif /* defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT) */
        -:  463:
        -:  464:static uint64
    #####:  465:checkMultiply64(uint64 first, uint64 second, T2P* t2p)
        -:  466:{
    #####:  467:	uint64 bytes = first * second;
        -:  468:
    #####:  469:	if (second && bytes / second != first) {
    #####:  470:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  471:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  472:		bytes = 0;
        -:  473:	}
        -:  474:
    #####:  475:	return bytes;
        -:  476:}
        -:  477:
        -:  478:/*
        -:  479:
        -:  480:  This is the main function.
        -:  481:
        -:  482:  The program converts one TIFF file to one PDF file, including multiple page 
        -:  483:  TIFF files, tiled TIFF files, black and white. grayscale, and color TIFF 
        -:  484:  files that contain data of TIFF photometric interpretations of bilevel, 
        -:  485:  grayscale, RGB, YCbCr, CMYK separation, and ICC L*a*b* as supported by 
        -:  486:  libtiff and PDF.
        -:  487:
        -:  488:  If you have multiple TIFF files to convert into one PDF file then use tiffcp 
        -:  489:  or other program to concatenate the files into a multiple page TIFF file.  
        -:  490:  If the input TIFF file is of huge dimensions (greater than 10000 pixels height
        -:  491:  or width) convert the input image to a tiled TIFF if it is not already.
        -:  492:
        -:  493:  The standard output is standard output.  Set the output file name with the 
        -:  494:  "-o output.pdf" option.
        -:  495:
        -:  496:  All black and white files are compressed into a single strip CCITT G4 Fax 
        -:  497:  compressed PDF, unless tiled, where tiled black and white images are 
        -:  498:  compressed into tiled CCITT G4 Fax compressed PDF, libtiff CCITT support 
        -:  499:  is assumed.
        -:  500:
        -:  501:  Color and grayscale data can be compressed using either JPEG compression, 
        -:  502:  ITU-T T.81, or Zip/Deflate LZ77 compression, per PNG 1.2 and RFC 1951.  Set 
        -:  503:  the compression type using the -j or -z options.  JPEG compression support 
        -:  504:  requires that libtiff be configured with JPEG support, and Zip/Deflate 
        -:  505:  compression support requires that libtiff is configured with Zip support, 
        -:  506:  in tiffconf.h.  Use only one or the other of -j and -z.  The -q option 
        -:  507:  sets the image compression quality, that is 1-100 with libjpeg JPEG 
        -:  508:  compression and one of 1, 10, 11, 12, 13, 14, or 15 for PNG group compression 
        -:  509:  predictor methods, add 100, 200, ..., 900 to set zlib compression quality 1-9.
        -:  510:  PNG Group differencing predictor methods are not currently implemented.
        -:  511:
        -:  512:  If the input TIFF contains single strip CCITT G4 Fax compressed information, 
        -:  513:  then that is written to the PDF file without transcoding, unless the options 
        -:  514:  of no compression and no passthrough are set, -d and -n.
        -:  515:
        -:  516:  If the input TIFF contains JPEG or single strip Zip/Deflate compressed 
        -:  517:  information, and they are configured, then that is written to the PDF file 
        -:  518:  without transcoding, unless the options of no compression and no passthrough 
        -:  519:  are set.
        -:  520:
        -:  521:  The default page size upon which the TIFF image is placed is determined by 
        -:  522:  the resolution and extent of the image data.  Default values for the TIFF 
        -:  523:  image resolution can be set using the -x and -y options.  The page size can 
        -:  524:  be set using the -p option for paper size, or -w and -l for paper width and 
        -:  525:  length, then each page of the TIFF image is centered on its page.  The 
        -:  526:  distance unit for default resolution and page width and length can be set 
        -:  527:  by the -u option, the default unit is inch.
        -:  528:
        -:  529:  Various items of the output document information can be set with the -e, -c, 
        -:  530:  -a, -t, -s, and -k tags.  Setting the argument of the option to "" for these 
        -:  531:  tags causes the relevant document information field to be not written.  Some 
        -:  532:  of the document information values otherwise get their information from the 
        -:  533:  input TIFF image, the software, author, document name, and image description.
        -:  534:
        -:  535:  The output PDF file conforms to the PDF 1.1 specification or PDF 1.2 if using 
        -:  536:  Zip/Deflate compression.  
        -:  537:  
        -:  538:  The Portable Document Format (PDF) specification is copyrighted by Adobe 
        -:  539:  Systems, Incorporated.  Todos derechos reservados.
        -:  540:
        -:  541:  Here is a listing of the usage example and the options to the tiff2pdf 
        -:  542:  program that is part of the libtiff distribution.  Options followed by 
        -:  543:  a colon have a required argument.
        -:  544:  
        -:  545:    usage:  tiff2pdf [options] input.tif
        -:  546:
        -:  547:    options:
        -:  548:    -o: output to file name
        -:  549:
        -:  550:    -j: compress with JPEG (requires libjpeg configured with libtiff)
        -:  551:    -z: compress with Zip/Deflate (requires zlib configured with libtiff)
        -:  552:    -q: compression quality
        -:  553:    -n: no compressed data passthrough
        -:  554:    -d: do not compress (decompress)
        -:  555:    -i: invert colors
        -:  556:    -u: set distance unit, 'i' for inch, 'm' for centimeter
        -:  557:    -x: set x resolution default
        -:  558:    -y: set y resolution default
        -:  559:    -w: width in units
        -:  560:    -l: length in units
        -:  561:    -r: 'd' for resolution default, 'o' for resolution override
        -:  562:    -p: paper size, eg "letter", "legal", "a4"
        -:  563:    -F: make the tiff fill the PDF page
        -:  564:    -f: set pdf "fit window" user preference
        -:  565:    -b:	set PDF "Interpolate" user preference
        -:  566:    -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS
        -:  567:    -c: creator, overrides image software default
        -:  568:    -a: author, overrides image artist default
        -:  569:    -t: title, overrides image document name default
        -:  570:    -s: subject, overrides image image description default
        -:  571:    -k: keywords
        -:  572:
        -:  573:    -h: usage
        -:  574:
        -:  575:    examples:
        -:  576:
        -:  577:        tiff2pdf -o output.pdf input.tiff
        -:  578:
        -:  579:    The above example would generate the file output.pdf from input.tiff.
        -:  580:
        -:  581:        tiff2pdf input.tiff
        -:  582:
        -:  583:    The above example would generate PDF output from input.tiff and write it
        -:  584:    to standard output.
        -:  585:
        -:  586:        tiff2pdf -j -p letter -o output.pdf input.tiff
        -:  587:
        -:  588:    The above example would generate the file output.pdf from input.tiff,
        -:  589:    putting the image pages on a letter sized page, compressing the output
        -:  590:    with JPEG.
        -:  591:
        -:  592:	Please report bugs through:
        -:  593:
        -:  594:	http://bugzilla.remotesensing.org/buglist.cgi?product=libtiff
        -:  595:
        -:  596:    See also libtiff.3t, tiffcp.
        -:  597:  */
        -:  598:
    #####:  599:int main(int argc, char** argv){
        -:  600:#if !HAVE_DECL_OPTARG
        -:  601:	extern char *optarg;
        -:  602:	extern int optind;
        -:  603:#endif
    #####:  604:	const char *outfilename = NULL;
    #####:  605:	T2P *t2p = NULL;
    #####:  606:	TIFF *input = NULL, *output = NULL;
    #####:  607:	int c, ret = EXIT_SUCCESS;
        -:  608:
    #####:  609:	t2p = t2p_init();
        -:  610:
    #####:  611:	if (t2p == NULL){
    #####:  612:		TIFFError(TIFF2PDF_MODULE, "Can't initialize context");
    #####:  613:		goto fail;
        -:  614:	}
        -:  615:
    #####:  616:	while (argv &&
    #####:  617:	       (c = getopt(argc, argv,
        -:  618:			   "o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF")) != -1){
    #####:  619:		switch (c) {
    #####:  620:			case 'o':
    #####:  621:				outfilename = optarg;
    #####:  622:				break;
        -:  623:#ifdef JPEG_SUPPORT
    #####:  624:			case 'j':  
    #####:  625:				t2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;
    #####:  626:				break;
        -:  627:#endif
        -:  628:#ifndef JPEG_SUPPORT
        -:  629:			case 'j':  
        -:  630:				TIFFWarning(
        -:  631:					TIFF2PDF_MODULE, 
        -:  632:					"JPEG support in libtiff required for JPEG compression, ignoring option");
        -:  633:				break;
        -:  634:#endif
        -:  635:#ifdef ZIP_SUPPORT
        -:  636:			case 'z':  
        -:  637:				t2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;
        -:  638:				break;
        -:  639:#endif
        -:  640:#ifndef ZIP_SUPPORT
    #####:  641:			case 'z':  
    #####:  642:				TIFFWarning(
        -:  643:					TIFF2PDF_MODULE, 
        -:  644:					"Zip support in libtiff required for Zip compression, ignoring option");
    #####:  645:				break;
        -:  646:#endif
    #####:  647:			case 'q': 
    #####:  648:				t2p->pdf_defaultcompressionquality=atoi(optarg);
    #####:  649:				break;
    #####:  650:			case 'n': 
    #####:  651:				t2p->pdf_nopassthrough=1;
    #####:  652:				break;
    #####:  653:			case 'd': 
    #####:  654:				t2p->pdf_defaultcompression=T2P_COMPRESS_NONE;
    #####:  655:				break;
    #####:  656:			case 'u': 
    #####:  657:				if(optarg[0]=='m'){
    #####:  658:					t2p->pdf_centimeters=1;
        -:  659:				}
    #####:  660:				break;
    #####:  661:			case 'x': 
    #####:  662:				t2p->pdf_defaultxres = 
    #####:  663:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  664:				break;
    #####:  665:			case 'y': 
    #####:  666:				t2p->pdf_defaultyres = 
    #####:  667:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  668:				break;
    #####:  669:			case 'w': 
    #####:  670:				t2p->pdf_overridepagesize=1;
    #####:  671:				t2p->pdf_defaultpagewidth = 
    #####:  672:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  673:				break;
    #####:  674:			case 'l': 
    #####:  675:				t2p->pdf_overridepagesize=1;
    #####:  676:				t2p->pdf_defaultpagelength = 
    #####:  677:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  678:				break;
    #####:  679:			case 'r': 
    #####:  680:				if(optarg[0]=='o'){
    #####:  681:					t2p->pdf_overrideres=1;
        -:  682:				}
    #####:  683:				break;
    #####:  684:			case 'p': 
    #####:  685:				if(tiff2pdf_match_paper_size(
        -:  686:					&(t2p->pdf_defaultpagewidth), 
        -:  687:					&(t2p->pdf_defaultpagelength), 
        -:  688:					optarg)){
    #####:  689:					t2p->pdf_overridepagesize=1;
        -:  690:				} else {
    #####:  691:					TIFFWarning(TIFF2PDF_MODULE, 
        -:  692:					"Unknown paper size %s, ignoring option",
        -:  693:						optarg);
        -:  694:				}
    #####:  695:				break;
    #####:  696:			case 'i':
    #####:  697:				t2p->pdf_colorspace_invert=1;
    #####:  698:				break;
    #####:  699:			case 'F':
    #####:  700:				t2p->pdf_image_fillpage = 1;
    #####:  701:				break;
    #####:  702:			case 'f': 
    #####:  703:				t2p->pdf_fitwindow=1;
    #####:  704:				break;
    #####:  705:			case 'e':
    #####:  706:				if (strlen(optarg) == 0) {
    #####:  707:					t2p->pdf_datetime[0] = '\0';
        -:  708:				} else {
    #####:  709:					t2p->pdf_datetime[0] = 'D';
    #####:  710:					t2p->pdf_datetime[1] = ':';
    #####:  711:					strncpy(t2p->pdf_datetime + 2, optarg,
        -:  712:						sizeof(t2p->pdf_datetime) - 3);
    #####:  713:					t2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\0';
        -:  714:				}
    #####:  715:				break;
    #####:  716:			case 'c': 
    #####:  717:				strncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);
    #####:  718:				t2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####:  719:				break;
    #####:  720:			case 'a': 
    #####:  721:				strncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);
    #####:  722:				t2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\0';
    #####:  723:				break;
    #####:  724:			case 't': 
    #####:  725:				strncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);
    #####:  726:				t2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\0';
    #####:  727:				break;
    #####:  728:			case 's': 
    #####:  729:				strncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);
    #####:  730:				t2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####:  731:				break;
    #####:  732:			case 'k': 
    #####:  733:				strncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);
    #####:  734:				t2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\0';
    #####:  735:				break;
    #####:  736:			case 'b':
    #####:  737:				t2p->pdf_image_interpolate = 1;
    #####:  738:				break;
    #####:  739:			case 'h': 
        -:  740:			case '?': 
    #####:  741:				tiff2pdf_usage();
    #####:  742:				goto success;
        -:  743:				break;
        -:  744:		}
    #####:  745:	}
        -:  746:
        -:  747:	/*
        -:  748:	 * Input
        -:  749:	 */
    #####:  750:	if(argc > optind) {
    #####:  751:		input = TIFFOpen(argv[optind++], "r");
    #####:  752:		if (input==NULL) {
    #####:  753:			TIFFError(TIFF2PDF_MODULE, 
        -:  754:				  "Can't open input file %s for reading", 
    #####:  755:				  argv[optind-1]);
    #####:  756:			goto fail;
        -:  757:		}
        -:  758:	} else {
    #####:  759:		TIFFError(TIFF2PDF_MODULE, "No input file specified"); 
    #####:  760:		tiff2pdf_usage();
    #####:  761:		goto fail;
        -:  762:	}
        -:  763:
    #####:  764:	if(argc > optind) {
    #####:  765:		TIFFError(TIFF2PDF_MODULE, 
        -:  766:			  "No support for multiple input files"); 
    #####:  767:		tiff2pdf_usage();
    #####:  768:		goto fail;
        -:  769:	}
        -:  770:
        -:  771:	/*
        -:  772:	 * Output
        -:  773:	 */
    #####:  774:	t2p->outputdisable = 1;
    #####:  775:	if (outfilename) {
    #####:  776:		t2p->outputfile = fopen(outfilename, "wb");
    #####:  777:		if (t2p->outputfile == NULL) {
    #####:  778:			TIFFError(TIFF2PDF_MODULE,
        -:  779:				  "Can't open output file %s for writing",
        -:  780:				  outfilename);
    #####:  781:			goto fail;
        -:  782:		}
        -:  783:	} else {
    #####:  784:		outfilename = "-";
    #####:  785:		t2p->outputfile = stdout;
        -:  786:	}
        -:  787:
    #####:  788:	output = TIFFClientOpen(outfilename, "w", (thandle_t) t2p,
        -:  789:				t2p_readproc, t2p_writeproc, t2p_seekproc, 
        -:  790:				t2p_closeproc, t2p_sizeproc, 
        -:  791:				t2p_mapproc, t2p_unmapproc);
    #####:  792:	t2p->outputdisable = 0;
    #####:  793:	if (output == NULL) {
    #####:  794:		TIFFError(TIFF2PDF_MODULE,
        -:  795:			  "Can't initialize output descriptor");
    #####:  796:		goto fail;
        -:  797:	}
        -:  798:	
        -:  799:	/*
        -:  800:	 * Validate
        -:  801:	 */
    #####:  802:	t2p_validate(t2p);
    #####:  803:	t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -:  804:
        -:  805:	/*
        -:  806:	 * Write
        -:  807:	 */
    #####:  808:	t2p_write_pdf(t2p, input, output);
    #####:  809:	if (t2p->t2p_error != 0) {
    #####:  810:		TIFFError(TIFF2PDF_MODULE,
        -:  811:			  "An error occurred creating output PDF file");
    #####:  812:		goto fail;
        -:  813:	}
        -:  814:
    #####:  815:	goto success;
    #####:  816:fail:
    #####:  817:	ret = EXIT_FAILURE;
    #####:  818:success:
    #####:  819:	if(input != NULL)
    #####:  820:		TIFFClose(input);
    #####:  821:	if (output != NULL)
    #####:  822:		TIFFClose(output);
    #####:  823:	if (t2p != NULL)
    #####:  824:		t2p_free(t2p);
    #####:  825:	return ret;
        -:  826:  
        -:  827:}
        -:  828:
    #####:  829:void tiff2pdf_usage(){
    #####:  830:	char* lines[]={
        -:  831:	"usage:  tiff2pdf [options] input.tiff",
        -:  832:	"options:",
        -:  833:	" -o: output to file name",
        -:  834:#ifdef JPEG_SUPPORT
        -:  835:	" -j: compress with JPEG", 
        -:  836:#endif
        -:  837:#ifdef ZIP_SUPPORT
        -:  838:	" -z: compress with Zip/Deflate",
        -:  839:#endif
        -:  840:	" -q: compression quality",
        -:  841:	" -n: no compressed data passthrough",
        -:  842:	" -d: do not compress (decompress)",
        -:  843:	" -i: invert colors",
        -:  844:	" -u: set distance unit, 'i' for inch, 'm' for centimeter",
        -:  845:	" -x: set x resolution default in dots per unit",
        -:  846:	" -y: set y resolution default in dots per unit",
        -:  847:	" -w: width in units",
        -:  848:	" -l: length in units",
        -:  849:	" -r: 'd' for resolution default, 'o' for resolution override",
        -:  850:	" -p: paper size, eg \"letter\", \"legal\", \"A4\"",
        -:  851:  " -F: make the tiff fill the PDF page",
        -:  852:	" -f: set PDF \"Fit Window\" user preference",
        -:  853:	" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS",
        -:  854:	" -c: sets document creator, overrides image software default",
        -:  855:	" -a: sets document author, overrides image artist default",
        -:  856:	" -t: sets document title, overrides image document name default",
        -:  857:	" -s: sets document subject, overrides image image description default",
        -:  858:	" -k: sets document keywords",
        -:  859:	" -b: set PDF \"Interpolate\" user preference",
        -:  860:	" -h: usage",
        -:  861:	NULL
        -:  862:	};
    #####:  863:	int i=0;
        -:  864:
    #####:  865:	fprintf(stderr, "%s\n\n", TIFFGetVersion());
    #####:  866:	for (i=0;lines[i]!=NULL;i++){
    #####:  867:		fprintf(stderr, "%s\n", lines[i]);
        -:  868:	}
        -:  869:
    #####:  870:	return;
        -:  871:}
        -:  872:
    #####:  873:int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){
        -:  874:
        -:  875:	size_t i, len;
    #####:  876:	const char* sizes[]={
        -:  877:		"LETTER", "A4", "LEGAL",
        -:  878:		"EXECUTIVE", "LETTER", "LEGAL", "LEDGER", "TABLOID", 
        -:  879:		"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", 
        -:  880:		"A10", "A9", "A8", "A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0", 
        -:  881:		"2A0", "4A0", "2A", "4A", 
        -:  882:		"B10", "B9", "B8", "B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0", 
        -:  883:		"JISB10", "JISB9", "JISB8", "JISB7", "JISB6", "JISB5", "JISB4", 
        -:  884:		"JISB3", "JISB2", "JISB1", "JISB0", 
        -:  885:		"C10", "C9", "C8", "C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0", 
        -:  886:		"RA2", "RA1", "RA0", "SRA4", "SRA3", "SRA2", "SRA1", "SRA0", 
        -:  887:		"A3EXTRA", "A4EXTRA", 
        -:  888:		"STATEMENT", "FOLIO", "QUARTO", 
        -:  889:		NULL
        -:  890:	} ;
    #####:  891:	const int widths[]={
        -:  892:		612, 595, 612,
        -:  893:		522, 612,612,792,792,
        -:  894:		612,792,1224,1584,2448,2016,792,2016,2448,2880,
        -:  895:		74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,
        -:  896:		88,125,176,249,354,499,709,1001,1417,2004,2835,
        -:  897:		91,128,181,258,363,516,729,1032,1460,2064,2920,
        -:  898:		79,113,162,230,323,459,649,918,1298,1298,2599,
        -:  899:		1219,1729,2438,638,907,1276,1814,2551,
        -:  900:		914,667,
        -:  901:		396, 612, 609, 
        -:  902:		0
        -:  903:	};
    #####:  904:	const int lengths[]={
        -:  905:		792,842,1008,
        -:  906:		756,792,1008,1224,1224,
        -:  907:		792,1224,1584,2448,3168,2880,6480,10296,12672,10296,
        -:  908:		105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,
        -:  909:		125,176,249,354,499,709,1001,1417,2004,2835,4008,
        -:  910:		128,181,258,363,516,729,1032,1460,2064,2920,4127,
        -:  911:		113,162,230,323,459,649,918,1298,1837,1837,3677,
        -:  912:		1729,2438,3458,907,1276,1814,2551,3628,
        -:  913:		1262,914,
        -:  914:		612, 936, 780, 
        -:  915:		0
        -:  916:	};
        -:  917:
    #####:  918:	len=strlen(papersize);
    #####:  919:	for(i=0;i<len;i++){
    #####:  920:		papersize[i]=toupper((int) papersize[i]);
        -:  921:	}
    #####:  922:	for(i=0;sizes[i]!=NULL; i++){
    #####:  923:		if (strcmp( (const char*)papersize, sizes[i])==0){
    #####:  924:			*width=(float)widths[i];
    #####:  925:			*length=(float)lengths[i];
    #####:  926:			return(1);
        -:  927:		}
        -:  928:	}
        -:  929:
    #####:  930:	return(0);
        -:  931:}
        -:  932:
        -:  933:/*
        -:  934: * This function allocates and initializes a T2P context struct pointer.
        -:  935: */
        -:  936:
    #####:  937:T2P* t2p_init()
        -:  938:{
    #####:  939:	T2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));
    #####:  940:	if(t2p==NULL){
    #####:  941:		TIFFError(
        -:  942:			TIFF2PDF_MODULE, 
        -:  943:			"Can't allocate %lu bytes of memory for t2p_init", 
        -:  944:			(unsigned long) sizeof(T2P));
    #####:  945:		return( (T2P*) NULL );
        -:  946:	}
    #####:  947:	_TIFFmemset(t2p, 0x00, sizeof(T2P));
    #####:  948:	t2p->pdf_majorversion=1;
    #####:  949:	t2p->pdf_minorversion=1;
    #####:  950:	t2p->pdf_defaultxres=300.0;
    #####:  951:	t2p->pdf_defaultyres=300.0;
    #####:  952:	t2p->pdf_defaultpagewidth=612.0;
    #####:  953:	t2p->pdf_defaultpagelength=792.0;
    #####:  954:	t2p->pdf_xrefcount=3; /* Catalog, Info, Pages */
        -:  955:	
    #####:  956:	return(t2p);
        -:  957:}
        -:  958:
        -:  959:/*
        -:  960: * This function frees a T2P context struct pointer and any allocated data fields of it.
        -:  961: */
        -:  962:
    #####:  963:void t2p_free(T2P* t2p)
        -:  964:{
    #####:  965:	int i = 0;
        -:  966:
    #####:  967:	if (t2p != NULL) {
    #####:  968:		if(t2p->pdf_xrefoffsets != NULL){
    #####:  969:			_TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);
        -:  970:		}
    #####:  971:		if(t2p->tiff_pages != NULL){
    #####:  972:			_TIFFfree( (tdata_t) t2p->tiff_pages);
        -:  973:		}
    #####:  974:		for(i=0;i<t2p->tiff_pagecount;i++){
    #####:  975:			if(t2p->tiff_tiles[i].tiles_tiles != NULL){
    #####:  976:				_TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles);
        -:  977:			}
        -:  978:		}
    #####:  979:		if(t2p->tiff_tiles != NULL){
    #####:  980:			_TIFFfree( (tdata_t) t2p->tiff_tiles);
        -:  981:		}
    #####:  982:		if(t2p->pdf_palette != NULL){
    #####:  983:			_TIFFfree( (tdata_t) t2p->pdf_palette);
        -:  984:		}
        -:  985:#ifdef OJPEG_SUPPORT
    #####:  986:		if(t2p->pdf_ojpegdata != NULL){
    #####:  987:			_TIFFfree( (tdata_t) t2p->pdf_ojpegdata);
        -:  988:		}
        -:  989:#endif
    #####:  990:		_TIFFfree( (tdata_t) t2p );
        -:  991:	}
        -:  992:
    #####:  993:	return;
        -:  994:}
        -:  995:
        -:  996:/*
        -:  997:	This function validates the values of a T2P context struct pointer
        -:  998:        before calling t2p_write_pdf with it.
        -:  999:*/
        -: 1000:
    #####: 1001:void t2p_validate(T2P* t2p){
        -: 1002:
        -: 1003:#ifdef JPEG_SUPPORT
    #####: 1004:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1005:		if(t2p->pdf_defaultcompressionquality>100 ||
    #####: 1006:			t2p->pdf_defaultcompressionquality<1){
    #####: 1007:			t2p->pdf_defaultcompressionquality=0;
        -: 1008:		}
        -: 1009:	}
        -: 1010:#endif
        -: 1011:#ifdef ZIP_SUPPORT
        -: 1012:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){
        -: 1013: 		uint16 m=t2p->pdf_defaultcompressionquality%100;
        -: 1014: 		if(t2p->pdf_defaultcompressionquality/100 > 9 ||
        -: 1015: 			(m>1 && m<10) || m>15){
        -: 1016: 			t2p->pdf_defaultcompressionquality=0;
        -: 1017:		}
        -: 1018:		if(t2p->pdf_defaultcompressionquality%100 !=0){
        -: 1019: 			t2p->pdf_defaultcompressionquality/=100;
        -: 1020: 			t2p->pdf_defaultcompressionquality*=100;
        -: 1021:			TIFFError(
        -: 1022:				TIFF2PDF_MODULE, 
        -: 1023:				"PNG Group predictor differencing not implemented, assuming compression quality %u", 
        -: 1024:				t2p->pdf_defaultcompressionquality);
        -: 1025:		}
        -: 1026:		t2p->pdf_defaultcompressionquality%=100;
        -: 1027:		if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1028:	}
        -: 1029:#endif
        -: 1030:	(void)0;
        -: 1031:
    #####: 1032:	return;
        -: 1033:}
        -: 1034:
        -: 1035:
        -: 1036:/*
        -: 1037:	This function scans the input TIFF file for pages.  It attempts
        -: 1038:        to determine which IFD's of the TIFF file contain image document
        -: 1039:        pages.  For each, it gathers some information that has to do
        -: 1040:        with the output of the PDF document as a whole.  
        -: 1041:*/
        -: 1042:
    #####: 1043:void t2p_read_tiff_init(T2P* t2p, TIFF* input){
        -: 1044:
    #####: 1045:	tdir_t directorycount=0;
    #####: 1046:	tdir_t i=0;
    #####: 1047:	uint16 pagen=0;
    #####: 1048:	uint16 paged=0;
    #####: 1049:	uint16 xuint16=0;
        -: 1050:
    #####: 1051:	directorycount=TIFFNumberOfDirectories(input);
    #####: 1052:	t2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));
    #####: 1053:	if(t2p->tiff_pages==NULL){
    #####: 1054:		TIFFError(
        -: 1055:			TIFF2PDF_MODULE, 
        -: 1056:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_pages array, %s", 
    #####: 1057:			(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), 
        -: 1058:			TIFFFileName(input));
    #####: 1059:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1060:		return;
        -: 1061:	}
    #####: 1062:	_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));
    #####: 1063:	t2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));
    #####: 1064:	if(t2p->tiff_tiles==NULL){
    #####: 1065:		TIFFError(
        -: 1066:			TIFF2PDF_MODULE, 
        -: 1067:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_tiles array, %s", 
    #####: 1068:			(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), 
        -: 1069:			TIFFFileName(input));
    #####: 1070:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1071:		return;
        -: 1072:	}
    #####: 1073:	_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));
    #####: 1074:	for(i=0;i<directorycount;i++){
    #####: 1075:		uint32 subfiletype = 0;
        -: 1076:		
    #####: 1077:		if(!TIFFSetDirectory(input, i)){
    #####: 1078:			TIFFError(
        -: 1079:				TIFF2PDF_MODULE, 
        -: 1080:				"Can't set directory %u of input file %s", 
        -: 1081:				i,
        -: 1082:				TIFFFileName(input));
    #####: 1083:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1084:			return;
        -: 1085:		}
    #####: 1086:		if(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){
    #####: 1087:			if((pagen>paged) && (paged != 0)){
    #####: 1088:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1089:					paged;
        -: 1090:			} else {
    #####: 1091:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1092:					pagen;
        -: 1093:			}
    #####: 1094:			goto ispage2;
        -: 1095:		}
    #####: 1096:		if(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){
    #####: 1097:			if ( ((subfiletype & FILETYPE_PAGE) != 0)
    #####: 1098:                             || (subfiletype == 0)){
    #####: 1099:				goto ispage;
        -: 1100:			} else {
    #####: 1101:				goto isnotpage;
        -: 1102:			}
        -: 1103:		}
    #####: 1104:		if(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){
    #####: 1105:			if ((subfiletype == OFILETYPE_IMAGE) 
    #####: 1106:				|| (subfiletype == OFILETYPE_PAGE)
    #####: 1107:				|| (subfiletype == 0) ){
    #####: 1108:				goto ispage;
        -: 1109:			} else {
    #####: 1110:				goto isnotpage;
        -: 1111:			}
        -: 1112:		}
    #####: 1113:		ispage:
    #####: 1114:		t2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;
    #####: 1115:		ispage2:
    #####: 1116:		t2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;
    #####: 1117:		if(TIFFIsTiled(input)){
    #####: 1118:			t2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = 
    #####: 1119:				TIFFNumberOfTiles(input);
        -: 1120:		}
    #####: 1121:		t2p->tiff_pagecount++;
    #####: 1122:		isnotpage:
        -: 1123:		(void)0;
        -: 1124:	}
        -: 1125:	
    #####: 1126:	qsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,
        -: 1127:              sizeof(T2P_PAGE), t2p_cmp_t2p_page);
        -: 1128:
    #####: 1129:	for(i=0;i<t2p->tiff_pagecount;i++){
    #####: 1130:		t2p->pdf_xrefcount += 5;
    #####: 1131:		TIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );
    #####: 1132:		if((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)
    #####: 1133:                    && (xuint16==PHOTOMETRIC_PALETTE))
    #####: 1134:		   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {
    #####: 1135:			t2p->tiff_pages[i].page_extra++;
    #####: 1136:			t2p->pdf_xrefcount++;
        -: 1137:		}
        -: 1138:#ifdef ZIP_SUPPORT
        -: 1139:		if (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {
        -: 1140:                        if( (xuint16== COMPRESSION_DEFLATE ||
        -: 1141:                             xuint16== COMPRESSION_ADOBE_DEFLATE) && 
        -: 1142:                            ((t2p->tiff_pages[i].page_tilecount != 0) 
        -: 1143:                             || TIFFNumberOfStrips(input)==1) &&
        -: 1144:                            (t2p->pdf_nopassthrough==0)	){
        -: 1145:                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1146:                        }
        -: 1147:                }
        -: 1148:#endif
    #####: 1149:		if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1150:                                 &(t2p->tiff_transferfunction[0]),
        -: 1151:                                 &(t2p->tiff_transferfunction[1]),
        -: 1152:                                 &(t2p->tiff_transferfunction[2]))) {
    #####: 1153:			if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1154:                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1155:                           (t2p->tiff_transferfunction[1] !=
    #####: 1156:                            t2p->tiff_transferfunction[0])) {
    #####: 1157:				t2p->tiff_transferfunctioncount = 3;
    #####: 1158:				t2p->tiff_pages[i].page_extra += 4;
    #####: 1159:				t2p->pdf_xrefcount += 4;
        -: 1160:			} else {
    #####: 1161:				t2p->tiff_transferfunctioncount = 1;
    #####: 1162:				t2p->tiff_pages[i].page_extra += 2;
    #####: 1163:				t2p->pdf_xrefcount += 2;
        -: 1164:			}
    #####: 1165:			if(t2p->pdf_minorversion < 2)
    #####: 1166:				t2p->pdf_minorversion = 2;
        -: 1167:                } else {
    #####: 1168:			t2p->tiff_transferfunctioncount=0;
        -: 1169:		}
    #####: 1170:		if( TIFFGetField(
        -: 1171:			input, 
        -: 1172:			TIFFTAG_ICCPROFILE, 
        -: 1173:			&(t2p->tiff_iccprofilelength), 
        -: 1174:			&(t2p->tiff_iccprofile)) != 0){
    #####: 1175:			t2p->tiff_pages[i].page_extra++;
    #####: 1176:			t2p->pdf_xrefcount++;
    #####: 1177:			if(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}
        -: 1178:		}
    #####: 1179:		t2p->tiff_tiles[i].tiles_tilecount=
    #####: 1180:			t2p->tiff_pages[i].page_tilecount;
    #####: 1181:		if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)
    #####: 1182:			&& (xuint16 == PLANARCONFIG_SEPARATE ) ){
    #####: 1183:				if( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )
        -: 1184:				{
    #####: 1185:					TIFFError(
        -: 1186:                        TIFF2PDF_MODULE, 
        -: 1187:                        "Missing SamplesPerPixel, %s", 
        -: 1188:                        TIFFFileName(input));
    #####: 1189:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1190:                    return;
        -: 1191:				}
    #####: 1192:                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )
        -: 1193:                {
    #####: 1194:                    TIFFError(
        -: 1195:                        TIFF2PDF_MODULE, 
        -: 1196:                        "Invalid tile count, %s", 
        -: 1197:                        TIFFFileName(input));
    #####: 1198:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1199:                    return;
        -: 1200:                }
    #####: 1201:				t2p->tiff_tiles[i].tiles_tilecount/= xuint16;
        -: 1202:		}
    #####: 1203:		if( t2p->tiff_tiles[i].tiles_tilecount > 0){
    #####: 1204:			t2p->pdf_xrefcount += 
    #####: 1205:				(t2p->tiff_tiles[i].tiles_tilecount -1)*2;
    #####: 1206:			TIFFGetField(input, 
        -: 1207:				TIFFTAG_TILEWIDTH, 
    #####: 1208:				&( t2p->tiff_tiles[i].tiles_tilewidth) );
    #####: 1209:			TIFFGetField(input, 
        -: 1210:				TIFFTAG_TILELENGTH, 
    #####: 1211:				&( t2p->tiff_tiles[i].tiles_tilelength) );
    #####: 1212:			t2p->tiff_tiles[i].tiles_tiles = 
    #####: 1213:			(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,
        -: 1214:                                                                 sizeof(T2P_TILE)) );
    #####: 1215:			if( t2p->tiff_tiles[i].tiles_tiles == NULL){
    #####: 1216:				TIFFError(
        -: 1217:					TIFF2PDF_MODULE, 
        -: 1218:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for t2p_read_tiff_init, %s", 
    #####: 1219:					(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), 
        -: 1220:					TIFFFileName(input));
    #####: 1221:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1222:				return;
        -: 1223:			}
        -: 1224:		}
        -: 1225:	}
        -: 1226:
    #####: 1227:	return;
        -: 1228:}
        -: 1229:
        -: 1230:/*
        -: 1231: * This function is used by qsort to sort a T2P_PAGE* array of page structures
        -: 1232: * by page number. If the page numbers are the same, we fall back to comparing
        -: 1233: * directory numbers to preserve the order of the input file.
        -: 1234: */
        -: 1235:
    #####: 1236:int t2p_cmp_t2p_page(const void* e1, const void* e2){
        -: 1237:
        -: 1238:	int d;
    #####: 1239:	d = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);
    #####: 1240:	if(d == 0){
    #####: 1241:		d = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);
        -: 1242:	}
    #####: 1243:	return d;
        -: 1244:}
        -: 1245:
        -: 1246:/*
        -: 1247:	This function sets the input directory to the directory of a given
        -: 1248:	page and determines information about the image.  It checks
        -: 1249:	the image characteristics to determine if it is possible to convert
        -: 1250:	the image data into a page of PDF output, setting values of the T2P
        -: 1251:	struct for this page.  It determines what color space is used in
        -: 1252:	the output PDF to represent the image.
        -: 1253:	
        -: 1254:	It determines if the image can be converted as raw data without
        -: 1255:	requiring transcoding of the image data.
        -: 1256:*/
        -: 1257:
    #####: 1258:void t2p_read_tiff_data(T2P* t2p, TIFF* input){
        -: 1259:
    #####: 1260:	int i=0;
    #####: 1261:	uint16* r;
    #####: 1262:	uint16* g;
    #####: 1263:	uint16* b;
    #####: 1264:	uint16* a;
    #####: 1265:	uint16 xuint16;
    #####: 1266:	uint16* xuint16p;
    #####: 1267:	float* xfloatp;
        -: 1268:
    #####: 1269:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
    #####: 1270:	t2p->pdf_sample = T2P_SAMPLE_NOTHING;
    #####: 1271:        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;
        -: 1272:        
        -: 1273:	
    #####: 1274:	TIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);
        -: 1275:
    #####: 1276:	TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));
    #####: 1277:	if(t2p->tiff_width == 0){
    #####: 1278:		TIFFError(
        -: 1279:			TIFF2PDF_MODULE, 
        -: 1280:			"No support for %s with zero width", 
        -: 1281:			TIFFFileName(input)	);
    #####: 1282:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1283:		return;
        -: 1284:	}
        -: 1285:
    #####: 1286:	TIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));
    #####: 1287:	if(t2p->tiff_length == 0){
    #####: 1288:		TIFFError(
        -: 1289:			TIFF2PDF_MODULE, 
        -: 1290:			"No support for %s with zero length", 
        -: 1291:			TIFFFileName(input)	);
    #####: 1292:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1293:		return;
        -: 1294:	}
        -: 1295:
    #####: 1296:        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){
    #####: 1297:                TIFFError(
        -: 1298:                        TIFF2PDF_MODULE, 
        -: 1299:                        "No support for %s with no compression tag", 
        -: 1300:                        TIFFFileName(input)     );
    #####: 1301:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1302:                return;
        -: 1303:
        -: 1304:        }
    #####: 1305:        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){
    #####: 1306:		TIFFError(
        -: 1307:			TIFF2PDF_MODULE, 
        -: 1308:			"No support for %s with compression type %u:  not configured", 
        -: 1309:			TIFFFileName(input), 
    #####: 1310:			t2p->tiff_compression	
        -: 1311:			);
    #####: 1312:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1313:		return;
        -: 1314:	
        -: 1315:	}
        -: 1316:
    #####: 1317:	TIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));
    #####: 1318:	switch(t2p->tiff_bitspersample){
    #####: 1319:		case 1:
        -: 1320:		case 2:
        -: 1321:		case 4:
        -: 1322:		case 8:
    #####: 1323:			break;
    #####: 1324:		case 0:
    #####: 1325:			TIFFWarning(
        -: 1326:				TIFF2PDF_MODULE, 
        -: 1327:				"Image %s has 0 bits per sample, assuming 1",
        -: 1328:				TIFFFileName(input));
    #####: 1329:			t2p->tiff_bitspersample=1;
    #####: 1330:			break;
    #####: 1331:		default:
    #####: 1332:			TIFFError(
        -: 1333:				TIFF2PDF_MODULE, 
        -: 1334:				"No support for %s with %u bits per sample",
        -: 1335:				TIFFFileName(input),
    #####: 1336:				t2p->tiff_bitspersample);
    #####: 1337:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1338:			return;
        -: 1339:	}
        -: 1340:
    #####: 1341:	TIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));
    #####: 1342:	if(t2p->tiff_samplesperpixel>4){
    #####: 1343:		TIFFError(
        -: 1344:			TIFF2PDF_MODULE, 
        -: 1345:			"No support for %s with %u samples per pixel",
        -: 1346:			TIFFFileName(input),
    #####: 1347:			t2p->tiff_samplesperpixel);
    #####: 1348:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1349:		return;
        -: 1350:	}
    #####: 1351:	if(t2p->tiff_samplesperpixel==0){
    #####: 1352:		TIFFWarning(
        -: 1353:			TIFF2PDF_MODULE, 
        -: 1354:			"Image %s has 0 samples per pixel, assuming 1",
        -: 1355:			TIFFFileName(input));
    #####: 1356:		t2p->tiff_samplesperpixel=1;
        -: 1357:	}
        -: 1358:	
    #####: 1359:	if(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){
    #####: 1360:		switch(xuint16){
    #####: 1361:			case 0:
        -: 1362:			case 1:
        -: 1363:			case 4:
    #####: 1364:				break;
    #####: 1365:			default:
    #####: 1366:				TIFFError(
        -: 1367:					TIFF2PDF_MODULE, 
        -: 1368:					"No support for %s with sample format %u",
        -: 1369:					TIFFFileName(input),
        -: 1370:					xuint16);
    #####: 1371:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1372:				return;
        -: 1373:				break;
        -: 1374:		}
    #####: 1375:	}
        -: 1376:	
    #####: 1377:	TIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));
        -: 1378:	
    #####: 1379:        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){
    #####: 1380:                TIFFError(
        -: 1381:                        TIFF2PDF_MODULE, 
        -: 1382:                        "No support for %s with no photometric interpretation tag", 
        -: 1383:                        TIFFFileName(input)     );
    #####: 1384:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1385:                return;
        -: 1386:
        -: 1387:        }
        -: 1388:        
    #####: 1389:	switch(t2p->tiff_photometric){
    #####: 1390:		case PHOTOMETRIC_MINISWHITE:
        -: 1391:		case PHOTOMETRIC_MINISBLACK: 
    #####: 1392:			if (t2p->tiff_bitspersample==1){
    #####: 1393:				t2p->pdf_colorspace=T2P_CS_BILEVEL;
    #####: 1394:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1395:					t2p->pdf_switchdecode ^= 1;
        -: 1396:				}
        -: 1397:			} else {
    #####: 1398:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1399:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1400:					t2p->pdf_switchdecode ^= 1;
        -: 1401:				} 
        -: 1402:			}
    #####: 1403:			break;
    #####: 1404:		case PHOTOMETRIC_RGB: 
    #####: 1405:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1406:			if(t2p->tiff_samplesperpixel == 3){
    #####: 1407:				break;
        -: 1408:			}
    #####: 1409:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1410:				if(xuint16==1)
    #####: 1411:					goto photometric_palette;
        -: 1412:			}
    #####: 1413:			if(t2p->tiff_samplesperpixel > 3) {
    #####: 1414:				if(t2p->tiff_samplesperpixel == 4) {
    #####: 1415:					t2p->pdf_colorspace = T2P_CS_RGB;
    #####: 1416:					if(TIFFGetField(input,
        -: 1417:							TIFFTAG_EXTRASAMPLES,
        -: 1418:							&xuint16, &xuint16p)
    #####: 1419:					   && xuint16 == 1) {
    #####: 1420:						if(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){
    #####: 1421:							if( t2p->tiff_bitspersample != 8 )
        -: 1422:							{
    #####: 1423:							    TIFFError(
        -: 1424:								    TIFF2PDF_MODULE, 
        -: 1425:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1426:								    t2p->tiff_bitspersample);
    #####: 1427:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1428:							    return;
        -: 1429:							}
    #####: 1430:							t2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;
    #####: 1431:							break;
        -: 1432:						}
    #####: 1433:						if(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){
    #####: 1434:							if( t2p->tiff_bitspersample != 8 )
        -: 1435:							{
    #####: 1436:							    TIFFError(
        -: 1437:								    TIFF2PDF_MODULE, 
        -: 1438:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1439:								    t2p->tiff_bitspersample);
    #####: 1440:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1441:							    return;
        -: 1442:							}
    #####: 1443:							t2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;
    #####: 1444:							break;
        -: 1445:						}
    #####: 1446:						TIFFWarning(
        -: 1447:							TIFF2PDF_MODULE, 
        -: 1448:							"RGB image %s has 4 samples per pixel, assuming RGBA",
        -: 1449:							TIFFFileName(input));
    #####: 1450:							break;
        -: 1451:					}
    #####: 1452:					t2p->pdf_colorspace=T2P_CS_CMYK;
    #####: 1453:					t2p->pdf_switchdecode ^= 1;
    #####: 1454:					TIFFWarning(
        -: 1455:						TIFF2PDF_MODULE, 
        -: 1456:						"RGB image %s has 4 samples per pixel, assuming inverse CMYK",
        -: 1457:					TIFFFileName(input));
    #####: 1458:					break;
        -: 1459:				} else {
    #####: 1460:					TIFFError(
        -: 1461:						TIFF2PDF_MODULE, 
        -: 1462:						"No support for RGB image %s with %u samples per pixel", 
        -: 1463:						TIFFFileName(input), 
    #####: 1464:						t2p->tiff_samplesperpixel);
    #####: 1465:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1466:					break;
        -: 1467:				}
        -: 1468:			} else {
    #####: 1469:				TIFFError(
        -: 1470:					TIFF2PDF_MODULE, 
        -: 1471:					"No support for RGB image %s with %u samples per pixel", 
        -: 1472:					TIFFFileName(input), 
    #####: 1473:					t2p->tiff_samplesperpixel);
    #####: 1474:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1475:				break;
        -: 1476:			}
        -: 1477:		case PHOTOMETRIC_PALETTE: 
    #####: 1478:			photometric_palette:
    #####: 1479:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1480:				TIFFError(
        -: 1481:					TIFF2PDF_MODULE, 
        -: 1482:					"No support for palettized image %s with not one sample per pixel", 
        -: 1483:					TIFFFileName(input));
    #####: 1484:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1485:				return;
        -: 1486:			}
    #####: 1487:			t2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;
    #####: 1488:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1489:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){
    #####: 1490:				TIFFError(
        -: 1491:					TIFF2PDF_MODULE, 
        -: 1492:					"Palettized image %s has no color map", 
        -: 1493:					TIFFFileName(input));
    #####: 1494:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1495:				return;
        -: 1496:			} 
    #####: 1497:			if(t2p->pdf_palette != NULL){
    #####: 1498:				_TIFFfree(t2p->pdf_palette);
    #####: 1499:				t2p->pdf_palette=NULL;
        -: 1500:			}
    #####: 1501:			t2p->pdf_palette = (unsigned char*)
    #####: 1502:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));
    #####: 1503:			if(t2p->pdf_palette==NULL){
    #####: 1504:				TIFFError(
        -: 1505:					TIFF2PDF_MODULE, 
        -: 1506:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1507:					t2p->pdf_palettesize, 
        -: 1508:					TIFFFileName(input));
    #####: 1509:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1510:				return;
        -: 1511:			}
    #####: 1512:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1513:				t2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);
    #####: 1514:				t2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);
    #####: 1515:				t2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);
        -: 1516:			}
    #####: 1517:			t2p->pdf_palettesize *= 3;
    #####: 1518:			break;
    #####: 1519:		case PHOTOMETRIC_SEPARATED:
    #####: 1520:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1521:				if(xuint16==1){
    #####: 1522:						goto photometric_palette_cmyk;
        -: 1523:				}
        -: 1524:			}
    #####: 1525:			if( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){
    #####: 1526:				if(xuint16 != INKSET_CMYK){
    #####: 1527:					TIFFError(
        -: 1528:						TIFF2PDF_MODULE, 
        -: 1529:						"No support for %s because its inkset is not CMYK",
        -: 1530:						TIFFFileName(input) );
    #####: 1531:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1532:					return;
        -: 1533:				}
        -: 1534:			}
    #####: 1535:			if(t2p->tiff_samplesperpixel==4){
    #####: 1536:				t2p->pdf_colorspace=T2P_CS_CMYK;
        -: 1537:			} else {
    #####: 1538:				TIFFError(
        -: 1539:					TIFF2PDF_MODULE, 
        -: 1540:					"No support for %s because it has %u samples per pixel",
        -: 1541:					TIFFFileName(input), 
    #####: 1542:					t2p->tiff_samplesperpixel);
    #####: 1543:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1544:				return;
        -: 1545:			}
    #####: 1546:			break;
    #####: 1547:			photometric_palette_cmyk:
    #####: 1548:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1549:				TIFFError(
        -: 1550:					TIFF2PDF_MODULE, 
        -: 1551:					"No support for palettized CMYK image %s with not one sample per pixel", 
        -: 1552:					TIFFFileName(input));
    #####: 1553:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1554:				return;
        -: 1555:			}
    #####: 1556:			t2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;
    #####: 1557:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1558:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){
    #####: 1559:				TIFFError(
        -: 1560:					TIFF2PDF_MODULE, 
        -: 1561:					"Palettized image %s has no color map", 
        -: 1562:					TIFFFileName(input));
    #####: 1563:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1564:				return;
        -: 1565:			} 
    #####: 1566:			if(t2p->pdf_palette != NULL){
    #####: 1567:				_TIFFfree(t2p->pdf_palette);
    #####: 1568:				t2p->pdf_palette=NULL;
        -: 1569:			}
    #####: 1570:			t2p->pdf_palette = (unsigned char*) 
    #####: 1571:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));
    #####: 1572:			if(t2p->pdf_palette==NULL){
    #####: 1573:				TIFFError(
        -: 1574:					TIFF2PDF_MODULE, 
        -: 1575:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1576:					t2p->pdf_palettesize, 
        -: 1577:					TIFFFileName(input));
    #####: 1578:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1579:				return;
        -: 1580:			}
    #####: 1581:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1582:				t2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);
    #####: 1583:				t2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);
    #####: 1584:				t2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);
    #####: 1585:				t2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);
        -: 1586:			}
    #####: 1587:			t2p->pdf_palettesize *= 4;
    #####: 1588:			break;
    #####: 1589:		case PHOTOMETRIC_YCBCR:
    #####: 1590:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1591:			if(t2p->tiff_samplesperpixel==1){
    #####: 1592:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1593:				t2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;
    #####: 1594:				break;
        -: 1595:			}
    #####: 1596:			t2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;
        -: 1597:#ifdef JPEG_SUPPORT
    #####: 1598:			if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1599:				t2p->pdf_sample=T2P_SAMPLE_NOTHING;
        -: 1600:			}
        -: 1601:#endif
    #####: 1602:			break;
    #####: 1603:		case PHOTOMETRIC_CIELAB:
    #####: 1604:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1605:                TIFFError(
        -: 1606:                    TIFF2PDF_MODULE, 
        -: 1607:                    "Unsupported samplesperpixel = %d for CIELAB", 
    #####: 1608:                    t2p->tiff_samplesperpixel);
    #####: 1609:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1610:                return;
        -: 1611:            }
    #####: 1612:            if( t2p->tiff_bitspersample != 8){
    #####: 1613:                TIFFError(
        -: 1614:                    TIFF2PDF_MODULE, 
        -: 1615:                    "Invalid bitspersample = %d for CIELAB", 
    #####: 1616:                    t2p->tiff_bitspersample);
    #####: 1617:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1618:                return;
        -: 1619:            }
    #####: 1620:			t2p->pdf_labrange[0]= -127;
    #####: 1621:			t2p->pdf_labrange[1]= 127;
    #####: 1622:			t2p->pdf_labrange[2]= -127;
    #####: 1623:			t2p->pdf_labrange[3]= 127;
    #####: 1624:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1625:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1626:			break;
    #####: 1627:		case PHOTOMETRIC_ICCLAB:
    #####: 1628:			t2p->pdf_labrange[0]= 0;
    #####: 1629:			t2p->pdf_labrange[1]= 255;
    #####: 1630:			t2p->pdf_labrange[2]= 0;
    #####: 1631:			t2p->pdf_labrange[3]= 255;
    #####: 1632:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1633:			break;
    #####: 1634:		case PHOTOMETRIC_ITULAB:
    #####: 1635:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1636:                TIFFError(
        -: 1637:                    TIFF2PDF_MODULE, 
        -: 1638:                    "Unsupported samplesperpixel = %d for ITULAB", 
    #####: 1639:                    t2p->tiff_samplesperpixel);
    #####: 1640:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1641:                return;
        -: 1642:            }
    #####: 1643:            if( t2p->tiff_bitspersample != 8){
    #####: 1644:                TIFFError(
        -: 1645:                    TIFF2PDF_MODULE, 
        -: 1646:                    "Invalid bitspersample = %d for ITULAB", 
    #####: 1647:                    t2p->tiff_bitspersample);
    #####: 1648:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1649:                return;
        -: 1650:            }
    #####: 1651:			t2p->pdf_labrange[0]=-85;
    #####: 1652:			t2p->pdf_labrange[1]=85;
    #####: 1653:			t2p->pdf_labrange[2]=-75;
    #####: 1654:			t2p->pdf_labrange[3]=124;
    #####: 1655:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1656:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1657:			break;
    #####: 1658:		case PHOTOMETRIC_LOGL:
        -: 1659:		case PHOTOMETRIC_LOGLUV:
    #####: 1660:			TIFFError(
        -: 1661:				TIFF2PDF_MODULE, 
        -: 1662:				"No support for %s with photometric interpretation LogL/LogLuv", 
        -: 1663:				TIFFFileName(input));
    #####: 1664:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1665:			return;
    #####: 1666:		default:
    #####: 1667:			TIFFError(
        -: 1668:				TIFF2PDF_MODULE, 
        -: 1669:				"No support for %s with photometric interpretation %u", 
        -: 1670:				TIFFFileName(input),
    #####: 1671:				t2p->tiff_photometric);
    #####: 1672:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1673:			return;
        -: 1674:	}
        -: 1675:
    #####: 1676:	if(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){
    #####: 1677:		switch(t2p->tiff_planar){
    #####: 1678:			case 0:
    #####: 1679:				TIFFWarning(
        -: 1680:					TIFF2PDF_MODULE, 
        -: 1681:					"Image %s has planar configuration 0, assuming 1", 
        -: 1682:					TIFFFileName(input));
    #####: 1683:				t2p->tiff_planar=PLANARCONFIG_CONTIG;
    #####: 1684:			case PLANARCONFIG_CONTIG:
    #####: 1685:				break;
    #####: 1686:			case PLANARCONFIG_SEPARATE:
    #####: 1687:				t2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;
    #####: 1688:				if(t2p->tiff_bitspersample!=8){
    #####: 1689:					TIFFError(
        -: 1690:						TIFF2PDF_MODULE, 
        -: 1691:						"No support for %s with separated planar configuration and %u bits per sample", 
        -: 1692:						TIFFFileName(input),
    #####: 1693:						t2p->tiff_bitspersample);
    #####: 1694:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1695:					return;
        -: 1696:				}
    #####: 1697:				break;
    #####: 1698:			default:
    #####: 1699:				TIFFError(
        -: 1700:					TIFF2PDF_MODULE, 
        -: 1701:					"No support for %s with planar configuration %u", 
        -: 1702:					TIFFFileName(input),
    #####: 1703:					t2p->tiff_planar);
    #####: 1704:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1705:				return;
        -: 1706:		}
    #####: 1707:	}
        -: 1708:
    #####: 1709:        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,
        -: 1710:                              &(t2p->tiff_orientation));
    #####: 1711:        if(t2p->tiff_orientation>8){
    #####: 1712:                TIFFWarning(TIFF2PDF_MODULE,
        -: 1713:                            "Image %s has orientation %u, assuming 0",
    #####: 1714:                            TIFFFileName(input), t2p->tiff_orientation);
    #####: 1715:                t2p->tiff_orientation=0;
        -: 1716:        }
        -: 1717:
    #####: 1718:        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){
    #####: 1719:                t2p->tiff_xres=0.0;
        -: 1720:        }
    #####: 1721:        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){
    #####: 1722:                t2p->tiff_yres=0.0;
        -: 1723:        }
    #####: 1724:	TIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,
        -: 1725:			      &(t2p->tiff_resunit));
    #####: 1726:	if(t2p->tiff_resunit == RESUNIT_CENTIMETER) {
    #####: 1727:		t2p->tiff_xres *= 2.54F;
    #####: 1728:		t2p->tiff_yres *= 2.54F;
    #####: 1729:	} else if (t2p->tiff_resunit != RESUNIT_INCH
    #####: 1730:		   && t2p->pdf_centimeters != 0) {
    #####: 1731:		t2p->tiff_xres *= 2.54F;
    #####: 1732:		t2p->tiff_yres *= 2.54F;
        -: 1733:	}
        -: 1734:
    #####: 1735:	t2p_compose_pdf_page(t2p);
    #####: 1736:        if( t2p->t2p_error == T2P_ERR_ERROR )
    #####: 1737:	    return;
        -: 1738:
    #####: 1739:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
    #####: 1740:	if(t2p->pdf_nopassthrough==0){
        -: 1741:#ifdef CCITT_SUPPORT
    #####: 1742:		if(t2p->tiff_compression==COMPRESSION_CCITTFAX4  
        -: 1743:			){
    #####: 1744:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
    #####: 1745:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1746:				t2p->pdf_compression=T2P_COMPRESS_G4;
        -: 1747:			}
        -: 1748:		}
        -: 1749:#endif
        -: 1750:#ifdef ZIP_SUPPORT
        -: 1751:		if(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE 
        -: 1752:			|| t2p->tiff_compression==COMPRESSION_DEFLATE){
        -: 1753:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
        -: 1754:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
        -: 1755:				t2p->pdf_compression=T2P_COMPRESS_ZIP;
        -: 1756:			}
        -: 1757:		}
        -: 1758:#endif
        -: 1759:#ifdef OJPEG_SUPPORT
    #####: 1760:		if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1761:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1762:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
    #####: 1763:			t2p_process_ojpeg_tables(t2p, input);
        -: 1764:		}
        -: 1765:#endif
        -: 1766:#ifdef JPEG_SUPPORT
    #####: 1767:		if(t2p->tiff_compression==COMPRESSION_JPEG){
    #####: 1768:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1769:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
        -: 1770:		}
        -: 1771:#endif
        -: 1772:		(void)0;
        -: 1773:	}
        -: 1774:
    #####: 1775:	if(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){
    #####: 1776:		t2p->pdf_compression = t2p->pdf_defaultcompression;
        -: 1777:	}
        -: 1778:
        -: 1779:#ifdef JPEG_SUPPORT
    #####: 1780:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1781:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 1782:			t2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;
    #####: 1783:			t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 1784:			t2p->tiff_pages[t2p->pdf_page].page_extra--;
        -: 1785:		}
        -: 1786:	}
    #####: 1787:	if(t2p->tiff_compression==COMPRESSION_JPEG){
    #####: 1788:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1789:			TIFFError(
        -: 1790:				TIFF2PDF_MODULE, 
        -: 1791:				"No support for %s with JPEG compression and separated planar configuration", 
        -: 1792:				TIFFFileName(input));
    #####: 1793:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1794:			return;
        -: 1795:		}
        -: 1796:	}
        -: 1797:#endif
        -: 1798:#ifdef OJPEG_SUPPORT
    #####: 1799:	if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1800:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1801:			TIFFError(
        -: 1802:				TIFF2PDF_MODULE, 
        -: 1803:				"No support for %s with OJPEG compression and separated planar configuration", 
        -: 1804:				TIFFFileName(input));
    #####: 1805:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1806:			return;
        -: 1807:		}
        -: 1808:	}
        -: 1809:#endif
        -: 1810:
    #####: 1811:	if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
    #####: 1812:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 1813:			t2p->tiff_samplesperpixel=4;
    #####: 1814:			t2p->tiff_photometric=PHOTOMETRIC_SEPARATED;
        -: 1815:		} else {
    #####: 1816:			t2p->tiff_samplesperpixel=3;
    #####: 1817:			t2p->tiff_photometric=PHOTOMETRIC_RGB;
        -: 1818:		}
        -: 1819:	}
        -: 1820:
    #####: 1821:	if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1822:			 &(t2p->tiff_transferfunction[0]),
        -: 1823:			 &(t2p->tiff_transferfunction[1]),
        -: 1824:			 &(t2p->tiff_transferfunction[2]))) {
    #####: 1825:		if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1826:                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1827:                   (t2p->tiff_transferfunction[1] !=
    #####: 1828:                    t2p->tiff_transferfunction[0])) {
    #####: 1829:			t2p->tiff_transferfunctioncount=3;
        -: 1830:		} else {
    #####: 1831:			t2p->tiff_transferfunctioncount=1;
        -: 1832:		}
        -: 1833:	} else {
    #####: 1834:		t2p->tiff_transferfunctioncount=0;
        -: 1835:	}
    #####: 1836:	if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){
    #####: 1837:		t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1838:		t2p->tiff_whitechromaticities[1]=xfloatp[1];
    #####: 1839:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 1840:			t2p->pdf_colorspace |= T2P_CS_CALGRAY;
        -: 1841:		}
    #####: 1842:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1843:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1844:		}
        -: 1845:	}
    #####: 1846:	if(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){
    #####: 1847:		t2p->tiff_primarychromaticities[0]=xfloatp[0];
    #####: 1848:		t2p->tiff_primarychromaticities[1]=xfloatp[1];
    #####: 1849:		t2p->tiff_primarychromaticities[2]=xfloatp[2];
    #####: 1850:		t2p->tiff_primarychromaticities[3]=xfloatp[3];
    #####: 1851:		t2p->tiff_primarychromaticities[4]=xfloatp[4];
    #####: 1852:		t2p->tiff_primarychromaticities[5]=xfloatp[5];
    #####: 1853:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1854:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1855:		}
        -: 1856:	}
    #####: 1857:	if(t2p->pdf_colorspace & T2P_CS_LAB){
    #####: 1858:		if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){
    #####: 1859:			t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1860:			t2p->tiff_whitechromaticities[1]=xfloatp[1];
        -: 1861:		} else {
    #####: 1862:			t2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */
    #####: 1863:			t2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */
        -: 1864:		}
        -: 1865:	}
    #####: 1866:	if(TIFFGetField(input, 
        -: 1867:		TIFFTAG_ICCPROFILE, 
        -: 1868:		&(t2p->tiff_iccprofilelength), 
        -: 1869:		&(t2p->tiff_iccprofile))!=0){
    #####: 1870:		t2p->pdf_colorspace |= T2P_CS_ICCBASED;
        -: 1871:	} else {
    #####: 1872:		t2p->tiff_iccprofilelength=0;
    #####: 1873:		t2p->tiff_iccprofile=NULL;
        -: 1874:	}
        -: 1875:	
        -: 1876:#ifdef CCITT_SUPPORT
    #####: 1877:	if( t2p->tiff_bitspersample==1 &&
    #####: 1878:		t2p->tiff_samplesperpixel==1){
    #####: 1879:		t2p->pdf_compression = T2P_COMPRESS_G4;
        -: 1880:	}
        -: 1881:#endif
        -: 1882:
        -: 1883:
    #####: 1884:	return;
        -: 1885:}
        -: 1886:
        -: 1887:/*
        -: 1888:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 1889:	uncompressed image data from the input TIFF for a page.
        -: 1890:*/
        -: 1891:
    #####: 1892:void t2p_read_tiff_size(T2P* t2p, TIFF* input){
        -: 1893:
    #####: 1894:	uint64* sbc=NULL;
        -: 1895:#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
    #####: 1896:	unsigned char* jpt=NULL;
    #####: 1897:	tstrip_t i=0;
    #####: 1898:	tstrip_t stripcount=0;
        -: 1899:#endif
    #####: 1900:        uint64 k = 0;
        -: 1901:
    #####: 1902:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 1903:#ifdef CCITT_SUPPORT
    #####: 1904:		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
    #####: 1905:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1906:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1907:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1908:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1909:            }
    #####: 1910:			t2p->tiff_datasize=(tmsize_t)sbc[0];
    #####: 1911:			return;
        -: 1912:		}
        -: 1913:#endif
        -: 1914:#ifdef ZIP_SUPPORT
        -: 1915:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 1916:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1917:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1918:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1919:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1920:            }
        -: 1921:			t2p->tiff_datasize=(tmsize_t)sbc[0];
        -: 1922:			return;
        -: 1923:		}
        -: 1924:#endif
        -: 1925:#ifdef OJPEG_SUPPORT
    #####: 1926:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 1927:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 1928:				TIFFError(TIFF2PDF_MODULE, 
        -: 1929:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 1930:					TIFFFileName(input));
    #####: 1931:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1932:				return;
        -: 1933:			}
    #####: 1934:			stripcount=TIFFNumberOfStrips(input);
    #####: 1935:			for(i=0;i<stripcount;i++){
    #####: 1936:				k = checkAdd64(k, sbc[i], t2p);
        -: 1937:			}
    #####: 1938:			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
    #####: 1939:				if(t2p->tiff_dataoffset != 0){
    #####: 1940:					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
    #####: 1941:						if((uint64)t2p->tiff_datasize < k) {
    #####: 1942:							TIFFWarning(TIFF2PDF_MODULE, 
        -: 1943:								"Input file %s has short JPEG interchange file byte count", 
        -: 1944:								TIFFFileName(input));
    #####: 1945:							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
    #####: 1946:							k = checkAdd64(k, t2p->tiff_datasize, t2p);
    #####: 1947:							k = checkAdd64(k, 6, t2p);
    #####: 1948:							k = checkAdd64(k, stripcount, t2p);
    #####: 1949:							k = checkAdd64(k, stripcount, t2p);
    #####: 1950:							t2p->tiff_datasize = (tsize_t) k;
    #####: 1951:							if ((uint64) t2p->tiff_datasize != k) {
    #####: 1952:								TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 1953:								t2p->t2p_error = T2P_ERR_ERROR;
        -: 1954:							}
    #####: 1955:							return;
        -: 1956:						}
    #####: 1957:						return;
        -: 1958:					}else {
    #####: 1959:						TIFFError(TIFF2PDF_MODULE, 
        -: 1960:							"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT",
        -: 1961:							TIFFFileName(input));
    #####: 1962:							t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1963:							return;
        -: 1964:					}
        -: 1965:				}
        -: 1966:			}
    #####: 1967:			k = checkAdd64(k, stripcount, t2p);
    #####: 1968:			k = checkAdd64(k, stripcount, t2p);
    #####: 1969:			k = checkAdd64(k, 2048, t2p);
    #####: 1970:			t2p->tiff_datasize = (tsize_t) k;
    #####: 1971:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 1972:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 1973:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 1974:			}
    #####: 1975:			return;
        -: 1976:		}
        -: 1977:#endif
        -: 1978:#ifdef JPEG_SUPPORT
    #####: 1979:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 1980:			uint32 count = 0;
    #####: 1981:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
    #####: 1982:				if(count > 4){
    #####: 1983:					k += count;
    #####: 1984:					k -= 2; /* don't use EOI of header */
        -: 1985:				}
        -: 1986:			} else {
    #####: 1987:				k = 2; /* SOI for first strip */
        -: 1988:			}
    #####: 1989:			stripcount=TIFFNumberOfStrips(input);
    #####: 1990:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 1991:				TIFFError(TIFF2PDF_MODULE, 
        -: 1992:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 1993:					TIFFFileName(input));
    #####: 1994:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1995:				return;
        -: 1996:			}
    #####: 1997:			for(i=0;i<stripcount;i++){
    #####: 1998:				k = checkAdd64(k, sbc[i], t2p);
    #####: 1999:				k -=2; /* don't use EOI of strip */
    #####: 2000:				k +=2; /* add space for restart marker */
        -: 2001:			}
    #####: 2002:			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
    #####: 2003:			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
    #####: 2004:			t2p->tiff_datasize = (tsize_t) k;
    #####: 2005:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2006:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2007:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2008:			}
    #####: 2009:			return;
        -: 2010:		}
        -: 2011:#endif
        -: 2012:		(void) 0;
        -: 2013:	}
    #####: 2014:	k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
    #####: 2015:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2016:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2017:	}
    #####: 2018:	if (k == 0) {
        -: 2019:		/* Assume we had overflow inside TIFFScanlineSize */
    #####: 2020:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2021:	}
        -: 2022:
    #####: 2023:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2024:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2025:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2026:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2027:	}
        -: 2028:
    #####: 2029:	return;
        -: 2030:}
        -: 2031:
        -: 2032:/*
        -: 2033:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 2034:	uncompressed image data from the input TIFF for a tile of a page.
        -: 2035:*/
        -: 2036:
    #####: 2037:void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){
        -: 2038:
    #####: 2039:	uint64* tbc = NULL;
    #####: 2040:	uint16 edge=0;
        -: 2041:#ifdef JPEG_SUPPORT
    #####: 2042:	unsigned char* jpt;
        -: 2043:#endif
        -: 2044:        uint64 k;
        -: 2045:
    #####: 2046:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
    #####: 2047:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2048:	
    #####: 2049:	if(t2p->pdf_transcode==T2P_TRANSCODE_RAW){
    #####: 2050:		if(edge
        -: 2051:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
    #####: 2052:		&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)
        -: 2053:#endif
        -: 2054:		){
    #####: 2055:			t2p->tiff_datasize=TIFFTileSize(input);
    #####: 2056:			if (t2p->tiff_datasize == 0) {
        -: 2057:				/* Assume we had overflow inside TIFFTileSize */
    #####: 2058:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2059:			}
    #####: 2060:			return;
        -: 2061:		} else {
    #####: 2062:			TIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);
    #####: 2063:			k=tbc[tile];
        -: 2064:#ifdef OJPEG_SUPPORT
    #####: 2065:			if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 2066:			  	k = checkAdd64(k, 2048, t2p);
        -: 2067:			}
        -: 2068:#endif
        -: 2069:#ifdef JPEG_SUPPORT
    #####: 2070:			if(t2p->tiff_compression==COMPRESSION_JPEG) {
    #####: 2071:				uint32 count = 0;
    #####: 2072:				if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){
    #####: 2073:					if(count > 4){
    #####: 2074:						k = checkAdd64(k, count, t2p);
    #####: 2075:						k -= 2; /* don't use EOI of header or SOI of tile */
        -: 2076:					}
        -: 2077:				}
        -: 2078:			}
        -: 2079:#endif
    #####: 2080:			t2p->tiff_datasize = (tsize_t) k;
    #####: 2081:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2082:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2083:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2084:			}
    #####: 2085:			return;
        -: 2086:		}
        -: 2087:	}
    #####: 2088:	k = TIFFTileSize(input);
    #####: 2089:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2090:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2091:	}
    #####: 2092:	if (k == 0) {
        -: 2093:		/* Assume we had overflow inside TIFFTileSize */
    #####: 2094:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2095:	}
        -: 2096:
    #####: 2097:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2098:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2099:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2100:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2101:	}
        -: 2102:
    #####: 2103:	return;
        -: 2104:}
        -: 2105:
        -: 2106:/*
        -: 2107: * This functions returns a non-zero value when the tile is on the right edge
        -: 2108: * and does not have full imaged tile width.
        -: 2109: */
        -: 2110:
    #####: 2111:int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){
        -: 2112:
    #####: 2113:	if( ((tile+1) % tiles.tiles_tilecountx == 0) 
    #####: 2114:		&& (tiles.tiles_edgetilewidth != 0) ){
    #####: 2115:		return(1);
        -: 2116:	} else {
    #####: 2117:		return(0);
        -: 2118:	}
        -: 2119:}
        -: 2120:
        -: 2121:/*
        -: 2122: * This functions returns a non-zero value when the tile is on the bottom edge
        -: 2123: * and does not have full imaged tile length.
        -: 2124: */
        -: 2125:
    #####: 2126:int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){
        -: 2127:
    #####: 2128:	if( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )
    #####: 2129:		&& (tiles.tiles_edgetilelength != 0) ){
    #####: 2130:		return(1);
        -: 2131:	} else {
    #####: 2132:		return(0);
        -: 2133:	}
        -: 2134:}
        -: 2135:
        -: 2136:/*
        -: 2137: * This function returns a non-zero value when the tile is a right edge tile
        -: 2138: * or a bottom edge tile.
        -: 2139: */
        -: 2140:
    #####: 2141:int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){
        -: 2142:
    #####: 2143:	return(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2144:}
        -: 2145:
        -: 2146:/*
        -: 2147:	This function returns a non-zero value when the tile is a right edge tile and a bottom 
        -: 2148:	edge tile.
        -: 2149:*/
        -: 2150:
    #####: 2151:int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){
        -: 2152:
    #####: 2153:	return(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2154:}
        -: 2155:
        -: 2156:
        -: 2157:/*
        -: 2158:	This function reads the raster image data from the input TIFF for an image and writes 
        -: 2159:	the data to the output PDF XObject image dictionary stream.  It returns the amount written 
        -: 2160:	or zero on error.
        -: 2161:*/
        -: 2162:
    #####: 2163:tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){
        -: 2164:
    #####: 2165:	tsize_t written=0;
    #####: 2166:	unsigned char* buffer=NULL;
    #####: 2167:	unsigned char* samplebuffer=NULL;
    #####: 2168:	tsize_t bufferoffset=0;
    #####: 2169:	tsize_t samplebufferoffset=0;
    #####: 2170:	tsize_t read=0;
    #####: 2171:	tstrip_t i=0;
    #####: 2172:	tstrip_t j=0;
    #####: 2173:	tstrip_t stripcount=0;
    #####: 2174:	tsize_t stripsize=0;
    #####: 2175:	tsize_t sepstripcount=0;
    #####: 2176:	tsize_t sepstripsize=0;
        -: 2177:#ifdef OJPEG_SUPPORT
    #####: 2178:	toff_t inputoffset=0;
    #####: 2179:	uint16 h_samp=1;
    #####: 2180:	uint16 v_samp=1;
    #####: 2181:	uint16 ri=1;
    #####: 2182:	uint32 rows=0;
        -: 2183:#endif /* ifdef OJPEG_SUPPORT */
        -: 2184:#ifdef JPEG_SUPPORT
    #####: 2185:	unsigned char* jpt;
    #####: 2186:	float* xfloatp;
    #####: 2187:	uint64* sbc;
        -: 2188:	unsigned char* stripbuffer;
    #####: 2189:	tsize_t striplength=0;
    #####: 2190:	uint32 max_striplength=0;
        -: 2191:#endif /* ifdef JPEG_SUPPORT */
        -: 2192:
        -: 2193:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
    #####: 2194:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2195:		return(0);
        -: 2196:
    #####: 2197:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 2198:#ifdef CCITT_SUPPORT
    #####: 2199:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
        -: 2200:			buffer = (unsigned char*)
    #####: 2201:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2202:			if (buffer == NULL) {
    #####: 2203:				TIFFError(TIFF2PDF_MODULE, 
        -: 2204:                                          "Can't allocate %lu bytes of memory for "
        -: 2205:                                          "t2p_readwrite_pdf_image, %s", 
    #####: 2206:					(unsigned long) t2p->tiff_datasize, 
        -: 2207:					TIFFFileName(input));
    #####: 2208:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2209:				return(0);
        -: 2210:			}
    #####: 2211:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2212:					 t2p->tiff_datasize);
    #####: 2213:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2214:					/*
        -: 2215:					 * make sure is lsb-to-msb
        -: 2216:					 * bit-endianness fill order
        -: 2217:					 */
    #####: 2218:					TIFFReverseBits(buffer,
        -: 2219:							t2p->tiff_datasize);
        -: 2220:			}
    #####: 2221:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2222:				      t2p->tiff_datasize);
    #####: 2223:			_TIFFfree(buffer);
    #####: 2224:			return(t2p->tiff_datasize);
        -: 2225:		}
        -: 2226:#endif /* ifdef CCITT_SUPPORT */
        -: 2227:#ifdef ZIP_SUPPORT
        -: 2228:		if (t2p->pdf_compression == T2P_COMPRESS_ZIP) {
        -: 2229:			buffer = (unsigned char*)
        -: 2230:				_TIFFmalloc(t2p->tiff_datasize);
        -: 2231:			if(buffer == NULL){
        -: 2232:				TIFFError(TIFF2PDF_MODULE, 
        -: 2233:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2234:					(unsigned long) t2p->tiff_datasize, 
        -: 2235:					TIFFFileName(input));
        -: 2236:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2237:				return(0);
        -: 2238:			}
        -: 2239:                        memset(buffer, 0, t2p->tiff_datasize);
        -: 2240:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2241:					 t2p->tiff_datasize);
        -: 2242:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {
        -: 2243:					TIFFReverseBits(buffer,
        -: 2244:							t2p->tiff_datasize);
        -: 2245:			}
        -: 2246:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2247:				      t2p->tiff_datasize);
        -: 2248:			_TIFFfree(buffer);
        -: 2249:			return(t2p->tiff_datasize);
        -: 2250:		}
        -: 2251:#endif /* ifdef ZIP_SUPPORT */
        -: 2252:#ifdef OJPEG_SUPPORT
    #####: 2253:		if(t2p->tiff_compression == COMPRESSION_OJPEG) {
        -: 2254:
    #####: 2255:			if(t2p->tiff_dataoffset != 0) {
        -: 2256:				buffer = (unsigned char*)
    #####: 2257:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2258:				if(buffer == NULL) {
    #####: 2259:					TIFFError(TIFF2PDF_MODULE, 
        -: 2260:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2261:						(unsigned long) t2p->tiff_datasize, 
        -: 2262:						TIFFFileName(input));
    #####: 2263:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2264:					return(0);
        -: 2265:				}
    #####: 2266:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2267:				if(t2p->pdf_ojpegiflength==0){
    #####: 2268:					inputoffset=t2pSeekFile(input, 0,
        -: 2269:								 SEEK_CUR);
    #####: 2270:					t2pSeekFile(input,
        -: 2271:						     t2p->tiff_dataoffset,
        -: 2272:						     SEEK_SET);
    #####: 2273:					t2pReadFile(input, (tdata_t) buffer,
        -: 2274:						     t2p->tiff_datasize);
    #####: 2275:					t2pSeekFile(input, inputoffset,
        -: 2276:						     SEEK_SET);
    #####: 2277:					t2pWriteFile(output, (tdata_t) buffer,
        -: 2278:						      t2p->tiff_datasize);
    #####: 2279:					_TIFFfree(buffer);
    #####: 2280:					return(t2p->tiff_datasize);
        -: 2281:				} else {
    #####: 2282:					inputoffset=t2pSeekFile(input, 0,
        -: 2283:								 SEEK_CUR);
    #####: 2284:					t2pSeekFile(input,
        -: 2285:						     t2p->tiff_dataoffset,
        -: 2286:						     SEEK_SET);
    #####: 2287:					bufferoffset = t2pReadFile(input,
        -: 2288:						(tdata_t) buffer,
    #####: 2289:						t2p->pdf_ojpegiflength);
    #####: 2290:					t2p->pdf_ojpegiflength = 0;
    #####: 2291:					t2pSeekFile(input, inputoffset,
        -: 2292:						     SEEK_SET);
    #####: 2293:					TIFFGetField(input,
        -: 2294:						     TIFFTAG_YCBCRSUBSAMPLING,
        -: 2295:						     &h_samp, &v_samp);
    #####: 2296:					buffer[bufferoffset++]= 0xff;
    #####: 2297:					buffer[bufferoffset++]= 0xdd;
    #####: 2298:					buffer[bufferoffset++]= 0x00;
    #####: 2299:					buffer[bufferoffset++]= 0x04;
    #####: 2300:					h_samp*=8;
    #####: 2301:					v_samp*=8;
    #####: 2302:					ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 2303:					TIFFGetField(input,
        -: 2304:						     TIFFTAG_ROWSPERSTRIP,
        -: 2305:						     &rows);
    #####: 2306:					ri*=(rows+v_samp-1)/v_samp;
    #####: 2307:					buffer[bufferoffset++]= (ri>>8) & 0xff;
    #####: 2308:					buffer[bufferoffset++]= ri & 0xff;
    #####: 2309:					stripcount=TIFFNumberOfStrips(input);
    #####: 2310:					for(i=0;i<stripcount;i++){
    #####: 2311:						if(i != 0 ){ 
    #####: 2312:							buffer[bufferoffset++]=0xff;
    #####: 2313:							buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2314:						}
    #####: 2315:						bufferoffset+=TIFFReadRawStrip(input, 
        -: 2316:							i, 
    #####: 2317:							(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2318:							-1);
        -: 2319:					}
    #####: 2320:					t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2321:					_TIFFfree(buffer);
    #####: 2322:					return(bufferoffset);
        -: 2323:				}
        -: 2324:			} else {
    #####: 2325:				if(! t2p->pdf_ojpegdata){
    #####: 2326:					TIFFError(TIFF2PDF_MODULE, 
        -: 2327:				"No support for OJPEG image %s with bad tables", 
        -: 2328:						TIFFFileName(input));
    #####: 2329:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2330:					return(0);
        -: 2331:				}
        -: 2332:				buffer = (unsigned char*)
    #####: 2333:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2334:				if(buffer==NULL){
    #####: 2335:					TIFFError(TIFF2PDF_MODULE, 
        -: 2336:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2337:						(unsigned long) t2p->tiff_datasize, 
        -: 2338:						TIFFFileName(input));
    #####: 2339:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2340:					return(0);
        -: 2341:				}
    #####: 2342:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2343:				_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2344:				bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2345:				stripcount=TIFFNumberOfStrips(input);
    #####: 2346:				for(i=0;i<stripcount;i++){
    #####: 2347:					if(i != 0){
    #####: 2348:						buffer[bufferoffset++]=0xff;
    #####: 2349:						buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2350:					}
    #####: 2351:					bufferoffset+=TIFFReadRawStrip(input, 
        -: 2352:						i, 
    #####: 2353:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2354:						-1);
        -: 2355:				}
    #####: 2356:				if( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){
    #####: 2357:						buffer[bufferoffset++]=0xff;
    #####: 2358:						buffer[bufferoffset++]=0xd9;
        -: 2359:				}
    #####: 2360:				t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2361:				_TIFFfree(buffer);
    #####: 2362:				return(bufferoffset);
        -: 2363:#if 0
        -: 2364:                                /*
        -: 2365:                                  This hunk of code removed code is clearly
        -: 2366:                                  mis-placed and we are not sure where it
        -: 2367:                                  should be (if anywhere)
        -: 2368:                                */
        -: 2369:				TIFFError(TIFF2PDF_MODULE, 
        -: 2370:	"No support for OJPEG image %s with no JPEG File Interchange offset", 
        -: 2371:					TIFFFileName(input));
        -: 2372:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2373:				return(0);
        -: 2374:#endif
        -: 2375:			}
        -: 2376:		}
        -: 2377:#endif /* ifdef OJPEG_SUPPORT */
        -: 2378:#ifdef JPEG_SUPPORT
    #####: 2379:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 2380:			uint32 count = 0;
        -: 2381:			buffer = (unsigned char*)
    #####: 2382:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2383:			if(buffer==NULL){
    #####: 2384:				TIFFError(TIFF2PDF_MODULE, 
        -: 2385:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2386:					(unsigned long) t2p->tiff_datasize, 
        -: 2387:					TIFFFileName(input));
    #####: 2388:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2389:				return(0);
        -: 2390:			}
    #####: 2391:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2392:			if (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
    #####: 2393:				if(count > 4) {
    #####: 2394:					_TIFFmemcpy(buffer, jpt, count);
    #####: 2395:					bufferoffset += count - 2;
        -: 2396:				}
        -: 2397:			}
    #####: 2398:			stripcount=TIFFNumberOfStrips(input);
    #####: 2399:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
    #####: 2400:			for(i=0;i<stripcount;i++){
    #####: 2401:				if(sbc[i]>max_striplength) max_striplength=sbc[i];
        -: 2402:			}
        -: 2403:			stripbuffer = (unsigned char*)
    #####: 2404:				_TIFFmalloc(max_striplength);
    #####: 2405:			if(stripbuffer==NULL){
    #####: 2406:				TIFFError(TIFF2PDF_MODULE, 
        -: 2407:	"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2408:					max_striplength, 
        -: 2409:					TIFFFileName(input));
    #####: 2410:				_TIFFfree(buffer);
    #####: 2411:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2412:				return(0);
        -: 2413:			}
    #####: 2414:			for(i=0;i<stripcount;i++){
    #####: 2415:				striplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);
    #####: 2416:				if(!t2p_process_jpeg_strip(
        -: 2417:					stripbuffer, 
        -: 2418:					&striplength, 
        -: 2419:					buffer,
        -: 2420:                    t2p->tiff_datasize,
        -: 2421:					&bufferoffset, 
        -: 2422:					i, 
        -: 2423:					t2p->tiff_length)){
    #####: 2424:						TIFFError(TIFF2PDF_MODULE, 
        -: 2425:				"Can't process JPEG data in input file %s", 
        -: 2426:							TIFFFileName(input));
    #####: 2427:						_TIFFfree(samplebuffer);
    #####: 2428:						_TIFFfree(buffer);
    #####: 2429:						t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2430:						return(0);
        -: 2431:				}
        -: 2432:			}
    #####: 2433:			buffer[bufferoffset++]=0xff; 
    #####: 2434:			buffer[bufferoffset++]=0xd9;
    #####: 2435:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2436:			_TIFFfree(stripbuffer);
    #####: 2437:			_TIFFfree(buffer);
    #####: 2438:			return(bufferoffset);
        -: 2439:		}
        -: 2440:#endif /* ifdef JPEG_SUPPORT */
        -: 2441:		(void)0;
        -: 2442:	}
        -: 2443:
    #####: 2444:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2445:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2446:		if(buffer==NULL){
    #####: 2447:			TIFFError(TIFF2PDF_MODULE, 
        -: 2448:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2449:				(unsigned long) t2p->tiff_datasize, 
        -: 2450:				TIFFFileName(input));
    #####: 2451:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2452:			return(0);
        -: 2453:		}
    #####: 2454:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2455:		stripsize=TIFFStripSize(input);
    #####: 2456:		stripcount=TIFFNumberOfStrips(input);
    #####: 2457:		for(i=0;i<stripcount;i++){
        -: 2458:			read = 
    #####: 2459:				TIFFReadEncodedStrip(input, 
        -: 2460:				i, 
    #####: 2461:				(tdata_t) &buffer[bufferoffset], 
    #####: 2462:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2463:			if(read==-1){
    #####: 2464:				TIFFError(TIFF2PDF_MODULE, 
        -: 2465:					"Error on decoding strip %u of %s", 
        -: 2466:					i, 
        -: 2467:					TIFFFileName(input));
    #####: 2468:				_TIFFfree(buffer);
    #####: 2469:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2470:				return(0);
        -: 2471:			}
    #####: 2472:			bufferoffset+=read;
        -: 2473:		}
        -: 2474:	} else {
    #####: 2475:		if(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
        -: 2476:		
    #####: 2477:			sepstripsize=TIFFStripSize(input);
    #####: 2478:			sepstripcount=TIFFNumberOfStrips(input);
        -: 2479:		
    #####: 2480:			stripsize=sepstripsize*t2p->tiff_samplesperpixel;
    #####: 2481:			stripcount=sepstripcount/t2p->tiff_samplesperpixel;
        -: 2482:			
    #####: 2483:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2484:			if(buffer==NULL){
    #####: 2485:				TIFFError(TIFF2PDF_MODULE, 
        -: 2486:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2487:					(unsigned long) t2p->tiff_datasize, 
        -: 2488:					TIFFFileName(input));
    #####: 2489:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2490:				return(0);
        -: 2491:			}
    #####: 2492:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2493:			samplebuffer = (unsigned char*) _TIFFmalloc(stripsize);
    #####: 2494:			if(samplebuffer==NULL){
    #####: 2495:				TIFFError(TIFF2PDF_MODULE, 
        -: 2496:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2497:					(unsigned long) t2p->tiff_datasize, 
        -: 2498:					TIFFFileName(input));
    #####: 2499:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2500:                                _TIFFfree(buffer);
    #####: 2501:				return(0);
        -: 2502:			}
    #####: 2503:			for(i=0;i<stripcount;i++){
    #####: 2504:				samplebufferoffset=0;
    #####: 2505:				for(j=0;j<t2p->tiff_samplesperpixel;j++){
        -: 2506:					read = 
    #####: 2507:						TIFFReadEncodedStrip(input, 
    #####: 2508:							i + j*stripcount, 
    #####: 2509:							(tdata_t) &(samplebuffer[samplebufferoffset]), 
    #####: 2510:							TIFFmin(sepstripsize, stripsize - samplebufferoffset));
    #####: 2511:					if(read==-1){
    #####: 2512:						TIFFError(TIFF2PDF_MODULE, 
        -: 2513:					"Error on decoding strip %u of %s", 
    #####: 2514:							i + j*stripcount, 
        -: 2515:							TIFFFileName(input));
    #####: 2516:							_TIFFfree(buffer);
    #####: 2517:						t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2518:						return(0);
        -: 2519:					}
    #####: 2520:					samplebufferoffset+=read;
        -: 2521:				}
    #####: 2522:				t2p_sample_planar_separate_to_contig(
        -: 2523:					t2p,
        -: 2524:					&(buffer[bufferoffset]),
        -: 2525:					samplebuffer, 
        -: 2526:					samplebufferoffset); 
    #####: 2527:				bufferoffset+=samplebufferoffset;
        -: 2528:			}
    #####: 2529:			_TIFFfree(samplebuffer);
    #####: 2530:			goto dataready;
        -: 2531:		}
        -: 2532:
    #####: 2533:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2534:		if(buffer==NULL){
    #####: 2535:			TIFFError(TIFF2PDF_MODULE, 
        -: 2536:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2537:				(unsigned long) t2p->tiff_datasize, 
        -: 2538:				TIFFFileName(input));
    #####: 2539:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2540:			return(0);
        -: 2541:		}
    #####: 2542:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2543:		stripsize=TIFFStripSize(input);
    #####: 2544:		stripcount=TIFFNumberOfStrips(input);
    #####: 2545:		for(i=0;i<stripcount;i++){
        -: 2546:			read = 
    #####: 2547:				TIFFReadEncodedStrip(input, 
        -: 2548:				i, 
    #####: 2549:				(tdata_t) &buffer[bufferoffset], 
    #####: 2550:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2551:			if(read==-1){
    #####: 2552:				TIFFError(TIFF2PDF_MODULE, 
        -: 2553:					"Error on decoding strip %u of %s", 
        -: 2554:					i, 
        -: 2555:					TIFFFileName(input));
    #####: 2556:				_TIFFfree(samplebuffer);
    #####: 2557:				_TIFFfree(buffer);
    #####: 2558:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2559:				return(0);
        -: 2560:			}
    #####: 2561:			bufferoffset+=read;
        -: 2562:		}
        -: 2563:
    #####: 2564:		if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
        -: 2565:			// FIXME: overflow?
    #####: 2566:			samplebuffer=(unsigned char*)_TIFFrealloc( 
        -: 2567:				(tdata_t) buffer, 
    #####: 2568:				t2p->tiff_datasize * t2p->tiff_samplesperpixel);
    #####: 2569:			if(samplebuffer==NULL){
    #####: 2570:				TIFFError(TIFF2PDF_MODULE, 
        -: 2571:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2572:					(unsigned long) t2p->tiff_datasize, 
        -: 2573:					TIFFFileName(input));
    #####: 2574:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2575:				_TIFFfree(buffer);
    #####: 2576:				return(0);
        -: 2577:			} else {
    #####: 2578:				buffer=samplebuffer;
    #####: 2579:				t2p->tiff_datasize *= t2p->tiff_samplesperpixel;
        -: 2580:			}
    #####: 2581:			t2p_sample_realize_palette(t2p, buffer);
        -: 2582:		}
        -: 2583:
    #####: 2584:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 2585:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 2586:				(tdata_t)buffer, 
    #####: 2587:				t2p->tiff_width*t2p->tiff_length);
        -: 2588:		}
        -: 2589:
    #####: 2590:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 2591:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 2592:				(tdata_t)buffer, 
    #####: 2593:				t2p->tiff_width*t2p->tiff_length);
        -: 2594:		}
        -: 2595:
    #####: 2596:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 2597:			samplebuffer=(unsigned char*)_TIFFrealloc(
        -: 2598:				(tdata_t)buffer, 
    #####: 2599:				t2p->tiff_width*t2p->tiff_length*4);
    #####: 2600:			if(samplebuffer==NULL){
    #####: 2601:				TIFFError(TIFF2PDF_MODULE, 
        -: 2602:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2603:					(unsigned long) t2p->tiff_datasize, 
        -: 2604:					TIFFFileName(input));
    #####: 2605:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2606:				_TIFFfree(buffer);
    #####: 2607:				return(0);
        -: 2608:			} else {
    #####: 2609:				buffer=samplebuffer;
        -: 2610:			}
    #####: 2611:			if(!TIFFReadRGBAImageOriented(
        -: 2612:				input, 
        -: 2613:				t2p->tiff_width, 
        -: 2614:				t2p->tiff_length, 
        -: 2615:				(uint32*)buffer, 
        -: 2616:				ORIENTATION_TOPLEFT,
        -: 2617:				0)){
    #####: 2618:				TIFFError(TIFF2PDF_MODULE, 
        -: 2619:	"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s", 
        -: 2620:					TIFFFileName(input));
    #####: 2621:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2622:				return(0);
        -: 2623:			}
    #####: 2624:			t2p->tiff_datasize=t2p_sample_abgr_to_rgb(
        -: 2625:				(tdata_t) buffer, 
    #####: 2626:				t2p->tiff_width*t2p->tiff_length);
        -: 2627:
        -: 2628:		}
        -: 2629:
    #####: 2630:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 2631:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 2632:				(tdata_t)buffer, 
    #####: 2633:				t2p->tiff_width*t2p->tiff_length);
        -: 2634:		}
        -: 2635:	}
        -: 2636:
    #####: 2637:dataready:
        -: 2638:
    #####: 2639:	t2p_disable(output);
    #####: 2640:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 2641:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 2642:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 2643:	TIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);
    #####: 2644:	TIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);
    #####: 2645:	TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);
    #####: 2646:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 2647:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 2648:
    #####: 2649:	switch(t2p->pdf_compression){
    #####: 2650:	case T2P_COMPRESS_NONE:
    #####: 2651:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 2652:		break;
        -: 2653:#ifdef CCITT_SUPPORT
    #####: 2654:	case T2P_COMPRESS_G4:
    #####: 2655:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 2656:		break;
        -: 2657:#endif /* ifdef CCITT_SUPPORT */
        -: 2658:#ifdef JPEG_SUPPORT
    #####: 2659:	case T2P_COMPRESS_JPEG:
    #####: 2660:		if(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 2661:			uint16 hor = 0, ver = 0;
    #####: 2662:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {
    #####: 2663:				if(hor != 0 && ver != 0){
    #####: 2664:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 2665:				}
        -: 2666:			}
    #####: 2667:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 2668:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 2669:			}
        -: 2670:		}
    #####: 2671:		if(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){
    #####: 2672:			TIFFError(TIFF2PDF_MODULE, 
        -: 2673:		"Unable to use JPEG compression for input %s and output %s", 
        -: 2674:				TIFFFileName(input),
        -: 2675:				TIFFFileName(output));
    #####: 2676:			_TIFFfree(buffer);
    #####: 2677:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2678:			return(0);
        -: 2679:		}
    #####: 2680:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);
        -: 2681:
    #####: 2682:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 2683:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 2684:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 2685:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 2686:			} else {
    #####: 2687:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 2688:			}
        -: 2689:		}
    #####: 2690:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 2691:			(void)0;
        -: 2692:		}
    #####: 2693:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 2694:			(void)0;
        -: 2695:		}
    #####: 2696:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 2697:			TIFFSetField(output, 
        -: 2698:				TIFFTAG_JPEGQUALITY, 
    #####: 2699:				t2p->pdf_defaultcompressionquality);
        -: 2700:		}
        -: 2701:	
    #####: 2702:		break;
        -: 2703:#endif /* ifdef JPEG_SUPPORT */
        -: 2704:#ifdef ZIP_SUPPORT
        -: 2705:	case T2P_COMPRESS_ZIP:
        -: 2706:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 2707:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 2708:			TIFFSetField(output, 
        -: 2709:				TIFFTAG_PREDICTOR, 
        -: 2710:				t2p->pdf_defaultcompressionquality % 100);
        -: 2711:		}
        -: 2712:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 2713:			TIFFSetField(output, 
        -: 2714:				TIFFTAG_ZIPQUALITY, 
        -: 2715:				(t2p->pdf_defaultcompressionquality / 100));
        -: 2716:		}
        -: 2717:		break;
        -: 2718:#endif /* ifdef ZIP_SUPPORT */
    #####: 2719:	default:
    #####: 2720:		break;
        -: 2721:	}
        -: 2722:
    #####: 2723:	t2p_enable(output);
    #####: 2724:	t2p->outputwritten = 0;
        -: 2725:#ifdef JPEG_SUPPORT
    #####: 2726:	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
    #####: 2727:	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){
    #####: 2728:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2729:						     buffer,
        -: 2730:						     stripsize * stripcount); 
        -: 2731:	} else
        -: 2732:#endif /* ifdef JPEG_SUPPORT */
        -: 2733:        {
    #####: 2734:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2735:						     buffer,
        -: 2736:						     t2p->tiff_datasize); 
        -: 2737:	}
    #####: 2738:	if (buffer != NULL) {
    #####: 2739:		_TIFFfree(buffer);
    #####: 2740:		buffer=NULL;
        -: 2741:	}
        -: 2742:
    #####: 2743:	if (bufferoffset == (tsize_t)-1) {
    #####: 2744:		TIFFError(TIFF2PDF_MODULE, 
        -: 2745:			  "Error writing encoded strip to output PDF %s", 
        -: 2746:			  TIFFFileName(output));
    #####: 2747:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2748:		return(0);
        -: 2749:	}
        -: 2750:	
    #####: 2751:	written = t2p->outputwritten;
    #####: 2752:	return(written);
        -: 2753:}
        -: 2754:
        -: 2755:/*
        -: 2756: * This function reads the raster image data from the input TIFF for an image
        -: 2757: * tile and writes the data to the output PDF XObject image dictionary stream
        -: 2758: * for the tile.  It returns the amount written or zero on error.
        -: 2759: */
        -: 2760:
    #####: 2761:tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){
        -: 2762:
    #####: 2763:	uint16 edge=0;
    #####: 2764:	tsize_t written=0;
    #####: 2765:	unsigned char* buffer=NULL;
    #####: 2766:	tsize_t bufferoffset=0;
    #####: 2767:	unsigned char* samplebuffer=NULL;
    #####: 2768:	tsize_t samplebufferoffset=0;
    #####: 2769:	tsize_t read=0;
    #####: 2770:	uint16 i=0;
    #####: 2771:	ttile_t tilecount=0;
        -: 2772:	/* tsize_t tilesize=0; */
    #####: 2773:	ttile_t septilecount=0;
    #####: 2774:	tsize_t septilesize=0;
        -: 2775:#ifdef JPEG_SUPPORT
    #####: 2776:	unsigned char* jpt;
    #####: 2777:	float* xfloatp;
    #####: 2778:	uint32 xuint32=0;
        -: 2779:#endif
        -: 2780:
        -: 2781:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
    #####: 2782:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2783:		return(0);
        -: 2784:
    #####: 2785:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
    #####: 2786:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2787:
    #####: 2788:	if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)
        -: 2789:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
    #####: 2790:		|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)
        -: 2791:#endif
        -: 2792:	)
        -: 2793:	){
        -: 2794:#ifdef CCITT_SUPPORT
    #####: 2795:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
    #####: 2796:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2797:			if(buffer==NULL){
    #####: 2798:				TIFFError(TIFF2PDF_MODULE, 
        -: 2799:					"Can't allocate %lu bytes of memory "
        -: 2800:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2801:					(unsigned long) t2p->tiff_datasize, 
        -: 2802:					TIFFFileName(input));
    #####: 2803:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2804:				return(0);
        -: 2805:			}
    #####: 2806:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2807:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
    #####: 2808:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2809:			}
    #####: 2810:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2811:			_TIFFfree(buffer);
    #####: 2812:			return(t2p->tiff_datasize);
        -: 2813:		}
        -: 2814:#endif
        -: 2815:#ifdef ZIP_SUPPORT
        -: 2816:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 2817:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
        -: 2818:			if(buffer==NULL){
        -: 2819:				TIFFError(TIFF2PDF_MODULE, 
        -: 2820:					"Can't allocate %lu bytes of memory "
        -: 2821:                                        "for t2p_readwrite_pdf_image_tile, %s", 
        -: 2822:					(unsigned long) t2p->tiff_datasize, 
        -: 2823:					TIFFFileName(input));
        -: 2824:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2825:				return(0);
        -: 2826:			}
        -: 2827:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2828:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2829:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2830:			}
        -: 2831:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2832:			_TIFFfree(buffer);
        -: 2833:			return(t2p->tiff_datasize);
        -: 2834:		}
        -: 2835:#endif
        -: 2836:#ifdef OJPEG_SUPPORT
    #####: 2837:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 2838:			if(! t2p->pdf_ojpegdata){
    #####: 2839:				TIFFError(TIFF2PDF_MODULE, 
        -: 2840:					"No support for OJPEG image %s with "
        -: 2841:                                        "bad tables", 
        -: 2842:					TIFFFileName(input));
    #####: 2843:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2844:				return(0);
        -: 2845:			}
    #####: 2846:			buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2847:			if(buffer==NULL){
    #####: 2848:				TIFFError(TIFF2PDF_MODULE, 
        -: 2849:					"Can't allocate %lu bytes of memory "
        -: 2850:                                        "for t2p_readwrite_pdf_image, %s", 
    #####: 2851:					(unsigned long) t2p->tiff_datasize, 
        -: 2852:					TIFFFileName(input));
    #####: 2853:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2854:				return(0);
        -: 2855:			}
    #####: 2856:			_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2857:			if(edge!=0){
    #####: 2858:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2859:					buffer[7]=
    #####: 2860:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;
    #####: 2861:					buffer[8]=
    #####: 2862:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;
        -: 2863:				}
    #####: 2864:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2865:					buffer[9]=
    #####: 2866:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
    #####: 2867:					buffer[10]=
    #####: 2868:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;
        -: 2869:				}
        -: 2870:			}
    #####: 2871:			bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2872:			bufferoffset+=TIFFReadRawTile(input, 
        -: 2873:					tile, 
    #####: 2874:					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2875:					-1);
    #####: 2876:			((unsigned char*)buffer)[bufferoffset++]=0xff;
    #####: 2877:			((unsigned char*)buffer)[bufferoffset++]=0xd9;
    #####: 2878:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2879:			_TIFFfree(buffer);
    #####: 2880:			return(bufferoffset);
        -: 2881:		}
        -: 2882:#endif
        -: 2883:#ifdef JPEG_SUPPORT
    #####: 2884:		if(t2p->tiff_compression == COMPRESSION_JPEG){
        -: 2885:			unsigned char table_end[2];
    #####: 2886:			uint32 count = 0;
    #####: 2887:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2888:			if(buffer==NULL){
    #####: 2889:				TIFFError(TIFF2PDF_MODULE, 
        -: 2890:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory "
        -: 2891:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2892:                                          (TIFF_SIZE_T) t2p->tiff_datasize, 
        -: 2893:					TIFFFileName(input));
    #####: 2894:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2895:				return(0);
        -: 2896:			}
    #####: 2897:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
    #####: 2898:				if (count >= 4) {
        -: 2899:                    /* Ignore EOI marker of JpegTables */
    #####: 2900:					_TIFFmemcpy(buffer, jpt, count - 2);
    #####: 2901:					bufferoffset += count - 2;
        -: 2902:                    /* Store last 2 bytes of the JpegTables */
    #####: 2903:					table_end[0] = buffer[bufferoffset-2];
    #####: 2904:					table_end[1] = buffer[bufferoffset-1];
    #####: 2905:					xuint32 = bufferoffset;
    #####: 2906:                    bufferoffset -= 2;
    #####: 2907:					bufferoffset += TIFFReadRawTile(
        -: 2908:						input, 
        -: 2909:						tile, 
    #####: 2910:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2911:						-1);
        -: 2912:                    /* Overwrite SOI marker of image scan with previously */
        -: 2913:                    /* saved end of JpegTables */
    #####: 2914:					buffer[xuint32-2]=table_end[0];
    #####: 2915:					buffer[xuint32-1]=table_end[1];
        -: 2916:				} else {
    #####: 2917:					bufferoffset += TIFFReadRawTile(
        -: 2918:						input, 
        -: 2919:						tile, 
    #####: 2920:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2921:						-1);
        -: 2922:				}
        -: 2923:			}
    #####: 2924:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2925:			_TIFFfree(buffer);
    #####: 2926:			return(bufferoffset);
        -: 2927:		}
        -: 2928:#endif
        -: 2929:		(void)0;
        -: 2930:	}
        -: 2931:
    #####: 2932:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2933:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2934:		if(buffer==NULL){
    #####: 2935:			TIFFError(TIFF2PDF_MODULE, 
        -: 2936:				"Can't allocate %lu bytes of memory for "
        -: 2937:                                "t2p_readwrite_pdf_image_tile, %s", 
    #####: 2938:				(unsigned long) t2p->tiff_datasize, 
        -: 2939:				TIFFFileName(input));
    #####: 2940:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2941:			return(0);
        -: 2942:		}
        -: 2943:
    #####: 2944:		read = TIFFReadEncodedTile(
        -: 2945:			input, 
        -: 2946:			tile, 
    #####: 2947:			(tdata_t) &buffer[bufferoffset], 
        -: 2948:			t2p->tiff_datasize);
    #####: 2949:		if(read==-1){
    #####: 2950:			TIFFError(TIFF2PDF_MODULE, 
        -: 2951:				"Error on decoding tile %u of %s", 
        -: 2952:				tile, 
        -: 2953:				TIFFFileName(input));
    #####: 2954:			_TIFFfree(buffer);
    #####: 2955:			t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2956:			return(0);
        -: 2957:		}
        -: 2958:
        -: 2959:	} else {
        -: 2960:
    #####: 2961:		if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
    #####: 2962:			septilesize=TIFFTileSize(input);
    #####: 2963:			septilecount=TIFFNumberOfTiles(input);
        -: 2964:			/* tilesize=septilesize*t2p->tiff_samplesperpixel; */
    #####: 2965:			tilecount=septilecount/t2p->tiff_samplesperpixel;
    #####: 2966:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2967:			if(buffer==NULL){
    #####: 2968:				TIFFError(TIFF2PDF_MODULE, 
        -: 2969:					"Can't allocate %lu bytes of memory "
        -: 2970:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2971:					(unsigned long) t2p->tiff_datasize, 
        -: 2972:					TIFFFileName(input));
    #####: 2973:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2974:				return(0);
        -: 2975:			}
    #####: 2976:			samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2977:			if(samplebuffer==NULL){
    #####: 2978:				TIFFError(TIFF2PDF_MODULE, 
        -: 2979:					"Can't allocate %lu bytes of memory "
        -: 2980:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2981:					(unsigned long) t2p->tiff_datasize, 
        -: 2982:					TIFFFileName(input));
    #####: 2983:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2984:				return(0);
        -: 2985:			}
    #####: 2986:			samplebufferoffset=0;
    #####: 2987:			for(i=0;i<t2p->tiff_samplesperpixel;i++){
        -: 2988:				read = 
    #####: 2989:					TIFFReadEncodedTile(input, 
    #####: 2990:						tile + i*tilecount, 
    #####: 2991:						(tdata_t) &(samplebuffer[samplebufferoffset]), 
        -: 2992:						septilesize);
    #####: 2993:				if(read==-1){
    #####: 2994:					TIFFError(TIFF2PDF_MODULE, 
        -: 2995:						"Error on decoding tile %u of %s", 
    #####: 2996:						tile + i*tilecount, 
        -: 2997:						TIFFFileName(input));
    #####: 2998:						_TIFFfree(samplebuffer);
    #####: 2999:						_TIFFfree(buffer);
    #####: 3000:					t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3001:					return(0);
        -: 3002:				}
    #####: 3003:				samplebufferoffset+=read;
        -: 3004:			}
    #####: 3005:			t2p_sample_planar_separate_to_contig(
        -: 3006:				t2p,
        -: 3007:				&(buffer[bufferoffset]),
        -: 3008:				samplebuffer, 
        -: 3009:				samplebufferoffset); 
    #####: 3010:			bufferoffset+=samplebufferoffset;
    #####: 3011:			_TIFFfree(samplebuffer);
        -: 3012:		}
        -: 3013:
    #####: 3014:		if(buffer==NULL){
    #####: 3015:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 3016:			if(buffer==NULL){
    #####: 3017:				TIFFError(TIFF2PDF_MODULE, 
        -: 3018:					"Can't allocate %lu bytes of memory "
        -: 3019:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 3020:					(unsigned long) t2p->tiff_datasize, 
        -: 3021:					TIFFFileName(input));
    #####: 3022:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3023:				return(0);
        -: 3024:			}
    #####: 3025:			read = TIFFReadEncodedTile(
        -: 3026:				input, 
        -: 3027:				tile, 
    #####: 3028:				(tdata_t) &buffer[bufferoffset], 
        -: 3029:				t2p->tiff_datasize);
    #####: 3030:			if(read==-1){
    #####: 3031:				TIFFError(TIFF2PDF_MODULE, 
        -: 3032:					"Error on decoding tile %u of %s", 
        -: 3033:					tile, 
        -: 3034:					TIFFFileName(input));
    #####: 3035:				_TIFFfree(buffer);
    #####: 3036:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3037:				return(0);
        -: 3038:			}
        -: 3039:		}
        -: 3040:
    #####: 3041:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 3042:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 3043:				(tdata_t)buffer, 
    #####: 3044:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3045:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3046:		}
        -: 3047:
    #####: 3048:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 3049:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 3050:				(tdata_t)buffer, 
    #####: 3051:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3052:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3053:		}
        -: 3054:
    #####: 3055:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 3056:			TIFFError(TIFF2PDF_MODULE, 
        -: 3057:				"No support for YCbCr to RGB in tile for %s", 
        -: 3058:				TIFFFileName(input));
    #####: 3059:			_TIFFfree(buffer);
    #####: 3060:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3061:			return(0);
        -: 3062:		}
        -: 3063:
    #####: 3064:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 3065:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 3066:				(tdata_t)buffer, 
    #####: 3067:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3068:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3069:		}
        -: 3070:	}
        -: 3071:
    #####: 3072:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){
    #####: 3073:		t2p_tile_collapse_left(
        -: 3074:			buffer, 
        -: 3075:			TIFFTileRowSize(input),
    #####: 3076:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
    #####: 3077:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, 
    #####: 3078:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3079:	}
        -: 3080:
        -: 3081:
    #####: 3082:	t2p_disable(output);
    #####: 3083:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 3084:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 3085:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 3086:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3087:		TIFFSetField(
        -: 3088:			output, 
        -: 3089:			TIFFTAG_IMAGEWIDTH, 
    #####: 3090:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 3091:	} else {
    #####: 3092:		TIFFSetField(
        -: 3093:			output, 
        -: 3094:			TIFFTAG_IMAGEWIDTH, 
    #####: 3095:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 3096:	}
    #####: 3097:	if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3098:		TIFFSetField(
        -: 3099:			output, 
        -: 3100:			TIFFTAG_IMAGELENGTH, 
    #####: 3101:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 3102:		TIFFSetField(
        -: 3103:			output, 
        -: 3104:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3105:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3106:	} else {
    #####: 3107:		TIFFSetField(
        -: 3108:			output, 
        -: 3109:			TIFFTAG_IMAGELENGTH, 
    #####: 3110:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 3111:		TIFFSetField(
        -: 3112:			output, 
        -: 3113:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3114:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 3115:	}
    #####: 3116:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 3117:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 3118:
    #####: 3119:	switch(t2p->pdf_compression){
    #####: 3120:	case T2P_COMPRESS_NONE:
    #####: 3121:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 3122:		break;
        -: 3123:#ifdef CCITT_SUPPORT
    #####: 3124:	case T2P_COMPRESS_G4:
    #####: 3125:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 3126:		break;
        -: 3127:#endif
        -: 3128:#ifdef JPEG_SUPPORT
    #####: 3129:	case T2P_COMPRESS_JPEG:
    #####: 3130:		if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 3131:			uint16 hor = 0, ver = 0;
    #####: 3132:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {
    #####: 3133:				if (hor != 0 && ver != 0) {
    #####: 3134:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 3135:				}
        -: 3136:			}
    #####: 3137:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 3138:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 3139:			}
        -: 3140:		}
    #####: 3141:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
    #####: 3142:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */
    #####: 3143:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 3144:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 3145:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 3146:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 3147:			} else {
    #####: 3148:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 3149:			}
        -: 3150:		}
    #####: 3151:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 3152:			(void)0;
        -: 3153:		}
    #####: 3154:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 3155:			(void)0;
        -: 3156:		}
    #####: 3157:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 3158:			TIFFSetField(output, 
        -: 3159:				TIFFTAG_JPEGQUALITY, 
    #####: 3160:				t2p->pdf_defaultcompressionquality);
        -: 3161:		}
    #####: 3162:		break;
        -: 3163:#endif
        -: 3164:#ifdef ZIP_SUPPORT
        -: 3165:	case T2P_COMPRESS_ZIP:
        -: 3166:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 3167:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 3168:			TIFFSetField(output, 
        -: 3169:				TIFFTAG_PREDICTOR, 
        -: 3170:				t2p->pdf_defaultcompressionquality % 100);
        -: 3171:		}
        -: 3172:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 3173:			TIFFSetField(output, 
        -: 3174:				TIFFTAG_ZIPQUALITY, 
        -: 3175:				(t2p->pdf_defaultcompressionquality / 100));
        -: 3176:		}
        -: 3177:		break;
        -: 3178:#endif
    #####: 3179:	default:
    #####: 3180:		break;
        -: 3181:	}
        -: 3182:
    #####: 3183:	t2p_enable(output);
    #####: 3184:	t2p->outputwritten = 0;
    #####: 3185:	bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,
        -: 3186:					     TIFFStripSize(output)); 
    #####: 3187:	if (buffer != NULL) {
    #####: 3188:		_TIFFfree(buffer);
    #####: 3189:		buffer = NULL;
        -: 3190:	}
    #####: 3191:	if (bufferoffset == -1) {
    #####: 3192:		TIFFError(TIFF2PDF_MODULE, 
        -: 3193:			  "Error writing encoded tile to output PDF %s", 
        -: 3194:			  TIFFFileName(output));
    #####: 3195:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3196:		return(0);
        -: 3197:	}
        -: 3198:	
    #####: 3199:	written = t2p->outputwritten;
        -: 3200:	
    #####: 3201:	return(written);
        -: 3202:}
        -: 3203:
        -: 3204:#ifdef OJPEG_SUPPORT
    #####: 3205:int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){
    #####: 3206:	uint16 proc=0;
    #####: 3207:	void* q;
    #####: 3208:	uint32 q_length=0;
    #####: 3209:	void* dc;
    #####: 3210:	uint32 dc_length=0;
    #####: 3211:	void* ac;
    #####: 3212:	uint32 ac_length=0;
    #####: 3213:	uint16* lp;
    #####: 3214:	uint16* pt;
    #####: 3215:	uint16 h_samp=1;
    #####: 3216:	uint16 v_samp=1;
        -: 3217:	unsigned char* ojpegdata;
        -: 3218:	uint16 table_count;
        -: 3219:	uint32 offset_table;
        -: 3220:	uint32 offset_ms_l;
        -: 3221:	uint32 code_count;
    #####: 3222:	uint32 i=0;
    #####: 3223:	uint32 dest=0;
    #####: 3224:	uint16 ri=0;
    #####: 3225:	uint32 rows=0;
        -: 3226:	
    #####: 3227:	if(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){
    #####: 3228:		TIFFError(TIFF2PDF_MODULE, 
        -: 3229:			"Missing JPEGProc field in OJPEG image %s", 
        -: 3230:			TIFFFileName(input));
    #####: 3231:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3232:		return(0);
        -: 3233:	}
    #####: 3234:	if(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){
    #####: 3235:		TIFFError(TIFF2PDF_MODULE, 
        -: 3236:			"Bad JPEGProc field in OJPEG image %s", 
        -: 3237:			TIFFFileName(input));
    #####: 3238:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3239:		return(0);
        -: 3240:	}
    #####: 3241:	if(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){
    #####: 3242:		TIFFError(TIFF2PDF_MODULE, 
        -: 3243:			"Missing JPEGQTables field in OJPEG image %s", 
        -: 3244:			TIFFFileName(input));
    #####: 3245:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3246:		return(0);
        -: 3247:	}
    #####: 3248:	if(q_length < (64U * t2p->tiff_samplesperpixel)){
    #####: 3249:		TIFFError(TIFF2PDF_MODULE, 
        -: 3250:			"Bad JPEGQTables field in OJPEG image %s", 
        -: 3251:			TIFFFileName(input));
    #####: 3252:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3253:		return(0);
        -: 3254:	} 
    #####: 3255:	if(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){
    #####: 3256:		TIFFError(TIFF2PDF_MODULE, 
        -: 3257:			"Missing JPEGDCTables field in OJPEG image %s", 
        -: 3258:			TIFFFileName(input));
    #####: 3259:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3260:		return(0);
        -: 3261:	}
    #####: 3262:	if(proc==JPEGPROC_BASELINE){
    #####: 3263:		if(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){
    #####: 3264:			TIFFError(TIFF2PDF_MODULE, 
        -: 3265:				"Missing JPEGACTables field in OJPEG image %s", 
        -: 3266:				TIFFFileName(input));
    #####: 3267:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3268:			return(0);
        -: 3269:		}
        -: 3270:	} else {
    #####: 3271:		if(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){
    #####: 3272:			TIFFError(TIFF2PDF_MODULE, 
        -: 3273:				"Missing JPEGLosslessPredictors field in OJPEG image %s", 
        -: 3274:				TIFFFileName(input));
    #####: 3275:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3276:				return(0);
        -: 3277:		}
    #####: 3278:		if(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){
    #####: 3279:			TIFFError(TIFF2PDF_MODULE, 
        -: 3280:				"Missing JPEGPointTransform field in OJPEG image %s", 
        -: 3281:				TIFFFileName(input));
    #####: 3282:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3283:			return(0);
        -: 3284:		}
        -: 3285:	}
    #####: 3286:	if(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){
    #####: 3287:		h_samp=1;
    #####: 3288:		v_samp=1;
        -: 3289:	}
    #####: 3290:	if(t2p->pdf_ojpegdata != NULL){
    #####: 3291:		_TIFFfree(t2p->pdf_ojpegdata);
    #####: 3292:		t2p->pdf_ojpegdata=NULL;
        -: 3293:	} 
    #####: 3294:	t2p->pdf_ojpegdata = _TIFFmalloc(2048);
    #####: 3295:	if(t2p->pdf_ojpegdata == NULL){
    #####: 3296:		TIFFError(TIFF2PDF_MODULE, 
        -: 3297:			"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s", 
        -: 3298:			2048, 
        -: 3299:			TIFFFileName(input));
    #####: 3300:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3301:		return(0);
        -: 3302:	}
    #####: 3303:	_TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048);
    #####: 3304:	t2p->pdf_ojpegdatalength = 0;
    #####: 3305:	table_count=t2p->tiff_samplesperpixel;
    #####: 3306:	if(proc==JPEGPROC_BASELINE){
    #####: 3307:		if(table_count>2) table_count=2;
        -: 3308:	}
    #####: 3309:	ojpegdata=(unsigned char*)t2p->pdf_ojpegdata;
    #####: 3310:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3311:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xd8;
    #####: 3312:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3313:	if(proc==JPEGPROC_BASELINE){
    #####: 3314:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc0;
        -: 3315:	} else {
    #####: 3316:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc3;
        -: 3317:	}
    #####: 3318:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3319:	ojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel);
    #####: 3320:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff);
    #####: 3321:	if(TIFFIsTiled(input)){
    #####: 3322:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3323:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff;
    #####: 3324:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3325:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff;
    #####: 3326:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3327:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff;
    #####: 3328:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3329:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff;
        -: 3330:	} else {
    #####: 3331:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3332:			(t2p->tiff_length >> 8) & 0xff;
    #####: 3333:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3334:			(t2p->tiff_length ) & 0xff;
    #####: 3335:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3336:			(t2p->tiff_width >> 8) & 0xff;
    #####: 3337:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3338:			(t2p->tiff_width ) & 0xff;
        -: 3339:	}
    #####: 3340:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff);
    #####: 3341:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3342:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
    #####: 3343:		if(i==0){
    #####: 3344:			ojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;;
    #####: 3345:			ojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f;
        -: 3346:		} else {
    #####: 3347:				ojpegdata[t2p->pdf_ojpegdatalength++]= 0x11;
        -: 3348:		}
    #####: 3349:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
        -: 3350:	}
    #####: 3351:	for(dest=0;dest<t2p->tiff_samplesperpixel;dest++){
    #####: 3352:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3353:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdb;
    #####: 3354:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3355:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x43;
    #####: 3356:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest;
    #####: 3357:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]), 
    #####: 3358:			&(((unsigned char*)q)[64*dest]), 64);
    #####: 3359:		t2p->pdf_ojpegdatalength+=64;
        -: 3360:	}
    #####: 3361:	offset_table=0;
    #####: 3362:	for(dest=0;dest<table_count;dest++){
    #####: 3363:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3364:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3365:		offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3366:		t2p->pdf_ojpegdatalength+=2;
    #####: 3367:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f;
    #####: 3368:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3369:			&(((unsigned char*)dc)[offset_table]), 16);
    #####: 3370:		code_count=0;
    #####: 3371:		offset_table+=16;
    #####: 3372:		for(i=0;i<16;i++){
    #####: 3373:			code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3374:		}
    #####: 3375:		ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3376:		ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3377:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3378:			&(((unsigned char*)dc)[offset_table]), code_count);
    #####: 3379:		offset_table+=code_count;
    #####: 3380:		t2p->pdf_ojpegdatalength+=code_count;
        -: 3381:	}
    #####: 3382:	if(proc==JPEGPROC_BASELINE){
    #####: 3383:	offset_table=0;
    #####: 3384:		for(dest=0;dest<table_count;dest++){
    #####: 3385:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3386:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3387:			offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3388:			t2p->pdf_ojpegdatalength+=2;
    #####: 3389:			ojpegdata[t2p->pdf_ojpegdatalength] |= 0x10;
    #####: 3390:			ojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f;
    #####: 3391:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3392:				&(((unsigned char*)ac)[offset_table]), 16);
    #####: 3393:			code_count=0;
    #####: 3394:			offset_table+=16;
    #####: 3395:			for(i=0;i<16;i++){
    #####: 3396:				code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3397:			}	
    #####: 3398:			ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3399:			ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3400:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3401:				&(((unsigned char*)ac)[offset_table]), code_count);
    #####: 3402:			offset_table+=code_count;
    #####: 3403:			t2p->pdf_ojpegdatalength+=code_count;
        -: 3404:		}
        -: 3405:	}
    #####: 3406:	if(TIFFNumberOfStrips(input)>1){
    #####: 3407:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3408:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdd;
    #####: 3409:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3410:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x04;
    #####: 3411:		h_samp*=8;
    #####: 3412:		v_samp*=8;
    #####: 3413:		ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 3414:		TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows);
    #####: 3415:		ri*=(rows+v_samp-1)/v_samp;
    #####: 3416:		ojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff;
    #####: 3417:		ojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff;
        -: 3418:	}
    #####: 3419:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3420:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xda;
    #####: 3421:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3422:	ojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel);
    #####: 3423:	ojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff;
    #####: 3424:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3425:		ojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff;
    #####: 3426:		if(proc==JPEGPROC_BASELINE){
    #####: 3427:			ojpegdata[t2p->pdf_ojpegdatalength] |= 
    #####: 3428:				( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0;
    #####: 3429:			ojpegdata[t2p->pdf_ojpegdatalength++] |= 
    #####: 3430:				( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f;
        -: 3431:		} else {
    #####: 3432:			ojpegdata[t2p->pdf_ojpegdatalength++] =  (i << 4) & 0xf0;
        -: 3433:		}
        -: 3434:	}
    #####: 3435:	if(proc==JPEGPROC_BASELINE){
    #####: 3436:		t2p->pdf_ojpegdatalength++;
    #####: 3437:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x3f;
    #####: 3438:		t2p->pdf_ojpegdatalength++;
        -: 3439:	} else {
    #####: 3440:		ojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff);
    #####: 3441:		t2p->pdf_ojpegdatalength++;
    #####: 3442:		ojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f);
        -: 3443:	}
        -: 3444:
    #####: 3445:	return(1);
        -: 3446:}
        -: 3447:#endif
        -: 3448:
        -: 3449:#ifdef JPEG_SUPPORT
    #####: 3450:int t2p_process_jpeg_strip(
        -: 3451:	unsigned char* strip, 
        -: 3452:	tsize_t* striplength, 
        -: 3453:	unsigned char* buffer, 
        -: 3454:    tsize_t buffersize,
        -: 3455:	tsize_t* bufferoffset, 
        -: 3456:	tstrip_t no, 
        -: 3457:	uint32 height){
        -: 3458:
    #####: 3459:	tsize_t i=0;
        -: 3460:
    #####: 3461:	while (i < *striplength) {
        -: 3462:		tsize_t datalen;
        -: 3463:		uint16 ri;
        -: 3464:		uint16 v_samp;
        -: 3465:		uint16 h_samp;
        -: 3466:		int j;
        -: 3467:		int ncomp;
        -: 3468:
        -: 3469:		/* marker header: one or more FFs */
    #####: 3470:		if (strip[i] != 0xff)
    #####: 3471:			return(0);
    #####: 3472:		i++;
    #####: 3473:		while (i < *striplength && strip[i] == 0xff)
    #####: 3474:			i++;
    #####: 3475:		if (i >= *striplength)
    #####: 3476:			return(0);
        -: 3477:		/* SOI is the only pre-SOS marker without a length word */
    #####: 3478:		if (strip[i] == 0xd8)
    #####: 3479:			datalen = 0;
        -: 3480:		else {
    #####: 3481:			if ((*striplength - i) <= 2)
    #####: 3482:				return(0);
    #####: 3483:			datalen = (strip[i+1] << 8) | strip[i+2];
    #####: 3484:			if (datalen < 2 || datalen >= (*striplength - i))
    #####: 3485:				return(0);
        -: 3486:		}
    #####: 3487:		switch( strip[i] ){
    #####: 3488:			case 0xd8:	/* SOI - start of image */
    #####: 3489:                if( *bufferoffset + 2 > buffersize )
    #####: 3490:                    return(0);
    #####: 3491:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);
    #####: 3492:				*bufferoffset+=2;
    #####: 3493:				break;
    #####: 3494:			case 0xc0:	/* SOF0 */
        -: 3495:			case 0xc1:	/* SOF1 */
        -: 3496:			case 0xc3:	/* SOF3 */
        -: 3497:			case 0xc9:	/* SOF9 */
        -: 3498:			case 0xca:	/* SOF10 */
    #####: 3499:				if(no==0){
    #####: 3500:                    if( *bufferoffset + datalen + 2 + 6 > buffersize )
    #####: 3501:                        return(0);
    #####: 3502:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3503:                    if( *bufferoffset + 9 >= buffersize )
    #####: 3504:                        return(0);
    #####: 3505:					ncomp = buffer[*bufferoffset+9];
    #####: 3506:					if (ncomp < 1 || ncomp > 4)
    #####: 3507:						return(0);
    #####: 3508:					v_samp=1;
    #####: 3509:					h_samp=1;
    #####: 3510:                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )
    #####: 3511:                        return(0);
    #####: 3512:					for(j=0;j<ncomp;j++){
    #####: 3513:						uint16 samp = buffer[*bufferoffset+11+(3*j)];
    #####: 3514:						if( (samp>>4) > h_samp) 
    #####: 3515:							h_samp = (samp>>4);
    #####: 3516:						if( (samp & 0x0f) > v_samp) 
    #####: 3517:							v_samp = (samp & 0x0f);
        -: 3518:					}
    #####: 3519:					v_samp*=8;
    #####: 3520:					h_samp*=8;
    #####: 3521:					ri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | 
    #####: 3522:					(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ 
        -: 3523:					v_samp);
    #####: 3524:					ri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | 
    #####: 3525:					(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ 
        -: 3526:					h_samp);
    #####: 3527:					buffer[*bufferoffset+5]=
    #####: 3528:                                          (unsigned char) ((height>>8) & 0xff);
    #####: 3529:					buffer[*bufferoffset+6]=
    #####: 3530:                                            (unsigned char) (height & 0xff);
    #####: 3531:					*bufferoffset+=datalen+2;
        -: 3532:					/* insert a DRI marker */
    #####: 3533:					buffer[(*bufferoffset)++]=0xff;
    #####: 3534:					buffer[(*bufferoffset)++]=0xdd;
    #####: 3535:					buffer[(*bufferoffset)++]=0x00;
    #####: 3536:					buffer[(*bufferoffset)++]=0x04;
    #####: 3537:					buffer[(*bufferoffset)++]=(ri >> 8) & 0xff;
    #####: 3538:					buffer[(*bufferoffset)++]= ri & 0xff;
        -: 3539:				}
    #####: 3540:				break;
    #####: 3541:			case 0xc4: /* DHT */
        -: 3542:			case 0xdb: /* DQT */
    #####: 3543:                if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3544:                    return(0);
    #####: 3545:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3546:				*bufferoffset+=datalen+2;
    #####: 3547:				break;
    #####: 3548:			case 0xda: /* SOS */
    #####: 3549:				if(no==0){
    #####: 3550:                    if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3551:                        return(0);
    #####: 3552:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3553:					*bufferoffset+=datalen+2;
        -: 3554:				} else {
    #####: 3555:                    if( *bufferoffset + 2 > buffersize )
    #####: 3556:                        return(0);
    #####: 3557:					buffer[(*bufferoffset)++]=0xff;
    #####: 3558:					buffer[(*bufferoffset)++]=
    #####: 3559:                                            (unsigned char)(0xd0 | ((no-1)%8));
        -: 3560:				}
    #####: 3561:				i += datalen + 1;
        -: 3562:				/* copy remainder of strip */
    #####: 3563:                if( *bufferoffset + *striplength - i > buffersize )
    #####: 3564:                    return(0);
    #####: 3565:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);
    #####: 3566:				*bufferoffset+= *striplength - i;
    #####: 3567:				return(1);
    #####: 3568:			default:
        -: 3569:				/* ignore any other marker */
    #####: 3570:				break;
        -: 3571:		}
    #####: 3572:		i += datalen + 1;
        -: 3573:	}
        -: 3574:
        -: 3575:	/* failed to find SOS marker */
    #####: 3576:	return(0);
        -: 3577:}
        -: 3578:#endif
        -: 3579:
        -: 3580:/*
        -: 3581:	This functions converts a tilewidth x tilelength buffer of samples into an edgetilewidth x 
        -: 3582:	tilelength buffer of samples.
        -: 3583:*/
    #####: 3584:void t2p_tile_collapse_left(
        -: 3585:	tdata_t buffer, 
        -: 3586:	tsize_t scanwidth, 
        -: 3587:	uint32 tilewidth, 
        -: 3588:	uint32 edgetilewidth, 
        -: 3589:	uint32 tilelength){
        -: 3590:	
        -: 3591:	uint32 i;
    #####: 3592:	tsize_t edgescanwidth=0;
        -: 3593:	
    #####: 3594:	edgescanwidth = (scanwidth * edgetilewidth + (tilewidth - 1))/ tilewidth;
    #####: 3595:	for(i=0;i<tilelength;i++){
    #####: 3596:		_TIFFmemcpy( 
    #####: 3597:			&(((char*)buffer)[edgescanwidth*i]), 
    #####: 3598:			&(((char*)buffer)[scanwidth*i]), 
        -: 3599:			edgescanwidth);
        -: 3600:	}
        -: 3601:	
    #####: 3602:	return;
        -: 3603:}
        -: 3604:
        -: 3605:
        -: 3606:/*
        -: 3607: * This function calls TIFFWriteDirectory on the output after blanking its
        -: 3608: * output by replacing the read, write, and seek procedures with empty
        -: 3609: * implementations, then it replaces the original implementations.
        -: 3610: */
        -: 3611:
        -: 3612:void
    #####: 3613:t2p_write_advance_directory(T2P* t2p, TIFF* output)
        -: 3614:{
    #####: 3615:	t2p_disable(output);
    #####: 3616:	if(!TIFFWriteDirectory(output)){
    #####: 3617:		TIFFError(TIFF2PDF_MODULE, 
        -: 3618:			"Error writing virtual directory to output PDF %s", 
        -: 3619:			TIFFFileName(output));
    #####: 3620:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3621:		return;
        -: 3622:	}
    #####: 3623:	t2p_enable(output);
    #####: 3624:	return;
        -: 3625:}
        -: 3626:
    #####: 3627:tsize_t t2p_sample_planar_separate_to_contig(
        -: 3628:											T2P* t2p, 
        -: 3629:											unsigned char* buffer, 
        -: 3630:											unsigned char* samplebuffer, 
        -: 3631:											tsize_t samplebuffersize){
        -: 3632:
    #####: 3633:	tsize_t stride=0;
    #####: 3634:	tsize_t i=0;
    #####: 3635:	tsize_t j=0;
        -: 3636:	
    #####: 3637:	stride=samplebuffersize/t2p->tiff_samplesperpixel;
    #####: 3638:	for(i=0;i<stride;i++){
    #####: 3639:		for(j=0;j<t2p->tiff_samplesperpixel;j++){
    #####: 3640:			buffer[i*t2p->tiff_samplesperpixel + j] = samplebuffer[i + j*stride];
        -: 3641:		}
        -: 3642:	}
        -: 3643:
    #####: 3644:	return(samplebuffersize);
        -: 3645:}
        -: 3646:
    #####: 3647:tsize_t t2p_sample_realize_palette(T2P* t2p, unsigned char* buffer){
        -: 3648:
    #####: 3649:	uint32 sample_count=0;
    #####: 3650:	uint16 component_count=0;
    #####: 3651:	uint32 palette_offset=0;
    #####: 3652:	uint32 sample_offset=0;
    #####: 3653:	uint32 i=0;
    #####: 3654:	uint32 j=0;
    #####: 3655:	sample_count=t2p->tiff_width*t2p->tiff_length;
    #####: 3656:	component_count=t2p->tiff_samplesperpixel;
        -: 3657:	
    #####: 3658:	for(i=sample_count;i>0;i--){
    #####: 3659:		palette_offset=buffer[i-1] * component_count;
    #####: 3660:		sample_offset= (i-1) * component_count;
    #####: 3661:		for(j=0;j<component_count;j++){
    #####: 3662:			buffer[sample_offset+j]=t2p->pdf_palette[palette_offset+j];
        -: 3663:		}
        -: 3664:	}
        -: 3665:
    #####: 3666:	return(0);
        -: 3667:}
        -: 3668:
        -: 3669:/*
        -: 3670:	This functions converts in place a buffer of ABGR interleaved data
        -: 3671:	into RGB interleaved data, discarding A.
        -: 3672:*/
        -: 3673:
    #####: 3674:tsize_t t2p_sample_abgr_to_rgb(tdata_t data, uint32 samplecount)
        -: 3675:{
    #####: 3676:	uint32 i=0;
    #####: 3677:	uint32 sample=0;
        -: 3678:	
    #####: 3679:	for(i=0;i<samplecount;i++){
    #####: 3680:		sample=((uint32*)data)[i];
    #####: 3681:		((char*)data)[i*3]= (char) (sample & 0xff);
    #####: 3682:		((char*)data)[i*3+1]= (char) ((sample>>8) & 0xff);
    #####: 3683:		((char*)data)[i*3+2]= (char) ((sample>>16) & 0xff);
        -: 3684:	}
        -: 3685:
    #####: 3686:	return(i*3);
        -: 3687:}
        -: 3688:
        -: 3689:/*
        -: 3690: * This functions converts in place a buffer of RGBA interleaved data
        -: 3691: * into RGB interleaved data, discarding A.
        -: 3692: */
        -: 3693:
        -: 3694:tsize_t
    #####: 3695:t2p_sample_rgbaa_to_rgb(tdata_t data, uint32 samplecount)
        -: 3696:{
        -: 3697:	uint32 i;
        -: 3698:	
        -: 3699:    /* For the 3 first samples, there is overlapping between souce and
        -: 3700:       destination, so use memmove().
        -: 3701:       See http://bugzilla.maptools.org/show_bug.cgi?id=2577 */
    #####: 3702:    for(i = 0; i < 3 && i < samplecount; i++)
    #####: 3703:        memmove((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
    #####: 3704:	for(; i < samplecount; i++)
    #####: 3705:		memcpy((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
        -: 3706:
    #####: 3707:	return(i * 3);
        -: 3708:}
        -: 3709:
        -: 3710:/*
        -: 3711: * This functions converts in place a buffer of RGBA interleaved data
        -: 3712: * into RGB interleaved data, adding 255-A to each component sample.
        -: 3713: */
        -: 3714:
        -: 3715:tsize_t
    #####: 3716:t2p_sample_rgba_to_rgb(tdata_t data, uint32 samplecount)
        -: 3717:{
    #####: 3718:	uint32 i = 0;
    #####: 3719:	uint32 sample = 0;
    #####: 3720:	uint8 alpha = 0;
        -: 3721:
    #####: 3722:	for (i = 0; i < samplecount; i++) {
    #####: 3723:		sample=((uint32*)data)[i];
    #####: 3724:		alpha=(uint8)((255 - ((sample >> 24) & 0xff)));
    #####: 3725:		((uint8 *)data)[i * 3] = (uint8) ((sample >> 16) & 0xff) + alpha;
    #####: 3726:		((uint8 *)data)[i * 3 + 1] = (uint8) ((sample >> 8) & 0xff) + alpha;
    #####: 3727:		((uint8 *)data)[i * 3 + 2] = (uint8) (sample & 0xff) + alpha;
        -: 3728:	}
        -: 3729:
    #####: 3730:	return (i * 3);
        -: 3731:}
        -: 3732:
        -: 3733:/*
        -: 3734:	This function converts the a and b samples of Lab data from signed
        -: 3735:	to unsigned.
        -: 3736:*/
        -: 3737:
    #####: 3738:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){
        -: 3739:
    #####: 3740:	uint32 i=0;
        -: 3741:
    #####: 3742:	for(i=0;i<samplecount;i++){
    #####: 3743:		if( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){
    #####: 3744:			((unsigned char*)buffer)[(i*3)+1] =
    #####: 3745:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);
        -: 3746:		} else {
    #####: 3747:			((unsigned char*)buffer)[(i*3)+1] |= 0x80;
        -: 3748:		}
    #####: 3749:		if( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){
    #####: 3750:			((unsigned char*)buffer)[(i*3)+2] =
    #####: 3751:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);
        -: 3752:		} else {
    #####: 3753:			((unsigned char*)buffer)[(i*3)+2] |= 0x80;
        -: 3754:		}
        -: 3755:	}
        -: 3756:
    #####: 3757:	return(samplecount*3);
        -: 3758:}
        -: 3759:
        -: 3760:/* 
        -: 3761:	This function writes the PDF header to output.
        -: 3762:*/
        -: 3763:
    #####: 3764:tsize_t t2p_write_pdf_header(T2P* t2p, TIFF* output){
        -: 3765:
    #####: 3766:	tsize_t written=0;
    #####: 3767:	char buffer[16];
    #####: 3768:	int buflen=0;
        -: 3769:	
    #####: 3770:	buflen = snprintf(buffer, sizeof(buffer), "%%PDF-%u.%u ",
    #####: 3771:			  t2p->pdf_majorversion&0xff,
    #####: 3772:			  t2p->pdf_minorversion&0xff);
    #####: 3773:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 3774:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 3775:	written += t2pWriteFile(output, (tdata_t)"\n%\342\343\317\323\n", 7);
        -: 3776:
    #####: 3777:	return(written);
        -: 3778:}
        -: 3779:
        -: 3780:/*
        -: 3781:	This function writes the beginning of a PDF object to output.
        -: 3782:*/
        -: 3783:
    #####: 3784:tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){
        -: 3785:
    #####: 3786:	tsize_t written=0;
    #####: 3787:	char buffer[32];
    #####: 3788:	int buflen=0;
        -: 3789:
    #####: 3790:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
    #####: 3791:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 3792:	written += t2pWriteFile(output, (tdata_t) buffer, buflen );
    #####: 3793:	written += t2pWriteFile(output, (tdata_t) " 0 obj\n", 7);
        -: 3794:
    #####: 3795:	return(written);
        -: 3796:}
        -: 3797:
        -: 3798:/*
        -: 3799:	This function writes the end of a PDF object to output.
        -: 3800:*/
        -: 3801:
    #####: 3802:tsize_t t2p_write_pdf_obj_end(TIFF* output){
        -: 3803:
    #####: 3804:	tsize_t written=0;
        -: 3805:
    #####: 3806:	written += t2pWriteFile(output, (tdata_t) "endobj\n", 7);
        -: 3807:
    #####: 3808:	return(written);
        -: 3809:}
        -: 3810:
        -: 3811:/*
        -: 3812:	This function writes a PDF name object to output.
        -: 3813:*/
        -: 3814:
    #####: 3815:tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){
        -: 3816:
    #####: 3817:	tsize_t written=0;
    #####: 3818:	uint32 i=0;
    #####: 3819:	char buffer[64];
    #####: 3820:	uint16 nextchar=0;
    #####: 3821:	size_t namelen=0;
        -: 3822:	
    #####: 3823:	namelen = strlen((char *)name);
    #####: 3824:	if (namelen>126) {
    #####: 3825:		namelen=126;
        -: 3826:	}
    #####: 3827:	written += t2pWriteFile(output, (tdata_t) "/", 1);
    #####: 3828:	for (i=0;i<namelen;i++){
    #####: 3829:		if ( ((unsigned char)name[i]) < 0x21){
    #####: 3830:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3831:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3832:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3833:			nextchar=1;
        -: 3834:		}
    #####: 3835:		if ( ((unsigned char)name[i]) > 0x7E){
    #####: 3836:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3837:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3838:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3839:			nextchar=1;
        -: 3840:		}
    #####: 3841:		if (nextchar==0){
    #####: 3842:			switch (name[i]){
    #####: 3843:				case 0x23:
    #####: 3844:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3845:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3846:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3847:					break;
    #####: 3848:				case 0x25:
    #####: 3849:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3850:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3851:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3852:					break;
    #####: 3853:				case 0x28:
    #####: 3854:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3855:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3856:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3857:					break;
    #####: 3858:				case 0x29:
    #####: 3859:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3860:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3861:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3862:					break;
    #####: 3863:				case 0x2F:
    #####: 3864:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3865:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3866:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3867:					break;
    #####: 3868:				case 0x3C:
    #####: 3869:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3870:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3871:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3872:					break;
    #####: 3873:				case 0x3E:
    #####: 3874:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3875:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3876:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3877:					break;
    #####: 3878:				case 0x5B:
    #####: 3879:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3880:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3881:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3882:					break;
    #####: 3883:				case 0x5D:
    #####: 3884:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3885:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3886:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3887:					break;
    #####: 3888:				case 0x7B:
    #####: 3889:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3890:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3891:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3892:					break;
    #####: 3893:				case 0x7D:
    #####: 3894:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3895:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3896:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3897:					break;
    #####: 3898:				default:
    #####: 3899:					written += t2pWriteFile(output, (tdata_t) &name[i], 1);
        -: 3900:			}
    #####: 3901:		}
    #####: 3902:		nextchar=0;
        -: 3903:	}
    #####: 3904:	written += t2pWriteFile(output, (tdata_t) " ", 1);
        -: 3905:
    #####: 3906:	return(written);
        -: 3907:}
        -: 3908:
        -: 3909:/*
        -: 3910: * This function writes a PDF string object to output.
        -: 3911: */
        -: 3912:	
    #####: 3913:tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)
        -: 3914:{
    #####: 3915:	tsize_t written = 0;
    #####: 3916:	uint32 i = 0;
    #####: 3917:	char buffer[64];
    #####: 3918:	size_t len = 0;
        -: 3919:	
    #####: 3920:	len = strlen(pdfstr);
    #####: 3921:	written += t2pWriteFile(output, (tdata_t) "(", 1);
    #####: 3922:	for (i=0; i<len; i++) {
    #####: 3923:		if((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){
    #####: 3924:			snprintf(buffer, sizeof(buffer), "\\%.3o", ((unsigned char)pdfstr[i]));
    #####: 3925:			written += t2pWriteFile(output, (tdata_t)buffer, 4);
        -: 3926:		} else {
    #####: 3927:			switch (pdfstr[i]){
    #####: 3928:				case 0x08:
    #####: 3929:					written += t2pWriteFile(output, (tdata_t) "\\b", 2);
    #####: 3930:					break;
    #####: 3931:				case 0x09:
    #####: 3932:					written += t2pWriteFile(output, (tdata_t) "\\t", 2);
    #####: 3933:					break;
    #####: 3934:				case 0x0A:
    #####: 3935:					written += t2pWriteFile(output, (tdata_t) "\\n", 2);
    #####: 3936:					break;
    #####: 3937:				case 0x0C:
    #####: 3938:					written += t2pWriteFile(output, (tdata_t) "\\f", 2);
    #####: 3939:					break;
    #####: 3940:				case 0x0D:
    #####: 3941:					written += t2pWriteFile(output, (tdata_t) "\\r", 2);
    #####: 3942:					break;
    #####: 3943:				case 0x28:
    #####: 3944:					written += t2pWriteFile(output, (tdata_t) "\\(", 2);
    #####: 3945:					break;
    #####: 3946:				case 0x29:
    #####: 3947:					written += t2pWriteFile(output, (tdata_t) "\\)", 2);
    #####: 3948:					break;
    #####: 3949:				case 0x5C:
    #####: 3950:					written += t2pWriteFile(output, (tdata_t) "\\\\", 2);
    #####: 3951:					break;
    #####: 3952:				default:
    #####: 3953:					written += t2pWriteFile(output, (tdata_t) &pdfstr[i], 1);
        -: 3954:			}
        -: 3955:		}
        -: 3956:	}
    #####: 3957:	written += t2pWriteFile(output, (tdata_t) ") ", 1);
        -: 3958:
    #####: 3959:	return(written);
        -: 3960:}
        -: 3961:
        -: 3962:
        -: 3963:/*
        -: 3964:	This function writes a buffer of data to output.
        -: 3965:*/
        -: 3966:
    #####: 3967:tsize_t t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output){
        -: 3968:
    #####: 3969:	tsize_t written=0;
        -: 3970:
    #####: 3971:	written += t2pWriteFile(output, (tdata_t) buffer, len);
        -: 3972:
    #####: 3973:	return(written);
        -: 3974:}
        -: 3975:
        -: 3976:/*
        -: 3977:	This functions writes the beginning of a PDF stream to output.
        -: 3978:*/
        -: 3979:
    #####: 3980:tsize_t t2p_write_pdf_stream_start(TIFF* output){
        -: 3981:
    #####: 3982:	tsize_t written=0;
        -: 3983:
    #####: 3984:	written += t2pWriteFile(output, (tdata_t) "stream\n", 7);
        -: 3985:
    #####: 3986:	return(written);
        -: 3987:}
        -: 3988:
        -: 3989:/*
        -: 3990:	This function writes the end of a PDF stream to output. 
        -: 3991:*/
        -: 3992:
    #####: 3993:tsize_t t2p_write_pdf_stream_end(TIFF* output){
        -: 3994:
    #####: 3995:	tsize_t written=0;
        -: 3996:
    #####: 3997:	written += t2pWriteFile(output, (tdata_t) "\nendstream\n", 11);
        -: 3998:
    #####: 3999:	return(written);
        -: 4000:}
        -: 4001:
        -: 4002:/*
        -: 4003:	This function writes a stream dictionary for a PDF stream to output.
        -: 4004:*/
        -: 4005:
    #####: 4006:tsize_t t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output){
        -: 4007:	
    #####: 4008:	tsize_t written=0;
    #####: 4009:	char buffer[32];
    #####: 4010:	int buflen=0;
        -: 4011:	
    #####: 4012:	written += t2pWriteFile(output, (tdata_t) "/Length ", 8);
    #####: 4013:	if(len!=0){
    #####: 4014:		written += t2p_write_pdf_stream_length(len, output);
        -: 4015:	} else {
    #####: 4016:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
    #####: 4017:		check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 4018:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4019:		written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        -: 4020:	}
        -: 4021:	
    #####: 4022:	return(written);
        -: 4023:}
        -: 4024:
        -: 4025:/*
        -: 4026:	This functions writes the beginning of a PDF stream dictionary to output.
        -: 4027:*/
        -: 4028:
    #####: 4029:tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){
        -: 4030:
    #####: 4031:	tsize_t written=0;
        -: 4032:
    #####: 4033:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
        -: 4034:
    #####: 4035:	return(written);
        -: 4036:}
        -: 4037:
        -: 4038:/*
        -: 4039:	This function writes the end of a PDF stream dictionary to output. 
        -: 4040:*/
        -: 4041:
    #####: 4042:tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){
        -: 4043:
    #####: 4044:	tsize_t written=0;
        -: 4045:
    #####: 4046:	written += t2pWriteFile(output, (tdata_t) " >>\n", 4);
        -: 4047:
    #####: 4048:	return(written);
        -: 4049:}
        -: 4050:
        -: 4051:/*
        -: 4052:	This function writes a number to output.
        -: 4053:*/
        -: 4054:
    #####: 4055:tsize_t t2p_write_pdf_stream_length(tsize_t len, TIFF* output){
        -: 4056:
    #####: 4057:	tsize_t written=0;
    #####: 4058:	char buffer[32];
    #####: 4059:	int buflen=0;
        -: 4060:
    #####: 4061:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)len);
    #####: 4062:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 4063:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4064:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4065:
    #####: 4066:	return(written);
        -: 4067:}
        -: 4068:
        -: 4069:/*
        -: 4070: * This function writes the PDF Catalog structure to output.
        -: 4071: */
        -: 4072:
    #####: 4073:tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)
        -: 4074:{
    #####: 4075:	tsize_t written = 0;
    #####: 4076:	char buffer[32];
    #####: 4077:	int buflen = 0;
        -: 4078:
    #####: 4079:	written += t2pWriteFile(output, 
        -: 4080:		(tdata_t)"<< \n/Type /Catalog \n/Pages ", 
        -: 4081:		27);
    #####: 4082:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
    #####: 4083:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4084:	written += t2pWriteFile(output, (tdata_t) buffer,
    #####: 4085:				TIFFmin((size_t)buflen, sizeof(buffer) - 1));
    #####: 4086:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4087:	if(t2p->pdf_fitwindow){
    #####: 4088:		written += t2pWriteFile(output, 
        -: 4089:			(tdata_t) "/ViewerPreferences <</FitWindow true>>\n", 
        -: 4090:			39);
        -: 4091:	}
    #####: 4092:	written += t2pWriteFile(output, (tdata_t)">>\n", 3);
        -: 4093:
    #####: 4094:	return(written);
        -: 4095:}
        -: 4096:
        -: 4097:/*
        -: 4098:	This function writes the PDF Info structure to output.
        -: 4099:*/
        -: 4100:
    #####: 4101:tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)
        -: 4102:{
    #####: 4103:	tsize_t written = 0;
    #####: 4104:	char* info;
    #####: 4105:	char buffer[512];
        -: 4106:
    #####: 4107:	if(t2p->pdf_datetime[0] == '\0')
    #####: 4108:		t2p_pdf_tifftime(t2p, input);
    #####: 4109:	if (strlen(t2p->pdf_datetime) > 0) {
    #####: 4110:		written += t2pWriteFile(output, (tdata_t) "<< \n/CreationDate ", 18);
    #####: 4111:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
    #####: 4112:		written += t2pWriteFile(output, (tdata_t) "\n/ModDate ", 10);
    #####: 4113:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
        -: 4114:	}
    #####: 4115:	written += t2pWriteFile(output, (tdata_t) "\n/Producer ", 11);
    #####: 4116:	snprintf(buffer, sizeof(buffer), "libtiff / tiff2pdf - %d", TIFFLIB_VERSION);
    #####: 4117:	written += t2p_write_pdf_string(buffer, output);
    #####: 4118:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
    #####: 4119:	if (t2p->pdf_creator[0] != '\0') {
    #####: 4120:		written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4121:		written += t2p_write_pdf_string(t2p->pdf_creator, output);
    #####: 4122:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4123:	} else {
    #####: 4124:		if (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {
    #####: 4125:			if(strlen(info) >= sizeof(t2p->pdf_creator))
    #####: 4126:				info[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####: 4127:			written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4128:			written += t2p_write_pdf_string(info, output);
    #####: 4129:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4130:		}
        -: 4131:	}
    #####: 4132:	if (t2p->pdf_author[0] != '\0') {
    #####: 4133:		written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4134:		written += t2p_write_pdf_string(t2p->pdf_author, output);
    #####: 4135:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4136:	} else {
    #####: 4137:		if ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0
    #####: 4138:		     || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)
    #####: 4139:		    && info) {
    #####: 4140:			if (strlen(info) >= sizeof(t2p->pdf_author))
    #####: 4141:				info[sizeof(t2p->pdf_author) - 1] = '\0';
    #####: 4142:			written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4143:			written += t2p_write_pdf_string(info, output);
    #####: 4144:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4145:		}
        -: 4146:	}
    #####: 4147:	if (t2p->pdf_title[0] != '\0') {
    #####: 4148:		written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
    #####: 4149:		written += t2p_write_pdf_string(t2p->pdf_title, output);
    #####: 4150:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4151:	} else {
    #####: 4152:		if (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){
    #####: 4153:			if(strlen(info) > 511) {
    #####: 4154:				info[512] = '\0';
        -: 4155:			}
    #####: 4156:			written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
    #####: 4157:			written += t2p_write_pdf_string(info, output);
    #####: 4158:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4159:		}
        -: 4160:	}
    #####: 4161:	if (t2p->pdf_subject[0] != '\0') {
    #####: 4162:		written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4163:		written += t2p_write_pdf_string(t2p->pdf_subject, output);
    #####: 4164:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4165:	} else {
    #####: 4166:		if (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {
    #####: 4167:			if (strlen(info) >= sizeof(t2p->pdf_subject))
    #####: 4168:				info[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####: 4169:			written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4170:			written += t2p_write_pdf_string(info, output);
    #####: 4171:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4172:		}
        -: 4173:	}
    #####: 4174:	if (t2p->pdf_keywords[0] != '\0') {
    #####: 4175:		written += t2pWriteFile(output, (tdata_t) "/Keywords ", 10);
    #####: 4176:		written += t2p_write_pdf_string(t2p->pdf_keywords, output);
    #####: 4177:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4178:	}
    #####: 4179:	written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4180:
    #####: 4181:	return(written);
        -: 4182:}
        -: 4183:
        -: 4184:/*
        -: 4185: * This function fills a string of a T2P struct with the current time as a PDF
        -: 4186: * date string, it is called by t2p_pdf_tifftime.
        -: 4187: */
        -: 4188:
    #####: 4189:void t2p_pdf_currenttime(T2P* t2p)
        -: 4190:{
        -: 4191:	struct tm* currenttime;
    #####: 4192:	time_t timenow;
        -: 4193:
    #####: 4194:	if (time(&timenow) == (time_t) -1) {
    #####: 4195:		TIFFError(TIFF2PDF_MODULE,
    #####: 4196:			  "Can't get the current time: %s", strerror(errno));
    #####: 4197:		timenow = (time_t) 0;
        -: 4198:	}
        -: 4199:
    #####: 4200:	currenttime = localtime(&timenow);
    #####: 4201:	snprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),
        -: 4202:		 "D:%.4d%.2d%.2d%.2d%.2d%.2d",
    #####: 4203:		 (currenttime->tm_year + 1900) % 65536,
    #####: 4204:		 (currenttime->tm_mon + 1) % 256,
    #####: 4205:		 (currenttime->tm_mday) % 256,
    #####: 4206:		 (currenttime->tm_hour) % 256,
    #####: 4207:		 (currenttime->tm_min) % 256,
    #####: 4208:		 (currenttime->tm_sec) % 256);
        -: 4209:
    #####: 4210:	return;
        -: 4211:}
        -: 4212:
        -: 4213:/*
        -: 4214: * This function fills a string of a T2P struct with the date and time of a
        -: 4215: * TIFF file if it exists or the current time as a PDF date string.
        -: 4216: */
        -: 4217:
    #####: 4218:void t2p_pdf_tifftime(T2P* t2p, TIFF* input)
        -: 4219:{
    #####: 4220:	char* datetime;
        -: 4221:
    #####: 4222:	if (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0
    #####: 4223:	    && (strlen(datetime) >= 19) ){
    #####: 4224:		t2p->pdf_datetime[0]='D';
    #####: 4225:		t2p->pdf_datetime[1]=':';
    #####: 4226:		t2p->pdf_datetime[2]=datetime[0];
    #####: 4227:		t2p->pdf_datetime[3]=datetime[1];
    #####: 4228:		t2p->pdf_datetime[4]=datetime[2];
    #####: 4229:		t2p->pdf_datetime[5]=datetime[3];
    #####: 4230:		t2p->pdf_datetime[6]=datetime[5];
    #####: 4231:		t2p->pdf_datetime[7]=datetime[6];
    #####: 4232:		t2p->pdf_datetime[8]=datetime[8];
    #####: 4233:		t2p->pdf_datetime[9]=datetime[9];
    #####: 4234:		t2p->pdf_datetime[10]=datetime[11];
    #####: 4235:		t2p->pdf_datetime[11]=datetime[12];
    #####: 4236:		t2p->pdf_datetime[12]=datetime[14];
    #####: 4237:		t2p->pdf_datetime[13]=datetime[15];
    #####: 4238:		t2p->pdf_datetime[14]=datetime[17];
    #####: 4239:		t2p->pdf_datetime[15]=datetime[18];
    #####: 4240:		t2p->pdf_datetime[16] = '\0';
        -: 4241:	} else {
    #####: 4242:		t2p_pdf_currenttime(t2p);
        -: 4243:	}
        -: 4244:
    #####: 4245:	return;
        -: 4246:}
        -: 4247:
        -: 4248:/*
        -: 4249: * This function writes a PDF Pages Tree structure to output.
        -: 4250: */
        -: 4251:
    #####: 4252:tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)
        -: 4253:{
    #####: 4254:	tsize_t written=0;
    #####: 4255:	tdir_t i=0;
    #####: 4256:	char buffer[32];
    #####: 4257:	int buflen=0;
        -: 4258:
    #####: 4259:	int page=0;
    #####: 4260:	written += t2pWriteFile(output,
        -: 4261:		(tdata_t) "<< \n/Type /Pages \n/Kids [ ", 26);
    #####: 4262:	page = t2p->pdf_pages+1;
    #####: 4263:	for (i=0;i<t2p->tiff_pagecount;i++){
    #####: 4264:		buflen=snprintf(buffer, sizeof(buffer), "%d", page);
    #####: 4265:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4266:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4267:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4268:		if ( ((i+1)%8)==0 ) {
    #####: 4269:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4270:		}
    #####: 4271:		page +=3;
    #####: 4272:		page += t2p->tiff_pages[i].page_extra;
    #####: 4273:		if(t2p->tiff_pages[i].page_tilecount>0){
    #####: 4274:			page += (2 * t2p->tiff_pages[i].page_tilecount);
        -: 4275:		} else {
    #####: 4276:			page +=2;
        -: 4277:		}
        -: 4278:	}
    #####: 4279:	written += t2pWriteFile(output, (tdata_t) "] \n/Count ", 10);
    #####: 4280:	buflen=snprintf(buffer, sizeof(buffer), "%d", t2p->tiff_pagecount);
    #####: 4281:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4282:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4283:	written += t2pWriteFile(output, (tdata_t) " \n>> \n", 6);
        -: 4284:
    #####: 4285:	return(written);
        -: 4286:}
        -: 4287:
        -: 4288:/*
        -: 4289:	This function writes a PDF Page structure to output.
        -: 4290:*/
        -: 4291:
    #####: 4292:tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){
        -: 4293:
    #####: 4294:	unsigned int i=0;
    #####: 4295:	tsize_t written=0;
    #####: 4296:	char buffer[256];
    #####: 4297:	int buflen=0;
        -: 4298:
    #####: 4299:	written += t2pWriteFile(output, (tdata_t) "<<\n/Type /Page \n/Parent ", 24);
    #####: 4300:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
    #####: 4301:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4302:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4303:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4304:	written += t2pWriteFile(output, (tdata_t) "/MediaBox [", 11); 
    #####: 4305:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x1);
    #####: 4306:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4307:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4308:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4309:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y1);
    #####: 4310:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4311:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4312:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4313:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x2);
    #####: 4314:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4315:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4316:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4317:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y2);
    #####: 4318:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4319:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4320:	written += t2pWriteFile(output, (tdata_t) "] \n", 3); 
    #####: 4321:	written += t2pWriteFile(output, (tdata_t) "/Contents ", 10);
    #####: 4322:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(object + 1));
    #####: 4323:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4324:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4325:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4326:	written += t2pWriteFile(output, (tdata_t) "/Resources << \n", 15);
    #####: 4327:	if( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){
    #####: 4328:		written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
    #####: 4329:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){
    #####: 4330:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
    #####: 4331:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4332:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4333:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4334:			written += t2pWriteFile(output, (tdata_t) "_", 1);
    #####: 4335:			buflen = snprintf(buffer, sizeof(buffer), "%u", i+1);
    #####: 4336:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4337:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4338:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4339:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4340:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
    #####: 4341:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4342:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4343:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4344:			if(i%4==3){
    #####: 4345:				written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4346:			}
        -: 4347:		}
    #####: 4348:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4349:	} else {
    #####: 4350:			written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
    #####: 4351:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
    #####: 4352:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4353:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4354:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4355:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4356:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4357:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
    #####: 4358:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4359:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4360:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4361:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4362:	}
    #####: 4363:	if(t2p->tiff_transferfunctioncount != 0) {
    #####: 4364:		written += t2pWriteFile(output, (tdata_t) "/ExtGState <<", 13);
    #####: 4365:		t2pWriteFile(output, (tdata_t) "/GS1 ", 5);
    #####: 4366:		buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4367:			(unsigned long)(object + 3)); 
    #####: 4368:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4369:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4370:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4371:		written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4372:	}
    #####: 4373:	written += t2pWriteFile(output, (tdata_t) "/ProcSet [ ", 11);
    #####: 4374:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL 
    #####: 4375:		|| t2p->pdf_colorspace & T2P_CS_GRAY
        -: 4376:		){
    #####: 4377:		written += t2pWriteFile(output, (tdata_t) "/ImageB ", 8);
        -: 4378:	} else {
    #####: 4379:		written += t2pWriteFile(output, (tdata_t) "/ImageC ", 8);
    #####: 4380:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 4381:			written += t2pWriteFile(output, (tdata_t) "/ImageI ", 8);
        -: 4382:		}
        -: 4383:	}
    #####: 4384:	written += t2pWriteFile(output, (tdata_t) "]\n>>\n>>\n", 8);
        -: 4385:
    #####: 4386:	return(written);
        -: 4387:}
        -: 4388:
        -: 4389:/*
        -: 4390:	This function composes the page size and image and tile locations on a page.
        -: 4391:*/
        -: 4392:
    #####: 4393:void t2p_compose_pdf_page(T2P* t2p){
        -: 4394:
    #####: 4395:	uint32 i=0;
    #####: 4396:	uint32 i2=0;
    #####: 4397:	T2P_TILE* tiles=NULL;
    #####: 4398:	T2P_BOX* boxp=NULL;
    #####: 4399:	uint32 tilecountx=0;
    #####: 4400:	uint32 tilecounty=0;
    #####: 4401:	uint32 tilewidth=0;
    #####: 4402:	uint32 tilelength=0;
    #####: 4403:	int istiled=0;
    #####: 4404:	float f=0;
    #####: 4405:	float width_ratio=0;
    #####: 4406:	float length_ratio=0;
        -: 4407:	
    #####: 4408:	t2p->pdf_xres = t2p->tiff_xres;
    #####: 4409:	t2p->pdf_yres = t2p->tiff_yres;
    #####: 4410:	if(t2p->pdf_overrideres) {
    #####: 4411:		t2p->pdf_xres = t2p->pdf_defaultxres;
    #####: 4412:		t2p->pdf_yres = t2p->pdf_defaultyres;
        -: 4413:	}
    #####: 4414:	if(t2p->pdf_xres == 0.0)
    #####: 4415:		t2p->pdf_xres = t2p->pdf_defaultxres;
    #####: 4416:	if(t2p->pdf_yres == 0.0)
    #####: 4417:		t2p->pdf_yres = t2p->pdf_defaultyres;
    #####: 4418:	if (t2p->pdf_image_fillpage) {
    #####: 4419:		width_ratio = t2p->pdf_defaultpagewidth/t2p->tiff_width;
    #####: 4420:		length_ratio = t2p->pdf_defaultpagelength/t2p->tiff_length;
    #####: 4421:		if (width_ratio < length_ratio ) {
    #####: 4422:			t2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;
    #####: 4423:			t2p->pdf_imagelength = t2p->tiff_length * width_ratio;
        -: 4424:		} else {
    #####: 4425:			t2p->pdf_imagewidth = t2p->tiff_width * length_ratio;
    #####: 4426:			t2p->pdf_imagelength = t2p->pdf_defaultpagelength;
        -: 4427:		}
    #####: 4428:	} else if (t2p->tiff_resunit != RESUNIT_CENTIMETER	/* RESUNIT_NONE and */
    #####: 4429:		&& t2p->tiff_resunit != RESUNIT_INCH) {	/* other cases */
    #####: 4430:		t2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;
    #####: 4431:		t2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;
        -: 4432:	} else {
    #####: 4433:		t2p->pdf_imagewidth = 
    #####: 4434:			((float)(t2p->tiff_width))*PS_UNIT_SIZE/t2p->pdf_xres;
    #####: 4435:		t2p->pdf_imagelength = 
    #####: 4436:			((float)(t2p->tiff_length))*PS_UNIT_SIZE/t2p->pdf_yres;
        -: 4437:	}
    #####: 4438:	if(t2p->pdf_overridepagesize != 0) {
    #####: 4439:		t2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;
    #####: 4440:		t2p->pdf_pagelength = t2p->pdf_defaultpagelength;
        -: 4441:	} else {
    #####: 4442:		t2p->pdf_pagewidth = t2p->pdf_imagewidth;
    #####: 4443:		t2p->pdf_pagelength = t2p->pdf_imagelength;
        -: 4444:	}
    #####: 4445:	t2p->pdf_mediabox.x1=0.0;
    #####: 4446:	t2p->pdf_mediabox.y1=0.0;
    #####: 4447:	t2p->pdf_mediabox.x2=t2p->pdf_pagewidth;
    #####: 4448:	t2p->pdf_mediabox.y2=t2p->pdf_pagelength;
    #####: 4449:	t2p->pdf_imagebox.x1=0.0;
    #####: 4450:	t2p->pdf_imagebox.y1=0.0;
    #####: 4451:	t2p->pdf_imagebox.x2=t2p->pdf_imagewidth;
    #####: 4452:	t2p->pdf_imagebox.y2=t2p->pdf_imagelength;
    #####: 4453:	if(t2p->pdf_overridepagesize!=0){
    #####: 4454:		t2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4455:		t2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
    #####: 4456:		t2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4457:		t2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
        -: 4458:	}
    #####: 4459:	if(t2p->tiff_orientation > 4){
    #####: 4460:		f=t2p->pdf_mediabox.x2;
    #####: 4461:		t2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;
    #####: 4462:		t2p->pdf_mediabox.y2=f;
        -: 4463:	}
    #####: 4464:	istiled=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;
    #####: 4465:	if(istiled==0){
    #####: 4466:		t2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);
    #####: 4467:		return;
        -: 4468:	} else {
    #####: 4469:		tilewidth=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;
    #####: 4470:		tilelength=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;
    #####: 4471:		if( tilewidth > INT_MAX ||
    #####: 4472:		    tilelength > INT_MAX ||
    #####: 4473:		    t2p->tiff_width > INT_MAX - tilewidth ||
    #####: 4474:		    t2p->tiff_length > INT_MAX - tilelength )
        -: 4475:		{
    #####: 4476:		    TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 4477:		    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 4478:		    return;
        -: 4479:		}
    #####: 4480:		tilecountx=(t2p->tiff_width + 
    #####: 4481:			tilewidth -1)/ 
        -: 4482:			tilewidth;
    #####: 4483:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=tilecountx;
    #####: 4484:		tilecounty=(t2p->tiff_length + 
    #####: 4485:			tilelength -1)/ 
        -: 4486:			tilelength;
    #####: 4487:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=tilecounty;
    #####: 4488:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=
    #####: 4489:			t2p->tiff_width % tilewidth;
    #####: 4490:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=
    #####: 4491:			t2p->tiff_length % tilelength;
    #####: 4492:		tiles=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;
    #####: 4493:		for(i2=0;i2<tilecounty-1;i2++){
    #####: 4494:			for(i=0;i<tilecountx-1;i++){
    #####: 4495:				boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4496:				boxp->x1 = 
    #####: 4497:					t2p->pdf_imagebox.x1 
    #####: 4498:					+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4499:					/ (float)t2p->tiff_width);
    #####: 4500:				boxp->x2 = 
    #####: 4501:					t2p->pdf_imagebox.x1 
    #####: 4502:					+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4503:					/ (float)t2p->tiff_width);
    #####: 4504:				boxp->y1 = 
    #####: 4505:					t2p->pdf_imagebox.y2 
    #####: 4506:					- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4507:					/ (float)t2p->tiff_length);
    #####: 4508:				boxp->y2 = 
    #####: 4509:					t2p->pdf_imagebox.y2 
    #####: 4510:					- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4511:					/ (float)t2p->tiff_length);
        -: 4512:			}
    #####: 4513:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4514:			boxp->x1 = 
    #####: 4515:				t2p->pdf_imagebox.x1 
    #####: 4516:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4517:				/ (float)t2p->tiff_width);
    #####: 4518:			boxp->x2 = t2p->pdf_imagebox.x2;
    #####: 4519:			boxp->y1 = 
    #####: 4520:				t2p->pdf_imagebox.y2 
    #####: 4521:				- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4522:				/ (float)t2p->tiff_length);
    #####: 4523:			boxp->y2 = 
    #####: 4524:				t2p->pdf_imagebox.y2 
    #####: 4525:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4526:				/ (float)t2p->tiff_length);
        -: 4527:		}
    #####: 4528:		for(i=0;i<tilecountx-1;i++){
    #####: 4529:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4530:			boxp->x1 = 
    #####: 4531:				t2p->pdf_imagebox.x1 
    #####: 4532:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4533:				/ (float)t2p->tiff_width);
    #####: 4534:			boxp->x2 = 
    #####: 4535:				t2p->pdf_imagebox.x1 
    #####: 4536:				+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4537:				/ (float)t2p->tiff_width);
    #####: 4538:			boxp->y1 = t2p->pdf_imagebox.y1;
    #####: 4539:			boxp->y2 = 
    #####: 4540:				t2p->pdf_imagebox.y2 
    #####: 4541:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4542:				/ (float)t2p->tiff_length);
        -: 4543:		}
    #####: 4544:		boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4545:		boxp->x1 = 
    #####: 4546:			t2p->pdf_imagebox.x1 
    #####: 4547:			+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4548:			/ (float)t2p->tiff_width);
    #####: 4549:		boxp->x2 = t2p->pdf_imagebox.x2;
    #####: 4550:		boxp->y1 = t2p->pdf_imagebox.y1;
    #####: 4551:		boxp->y2 = 
    #####: 4552:			t2p->pdf_imagebox.y2 
    #####: 4553:			- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4554:			/ (float)t2p->tiff_length);
        -: 4555:	}
    #####: 4556:	if(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){
    #####: 4557:		for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
    #####: 4558:			t2p_compose_pdf_page_orient( &(tiles[i].tile_box) , 0);
        -: 4559:		}
    #####: 4560:		return;
        -: 4561:	}
    #####: 4562:	for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
    #####: 4563:		boxp=&(tiles[i].tile_box);
    #####: 4564:		boxp->x1 -= t2p->pdf_imagebox.x1;
    #####: 4565:		boxp->x2 -= t2p->pdf_imagebox.x1;
    #####: 4566:		boxp->y1 -= t2p->pdf_imagebox.y1;
    #####: 4567:		boxp->y2 -= t2p->pdf_imagebox.y1;
    #####: 4568:		if(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){
    #####: 4569:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4570:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4571:		}
    #####: 4572:		if(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){
    #####: 4573:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4574:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4575:		}
    #####: 4576:		if(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){
    #####: 4577:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4578:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4579:		}
    #####: 4580:		if(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){
    #####: 4581:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4582:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4583:		}
    #####: 4584:		if(t2p->tiff_orientation > 4){
    #####: 4585:			f=boxp->x1;
    #####: 4586:			boxp->x1 = boxp->y1;
    #####: 4587:			boxp->y1 = f;
    #####: 4588:			f=boxp->x2;
    #####: 4589:			boxp->x2 = boxp->y2;
    #####: 4590:			boxp->y2 = f; 
    #####: 4591:			t2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);
        -: 4592:		} else {
    #####: 4593:			t2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);
        -: 4594:		}
        -: 4595:		
        -: 4596:	}
        -: 4597:
    #####: 4598:	return;
        -: 4599:}
        -: 4600:
    #####: 4601:void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){
        -: 4602:
        -: 4603:	float m1[9];
    #####: 4604:	float f=0.0;
        -: 4605:	
    #####: 4606:	if( boxp->x1 > boxp->x2){
    #####: 4607:		f=boxp->x1;
    #####: 4608:		boxp->x1=boxp->x2;
    #####: 4609:		boxp->x2 = f;
        -: 4610:	}
    #####: 4611:	if( boxp->y1 > boxp->y2){
    #####: 4612:		f=boxp->y1;
    #####: 4613:		boxp->y1=boxp->y2;
    #####: 4614:		boxp->y2 = f;
        -: 4615:	}
    #####: 4616:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
    #####: 4617:	boxp->mat[1]=m1[1]=0.0;
    #####: 4618:	boxp->mat[2]=m1[2]=0.0;
    #####: 4619:	boxp->mat[3]=m1[3]=0.0;
    #####: 4620:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
    #####: 4621:	boxp->mat[5]=m1[5]=0.0;
    #####: 4622:	boxp->mat[6]=m1[6]=boxp->x1;
    #####: 4623:	boxp->mat[7]=m1[7]=boxp->y1;
    #####: 4624:	boxp->mat[8]=m1[8]=1.0;
    #####: 4625:	switch(orientation){
    #####: 4626:		case 0:
        -: 4627:		case 1:
    #####: 4628:			break;
    #####: 4629:		case 2:
    #####: 4630:			boxp->mat[0]=0.0F-m1[0];
    #####: 4631:			boxp->mat[6]+=m1[0];
    #####: 4632:			break;
    #####: 4633:		case 3:
    #####: 4634:			boxp->mat[0]=0.0F-m1[0];
    #####: 4635:			boxp->mat[4]=0.0F-m1[4];
    #####: 4636:			boxp->mat[6]+=m1[0];
    #####: 4637:			boxp->mat[7]+=m1[4];
    #####: 4638:			break;
    #####: 4639:		case 4:
    #####: 4640:			boxp->mat[4]=0.0F-m1[4];
    #####: 4641:			boxp->mat[7]+=m1[4];
    #####: 4642:			break;
    #####: 4643:		case 5:
    #####: 4644:			boxp->mat[0]=0.0F;
    #####: 4645:			boxp->mat[1]=0.0F-m1[0];
    #####: 4646:			boxp->mat[3]=0.0F-m1[4];
    #####: 4647:			boxp->mat[4]=0.0F;
    #####: 4648:			boxp->mat[6]+=m1[4];
    #####: 4649:			boxp->mat[7]+=m1[0];
    #####: 4650:			break;
    #####: 4651:		case 6:
    #####: 4652:			boxp->mat[0]=0.0F;
    #####: 4653:			boxp->mat[1]=0.0F-m1[0];
    #####: 4654:			boxp->mat[3]=m1[4];
    #####: 4655:			boxp->mat[4]=0.0F;
    #####: 4656:			boxp->mat[7]+=m1[0];
    #####: 4657:			break;
    #####: 4658:		case 7:
    #####: 4659:			boxp->mat[0]=0.0F;
    #####: 4660:			boxp->mat[1]=m1[0];
    #####: 4661:			boxp->mat[3]=m1[4];
    #####: 4662:			boxp->mat[4]=0.0F;
    #####: 4663:			break;
    #####: 4664:		case 8:
    #####: 4665:			boxp->mat[0]=0.0F;
    #####: 4666:			boxp->mat[1]=m1[0];
    #####: 4667:			boxp->mat[3]=0.0F-m1[4];
    #####: 4668:			boxp->mat[4]=0.0F;
    #####: 4669:			boxp->mat[6]+=m1[4];
    #####: 4670:			break;
        -: 4671:	}
        -: 4672:
    #####: 4673:	return;
        -: 4674:}
        -: 4675:
    #####: 4676:void t2p_compose_pdf_page_orient_flip(T2P_BOX* boxp, uint16 orientation){
        -: 4677:
        -: 4678:	float m1[9];
    #####: 4679:	float f=0.0;
        -: 4680:	
    #####: 4681:	if( boxp->x1 > boxp->x2){
    #####: 4682:		f=boxp->x1;
    #####: 4683:		boxp->x1=boxp->x2;
    #####: 4684:		boxp->x2 = f;
        -: 4685:	}
    #####: 4686:	if( boxp->y1 > boxp->y2){
    #####: 4687:		f=boxp->y1;
    #####: 4688:		boxp->y1=boxp->y2;
    #####: 4689:		boxp->y2 = f;
        -: 4690:	}
    #####: 4691:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
    #####: 4692:	boxp->mat[1]=m1[1]=0.0F;
    #####: 4693:	boxp->mat[2]=m1[2]=0.0F;
    #####: 4694:	boxp->mat[3]=m1[3]=0.0F;
    #####: 4695:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
    #####: 4696:	boxp->mat[5]=m1[5]=0.0F;
    #####: 4697:	boxp->mat[6]=m1[6]=boxp->x1;
    #####: 4698:	boxp->mat[7]=m1[7]=boxp->y1;
    #####: 4699:	boxp->mat[8]=m1[8]=1.0F;
    #####: 4700:	switch(orientation){
    #####: 4701:		case 5:
    #####: 4702:			boxp->mat[0]=0.0F;
    #####: 4703:			boxp->mat[1]=0.0F-m1[4];
    #####: 4704:			boxp->mat[3]=0.0F-m1[0];
    #####: 4705:			boxp->mat[4]=0.0F;
    #####: 4706:			boxp->mat[6]+=m1[0];
    #####: 4707:			boxp->mat[7]+=m1[4];
    #####: 4708:			break;
    #####: 4709:		case 6:
    #####: 4710:			boxp->mat[0]=0.0F;
    #####: 4711:			boxp->mat[1]=0.0F-m1[4];
    #####: 4712:			boxp->mat[3]=m1[0];
    #####: 4713:			boxp->mat[4]=0.0F;
    #####: 4714:			boxp->mat[7]+=m1[4];
    #####: 4715:			break;
    #####: 4716:		case 7:
    #####: 4717:			boxp->mat[0]=0.0F;
    #####: 4718:			boxp->mat[1]=m1[4];
    #####: 4719:			boxp->mat[3]=m1[0];
    #####: 4720:			boxp->mat[4]=0.0F;
    #####: 4721:			break;
    #####: 4722:		case 8:
    #####: 4723:			boxp->mat[0]=0.0F;
    #####: 4724:			boxp->mat[1]=m1[4];
    #####: 4725:			boxp->mat[3]=0.0F-m1[0];
    #####: 4726:			boxp->mat[4]=0.0F;
    #####: 4727:			boxp->mat[6]+=m1[0];
    #####: 4728:			break;
        -: 4729:	}
        -: 4730:
    #####: 4731:	return;
        -: 4732:}
        -: 4733:
        -: 4734:/*
        -: 4735:	This function writes a PDF Contents stream to output.
        -: 4736:*/
        -: 4737:
    #####: 4738:tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){
        -: 4739:
    #####: 4740:	tsize_t written=0;
    #####: 4741:	ttile_t i=0;
    #####: 4742:	char buffer[512];
    #####: 4743:	int buflen=0;
        -: 4744:	T2P_BOX box;
        -: 4745:	
    #####: 4746:	if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){ 
    #####: 4747:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; i++){
    #####: 4748:			box=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[i].tile_box;
    #####: 4749:			buflen=snprintf(buffer, sizeof(buffer), 
        -: 4750:				"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\n", 
    #####: 4751:				t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    #####: 4752:				box.mat[0],
    #####: 4753:				box.mat[1],
    #####: 4754:				box.mat[3],
    #####: 4755:				box.mat[4],
    #####: 4756:				box.mat[6],
    #####: 4757:				box.mat[7],
    #####: 4758:				t2p->pdf_page + 1, 
    #####: 4759:				(long)(i + 1));
    #####: 4760:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4761:			written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4762:		}
        -: 4763:	} else {
    #####: 4764:		box=t2p->pdf_imagebox;
    #####: 4765:		buflen=snprintf(buffer, sizeof(buffer), 
        -: 4766:			"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\n", 
    #####: 4767:			t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    #####: 4768:			box.mat[0],
    #####: 4769:			box.mat[1],
    #####: 4770:			box.mat[3],
    #####: 4771:			box.mat[4],
    #####: 4772:			box.mat[6],
    #####: 4773:			box.mat[7],
    #####: 4774:			t2p->pdf_page+1);
    #####: 4775:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4776:		written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4777:	}
        -: 4778:
    #####: 4779:	return(written);
        -: 4780:}
        -: 4781:
        -: 4782:/*
        -: 4783:	This function writes a PDF Image XObject stream dictionary to output. 
        -: 4784:*/
        -: 4785:
    #####: 4786:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t tile, 
        -: 4787:												T2P* t2p, 
        -: 4788:												TIFF* output){
        -: 4789:
    #####: 4790:	tsize_t written=0;
    #####: 4791:	char buffer[32];
    #####: 4792:	int buflen=0;
        -: 4793:
    #####: 4794:	written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); 
    #####: 4795:	written += t2pWriteFile(output, 
        -: 4796:		(tdata_t) "/Type /XObject \n/Subtype /Image \n/Name /Im", 
        -: 4797:		42);
    #####: 4798:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4799:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4800:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4801:	if(tile != 0){
    #####: 4802:		written += t2pWriteFile(output, (tdata_t) "_", 1);
    #####: 4803:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)tile);
    #####: 4804:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4805:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 4806:	}
    #####: 4807:	written += t2pWriteFile(output, (tdata_t) "\n/Width ", 8);
    #####: 4808:	if(tile==0){
    #####: 4809:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_width);
        -: 4810:	} else {
    #####: 4811:		if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
    #####: 4812:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4813:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 4814:		} else {
    #####: 4815:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4816:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 4817:		}
        -: 4818:	}
    #####: 4819:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4820:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4821:	written += t2pWriteFile(output, (tdata_t) "\n/Height ", 9);
    #####: 4822:	if(tile==0){
    #####: 4823:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_length);
        -: 4824:	} else {
    #####: 4825:		if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
    #####: 4826:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4827:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 4828:		} else {
    #####: 4829:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4830:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 4831:		}
        -: 4832:	}
    #####: 4833:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4834:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4835:	written += t2pWriteFile(output, (tdata_t) "\n/BitsPerComponent ", 19);
    #####: 4836:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
    #####: 4837:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4838:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4839:	written += t2pWriteFile(output, (tdata_t) "\n/ColorSpace ", 13);
    #####: 4840:	written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 4841:	if (t2p->pdf_image_interpolate)
    #####: 4842:		written += t2pWriteFile(output,
        -: 4843:					 (tdata_t) "\n/Interpolate true", 18);
    #####: 4844:	if( (t2p->pdf_switchdecode != 0)
        -: 4845:#ifdef CCITT_SUPPORT
    #####: 4846:		&& ! (t2p->pdf_colorspace & T2P_CS_BILEVEL 
    #####: 4847:		&& t2p->pdf_compression == T2P_COMPRESS_G4)
        -: 4848:#endif
        -: 4849:		){
    #####: 4850:		written += t2p_write_pdf_xobject_decode(t2p, output);
        -: 4851:	}
    #####: 4852:	written += t2p_write_pdf_xobject_stream_filter(tile, t2p, output);
        -: 4853:	
    #####: 4854:	return(written);
        -: 4855:}
        -: 4856:
        -: 4857:/*
        -: 4858: * 	This function writes a PDF Image XObject Colorspace name to output.
        -: 4859: */
        -: 4860:
        -: 4861:
    #####: 4862:tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){
        -: 4863:
    #####: 4864:	tsize_t written=0;
    #####: 4865:	char buffer[128];
    #####: 4866:	int buflen=0;
        -: 4867:
    #####: 4868:	float X_W=1.0;
    #####: 4869:	float Y_W=1.0;
    #####: 4870:	float Z_W=1.0;
        -: 4871:	
    #####: 4872:	if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 4873:		written += t2p_write_pdf_xobject_icccs(t2p, output);
    #####: 4874:		return(written);
        -: 4875:	}
    #####: 4876:	if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 4877:		written += t2pWriteFile(output, (tdata_t) "[ /Indexed ", 11);
    #####: 4878:		t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 4879:		written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 4880:		t2p->pdf_colorspace |= T2P_CS_PALETTE;
    #####: 4881:		buflen=snprintf(buffer, sizeof(buffer), "%u", (0x0001 << t2p->tiff_bitspersample)-1 );
    #####: 4882:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4883:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4884:		written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4885:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_palettecs ); 
    #####: 4886:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4887:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4888:		written += t2pWriteFile(output, (tdata_t) " 0 R ]\n", 7);
    #####: 4889:		return(written);
        -: 4890:	}
    #####: 4891:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL){
    #####: 4892:			written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4893:	}
    #####: 4894:	if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 4895:			if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 4896:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4897:			} else {
    #####: 4898:				written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4899:			}
        -: 4900:	}
    #####: 4901:	if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 4902:			if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 4903:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4904:			} else {
    #####: 4905:				written += t2pWriteFile(output, (tdata_t) "/DeviceRGB \n", 12);
        -: 4906:			}
        -: 4907:	}
    #####: 4908:	if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 4909:			written += t2pWriteFile(output, (tdata_t) "/DeviceCMYK \n", 13);
        -: 4910:	}
    #####: 4911:	if(t2p->pdf_colorspace & T2P_CS_LAB){
    #####: 4912:			written += t2pWriteFile(output, (tdata_t) "[/Lab << \n", 10);
    #####: 4913:			written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 4914:			X_W = t2p->tiff_whitechromaticities[0];
    #####: 4915:			Y_W = t2p->tiff_whitechromaticities[1];
    #####: 4916:			Z_W = 1.0F - (X_W + Y_W);
    #####: 4917:			X_W /= Y_W;
    #####: 4918:			Z_W /= Y_W;
    #####: 4919:			Y_W = 1.0F;
    #####: 4920:			buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 4921:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4922:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4923:			written += t2pWriteFile(output, (tdata_t) "/Range ", 7);
    #####: 4924:			buflen=snprintf(buffer, sizeof(buffer), "[%d %d %d %d] \n", 
        -: 4925:				t2p->pdf_labrange[0], 
        -: 4926:				t2p->pdf_labrange[1], 
        -: 4927:				t2p->pdf_labrange[2], 
        -: 4928:				t2p->pdf_labrange[3]);
    #####: 4929:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4930:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4931:			written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 4932:			
        -: 4933:	}
        -: 4934:	
    #####: 4935:	return(written);
        -: 4936:}
        -: 4937:
    #####: 4938:tsize_t t2p_write_pdf_transfer(T2P* t2p, TIFF* output){
        -: 4939:
    #####: 4940:	tsize_t written=0;
    #####: 4941:	char buffer[32];
    #####: 4942:	int buflen=0;
        -: 4943:
    #####: 4944:	written += t2pWriteFile(output, (tdata_t) "<< /Type /ExtGState \n/TR ", 25);
    #####: 4945:	if(t2p->tiff_transferfunctioncount == 1){
    #####: 4946:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4947:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4948:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4949:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4950:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
        -: 4951:	} else {
    #####: 4952:		written += t2pWriteFile(output, (tdata_t) "[ ", 2);
    #####: 4953:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4954:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4955:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4956:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4957:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4958:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4959:			       (unsigned long)(t2p->pdf_xrefcount + 2));
    #####: 4960:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4961:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4962:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4963:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4964:			       (unsigned long)(t2p->pdf_xrefcount + 3));
    #####: 4965:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4966:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4967:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4968:		written += t2pWriteFile(output, (tdata_t) "/Identity ] ", 12);
        -: 4969:	}
        -: 4970:
    #####: 4971:	written += t2pWriteFile(output, (tdata_t) " >> \n", 5);
        -: 4972:
    #####: 4973:	return(written);
        -: 4974:}
        -: 4975:
    #####: 4976:tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 i){
        -: 4977:
    #####: 4978:	tsize_t written=0;
    #####: 4979:	char buffer[32];
    #####: 4980:	int buflen=0;
        -: 4981:	(void)i; /* XXX */
        -: 4982:
    #####: 4983:	written += t2pWriteFile(output, (tdata_t) "/FunctionType 0 \n", 17);
    #####: 4984:	written += t2pWriteFile(output, (tdata_t) "/Domain [0.0 1.0] \n", 19);
    #####: 4985:	written += t2pWriteFile(output, (tdata_t) "/Range [0.0 1.0] \n", 18);
    #####: 4986:	buflen=snprintf(buffer, sizeof(buffer), "/Size [%u] \n", (1<<t2p->tiff_bitspersample));
    #####: 4987:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4988:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4989:	written += t2pWriteFile(output, (tdata_t) "/BitsPerSample 16 \n", 19);
    #####: 4990:	written += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);
        -: 4991:
    #####: 4992:	return(written);
        -: 4993:}
        -: 4994:
    #####: 4995:tsize_t t2p_write_pdf_transfer_stream(T2P* t2p, TIFF* output, uint16 i){
        -: 4996:
    #####: 4997:	tsize_t written=0;
        -: 4998:
    #####: 4999:	written += t2p_write_pdf_stream(
    #####: 5000:		t2p->tiff_transferfunction[i], 
    #####: 5001:		(((tsize_t)1)<<(t2p->tiff_bitspersample+1)), 
        -: 5002:		output);
        -: 5003:
    #####: 5004:	return(written);
        -: 5005:}
        -: 5006:
        -: 5007:/*
        -: 5008:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5009:*/
        -: 5010:
    #####: 5011:tsize_t t2p_write_pdf_xobject_calcs(T2P* t2p, TIFF* output){
        -: 5012:
    #####: 5013:	tsize_t written=0;
    #####: 5014:	char buffer[256];
    #####: 5015:	int buflen=0;
        -: 5016:	
    #####: 5017:	float X_W=0.0;
    #####: 5018:	float Y_W=0.0;
    #####: 5019:	float Z_W=0.0;
    #####: 5020:	float X_R=0.0;
    #####: 5021:	float Y_R=0.0;
    #####: 5022:	float Z_R=0.0;
    #####: 5023:	float X_G=0.0;
    #####: 5024:	float Y_G=0.0;
    #####: 5025:	float Z_G=0.0;
    #####: 5026:	float X_B=0.0;
    #####: 5027:	float Y_B=0.0;
    #####: 5028:	float Z_B=0.0;
    #####: 5029:	float x_w=0.0;
    #####: 5030:	float y_w=0.0;
    #####: 5031:	float z_w=0.0;
    #####: 5032:	float x_r=0.0;
    #####: 5033:	float y_r=0.0;
    #####: 5034:	float x_g=0.0;
    #####: 5035:	float y_g=0.0;
    #####: 5036:	float x_b=0.0;
    #####: 5037:	float y_b=0.0;
    #####: 5038:	float R=1.0;
    #####: 5039:	float G=1.0;
    #####: 5040:	float B=1.0;
        -: 5041:	
    #####: 5042:	written += t2pWriteFile(output, (tdata_t) "[", 1);
    #####: 5043:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5044:		written += t2pWriteFile(output, (tdata_t) "/CalGray ", 9);
    #####: 5045:		X_W = t2p->tiff_whitechromaticities[0];
    #####: 5046:		Y_W = t2p->tiff_whitechromaticities[1];
    #####: 5047:		Z_W = 1.0F - (X_W + Y_W);
    #####: 5048:		X_W /= Y_W;
    #####: 5049:		Z_W /= Y_W;
    #####: 5050:		Y_W = 1.0F;
        -: 5051:	}
    #####: 5052:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5053:		written += t2pWriteFile(output, (tdata_t) "/CalRGB ", 8);
    #####: 5054:		x_w = t2p->tiff_whitechromaticities[0];
    #####: 5055:		y_w = t2p->tiff_whitechromaticities[1];
    #####: 5056:		x_r = t2p->tiff_primarychromaticities[0];
    #####: 5057:		y_r = t2p->tiff_primarychromaticities[1];
    #####: 5058:		x_g = t2p->tiff_primarychromaticities[2];
    #####: 5059:		y_g = t2p->tiff_primarychromaticities[3];
    #####: 5060:		x_b = t2p->tiff_primarychromaticities[4];
    #####: 5061:		y_b = t2p->tiff_primarychromaticities[5];
    #####: 5062:		z_w = y_w * ((x_g - x_b)*y_r - (x_r-x_b)*y_g + (x_r-x_g)*y_b);
    #####: 5063:		Y_R = (y_r/R) * ((x_g-x_b)*y_w - (x_w-x_b)*y_g + (x_w-x_g)*y_b) / z_w;
    #####: 5064:		X_R = Y_R * x_r / y_r;
    #####: 5065:		Z_R = Y_R * (((1-x_r)/y_r)-1);
    #####: 5066:		Y_G = ((0.0F-(y_g))/G) * ((x_r-x_b)*y_w - (x_w-x_b)*y_r + (x_w-x_r)*y_b) / z_w;
    #####: 5067:		X_G = Y_G * x_g / y_g;
    #####: 5068:		Z_G = Y_G * (((1-x_g)/y_g)-1);
    #####: 5069:		Y_B = (y_b/B) * ((x_r-x_g)*y_w - (x_w-x_g)*y_r + (x_w-x_r)*y_g) / z_w;
    #####: 5070:		X_B = Y_B * x_b / y_b;
    #####: 5071:		Z_B = Y_B * (((1-x_b)/y_b)-1);
    #####: 5072:		X_W = (X_R * R) + (X_G * G) + (X_B * B);
    #####: 5073:		Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);
    #####: 5074:		Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);
    #####: 5075:		X_W /= Y_W;
    #####: 5076:		Z_W /= Y_W;
    #####: 5077:		Y_W = 1.0;
        -: 5078:	}
    #####: 5079:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
    #####: 5080:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5081:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5082:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5083:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5084:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5085:		written += t2pWriteFile(output, (tdata_t) "/Gamma 2.2 \n", 12);
        -: 5086:	}
    #####: 5087:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5088:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5089:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5090:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5091:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5092:		written += t2pWriteFile(output, (tdata_t) "/Matrix ", 8);
    #####: 5093:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f] \n", 
        -: 5094:			X_R, Y_R, Z_R, 
        -: 5095:			X_G, Y_G, Z_G, 
        -: 5096:			X_B, Y_B, Z_B); 
    #####: 5097:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5098:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5099:		written += t2pWriteFile(output, (tdata_t) "/Gamma [2.2 2.2 2.2] \n", 22);
        -: 5100:	}
    #####: 5101:	written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 5102:
    #####: 5103:	return(written);
        -: 5104:}
        -: 5105:
        -: 5106:/*
        -: 5107:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5108:*/
        -: 5109:
    #####: 5110:tsize_t t2p_write_pdf_xobject_icccs(T2P* t2p, TIFF* output){
        -: 5111:
    #####: 5112:	tsize_t written=0;
    #####: 5113:	char buffer[32];
    #####: 5114:	int buflen=0;
        -: 5115:	
    #####: 5116:	written += t2pWriteFile(output, (tdata_t) "[/ICCBased ", 11);
    #####: 5117:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_icccs);
    #####: 5118:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5119:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5120:	written += t2pWriteFile(output, (tdata_t) " 0 R] \n", 7);
        -: 5121:
    #####: 5122:	return(written);
        -: 5123:}
        -: 5124:
    #####: 5125:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P* t2p, TIFF* output){
        -: 5126:
    #####: 5127:	tsize_t written=0;
    #####: 5128:	char buffer[32];
    #####: 5129:	int buflen=0;
        -: 5130:	
    #####: 5131:	written += t2pWriteFile(output, (tdata_t) "/N ", 3);
    #####: 5132:	buflen=snprintf(buffer, sizeof(buffer), "%u \n", t2p->tiff_samplesperpixel);
    #####: 5133:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5134:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5135:	written += t2pWriteFile(output, (tdata_t) "/Alternate ", 11);
    #####: 5136:	t2p->pdf_colorspace ^= T2P_CS_ICCBASED;
    #####: 5137:	written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 5138:	t2p->pdf_colorspace |= T2P_CS_ICCBASED;
    #####: 5139:	written += t2p_write_pdf_stream_dict(t2p->tiff_iccprofilelength, 0, output);
        -: 5140:	
    #####: 5141:	return(written);
        -: 5142:}
        -: 5143:
    #####: 5144:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P* t2p, TIFF* output){
        -: 5145:
    #####: 5146:	tsize_t written=0;
        -: 5147:
    #####: 5148:	written += t2p_write_pdf_stream(
    #####: 5149:				(tdata_t) t2p->tiff_iccprofile, 
    #####: 5150:				(tsize_t) t2p->tiff_iccprofilelength, 
        -: 5151:				output);
        -: 5152:	
    #####: 5153:	return(written);
        -: 5154:}
        -: 5155:
        -: 5156:/*
        -: 5157:	This function writes a palette stream for an indexed color space to output.
        -: 5158:*/
        -: 5159:
    #####: 5160:tsize_t t2p_write_pdf_xobject_palettecs_stream(T2P* t2p, TIFF* output){
        -: 5161:
    #####: 5162:	tsize_t written=0;
        -: 5163:
    #####: 5164:	written += t2p_write_pdf_stream(
    #####: 5165:				(tdata_t) t2p->pdf_palette, 
    #####: 5166:				(tsize_t) t2p->pdf_palettesize, 
        -: 5167:				output);
        -: 5168:	
    #####: 5169:	return(written);
        -: 5170:}
        -: 5171:
        -: 5172:/*
        -: 5173:	This function writes a PDF Image XObject Decode array to output.
        -: 5174:*/
        -: 5175:
    #####: 5176:tsize_t t2p_write_pdf_xobject_decode(T2P* t2p, TIFF* output){
        -: 5177:
    #####: 5178:	tsize_t written=0;
    #####: 5179:	int i=0;
        -: 5180:
    #####: 5181:	written += t2pWriteFile(output, (tdata_t) "/Decode [ ", 10);
    #####: 5182:	for (i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 5183:		written += t2pWriteFile(output, (tdata_t) "1 0 ", 4);
        -: 5184:	}
    #####: 5185:	written += t2pWriteFile(output, (tdata_t) "]\n", 2);
        -: 5186:
    #####: 5187:	return(written);
        -: 5188:}
        -: 5189:
        -: 5190:/*
        -: 5191:	This function writes a PDF Image XObject stream filter name and parameters to 
        -: 5192:	output.
        -: 5193:*/
        -: 5194:
    #####: 5195:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output){
        -: 5196:
    #####: 5197:	tsize_t written=0;
    #####: 5198:	char buffer[32];
    #####: 5199:	int buflen=0;
        -: 5200:
    #####: 5201:	if(t2p->pdf_compression==T2P_COMPRESS_NONE){
    #####: 5202:		return(written);
        -: 5203:	}
    #####: 5204:	written += t2pWriteFile(output, (tdata_t) "/Filter ", 8);
    #####: 5205:	switch(t2p->pdf_compression){
        -: 5206:#ifdef CCITT_SUPPORT
    #####: 5207:		case T2P_COMPRESS_G4:
    #####: 5208:			written += t2pWriteFile(output, (tdata_t) "/CCITTFaxDecode ", 16);
    #####: 5209:			written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
    #####: 5210:			written += t2pWriteFile(output, (tdata_t) "<< /K -1 ", 9);
    #####: 5211:			if(tile==0){
    #####: 5212:				written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5213:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5214:					       (unsigned long)t2p->tiff_width);
    #####: 5215:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5216:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5217:				written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5218:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5219:					       (unsigned long)t2p->tiff_length);
    #####: 5220:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5221:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5222:			} else {
    #####: 5223:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5224:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5225:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5226:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
    #####: 5227:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5228:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5229:				} else {
    #####: 5230:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5231:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5232:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
    #####: 5233:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5234:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5235:				}
    #####: 5236:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5237:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5238:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5239:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 5240:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5241:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5242:				} else {
    #####: 5243:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5244:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5245:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 5246:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5247:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5248:				}
        -: 5249:			}
    #####: 5250:			if(t2p->pdf_switchdecode == 0){
    #####: 5251:				written += t2pWriteFile(output, (tdata_t) " /BlackIs1 true ", 16);
        -: 5252:			}
    #####: 5253:			written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
    #####: 5254:			break;
        -: 5255:#endif
        -: 5256:#ifdef JPEG_SUPPORT
    #####: 5257:		case T2P_COMPRESS_JPEG:
    #####: 5258:			written += t2pWriteFile(output, (tdata_t) "/DCTDecode ", 11);
        -: 5259:
    #####: 5260:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR) {
    #####: 5261:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
    #####: 5262:				written += t2pWriteFile(output, (tdata_t) "<< /ColorTransform 1 >>\n", 24);
        -: 5263:			}
    #####: 5264:			break;
        -: 5265:#endif
        -: 5266:#ifdef ZIP_SUPPORT
        -: 5267:		case T2P_COMPRESS_ZIP:
        -: 5268:			written += t2pWriteFile(output, (tdata_t) "/FlateDecode ", 13);
        -: 5269:			if(t2p->pdf_compressionquality%100){
        -: 5270:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
        -: 5271:				written += t2pWriteFile(output, (tdata_t) "<< /Predictor ", 14);
        -: 5272:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_compressionquality%100);
        -: 5273:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5274:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5275:				written += t2pWriteFile(output, (tdata_t) " /Columns ", 10);
        -: 5276:				buflen = snprintf(buffer, sizeof(buffer), "%lu",
        -: 5277:						 (unsigned long)t2p->tiff_width);
        -: 5278:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5279:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5280:				written += t2pWriteFile(output, (tdata_t) " /Colors ", 9);
        -: 5281:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_samplesperpixel);
        -: 5282:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5283:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5284:				written += t2pWriteFile(output, (tdata_t) " /BitsPerComponent ", 19);
        -: 5285:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
        -: 5286:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5287:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5288:				written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 5289:			}
        -: 5290:			break;
        -: 5291:#endif
    #####: 5292:		default:
    #####: 5293:			break;
        -: 5294:	}
        -: 5295:
    #####: 5296:	return(written);
        -: 5297:}
        -: 5298:
        -: 5299:/*
        -: 5300:	This function writes a PDF xref table to output.
        -: 5301:*/
        -: 5302:
    #####: 5303:tsize_t t2p_write_pdf_xreftable(T2P* t2p, TIFF* output){
        -: 5304:
    #####: 5305:	tsize_t written=0;
    #####: 5306:	char buffer[64];
    #####: 5307:	int buflen=0;
    #####: 5308:	uint32 i=0;
        -: 5309:
    #####: 5310:	written += t2pWriteFile(output, (tdata_t) "xref\n0 ", 7);
    #####: 5311:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 5312:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5313:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5314:	written += t2pWriteFile(output, (tdata_t) " \n0000000000 65535 f \n", 22);
    #####: 5315:	for (i=0;i<t2p->pdf_xrefcount;i++){
    #####: 5316:		snprintf(buffer, sizeof(buffer), "%.10lu 00000 n \n",
    #####: 5317:			(unsigned long)t2p->pdf_xrefoffsets[i]);
    #####: 5318:		written += t2pWriteFile(output, (tdata_t) buffer, 20);
        -: 5319:	}
        -: 5320:
    #####: 5321:	return(written);
        -: 5322:}
        -: 5323:
        -: 5324:/*
        -: 5325: * This function writes a PDF trailer to output.
        -: 5326: */
        -: 5327:
    #####: 5328:tsize_t t2p_write_pdf_trailer(T2P* t2p, TIFF* output)
        -: 5329:{
        -: 5330:
    #####: 5331:	tsize_t written = 0;
    #####: 5332:	char buffer[32];
    #####: 5333:	int buflen = 0;
    #####: 5334:	size_t i = 0;
        -: 5335:
    #####: 5336:	for (i = 0; i < sizeof(t2p->pdf_fileid) - 8; i += 8)
    #####: 5337:		snprintf(t2p->pdf_fileid + i, 9, "%.8X", rand());
        -: 5338:
    #####: 5339:	written += t2pWriteFile(output, (tdata_t) "trailer\n<<\n/Size ", 17);
    #####: 5340:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount+1));
    #####: 5341:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5342:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5343:	written += t2pWriteFile(output, (tdata_t) "\n/Root ", 7);
    #####: 5344:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_catalog);
    #####: 5345:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5346:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5347:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/Info ", 12);
    #####: 5348:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_info);
    #####: 5349:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5350:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5351:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/ID[<", 11);
    #####: 5352:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5353:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5354:	written += t2pWriteFile(output, (tdata_t) "><", 2);
    #####: 5355:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5356:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5357:	written += t2pWriteFile(output, (tdata_t) ">]\n>>\nstartxref\n", 16);
    #####: 5358:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_startxref);
    #####: 5359:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5360:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5361:	written += t2pWriteFile(output, (tdata_t) "\n%%EOF\n", 7);
        -: 5362:
    #####: 5363:	return(written);
        -: 5364:}
        -: 5365: 
        -: 5366:/*
        -: 5367:
        -: 5368:  This function writes a PDF to a file given a pointer to a TIFF.
        -: 5369:
        -: 5370:  The idea with using a TIFF* as output for a PDF file is that the file 
        -: 5371:  can be created with TIFFClientOpen for memory-mapped use within the TIFF 
        -: 5372:  library, and TIFFWriteEncodedStrip can be used to write compressed data to 
        -: 5373:  the output.  The output is not actually a TIFF file, it is a PDF file.  
        -: 5374:
        -: 5375:  This function uses only t2pWriteFile and TIFFWriteEncodedStrip to write to 
        -: 5376:  the output TIFF file.  When libtiff would otherwise be writing data to the 
        -: 5377:  output file, the write procedure of the TIFF structure is replaced with an 
        -: 5378:  empty implementation.
        -: 5379:
        -: 5380:  The first argument to the function is an initialized and validated T2P 
        -: 5381:  context struct pointer.
        -: 5382:
        -: 5383:  The second argument to the function is the TIFF* that is the input that has 
        -: 5384:  been opened for reading and no other functions have been called upon it.
        -: 5385:
        -: 5386:  The third argument to the function is the TIFF* that is the output that has 
        -: 5387:  been opened for writing.  It has to be opened so that it hasn't written any 
        -: 5388:  data to the output.  If the output is seekable then it's OK to seek to the 
        -: 5389:  beginning of the file.  The function only writes to the output PDF and does 
        -: 5390:  not seek.  See the example usage in the main() function.
        -: 5391:
        -: 5392:	TIFF* output = TIFFOpen("output.pdf", "w");
        -: 5393:	assert(output != NULL);
        -: 5394:
        -: 5395:	if(output->tif_seekproc != NULL){
        -: 5396:		t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -: 5397:	}
        -: 5398:
        -: 5399:  This function returns the file size of the output PDF file.  On error it 
        -: 5400:  returns zero and the t2p->t2p_error variable is set to T2P_ERR_ERROR.
        -: 5401:
        -: 5402:  After this function completes, call t2p_free on t2p, TIFFClose on input, 
        -: 5403:  and TIFFClose on output.
        -: 5404:*/
        -: 5405:
    #####: 5406:tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){
        -: 5407:
    #####: 5408:	tsize_t written=0;
    #####: 5409:	ttile_t i2=0;
    #####: 5410:	tsize_t streamlen=0;
    #####: 5411:	uint16 i=0;
        -: 5412:
    #####: 5413:	t2p_read_tiff_init(t2p, input);
    #####: 5414:	if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5415:	t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );
    #####: 5416:	if(t2p->pdf_xrefoffsets==NULL){
    #####: 5417:		TIFFError(
        -: 5418:			TIFF2PDF_MODULE, 
        -: 5419:			"Can't allocate %u bytes of memory for t2p_write_pdf", 
    #####: 5420:			(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );
    #####: 5421:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 5422:		return(written);
        -: 5423:	}
    #####: 5424:	t2p->pdf_xrefcount=0;
    #####: 5425:	t2p->pdf_catalog=1;
    #####: 5426:	t2p->pdf_info=2;
    #####: 5427:	t2p->pdf_pages=3;
    #####: 5428:	written += t2p_write_pdf_header(t2p, output);
    #####: 5429:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5430:	t2p->pdf_catalog=t2p->pdf_xrefcount;
    #####: 5431:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5432:	written += t2p_write_pdf_catalog(t2p, output);
    #####: 5433:	written += t2p_write_pdf_obj_end(output);
    #####: 5434:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5435:	t2p->pdf_info=t2p->pdf_xrefcount;
    #####: 5436:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5437:	written += t2p_write_pdf_info(t2p, input, output);
    #####: 5438:	written += t2p_write_pdf_obj_end(output);
    #####: 5439:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5440:	t2p->pdf_pages=t2p->pdf_xrefcount;
    #####: 5441:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5442:	written += t2p_write_pdf_pages(t2p, output);
    #####: 5443:	written += t2p_write_pdf_obj_end(output);
    #####: 5444:	for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){
    #####: 5445:		t2p_read_tiff_data(t2p, input);
    #####: 5446:		if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5447:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5448:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5449:		written += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);
    #####: 5450:		written += t2p_write_pdf_obj_end(output);
    #####: 5451:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5452:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5453:		written += t2p_write_pdf_stream_dict_start(output);
    #####: 5454:		written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);
    #####: 5455:		written += t2p_write_pdf_stream_dict_end(output);
    #####: 5456:		written += t2p_write_pdf_stream_start(output);
    #####: 5457:		streamlen=written;
    #####: 5458:		written += t2p_write_pdf_page_content_stream(t2p, output);
    #####: 5459:		streamlen=written-streamlen;
    #####: 5460:		written += t2p_write_pdf_stream_end(output);
    #####: 5461:		written += t2p_write_pdf_obj_end(output);
    #####: 5462:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5463:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5464:		written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5465:		written += t2p_write_pdf_obj_end(output);
    #####: 5466:		if(t2p->tiff_transferfunctioncount != 0){
    #####: 5467:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5468:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5469:			written += t2p_write_pdf_transfer(t2p, output);
    #####: 5470:			written += t2p_write_pdf_obj_end(output);
    #####: 5471:			for(i=0; i < t2p->tiff_transferfunctioncount; i++){
    #####: 5472:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5473:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5474:				written += t2p_write_pdf_stream_dict_start(output);
    #####: 5475:				written += t2p_write_pdf_transfer_dict(t2p, output, i);
    #####: 5476:				written += t2p_write_pdf_stream_dict_end(output);
    #####: 5477:				written += t2p_write_pdf_stream_start(output);
        -: 5478:				/* streamlen=written; */ /* value not used */
    #####: 5479:				written += t2p_write_pdf_transfer_stream(t2p, output, i);
        -: 5480:				/* streamlen=written-streamlen; */ /* value not used */
    #####: 5481:				written += t2p_write_pdf_stream_end(output);
    #####: 5482:				written += t2p_write_pdf_obj_end(output);
        -: 5483:			}
        -: 5484:		}
    #####: 5485:		if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 5486:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5487:			t2p->pdf_palettecs=t2p->pdf_xrefcount;
    #####: 5488:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5489:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5490:			written += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);
    #####: 5491:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5492:			written += t2p_write_pdf_stream_start(output);
        -: 5493:			/* streamlen=written; */ /* value not used */
    #####: 5494:			written += t2p_write_pdf_xobject_palettecs_stream(t2p, output);
        -: 5495:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5496:			written += t2p_write_pdf_stream_end(output);
    #####: 5497:			written += t2p_write_pdf_obj_end(output);
        -: 5498:		}
    #####: 5499:		if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 5500:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5501:			t2p->pdf_icccs=t2p->pdf_xrefcount;
    #####: 5502:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5503:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5504:			written += t2p_write_pdf_xobject_icccs_dict(t2p, output);
    #####: 5505:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5506:			written += t2p_write_pdf_stream_start(output);
        -: 5507:			/* streamlen=written; */ /* value not used */
    #####: 5508:			written += t2p_write_pdf_xobject_icccs_stream(t2p, output);
        -: 5509:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5510:			written += t2p_write_pdf_stream_end(output);
    #####: 5511:			written += t2p_write_pdf_obj_end(output);
        -: 5512:		}
    #####: 5513:		if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){
    #####: 5514:			for(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){
    #####: 5515:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5516:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5517:				written += t2p_write_pdf_stream_dict_start(output);
    #####: 5518:				written += t2p_write_pdf_xobject_stream_dict(
        -: 5519:					i2+1, 
        -: 5520:					t2p, 
        -: 5521:					output);
    #####: 5522:				written += t2p_write_pdf_stream_dict_end(output);
    #####: 5523:				written += t2p_write_pdf_stream_start(output);
    #####: 5524:				streamlen=written;
    #####: 5525:				t2p_read_tiff_size_tile(t2p, input, i2);
    #####: 5526:				written += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);
    #####: 5527:				t2p_write_advance_directory(t2p, output);
    #####: 5528:				if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5529:				streamlen=written-streamlen;
    #####: 5530:				written += t2p_write_pdf_stream_end(output);
    #####: 5531:				written += t2p_write_pdf_obj_end(output);
    #####: 5532:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5533:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5534:				written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5535:				written += t2p_write_pdf_obj_end(output);
        -: 5536:			}
        -: 5537:		} else {
    #####: 5538:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5539:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5540:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5541:			written += t2p_write_pdf_xobject_stream_dict(
        -: 5542:				0, 
        -: 5543:				t2p, 
        -: 5544:				output);
    #####: 5545:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5546:			written += t2p_write_pdf_stream_start(output);
    #####: 5547:			streamlen=written;
    #####: 5548:			t2p_read_tiff_size(t2p, input);
    #####: 5549:			written += t2p_readwrite_pdf_image(t2p, input, output);
    #####: 5550:			t2p_write_advance_directory(t2p, output);
    #####: 5551:			if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5552:			streamlen=written-streamlen;
    #####: 5553:			written += t2p_write_pdf_stream_end(output);
    #####: 5554:			written += t2p_write_pdf_obj_end(output);
    #####: 5555:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5556:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5557:			written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5558:			written += t2p_write_pdf_obj_end(output);
        -: 5559:		}
        -: 5560:	}
    #####: 5561:	t2p->pdf_startxref = written;
    #####: 5562:	written += t2p_write_pdf_xreftable(t2p, output);
    #####: 5563:	written += t2p_write_pdf_trailer(t2p, output);
    #####: 5564:	t2p_disable(output);
        -: 5565:
    #####: 5566:	return(written);
        -: 5567:}
        -: 5568:
        -: 5569:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 5570:/*
        -: 5571: * Local Variables:
        -: 5572: * mode: c
        -: 5573: * c-basic-offset: 8
        -: 5574: * fill-column: 78
        -: 5575: * End:
        -: 5576: */
