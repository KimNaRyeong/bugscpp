        -:    0:Source:tiff2ps.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tif_config.h"
        -:   28:
        -:   29:#include <stdio.h>
        -:   30:#include <stdlib.h>			/* for atof */
        -:   31:#include <math.h>
        -:   32:#include <time.h>
        -:   33:#include <string.h>
        -:   34:
        -:   35:#ifdef HAVE_UNISTD_H
        -:   36:# include <unistd.h>
        -:   37:#endif
        -:   38:
        -:   39:#ifdef NEED_LIBPORT
        -:   40:# include "libport.h"
        -:   41:#endif
        -:   42:
        -:   43:#include "tiffio.h"
        -:   44:
        -:   45:/*
        -:   46: * Revision history
        -:   47: * 2013-Jan-21
        -:   48: *    Richard Nolde: Fix bug in auto rotate option code. Once a
        -:   49: *    rotation angle was set by the auto rotate check, it was
        -:   50: *    retained for all pages that followed instead of being
        -:   51: *    retested for each page.
        -:   52: *
        -:   53: * 2010-Sep-17
        -:   54: *    Richard Nolde: Reinstate code from Feb 2009 that never got
        -:   55: *    accepted into CVS with major modifications to handle -H and -W
        -:   56: *    options. Replaced original PlaceImage function with several
        -:   57: *    new functions that make support for multiple output pages
        -:   58: *    from a single image easier to understand. Added additional
        -:   59: *    warning messages for incompatible command line options.
        -:   60: *    Add new command line options to specify PageOrientation
        -:   61: *    Document Structuring Comment for landscape or portrait
        -:   62: *    and code to determine the values from ouput width and height
        -:   63: *    if not specified on the command line.
        -:   64: *    Add new command line option to specify document creator
        -:   65: *    as an alterntive to the string "tiff2ps" following model
        -:   66: *    of patch submitted by Thomas Jarosch for specifiying a
        -:   67: *    document title which is also supported now.
        -:   68: *
        -:   69: * 2009-Feb-11
        -:   70: *    Richard Nolde: Added support for rotations of 90, 180, 270
        -:   71: *    and auto using -r <90|180|270|auto>.  Auto picks the best
        -:   72: *    fit for the image on the specified paper size (eg portrait
        -:   73: *    or landscape) if -h or -w is specified. Rotation is in
        -:   74: *    degrees counterclockwise since that is how Postscript does
        -:   75: *    it. The auto opption rotates the image 90 degrees ccw to
        -:   76: *    produce landscape if that is a better fit than portait.
        -:   77: *
        -:   78: *    Cleaned up code in TIFF2PS and broke into smaller functions
        -:   79: *    to simplify rotations.
        -:   80: *
        -:   81: *    Identified incompatible options and returned errors, eg
        -:   82: *    -i for imagemask operator is only available for Level2 or
        -:   83: *    Level3 Postscript in the current implmentation since there
        -:   84: *    is a difference in the way the operands are called for Level1
        -:   85: *    and there is no function to provide the Level1 version.
        -:   86: *    -H was not handled properly if -h and/or -w were specified.
        -:   87: *    It should only clip the masked images if the scaled image
        -:   88: *    exceeds the maxPageHeight specified with -H.
        -:   89: *  
        -:   90: *    New design allows for all of the following combinations:
        -:   91: *    Conversion of TIFF to Postscript with optional rotations
        -:   92: *    of 90, 180, 270, or auto degrees counterclockwise
        -:   93: *    Conversion of TIFF to Postscript with entire image scaled
        -:   94: *    to maximum of values spedified with -h or -w while
        -:   95: *    maintaining aspect ratio. Same rotations apply.
        -:   96: *    Conversion of TIFF to Postscript with clipping of output
        -:   97: *    viewport to height specified with -H, producing multiple
        -:   98: *    pages at this height and original width as needed.
        -:   99: *    Same rotations apply.
        -:  100: *    Conversion of TIFF to Postscript with image scaled to 
        -:  101: *    maximum specified by -h and -w and the resulting scaled
        -:  102: *    image is presented in an output viewport clipped by -H height.
        -:  103: *    The same rotations apply.
        -:  104: *
        -:  105: *    Added maxPageWidth option using -W flag. MaxPageHeight and
        -:  106: *    MaxPageWidth are mutually exclusive since the aspect ratio
        -:  107: *    cannot be maintained if you set both.
        -:  108: *    Rewrote PlaceImage to allow maxPageHeight and maxPageWidth
        -:  109: *    options to work with values smaller or larger than the
        -:  110: *    physical paper size and still preserve the aspect ratio.
        -:  111: *    This is accomplished by creating multiple pages across
        -:  112: *    as well as down if need be.
        -:  113: *
        -:  114: * 2001-Mar-21
        -:  115: *    I (Bruce A. Mallett) added this revision history comment ;)
        -:  116: *
        -:  117: *    Fixed PS_Lvl2page() code which outputs non-ASCII85 raw
        -:  118: *    data.  Moved test for when to output a line break to
        -:  119: *    *after* the output of a character.  This just serves
        -:  120: *    to fix an eye-nuisance where the first line of raw
        -:  121: *    data was one character shorter than subsequent lines.
        -:  122: *
        -:  123: *    Added an experimental ASCII85 encoder which can be used
        -:  124: *    only when there is a single buffer of bytes to be encoded.
        -:  125: *    This version is much faster at encoding a straight-line
        -:  126: *    buffer of data because it can avoid a lot of the loop
        -:  127: *    overhead of the byte-by-byte version.  To use this version
        -:  128: *    you need to define EXP_ASCII85ENCODER (experimental ...).
        -:  129: *
        -:  130: *    Added bug fix given by Michael Schmidt to PS_Lvl2page()
        -:  131: *    in which an end-of-data marker ('>') was not being output
        -:  132: *    when producing non-ASCII85 encoded PostScript Level 2
        -:  133: *    data.
        -:  134: *
        -:  135: *    Fixed PS_Lvl2colorspace() so that it no longer assumes that
        -:  136: *    a TIFF having more than 2 planes is a CMYK.  This routine
        -:  137: *    no longer looks at the samples per pixel but instead looks
        -:  138: *    at the "photometric" value.  This change allows support of
        -:  139: *    CMYK TIFFs.
        -:  140: *
        -:  141: *    Modified the PostScript L2 imaging loop so as to test if
        -:  142: *    the input stream is still open before attempting to do a
        -:  143: *    flushfile on it.  This was done because some RIPs close
        -:  144: *    the stream after doing the image operation.
        -:  145: *
        -:  146: *    Got rid of the realloc() being done inside a loop in the
        -:  147: *    PSRawDataBW() routine.  The code now walks through the
        -:  148: *    byte-size array outside the loop to determine the largest
        -:  149: *    size memory block that will be needed.
        -:  150: *
        -:  151: *    Added "-m" switch to ask tiff2ps to, where possible, use the
        -:  152: *    "imagemask" operator instead of the "image" operator.
        -:  153: *
        -:  154: *    Added the "-i #" switch to allow interpolation to be disabled.
        -:  155: *
        -:  156: *    Unrolled a loop or two to improve performance.
        -:  157: */
        -:  158:
        -:  159:/*
        -:  160: * Define EXP_ASCII85ENCODER if you want to use an experimental
        -:  161: * version of the ASCII85 encoding routine.  The advantage of
        -:  162: * using this routine is that tiff2ps will convert to ASCII85
        -:  163: * encoding at between 3 and 4 times the speed as compared to
        -:  164: * using the old (non-experimental) encoder.  The disadvantage
        -:  165: * is that you will be using a new (and unproven) encoding
        -:  166: * routine.  So user beware, you have been warned!
        -:  167: */
        -:  168:
        -:  169:#define	EXP_ASCII85ENCODER
        -:  170:
        -:  171:/*
        -:  172: * NB: this code assumes uint32 works with printf's %l[ud].
        -:  173: */
        -:  174:#ifndef TRUE
        -:  175:#define	TRUE	1
        -:  176:#define	FALSE	0
        -:  177:#endif
        -:  178:
        -:  179:int	ascii85 = FALSE;		/* use ASCII85 encoding */
        -:  180:int	interpolate = TRUE;		/* interpolate level2 image */
        -:  181:int	level2 = FALSE;			/* generate PostScript level 2 */
        -:  182:int	level3 = FALSE;			/* generate PostScript level 3 */
        -:  183:int	printAll = FALSE;		/* print all images in file */
        -:  184:int	generateEPSF = TRUE;		/* generate Encapsulated PostScript */
        -:  185:int	PSduplex = FALSE;		/* enable duplex printing */
        -:  186:int	PStumble = FALSE;		/* enable top edge binding */
        -:  187:int	PSavoiddeadzone = TRUE;		/* enable avoiding printer deadzone */
        -:  188:double	maxPageHeight = 0;		/* maximum height to select from image and print per page */
        -:  189:double	maxPageWidth  = 0;		/* maximum width  to select from image and print per page */
        -:  190:double	splitOverlap = 0;		/* amount for split pages to overlag */
        -:  191:int	rotation = 0;                   /* optional value for rotation angle */
        -:  192:int     auto_rotate = 0;                /* rotate image for best fit on the page */
        -:  193:char	*filename = NULL;		/* input filename */
        -:  194:char    *title = NULL;                  /* optional document title string */
        -:  195:char    *creator = NULL;                /* optional document creator string */
        -:  196:char    pageOrientation[12];            /* set optional PageOrientation DSC to Landscape or Portrait */
        -:  197:int	useImagemask = FALSE;		/* Use imagemask instead of image operator */
        -:  198:uint16	res_unit = 0;			/* Resolution units: 2 - inches, 3 - cm */
        -:  199:
        -:  200:/*
        -:  201: * ASCII85 Encoding Support.
        -:  202: */
        -:  203:unsigned char ascii85buf[10];
        -:  204:int	ascii85count;
        -:  205:int	ascii85breaklen;
        -:  206:
        -:  207:int	TIFF2PS(FILE*, TIFF*, double, double, double, double, int);
        -:  208:void	PSpage(FILE*, TIFF*, uint32, uint32);
        -:  209:void	PSColorContigPreamble(FILE*, uint32, uint32, int);
        -:  210:void	PSColorSeparatePreamble(FILE*, uint32, uint32, int);
        -:  211:void	PSDataColorContig(FILE*, TIFF*, uint32, uint32, int);
        -:  212:void	PSDataColorSeparate(FILE*, TIFF*, uint32, uint32, int);
        -:  213:void	PSDataPalette(FILE*, TIFF*, uint32, uint32);
        -:  214:void	PSDataBW(FILE*, TIFF*, uint32, uint32);
        -:  215:void	PSRawDataBW(FILE*, TIFF*, uint32, uint32);
        -:  216:void	Ascii85Init(void);
        -:  217:void	Ascii85Put(unsigned char code, FILE* fd);
        -:  218:void	Ascii85Flush(FILE* fd);
        -:  219:void    PSHead(FILE*, double, double, double, double);
        -:  220:void	PSTail(FILE*, int);
        -:  221:int     psStart(FILE *, int, int, int *, double *, double, double, double,
        -:  222:                double, double, double, double, double, double, double);
        -:  223:int     psPageSize(FILE *, int, double, double, double, double, double, double);
        -:  224:int     psRotateImage(FILE *, int, double, double, double, double);
        -:  225:int     psMaskImage(FILE *, TIFF *, int, int, int *, double, double,
        -:  226:		    double, double, double, double, double, double, double);
        -:  227:int     psScaleImage(FILE *, double, int, int, double, double, double, double,
        -:  228:                     double, double);
        -:  229:int     get_viewport (double, double, double, double, double *, double *, int);
        -:  230:int     exportMaskedImage(FILE *, double, double, double, double, int, int,
        -:  231:			  double, double, double, int, int);
        -:  232:
        -:  233:#if	defined( EXP_ASCII85ENCODER)
        -:  234:tsize_t Ascii85EncodeBlock( uint8 * ascii85_p, unsigned f_eod, const uint8 * raw_p, tsize_t raw_l );
        -:  235:#endif
        -:  236:
        -:  237:static	void usage(int);
        -:  238:
        -:  239:#ifdef DPP_ENABLE_GCOV
        -:  240:#include <signal.h>
        -:  241:static struct sigaction dpp_gcov_sigaction;
        -:  242:static struct sigaction dpp_orig_sigaction;
    #####:  243:void dpp_sighandler(int signum) {
    #####:  244:	__gcov_flush();
    #####:  245:	sigaction(sigaction, &dpp_orig_sigaction, NULL);
    #####:  246:	raise(signum);
    #####:  247:	exit(1);
        -:  248:}
        -:  249:#endif
        1:  250:void __asan_on_error(void) {
        -:  251:#ifdef DPP_ENABLE_GCOV
        1:  252:    __gcov_flush();
        -:  253:#endif
    #####:  254:}
        -:  255:int
        1:  256:main(int argc, char* argv[])
        -:  257:{
        -:  258:#ifdef DPP_ENABLE_GCOV
        -:  259:	  {
        1:  260:		  dpp_gcov_sigaction.sa_handler = dpp_sighandler;
        1:  261:		  sigemptyset(&dpp_gcov_sigaction.sa_mask);
        1:  262:		  dpp_gcov_sigaction.sa_flags = 0;
        1:  263:		  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        1:  264:		  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        1:  265:		  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        -:  266:	  }
        -:  267:#endif
        1:  268:	int dirnum = -1, c, np = 0;
        1:  269:	int centered = 0;
        1:  270:	double bottommargin = 0;
        1:  271:	double leftmargin = 0;
        1:  272:	double pageWidth = 0;
        1:  273:	double pageHeight = 0;
        1:  274:	uint32 diroff = 0;
        -:  275:#if !HAVE_DECL_OPTARG
        -:  276:	extern char *optarg;
        -:  277:	extern int optind;
        -:  278:#endif
        1:  279:	FILE* output = stdout;
        -:  280:
        1:  281:        pageOrientation[0] = '\0';
        -:  282:
       2*:  283:	while ((c = getopt(argc, argv, "b:d:h:H:W:L:i:w:l:o:O:P:C:r:t:acemxyzps1238DT")) != -1)
    #####:  284:		switch (c) {
    #####:  285:		case 'b':
    #####:  286:			bottommargin = atof(optarg);
    #####:  287:			break;
    #####:  288:		case 'c':
    #####:  289:			centered = 1;
    #####:  290:			break;
    #####:  291:		case 'C':
    #####:  292:			creator = optarg;
    #####:  293:			break;
    #####:  294:		case 'd': /* without -a, this only processes one image at this IFD */
    #####:  295:			dirnum = atoi(optarg);
    #####:  296:			break;
    #####:  297:		case 'D':
    #####:  298:			PSduplex = TRUE;
    #####:  299:			break;
    #####:  300:		case 'i':
    #####:  301:			interpolate = atoi(optarg) ? TRUE:FALSE;
    #####:  302:			break;
    #####:  303:		case 'T':
    #####:  304:			PStumble = TRUE;
    #####:  305:			break;
    #####:  306:		case 'e':
    #####:  307:                        PSavoiddeadzone = FALSE;
    #####:  308:			generateEPSF = TRUE;
    #####:  309:			break;
    #####:  310:		case 'h':
    #####:  311:			pageHeight = atof(optarg);
    #####:  312:			break;
    #####:  313:		case 'H':
    #####:  314:			maxPageHeight = atof(optarg);
    #####:  315:			break;
    #####:  316:		case 'W':
    #####:  317:			maxPageWidth = atof(optarg);
    #####:  318:			break;
    #####:  319:		case 'L':
    #####:  320:			splitOverlap = atof(optarg);
    #####:  321:			break;
    #####:  322:		case 'm':
    #####:  323:			useImagemask = TRUE;
    #####:  324:			break;
    #####:  325:		case 'o':
    #####:  326:		        switch (optarg[0])
        -:  327:                          {
    #####:  328:                          case '0':
        -:  329:                          case '1':
        -:  330:                          case '2':
        -:  331:                          case '3':
        -:  332:                          case '4':
        -:  333:                          case '5':
        -:  334:                          case '6':
        -:  335:                          case '7':
        -:  336:                          case '8':
    #####:  337:                          case '9': diroff = (uint32) strtoul(optarg, NULL, 0);
    #####:  338:			          break;
    #####:  339:                          default: TIFFError ("-o", "Offset must be a numeric value.");
    #####:  340:			    exit (1);
        -:  341:			  }
    #####:  342:			break;
    #####:  343:		case 'O':		/* XXX too bad -o is already taken */
    #####:  344:			output = fopen(optarg, "w");
    #####:  345:			if (output == NULL) {
    #####:  346:				fprintf(stderr,
        -:  347:				    "%s: %s: Cannot open output file.\n",
        -:  348:				    argv[0], optarg);
    #####:  349:				exit(-2);
        -:  350:			}
    #####:  351:			break;
    #####:  352:		case 'P':
    #####:  353:                        switch (optarg[0])
        -:  354:                          {
    #####:  355:                          case 'l':
    #####:  356:                          case 'L': strcpy (pageOrientation, "Landscape");
    #####:  357:			            break; 
    #####:  358:                          case 'p':
    #####:  359:                          case 'P': strcpy (pageOrientation, "Portrait");
    #####:  360:			            break; 
    #####:  361:                          default: TIFFError ("-P", "Page orientation must be Landscape or Portrait");
    #####:  362:			           exit (-1);
        -:  363:			  }
    #####:  364:			break;
    #####:  365:		case 'l':
    #####:  366:			leftmargin = atof(optarg);
    #####:  367:			break;
    #####:  368:		case 'a': /* removed fall through to generate warning below, R Nolde 09-01-2010 */
    #####:  369:			printAll = TRUE;
    #####:  370:			break;
    #####:  371:		case 'p':
    #####:  372:			generateEPSF = FALSE;
    #####:  373:			break;
    #####:  374:		case 'r':
    #####:  375:                        if (strcmp (optarg, "auto") == 0)
        -:  376:			  {
    #####:  377:                          rotation = 0;
    #####:  378:                          auto_rotate = TRUE;
        -:  379:                          }
        -:  380:                        else
        -:  381:			  {
    #####:  382: 			  rotation = atoi(optarg);
    #####:  383:                          auto_rotate = FALSE;
        -:  384:			  }
    #####:  385:                        switch (rotation)
        -:  386:                          {
    #####:  387:			  case   0:
        -:  388:                          case  90:
        -:  389:                          case 180:
        -:  390:                          case 270:
    #####:  391:			    break;
    #####:  392:			  default:
    #####:  393:                            fprintf (stderr, "Rotation angle must be 90, 180, 270 (degrees ccw) or auto\n");
    #####:  394:			    exit (-1);
        -:  395:			  }
    #####:  396:			break;
    #####:  397:		case 's':
    #####:  398:			printAll = FALSE;
    #####:  399:			break;
    #####:  400:                case 't':
    #####:  401:                        title = optarg;
    #####:  402:                        break;
    #####:  403:		case 'w':
    #####:  404:			pageWidth = atof(optarg);
    #####:  405:			break;
    #####:  406:		case 'z':
    #####:  407:			PSavoiddeadzone = FALSE;
    #####:  408:			break;
    #####:  409:		case '1':
    #####:  410:			level2 = FALSE;
    #####:  411:			level3 = FALSE;
    #####:  412:			ascii85 = FALSE;
    #####:  413:			break;
    #####:  414:		case '2':
    #####:  415:			level2 = TRUE;
    #####:  416:			ascii85 = TRUE;			/* default to yes */
    #####:  417:			break;
    #####:  418:		case '3':
    #####:  419:			level3 = TRUE;
    #####:  420:			ascii85 = TRUE;			/* default to yes */
    #####:  421:			break;
    #####:  422:		case '8':
    #####:  423:			ascii85 = FALSE;
    #####:  424:			break;
    #####:  425:		case 'x':
    #####:  426:			res_unit = RESUNIT_CENTIMETER;
    #####:  427:			break;
    #####:  428:		case 'y':
    #####:  429:			res_unit = RESUNIT_INCH;
    #####:  430:			break;
    #####:  431:		case '?':
    #####:  432:			usage(-1);
        -:  433:		}
        -:  434:
        2:  435:        if (useImagemask == TRUE)
        -:  436:          {
    #####:  437:	  if ((level2 == FALSE) && (level3 == FALSE))
        -:  438:            {
    #####:  439:	    TIFFError ("-m "," imagemask operator requres Postscript Level2 or Level3");
    #####:  440:	    exit (1);
        -:  441:            }
        -:  442:          }
        -:  443:
       1*:  444:        if (pageWidth && (maxPageWidth > pageWidth))
        -:  445:	  {
    #####:  446:	  TIFFError ("-W", "Max viewport width cannot exceed page width");
    #####:  447:	  exit (1);
        -:  448:          }
        -:  449:
        -:  450:        /* auto rotate requires a specified page width and height */
        1:  451:        if (auto_rotate == TRUE)
        -:  452:          {
        -:  453:	    /*
        -:  454:	  if ((pageWidth == 0) || (pageHeight == 0))
        -:  455:	    TIFFWarning ("-r auto", " requires page height and width specified with -h and -w");
        -:  456:	    */
    #####:  457:          if ((maxPageWidth > 0) || (maxPageHeight > 0))
        -:  458:            {
    #####:  459:	    TIFFError ("-r auto", " is incompatible with maximum page width/height specified by -H or -W");
    #####:  460:            exit (1);
        -:  461:            }
        -:  462:          }
       1*:  463:        if ((maxPageWidth > 0) && (maxPageHeight > 0))
        -:  464:            {
    #####:  465:	    TIFFError ("-H and -W", " Use only one of -H or -W to define a viewport");
    #####:  466:            exit (1);
        -:  467:            }
        -:  468:
        1:  469:        if ((generateEPSF == TRUE) && (printAll == TRUE))
        -:  470:          {
    #####:  471:	  TIFFError(" -e and -a", "Warning: Cannot generate Encapsulated Postscript for multiple images");
    #####:  472:	  generateEPSF = FALSE;
        -:  473:          }
        -:  474:
        1:  475:        if ((generateEPSF == TRUE) && (PSduplex == TRUE))
        -:  476:          {
    #####:  477:	  TIFFError(" -e and -D", "Warning: Encapsulated Postscript does not support Duplex option");
    #####:  478:	  PSduplex = FALSE;
        -:  479:          }
        -:  480:
        1:  481:        if ((generateEPSF == TRUE) && (PStumble == TRUE))
        -:  482:          {
    #####:  483:	  TIFFError(" -e and -T", "Warning: Encapsulated Postscript does not support Top Edge Binding option");
    #####:  484:	  PStumble = FALSE;
        -:  485:          }
        -:  486:
        1:  487:        if ((generateEPSF == TRUE) && (PSavoiddeadzone == TRUE))
        1:  488:	  PSavoiddeadzone = FALSE;
        -:  489:
       1*:  490:	for (; argc - optind > 0; optind++) {
        1:  491:		TIFF* tif = TIFFOpen(filename = argv[optind], "r");
        1:  492:		if (tif != NULL) {
        1:  493:			if (dirnum != -1
    #####:  494:                            && !TIFFSetDirectory(tif, (tdir_t)dirnum))
    #####:  495:				return (-1);
       1*:  496:			else if (diroff != 0 &&
    #####:  497:			    !TIFFSetSubDirectory(tif, diroff))
    #####:  498:				return (-1);
        1:  499:			np = TIFF2PS(output, tif, pageWidth, pageHeight,
        -:  500:				     leftmargin, bottommargin, centered);
    #####:  501:                        if (np < 0)
        -:  502:                          {
    #####:  503:			  TIFFError("Error", "Unable to process %s", filename);
        -:  504:                          }
    #####:  505:			TIFFClose(tif);
        -:  506:		}
        -:  507:	}
    #####:  508:	if (np)
    #####:  509:		PSTail(output, np);
        -:  510:	else
    #####:  511:		usage(-1);
    #####:  512:	if (output != stdout)
    #####:  513:		fclose(output);
    #####:  514:	return (0);
        -:  515:}
        -:  516:
        -:  517:static	uint16 samplesperpixel;
        -:  518:static	uint16 bitspersample;
        -:  519:static	uint16 planarconfiguration;
        -:  520:static	uint16 photometric;
        -:  521:static	uint16 compression;
        -:  522:static	uint16 extrasamples;
        -:  523:static	int alpha;
        -:  524:
        -:  525:static int
        1:  526:checkImage(TIFF* tif)
        -:  527:{
        1:  528:	switch (photometric) {
    #####:  529:	case PHOTOMETRIC_YCBCR:
    #####:  530:		if ((compression == COMPRESSION_JPEG || compression == COMPRESSION_OJPEG)
    #####:  531:			&& planarconfiguration == PLANARCONFIG_CONTIG) {
        -:  532:			/* can rely on libjpeg to convert to RGB */
    #####:  533:			TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE,
        -:  534:				     JPEGCOLORMODE_RGB);
    #####:  535:			photometric = PHOTOMETRIC_RGB;
        -:  536:		} else {
    #####:  537:			if (level2 || level3)
        -:  538:				break;
    #####:  539:			TIFFError(filename, "Can not handle image with %s",
        -:  540:			    "PhotometricInterpretation=YCbCr");
    #####:  541:			return (0);
        -:  542:		}
        -:  543:		/* fall thru... */
        -:  544:	case PHOTOMETRIC_RGB:
        1:  545:		if (alpha && bitspersample != 8) {
    #####:  546:			TIFFError(filename,
        -:  547:			    "Can not handle %d-bit/sample RGB image with alpha",
        -:  548:			    bitspersample);
    #####:  549:			return (0);
        -:  550:		}
        -:  551:		/* fall thru... */
        -:  552:	case PHOTOMETRIC_SEPARATED:
        -:  553:	case PHOTOMETRIC_PALETTE:
        -:  554:	case PHOTOMETRIC_MINISBLACK:
        -:  555:	case PHOTOMETRIC_MINISWHITE:
        1:  556:		break;
    #####:  557:	case PHOTOMETRIC_LOGL:
        -:  558:	case PHOTOMETRIC_LOGLUV:
    #####:  559:		if (compression != COMPRESSION_SGILOG &&
    #####:  560:		    compression != COMPRESSION_SGILOG24) {
    #####:  561:			TIFFError(filename,
        -:  562:		    "Can not handle %s data with compression other than SGILog",
    #####:  563:			    (photometric == PHOTOMETRIC_LOGL) ?
        -:  564:				"LogL" : "LogLuv"
        -:  565:			);
    #####:  566:			return (0);
        -:  567:		}
        -:  568:		/* rely on library to convert to RGB/greyscale */
    #####:  569:		TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);
    #####:  570:		photometric = (photometric == PHOTOMETRIC_LOGL) ?
        -:  571:		    PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;
    #####:  572:		bitspersample = 8;
    #####:  573:		break;
    #####:  574:	case PHOTOMETRIC_CIELAB:
        -:  575:		/* fall thru... */
        -:  576:	default:
    #####:  577:		TIFFError(filename,
        -:  578:		    "Can not handle image with PhotometricInterpretation=%d",
        -:  579:		    photometric);
    #####:  580:		return (0);
        -:  581:	}
       1*:  582:	switch (bitspersample) {
        1:  583:	case 1: case 2:
        -:  584:	case 4: case 8:
        -:  585:	case 16:
        1:  586:		break;
    #####:  587:	default:
    #####:  588:		TIFFError(filename, "Can not handle %d-bit/sample image",
        -:  589:		    bitspersample);
    #####:  590:		return (0);
        -:  591:	}
       1*:  592:	if (planarconfiguration == PLANARCONFIG_SEPARATE && extrasamples > 0)
    #####:  593:		TIFFWarning(filename, "Ignoring extra samples");
        1:  594:	return (1);
        -:  595:}
        -:  596:
        -:  597:#define PS_UNIT_SIZE	72.0F
        -:  598:#define	PSUNITS(npix,res)	((npix) * (PS_UNIT_SIZE / (res)))
        -:  599:
        -:  600:static	char RGBcolorimage[] = "\
        -:  601:/bwproc {\n\
        -:  602:    rgbproc\n\
        -:  603:    dup length 3 idiv string 0 3 0\n\
        -:  604:    5 -1 roll {\n\
        -:  605:	add 2 1 roll 1 sub dup 0 eq {\n\
        -:  606:	    pop 3 idiv\n\
        -:  607:	    3 -1 roll\n\
        -:  608:	    dup 4 -1 roll\n\
        -:  609:	    dup 3 1 roll\n\
        -:  610:	    5 -1 roll put\n\
        -:  611:	    1 add 3 0\n\
        -:  612:	} { 2 1 roll } ifelse\n\
        -:  613:    } forall\n\
        -:  614:    pop pop pop\n\
        -:  615:} def\n\
        -:  616:/colorimage where {pop} {\n\
        -:  617:    /colorimage {pop pop /rgbproc exch def {bwproc} image} bind def\n\
        -:  618:} ifelse\n\
        -:  619:";
        -:  620:
        -:  621:/*
        -:  622: * Adobe Photoshop requires a comment line of the form:
        -:  623: *
        -:  624: * %ImageData: <cols> <rows> <depth>  <main channels> <pad channels>
        -:  625: *	<block size> <1 for binary|2 for hex> "data start"
        -:  626: *
        -:  627: * It is claimed to be part of some future revision of the EPS spec.
        -:  628: */
        -:  629:static void
        1:  630:PhotoshopBanner(FILE* fd, uint32 w, uint32 h, int bs, int nc, char* startline)
        -:  631:{
       1*:  632:	fprintf(fd, "%%ImageData: %ld %ld %d %d 0 %d 2 \"",
        -:  633:	    (long) w, (long) h, bitspersample, nc, bs);
       1*:  634:	fprintf(fd, startline, nc);
       1*:  635:	fprintf(fd, "\"\n");
        1:  636:}
        -:  637:
        -:  638:/*   Convert pixel width and height pw, ph, to points pprw, pprh 
        -:  639: *   using image resolution and resolution units from TIFF tags.
        -:  640: *   pw : image width in pixels
        -:  641: *   ph : image height in pixels
        -:  642: * pprw : image width in PS units (72 dpi)
        -:  643: * pprh : image height in PS units (72 dpi)
        -:  644: */
        -:  645:static void
        1:  646:setupPageState(TIFF* tif, uint32* pw, uint32* ph, double* pprw, double* pprh)
        -:  647:{
        1:  648:	float xres = 0.0F, yres = 0.0F;
        -:  649:
        1:  650:	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, pw);
        1:  651:	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, ph);
        1:  652:	if (res_unit == 0)	/* Not specified as command line option */
        1:  653:		if (!TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &res_unit))
    #####:  654:			res_unit = RESUNIT_INCH;
        -:  655:	/*
        -:  656:	 * Calculate printable area.
        -:  657:	 */
        1:  658:	if (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres)
        1:  659:            || fabs(xres) < 0.0000001)
    #####:  660:		xres = PS_UNIT_SIZE;
        1:  661:	if (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres)
        1:  662:            || fabs(yres) < 0.0000001)
        1:  663:		yres = PS_UNIT_SIZE;
        1:  664:	switch (res_unit) {
        1:  665:	case RESUNIT_CENTIMETER:
        1:  666:		xres *= 2.54F, yres *= 2.54F;
        1:  667:		break;
    #####:  668:	case RESUNIT_INCH:
    #####:  669:		break;
    #####:  670:	case RESUNIT_NONE:	/* Subsequent code assumes we have converted to inches! */
    #####:  671:		res_unit = RESUNIT_INCH;
    #####:  672:		break;
    #####:  673:	default:	/* Last ditch guess for unspecified RESUNIT case
        -:  674:			 * check that the resolution is not inches before scaling it.
        -:  675:			 * Moved to end of function with additional check, RJN, 08-31-2010
        -:  676:			 * if (xres != PS_UNIT_SIZE || yres != PS_UNIT_SIZE)
        -:  677:			 * xres *= PS_UNIT_SIZE, yres *= PS_UNIT_SIZE;
        -:  678:			 */
    #####:  679:		break;
        -:  680:	}
        -:  681:	/* This is a hack to deal with images that have no meaningful Resolution Size
        -:  682:	 * but may have x and/or y resolutions of 1 pixel per undefined unit.
        -:  683:	 */
        1:  684:	if ((xres > 1.0) && (xres != PS_UNIT_SIZE))
        1:  685:		*pprw = PSUNITS(*pw, xres);
        -:  686:	else
    #####:  687:		*pprw = PSUNITS(*pw, PS_UNIT_SIZE);
        1:  688:	if ((yres > 1.0) && (yres != PS_UNIT_SIZE))
        1:  689:		*pprh = PSUNITS(*ph, yres);
        -:  690:	else
    #####:  691:		*pprh = PSUNITS(*ph, PS_UNIT_SIZE);
        1:  692:}
        -:  693:
        -:  694:static int
    #####:  695:isCCITTCompression(TIFF* tif)
        -:  696:{
    #####:  697:    uint16 compress;
    #####:  698:    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);
    #####:  699:    return (compress == COMPRESSION_CCITTFAX3 ||
    #####:  700:	    compress == COMPRESSION_CCITTFAX4 ||
    #####:  701:	    compress == COMPRESSION_CCITTRLE ||
    #####:  702:	    compress == COMPRESSION_CCITTRLEW);
        -:  703:}
        -:  704:
        -:  705:static	tsize_t tf_bytesperrow;
        -:  706:static	tsize_t ps_bytesperrow;
        -:  707:static	tsize_t	tf_rowsperstrip;
        -:  708:static	tsize_t	tf_numberstrips;
        -:  709:static	char *hex = "0123456789abcdef";
        -:  710:
        -:  711:/*
        -:  712: * Pagewidth and pageheight are the output size in points,
        -:  713: * may refer to values specified with -h and -w, or to
        -:  714: * values read from the image if neither -h nor -w are used.
        -:  715: * Imagewidth and imageheight are image size in points.
        -:  716: * Ximages and Yimages are number of pages across and down.
        -:  717: * Only one of maxPageHeight or maxPageWidth can be used.
        -:  718: * These are global variables unfortunately.
        -:  719: */
    #####:  720:int get_subimage_count(double pagewidth,  double pageheight,
        -:  721:		       double imagewidth, double imageheight,
        -:  722:		       int *ximages, int *yimages,
        -:  723:		       int rotation, double scale)
        -:  724:{
    #####:  725:	int pages = 1;
    #####:  726:	double splitheight = 0;  /* Requested Max Height in points */
    #####:  727:	double splitwidth  = 0;  /* Requested Max Width in points */
    #####:  728:	double overlap     = 0;  /* Repeated edge width in points */
        -:  729:
    #####:  730:	splitheight = maxPageHeight * PS_UNIT_SIZE;
    #####:  731:	splitwidth  = maxPageWidth  * PS_UNIT_SIZE;
    #####:  732:	overlap     = splitOverlap  * PS_UNIT_SIZE;
    #####:  733:	pagewidth  *= PS_UNIT_SIZE;
    #####:  734:	pageheight *= PS_UNIT_SIZE;
        -:  735:
    #####:  736:	if ((imagewidth < 1.0) || (imageheight < 1.0))
        -:  737:	{
    #####:  738:		TIFFError("get_subimage_count", "Invalid image width or height");
    #####:  739:		return (0);
        -:  740:	}
        -:  741:
    #####:  742:  switch (rotation)
        -:  743:    {
    #####:  744:    case 0:
    #####:  745:    case 180: if (splitheight > 0) /* -H maxPageHeight */
        -:  746:                {
    #####:  747:               if (imageheight > splitheight) /* More than one vertical image segment */
        -:  748:                 {
    #####:  749:                 if (pagewidth)
    #####:  750:                   *ximages = (int)ceil((scale * imagewidth)  / (pagewidth - overlap));
        -:  751:                  else
    #####:  752:                   *ximages = 1;
    #####:  753:                 *yimages = (int)ceil((scale * imageheight) / (splitheight - overlap)); /* Max vert pages needed */
        -:  754:                 }
        -:  755:                else
        -:  756:                 {
    #####:  757:                 if (pagewidth)
    #####:  758:                   *ximages = (int)ceil((scale * imagewidth) / (pagewidth - overlap));    /* Max horz pages needed */
        -:  759:                  else
    #####:  760:                   *ximages = 1;
    #####:  761:                 *yimages = 1;                                                     /* Max vert pages needed */
        -:  762:                 }
        -:  763:               }
        -:  764:              else
        -:  765:               {
    #####:  766:                if (splitwidth > 0) /* -W maxPageWidth */
        -:  767:                 {
    #####:  768:                 if (imagewidth >splitwidth)
        -:  769:                   {
    #####:  770:                   *ximages = (int)ceil((scale * imagewidth)  / (splitwidth - overlap));   /* Max horz pages needed */
    #####:  771:                    if (pageheight)
    #####:  772:                     *yimages = (int)ceil((scale * imageheight) / (pageheight - overlap)); /* Max vert pages needed */
        -:  773:                    else
    #####:  774:                     *yimages = 1;
        -:  775:                   }
        -:  776:                  else
        -:  777:                   {
    #####:  778:                   *ximages = 1;                                                     /* Max vert pages needed */
    #####:  779:                    if (pageheight)
    #####:  780:                     *yimages = (int)ceil((scale * imageheight) / (pageheight - overlap)); /* Max vert pages needed */
        -:  781:                    else
    #####:  782:                     *yimages = 1;
        -:  783:                   }
        -:  784:                 }
        -:  785:                else
        -:  786:                 {
    #####:  787:                 *ximages = 1;
    #####:  788:                 *yimages = 1;
        -:  789:                 }
        -:  790:               }
    #####:  791:             break;
    #####:  792:    case 90:
    #####:  793:    case 270: if (splitheight > 0) /* -H maxPageHeight */
        -:  794:                {
    #####:  795:               if (imagewidth > splitheight) /* More than one vertical image segment */
        -:  796:                 {
    #####:  797:                 *yimages = (int)ceil((scale * imagewidth) / (splitheight - overlap)); /* Max vert pages needed */
    #####:  798:                  if (pagewidth)
    #####:  799:                   *ximages = (int)ceil((scale * imageheight) / (pagewidth - overlap));   /* Max horz pages needed */
        -:  800:                  else
    #####:  801:                   *ximages = 1;
        -:  802:                 }
        -:  803:                else
        -:  804:                 {
    #####:  805:                 *yimages = 1;                                                     /* Max vert pages needed */
    #####:  806:                  if (pagewidth)
    #####:  807:                   *ximages = (int)ceil((scale * imageheight) / (pagewidth - overlap));    /* Max horz pages needed */
        -:  808:                  else
    #####:  809:                   *ximages = 1;
        -:  810:                 }
        -:  811:               }
        -:  812:              else
        -:  813:               {
    #####:  814:                if (splitwidth > 0) /* -W maxPageWidth */
        -:  815:                 {
    #####:  816:                 if (imageheight > splitwidth)
        -:  817:                   {
    #####:  818:                   if (pageheight)
    #####:  819:                     *yimages = (int)ceil((scale * imagewidth) / (pageheight - overlap)); /* Max vert pages needed */
        -:  820:                    else
    #####:  821:                     *yimages = 1;
    #####:  822:                   *ximages = (int)ceil((scale * imageheight)  / (splitwidth - overlap));   /* Max horz pages needed */
        -:  823:                   }
        -:  824:                  else
        -:  825:                   {
    #####:  826:                   if (pageheight)
    #####:  827:                     *yimages = (int)ceil((scale * imagewidth) / (pageheight - overlap));  /* Max horz pages needed */
        -:  828:                    else
    #####:  829:                     *yimages = 1;
    #####:  830:                   *ximages = 1;                                                     /* Max vert pages needed */
        -:  831:                   }
        -:  832:                 }
        -:  833:                else
        -:  834:                 {
    #####:  835:                 *ximages = 1;
    #####:  836:                 *yimages = 1;
        -:  837:                 }
        -:  838:               }
    #####:  839:             break;
    #####:  840:    default:  *ximages = 1;
    #####:  841:             *yimages = 1;
        -:  842:  }
    #####:  843:  pages = (*ximages) * (*yimages);
    #####:  844:  return (pages);
        -:  845:  }
        -:  846:
        -:  847:/* New version of PlaceImage that handles only the translation and rotation
        -:  848: * for a single output page.
        -:  849: */
    #####:  850:int exportMaskedImage(FILE *fp, double pagewidth, double pageheight,
        -:  851:                     double imagewidth, double imageheight,
        -:  852:                      int row, int column,
        -:  853:                      double left_offset, double bott_offset,
        -:  854:                     double scale, int center, int rotation)
        -:  855:  {
    #####:  856:  double xtran = 0.0;
    #####:  857:  double ytran = 0.0;
        -:  858:
    #####:  859:  double xscale = 1.0;
    #####:  860:  double yscale = 1.0;
        -:  861:
    #####:  862:  double splitheight    = 0;  /* Requested Max Height in points */
    #####:  863:  double splitwidth     = 0;  /* Requested Max Width in points */
    #####:  864:  double overlap        = 0;  /* Repeated edge width in points */
    #####:  865:  double subimage_height = 0.0;
        -:  866:
    #####:  867:  splitheight = maxPageHeight * PS_UNIT_SIZE;
    #####:  868:  splitwidth  = maxPageWidth  * PS_UNIT_SIZE;
    #####:  869:  overlap     = splitOverlap  * PS_UNIT_SIZE;
    #####:  870:  xscale = scale * imagewidth;
    #####:  871:  yscale = scale * imageheight;
        -:  872:
    #####:  873:  if ((xscale < 0.0) || (yscale < 0.0))
        -:  874:    {
    #####:  875:    TIFFError("exportMaskedImage", "Invalid parameters.");
    #####:  876:    return (-1);
        -:  877:    }
        -:  878:
        -:  879:  /* If images are cropped to a vewport with -H or -W, the output pages are shifted to
        -:  880:   * the top of each output page rather than the Postscript default lower edge.
        -:  881:   */
    #####:  882:  switch (rotation)
        -:  883:    {
    #####:  884:    case 0:
    #####:  885:    case 180: if (splitheight > 0) /* -H maxPageHeight */
        -:  886:                {
    #####:  887:               if (splitheight < imageheight) /* More than one vertical image segments */
        -:  888:                 {
        -:  889:                 /* Intra2net: Keep correct apspect ratio */
    #####:  890:                 xscale = (imagewidth + overlap) * (pageheight / splitheight) * scale;
        -:  891:
    #####:  892:                 xtran = -1.0 * column * (pagewidth - overlap);
    #####:  893:                  subimage_height = imageheight - ((splitheight - overlap) * row);
    #####:  894:                 ytran  = pageheight - subimage_height * (pageheight / splitheight);
        -:  895:                  }
        -:  896:                else  /* Only one page in vertical direction */
        -:  897:                 {
    #####:  898:                 xtran = -1.0 * column * (pagewidth - overlap);
    #####:  899:                  ytran = splitheight - imageheight;
        -:  900:                 }
        -:  901:               }
        -:  902:              else
        -:  903:               {
    #####:  904:                if (splitwidth > 0) /* maxPageWidth */
        -:  905:                 {
    #####:  906:                 if (splitwidth < imagewidth)
        -:  907:                   {
    #####:  908:                   xtran = -1.0  * column * splitwidth;
    #####:  909:                   ytran = -1.0 * row * (pageheight - overlap);
        -:  910:                    }
        -:  911:                  else /* Only one page in horizontal direction */
        -:  912:                   {
    #####:  913:                    ytran = -1.0 * row * (pageheight - overlap);
    #####:  914:                    xtran = 0;
        -:  915:                   }
        -:  916:                 }
        -:  917:                else    /* Simple case, no splitting */
        -:  918:                 {
    #####:  919:                 ytran = pageheight - imageheight;
    #####:  920:                 xtran = 0;
        -:  921:                  }
        -:  922:                }
        -:  923:
    #####:  924:            if (imagewidth <= pagewidth) {
        -:  925:                /* Intra2net: Crop page at the bottom instead of the top (-> output starts at the top).
        -:  926:                     Only do this in non-page-split mode */
    #####:  927:                if (imageheight <= splitheight) {
    #####:  928:                    ytran = pageheight - imageheight; /* Note: Will be negative for images longer than page size */
        -:  929:                }
        -:  930:            }
    #####:  931:              bott_offset += ytran / (center ? 2 : 1);
    #####:  932:              left_offset += xtran / (center ? 2 : 1);
    #####:  933:              break;
    #####:  934:    case  90:
    #####:  935:    case 270:  if (splitheight > 0) /* -H maxPageHeight */
        -:  936:                {
    #####:  937:               if (splitheight < imagewidth) /* More than one vertical image segments */
        -:  938:                 {
    #####:  939:                 xtran = -1.0 * column * (pageheight - overlap);
        -:  940:                 /* Commented code places image at bottom of page instead of top.
        -:  941:                     ytran = -1.0 * row * splitheight;
        -:  942:                   */
    #####:  943:                  if (row == 0)
    #####:  944:                    ytran = -1.0 * (imagewidth - splitheight);
        -:  945:                  else
    #####:  946:                    ytran = -1.0 * (imagewidth - (splitheight - overlap) * (row + 1));
        -:  947:                  }
        -:  948:                else  /* Only one page in vertical direction */
        -:  949:                 {
    #####:  950:                  xtran = -1.0 * column * (pageheight - overlap);
    #####:  951:                  ytran = splitheight - imagewidth;
        -:  952:                 }
        -:  953:		}
        -:  954:              else
        -:  955:               {
    #####:  956:                if (splitwidth > 0) /* maxPageWidth */
        -:  957:                 {
    #####:  958:                 if (splitwidth < imageheight)
        -:  959:                   {
    #####:  960:                    xtran = -1.0  * column * splitwidth;
    #####:  961:                    ytran = -1.0 * row * (pagewidth - overlap);
        -:  962:                    }
        -:  963:                  else /* Only one page in horizontal direction */
        -:  964:                   {
    #####:  965:                    ytran = -1.0 * row * (pagewidth - overlap);
    #####:  966:                    xtran = 0;
        -:  967:                   }
        -:  968:                 }
        -:  969:                else    /* Simple case, no splitting */
        -:  970:                 {
    #####:  971:                 ytran = pageheight - imageheight;
    #####:  972:                 xtran = 0; /* pagewidth  - imagewidth; */
        -:  973:                  }
        -:  974:                }
    #####:  975:              bott_offset += ytran / (center ? 2 : 1);
    #####:  976:              left_offset += xtran / (center ? 2 : 1);
    #####:  977:              break;
    #####:  978:    default:  xtran = 0;
    #####:  979:             ytran = 0;
        -:  980:    }
        -:  981:
    #####:  982:  switch (rotation)
        -:  983:    {
    #####:  984:    case   0: fprintf(fp, "%f %f translate\n", left_offset, bott_offset);
    #####:  985:              fprintf(fp, "%f %f scale\n", xscale, yscale);
    #####:  986:             break;
    #####:  987:    case 180: fprintf(fp, "%f %f translate\n", left_offset, bott_offset);
    #####:  988:              fprintf(fp, "%f %f scale\n1 1 translate 180 rotate\n",  xscale, yscale);
    #####:  989:              break;
    #####:  990:    case  90: fprintf(fp, "%f %f translate\n", left_offset, bott_offset);
    #####:  991:              fprintf(fp, "%f %f scale\n1 0 translate 90 rotate\n", yscale, xscale);
    #####:  992:              break;
    #####:  993:    case 270: fprintf(fp, "%f %f translate\n", left_offset, bott_offset);
    #####:  994:              fprintf(fp, "%f %f scale\n0 1 translate 270 rotate\n", yscale, xscale);
    #####:  995:              break;
    #####:  996:    default:  TIFFError ("exportMaskedImage", "Unsupported rotation angle %d. No rotation", rotation);
    #####:  997:             fprintf( fp, "%f %f scale\n", xscale, yscale);
    #####:  998:              break;
        -:  999:    }
        -: 1000:
    #####: 1001:  return (0);
        -: 1002:  }
        -: 1003:
        -: 1004:/* Rotate an image without scaling or clipping */
        1: 1005:int  psRotateImage (FILE * fd, int rotation, double pswidth, double psheight,
        -: 1006:                    double left_offset, double bottom_offset)
        -: 1007:  {
        1: 1008:  if ((left_offset != 0.0) || (bottom_offset != 0))
    #####: 1009:    fprintf (fd, "%f %f translate\n", left_offset, bottom_offset);
        -: 1010:
        -: 1011:  /* Exchange width and height for 90/270 rotations */
        1: 1012:  switch (rotation)
        -: 1013:    {
       1*: 1014:    case   0: fprintf (fd, "%f %f scale\n", pswidth, psheight);
        1: 1015:              break;
    #####: 1016:    case  90: fprintf (fd, "%f %f scale\n1 0 translate 90 rotate\n", psheight, pswidth);
    #####: 1017:              break;
    #####: 1018:    case 180: fprintf (fd, "%f %f scale\n1 1 translate 180 rotate\n", pswidth, psheight);
    #####: 1019:              break;
    #####: 1020:    case 270: fprintf (fd, "%f %f scale\n0 1 translate 270 rotate\n", psheight, pswidth);
    #####: 1021:              break;
    #####: 1022:    default:  TIFFError ("psRotateImage", "Unsupported rotation %d.", rotation);
    #####: 1023:             fprintf( fd, "%f %f scale\n", pswidth, psheight);
    #####: 1024:              return (1);
        -: 1025:    }
        1: 1026:  return (0);
        -: 1027:  }
        -: 1028:
        -: 1029:/* Scale and rotate an image to a single output page. */
    #####: 1030:int psScaleImage(FILE * fd, double scale, int rotation, int center,
        -: 1031:                 double reqwidth, double reqheight, double pswidth, double psheight,
        -: 1032:                 double left_offset, double bottom_offset)
        -: 1033:  {
    #####: 1034:  double hcenter = 0.0, vcenter = 0.0;
        -: 1035:
        -: 1036:  /* Adjust offsets for centering */
    #####: 1037:  if (center)
        -: 1038:    {
    #####: 1039:    switch (rotation)
        -: 1040:      {
    #####: 1041:      case   90: vcenter = (reqheight - pswidth * scale) / 2;
    #####: 1042:                hcenter = (reqwidth - psheight * scale) / 2;
    #####: 1043:                 fprintf (fd, "%f %f translate\n", hcenter, vcenter);
    #####: 1044:                 fprintf (fd, "%f %f scale\n1 0 translate 90 rotate\n", psheight * scale, pswidth * scale);
    #####: 1045:                 break;
    #####: 1046:      case  180: hcenter = (reqwidth - pswidth * scale) / 2;
    #####: 1047:                vcenter = (reqheight - psheight * scale) / 2;
    #####: 1048:                 fprintf (fd, "%f %f translate\n", hcenter, vcenter);
    #####: 1049:                 fprintf (fd, "%f %f scale\n1 1 translate 180 rotate\n", pswidth * scale, psheight * scale);
    #####: 1050:                 break;
    #####: 1051:      case  270: vcenter = (reqheight - pswidth * scale) / 2;
    #####: 1052:                hcenter = (reqwidth - psheight * scale) / 2;
    #####: 1053:                 fprintf (fd, "%f %f translate\n", hcenter, vcenter);
    #####: 1054:                 fprintf (fd, "%f %f scale\n0 1 translate 270 rotate\n", psheight * scale, pswidth * scale);
    #####: 1055:                 break;
    #####: 1056:      case    0:
    #####: 1057:      default:   hcenter = (reqwidth - pswidth * scale) / 2;
    #####: 1058:                vcenter = (reqheight - psheight * scale) / 2;
    #####: 1059:                 fprintf (fd, "%f %f translate\n", hcenter, vcenter);
    #####: 1060:                 fprintf (fd, "%f %f scale\n", pswidth * scale, psheight * scale);
    #####: 1061:                 break;
        -: 1062:      }
        -: 1063:    }
        -: 1064:  else  /* Not centered */
        -: 1065:    {
    #####: 1066:    switch (rotation)
        -: 1067:      {
    #####: 1068:      case 0:   fprintf (fd, "%f %f translate\n", left_offset ? left_offset : 0.0,
    #####: 1069:                         bottom_offset ? bottom_offset : reqheight - (psheight * scale));
    #####: 1070:                fprintf (fd, "%f %f scale\n", pswidth * scale, psheight * scale);
    #####: 1071:                break;
    #####: 1072:      case 90:  fprintf (fd, "%f %f translate\n", left_offset ? left_offset : 0.0,
    #####: 1073:                         bottom_offset ? bottom_offset : reqheight - (pswidth * scale));
    #####: 1074:                fprintf (fd, "%f %f scale\n1 0 translate 90 rotate\n", psheight * scale, pswidth * scale);
    #####: 1075:                break;
    #####: 1076:      case 180: fprintf (fd, "%f %f translate\n", left_offset ? left_offset : 0.0,
    #####: 1077:                         bottom_offset ? bottom_offset : reqheight - (psheight * scale));
    #####: 1078:                fprintf (fd, "%f %f scale\n1 1 translate 180 rotate\n", pswidth * scale, psheight * scale);
    #####: 1079:                break;
    #####: 1080:      case 270: fprintf (fd, "%f %f translate\n", left_offset ? left_offset : 0.0,
    #####: 1081:                         bottom_offset ? bottom_offset : reqheight - (pswidth * scale));
    #####: 1082:                fprintf (fd, "%f %f scale\n0 1 translate 270 rotate\n", psheight * scale, pswidth * scale);
    #####: 1083:                break;
    #####: 1084:      default:  TIFFError ("psScaleImage", "Unsupported rotation  %d", rotation);
    #####: 1085:               fprintf (fd, "%f %f scale\n", pswidth * scale, psheight * scale);
    #####: 1086:                return (1);
        -: 1087:      }
        -: 1088:    }
        -: 1089:
    #####: 1090:  return (0);
        -: 1091:  }
        -: 1092:
        -: 1093:/* This controls the visible portion of the page which is displayed.
        -: 1094: * N.B. Setting maxPageHeight no longer sets pageheight if not set explicitly
        -: 1095: */
    #####: 1096:int psPageSize (FILE * fd, int rotation, double pgwidth, double pgheight,
        -: 1097:                double reqwidth, double reqheight, double pswidth, double psheight)
        -: 1098:  {
    #####: 1099:  double xscale = 1.0, yscale = 1.0, scale = 1.0;
        -: 1100:  double splitheight;
        -: 1101:  double splitwidth;
        -: 1102:  double new_width;
        -: 1103:  double new_height;
        -: 1104:
    #####: 1105:  splitheight = maxPageHeight * PS_UNIT_SIZE;
    #####: 1106:  splitwidth  = maxPageWidth  * PS_UNIT_SIZE;
        -: 1107:
    #####: 1108:  switch (rotation)
        -: 1109:    {
    #####: 1110:    case   0:
    #####: 1111:    case 180: if ((splitheight > 0) || (splitwidth > 0))
        -: 1112:                {
    #####: 1113:               if (pgwidth != 0 || pgheight != 0)
        -: 1114:                  {
    #####: 1115:                 xscale = reqwidth / (splitwidth ? splitwidth : pswidth);
    #####: 1116:                 yscale = reqheight / (splitheight ? splitheight : psheight);
    #####: 1117:                  scale = (xscale < yscale) ? xscale : yscale;
        -: 1118:                  }
    #####: 1119:                new_width = splitwidth ? splitwidth : scale * pswidth;
    #####: 1120:                new_height = splitheight ? splitheight : scale * psheight;
    #####: 1121:                if (strlen(pageOrientation))
    #####: 1122:                  fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1123:                else
    #####: 1124:                  fprintf (fd, "%%%%PageOrientation: %s\n", (new_width > new_height) ? "Landscape" : "Portrait");
    #####: 1125:                fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)new_width, (long)new_height);
    #####: 1126:                fprintf (fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1127:                       new_width, new_height);
        -: 1128:                }
        -: 1129:             else /* No viewport defined with -H or -W */
        -: 1130:                {
    #####: 1131:                if ((pgwidth == 0) && (pgheight == 0)) /* Image not scaled */
        -: 1132:                  {
    #####: 1133:                  if (strlen(pageOrientation))
    #####: 1134:                    fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1135:                  else
    #####: 1136:                    fprintf (fd, "%%%%PageOrientation: %s\n", (pswidth > psheight) ? "Landscape" : "Portrait");
    #####: 1137:                 fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)pswidth, (long)psheight);
    #####: 1138:                  fprintf(fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1139:                          pswidth, psheight);
        -: 1140:                  }
        -: 1141:               else /* Image scaled */
        -: 1142:                  {
    #####: 1143:                  if (strlen(pageOrientation))
    #####: 1144:                    fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1145:                  else
    #####: 1146:                    fprintf (fd, "%%%%PageOrientation: %s\n", (reqwidth > reqheight) ? "Landscape" : "Portrait");
    #####: 1147:                 fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)reqwidth, (long)reqheight);
    #####: 1148:                  fprintf(fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1149:                           reqwidth, reqheight);
        -: 1150:                  }
        -: 1151:                }
    #####: 1152:             break;
    #####: 1153:    case  90:
    #####: 1154:    case 270: if ((splitheight > 0) || (splitwidth > 0))
        -: 1155:               {
    #####: 1156:               if (pgwidth != 0 || pgheight != 0)
        -: 1157:                  {
    #####: 1158:                 xscale = reqwidth / (splitwidth ? splitwidth : pswidth);
    #####: 1159:                 yscale = reqheight / (splitheight ? splitheight : psheight);
    #####: 1160:                  scale = (xscale < yscale) ? xscale : yscale;
        -: 1161:                  }
    #####: 1162:                new_width = splitwidth ? splitwidth : scale * psheight;
    #####: 1163:                new_height = splitheight ? splitheight : scale * pswidth;
        -: 1164:
    #####: 1165:                if (strlen(pageOrientation))
    #####: 1166:                  fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1167:                else
    #####: 1168:                  fprintf (fd, "%%%%PageOrientation: %s\n", (new_width > new_height) ? "Landscape" : "Portrait");
    #####: 1169:                fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)new_width, (long)new_height);
    #####: 1170:                fprintf (fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1171:                       new_width, new_height);
        -: 1172:                }
        -: 1173:              else
        -: 1174:                {
    #####: 1175:                if ((pgwidth == 0) && (pgheight == 0)) /* Image not scaled */
        -: 1176:                  {
    #####: 1177:                  if (strlen(pageOrientation))
    #####: 1178:                    fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1179:                  else
    #####: 1180:                    fprintf (fd, "%%%%PageOrientation: %s\n", (psheight > pswidth) ? "Landscape" : "Portrait");
    #####: 1181:                 fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)psheight, (long)pswidth);
    #####: 1182:                  fprintf(fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1183:                         psheight, pswidth);
        -: 1184:                  }
        -: 1185:               else /* Image scaled */
        -: 1186:                  {
    #####: 1187:                  if (strlen(pageOrientation))
    #####: 1188:                    fprintf (fd, "%%%%PageOrientation: %s\n", pageOrientation);
        -: 1189:                  else
    #####: 1190:                    fprintf (fd, "%%%%PageOrientation: %s\n", (reqwidth > reqheight) ? "Landscape" : "Portrait");
    #####: 1191:                 fprintf (fd, "%%%%PageBoundingBox: 0 0 %ld %ld\n", (long)reqwidth, (long)reqheight);
    #####: 1192:                  fprintf(fd, "1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\n",
        -: 1193:                          reqwidth, reqheight);
        -: 1194:                  }
        -: 1195:               }
    #####: 1196:             break;
    #####: 1197:    default:  TIFFError ("psPageSize", "Invalid rotation %d", rotation);
    #####: 1198:      return (1);
        -: 1199:    }
    #####: 1200:  fputs("<<\n  /Policies <<\n    /PageSize 3\n  >>\n>> setpagedevice\n", fd);
        -: 1201:
    #####: 1202:  return (0);
        -: 1203:  } /* end psPageSize */
        -: 1204:
        -: 1205:/* Mask an image as a series of pages, each only showing a section defined
        -: 1206: * by the maxPageHeight or maxPageWidth options.
        -: 1207: */
    #####: 1208:int psMaskImage(FILE *fd, TIFF *tif, int rotation, int center,
        -: 1209:                int *npages, double pixwidth, double pixheight,
        -: 1210:               double left_margin, double bottom_margin,
        -: 1211:                double pgwidth, double pgheight,
        -: 1212:               double pswidth, double psheight, double scale)
        -: 1213:  {
        -: 1214:  int i, j;
    #####: 1215:  int ximages = 1, yimages = 1;
    #####: 1216:  int pages = *npages;
    #####: 1217:  double view_width = 0;
    #####: 1218:  double view_height = 0;
        -: 1219:
    #####: 1220:  if (get_viewport (pgwidth, pgheight, pswidth, psheight, &view_width, &view_height, rotation))
        -: 1221:    {
    #####: 1222:    TIFFError ("get_viewport", "Unable to set image viewport");
    #####: 1223:    return (-1);
        -: 1224:    }
        -: 1225:
    #####: 1226:  if (get_subimage_count(pgwidth, pgheight, pswidth, psheight,
        -: 1227:                        &ximages, &yimages, rotation, scale) < 1)
        -: 1228:    {
    #####: 1229:    TIFFError("get_subimage_count", "Invalid image count: %d columns, %d rows", ximages, yimages);
    #####: 1230:    return (-1);
        -: 1231:    }
        -: 1232:
    #####: 1233:  for (i = 0; i < yimages; i++)
        -: 1234:    {
    #####: 1235:    for (j = 0; j < ximages; j++)
        -: 1236:       {
    #####: 1237:       pages++;
    #####: 1238:       *npages = pages;
    #####: 1239:       fprintf(fd, "%%%%Page: %d %d\n", pages, pages);
        -: 1240:
        -: 1241:       /* Write out the PageSize info for non EPS files */
    #####: 1242:       if (!generateEPSF && ( level2 || level3 ))
        -: 1243:         {
    #####: 1244:         if (psPageSize(fd, rotation, pgwidth, pgheight,
        -: 1245:                        view_width, view_height, pswidth, psheight))
    #####: 1246:           return (-1);
        -: 1247:        }
    #####: 1248:       fprintf(fd, "gsave\n");
    #####: 1249:       fprintf(fd, "100 dict begin\n");
    #####: 1250:       if (exportMaskedImage(fd, view_width, view_height, pswidth, psheight,
        -: 1251:                            i, j, left_margin, bottom_margin,
        -: 1252:                            scale, center, rotation))
        -: 1253:        {
    #####: 1254:        TIFFError("exportMaskedImage", "Invalid image parameters.");
    #####: 1255:        return (-1);
        -: 1256:        }
    #####: 1257:       PSpage(fd, tif, pixwidth, pixheight);
    #####: 1258:       fprintf(fd, "end\n");
    #####: 1259:       fprintf(fd, "grestore\n");
    #####: 1260:       fprintf(fd, "showpage\n");
        -: 1261:       }
        -: 1262:    }
        -: 1263:
    #####: 1264:  return (pages);
        -: 1265:  }
        -: 1266:
        -: 1267:/* Compute scale factor and write out file header */
        1: 1268:int psStart(FILE *fd, int npages, int auto_rotate, int *rotation, double *scale,
        -: 1269:            double ox, double oy, double pgwidth, double pgheight,
        -: 1270:           double reqwidth, double reqheight, double pswidth, double psheight,
        -: 1271:           double left_offset, double bottom_offset)
        -: 1272:  {
        1: 1273:  double maxsource = 0.0;    /* Used for auto rotations */
        1: 1274:  double maxtarget = 0.0;
        1: 1275:  double xscale = 1.0, yscale = 1.0;
        -: 1276:  double splitheight;
        -: 1277:  double splitwidth;
        1: 1278:  double view_width = 0.0, view_height = 0.0;
        1: 1279:  double page_width = 0.0, page_height = 0.0;
        -: 1280:
        -: 1281:  /* Splitheight and splitwidth are in inches */
        1: 1282:  splitheight = maxPageHeight * PS_UNIT_SIZE;
        1: 1283:  splitwidth  = maxPageWidth * PS_UNIT_SIZE;
        -: 1284:
        1: 1285:  page_width = pgwidth * PS_UNIT_SIZE;
        1: 1286:  page_height = pgheight * PS_UNIT_SIZE;
        -: 1287:
        -: 1288:  /* If user has specified a page width and height and requested the
        -: 1289:   * image to be auto-rotated to fit on that media, we match the
        -: 1290:   * longest dimension of the image to the longest dimension of the
        -: 1291:   * target media but we have to ignore auto rotate if user specified
        -: 1292:   * maxPageHeight since this makes life way too complicated. */
        1: 1293:  if (auto_rotate)
        -: 1294:    {
    #####: 1295:    if ((splitheight != 0) || (splitwidth != 0))
        -: 1296:      {
    #####: 1297:      TIFFError ("psStart", "Auto-rotate is incompatible with page splitting ");
    #####: 1298:      return (1);
        -: 1299:      }
        -: 1300:
        -: 1301:    /* Find longest edges in image and output media */
    #####: 1302:    maxsource = (pswidth >= psheight) ? pswidth : psheight;
    #####: 1303:    maxtarget = (reqwidth >= reqheight) ? reqwidth : reqheight;
        -: 1304:
    #####: 1305:    if (((maxsource == pswidth) && (maxtarget != reqwidth)) ||
    #####: 1306:        ((maxsource == psheight) && (maxtarget != reqheight)))
        -: 1307:      {  /* optimal orientaion does not match input orientation */
    #####: 1308:      *rotation = 90;
    #####: 1309:      xscale = (reqwidth - left_offset)/psheight;
    #####: 1310:      yscale = (reqheight - bottom_offset)/pswidth;
        -: 1311:      }
        -: 1312:    else /* optimal orientaion matches input orientation */
        -: 1313:      {
    #####: 1314:      xscale = (reqwidth - left_offset)/pswidth;
    #####: 1315:      yscale = (reqheight - bottom_offset)/psheight;
        -: 1316:      }
    #####: 1317:    *scale = (xscale < yscale) ? xscale : yscale;
        -: 1318:
        -: 1319:    /* Do not scale image beyound original size */
    #####: 1320:    if (*scale > 1.0)
    #####: 1321:      *scale = 1.0;
        -: 1322:
        -: 1323:    /* Set the size of the displayed image to requested page size
        -: 1324:     * and optimal orientation.
        -: 1325:     */
    #####: 1326:    if (!npages)
    #####: 1327:      PSHead(fd, reqwidth, reqheight, ox, oy);
        -: 1328:
    #####: 1329:    return (0);
        -: 1330:    }
        -: 1331:
        -: 1332:  /* N.B. If pgwidth or pgheight are set from maxPageHeight/Width,
        -: 1333:   * we have a problem with the tests below under splitheight.
        -: 1334:   */
        -: 1335:
        1: 1336:  switch (*rotation)  /* Auto rotate has NOT been specified */
        -: 1337:    {
        1: 1338:    case   0:
        1: 1339:    case 180: if ((splitheight != 0)  || (splitwidth != 0))
        -: 1340:                {  /* Viewport clipped to maxPageHeight or maxPageWidth */
    #####: 1341:                if ((page_width != 0) || (page_height != 0)) /* Image scaled */
        -: 1342:                  {
    #####: 1343:                 xscale = (reqwidth  - left_offset) / (page_width ? page_width : pswidth);
    #####: 1344:                 yscale = (reqheight - bottom_offset) / (page_height ? page_height : psheight);
    #####: 1345:                  *scale = (xscale < yscale) ? xscale : yscale;
        -: 1346:                  /*
        -: 1347:                  if (*scale > 1.0)
        -: 1348:                    *scale = 1.0;
        -: 1349:                   */
        -: 1350:                 }
        -: 1351:                else       /* Image clipped but not scaled */
    #####: 1352:                 *scale = 1.0;
        -: 1353:
    #####: 1354:                view_width = splitwidth ? splitwidth : *scale * pswidth;
    #####: 1355:                view_height = splitheight ? splitheight: *scale * psheight;
        -: 1356:               }
        -: 1357:              else   /* Viewport not clipped to maxPageHeight or maxPageWidth */
        -: 1358:                {
        1: 1359:                if ((page_width != 0) || (page_height != 0))
        -: 1360:                  {   /* Image scaled  */
    #####: 1361:                  xscale = (reqwidth - left_offset) / pswidth;
    #####: 1362:                  yscale = (reqheight - bottom_offset) / psheight;
        -: 1363:
    #####: 1364:                  view_width = reqwidth;
    #####: 1365:                  view_height = reqheight;
        -: 1366:                 }
        -: 1367:                else
        -: 1368:                  {  /* Image not scaled  */
        1: 1369:                  xscale = (pswidth - left_offset)/pswidth;
        1: 1370:                  yscale = (psheight - bottom_offset)/psheight;
        -: 1371:
        1: 1372:                  view_width = pswidth;
        1: 1373:                  view_height = psheight;
        -: 1374:                 }
        -: 1375:               }
        1: 1376:             break;
    #####: 1377:    case  90:
    #####: 1378:    case 270: if ((splitheight != 0) || (splitwidth != 0))
        -: 1379:                {  /* Viewport clipped to maxPageHeight or maxPageWidth */
    #####: 1380:                if ((page_width != 0) || (page_height != 0)) /* Image scaled */
        -: 1381:                  {
    #####: 1382:                 xscale = (reqwidth - left_offset)/ psheight;
    #####: 1383:                 yscale = (reqheight - bottom_offset)/ pswidth;
    #####: 1384:                  *scale = (xscale < yscale) ? xscale : yscale;
        -: 1385:                  /*
        -: 1386:                  if (*scale > 1.0)
        -: 1387:                    *scale = 1.0;
        -: 1388:                 */
        -: 1389:                 }
        -: 1390:                else  /* Image clipped but not scaled */
    #####: 1391:                 *scale = 1.0;
    #####: 1392:                view_width = splitwidth ? splitwidth : *scale * psheight;
    #####: 1393:                view_height = splitheight ? splitheight : *scale * pswidth;
        -: 1394:               }
        -: 1395:              else /* Viewport not clipped to maxPageHeight or maxPageWidth */
        -: 1396:                {
    #####: 1397:                if ((page_width != 0) || (page_height != 0)) /* Image scaled */
        -: 1398:                  {
    #####: 1399:                  xscale = (reqwidth - left_offset) / psheight;
    #####: 1400:                  yscale = (reqheight - bottom_offset) / pswidth;
        -: 1401:
    #####: 1402:                 view_width = reqwidth;
    #####: 1403:                 view_height = reqheight;
        -: 1404:                 }
        -: 1405:                else
        -: 1406:                  {
    #####: 1407:                  xscale = (pswidth  - left_offset)/ psheight;
    #####: 1408:                 yscale = (psheight  - bottom_offset)/ pswidth;
        -: 1409:
    #####: 1410:                 view_width = psheight;
    #####: 1411:                 view_height = pswidth;
        -: 1412:                  }
        -: 1413:                }
    #####: 1414:              break;
    #####: 1415:    default:  TIFFError ("psPageSize", "Invalid rotation %d", *rotation);
    #####: 1416:              return (1);
        -: 1417:    }
        -: 1418:
        1: 1419:  if (!npages)
       1*: 1420:    PSHead(fd, (page_width ? page_width : view_width), (page_height ? page_height : view_height), ox, oy);
        -: 1421:
       1*: 1422:  *scale = (xscale < yscale) ? xscale : yscale;
        1: 1423:  if (*scale > 1.0)
    #####: 1424:    *scale = 1.0;
        -: 1425:
        1: 1426:  return (0);
        -: 1427:  }
        -: 1428:
        1: 1429:int get_viewport (double pgwidth, double pgheight, double pswidth, double psheight,
        -: 1430:                  double *view_width, double *view_height, int rotation)
        -: 1431:  {
        -: 1432:  /* Only one of maxPageHeight or maxPageWidth can be specified */
        1: 1433:  if (maxPageHeight != 0)   /* Clip the viewport to maxPageHeight on each page */
        -: 1434:    {
    #####: 1435:    if (pgheight != 0 && pgheight < maxPageHeight)
    #####: 1436:      *view_height = pgheight * PS_UNIT_SIZE;
        -: 1437:    else
    #####: 1438:      *view_height = maxPageHeight * PS_UNIT_SIZE;
        -: 1439:    /*
        -: 1440:     * if (res_unit == RESUNIT_CENTIMETER)
        -: 1441:     * *view_height /= 2.54F;
        -: 1442:     */
        -: 1443:    }
        -: 1444:  else
        -: 1445:    {
        1: 1446:    if (pgheight != 0) /* User has set PageHeight with -h flag */
        -: 1447:      {
    #####: 1448:      *view_height = pgheight * PS_UNIT_SIZE; /* Postscript size for Page Height in inches */
        -: 1449:      /* if (res_unit == RESUNIT_CENTIMETER)
        -: 1450:       *  *view_height /= 2.54F;
        -: 1451:       */
        -: 1452:      }
        -: 1453:    else /* If no width or height are specified, use the original size from image */
        1: 1454:      switch (rotation)
        -: 1455:        {
        1: 1456:        default:
        -: 1457:        case   0:
        1: 1458:        case 180: *view_height = psheight;
        1: 1459:                 break;
    #####: 1460:        case  90:
    #####: 1461:        case 270: *view_height = pswidth;
    #####: 1462:                 break;
        -: 1463:       }
        -: 1464:    }
        -: 1465:
        1: 1466:  if (maxPageWidth != 0)   /* Clip the viewport to maxPageWidth on each page */
        -: 1467:    {
    #####: 1468:    if (pgwidth != 0 && pgwidth < maxPageWidth)
    #####: 1469:      *view_width = pgwidth * PS_UNIT_SIZE;
        -: 1470:    else
    #####: 1471:      *view_width = maxPageWidth * PS_UNIT_SIZE;
        -: 1472:    /* if (res_unit == RESUNIT_CENTIMETER)
        -: 1473:     *  *view_width /= 2.54F;
        -: 1474:     */
        -: 1475:    }
        -: 1476:  else
        -: 1477:    {
        1: 1478:    if (pgwidth != 0)  /* User has set PageWidth with -w flag */
        -: 1479:      {
    #####: 1480:      *view_width = pgwidth * PS_UNIT_SIZE; /* Postscript size for Page Width in inches */
        -: 1481:      /* if (res_unit == RESUNIT_CENTIMETER)
        -: 1482:       * *view_width /= 2.54F;
        -: 1483:       */
        -: 1484:      }
        -: 1485:    else  /* If no width or height are specified, use the original size from image */
        1: 1486:      switch (rotation)
        -: 1487:        {
        1: 1488:        default:
        -: 1489:        case   0:
        1: 1490:        case 180: *view_width = pswidth;
        1: 1491:                 break;
    #####: 1492:        case  90:
    #####: 1493:        case 270: *view_width = psheight; /* (*view_height / psheight) * psheight; */
    #####: 1494:                 break;
        -: 1495:       }
        -: 1496:    }
        -: 1497:
        1: 1498:  return (0);
        -: 1499:  }
        -: 1500:
        -: 1501:/* pgwidth and pgheight specify page width and height in inches from -h and -w flags
        -: 1502: * lm and bm are the LeftMargin and BottomMargin in inches
        -: 1503: * center causes the image to be centered on the page if the paper size is
        -: 1504: * larger than the image size
        -: 1505: * returns the sequence number of the page processed or -1 on error
        -: 1506: */
        -: 1507:
        1: 1508:int TIFF2PS(FILE* fd, TIFF* tif, double pgwidth, double pgheight, double lm, double bm, int center)
        -: 1509:  {
        1: 1510:  uint32 pixwidth = 0, pixheight = 0;  /* Image width and height in pixels */
        1: 1511:  double ox = 0.0, oy = 0.0;  /* Offset from current Postscript origin */
        1: 1512:  double pswidth, psheight;   /* Original raw image width and height in points */
        1: 1513:  double view_width, view_height; /* Viewport width and height in points */
        1: 1514:  double scale = 1.0;
        1: 1515:  double left_offset = lm * PS_UNIT_SIZE;
        1: 1516:  double bottom_offset = bm * PS_UNIT_SIZE;
        1: 1517:  uint32 subfiletype;
        1: 1518:  uint16* sampleinfo;
        -: 1519:  static int npages = 0;
        -: 1520:
        1: 1521:  if (!TIFFGetField(tif, TIFFTAG_XPOSITION, &ox))
        1: 1522:     ox = 0;
        1: 1523:  if (!TIFFGetField(tif, TIFFTAG_YPOSITION, &oy))
        1: 1524:     oy = 0;
        -: 1525:
        -: 1526:  /* Consolidated all the tag information into one code segment, Richard Nolde */
        -: 1527:  do {
        1: 1528:     tf_numberstrips = TIFFNumberOfStrips(tif);
        1: 1529:     TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &tf_rowsperstrip);
        1: 1530:     TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);
        1: 1531:     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);
        1: 1532:     TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfiguration);
        1: 1533:     TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);
        1: 1534:     TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);
       1*: 1535:     alpha = (extrasamples == 1 && sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
        1: 1536:     if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))
        -: 1537:       {
    #####: 1538:       switch (samplesperpixel - extrasamples)
        -: 1539:             {
    #####: 1540:            case 1: if (isCCITTCompression(tif))
    #####: 1541:                      photometric = PHOTOMETRIC_MINISWHITE;
        -: 1542:                    else
    #####: 1543:                       photometric = PHOTOMETRIC_MINISBLACK;
    #####: 1544:                    break;
    #####: 1545:            case 3: photometric = PHOTOMETRIC_RGB;
    #####: 1546:                    break;
    #####: 1547:            case 4: photometric = PHOTOMETRIC_SEPARATED;
    #####: 1548:                    break;
        -: 1549:            }
        1: 1550:       }
        -: 1551:
        -: 1552:     /* Read image tags for width and height in pixels pixwidth, pixheight,
        -: 1553:      * and convert to points pswidth, psheight
        -: 1554:      */
        1: 1555:     setupPageState(tif, &pixwidth, &pixheight, &pswidth, &psheight);
        1: 1556:     view_width = pswidth;
        1: 1557:     view_height = psheight;
        -: 1558:
        1: 1559:     if (get_viewport (pgwidth, pgheight, pswidth, psheight, &view_width, &view_height, rotation))
        -: 1560:       {
    #####: 1561:       TIFFError("get_viewport", "Unable to set image viewport");
    #####: 1562:       return (1);
        -: 1563:       }
        -: 1564:
        -: 1565:     /* Write the Postscript file header with Bounding Box and Page Size definitions */
        1: 1566:     if (psStart(fd, npages, auto_rotate, &rotation, &scale, ox, oy,
        -: 1567:                pgwidth, pgheight, view_width, view_height, pswidth, psheight,
        -: 1568:                 left_offset, bottom_offset))
    #####: 1569:       return (-1);
        -: 1570:
        1: 1571:     if (checkImage(tif))  /* Aborts if unsupported image parameters */
        -: 1572:       {
        1: 1573:       tf_bytesperrow = TIFFScanlineSize(tif);
        -: 1574:
        -: 1575:       /* Set viewport clipping and scaling options */
        1: 1576:       if ((maxPageHeight) || (maxPageWidth)  || (pgwidth != 0) || (pgheight != 0))
        -: 1577:         {
    #####: 1578:        if ((maxPageHeight) || (maxPageWidth)) /* used -H or -W  option */
        -: 1579:           {
    #####: 1580:          if (psMaskImage(fd, tif, rotation, center, &npages, pixwidth, pixheight,
        -: 1581:                          left_offset, bottom_offset, pgwidth, pgheight,
        -: 1582:                           pswidth, psheight, scale) < 0)
    #####: 1583:            return (-1);
        -: 1584:          }
        -: 1585:         else  /* N.B. Setting maxPageHeight no longer sets pgheight */
        -: 1586:           {
    #####: 1587:           if (pgwidth != 0 || pgheight != 0)
        -: 1588:             {
        -: 1589:             /* User did not specify a maxium page height or width using -H or -W flag
        -: 1590:              * but did use -h or -w flag to scale to a specific size page.
        -: 1591:              */
    #####: 1592:             npages++;
    #####: 1593:             fprintf(fd, "%%%%Page: %d %d\n", npages, npages);
        -: 1594:
    #####: 1595:             if (!generateEPSF && ( level2 || level3 ))
        -: 1596:               {
        -: 1597:              /* Write out the PageSize info for non EPS files */
    #####: 1598:              if (psPageSize(fd, rotation, pgwidth, pgheight,
        -: 1599:                              view_width, view_height, pswidth, psheight))
    #####: 1600:                return (-1);
        -: 1601:               }
    #####: 1602:             fprintf(fd, "gsave\n");
    #####: 1603:             fprintf(fd, "100 dict begin\n");
    #####: 1604:             if (psScaleImage(fd, scale, rotation, center, view_width, view_height,
        -: 1605:                              pswidth, psheight, left_offset, bottom_offset))
    #####: 1606:              return (-1);
        -: 1607:
    #####: 1608:             PSpage(fd, tif, pixwidth, pixheight);
    #####: 1609:             fprintf(fd, "end\n");
    #####: 1610:             fprintf(fd, "grestore\n");
    #####: 1611:             fprintf(fd, "showpage\n");
        -: 1612:            }
        -: 1613:          }
        -: 1614:        }
        -: 1615:       else  /* Simple rotation: user did not use -H, -W, -h or -w */
        -: 1616:         {
        1: 1617:         npages++;
       1*: 1618:         fprintf(fd, "%%%%Page: %d %d\n", npages, npages);
        -: 1619:
       1*: 1620:         if (!generateEPSF && ( level2 || level3 ))
        -: 1621:           {
        -: 1622:          /* Write out the PageSize info for non EPS files */
    #####: 1623:          if (psPageSize(fd, rotation, pgwidth, pgheight,
        -: 1624:                          view_width, view_height, pswidth, psheight))
    #####: 1625:           return (-1);
        -: 1626:         }
       1*: 1627:         fprintf(fd, "gsave\n");
       1*: 1628:         fprintf(fd, "100 dict begin\n");
        1: 1629:        if (psRotateImage(fd, rotation, pswidth, psheight, left_offset, bottom_offset))
    #####: 1630:           return (-1);
        -: 1631:
        1: 1632:         PSpage(fd, tif, pixwidth, pixheight);
    #####: 1633:         fprintf(fd, "end\n");
    #####: 1634:         fprintf(fd, "grestore\n");
    #####: 1635:         fprintf(fd, "showpage\n");
        -: 1636:         }
        -: 1637:       }
    #####: 1638:  if (generateEPSF)
    #####: 1639:    break;
    #####: 1640:  if (auto_rotate)
    #####: 1641:    rotation = 0.0;
    #####: 1642:  TIFFGetFieldDefaulted(tif, TIFFTAG_SUBFILETYPE, &subfiletype);
    #####: 1643:  } while (((subfiletype & FILETYPE_PAGE) || printAll) && TIFFReadDirectory(tif));
        -: 1644:
    #####: 1645:return(npages);
        -: 1646:}
        -: 1647:
        -: 1648:static char DuplexPreamble[] = "\
        -: 1649:%%BeginFeature: *Duplex True\n\
        -: 1650:systemdict begin\n\
        -: 1651:  /languagelevel where { pop languagelevel } { 1 } ifelse\n\
        -: 1652:  2 ge { 1 dict dup /Duplex true put setpagedevice }\n\
        -: 1653:  { statusdict /setduplex known { statusdict begin setduplex true end } if\n\
        -: 1654:  } ifelse\n\
        -: 1655:end\n\
        -: 1656:%%EndFeature\n\
        -: 1657:";
        -: 1658:
        -: 1659:static char TumblePreamble[] = "\
        -: 1660:%%BeginFeature: *Tumble True\n\
        -: 1661:systemdict begin\n\
        -: 1662:  /languagelevel where { pop languagelevel } { 1 } ifelse\n\
        -: 1663:  2 ge { 1 dict dup /Tumble true put setpagedevice }\n\
        -: 1664:  { statusdict /settumble known { statusdict begin true settumble end } if\n\
        -: 1665:  } ifelse\n\
        -: 1666:end\n\
        -: 1667:%%EndFeature\n\
        -: 1668:";
        -: 1669:
        -: 1670:static char AvoidDeadZonePreamble[] = "\
        -: 1671:gsave newpath clippath pathbbox grestore\n\
        -: 1672:  4 2 roll 2 copy translate\n\
        -: 1673:  exch 3 1 roll sub 3 1 roll sub exch\n\
        -: 1674:  currentpagedevice /PageSize get aload pop\n\
        -: 1675:  exch 3 1 roll div 3 1 roll div abs exch abs\n\
        -: 1676:  2 copy gt { exch } if pop\n\
        -: 1677:  dup 1 lt { dup scale } { pop } ifelse\n\
        -: 1678:";
        -: 1679:
        -: 1680:void
        1: 1681:PSHead(FILE *fd, double pagewidth, double pageheight, double xoff, double yoff)
        -: 1682:{
        1: 1683:	time_t t;
        -: 1684:
        1: 1685:	t = time(0);
       1*: 1686:	fprintf(fd, "%%!PS-Adobe-3.0%s\n", generateEPSF ? " EPSF-3.0" : "");
       1*: 1687:	fprintf(fd, "%%%%Creator: %s\n", creator ? creator : "tiff2ps");
       1*: 1688:        fprintf(fd, "%%%%Title: %s\n", title ? title : filename);
       1*: 1689:	fprintf(fd, "%%%%CreationDate: %s", ctime(&t));
       1*: 1690:	fprintf(fd, "%%%%DocumentData: Clean7Bit\n");
        -: 1691:	/* NB: should use PageBoundingBox for each page instead of BoundingBox *
        -: 1692:         * PageBoundingBox DSC added in PSPageSize function, R Nolde 09-01-2010
        -: 1693:         */
       1*: 1694:	fprintf(fd, "%%%%Origin: %ld %ld\n", (long) xoff, (long) yoff);
       1*: 1695:        fprintf(fd, "%%%%BoundingBox: 0 0 %ld %ld\n",
        1: 1696:	       (long) ceil(pagewidth), (long) ceil(pageheight));
        -: 1697:
       1*: 1698:	fprintf(fd, "%%%%LanguageLevel: %d\n", (level3 ? 3 : (level2 ? 2 : 1)));
        1: 1699:        if (generateEPSF == TRUE)
       1*: 1700:	  fprintf(fd, "%%%%Pages: 1 1\n");
        -: 1701:        else
    #####: 1702:	  fprintf(fd, "%%%%Pages: (atend)\n");
       1*: 1703:	fprintf(fd, "%%%%EndComments\n");
        1: 1704:        if (generateEPSF == FALSE)
        -: 1705:          {
    #####: 1706:  	  fprintf(fd, "%%%%BeginSetup\n");
    #####: 1707:	  if (PSduplex)
    #####: 1708:		fprintf(fd, "%s", DuplexPreamble);
    #####: 1709:	  if (PStumble)
    #####: 1710:		fprintf(fd, "%s", TumblePreamble);
    #####: 1711:	  if (PSavoiddeadzone && (level2 || level3))
    #####: 1712:		fprintf(fd, "%s", AvoidDeadZonePreamble);
    #####: 1713:	  fprintf(fd, "%%%%EndSetup\n");
        -: 1714:	  }
        1: 1715:}
        -: 1716:
        -: 1717:void
    #####: 1718:PSTail(FILE *fd, int npages)
        -: 1719:{
    #####: 1720:	fprintf(fd, "%%%%Trailer\n");
    #####: 1721:        if (generateEPSF == FALSE)
    #####: 1722:	  fprintf(fd, "%%%%Pages: %d\n", npages);
    #####: 1723:	fprintf(fd, "%%%%EOF\n");
    #####: 1724:}
        -: 1725:
        -: 1726:static int
    #####: 1727:checkcmap(TIFF* tif, int n, uint16* r, uint16* g, uint16* b)
        -: 1728:{
        -: 1729:	(void) tif;
    #####: 1730:	while (n-- > 0)
    #####: 1731:		if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)
    #####: 1732:			return (16);
    #####: 1733:	TIFFWarning(filename, "Assuming 8-bit colormap");
    #####: 1734:	return (8);
        -: 1735:}
        -: 1736:
        -: 1737:static void
    #####: 1738:PS_Lvl2colorspace(FILE* fd, TIFF* tif)
        -: 1739:{
    #####: 1740:	uint16 *rmap, *gmap, *bmap;
        -: 1741:	int i, num_colors;
        -: 1742:	const char * colorspace_p;
        -: 1743:
    #####: 1744:	switch ( photometric )
        -: 1745:	{
    #####: 1746:	case PHOTOMETRIC_SEPARATED:
    #####: 1747:		colorspace_p = "CMYK";
    #####: 1748:		break;
        -: 1749:
    #####: 1750:	case PHOTOMETRIC_RGB:
    #####: 1751:		colorspace_p = "RGB";
    #####: 1752:		break;
        -: 1753:
    #####: 1754:	default:
    #####: 1755:		colorspace_p = "Gray";
        -: 1756:	}
        -: 1757:
        -: 1758:	/*
        -: 1759:	 * Set up PostScript Level 2 colorspace according to
        -: 1760:	 * section 4.8 in the PostScript refenence manual.
        -: 1761:	 */
    #####: 1762:	fputs("% PostScript Level 2 only.\n", fd);
    #####: 1763:	if (photometric != PHOTOMETRIC_PALETTE) {
    #####: 1764:		if (photometric == PHOTOMETRIC_YCBCR) {
        -: 1765:		    /* MORE CODE HERE */
        -: 1766:		}
    #####: 1767:		fprintf(fd, "/Device%s setcolorspace\n", colorspace_p );
    #####: 1768:		return;
        -: 1769:	}
        -: 1770:
        -: 1771:	/*
        -: 1772:	 * Set up an indexed/palette colorspace
        -: 1773:	 */
    #####: 1774:	num_colors = (1 << bitspersample);
    #####: 1775:	if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {
    #####: 1776:		TIFFError(filename,
        -: 1777:			"Palette image w/o \"Colormap\" tag");
    #####: 1778:		return;
        -: 1779:	}
    #####: 1780:	if (checkcmap(tif, num_colors, rmap, gmap, bmap) == 16) {
        -: 1781:		/*
        -: 1782:		 * Convert colormap to 8-bits values.
        -: 1783:		 */
        -: 1784:#define	CVT(x)		(((x) * 255) / ((1L<<16)-1))
    #####: 1785:		for (i = 0; i < num_colors; i++) {
    #####: 1786:			rmap[i] = CVT(rmap[i]);
    #####: 1787:			gmap[i] = CVT(gmap[i]);
    #####: 1788:			bmap[i] = CVT(bmap[i]);
        -: 1789:		}
        -: 1790:#undef CVT
        -: 1791:	}
    #####: 1792:	fprintf(fd, "[ /Indexed /DeviceRGB %d", num_colors - 1);
    #####: 1793:	if (ascii85) {
    #####: 1794:		Ascii85Init();
    #####: 1795:		fputs("\n<~", fd);
    #####: 1796:		ascii85breaklen -= 2;
        -: 1797:	} else
    #####: 1798:		fputs(" <", fd);
    #####: 1799:	for (i = 0; i < num_colors; i++) {
    #####: 1800:		if (ascii85) {
    #####: 1801:			Ascii85Put((unsigned char)rmap[i], fd);
    #####: 1802:			Ascii85Put((unsigned char)gmap[i], fd);
    #####: 1803:			Ascii85Put((unsigned char)bmap[i], fd);
        -: 1804:		} else {
    #####: 1805:			fputs((i % 8) ? " " : "\n  ", fd);
    #####: 1806:			fprintf(fd, "%02x%02x%02x",
    #####: 1807:			    rmap[i], gmap[i], bmap[i]);
        -: 1808:		}
        -: 1809:	}
    #####: 1810:	if (ascii85)
    #####: 1811:		Ascii85Flush(fd);
        -: 1812:	else
    #####: 1813:		fputs(">\n", fd);
    #####: 1814:	fputs("] setcolorspace\n", fd);
        -: 1815:}
        -: 1816:
        -: 1817:static int
    #####: 1818:PS_Lvl2ImageDict(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 1819:{
        -: 1820:	int use_rawdata;
    #####: 1821:	uint32 tile_width, tile_height;
    #####: 1822:	uint16 predictor, minsamplevalue, maxsamplevalue;
        -: 1823:	int repeat_count;
    #####: 1824:	char im_h[64], im_x[64], im_y[64];
    #####: 1825:	char * imageOp = "image";
        -: 1826:
    #####: 1827:	if ( useImagemask && (bitspersample == 1) )
    #####: 1828:		imageOp = "imagemask";
        -: 1829:
    #####: 1830:	(void)strcpy(im_x, "0");
    #####: 1831:	(void)snprintf(im_y, sizeof(im_y), "%lu", (long) h);
    #####: 1832:	(void)snprintf(im_h, sizeof(im_h), "%lu", (long) h);
    #####: 1833:	tile_width = w;
    #####: 1834:	tile_height = h;
    #####: 1835:	if (TIFFIsTiled(tif)) {
    #####: 1836:		repeat_count = TIFFNumberOfTiles(tif);
    #####: 1837:		TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);
    #####: 1838:		TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);
    #####: 1839:		if (tile_width > w || tile_height > h ||
    #####: 1840:		    (w % tile_width) != 0 || (h % tile_height != 0)) {
        -: 1841:			/*
        -: 1842:			 * The tiles does not fit image width and height.
        -: 1843:			 * Set up a clip rectangle for the image unit square.
        -: 1844:			 */
    #####: 1845:			fputs("0 0 1 1 rectclip\n", fd);
        -: 1846:		}
    #####: 1847:		if (tile_width < w) {
    #####: 1848:			fputs("/im_x 0 def\n", fd);
    #####: 1849:			(void)strcpy(im_x, "im_x neg");
        -: 1850:		}
    #####: 1851:		if (tile_height < h) {
    #####: 1852:			fputs("/im_y 0 def\n", fd);
    #####: 1853:			(void)snprintf(im_y, sizeof(im_y), "%lu im_y sub", (unsigned long) h);
        -: 1854:		}
        -: 1855:	} else {
    #####: 1856:		repeat_count = tf_numberstrips;
    #####: 1857:		tile_height = tf_rowsperstrip;
    #####: 1858:		if (tile_height > h)
    #####: 1859:			tile_height = h;
    #####: 1860:		if (repeat_count > 1) {
    #####: 1861:			fputs("/im_y 0 def\n", fd);
    #####: 1862:			fprintf(fd, "/im_h %lu def\n",
        -: 1863:			    (unsigned long) tile_height);
    #####: 1864:			(void)strcpy(im_h, "im_h");
    #####: 1865:			(void)snprintf(im_y, sizeof(im_y), "%lu im_y sub", (unsigned long) h);
        -: 1866:		}
        -: 1867:	}
        -: 1868:
        -: 1869:	/*
        -: 1870:	 * Output start of exec block
        -: 1871:	 */
    #####: 1872:	fputs("{ % exec\n", fd);
        -: 1873:
    #####: 1874:	if (repeat_count > 1)
    #####: 1875:		fprintf(fd, "%d { %% repeat\n", repeat_count);
        -: 1876:
        -: 1877:	/*
        -: 1878:	 * Output filter options and image dictionary.
        -: 1879:	 */
    #####: 1880:	if (ascii85)
    #####: 1881:		fputs(" /im_stream currentfile /ASCII85Decode filter def\n",
        -: 1882:		    fd);
    #####: 1883:	fputs(" <<\n", fd);
    #####: 1884:	fputs("  /ImageType 1\n", fd);
    #####: 1885:	fprintf(fd, "  /Width %lu\n", (unsigned long) tile_width);
        -: 1886:	/*
        -: 1887:	 * Workaround for some software that may crash when last strip
        -: 1888:	 * of image contains fewer number of scanlines than specified
        -: 1889:	 * by the `/Height' variable. So for stripped images with multiple
        -: 1890:	 * strips we will set `/Height' as `im_h', because one is 
        -: 1891:	 * recalculated for each strip - including the (smaller) final strip.
        -: 1892:	 * For tiled images and images with only one strip `/Height' will
        -: 1893:	 * contain number of scanlines in tile (or image height in case of
        -: 1894:	 * one-stripped image).
        -: 1895:	 */
    #####: 1896:	if (TIFFIsTiled(tif) || tf_numberstrips == 1)
    #####: 1897:		fprintf(fd, "  /Height %lu\n", (unsigned long) tile_height);
        -: 1898:	else
    #####: 1899:		fprintf(fd, "  /Height im_h\n");
        -: 1900:	
    #####: 1901:	if (planarconfiguration == PLANARCONFIG_SEPARATE && samplesperpixel > 1)
    #####: 1902:		fputs("  /MultipleDataSources true\n", fd);
    #####: 1903:	fprintf(fd, "  /ImageMatrix [ %lu 0 0 %ld %s %s ]\n",
    #####: 1904:	    (unsigned long) w, - (long)h, im_x, im_y);
    #####: 1905:	fprintf(fd, "  /BitsPerComponent %d\n", bitspersample);
    #####: 1906:	fprintf(fd, "  /Interpolate %s\n", interpolate ? "true" : "false");
        -: 1907:
    #####: 1908:	switch (samplesperpixel - extrasamples) {
    #####: 1909:	case 1:
    #####: 1910:		switch (photometric) {
    #####: 1911:		case PHOTOMETRIC_MINISBLACK:
    #####: 1912:			fputs("  /Decode [0 1]\n", fd);
    #####: 1913:			break;
    #####: 1914:		case PHOTOMETRIC_MINISWHITE:
    #####: 1915:			switch (compression) {
    #####: 1916:			case COMPRESSION_CCITTRLE:
        -: 1917:			case COMPRESSION_CCITTRLEW:
        -: 1918:			case COMPRESSION_CCITTFAX3:
        -: 1919:			case COMPRESSION_CCITTFAX4:
        -: 1920:				/*
        -: 1921:				 * Manage inverting with /Blackis1 flag
        -: 1922:				 * since there migth be uncompressed parts
        -: 1923:				 */
    #####: 1924:				fputs("  /Decode [0 1]\n", fd);
    #####: 1925:				break;
    #####: 1926:			default:
        -: 1927:				/*
        -: 1928:				 * ERROR...
        -: 1929:				 */
    #####: 1930:				fputs("  /Decode [1 0]\n", fd);
    #####: 1931:				break;
        -: 1932:			}
    #####: 1933:			break;
    #####: 1934:		case PHOTOMETRIC_PALETTE:
    #####: 1935:			TIFFGetFieldDefaulted(tif, TIFFTAG_MINSAMPLEVALUE,
        -: 1936:			    &minsamplevalue);
    #####: 1937:			TIFFGetFieldDefaulted(tif, TIFFTAG_MAXSAMPLEVALUE,
        -: 1938:			    &maxsamplevalue);
    #####: 1939:			fprintf(fd, "  /Decode [%u %u]\n",
        -: 1940:				    minsamplevalue, maxsamplevalue);
    #####: 1941:			break;
    #####: 1942:		default:
        -: 1943:			/*
        -: 1944:			 * ERROR ?
        -: 1945:			 */
    #####: 1946:			fputs("  /Decode [0 1]\n", fd);
    #####: 1947:			break;
        -: 1948:		}
    #####: 1949:		break;
    #####: 1950:	case 3:
    #####: 1951:		switch (photometric) {
    #####: 1952:		case PHOTOMETRIC_RGB:
    #####: 1953:			fputs("  /Decode [0 1 0 1 0 1]\n", fd);
    #####: 1954:			break;
    #####: 1955:		case PHOTOMETRIC_MINISWHITE:
        -: 1956:		case PHOTOMETRIC_MINISBLACK:
        -: 1957:		default:
        -: 1958:			/*
        -: 1959:			 * ERROR??
        -: 1960:			 */
    #####: 1961:			fputs("  /Decode [0 1 0 1 0 1]\n", fd);
    #####: 1962:			break;
        -: 1963:		}
    #####: 1964:		break;
    #####: 1965:	case 4:
        -: 1966:		/*
        -: 1967:		 * ERROR??
        -: 1968:		 */
    #####: 1969:		fputs("  /Decode [0 1 0 1 0 1 0 1]\n", fd);
    #####: 1970:		break;
        -: 1971:	}
    #####: 1972:	fputs("  /DataSource", fd);
    #####: 1973:	if (planarconfiguration == PLANARCONFIG_SEPARATE &&
    #####: 1974:	    samplesperpixel > 1)
    #####: 1975:		fputs(" [", fd);
    #####: 1976:	if (ascii85)
    #####: 1977:		fputs(" im_stream", fd);
        -: 1978:	else
    #####: 1979:		fputs(" currentfile /ASCIIHexDecode filter", fd);
        -: 1980:
    #####: 1981:	use_rawdata = TRUE;
    #####: 1982:	switch (compression) {
    #####: 1983:	case COMPRESSION_NONE:		/* 1: uncompressed */
    #####: 1984:		break;
    #####: 1985:	case COMPRESSION_CCITTRLE:	/* 2: CCITT modified Huffman RLE */
        -: 1986:	case COMPRESSION_CCITTRLEW:	/* 32771: #1 w/ word alignment */
        -: 1987:	case COMPRESSION_CCITTFAX3:	/* 3: CCITT Group 3 fax encoding */
        -: 1988:	case COMPRESSION_CCITTFAX4:	/* 4: CCITT Group 4 fax encoding */
    #####: 1989:		fputs("\n\t<<\n", fd);
    #####: 1990:		if (compression == COMPRESSION_CCITTFAX3) {
    #####: 1991:			uint32 g3_options;
        -: 1992:
    #####: 1993:			fputs("\t /EndOfLine true\n", fd);
    #####: 1994:			fputs("\t /EndOfBlock false\n", fd);
    #####: 1995:			if (!TIFFGetField(tif, TIFFTAG_GROUP3OPTIONS,
        -: 1996:					    &g3_options))
    #####: 1997:				g3_options = 0;
    #####: 1998:			if (g3_options & GROUP3OPT_2DENCODING)
    #####: 1999:				fprintf(fd, "\t /K %s\n", im_h);
    #####: 2000:			if (g3_options & GROUP3OPT_UNCOMPRESSED)
    #####: 2001:				fputs("\t /Uncompressed true\n", fd);
    #####: 2002:			if (g3_options & GROUP3OPT_FILLBITS)
    #####: 2003:				fputs("\t /EncodedByteAlign true\n", fd);
        -: 2004:		}
    #####: 2005:		if (compression == COMPRESSION_CCITTFAX4) {
    #####: 2006:			uint32 g4_options;
        -: 2007:
    #####: 2008:			fputs("\t /K -1\n", fd);
    #####: 2009:			TIFFGetFieldDefaulted(tif, TIFFTAG_GROUP4OPTIONS,
        -: 2010:					       &g4_options);
    #####: 2011:			if (g4_options & GROUP4OPT_UNCOMPRESSED)
    #####: 2012:				fputs("\t /Uncompressed true\n", fd);
        -: 2013:		}
    #####: 2014:		if (!(tile_width == w && w == 1728U))
    #####: 2015:			fprintf(fd, "\t /Columns %lu\n",
        -: 2016:			    (unsigned long) tile_width);
    #####: 2017:		fprintf(fd, "\t /Rows %s\n", im_h);
    #####: 2018:		if (compression == COMPRESSION_CCITTRLE ||
    #####: 2019:		    compression == COMPRESSION_CCITTRLEW) {
    #####: 2020:			fputs("\t /EncodedByteAlign true\n", fd);
    #####: 2021:			fputs("\t /EndOfBlock false\n", fd);
        -: 2022:		}
    #####: 2023:		if (photometric == PHOTOMETRIC_MINISBLACK)
    #####: 2024:			fputs("\t /BlackIs1 true\n", fd);
    #####: 2025:		fprintf(fd, "\t>> /CCITTFaxDecode filter");
    #####: 2026:		break;
    #####: 2027:	case COMPRESSION_LZW:	/* 5: Lempel-Ziv & Welch */
    #####: 2028:		TIFFGetFieldDefaulted(tif, TIFFTAG_PREDICTOR, &predictor);
    #####: 2029:		if (predictor == 2) {
    #####: 2030:			fputs("\n\t<<\n", fd);
    #####: 2031:			fprintf(fd, "\t /Predictor %u\n", predictor);
    #####: 2032:			fprintf(fd, "\t /Columns %lu\n",
        -: 2033:			    (unsigned long) tile_width);
    #####: 2034:			fprintf(fd, "\t /Colors %u\n", samplesperpixel);
    #####: 2035:			fprintf(fd, "\t /BitsPerComponent %u\n",
        -: 2036:			    bitspersample);
    #####: 2037:			fputs("\t>>", fd);
        -: 2038:		}
    #####: 2039:		fputs(" /LZWDecode filter", fd);
    #####: 2040:		break;
    #####: 2041:	case COMPRESSION_DEFLATE:	/* 5: ZIP */
        -: 2042:	case COMPRESSION_ADOBE_DEFLATE:
    #####: 2043:		if ( level3 ) {
    #####: 2044:			 TIFFGetFieldDefaulted(tif, TIFFTAG_PREDICTOR, &predictor);
    #####: 2045:			 if (predictor > 1) {
    #####: 2046:				fprintf(fd, "\t %% PostScript Level 3 only.");
    #####: 2047:				fputs("\n\t<<\n", fd);
    #####: 2048:				fprintf(fd, "\t /Predictor %u\n", predictor);
    #####: 2049:				fprintf(fd, "\t /Columns %lu\n",
        -: 2050:					(unsigned long) tile_width);
    #####: 2051:				fprintf(fd, "\t /Colors %u\n", samplesperpixel);
    #####: 2052:					fprintf(fd, "\t /BitsPerComponent %u\n",
        -: 2053:					bitspersample);
    #####: 2054:				fputs("\t>>", fd);
        -: 2055:			 }
    #####: 2056:			 fputs(" /FlateDecode filter", fd);
        -: 2057:		} else {
    #####: 2058:			use_rawdata = FALSE ;
        -: 2059:		}
    #####: 2060:		break;
    #####: 2061:	case COMPRESSION_PACKBITS:	/* 32773: Macintosh RLE */
    #####: 2062:		fputs(" /RunLengthDecode filter", fd);
    #####: 2063:		use_rawdata = TRUE;
    #####: 2064:	    break;
    #####: 2065:	case COMPRESSION_OJPEG:		/* 6: !6.0 JPEG */
        -: 2066:	case COMPRESSION_JPEG:		/* 7: %JPEG DCT compression */
        -: 2067:#ifdef notdef
        -: 2068:		/*
        -: 2069:		 * Code not tested yet
        -: 2070:		 */
        -: 2071:		fputs(" /DCTDecode filter", fd);
        -: 2072:		use_rawdata = TRUE;
        -: 2073:#else
    #####: 2074:		use_rawdata = FALSE;
        -: 2075:#endif
    #####: 2076:		break;
    #####: 2077:	case COMPRESSION_NEXT:		/* 32766: NeXT 2-bit RLE */
        -: 2078:	case COMPRESSION_THUNDERSCAN:	/* 32809: ThunderScan RLE */
        -: 2079:	case COMPRESSION_PIXARFILM:	/* 32908: Pixar companded 10bit LZW */
        -: 2080:	case COMPRESSION_JBIG:		/* 34661: ISO JBIG */
    #####: 2081:		use_rawdata = FALSE;
    #####: 2082:		break;
    #####: 2083:	case COMPRESSION_SGILOG:	/* 34676: SGI LogL or LogLuv */
        -: 2084:	case COMPRESSION_SGILOG24:	/* 34677: SGI 24-bit LogLuv */
    #####: 2085:		use_rawdata = FALSE;
    #####: 2086:		break;
    #####: 2087:	default:
        -: 2088:		/*
        -: 2089:		 * ERROR...
        -: 2090:		 */
    #####: 2091:		use_rawdata = FALSE;
    #####: 2092:		break;
        -: 2093:	}
    #####: 2094:	if (planarconfiguration == PLANARCONFIG_SEPARATE &&
    #####: 2095:	    samplesperpixel > 1) {
        -: 2096:		uint16 i;
        -: 2097:
        -: 2098:		/*
        -: 2099:		 * NOTE: This code does not work yet...
        -: 2100:		 */
    #####: 2101:		for (i = 1; i < samplesperpixel; i++)
    #####: 2102:			fputs(" dup", fd);
    #####: 2103:		fputs(" ]", fd);
        -: 2104:	}
        -: 2105:
    #####: 2106:	fprintf( fd, "\n >> %s\n", imageOp );
    #####: 2107:	if (ascii85)
    #####: 2108:		fputs(" im_stream status { im_stream flushfile } if\n", fd);
    #####: 2109:	if (repeat_count > 1) {
    #####: 2110:		if (tile_width < w) {
    #####: 2111:			fprintf(fd, " /im_x im_x %lu add def\n",
        -: 2112:			    (unsigned long) tile_width);
    #####: 2113:			if (tile_height < h) {
    #####: 2114:				fprintf(fd, " im_x %lu ge {\n",
        -: 2115:				    (unsigned long) w);
    #####: 2116:				fputs("  /im_x 0 def\n", fd);
    #####: 2117:				fprintf(fd, " /im_y im_y %lu add def\n",
        -: 2118:				    (unsigned long) tile_height);
    #####: 2119:				fputs(" } if\n", fd);
        -: 2120:			}
        -: 2121:		}
    #####: 2122:		if (tile_height < h) {
    #####: 2123:			if (tile_width >= w) {
    #####: 2124:				fprintf(fd, " /im_y im_y %lu add def\n",
        -: 2125:				    (unsigned long) tile_height);
    #####: 2126:				if (!TIFFIsTiled(tif)) {
    #####: 2127:					fprintf(fd, " /im_h %lu im_y sub",
        -: 2128:					    (unsigned long) h);
    #####: 2129:					fprintf(fd, " dup %lu gt { pop",
        -: 2130:					    (unsigned long) tile_height);
    #####: 2131:					fprintf(fd, " %lu } if def\n",
        -: 2132:					    (unsigned long) tile_height);
        -: 2133:				}
        -: 2134:			}
        -: 2135:		}
    #####: 2136:		fputs("} repeat\n", fd);
        -: 2137:	}
        -: 2138:	/*
        -: 2139:	 * End of exec function
        -: 2140:	 */
    #####: 2141:	fputs("}\n", fd);
        -: 2142:
    #####: 2143:	return(use_rawdata);
        -: 2144:}
        -: 2145:
        -: 2146:/* Flip the byte order of buffers with 16 bit samples */
        -: 2147:static void
    #####: 2148:PS_FlipBytes(unsigned char* buf, tsize_t count)
        -: 2149:{
        -: 2150:	int i;
        -: 2151:	unsigned char temp;
        -: 2152:
    #####: 2153:	if (count <= 0 || bitspersample <= 8) {
    #####: 2154:		return;
        -: 2155:	}
        -: 2156:
    #####: 2157:	count--;
        -: 2158:
    #####: 2159:	for (i = 0; i < count; i += 2) {
    #####: 2160:		temp = buf[i];
    #####: 2161:		buf[i] = buf[i + 1];
    #####: 2162:		buf[i + 1] = temp;
        -: 2163:	}
        -: 2164:}
        -: 2165:
        -: 2166:#define MAXLINE		36
        -: 2167:
        -: 2168:int
    #####: 2169:PS_Lvl2page(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 2170:{
    #####: 2171:	uint16 fillorder;
    #####: 2172:	int use_rawdata, tiled_image, breaklen = MAXLINE;
        -: 2173:	uint32 chunk_no, num_chunks;
    #####: 2174:        uint64 *bc;
        -: 2175:	unsigned char *buf_data, *cp;
        -: 2176:	tsize_t chunk_size, byte_count;
        -: 2177:
        -: 2178:#if defined( EXP_ASCII85ENCODER )
        -: 2179:	tsize_t			ascii85_l;	/* Length, in bytes, of ascii85_p[] data */
    #####: 2180:	uint8		*	ascii85_p = 0;	/* Holds ASCII85 encoded data */
        -: 2181:#endif
        -: 2182:
    #####: 2183:	PS_Lvl2colorspace(fd, tif);
    #####: 2184:	use_rawdata = PS_Lvl2ImageDict(fd, tif, w, h);
        -: 2185:
        -: 2186:/* See http://bugzilla.remotesensing.org/show_bug.cgi?id=80 */
        -: 2187:#ifdef ENABLE_BROKEN_BEGINENDDATA
        -: 2188:	fputs("%%BeginData:\n", fd);
        -: 2189:#endif
    #####: 2190:	fputs("exec\n", fd);
        -: 2191:
    #####: 2192:	tiled_image = TIFFIsTiled(tif);
    #####: 2193:	if (tiled_image) {
    #####: 2194:		num_chunks = TIFFNumberOfTiles(tif);
    #####: 2195:		TIFFGetField(tif, TIFFTAG_TILEBYTECOUNTS, &bc);
        -: 2196:	} else {
    #####: 2197:		num_chunks = TIFFNumberOfStrips(tif);
    #####: 2198:		TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);
        -: 2199:	}
        -: 2200:
    #####: 2201:	if (use_rawdata) {
    #####: 2202:		chunk_size = (tsize_t) bc[0];
    #####: 2203:		for (chunk_no = 1; chunk_no < num_chunks; chunk_no++)
    #####: 2204:			if ((tsize_t) bc[chunk_no] > chunk_size)
    #####: 2205:				chunk_size = (tsize_t) bc[chunk_no];
        -: 2206:	} else {
    #####: 2207:		if (tiled_image)
    #####: 2208:			chunk_size = TIFFTileSize(tif);
        -: 2209:		else
    #####: 2210:			chunk_size = TIFFStripSize(tif);
        -: 2211:	}
    #####: 2212:	buf_data = (unsigned char *)_TIFFmalloc(chunk_size);
    #####: 2213:	if (!buf_data) {
    #####: 2214:		TIFFError(filename, "Can't alloc %lu bytes for %s.",
        -: 2215:			(unsigned long) chunk_size, tiled_image ? "tiles" : "strips");
    #####: 2216:		return(FALSE);
        -: 2217:	}
        -: 2218:
        -: 2219:#if defined( EXP_ASCII85ENCODER )
    #####: 2220:	if ( ascii85 ) {
        -: 2221:	    /*
        -: 2222:	     * Allocate a buffer to hold the ASCII85 encoded data.  Note
        -: 2223:	     * that it is allocated with sufficient room to hold the
        -: 2224:	     * encoded data (5*chunk_size/4) plus the EOD marker (+8)
        -: 2225:	     * and formatting line breaks.  The line breaks are more
        -: 2226:	     * than taken care of by using 6*chunk_size/4 rather than
        -: 2227:	     * 5*chunk_size/4.
        -: 2228:	     */
        -: 2229:
    #####: 2230:	    ascii85_p = _TIFFmalloc( (chunk_size+(chunk_size/2)) + 8 );
        -: 2231:
    #####: 2232:	    if ( !ascii85_p ) {
    #####: 2233:		_TIFFfree( buf_data );
        -: 2234:
    #####: 2235:		TIFFError( filename, "Cannot allocate ASCII85 encoding buffer." );
    #####: 2236:		return ( FALSE );
        -: 2237:	    }
        -: 2238:	}
        -: 2239:#endif
        -: 2240:
    #####: 2241:	TIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);
    #####: 2242:	for (chunk_no = 0; chunk_no < num_chunks; chunk_no++) {
    #####: 2243:		if (ascii85)
    #####: 2244:			Ascii85Init();
        -: 2245:		else
    #####: 2246:			breaklen = MAXLINE;
    #####: 2247:		if (use_rawdata) {
    #####: 2248:			if (tiled_image)
    #####: 2249:				byte_count = TIFFReadRawTile(tif, chunk_no,
        -: 2250:						  buf_data, chunk_size);
        -: 2251:			else
    #####: 2252:				byte_count = TIFFReadRawStrip(tif, chunk_no,
        -: 2253:						  buf_data, chunk_size);
    #####: 2254:			if (fillorder == FILLORDER_LSB2MSB)
    #####: 2255:			    TIFFReverseBits(buf_data, byte_count);
        -: 2256:		} else {
    #####: 2257:			if (tiled_image)
    #####: 2258:				byte_count = TIFFReadEncodedTile(tif,
        -: 2259:						chunk_no, buf_data,
        -: 2260:						chunk_size);
        -: 2261:			else
    #####: 2262:				byte_count = TIFFReadEncodedStrip(tif,
        -: 2263:						chunk_no, buf_data,
        -: 2264:						chunk_size);
        -: 2265:		}
    #####: 2266:		if (byte_count < 0) {
    #####: 2267:			TIFFError(filename, "Can't read %s %d.",
        -: 2268:				tiled_image ? "tile" : "strip", chunk_no);
    #####: 2269:			if (ascii85)
    #####: 2270:				Ascii85Put('\0', fd);
        -: 2271:		}
        -: 2272:		/*
        -: 2273:		 * for 16 bits, the two bytes must be most significant
        -: 2274:		 * byte first
        -: 2275:		 */
    #####: 2276:		if (bitspersample == 16 && !TIFFIsBigEndian(tif)) {
    #####: 2277:			PS_FlipBytes(buf_data, byte_count);
        -: 2278:		}
        -: 2279:		/*
        -: 2280:		 * For images with alpha, matte against a white background;
        -: 2281:		 * i.e. Cback * (1 - Aimage) where Cback = 1. We will fill the
        -: 2282:		 * lower part of the buffer with the modified values.
        -: 2283:		 *
        -: 2284:		 * XXX: needs better solution
        -: 2285:		 */
    #####: 2286:		if (alpha) {
    #####: 2287:			int adjust, i, j = 0;
    #####: 2288:			int ncomps = samplesperpixel - extrasamples;
    #####: 2289:			for (i = 0; i < byte_count; i+=samplesperpixel) {
    #####: 2290:				adjust = 255 - buf_data[i + ncomps];
    #####: 2291:				switch (ncomps) {
    #####: 2292:					case 1:
    #####: 2293:						buf_data[j++] = buf_data[i] + adjust;
    #####: 2294:						break;
    #####: 2295:					case 2:
    #####: 2296:						buf_data[j++] = buf_data[i] + adjust;
    #####: 2297:						buf_data[j++] = buf_data[i+1] + adjust;
    #####: 2298:						break;
    #####: 2299:					case 3:
    #####: 2300:						buf_data[j++] = buf_data[i] + adjust;
    #####: 2301:						buf_data[j++] = buf_data[i+1] + adjust;
    #####: 2302:						buf_data[j++] = buf_data[i+2] + adjust;
    #####: 2303:						break;
        -: 2304:				}
    #####: 2305:			}
    #####: 2306:			byte_count -= j;
        -: 2307:		}
        -: 2308:
    #####: 2309:		if (ascii85) {
        -: 2310:#if defined( EXP_ASCII85ENCODER )
    #####: 2311:			ascii85_l = Ascii85EncodeBlock(ascii85_p, 1, buf_data, byte_count );
        -: 2312:
    #####: 2313:			if ( ascii85_l > 0 )
    #####: 2314:				fwrite( ascii85_p, ascii85_l, 1, fd );
        -: 2315:#else
        -: 2316:			for (cp = buf_data; byte_count > 0; byte_count--)
        -: 2317:				Ascii85Put(*cp++, fd);
        -: 2318:#endif
        -: 2319:		}
        -: 2320:		else
        -: 2321:		{
    #####: 2322:			for (cp = buf_data; byte_count > 0; byte_count--) {
    #####: 2323:				putc(hex[((*cp)>>4)&0xf], fd);
    #####: 2324:				putc(hex[(*cp)&0xf], fd);
    #####: 2325:				cp++;
        -: 2326:
    #####: 2327:				if (--breaklen <= 0) {
    #####: 2328:					putc('\n', fd);
    #####: 2329:					breaklen = MAXLINE;
        -: 2330:				}
        -: 2331:			}
        -: 2332:		}
        -: 2333:
    #####: 2334:		if ( !ascii85 ) {
    #####: 2335:			if ( level2 || level3 )
    #####: 2336:				putc( '>', fd );
    #####: 2337:			putc('\n', fd);
        -: 2338:		}
        -: 2339:#if !defined( EXP_ASCII85ENCODER )
        -: 2340:		else
        -: 2341:			Ascii85Flush(fd);
        -: 2342:#endif
        -: 2343:	}
        -: 2344:
        -: 2345:#if defined( EXP_ASCII85ENCODER )
    #####: 2346:	if ( ascii85_p )
    #####: 2347:	    _TIFFfree( ascii85_p );
        -: 2348:#endif
        -: 2349:       
    #####: 2350:	_TIFFfree(buf_data);
        -: 2351:#ifdef ENABLE_BROKEN_BEGINENDDATA
        -: 2352:	fputs("%%EndData\n", fd);
        -: 2353:#endif
    #####: 2354:	return(TRUE);
        -: 2355:}
        -: 2356:
        -: 2357:void
        1: 2358:PSpage(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 2359:{
        1: 2360:	char	*	imageOp = "image";
        -: 2361:
       1*: 2362:	if ( useImagemask && (bitspersample == 1) )
    #####: 2363:		imageOp = "imagemask";
        -: 2364:
       1*: 2365:	if ((level2 || level3) && PS_Lvl2page(fd, tif, w, h))
    #####: 2366:		return;
        1: 2367:	ps_bytesperrow = tf_bytesperrow - (extrasamples * bitspersample / 8)*w;
        1: 2368:	switch (photometric) {
        1: 2369:	case PHOTOMETRIC_RGB:
        1: 2370:		if (planarconfiguration == PLANARCONFIG_CONTIG) {
       1*: 2371:			fprintf(fd, "%s", RGBcolorimage);
        1: 2372:			PSColorContigPreamble(fd, w, h, 3);
        1: 2373:			PSDataColorContig(fd, tif, w, h, 3);
        -: 2374:		} else {
    #####: 2375:			PSColorSeparatePreamble(fd, w, h, 3);
    #####: 2376:			PSDataColorSeparate(fd, tif, w, h, 3);
        -: 2377:		}
    #####: 2378:		break;
    #####: 2379:	case PHOTOMETRIC_SEPARATED:
        -: 2380:		/* XXX should emit CMYKcolorimage */
    #####: 2381:		if (planarconfiguration == PLANARCONFIG_CONTIG) {
    #####: 2382:			PSColorContigPreamble(fd, w, h, 4);
    #####: 2383:			PSDataColorContig(fd, tif, w, h, 4);
        -: 2384:		} else {
    #####: 2385:			PSColorSeparatePreamble(fd, w, h, 4);
    #####: 2386:			PSDataColorSeparate(fd, tif, w, h, 4);
        -: 2387:		}
    #####: 2388:		break;
    #####: 2389:	case PHOTOMETRIC_PALETTE:
    #####: 2390:		fprintf(fd, "%s", RGBcolorimage);
    #####: 2391:		PhotoshopBanner(fd, w, h, 1, 3, "false 3 colorimage");
    #####: 2392:		fprintf(fd, "/scanLine %ld string def\n",
    #####: 2393:		    (long) ps_bytesperrow * 3L);
    #####: 2394:		fprintf(fd, "%lu %lu 8\n",
        -: 2395:		    (unsigned long) w, (unsigned long) h);
    #####: 2396:		fprintf(fd, "[%lu 0 0 -%lu 0 %lu]\n",
        -: 2397:		    (unsigned long) w, (unsigned long) h, (unsigned long) h);
    #####: 2398:		fprintf(fd, "{currentfile scanLine readhexstring pop} bind\n");
    #####: 2399:		fprintf(fd, "false 3 colorimage\n");
    #####: 2400:		PSDataPalette(fd, tif, w, h);
    #####: 2401:		break;
    #####: 2402:	case PHOTOMETRIC_MINISBLACK:
        -: 2403:	case PHOTOMETRIC_MINISWHITE:
    #####: 2404:		PhotoshopBanner(fd, w, h, 1, 1, imageOp);
    #####: 2405:		fprintf(fd, "/scanLine %ld string def\n",
        -: 2406:		    (long) ps_bytesperrow);
    #####: 2407:		fprintf(fd, "%lu %lu %d\n",
        -: 2408:		    (unsigned long) w, (unsigned long) h, bitspersample);
    #####: 2409:		fprintf(fd, "[%lu 0 0 -%lu 0 %lu]\n",
        -: 2410:		    (unsigned long) w, (unsigned long) h, (unsigned long) h);
    #####: 2411:		fprintf(fd,
        -: 2412:		    "{currentfile scanLine readhexstring pop} bind\n");
    #####: 2413:		fprintf(fd, "%s\n", imageOp);
    #####: 2414:		PSDataBW(fd, tif, w, h);
    #####: 2415:		break;
        -: 2416:	}
    #####: 2417:	putc('\n', fd);
        -: 2418:}
        -: 2419:
        -: 2420:void
        1: 2421:PSColorContigPreamble(FILE* fd, uint32 w, uint32 h, int nc)
        -: 2422:{
       1*: 2423:	ps_bytesperrow = nc * (tf_bytesperrow / samplesperpixel);
        1: 2424:	PhotoshopBanner(fd, w, h, 1, nc, "false %d colorimage");
       1*: 2425:	fprintf(fd, "/line %ld string def\n", (long) ps_bytesperrow);
       1*: 2426:	fprintf(fd, "%lu %lu %d\n",
        -: 2427:	    (unsigned long) w, (unsigned long) h, bitspersample);
       1*: 2428:	fprintf(fd, "[%lu 0 0 -%lu 0 %lu]\n",
        -: 2429:	    (unsigned long) w, (unsigned long) h, (unsigned long) h);
       1*: 2430:	fprintf(fd, "{currentfile line readhexstring pop} bind\n");
       1*: 2431:	fprintf(fd, "false %d colorimage\n", nc);
        1: 2432:}
        -: 2433:
        -: 2434:void
    #####: 2435:PSColorSeparatePreamble(FILE* fd, uint32 w, uint32 h, int nc)
        -: 2436:{
        -: 2437:	int i;
        -: 2438:
    #####: 2439:	PhotoshopBanner(fd, w, h, ps_bytesperrow, nc, "true %d colorimage");
    #####: 2440:	for (i = 0; i < nc; i++)
    #####: 2441:		fprintf(fd, "/line%d %ld string def\n",
        -: 2442:		    i, (long) ps_bytesperrow);
    #####: 2443:	fprintf(fd, "%lu %lu %d\n",
        -: 2444:	    (unsigned long) w, (unsigned long) h, bitspersample);
    #####: 2445:	fprintf(fd, "[%lu 0 0 -%lu 0 %lu] \n",
        -: 2446:	    (unsigned long) w, (unsigned long) h, (unsigned long) h);
    #####: 2447:	for (i = 0; i < nc; i++)
    #####: 2448:		fprintf(fd, "{currentfile line%d readhexstring pop}bind\n", i);
    #####: 2449:	fprintf(fd, "true %d colorimage\n", nc);
    #####: 2450:}
        -: 2451:
        -: 2452:#define	DOBREAK(len, howmany, fd) \
        -: 2453:	if (((len) -= (howmany)) <= 0) {	\
        -: 2454:		putc('\n', fd);			\
        -: 2455:		(len) = MAXLINE-(howmany);	\
        -: 2456:	}
        -: 2457:#define	PUTHEX(c,fd)	putc(hex[((c)>>4)&0xf],fd); putc(hex[(c)&0xf],fd)
        -: 2458:
        -: 2459:void
        1: 2460:PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
        -: 2461:{
        -: 2462:	uint32 row;
        1: 2463:	int breaklen = MAXLINE, es = samplesperpixel - nc;
        -: 2464:	tsize_t cc;
        -: 2465:	unsigned char *tf_buf;
        -: 2466:	unsigned char *cp, c;
        -: 2467:
        -: 2468:	(void) w;
        1: 2469:	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
        1: 2470:	if (tf_buf == NULL) {
    #####: 2471:		TIFFError(filename, "No space for scanline buffer");
    #####: 2472:		return;
        -: 2473:	}
       1*: 2474:	for (row = 0; row < h; row++) {
        1: 2475:		if (TIFFReadScanline(tif, tf_buf, row, 0) < 0)
    #####: 2476:			break;
        1: 2477:		cp = tf_buf;
        -: 2478:		/*
        -: 2479:		 * for 16 bits, the two bytes must be most significant
        -: 2480:		 * byte first
        -: 2481:		 */
        1: 2482:		if (bitspersample == 16 && !HOST_BIGENDIAN) {
    #####: 2483:			PS_FlipBytes(cp, tf_bytesperrow);
        -: 2484:		}
        1: 2485:		if (alpha) {
        -: 2486:			int adjust;
        1: 2487:			cc = 0;
        2: 2488:			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
       2*: 2489:				DOBREAK(breaklen, nc, fd);
        -: 2490:				/*
        -: 2491:				 * For images with alpha, matte against
        -: 2492:				 * a white background; i.e.
        -: 2493:				 *    Cback * (1 - Aimage)
        -: 2494:				 * where Cback = 1.
        -: 2495:				 */
        2: 2496:				adjust = 255 - cp[nc];
        2: 2497:				switch (nc) {
    #####: 2498:				case 4: c = *cp++ + adjust; PUTHEX(c,fd);
       1*: 2499:				case 3: c = *cp++ + adjust; PUTHEX(c,fd);
       1*: 2500:				case 2: c = *cp++ + adjust; PUTHEX(c,fd);
       1*: 2501:				case 1: c = *cp++ + adjust; PUTHEX(c,fd);
        -: 2502:				}
        2: 2503:				cp += es;
        -: 2504:			}
        -: 2505:		} else {
    #####: 2506:			cc = 0;
    #####: 2507:			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
    #####: 2508:				DOBREAK(breaklen, nc, fd);
    #####: 2509:				switch (nc) {
    #####: 2510:				case 4: c = *cp++; PUTHEX(c,fd);
    #####: 2511:				case 3: c = *cp++; PUTHEX(c,fd);
    #####: 2512:				case 2: c = *cp++; PUTHEX(c,fd);
    #####: 2513:				case 1: c = *cp++; PUTHEX(c,fd);
        -: 2514:				}
    #####: 2515:				cp += es;
        -: 2516:			}
        -: 2517:		}
        -: 2518:	}
    #####: 2519:	_TIFFfree((char *) tf_buf);
        -: 2520:}
        -: 2521:
        -: 2522:void
    #####: 2523:PSDataColorSeparate(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
        -: 2524:{
        -: 2525:	uint32 row;
    #####: 2526:	int breaklen = MAXLINE;
        -: 2527:	tsize_t cc;
        -: 2528:	tsample_t s, maxs;
        -: 2529:	unsigned char *tf_buf;
        -: 2530:	unsigned char *cp, c;
        -: 2531:
        -: 2532:	(void) w;
    #####: 2533:	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
    #####: 2534:	if (tf_buf == NULL) {
    #####: 2535:		TIFFError(filename, "No space for scanline buffer");
    #####: 2536:		return;
        -: 2537:	}
    #####: 2538:	maxs = (samplesperpixel > nc ? nc : samplesperpixel);
    #####: 2539:	for (row = 0; row < h; row++) {
    #####: 2540:		for (s = 0; s < maxs; s++) {
    #####: 2541:			if (TIFFReadScanline(tif, tf_buf, row, s) < 0)
    #####: 2542:				break;
    #####: 2543:			for (cp = tf_buf, cc = 0; cc < tf_bytesperrow; cc++) {
    #####: 2544:				DOBREAK(breaklen, 1, fd);
    #####: 2545:				c = *cp++;
    #####: 2546:				PUTHEX(c,fd);
        -: 2547:			}
        -: 2548:		}
        -: 2549:	}
    #####: 2550:	_TIFFfree((char *) tf_buf);
        -: 2551:}
        -: 2552:
        -: 2553:#define	PUTRGBHEX(c,fd) \
        -: 2554:	PUTHEX(rmap[c],fd); PUTHEX(gmap[c],fd); PUTHEX(bmap[c],fd)
        -: 2555:
        -: 2556:void
    #####: 2557:PSDataPalette(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 2558:{
    #####: 2559:	uint16 *rmap, *gmap, *bmap;
        -: 2560:	uint32 row;
    #####: 2561:	int breaklen = MAXLINE, nc;
        -: 2562:	tsize_t cc;
        -: 2563:	unsigned char *tf_buf;
        -: 2564:	unsigned char *cp, c;
        -: 2565:
        -: 2566:	(void) w;
    #####: 2567:	if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {
    #####: 2568:		TIFFError(filename, "Palette image w/o \"Colormap\" tag");
    #####: 2569:		return;
        -: 2570:	}
    #####: 2571:	switch (bitspersample) {
    #####: 2572:	case 8:	case 4: case 2: case 1:
    #####: 2573:		break;
    #####: 2574:	default:
    #####: 2575:		TIFFError(filename, "Depth %d not supported", bitspersample);
    #####: 2576:		return;
        -: 2577:	}
    #####: 2578:	nc = 3 * (8 / bitspersample);
    #####: 2579:	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
    #####: 2580:	if (tf_buf == NULL) {
    #####: 2581:		TIFFError(filename, "No space for scanline buffer");
    #####: 2582:		return;
        -: 2583:	}
    #####: 2584:	if (checkcmap(tif, 1<<bitspersample, rmap, gmap, bmap) == 16) {
        -: 2585:		int i;
        -: 2586:#define	CVT(x)		((unsigned short) (((x) * 255) / ((1U<<16)-1)))
    #####: 2587:		for (i = (1<<bitspersample)-1; i >= 0; i--) {
    #####: 2588:			rmap[i] = CVT(rmap[i]);
    #####: 2589:			gmap[i] = CVT(gmap[i]);
    #####: 2590:			bmap[i] = CVT(bmap[i]);
        -: 2591:		}
        -: 2592:#undef CVT
        -: 2593:	}
    #####: 2594:	for (row = 0; row < h; row++) {
    #####: 2595:		if (TIFFReadScanline(tif, tf_buf, row, 0) < 0)
    #####: 2596:			break;
    #####: 2597:		for (cp = tf_buf, cc = 0; cc < tf_bytesperrow; cc++) {
    #####: 2598:			DOBREAK(breaklen, nc, fd);
    #####: 2599:			switch (bitspersample) {
    #####: 2600:			case 8:
    #####: 2601:				c = *cp++; PUTRGBHEX(c, fd);
    #####: 2602:				break;
    #####: 2603:			case 4:
    #####: 2604:				c = *cp++; PUTRGBHEX(c&0xf, fd);
    #####: 2605:				c >>= 4;   PUTRGBHEX(c, fd);
    #####: 2606:				break;
    #####: 2607:			case 2:
    #####: 2608:				c = *cp++; PUTRGBHEX(c&0x3, fd);
    #####: 2609:				c >>= 2;   PUTRGBHEX(c&0x3, fd);
    #####: 2610:				c >>= 2;   PUTRGBHEX(c&0x3, fd);
    #####: 2611:				c >>= 2;   PUTRGBHEX(c, fd);
    #####: 2612:				break;
    #####: 2613:			case 1:
    #####: 2614:				c = *cp++; PUTRGBHEX(c&0x1, fd);
    #####: 2615:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2616:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2617:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2618:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2619:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2620:				c >>= 1;   PUTRGBHEX(c&0x1, fd);
    #####: 2621:				c >>= 1;   PUTRGBHEX(c, fd);
    #####: 2622:				break;
        -: 2623:			}
    #####: 2624:		}
        -: 2625:	}
    #####: 2626:	_TIFFfree((char *) tf_buf);
        -: 2627:}
        -: 2628:
        -: 2629:void
    #####: 2630:PSDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 2631:{
    #####: 2632:	int breaklen = MAXLINE;
        -: 2633:	unsigned char* tf_buf;
        -: 2634:	unsigned char* cp;
    #####: 2635:	tsize_t stripsize = TIFFStripSize(tif);
        -: 2636:	tstrip_t s;
        -: 2637:
        -: 2638:#if defined( EXP_ASCII85ENCODER )
        -: 2639:	tsize_t	ascii85_l;		/* Length, in bytes, of ascii85_p[] data */
    #####: 2640:	uint8	*ascii85_p = 0;		/* Holds ASCII85 encoded data */
        -: 2641:#endif
        -: 2642:
        -: 2643:	(void) w; (void) h;
    #####: 2644:	tf_buf = (unsigned char *) _TIFFmalloc(stripsize);
    #####: 2645:	if (tf_buf == NULL) {
    #####: 2646:		TIFFError(filename, "No space for scanline buffer");
    #####: 2647:		return;
        -: 2648:	}
        -: 2649:
        -: 2650:	// FIXME
    #####: 2651:	memset(tf_buf, 0, stripsize);
        -: 2652:
        -: 2653:#if defined( EXP_ASCII85ENCODER )
    #####: 2654:	if ( ascii85 ) {
        -: 2655:	    /*
        -: 2656:	     * Allocate a buffer to hold the ASCII85 encoded data.  Note
        -: 2657:	     * that it is allocated with sufficient room to hold the
        -: 2658:	     * encoded data (5*stripsize/4) plus the EOD marker (+8)
        -: 2659:	     * and formatting line breaks.  The line breaks are more
        -: 2660:	     * than taken care of by using 6*stripsize/4 rather than
        -: 2661:	     * 5*stripsize/4.
        -: 2662:	     */
        -: 2663:
    #####: 2664:	    ascii85_p = _TIFFmalloc( (stripsize+(stripsize/2)) + 8 );
        -: 2665:
    #####: 2666:	    if ( !ascii85_p ) {
    #####: 2667:		_TIFFfree( tf_buf );
        -: 2668:
    #####: 2669:		TIFFError( filename, "Cannot allocate ASCII85 encoding buffer." );
    #####: 2670:		return;
        -: 2671:	    }
        -: 2672:	}
        -: 2673:#endif
        -: 2674:
    #####: 2675:	if (ascii85)
    #####: 2676:		Ascii85Init();
        -: 2677:
    #####: 2678:	for (s = 0; s < TIFFNumberOfStrips(tif); s++) {
    #####: 2679:		tmsize_t cc = TIFFReadEncodedStrip(tif, s, tf_buf, stripsize);
    #####: 2680:		if (cc < 0) {
    #####: 2681:			TIFFError(filename, "Can't read strip");
    #####: 2682:			break;
        -: 2683:		}
    #####: 2684:		cp = tf_buf;
    #####: 2685:		if (photometric == PHOTOMETRIC_MINISWHITE) {
    #####: 2686:			for (cp += cc; --cp >= tf_buf;)
    #####: 2687:				*cp = ~*cp;
    #####: 2688:			cp++;
        -: 2689:		}
        -: 2690:		/*
        -: 2691:		 * for 16 bits, the two bytes must be most significant
        -: 2692:		 * byte first
        -: 2693:		 */
    #####: 2694:		if (bitspersample == 16 && !HOST_BIGENDIAN) {
    #####: 2695:			PS_FlipBytes(cp, cc);
        -: 2696:		}
    #####: 2697:		if (ascii85) {
        -: 2698:#if defined( EXP_ASCII85ENCODER )
    #####: 2699:			if (alpha) {
        -: 2700:				int adjust, i;
    #####: 2701:				for (i = 0; i < cc; i+=2) {
    #####: 2702:					adjust = 255 - cp[i + 1];
    #####: 2703:				    cp[i / 2] = cp[i] + adjust;
        -: 2704:				}
    #####: 2705:				cc /= 2;
        -: 2706:			}
        -: 2707:
    #####: 2708:			ascii85_l = Ascii85EncodeBlock( ascii85_p, 1, cp, cc );
        -: 2709:
    #####: 2710:			if ( ascii85_l > 0 )
    #####: 2711:			    fwrite( ascii85_p, ascii85_l, 1, fd );
        -: 2712:#else
        -: 2713:			while (cc-- > 0)
        -: 2714:				Ascii85Put(*cp++, fd);
        -: 2715:#endif /* EXP_ASCII85_ENCODER */
        -: 2716:		} else {
        -: 2717:			unsigned char c;
        -: 2718:
    #####: 2719:			if (alpha) {
        -: 2720:				int adjust;
    #####: 2721:				while (cc-- > 1) {
    #####: 2722:					DOBREAK(breaklen, 1, fd);
        -: 2723:					/*
        -: 2724:					 * For images with alpha, matte against
        -: 2725:					 * a white background; i.e.
        -: 2726:					 *    Cback * (1 - Aimage)
        -: 2727:					 * where Cback = 1.
        -: 2728:					 */
    #####: 2729:					adjust = 255 - cp[1];
    #####: 2730:					c = *cp++ + adjust; PUTHEX(c,fd);
    #####: 2731:					cp++, cc--;
        -: 2732:				}
        -: 2733:			} else {
    #####: 2734:				while (cc-- > 0) {
    #####: 2735:					c = *cp++;
    #####: 2736:					DOBREAK(breaklen, 1, fd);
    #####: 2737:					PUTHEX(c, fd);
        -: 2738:				}
        -: 2739:			}
        -: 2740:		}
        -: 2741:	}
        -: 2742:
    #####: 2743:	if ( !ascii85 )
        -: 2744:	{
    #####: 2745:	    if ( level2 || level3)
    #####: 2746:		fputs(">\n", fd);
        -: 2747:	}
        -: 2748:#if !defined( EXP_ASCII85ENCODER )
        -: 2749:	else
        -: 2750:	    Ascii85Flush(fd);
        -: 2751:#else
    #####: 2752:	if ( ascii85_p )
    #####: 2753:	    _TIFFfree( ascii85_p );
        -: 2754:#endif
        -: 2755:
    #####: 2756:	_TIFFfree(tf_buf);
        -: 2757:}
        -: 2758:
        -: 2759:void
    #####: 2760:PSRawDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)
        -: 2761:{
    #####: 2762:	uint64 *bc;
        -: 2763:	uint32 bufsize;
    #####: 2764:	int breaklen = MAXLINE;
        -: 2765:	tmsize_t cc;
    #####: 2766:	uint16 fillorder;
        -: 2767:	unsigned char *tf_buf;
        -: 2768:	unsigned char *cp, c;
        -: 2769:	tstrip_t s;
        -: 2770:
        -: 2771:#if defined( EXP_ASCII85ENCODER )
        -: 2772:	tsize_t 		ascii85_l;		/* Length, in bytes, of ascii85_p[] data */
    #####: 2773:	uint8		*	ascii85_p = 0;		/* Holds ASCII85 encoded data */
        -: 2774:#endif
        -: 2775:
        -: 2776:	(void) w; (void) h;
    #####: 2777:	TIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);
    #####: 2778:	TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);
        -: 2779:
        -: 2780:	/*
        -: 2781:	 * Find largest strip:
        -: 2782:	 */
        -: 2783:
    #####: 2784:	bufsize = (uint32) bc[0];
        -: 2785:
    #####: 2786:	for ( s = 0; ++s < (tstrip_t)tf_numberstrips; ) {
    #####: 2787:		if ( bc[s] > bufsize )
    #####: 2788:			bufsize = (uint32) bc[s];
        -: 2789:	}
        -: 2790:
    #####: 2791:	tf_buf = (unsigned char*) _TIFFmalloc(bufsize);
    #####: 2792:	if (tf_buf == NULL) {
    #####: 2793:		TIFFError(filename, "No space for strip buffer");
    #####: 2794:		return;
        -: 2795:	}
        -: 2796:
        -: 2797:#if defined( EXP_ASCII85ENCODER )
    #####: 2798:	if ( ascii85 ) {
        -: 2799:	    /*
        -: 2800:	     * Allocate a buffer to hold the ASCII85 encoded data.  Note
        -: 2801:	     * that it is allocated with sufficient room to hold the
        -: 2802:	     * encoded data (5*bufsize/4) plus the EOD marker (+8)
        -: 2803:	     * and formatting line breaks.  The line breaks are more
        -: 2804:	     * than taken care of by using 6*bufsize/4 rather than
        -: 2805:	     * 5*bufsize/4.
        -: 2806:	     */
        -: 2807:
    #####: 2808:	    ascii85_p = _TIFFmalloc( (bufsize+(bufsize/2)) + 8 );
        -: 2809:
    #####: 2810:	    if ( !ascii85_p ) {
    #####: 2811:		_TIFFfree( tf_buf );
        -: 2812:
    #####: 2813:		TIFFError( filename, "Cannot allocate ASCII85 encoding buffer." );
    #####: 2814:		return;
        -: 2815:	    }
        -: 2816:	}
        -: 2817:#endif
        -: 2818:
    #####: 2819:	for (s = 0; s < (tstrip_t) tf_numberstrips; s++) {
    #####: 2820:		cc = TIFFReadRawStrip(tif, s, tf_buf, (tmsize_t) bc[s]);
    #####: 2821:		if (cc < 0) {
    #####: 2822:			TIFFError(filename, "Can't read strip");
    #####: 2823:			break;
        -: 2824:		}
    #####: 2825:		if (fillorder == FILLORDER_LSB2MSB)
    #####: 2826:			TIFFReverseBits(tf_buf, cc);
    #####: 2827:		if (!ascii85) {
    #####: 2828:			for (cp = tf_buf; cc > 0; cc--) {
    #####: 2829:				DOBREAK(breaklen, 1, fd);
    #####: 2830:				c = *cp++;
    #####: 2831:				PUTHEX(c, fd);
        -: 2832:			}
    #####: 2833:			fputs(">\n", fd);
    #####: 2834:			breaklen = MAXLINE;
        -: 2835:		} else {
    #####: 2836:			Ascii85Init();
        -: 2837:#if defined( EXP_ASCII85ENCODER )
    #####: 2838:			ascii85_l = Ascii85EncodeBlock( ascii85_p, 1, tf_buf, cc );
        -: 2839:
    #####: 2840:			if ( ascii85_l > 0 )
    #####: 2841:				fwrite( ascii85_p, ascii85_l, 1, fd );
        -: 2842:#else
        -: 2843:			for (cp = tf_buf; cc > 0; cc--)
        -: 2844:				Ascii85Put(*cp++, fd);
        -: 2845:			Ascii85Flush(fd);
        -: 2846:#endif	/* EXP_ASCII85ENCODER */
        -: 2847:		}
        -: 2848:	}
    #####: 2849:	_TIFFfree((char *) tf_buf);
        -: 2850:
        -: 2851:#if defined( EXP_ASCII85ENCODER )
    #####: 2852:	if ( ascii85_p )
    #####: 2853:		_TIFFfree( ascii85_p );
        -: 2854:#endif
        -: 2855:}
        -: 2856:
        -: 2857:void
    #####: 2858:Ascii85Init(void)
        -: 2859:{
    #####: 2860:	ascii85breaklen = 2*MAXLINE;
    #####: 2861:	ascii85count = 0;
    #####: 2862:}
        -: 2863:
        -: 2864:static char*
    #####: 2865:Ascii85Encode(unsigned char* raw)
        -: 2866:{
        -: 2867:	static char encoded[6];
        -: 2868:	uint32 word;
        -: 2869:
    #####: 2870:	word = (((raw[0]<<8)+raw[1])<<16) + (raw[2]<<8) + raw[3];
    #####: 2871:	if (word != 0L) {
        -: 2872:		uint32 q;
        -: 2873:		uint16 w1;
        -: 2874:
    #####: 2875:		q = word / (85L*85*85*85);	/* actually only a byte */
    #####: 2876:		encoded[0] = (char) (q + '!');
        -: 2877:
    #####: 2878:		word -= q * (85L*85*85*85); q = word / (85L*85*85);
    #####: 2879:		encoded[1] = (char) (q + '!');
        -: 2880:
    #####: 2881:		word -= q * (85L*85*85); q = word / (85*85);
    #####: 2882:		encoded[2] = (char) (q + '!');
        -: 2883:
    #####: 2884:		w1 = (uint16) (word - q*(85L*85));
    #####: 2885:		encoded[3] = (char) ((w1 / 85) + '!');
    #####: 2886:		encoded[4] = (char) ((w1 % 85) + '!');
    #####: 2887:		encoded[5] = '\0';
        -: 2888:	} else
    #####: 2889:		encoded[0] = 'z', encoded[1] = '\0';
    #####: 2890:	return (encoded);
        -: 2891:}
        -: 2892:
        -: 2893:void
    #####: 2894:Ascii85Put(unsigned char code, FILE* fd)
        -: 2895:{
    #####: 2896:	ascii85buf[ascii85count++] = code;
    #####: 2897:	if (ascii85count >= 4) {
        -: 2898:		unsigned char* p;
        -: 2899:		int n;
        -: 2900:
    #####: 2901:		for (n = ascii85count, p = ascii85buf; n >= 4; n -= 4, p += 4) {
        -: 2902:			char* cp;
    #####: 2903:			for (cp = Ascii85Encode(p); *cp; cp++) {
    #####: 2904:				putc(*cp, fd);
    #####: 2905:				if (--ascii85breaklen == 0) {
    #####: 2906:					putc('\n', fd);
    #####: 2907:					ascii85breaklen = 2*MAXLINE;
        -: 2908:				}
        -: 2909:			}
        -: 2910:		}
    #####: 2911:		_TIFFmemcpy(ascii85buf, p, n);
    #####: 2912:		ascii85count = n;
        -: 2913:	}
    #####: 2914:}
        -: 2915:
        -: 2916:void
    #####: 2917:Ascii85Flush(FILE* fd)
        -: 2918:{
    #####: 2919:	if (ascii85count > 0) {
        -: 2920:		char* res;
    #####: 2921:		_TIFFmemset(&ascii85buf[ascii85count], 0, 3);
    #####: 2922:		res = Ascii85Encode(ascii85buf);
    #####: 2923:		fwrite(res[0] == 'z' ? "!!!!" : res, ascii85count + 1, 1, fd);
        -: 2924:	}
    #####: 2925:	fputs("~>\n", fd);
    #####: 2926:}
        -: 2927:#if	defined( EXP_ASCII85ENCODER)
        -: 2928:
        -: 2929:#define A85BREAKCNTR    ascii85breaklen
        -: 2930:#define A85BREAKLEN     (2*MAXLINE)
        -: 2931:
        -: 2932:/*****************************************************************************
        -: 2933:*
        -: 2934:* Name:         Ascii85EncodeBlock( ascii85_p, f_eod, raw_p, raw_l )
        -: 2935:*
        -: 2936:* Description:  This routine will encode the raw data in the buffer described
        -: 2937:*               by raw_p and raw_l into ASCII85 format and store the encoding
        -: 2938:*               in the buffer given by ascii85_p.
        -: 2939:*
        -: 2940:* Parameters:   ascii85_p   -   A buffer supplied by the caller which will
        -: 2941:*                               contain the encoded ASCII85 data.
        -: 2942:*               f_eod       -   Flag: Nz means to end the encoded buffer with
        -: 2943:*                               an End-Of-Data marker.
        -: 2944:*               raw_p       -   Pointer to the buffer of data to be encoded
        -: 2945:*               raw_l       -   Number of bytes in raw_p[] to be encoded
        -: 2946:*
        -: 2947:* Returns:      (int)   <   0   Error, see errno
        -: 2948:*                       >=  0   Number of bytes written to ascii85_p[].
        -: 2949:*
        -: 2950:* Notes:        An external variable given by A85BREAKCNTR is used to
        -: 2951:*               determine when to insert newline characters into the
        -: 2952:*               encoded data.  As each byte is placed into ascii85_p this
        -: 2953:*               external is decremented.  If the variable is decrement to
        -: 2954:*               or past zero then a newline is inserted into ascii85_p
        -: 2955:*               and the A85BREAKCNTR is then reset to A85BREAKLEN.
        -: 2956:*                   Note:  for efficiency reasons the A85BREAKCNTR variable
        -: 2957:*                          is not actually checked on *every* character
        -: 2958:*                          placed into ascii85_p but often only for every
        -: 2959:*                          5 characters.
        -: 2960:*
        -: 2961:*               THE CALLER IS RESPONSIBLE FOR ENSURING THAT ASCII85_P[] IS
        -: 2962:*               SUFFICIENTLY LARGE TO THE ENCODED DATA!
        -: 2963:*                   You will need at least 5 * (raw_l/4) bytes plus space for
        -: 2964:*                   newline characters and space for an EOD marker (if
        -: 2965:*                   requested).  A safe calculation is to use 6*(raw_l/4) + 8
        -: 2966:*                   to size ascii85_p.
        -: 2967:*
        -: 2968:*****************************************************************************/
        -: 2969:
    #####: 2970:tsize_t Ascii85EncodeBlock( uint8 * ascii85_p, unsigned f_eod, const uint8 * raw_p, tsize_t raw_l )
        -: 2971:
        -: 2972:{
    #####: 2973:    char                        ascii85[5];     /* Encoded 5 tuple */
        -: 2974:    tsize_t                     ascii85_l;      /* Number of bytes written to ascii85_p[] */
        -: 2975:    int                         rc;             /* Return code */
        -: 2976:    uint32                      val32;          /* Unencoded 4 tuple */
        -: 2977:
    #####: 2978:    ascii85_l = 0;                              /* Nothing written yet */
        -: 2979:
    #####: 2980:    if ( raw_p )
        -: 2981:    {
    #####: 2982:        --raw_p;                                /* Prepare for pre-increment fetches */
        -: 2983:
    #####: 2984:        for ( ; raw_l > 3; raw_l -= 4 )
        -: 2985:        {
    #####: 2986:            val32  = *(++raw_p) << 24;
    #####: 2987:            val32 += *(++raw_p) << 16;
    #####: 2988:            val32 += *(++raw_p) <<  8;
    #####: 2989:            val32 += *(++raw_p);
        -: 2990:    
    #####: 2991:            if ( val32 == 0 )                   /* Special case */
        -: 2992:            {
    #####: 2993:                ascii85_p[ascii85_l] = 'z';
    #####: 2994:                rc = 1;
        -: 2995:            }
        -: 2996:    
        -: 2997:            else
        -: 2998:            {
    #####: 2999:                ascii85[4] = (char) ((val32 % 85) + 33);
    #####: 3000:                val32 /= 85;
        -: 3001:    
    #####: 3002:                ascii85[3] = (char) ((val32 % 85) + 33);
    #####: 3003:                val32 /= 85;
        -: 3004:    
    #####: 3005:                ascii85[2] = (char) ((val32 % 85) + 33);
    #####: 3006:                val32 /= 85;
        -: 3007:    
    #####: 3008:                ascii85[1] = (char) ((val32 % 85) + 33);
    #####: 3009:                ascii85[0] = (char) ((val32 / 85) + 33);
        -: 3010:
    #####: 3011:                _TIFFmemcpy( &ascii85_p[ascii85_l], ascii85, sizeof(ascii85) );
    #####: 3012:                rc = sizeof(ascii85);
        -: 3013:            }
        -: 3014:    
    #####: 3015:            ascii85_l += rc;
        -: 3016:    
    #####: 3017:            if ( (A85BREAKCNTR -= rc) <= 0 )
        -: 3018:            {
    #####: 3019:                ascii85_p[ascii85_l] = '\n';
    #####: 3020:                ++ascii85_l;
    #####: 3021:                A85BREAKCNTR = A85BREAKLEN;
        -: 3022:            }
        -: 3023:        }
        -: 3024:    
        -: 3025:        /*
        -: 3026:         * Output any straggler bytes:
        -: 3027:         */
        -: 3028:    
    #####: 3029:        if ( raw_l > 0 )
        -: 3030:        {
        -: 3031:            tsize_t         len;                /* Output this many bytes */
        -: 3032:    
    #####: 3033:            len = raw_l + 1;
    #####: 3034:            val32 = *++raw_p << 24;             /* Prime the pump */
        -: 3035:    
    #####: 3036:            if ( --raw_l > 0 )  val32 += *(++raw_p) << 16;
    #####: 3037:            if ( --raw_l > 0 )  val32 += *(++raw_p) <<  8;
        -: 3038:    
    #####: 3039:            val32 /= 85;
        -: 3040:    
    #####: 3041:            ascii85[3] = (char) ((val32 % 85) + 33);
    #####: 3042:            val32 /= 85;
        -: 3043:    
    #####: 3044:            ascii85[2] = (char) ((val32 % 85) + 33);
    #####: 3045:            val32 /= 85;
        -: 3046:    
    #####: 3047:            ascii85[1] = (char) ((val32 % 85) + 33);
    #####: 3048:            ascii85[0] = (char) ((val32 / 85) + 33);
        -: 3049:    
    #####: 3050:            _TIFFmemcpy( &ascii85_p[ascii85_l], ascii85, len );
    #####: 3051:            ascii85_l += len;
        -: 3052:        }
        -: 3053:    }
        -: 3054:
        -: 3055:    /*
        -: 3056:     * If requested add an ASCII85 End Of Data marker:
        -: 3057:     */
        -: 3058:
    #####: 3059:    if ( f_eod )
        -: 3060:    {
    #####: 3061:        ascii85_p[ascii85_l++] = '~';
    #####: 3062:        ascii85_p[ascii85_l++] = '>';
    #####: 3063:        ascii85_p[ascii85_l++] = '\n';
        -: 3064:    }
        -: 3065:
    #####: 3066:    return ( ascii85_l );
        -: 3067:
        -: 3068:}   /* Ascii85EncodeBlock() */
        -: 3069:
        -: 3070:#endif	/* EXP_ASCII85ENCODER */
        -: 3071:
        -: 3072:
        -: 3073:char* stuff[] = {
        -: 3074:"usage: tiff2ps [options] input.tif ...",
        -: 3075:"where options are:",
        -: 3076:" -1            generate PostScript Level 1 (default)",
        -: 3077:" -2            generate PostScript Level 2",
        -: 3078:" -3            generate PostScript Level 3",
        -: 3079:" -8            disable use of ASCII85 encoding with PostScript Level 2/3",
        -: 3080:" -a            convert all directories in file (default is first), Not EPS",
        -: 3081:" -b #          set the bottom margin to # inches",
        -: 3082:" -c            center image (-b and -l still add to this)",
        -: 3083:" -C name       set postscript document creator name",
        -: 3084:" -d #          set initial directory to # counting from zero",
        -: 3085:" -D            enable duplex printing (two pages per sheet of paper)",
        -: 3086:" -e            generate Encapsulated PostScript (EPS) (implies -z)",
        -: 3087:" -h #          set printed page height to # inches (no default)",
        -: 3088:" -w #          set printed page width to # inches (no default)",
        -: 3089:" -H #          split image if height is more than # inches",
        -: 3090:" -W #          split image if width is more than # inches",
        -: 3091:" -L #          overLap split images by # inches",
        -: 3092:" -i #          enable/disable (Nz/0) pixel interpolation (default: enable)",
        -: 3093:" -l #          set the left margin to # inches",
        -: 3094:" -m            use \"imagemask\" operator instead of \"image\"",
        -: 3095:" -o #          convert directory at file offset # bytes",
        -: 3096:" -O file       write PostScript to file instead of standard output",
        -: 3097:" -p            generate regular (non-encapsulated) PostScript",
        -: 3098:" -P L or P     set optional PageOrientation DSC comment to Landscape or Portrait",
        -: 3099:" -r # or auto  rotate by 90, 180, 270 degrees or auto",
        -: 3100:" -s            generate PostScript for a single image",
        -: 3101:" -t name       set postscript document title. Otherwise the filename is used",
        -: 3102:" -T            print pages for top edge binding",
        -: 3103:" -x            override resolution units as centimeters",
        -: 3104:" -y            override resolution units as inches",
        -: 3105:" -z            enable printing in the deadzone (only for PostScript Level 2/3)",
        -: 3106:NULL
        -: 3107:};
        -: 3108:
        -: 3109:static void
    #####: 3110:usage(int code)
        -: 3111:{
    #####: 3112:	char buf[BUFSIZ];
        -: 3113:	int i;
        -: 3114:
    #####: 3115:	setbuf(stderr, buf);
    #####: 3116:        fprintf(stderr, "%s\n\n", TIFFGetVersion());
    #####: 3117:	for (i = 0; stuff[i] != NULL; i++)
    #####: 3118:		fprintf(stderr, "%s\n", stuff[i]);
    #####: 3119:	exit(code);
        -: 3120:}
        -: 3121:
