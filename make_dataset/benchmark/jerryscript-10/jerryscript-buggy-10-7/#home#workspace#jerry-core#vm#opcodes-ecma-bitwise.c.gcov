        -:    0:Source:/home/workspace/jerry-core/vm/opcodes-ecma-bitwise.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-bigint.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "ecma-objects.h"
        -:   22:
        -:   23:#include "opcodes.h"
        -:   24:
        -:   25:/** \addtogroup vm Virtual machine
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup vm_opcodes Opcodes
        -:   29: * @{
        -:   30: */
        -:   31:
        -:   32:/**
        -:   33: * Perform ECMA number logic operation.
        -:   34: *
        -:   35: * The algorithm of the operation is following:
        -:   36: *   leftNum = ToNumber (leftValue);
        -:   37: *   rightNum = ToNumber (rightValue);
        -:   38: *   result = leftNum BitwiseLogicOp rightNum;
        -:   39: *
        -:   40: * @return ecma value
        -:   41: *         Returned value must be freed with ecma_free_value
        -:   42: */
        -:   43:ecma_value_t
    #####:   44:do_number_bitwise_logic (number_bitwise_logic_op op, /**< number bitwise logic operation */
        -:   45:                         ecma_value_t left_value, /**< left value */
        -:   46:                         ecma_value_t right_value) /**< right value */
        -:   47:{
    #####:   48:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -:   49:
    #####:   50:  ecma_number_t left_number;
    #####:   51:  left_value = ecma_op_to_numeric (left_value, &left_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:   52:
    #####:   53:  if (ECMA_IS_VALUE_ERROR (left_value))
        -:   54:  {
    #####:   55:    return left_value;
        -:   56:  }
        -:   57:
    #####:   58:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:   59:
        -:   60:#if JERRY_BUILTIN_BIGINT
    #####:   61:  if (JERRY_LIKELY (!ecma_is_value_bigint (left_value)))
        -:   62:  {
        -:   63:#endif /* JERRY_BUILTIN_BIGINT */
    #####:   64:    ecma_number_t right_number;
        -:   65:
    #####:   66:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (right_value, &right_number)))
        -:   67:    {
    #####:   68:      return ECMA_VALUE_ERROR;
        -:   69:    }
        -:   70:
    #####:   71:    ecma_number_t result = ECMA_NUMBER_ZERO;
    #####:   72:    uint32_t right_uint32 = ecma_number_to_uint32 (right_number);
        -:   73:
    #####:   74:    switch (op)
        -:   75:    {
    #####:   76:      case NUMBER_BITWISE_LOGIC_AND:
        -:   77:      {
    #####:   78:        uint32_t left_uint32 = ecma_number_to_uint32 (left_number);
    #####:   79:        result = (ecma_number_t) ((int32_t) (left_uint32 & right_uint32));
    #####:   80:        break;
        -:   81:      }
    #####:   82:      case NUMBER_BITWISE_LOGIC_OR:
        -:   83:      {
    #####:   84:        uint32_t left_uint32 = ecma_number_to_uint32 (left_number);
    #####:   85:        result = (ecma_number_t) ((int32_t) (left_uint32 | right_uint32));
    #####:   86:        break;
        -:   87:      }
    #####:   88:      case NUMBER_BITWISE_LOGIC_XOR:
        -:   89:      {
    #####:   90:        uint32_t left_uint32 = ecma_number_to_uint32 (left_number);
    #####:   91:        result = (ecma_number_t) ((int32_t) (left_uint32 ^ right_uint32));
    #####:   92:        break;
        -:   93:      }
    #####:   94:      case NUMBER_BITWISE_SHIFT_LEFT:
        -:   95:      {
    #####:   96:        result = (ecma_number_t) (ecma_number_to_int32 (left_number) << (right_uint32 & 0x1F));
    #####:   97:        break;
        -:   98:      }
    #####:   99:      case NUMBER_BITWISE_SHIFT_RIGHT:
        -:  100:      {
    #####:  101:        result = (ecma_number_t) (ecma_number_to_int32 (left_number) >> (right_uint32 & 0x1F));
    #####:  102:        break;
        -:  103:      }
    #####:  104:      default:
        -:  105:      {
    #####:  106:        JERRY_ASSERT (op == NUMBER_BITWISE_SHIFT_URIGHT);
        -:  107:
    #####:  108:        uint32_t left_uint32 = ecma_number_to_uint32 (left_number);
    #####:  109:        result = (ecma_number_t) (left_uint32 >> (right_uint32 & 0x1F));
    #####:  110:        break;
        -:  111:      }
        -:  112:    }
        -:  113:
    #####:  114:    ret_value = ecma_make_number_value (result);
        -:  115:
        -:  116:#if JERRY_BUILTIN_BIGINT
        -:  117:  }
        -:  118:  else
        -:  119:  {
    #####:  120:    bool free_right_value;
    #####:  121:    right_value = ecma_bigint_get_bigint (right_value, &free_right_value);
        -:  122:
    #####:  123:    if (ECMA_IS_VALUE_ERROR (right_value))
        -:  124:    {
    #####:  125:      ecma_free_value (left_value);
    #####:  126:      return right_value;
        -:  127:    }
        -:  128:
    #####:  129:    switch (op)
        -:  130:    {
    #####:  131:      case NUMBER_BITWISE_LOGIC_AND:
        -:  132:      {
    #####:  133:        ret_value = ecma_bigint_and (left_value, right_value);
    #####:  134:        break;
        -:  135:      }
    #####:  136:      case NUMBER_BITWISE_LOGIC_OR:
        -:  137:      {
    #####:  138:        ret_value = ecma_bigint_or (left_value, right_value);
    #####:  139:        break;
        -:  140:      }
    #####:  141:      case NUMBER_BITWISE_LOGIC_XOR:
        -:  142:      {
    #####:  143:        ret_value = ecma_bigint_xor (left_value, right_value);
    #####:  144:        break;
        -:  145:      }
    #####:  146:      case NUMBER_BITWISE_SHIFT_LEFT:
        -:  147:      {
    #####:  148:        ret_value = ecma_bigint_shift (left_value, right_value, true);
    #####:  149:        break;
        -:  150:      }
    #####:  151:      case NUMBER_BITWISE_SHIFT_RIGHT:
        -:  152:      {
    #####:  153:        ret_value = ecma_bigint_shift (left_value, right_value, false);
    #####:  154:        break;
        -:  155:      }
    #####:  156:      default:
        -:  157:      {
    #####:  158:        JERRY_ASSERT (op == NUMBER_BITWISE_SHIFT_URIGHT);
        -:  159:
    #####:  160:        ret_value = ecma_raise_type_error (ECMA_ERR_UNSIGNED_RIGHT_SHIFT_IS_NOT_ALLOWED_FOR_BIGINTS);
    #####:  161:        break;
        -:  162:      }
        -:  163:    }
        -:  164:
    #####:  165:    ecma_free_value (left_value);
    #####:  166:    if (free_right_value)
        -:  167:    {
    #####:  168:      ecma_free_value (right_value);
        -:  169:    }
        -:  170:  }
        -:  171:#endif /* JERRY_BUILTIN_BIGINT */
        -:  172:
    #####:  173:  return ret_value;
        -:  174:} /* do_number_bitwise_logic */
        -:  175:
        -:  176:/**
        -:  177: * Perform ECMA number bitwise not operation.
        -:  178: *
        -:  179: * @return ecma value
        -:  180: *         Returned value must be freed with ecma_free_value
        -:  181: */
        -:  182:ecma_value_t
    #####:  183:do_number_bitwise_not (ecma_value_t value) /**< value */
        -:  184:{
    #####:  185:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (value));
        -:  186:
    #####:  187:  ecma_number_t number;
    #####:  188:  value = ecma_op_to_numeric (value, &number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:  189:
    #####:  190:  if (ECMA_IS_VALUE_ERROR (value))
        -:  191:  {
    #####:  192:    return value;
        -:  193:  }
        -:  194:
        -:  195:#if JERRY_BUILTIN_BIGINT
    #####:  196:  if (JERRY_LIKELY (!ecma_is_value_bigint (value)))
        -:  197:  {
        -:  198:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  199:    return ecma_make_number_value ((ecma_number_t) ((int32_t) ~ecma_number_to_uint32 (number)));
        -:  200:#if JERRY_BUILTIN_BIGINT
        -:  201:  }
        -:  202:
    #####:  203:  ecma_value_t ret_value = ecma_bigint_unary (value, ECMA_BIGINT_UNARY_BITWISE_NOT);
    #####:  204:  ecma_free_value (value);
    #####:  205:  return ret_value;
        -:  206:#endif /* JERRY_BUILTIN_BIGINT */
        -:  207:} /* do_number_bitwise_not */
        -:  208:
        -:  209:/**
        -:  210: * @}
        -:  211: * @}
        -:  212: */
