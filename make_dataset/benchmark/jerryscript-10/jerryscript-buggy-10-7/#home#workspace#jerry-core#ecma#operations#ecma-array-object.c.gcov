        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-array-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-array-object.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-property-hashmap.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmaarrayobject ECMA Array object related routines
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:#if JERRY_CPOINTER_32_BIT
        -:   39:/**
        -:   40: * Maximum length of the array length to allocate fast mode access for it
        -:   41: * e.g. new Array(5000) is constructed as fast mode access array,
        -:   42: * but new Array(50000000) is consturcted as normal property list based array
        -:   43: */
        -:   44:#define ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH (1 << 17)
        -:   45:#else /* JERRY_CPOINTER_32_BIT */
        -:   46:/**
        -:   47: * Maximum length of the array length to allocate fast mode access for it
        -:   48: * e.g. new Array(5000) is constructed as fast mode access array,
        -:   49: * but new Array(50000000) is consturcted as normal property list based array
        -:   50: */
        -:   51:#define ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH (1 << 13)
        -:   52:#endif /* JERRY_CPOINTER_32_BIT */
        -:   53:
        -:   54:/**
        -:   55: * Property name type flag for array indices.
        -:   56: */
        -:   57:#define ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE (ECMA_DIRECT_STRING_UINT << ECMA_PROPERTY_NAME_TYPE_SHIFT)
        -:   58:
        -:   59:/**
        -:   60: * Allocate a new array object with the given length
        -:   61: *
        -:   62: * @return pointer to the constructed array object
        -:   63: */
        -:   64:static ecma_object_t *
        3:   65:ecma_op_alloc_array_object (uint32_t length) /**< length of the new array */
        -:   66:{
        -:   67:#if JERRY_BUILTIN_ARRAY
        3:   68:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);
        -:   69:#else /* !JERRY_BUILTIN_ARRAY */
        -:   70:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -:   71:#endif /* JERRY_BUILTIN_ARRAY */
        -:   72:
        3:   73:  ecma_object_t *object_p =
        -:   74:    ecma_create_object (array_prototype_object_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_ARRAY);
        -:   75:
        -:   76:  /*
        -:   77:   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.
        -:   78:   *
        -:   79:   * See also: ecma_object_get_class_name
        -:   80:   */
        -:   81:
        3:   82:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        3:   83:  ext_obj_p->u.array.length = length;
        3:   84:  ext_obj_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:   85:
        3:   86:  return object_p;
        -:   87:} /* ecma_op_alloc_array_object */
        -:   88:
        -:   89:/**
        -:   90: * Check whether the given object is fast-access mode array
        -:   91: *
        -:   92: * @return true - if the object is fast-access mode array
        -:   93: *         false, otherwise
        -:   94: */
        -:   95:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    43729:   96:ecma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */
        -:   97:{
    43730:   98:  return (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY
    65575:   99:          && ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p));
        -:  100:} /* ecma_op_object_is_fast_array */
        -:  101:
        -:  102:/**
        -:  103: * Check whether the given array object is fast-access mode array
        -:  104: *
        -:  105: * @return true - if the array object is fast-access mode array
        -:  106: *         false, otherwise
        -:  107: */
        -:  108:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    65511:  109:ecma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */
        -:  110:{
    87356:  111:  JERRY_ASSERT (ecma_get_object_base_type ((ecma_object_t *) array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:  112:
    87356:  113:  return array_p->u.array.length_prop_and_hole_count & ECMA_FAST_ARRAY_FLAG;
        -:  114:} /* ecma_op_array_is_fast_array */
        -:  115:
        -:  116:/**
        -:  117: * Allocate a new array object with the given length
        -:  118: *
        -:  119: * Note: The returned array can be normal of fast access mode
        -:  120: *
        -:  121: * @return pointer to the constructed array object
        -:  122: */
        -:  123:ecma_object_t *
        3:  124:ecma_op_new_array_object (uint32_t length) /**< length of the new array */
        -:  125:{
        3:  126:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
        -:  127:
        3:  128:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
        3:  129:  ecma_value_t *values_p = NULL;
        -:  130:
        3:  131:  if (length > 0)
        -:  132:  {
        1:  133:    if (length >= ECMA_FAST_ARRAY_MAX_INITIAL_LENGTH)
        -:  134:    {
    #####:  135:      return object_p;
        -:  136:    }
        -:  137:
        1:  138:    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  139:
        1:  140:    if (JERRY_UNLIKELY (values_p == NULL))
        -:  141:    {
    #####:  142:      return object_p;
        -:  143:    }
        -:  144:  }
        -:  145:
        3:  146:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        3:  147:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
        3:  148:  ext_obj_p->u.array.length_prop_and_hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  149:
       11:  150:  for (uint32_t i = 0; i < aligned_length; i++)
        -:  151:  {
        8:  152:    values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  153:  }
        -:  154:
        3:  155:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
        3:  156:  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
        3:  157:  return object_p;
        -:  158:} /* ecma_op_new_array_object */
        -:  159:
        -:  160:/**
        -:  161: * Allocate a new array object from the given length
        -:  162: *
        -:  163: * Note: The returned array can be normal of fast access mode
        -:  164: *
        -:  165: * @return NULL - if the given length is invalid
        -:  166: *         pointer to the constructed array object - otherwise
        -:  167: */
        -:  168:ecma_object_t *
    #####:  169:ecma_op_new_array_object_from_length (ecma_length_t length) /**< length of the new array */
        -:  170:{
        -:  171:#if JERRY_ESNEXT
    #####:  172:  if (length > UINT32_MAX)
        -:  173:  {
    #####:  174:    ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
    #####:  175:    return NULL;
        -:  176:  }
        -:  177:#endif /* JERRY_ESNEXT */
        -:  178:
    #####:  179:  return ecma_op_new_array_object ((uint32_t) length);
        -:  180:} /* ecma_op_new_array_object_from_length */
        -:  181:
        -:  182:/**
        -:  183: * Allocate a new array object from the given buffer
        -:  184: *
        -:  185: * Note: The returned array can be normal of fast access mode
        -:  186: *
        -:  187: * @return ecma_value - constructed array object
        -:  188: */
        -:  189:ecma_value_t
    #####:  190:ecma_op_new_array_object_from_buffer (const ecma_value_t *args_p, /**< array element list */
        -:  191:                                      uint32_t length) /**< number of array elements */
        -:  192:{
    #####:  193:  if (length == 0)
        -:  194:  {
    #####:  195:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  196:  }
        -:  197:
    #####:  198:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
    #####:  199:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
        -:  200:  ecma_value_t *values_p;
    #####:  201:  values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  202:
    #####:  203:  if (values_p != NULL)
        -:  204:  {
    #####:  205:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  206:    ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  207:    JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
        -:  208:
    #####:  209:    for (uint32_t i = 0; i < length; i++)
        -:  210:    {
    #####:  211:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
    #####:  212:      values_p[i] = ecma_copy_value_if_not_object (args_p[i]);
        -:  213:    }
        -:  214:
    #####:  215:    for (uint32_t i = length; i < aligned_length; i++)
        -:  216:    {
    #####:  217:      values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  218:    }
        -:  219:
    #####:  220:    ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
        -:  221:  }
        -:  222:  else
        -:  223:  {
    #####:  224:    for (uint32_t i = 0; i < length; i++)
        -:  225:    {
    #####:  226:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
        -:  227:
    #####:  228:      ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -:  229:      ecma_property_value_t *prop_value_p;
    #####:  230:      prop_value_p =
        -:  231:        ecma_create_named_data_property (object_p, prop_name_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
    #####:  232:      ecma_deref_ecma_string (prop_name_p);
    #####:  233:      prop_value_p->value = ecma_copy_value_if_not_object (args_p[i]);
        -:  234:    }
        -:  235:  }
        -:  236:
    #####:  237:  return ecma_make_object_value (object_p);
        -:  238:} /* ecma_op_new_array_object_from_buffer */
        -:  239:
        -:  240:/**
        -:  241: * Allocate a new fast acces mode array object from the given collection
        -:  242: *
        -:  243: * Note: The given collection will be unavailable after and it's underlying buffer is reused
        -:  244: *
        -:  245: * @return ecma_value - constructed fast access mode array object
        -:  246: */
        -:  247:ecma_value_t
    #####:  248:ecma_op_new_array_object_from_collection (ecma_collection_t *collection_p, /**< collection to create array from */
        -:  249:                                          bool unref_objects) /**< true - if the collection potentially
        -:  250:                                                                          containts objects
        -:  251:                                                                   false - otherwise */
        -:  252:{
    #####:  253:  const uint32_t item_count = collection_p->item_count;
        -:  254:
    #####:  255:  if (item_count == 0)
        -:  256:  {
    #####:  257:    ecma_collection_destroy (collection_p);
    #####:  258:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  259:  }
        -:  260:
        -:  261:  ecma_object_t *object_p;
    #####:  262:  ecma_value_t *buffer_p = collection_p->buffer_p;
    #####:  263:  const uint32_t old_size = ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity);
    #####:  264:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (collection_p->item_count);
        -:  265:
    #####:  266:  jmem_heap_free_block (collection_p, sizeof (ecma_collection_t));
    #####:  267:  buffer_p = jmem_heap_realloc_block (buffer_p, old_size, aligned_length * sizeof (ecma_value_t));
    #####:  268:  object_p = ecma_op_alloc_array_object (item_count);
        -:  269:
    #####:  270:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  271:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  272:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
    #####:  273:  JERRY_ASSERT (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE);
    #####:  274:  ECMA_SET_POINTER (object_p->u1.property_list_cp, buffer_p);
        -:  275:
    #####:  276:  if (JERRY_UNLIKELY (unref_objects))
        -:  277:  {
    #####:  278:    for (uint32_t i = 0; i < item_count; i++)
        -:  279:    {
        -:  280:      /* Strong references from the collection are no longer needed
        -:  281:         since GC will mark these object as a fast access mode array properties */
    #####:  282:      ecma_deref_if_object (buffer_p[i]);
        -:  283:    }
        -:  284:  }
        -:  285:
    #####:  286:  for (uint32_t i = item_count; i < aligned_length; i++)
        -:  287:  {
    #####:  288:    buffer_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  289:  }
        -:  290:
    #####:  291:  return ecma_make_object_value (object_p);
        -:  292:} /* ecma_op_new_array_object_from_collection */
        -:  293:
        -:  294:/**
        -:  295: * Converts a fast access mode array back to a normal property list based array
        -:  296: */
        -:  297:void
    #####:  298:ecma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */
        -:  299:{
    #####:  300:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  301:
    #####:  302:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  303:
    #####:  304:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  305:  {
    #####:  306:    ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  307:    return;
        -:  308:  }
        -:  309:
    #####:  310:  uint32_t length = ext_obj_p->u.array.length;
    #####:  311:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
    #####:  312:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  313:
    #####:  314:  ecma_ref_object (object_p);
        -:  315:
    #####:  316:  ecma_property_pair_t *property_pair_p = NULL;
    #####:  317:  jmem_cpointer_t next_property_pair_cp = JMEM_CP_NULL;
        -:  318:
    #####:  319:  uint32_t prop_index = 1;
    #####:  320:  int32_t index = (int32_t) (length - 1);
        -:  321:
    #####:  322:  while (index >= 0)
        -:  323:  {
    #####:  324:    if (ecma_is_value_array_hole (values_p[index]))
        -:  325:    {
    #####:  326:      index--;
    #####:  327:      continue;
        -:  328:    }
        -:  329:
    #####:  330:    if (prop_index == 1)
        -:  331:    {
    #####:  332:      property_pair_p = ecma_alloc_property_pair ();
    #####:  333:      property_pair_p->header.next_property_cp = next_property_pair_cp;
    #####:  334:      property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;
    #####:  335:      property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  336:      ECMA_SET_NON_NULL_POINTER (next_property_pair_cp, property_pair_p);
        -:  337:    }
        -:  338:
    #####:  339:    JERRY_ASSERT (index <= ECMA_DIRECT_STRING_MAX_IMM);
        -:  340:
    #####:  341:    property_pair_p->names_cp[prop_index] = (jmem_cpointer_t) index;
    #####:  342:    property_pair_p->header.types[prop_index] =
        -:  343:      (ecma_property_t) (ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE
        -:  344:                         | ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE);
        -:  345:
    #####:  346:    property_pair_p->values[prop_index].value = values_p[index];
        -:  347:
    #####:  348:    index--;
    #####:  349:    prop_index = !prop_index;
        -:  350:  }
        -:  351:
    #####:  352:  ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  353:  jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));
    #####:  354:  ECMA_SET_POINTER (object_p->u1.property_list_cp, property_pair_p);
        -:  355:
    #####:  356:  ecma_deref_object (object_p);
        -:  357:} /* ecma_fast_array_convert_to_normal */
        -:  358:
        -:  359:/**
        -:  360: * [[Put]] operation for a fast access mode array
        -:  361: *
        -:  362: * @return false - If the property name is not array index, or the requested index to be set
        -:  363: *                 would result too much array hole in the underlying buffer. The these cases
        -:  364: *                 the array is converted back to normal property list based array.
        -:  365: *         true - If the indexed property can be set with/without resizing the underlying buffer.
        -:  366: */
        -:  367:bool
        1:  368:ecma_fast_array_set_property (ecma_object_t *object_p, /**< fast access mode array object */
        -:  369:                              uint32_t index, /**< property name index */
        -:  370:                              ecma_value_t value) /**< value to be set */
        -:  371:{
        1:  372:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        1:  373:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        1:  374:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  375:
        -:  376:  ecma_value_t *values_p;
        -:  377:
        1:  378:  if (JERRY_LIKELY (index < old_length))
        -:  379:  {
    #####:  380:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  381:
    #####:  382:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  383:
    #####:  384:    if (ecma_is_value_array_hole (values_p[index]))
        -:  385:    {
    #####:  386:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  387:    }
        -:  388:    else
        -:  389:    {
    #####:  390:      ecma_free_value_if_not_object (values_p[index]);
        -:  391:    }
        -:  392:
    #####:  393:    values_p[index] = ecma_copy_value_if_not_object (value);
        -:  394:
    #####:  395:    return true;
        -:  396:  }
        -:  397:
        1:  398:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
        1:  399:  uint32_t new_holes = index - old_length;
        -:  400:
        1:  401:  if (JERRY_UNLIKELY (new_holes > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT
        -:  402:                      || ((old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT) + new_holes) > ECMA_FAST_ARRAY_MAX_HOLE_COUNT))
        -:  403:  {
    #####:  404:    ecma_fast_array_convert_to_normal (object_p);
        -:  405:
    #####:  406:    return false;
        -:  407:  }
        -:  408:
        1:  409:  uint32_t new_length = index + 1;
        -:  410:
        1:  411:  JERRY_ASSERT (new_length < UINT32_MAX);
        -:  412:
        1:  413:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
        -:  414:
        1:  415:  if (JERRY_LIKELY (index < aligned_length))
        -:  416:  {
        1:  417:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  418:
        1:  419:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  420:    /* This area is filled with ECMA_VALUE_ARRAY_HOLE, but not counted in u.array.length_prop_and_hole_count */
        1:  421:    JERRY_ASSERT (ecma_is_value_array_hole (values_p[index]));
        1:  422:    ext_obj_p->u.array.length_prop_and_hole_count += new_holes * ECMA_FAST_ARRAY_HOLE_ONE;
        1:  423:    ext_obj_p->u.array.length = new_length;
        -:  424:  }
        -:  425:  else
        -:  426:  {
    #####:  427:    values_p = ecma_fast_array_extend (object_p, new_length);
    #####:  428:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  429:  }
        -:  430:
        1:  431:  values_p[index] = ecma_copy_value_if_not_object (value);
        -:  432:
        1:  433:  return true;
        -:  434:} /* ecma_fast_array_set_property */
        -:  435:
        -:  436:/**
        -:  437: * Get the number of array holes in a fast access array object
        -:  438: *
        -:  439: * @return number of array holes in a fast access array object
        -:  440: */
        -:  441:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    #####:  442:ecma_fast_array_get_hole_count (ecma_object_t *obj_p) /**< fast access mode array object */
        -:  443:{
    #####:  444:  JERRY_ASSERT (ecma_op_object_is_fast_array (obj_p));
        -:  445:
    #####:  446:  return ((ecma_extended_object_t *) obj_p)->u.array.length_prop_and_hole_count >> ECMA_FAST_ARRAY_HOLE_SHIFT;
        -:  447:} /* ecma_fast_array_get_hole_count */
        -:  448:
        -:  449:/**
        -:  450: * Extend the underlying buffer of a fast mode access array for the given new length
        -:  451: *
        -:  452: * @return pointer to the extended underlying buffer
        -:  453: */
        -:  454:ecma_value_t *
    #####:  455:ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */
        -:  456:                        uint32_t new_length) /**< new length of the fast access mode array */
        -:  457:{
    #####:  458:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
    #####:  459:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  460:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  461:
    #####:  462:  JERRY_ASSERT (old_length < new_length);
        -:  463:
    #####:  464:  ecma_ref_object (object_p);
        -:  465:
        -:  466:  ecma_value_t *new_values_p;
    #####:  467:  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
    #####:  468:  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  469:
    #####:  470:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  471:  {
    #####:  472:    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));
        -:  473:  }
        -:  474:  else
        -:  475:  {
    #####:  476:    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
    #####:  477:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  478:                                                             old_length_aligned * sizeof (ecma_value_t),
        -:  479:                                                             new_length_aligned * sizeof (ecma_value_t));
        -:  480:  }
        -:  481:
    #####:  482:  for (uint32_t i = old_length; i < new_length_aligned; i++)
        -:  483:  {
    #####:  484:    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  485:  }
        -:  486:
    #####:  487:  ext_obj_p->u.array.length_prop_and_hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  488:  ext_obj_p->u.array.length = new_length;
        -:  489:
    #####:  490:  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);
        -:  491:
    #####:  492:  ecma_deref_object (object_p);
    #####:  493:  return new_values_p;
        -:  494:} /* ecma_fast_array_extend */
        -:  495:
        -:  496:/**
        -:  497: * Delete the array object's property referenced by its value pointer.
        -:  498: *
        -:  499: * Note: specified property must be owned by specified object.
        -:  500: *
        -:  501: * @return true, if the property is deleted
        -:  502: *         false, otherwise
        -:  503: */
        -:  504:bool
    #####:  505:ecma_array_object_delete_property (ecma_object_t *object_p, /**< object */
        -:  506:                                   ecma_string_t *property_name_p) /**< property name */
        -:  507:{
    #####:  508:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
    #####:  509:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  510:
    #####:  511:  if (!ecma_op_object_is_fast_array (object_p))
        -:  512:  {
    #####:  513:    return false;
        -:  514:  }
        -:  515:
    #####:  516:  JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  517:
    #####:  518:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  519:
    #####:  520:  JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
    #####:  521:  JERRY_ASSERT (index < ext_obj_p->u.array.length);
        -:  522:
    #####:  523:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  524:
    #####:  525:  if (ecma_is_value_array_hole (values_p[index]))
        -:  526:  {
    #####:  527:    return true;
        -:  528:  }
        -:  529:
    #####:  530:  ecma_free_value_if_not_object (values_p[index]);
        -:  531:
    #####:  532:  values_p[index] = ECMA_VALUE_ARRAY_HOLE;
    #####:  533:  ext_obj_p->u.array.length_prop_and_hole_count += ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  534:  return true;
        -:  535:} /* ecma_array_object_delete_property */
        -:  536:
        -:  537:/**
        -:  538: * Low level delete of fast access mode array items
        -:  539: *
        -:  540: * @return the updated value of new_length
        -:  541: */
        -:  542:uint32_t
    #####:  543:ecma_delete_fast_array_properties (ecma_object_t *object_p, /**< fast access mode array */
        -:  544:                                   uint32_t new_length) /**< new length of the fast access mode array */
        -:  545:{
    #####:  546:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  547:
    #####:  548:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  549:
    #####:  550:  ecma_ref_object (object_p);
    #####:  551:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  552:
    #####:  553:  uint32_t old_length = ext_obj_p->u.array.length;
    #####:  554:  const uint32_t old_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
    #####:  555:  JERRY_ASSERT (new_length < old_length);
        -:  556:
    #####:  557:  for (uint32_t i = new_length; i < old_length; i++)
        -:  558:  {
    #####:  559:    if (ecma_is_value_array_hole (values_p[i]))
        -:  560:    {
    #####:  561:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  562:    }
        -:  563:    else
        -:  564:    {
    #####:  565:      ecma_free_value_if_not_object (values_p[i]);
        -:  566:    }
        -:  567:  }
        -:  568:
        -:  569:  jmem_cpointer_t new_property_list_cp;
        -:  570:
    #####:  571:  if (new_length == 0)
        -:  572:  {
    #####:  573:    jmem_heap_free_block (values_p, old_aligned_length * sizeof (ecma_value_t));
    #####:  574:    new_property_list_cp = JMEM_CP_NULL;
        -:  575:  }
        -:  576:  else
        -:  577:  {
    #####:  578:    const uint32_t new_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  579:
        -:  580:    ecma_value_t *new_values_p;
    #####:  581:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  582:                                                             old_aligned_length * sizeof (ecma_value_t),
        -:  583:                                                             new_aligned_length * sizeof (ecma_value_t));
        -:  584:
    #####:  585:    for (uint32_t i = new_length; i < new_aligned_length; i++)
        -:  586:    {
    #####:  587:      new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  588:    }
        -:  589:
    #####:  590:    ECMA_SET_NON_NULL_POINTER (new_property_list_cp, new_values_p);
        -:  591:  }
        -:  592:
    #####:  593:  ext_obj_p->u.array.length = new_length;
    #####:  594:  object_p->u1.property_list_cp = new_property_list_cp;
        -:  595:
    #####:  596:  ecma_deref_object (object_p);
        -:  597:
    #####:  598:  return new_length;
        -:  599:} /* ecma_delete_fast_array_properties */
        -:  600:
        -:  601:/**
        -:  602: * Update the length of a fast access mode array to a new length
        -:  603: *
        -:  604: * Note: if the new length would result too much array hole in the underlying arraybuffer
        -:  605: *       the array is converted back to normal property list based array
        -:  606: */
        -:  607:static void
    #####:  608:ecma_fast_array_set_length (ecma_object_t *object_p, /**< fast access mode array object */
        -:  609:                            uint32_t new_length) /**< new length of the fast access mode array object*/
        -:  610:{
    #####:  611:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  612:
    #####:  613:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  614:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  615:
    #####:  616:  JERRY_ASSERT (new_length >= old_length);
        -:  617:
    #####:  618:  if (new_length == old_length)
        -:  619:  {
    #####:  620:    return;
        -:  621:  }
        -:  622:
    #####:  623:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
    #####:  624:  uint32_t new_holes = new_length - old_length;
        -:  625:
    #####:  626:  if (JERRY_UNLIKELY (new_holes > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT
        -:  627:                      || ((old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT) + new_holes) > ECMA_FAST_ARRAY_MAX_HOLE_COUNT))
        -:  628:  {
    #####:  629:    ecma_fast_array_convert_to_normal (object_p);
        -:  630:  }
        -:  631:  else
        -:  632:  {
    #####:  633:    ecma_fast_array_extend (object_p, new_length);
        -:  634:  }
        -:  635:
    #####:  636:  return;
        -:  637:} /* ecma_fast_array_set_length */
        -:  638:
        -:  639:/**
        -:  640: * Get collection of property names of a fast access mode array object
        -:  641: *
        -:  642: * Note: Since the fast array object only contains indexed, enumerable, writable, configurable properties
        -:  643: *       we can return a collection of non-array hole array indices
        -:  644: *
        -:  645: * @return collection of strings - property names
        -:  646: */
        -:  647:ecma_collection_t *
    #####:  648:ecma_fast_array_object_own_property_keys (ecma_object_t *object_p, /**< fast access mode array object */
        -:  649:                                          jerry_property_filter_t filter) /**< property name filter options */
        -:  650:{
    #####:  651:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  652:
    #####:  653:  ecma_collection_t *ret_p = ecma_new_collection ();
        -:  654:
    #####:  655:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES))
        -:  656:  {
    #####:  657:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  658:    uint32_t length = ext_obj_p->u.array.length;
        -:  659:
    #####:  660:    if (length != 0)
        -:  661:    {
    #####:  662:      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  663:
    #####:  664:      for (uint32_t i = 0; i < length; i++)
        -:  665:      {
    #####:  666:        if (ecma_is_value_array_hole (values_p[i]))
        -:  667:        {
    #####:  668:          continue;
        -:  669:        }
        -:  670:
    #####:  671:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);
        -:  672:
    #####:  673:        ecma_collection_push_back (ret_p, ecma_make_string_value (index_str_p));
        -:  674:      }
        -:  675:    }
        -:  676:  }
        -:  677:
    #####:  678:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS))
        -:  679:  {
    #####:  680:    ecma_collection_push_back (ret_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
        -:  681:  }
        -:  682:
    #####:  683:  return ret_p;
        -:  684:} /* ecma_fast_array_object_own_property_keys */
        -:  685:
        -:  686:#if JERRY_ESNEXT
        -:  687:/**
        -:  688: * Array object creation with custom prototype.
        -:  689: *
        -:  690: * See also: ECMA-262 v6, 9.4.2.3
        -:  691: *
        -:  692: * @return ecma value
        -:  693: *         Returned value must be freed with ecma_free_value
        -:  694: */
        -:  695:ecma_object_t *
        2:  696:ecma_op_array_species_create (ecma_object_t *original_array_p, /**< The object from whom the new array object
        -:  697:                                                                *   is being created */
        -:  698:                              ecma_length_t length) /**< length of the array */
        -:  699:{
        2:  700:  ecma_value_t constructor = ECMA_VALUE_UNDEFINED;
        2:  701:  ecma_value_t original_array = ecma_make_object_value (original_array_p);
        -:  702:
        2:  703:  ecma_value_t is_array = ecma_is_value_array (original_array);
        -:  704:
        2:  705:  if (ECMA_IS_VALUE_ERROR (is_array))
        -:  706:  {
    #####:  707:    return NULL;
        -:  708:  }
        -:  709:
        2:  710:  if (ecma_is_value_true (is_array))
        -:  711:  {
        2:  712:    constructor = ecma_op_object_get_by_magic_id (original_array_p, LIT_MAGIC_STRING_CONSTRUCTOR);
        2:  713:    if (ECMA_IS_VALUE_ERROR (constructor))
        -:  714:    {
    #####:  715:      return NULL;
        -:  716:    }
        -:  717:
        -:  718:#if JERRY_BUILTIN_REALMS
        2:  719:    if (ecma_is_constructor (constructor))
        -:  720:    {
        2:  721:      ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);
        2:  722:      ecma_global_object_t *global_object_p = ecma_op_function_get_function_realm (constructor_p);
        -:  723:
        2:  724:      if ((ecma_object_t *) global_object_p != ecma_builtin_get_global ()
    #####:  725:          && constructor_p == ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_ARRAY))
        -:  726:      {
    #####:  727:        ecma_deref_object (constructor_p);
    #####:  728:        constructor = ECMA_VALUE_UNDEFINED;
        -:  729:      }
        -:  730:    }
        -:  731:#endif /* JERRY_BUILTIN_REALMS */
        -:  732:
        2:  733:    if (ecma_is_value_object (constructor))
        -:  734:    {
        2:  735:      ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
        2:  736:      constructor = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
        2:  737:      ecma_deref_object (ctor_object_p);
        -:  738:
        2:  739:      if (ECMA_IS_VALUE_ERROR (constructor))
        -:  740:      {
    #####:  741:        return NULL;
        -:  742:      }
        -:  743:
        2:  744:      if (ecma_is_value_null (constructor))
        -:  745:      {
    #####:  746:        constructor = ECMA_VALUE_UNDEFINED;
        -:  747:      }
        -:  748:    }
        -:  749:  }
        -:  750:
        2:  751:  if (ecma_is_value_undefined (constructor))
        -:  752:  {
    #####:  753:    return ecma_op_new_array_object_from_length (length);
        -:  754:  }
        -:  755:
        2:  756:  if (!ecma_is_constructor (constructor))
        -:  757:  {
    #####:  758:    ecma_free_value (constructor);
    #####:  759:    ecma_raise_type_error (ECMA_ERR_INVALID_SPECIES_CONSTRUCTOR);
    #####:  760:    return NULL;
        -:  761:  }
        -:  762:
        2:  763:  ecma_value_t len_val = ecma_make_length_value (length);
        2:  764:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
        2:  765:  ecma_value_t ret_val = ecma_op_function_construct (ctor_object_p, ctor_object_p, &len_val, 1);
        -:  766:
        2:  767:  ecma_deref_object (ctor_object_p);
        2:  768:  ecma_free_value (len_val);
        -:  769:
        2:  770:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  771:  {
    #####:  772:    return NULL;
        -:  773:  }
        -:  774:
        2:  775:  return ecma_get_object_from_value (ret_val);
        -:  776:} /* ecma_op_array_species_create */
        -:  777:
        -:  778:/**
        -:  779: * CreateArrayIterator Abstract Operation
        -:  780: *
        -:  781: * See also:
        -:  782: *          ECMA-262 v6, 22.1.5.1
        -:  783: *
        -:  784: * Referenced by:
        -:  785: *          ECMA-262 v6, 22.1.3.4
        -:  786: *          ECMA-262 v6, 22.1.3.13
        -:  787: *          ECMA-262 v6, 22.1.3.29
        -:  788: *          ECMA-262 v6, 22.1.3.30
        -:  789: *
        -:  790: * Note:
        -:  791: *      Returned value must be freed with ecma_free_value.
        -:  792: *
        -:  793: * @return array iterator object
        -:  794: */
        -:  795:ecma_value_t
    #####:  796:ecma_op_create_array_iterator (ecma_object_t *obj_p, /**< array object */
        -:  797:                               ecma_iterator_kind_t kind) /**< array iterator kind */
        -:  798:{
    #####:  799:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -:  800:
    #####:  801:  return ecma_op_create_iterator_object (ecma_make_object_value (obj_p),
        -:  802:                                         prototype_obj_p,
        -:  803:                                         ECMA_OBJECT_CLASS_ARRAY_ITERATOR,
        -:  804:                                         kind);
        -:  805:} /* ecma_op_create_array_iterator */
        -:  806:#endif /* JERRY_ESNEXT */
        -:  807:
        -:  808:/**
        -:  809: * Low level delete of array items from new_length to old_length
        -:  810: *
        -:  811: * Note: new_length must be less than old_length
        -:  812: *
        -:  813: * @return the updated value of new_length
        -:  814: */
        -:  815:static uint32_t
    #####:  816:ecma_delete_array_properties (ecma_object_t *object_p, /**< object */
        -:  817:                              uint32_t new_length, /**< new length */
        -:  818:                              uint32_t old_length) /**< old length */
        -:  819:{
    #####:  820:  JERRY_ASSERT (new_length < old_length);
    #####:  821:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:  822:
    #####:  823:  if (ecma_op_object_is_fast_array (object_p))
        -:  824:  {
    #####:  825:    return ecma_delete_fast_array_properties (object_p, new_length);
        -:  826:  }
        -:  827:
        -:  828:  /* First the minimum value of new_length is updated. */
    #####:  829:  jmem_cpointer_t current_prop_cp = object_p->u1.property_list_cp;
        -:  830:
    #####:  831:  if (current_prop_cp == JMEM_CP_NULL)
        -:  832:  {
    #####:  833:    return new_length;
        -:  834:  }
        -:  835:
        -:  836:  ecma_property_header_t *current_prop_p;
        -:  837:
        -:  838:#if JERRY_PROPERTY_HASHMAP
    #####:  839:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  840:
    #####:  841:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  842:  {
    #####:  843:    current_prop_cp = current_prop_p->next_property_cp;
        -:  844:  }
        -:  845:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  846:
    #####:  847:  while (current_prop_cp != JMEM_CP_NULL)
        -:  848:  {
    #####:  849:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
    #####:  850:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
        -:  851:
    #####:  852:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  853:
    #####:  854:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  855:    {
    #####:  856:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  857:          && !ecma_is_property_configurable (current_prop_p->types[i]))
        -:  858:      {
    #####:  859:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i], prop_pair_p->names_cp[i]);
        -:  860:
    #####:  861:        if (index < old_length && index >= new_length)
        -:  862:        {
    #####:  863:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  864:
    #####:  865:          new_length = index + 1;
        -:  866:
    #####:  867:          if (new_length == old_length)
        -:  868:          {
        -:  869:            /* Early return. */
    #####:  870:            return new_length;
        -:  871:          }
        -:  872:        }
        -:  873:      }
        -:  874:    }
        -:  875:
    #####:  876:    current_prop_cp = current_prop_p->next_property_cp;
        -:  877:  }
        -:  878:
        -:  879:  /* Second all properties between new_length and old_length are deleted. */
    #####:  880:  current_prop_cp = object_p->u1.property_list_cp;
    #####:  881:  ecma_property_header_t *prev_prop_p = NULL;
        -:  882:
        -:  883:#if JERRY_PROPERTY_HASHMAP
    #####:  884:  JERRY_ASSERT (current_prop_cp != JMEM_CP_NULL);
        -:  885:
    #####:  886:  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;
    #####:  887:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  888:
    #####:  889:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  890:  {
    #####:  891:    prev_prop_p = current_prop_p;
    #####:  892:    current_prop_cp = current_prop_p->next_property_cp;
    #####:  893:    hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  894:  }
        -:  895:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  896:
    #####:  897:  while (current_prop_cp != JMEM_CP_NULL)
        -:  898:  {
    #####:  899:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  900:
    #####:  901:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
    #####:  902:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  903:
    #####:  904:    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  905:    {
    #####:  906:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  907:          && ecma_is_property_configurable (current_prop_p->types[i]))
        -:  908:      {
    #####:  909:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i], prop_pair_p->names_cp[i]);
        -:  910:
    #####:  911:        if (index < old_length && index >= new_length)
        -:  912:        {
    #####:  913:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  914:
        -:  915:#if JERRY_PROPERTY_HASHMAP
    #####:  916:          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)
        -:  917:          {
    #####:  918:            hashmap_status =
    #####:  919:              ecma_property_hashmap_delete (object_p, prop_pair_p->names_cp[i], current_prop_p->types + i);
        -:  920:          }
        -:  921:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  922:
    #####:  923:          ecma_gc_free_property (object_p, prop_pair_p, i);
    #####:  924:          current_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  925:          prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  926:        }
        -:  927:      }
        -:  928:    }
        -:  929:
    #####:  930:    if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_DELETED
    #####:  931:        && current_prop_p->types[1] == ECMA_PROPERTY_TYPE_DELETED)
    #####:  932:    {
    #####:  933:      if (prev_prop_p == NULL)
        -:  934:      {
    #####:  935:        object_p->u1.property_list_cp = current_prop_p->next_property_cp;
        -:  936:      }
        -:  937:      else
        -:  938:      {
    #####:  939:        prev_prop_p->next_property_cp = current_prop_p->next_property_cp;
        -:  940:      }
        -:  941:
    #####:  942:      jmem_cpointer_t next_prop_cp = current_prop_p->next_property_cp;
    #####:  943:      ecma_dealloc_property_pair ((ecma_property_pair_t *) current_prop_p);
    #####:  944:      current_prop_cp = next_prop_cp;
        -:  945:    }
        -:  946:    else
        -:  947:    {
    #####:  948:      prev_prop_p = current_prop_p;
    #####:  949:      current_prop_cp = current_prop_p->next_property_cp;
        -:  950:    }
        -:  951:  }
        -:  952:
        -:  953:#if JERRY_PROPERTY_HASHMAP
    #####:  954:  if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  955:  {
    #####:  956:    ecma_property_hashmap_free (object_p);
    #####:  957:    ecma_property_hashmap_create (object_p);
        -:  958:  }
        -:  959:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  960:
    #####:  961:  return new_length;
        -:  962:} /* ecma_delete_array_properties */
        -:  963:
        -:  964:/**
        -:  965: * Update the length of an array to a new length
        -:  966: *
        -:  967: * @return ecma value
        -:  968: *         Returned value must be freed with ecma_free_value
        -:  969: */
        -:  970:ecma_value_t
        2:  971:ecma_op_array_object_set_length (ecma_object_t *object_p, /**< the array object */
        -:  972:                                 ecma_value_t new_value, /**< new length value */
        -:  973:                                 uint16_t flags) /**< property descriptor flags */
        -:  974:{
        2:  975:  ecma_number_t new_len_num;
        2:  976:  ecma_value_t completion = ecma_op_to_number (new_value, &new_len_num);
        -:  977:
        2:  978:  if (ECMA_IS_VALUE_ERROR (completion))
        -:  979:  {
    #####:  980:    return completion;
        -:  981:  }
        -:  982:
        2:  983:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion));
        -:  984:
        2:  985:  if (ecma_is_value_object (new_value))
        -:  986:  {
    #####:  987:    ecma_value_t compared_num_val = ecma_op_to_number (new_value, &new_len_num);
        -:  988:
    #####:  989:    if (ECMA_IS_VALUE_ERROR (compared_num_val))
        -:  990:    {
    #####:  991:      return compared_num_val;
        -:  992:    }
        -:  993:  }
        -:  994:
        2:  995:  uint32_t new_len_uint32 = ecma_number_to_uint32 (new_len_num);
        -:  996:
        2:  997:  if (((ecma_number_t) new_len_uint32) != new_len_num)
        -:  998:  {
    #####:  999:    return ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -: 1000:  }
        -: 1001:
        -: 1002:  /* Only the writable and data properties can be modified. */
        2: 1003:  if (flags
        2: 1004:      & (JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 1005:  {
    #####: 1006:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1007:  }
        -: 1008:
        2: 1009:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1010:
        2: 1011:  uint32_t old_len_uint32 = ext_object_p->u.array.length;
        -: 1012:
        2: 1013:  if (new_len_num == old_len_uint32)
        -: 1014:  {
        -: 1015:    /* Only the writable flag must be updated. */
        2: 1016:    if (flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 1017:    {
    #####: 1018:      if (!(flags & JERRY_PROP_IS_WRITABLE))
        -: 1019:      {
    #####: 1020:        if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1021:        {
    #####: 1022:          ecma_fast_array_convert_to_normal (object_p);
        -: 1023:        }
        -: 1024:
    #####: 1025:        ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1026:      }
    #####: 1027:      else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1028:      {
    #####: 1029:        return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1030:      }
        -: 1031:    }
        2: 1032:    return ECMA_VALUE_TRUE;
        -: 1033:  }
    #####: 1034:  else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1035:  {
    #####: 1036:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1037:  }
        -: 1038:
    #####: 1039:  uint32_t current_len_uint32 = new_len_uint32;
        -: 1040:
    #####: 1041:  if (new_len_uint32 < old_len_uint32)
        -: 1042:  {
    #####: 1043:    current_len_uint32 = ecma_delete_array_properties (object_p, new_len_uint32, old_len_uint32);
        -: 1044:  }
    #####: 1045:  else if (ecma_op_object_is_fast_array (object_p))
        -: 1046:  {
    #####: 1047:    ecma_fast_array_set_length (object_p, new_len_uint32);
        -: 1048:  }
        -: 1049:
    #####: 1050:  ext_object_p->u.array.length = current_len_uint32;
        -: 1051:
    #####: 1052:  if ((flags & JERRY_PROP_IS_WRITABLE_DEFINED) && !(flags & JERRY_PROP_IS_WRITABLE))
        -: 1053:  {
    #####: 1054:    if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1055:    {
    #####: 1056:      ecma_fast_array_convert_to_normal (object_p);
        -: 1057:    }
        -: 1058:
    #####: 1059:    ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1060:  }
        -: 1061:
    #####: 1062:  if (current_len_uint32 == new_len_uint32)
        -: 1063:  {
    #####: 1064:    return ECMA_VALUE_TRUE;
        -: 1065:  }
        -: 1066:
    #####: 1067:  return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1068:} /* ecma_op_array_object_set_length */
        -: 1069:
        -: 1070:/**
        -: 1071: * Property descriptor bitset for fast array data properties.
        -: 1072: * If the property desciptor fields contains all the flags below
        -: 1073: * attempt to stay fast access array during [[DefineOwnProperty]] operation.
        -: 1074: */
        -: 1075:#define ECMA_FAST_ARRAY_DATA_PROP_FLAGS                                                               \
        -: 1076:  (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_ENUMERABLE          \
        -: 1077:   | JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_WRITABLE_DEFINED \
        -: 1078:   | JERRY_PROP_IS_WRITABLE)
        -: 1079:
        -: 1080:/**
        -: 1081: * [[DefineOwnProperty]] ecma array object's operation
        -: 1082: *
        -: 1083: * See also:
        -: 1084: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1085: *          ECMA-262 v5, 15.4.5.1
        -: 1086: *
        -: 1087: * @return ecma value
        -: 1088: *         Returned value must be freed with ecma_free_value
        -: 1089: */
        -: 1090:ecma_value_t
    #####: 1091:ecma_op_array_object_define_own_property (ecma_object_t *object_p, /**< the array object */
        -: 1092:                                          ecma_string_t *property_name_p, /**< property name */
        -: 1093:                                          const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1094:{
    #####: 1095:  if (ecma_string_is_length (property_name_p))
        -: 1096:  {
    #####: 1097:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 1098:                  || !(property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));
    #####: 1099:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 1100:                  || !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));
    #####: 1101:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 1102:                  || !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE));
        -: 1103:
    #####: 1104:    if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1105:    {
    #####: 1106:      return ecma_op_array_object_set_length (object_p, property_desc_p->value, property_desc_p->flags);
        -: 1107:    }
        -: 1108:
    #####: 1109:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 1110:    ecma_value_t length_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -: 1111:
    #####: 1112:    ecma_value_t result = ecma_op_array_object_set_length (object_p, length_value, property_desc_p->flags);
        -: 1113:
    #####: 1114:    ecma_fast_free_value (length_value);
    #####: 1115:    return result;
        -: 1116:  }
        -: 1117:
    #####: 1118:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1119:
    #####: 1120:  if (ecma_op_object_is_fast_array (object_p))
        -: 1121:  {
    #####: 1122:    if ((property_desc_p->flags & ECMA_FAST_ARRAY_DATA_PROP_FLAGS) == ECMA_FAST_ARRAY_DATA_PROP_FLAGS)
        -: 1123:    {
    #####: 1124:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1125:
    #####: 1126:      if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1127:      {
    #####: 1128:        ecma_fast_array_convert_to_normal (object_p);
        -: 1129:      }
    #####: 1130:      else if (ecma_fast_array_set_property (object_p, index, property_desc_p->value))
        -: 1131:      {
    #####: 1132:        return ECMA_VALUE_TRUE;
        -: 1133:      }
        -: 1134:
    #####: 1135:      JERRY_ASSERT (!ecma_op_array_is_fast_array (ext_object_p));
        -: 1136:    }
        -: 1137:    else
        -: 1138:    {
    #####: 1139:      ecma_fast_array_convert_to_normal (object_p);
        -: 1140:    }
        -: 1141:  }
        -: 1142:
    #####: 1143:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
    #####: 1144:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1145:
    #####: 1146:  if (index == ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1147:  {
    #####: 1148:    return ecma_op_general_object_define_own_property (object_p, property_name_p, property_desc_p);
        -: 1149:  }
        -: 1150:
    #####: 1151:  bool update_length = (index >= ext_object_p->u.array.length);
        -: 1152:
    #####: 1153:  if (update_length && !ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1154:  {
    #####: 1155:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1156:  }
        -: 1157:
    #####: 1158:  ecma_property_descriptor_t prop_desc;
        -: 1159:
    #####: 1160:  prop_desc = *property_desc_p;
    #####: 1161:  prop_desc.flags &= (uint16_t) ~JERRY_PROP_SHOULD_THROW;
        -: 1162:
    #####: 1163:  ecma_value_t completition = ecma_op_general_object_define_own_property (object_p, property_name_p, &prop_desc);
    #####: 1164:  JERRY_ASSERT (ecma_is_value_boolean (completition));
        -: 1165:
    #####: 1166:  if (ecma_is_value_false (completition))
        -: 1167:  {
    #####: 1168:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1169:  }
        -: 1170:
    #####: 1171:  if (update_length)
        -: 1172:  {
    #####: 1173:    ext_object_p->u.array.length = index + 1;
        -: 1174:  }
        -: 1175:
    #####: 1176:  return ECMA_VALUE_TRUE;
        -: 1177:} /* ecma_op_array_object_define_own_property */
        -: 1178:
        -: 1179:/**
        -: 1180: * Get the length of the an array object
        -: 1181: *
        -: 1182: * @return the array length
        -: 1183: */
        -: 1184:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    21836: 1185:ecma_array_get_length (ecma_object_t *array_p) /**< array object */
        -: 1186:{
    21836: 1187:  JERRY_ASSERT (ecma_get_object_base_type (array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1188:
    21836: 1189:  return ((ecma_extended_object_t *) array_p)->u.array.length;
        -: 1190:} /* ecma_array_get_length */
        -: 1191:
        -: 1192:/**
        -: 1193: * The Array.prototype and %TypedArray%.prototype objects' 'toString' routine.
        -: 1194: *
        -: 1195: * See also:
        -: 1196: *          ECMA-262 v5, 15.4.4.2
        -: 1197: *          ECMA-262 v6, 22.1.3.7
        -: 1198: *
        -: 1199: * @return ecma value
        -: 1200: *         Returned value must be freed with ecma_free_value.
        -: 1201: */
        -: 1202:ecma_value_t
    #####: 1203:ecma_array_object_to_string (ecma_value_t this_arg) /**< this argument */
        -: 1204:{
    #####: 1205:  JERRY_ASSERT (ecma_is_value_object (this_arg));
        -: 1206:
    #####: 1207:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1208:
    #####: 1209:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
        -: 1210:
        -: 1211:  /* 2. */
    #####: 1212:  ecma_value_t join_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_JOIN);
    #####: 1213:  if (ECMA_IS_VALUE_ERROR (join_value))
        -: 1214:  {
    #####: 1215:    return join_value;
        -: 1216:  }
        -: 1217:
    #####: 1218:  if (!ecma_op_is_callable (join_value))
        -: 1219:  {
        -: 1220:    /* 3. */
    #####: 1221:    ret_value = ecma_builtin_helper_object_to_string (this_arg);
        -: 1222:  }
        -: 1223:  else
        -: 1224:  {
        -: 1225:    /* 4. */
    #####: 1226:    ecma_object_t *join_func_obj_p = ecma_get_object_from_value (join_value);
        -: 1227:
    #####: 1228:    ret_value = ecma_op_function_call (join_func_obj_p, this_arg, NULL, 0);
        -: 1229:  }
        -: 1230:
    #####: 1231:  ecma_free_value (join_value);
        -: 1232:
    #####: 1233:  return ret_value;
        -: 1234:} /* ecma_array_object_to_string */
        -: 1235:
        -: 1236:/**
        -: 1237: * @}
        -: 1238: * @}
        -: 1239: */
