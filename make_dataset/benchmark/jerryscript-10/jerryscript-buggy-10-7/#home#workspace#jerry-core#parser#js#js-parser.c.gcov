        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-extended-info.h"
        -:   18:#include "ecma-helpers.h"
        -:   19:#include "ecma-literal-storage.h"
        -:   20:#include "ecma-module.h"
        -:   21:
        -:   22:#include "debugger.h"
        -:   23:#include "jcontext.h"
        -:   24:#include "js-parser-internal.h"
        -:   25:#include "lit-char-helpers.h"
        -:   26:
        -:   27:#if JERRY_PARSER
        -:   28:
        -:   29:JERRY_STATIC_ASSERT ((int) ECMA_PARSE_STRICT_MODE == (int) PARSER_IS_STRICT,
        -:   30:                     ecma_parse_strict_mode_must_be_equal_to_parser_is_strict);
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:JERRY_STATIC_ASSERT (PARSER_SAVE_STATUS_FLAGS (PARSER_ALLOW_SUPER) == 0x1, incorrect_saving_of_ecma_parse_allow_super);
        -:   34:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_ALLOW_SUPER) == PARSER_ALLOW_SUPER,
        -:   35:                     incorrect_restoring_of_ecma_parse_allow_super);
        -:   36:
        -:   37:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_FUNCTION_CONTEXT) == 0,
        -:   38:                     ecma_parse_function_context_must_not_be_transformed);
        -:   39:#endif /* JERRY_ESNEXT */
        -:   40:
        -:   41:/** \addtogroup parser Parser
        -:   42: * @{
        -:   43: *
        -:   44: * \addtogroup jsparser JavaScript
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup jsparser_parser Parser
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:/**
        -:   52: * Compute real literal indicies.
        -:   53: *
        -:   54: * @return length of the prefix opcodes
        -:   55: */
        -:   56:static void
        1:   57:parser_compute_indicies (parser_context_t *context_p, /**< context */
        -:   58:                         uint16_t *ident_end, /**< end of the identifier group */
        -:   59:                         uint16_t *const_literal_end) /**< end of the const literal group */
        -:   60:{
        1:   61:  parser_list_iterator_t literal_iterator;
        -:   62:  lexer_literal_t *literal_p;
        -:   63:
        1:   64:  uint16_t ident_count = 0;
        1:   65:  uint16_t const_literal_count = 0;
        -:   66:
        -:   67:  uint16_t ident_index;
        -:   68:  uint16_t const_literal_index;
        -:   69:  uint16_t literal_index;
        -:   70:
        -:   71:  /* First phase: count the number of items in each group. */
        1:   72:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        7:   73:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:   74:  {
        5:   75:    switch (literal_p->type)
        -:   76:    {
        3:   77:      case LEXER_IDENT_LITERAL:
        -:   78:      {
        3:   79:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:   80:        {
        3:   81:          ident_count++;
        3:   82:          break;
        -:   83:        }
    #####:   84:        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   85:        {
    #####:   86:          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   87:          /* This literal should not be freed even if an error is encountered later. */
    #####:   88:          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:   89:        }
    #####:   90:        continue;
        -:   91:      }
        2:   92:      case LEXER_STRING_LITERAL:
        -:   93:      {
        2:   94:        const_literal_count++;
        2:   95:        break;
        -:   96:      }
    #####:   97:      case LEXER_NUMBER_LITERAL:
        -:   98:      {
    #####:   99:        const_literal_count++;
    #####:  100:        continue;
        -:  101:      }
    #####:  102:      case LEXER_FUNCTION_LITERAL:
        -:  103:      case LEXER_REGEXP_LITERAL:
        -:  104:      {
    #####:  105:        continue;
        -:  106:      }
    #####:  107:      default:
        -:  108:      {
    #####:  109:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  110:        continue;
        -:  111:      }
        -:  112:    }
        -:  113:
        5:  114:    const uint8_t *char_p = literal_p->u.char_p;
        5:  115:    uint32_t status_flags = context_p->status_flags;
        -:  116:
        5:  117:    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR) && literal_p->prop.length < 0xfff)
        -:  118:    {
        5:  119:      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);
        -:  120:
        5:  121:      if (bytes_to_end < 0xfffff)
        -:  122:      {
        5:  123:        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);
        5:  124:        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;
        5:  125:        status_flags |= PARSER_HAS_LATE_LIT_INIT;
        5:  126:        context_p->status_flags = status_flags;
        5:  127:        char_p = NULL;
        -:  128:      }
        -:  129:    }
        -:  130:
        5:  131:    if (char_p != NULL)
        -:  132:    {
    #####:  133:      literal_p->u.value = ecma_find_or_create_literal_string (char_p,
    #####:  134:                                                               literal_p->prop.length,
    #####:  135:                                                               (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        -:  136:
    #####:  137:      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:  138:      {
    #####:  139:        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);
        -:  140:        /* This literal should not be freed even if an error is encountered later. */
    #####:  141:        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
        1:  146:  ident_index = context_p->register_count;
        1:  147:  const_literal_index = (uint16_t) (ident_index + ident_count);
        1:  148:  literal_index = (uint16_t) (const_literal_index + const_literal_count);
        -:  149:
        -:  150:  /* Second phase: Assign an index to each literal. */
        1:  151:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  152:
        7:  153:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  154:  {
        5:  155:    switch (literal_p->type)
        -:  156:    {
        3:  157:      case LEXER_IDENT_LITERAL:
        -:  158:      {
        3:  159:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:  160:        {
        3:  161:          literal_p->prop.index = ident_index;
        3:  162:          ident_index++;
        -:  163:        }
        3:  164:        break;
        -:  165:      }
        2:  166:      case LEXER_STRING_LITERAL:
        -:  167:      case LEXER_NUMBER_LITERAL:
        -:  168:      {
        2:  169:        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);
        2:  170:        literal_p->prop.index = const_literal_index;
        2:  171:        const_literal_index++;
        2:  172:        break;
        -:  173:      }
    #####:  174:      case LEXER_FUNCTION_LITERAL:
        -:  175:      case LEXER_REGEXP_LITERAL:
        -:  176:      {
    #####:  177:        JERRY_ASSERT (literal_p->status_flags == 0);
        -:  178:
    #####:  179:        literal_p->prop.index = literal_index;
    #####:  180:        literal_index++;
    #####:  181:        break;
        -:  182:      }
    #####:  183:      default:
        -:  184:      {
    #####:  185:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL
        -:  186:                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);
    #####:  187:        break;
        -:  188:      }
        -:  189:    }
        -:  190:  }
        -:  191:
        1:  192:  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);
        1:  193:  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);
        1:  194:  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);
        -:  195:
        1:  196:  context_p->literal_count = literal_index;
        -:  197:
        1:  198:  *ident_end = ident_index;
        1:  199:  *const_literal_end = const_literal_index;
        1:  200:} /* parser_compute_indicies */
        -:  201:
        -:  202:/**
        -:  203: * Initialize literal pool.
        -:  204: */
        -:  205:static void
        1:  206:parser_init_literal_pool (parser_context_t *context_p, /**< context */
        -:  207:                          ecma_value_t *literal_pool_p) /**< start of literal pool */
        -:  208:{
        1:  209:  parser_list_iterator_t literal_iterator;
        -:  210:  lexer_literal_t *literal_p;
        -:  211:
        1:  212:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  213:
        7:  214:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  215:  {
        5:  216:    switch (literal_p->type)
        -:  217:    {
        3:  218:      case LEXER_IDENT_LITERAL:
        -:  219:      {
        3:  220:        if (!(literal_p->status_flags & LEXER_FLAG_USED))
        -:  221:        {
    #####:  222:          break;
        -:  223:        }
        -:  224:        /* FALLTHRU */
        -:  225:      }
        -:  226:      case LEXER_STRING_LITERAL:
        -:  227:      {
        5:  228:        ecma_value_t lit_value = literal_p->u.value;
        -:  229:
        5:  230:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        5:  231:        literal_pool_p[literal_p->prop.index] = lit_value;
        5:  232:        break;
        -:  233:      }
    #####:  234:      case LEXER_NUMBER_LITERAL:
        -:  235:      {
    #####:  236:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  237:
    #####:  238:        literal_pool_p[literal_p->prop.index] = literal_p->u.value;
    #####:  239:        break;
        -:  240:      }
    #####:  241:      case LEXER_FUNCTION_LITERAL:
        -:  242:      case LEXER_REGEXP_LITERAL:
        -:  243:      {
    #####:  244:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  245:
    #####:  246:        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index], literal_p->u.bytecode_p);
    #####:  247:        break;
        -:  248:      }
    #####:  249:      default:
        -:  250:      {
    #####:  251:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  252:        break;
        -:  253:      }
        -:  254:    }
    #####:  255:  }
        1:  256:} /* parser_init_literal_pool */
        -:  257:
        -:  258:/*
        -:  259: * During byte code post processing certain bytes are not
        -:  260: * copied into the final byte code buffer. For example, if
        -:  261: * one byte is enough for encoding a literal index, the
        -:  262: * second byte is not copied. However, when a byte is skipped,
        -:  263: * the offsets of those branches which crosses (jumps over)
        -:  264: * that byte code should also be decreased by one. Instead
        -:  265: * of finding these jumps every time when a byte is skipped,
        -:  266: * all branch offset updates are computed in one step.
        -:  267: *
        -:  268: * Branch offset mapping example:
        -:  269: *
        -:  270: * Let's assume that each parser_mem_page of the byte_code
        -:  271: * buffer is 8 bytes long and only 4 bytes are kept for a
        -:  272: * given page:
        -:  273: *
        -:  274: * +---+---+---+---+---+---+---+---+
        -:  275: * | X | 1 | 2 | 3 | X | 4 | X | X |
        -:  276: * +---+---+---+---+---+---+---+---+
        -:  277: *
        -:  278: * X marks those bytes which are removed. The resulting
        -:  279: * offset mapping is the following:
        -:  280: *
        -:  281: * +---+---+---+---+---+---+---+---+
        -:  282: * | 0 | 1 | 2 | 3 | 3 | 4 | 4 | 4 |
        -:  283: * +---+---+---+---+---+---+---+---+
        -:  284: *
        -:  285: * Each X is simply replaced by the index of the previous
        -:  286: * index starting from zero. This shows the number of
        -:  287: * copied bytes before a given byte including the byte
        -:  288: * itself. The last byte always shows the number of bytes
        -:  289: * copied from this page.
        -:  290: *
        -:  291: * This mapping allows recomputing all branch targets,
        -:  292: * since mapping[to] - mapping[from] is the new argument
        -:  293: * for forward branches. As for backward branches, the
        -:  294: * equation is reversed to mapping[from] - mapping[to].
        -:  295: *
        -:  296: * The mapping is relative to one page, so distance
        -:  297: * computation affecting multiple pages requires a loop.
        -:  298: * We should also note that only argument bytes can
        -:  299: * be skipped, so removed bytes cannot be targeted by
        -:  300: * branches. Valid branches always target instruction
        -:  301: * starts only.
        -:  302: */
        -:  303:
        -:  304:/**
        -:  305: * Recompute the argument of a forward branch.
        -:  306: *
        -:  307: * @return the new distance
        -:  308: */
        -:  309:static size_t
    #####:  310:parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  311:                              size_t full_distance, /**< full distance */
        -:  312:                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  313:{
    #####:  314:  size_t new_distance = 0;
        -:  315:
    #####:  316:  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)
        -:  317:  {
    #####:  318:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  319:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  320:    page_p = page_p->next_p;
        -:  321:  }
        -:  322:
    #####:  323:  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  324:  return new_distance - bytes_copied_before_jump;
        -:  325:} /* parser_update_forward_branch */
        -:  326:
        -:  327:/**
        -:  328: * Recompute the argument of a backward branch.
        -:  329: *
        -:  330: * @return the new distance
        -:  331: */
        -:  332:static size_t
    #####:  333:parser_update_backward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  334:                               size_t full_distance, /**< full distance */
        -:  335:                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  336:{
    #####:  337:  size_t new_distance = bytes_copied_before_jump;
        -:  338:
    #####:  339:  while (full_distance >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  340:  {
    #####:  341:    JERRY_ASSERT (page_p != NULL);
    #####:  342:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  343:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  344:    page_p = page_p->next_p;
        -:  345:  }
        -:  346:
    #####:  347:  if (full_distance > 0)
        -:  348:  {
    #####:  349:    size_t offset = PARSER_CBC_STREAM_PAGE_SIZE - full_distance;
        -:  350:
    #####:  351:    JERRY_ASSERT (page_p != NULL);
        -:  352:
    #####:  353:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  354:    new_distance -= page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  355:  }
        -:  356:
    #####:  357:  return new_distance;
        -:  358:} /* parser_update_backward_branch */
        -:  359:
        -:  360:/**
        -:  361: * Update targets of all branches in one step.
        -:  362: */
        -:  363:static void
        1:  364:parse_update_branches (parser_context_t *context_p, /**< context */
        -:  365:                       uint8_t *byte_code_p) /**< byte code */
        -:  366:{
        1:  367:  parser_mem_page_t *page_p = context_p->byte_code.first_p;
        1:  368:  parser_mem_page_t *prev_page_p = NULL;
        1:  369:  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;
        1:  370:  size_t last_position = context_p->byte_code.last_position;
        1:  371:  size_t offset = 0;
        1:  372:  size_t bytes_copied = 0;
        -:  373:
        1:  374:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  375:  {
    #####:  376:    last_page_p = NULL;
    #####:  377:    last_position = 0;
        -:  378:  }
        -:  379:
       38:  380:  while (page_p != last_page_p || offset < last_position)
        -:  381:  {
        -:  382:    /* Branch instructions are marked to improve search speed. */
       36:  383:    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)
        -:  384:    {
    #####:  385:      uint8_t *bytes_p = byte_code_p + bytes_copied;
        -:  386:      uint8_t flags;
    #####:  387:      uint8_t bytes_copied_before_jump = 0;
        -:  388:      size_t branch_argument_length;
        -:  389:      size_t target_distance;
        -:  390:      size_t length;
        -:  391:
    #####:  392:      if (offset > 0)
        -:  393:      {
    #####:  394:        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  395:      }
    #####:  396:      bytes_p += bytes_copied_before_jump;
        -:  397:
    #####:  398:      if (*bytes_p == CBC_EXT_OPCODE)
        -:  399:      {
    #####:  400:        bytes_p++;
    #####:  401:        flags = cbc_ext_flags[*bytes_p];
        -:  402:      }
        -:  403:      else
        -:  404:      {
    #####:  405:        flags = cbc_flags[*bytes_p];
        -:  406:      }
        -:  407:
    #####:  408:      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
    #####:  409:      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);
    #####:  410:      bytes_p++;
        -:  411:
        -:  412:      /* Decoding target. */
    #####:  413:      length = branch_argument_length;
    #####:  414:      target_distance = 0;
        -:  415:      do
        -:  416:      {
    #####:  417:        target_distance = (target_distance << 8) | *bytes_p;
    #####:  418:        bytes_p++;
    #####:  419:      } while (--length > 0);
        -:  420:
    #####:  421:      if (CBC_BRANCH_IS_FORWARD (flags))
        -:  422:      {
        -:  423:        /* Branch target was not set. */
    #####:  424:        JERRY_ASSERT (target_distance > 0);
        -:  425:
    #####:  426:        target_distance = parser_update_forward_branch (page_p, offset + target_distance, bytes_copied_before_jump);
        -:  427:      }
        -:  428:      else
        -:  429:      {
    #####:  430:        if (target_distance < offset)
        -:  431:        {
    #####:  432:          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];
    #####:  433:          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;
        -:  434:
    #####:  435:          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);
        -:  436:        }
    #####:  437:        else if (target_distance == offset)
        -:  438:        {
    #####:  439:          target_distance = bytes_copied_before_jump;
        -:  440:        }
        -:  441:        else
        -:  442:        {
    #####:  443:          target_distance =
    #####:  444:            parser_update_backward_branch (prev_page_p, target_distance - offset, bytes_copied_before_jump);
        -:  445:        }
        -:  446:      }
        -:  447:
        -:  448:      /* Encoding target again. */
        -:  449:      do
        -:  450:      {
    #####:  451:        bytes_p--;
    #####:  452:        *bytes_p = (uint8_t) (target_distance & 0xff);
    #####:  453:        target_distance >>= 8;
    #####:  454:      } while (--branch_argument_length > 0);
        -:  455:    }
        -:  456:
       36:  457:    offset++;
       36:  458:    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  459:    {
    #####:  460:      parser_mem_page_t *next_p = page_p->next_p;
        -:  461:
        -:  462:      /* We reverse the pages before the current page. */
    #####:  463:      page_p->next_p = prev_page_p;
    #####:  464:      prev_page_p = page_p;
        -:  465:
    #####:  466:      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  467:      page_p = next_p;
    #####:  468:      offset = 0;
        -:  469:    }
        -:  470:  }
        -:  471:
        -:  472:  /* After this point the pages of the byte code stream are
        -:  473:   * not used anymore. However, they needs to be freed during
        -:  474:   * cleanup, so the first and last pointers of the stream
        -:  475:   * descriptor are reversed as well. */
        1:  476:  if (last_page_p != NULL)
        -:  477:  {
        1:  478:    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);
        1:  479:    last_page_p->next_p = prev_page_p;
        -:  480:  }
        -:  481:  else
        -:  482:  {
    #####:  483:    last_page_p = context_p->byte_code.last_p;
        -:  484:  }
        -:  485:
        1:  486:  context_p->byte_code.last_p = context_p->byte_code.first_p;
        1:  487:  context_p->byte_code.first_p = last_page_p;
        1:  488:} /* parse_update_branches */
        -:  489:
        -:  490:#if JERRY_DEBUGGER
        -:  491:
        -:  492:/**
        -:  493: * Send current breakpoint list.
        -:  494: */
        -:  495:static void
        -:  496:parser_send_breakpoints (parser_context_t *context_p, /**< context */
        -:  497:                         jerry_debugger_header_type_t type) /**< message type */
        -:  498:{
        -:  499:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  500:  JERRY_ASSERT (context_p->breakpoint_info_count > 0);
        -:  501:
        -:  502:  jerry_debugger_send_data (type,
        -:  503:                            context_p->breakpoint_info,
        -:  504:                            context_p->breakpoint_info_count * sizeof (parser_breakpoint_info_t));
        -:  505:
        -:  506:  context_p->breakpoint_info_count = 0;
        -:  507:} /* parser_send_breakpoints */
        -:  508:
        -:  509:/**
        -:  510: * Append a breakpoint info.
        -:  511: */
        -:  512:void
        -:  513:parser_append_breakpoint_info (parser_context_t *context_p, /**< context */
        -:  514:                               jerry_debugger_header_type_t type, /**< message type */
        -:  515:                               uint32_t value) /**< line or offset of the breakpoint */
        -:  516:{
        -:  517:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  518:
        -:  519:  context_p->status_flags |= PARSER_DEBUGGER_BREAKPOINT_APPENDED;
        -:  520:
        -:  521:  if (context_p->breakpoint_info_count >= JERRY_DEBUGGER_SEND_MAX (parser_breakpoint_info_t))
        -:  522:  {
        -:  523:    parser_send_breakpoints (context_p, type);
        -:  524:  }
        -:  525:
        -:  526:  context_p->breakpoint_info[context_p->breakpoint_info_count].value = value;
        -:  527:  context_p->breakpoint_info_count = (uint16_t) (context_p->breakpoint_info_count + 1);
        -:  528:} /* parser_append_breakpoint_info */
        -:  529:
        -:  530:#endif /* JERRY_DEBUGGER */
        -:  531:
        -:  532:/**
        -:  533: * Forward iterator: move to the next byte code
        -:  534: *
        -:  535: * @param page_p page
        -:  536: * @param offset offset
        -:  537: */
        -:  538:#define PARSER_NEXT_BYTE(page_p, offset)           \
        -:  539:  do                                               \
        -:  540:  {                                                \
        -:  541:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:  542:    {                                              \
        -:  543:      offset = 0;                                  \
        -:  544:      page_p = page_p->next_p;                     \
        -:  545:    }                                              \
        -:  546:  } while (0)
        -:  547:
        -:  548:/**
        -:  549: * Forward iterator: move to the next byte code. Also updates the offset of the previous byte code.
        -:  550: *
        -:  551: * @param page_p page
        -:  552: * @param offset offset
        -:  553: * @param real_offset real offset
        -:  554: */
        -:  555:#define PARSER_NEXT_BYTE_UPDATE(page_p, offset, real_offset) \
        -:  556:  do                                                         \
        -:  557:  {                                                          \
        -:  558:    page_p->bytes[offset] = real_offset;                     \
        -:  559:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE)           \
        -:  560:    {                                                        \
        -:  561:      offset = 0;                                            \
        -:  562:      real_offset = 0;                                       \
        -:  563:      page_p = page_p->next_p;                               \
        -:  564:    }                                                        \
        -:  565:  } while (0)
        -:  566:
        -:  567:/**
        -:  568: * Post processing main function.
        -:  569: *
        -:  570: * @return compiled code
        -:  571: */
        -:  572:static ecma_compiled_code_t *
        1:  573:parser_post_processing (parser_context_t *context_p) /**< context */
        -:  574:{
        -:  575:  uint16_t literal_one_byte_limit;
        1:  576:  uint16_t ident_end;
        1:  577:  uint16_t const_literal_end;
        -:  578:  parser_mem_page_t *page_p;
        -:  579:  parser_mem_page_t *last_page_p;
        -:  580:  size_t last_position;
        -:  581:  size_t offset;
        -:  582:  size_t length;
        -:  583:  size_t literal_length;
        -:  584:  size_t total_size;
        -:  585:  uint8_t real_offset;
        -:  586:  uint8_t *byte_code_p;
        -:  587:  bool needs_uint16_arguments;
        1:  588:  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;
        -:  589:  ecma_compiled_code_t *compiled_code_p;
        -:  590:  ecma_value_t *literal_pool_p;
        -:  591:  uint8_t *dst_p;
        -:  592:
        -:  593:#if JERRY_ESNEXT
        1:  594:  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  595:      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  596:  {
    #####:  597:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  598:#ifndef JERRY_NDEBUG
    #####:  599:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  600:#endif /* !JERRY_NDEBUG */
        -:  601:
    #####:  602:    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -:  603:
    #####:  604:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
        -:  605:
    #####:  606:    parser_branch_t branch;
    #####:  607:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  608:    parser_set_branch_to_current_position (context_p, &branch);
        -:  609:
    #####:  610:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  611:  }
        -:  612:
        1:  613:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  614:  {
    #####:  615:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  616:#ifndef JERRY_NDEBUG
    #####:  617:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  618:#endif /* !JERRY_NDEBUG */
        -:  619:
    #####:  620:    if (context_p->stack_limit < PARSER_FINALLY_CONTEXT_STACK_ALLOCATION)
        -:  621:    {
    #####:  622:      context_p->stack_limit = PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -:  623:    }
        -:  624:
    #####:  625:    parser_branch_t branch;
        -:  626:
    #####:  627:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  628:    parser_set_branch_to_current_position (context_p, &branch);
        -:  629:
    #####:  630:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  631:  }
        -:  632:#endif /* JERRY_ESNEXT */
        -:  633:
        -:  634:#if JERRY_LINE_INFO
        1:  635:  JERRY_ASSERT (context_p->line_info_p != NULL);
        -:  636:#endif /* JERRY_LINE_INFO */
        -:  637:
        1:  638:  JERRY_ASSERT (context_p->stack_depth == 0);
        -:  639:#ifndef JERRY_NDEBUG
        1:  640:  JERRY_ASSERT (context_p->context_stack_depth == 0);
        -:  641:#endif /* !JERRY_NDEBUG */
        -:  642:
        1:  643:  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)
        -:  644:  {
    #####:  645:    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  646:  }
        -:  647:
        1:  648:  if (JERRY_UNLIKELY (context_p->script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -:  649:  {
        -:  650:    /* This is probably never happens in practice. */
    #####:  651:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  652:  }
        -:  653:
        1:  654:  context_p->script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        -:  655:
        1:  656:  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);
        -:  657:
        -:  658:#if JERRY_DEBUGGER
        -:  659:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  660:      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))
        -:  661:  {
        -:  662:    /* Always provide at least one breakpoint. */
        -:  663:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  664:    parser_flush_cbc (context_p);
        -:  665:
        -:  666:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -:  667:
        -:  668:    context_p->last_breakpoint_line = context_p->token.line;
        -:  669:  }
        -:  670:
        -:  671:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -:  672:  {
        -:  673:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -:  674:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -:  675:  }
        -:  676:#endif /* JERRY_DEBUGGER */
        -:  677:
        1:  678:  parser_compute_indicies (context_p, &ident_end, &const_literal_end);
        -:  679:
        1:  680:  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  681:  {
        1:  682:    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;
        -:  683:  }
        -:  684:  else
        -:  685:  {
    #####:  686:    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;
        -:  687:  }
        -:  688:
        1:  689:  last_page_p = context_p->byte_code.last_p;
        1:  690:  last_position = context_p->byte_code.last_position;
        -:  691:
        1:  692:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  693:  {
    #####:  694:    last_page_p = NULL;
    #####:  695:    last_position = 0;
        -:  696:  }
        -:  697:
        1:  698:  page_p = context_p->byte_code.first_p;
        1:  699:  offset = 0;
        1:  700:  length = 0;
        -:  701:
       15:  702:  while (page_p != last_page_p || offset < last_position)
        -:  703:  {
        -:  704:    uint8_t *opcode_p;
        -:  705:    uint8_t flags;
        -:  706:    size_t branch_offset_length;
        -:  707:
       13:  708:    opcode_p = page_p->bytes + offset;
       13:  709:    last_opcode = (cbc_opcode_t) (*opcode_p);
       13:  710:    PARSER_NEXT_BYTE (page_p, offset);
       13:  711:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);
       13:  712:    flags = cbc_flags[last_opcode];
       13:  713:    length++;
        -:  714:
       13:  715:    switch (last_opcode)
        -:  716:    {
    #####:  717:      case CBC_EXT_OPCODE:
        -:  718:      {
        -:  719:        cbc_ext_opcode_t ext_opcode;
        -:  720:
    #####:  721:        ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
    #####:  722:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
    #####:  723:        flags = cbc_ext_flags[ext_opcode];
    #####:  724:        PARSER_NEXT_BYTE (page_p, offset);
    #####:  725:        length++;
    #####:  726:        break;
        -:  727:      }
    #####:  728:      case CBC_POST_DECR:
        -:  729:      {
    #####:  730:        *opcode_p = CBC_PRE_DECR;
    #####:  731:        break;
        -:  732:      }
    #####:  733:      case CBC_POST_INCR:
        -:  734:      {
    #####:  735:        *opcode_p = CBC_PRE_INCR;
    #####:  736:        break;
        -:  737:      }
    #####:  738:      case CBC_POST_DECR_IDENT:
        -:  739:      {
    #####:  740:        *opcode_p = CBC_PRE_DECR_IDENT;
    #####:  741:        break;
        -:  742:      }
    #####:  743:      case CBC_POST_INCR_IDENT:
        -:  744:      {
    #####:  745:        *opcode_p = CBC_PRE_INCR_IDENT;
    #####:  746:        break;
        -:  747:      }
       13:  748:      default:
        -:  749:      {
       13:  750:        break;
        -:  751:      }
        -:  752:    }
        -:  753:
       28:  754:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  755:    {
       10:  756:      uint8_t *first_byte = page_p->bytes + offset;
       10:  757:      uint32_t literal_index = *first_byte;
        -:  758:
       10:  759:      PARSER_NEXT_BYTE (page_p, offset);
       10:  760:      length++;
        -:  761:
       10:  762:      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;
        -:  763:
       10:  764:      if (literal_index >= PARSER_REGISTER_START)
        -:  765:      {
    #####:  766:        literal_index -= PARSER_REGISTER_START;
        -:  767:      }
        -:  768:      else
        -:  769:      {
       10:  770:        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;
        -:  771:      }
        -:  772:
       10:  773:      if (literal_index <= literal_one_byte_limit)
        -:  774:      {
       10:  775:        *first_byte = (uint8_t) literal_index;
        -:  776:      }
        -:  777:      else
        -:  778:      {
    #####:  779:        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  780:        {
    #####:  781:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);
    #####:  782:          *first_byte = CBC_MAXIMUM_BYTE_VALUE;
    #####:  783:          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);
    #####:  784:          length++;
        -:  785:        }
        -:  786:        else
        -:  787:        {
    #####:  788:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);
    #####:  789:          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);
    #####:  790:          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);
    #####:  791:          length++;
        -:  792:        }
        -:  793:      }
       10:  794:      PARSER_NEXT_BYTE (page_p, offset);
        -:  795:
       10:  796:      if (flags & CBC_HAS_LITERAL_ARG2)
        -:  797:      {
        2:  798:        if (flags & CBC_HAS_LITERAL_ARG)
        -:  799:        {
        2:  800:          flags = CBC_HAS_LITERAL_ARG;
        -:  801:        }
        -:  802:        else
        -:  803:        {
    #####:  804:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -:  805:        }
        -:  806:      }
        -:  807:      else
        -:  808:      {
        8:  809:        break;
        -:  810:      }
        -:  811:    }
        -:  812:
       13:  813:    if (flags & CBC_HAS_BYTE_ARG)
        -:  814:    {
        -:  815:      /* This argument will be copied without modification. */
        3:  816:      PARSER_NEXT_BYTE (page_p, offset);
        3:  817:      length++;
        -:  818:    }
        -:  819:
       13:  820:    if (flags & CBC_HAS_BRANCH_ARG)
        -:  821:    {
    #####:  822:      bool prefix_zero = true;
        -:  823:
        -:  824:      /* The leading zeroes are dropped from the stream.
        -:  825:       * Although dropping these zeroes for backward
        -:  826:       * branches are unnecessary, we use the same
        -:  827:       * code path for simplicity. */
    #####:  828:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -:  829:
    #####:  830:      while (--branch_offset_length > 0)
        -:  831:      {
    #####:  832:        uint8_t byte = page_p->bytes[offset];
    #####:  833:        if (byte > 0 || !prefix_zero)
        -:  834:        {
    #####:  835:          prefix_zero = false;
    #####:  836:          length++;
        -:  837:        }
        -:  838:        else
        -:  839:        {
    #####:  840:          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
        -:  841:        }
    #####:  842:        PARSER_NEXT_BYTE (page_p, offset);
        -:  843:      }
        -:  844:
    #####:  845:      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1) && prefix_zero
    #####:  846:          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)
        -:  847:      {
        -:  848:        /* Uncoditional jumps which jump right after the instruction
        -:  849:         * are effectively NOPs. These jumps are removed from the
        -:  850:         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these
        -:  851:         * instructions, since this form is constructed during post
        -:  852:         * processing and cannot be emitted directly. */
    #####:  853:        *opcode_p = CBC_JUMP_FORWARD;
    #####:  854:        length--;
        -:  855:      }
        -:  856:      else
        -:  857:      {
        -:  858:        /* Other last bytes are always copied. */
    #####:  859:        length++;
        -:  860:      }
        -:  861:
    #####:  862:      PARSER_NEXT_BYTE (page_p, offset);
        -:  863:    }
        -:  864:  }
        -:  865:
        1:  866:  if (!(context_p->status_flags & PARSER_NO_END_LABEL) || !(PARSER_OPCODE_IS_RETURN (last_opcode)))
        -:  867:  {
        1:  868:    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  869:
        -:  870:#if JERRY_ESNEXT
        1:  871:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  872:    {
    #####:  873:      length++;
        -:  874:    }
        -:  875:#endif /* JERRY_ESNEXT */
        -:  876:
        1:  877:    length++;
        -:  878:  }
        -:  879:
        1:  880:  needs_uint16_arguments = false;
        1:  881:  total_size = sizeof (cbc_uint8_arguments_t);
        -:  882:
        1:  883:  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE
        1:  884:      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)
        -:  885:  {
    #####:  886:    needs_uint16_arguments = true;
    #####:  887:    total_size = sizeof (cbc_uint16_arguments_t);
        -:  888:  }
        -:  889:
        1:  890:  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);
        -:  891:
        1:  892:  total_size += literal_length + length;
        -:  893:
        1:  894:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -:  895:  {
    #####:  896:    total_size += context_p->argument_count * sizeof (ecma_value_t);
        -:  897:  }
        -:  898:
        -:  899:#if JERRY_ESNEXT
        -:  900:  /* function.name */
        1:  901:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -:  902:  {
        1:  903:    total_size += sizeof (ecma_value_t);
        -:  904:  }
        -:  905:
        1:  906:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -:  907:  {
    #####:  908:    total_size += sizeof (ecma_value_t);
        -:  909:  }
        -:  910:#endif /* JERRY_ESNEXT */
        -:  911:
        -:  912:#if JERRY_LINE_INFO
        1:  913:  total_size += sizeof (ecma_value_t);
        -:  914:#endif /* JERRY_LINE_INFO */
        -:  915:
        -:  916:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        1:  917:  uint8_t extended_info = 0;
        -:  918:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  919:
        -:  920:#if JERRY_ESNEXT
        1:  921:  if (context_p->argument_length != UINT16_MAX)
        -:  922:  {
    #####:  923:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH;
    #####:  924:    total_size += ecma_extended_info_get_encoded_length (context_p->argument_length);
        -:  925:  }
        -:  926:#endif /* JERRY_ESNEXT */
        -:  927:
        -:  928:#if JERRY_FUNCTION_TO_STRING
    #####:  929:  if (context_p->last_context_p != NULL)
        -:  930:  {
    #####:  931:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE;
        -:  932:
    #####:  933:    const uint8_t *start_p = context_p->source_start_p;
    #####:  934:    const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -:  935:
    #####:  936:    if (function_start_p < start_p || function_start_p >= start_p + context_p->source_size)
        -:  937:    {
        -:  938:      JERRY_ASSERT (context_p->arguments_start_p != NULL && function_start_p >= context_p->arguments_start_p
        -:  939:                    && function_start_p < context_p->arguments_start_p + context_p->arguments_size);
        -:  940:
    #####:  941:      start_p = context_p->arguments_start_p;
    #####:  942:      extended_info |= CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS;
        -:  943:    }
        -:  944:
    #####:  945:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (function_start_p - start_p));
    #####:  946:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (context_p->function_end_p - function_start_p));
        -:  947:  }
        -:  948:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  949:
        -:  950:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        1:  951:  if (extended_info != 0)
        -:  952:  {
    #####:  953:    total_size += sizeof (uint8_t);
        -:  954:  }
        -:  955:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  956:
        1:  957:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -:  958:
        1:  959:  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);
        -:  960:
        -:  961:#if JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE
        -:  962:  // Avoid getting junk bytes
    #####:  963:  memset (compiled_code_p, 0, total_size);
        -:  964:#endif /* JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE */
        -:  965:
        -:  966:#if JERRY_MEM_STATS
    #####:  967:  jmem_stats_allocate_byte_code_bytes (total_size);
        -:  968:#endif /* JERRY_MEM_STATS */
        -:  969:
        1:  970:  byte_code_p = (uint8_t *) compiled_code_p;
        1:  971:  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);
        1:  972:  compiled_code_p->refs = 1;
        1:  973:  compiled_code_p->status_flags = 0;
        -:  974:
        -:  975:#if JERRY_ESNEXT
        1:  976:  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -:  977:  {
    #####:  978:    JERRY_ASSERT (context_p->argument_count > 0);
    #####:  979:    context_p->argument_count--;
        -:  980:  }
        -:  981:#endif /* JERRY_ESNEXT */
        -:  982:
        1:  983:  if (needs_uint16_arguments)
        -:  984:  {
    #####:  985:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  986:
    #####:  987:    args_p->stack_limit = context_p->stack_limit;
    #####:  988:    args_p->script_value = context_p->script_value;
    #####:  989:    args_p->argument_end = context_p->argument_count;
    #####:  990:    args_p->register_end = context_p->register_count;
    #####:  991:    args_p->ident_end = ident_end;
    #####:  992:    args_p->const_literal_end = const_literal_end;
    #####:  993:    args_p->literal_end = context_p->literal_count;
        -:  994:
    #####:  995:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;
    #####:  996:    byte_code_p += sizeof (cbc_uint16_arguments_t);
        -:  997:  }
        -:  998:  else
        -:  999:  {
        1: 1000:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 1001:
        1: 1002:    args_p->stack_limit = (uint8_t) context_p->stack_limit;
        1: 1003:    args_p->argument_end = (uint8_t) context_p->argument_count;
        1: 1004:    args_p->script_value = context_p->script_value;
        1: 1005:    args_p->register_end = (uint8_t) context_p->register_count;
        1: 1006:    args_p->ident_end = (uint8_t) ident_end;
        1: 1007:    args_p->const_literal_end = (uint8_t) const_literal_end;
        1: 1008:    args_p->literal_end = (uint8_t) context_p->literal_count;
        -: 1009:
        1: 1010:    byte_code_p += sizeof (cbc_uint8_arguments_t);
        -: 1011:  }
        -: 1012:
        -: 1013:  uint16_t encoding_limit;
        -: 1014:  uint16_t encoding_delta;
        -: 1015:
        1: 1016:  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)
        -: 1017:  {
    #####: 1018:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;
    #####: 1019:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1020:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1021:  }
        -: 1022:  else
        -: 1023:  {
        1: 1024:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        1: 1025:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1026:  }
        -: 1027:
        1: 1028:  if (context_p->status_flags & PARSER_IS_STRICT)
        -: 1029:  {
    #####: 1030:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;
        -: 1031:  }
        -: 1032:
        1: 1033:  if ((context_p->status_flags & PARSER_ARGUMENTS_NEEDED) && PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1034:  {
    #####: 1035:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;
        -: 1036:  }
        -: 1037:
        1: 1038:  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))
        -: 1039:  {
    #####: 1040:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;
        -: 1041:  }
        -: 1042:
        1: 1043:  uint16_t function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_NORMAL);
        -: 1044:
        1: 1045:  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 1046:  {
    #####: 1047:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ACCESSOR);
        -: 1048:  }
        1: 1049:  else if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 1050:  {
        1: 1051:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_SCRIPT);
        -: 1052:  }
        -: 1053:#if JERRY_ESNEXT
    #####: 1054:  else if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)
        -: 1055:  {
    #####: 1056:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1057:    {
    #####: 1058:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_ARROW);
        -: 1059:    }
        -: 1060:    else
        -: 1061:    {
    #####: 1062:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ARROW);
        -: 1063:    }
        -: 1064:  }
    #####: 1065:  else if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1066:  {
    #####: 1067:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1068:    {
    #####: 1069:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1070:    }
        -: 1071:    else
        -: 1072:    {
    #####: 1073:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_GENERATOR);
        -: 1074:    }
        -: 1075:  }
    #####: 1076:  else if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1077:  {
    #####: 1078:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC);
        -: 1079:  }
    #####: 1080:  else if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)
        -: 1081:  {
    #####: 1082:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_CONSTRUCTOR);
        -: 1083:  }
    #####: 1084:  else if (context_p->status_flags & PARSER_IS_METHOD)
        -: 1085:  {
    #####: 1086:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_METHOD);
        -: 1087:  }
        -: 1088:
        1: 1089:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1090:  {
        1: 1091:    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));
        1: 1092:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;
        -: 1093:  }
        -: 1094:#endif /* JERRY_ESNEXT */
        -: 1095:
        1: 1096:  compiled_code_p->status_flags |= function_type;
        -: 1097:
        -: 1098:#if JERRY_LINE_INFO
        1: 1099:  compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_LINE_INFO;
        -: 1100:#endif /* JERRY_LINE_INFO */
        -: 1101:
        1: 1102:  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;
        1: 1103:  byte_code_p += literal_length;
        1: 1104:  dst_p = byte_code_p;
        -: 1105:
        1: 1106:  parser_init_literal_pool (context_p, literal_pool_p);
        -: 1107:
        1: 1108:  page_p = context_p->byte_code.first_p;
        1: 1109:  offset = 0;
        1: 1110:  real_offset = 0;
        1: 1111:  uint8_t last_register_index =
        1: 1112:    (uint8_t) JERRY_MIN (context_p->register_count, (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));
        -: 1113:
       15: 1114:  while (page_p != last_page_p || offset < last_position)
        -: 1115:  {
        -: 1116:    uint8_t flags;
        -: 1117:    uint8_t *opcode_p;
        -: 1118:    uint8_t *branch_mark_p;
        -: 1119:    cbc_opcode_t opcode;
        -: 1120:    size_t branch_offset_length;
        -: 1121:
       13: 1122:    opcode_p = dst_p;
       13: 1123:    branch_mark_p = page_p->bytes + offset;
       13: 1124:    opcode = (cbc_opcode_t) (*branch_mark_p);
       13: 1125:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        -: 1126:
       13: 1127:    if (opcode == CBC_JUMP_FORWARD)
        -: 1128:    {
        -: 1129:      /* These opcodes are deleted from the stream. */
    #####: 1130:      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;
        -: 1131:
        -: 1132:      do
        -: 1133:      {
    #####: 1134:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1135:      } while (--counter > 0);
        -: 1136:
    #####: 1137:      continue;
        -: 1138:    }
        -: 1139:
        -: 1140:    /* Storing the opcode */
       13: 1141:    *dst_p++ = (uint8_t) opcode;
       13: 1142:    real_offset++;
       13: 1143:    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
       13: 1144:    flags = cbc_flags[opcode];
        -: 1145:
        -: 1146:#if JERRY_DEBUGGER
        -: 1147:    if (opcode == CBC_BREAKPOINT_DISABLED)
        -: 1148:    {
        -: 1149:      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);
        -: 1150:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);
        -: 1151:    }
        -: 1152:#endif /* JERRY_DEBUGGER */
        -: 1153:
       13: 1154:    if (opcode == CBC_EXT_OPCODE)
        -: 1155:    {
        -: 1156:      cbc_ext_opcode_t ext_opcode;
        -: 1157:
    #####: 1158:      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
    #####: 1159:      flags = cbc_ext_flags[ext_opcode];
    #####: 1160:      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        -: 1161:
        -: 1162:      /* Storing the extended opcode */
    #####: 1163:      *dst_p++ = (uint8_t) ext_opcode;
    #####: 1164:      opcode_p++;
    #####: 1165:      real_offset++;
    #####: 1166:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1167:    }
        -: 1168:
        -: 1169:    /* Only literal and call arguments can be combined. */
       13: 1170:    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG) || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));
        -: 1171:
       28: 1172:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -: 1173:    {
       10: 1174:      uint16_t first_byte = page_p->bytes[offset];
        -: 1175:
       10: 1176:      uint8_t *opcode_pos_p = dst_p - 1;
       10: 1177:      *dst_p++ = (uint8_t) first_byte;
       10: 1178:      real_offset++;
       10: 1179:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1180:
       10: 1181:      if (first_byte > literal_one_byte_limit)
        -: 1182:      {
    #####: 1183:        *dst_p++ = page_p->bytes[offset];
        -: 1184:
    #####: 1185:        if (first_byte >= encoding_limit)
        -: 1186:        {
    #####: 1187:          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);
        -: 1188:        }
    #####: 1189:        real_offset++;
        -: 1190:      }
       10: 1191:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1192:
       10: 1193:      if (flags & CBC_HAS_LITERAL_ARG2)
        -: 1194:      {
        2: 1195:        if (flags & CBC_HAS_LITERAL_ARG)
        -: 1196:        {
        2: 1197:          flags = CBC_HAS_LITERAL_ARG;
        -: 1198:        }
        -: 1199:        else
        -: 1200:        {
    #####: 1201:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -: 1202:        }
        -: 1203:      }
        -: 1204:      else
        -: 1205:      {
        8: 1206:        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))
        -: 1207:        {
    #####: 1208:          *opcode_pos_p = CBC_MOV_IDENT;
        -: 1209:        }
        -: 1210:
        8: 1211:        break;
        -: 1212:      }
        -: 1213:    }
        -: 1214:
       13: 1215:    if (flags & CBC_HAS_BYTE_ARG)
        -: 1216:    {
        -: 1217:      /* This argument will be copied without modification. */
        3: 1218:      *dst_p++ = page_p->bytes[offset];
        3: 1219:      real_offset++;
        3: 1220:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        3: 1221:      continue;
        -: 1222:    }
        -: 1223:
       10: 1224:    if (flags & CBC_HAS_BRANCH_ARG)
        -: 1225:    {
    #####: 1226:      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;
    #####: 1227:      bool prefix_zero = true;
        -: 1228:
        -: 1229:      /* The leading zeroes are dropped from the stream. */
    #####: 1230:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -: 1231:
    #####: 1232:      while (--branch_offset_length > 0)
        -: 1233:      {
    #####: 1234:        uint8_t byte = page_p->bytes[offset];
    #####: 1235:        if (byte > 0 || !prefix_zero)
        -: 1236:        {
    #####: 1237:          prefix_zero = false;
    #####: 1238:          *dst_p++ = page_p->bytes[offset];
    #####: 1239:          real_offset++;
        -: 1240:        }
        -: 1241:        else
        -: 1242:        {
        -: 1243:          /* When a leading zero is dropped, the branch
        -: 1244:           * offset length must be decreased as well. */
    #####: 1245:          (*opcode_p)--;
        -: 1246:        }
    #####: 1247:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1248:      }
        -: 1249:
    #####: 1250:      *dst_p++ = page_p->bytes[offset];
    #####: 1251:      real_offset++;
    #####: 1252:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1253:      continue;
        -: 1254:    }
        -: 1255:  }
        -: 1256:
        -: 1257:#if JERRY_DEBUGGER
        -: 1258:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 1259:  {
        -: 1260:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);
        -: 1261:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -: 1262:  }
        -: 1263:#endif /* JERRY_DEBUGGER */
        -: 1264:
        1: 1265:  if (!(context_p->status_flags & PARSER_NO_END_LABEL))
        -: 1266:  {
        1: 1267:    *dst_p++ = CBC_RETURN_FUNCTION_END;
        -: 1268:
        -: 1269:#if JERRY_ESNEXT
        1: 1270:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1271:    {
    #####: 1272:      dst_p[-1] = CBC_EXT_OPCODE;
    #####: 1273:      dst_p[0] = CBC_EXT_ASYNC_EXIT;
    #####: 1274:      dst_p++;
        -: 1275:    }
        -: 1276:#endif /* JERRY_ESNEXT */
        -: 1277:  }
        1: 1278:  JERRY_ASSERT (dst_p == byte_code_p + length);
        -: 1279:
        -: 1280:#if JERRY_LINE_INFO
        1: 1281:  uint8_t *line_info_p = parser_line_info_generate (context_p);
        -: 1282:#endif /* JERRY_LINE_INFO */
        -: 1283:
        1: 1284:  parse_update_branches (context_p, byte_code_p);
        -: 1285:
        1: 1286:  parser_cbc_stream_free (&context_p->byte_code);
        -: 1287:
        1: 1288:  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)
        -: 1289:  {
        1: 1290:    parser_list_iterator_t literal_iterator;
        -: 1291:    lexer_literal_t *literal_p;
        1: 1292:    uint16_t register_count = context_p->register_count;
        -: 1293:
        1: 1294:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        7: 1295:    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -: 1296:    {
        5: 1297:      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT) && literal_p->prop.index >= register_count)
        -: 1298:      {
        5: 1299:        uint32_t source_data = literal_p->u.source_data;
        5: 1300:        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);
        5: 1301:        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,
        -: 1302:                                                                     source_data >> 20,
        5: 1303:                                                                     (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        5: 1304:        literal_pool_p[literal_p->prop.index] = lit_value;
        -: 1305:      }
        -: 1306:    }
        -: 1307:  }
        -: 1308:
        1: 1309:  ecma_value_t *base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);
        -: 1310:
        1: 1311:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1312:  {
    #####: 1313:    parser_list_iterator_t literal_iterator;
    #####: 1314:    uint16_t argument_count = 0;
    #####: 1315:    uint16_t register_count = context_p->register_count;
    #####: 1316:    base_p -= context_p->argument_count;
        -: 1317:
    #####: 1318:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
    #####: 1319:    while (argument_count < context_p->argument_count)
        -: 1320:    {
        -: 1321:      lexer_literal_t *literal_p;
    #####: 1322:      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);
        -: 1323:
    #####: 1324:      JERRY_ASSERT (literal_p != NULL);
        -: 1325:
    #####: 1326:      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1327:      {
    #####: 1328:        continue;
        -: 1329:      }
        -: 1330:
        -: 1331:      /* All arguments must be moved to initialized registers. */
    #####: 1332:      if (literal_p->type == LEXER_UNUSED_LITERAL)
        -: 1333:      {
    #####: 1334:        base_p[argument_count] = ECMA_VALUE_EMPTY;
    #####: 1335:        argument_count++;
    #####: 1336:        continue;
        -: 1337:      }
        -: 1338:
    #####: 1339:      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);
        -: 1340:
    #####: 1341:      JERRY_ASSERT (literal_p->prop.index >= register_count);
        -: 1342:
    #####: 1343:      base_p[argument_count] = literal_pool_p[literal_p->prop.index];
    #####: 1344:      argument_count++;
        -: 1345:    }
        -: 1346:  }
        -: 1347:
        -: 1348:#if JERRY_ESNEXT
        1: 1349:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -: 1350:  {
        1: 1351:    *(--base_p) = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1352:  }
        -: 1353:
        1: 1354:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 1355:  {
    #####: 1356:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_TAGGED_LITERALS;
    #####: 1357:    *(--base_p) = (ecma_value_t) context_p->tagged_template_literal_cp;
        -: 1358:  }
        -: 1359:#endif /* JERRY_ESNEXT */
        -: 1360:
        -: 1361:#if JERRY_LINE_INFO
        1: 1362:  ECMA_SET_INTERNAL_VALUE_POINTER (base_p[-1], line_info_p);
        -: 1363:#endif /* JERRY_LINE_INFO */
        -: 1364:
        -: 1365:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        1: 1366:  if (extended_info != 0)
        -: 1367:  {
        -: 1368:#if JERRY_LINE_INFO
    #####: 1369:    base_p--;
        -: 1370:#endif /* JERRY_LINE_INFO */
        -: 1371:
    #####: 1372:    uint8_t *extended_info_p = ((uint8_t *) base_p) - 1;
        -: 1373:
    #####: 1374:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_EXTENDED_INFO;
    #####: 1375:    *extended_info_p = extended_info;
        -: 1376:
        -: 1377:#if JERRY_ESNEXT
    #####: 1378:    if (context_p->argument_length != UINT16_MAX)
        -: 1379:    {
    #####: 1380:      ecma_extended_info_encode_vlq (&extended_info_p, context_p->argument_length);
        -: 1381:    }
        -: 1382:#endif /* JERRY_ESNEXT */
        -: 1383:
        -: 1384:#if JERRY_FUNCTION_TO_STRING
    #####: 1385:    if (context_p->last_context_p != NULL)
        -: 1386:    {
    #####: 1387:      const uint8_t *start_p = context_p->source_start_p;
        -: 1388:
    #####: 1389:      if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 1390:      {
    #####: 1391:        start_p = context_p->arguments_start_p;
        -: 1392:      }
        -: 1393:
    #####: 1394:      const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -: 1395:
    #####: 1396:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (function_start_p - start_p));
    #####: 1397:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (context_p->function_end_p - function_start_p));
        -: 1398:    }
        -: 1399:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1400:  }
        -: 1401:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -: 1402:
        -: 1403:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1404:  if (context_p->is_show_opcodes)
        -: 1405:  {
        -: 1406:    util_print_cbc (compiled_code_p);
        -: 1407:    JERRY_DEBUG_MSG ("\nByte code size: %d bytes\n", (int) length);
        -: 1408:    context_p->total_byte_code_size += (uint32_t) length;
        -: 1409:  }
        -: 1410:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1411:
        -: 1412:#if JERRY_DEBUGGER
        -: 1413:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1414:  {
        -: 1415:    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);
        -: 1416:  }
        -: 1417:#endif /* JERRY_DEBUGGER */
        -: 1418:
        1: 1419:  return compiled_code_p;
        -: 1420:} /* parser_post_processing */
        -: 1421:
        -: 1422:#undef PARSER_NEXT_BYTE
        -: 1423:#undef PARSER_NEXT_BYTE_UPDATE
        -: 1424:
        -: 1425:#if JERRY_ESNEXT
        -: 1426:/**
        -: 1427: * Resolve private identifier in direct eval context
        -: 1428: */
        -: 1429:static bool
    #####: 1430:parser_resolve_private_identifier_eval (parser_context_t *context_p) /**< context */
        -: 1431:{
        -: 1432:  ecma_string_t *search_key_p;
    #####: 1433:  uint8_t *destination_p = (uint8_t *) parser_malloc (context_p, context_p->token.lit_location.length);
        -: 1434:
    #####: 1435:  lexer_convert_ident_to_cesu8 (destination_p,
        -: 1436:                                context_p->token.lit_location.char_p,
    #####: 1437:                                context_p->token.lit_location.length);
        -: 1438:
    #####: 1439:  search_key_p = ecma_new_ecma_string_from_utf8 (destination_p, context_p->token.lit_location.length);
        -: 1440:
    #####: 1441:  parser_free (destination_p, context_p->token.lit_location.length);
        -: 1442:
    #####: 1443:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1444:
        -: 1445:  while (true)
        -: 1446:  {
    #####: 1447:    JERRY_ASSERT (lex_env_p != NULL);
        -: 1448:
    #####: 1449:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1450:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) != 0
    #####: 1451:        && !ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -: 1452:    {
    #####: 1453:      ecma_object_t *class_object_p = ((ecma_lexical_environment_class_t *) lex_env_p)->object_p;
        -: 1454:
    #####: 1455:      ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1456:      ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1457:
    #####: 1458:      if (prop_p != NULL)
        -: 1459:      {
    #####: 1460:        ecma_value_t *collection_p =
    #####: 1461:          ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1462:        ecma_value_t *current_p = collection_p + 1;
    #####: 1463:        ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1464:
    #####: 1465:        while (current_p < end_p)
        -: 1466:        {
    #####: 1467:          current_p++; /* skip kind */
    #####: 1468:          ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1469:          current_p++; /* skip value */
        -: 1470:
    #####: 1471:          JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1472:
    #####: 1473:          ecma_string_t *private_key_desc_p =
    #####: 1474:            ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1475:
    #####: 1476:          if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1477:          {
    #####: 1478:            ecma_deref_ecma_string (search_key_p);
    #####: 1479:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1480:            return true;
        -: 1481:          }
        -: 1482:        }
        -: 1483:      }
        -: 1484:    }
        -: 1485:
    #####: 1486:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -: 1487:    {
    #####: 1488:      break;
        -: 1489:    }
        -: 1490:
    #####: 1491:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1492:  }
        -: 1493:
    #####: 1494:  ecma_deref_ecma_string (search_key_p);
    #####: 1495:  return false;
        -: 1496:} /* parser_resolve_private_identifier_eval */
        -: 1497:
        -: 1498:/**
        -: 1499: * Resolve private identifier
        -: 1500: */
        -: 1501:void
    #####: 1502:parser_resolve_private_identifier (parser_context_t *context_p) /**< context */
        -: 1503:{
    #####: 1504:  if ((context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL) && parser_resolve_private_identifier_eval (context_p))
        -: 1505:  {
    #####: 1506:    return;
        -: 1507:  }
        -: 1508:
    #####: 1509:  parser_private_context_t *context_iter_p = context_p->private_context_p;
        -: 1510:
    #####: 1511:  while (context_iter_p)
        -: 1512:  {
    #####: 1513:    if (context_iter_p == NULL || !(context_iter_p->opts & SCANNER_PRIVATE_FIELD_ACTIVE))
        -: 1514:    {
    #####: 1515:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1516:    }
        -: 1517:
    #####: 1518:    if (!(context_iter_p->opts & SCANNER_SUCCESSFUL_CLASS_SCAN))
        -: 1519:    {
    #####: 1520:      return;
        -: 1521:    }
        -: 1522:
    #####: 1523:    parser_private_context_t *private_context_p = context_iter_p;
        -: 1524:
    #####: 1525:    if (private_context_p == NULL)
        -: 1526:    {
    #####: 1527:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1528:    }
        -: 1529:
    #####: 1530:    scanner_class_private_member_t *ident_iter = private_context_p->members_p;
        -: 1531:
    #####: 1532:    while (ident_iter)
        -: 1533:    {
    #####: 1534:      if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &ident_iter->loc))
        -: 1535:      {
    #####: 1536:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1537:        return;
        -: 1538:      }
        -: 1539:
    #####: 1540:      ident_iter = ident_iter->prev_p;
        -: 1541:    }
        -: 1542:
    #####: 1543:    context_iter_p = context_iter_p->prev_p;
        -: 1544:  }
        -: 1545:
    #####: 1546:  parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1547:} /* parser_resolve_private_identifier */
        -: 1548:
        -: 1549:/**
        -: 1550: * Save private field context
        -: 1551: */
        -: 1552:void
    #####: 1553:parser_save_private_context (parser_context_t *context_p, /**< context */
        -: 1554:                             parser_private_context_t *private_ctx_p, /**< private context */
        -: 1555:                             scanner_class_info_t *class_info_p) /**< class scanner info */
        -: 1556:{
    #####: 1557:  private_ctx_p->prev_p = context_p->private_context_p;
    #####: 1558:  context_p->private_context_p = private_ctx_p;
        -: 1559:
    #####: 1560:  context_p->private_context_p->members_p = class_info_p->members;
    #####: 1561:  context_p->private_context_p->opts = class_info_p->info.u8_arg;
    #####: 1562:  class_info_p->members = NULL;
    #####: 1563:} /* parser_save_private_context */
        -: 1564:
        -: 1565:/**
        -: 1566: * Release contexts private fields
        -: 1567: */
        -: 1568:static void
    #####: 1569:parser_free_private_fields (parser_context_t *context_p) /**< context */
        -: 1570:{
    #####: 1571:  parser_private_context_t *iter = context_p->private_context_p;
        -: 1572:
    #####: 1573:  while (iter != NULL)
        -: 1574:  {
    #####: 1575:    parser_private_context_t *prev_p = iter->prev_p;
    #####: 1576:    scanner_release_private_fields (iter->members_p);
    #####: 1577:    iter = prev_p;
        -: 1578:  }
    #####: 1579:} /* parser_free_private_fields */
        -: 1580:
        -: 1581:/**
        -: 1582: * Restore contexts private fields
        -: 1583: */
        -: 1584:void
    #####: 1585:parser_restore_private_context (parser_context_t *context_p, /**< context */
        -: 1586:                                parser_private_context_t *private_ctx_p) /**< private context */
        -: 1587:{
    #####: 1588:  scanner_release_private_fields (context_p->private_context_p->members_p);
    #####: 1589:  context_p->private_context_p = private_ctx_p->prev_p;
    #####: 1590:} /* parser_restore_private_context */
        -: 1591:#endif /* JERRY_ESNEXT */
        -: 1592:
        -: 1593:/**
        -: 1594: * Free identifiers and literals.
        -: 1595: */
        -: 1596:static void
    #####: 1597:parser_free_literals (parser_list_t *literal_pool_p) /**< literals */
        -: 1598:{
    #####: 1599:  parser_list_iterator_t literal_iterator;
        -: 1600:  lexer_literal_t *literal_p;
        -: 1601:
    #####: 1602:  parser_list_iterator_init (literal_pool_p, &literal_iterator);
    #####: 1603:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1604:  {
    #####: 1605:    util_free_literal (literal_p);
        -: 1606:  }
        -: 1607:
    #####: 1608:  parser_list_free (literal_pool_p);
    #####: 1609:} /* parser_free_literals */
        -: 1610:
        -: 1611:/**
        -: 1612: * Parse function arguments
        -: 1613: */
        -: 1614:static void
    #####: 1615:parser_parse_function_arguments (parser_context_t *context_p, /**< context */
        -: 1616:                                 lexer_token_type_t end_type) /**< expected end type */
        -: 1617:{
    #####: 1618:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1619:
        -: 1620:#if JERRY_ESNEXT
    #####: 1621:  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
    #####: 1622:  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));
        -: 1623:
    #####: 1624:  bool has_duplicated_arg_names = false;
        -: 1625:
    #####: 1626:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1627:  {
    #####: 1628:    parser_branch_t branch;
    #####: 1629:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_TRY_CREATE_CONTEXT, &branch);
    #####: 1630:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1631:
        -: 1632:#ifndef JERRY_NDEBUG
    #####: 1633:    context_p->context_stack_depth = PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 1634:#endif /* !JERRY_NDEBUG */
        -: 1635:  }
        -: 1636:#endif /* JERRY_ESNEXT */
        -: 1637:
    #####: 1638:  if (context_p->token.type == end_type)
        -: 1639:  {
        -: 1640:#if JERRY_ESNEXT
    #####: 1641:    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;
        -: 1642:
    #####: 1643:    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1644:    {
    #####: 1645:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1646:      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1647:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1648:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
    #####: 1649:      return;
        -: 1650:    }
        -: 1651:#endif /* JERRY_ESNEXT */
    #####: 1652:    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
    #####: 1653:    return;
        -: 1654:  }
        -: 1655:
        -: 1656:#if JERRY_ESNEXT
    #####: 1657:  bool has_complex_argument = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT) != 0;
        -: 1658:#endif /* JERRY_ESNEXT */
    #####: 1659:  bool is_strict = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT) != 0;
        -: 1660:
    #####: 1661:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1662:  scanner_set_active (context_p);
        -: 1663:
        -: 1664:#if JERRY_ESNEXT
    #####: 1665:  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;
        -: 1666:#endif /* JERRY_ESNEXT */
        -: 1667:
        -: 1668:  while (true)
    #####: 1669:  {
        -: 1670:#if JERRY_ESNEXT
    #####: 1671:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 1672:    {
    #####: 1673:      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)
        -: 1674:      {
    #####: 1675:        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);
        -: 1676:      }
    #####: 1677:      lexer_next_token (context_p);
        -: 1678:
    #####: 1679:      if (has_duplicated_arg_names)
        -: 1680:      {
    #####: 1681:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1682:      }
        -: 1683:
    #####: 1684:      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1685:    }
        -: 1686:
    #####: 1687:    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1688:    {
    #####: 1689:      if (has_duplicated_arg_names)
        -: 1690:      {
    #####: 1691:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1692:      }
        -: 1693:
    #####: 1694:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1695:
    #####: 1696:      if (!(context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM))
        -: 1697:      {
    #####: 1698:        parser_emit_cbc_literal (context_p,
        -: 1699:                                 CBC_PUSH_LITERAL,
    #####: 1700:                                 (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
        -: 1701:      }
        -: 1702:      else
        -: 1703:      {
    #####: 1704:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1705:      }
        -: 1706:
    #####: 1707:      uint32_t flags =
        -: 1708:        (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_LOCAL | PARSER_PATTERN_ARGUMENTS);
        -: 1709:
    #####: 1710:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1711:      {
    #####: 1712:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1713:        {
    #####: 1714:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1715:          {
    #####: 1716:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1717:          }
        -: 1718:
    #####: 1719:          if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1720:          {
    #####: 1721:            parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1722:          }
        -: 1723:
    #####: 1724:          if (context_p->argument_length == UINT16_MAX)
        -: 1725:          {
    #####: 1726:            context_p->argument_length = context_p->argument_count;
        -: 1727:          }
        -: 1728:
    #####: 1729:          flags |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 1730:        }
    #####: 1731:        else if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 1732:        {
    #####: 1733:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1734:          {
    #####: 1735:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1736:          }
    #####: 1737:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1738:        }
        -: 1739:        else
        -: 1740:        {
    #####: 1741:          parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 1742:        }
        -: 1743:      }
        -: 1744:
    #####: 1745:      parser_parse_initializer (context_p, flags);
        -: 1746:
    #####: 1747:      context_p->argument_count++;
    #####: 1748:      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1749:      {
    #####: 1750:        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1751:      }
        -: 1752:
    #####: 1753:      if (context_p->token.type != LEXER_COMMA)
        -: 1754:      {
    #####: 1755:        if (context_p->token.type != end_type)
        -: 1756:        {
    #####: 1757:          parser_error_msg_t error =
    #####: 1758:            ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1759:
    #####: 1760:          parser_raise_error (context_p, error);
        -: 1761:        }
    #####: 1762:        break;
        -: 1763:      }
        -: 1764:
    #####: 1765:      lexer_next_token (context_p);
        -: 1766:
    #####: 1767:      if (context_p->token.type == end_type)
        -: 1768:      {
    #####: 1769:        break;
        -: 1770:      }
    #####: 1771:      continue;
        -: 1772:    }
        -: 1773:#endif /* JERRY_ESNEXT */
        -: 1774:
    #####: 1775:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1776:    {
    #####: 1777:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1778:    }
        -: 1779:
    #####: 1780:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 1781:
    #####: 1782:    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1783:    {
    #####: 1784:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1785:    }
        -: 1786:
    #####: 1787:    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1788:    {
        -: 1789:#if JERRY_ESNEXT
    #####: 1790:      if ((context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT)
    #####: 1791:          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))
        -: 1792:      {
    #####: 1793:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1794:      }
    #####: 1795:      has_duplicated_arg_names = true;
        -: 1796:#endif /* JERRY_ESNEXT */
        -: 1797:
    #####: 1798:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1799:    }
        -: 1800:    else
        -: 1801:    {
    #####: 1802:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 1803:    }
        -: 1804:
    #####: 1805:    lexer_next_token (context_p);
        -: 1806:
        -: 1807:#if JERRY_ESNEXT
    #####: 1808:    uint16_t literal_index = context_p->lit_object.index;
        -: 1809:
    #####: 1810:    if (context_p->token.type == LEXER_ASSIGN)
        -: 1811:    {
    #####: 1812:      JERRY_ASSERT (has_complex_argument);
        -: 1813:
    #####: 1814:      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1815:      {
    #####: 1816:        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1817:      }
        -: 1818:
    #####: 1819:      if (context_p->argument_length == UINT16_MAX)
        -: 1820:      {
    #####: 1821:        context_p->argument_length = context_p->argument_count;
        -: 1822:      }
        -: 1823:
    #####: 1824:      parser_branch_t skip_init;
        -: 1825:
    #####: 1826:      if (has_duplicated_arg_names)
        -: 1827:      {
    #####: 1828:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1829:      }
        -: 1830:
    #####: 1831:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1832:
        -: 1833:      /* LEXER_ASSIGN does not overwrite lit_object. */
    #####: 1834:      parser_emit_cbc_literal (context_p,
        -: 1835:                               CBC_PUSH_LITERAL,
    #####: 1836:                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
    #####: 1837:      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 1838:
    #####: 1839:      lexer_next_token (context_p);
    #####: 1840:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1841:
    #####: 1842:      parser_set_branch_to_current_position (context_p, &skip_init);
        -: 1843:
    #####: 1844:      uint16_t opcode = CBC_ASSIGN_LET_CONST;
        -: 1845:
    #####: 1846:      if (literal_index >= PARSER_REGISTER_START)
        -: 1847:      {
    #####: 1848:        opcode = CBC_MOV_IDENT;
        -: 1849:      }
    #####: 1850:      else if (!scanner_literal_is_created (context_p, literal_index))
        -: 1851:      {
    #####: 1852:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1853:      }
        -: 1854:
    #####: 1855:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1856:    }
    #####: 1857:    else if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1858:    {
    #####: 1859:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1860:
    #####: 1861:      uint16_t opcode = CBC_MOV_IDENT;
        -: 1862:
    #####: 1863:      if (literal_index < PARSER_REGISTER_START)
        -: 1864:      {
    #####: 1865:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1866:
    #####: 1867:        if (scanner_literal_is_created (context_p, literal_index))
        -: 1868:        {
    #####: 1869:          opcode = CBC_ASSIGN_LET_CONST;
        -: 1870:        }
        -: 1871:      }
        -: 1872:
    #####: 1873:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1874:    }
    #####: 1875:    else if (has_complex_argument && literal_index < PARSER_REGISTER_START)
        -: 1876:    {
    #####: 1877:      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;
        -: 1878:
    #####: 1879:      if (scanner_literal_is_created (context_p, literal_index))
        -: 1880:      {
    #####: 1881:        opcode = CBC_ASSIGN_LET_CONST_LITERAL;
        -: 1882:      }
        -: 1883:
    #####: 1884:      parser_emit_cbc_literal_value (context_p,
        -: 1885:                                     opcode,
    #####: 1886:                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),
        -: 1887:                                     literal_index);
        -: 1888:    }
        -: 1889:#endif /* JERRY_ESNEXT */
        -: 1890:
    #####: 1891:    context_p->argument_count++;
    #####: 1892:    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1893:    {
    #####: 1894:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1895:    }
        -: 1896:
    #####: 1897:    if (context_p->token.type != LEXER_COMMA)
        -: 1898:    {
    #####: 1899:      if (context_p->token.type != end_type)
        -: 1900:      {
    #####: 1901:        parser_error_msg_t error =
    #####: 1902:          ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1903:
    #####: 1904:        parser_raise_error (context_p, error);
        -: 1905:      }
    #####: 1906:      break;
        -: 1907:    }
        -: 1908:
        -: 1909:#if JERRY_ESNEXT
    #####: 1910:    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1911:    {
    #####: 1912:      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);
        -: 1913:    }
        -: 1914:#endif /* JERRY_ESNEXT */
        -: 1915:
    #####: 1916:    lexer_next_token (context_p);
        -: 1917:
        -: 1918:#if JERRY_ESNEXT
    #####: 1919:    if (context_p->token.type == end_type)
        -: 1920:    {
    #####: 1921:      break;
        -: 1922:    }
        -: 1923:#endif /* JERRY_ESNEXT */
        -: 1924:  }
        -: 1925:
    #####: 1926:  scanner_revert_active (context_p);
        -: 1927:
        -: 1928:#if JERRY_ESNEXT
    #####: 1929:  JERRY_ASSERT (has_complex_argument || !(context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT));
        -: 1930:
    #####: 1931:  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1932:  {
    #####: 1933:    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1934:    parser_emit_cbc (context_p, CBC_POP);
        -: 1935:  }
        -: 1936:
    #####: 1937:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1938:  {
    #####: 1939:    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)
    #####: 1940:        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))
    #####: 1941:    {
    #####: 1942:      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 1943:
    #####: 1944:      parser_branch_t branch;
    #####: 1945:      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);
    #####: 1946:      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1947:
        -: 1948:#ifndef JERRY_NDEBUG
    #####: 1949:      PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -: 1950:#endif /* !JERRY_NDEBUG */
        -: 1951:    }
        -: 1952:    else
        -: 1953:    {
    #####: 1954:      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -: 1955:    }
        -: 1956:  }
        -: 1957:
    #####: 1958:  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);
        -: 1959:#endif /* JERRY_ESNEXT */
        -: 1960:
    #####: 1961:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
        -: 1962:
    #####: 1963:  if (is_strict)
        -: 1964:  {
    #####: 1965:    context_p->status_flags |= PARSER_IS_STRICT;
        -: 1966:  }
        -: 1967:} /* parser_parse_function_arguments */
        -: 1968:
        -: 1969:#ifndef JERRY_NDEBUG
        -: 1970:JERRY_STATIC_ASSERT (PARSER_SCANNING_SUCCESSFUL == PARSER_HAS_LATE_LIT_INIT,
        -: 1971:                     parser_scanning_successful_should_share_the_bit_position_with_parser_has_late_lit_init);
        -: 1972:#endif /* !JERRY_NDEBUG */
        -: 1973:
        -: 1974:/**
        -: 1975: * Parse and compile EcmaScript source code
        -: 1976: *
        -: 1977: * Note: source must be a valid UTF-8 string
        -: 1978: *
        -: 1979: * @return compiled code
        -: 1980: */
        -: 1981:static ecma_compiled_code_t *
        1: 1982:parser_parse_source (void *source_p, /**< source code */
        -: 1983:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 1984:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 1985:{
        1: 1986:  parser_context_t context;
        -: 1987:  ecma_compiled_code_t *compiled_code_p;
        -: 1988:
        1: 1989:  context.error = PARSER_ERR_NO_ERROR;
        1: 1990:  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;
        1: 1991:  context.global_status_flags = parse_opts;
        -: 1992:
        -: 1993:#if JERRY_ESNEXT
        1: 1994:  context.status_flags |= PARSER_RESTORE_STATUS_FLAGS (parse_opts);
        1: 1995:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        -: 1996:#endif /* JERRY_ESNEXT */
        -: 1997:
        1: 1998:  context.stack_depth = 0;
        1: 1999:  context.stack_limit = 0;
        1: 2000:  context.options_p = options_p;
        1: 2001:  context.script_p = NULL;
        1: 2002:  context.arguments_start_p = NULL;
        1: 2003:  context.arguments_size = 0;
        -: 2004:#if JERRY_MODULE_SYSTEM
        1: 2005:  if (context.global_status_flags & ECMA_PARSE_MODULE)
        -: 2006:  {
    #####: 2007:    context.status_flags |= PARSER_IS_STRICT;
        -: 2008:  }
        -: 2009:
        1: 2010:  context.module_names_p = NULL;
        -: 2011:#endif /* JERRY_MODULE_SYSTEM */
        -: 2012:
        1: 2013:  context.argument_list = ECMA_VALUE_EMPTY;
        -: 2014:
        1: 2015:  if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST))
        -: 2016:  {
    #####: 2017:    context.argument_list = context.options_p->argument_list;
        -: 2018:  }
        1: 2019:  else if (context.global_status_flags & ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE)
        -: 2020:  {
    #####: 2021:    JERRY_ASSERT (context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE);
    #####: 2022:    context.argument_list = ((ecma_value_t *) source_p)[1];
        -: 2023:  }
        -: 2024:
        1: 2025:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2026:  {
    #####: 2027:    JERRY_ASSERT (ecma_is_value_string (context.argument_list));
        -: 2028:
    #####: 2029:    context.status_flags |= PARSER_IS_FUNCTION;
        -: 2030:#if JERRY_ESNEXT
    #####: 2031:    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)
        -: 2032:    {
    #####: 2033:      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2034:    }
    #####: 2035:    if (parse_opts & ECMA_PARSE_ASYNC_FUNCTION)
        -: 2036:    {
    #####: 2037:      context.status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 2038:    }
        -: 2039:#endif /* JERRY_ESNEXT */
        -: 2040:
    #####: 2041:    ecma_string_t *string_p = ecma_get_string_from_value (context.argument_list);
    #####: 2042:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2043:
    #####: 2044:    context.arguments_start_p = ecma_string_get_chars (string_p, &context.arguments_size, NULL, NULL, &flags);
        -: 2045:
    #####: 2046:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2047:    {
    #####: 2048:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_ARG_LIST;
        -: 2049:    }
        -: 2050:  }
        -: 2051:
        1: 2052:  if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2053:  {
        1: 2054:    context.source_start_p = ((parser_source_char_t *) source_p)->source_p;
        1: 2055:    context.source_size = (lit_utf8_size_t) ((parser_source_char_t *) source_p)->source_size;
        -: 2056:  }
        -: 2057:  else
        -: 2058:  {
    #####: 2059:    ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2060:
    #####: 2061:    JERRY_ASSERT (ecma_is_value_string (source));
        -: 2062:
    #####: 2063:    ecma_string_t *string_p = ecma_get_string_from_value (source);
    #####: 2064:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2065:
    #####: 2066:    context.source_start_p = ecma_string_get_chars (string_p, &context.source_size, NULL, NULL, &flags);
        -: 2067:
    #####: 2068:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2069:    {
    #####: 2070:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_SOURCE;
        -: 2071:    }
        -: 2072:  }
        -: 2073:
        -: 2074:#if JERRY_DEBUGGER
        -: 2075:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2076:  {
        -: 2077:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,
        -: 2078:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -: 2079:                                context.source_start_p,
        -: 2080:                                context.source_size);
        -: 2081:  }
        -: 2082:#endif /* JERRY_DEBUGGER */
        -: 2083:
        1: 2084:  context.user_value = ECMA_VALUE_EMPTY;
        -: 2085:
        1: 2086:  if ((context.global_status_flags & ECMA_PARSE_EVAL) && JERRY_CONTEXT (vm_top_context_p) != NULL)
    #####: 2087:  {
    #####: 2088:    const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;
        -: 2089:
        -: 2090:#if JERRY_SNAPSHOT_EXEC
    #####: 2091:    if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 2092:    {
        -: 2093:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 2094:      ecma_value_t parent_script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 2095:      ;
    #####: 2096:      cbc_script_t *parent_script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, parent_script_value);
        -: 2097:
    #####: 2098:      if (parent_script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 2099:      {
    #####: 2100:        context.user_value = CBC_SCRIPT_GET_USER_VALUE (parent_script_p);
        -: 2101:      }
        -: 2102:#if JERRY_SNAPSHOT_EXEC
        -: 2103:    }
        -: 2104:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 2105:  }
        1: 2106:  else if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_USER_VALUE))
        -: 2107:  {
    #####: 2108:    context.user_value = context.options_p->user_value;
        -: 2109:  }
        -: 2110:
        -: 2111:#if JERRY_SOURCE_NAME
        1: 2112:  ecma_value_t source_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 2113:
        1: 2114:  if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_SOURCE_NAME))
        -: 2115:  {
        1: 2116:    JERRY_ASSERT (ecma_is_value_string (context.options_p->source_name));
        -: 2117:
        1: 2118:    ecma_ref_ecma_string (ecma_get_string_from_value (context.options_p->source_name));
        1: 2119:    source_name = context.options_p->source_name;
        -: 2120:  }
    #####: 2121:  else if (context.global_status_flags & ECMA_PARSE_EVAL)
        -: 2122:  {
    #####: 2123:    source_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_EVAL);
        -: 2124:  }
        -: 2125:#endif /* JERRY_SOURCE_NAME */
        -: 2126:
        1: 2127:  context.last_context_p = NULL;
        1: 2128:  context.last_statement.current_p = NULL;
        1: 2129:  context.token.flags = 0;
        1: 2130:  lexer_init_line_info (&context);
        -: 2131:
        1: 2132:  scanner_info_t scanner_info_end;
        1: 2133:  scanner_info_end.next_p = NULL;
        1: 2134:  scanner_info_end.source_p = NULL;
        1: 2135:  scanner_info_end.type = SCANNER_TYPE_END;
        1: 2136:  context.next_scanner_info_p = &scanner_info_end;
        1: 2137:  context.active_scanner_info_p = NULL;
        1: 2138:  context.skipped_scanner_info_p = NULL;
        1: 2139:  context.skipped_scanner_info_end_p = NULL;
        -: 2140:
        1: 2141:  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2142:
        1: 2143:  context.argument_count = 0;
        -: 2144:#if JERRY_ESNEXT
        1: 2145:  context.argument_length = UINT16_MAX;
        -: 2146:#endif /* JERRY_ESNEXT */
        1: 2147:  context.register_count = 0;
        1: 2148:  context.literal_count = 0;
        -: 2149:
        1: 2150:  parser_cbc_stream_init (&context.byte_code);
        1: 2151:  context.byte_code_size = 0;
        1: 2152:  parser_list_init (&context.literal_pool,
        -: 2153:                    sizeof (lexer_literal_t),
        -: 2154:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));
        1: 2155:  context.scope_stack_p = NULL;
        1: 2156:  context.scope_stack_size = 0;
        1: 2157:  context.scope_stack_top = 0;
        1: 2158:  context.scope_stack_reg_top = 0;
        -: 2159:#if JERRY_ESNEXT
        1: 2160:  context.scope_stack_global_end = 0;
        1: 2161:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        1: 2162:  context.private_context_p = NULL;
        -: 2163:#endif /* JERRY_ESNEXT */
        -: 2164:
        -: 2165:#ifndef JERRY_NDEBUG
        1: 2166:  context.context_stack_depth = 0;
        -: 2167:#endif /* !JERRY_NDEBUG */
        -: 2168:
        -: 2169:#if JERRY_LINE_INFO
        1: 2170:  context.line_info_p = NULL;
        -: 2171:#endif /* JERRY_LINE_INFO */
        -: 2172:
        -: 2173:#if JERRY_FUNCTION_TO_STRING
    #####: 2174:  context.function_start_p = NULL;
    #####: 2175:  context.function_end_p = NULL;
        -: 2176:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2177:
        -: 2178:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2179:  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES);
        -: 2180:  context.total_byte_code_size = 0;
        -: 2181:
        -: 2182:  if (context.is_show_opcodes)
        -: 2183:  {
        -: 2184:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2185:  }
        -: 2186:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2187:
        1: 2188:  scanner_scan_all (&context);
        -: 2189:
        1: 2190:  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))
        -: 2191:  {
    #####: 2192:    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);
        -: 2193:
        -: 2194:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2195:     * situation. However, a simple value can still be thrown. */
    #####: 2196:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2197:    return NULL;
        -: 2198:  }
        -: 2199:
        1: 2200:  size_t script_size = sizeof (cbc_script_t);
        -: 2201:
        1: 2202:  if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2203:  {
    #####: 2204:    script_size += sizeof (ecma_value_t);
        -: 2205:  }
        -: 2206:
        -: 2207:#if JERRY_FUNCTION_TO_STRING
    #####: 2208:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2209:  {
    #####: 2210:    script_size += sizeof (ecma_value_t);
        -: 2211:  }
        -: 2212:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2213:
        -: 2214:#if JERRY_MODULE_SYSTEM
        1: 2215:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2216:  {
    #####: 2217:    script_size += sizeof (ecma_value_t);
        -: 2218:  }
        -: 2219:#endif /* JERRY_MODULE_SYSTEM */
        -: 2220:
        1: 2221:  if (context.arguments_start_p == NULL)
        -: 2222:  {
        1: 2223:    context.source_p = context.source_start_p;
        1: 2224:    context.source_end_p = context.source_start_p + context.source_size;
        -: 2225:  }
        -: 2226:  else
        -: 2227:  {
    #####: 2228:    context.source_p = context.arguments_start_p;
    #####: 2229:    context.source_end_p = context.arguments_start_p + context.arguments_size;
        -: 2230:  }
        -: 2231:
        1: 2232:  context.u.allocated_buffer_p = NULL;
        1: 2233:  context.token.flags = 0;
        1: 2234:  lexer_init_line_info (&context);
        -: 2235:
        1: 2236:  parser_stack_init (&context);
        -: 2237:
        -: 2238:#if JERRY_DEBUGGER
        -: 2239:  context.breakpoint_info_count = 0;
        -: 2240:#endif /* JERRY_DEBUGGER */
        -: 2241:
        1: 2242:  JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_p);
        1: 2243:  JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2244:
        1: 2245:  if (context.next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT)
        -: 2246:  {
    #####: 2247:    context.status_flags |= PARSER_IS_STRICT;
        -: 2248:  }
        -: 2249:
        1: 2250:  PARSER_TRY (context.try_buffer)
        -: 2251:  {
        1: 2252:    context.script_p = parser_malloc (&context, script_size);
        -: 2253:
        1: 2254:    CBC_SCRIPT_SET_TYPE (context.script_p, context.user_value, CBC_SCRIPT_REF_ONE);
        -: 2255:
        1: 2256:    if (context.global_status_flags & (ECMA_PARSE_EVAL | ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE))
        -: 2257:    {
    #####: 2258:      context.script_p->refs_and_type |= CBC_SCRIPT_IS_EVAL_CODE;
        -: 2259:    }
        -: 2260:
        -: 2261:#if JERRY_BUILTIN_REALMS
        1: 2262:    context.script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -: 2263:#endif /* JERRY_BUILTIN_REALMS */
        -: 2264:
        -: 2265:#if JERRY_SOURCE_NAME
        1: 2266:    context.script_p->source_name = source_name;
        -: 2267:#endif /* JERRY_SOURCE_NAME */
        -: 2268:
        1: 2269:    ECMA_SET_INTERNAL_VALUE_POINTER (context.script_value, context.script_p);
        -: 2270:
        -: 2271:    /* Pushing a dummy value ensures the stack is never empty.
        -: 2272:     * This simplifies the stack management routines. */
        1: 2273:    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);
        -: 2274:    /* The next token must always be present to make decisions
        -: 2275:     * in the parser. Therefore when a token is consumed, the
        -: 2276:     * lexer_next_token() must be immediately called. */
        1: 2277:    lexer_next_token (&context);
        -: 2278:
        1: 2279:    if (context.arguments_start_p != NULL)
        -: 2280:    {
    #####: 2281:      parser_parse_function_arguments (&context, LEXER_EOS);
        -: 2282:
    #####: 2283:      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
    #####: 2284:      scanner_release_next (&context, sizeof (scanner_info_t));
        -: 2285:
    #####: 2286:      context.source_p = context.source_start_p;
    #####: 2287:      context.source_end_p = context.source_start_p + context.source_size;
    #####: 2288:      lexer_init_line_info (&context);
        -: 2289:
    #####: 2290:      lexer_next_token (&context);
        -: 2291:    }
        -: 2292:#if JERRY_MODULE_SYSTEM
        1: 2293:    else if (parse_opts & ECMA_PARSE_MODULE)
        -: 2294:    {
    #####: 2295:      parser_branch_t branch;
    #####: 2296:      parser_emit_cbc_forward_branch (&context, CBC_JUMP_FORWARD, &branch);
        -: 2297:
    #####: 2298:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_MODULE);
    #####: 2299:      parser_emit_cbc (&context, CBC_RETURN_FUNCTION_END);
        -: 2300:
    #####: 2301:      parser_set_branch_to_current_position (&context, &branch);
        -: 2302:    }
        -: 2303:#endif /* JERRY_MODULE_SYSTEM */
        -: 2304:    else
        -: 2305:    {
        1: 2306:      JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_start_p
        -: 2307:                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2308:
        -: 2309:#if JERRY_ESNEXT
        1: 2310:      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))
        -: 2311:      {
        1: 2312:        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2313:      }
        -: 2314:
        1: 2315:      if (!(parse_opts & ECMA_PARSE_EVAL))
        -: 2316:      {
        1: 2317:        scanner_check_variables (&context);
        -: 2318:      }
        -: 2319:#endif /* JERRY_ESNEXT */
        -: 2320:
        1: 2321:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);
        -: 2322:    }
        -: 2323:
        1: 2324:    parser_parse_statements (&context);
        -: 2325:
        1: 2326:    JERRY_ASSERT (context.last_statement.current_p == NULL);
        -: 2327:
        1: 2328:    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        1: 2329:    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);
        -: 2330:
        -: 2331:#ifndef JERRY_NDEBUG
        1: 2332:    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);
        1: 2333:    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));
        1: 2334:    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;
        -: 2335:#endif /* !JERRY_NDEBUG */
        -: 2336:
        1: 2337:    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));
        -: 2338:
        1: 2339:    compiled_code_p = parser_post_processing (&context);
        1: 2340:    parser_list_free (&context.literal_pool);
        -: 2341:
        -: 2342:    /* When parsing is successful, only the dummy value can be remained on the stack. */
        1: 2343:    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE && context.stack.last_position == 1
        -: 2344:                  && context.stack.first_p != NULL && context.stack.first_p->next_p == NULL
        -: 2345:                  && context.stack.last_p == NULL);
        -: 2346:
        1: 2347:    JERRY_ASSERT (context.arguments_start_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));
        -: 2348:
        1: 2349:    context.script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -: 2350:
        1: 2351:    if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2352:    {
    #####: 2353:      CBC_SCRIPT_GET_USER_VALUE (context.script_p) = ecma_copy_value_if_not_object (context.user_value);
        -: 2354:    }
        -: 2355:
        -: 2356:#if JERRY_MODULE_SYSTEM
        1: 2357:    if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2358:    {
    #####: 2359:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
    #####: 2360:      ecma_value_t module = ecma_make_object_value ((ecma_object_t *) JERRY_CONTEXT (module_current_p));
        -: 2361:
    #####: 2362:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = module;
    #####: 2363:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_IMPORT_META;
        -: 2364:    }
        -: 2365:#endif /* JERRY_MODULE_SYSTEM */
        -: 2366:
        -: 2367:#if JERRY_FUNCTION_TO_STRING
    #####: 2368:    if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2369:    {
        -: 2370:      ecma_string_t *string_p;
        -: 2371:
    #####: 2372:      if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER)
        -: 2373:      {
    #####: 2374:        string_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (context.source_start_p, context.source_size);
        -: 2375:      }
        -: 2376:      else
        -: 2377:      {
    #####: 2378:        string_p = ecma_new_ecma_string_from_utf8 (context.source_start_p, context.source_size);
        -: 2379:      }
        -: 2380:
    #####: 2381:      context.script_p->source_code = ecma_make_string_value (string_p);
        -: 2382:    }
        -: 2383:    else
        -: 2384:    {
    #####: 2385:      ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2386:
    #####: 2387:      ecma_ref_ecma_string (ecma_get_string_from_value (source));
    #####: 2388:      context.script_p->source_code = source;
        -: 2389:    }
        -: 2390:
    #####: 2391:    if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2392:    {
    #####: 2393:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
        -: 2394:
    #####: 2395:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = context.argument_list;
        -: 2396:
    #####: 2397:      ecma_ref_ecma_string (ecma_get_string_from_value (context.argument_list));
    #####: 2398:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS;
        -: 2399:    }
        -: 2400:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2401:
        -: 2402:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2403:    if (context.is_show_opcodes)
        -: 2404:    {
        -: 2405:      JERRY_DEBUG_MSG ("\n%s parsing successfully completed. Total byte code size: %d bytes\n",
        -: 2406:                       (context.arguments_start_p == NULL) ? "Script" : "Function",
        -: 2407:                       (int) context.total_byte_code_size);
        -: 2408:    }
        -: 2409:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2410:  }
        -: 2411:  PARSER_CATCH
        -: 2412:  {
    #####: 2413:    if (context.last_statement.current_p != NULL)
        -: 2414:    {
    #####: 2415:      parser_free_jumps (context.last_statement);
        -: 2416:    }
        -: 2417:
    #####: 2418:    parser_free_allocated_buffer (&context);
        -: 2419:
    #####: 2420:    scanner_cleanup (&context);
        -: 2421:
        -: 2422:#if JERRY_MODULE_SYSTEM
    #####: 2423:    if (context.module_names_p != NULL)
        -: 2424:    {
    #####: 2425:      ecma_module_release_module_names (context.module_names_p);
        -: 2426:    }
        -: 2427:#endif /* JERRY_MODULE_SYSTEM */
        -: 2428:
    #####: 2429:    compiled_code_p = NULL;
    #####: 2430:    parser_free_literals (&context.literal_pool);
    #####: 2431:    parser_cbc_stream_free (&context.byte_code);
        -: 2432:
        -: 2433:#if JERRY_SOURCE_NAME
    #####: 2434:    ecma_deref_ecma_string (ecma_get_string_from_value (context.script_p->source_name));
        -: 2435:#endif /* JERRY_SOURCE_NAME */
        -: 2436:
    #####: 2437:    if (context.script_p != NULL)
        -: 2438:    {
    #####: 2439:      JERRY_ASSERT (context.script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);
    #####: 2440:      jmem_heap_free_block (context.script_p, script_size);
        -: 2441:    }
        -: 2442:  }
        -: 2443:  PARSER_TRY_END
        -: 2444:
        1: 2445:  if (context.scope_stack_p != NULL)
        -: 2446:  {
        1: 2447:    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2448:  }
        -: 2449:
        -: 2450:#if JERRY_LINE_INFO
        1: 2451:  parser_line_info_free (context.line_info_p);
        -: 2452:#endif /* JERRY_LINE_INFO */
        -: 2453:
        -: 2454:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2455:  if (context.is_show_opcodes)
        -: 2456:  {
        -: 2457:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2458:  }
        -: 2459:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2460:
        1: 2461:  parser_stack_free (&context);
        -: 2462:
        1: 2463:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_SOURCE)
        -: 2464:  {
    #####: 2465:    jmem_heap_free_block ((void *) context.source_start_p, context.source_size);
        -: 2466:  }
        -: 2467:
        1: 2468:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_ARG_LIST)
        -: 2469:  {
    #####: 2470:    jmem_heap_free_block ((void *) context.arguments_start_p, context.arguments_size);
        -: 2471:  }
        -: 2472:
        1: 2473:  if (compiled_code_p != NULL)
        -: 2474:  {
        1: 2475:    return compiled_code_p;
        -: 2476:  }
        -: 2477:
        -: 2478:#if JERRY_DEBUGGER
        -: 2479:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2480:  {
        -: 2481:    jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);
        -: 2482:  }
        -: 2483:#endif /* JERRY_DEBUGGER */
        -: 2484:
    #####: 2485:  if (context.error == PARSER_ERR_OUT_OF_MEMORY)
        -: 2486:  {
        -: 2487:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2488:     * situation. However, a simple value can still be thrown. */
    #####: 2489:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2490:    return NULL;
        -: 2491:  }
        -: 2492:
        -: 2493:#if JERRY_ERROR_MESSAGES
        -: 2494:  ecma_string_t *err_str_p;
        -: 2495:
    #####: 2496:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2497:  {
    #####: 2498:    ecma_value_t error = jcontext_take_exception ();
    #####: 2499:    ecma_property_t *prop_p =
    #####: 2500:      ecma_find_named_property (ecma_get_object_from_value (error), ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE));
    #####: 2501:    ecma_free_value (error);
    #####: 2502:    JERRY_ASSERT (prop_p);
    #####: 2503:    err_str_p = ecma_get_string_from_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 2504:    ecma_ref_ecma_string (err_str_p);
        -: 2505:  }
        -: 2506:  else
        -: 2507:  {
    #####: 2508:    err_str_p = ecma_new_ecma_external_string_from_cesu8 (parser_get_error_utf8 (context.error),
    #####: 2509:                                                          parser_get_error_size (context.error),
        -: 2510:                                                          NULL);
        -: 2511:  }
    #####: 2512:  ecma_value_t err_str_val = ecma_make_string_value (err_str_p);
    #####: 2513:  ecma_value_t line_str_val = ecma_make_uint32_value (context.token.line);
    #####: 2514:  ecma_value_t col_str_val = ecma_make_uint32_value (context.token.column);
        -: 2515:
    #####: 2516:  ecma_raise_standard_error_with_format (JERRY_ERROR_SYNTAX,
        -: 2517:                                         "% [%:%:%]",
        -: 2518:                                         err_str_val,
        -: 2519:                                         source_name,
        -: 2520:                                         line_str_val,
        -: 2521:                                         col_str_val);
        -: 2522:
    #####: 2523:  ecma_free_value (col_str_val);
    #####: 2524:  ecma_free_value (line_str_val);
    #####: 2525:  ecma_deref_ecma_string (err_str_p);
        -: 2526:#else /* !JERRY_ERROR_MESSAGES */
        -: 2527:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2528:  {
        -: 2529:    jcontext_release_exception ();
        -: 2530:  }
        -: 2531:
        -: 2532:  ecma_raise_syntax_error (ECMA_ERR_EMPTY);
        -: 2533:#endif /* JERRY_ERROR_MESSAGES */
        -: 2534:
    #####: 2535:  return NULL;
        -: 2536:} /* parser_parse_source */
        -: 2537:
        -: 2538:/**
        -: 2539: * Save parser context before function parsing.
        -: 2540: */
        -: 2541:static void
    #####: 2542:parser_save_context (parser_context_t *context_p, /**< context */
        -: 2543:                     parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2544:{
    #####: 2545:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2546:
        -: 2547:#if JERRY_DEBUGGER
        -: 2548:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 2549:  {
        -: 2550:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -: 2551:    context_p->breakpoint_info_count = 0;
        -: 2552:  }
        -: 2553:#endif /* JERRY_DEBUGGER */
        -: 2554:
        -: 2555:#if JERRY_ESNEXT
    #####: 2556:  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2557:  {
    #####: 2558:    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2559:  }
        -: 2560:#endif /* JERRY_ESNEXT */
        -: 2561:
        -: 2562:  /* Save private part of the context. */
        -: 2563:
    #####: 2564:  saved_context_p->status_flags = context_p->status_flags;
    #####: 2565:  saved_context_p->stack_depth = context_p->stack_depth;
    #####: 2566:  saved_context_p->stack_limit = context_p->stack_limit;
    #####: 2567:  saved_context_p->prev_context_p = context_p->last_context_p;
    #####: 2568:  saved_context_p->last_statement = context_p->last_statement;
        -: 2569:
    #####: 2570:  saved_context_p->argument_count = context_p->argument_count;
        -: 2571:#if JERRY_ESNEXT
    #####: 2572:  saved_context_p->argument_length = context_p->argument_length;
        -: 2573:#endif /* JERRY_ESNEXT */
    #####: 2574:  saved_context_p->register_count = context_p->register_count;
    #####: 2575:  saved_context_p->literal_count = context_p->literal_count;
        -: 2576:
    #####: 2577:  saved_context_p->byte_code = context_p->byte_code;
    #####: 2578:  saved_context_p->byte_code_size = context_p->byte_code_size;
    #####: 2579:  saved_context_p->literal_pool_data = context_p->literal_pool.data;
    #####: 2580:  saved_context_p->scope_stack_p = context_p->scope_stack_p;
    #####: 2581:  saved_context_p->scope_stack_size = context_p->scope_stack_size;
    #####: 2582:  saved_context_p->scope_stack_top = context_p->scope_stack_top;
    #####: 2583:  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2584:#if JERRY_ESNEXT
    #####: 2585:  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;
    #####: 2586:  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;
        -: 2587:#endif /* JERRY_ESNEXT */
        -: 2588:
        -: 2589:#ifndef JERRY_NDEBUG
    #####: 2590:  saved_context_p->context_stack_depth = context_p->context_stack_depth;
        -: 2591:#endif /* !JERRY_NDEBUG */
        -: 2592:
        -: 2593:#if JERRY_LINE_INFO
    #####: 2594:  saved_context_p->line_info_p = context_p->line_info_p;
        -: 2595:#endif /* JERRY_LINE_INFO */
        -: 2596:
        -: 2597:#if JERRY_FUNCTION_TO_STRING
    #####: 2598:  saved_context_p->function_start_p = context_p->function_start_p;
        -: 2599:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2600:
        -: 2601:  /* Reset private part of the context. */
        -: 2602:
    #####: 2603:  context_p->status_flags &= PARSER_IS_STRICT;
    #####: 2604:  context_p->stack_depth = 0;
    #####: 2605:  context_p->stack_limit = 0;
    #####: 2606:  context_p->last_context_p = saved_context_p;
    #####: 2607:  context_p->last_statement.current_p = NULL;
        -: 2608:
    #####: 2609:  context_p->argument_count = 0;
        -: 2610:#if JERRY_ESNEXT
    #####: 2611:  context_p->argument_length = UINT16_MAX;
        -: 2612:#endif /* JERRY_ESNEXT */
    #####: 2613:  context_p->register_count = 0;
    #####: 2614:  context_p->literal_count = 0;
        -: 2615:
    #####: 2616:  parser_cbc_stream_init (&context_p->byte_code);
    #####: 2617:  context_p->byte_code_size = 0;
    #####: 2618:  parser_list_reset (&context_p->literal_pool);
    #####: 2619:  context_p->scope_stack_p = NULL;
    #####: 2620:  context_p->scope_stack_size = 0;
    #####: 2621:  context_p->scope_stack_top = 0;
    #####: 2622:  context_p->scope_stack_reg_top = 0;
        -: 2623:#if JERRY_ESNEXT
    #####: 2624:  context_p->scope_stack_global_end = 0;
    #####: 2625:  context_p->tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2626:#endif /* JERRY_ESNEXT */
        -: 2627:
        -: 2628:#ifndef JERRY_NDEBUG
    #####: 2629:  context_p->context_stack_depth = 0;
        -: 2630:#endif /* !JERRY_NDEBUG */
        -: 2631:
        -: 2632:#if JERRY_LINE_INFO
    #####: 2633:  context_p->line_info_p = NULL;
        -: 2634:#endif /* JERRY_LINE_INFO */
    #####: 2635:} /* parser_save_context */
        -: 2636:
        -: 2637:/**
        -: 2638: * Restore parser context after function parsing.
        -: 2639: */
        -: 2640:static void
    #####: 2641:parser_restore_context (parser_context_t *context_p, /**< context */
        -: 2642:                        parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2643:{
    #####: 2644:  parser_list_free (&context_p->literal_pool);
        -: 2645:
    #####: 2646:  if (context_p->scope_stack_p != NULL)
        -: 2647:  {
    #####: 2648:    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2649:  }
        -: 2650:
        -: 2651:#if JERRY_LINE_INFO
    #####: 2652:  parser_line_info_free (context_p->line_info_p);
        -: 2653:#endif /* JERRY_LINE_INFO */
        -: 2654:
        -: 2655:  /* Restore private part of the context. */
        -: 2656:
    #####: 2657:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2658:
    #####: 2659:  context_p->status_flags = saved_context_p->status_flags;
    #####: 2660:  context_p->stack_depth = saved_context_p->stack_depth;
    #####: 2661:  context_p->stack_limit = saved_context_p->stack_limit;
    #####: 2662:  context_p->last_context_p = saved_context_p->prev_context_p;
    #####: 2663:  context_p->last_statement = saved_context_p->last_statement;
        -: 2664:
    #####: 2665:  context_p->argument_count = saved_context_p->argument_count;
        -: 2666:#if JERRY_ESNEXT
    #####: 2667:  context_p->argument_length = saved_context_p->argument_length;
        -: 2668:#endif /* JERRY_ESNEXT */
    #####: 2669:  context_p->register_count = saved_context_p->register_count;
    #####: 2670:  context_p->literal_count = saved_context_p->literal_count;
        -: 2671:
    #####: 2672:  context_p->byte_code = saved_context_p->byte_code;
    #####: 2673:  context_p->byte_code_size = saved_context_p->byte_code_size;
    #####: 2674:  context_p->literal_pool.data = saved_context_p->literal_pool_data;
    #####: 2675:  context_p->scope_stack_p = saved_context_p->scope_stack_p;
    #####: 2676:  context_p->scope_stack_size = saved_context_p->scope_stack_size;
    #####: 2677:  context_p->scope_stack_top = saved_context_p->scope_stack_top;
    #####: 2678:  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;
        -: 2679:#if JERRY_ESNEXT
    #####: 2680:  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;
    #####: 2681:  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;
        -: 2682:#endif /* JERRY_ESNEXT */
        -: 2683:
        -: 2684:#ifndef JERRY_NDEBUG
    #####: 2685:  context_p->context_stack_depth = saved_context_p->context_stack_depth;
        -: 2686:#endif /* !JERRY_NDEBUG */
        -: 2687:
        -: 2688:#if JERRY_LINE_INFO
    #####: 2689:  context_p->line_info_p = saved_context_p->line_info_p;
        -: 2690:#endif /* JERRY_LINE_INFO */
    #####: 2691:} /* parser_restore_context */
        -: 2692:
        -: 2693:/**
        -: 2694: * Parse function code
        -: 2695: *
        -: 2696: * @return compiled code
        -: 2697: */
        -: 2698:ecma_compiled_code_t *
    #####: 2699:parser_parse_function (parser_context_t *context_p, /**< context */
        -: 2700:                       uint32_t status_flags) /**< extra status flags */
        -: 2701:{
    #####: 2702:  parser_saved_context_t saved_context;
        -: 2703:  ecma_compiled_code_t *compiled_code_p;
        -: 2704:
    #####: 2705:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
    #####: 2706:  parser_save_context (context_p, &saved_context);
    #####: 2707:  context_p->status_flags |= status_flags;
        -: 2708:#if JERRY_ESNEXT
    #####: 2709:  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;
        -: 2710:#endif /* JERRY_ESNEXT */
        -: 2711:
        -: 2712:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2713:  if (context_p->is_show_opcodes)
        -: 2714:  {
        -: 2715:#if JERRY_ESNEXT
        -: 2716:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n",
        -: 2717:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2718:#else /* !JERRY_ESNEXT */
        -: 2719:    JERRY_DEBUG_MSG ("\n--- Function parsing start ---\n\n");
        -: 2720:#endif /* JERRY_ESNEXT */
        -: 2721:  }
        -: 2722:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2723:
        -: 2724:#if JERRY_DEBUGGER
        -: 2725:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2726:  {
        -: 2727:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2728:  }
        -: 2729:#endif /* JERRY_DEBUGGER */
        -: 2730:
    #####: 2731:  lexer_next_token (context_p);
        -: 2732:
    #####: 2733:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2734:  {
    #####: 2735:    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -: 2736:  }
        -: 2737:
    #####: 2738:  lexer_next_token (context_p);
        -: 2739:
    #####: 2740:  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
    #####: 2741:  lexer_next_token (context_p);
        -: 2742:
    #####: 2743:  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER) && context_p->argument_count != 0)
        -: 2744:  {
    #####: 2745:    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);
        -: 2746:  }
        -: 2747:
    #####: 2748:  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER) && context_p->argument_count != 1)
        -: 2749:  {
    #####: 2750:    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);
        -: 2751:  }
        -: 2752:
        -: 2753:#if JERRY_ESNEXT
    #####: 2754:  if ((context_p->status_flags & (PARSER_CLASS_CONSTRUCTOR | PARSER_ALLOW_SUPER_CALL)) == PARSER_CLASS_CONSTRUCTOR)
        -: 2755:  {
    #####: 2756:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_FIELD_INIT);
    #####: 2757:    parser_flush_cbc (context_p);
        -: 2758:  }
        -: 2759:#endif /* JERRY_ESNEXT */
        -: 2760:
        -: 2761:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2762:  if (context_p->is_show_opcodes && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))
        -: 2763:  {
        -: 2764:    JERRY_DEBUG_MSG ("  Note: legacy (non-strict) argument definition\n\n");
        -: 2765:  }
        -: 2766:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2767:
    #####: 2768:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2769:  {
    #####: 2770:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2771:  }
        -: 2772:
    #####: 2773:  lexer_next_token (context_p);
    #####: 2774:  parser_parse_statements (context_p);
    #####: 2775:  compiled_code_p = parser_post_processing (context_p);
        -: 2776:
        -: 2777:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2778:  if (context_p->is_show_opcodes)
        -: 2779:  {
        -: 2780:#if JERRY_ESNEXT
        -: 2781:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n",
        -: 2782:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2783:#else /* !JERRY_ESNEXT */
        -: 2784:    JERRY_DEBUG_MSG ("\n--- Function parsing end ---\n\n");
        -: 2785:#endif /* JERRY_ESNEXT */
        -: 2786:  }
        -: 2787:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2788:
    #####: 2789:  parser_restore_context (context_p, &saved_context);
        -: 2790:
    #####: 2791:  return compiled_code_p;
        -: 2792:} /* parser_parse_function */
        -: 2793:
        -: 2794:#if JERRY_ESNEXT
        -: 2795:
        -: 2796:/**
        -: 2797: * Parse arrow function code
        -: 2798: *
        -: 2799: * @return compiled code
        -: 2800: */
        -: 2801:ecma_compiled_code_t *
    #####: 2802:parser_parse_arrow_function (parser_context_t *context_p, /**< context */
        -: 2803:                             uint32_t status_flags) /**< extra status flags */
        -: 2804:{
    #####: 2805:  parser_saved_context_t saved_context;
        -: 2806:  ecma_compiled_code_t *compiled_code_p;
        -: 2807:
    #####: 2808:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
    #####: 2809:  JERRY_ASSERT (status_flags & PARSER_IS_ARROW_FUNCTION);
    #####: 2810:  parser_save_context (context_p, &saved_context);
    #####: 2811:  context_p->status_flags |= status_flags;
    #####: 2812:  context_p->status_flags |=
    #####: 2813:    saved_context.status_flags & (PARSER_ALLOW_NEW_TARGET | PARSER_ALLOW_SUPER | PARSER_ALLOW_SUPER_CALL);
        -: 2814:
        -: 2815:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2816:  if (context_p->is_show_opcodes)
        -: 2817:  {
        -: 2818:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing start ---\n\n");
        -: 2819:  }
        -: 2820:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2821:
        -: 2822:#if JERRY_DEBUGGER
        -: 2823:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2824:  {
        -: 2825:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2826:  }
        -: 2827:#endif /* JERRY_DEBUGGER */
        -: 2828:
    #####: 2829:  if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2830:  {
    #####: 2831:    lexer_next_token (context_p);
    #####: 2832:    parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
    #####: 2833:    lexer_next_token (context_p);
        -: 2834:  }
        -: 2835:  else
        -: 2836:  {
    #####: 2837:    parser_parse_function_arguments (context_p, LEXER_ARROW);
        -: 2838:  }
        -: 2839:
    #####: 2840:  JERRY_ASSERT (context_p->token.type == LEXER_ARROW);
        -: 2841:
    #####: 2842:  lexer_next_token (context_p);
        -: 2843:
    #####: 2844:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2845:  {
    #####: 2846:    lexer_next_token (context_p);
        -: 2847:
    #####: 2848:    context_p->status_flags |= PARSER_IS_CLOSURE;
    #####: 2849:    parser_parse_statements (context_p);
        -: 2850:
        -: 2851:    /* Unlike normal function, arrow functions consume their close brace. */
    #####: 2852:    JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE);
    #####: 2853:    lexer_next_token (context_p);
        -: 2854:  }
        -: 2855:  else
        -: 2856:  {
    #####: 2857:    if (context_p->status_flags & PARSER_IS_STRICT && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2858:    {
    #####: 2859:      parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2860:    }
        -: 2861:
        -: 2862:#if JERRY_LINE_INFO
    #####: 2863:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2864:#endif /* JERRY_LINE_INFO */
        -: 2865:
    #####: 2866:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2867:
    #####: 2868:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2869:    {
    #####: 2870:      context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
        -: 2871:    }
        -: 2872:    else
        -: 2873:    {
    #####: 2874:      parser_emit_cbc (context_p, CBC_RETURN);
        -: 2875:    }
    #####: 2876:    parser_flush_cbc (context_p);
        -: 2877:
    #####: 2878:    lexer_update_await_yield (context_p, saved_context.status_flags);
        -: 2879:  }
        -: 2880:
    #####: 2881:  compiled_code_p = parser_post_processing (context_p);
        -: 2882:
        -: 2883:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2884:  if (context_p->is_show_opcodes)
        -: 2885:  {
        -: 2886:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing end ---\n\n");
        -: 2887:  }
        -: 2888:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2889:
    #####: 2890:  parser_restore_context (context_p, &saved_context);
        -: 2891:
    #####: 2892:  return compiled_code_p;
        -: 2893:} /* parser_parse_arrow_function */
        -: 2894:
        -: 2895:/**
        -: 2896: * Parse class fields
        -: 2897: *
        -: 2898: * @return compiled code
        -: 2899: */
        -: 2900:ecma_compiled_code_t *
    #####: 2901:parser_parse_class_fields (parser_context_t *context_p) /**< context */
        -: 2902:{
    #####: 2903:  parser_saved_context_t saved_context;
        -: 2904:  ecma_compiled_code_t *compiled_code_p;
        -: 2905:
    #####: 2906:  uint32_t extra_status_flags = context_p->status_flags & PARSER_INSIDE_WITH;
        -: 2907:
    #####: 2908:  parser_save_context (context_p, &saved_context);
    #####: 2909:  context_p->status_flags |= (PARSER_IS_FUNCTION | PARSER_ALLOW_SUPER | PARSER_INSIDE_CLASS_FIELD
        -: 2910:                              | PARSER_ALLOW_NEW_TARGET | extra_status_flags);
        -: 2911:
        -: 2912:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2913:  if (context_p->is_show_opcodes)
        -: 2914:  {
        -: 2915:    JERRY_DEBUG_MSG ("\n--- Class fields parsing start ---\n\n");
        -: 2916:  }
        -: 2917:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2918:
        -: 2919:#if JERRY_DEBUGGER
        -: 2920:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2921:  {
        -: 2922:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2923:  }
        -: 2924:#endif /* JERRY_DEBUGGER */
        -: 2925:
    #####: 2926:  const uint8_t *source_end_p = context_p->source_end_p;
    #####: 2927:  bool first_computed_class_field = true;
    #####: 2928:  scanner_location_t end_location;
    #####: 2929:  scanner_get_location (&end_location, context_p);
        -: 2930:
        -: 2931:  do
        -: 2932:  {
    #####: 2933:    uint8_t class_field_type = context_p->stack_top_uint8;
    #####: 2934:    parser_stack_pop_uint8 (context_p);
        -: 2935:
    #####: 2936:    scanner_range_t range = { 0 };
        -: 2937:
    #####: 2938:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2939:    {
    #####: 2940:      parser_stack_pop (context_p, &range, sizeof (scanner_range_t));
        -: 2941:    }
    #####: 2942:    else if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 2943:    {
    #####: 2944:      parser_stack_pop (context_p, &range.start_location, sizeof (scanner_location_t));
        -: 2945:    }
        -: 2946:
    #####: 2947:    uint16_t literal_index = 0;
    #####: 2948:    bool is_private = false;
        -: 2949:
    #####: 2950:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 2951:    {
    #####: 2952:      scanner_set_location (context_p, &range.start_location);
    #####: 2953:      uint32_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
    #####: 2954:      is_private = context_p->source_p[-1] == LIT_CHAR_HASHMARK;
        -: 2955:
    #####: 2956:      if (is_private)
        -: 2957:      {
    #####: 2958:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
        -: 2959:      }
        -: 2960:
    #####: 2961:      context_p->source_end_p = source_end_p;
    #####: 2962:      scanner_seek (context_p);
        -: 2963:
    #####: 2964:      lexer_expect_object_literal_id (context_p, ident_opts);
        -: 2965:
    #####: 2966:      literal_index = context_p->lit_object.index;
        -: 2967:
    #####: 2968:      if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2969:      {
    #####: 2970:        lexer_next_token (context_p);
    #####: 2971:        JERRY_ASSERT (context_p->token.type == LEXER_ASSIGN);
        -: 2972:      }
        -: 2973:    }
    #####: 2974:    else if (first_computed_class_field)
        -: 2975:    {
    #####: 2976:      parser_emit_cbc (context_p, CBC_PUSH_NUMBER_0);
    #####: 2977:      first_computed_class_field = false;
        -: 2978:    }
        -: 2979:
    #####: 2980:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 2981:    {
    #####: 2982:      if (!(class_field_type & PARSER_CLASS_FIELD_NORMAL))
        -: 2983:      {
    #####: 2984:        scanner_set_location (context_p, &range.start_location);
    #####: 2985:        scanner_seek (context_p);
        -: 2986:      }
        -: 2987:
    #####: 2988:      context_p->source_end_p = range.source_end_p;
    #####: 2989:      lexer_next_token (context_p);
        -: 2990:
        -: 2991:#if JERRY_LINE_INFO
    #####: 2992:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2993:#endif /* JERRY_LINE_INFO */
        -: 2994:
    #####: 2995:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2996:
    #####: 2997:      if (context_p->token.type != LEXER_EOS)
        -: 2998:      {
    #####: 2999:        parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 3000:      }
        -: 3001:    }
        -: 3002:    else
        -: 3003:    {
    #####: 3004:      parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 3005:    }
        -: 3006:
    #####: 3007:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3008:    {
    #####: 3009:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3010:
    #####: 3011:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3012:      {
    #####: 3013:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, literal_index);
        -: 3014:      }
    #####: 3015:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3016:      {
    #####: 3017:        uint32_t function_name_status_flags = is_private ? PARSER_PRIVATE_FUNCTION_NAME : 0;
    #####: 3018:        parser_set_function_name (context_p, function_literal_index, literal_index, function_name_status_flags);
        -: 3019:      }
        -: 3020:
    #####: 3021:      if (is_private)
        -: 3022:      {
    #####: 3023:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_PRIVATE_FIELD_ADD, literal_index);
        -: 3024:      }
        -: 3025:      else
        -: 3026:      {
    #####: 3027:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_DEFINE_FIELD, literal_index);
        -: 3028:      }
        -: 3029:
        -: 3030:      /* Prepare stack slot for assignment property reference base. Needed by vm.c */
    #####: 3031:      if (context_p->stack_limit == context_p->stack_depth)
        -: 3032:      {
    #####: 3033:        context_p->stack_limit++;
    #####: 3034:        JERRY_ASSERT (context_p->stack_limit <= PARSER_MAXIMUM_STACK_LIMIT);
        -: 3035:      }
        -: 3036:    }
        -: 3037:    else
        -: 3038:    {
    #####: 3039:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
    #####: 3040:      uint16_t opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD;
        -: 3041:
    #####: 3042:      if (function_literal_index < PARSER_NAMED_FUNCTION || function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3043:      {
    #####: 3044:        opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC;
        -: 3045:      }
        -: 3046:
    #####: 3047:      parser_flush_cbc (context_p);
        -: 3048:
        -: 3049:      /* The next opcode pushes two more temporary values onto the stack */
    #####: 3050:      if (context_p->stack_depth + 1 > context_p->stack_limit)
        -: 3051:      {
    #####: 3052:        context_p->stack_limit = (uint16_t) (context_p->stack_depth + 1);
    #####: 3053:        if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3054:        {
    #####: 3055:          parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3056:        }
        -: 3057:      }
        -: 3058:
    #####: 3059:      parser_emit_cbc_ext (context_p, opcode);
        -: 3060:    }
    #####: 3061:  } while (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -: 3062:
    #####: 3063:  if (!first_computed_class_field)
        -: 3064:  {
    #####: 3065:    parser_emit_cbc (context_p, CBC_POP);
        -: 3066:  }
        -: 3067:
    #####: 3068:  parser_flush_cbc (context_p);
    #####: 3069:  context_p->source_end_p = source_end_p;
    #####: 3070:  scanner_set_location (context_p, &end_location);
        -: 3071:
        -: 3072:#if JERRY_LINE_INFO
    #####: 3073:  if (context_p->line_info_p == NULL)
        -: 3074:  {
    #####: 3075:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3076:  }
        -: 3077:#endif /* JERRY_LINE_INFO */
        -: 3078:
    #####: 3079:  compiled_code_p = parser_post_processing (context_p);
        -: 3080:
        -: 3081:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 3082:  if (context_p->is_show_opcodes)
        -: 3083:  {
        -: 3084:    JERRY_DEBUG_MSG ("\n--- Class fields parsing end ---\n\n");
        -: 3085:  }
        -: 3086:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 3087:
    #####: 3088:  parser_restore_context (context_p, &saved_context);
        -: 3089:
    #####: 3090:  return compiled_code_p;
        -: 3091:} /* parser_parse_class_fields */
        -: 3092:
        -: 3093:/**
        -: 3094: * Check whether the last emitted cbc opcode was an anonymous function declaration
        -: 3095: *
        -: 3096: * @return PARSER_NOT_FUNCTION_LITERAL - if the last opcode is not a function literal
        -: 3097: *         PARSER_NAMED_FUNCTION - if the last opcode is not a named function declataion
        -: 3098: *         PARSER_ANONYMOUS_CLASS - if the last opcode is an anonymous class declaration
        -: 3099: *         literal index of the anonymous function literal - otherwise
        -: 3100: */
        -: 3101:uint16_t
        1: 3102:parser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */
        -: 3103:{
        1: 3104:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 3105:  {
    #####: 3106:    return PARSER_ANONYMOUS_CLASS;
        -: 3107:  }
        -: 3108:
        1: 3109:  if (context_p->last_cbc.literal_type != LEXER_FUNCTION_LITERAL)
        -: 3110:  {
        1: 3111:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3112:  }
        -: 3113:
    #####: 3114:  uint16_t literal_index = PARSER_NOT_FUNCTION_LITERAL;
        -: 3115:
    #####: 3116:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3117:  {
    #####: 3118:    literal_index = context_p->last_cbc.literal_index;
        -: 3119:  }
    #####: 3120:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3121:  {
    #####: 3122:    literal_index = context_p->last_cbc.value;
        -: 3123:  }
    #####: 3124:  else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -: 3125:  {
    #####: 3126:    literal_index = context_p->last_cbc.third_literal_index;
        -: 3127:  }
        -: 3128:  else
        -: 3129:  {
    #####: 3130:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3131:  }
        -: 3132:
        -: 3133:  const ecma_compiled_code_t *bytecode_p;
    #####: 3134:  bytecode_p = (const ecma_compiled_code_t *) (PARSER_GET_LITERAL (literal_index)->u.bytecode_p);
    #####: 3135:  bool is_anon =
    #####: 3136:    ecma_is_value_magic_string (*ecma_compiled_code_resolve_function_name (bytecode_p), LIT_MAGIC_STRING__EMPTY);
        -: 3137:
    #####: 3138:  return (is_anon ? literal_index : PARSER_NAMED_FUNCTION);
        -: 3139:} /* parser_check_anonymous_function_declaration */
        -: 3140:
        -: 3141:/**
        -: 3142: * Set the function name of the function literal corresponds to the given function literal index
        -: 3143: * to the given character buffer of literal corresponds to the given name index.
        -: 3144: */
        -: 3145:void
    #####: 3146:parser_set_function_name (parser_context_t *context_p, /**< context */
        -: 3147:                          uint16_t function_literal_index, /**< function literal index */
        -: 3148:                          uint16_t name_index, /**< function name literal index */
        -: 3149:                          uint32_t status_flags) /**< status flags */
        -: 3150:{
        -: 3151:  ecma_compiled_code_t *bytecode_p;
    #####: 3152:  bytecode_p = (ecma_compiled_code_t *) (PARSER_GET_LITERAL (function_literal_index)->u.bytecode_p);
        -: 3153:
    #####: 3154:  parser_compiled_code_set_function_name (context_p, bytecode_p, name_index, status_flags);
    #####: 3155:} /* parser_set_function_name */
        -: 3156:
        -: 3157:/**
        -: 3158: * Prepend the given prefix into the current function name literal
        -: 3159: *
        -: 3160: * @return pointer to the newly allocated buffer
        -: 3161: */
        -: 3162:static uint8_t *
    #####: 3163:parser_add_function_name_prefix (parser_context_t *context_p, /**< context */
        -: 3164:                                 const char *prefix_p, /**< prefix */
        -: 3165:                                 uint32_t prefix_size, /**< prefix's length */
        -: 3166:                                 uint32_t *name_length_p, /**< [out] function name's size */
        -: 3167:                                 lexer_literal_t *name_lit_p) /**< function name literal */
        -: 3168:{
    #####: 3169:  *name_length_p += prefix_size;
    #####: 3170:  uint8_t *name_buffer_p = (uint8_t *) parser_malloc (context_p, *name_length_p * sizeof (uint8_t));
    #####: 3171:  memcpy (name_buffer_p, prefix_p, prefix_size);
    #####: 3172:  memcpy (name_buffer_p + prefix_size, name_lit_p->u.char_p, name_lit_p->prop.length);
        -: 3173:
    #####: 3174:  return name_buffer_p;
        -: 3175:} /* parser_add_function_name_prefix */
        -: 3176:
        -: 3177:/**
        -: 3178: * Set the function name of the given compiled code
        -: 3179: * to the given character buffer of literal corresponds to the given name index.
        -: 3180: */
        -: 3181:void
    #####: 3182:parser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */
        -: 3183:                                        ecma_compiled_code_t *bytecode_p, /**< function literal index */
        -: 3184:                                        uint16_t name_index, /**< function name literal index */
        -: 3185:                                        uint32_t status_flags) /**< status flags */
        -: 3186:{
        -: 3187:  ecma_value_t *func_name_start_p;
    #####: 3188:  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);
        -: 3189:
    #####: 3190:  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))
        -: 3191:  {
    #####: 3192:    return;
        -: 3193:  }
        -: 3194:
    #####: 3195:  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;
    #####: 3196:  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;
        -: 3197:
    #####: 3198:  while (scope_stack_p > scope_stack_start_p)
        -: 3199:  {
    #####: 3200:    scope_stack_p--;
        -: 3201:
    #####: 3202:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC && scanner_decode_map_to (scope_stack_p) == name_index)
        -: 3203:    {
    #####: 3204:      name_index = scope_stack_p->map_from;
    #####: 3205:      break;
        -: 3206:    }
        -: 3207:  }
        -: 3208:
    #####: 3209:  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);
        -: 3210:
    #####: 3211:  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)
        -: 3212:  {
    #####: 3213:    return;
        -: 3214:  }
        -: 3215:
    #####: 3216:  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;
    #####: 3217:  uint32_t name_length = name_lit_p->prop.length;
        -: 3218:
    #####: 3219:  if (status_flags & PARSER_PRIVATE_FUNCTION_NAME)
        -: 3220:  {
    #####: 3221:    name_buffer_p = parser_add_function_name_prefix (context_p, "#", 1, &name_length, name_lit_p);
        -: 3222:  }
    #####: 3223:  else if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 3224:  {
    #####: 3225:    name_buffer_p = parser_add_function_name_prefix (context_p,
    #####: 3226:                                                     (status_flags & PARSER_IS_PROPERTY_GETTER) ? "get " : "set ",
        -: 3227:                                                     4,
        -: 3228:                                                     &name_length,
        -: 3229:                                                     name_lit_p);
        -: 3230:  }
        -: 3231:
    #####: 3232:  *func_name_start_p =
    #####: 3233:    ecma_find_or_create_literal_string (name_buffer_p, name_length, (status_flags & LEXER_FLAG_ASCII) != 0);
        -: 3234:
    #####: 3235:  if (name_buffer_p != name_lit_p->u.char_p)
        -: 3236:  {
    #####: 3237:    parser_free (name_buffer_p, name_length);
        -: 3238:  }
        -: 3239:} /* parser_compiled_code_set_function_name */
        -: 3240:
        -: 3241:#endif /* JERRY_ESNEXT */
        -: 3242:
        -: 3243:/**
        -: 3244: * Raise a parse error.
        -: 3245: */
        -: 3246:void
    #####: 3247:parser_raise_error (parser_context_t *context_p, /**< context */
        -: 3248:                    parser_error_msg_t error) /**< error code */
        -: 3249:{
        -: 3250:  /* Must be compatible with the scanner because
        -: 3251:   * the lexer might throws errors during prescanning. */
    #####: 3252:  parser_saved_context_t *saved_context_p = context_p->last_context_p;
        -: 3253:
    #####: 3254:  while (saved_context_p != NULL)
        -: 3255:  {
    #####: 3256:    parser_cbc_stream_free (&saved_context_p->byte_code);
        -: 3257:
        -: 3258:    /* First the current literal pool is freed, and then it is replaced
        -: 3259:     * by the literal pool coming from the saved context. Since literals
        -: 3260:     * are not used anymore, this is a valid replacement. The last pool
        -: 3261:     * is freed by parser_parse_source. */
        -: 3262:
    #####: 3263:    parser_free_literals (&context_p->literal_pool);
    #####: 3264:    context_p->literal_pool.data = saved_context_p->literal_pool_data;
        -: 3265:
    #####: 3266:    if (context_p->scope_stack_p != NULL)
        -: 3267:    {
    #####: 3268:      parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 3269:    }
    #####: 3270:    context_p->scope_stack_p = saved_context_p->scope_stack_p;
    #####: 3271:    context_p->scope_stack_size = saved_context_p->scope_stack_size;
        -: 3272:
    #####: 3273:    if (saved_context_p->last_statement.current_p != NULL)
        -: 3274:    {
    #####: 3275:      parser_free_jumps (saved_context_p->last_statement);
        -: 3276:    }
        -: 3277:
        -: 3278:#if JERRY_ESNEXT
    #####: 3279:    if (saved_context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3280:    {
    #####: 3281:      ecma_collection_t *collection =
    #####: 3282:        ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, saved_context_p->tagged_template_literal_cp);
    #####: 3283:      ecma_collection_free_template_literal (collection);
        -: 3284:    }
        -: 3285:#endif /* JERRY_ESNEXT  */
        -: 3286:
        -: 3287:#if JERRY_LINE_INFO
    #####: 3288:    parser_line_info_free (saved_context_p->line_info_p);
        -: 3289:#endif /* JERRY_LINE_INFO */
        -: 3290:
    #####: 3291:    saved_context_p = saved_context_p->prev_context_p;
        -: 3292:  }
        -: 3293:
        -: 3294:#if JERRY_ESNEXT
    #####: 3295:  parser_free_private_fields (context_p);
        -: 3296:
    #####: 3297:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3298:  {
    #####: 3299:    ecma_collection_t *collection =
    #####: 3300:      ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 3301:    ecma_collection_free_template_literal (collection);
        -: 3302:  }
        -: 3303:#endif /* JERRY_ESNEXT  */
        -: 3304:
    #####: 3305:  context_p->error = error;
    #####: 3306:  PARSER_THROW (context_p->try_buffer);
        -: 3307:  /* Should never been reached. */
        -: 3308:  JERRY_ASSERT (0);
        -: 3309:} /* parser_raise_error */
        -: 3310:
        -: 3311:#endif /* JERRY_PARSER */
        -: 3312:
        -: 3313:/**
        -: 3314: * Parse EcmaScript source code
        -: 3315: *
        -: 3316: * Note:
        -: 3317: *      if arg_list_p is not NULL, a function body is parsed
        -: 3318: *      returned value must be freed with ecma_free_value
        -: 3319: *
        -: 3320: * @return pointer to compiled byte code - if success
        -: 3321: *         NULL - otherwise
        -: 3322: */
        -: 3323:ecma_compiled_code_t *
        1: 3324:parser_parse_script (void *source_p, /**< source code */
        -: 3325:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 3326:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 3327:{
        -: 3328:#if JERRY_PARSER
        1: 3329:  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p, parse_opts, options_p);
        -: 3330:
        1: 3331:  if (JERRY_UNLIKELY (bytecode_p == NULL))
        -: 3332:  {
        -: 3333:    /* Exception has already thrown. */
    #####: 3334:    return NULL;
        -: 3335:  }
        -: 3336:
        -: 3337:#if JERRY_DEBUGGER
        -: 3338:  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3339:      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3340:  {
        -: 3341:    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);
        -: 3342:    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);
        -: 3343:
        -: 3344:    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)
        -: 3345:    {
        -: 3346:      jerry_debugger_receive (NULL);
        -: 3347:
        -: 3348:      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))
        -: 3349:      {
        -: 3350:        break;
        -: 3351:      }
        -: 3352:
        -: 3353:      jerry_debugger_transport_sleep ();
        -: 3354:    }
        -: 3355:  }
        -: 3356:#endif /* JERRY_DEBUGGER */
        -: 3357:
        1: 3358:  return bytecode_p;
        -: 3359:#else /* !JERRY_PARSER */
        -: 3360:  JERRY_UNUSED (arg_list_p);
        -: 3361:  JERRY_UNUSED (arg_list_size);
        -: 3362:  JERRY_UNUSED (source_p);
        -: 3363:  JERRY_UNUSED (source_size);
        -: 3364:  JERRY_UNUSED (parse_opts);
        -: 3365:  JERRY_UNUSED (source_name);
        -: 3366:
        -: 3367:  ecma_raise_syntax_error (ECMA_ERR_PARSER_NOT_SUPPORTED);
        -: 3368:  return NULL;
        -: 3369:#endif /* JERRY_PARSER */
        -: 3370:} /* parser_parse_script */
        -: 3371:
        -: 3372:/**
        -: 3373: * @}
        -: 3374: * @}
        -: 3375: * @}
        -: 3376: */
