        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-typedarray-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-typedarray-object.h"
        -:   17:
        -:   18:#include <math.h>
        -:   19:
        -:   20:#include "ecma-arraybuffer-object.h"
        -:   21:#include "ecma-big-uint.h"
        -:   22:#include "ecma-bigint.h"
        -:   23:#include "ecma-builtin-helpers.h"
        -:   24:#include "ecma-builtins.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-exceptions.h"
        -:   27:#include "ecma-function-object.h"
        -:   28:#include "ecma-gc.h"
        -:   29:#include "ecma-globals.h"
        -:   30:#include "ecma-helpers-number.h"
        -:   31:#include "ecma-helpers.h"
        -:   32:#include "ecma-iterator-object.h"
        -:   33:#include "ecma-objects-general.h"
        -:   34:#include "ecma-objects.h"
        -:   35:#include "ecma-shared-arraybuffer-object.h"
        -:   36:
        -:   37:#include "jcontext.h"
        -:   38:
        -:   39:#if JERRY_BUILTIN_TYPEDARRAY
        -:   40:
        -:   41:/** \addtogroup ecma ECMA
        -:   42: * @{
        -:   43: *
        -:   44: * \addtogroup ecmatypedarrayobject ECMA TypedArray object related routines
        -:   45: * @{
        -:   46: */
        -:   47:
        -:   48:/**
        -:   49: * Read and copy a number from a given buffer to a value.
        -:   50: **/
        -:   51:#define ECMA_TYPEDARRAY_GET_ELEMENT(src_p, num, type)                      \
        -:   52:  do                                                                       \
        -:   53:  {                                                                        \
        -:   54:    if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   55:    {                                                                      \
        -:   56:      num = *(type *) ((void *) src_p);                                    \
        -:   57:    }                                                                      \
        -:   58:    else                                                                   \
        -:   59:    {                                                                      \
        -:   60:      memcpy (&num, (void *) src_p, sizeof (type));                        \
        -:   61:    }                                                                      \
        -:   62:  } while (0)
        -:   63:
        -:   64:/**
        -:   65: * Copy a number from a value to the given buffer
        -:   66: **/
        -:   67:#define ECMA_TYPEDARRAY_SET_ELEMENT(src_p, num, type)                      \
        -:   68:  do                                                                       \
        -:   69:  {                                                                        \
        -:   70:    if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   71:    {                                                                      \
        -:   72:      *(type *) ((void *) src_p) = num;                                    \
        -:   73:    }                                                                      \
        -:   74:    else                                                                   \
        -:   75:    {                                                                      \
        -:   76:      memcpy ((void *) src_p, &num, sizeof (type));                        \
        -:   77:    }                                                                      \
        -:   78:  } while (0)
        -:   79:
        -:   80:/**
        -:   81: * Read an int8_t value from the given arraybuffer
        -:   82: */
        -:   83:static ecma_value_t
    #####:   84:ecma_typedarray_get_int8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   85:{
    #####:   86:  int8_t num = (int8_t) *src;
    #####:   87:  return ecma_make_integer_value (num);
        -:   88:} /* ecma_typedarray_get_int8_element */
        -:   89:
        -:   90:/**
        -:   91: * Read an uint8_t value from the given arraybuffer
        -:   92: */
        -:   93:static ecma_value_t
    #####:   94:ecma_typedarray_get_uint8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   95:{
    #####:   96:  uint8_t num = (uint8_t) *src;
    #####:   97:  return ecma_make_integer_value (num);
        -:   98:} /* ecma_typedarray_get_uint8_element */
        -:   99:
        -:  100:/**
        -:  101: * Read an int16_t value from the given arraybuffer
        -:  102: */
        -:  103:static ecma_value_t
    #####:  104:ecma_typedarray_get_int16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  105:{
    #####:  106:  int16_t num;
    #####:  107:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int16_t);
    #####:  108:  return ecma_make_integer_value (num);
        -:  109:} /* ecma_typedarray_get_int16_element */
        -:  110:
        -:  111:/**
        -:  112: * Read an uint16_t value from the given arraybuffer
        -:  113: */
        -:  114:static ecma_value_t
    #####:  115:ecma_typedarray_get_uint16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  116:{
    #####:  117:  uint16_t num;
    #####:  118:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint16_t);
    #####:  119:  return ecma_make_integer_value (num);
        -:  120:} /* ecma_typedarray_get_uint16_element */
        -:  121:
        -:  122:/**
        -:  123: * Read an int32_t value from the given arraybuffer
        -:  124: */
        -:  125:static ecma_value_t
    #####:  126:ecma_typedarray_get_int32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  127:{
    #####:  128:  int32_t num;
    #####:  129:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int32_t);
    #####:  130:  return ecma_make_number_value (num);
        -:  131:} /* ecma_typedarray_get_int32_element */
        -:  132:
        -:  133:/**
        -:  134: * Read an uint32_t value from the given arraybuffer
        -:  135: */
        -:  136:static ecma_value_t
    #####:  137:ecma_typedarray_get_uint32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  138:{
    #####:  139:  uint32_t num;
    #####:  140:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint32_t);
    #####:  141:  return ecma_make_number_value (num);
        -:  142:} /* ecma_typedarray_get_uint32_element */
        -:  143:
        -:  144:/**
        -:  145: * Read a float value from the given arraybuffer
        -:  146: */
        -:  147:static ecma_value_t
    #####:  148:ecma_typedarray_get_float_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  149:{
    #####:  150:  float num;
    #####:  151:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, float);
    #####:  152:  return ecma_make_number_value (num);
        -:  153:} /* ecma_typedarray_get_float_element */
        -:  154:
        -:  155:/**
        -:  156: * Read a double value from the given arraybuffer
        -:  157: */
        -:  158:static ecma_value_t
    #####:  159:ecma_typedarray_get_double_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  160:{
    #####:  161:  double num;
    #####:  162:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, double);
    #####:  163:  return ecma_make_number_value (num);
        -:  164:} /* ecma_typedarray_get_double_element */
        -:  165:
        -:  166:#if JERRY_BUILTIN_BIGINT
        -:  167:/**
        -:  168: * Read a bigint64 value from the given arraybuffer
        -:  169: */
        -:  170:static ecma_value_t
    #####:  171:ecma_typedarray_get_bigint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  172:{
    #####:  173:  uint64_t num;
    #####:  174:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  175:  bool sign = (num >> 63) != 0;
        -:  176:
    #####:  177:  if (sign)
        -:  178:  {
    #####:  179:    num = (uint64_t) (-(int64_t) num);
        -:  180:  }
        -:  181:
    #####:  182:  return ecma_bigint_create_from_digits (&num, 1, sign);
        -:  183:} /* ecma_typedarray_get_bigint64_element */
        -:  184:
        -:  185:/**
        -:  186: * Read a biguint64 value from the given arraybuffer
        -:  187: */
        -:  188:static ecma_value_t
    #####:  189:ecma_typedarray_get_biguint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  190:{
    #####:  191:  uint64_t num;
    #####:  192:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  193:  return ecma_bigint_create_from_digits (&num, 1, false);
        -:  194:} /* ecma_typedarray_get_biguint64_element */
        -:  195:#endif /* JERRY_BUILTIN_BIGINT */
        -:  196:
        -:  197:/**
        -:  198: * Normalize the given ecma_number_t to an uint32_t value
        -:  199: */
        -:  200:static uint32_t
    #####:  201:ecma_typedarray_setter_number_to_uint32 (ecma_number_t value) /**< the number value to normalize */
        -:  202:{
    #####:  203:  uint32_t uint32_value = 0;
        -:  204:
    #####:  205:  if (!ecma_number_is_nan (value) && !ecma_number_is_infinity (value))
        -:  206:  {
    #####:  207:    bool is_negative = false;
        -:  208:
    #####:  209:    if (value < 0)
        -:  210:    {
    #####:  211:      is_negative = true;
    #####:  212:      value = -value;
        -:  213:    }
        -:  214:
    #####:  215:    if (value > ((ecma_number_t) 0xffffffff))
        -:  216:    {
    #####:  217:      value = (ecma_number_t) (fmod (value, (ecma_number_t) 0x100000000));
        -:  218:    }
        -:  219:
    #####:  220:    uint32_value = (uint32_t) value;
        -:  221:
    #####:  222:    if (is_negative)
        -:  223:    {
    #####:  224:      uint32_value = (uint32_t) (-(int32_t) uint32_value);
        -:  225:    }
        -:  226:  }
        -:  227:
    #####:  228:  return uint32_value;
        -:  229:} /* ecma_typedarray_setter_number_to_uint32 */
        -:  230:
        -:  231:/**
        -:  232: * Write an int8_t value into the given arraybuffer
        -:  233: *
        -:  234: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  235: *         ECMA_VALUE_TRUE - otherwise
        -:  236: */
        -:  237:static ecma_value_t
    #####:  238:ecma_typedarray_set_int8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  239:                                  ecma_value_t value) /**< the number value to set */
        -:  240:{
    #####:  241:  ecma_number_t result_num;
    #####:  242:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  243:
    #####:  244:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  245:  {
    #####:  246:    return to_num;
        -:  247:  }
        -:  248:
    #####:  249:  int8_t num = (int8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  250:  *dst_p = (lit_utf8_byte_t) num;
    #####:  251:  return ECMA_VALUE_TRUE;
        -:  252:} /* ecma_typedarray_set_int8_element */
        -:  253:
        -:  254:/**
        -:  255: * Write an uint8_t value into the given arraybuffer
        -:  256: *
        -:  257: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  258: *         ECMA_VALUE_TRUE - otherwise
        -:  259: */
        -:  260:static ecma_value_t
    #####:  261:ecma_typedarray_set_uint8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  262:                                   ecma_value_t value) /**< the number value to set */
        -:  263:{
    #####:  264:  ecma_number_t result_num;
    #####:  265:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  266:
    #####:  267:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  268:  {
    #####:  269:    return to_num;
        -:  270:  }
        -:  271:
    #####:  272:  uint8_t num = (uint8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  273:  *dst_p = (lit_utf8_byte_t) num;
    #####:  274:  return ECMA_VALUE_TRUE;
        -:  275:} /* ecma_typedarray_set_uint8_element */
        -:  276:
        -:  277:/**
        -:  278: * Write an uint8_t clamped value into the given arraybuffer
        -:  279: *
        -:  280: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  281: *         ECMA_VALUE_TRUE - otherwise
        -:  282: */
        -:  283:static ecma_value_t
    #####:  284:ecma_typedarray_set_uint8_clamped_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  285:                                           ecma_value_t value) /**< the number value to set */
        -:  286:{
    #####:  287:  ecma_number_t result_num;
    #####:  288:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  289:
    #####:  290:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  291:  {
    #####:  292:    return to_num;
        -:  293:  }
        -:  294:
        -:  295:  uint8_t clamped;
        -:  296:
    #####:  297:  if (result_num > 255)
        -:  298:  {
    #####:  299:    clamped = 255;
        -:  300:  }
    #####:  301:  else if (result_num <= 0)
        -:  302:  {
    #####:  303:    clamped = 0;
        -:  304:  }
        -:  305:  else
        -:  306:  {
    #####:  307:    clamped = (uint8_t) result_num;
        -:  308:
    #####:  309:    if (clamped + 0.5 < result_num || (clamped + 0.5 == result_num && (clamped % 2) == 1))
        -:  310:    {
    #####:  311:      clamped++;
        -:  312:    }
        -:  313:  }
        -:  314:
    #####:  315:  *dst_p = (lit_utf8_byte_t) clamped;
    #####:  316:  return ECMA_VALUE_TRUE;
        -:  317:} /* ecma_typedarray_set_uint8_clamped_element */
        -:  318:
        -:  319:/**
        -:  320: * Write an int16_t value into the given arraybuffer
        -:  321: *
        -:  322: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  323: *         ECMA_VALUE_TRUE - otherwise
        -:  324: */
        -:  325:static ecma_value_t
    #####:  326:ecma_typedarray_set_int16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  327:                                   ecma_value_t value) /**< the number value to set */
        -:  328:{
    #####:  329:  ecma_number_t resut_num;
    #####:  330:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  331:
    #####:  332:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  333:  {
    #####:  334:    return to_num;
        -:  335:  }
        -:  336:
    #####:  337:  int16_t num = (int16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  338:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int16_t);
    #####:  339:  return ECMA_VALUE_TRUE;
        -:  340:} /* ecma_typedarray_set_int16_element */
        -:  341:
        -:  342:/**
        -:  343: * Write an uint8_t value into the given arraybuffer
        -:  344: *
        -:  345: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  346: *         ECMA_VALUE_TRUE - otherwise
        -:  347: */
        -:  348:static ecma_value_t
    #####:  349:ecma_typedarray_set_uint16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  350:                                    ecma_value_t value) /**< the number value to set */
        -:  351:{
    #####:  352:  ecma_number_t resut_num;
    #####:  353:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  354:
    #####:  355:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  356:  {
    #####:  357:    return to_num;
        -:  358:  }
        -:  359:
    #####:  360:  uint16_t num = (uint16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  361:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint16_t);
    #####:  362:  return ECMA_VALUE_TRUE;
        -:  363:} /* ecma_typedarray_set_uint16_element */
        -:  364:
        -:  365:/**
        -:  366: * Write an int32_t value into the given arraybuffer
        -:  367: *
        -:  368: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  369: *         ECMA_VALUE_TRUE - otherwise
        -:  370: */
        -:  371:static ecma_value_t
    #####:  372:ecma_typedarray_set_int32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  373:                                   ecma_value_t value) /**< the number value to set */
        -:  374:{
    #####:  375:  ecma_number_t resut_num;
    #####:  376:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  377:
    #####:  378:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  379:  {
    #####:  380:    return to_num;
        -:  381:  }
        -:  382:
    #####:  383:  int32_t num = (int32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  384:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int32_t);
    #####:  385:  return ECMA_VALUE_TRUE;
        -:  386:} /* ecma_typedarray_set_int32_element */
        -:  387:
        -:  388:/**
        -:  389: * Write an uint32_t value into the given arraybuffer
        -:  390: *
        -:  391: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  392: *         ECMA_VALUE_TRUE - otherwise
        -:  393: */
        -:  394:static ecma_value_t
    #####:  395:ecma_typedarray_set_uint32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  396:                                    ecma_value_t value) /**< the number value to set */
        -:  397:{
    #####:  398:  ecma_number_t resut_num;
    #####:  399:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  400:
    #####:  401:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  402:  {
    #####:  403:    return to_num;
        -:  404:  }
        -:  405:
    #####:  406:  uint32_t num = (uint32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  407:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint32_t);
    #####:  408:  return ECMA_VALUE_TRUE;
        -:  409:} /* ecma_typedarray_set_uint32_element */
        -:  410:
        -:  411:/**
        -:  412: * Write a float value into the given arraybuffer
        -:  413: *
        -:  414: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  415: *         ECMA_VALUE_TRUE - otherwise
        -:  416: */
        -:  417:static ecma_value_t
    #####:  418:ecma_typedarray_set_float_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  419:                                   ecma_value_t value) /**< the number value to set */
        -:  420:{
    #####:  421:  ecma_number_t result_num;
    #####:  422:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  423:
    #####:  424:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  425:  {
    #####:  426:    return to_num;
        -:  427:  }
        -:  428:
    #####:  429:  float num = (float) result_num;
    #####:  430:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, float);
    #####:  431:  return ECMA_VALUE_TRUE;
        -:  432:} /* ecma_typedarray_set_float_element */
        -:  433:
        -:  434:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  435:/**
        -:  436: * Write a double value into the given arraybuffer
        -:  437: *
        -:  438: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  439: *         ECMA_VALUE_TRUE - otherwise
        -:  440: */
        -:  441:static ecma_value_t
    #####:  442:ecma_typedarray_set_double_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  443:                                    ecma_value_t value) /**< the number value to set */
        -:  444:{
    #####:  445:  ecma_number_t result_num;
    #####:  446:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  447:
    #####:  448:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  449:  {
    #####:  450:    return to_num;
        -:  451:  }
        -:  452:
    #####:  453:  double num = (double) result_num;
    #####:  454:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, double);
    #####:  455:  return ECMA_VALUE_TRUE;
        -:  456:} /* ecma_typedarray_set_double_element */
        -:  457:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  458:
        -:  459:#if JERRY_BUILTIN_BIGINT
        -:  460:/**
        -:  461: * Write a bigint64/biguint64 value into the given arraybuffer
        -:  462: *
        -:  463: * @return ECMA_VALUE_ERROR - if the ToBigInt operation fails
        -:  464: *         ECMA_VALUE_TRUE - otherwise
        -:  465: */
        -:  466:static ecma_value_t
    #####:  467:ecma_typedarray_set_bigint_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  468:                                    ecma_value_t value) /**< the bigint value to set */
        -:  469:{
    #####:  470:  ecma_value_t bigint = ecma_bigint_to_bigint (value, false);
        -:  471:
    #####:  472:  if (ECMA_IS_VALUE_ERROR (bigint))
        -:  473:  {
    #####:  474:    return bigint;
        -:  475:  }
        -:  476:
    #####:  477:  uint64_t num;
    #####:  478:  bool sign;
    #####:  479:  ecma_bigint_get_digits_and_sign (bigint, &num, 1, &sign);
        -:  480:
    #####:  481:  if (sign)
        -:  482:  {
    #####:  483:    num = (uint64_t) (-(int64_t) num);
        -:  484:  }
        -:  485:
    #####:  486:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint64_t);
        -:  487:
    #####:  488:  ecma_free_value (bigint);
        -:  489:
    #####:  490:  return ECMA_VALUE_TRUE;
        -:  491:} /* ecma_typedarray_set_bigint_element */
        -:  492:#endif /* JERRY_BUILTIN_BIGINT */
        -:  493:
        -:  494:/**
        -:  495: * Builtin id of the first %TypedArray% builtin routine intrinsic object
        -:  496: */
        -:  497:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_INT8ARRAY
        -:  498:
        -:  499:#if JERRY_BUILTIN_BIGINT
        -:  500:/**
        -:  501: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  502: */
        -:  503:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_BIGUINT64ARRAY
        -:  504:#elif !JERRY_BUILTIN_BIGINT && JERRY_NUMBER_TYPE_FLOAT64
        -:  505:/**
        -:  506: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  507: */
        -:  508:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT64ARRAY
        -:  509:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  510:/**
        -:  511: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  512: */
        -:  513:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT32ARRAY
        -:  514:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  515:
        -:  516:/**
        -:  517: * Builtin id of the first %TypedArray% builtin prototype intrinsic object
        -:  518: */
        -:  519:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE
        -:  520:
        -:  521:/**
        -:  522: * List of typedarray getters based on their builtin id
        -:  523: */
        -:  524:static const ecma_typedarray_getter_fn_t ecma_typedarray_getters[] = {
        -:  525:  ecma_typedarray_get_int8_element, /**< Int8Array */
        -:  526:  ecma_typedarray_get_uint8_element, /**< Uint8Array */
        -:  527:  ecma_typedarray_get_uint8_element, /**< Uint8ClampedArray */
        -:  528:  ecma_typedarray_get_int16_element, /**< Int16Array */
        -:  529:  ecma_typedarray_get_uint16_element, /**< Int32Array */
        -:  530:  ecma_typedarray_get_int32_element, /**< Uint32Array */
        -:  531:  ecma_typedarray_get_uint32_element, /**< Uint32Array */
        -:  532:  ecma_typedarray_get_float_element, /**< Float32Array */
        -:  533:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  534:  ecma_typedarray_get_double_element, /**< Float64Array */
        -:  535:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  536:#if JERRY_BUILTIN_BIGINT
        -:  537:  ecma_typedarray_get_bigint64_element, /**< BigInt64Array*/
        -:  538:  ecma_typedarray_get_biguint64_element, /**< BigUint64Array */
        -:  539:#endif /* JERRY_BUILTIN_BIGINT */
        -:  540:};
        -:  541:
        -:  542:/**
        -:  543: * List of typedarray setters based on their builtin id
        -:  544: */
        -:  545:static const ecma_typedarray_setter_fn_t ecma_typedarray_setters[] = {
        -:  546:  ecma_typedarray_set_int8_element, /**< Int8Array */
        -:  547:  ecma_typedarray_set_uint8_element, /**< Uint8Array */
        -:  548:  ecma_typedarray_set_uint8_clamped_element, /**< Uint8ClampedArray */
        -:  549:  ecma_typedarray_set_int16_element, /**< Int16Array */
        -:  550:  ecma_typedarray_set_uint16_element, /**< Int32Array */
        -:  551:  ecma_typedarray_set_int32_element, /**< Uint32Array */
        -:  552:  ecma_typedarray_set_uint32_element, /**< Uint32Array */
        -:  553:  ecma_typedarray_set_float_element, /**< Float32Array */
        -:  554:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  555:  ecma_typedarray_set_double_element, /**< Float64Array */
        -:  556:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  557:#if JERRY_BUILTIN_BIGINT
        -:  558:  ecma_typedarray_set_bigint_element, /**< BigInt64Array */
        -:  559:  ecma_typedarray_set_bigint_element, /**< BigUInt64Array */
        -:  560:#endif /* JERRY_BUILTIN_BIGINT */
        -:  561:};
        -:  562:
        -:  563:/**
        -:  564: * List of typedarray element shift sizes based on their builtin id
        -:  565: */
        -:  566:static const uint8_t ecma_typedarray_element_shift_sizes[] = {
        -:  567:  0, /**< Int8Array */
        -:  568:  0, /**< Uint8Array */
        -:  569:  0, /**< Uint8ClampedArray */
        -:  570:  1, /**< Int16Array */
        -:  571:  1, /**< Uint16Array */
        -:  572:  2, /**< Int32Array */
        -:  573:  2, /**< Uint32Array */
        -:  574:  2, /**< Float32Array */
        -:  575:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  576:  3, /**< Float64Array */
        -:  577:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  578:#if JERRY_BUILTIN_BIGINT
        -:  579:  3, /**< BigInt64Array */
        -:  580:  3, /**< BigUInt64Array */
        -:  581:#endif /* JERRY_BUILTIN_BIGINT */
        -:  582:};
        -:  583:
        -:  584:/**
        -:  585: * List of typedarray class magic strings based on their builtin id
        -:  586: */
        -:  587:static const uint16_t ecma_typedarray_magic_string_list[] = {
        -:  588:  (uint16_t) LIT_MAGIC_STRING_INT8_ARRAY_UL, /**< Int8Array */
        -:  589:  (uint16_t) LIT_MAGIC_STRING_UINT8_ARRAY_UL, /**< Uint8Array */
        -:  590:  (uint16_t) LIT_MAGIC_STRING_UINT8_CLAMPED_ARRAY_UL, /**< Uint8ClampedArray */
        -:  591:  (uint16_t) LIT_MAGIC_STRING_INT16_ARRAY_UL, /**< Int16Array */
        -:  592:  (uint16_t) LIT_MAGIC_STRING_UINT16_ARRAY_UL, /**< Uint16Array */
        -:  593:  (uint16_t) LIT_MAGIC_STRING_INT32_ARRAY_UL, /**< Int32Array */
        -:  594:  (uint16_t) LIT_MAGIC_STRING_UINT32_ARRAY_UL, /**< Uint32Array */
        -:  595:  (uint16_t) LIT_MAGIC_STRING_FLOAT32_ARRAY_UL, /**< Float32Array */
        -:  596:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  597:  (uint16_t) LIT_MAGIC_STRING_FLOAT64_ARRAY_UL, /**< Float64Array */
        -:  598:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  599:#if JERRY_BUILTIN_BIGINT
        -:  600:  (uint16_t) LIT_MAGIC_STRING_BIGINT64_ARRAY_UL, /**< BigInt64Array */
        -:  601:  (uint16_t) LIT_MAGIC_STRING_BIGUINT64_ARRAY_UL, /**< BigUInt64Array */
        -:  602:#endif /* JERRY_BUILTIN_BIGINT */
        -:  603:};
        -:  604:
        -:  605:/**
        -:  606: * Get the magic string id of a typedarray
        -:  607: *
        -:  608: * @return magic string
        -:  609: */
        -:  610:extern inline lit_magic_string_id_t JERRY_ATTR_ALWAYS_INLINE
    #####:  611:ecma_get_typedarray_magic_string_id (ecma_typedarray_type_t typedarray_id)
        -:  612:{
    #####:  613:  return (lit_magic_string_id_t) ecma_typedarray_magic_string_list[typedarray_id];
        -:  614:} /* ecma_get_typedarray_magic_string_id */
        -:  615:
        -:  616:/**
        -:  617: * Get typedarray's getter function callback
        -:  618: *
        -:  619: * @return ecma_typedarray_getter_fn_t: the getter function for the given builtin TypedArray id
        -:  620: */
        -:  621:extern inline ecma_typedarray_getter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  622:ecma_get_typedarray_getter_fn (ecma_typedarray_type_t typedarray_id) /**< typedarray id */
        -:  623:{
    #####:  624:  return ecma_typedarray_getters[typedarray_id];
        -:  625:} /* ecma_get_typedarray_getter_fn */
        -:  626:
        -:  627:/**
        -:  628: * Get element from a TypedArray
        -:  629: *
        -:  630: * @return the value of the element
        -:  631: */
        -:  632:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  633:ecma_get_typedarray_element (ecma_typedarray_info_t *info_p, /**< typedarray info */
        -:  634:                             uint32_t index) /**< element index */
        -:  635:{
    #####:  636:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info_p->array_buffer_p))
        -:  637:  {
    #####:  638:    return ECMA_VALUE_ERROR;
        -:  639:  }
        -:  640:
    #####:  641:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p) || index >= info_p->length)
        -:  642:  {
    #####:  643:    return ECMA_VALUE_UNDEFINED;
        -:  644:  }
        -:  645:
    #####:  646:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -:  647:
    #####:  648:  return ecma_typedarray_getters[info_p->id](buffer_p + (index << info_p->shift));
        -:  649:} /* ecma_get_typedarray_element */
        -:  650:
        -:  651:/**
        -:  652: * Get typedarray's setter function callback
        -:  653: *
        -:  654: * @return ecma_typedarray_setter_fn_t: the setter function for the given builtin TypedArray id
        -:  655: */
        -:  656:extern inline ecma_typedarray_setter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  657:ecma_get_typedarray_setter_fn (ecma_typedarray_type_t typedarray_id) /**< typedarray id */
        -:  658:{
    #####:  659:  return ecma_typedarray_setters[typedarray_id];
        -:  660:} /* ecma_get_typedarray_setter_fn */
        -:  661:
        -:  662:/**
        -:  663: * set typedarray's element value
        -:  664: */
        -:  665:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  666:ecma_set_typedarray_element (ecma_typedarray_info_t *info_p, /**< typedarray info */
        -:  667:                             ecma_value_t value, /**< value to be set */
        -:  668:                             uint32_t index) /**< element index */
        -:  669:{
        -:  670:  ecma_value_t to_num;
    #####:  671:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -:  672:  {
    #####:  673:    to_num = ecma_bigint_to_bigint (value, false);
        -:  674:
    #####:  675:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  676:    {
    #####:  677:      return to_num;
        -:  678:    }
        -:  679:  }
        -:  680:  else
        -:  681:  {
    #####:  682:    ecma_number_t result_num;
    #####:  683:    to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  684:
    #####:  685:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  686:    {
    #####:  687:      return to_num;
        -:  688:    }
        -:  689:  }
        -:  690:
    #####:  691:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info_p->array_buffer_p))
        -:  692:  {
    #####:  693:    ecma_free_value (to_num);
    #####:  694:    return ECMA_VALUE_ERROR;
        -:  695:  }
        -:  696:
    #####:  697:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p) || index >= info_p->length)
        -:  698:  {
    #####:  699:    ecma_free_value (to_num);
    #####:  700:    return ECMA_VALUE_FALSE;
        -:  701:  }
        -:  702:
    #####:  703:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -:  704:
    #####:  705:  ecma_free_value (to_num);
        -:  706:
    #####:  707:  return ecma_typedarray_setters[info_p->id](buffer_p + (index << info_p->shift), value);
        -:  708:} /* ecma_set_typedarray_element */
        -:  709:
        -:  710:/**
        -:  711: * Get the element shift size of a TypedArray type.
        -:  712: *
        -:  713: * @return uint8_t
        -:  714: */
        -:  715:extern inline uint8_t JERRY_ATTR_ALWAYS_INLINE
    #####:  716:ecma_typedarray_helper_get_shift_size (ecma_typedarray_type_t typedarray_id)
        -:  717:{
    #####:  718:  return ecma_typedarray_element_shift_sizes[typedarray_id];
        -:  719:} /* ecma_typedarray_helper_get_shift_size */
        -:  720:
        -:  721:/**
        -:  722: * Check if the builtin is a TypedArray type.
        -:  723: *
        -:  724: * @return bool: - true if based on the given id it is a TypedArray
        -:  725: *               - false if based on the given id it is not a TypedArray
        -:  726: */
        -:  727:bool
    #####:  728:ecma_typedarray_helper_is_typedarray (ecma_builtin_id_t builtin_id) /**< the builtin id of a type **/
        -:  729:{
        -:  730:  return ((builtin_id >= ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID)
    #####:  731:          && (builtin_id <= ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID));
        -:  732:} /* ecma_typedarray_helper_is_typedarray */
        -:  733:
        -:  734:/**
        -:  735: * Get the prototype ID of a TypedArray type.
        -:  736: *
        -:  737: * @return ecma_builtin_id_t
        -:  738: */
        -:  739:ecma_builtin_id_t
    #####:  740:ecma_typedarray_helper_get_prototype_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  741:{
    #####:  742:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID + typedarray_id);
        -:  743:} /* ecma_typedarray_helper_get_prototype_id */
        -:  744:
        -:  745:/**
        -:  746: * Get the constructor ID of a TypedArray type.
        -:  747: *
        -:  748: * @return ecma_builtin_id_t
        -:  749: */
        -:  750:ecma_builtin_id_t
    #####:  751:ecma_typedarray_helper_get_constructor_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  752:{
    #####:  753:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID + typedarray_id);
        -:  754:} /* ecma_typedarray_helper_get_constructor_id */
        -:  755:
        -:  756:/**
        -:  757: * Get the built-in TypedArray type of the given object.
        -:  758: *
        -:  759: * @return ecma_typedarray_type_t
        -:  760: */
        -:  761:ecma_typedarray_type_t
    #####:  762:ecma_get_typedarray_id (ecma_object_t *obj_p) /**< typedarray object **/
        -:  763:{
    #####:  764:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -:  765:
    #####:  766:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  767:
    #####:  768:  return (ecma_typedarray_type_t) ext_object_p->u.cls.u1.typedarray_type;
        -:  769:} /* ecma_get_typedarray_id */
        -:  770:
        -:  771:/**
        -:  772: * Get the built-in TypedArray type of the given object.
        -:  773: *
        -:  774: * @return ecma_typedarray_type_t
        -:  775: */
        -:  776:ecma_typedarray_type_t
    #####:  777:ecma_typedarray_helper_builtin_to_typedarray_id (ecma_builtin_id_t builtin_id)
        -:  778:{
    #####:  779:  JERRY_ASSERT (ecma_typedarray_helper_is_typedarray (builtin_id));
        -:  780:
    #####:  781:  return (ecma_typedarray_type_t) (builtin_id - ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID);
        -:  782:} /* ecma_typedarray_helper_builtin_to_typedarray_id */
        -:  783:
        -:  784:/**
        -:  785: * Create a TypedArray object by given array_length
        -:  786: *
        -:  787: * See also: ES2015 22.2.1.2.1
        -:  788: *
        -:  789: * @return ecma value of the new typedarray object
        -:  790: *         Returned value must be freed with ecma_free_value
        -:  791: */
        -:  792:ecma_value_t
    #####:  793:ecma_typedarray_create_object_with_length (uint32_t array_length, /**< length of the typedarray */
        -:  794:                                           ecma_object_t *src_buffer_p, /**< source buffer */
        -:  795:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  796:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  797:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  798:{
    #####:  799:  uint32_t byte_length = UINT32_MAX;
        -:  800:
    #####:  801:  if (array_length <= (UINT32_MAX >> element_size_shift))
        -:  802:  {
    #####:  803:    byte_length = array_length << element_size_shift;
        -:  804:  }
        -:  805:
    #####:  806:  if (byte_length > UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1)
        -:  807:  {
        -:  808:#if JERRY_ERROR_MESSAGES
    #####:  809:    ecma_value_t array_length_value = ecma_make_number_value (array_length);
        -:  810:
    #####:  811:    ecma_value_t result =
        -:  812:      ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE, "Invalid typed array length: %", array_length_value);
    #####:  813:    ecma_free_value (array_length_value);
    #####:  814:    return result;
        -:  815:#else /* !JERRY_ERROR_MESSAGES */
        -:  816:    return ecma_raise_range_error (ECMA_ERR_EMPTY);
        -:  817:#endif /* JERRY_ERROR_MESSAGES */
        -:  818:  }
        -:  819:
    #####:  820:  ecma_object_t *new_arraybuffer_p = NULL;
    #####:  821:  if (src_buffer_p == NULL)
        -:  822:  {
    #####:  823:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  824:  }
        -:  825:  else
        -:  826:  {
    #####:  827:    ecma_value_t ctor_proto = ecma_op_species_constructor (src_buffer_p, ECMA_BUILTIN_ID_ARRAYBUFFER);
        -:  828:
    #####:  829:    if (ECMA_IS_VALUE_ERROR (ctor_proto))
        -:  830:    {
    #####:  831:      return ctor_proto;
        -:  832:    }
        -:  833:
    #####:  834:    ecma_object_t *ctor_proto_p = ecma_get_object_from_value (ctor_proto);
        -:  835:
    #####:  836:    ecma_object_t *prototype_p =
        -:  837:      ecma_op_get_prototype_from_constructor (ctor_proto_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
        -:  838:
    #####:  839:    ecma_deref_object (ctor_proto_p);
        -:  840:
    #####:  841:    if (JERRY_UNLIKELY (prototype_p == NULL))
        -:  842:    {
    #####:  843:      return ECMA_VALUE_ERROR;
        -:  844:    }
        -:  845:
    #####:  846:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  847:
    #####:  848:    ECMA_SET_NON_NULL_POINTER (new_arraybuffer_p->u2.prototype_cp, prototype_p);
        -:  849:
    #####:  850:    ecma_deref_object (prototype_p);
        -:  851:
    #####:  852:    if (ecma_arraybuffer_is_detached (src_buffer_p))
        -:  853:    {
    #####:  854:      ecma_deref_object (new_arraybuffer_p);
    #####:  855:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  856:    }
        -:  857:  }
        -:  858:
    #####:  859:  ecma_object_t *object_p = ecma_create_object (proto_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  860:
    #####:  861:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  862:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
    #####:  863:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
    #####:  864:  ext_object_p->u.cls.u2.typedarray_flags = 0;
    #####:  865:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (new_arraybuffer_p);
        -:  866:
    #####:  867:  ecma_deref_object (new_arraybuffer_p);
        -:  868:
    #####:  869:  return ecma_make_object_value (object_p);
        -:  870:} /* ecma_typedarray_create_object_with_length */
        -:  871:
        -:  872:/**
        -:  873: * Create a TypedArray object by given another TypedArray object
        -:  874: *
        -:  875: * See also: ES2015 22.2.1.3
        -:  876: *
        -:  877: * @return ecma value of the new typedarray object
        -:  878: *         Returned value must be freed with ecma_free_value
        -:  879: */
        -:  880:static ecma_value_t
    #####:  881:ecma_typedarray_create_object_with_typedarray (ecma_object_t *typedarray_p, /**< a typedarray object */
        -:  882:                                               ecma_object_t *proto_p, /**< prototype object */
        -:  883:                                               uint8_t element_size_shift, /**< the size shift of the element length */
        -:  884:                                               ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  885:{
    #####:  886:  uint32_t array_length = ecma_typedarray_get_length (typedarray_p);
    #####:  887:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -:  888:
    #####:  889:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (src_arraybuffer_p))
        -:  890:  {
    #####:  891:    return ECMA_VALUE_ERROR;
        -:  892:  }
        -:  893:
    #####:  894:  if (ecma_arraybuffer_is_detached (src_arraybuffer_p))
        -:  895:  {
    #####:  896:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  897:  }
        -:  898:
    #####:  899:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (array_length,
        -:  900:                                                                           src_arraybuffer_p,
        -:  901:                                                                           proto_p,
        -:  902:                                                                           element_size_shift,
        -:  903:                                                                           typedarray_id);
        -:  904:
    #####:  905:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  906:  {
    #####:  907:    return new_typedarray;
        -:  908:  }
        -:  909:
    #####:  910:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####:  911:  ecma_object_t *dst_arraybuffer_p = ecma_typedarray_get_arraybuffer (new_typedarray_p);
        -:  912:
    #####:  913:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (dst_arraybuffer_p))
        -:  914:  {
    #####:  915:    ecma_deref_object (new_typedarray_p);
    #####:  916:    return ECMA_VALUE_ERROR;
        -:  917:  }
        -:  918:
    #####:  919:  if (ecma_arraybuffer_is_detached (dst_arraybuffer_p))
        -:  920:  {
    #####:  921:    ecma_deref_object (new_typedarray_p);
    #####:  922:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  923:  }
        -:  924:
    #####:  925:  lit_utf8_byte_t *src_buf_p = ecma_arraybuffer_get_buffer (src_arraybuffer_p);
    #####:  926:  lit_utf8_byte_t *dst_buf_p = ecma_arraybuffer_get_buffer (dst_arraybuffer_p);
        -:  927:
    #####:  928:  src_buf_p += ecma_typedarray_get_offset (typedarray_p);
        -:  929:
    #####:  930:  ecma_typedarray_type_t src_id = ecma_get_typedarray_id (typedarray_p);
        -:  931:
    #####:  932:  if (src_id == typedarray_id)
        -:  933:  {
    #####:  934:    memcpy (dst_buf_p, src_buf_p, array_length << element_size_shift);
        -:  935:  }
        -:  936:  else
        -:  937:  {
        -:  938:#if JERRY_BUILTIN_BIGINT
    #####:  939:    if ((ECMA_TYPEDARRAY_IS_BIGINT_TYPE (src_id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (typedarray_id)) == 1)
        -:  940:    {
    #####:  941:      ecma_deref_object (new_typedarray_p);
    #####:  942:      return ecma_raise_type_error (ECMA_ERR_INCOMPATIBLE_TYPEDARRAY_TYPES);
        -:  943:    }
        -:  944:#endif /* JERRY_BUILTIN_BIGINT */
        -:  945:
    #####:  946:    uint32_t src_element_size = 1u << ecma_typedarray_get_element_size_shift (typedarray_p);
    #####:  947:    uint32_t dst_element_size = 1u << element_size_shift;
    #####:  948:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_id);
    #####:  949:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (typedarray_id);
        -:  950:
    #####:  951:    for (uint32_t i = 0; i < array_length; i++)
        -:  952:    {
        -:  953:      /* Convert values from source to destination format. */
    #####:  954:      ecma_value_t tmp = src_typedarray_getter_cb (src_buf_p);
    #####:  955:      ecma_value_t set_element = target_typedarray_setter_cb (dst_buf_p, tmp);
        -:  956:
    #####:  957:      ecma_free_value (tmp);
        -:  958:
    #####:  959:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  960:      {
    #####:  961:        ecma_deref_object (new_typedarray_p);
    #####:  962:        return set_element;
        -:  963:      }
        -:  964:
    #####:  965:      src_buf_p += src_element_size;
    #####:  966:      dst_buf_p += dst_element_size;
        -:  967:    }
        -:  968:  }
        -:  969:
    #####:  970:  return new_typedarray;
        -:  971:} /* ecma_typedarray_create_object_with_typedarray */
        -:  972:
        -:  973:/**
        -:  974: * Helper method for ecma_op_typedarray_from
        -:  975: *
        -:  976: * @return ECMA_VALUE_TRUE - if setting the given value to the new typedarray was successful
        -:  977: *         ECMA_VALUE_ERROR - otherwise
        -:  978: */
        -:  979:static ecma_value_t
    #####:  980:ecma_op_typedarray_from_helper (ecma_value_t this_val, /**< this_arg for the above from function */
        -:  981:                                ecma_value_t current_value, /**< given value to set */
        -:  982:                                uint32_t index, /**< currrent index */
        -:  983:                                ecma_object_t *func_object_p, /**< map function object */
        -:  984:                                uint8_t *buffer_p, /**< target buffer */
        -:  985:                                ecma_typedarray_setter_fn_t setter_cb) /**< setter callback function */
        -:  986:{
    #####:  987:  ecma_value_t mapped_value = current_value;
        -:  988:
    #####:  989:  if (func_object_p != NULL)
        -:  990:  {
        -:  991:    /* 17.d 17.f */
    #####:  992:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  993:    ecma_value_t call_args[] = { current_value, current_index };
        -:  994:
    #####:  995:    ecma_value_t cb_value = ecma_op_function_call (func_object_p, this_val, call_args, 2);
        -:  996:
    #####:  997:    ecma_free_value (current_value);
    #####:  998:    ecma_free_value (current_index);
        -:  999:
    #####: 1000:    if (ECMA_IS_VALUE_ERROR (cb_value))
        -: 1001:    {
    #####: 1002:      return cb_value;
        -: 1003:    }
        -: 1004:
    #####: 1005:    mapped_value = cb_value;
        -: 1006:  }
        -: 1007:
    #####: 1008:  ecma_value_t set_element = setter_cb (buffer_p, mapped_value);
    #####: 1009:  ecma_free_value (mapped_value);
        -: 1010:
    #####: 1011:  if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1012:  {
    #####: 1013:    return set_element;
        -: 1014:  }
        -: 1015:
    #####: 1016:  return ECMA_VALUE_TRUE;
        -: 1017:} /* ecma_op_typedarray_from_helper */
        -: 1018:
        -: 1019:/**
        -: 1020: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1021: *
        -: 1022: * See also: ES11 22.2.4.4
        -: 1023: *
        -: 1024: * @return ecma value of the new typedarray object
        -: 1025: *         Returned value must be freed with ecma_free_value
        -: 1026: */
        -: 1027:ecma_value_t
    #####: 1028:ecma_typedarray_create_object_with_object (ecma_value_t items_val, /**< the source array-like object */
        -: 1029:                                           ecma_object_t *proto_p, /**< prototype object */
        -: 1030:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1031:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1032:{
        -: 1033:  /* 5 */
    #####: 1034:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (items_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1035:
    #####: 1036:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1037:  {
    #####: 1038:    return using_iterator;
        -: 1039:  }
        -: 1040:
        -: 1041:  /* 6 */
    #####: 1042:  if (!ecma_is_value_undefined (using_iterator))
        -: 1043:  {
        -: 1044:    /* 6.a */
    #####: 1045:    ecma_value_t next_method;
    #####: 1046:    ecma_value_t iterator = ecma_op_get_iterator (items_val, using_iterator, &next_method);
    #####: 1047:    ecma_free_value (using_iterator);
        -: 1048:
    #####: 1049:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1050:    {
    #####: 1051:      return iterator;
        -: 1052:    }
        -: 1053:
    #####: 1054:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1055:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1056:
        -: 1057:    while (true)
    #####: 1058:    {
    #####: 1059:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1060:
    #####: 1061:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1062:      {
    #####: 1063:        ret_value = next;
    #####: 1064:        break;
        -: 1065:      }
        -: 1066:
    #####: 1067:      if (next == ECMA_VALUE_FALSE)
        -: 1068:      {
    #####: 1069:        break;
        -: 1070:      }
        -: 1071:
    #####: 1072:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1073:      ecma_free_value (next);
        -: 1074:
    #####: 1075:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1076:      {
    #####: 1077:        ret_value = next_value;
    #####: 1078:        break;
        -: 1079:      }
        -: 1080:
    #####: 1081:      ecma_collection_push_back (values_p, next_value);
        -: 1082:    }
        -: 1083:
    #####: 1084:    ecma_free_value (iterator);
    #####: 1085:    ecma_free_value (next_method);
        -: 1086:
    #####: 1087:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1088:    {
    #####: 1089:      ecma_collection_free (values_p);
    #####: 1090:      return ret_value;
        -: 1091:    }
        -: 1092:
        -: 1093:    /* 8.c */
    #####: 1094:    ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (values_p->item_count,
        -: 1095:                                                                             NULL,
        -: 1096:                                                                             proto_p,
        -: 1097:                                                                             element_size_shift,
        -: 1098:                                                                             typedarray_id);
        -: 1099:
    #####: 1100:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1101:    {
    #####: 1102:      ecma_collection_free (values_p);
    #####: 1103:      return new_typedarray;
        -: 1104:    }
        -: 1105:
    #####: 1106:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1107:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1108:    ecma_value_t *next_value_p = values_p->buffer_p;
        -: 1109:
    #####: 1110:    ret_value = ECMA_VALUE_ERROR;
        -: 1111:
    #####: 1112:    if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1113:    {
    #####: 1114:      goto free_collection;
        -: 1115:    }
        -: 1116:
    #####: 1117:    if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1118:    {
    #####: 1119:      ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
    #####: 1120:      goto free_collection;
        -: 1121:    }
        -: 1122:
    #####: 1123:    uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1124:
    #####: 1125:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1126:    uint8_t *limit_p = buffer_p + (values_p->item_count << info.shift);
        -: 1127:
    #####: 1128:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1129:
        -: 1130:    /* 8.e */
    #####: 1131:    while (buffer_p < limit_p)
        -: 1132:    {
    #####: 1133:      ecma_value_t value = *next_value_p++;
    #####: 1134:      ecma_value_t set_value = setter_cb (buffer_p, value);
    #####: 1135:      ecma_free_value (value);
        -: 1136:
    #####: 1137:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1138:      {
    #####: 1139:        ret_value = set_value;
    #####: 1140:        break;
        -: 1141:      }
        -: 1142:
    #####: 1143:      buffer_p += info.element_size;
        -: 1144:    }
        -: 1145:
    #####: 1146:free_collection:
    #####: 1147:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1148:    {
    #####: 1149:      ecma_value_t *last_value_p = values_p->buffer_p + values_p->item_count;
        -: 1150:
    #####: 1151:      while (next_value_p < last_value_p)
        -: 1152:      {
    #####: 1153:        ecma_free_value (*next_value_p++);
        -: 1154:      }
        -: 1155:
    #####: 1156:      ecma_deref_object (new_typedarray_p);
        -: 1157:    }
        -: 1158:
    #####: 1159:    ecma_collection_destroy (values_p);
    #####: 1160:    return ret_value;
        -: 1161:  }
        -: 1162:
        -: 1163:  /* 8 */
    #####: 1164:  ecma_value_t arraylike_object_val = ecma_op_to_object (items_val);
        -: 1165:
    #####: 1166:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1167:  {
    #####: 1168:    return arraylike_object_val;
        -: 1169:  }
        -: 1170:
    #####: 1171:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1172:
        -: 1173:  /* 9 */
    #####: 1174:  ecma_length_t length_index;
    #####: 1175:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1176:
    #####: 1177:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1178:  {
    #####: 1179:    ecma_deref_object (arraylike_object_p);
    #####: 1180:    return len_value;
        -: 1181:  }
        -: 1182:
    #####: 1183:  if (length_index >= UINT32_MAX)
        -: 1184:  {
    #####: 1185:    ecma_deref_object (arraylike_object_p);
    #####: 1186:    return ecma_raise_range_error (ECMA_ERR_INVALID_TYPEDARRAY_LENGTH);
        -: 1187:  }
        -: 1188:
    #####: 1189:  uint32_t len = (uint32_t) length_index;
        -: 1190:
        -: 1191:  /* 10 */
    #####: 1192:  ecma_value_t new_typedarray =
    #####: 1193:    ecma_typedarray_create_object_with_length (len, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1194:
    #####: 1195:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1196:  {
    #####: 1197:    ecma_deref_object (arraylike_object_p);
    #####: 1198:    return new_typedarray;
        -: 1199:  }
        -: 1200:
    #####: 1201:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1202:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
        -: 1203:
    #####: 1204:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -: 1205:
    #####: 1206:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1207:  {
    #####: 1208:    goto free_object;
        -: 1209:  }
        -: 1210:
    #####: 1211:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1212:  {
    #####: 1213:    ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
    #####: 1214:    goto free_object;
        -: 1215:  }
        -: 1216:
    #####: 1217:  uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1218:
    #####: 1219:  ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1220:
    #####: 1221:  ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1222:
        -: 1223:  /* 12 */
    #####: 1224:  for (uint32_t index = 0; index < len; index++)
        -: 1225:  {
    #####: 1226:    ecma_value_t value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1227:
    #####: 1228:    if (ECMA_IS_VALUE_ERROR (value))
        -: 1229:    {
    #####: 1230:      ret_value = value;
    #####: 1231:      break;
        -: 1232:    }
        -: 1233:
    #####: 1234:    if (!ecma_is_value_found (value))
        -: 1235:    {
    #####: 1236:      value = ECMA_VALUE_UNDEFINED;
        -: 1237:    }
        -: 1238:
    #####: 1239:    ecma_value_t set_value = setter_cb (buffer_p, value);
    #####: 1240:    ecma_free_value (value);
        -: 1241:
    #####: 1242:    if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1243:    {
    #####: 1244:      ret_value = set_value;
    #####: 1245:      break;
        -: 1246:    }
        -: 1247:
    #####: 1248:    buffer_p += info.element_size;
        -: 1249:  }
        -: 1250:
    #####: 1251:free_object:
    #####: 1252:  ecma_deref_object (arraylike_object_p);
        -: 1253:
    #####: 1254:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1255:  {
    #####: 1256:    ecma_deref_object (new_typedarray_p);
        -: 1257:  }
        -: 1258:
    #####: 1259:  return ret_value;
        -: 1260:} /* ecma_typedarray_create_object_with_object */
        -: 1261:
        -: 1262:/**
        -: 1263: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1264: *
        -: 1265: * See also: ES11 22.2.2.1
        -: 1266: *
        -: 1267: * @return ecma value of the new typedarray object
        -: 1268: *         Returned value must be freed with ecma_free_value
        -: 1269: */
        -: 1270:ecma_value_t
    #####: 1271:ecma_op_typedarray_from (ecma_value_t this_val, /**< this value */
        -: 1272:                         ecma_value_t source_val, /**< source value */
        -: 1273:                         ecma_value_t map_fn_val, /**< mapped function value */
        -: 1274:                         ecma_value_t this_arg) /**< this argument */
        -: 1275:{
        -: 1276:  JERRY_UNUSED (this_arg);
        -: 1277:  /* 3 */
    #####: 1278:  JERRY_ASSERT (ecma_op_is_callable (map_fn_val) || ecma_is_value_undefined (map_fn_val));
        -: 1279:
        -: 1280:  /* 4 */
    #####: 1281:  ecma_object_t *func_object_p = NULL;
        -: 1282:
    #####: 1283:  if (!ecma_is_value_undefined (map_fn_val))
        -: 1284:  {
    #####: 1285:    func_object_p = ecma_get_object_from_value (map_fn_val);
        -: 1286:  }
        -: 1287:
        -: 1288:  /* 5 */
    #####: 1289:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (source_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1290:
    #####: 1291:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1292:  {
    #####: 1293:    return using_iterator;
        -: 1294:  }
        -: 1295:
        -: 1296:  /* 6 */
    #####: 1297:  if (!ecma_is_value_undefined (using_iterator))
        -: 1298:  {
        -: 1299:    /* 6.a */
    #####: 1300:    ecma_value_t next_method;
    #####: 1301:    ecma_value_t iterator = ecma_op_get_iterator (source_val, using_iterator, &next_method);
    #####: 1302:    ecma_free_value (using_iterator);
        -: 1303:
        -: 1304:    /* 6.b */
    #####: 1305:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1306:    {
    #####: 1307:      return iterator;
        -: 1308:    }
        -: 1309:
        -: 1310:    /* 6.c */
    #####: 1311:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1312:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1313:
        -: 1314:    /* 6.e */
        -: 1315:    while (true)
    #####: 1316:    {
    #####: 1317:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1318:
    #####: 1319:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1320:      {
    #####: 1321:        ret_value = next;
    #####: 1322:        break;
        -: 1323:      }
        -: 1324:
    #####: 1325:      if (next == ECMA_VALUE_FALSE)
        -: 1326:      {
    #####: 1327:        break;
        -: 1328:      }
        -: 1329:
    #####: 1330:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1331:      ecma_free_value (next);
        -: 1332:
    #####: 1333:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1334:      {
    #####: 1335:        ret_value = next_value;
    #####: 1336:        break;
        -: 1337:      }
        -: 1338:
    #####: 1339:      ecma_collection_push_back (values_p, next_value);
        -: 1340:    }
        -: 1341:
    #####: 1342:    ecma_free_value (iterator);
    #####: 1343:    ecma_free_value (next_method);
        -: 1344:
    #####: 1345:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1346:    {
    #####: 1347:      ecma_collection_free (values_p);
    #####: 1348:      return ret_value;
        -: 1349:    }
        -: 1350:
        -: 1351:    /* 6.c */
    #####: 1352:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1353:    ecma_value_t len_val = ecma_make_uint32_value (values_p->item_count);
    #####: 1354:    ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1355:    ecma_free_value (len_val);
        -: 1356:
    #####: 1357:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1358:    {
    #####: 1359:      ecma_collection_free (values_p);
    #####: 1360:      return new_typedarray;
        -: 1361:    }
        -: 1362:
    #####: 1363:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1364:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1365:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1366:    ecma_value_t *next_value_p = values_p->buffer_p;
        -: 1367:
    #####: 1368:    ret_value = ECMA_VALUE_ERROR;
        -: 1369:
    #####: 1370:    if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1371:    {
    #####: 1372:      goto free_collection;
        -: 1373:    }
        -: 1374:
    #####: 1375:    if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1376:    {
    #####: 1377:      ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
    #####: 1378:      goto free_collection;
        -: 1379:    }
        -: 1380:
    #####: 1381:    uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1382:
    #####: 1383:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1384:
        -: 1385:    /* 6.e */
    #####: 1386:    for (uint32_t index = 0; index < values_p->item_count; index++)
        -: 1387:    {
    #####: 1388:      ecma_value_t set_value =
    #####: 1389:        ecma_op_typedarray_from_helper (this_arg, *next_value_p++, index, func_object_p, buffer_p, setter_cb);
        -: 1390:
    #####: 1391:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1392:      {
    #####: 1393:        ret_value = set_value;
    #####: 1394:        break;
        -: 1395:      }
        -: 1396:
    #####: 1397:      buffer_p += info.element_size;
        -: 1398:    }
        -: 1399:
    #####: 1400:free_collection:
    #####: 1401:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1402:    {
    #####: 1403:      ecma_value_t *last_value_p = values_p->buffer_p + values_p->item_count;
        -: 1404:
    #####: 1405:      while (next_value_p < last_value_p)
        -: 1406:      {
    #####: 1407:        ecma_free_value (*next_value_p++);
        -: 1408:      }
        -: 1409:
    #####: 1410:      ecma_deref_object (new_typedarray_p);
        -: 1411:    }
        -: 1412:
    #####: 1413:    ecma_collection_destroy (values_p);
    #####: 1414:    return ret_value;
        -: 1415:  }
        -: 1416:
        -: 1417:  /* 8 */
    #####: 1418:  ecma_value_t arraylike_object_val = ecma_op_to_object (source_val);
        -: 1419:
    #####: 1420:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1421:  {
    #####: 1422:    return arraylike_object_val;
        -: 1423:  }
        -: 1424:
    #####: 1425:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1426:
        -: 1427:  /* 9 */
    #####: 1428:  ecma_length_t length_index;
    #####: 1429:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1430:
    #####: 1431:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1432:  {
    #####: 1433:    ecma_deref_object (arraylike_object_p);
    #####: 1434:    return len_value;
        -: 1435:  }
        -: 1436:
    #####: 1437:  if (length_index >= UINT32_MAX)
        -: 1438:  {
    #####: 1439:    ecma_deref_object (arraylike_object_p);
    #####: 1440:    return ecma_raise_range_error (ECMA_ERR_INVALID_TYPEDARRAY_LENGTH);
        -: 1441:  }
        -: 1442:
    #####: 1443:  uint32_t len = (uint32_t) length_index;
        -: 1444:
        -: 1445:  /* 10 */
    #####: 1446:  ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1447:  ecma_value_t len_val = ecma_make_uint32_value (len);
    #####: 1448:  ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1449:  ecma_free_value (len_val);
        -: 1450:
    #####: 1451:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1452:  {
    #####: 1453:    ecma_deref_object (arraylike_object_p);
    #####: 1454:    return new_typedarray;
        -: 1455:  }
        -: 1456:
    #####: 1457:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1458:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
        -: 1459:
    #####: 1460:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -: 1461:
    #####: 1462:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1463:  {
    #####: 1464:    goto free_object;
        -: 1465:  }
        -: 1466:
    #####: 1467:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1468:  {
    #####: 1469:    ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
    #####: 1470:    goto free_object;
        -: 1471:  }
        -: 1472:
    #####: 1473:  uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1474:
    #####: 1475:  ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1476:
    #####: 1477:  ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1478:
        -: 1479:  /* 12 */
    #####: 1480:  for (uint32_t index = 0; index < len; index++)
        -: 1481:  {
    #####: 1482:    ecma_value_t value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1483:
    #####: 1484:    if (ECMA_IS_VALUE_ERROR (value))
        -: 1485:    {
    #####: 1486:      ret_value = value;
    #####: 1487:      break;
        -: 1488:    }
        -: 1489:
    #####: 1490:    if (!ecma_is_value_found (value))
        -: 1491:    {
    #####: 1492:      value = ECMA_VALUE_UNDEFINED;
        -: 1493:    }
        -: 1494:
    #####: 1495:    ecma_value_t set_value =
        -: 1496:      ecma_op_typedarray_from_helper (this_arg, value, index, func_object_p, buffer_p, setter_cb);
        -: 1497:
    #####: 1498:    if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1499:    {
    #####: 1500:      ret_value = set_value;
    #####: 1501:      break;
        -: 1502:    }
        -: 1503:
    #####: 1504:    buffer_p += info.element_size;
        -: 1505:  }
        -: 1506:
    #####: 1507:free_object:
    #####: 1508:  ecma_deref_object (arraylike_object_p);
        -: 1509:
    #####: 1510:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1511:  {
    #####: 1512:    ecma_deref_object (new_typedarray_p);
        -: 1513:  }
        -: 1514:
    #####: 1515:  return ret_value;
        -: 1516:} /* ecma_op_typedarray_from */
        -: 1517:
        -: 1518:/**
        -: 1519: * Get the arraybuffer of the typedarray object
        -: 1520: *
        -: 1521: * @return the pointer to the internal arraybuffer
        -: 1522: */
        -: 1523:extern inline ecma_object_t *JERRY_ATTR_ALWAYS_INLINE
    #####: 1524:ecma_typedarray_get_arraybuffer (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1525:{
    #####: 1526:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1527:
    #####: 1528:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1529:
    #####: 1530:  return ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
        -: 1531:} /* ecma_typedarray_get_arraybuffer */
        -: 1532:
        -: 1533:/**
        -: 1534: * Get the element size shift in the typedarray object
        -: 1535: *
        -: 1536: * @return the size shift of the element, size is 1 << shift
        -: 1537: */
        -: 1538:uint8_t
    #####: 1539:ecma_typedarray_get_element_size_shift (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1540:{
    #####: 1541:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1542:
    #####: 1543:  return ecma_typedarray_helper_get_shift_size (ecma_get_typedarray_id (typedarray_p));
        -: 1544:} /* ecma_typedarray_get_element_size_shift */
        -: 1545:
        -: 1546:/**
        -: 1547: * Get the array length of the typedarray object
        -: 1548: *
        -: 1549: * @return the array length
        -: 1550: */
        -: 1551:uint32_t
    #####: 1552:ecma_typedarray_get_length (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1553:{
    #####: 1554:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1555:
    #####: 1556:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1557:
    #####: 1558:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1559:  {
    #####: 1560:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
    #####: 1561:    ecma_extended_object_t *arraybuffer_object_p = (ecma_extended_object_t *) arraybuffer_p;
    #####: 1562:    uint32_t buffer_length = arraybuffer_object_p->u.cls.u3.length;
    #####: 1563:    uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        -: 1564:
    #####: 1565:    return buffer_length >> shift;
        -: 1566:  }
        -: 1567:
    #####: 1568:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1569:
    #####: 1570:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1571:  {
    #####: 1572:    return 0;
        -: 1573:  }
        -: 1574:
    #####: 1575:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1576:
    #####: 1577:  return info_p->array_length;
        -: 1578:} /* ecma_typedarray_get_length */
        -: 1579:
        -: 1580:/**
        -: 1581: * Get the offset of the internal arraybuffer
        -: 1582: *
        -: 1583: * @return the offset
        -: 1584: */
        -: 1585:uint32_t
    #####: 1586:ecma_typedarray_get_offset (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1587:{
    #####: 1588:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1589:
    #####: 1590:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1591:
    #####: 1592:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1593:  {
    #####: 1594:    return 0;
        -: 1595:  }
        -: 1596:
    #####: 1597:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1598:
    #####: 1599:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1600:  {
    #####: 1601:    return 0;
        -: 1602:  }
        -: 1603:
    #####: 1604:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1605:
    #####: 1606:  return info_p->byte_offset;
        -: 1607:} /* ecma_typedarray_get_offset */
        -: 1608:
        -: 1609:/**
        -: 1610: * Utility function: return the pointer of the data buffer referenced by the typedarray info
        -: 1611: *
        -: 1612: * @return pointer to the data buffer if successfull,
        -: 1613: *         NULL otherwise
        -: 1614: */
        -: 1615:extern inline uint8_t *
    #####: 1616:ecma_typedarray_get_buffer (ecma_typedarray_info_t *info_p) /**< typedarray info */
        -: 1617:{
    #####: 1618:  return ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        -: 1619:} /* ecma_typedarray_get_buffer */
        -: 1620:
        -: 1621:/**
        -: 1622: * Create a new typedarray object.
        -: 1623: *
        -: 1624: * The struct of the typedarray object
        -: 1625: *   ecma_object_t
        -: 1626: *   extend_part
        -: 1627: *   typedarray_info
        -: 1628: *
        -: 1629: * @return ecma value of the new typedarray object
        -: 1630: *         Returned value must be freed with ecma_free_value
        -: 1631: */
        -: 1632:ecma_value_t
    #####: 1633:ecma_op_create_typedarray (const ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 1634:                           uint32_t arguments_list_len, /**< the length of the arguments_list_p */
        -: 1635:                           ecma_object_t *proto_p, /**< prototype object */
        -: 1636:                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1637:                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1638:{
    #####: 1639:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -: 1640:
    #####: 1641:  if (arguments_list_len == 0)
        -: 1642:  {
        -: 1643:    /* 22.2.1.1 */
    #####: 1644:    return ecma_typedarray_create_object_with_length (0, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1645:  }
        -: 1646:
    #####: 1647:  if (!ecma_is_value_object (arguments_list_p[0]))
        -: 1648:  {
    #####: 1649:    ecma_number_t num = 0;
        -: 1650:
    #####: 1651:    if (!ecma_is_value_undefined (arguments_list_p[0])
    #####: 1652:        && ECMA_IS_VALUE_ERROR (ecma_op_to_index (arguments_list_p[0], &num)))
        -: 1653:    {
    #####: 1654:      return ECMA_VALUE_ERROR;
        -: 1655:    }
        -: 1656:
    #####: 1657:    JERRY_ASSERT (num >= 0 && num <= ECMA_NUMBER_MAX_SAFE_INTEGER);
        -: 1658:
    #####: 1659:    if (num > UINT32_MAX)
        -: 1660:    {
        -: 1661:#if JERRY_ERROR_MESSAGES
    #####: 1662:      return ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE,
        -: 1663:                                                    "Invalid typed array length: %",
        -: 1664:                                                    arguments_list_p[0]);
        -: 1665:#else /* !JERRY_ERROR_MESSAGES */
        -: 1666:      return ecma_raise_range_error (ECMA_ERR_EMPTY);
        -: 1667:#endif /* JERRY_ERROR_MESSAGES */
        -: 1668:    }
        -: 1669:
    #####: 1670:    return ecma_typedarray_create_object_with_length ((uint32_t) num, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1671:  }
        -: 1672:
    #####: 1673:  ecma_object_t *obj_p = ecma_get_object_from_value (arguments_list_p[0]);
        -: 1674:
    #####: 1675:  if (ecma_object_is_typedarray (obj_p))
        -: 1676:  {
        -: 1677:    /* 22.2.1.3 */
    #####: 1678:    ecma_object_t *typedarray_p = obj_p;
    #####: 1679:    return ecma_typedarray_create_object_with_typedarray (typedarray_p, proto_p, element_size_shift, typedarray_id);
        -: 1680:  }
        -: 1681:
    #####: 1682:  if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER) && !ecma_object_is_shared_arraybuffer (obj_p))
        -: 1683:  {
        -: 1684:    /* 22.2.1.4 */
    #####: 1685:    return ecma_typedarray_create_object_with_object (arguments_list_p[0], proto_p, element_size_shift, typedarray_id);
        -: 1686:  }
        -: 1687:
        -: 1688:  /* 22.2.1.5 */
    #####: 1689:  ecma_object_t *arraybuffer_p = obj_p;
    #####: 1690:  ecma_value_t byte_offset_value = ((arguments_list_len > 1) ? arguments_list_p[1] : ECMA_VALUE_UNDEFINED);
        -: 1691:
    #####: 1692:  ecma_value_t length_value = ((arguments_list_len > 2) ? arguments_list_p[2] : ECMA_VALUE_UNDEFINED);
        -: 1693:
    #####: 1694:  ecma_number_t offset;
        -: 1695:
    #####: 1696:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (byte_offset_value, &offset)))
        -: 1697:  {
    #####: 1698:    return ECMA_VALUE_ERROR;
        -: 1699:  }
        -: 1700:
    #####: 1701:  if (ecma_number_is_negative (offset) || fmod (offset, (1 << element_size_shift)) != 0)
        -: 1702:  {
        -: 1703:    /* ES2015 22.2.1.5: 9 - 10. */
    #####: 1704:    if (ecma_number_is_zero (offset))
        -: 1705:    {
    #####: 1706:      offset = 0;
        -: 1707:    }
        -: 1708:    else
        -: 1709:    {
    #####: 1710:      return ecma_raise_range_error (ECMA_ERR_INVALID_OFFSET);
        -: 1711:    }
        -: 1712:  }
        -: 1713:
    #####: 1714:  ecma_number_t new_length = 0;
        -: 1715:
    #####: 1716:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (length_value, &new_length)))
        -: 1717:  {
    #####: 1718:    return ECMA_VALUE_ERROR;
        -: 1719:  }
        -: 1720:
    #####: 1721:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1722:  {
    #####: 1723:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1724:  }
        -: 1725:
    #####: 1726:  if (offset > UINT32_MAX)
        -: 1727:  {
    #####: 1728:    return ecma_raise_range_error (ECMA_ERR_INVALID_LENGTH);
        -: 1729:  }
        -: 1730:
    #####: 1731:  uint32_t byte_offset = (uint32_t) offset;
        -: 1732:
    #####: 1733:  uint32_t buf_byte_length = ecma_arraybuffer_get_length (arraybuffer_p);
    #####: 1734:  uint32_t new_byte_length = 0;
        -: 1735:
    #####: 1736:  if (ecma_is_value_undefined (length_value))
        -: 1737:  {
    #####: 1738:    if ((buf_byte_length % (uint32_t) (1 << element_size_shift) != 0) || (buf_byte_length < byte_offset))
        -: 1739:    {
    #####: 1740:      return ecma_raise_range_error (ECMA_ERR_INVALID_LENGTH);
        -: 1741:    }
        -: 1742:
    #####: 1743:    new_byte_length = (uint32_t) (buf_byte_length - byte_offset);
        -: 1744:  }
        -: 1745:  else
        -: 1746:  {
    #####: 1747:    if (new_length > (UINT32_MAX >> element_size_shift))
        -: 1748:    {
    #####: 1749:      return ecma_raise_range_error (ECMA_ERR_MAXIMUM_TYPEDARRAY_SIZE_IS_REACHED);
        -: 1750:    }
        -: 1751:
    #####: 1752:    new_byte_length = (uint32_t) new_length << element_size_shift;
        -: 1753:
    #####: 1754:    if (byte_offset > buf_byte_length || new_byte_length > (buf_byte_length - byte_offset))
        -: 1755:    {
    #####: 1756:      return ecma_raise_range_error (ECMA_ERR_INVALID_LENGTH);
        -: 1757:    }
        -: 1758:  }
        -: 1759:
    #####: 1760:  bool needs_ext_typedarray_obj = (byte_offset != 0 || new_byte_length != buf_byte_length);
        -: 1761:
    #####: 1762:  size_t object_size =
    #####: 1763:    (needs_ext_typedarray_obj ? sizeof (ecma_extended_typedarray_object_t) : sizeof (ecma_extended_object_t));
        -: 1764:
    #####: 1765:  ecma_object_t *object_p = ecma_create_object (proto_p, object_size, ECMA_OBJECT_TYPE_CLASS);
        -: 1766:
    #####: 1767:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 1768:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
    #####: 1769:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
    #####: 1770:  ext_object_p->u.cls.u2.typedarray_flags = 0;
    #####: 1771:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (arraybuffer_p);
        -: 1772:
    #####: 1773:  if (needs_ext_typedarray_obj)
        -: 1774:  {
    #####: 1775:    ext_object_p->u.cls.u2.typedarray_flags |= ECMA_TYPEDARRAY_IS_EXTENDED;
        -: 1776:
    #####: 1777:    ecma_extended_typedarray_object_t *typedarray_info_p = (ecma_extended_typedarray_object_t *) object_p;
    #####: 1778:    typedarray_info_p->array_length = new_byte_length >> element_size_shift;
    #####: 1779:    typedarray_info_p->byte_offset = byte_offset;
        -: 1780:  }
        -: 1781:
    #####: 1782:  return ecma_make_object_value (object_p);
        -: 1783:} /* ecma_op_create_typedarray */
        -: 1784:
        -: 1785:/**
        -: 1786: * Helper function for typedArray.prototype object's {'keys', 'values', 'entries', '@@iterator'}
        -: 1787: * routines common parts.
        -: 1788: *
        -: 1789: * See also:
        -: 1790: *          ECMA-262 v6, 22.2.3.15
        -: 1791: *          ECMA-262 v6, 22.2.3.29
        -: 1792: *          ECMA-262 v6, 22.2.3.6
        -: 1793: *          ECMA-262 v6, 22.1.3.30
        -: 1794: *
        -: 1795: * Note:
        -: 1796: *      Returned value must be freed with ecma_free_value.
        -: 1797: *
        -: 1798: * @return iterator result object, if success
        -: 1799: *         error - otherwise
        -: 1800: */
        -: 1801:ecma_value_t
    #####: 1802:ecma_typedarray_iterators_helper (ecma_value_t this_arg, /**< this argument */
        -: 1803:                                  ecma_iterator_kind_t kind) /**< iterator kind */
        -: 1804:{
    #####: 1805:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
        -: 1806:
    #####: 1807:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1808:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1809:
    #####: 1810:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1811:  {
    #####: 1812:    return ECMA_VALUE_ERROR;
        -: 1813:  }
        -: 1814:
    #####: 1815:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1816:  {
    #####: 1817:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1818:  }
        -: 1819:
    #####: 1820:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -: 1821:
    #####: 1822:  return ecma_op_create_iterator_object (this_arg, prototype_obj_p, ECMA_OBJECT_CLASS_ARRAY_ITERATOR, kind);
        -: 1823:} /* ecma_typedarray_iterators_helper */
        -: 1824:
        -: 1825:/**
        -: 1826: * Check if the object is typedarray
        -: 1827: *
        -: 1828: * @return true - if object is a TypedArray object
        -: 1829: *         false - otherwise
        -: 1830: */
        -: 1831:bool
    #####: 1832:ecma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */
        -: 1833:{
    #####: 1834:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -: 1835:
    #####: 1836:  return ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_TYPEDARRAY);
        -: 1837:} /* ecma_object_is_typedarray */
        -: 1838:
        -: 1839:/**
        -: 1840: * Check if the value is typedarray
        -: 1841: *
        -: 1842: * @return true - if value is a TypedArray object
        -: 1843: *         false - otherwise
        -: 1844: */
        -: 1845:bool
    #####: 1846:ecma_is_typedarray (ecma_value_t value) /**< the target need to be checked */
        -: 1847:{
    #####: 1848:  if (!ecma_is_value_object (value))
        -: 1849:  {
    #####: 1850:    return false;
        -: 1851:  }
        -: 1852:
    #####: 1853:  return ecma_object_is_typedarray (ecma_get_object_from_value (value));
        -: 1854:} /* ecma_is_typedarray */
        -: 1855:
        -: 1856:/**
        -: 1857: * Checks whether the property name is a valid element index
        -: 1858: *
        -: 1859: * @return true, if valid
        -: 1860: *         false, otherwise
        -: 1861: */
        -: 1862:bool
    #####: 1863:ecma_typedarray_is_element_index (ecma_string_t *property_name_p) /**< property name */
        -: 1864:{
    #####: 1865:  ecma_number_t num = ecma_string_to_number (property_name_p);
        -: 1866:
    #####: 1867:  if (num == 0)
        -: 1868:  {
    #####: 1869:    return true;
        -: 1870:  }
        -: 1871:
    #####: 1872:  ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####: 1873:  bool is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####: 1874:  ecma_deref_ecma_string (num_to_str);
    #####: 1875:  return is_same;
        -: 1876:} /* ecma_typedarray_is_element_index */
        -: 1877:
        -: 1878:/**
        -: 1879: * List names of a TypedArray object's integer indexed properties
        -: 1880: */
        -: 1881:void
    #####: 1882:ecma_op_typedarray_list_lazy_property_names (ecma_object_t *obj_p, /**< a TypedArray object */
        -: 1883:                                             ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 1884:                                             ecma_property_counter_t *prop_counter_p, /**< property counters */
        -: 1885:                                             jerry_property_filter_t filter) /**< property name filter options */
        -: 1886:{
    #####: 1887:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1888:
    #####: 1889:  if (filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES)
        -: 1890:  {
    #####: 1891:    return;
        -: 1892:  }
        -: 1893:
    #####: 1894:  uint32_t array_length = ecma_typedarray_get_length (obj_p);
        -: 1895:
    #####: 1896:  for (uint32_t i = 0; i < array_length; i++)
        -: 1897:  {
    #####: 1898:    ecma_string_t *name_p = ecma_new_ecma_string_from_uint32 (i);
    #####: 1899:    ecma_collection_push_back (prop_names_p, ecma_make_string_value (name_p));
        -: 1900:  }
        -: 1901:
    #####: 1902:  prop_counter_p->array_index_named_props += array_length;
        -: 1903:} /* ecma_op_typedarray_list_lazy_property_names */
        -: 1904:
        -: 1905:/**
        -: 1906: * [[DefineOwnProperty]] operation for TypedArray objects
        -: 1907: *
        -: 1908: * See also: ES2015 9.4.5.3
        -: 1909: *
        -: 1910: * @return ECMA_VALUE_TRUE - if the property is successfully defined
        -: 1911: *         ECMA_VALUE_FALSE - if is JERRY_PROP_SHOULD_THROW is not set
        -: 1912: *         raised TypeError - otherwise
        -: 1913: */
        -: 1914:ecma_value_t
    #####: 1915:ecma_op_typedarray_define_own_property (ecma_object_t *obj_p, /**< TypedArray object */
        -: 1916:                                        ecma_string_t *property_name_p, /**< property name */
        -: 1917:                                        const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1918:{
    #####: 1919:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1920:
    #####: 1921:  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -: 1922:  {
    #####: 1923:    return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1924:  }
        -: 1925:
    #####: 1926:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1927:
    #####: 1928:  if (index == ECMA_STRING_NOT_ARRAY_INDEX && !ecma_typedarray_is_element_index (property_name_p))
        -: 1929:  {
    #####: 1930:    return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1931:  }
        -: 1932:
    #####: 1933:  if ((property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
    #####: 1934:      || ((property_desc_p->flags & (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
        -: 1935:          == (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
    #####: 1936:      || ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
    #####: 1937:          && !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE))
    #####: 1938:      || ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
    #####: 1939:          && !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE)))
        -: 1940:  {
    #####: 1941:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1942:  }
        -: 1943:
    #####: 1944:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -: 1945:
    #####: 1946:  if (index >= info.length || ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1947:  {
    #####: 1948:    return ECMA_VALUE_FALSE;
        -: 1949:  }
        -: 1950:
    #####: 1951:  if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1952:  {
    #####: 1953:    ecma_value_t set_element = ecma_set_typedarray_element (&info, property_desc_p->value, index);
        -: 1954:
    #####: 1955:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1956:    {
    #####: 1957:      return set_element;
        -: 1958:    }
        -: 1959:  }
        -: 1960:
    #####: 1961:  return ECMA_VALUE_TRUE;
        -: 1962:} /* ecma_op_typedarray_define_own_property */
        -: 1963:
        -: 1964:/**
        -: 1965: * Specify the creation of a new TypedArray
        -: 1966: * object using a constructor function.
        -: 1967: *
        -: 1968: * See also: ES11 22.2.4.6
        -: 1969: *
        -: 1970: * Used by:
        -: 1971: *        - ecma_typedarray_species_create
        -: 1972: *
        -: 1973: * @return ecma_value_t function object from created from constructor_p argument
        -: 1974: */
        -: 1975:
        -: 1976:ecma_value_t
    #####: 1977:ecma_typedarray_create (ecma_object_t *constructor_p, /**< constructor function */
        -: 1978:                        ecma_value_t *arguments_list_p, /**< argument list */
        -: 1979:                        uint32_t arguments_list_len) /**< length of argument list */
        -: 1980:{
    #####: 1981:  ecma_value_t ret_val =
        -: 1982:    ecma_op_function_construct (constructor_p, constructor_p, arguments_list_p, arguments_list_len);
    #####: 1983:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -: 1984:  {
    #####: 1985:    return ret_val;
        -: 1986:  }
        -: 1987:
    #####: 1988:  if (!ecma_is_typedarray (ret_val))
        -: 1989:  {
    #####: 1990:    ecma_free_value (ret_val);
    #####: 1991:    return ecma_raise_type_error (ECMA_ERR_CONSTRUCTED_OBJECT_IS_NOT_TYPEDARRAY);
        -: 1992:  }
        -: 1993:
    #####: 1994:  ecma_object_t *typedarray_p = ecma_get_object_from_value (ret_val);
    #####: 1995:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1996:
    #####: 1997:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1998:  {
    #####: 1999:    ecma_deref_object (typedarray_p);
    #####: 2000:    return ECMA_VALUE_ERROR;
        -: 2001:  }
        -: 2002:
    #####: 2003:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 2004:  {
    #####: 2005:    ecma_deref_object (typedarray_p);
    #####: 2006:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 2007:  }
        -: 2008:
    #####: 2009:  if ((arguments_list_len == 1) && (ecma_is_value_number (arguments_list_p[0])))
        -: 2010:  {
    #####: 2011:    ecma_number_t num = ecma_get_number_from_value (arguments_list_p[0]);
        -: 2012:
    #####: 2013:    if (info.length < num)
        -: 2014:    {
    #####: 2015:      ecma_free_value (ret_val);
    #####: 2016:      return ecma_raise_type_error (ECMA_ERR_TYPEDARRAY_SMALLER_THAN_FILTER_CALL_RESULT);
        -: 2017:    }
        -: 2018:  }
    #####: 2019:  return ret_val;
        -: 2020:} /* ecma_typedarray_create */
        -: 2021:
        -: 2022:/* Specify the creation of a new TypedArray object
        -: 2023: * using a constructor function that is derived from this_arg.
        -: 2024: *
        -: 2025: * See also: ES11 22.2.4.7
        -: 2026: *
        -: 2027: * @return ecma value of the new typedarray object, constructed by default or species constructor
        -: 2028: */
        -: 2029:ecma_value_t
    #####: 2030:ecma_typedarray_species_create (ecma_value_t this_arg, /**< this argument */
        -: 2031:                                ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 2032:                                uint32_t arguments_list_len) /**< length of the the arg list */
        -: 2033:{
    #####: 2034:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 2035:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 2036:
    #####: 2037:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
        -: 2038:
    #####: 2039:  ecma_builtin_id_t default_constructor = ecma_typedarray_helper_get_constructor_id (info.id);
        -: 2040:
    #####: 2041:  ecma_value_t constructor = ecma_op_species_constructor (typedarray_p, default_constructor);
        -: 2042:
    #####: 2043:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2044:  {
    #####: 2045:    return constructor;
        -: 2046:  }
        -: 2047:
    #####: 2048:  ecma_object_t *constructor_proto_p = ecma_get_object_from_value (constructor);
        -: 2049:
    #####: 2050:  ecma_value_t result = ecma_typedarray_create (constructor_proto_p, arguments_list_p, arguments_list_len);
    #####: 2051:  ecma_deref_object (constructor_proto_p);
        -: 2052:
    #####: 2053:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2054:  {
    #####: 2055:    return result;
        -: 2056:  }
        -: 2057:
        -: 2058:#if JERRY_BUILTIN_BIGINT
    #####: 2059:  ecma_object_t *result_p = ecma_get_object_from_value (result);
    #####: 2060:  ecma_typedarray_info_t result_info = ecma_typedarray_get_info (result_p);
        -: 2061:  /*
        -: 2062:   * Check result_info.id to to be either bigint type if info.id is one
        -: 2063:   * or be neither of them is info.id is none of them as well.
        -: 2064:   */
    #####: 2065:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info.id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (result_info.id))
        -: 2066:  {
    #####: 2067:    ecma_free_value (result);
    #####: 2068:    return ecma_raise_type_error (ECMA_ERR_CONTENTTYPE_RETURNED_TYPEDARRAY_NOT_MATCH_SOURCE);
        -: 2069:  }
        -: 2070:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2071:
    #####: 2072:  return result;
        -: 2073:} /* ecma_typedarray_species_create */
        -: 2074:
        -: 2075:/**
        -: 2076: * Create a typedarray object based on the "type" and arraylength
        -: 2077: * The "type" is same with arg1
        -: 2078: *
        -: 2079: * @return ecma_value_t
        -: 2080: */
        -: 2081:ecma_value_t
    #####: 2082:ecma_op_create_typedarray_with_type_and_length (ecma_typedarray_type_t typedarray_id, /** TypedArray id  */
        -: 2083:                                                uint32_t array_length) /**< length of the typedarray */
        -: 2084:{
        -: 2085:  // TODO: assert validate typedarray_id
    #####: 2086:  ecma_object_t *proto_p = ecma_builtin_get (ecma_typedarray_helper_get_prototype_id (typedarray_id));
    #####: 2087:  uint8_t element_size_shift = ecma_typedarray_helper_get_shift_size (typedarray_id);
        -: 2088:
    #####: 2089:  ecma_value_t new_obj =
    #####: 2090:    ecma_typedarray_create_object_with_length (array_length, NULL, proto_p, element_size_shift, typedarray_id);
        -: 2091:
    #####: 2092:  return new_obj;
        -: 2093:} /* ecma_op_create_typedarray_with_type_and_length */
        -: 2094:
        -: 2095:/**
        -: 2096: * Method for getting the additional typedArray informations.
        -: 2097: */
        -: 2098:ecma_typedarray_info_t
    #####: 2099:ecma_typedarray_get_info (ecma_object_t *typedarray_p)
        -: 2100:{
        -: 2101:  ecma_typedarray_info_t info;
        -: 2102:
    #####: 2103:  info.id = ecma_get_typedarray_id (typedarray_p);
    #####: 2104:  info.length = ecma_typedarray_get_length (typedarray_p);
    #####: 2105:  info.shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 2106:  info.element_size = (uint8_t) (1 << info.shift);
    #####: 2107:  info.offset = ecma_typedarray_get_offset (typedarray_p);
    #####: 2108:  info.array_buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2109:
    #####: 2110:  return info;
        -: 2111:} /* ecma_typedarray_get_info */
        -: 2112:
        -: 2113:/**
        -: 2114: * @}
        -: 2115: * @}
        -: 2116: */
        -: 2117:#endif /* JERRY_BUILTIN_TYPEDARRAY */
