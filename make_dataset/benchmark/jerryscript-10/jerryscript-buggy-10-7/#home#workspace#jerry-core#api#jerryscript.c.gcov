        -:    0:Source:/home/workspace/jerry-core/api/jerryscript.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:
        -:   18:#include <math.h>
        -:   19:#include <stdio.h>
        -:   20:
        -:   21:#include "jerryscript-debugger-transport.h"
        -:   22:
        -:   23:#include "ecma-alloc.h"
        -:   24:#include "ecma-array-object.h"
        -:   25:#include "ecma-arraybuffer-object.h"
        -:   26:#include "ecma-bigint.h"
        -:   27:#include "ecma-builtin-helpers.h"
        -:   28:#include "ecma-builtins.h"
        -:   29:#include "ecma-comparison.h"
        -:   30:#include "ecma-container-object.h"
        -:   31:#include "ecma-dataview-object.h"
        -:   32:#include "ecma-errors.h"
        -:   33:#include "ecma-eval.h"
        -:   34:#include "ecma-exceptions.h"
        -:   35:#include "ecma-extended-info.h"
        -:   36:#include "ecma-function-object.h"
        -:   37:#include "ecma-gc.h"
        -:   38:#include "ecma-globals.h"
        -:   39:#include "ecma-helpers.h"
        -:   40:#include "ecma-init-finalize.h"
        -:   41:#include "ecma-iterator-object.h"
        -:   42:#include "ecma-lex-env.h"
        -:   43:#include "ecma-line-info.h"
        -:   44:#include "ecma-literal-storage.h"
        -:   45:#include "ecma-objects-general.h"
        -:   46:#include "ecma-objects.h"
        -:   47:#include "ecma-promise-object.h"
        -:   48:#include "ecma-proxy-object.h"
        -:   49:#include "ecma-regexp-object.h"
        -:   50:#include "ecma-shared-arraybuffer-object.h"
        -:   51:#include "ecma-symbol-object.h"
        -:   52:#include "ecma-typedarray-object.h"
        -:   53:
        -:   54:#include "debugger.h"
        -:   55:#include "jcontext.h"
        -:   56:#include "jmem.h"
        -:   57:#include "js-parser.h"
        -:   58:#include "lit-char-helpers.h"
        -:   59:#include "opcodes.h"
        -:   60:#include "re-compiler.h"
        -:   61:
        -:   62:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   63:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   64:
        -:   65:#if JERRY_BUILTIN_REGEXP
        -:   66:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   67:                       && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   68:                       && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE
        -:   69:                       && (int) RE_FLAG_STICKY == (int) JERRY_REGEXP_FLAG_STICKY
        -:   70:                       && (int) RE_FLAG_UNICODE == (int) JERRY_REGEXP_FLAG_UNICODE
        -:   71:                       && (int) RE_FLAG_DOTALL == (int) JERRY_REGEXP_FLAG_DOTALL,
        -:   72:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   73:#endif /* JERRY_BUILTIN_REGEXP */
        -:   74:
        -:   75:#if JERRY_ESNEXT
        -:   76:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   77:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   78:                       && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   79:                     promise_internal_state_matches_external);
        -:   80:#endif /* JERRY_ESNEXT */
        -:   81:
        -:   82:/**
        -:   83: * Offset between internal and external arithmetic operator types
        -:   84: */
        -:   85:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   86:
        -:   87:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   88:                       && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET)
        -:   89:                           == JERRY_BIN_OP_MUL)
        -:   90:                       && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   91:                       && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   92:                     number_arithmetics_operation_type_matches_external);
        -:   93:
        -:   94:#if !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC
        -:   95:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   96:#endif /* !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC */
        -:   97:
        -:   98:/** \addtogroup jerry Jerry engine interface
        -:   99: * @{
        -:  100: */
        -:  101:
        -:  102:/**
        -:  103: * Assert that it is correct to call API in current state.
        -:  104: *
        -:  105: * Note:
        -:  106: *         By convention, there are some states when API could not be invoked.
        -:  107: *
        -:  108: *         The API can be and only be invoked when the ECMA_STATUS_API_ENABLED
        -:  109: *         flag is set.
        -:  110: *
        -:  111: *         This procedure checks whether the API is available, and terminates
        -:  112: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  113: *
        -:  114: * Note:
        -:  115: *         The API could not be invoked in the following cases:
        -:  116: *           - before jerry_init and after jerry_cleanup
        -:  117: *           - between enter to and return from a native free callback
        -:  118: */
        -:  119:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  120:jerry_assert_api_enabled (void)
        -:  121:{
       51:  122:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_ENABLED);
        -:  123:} /* jerry_assert_api_enabled */
        -:  124:
        -:  125:/**
        -:  126: * Turn on API availability
        -:  127: */
        -:  128:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  129:jerry_api_enable (void)
        -:  130:{
        -:  131:#ifndef JERRY_NDEBUG
        1:  132:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_ENABLED;
        -:  133:#endif /* JERRY_NDEBUG */
        -:  134:} /* jerry_make_api_available */
        -:  135:
        -:  136:/**
        -:  137: * Turn off API availability
        -:  138: */
        -:  139:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  140:jerry_api_disable (void)
        -:  141:{
        -:  142:#ifndef JERRY_NDEBUG
    #####:  143:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_ENABLED;
        -:  144:#endif /* JERRY_NDEBUG */
        -:  145:} /* jerry_make_api_unavailable */
        -:  146:
        -:  147:/**
        -:  148: * Create an API compatible return value.
        -:  149: *
        -:  150: * @return return value for Jerry API functions
        -:  151: */
        -:  152:static jerry_value_t
        5:  153:jerry_return (const jerry_value_t value) /**< return value */
        -:  154:{
        5:  155:  if (ECMA_IS_VALUE_ERROR (value))
        -:  156:  {
    #####:  157:    return ecma_create_exception_from_context ();
        -:  158:  }
        -:  159:
        5:  160:  return value;
        -:  161:} /* jerry_return */
        -:  162:
        -:  163:/**
        -:  164: * Jerry engine initialization
        -:  165: */
        -:  166:void
        1:  167:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  168:{
        -:  169:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  170:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_ENABLED));
        -:  171:
        -:  172:  /* Zero out all non-external members. */
        1:  173:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER),
        -:  174:          0,
        -:  175:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  176:
        1:  177:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  178:
        -:  179:  jerry_api_enable ();
        -:  180:
        1:  181:  jmem_init ();
        1:  182:  ecma_init ();
        1:  183:} /* jerry_init */
        -:  184:
        -:  185:/**
        -:  186: * Terminate Jerry engine
        -:  187: */
        -:  188:void
    #####:  189:jerry_cleanup (void)
        -:  190:{
        -:  191:  jerry_assert_api_enabled ();
        -:  192:
        -:  193:#if JERRY_DEBUGGER
        -:  194:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  195:  {
        -:  196:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  197:
        -:  198:    jerry_debugger_transport_close ();
        -:  199:  }
        -:  200:#endif /* JERRY_DEBUGGER */
        -:  201:
    #####:  202:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p); this_p != NULL; this_p = this_p->next_p)
        -:  203:  {
    #####:  204:    if (this_p->manager_p->deinit_cb)
        -:  205:    {
    #####:  206:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  207:      this_p->manager_p->deinit_cb (data);
        -:  208:    }
        -:  209:  }
        -:  210:
        -:  211:#if JERRY_ESNEXT
    #####:  212:  ecma_free_all_enqueued_jobs ();
        -:  213:#endif /* JERRY_ESNEXT */
    #####:  214:  ecma_finalize ();
        -:  215:  jerry_api_disable ();
        -:  216:
    #####:  217:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL; this_p != NULL;
    #####:  218:       this_p = next_p)
        -:  219:  {
    #####:  220:    next_p = this_p->next_p;
    #####:  221:    if (this_p->manager_p->finalize_cb)
        -:  222:    {
    #####:  223:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  224:      this_p->manager_p->finalize_cb (data);
        -:  225:    }
    #####:  226:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  227:  }
        -:  228:
    #####:  229:  jmem_finalize ();
    #####:  230:} /* jerry_cleanup */
        -:  231:
        -:  232:/**
        -:  233: * Retrieve a context data item, or create a new one.
        -:  234: *
        -:  235: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  236: *
        -:  237: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  238: * none was found.
        -:  239: */
        -:  240:void *
    #####:  241:jerry_context_data (const jerry_context_data_manager_t *manager_p)
        -:  242:{
    #####:  243:  void *ret = NULL;
        -:  244:  jerry_context_data_header_t *item_p;
        -:  245:
    #####:  246:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  247:  {
    #####:  248:    if (item_p->manager_p == manager_p)
        -:  249:    {
    #####:  250:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  251:    }
        -:  252:  }
        -:  253:
    #####:  254:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  255:  item_p->manager_p = manager_p;
    #####:  256:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  257:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  258:
    #####:  259:  if (manager_p->bytes_needed > 0)
        -:  260:  {
    #####:  261:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  262:    memset (ret, 0, manager_p->bytes_needed);
        -:  263:  }
        -:  264:
    #####:  265:  if (manager_p->init_cb)
        -:  266:  {
    #####:  267:    manager_p->init_cb (ret);
        -:  268:  }
        -:  269:
    #####:  270:  return ret;
        -:  271:} /* jerry_context_data */
        -:  272:
        -:  273:/**
        -:  274: * Register external magic string array
        -:  275: */
        -:  276:void
    #####:  277:jerry_register_magic_strings (const jerry_char_t *const *ext_strings_p, /**< character arrays, representing
        -:  278:                                                                         *   external magic strings' contents */
        -:  279:                              uint32_t count, /**< number of the strings */
        -:  280:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  281:{
        -:  282:  jerry_assert_api_enabled ();
        -:  283:
    #####:  284:  lit_magic_strings_ex_set ((const lit_utf8_byte_t *const *) ext_strings_p,
        -:  285:                            count,
        -:  286:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  287:} /* jerry_register_magic_strings */
        -:  288:
        -:  289:/**
        -:  290: * Run garbage collection
        -:  291: */
        -:  292:void
    #####:  293:jerry_heap_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  294:{
        -:  295:  jerry_assert_api_enabled ();
        -:  296:
    #####:  297:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  298:  {
        -:  299:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  300:    ecma_gc_run ();
    #####:  301:    return;
        -:  302:  }
        -:  303:
    #####:  304:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  305:} /* jerry_heap_gc */
        -:  306:
        -:  307:/**
        -:  308: * Get heap memory stats.
        -:  309: *
        -:  310: * @return true - get the heap stats successful
        -:  311: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  312: */
        -:  313:bool
    #####:  314:jerry_heap_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  315:{
        -:  316:#if JERRY_MEM_STATS
    #####:  317:  if (out_stats_p == NULL)
        -:  318:  {
        -:  319:    return false;
        -:  320:  }
        -:  321:
        -:  322:  jmem_heap_stats_t jmem_heap_stats;
    #####:  323:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  324:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  325:
    #####:  326:  *out_stats_p = (jerry_heap_stats_t){ .version = 1,
    #####:  327:                                       .size = jmem_heap_stats.size,
    #####:  328:                                       .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  329:                                       .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes };
        -:  330:
    #####:  331:  return true;
        -:  332:#else /* !JERRY_MEM_STATS */
        -:  333:  JERRY_UNUSED (out_stats_p);
    #####:  334:  return false;
        -:  335:#endif /* JERRY_MEM_STATS */
        -:  336:} /* jerry_heap_stats */
        -:  337:
        -:  338:#if JERRY_PARSER
        -:  339:/**
        -:  340: * Common code for parsing a script, module, or function.
        -:  341: *
        -:  342: * @return function object value - if script was parsed successfully,
        -:  343: *         thrown error - otherwise
        -:  344: */
        -:  345:static jerry_value_t
        1:  346:jerry_parse_common (void *source_p, /**< script source */
        -:  347:                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */
        -:  348:                    uint32_t parse_opts) /**< internal parsing options */
        -:  349:{
        -:  350:  jerry_assert_api_enabled ();
        -:  351:
        1:  352:  if (options_p != NULL)
        -:  353:  {
        1:  354:    const uint32_t allowed_options =
        -:  355:      (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE | JERRY_PARSE_HAS_ARGUMENT_LIST | JERRY_PARSE_HAS_SOURCE_NAME
        -:  356:       | JERRY_PARSE_HAS_START | JERRY_PARSE_HAS_USER_VALUE);
        1:  357:    uint32_t options = options_p->options;
        -:  358:
        1:  359:    if ((options & ~allowed_options) != 0
        1:  360:        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)
    #####:  361:            && ((options_p->options & JERRY_PARSE_MODULE) || !ecma_is_value_string (options_p->argument_list)))
        1:  362:        || ((options_p->options & JERRY_PARSE_HAS_SOURCE_NAME) && !ecma_is_value_string (options_p->source_name)))
        -:  363:    {
    #####:  364:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  365:    }
        -:  366:  }
        -:  367:
        -:  368:#if JERRY_DEBUGGER
        -:  369:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && options_p != NULL
        -:  370:      && (options_p->options & JERRY_PARSE_HAS_SOURCE_NAME) && ecma_is_value_string (options_p->source_name))
        -:  371:  {
        -:  372:    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->source_name),
        -:  373:                                source_name_start_p,
        -:  374:                                source_name_size);
        -:  375:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  376:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  377:                                source_name_start_p,
        -:  378:                                source_name_size);
        -:  379:    ECMA_FINALIZE_UTF8_STRING (source_name_start_p, source_name_size);
        -:  380:  }
        -:  381:#endif /* JERRY_DEBUGGER */
        -:  382:
        1:  383:  if (options_p != NULL)
        -:  384:  {
        1:  385:    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);
        -:  386:  }
        -:  387:
        1:  388:  if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  389:  {
        -:  390:#if JERRY_MODULE_SYSTEM
    #####:  391:    JERRY_CONTEXT (module_current_p) = ecma_module_create ();
        -:  392:#else /* !JERRY_MODULE_SYSTEM */
    #####:  393:    return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  394:#endif /* JERRY_MODULE_SYSTEM */
        -:  395:  }
        -:  396:
        -:  397:  ecma_compiled_code_t *bytecode_data_p;
        1:  398:  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);
        -:  399:
        1:  400:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  401:  {
        -:  402:#if JERRY_MODULE_SYSTEM
    #####:  403:    if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  404:    {
    #####:  405:      ecma_module_cleanup_context ();
        -:  406:    }
        -:  407:#endif /* JERRY_MODULE_SYSTEM */
        -:  408:
    #####:  409:    return ecma_create_exception_from_context ();
        -:  410:  }
        -:  411:
        -:  412:#if JERRY_MODULE_SYSTEM
        1:  413:  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))
        -:  414:  {
    #####:  415:    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);
    #####:  416:    module_p->u.compiled_code_p = bytecode_data_p;
        -:  417:
    #####:  418:    JERRY_CONTEXT (module_current_p) = NULL;
        -:  419:
    #####:  420:    return ecma_make_object_value ((ecma_object_t *) module_p);
        -:  421:  }
        -:  422:#endif /* JERRY_MODULE_SYSTEM */
        -:  423:
        1:  424:  if (JERRY_UNLIKELY (options_p != NULL && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))
        -:  425:  {
    #####:  426:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -:  427:
        -:  428:#if JERRY_BUILTIN_REALMS
    #####:  429:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));
        -:  430:#endif /* JERRY_BUILTIN_REALMS */
        -:  431:
    #####:  432:    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);
    #####:  433:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  434:    ecma_bytecode_deref (bytecode_data_p);
        -:  435:
    #####:  436:    return ecma_make_object_value (func_obj_p);
        -:  437:  }
        -:  438:
        1:  439:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  440:
        1:  441:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  442:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;
        1:  443:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);
        -:  444:
        1:  445:  return ecma_make_object_value (object_p);
        -:  446:} /* jerry_parse_common */
        -:  447:
        -:  448:#endif /* JERRY_PARSER */
        -:  449:
        -:  450:/**
        -:  451: * Parse a script, module, or function and create a compiled code using a character string
        -:  452: *
        -:  453: * @return function object value - if script was parsed successfully,
        -:  454: *         thrown error - otherwise
        -:  455: */
        -:  456:jerry_value_t
        1:  457:jerry_parse (const jerry_char_t *source_p, /**< script source */
        -:  458:             size_t source_size, /**< script source size */
        -:  459:             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  460:{
        -:  461:#if JERRY_PARSER
        1:  462:  parser_source_char_t source_char;
        1:  463:  source_char.source_p = source_p;
        1:  464:  source_char.source_size = source_size;
        -:  465:
        1:  466:  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);
        -:  467:#else /* !JERRY_PARSER */
        -:  468:  JERRY_UNUSED (source_p);
        -:  469:  JERRY_UNUSED (source_size);
        -:  470:  JERRY_UNUSED (options_p);
        -:  471:
        -:  472:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_PARSER_NOT_SUPPORTED));
        -:  473:#endif /* JERRY_PARSER */
        -:  474:} /* jerry_parse */
        -:  475:
        -:  476:/**
        -:  477: * Parse a script, module, or function and create a compiled code using a string value
        -:  478: *
        -:  479: * @return function object value - if script was parsed successfully,
        -:  480: *         thrown error - otherwise
        -:  481: */
        -:  482:jerry_value_t
    #####:  483:jerry_parse_value (const jerry_value_t source, /**< script source */
        -:  484:                   const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  485:{
        -:  486:#if JERRY_PARSER
    #####:  487:  if (!ecma_is_value_string (source))
        -:  488:  {
    #####:  489:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  490:  }
        -:  491:
    #####:  492:  return jerry_parse_common ((void *) &source, options_p, ECMA_PARSE_HAS_SOURCE_VALUE);
        -:  493:#else /* !JERRY_PARSER */
        -:  494:  JERRY_UNUSED (source);
        -:  495:  JERRY_UNUSED (options_p);
        -:  496:
        -:  497:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_PARSER_NOT_SUPPORTED));
        -:  498:#endif /* JERRY_PARSER */
        -:  499:} /* jerry_parse_value */
        -:  500:
        -:  501:/**
        -:  502: * Run a Script or Module created by jerry_parse.
        -:  503: *
        -:  504: * Note:
        -:  505: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  506: *
        -:  507: * @return result of bytecode - if run was successful
        -:  508: *         thrown error - otherwise
        -:  509: */
        -:  510:jerry_value_t
        1:  511:jerry_run (const jerry_value_t script) /**< script or module to run */
        -:  512:{
        -:  513:  jerry_assert_api_enabled ();
        -:  514:
        1:  515:  if (!ecma_is_value_object (script))
        -:  516:  {
    #####:  517:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  518:  }
        -:  519:
        1:  520:  ecma_object_t *object_p = ecma_get_object_from_value (script);
        -:  521:
        1:  522:  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))
        -:  523:  {
    #####:  524:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  525:  }
        -:  526:
        1:  527:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  528:
        -:  529:  const ecma_compiled_code_t *bytecode_data_p;
        1:  530:  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  531:
        1:  532:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);
        -:  533:
        1:  534:  return jerry_return (vm_run_global (bytecode_data_p, object_p));
        -:  535:} /* jerry_run */
        -:  536:
        -:  537:/**
        -:  538: * Perform eval
        -:  539: *
        -:  540: * Note:
        -:  541: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  542: *
        -:  543: * @return result of eval, may be error value.
        -:  544: */
        -:  545:jerry_value_t
    #####:  546:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  547:            size_t source_size, /**< length of source code */
        -:  548:            uint32_t flags) /**< jerry_parse_opts_t flags */
        -:  549:{
        -:  550:  jerry_assert_api_enabled ();
        -:  551:
    #####:  552:  uint32_t allowed_parse_options = JERRY_PARSE_STRICT_MODE;
        -:  553:
    #####:  554:  if ((flags & ~allowed_parse_options) != 0)
        -:  555:  {
    #####:  556:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  557:  }
        -:  558:
    #####:  559:  parser_source_char_t source_char;
    #####:  560:  source_char.source_p = source_p;
    #####:  561:  source_char.source_size = source_size;
        -:  562:
    #####:  563:  return jerry_return (ecma_op_eval_chars_buffer ((void *) &source_char, flags));
        -:  564:} /* jerry_eval */
        -:  565:
        -:  566:/**
        -:  567: * Link modules to their dependencies. The dependencies are resolved by a user callback.
        -:  568: *
        -:  569: * Note:
        -:  570: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  571: *
        -:  572: * @return true - if linking is successful, error - otherwise
        -:  573: */
        -:  574:jerry_value_t
    #####:  575:jerry_module_link (const jerry_value_t module, /**< root module */
        -:  576:                   jerry_module_resolve_cb_t callback, /**< resolve module callback, uses
        -:  577:                                                        *   jerry_port_module_resolve when NULL is passed */
        -:  578:                   void *user_p) /**< pointer passed to the resolve callback */
        -:  579:{
        -:  580:  jerry_assert_api_enabled ();
        -:  581:
        -:  582:#if JERRY_MODULE_SYSTEM
    #####:  583:  if (callback == NULL)
        -:  584:  {
    #####:  585:    callback = jerry_port_module_resolve;
        -:  586:  }
        -:  587:
    #####:  588:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  589:
    #####:  590:  if (module_p == NULL)
        -:  591:  {
    #####:  592:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  593:  }
        -:  594:
    #####:  595:  return jerry_return (ecma_module_link (module_p, callback, user_p));
        -:  596:#else /* !JERRY_MODULE_SYSTEM */
        -:  597:  JERRY_UNUSED (module);
        -:  598:  JERRY_UNUSED (callback);
        -:  599:  JERRY_UNUSED (user_p);
        -:  600:
    #####:  601:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  602:#endif /* JERRY_MODULE_SYSTEM */
        -:  603:} /* jerry_module_link */
        -:  604:
        -:  605:/**
        -:  606: * Evaluate a module and its dependencies. The module must be in linked state.
        -:  607: *
        -:  608: * Note:
        -:  609: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  610: *
        -:  611: * @return result of module bytecode execution - if evaluation was successful
        -:  612: *         error - otherwise
        -:  613: */
        -:  614:jerry_value_t
    #####:  615:jerry_module_evaluate (const jerry_value_t module) /**< root module */
        -:  616:{
        -:  617:  jerry_assert_api_enabled ();
        -:  618:
        -:  619:#if JERRY_MODULE_SYSTEM
    #####:  620:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  621:
    #####:  622:  if (module_p == NULL)
        -:  623:  {
    #####:  624:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  625:  }
        -:  626:
    #####:  627:  if (module_p->header.u.cls.u1.module_state != JERRY_MODULE_STATE_LINKED)
        -:  628:  {
    #####:  629:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_MUST_BE_IN_LINKED_STATE));
        -:  630:  }
        -:  631:
    #####:  632:  return jerry_return (ecma_module_evaluate (module_p));
        -:  633:#else /* !JERRY_MODULE_SYSTEM */
        -:  634:  JERRY_UNUSED (module);
        -:  635:
    #####:  636:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  637:#endif /* JERRY_MODULE_SYSTEM */
        -:  638:} /* jerry_module_evaluate */
        -:  639:
        -:  640:/**
        -:  641: * Returns the current status of a module
        -:  642: *
        -:  643: * @return current status - if module is a module,
        -:  644: *         JERRY_MODULE_STATE_INVALID - otherwise
        -:  645: */
        -:  646:jerry_module_state_t
    #####:  647:jerry_module_state (const jerry_value_t module) /**< module object */
        -:  648:{
        -:  649:  jerry_assert_api_enabled ();
        -:  650:
        -:  651:#if JERRY_MODULE_SYSTEM
    #####:  652:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  653:
    #####:  654:  if (module_p == NULL)
        -:  655:  {
    #####:  656:    return JERRY_MODULE_STATE_INVALID;
        -:  657:  }
        -:  658:
    #####:  659:  return (jerry_module_state_t) module_p->header.u.cls.u1.module_state;
        -:  660:#else /* !JERRY_MODULE_SYSTEM */
        -:  661:  JERRY_UNUSED (module);
        -:  662:
    #####:  663:  return JERRY_MODULE_STATE_INVALID;
        -:  664:#endif /* JERRY_MODULE_SYSTEM */
        -:  665:} /* jerry_module_state */
        -:  666:
        -:  667:/**
        -:  668: * Sets a callback which is called after a module state is changed to linked, evaluated, or error.
        -:  669: */
        -:  670:void
    #####:  671:jerry_module_on_state_changed (jerry_module_state_changed_cb_t callback, /**< callback */
        -:  672:                               void *user_p) /**< pointer passed to the callback */
        -:  673:{
        -:  674:  jerry_assert_api_enabled ();
        -:  675:
        -:  676:#if JERRY_MODULE_SYSTEM
    #####:  677:  JERRY_CONTEXT (module_state_changed_callback_p) = callback;
    #####:  678:  JERRY_CONTEXT (module_state_changed_callback_user_p) = user_p;
        -:  679:#else /* !JERRY_MODULE_SYSTEM */
        -:  680:  JERRY_UNUSED (callback);
        -:  681:  JERRY_UNUSED (user_p);
        -:  682:#endif /* JERRY_MODULE_SYSTEM */
    #####:  683:} /* jerry_module_on_state_changed */
        -:  684:
        -:  685:/**
        -:  686: * Sets a callback which is called when an import.meta expression of a module is evaluated the first time.
        -:  687: */
        -:  688:void
    #####:  689:jerry_module_on_import_meta (jerry_module_import_meta_cb_t callback, /**< callback */
        -:  690:                             void *user_p) /**< pointer passed to the callback */
        -:  691:{
        -:  692:  jerry_assert_api_enabled ();
        -:  693:
        -:  694:#if JERRY_MODULE_SYSTEM
    #####:  695:  JERRY_CONTEXT (module_import_meta_callback_p) = callback;
    #####:  696:  JERRY_CONTEXT (module_import_meta_callback_user_p) = user_p;
        -:  697:#else /* !JERRY_MODULE_SYSTEM */
        -:  698:  JERRY_UNUSED (callback);
        -:  699:  JERRY_UNUSED (user_p);
        -:  700:#endif /* JERRY_MODULE_SYSTEM */
    #####:  701:} /* jerry_module_on_import_meta */
        -:  702:
        -:  703:/**
        -:  704: * Returns the number of import/export requests of a module
        -:  705: *
        -:  706: * @return number of import/export requests of a module
        -:  707: */
        -:  708:size_t
    #####:  709:jerry_module_request_count (const jerry_value_t module) /**< module */
        -:  710:{
        -:  711:  jerry_assert_api_enabled ();
        -:  712:
        -:  713:#if JERRY_MODULE_SYSTEM
    #####:  714:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  715:
    #####:  716:  if (module_p == NULL)
        -:  717:  {
    #####:  718:    return 0;
        -:  719:  }
        -:  720:
    #####:  721:  size_t number_of_requests = 0;
        -:  722:
    #####:  723:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  724:
    #####:  725:  while (node_p != NULL)
        -:  726:  {
    #####:  727:    number_of_requests++;
    #####:  728:    node_p = node_p->next_p;
        -:  729:  }
        -:  730:
    #####:  731:  return number_of_requests;
        -:  732:#else /* !JERRY_MODULE_SYSTEM */
        -:  733:  JERRY_UNUSED (module);
        -:  734:
    #####:  735:  return 0;
        -:  736:#endif /* JERRY_MODULE_SYSTEM */
        -:  737:} /* jerry_module_request_count */
        -:  738:
        -:  739:/**
        -:  740: * Returns the module request specified by the request_index argument
        -:  741: *
        -:  742: * Note:
        -:  743: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  744: *
        -:  745: * @return string - if the request has not been resolved yet,
        -:  746: *         module object - if the request has been resolved successfully,
        -:  747: *         error - otherwise
        -:  748: */
        -:  749:jerry_value_t
    #####:  750:jerry_module_request (const jerry_value_t module, /**< module */
        -:  751:                      size_t request_index) /**< request index */
        -:  752:{
        -:  753:  jerry_assert_api_enabled ();
        -:  754:
        -:  755:#if JERRY_MODULE_SYSTEM
    #####:  756:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  757:
    #####:  758:  if (module_p == NULL)
        -:  759:  {
    #####:  760:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  761:  }
        -:  762:
    #####:  763:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  764:
    #####:  765:  while (node_p != NULL)
        -:  766:  {
    #####:  767:    if (request_index == 0)
        -:  768:    {
    #####:  769:      return ecma_copy_value (node_p->u.path_or_module);
        -:  770:    }
        -:  771:
    #####:  772:    --request_index;
    #####:  773:    node_p = node_p->next_p;
        -:  774:  }
        -:  775:
    #####:  776:  return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_REQUEST_IS_NOT_AVAILABLE));
        -:  777:#else /* !JERRY_MODULE_SYSTEM */
        -:  778:  JERRY_UNUSED (module);
        -:  779:  JERRY_UNUSED (request_index);
        -:  780:
    #####:  781:  return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  782:#endif /* JERRY_MODULE_SYSTEM */
        -:  783:} /* jerry_module_request */
        -:  784:
        -:  785:/**
        -:  786: * Returns the namespace object of a module
        -:  787: *
        -:  788: * Note:
        -:  789: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  790: *
        -:  791: * @return object - if namespace object is available,
        -:  792: *         error - otherwise
        -:  793: */
        -:  794:jerry_value_t
    #####:  795:jerry_module_namespace (const jerry_value_t module) /**< module */
        -:  796:{
        -:  797:  jerry_assert_api_enabled ();
        -:  798:
        -:  799:#if JERRY_MODULE_SYSTEM
    #####:  800:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  801:
    #####:  802:  if (module_p == NULL)
        -:  803:  {
    #####:  804:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  805:  }
        -:  806:
    #####:  807:  if (module_p->header.u.cls.u1.module_state < JERRY_MODULE_STATE_LINKED
    #####:  808:      || module_p->header.u.cls.u1.module_state > JERRY_MODULE_STATE_EVALUATED)
        -:  809:  {
    #####:  810:    return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_NAMESPACE_OBJECT_IS_NOT_AVAILABLE));
        -:  811:  }
        -:  812:
    #####:  813:  JERRY_ASSERT (module_p->namespace_object_p != NULL);
        -:  814:
    #####:  815:  ecma_ref_object (module_p->namespace_object_p);
    #####:  816:  return ecma_make_object_value (module_p->namespace_object_p);
        -:  817:#else /* !JERRY_MODULE_SYSTEM */
        -:  818:  JERRY_UNUSED (module);
        -:  819:
    #####:  820:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  821:#endif /* JERRY_MODULE_SYSTEM */
        -:  822:} /* jerry_module_namespace */
        -:  823:
        -:  824:/**
        -:  825: * Sets the callback which is called when dynamic imports are resolved
        -:  826: */
        -:  827:void
    #####:  828:jerry_module_on_import (jerry_module_import_cb_t callback_p, /**< callback which handles
        -:  829:                                                              *   dynamic import calls */
        -:  830:                        void *user_p) /**< user pointer passed to the callback */
        -:  831:{
        -:  832:  jerry_assert_api_enabled ();
        -:  833:
        -:  834:#if JERRY_MODULE_SYSTEM
    #####:  835:  JERRY_CONTEXT (module_import_callback_p) = callback_p;
    #####:  836:  JERRY_CONTEXT (module_import_callback_user_p) = user_p;
        -:  837:#else /* !JERRY_MODULE_SYSTEM */
        -:  838:  JERRY_UNUSED (callback_p);
        -:  839:  JERRY_UNUSED (user_p);
        -:  840:#endif /* JERRY_MODULE_SYSTEM */
    #####:  841:} /* jerry_module_on_import */
        -:  842:
        -:  843:/**
        -:  844: * Creates a native module with a list of exports. The initial state of the module is linked.
        -:  845: *
        -:  846: * Note:
        -:  847: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  848: *
        -:  849: * @return native module - if the module is successfully created,
        -:  850: *         error - otherwise
        -:  851: */
        -:  852:jerry_value_t
    #####:  853:jerry_native_module (jerry_native_module_evaluate_cb_t callback, /**< evaluation callback for
        -:  854:                                                                  *   native modules */
        -:  855:                     const jerry_value_t *const exports_p, /**< list of the exported bindings of the module,
        -:  856:                                                            *   must be valid string identifiers */
        -:  857:                     size_t export_count) /**< number of exports in the exports_p list */
        -:  858:{
        -:  859:  jerry_assert_api_enabled ();
        -:  860:
        -:  861:#if JERRY_MODULE_SYSTEM
    #####:  862:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
    #####:  863:  ecma_object_t *scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:  864:  ecma_module_names_t *local_exports_p = NULL;
        -:  865:
    #####:  866:  for (size_t i = 0; i < export_count; i++)
        -:  867:  {
    #####:  868:    if (!ecma_is_value_string (exports_p[i]))
        -:  869:    {
    #####:  870:      ecma_deref_object (scope_p);
    #####:  871:      ecma_module_release_module_names (local_exports_p);
    #####:  872:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_EXPORTS_MUST_BE_STRING_VALUES));
        -:  873:    }
        -:  874:
    #####:  875:    ecma_string_t *name_str_p = ecma_get_string_from_value (exports_p[i]);
        -:  876:
    #####:  877:    bool valid_identifier = false;
        -:  878:
    #####:  879:    ECMA_STRING_TO_UTF8_STRING (name_str_p, name_start_p, name_size);
        -:  880:
    #####:  881:    if (name_size > 0)
        -:  882:    {
    #####:  883:      const lit_utf8_byte_t *name_p = name_start_p;
    #####:  884:      const lit_utf8_byte_t *name_end_p = name_start_p + name_size;
    #####:  885:      lit_code_point_t code_point;
        -:  886:
    #####:  887:      lit_utf8_size_t size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  888:
    #####:  889:      if (lit_code_point_is_identifier_start (code_point))
        -:  890:      {
    #####:  891:        name_p += size;
        -:  892:
    #####:  893:        valid_identifier = true;
        -:  894:
    #####:  895:        while (name_p < name_end_p)
        -:  896:        {
    #####:  897:          size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  898:
    #####:  899:          if (!lit_code_point_is_identifier_part (code_point))
        -:  900:          {
    #####:  901:            valid_identifier = false;
    #####:  902:            break;
        -:  903:          }
        -:  904:
    #####:  905:          name_p += size;
        -:  906:        }
        -:  907:      }
        -:  908:    }
        -:  909:
    #####:  910:    ECMA_FINALIZE_UTF8_STRING (name_start_p, name_size);
        -:  911:
    #####:  912:    if (!valid_identifier)
        -:  913:    {
    #####:  914:      ecma_deref_object (scope_p);
    #####:  915:      ecma_module_release_module_names (local_exports_p);
    #####:  916:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_EXPORTS_MUST_BE_VALID_IDENTIFIERS));
        -:  917:    }
        -:  918:
    #####:  919:    if (ecma_find_named_property (scope_p, name_str_p) != NULL)
        -:  920:    {
    #####:  921:      continue;
        -:  922:    }
        -:  923:
    #####:  924:    ecma_create_named_data_property (scope_p, name_str_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -:  925:
        -:  926:    ecma_module_names_t *new_export_p;
    #####:  927:    new_export_p = (ecma_module_names_t *) jmem_heap_alloc_block (sizeof (ecma_module_names_t));
        -:  928:
    #####:  929:    new_export_p->next_p = local_exports_p;
    #####:  930:    local_exports_p = new_export_p;
        -:  931:
    #####:  932:    ecma_ref_ecma_string (name_str_p);
    #####:  933:    new_export_p->imex_name_p = name_str_p;
        -:  934:
    #####:  935:    ecma_ref_ecma_string (name_str_p);
    #####:  936:    new_export_p->local_name_p = name_str_p;
        -:  937:  }
        -:  938:
    #####:  939:  ecma_module_t *module_p = ecma_module_create ();
        -:  940:
    #####:  941:  module_p->header.u.cls.u2.module_flags |= ECMA_MODULE_IS_NATIVE;
    #####:  942:  module_p->scope_p = scope_p;
    #####:  943:  module_p->local_exports_p = local_exports_p;
    #####:  944:  module_p->u.callback = callback;
        -:  945:
    #####:  946:  ecma_deref_object (scope_p);
        -:  947:
    #####:  948:  return ecma_make_object_value (&module_p->header.object);
        -:  949:
        -:  950:#else /* !JERRY_MODULE_SYSTEM */
        -:  951:  JERRY_UNUSED (callback);
        -:  952:  JERRY_UNUSED (exports_p);
        -:  953:  JERRY_UNUSED (export_count);
        -:  954:
    #####:  955:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  956:#endif /* JERRY_MODULE_SYSTEM */
        -:  957:} /* jerry_native_module */
        -:  958:
        -:  959:/**
        -:  960: * Gets the value of an export which belongs to a native module.
        -:  961: *
        -:  962: * Note:
        -:  963: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  964: *
        -:  965: * @return value of the export - if success
        -:  966: *         error - otherwise
        -:  967: */
        -:  968:jerry_value_t
    #####:  969:jerry_native_module_get (const jerry_value_t native_module, /**< a native module object */
        -:  970:                         const jerry_value_t export_name) /**< string identifier of the export */
        -:  971:{
        -:  972:  jerry_assert_api_enabled ();
        -:  973:
        -:  974:#if JERRY_MODULE_SYSTEM
    #####:  975:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module);
        -:  976:
    #####:  977:  if (module_p == NULL)
        -:  978:  {
    #####:  979:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  980:  }
        -:  981:
    #####:  982:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE) || !ecma_is_value_string (export_name))
        -:  983:  {
    #####:  984:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  985:  }
        -:  986:
    #####:  987:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p, ecma_get_string_from_value (export_name));
        -:  988:
    #####:  989:  if (property_p == NULL)
        -:  990:  {
    #####:  991:    return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_UNKNOWN_EXPORT));
        -:  992:  }
        -:  993:
    #####:  994:  return ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  995:#else /* !JERRY_MODULE_SYSTEM */
        -:  996:  JERRY_UNUSED (native_module);
        -:  997:  JERRY_UNUSED (export_name);
        -:  998:
    #####:  999:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -: 1000:#endif /* JERRY_MODULE_SYSTEM */
        -: 1001:} /* jerry_native_module_get */
        -: 1002:
        -: 1003:/**
        -: 1004: * Sets the value of an export which belongs to a native module.
        -: 1005: *
        -: 1006: * Note:
        -: 1007: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 1008: *
        -: 1009: * @return true value - if the operation was successful
        -: 1010: *         error - otherwise
        -: 1011: */
        -: 1012:jerry_value_t
    #####: 1013:jerry_native_module_set (jerry_value_t native_module, /**< a native module object */
        -: 1014:                         const jerry_value_t export_name, /**< string identifier of the export */
        -: 1015:                         const jerry_value_t value) /**< new value of the export */
        -: 1016:{
        -: 1017:  jerry_assert_api_enabled ();
        -: 1018:
        -: 1019:#if JERRY_MODULE_SYSTEM
    #####: 1020:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module);
        -: 1021:
    #####: 1022:  if (module_p == NULL)
        -: 1023:  {
    #####: 1024:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -: 1025:  }
        -: 1026:
    #####: 1027:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE) || !ecma_is_value_string (export_name)
    #####: 1028:      || ecma_is_value_exception (value))
        -: 1029:  {
    #####: 1030:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 1031:  }
        -: 1032:
    #####: 1033:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p, ecma_get_string_from_value (export_name));
        -: 1034:
    #####: 1035:  if (property_p == NULL)
        -: 1036:  {
    #####: 1037:    return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_UNKNOWN_EXPORT));
        -: 1038:  }
        -: 1039:
    #####: 1040:  ecma_named_data_property_assign_value (module_p->scope_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);
    #####: 1041:  return ECMA_VALUE_TRUE;
        -: 1042:#else /* !JERRY_MODULE_SYSTEM */
        -: 1043:  JERRY_UNUSED (native_module);
        -: 1044:  JERRY_UNUSED (export_name);
        -: 1045:  JERRY_UNUSED (value);
        -: 1046:
    #####: 1047:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -: 1048:#endif /* JERRY_MODULE_SYSTEM */
        -: 1049:} /* jerry_native_module_set */
        -: 1050:
        -: 1051:/**
        -: 1052: * Run enqueued microtasks created by Promise or AsyncFunction objects.
        -: 1053: * Tasks are executed until an exception is thrown or all tasks are executed.
        -: 1054: *
        -: 1055: * Note: returned value must be freed with jerry_value_free
        -: 1056: *
        -: 1057: * @return result of last executed job, possibly an exception.
        -: 1058: */
        -: 1059:jerry_value_t
    #####: 1060:jerry_run_jobs (void)
        -: 1061:{
        -: 1062:  jerry_assert_api_enabled ();
        -: 1063:
        -: 1064:#if JERRY_ESNEXT
    #####: 1065:  return jerry_return (ecma_process_all_enqueued_jobs ());
        -: 1066:#else /* !JERRY_ESNEXT */
    #####: 1067:  return ECMA_VALUE_UNDEFINED;
        -: 1068:#endif /* JERRY_ESNEXT */
        -: 1069:} /* jerry_run_jobs */
        -: 1070:
        -: 1071:/**
        -: 1072: * Get global object
        -: 1073: *
        -: 1074: * Note:
        -: 1075: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 1076: *
        -: 1077: * @return api value of global object
        -: 1078: */
        -: 1079:jerry_value_t
        5: 1080:jerry_current_realm (void)
        -: 1081:{
        -: 1082:  jerry_assert_api_enabled ();
        5: 1083:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        5: 1084:  ecma_ref_object (global_obj_p);
        5: 1085:  return ecma_make_object_value (global_obj_p);
        -: 1086:} /* jerry_current_realm */
        -: 1087:
        -: 1088:/**
        -: 1089: * Check if the specified value is an abort value.
        -: 1090: *
        -: 1091: * @return true  - if both the error and abort values are set,
        -: 1092: *         false - otherwise
        -: 1093: */
        -: 1094:bool
    #####: 1095:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -: 1096:{
        -: 1097:  jerry_assert_api_enabled ();
        -: 1098:
    #####: 1099:  if (!ecma_is_value_exception (value))
        -: 1100:  {
    #####: 1101:    return false;
        -: 1102:  }
        -: 1103:
    #####: 1104:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1105:
    #####: 1106:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_ABORT) != 0;
        -: 1107:} /* jerry_value_is_abort */
        -: 1108:
        -: 1109:/**
        -: 1110: * Check if the specified value is an array object value.
        -: 1111: *
        -: 1112: * @return true  - if the specified value is an array object,
        -: 1113: *         false - otherwise
        -: 1114: */
        -: 1115:bool
    #####: 1116:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -: 1117:{
        -: 1118:  jerry_assert_api_enabled ();
        -: 1119:
    #####: 1120:  return (ecma_is_value_object (value)
    #####: 1121:          && ecma_get_object_base_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1122:} /* jerry_value_is_array */
        -: 1123:
        -: 1124:/**
        -: 1125: * Check if the specified value is boolean.
        -: 1126: *
        -: 1127: * @return true  - if the specified value is boolean,
        -: 1128: *         false - otherwise
        -: 1129: */
        -: 1130:bool
    #####: 1131:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -: 1132:{
        -: 1133:  jerry_assert_api_enabled ();
        -: 1134:
    #####: 1135:  return ecma_is_value_boolean (value);
        -: 1136:} /* jerry_value_is_boolean */
        -: 1137:
        -: 1138:/**
        -: 1139: * Check if the specified value is true.
        -: 1140: *
        -: 1141: * @return true  - if the specified value is true
        -: 1142: *         false - otherwise
        -: 1143: */
        -: 1144:bool
    #####: 1145:jerry_value_is_true (const jerry_value_t value) /**< api value */
        -: 1146:{
        -: 1147:  jerry_assert_api_enabled ();
        -: 1148:
    #####: 1149:  return ecma_is_value_true (value);
        -: 1150:} /* jerry_value_is_true */
        -: 1151:
        -: 1152:/**
        -: 1153: * Check if the specified value is false.
        -: 1154: *
        -: 1155: * @return true  - if the specified value is false
        -: 1156: *         false - otherwise
        -: 1157: */
        -: 1158:bool
    #####: 1159:jerry_value_is_false (const jerry_value_t value) /**< api value */
        -: 1160:{
        -: 1161:  jerry_assert_api_enabled ();
        -: 1162:
    #####: 1163:  return ecma_is_value_false (value);
        -: 1164:} /* jerry_value_is_false */
        -: 1165:
        -: 1166:/**
        -: 1167: * Check if the specified value is a constructor function object value.
        -: 1168: *
        -: 1169: * @return true - if the specified value is a function value that implements [[Construct]],
        -: 1170: *         false - otherwise
        -: 1171: */
        -: 1172:bool
    #####: 1173:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -: 1174:{
        -: 1175:  jerry_assert_api_enabled ();
        -: 1176:
    #####: 1177:  return ecma_is_constructor (value);
        -: 1178:} /* jerry_value_is_constructor */
        -: 1179:
        -: 1180:/**
        -: 1181: * Check if the specified value is an error or abort value.
        -: 1182: *
        -: 1183: * @return true  - if the specified value is an error value,
        -: 1184: *         false - otherwise
        -: 1185: */
        -: 1186:bool
        6: 1187:jerry_value_is_exception (const jerry_value_t value) /**< api value */
        -: 1188:{
        -: 1189:  jerry_assert_api_enabled ();
        -: 1190:
        6: 1191:  return ecma_is_value_exception (value);
        -: 1192:} /* jerry_value_is_exception */
        -: 1193:
        -: 1194:/**
        -: 1195: * Check if the specified value is a function object value.
        -: 1196: *
        -: 1197: * @return true - if the specified value is callable,
        -: 1198: *         false - otherwise
        -: 1199: */
        -: 1200:bool
    #####: 1201:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -: 1202:{
        -: 1203:  jerry_assert_api_enabled ();
        -: 1204:
    #####: 1205:  return ecma_op_is_callable (value);
        -: 1206:} /* jerry_value_is_function */
        -: 1207:
        -: 1208:/**
        -: 1209: * Check if the specified value is an async function object value.
        -: 1210: *
        -: 1211: * @return true - if the specified value is an async function,
        -: 1212: *         false - otherwise
        -: 1213: */
        -: 1214:bool
    #####: 1215:jerry_value_is_async_function (const jerry_value_t value) /**< api value */
        -: 1216:{
        -: 1217:  jerry_assert_api_enabled ();
        -: 1218:
        -: 1219:#if JERRY_ESNEXT
    #####: 1220:  if (ecma_is_value_object (value))
        -: 1221:  {
    #####: 1222:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1223:
    #####: 1224:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1225:    {
        -: 1226:      const ecma_compiled_code_t *bytecode_data_p;
    #####: 1227:      bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);
    #####: 1228:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -: 1229:
    #####: 1230:      return (type == CBC_FUNCTION_ASYNC || type == CBC_FUNCTION_ASYNC_ARROW || type == CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1231:    }
        -: 1232:  }
        -: 1233:#else /* !JERRY_ESNEXT */
        -: 1234:  JERRY_UNUSED (value);
        -: 1235:#endif /* JERRY_ESNEXT */
        -: 1236:
    #####: 1237:  return false;
        -: 1238:} /* jerry_value_is_async_function */
        -: 1239:
        -: 1240:/**
        -: 1241: * Check if the specified value is number.
        -: 1242: *
        -: 1243: * @return true  - if the specified value is number,
        -: 1244: *         false - otherwise
        -: 1245: */
        -: 1246:bool
    #####: 1247:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -: 1248:{
        -: 1249:  jerry_assert_api_enabled ();
        -: 1250:
    #####: 1251:  return ecma_is_value_number (value);
        -: 1252:} /* jerry_value_is_number */
        -: 1253:
        -: 1254:/**
        -: 1255: * Check if the specified value is null.
        -: 1256: *
        -: 1257: * @return true  - if the specified value is null,
        -: 1258: *         false - otherwise
        -: 1259: */
        -: 1260:bool
    #####: 1261:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -: 1262:{
        -: 1263:  jerry_assert_api_enabled ();
        -: 1264:
    #####: 1265:  return ecma_is_value_null (value);
        -: 1266:} /* jerry_value_is_null */
        -: 1267:
        -: 1268:/**
        -: 1269: * Check if the specified value is object.
        -: 1270: *
        -: 1271: * @return true  - if the specified value is object,
        -: 1272: *         false - otherwise
        -: 1273: */
        -: 1274:bool
    #####: 1275:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -: 1276:{
        -: 1277:  jerry_assert_api_enabled ();
        -: 1278:
    #####: 1279:  return ecma_is_value_object (value);
        -: 1280:} /* jerry_value_is_object */
        -: 1281:
        -: 1282:/**
        -: 1283: * Check if the specified value is promise.
        -: 1284: *
        -: 1285: * @return true  - if the specified value is promise,
        -: 1286: *         false - otherwise
        -: 1287: */
        -: 1288:bool
    #####: 1289:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -: 1290:{
        -: 1291:  jerry_assert_api_enabled ();
        -: 1292:#if JERRY_ESNEXT
    #####: 1293:  return (ecma_is_value_object (value) && ecma_is_promise (ecma_get_object_from_value (value)));
        -: 1294:#else /* !JERRY_ESNEXT */
        -: 1295:  JERRY_UNUSED (value);
    #####: 1296:  return false;
        -: 1297:#endif /* JERRY_ESNEXT */
        -: 1298:} /* jerry_value_is_promise */
        -: 1299:
        -: 1300:/**
        -: 1301: * Check if the specified value is a proxy object.
        -: 1302: *
        -: 1303: * @return true  - if the specified value is a proxy object,
        -: 1304: *         false - otherwise
        -: 1305: */
        -: 1306:bool
    #####: 1307:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -: 1308:{
        -: 1309:  jerry_assert_api_enabled ();
        -: 1310:#if JERRY_BUILTIN_PROXY
    #####: 1311:  return (ecma_is_value_object (value) && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -: 1312:#else /* !JERRY_BUILTIN_PROXY */
        -: 1313:  JERRY_UNUSED (value);
    #####: 1314:  return false;
        -: 1315:#endif /* JERRY_BUILTIN_PROXY */
        -: 1316:} /* jerry_value_is_proxy */
        -: 1317:
        -: 1318:/**
        -: 1319: * Check if the specified value is string.
        -: 1320: *
        -: 1321: * @return true  - if the specified value is string,
        -: 1322: *         false - otherwise
        -: 1323: */
        -: 1324:bool
    #####: 1325:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -: 1326:{
        -: 1327:  jerry_assert_api_enabled ();
        -: 1328:
    #####: 1329:  return ecma_is_value_string (value);
        -: 1330:} /* jerry_value_is_string */
        -: 1331:
        -: 1332:/**
        -: 1333: * Check if the specified value is symbol.
        -: 1334: *
        -: 1335: * @return true  - if the specified value is symbol,
        -: 1336: *         false - otherwise
        -: 1337: */
        -: 1338:bool
    #####: 1339:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -: 1340:{
        -: 1341:  jerry_assert_api_enabled ();
        -: 1342:
        -: 1343:#if JERRY_ESNEXT
    #####: 1344:  return ecma_is_value_symbol (value);
        -: 1345:#else /* !JERRY_ESNEXT */
        -: 1346:  JERRY_UNUSED (value);
    #####: 1347:  return false;
        -: 1348:#endif /* JERRY_ESNEXT */
        -: 1349:} /* jerry_value_is_symbol */
        -: 1350:
        -: 1351:/**
        -: 1352: * Check if the specified value is BigInt.
        -: 1353: *
        -: 1354: * @return true  - if the specified value is BigInt,
        -: 1355: *         false - otherwise
        -: 1356: */
        -: 1357:bool
    #####: 1358:jerry_value_is_bigint (const jerry_value_t value) /**< api value */
        -: 1359:{
        -: 1360:  jerry_assert_api_enabled ();
        -: 1361:
        -: 1362:#if JERRY_BUILTIN_BIGINT
    #####: 1363:  return ecma_is_value_bigint (value);
        -: 1364:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1365:  JERRY_UNUSED (value);
    #####: 1366:  return false;
        -: 1367:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1368:} /* jerry_value_is_bigint */
        -: 1369:
        -: 1370:/**
        -: 1371: * Check if the specified value is undefined.
        -: 1372: *
        -: 1373: * @return true  - if the specified value is undefined,
        -: 1374: *         false - otherwise
        -: 1375: */
        -: 1376:bool
    #####: 1377:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -: 1378:{
        -: 1379:  jerry_assert_api_enabled ();
        -: 1380:
    #####: 1381:  return ecma_is_value_undefined (value);
        -: 1382:} /* jerry_value_is_undefined */
        -: 1383:
        -: 1384:/**
        -: 1385: * Perform the base type of the JavaScript value.
        -: 1386: *
        -: 1387: * @return jerry_type_t value
        -: 1388: */
        -: 1389:jerry_type_t
    #####: 1390:jerry_value_type (const jerry_value_t value) /**< input value to check */
        -: 1391:{
        -: 1392:  jerry_assert_api_enabled ();
        -: 1393:
    #####: 1394:  if (ecma_is_value_exception (value))
        -: 1395:  {
    #####: 1396:    return JERRY_TYPE_EXCEPTION;
        -: 1397:  }
        -: 1398:
    #####: 1399:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -: 1400:
    #####: 1401:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -: 1402:
    #####: 1403:  switch (lit_id)
        -: 1404:  {
    #####: 1405:    case LIT_MAGIC_STRING_UNDEFINED:
        -: 1406:    {
    #####: 1407:      return JERRY_TYPE_UNDEFINED;
        -: 1408:    }
    #####: 1409:    case LIT_MAGIC_STRING_BOOLEAN:
        -: 1410:    {
    #####: 1411:      return JERRY_TYPE_BOOLEAN;
        -: 1412:    }
    #####: 1413:    case LIT_MAGIC_STRING_NUMBER:
        -: 1414:    {
    #####: 1415:      return JERRY_TYPE_NUMBER;
        -: 1416:    }
    #####: 1417:    case LIT_MAGIC_STRING_STRING:
        -: 1418:    {
    #####: 1419:      return JERRY_TYPE_STRING;
        -: 1420:    }
        -: 1421:#if JERRY_ESNEXT
    #####: 1422:    case LIT_MAGIC_STRING_SYMBOL:
        -: 1423:    {
    #####: 1424:      return JERRY_TYPE_SYMBOL;
        -: 1425:    }
        -: 1426:#endif /* JERRY_ESNEXT */
    #####: 1427:    case LIT_MAGIC_STRING_FUNCTION:
        -: 1428:    {
    #####: 1429:      return JERRY_TYPE_FUNCTION;
        -: 1430:    }
        -: 1431:#if JERRY_BUILTIN_BIGINT
    #####: 1432:    case LIT_MAGIC_STRING_BIGINT:
        -: 1433:    {
    #####: 1434:      return JERRY_TYPE_BIGINT;
        -: 1435:    }
        -: 1436:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 1437:    default:
        -: 1438:    {
    #####: 1439:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -: 1440:
        -: 1441:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -: 1442:       * Thus we'll do an extra check for 'null' here.
        -: 1443:       */
    #####: 1444:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -: 1445:    }
        -: 1446:  }
        -: 1447:} /* jerry_value_type */
        -: 1448:
        -: 1449:/**
        -: 1450: * Used by jerry_object_type to get the type of class objects
        -: 1451: */
        -: 1452:static const uint8_t jerry_class_object_type[] = {
        -: 1453:  /* These objects require custom property resolving. */
        -: 1454:  JERRY_OBJECT_TYPE_STRING, /**< type of ECMA_OBJECT_CLASS_STRING */
        -: 1455:  JERRY_OBJECT_TYPE_ARGUMENTS, /**< type of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 1456:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1457:  JERRY_OBJECT_TYPE_TYPEDARRAY, /**< type of ECMA_OBJECT_CLASS_TYPEDARRAY */
        -: 1458:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1459:#if JERRY_MODULE_SYSTEM
        -: 1460:  JERRY_OBJECT_TYPE_MODULE_NAMESPACE, /**< type of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 1461:#endif /* JERRY_MODULE_SYSTEM */
        -: 1462:
        -: 1463:/* These objects are marked by Garbage Collector. */
        -: 1464:#if JERRY_ESNEXT
        -: 1465:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_GENERATOR */
        -: 1466:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 1467:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 1468:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 1469:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 1470:#if JERRY_BUILTIN_REGEXP
        -: 1471:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 1472:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1473:#endif /* JERRY_ESNEXT */
        -: 1474:#if JERRY_MODULE_SYSTEM
        -: 1475:  JERRY_OBJECT_TYPE_MODULE, /**< type of ECMA_OBJECT_CLASS_MODULE */
        -: 1476:#endif /* JERRY_MODULE_SYSTEM */
        -: 1477:#if JERRY_ESNEXT
        -: 1478:  JERRY_OBJECT_TYPE_PROMISE, /**< type of ECMA_OBJECT_CLASS_PROMISE */
        -: 1479:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 1480:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_ASYNC_FROM_SYNC_ITERATOR */
        -: 1481:#endif /* JERRY_ESNEXT */
        -: 1482:#if JERRY_BUILTIN_DATAVIEW
        -: 1483:  JERRY_OBJECT_TYPE_DATAVIEW, /**< type of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 1484:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1485:#if JERRY_BUILTIN_CONTAINER
        -: 1486:  JERRY_OBJECT_TYPE_CONTAINER, /**< type of ECMA_OBJECT_CLASS_CONTAINER */
        -: 1487:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1488:
        -: 1489:  /* Normal objects. */
        -: 1490:  JERRY_OBJECT_TYPE_BOOLEAN, /**< type of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 1491:  JERRY_OBJECT_TYPE_NUMBER, /**< type of ECMA_OBJECT_CLASS_NUMBER */
        -: 1492:  JERRY_OBJECT_TYPE_ERROR, /**< type of ECMA_OBJECT_CLASS_ERROR */
        -: 1493:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 1494:#if JERRY_PARSER
        -: 1495:  JERRY_OBJECT_TYPE_SCRIPT, /**< type of ECMA_OBJECT_CLASS_SCRIPT */
        -: 1496:#endif /* JERRY_PARSER */
        -: 1497:#if JERRY_BUILTIN_DATE
        -: 1498:  JERRY_OBJECT_TYPE_DATE, /**< type of ECMA_OBJECT_CLASS_DATE */
        -: 1499:#endif /* JERRY_BUILTIN_DATE */
        -: 1500:#if JERRY_BUILTIN_REGEXP
        -: 1501:  JERRY_OBJECT_TYPE_REGEXP, /**< type of ECMA_OBJECT_CLASS_REGEXP */
        -: 1502:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1503:#if JERRY_ESNEXT
        -: 1504:  JERRY_OBJECT_TYPE_SYMBOL, /**< type of ECMA_OBJECT_CLASS_SYMBOL */
        -: 1505:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 1506:#endif /* JERRY_ESNEXT */
        -: 1507:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1508:  JERRY_OBJECT_TYPE_ARRAYBUFFER, /**< type of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 1509:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1510:  JERRY_OBJECT_TYPE_SHARED_ARRAY_BUFFER, /**< type of ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER */
        -: 1511:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1512:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1513:#if JERRY_BUILTIN_BIGINT
        -: 1514:  JERRY_OBJECT_TYPE_BIGINT, /**< type of ECMA_OBJECT_CLASS_BIGINT */
        -: 1515:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1516:#if JERRY_BUILTIN_WEAKREF
        -: 1517:  JERRY_OBJECT_TYPE_WEAKREF, /**< type of ECMA_OBJECT_CLASS_WEAKREF */
        -: 1518:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1519:};
        -: 1520:
        -: 1521:JERRY_STATIC_ASSERT (sizeof (jerry_class_object_type) == ECMA_OBJECT_CLASS__MAX,
        -: 1522:                     jerry_class_object_type_must_have_object_class_max_elements);
        -: 1523:
        -: 1524:/**
        -: 1525: * Get the object type of the given value
        -: 1526: *
        -: 1527: * @return JERRY_OBJECT_TYPE_NONE - if the given value is not an object
        -: 1528: *         jerry_object_type_t value - otherwise
        -: 1529: */
        -: 1530:jerry_object_type_t
    #####: 1531:jerry_object_type (const jerry_value_t value) /**< input value to check */
        -: 1532:{
        -: 1533:  jerry_assert_api_enabled ();
        -: 1534:
    #####: 1535:  if (!ecma_is_value_object (value))
        -: 1536:  {
    #####: 1537:    return JERRY_OBJECT_TYPE_NONE;
        -: 1538:  }
        -: 1539:
    #####: 1540:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1541:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1542:
    #####: 1543:  switch (ecma_get_object_type (obj_p))
        -: 1544:  {
    #####: 1545:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1546:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1547:    {
    #####: 1548:      JERRY_ASSERT (ext_obj_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 1549:      return jerry_class_object_type[ext_obj_p->u.cls.type];
        -: 1550:    }
    #####: 1551:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1552:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1553:    {
    #####: 1554:      return JERRY_OBJECT_TYPE_ARRAY;
        -: 1555:    }
        -: 1556:#if JERRY_ESNEXT
    #####: 1557:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1558:    {
    #####: 1559:      return JERRY_OBJECT_TYPE_PROXY;
        -: 1560:    }
        -: 1561:#endif /* JERRY_ESNEXT */
    #####: 1562:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1563:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1564:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1565:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1566:    {
    #####: 1567:      return JERRY_OBJECT_TYPE_FUNCTION;
        -: 1568:    }
    #####: 1569:    default:
        -: 1570:    {
    #####: 1571:      break;
        -: 1572:    }
        -: 1573:  }
        -: 1574:
    #####: 1575:  return JERRY_OBJECT_TYPE_GENERIC;
        -: 1576:} /* jerry_object_type */
        -: 1577:
        -: 1578:/**
        -: 1579: * Get the function type of the given value
        -: 1580: *
        -: 1581: * @return JERRY_FUNCTION_TYPE_NONE - if the given value is not a function object
        -: 1582: *         jerry_function_type_t value - otherwise
        -: 1583: */
        -: 1584:jerry_function_type_t
    #####: 1585:jerry_function_type (const jerry_value_t value) /**< input value to check */
        -: 1586:{
        -: 1587:  jerry_assert_api_enabled ();
        -: 1588:
    #####: 1589:  if (ecma_is_value_object (value))
        -: 1590:  {
    #####: 1591:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1592:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1593:
    #####: 1594:    switch (ecma_get_object_type (obj_p))
        -: 1595:    {
    #####: 1596:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1597:      {
    #####: 1598:        return JERRY_FUNCTION_TYPE_BOUND;
        -: 1599:      }
    #####: 1600:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1601:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1602:      {
    #####: 1603:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1604:      }
    #####: 1605:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1606:      {
    #####: 1607:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_obj_p);
        -: 1608:
    #####: 1609:        switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))
        -: 1610:        {
        -: 1611:#if JERRY_ESNEXT
    #####: 1612:          case CBC_FUNCTION_ARROW:
        -: 1613:          case CBC_FUNCTION_ASYNC_ARROW:
        -: 1614:          {
    #####: 1615:            return JERRY_FUNCTION_TYPE_ARROW;
        -: 1616:          }
    #####: 1617:          case CBC_FUNCTION_GENERATOR:
        -: 1618:          case CBC_FUNCTION_ASYNC_GENERATOR:
        -: 1619:          {
    #####: 1620:            return JERRY_FUNCTION_TYPE_GENERATOR;
        -: 1621:          }
        -: 1622:#endif /* JERRY_ESNEXT */
    #####: 1623:          case CBC_FUNCTION_ACCESSOR:
        -: 1624:          {
    #####: 1625:            return JERRY_FUNCTION_TYPE_ACCESSOR;
        -: 1626:          }
    #####: 1627:          default:
        -: 1628:          {
    #####: 1629:            break;
        -: 1630:          }
        -: 1631:        }
    #####: 1632:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1633:      }
    #####: 1634:      default:
        -: 1635:      {
    #####: 1636:        break;
        -: 1637:      }
        -: 1638:    }
    #####: 1639:  }
        -: 1640:
    #####: 1641:  return JERRY_FUNCTION_TYPE_NONE;
        -: 1642:} /* jerry_function_type */
        -: 1643:
        -: 1644:/**
        -: 1645: * Get the itearator type of the given value
        -: 1646: *
        -: 1647: * @return JERRY_ITERATOR_TYPE_NONE - if the given value is not an iterator object
        -: 1648: *         jerry_iterator_type_t value - otherwise
        -: 1649: */
        -: 1650:jerry_iterator_type_t
    #####: 1651:jerry_iterator_type (const jerry_value_t value) /**< input value to check */
        -: 1652:{
        -: 1653:  jerry_assert_api_enabled ();
        -: 1654:
        -: 1655:#if JERRY_ESNEXT
    #####: 1656:  if (ecma_is_value_object (value))
        -: 1657:  {
    #####: 1658:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1659:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1660:
    #####: 1661:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 1662:    {
    #####: 1663:      switch (ext_obj_p->u.cls.type)
        -: 1664:      {
    #####: 1665:        case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1666:        {
    #####: 1667:          return JERRY_ITERATOR_TYPE_ARRAY;
        -: 1668:        }
        -: 1669:#if JERRY_BUILTIN_CONTAINER
    #####: 1670:        case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1671:        {
    #####: 1672:          return JERRY_ITERATOR_TYPE_SET;
        -: 1673:        }
    #####: 1674:        case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1675:        {
    #####: 1676:          return JERRY_ITERATOR_TYPE_MAP;
        -: 1677:        }
        -: 1678:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1679:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1680:        {
    #####: 1681:          return JERRY_ITERATOR_TYPE_STRING;
        -: 1682:        }
    #####: 1683:        default:
        -: 1684:        {
    #####: 1685:          break;
        -: 1686:        }
        -: 1687:      }
    #####: 1688:    }
        -: 1689:  }
        -: 1690:#else /* !JERRY_ESNEXT */
        -: 1691:  JERRY_UNUSED (value);
        -: 1692:#endif /* JERRY_ESNEXT */
        -: 1693:
    #####: 1694:  return JERRY_ITERATOR_TYPE_NONE;
        -: 1695:} /* jerry_iterator_type */
        -: 1696:
        -: 1697:/**
        -: 1698: * Check if the specified feature is enabled.
        -: 1699: *
        -: 1700: * @return true  - if the specified feature is enabled,
        -: 1701: *         false - otherwise
        -: 1702: */
        -: 1703:bool
    #####: 1704:jerry_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -: 1705:{
    #####: 1706:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -: 1707:
        -: 1708:  return (false
        -: 1709:#if JERRY_CPOINTER_32_BIT
        -: 1710:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -: 1711:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1712:#if JERRY_ERROR_MESSAGES
    #####: 1713:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -: 1714:#endif /* JERRY_ERROR_MESSAGES */
        -: 1715:#if JERRY_PARSER
    #####: 1716:          || feature == JERRY_FEATURE_JS_PARSER
        -: 1717:#endif /* JERRY_PARSER */
        -: 1718:#if JERRY_MEM_STATS
    #####: 1719:          || feature == JERRY_FEATURE_HEAP_STATS
        -: 1720:#endif /* JERRY_MEM_STATS */
        -: 1721:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1722:          || feature == JERRY_FEATURE_PARSER_DUMP
        -: 1723:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1724:#if JERRY_REGEXP_DUMP_BYTE_CODE
        -: 1725:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -: 1726:#endif /* JERRY_REGEXP_DUMP_BYTE_CODE */
        -: 1727:#if JERRY_SNAPSHOT_SAVE
    #####: 1728:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -: 1729:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1730:#if JERRY_SNAPSHOT_EXEC
    #####: 1731:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -: 1732:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1733:#if JERRY_DEBUGGER
        -: 1734:          || feature == JERRY_FEATURE_DEBUGGER
        -: 1735:#endif /* JERRY_DEBUGGER */
        -: 1736:#if JERRY_VM_HALT
    #####: 1737:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -: 1738:#endif /* JERRY_VM_HALT */
        -: 1739:#if JERRY_VM_THROW
        -: 1740:          || feature == JERRY_FEATURE_VM_THROW
        -: 1741:#endif /* JERRY_VM_THROW */
        -: 1742:#if JERRY_BUILTIN_JSON
    #####: 1743:          || feature == JERRY_FEATURE_JSON
        -: 1744:#endif /* JERRY_BUILTIN_JSON */
        -: 1745:#if JERRY_ESNEXT
    #####: 1746:          || feature == JERRY_FEATURE_PROMISE || feature == JERRY_FEATURE_SYMBOL
        -: 1747:#endif /* JERRY_ESNEXT */
        -: 1748:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1749:          || feature == JERRY_FEATURE_TYPEDARRAY
        -: 1750:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1751:#if JERRY_BUILTIN_DATAVIEW
    #####: 1752:          || feature == JERRY_FEATURE_DATAVIEW
        -: 1753:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1754:#if JERRY_BUILTIN_PROXY
    #####: 1755:          || feature == JERRY_FEATURE_PROXY
        -: 1756:#endif /* JERRY_BUILTIN_PROXY */
        -: 1757:#if JERRY_BUILTIN_DATE
    #####: 1758:          || feature == JERRY_FEATURE_DATE
        -: 1759:#endif /* JERRY_BUILTIN_DATE */
        -: 1760:#if JERRY_BUILTIN_REGEXP
    #####: 1761:          || feature == JERRY_FEATURE_REGEXP
        -: 1762:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1763:#if JERRY_LINE_INFO
    #####: 1764:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1765:#endif /* JERRY_LINE_INFO */
        -: 1766:#if JERRY_LOGGING
    #####: 1767:          || feature == JERRY_FEATURE_LOGGING
        -: 1768:#endif /* JERRY_LOGGING */
        -: 1769:#if JERRY_BUILTIN_GLOBAL_THIS
    #####: 1770:          || feature == JERRY_FEATURE_GLOBAL_THIS
        -: 1771:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        -: 1772:#if JERRY_BUILTIN_CONTAINER
    #####: 1773:          || feature == JERRY_FEATURE_MAP || feature == JERRY_FEATURE_SET || feature == JERRY_FEATURE_WEAKMAP
    #####: 1774:          || feature == JERRY_FEATURE_WEAKSET
        -: 1775:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1776:#if JERRY_BUILTIN_WEAKREF
    #####: 1777:          || feature == JERRY_FEATURE_WEAKREF
        -: 1778:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1779:#if JERRY_BUILTIN_BIGINT
    #####: 1780:          || feature == JERRY_FEATURE_BIGINT
        -: 1781:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1782:#if JERRY_BUILTIN_REALMS
    #####: 1783:          || feature == JERRY_FEATURE_REALM
        -: 1784:#endif /* JERRY_BUILTIN_REALMS */
        -: 1785:#if JERRY_PROMISE_CALLBACK
    #####: 1786:          || feature == JERRY_FEATURE_PROMISE_CALLBACK
        -: 1787:#endif /* JERRY_PROMISE_CALLBACK */
        -: 1788:#if JERRY_MODULE_SYSTEM
    #####: 1789:          || feature == JERRY_FEATURE_MODULE
        -: 1790:#endif /* JERRY_MODULE_SYSTEM */
        -: 1791:#if JERRY_FUNCTION_TO_STRING
    #####: 1792:          || feature == JERRY_FEATURE_FUNCTION_TO_STRING
        -: 1793:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1794:  );
        -: 1795:} /* jerry_feature_enabled */
        -: 1796:
        -: 1797:/**
        -: 1798: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1799: *
        -: 1800: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1801: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1802: */
        -: 1803:jerry_value_t
    #####: 1804:jerry_binary_op (jerry_binary_op_t operation, /**< operation */
        -: 1805:                 const jerry_value_t lhs, /**< first operand */
        -: 1806:                 const jerry_value_t rhs) /**< second operand */
        -: 1807:{
        -: 1808:  jerry_assert_api_enabled ();
        -: 1809:
    #####: 1810:  if (ecma_is_value_exception (lhs) || ecma_is_value_exception (rhs))
        -: 1811:  {
    #####: 1812:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 1813:  }
        -: 1814:
    #####: 1815:  switch (operation)
        -: 1816:  {
    #####: 1817:    case JERRY_BIN_OP_EQUAL:
        -: 1818:    {
    #####: 1819:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1820:    }
    #####: 1821:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1822:    {
    #####: 1823:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1824:    }
    #####: 1825:    case JERRY_BIN_OP_LESS:
        -: 1826:    {
    #####: 1827:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1828:    }
    #####: 1829:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1830:    {
    #####: 1831:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1832:    }
    #####: 1833:    case JERRY_BIN_OP_GREATER:
        -: 1834:    {
    #####: 1835:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1836:    }
    #####: 1837:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1838:    {
    #####: 1839:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1840:    }
    #####: 1841:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1842:    {
    #####: 1843:      if (!ecma_is_value_object (lhs) || !ecma_op_is_callable (rhs))
        -: 1844:      {
    #####: 1845:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 1846:      }
        -: 1847:
    #####: 1848:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1849:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1850:    }
    #####: 1851:    case JERRY_BIN_OP_ADD:
        -: 1852:    {
    #####: 1853:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1854:    }
    #####: 1855:    case JERRY_BIN_OP_SUB:
        -: 1856:    case JERRY_BIN_OP_MUL:
        -: 1857:    case JERRY_BIN_OP_DIV:
        -: 1858:    case JERRY_BIN_OP_REM:
        -: 1859:    {
    #####: 1860:      return jerry_return (do_number_arithmetic (operation - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1861:    }
    #####: 1862:    default:
        -: 1863:    {
    #####: 1864:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_UNSUPPORTED_BINARY_OPERATION));
        -: 1865:    }
        -: 1866:  }
        -: 1867:} /* jerry_binary_op */
        -: 1868:
        -: 1869:/**
        -: 1870: * Create an abort value containing the argument value. If the second argument is true
        -: 1871: * the function will take ownership ofthe input value, otherwise the value will be copied.
        -: 1872: *
        -: 1873: * @return api abort value
        -: 1874: */
        -: 1875:jerry_value_t
    #####: 1876:jerry_throw_abort (jerry_value_t value, /**< api value */
        -: 1877:                   bool take_ownership) /**< release api value */
        -: 1878:{
        -: 1879:  jerry_assert_api_enabled ();
        -: 1880:
    #####: 1881:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 1882:  {
        -: 1883:    /* This is a rare case so it is optimized for
        -: 1884:     * binary size rather than performance. */
    #####: 1885:    if (jerry_value_is_abort (value))
        -: 1886:    {
    #####: 1887:      return take_ownership ? value : jerry_value_copy (value);
        -: 1888:    }
        -: 1889:
    #####: 1890:    value = jerry_exception_value (value, take_ownership);
    #####: 1891:    take_ownership = true;
        -: 1892:  }
        -: 1893:
    #####: 1894:  if (!take_ownership)
        -: 1895:  {
    #####: 1896:    value = ecma_copy_value (value);
        -: 1897:  }
        -: 1898:
    #####: 1899:  return ecma_create_exception (value, ECMA_ERROR_API_FLAG_ABORT);
        -: 1900:} /* jerry_throw_abort */
        -: 1901:
        -: 1902:/**
        -: 1903: * Create an exception value containing the argument value. If the second argument is true
        -: 1904: * the function will take ownership ofthe input value, otherwise the value will be copied.
        -: 1905: *
        -: 1906: * @return exception value
        -: 1907: */
        -: 1908:jerry_value_t
    #####: 1909:jerry_throw_value (jerry_value_t value, /**< value */
        -: 1910:                   bool take_ownership) /**< take ownership of the value */
        -: 1911:{
        -: 1912:  jerry_assert_api_enabled ();
        -: 1913:
    #####: 1914:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 1915:  {
        -: 1916:    /* This is a rare case so it is optimized for
        -: 1917:     * binary size rather than performance. */
    #####: 1918:    if (!jerry_value_is_abort (value))
        -: 1919:    {
    #####: 1920:      return take_ownership ? value : jerry_value_copy (value);
        -: 1921:    }
        -: 1922:
    #####: 1923:    value = jerry_exception_value (value, take_ownership);
    #####: 1924:    take_ownership = true;
        -: 1925:  }
        -: 1926:
    #####: 1927:  if (!take_ownership)
        -: 1928:  {
    #####: 1929:    value = ecma_copy_value (value);
        -: 1930:  }
        -: 1931:
    #####: 1932:  return ecma_create_exception (value, ECMA_ERROR_API_FLAG_NONE);
        -: 1933:} /* jerry_throw_value */
        -: 1934:
        -: 1935:/**
        -: 1936: * Get the value contained in an exception. If the second argument is true
        -: 1937: * it will release the argument exception value in the process.
        -: 1938: *
        -: 1939: * @return value in exception
        -: 1940: */
        -: 1941:jerry_value_t
    #####: 1942:jerry_exception_value (jerry_value_t value, /**< api value */
        -: 1943:                       bool free_exception) /**< release api value */
        -: 1944:{
        -: 1945:  jerry_assert_api_enabled ();
        -: 1946:
    #####: 1947:  if (!ecma_is_value_exception (value))
        -: 1948:  {
    #####: 1949:    return free_exception ? value : ecma_copy_value (value);
        -: 1950:  }
        -: 1951:
    #####: 1952:  jerry_value_t ret_val = jerry_value_copy (ecma_get_extended_primitive_from_value (value)->u.value);
        -: 1953:
    #####: 1954:  if (free_exception)
        -: 1955:  {
    #####: 1956:    jerry_value_free (value);
        -: 1957:  }
    #####: 1958:  return ret_val;
        -: 1959:} /* jerry_exception_value */
        -: 1960:
        -: 1961:/**
        -: 1962: * Set new decorator callback for Error objects. The decorator can
        -: 1963: * create or update any properties of the newly created Error object.
        -: 1964: */
        -: 1965:void
    #####: 1966:jerry_error_on_created (jerry_error_object_created_cb_t callback, /**< new callback */
        -: 1967:                        void *user_p) /**< user pointer passed to the callback */
        -: 1968:{
        -: 1969:  jerry_assert_api_enabled ();
        -: 1970:
    #####: 1971:  JERRY_CONTEXT (error_object_created_callback_p) = callback;
    #####: 1972:  JERRY_CONTEXT (error_object_created_callback_user_p) = user_p;
    #####: 1973:} /* jerry_error_on_created */
        -: 1974:
        -: 1975:/**
        -: 1976: * When JERRY_VM_THROW is enabled, the callback passed to this
        -: 1977: * function is called when an error is thrown in ECMAScript code.
        -: 1978: */
        -: 1979:void
    #####: 1980:jerry_on_throw (jerry_throw_cb_t callback, /**< callback which is called on throws */
        -: 1981:                void *user_p) /**< pointer passed to the function */
        -: 1982:{
        -: 1983:#if JERRY_VM_THROW
    #####: 1984:  JERRY_CONTEXT (vm_throw_callback_p) = callback;
    #####: 1985:  JERRY_CONTEXT (vm_throw_callback_user_p) = user_p;
        -: 1986:#else /* !JERRY_VM_THROW */
        -: 1987:  JERRY_UNUSED (callback);
        -: 1988:  JERRY_UNUSED (user_p);
        -: 1989:#endif /* JERRY_VM_THROW */
    #####: 1990:} /* jerry_on_throw */
        -: 1991:
        -: 1992:/**
        -: 1993: * Checks whether the callback set by jerry_on_throw captured the error
        -: 1994: *
        -: 1995: * @return true, if the vm throw callback captured the error
        -: 1996: *         false, otherwise
        -: 1997: */
        -: 1998:bool
    #####: 1999:jerry_exception_is_captured (const jerry_value_t value) /**< exception value */
        -: 2000:{
        -: 2001:  jerry_assert_api_enabled ();
        -: 2002:
        -: 2003:#if JERRY_VM_THROW
    #####: 2004:  if (!ecma_is_value_exception (value))
        -: 2005:  {
        -: 2006:    return false;
        -: 2007:  }
        -: 2008:
    #####: 2009:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2010:
    #####: 2011:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_THROW_CAPTURED) != 0;
        -: 2012:#else /* !JERRY_VM_THROW */
        -: 2013:  JERRY_UNUSED (value);
    #####: 2014:  return false;
        -: 2015:#endif /* JERRY_VM_THROW */
        -: 2016:} /* jerry_exception_is_captured */
        -: 2017:
        -: 2018:/**
        -: 2019: * Sets whether the callback set by jerry_on_throw should capture the exception or not
        -: 2020: */
        -: 2021:void
    #####: 2022:jerry_exception_allow_capture (jerry_value_t value, /**< exception value */
        -: 2023:                               bool should_capture) /**< callback should capture this error */
        -: 2024:{
        -: 2025:  jerry_assert_api_enabled ();
        -: 2026:
        -: 2027:#if JERRY_VM_THROW
    #####: 2028:  if (!ecma_is_value_exception (value))
        -: 2029:  {
        -: 2030:    return;
        -: 2031:  }
        -: 2032:
    #####: 2033:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2034:
    #####: 2035:  if (should_capture)
        -: 2036:  {
    #####: 2037:    error_ref_p->refs_and_type &= ~(uint32_t) ECMA_ERROR_API_FLAG_THROW_CAPTURED;
    #####: 2038:    return;
        -: 2039:  }
        -: 2040:
    #####: 2041:  error_ref_p->refs_and_type |= ECMA_ERROR_API_FLAG_THROW_CAPTURED;
        -: 2042:#else /* !JERRY_VM_THROW */
        -: 2043:  JERRY_UNUSED (value);
        -: 2044:  JERRY_UNUSED (should_capture);
        -: 2045:#endif /* JERRY_VM_THROW */
    #####: 2046:} /* jerry_exception_allow_capture */
        -: 2047:
        -: 2048:/**
        -: 2049: * Check if the given value is an Error object.
        -: 2050: *
        -: 2051: * @return true - if it is an Error object
        -: 2052: *         false - otherwise
        -: 2053: */
        -: 2054:bool
    #####: 2055:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -: 2056:{
    #####: 2057:  return ecma_is_value_object (value)
    #####: 2058:         && ecma_object_class_is (ecma_get_object_from_value (value), ECMA_OBJECT_CLASS_ERROR);
        -: 2059:} /* jerry_value_is_error */
        -: 2060:
        -: 2061:/**
        -: 2062: * Return the type of the Error object if possible.
        -: 2063: *
        -: 2064: * @return one of the jerry_error_t value as the type of the Error object
        -: 2065: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 2066: */
        -: 2067:jerry_error_t
    #####: 2068:jerry_error_type (jerry_value_t value) /**< api value */
        -: 2069:{
    #####: 2070:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2071:  {
    #####: 2072:    value = ecma_get_extended_primitive_from_value (value)->u.value;
        -: 2073:  }
        -: 2074:
    #####: 2075:  if (!ecma_is_value_object (value))
        -: 2076:  {
    #####: 2077:    return JERRY_ERROR_NONE;
        -: 2078:  }
        -: 2079:
    #####: 2080:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2081:  /* TODO(check if error object) */
    #####: 2082:  jerry_error_t error_type = ecma_get_error_type (object_p);
        -: 2083:
    #####: 2084:  return (jerry_error_t) error_type;
        -: 2085:} /* jerry_error_type */
        -: 2086:
        -: 2087:/**
        -: 2088: * Get number from the specified value as a double.
        -: 2089: *
        -: 2090: * @return stored number as double
        -: 2091: */
        -: 2092:double
    #####: 2093:jerry_value_as_number (const jerry_value_t value) /**< api value */
        -: 2094:{
        -: 2095:  jerry_assert_api_enabled ();
        -: 2096:
    #####: 2097:  if (!ecma_is_value_number (value))
        -: 2098:  {
    #####: 2099:    return 0;
        -: 2100:  }
        -: 2101:
    #####: 2102:  return (double) ecma_get_number_from_value (value);
        -: 2103:} /* jerry_value_as_number */
        -: 2104:
        -: 2105:/**
        -: 2106: * Call ToBoolean operation on the api value.
        -: 2107: *
        -: 2108: * @return true  - if the logical value is true
        -: 2109: *         false - otherwise
        -: 2110: */
        -: 2111:bool
    #####: 2112:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 2113:{
        -: 2114:  jerry_assert_api_enabled ();
        -: 2115:
    #####: 2116:  if (ecma_is_value_exception (value))
        -: 2117:  {
    #####: 2118:    return false;
        -: 2119:  }
        -: 2120:
    #####: 2121:  return ecma_op_to_boolean (value);
        -: 2122:} /* jerry_value_to_boolean */
        -: 2123:
        -: 2124:/**
        -: 2125: * Call ToNumber operation on the api value.
        -: 2126: *
        -: 2127: * Note:
        -: 2128: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2129: *
        -: 2130: * @return converted number value - if success
        -: 2131: *         thrown error - otherwise
        -: 2132: */
        -: 2133:jerry_value_t
    #####: 2134:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 2135:{
        -: 2136:  jerry_assert_api_enabled ();
        -: 2137:
    #####: 2138:  if (ecma_is_value_exception (value))
        -: 2139:  {
    #####: 2140:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2141:  }
        -: 2142:
    #####: 2143:  ecma_number_t num;
    #####: 2144:  ecma_value_t ret_value = ecma_op_to_number (value, &num);
        -: 2145:
    #####: 2146:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2147:  {
    #####: 2148:    return ecma_create_exception_from_context ();
        -: 2149:  }
        -: 2150:
    #####: 2151:  return ecma_make_number_value (num);
        -: 2152:} /* jerry_value_to_number */
        -: 2153:
        -: 2154:/**
        -: 2155: * Call ToObject operation on the api value.
        -: 2156: *
        -: 2157: * Note:
        -: 2158: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2159: *
        -: 2160: * @return converted object value - if success
        -: 2161: *         thrown error - otherwise
        -: 2162: */
        -: 2163:jerry_value_t
    #####: 2164:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 2165:{
        -: 2166:  jerry_assert_api_enabled ();
        -: 2167:
    #####: 2168:  if (ecma_is_value_exception (value))
        -: 2169:  {
    #####: 2170:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2171:  }
        -: 2172:
    #####: 2173:  return jerry_return (ecma_op_to_object (value));
        -: 2174:} /* jerry_value_to_object */
        -: 2175:
        -: 2176:/**
        -: 2177: * Call ToPrimitive operation on the api value.
        -: 2178: *
        -: 2179: * Note:
        -: 2180: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2181: *
        -: 2182: * @return converted primitive value - if success
        -: 2183: *         thrown error - otherwise
        -: 2184: */
        -: 2185:jerry_value_t
    #####: 2186:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 2187:{
        -: 2188:  jerry_assert_api_enabled ();
        -: 2189:
    #####: 2190:  if (ecma_is_value_exception (value))
        -: 2191:  {
    #####: 2192:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2193:  }
        -: 2194:
    #####: 2195:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 2196:} /* jerry_value_to_primitive */
        -: 2197:
        -: 2198:/**
        -: 2199: * Call the ToString ecma builtin operation on the api value.
        -: 2200: *
        -: 2201: * Note:
        -: 2202: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2203: *
        -: 2204: * @return converted string value - if success
        -: 2205: *         thrown error - otherwise
        -: 2206: */
        -: 2207:jerry_value_t
    #####: 2208:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 2209:{
        -: 2210:  jerry_assert_api_enabled ();
        -: 2211:
    #####: 2212:  if (ecma_is_value_exception (value))
        -: 2213:  {
    #####: 2214:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2215:  }
        -: 2216:
    #####: 2217:  ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 2218:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 2219:  {
    #####: 2220:    return ecma_create_exception_from_context ();
        -: 2221:  }
        -: 2222:
    #####: 2223:  return ecma_make_string_value (str_p);
        -: 2224:} /* jerry_value_to_string */
        -: 2225:
        -: 2226:/**
        -: 2227: * Call the BigInt constructor ecma builtin operation on the api value.
        -: 2228: *
        -: 2229: * Note:
        -: 2230: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2231: *
        -: 2232: * @return BigInt value - if success
        -: 2233: *         thrown error - otherwise
        -: 2234: */
        -: 2235:jerry_value_t
    #####: 2236:jerry_value_to_bigint (const jerry_value_t value) /**< input value */
        -: 2237:{
        -: 2238:  jerry_assert_api_enabled ();
        -: 2239:
        -: 2240:#if JERRY_BUILTIN_BIGINT
    #####: 2241:  if (ecma_is_value_exception (value))
        -: 2242:  {
    #####: 2243:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2244:  }
        -: 2245:
    #####: 2246:  return jerry_return (ecma_bigint_to_bigint (value, true));
        -: 2247:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2248:  JERRY_UNUSED (value);
    #####: 2249:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_BIGINT_NOT_SUPPORTED));
        -: 2250:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2251:} /* jerry_value_to_bigint */
        -: 2252:
        -: 2253:/**
        -: 2254: * Convert any number to integer number.
        -: 2255: *
        -: 2256: * Note:
        -: 2257: *      For non-number values 0 is returned.
        -: 2258: *
        -: 2259: * @return integer representation of the number.
        -: 2260: */
        -: 2261:double
    #####: 2262:jerry_value_as_integer (const jerry_value_t value) /**< input value */
        -: 2263:{
        -: 2264:  jerry_assert_api_enabled ();
        -: 2265:
    #####: 2266:  if (!ecma_is_value_number (value))
        -: 2267:  {
    #####: 2268:    return 0;
        -: 2269:  }
        -: 2270:
    #####: 2271:  double number = ecma_get_number_from_value (value);
        -: 2272:
    #####: 2273:  if (ecma_number_is_nan (number))
        -: 2274:  {
    #####: 2275:    return ECMA_NUMBER_ZERO;
        -: 2276:  }
        -: 2277:
    #####: 2278:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -: 2279:  {
    #####: 2280:    return number;
        -: 2281:  }
        -: 2282:
    #####: 2283:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -: 2284:
    #####: 2285:  return ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        -: 2286:} /* jerry_value_as_integer */
        -: 2287:
        -: 2288:/**
        -: 2289: * Convert any number to int32 number.
        -: 2290: *
        -: 2291: * Note:
        -: 2292: *      For non-number values 0 is returned.
        -: 2293: *
        -: 2294: * @return int32 representation of the number.
        -: 2295: */
        -: 2296:int32_t
    #####: 2297:jerry_value_as_int32 (const jerry_value_t value) /**< input value */
        -: 2298:{
        -: 2299:  jerry_assert_api_enabled ();
        -: 2300:
    #####: 2301:  if (!ecma_is_value_number (value))
        -: 2302:  {
    #####: 2303:    return 0;
        -: 2304:  }
        -: 2305:
    #####: 2306:  return ecma_number_to_int32 (ecma_get_number_from_value (value));
        -: 2307:} /* jerry_value_as_int32 */
        -: 2308:
        -: 2309:/**
        -: 2310: * Convert any number to uint32 number.
        -: 2311: *
        -: 2312: * Note:
        -: 2313: *      For non-number values 0 is returned.
        -: 2314: *
        -: 2315: * @return uint32 representation of the number.
        -: 2316: */
        -: 2317:uint32_t
    #####: 2318:jerry_value_as_uint32 (const jerry_value_t value) /**< input value */
        -: 2319:{
        -: 2320:  jerry_assert_api_enabled ();
        -: 2321:
    #####: 2322:  if (!ecma_is_value_number (value))
        -: 2323:  {
    #####: 2324:    return 0;
        -: 2325:  }
        -: 2326:
    #####: 2327:  return ecma_number_to_uint32 (ecma_get_number_from_value (value));
        -: 2328:} /* jerry_value_as_uint32 */
        -: 2329:
        -: 2330:/**
        -: 2331: * Take additional ownership over the argument value.
        -: 2332: * The value will be copied by reference when possible, changes made to the new value will be reflected
        -: 2333: * in the original.
        -: 2334: *
        -: 2335: * @return copied value
        -: 2336: */
        -: 2337:jerry_value_t
    #####: 2338:jerry_value_copy (const jerry_value_t value) /**< value */
        -: 2339:{
        -: 2340:  jerry_assert_api_enabled ();
        -: 2341:
    #####: 2342:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2343:  {
    #####: 2344:    ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
    #####: 2345:    return value;
        -: 2346:  }
        -: 2347:
    #####: 2348:  return ecma_copy_value (value);
        -: 2349:} /* jerry_value_copy */
        -: 2350:
        -: 2351:/**
        -: 2352: * Release ownership of the argument value
        -: 2353: */
        -: 2354:void
       21: 2355:jerry_value_free (jerry_value_t value) /**< value */
        -: 2356:{
        -: 2357:  jerry_assert_api_enabled ();
        -: 2358:
       21: 2359:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2360:  {
    #####: 2361:    ecma_deref_exception (ecma_get_extended_primitive_from_value (value));
    #####: 2362:    return;
        -: 2363:  }
        -: 2364:
       21: 2365:  ecma_free_value (value);
        -: 2366:} /* jerry_value_free */
        -: 2367:
        -: 2368:/**
        -: 2369: * Create an array object value
        -: 2370: *
        -: 2371: * Note:
        -: 2372: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2373: *
        -: 2374: * @return value of the constructed array object
        -: 2375: */
        -: 2376:jerry_value_t
    #####: 2377:jerry_array (jerry_length_t length) /**< length of array */
        -: 2378:{
        -: 2379:  jerry_assert_api_enabled ();
        -: 2380:
    #####: 2381:  ecma_object_t *array_p = ecma_op_new_array_object (length);
    #####: 2382:  return ecma_make_object_value (array_p);
        -: 2383:} /* jerry_array */
        -: 2384:
        -: 2385:/**
        -: 2386: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 2387: *
        -: 2388: * @return value of the created boolean
        -: 2389: */
        -: 2390:jerry_value_t
    #####: 2391:jerry_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 2392:{
        -: 2393:  jerry_assert_api_enabled ();
        -: 2394:
    #####: 2395:  return ecma_make_boolean_value (value);
        -: 2396:} /* jerry_boolean */
        -: 2397:
        -: 2398:/**
        -: 2399: * Create an Error object with the provided string value as the error message.
        -: 2400: * If the message value is not a string, the created error will not have a message property.
        -: 2401: *
        -: 2402: * @return Error object
        -: 2403: */
        -: 2404:jerry_value_t
    #####: 2405:jerry_error (jerry_error_t error_type, /**< type of error */
        -: 2406:             const jerry_value_t message) /**< message of the error */
        -: 2407:{
        -: 2408:  jerry_assert_api_enabled ();
        -: 2409:
    #####: 2410:  ecma_string_t *message_p = NULL;
    #####: 2411:  if (ecma_is_value_string (message))
        -: 2412:  {
    #####: 2413:    message_p = ecma_get_string_from_value (message);
        -: 2414:  }
        -: 2415:
    #####: 2416:  ecma_object_t *error_object_p = ecma_new_standard_error ((jerry_error_t) error_type, message_p);
        -: 2417:
    #####: 2418:  return ecma_make_object_value (error_object_p);
        -: 2419:} /* jerry_error */
        -: 2420:
        -: 2421:/**
        -: 2422: * Create an Error object with a zero-terminated string as a message. If the message string is NULL, the created error
        -: 2423: * will not have a message property.
        -: 2424: *
        -: 2425: * @return Error object
        -: 2426: */
        -: 2427:jerry_value_t
    #####: 2428:jerry_error_sz (jerry_error_t error_type, /**< type of error */
        -: 2429:                const char *message_p) /**< value of 'message' property
        -: 2430:                                        *   of constructed error object */
        -: 2431:{
    #####: 2432:  jerry_value_t message = ECMA_VALUE_UNDEFINED;
        -: 2433:
    #####: 2434:  if (message_p != NULL)
        -: 2435:  {
    #####: 2436:    message = jerry_string_sz (message_p);
        -: 2437:  }
        -: 2438:
    #####: 2439:  ecma_value_t error = jerry_error (error_type, message);
    #####: 2440:  ecma_free_value (message);
        -: 2441:
    #####: 2442:  return error;
        -: 2443:} /* jerry_error_sz */
        -: 2444:
        -: 2445:/**
        -: 2446: * Create an exception by constructing an Error object with the specified type and the provided string value as the
        -: 2447: * error message.  If the message value is not a string, the created error will not have a message property.
        -: 2448: *
        -: 2449: * @return exception value
        -: 2450: */
        -: 2451:jerry_value_t
    #####: 2452:jerry_throw (jerry_error_t error_type, /**< type of error */
        -: 2453:             const jerry_value_t message) /**< message value */
        -: 2454:{
    #####: 2455:  return jerry_throw_value (jerry_error (error_type, message), true);
        -: 2456:} /* jerry_throw */
        -: 2457:
        -: 2458:/**
        -: 2459: * Create an exception by constructing an Error object with the specified type and the provided zero-terminated ASCII
        -: 2460: * string as the error message.  If the message string is NULL, the created error will not have a message property.
        -: 2461: *
        -: 2462: * @return exception value
        -: 2463: */
        -: 2464:jerry_value_t
    #####: 2465:jerry_throw_sz (jerry_error_t error_type, /**< type of error */
        -: 2466:                const char *message_p) /**< value of 'message' property
        -: 2467:                                        *   of constructed error object */
        -: 2468:{
    #####: 2469:  return jerry_throw_value (jerry_error_sz (error_type, message_p), true);
        -: 2470:} /* jerry_throw_sz */
        -: 2471:
        -: 2472:/**
        -: 2473: * Create an external function object
        -: 2474: *
        -: 2475: * Note:
        -: 2476: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2477: *
        -: 2478: * @return value of the constructed function object
        -: 2479: */
        -: 2480:jerry_value_t
        5: 2481:jerry_function_external (jerry_external_handler_t handler) /**< native handler
        -: 2482:                                                            *   for the function */
        -: 2483:{
        -: 2484:  jerry_assert_api_enabled ();
        -: 2485:
        5: 2486:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler);
        5: 2487:  return ecma_make_object_value (func_obj_p);
        -: 2488:} /* jerry_function_external */
        -: 2489:
        -: 2490:/**
        -: 2491: * Creates a jerry_value_t representing a number value.
        -: 2492: *
        -: 2493: * Note:
        -: 2494: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2495: *
        -: 2496: * @return jerry_value_t created from the given double argument.
        -: 2497: */
        -: 2498:jerry_value_t
    #####: 2499:jerry_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 2500:{
        -: 2501:  jerry_assert_api_enabled ();
        -: 2502:
    #####: 2503:  return ecma_make_number_value ((ecma_number_t) value);
        -: 2504:} /* jerry_number */
        -: 2505:
        -: 2506:/**
        -: 2507: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 2508: *
        -: 2509: * Note:
        -: 2510: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2511: *
        -: 2512: * @return jerry_value_t representing an infinity value.
        -: 2513: */
        -: 2514:jerry_value_t
    #####: 2515:jerry_infinity (bool sign) /**< true for negative Infinity
        -: 2516:                            *   false for positive Infinity */
        -: 2517:{
        -: 2518:  jerry_assert_api_enabled ();
        -: 2519:
    #####: 2520:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 2521:} /* jerry_infinity */
        -: 2522:
        -: 2523:/**
        -: 2524: * Creates a jerry_value_t representing a not-a-number value.
        -: 2525: *
        -: 2526: * Note:
        -: 2527: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2528: *
        -: 2529: * @return jerry_value_t representing a not-a-number value.
        -: 2530: */
        -: 2531:jerry_value_t
    #####: 2532:jerry_nan (void)
        -: 2533:{
        -: 2534:  jerry_assert_api_enabled ();
        -: 2535:
    #####: 2536:  return ecma_make_nan_value ();
        -: 2537:} /* jerry_nan */
        -: 2538:
        -: 2539:/**
        -: 2540: * Creates a jerry_value_t representing an undefined value.
        -: 2541: *
        -: 2542: * @return value of undefined
        -: 2543: */
        -: 2544:jerry_value_t
    #####: 2545:jerry_undefined (void)
        -: 2546:{
        -: 2547:  jerry_assert_api_enabled ();
        -: 2548:
    #####: 2549:  return ECMA_VALUE_UNDEFINED;
        -: 2550:} /* jerry_undefined */
        -: 2551:
        -: 2552:/**
        -: 2553: * Creates and returns a jerry_value_t with type null object.
        -: 2554: *
        -: 2555: * @return jerry_value_t representing null
        -: 2556: */
        -: 2557:jerry_value_t
    #####: 2558:jerry_null (void)
        -: 2559:{
        -: 2560:  jerry_assert_api_enabled ();
        -: 2561:
    #####: 2562:  return ECMA_VALUE_NULL;
        -: 2563:} /* jerry_null */
        -: 2564:
        -: 2565:/**
        -: 2566: * Create new JavaScript object, like with new Object().
        -: 2567: *
        -: 2568: * Note:
        -: 2569: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2570: *
        -: 2571: * @return value of the created object
        -: 2572: */
        -: 2573:jerry_value_t
    #####: 2574:jerry_object (void)
        -: 2575:{
        -: 2576:  jerry_assert_api_enabled ();
        -: 2577:
    #####: 2578:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 2579:} /* jerry_object */
        -: 2580:
        -: 2581:/**
        -: 2582: * Create an empty Promise object which can be resolved/rejected later
        -: 2583: * by calling jerry_promise_resolve or jerry_promise_reject.
        -: 2584: *
        -: 2585: * Note:
        -: 2586: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2587: *
        -: 2588: * @return value of the created object
        -: 2589: */
        -: 2590:jerry_value_t
    #####: 2591:jerry_promise (void)
        -: 2592:{
        -: 2593:  jerry_assert_api_enabled ();
        -: 2594:
        -: 2595:#if JERRY_ESNEXT
    #####: 2596:  return jerry_return (ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL));
        -: 2597:#else /* !JERRY_ESNEXT */
    #####: 2598:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 2599:#endif /* JERRY_ESNEXT */
        -: 2600:} /* jerry_promise */
        -: 2601:
        -: 2602:/**
        -: 2603: * Create a new Proxy object with the given target and handler
        -: 2604: *
        -: 2605: * Note:
        -: 2606: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2607: *
        -: 2608: * @return value of the created Proxy object
        -: 2609: */
        -: 2610:jerry_value_t
    #####: 2611:jerry_proxy (const jerry_value_t target, /**< target argument */
        -: 2612:             const jerry_value_t handler) /**< handler argument */
        -: 2613:{
        -: 2614:  jerry_assert_api_enabled ();
        -: 2615:
    #####: 2616:  if (ecma_is_value_exception (target) || ecma_is_value_exception (handler))
        -: 2617:  {
    #####: 2618:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2619:  }
        -: 2620:
        -: 2621:#if JERRY_BUILTIN_PROXY
    #####: 2622:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, 0);
        -: 2623:
    #####: 2624:  if (proxy_p == NULL)
        -: 2625:  {
    #####: 2626:    return ecma_create_exception_from_context ();
        -: 2627:  }
        -: 2628:
    #####: 2629:  return ecma_make_object_value (proxy_p);
        -: 2630:#else /* !JERRY_BUILTIN_PROXY */
    #####: 2631:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROXY_IS_NOT_SUPPORTED));
        -: 2632:#endif /* JERRY_BUILTIN_PROXY */
        -: 2633:} /* jerry_proxy */
        -: 2634:
        -: 2635:#if JERRY_BUILTIN_PROXY
        -: 2636:
        -: 2637:JERRY_STATIC_ASSERT ((int) JERRY_PROXY_SKIP_RESULT_VALIDATION == (int) ECMA_PROXY_SKIP_RESULT_VALIDATION,
        -: 2638:                     jerry_and_ecma_proxy_skip_result_validation_must_be_equal);
        -: 2639:
        -: 2640:#endif /* JERRY_BUILTIN_PROXY */
        -: 2641:
        -: 2642:/**
        -: 2643: * Create a new Proxy object with the given target, handler, and special options
        -: 2644: *
        -: 2645: * Note:
        -: 2646: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2647: *
        -: 2648: * @return value of the created Proxy object
        -: 2649: */
        -: 2650:jerry_value_t
    #####: 2651:jerry_proxy_custom (const jerry_value_t target, /**< target argument */
        -: 2652:                    const jerry_value_t handler, /**< handler argument */
        -: 2653:                    uint32_t flags) /**< jerry_proxy_custom_behavior_t option bits */
        -: 2654:{
        -: 2655:  jerry_assert_api_enabled ();
        -: 2656:
    #####: 2657:  if (ecma_is_value_exception (target) || ecma_is_value_exception (handler))
        -: 2658:  {
    #####: 2659:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2660:  }
        -: 2661:
        -: 2662:#if JERRY_BUILTIN_PROXY
    #####: 2663:  flags &= JERRY_PROXY_SKIP_RESULT_VALIDATION;
        -: 2664:
    #####: 2665:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, flags);
        -: 2666:
    #####: 2667:  if (proxy_p == NULL)
        -: 2668:  {
    #####: 2669:    return ecma_create_exception_from_context ();
        -: 2670:  }
        -: 2671:
    #####: 2672:  return ecma_make_object_value (proxy_p);
        -: 2673:#else /* !JERRY_BUILTIN_PROXY */
        -: 2674:  JERRY_UNUSED (flags);
    #####: 2675:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROXY_IS_NOT_SUPPORTED));
        -: 2676:#endif /* JERRY_BUILTIN_PROXY */
        -: 2677:} /* jerry_proxy_custom */
        -: 2678:
        -: 2679:/**
        -: 2680: * Create string value from the input zero-terminated ASCII string.
        -: 2681: *
        -: 2682: * @return created string
        -: 2683: */
        -: 2684:jerry_value_t
        5: 2685:jerry_string_sz (const char *str_p) /**< pointer to string */
        -: 2686:{
        5: 2687:  const jerry_char_t *data_p = (const jerry_char_t *) str_p;
        5: 2688:  return jerry_string (data_p, lit_zt_utf8_string_size (data_p), JERRY_ENCODING_CESU8);
        -: 2689:} /* jerry_string_sz */
        -: 2690:
        -: 2691:/**
        -: 2692: * Create a string value from the input buffer using the specified encoding.
        -: 2693: * The content of the buffer is assumed to be valid in the specified encoding, it's the callers responsibility to
        -: 2694: * validate the input.
        -: 2695: *
        -: 2696: * See also: jerry_validate_string
        -: 2697: *
        -: 2698: * @return created string
        -: 2699: */
        -: 2700:jerry_value_t
        6: 2701:jerry_string (const jerry_char_t *buffer_p, /**< pointer to buffer */
        -: 2702:              jerry_size_t buffer_size, /**< buffer size */
        -: 2703:              jerry_encoding_t encoding) /**< buffer encoding */
        -: 2704:{
        -: 2705:  jerry_assert_api_enabled ();
        6: 2706:  ecma_string_t *ecma_str_p = NULL;
        6: 2707:  JERRY_ASSERT (jerry_validate_string (buffer_p, buffer_size, encoding));
        -: 2708:
        6: 2709:  switch (encoding)
        -: 2710:  {
        5: 2711:    case JERRY_ENCODING_CESU8:
        -: 2712:    {
        5: 2713:      ecma_str_p = ecma_new_ecma_string_from_utf8 (buffer_p, buffer_size);
        5: 2714:      break;
        -: 2715:    }
        1: 2716:    case JERRY_ENCODING_UTF8:
        -: 2717:    {
        1: 2718:      ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (buffer_p, buffer_size);
        1: 2719:      break;
        -: 2720:    }
    #####: 2721:    default:
        -: 2722:    {
    #####: 2723:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_ENCODING));
        -: 2724:    }
        -: 2725:  }
        -: 2726:
        6: 2727:  return ecma_make_string_value (ecma_str_p);
        -: 2728:} /* jerry_string */
        -: 2729:
        -: 2730:/**
        -: 2731: * Create external string from input zero-terminated ASCII string.
        -: 2732: *
        -: 2733: * @return created external string
        -: 2734: */
        -: 2735:jerry_value_t
    #####: 2736:jerry_string_external_sz (const char *str_p, /**< pointer to string */
        -: 2737:                          void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2738:{
    #####: 2739:  const jerry_char_t *data_p = (const jerry_char_t *) str_p;
    #####: 2740:  return jerry_string_external (data_p, lit_zt_utf8_string_size (data_p), user_p);
        -: 2741:} /* jerry_string_external_sz */
        -: 2742:
        -: 2743:/**
        -: 2744: * Create external string from a valid CESU-8 encoded string.
        -: 2745: * The content of the buffer is assumed be encoded correctly, it's the callers responsibility to
        -: 2746: * validate the input.
        -: 2747: *
        -: 2748: * See also: jerry_validate_string
        -: 2749: *
        -: 2750: * @return created external string
        -: 2751: */
        -: 2752:jerry_value_t
    #####: 2753:jerry_string_external (const jerry_char_t *buffer_p, /**< pointer to string */
        -: 2754:                       jerry_size_t buffer_size, /**< string size */
        -: 2755:                       void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2756:{
        -: 2757:  jerry_assert_api_enabled ();
        -: 2758:
    #####: 2759:  JERRY_ASSERT (jerry_validate_string (buffer_p, buffer_size, JERRY_ENCODING_CESU8));
    #####: 2760:  ecma_string_t *ecma_str_p = ecma_new_ecma_external_string_from_cesu8 (buffer_p, buffer_size, user_p);
    #####: 2761:  return ecma_make_string_value (ecma_str_p);
        -: 2762:} /* jerry_string_external_sz_sz */
        -: 2763:
        -: 2764:/**
        -: 2765: * Create symbol with a description value
        -: 2766: *
        -: 2767: * Note: The given argument is converted to string. This operation can throw an exception.
        -: 2768: *
        -: 2769: * @return created symbol,
        -: 2770: *         or thrown exception
        -: 2771: */
        -: 2772:jerry_value_t
    #####: 2773:jerry_symbol_with_description (const jerry_value_t value) /**< api value */
        -: 2774:{
        -: 2775:  jerry_assert_api_enabled ();
        -: 2776:
    #####: 2777:  if (ecma_is_value_exception (value))
        -: 2778:  {
    #####: 2779:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2780:  }
        -: 2781:
        -: 2782:#if JERRY_ESNEXT
    #####: 2783:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 2784:#else /* !JERRY_ESNEXT */
    #####: 2785:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 2786:#endif /* JERRY_ESNEXT */
        -: 2787:} /* jerry_symbol_with_description */
        -: 2788:
        -: 2789:/**
        -: 2790: * Create BigInt from a sequence of uint64 digits.
        -: 2791: *
        -: 2792: * Note: This operation can throw an exception.
        -: 2793: *
        -: 2794: * @return created bigint,
        -: 2795: *         or thrown exception
        -: 2796: */
        -: 2797:jerry_value_t
    #####: 2798:jerry_bigint (const uint64_t *digits_p, /**< BigInt digits (lowest digit first) */
        -: 2799:              uint32_t digit_count, /**< number of BigInt digits */
        -: 2800:              bool sign) /**< sign bit, true if the result should be negative */
        -: 2801:{
        -: 2802:  jerry_assert_api_enabled ();
        -: 2803:
        -: 2804:#if JERRY_BUILTIN_BIGINT
    #####: 2805:  return jerry_return (ecma_bigint_create_from_digits (digits_p, digit_count, sign));
        -: 2806:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2807:  JERRY_UNUSED (digits_p);
        -: 2808:  JERRY_UNUSED (digit_count);
        -: 2809:  JERRY_UNUSED (sign);
    #####: 2810:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_BIGINT_NOT_SUPPORTED));
        -: 2811:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2812:} /* jerry_bigint */
        -: 2813:
        -: 2814:/**
        -: 2815: * Creates a RegExp object with the given ASCII pattern and flags.
        -: 2816: *
        -: 2817: * @return value of the constructed RegExp object.
        -: 2818: */
        -: 2819:jerry_value_t
    #####: 2820:jerry_regexp_sz (const char *pattern_p, /**< RegExp pattern as zero-terminated ASCII string */
        -: 2821:                 uint16_t flags) /**< RegExp flags */
        -: 2822:{
        -: 2823:  jerry_assert_api_enabled ();
        -: 2824:
    #####: 2825:  jerry_value_t pattern = jerry_string_sz (pattern_p);
    #####: 2826:  jerry_value_t result = jerry_regexp (pattern, flags);
        -: 2827:
    #####: 2828:  jerry_value_free (pattern);
    #####: 2829:  return jerry_return (result);
        -: 2830:} /* jerry_regexp_sz */
        -: 2831:
        -: 2832:/**
        -: 2833: * Creates a RegExp object with the given pattern and flags.
        -: 2834: *
        -: 2835: * @return value of the constructed RegExp object.
        -: 2836: */
        -: 2837:jerry_value_t
    #####: 2838:jerry_regexp (const jerry_value_t pattern, /**< pattern string */
        -: 2839:              uint16_t flags) /**< RegExp flags */
        -: 2840:{
        -: 2841:  jerry_assert_api_enabled ();
        -: 2842:
        -: 2843:#if JERRY_BUILTIN_REGEXP
    #####: 2844:  if (!ecma_is_value_string (pattern))
        -: 2845:  {
    #####: 2846:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2847:  }
        -: 2848:
    #####: 2849:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 2850:
    #####: 2851:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 2852:  {
    #####: 2853:    return ecma_create_exception_from_context ();
        -: 2854:  }
        -: 2855:
    #####: 2856:  jerry_value_t result = ecma_op_create_regexp_with_flags (regexp_obj_p, pattern, flags);
        -: 2857:
    #####: 2858:  return jerry_return (result);
        -: 2859:
        -: 2860:#else /* !JERRY_BUILTIN_REGEXP */
        -: 2861:  JERRY_UNUSED (pattern);
        -: 2862:  JERRY_UNUSED (flags);
        -: 2863:
        -: 2864:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_REGEXP_IS_NOT_SUPPORTED));
        -: 2865:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2866:} /* jerry_regexp */
        -: 2867:
        -: 2868:/**
        -: 2869: * Creates a new realm (global object).
        -: 2870: *
        -: 2871: * @return new realm object
        -: 2872: */
        -: 2873:jerry_value_t
    #####: 2874:jerry_realm (void)
        -: 2875:{
        -: 2876:  jerry_assert_api_enabled ();
        -: 2877:
        -: 2878:#if JERRY_BUILTIN_REALMS
    #####: 2879:  ecma_global_object_t *global_object_p = ecma_builtin_create_global_object ();
    #####: 2880:  return ecma_make_object_value ((ecma_object_t *) global_object_p);
        -: 2881:#else /* !JERRY_BUILTIN_REALMS */
    #####: 2882:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_REALMS_ARE_DISABLED));
        -: 2883:#endif /* JERRY_BUILTIN_REALMS */
        -: 2884:} /* jerry_realm */
        -: 2885:
        -: 2886:/**
        -: 2887: * Get length of an array object
        -: 2888: *
        -: 2889: * Note:
        -: 2890: *      Returns 0, if the value parameter is not an array object.
        -: 2891: *
        -: 2892: * @return length of the given array
        -: 2893: */
        -: 2894:jerry_length_t
    #####: 2895:jerry_array_length (const jerry_value_t value) /**< api value */
        -: 2896:{
        -: 2897:  jerry_assert_api_enabled ();
        -: 2898:
    #####: 2899:  if (!jerry_value_is_object (value))
        -: 2900:  {
    #####: 2901:    return 0;
        -: 2902:  }
        -: 2903:
    #####: 2904:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2905:
    #####: 2906:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -: 2907:  {
    #####: 2908:    return ecma_array_get_length (object_p);
        -: 2909:  }
        -: 2910:
    #####: 2911:  return 0;
        -: 2912:} /* jerry_array_length */
        -: 2913:
        -: 2914:/**
        -: 2915: * Get the size of a string value in the specified encoding.
        -: 2916: *
        -: 2917: * @return number of bytes required by the string,
        -: 2918: *         0 - if value is not a string
        -: 2919: */
        -: 2920:jerry_size_t
    #####: 2921:jerry_string_size (const jerry_value_t value, /**< input string */
        -: 2922:                   jerry_encoding_t encoding) /**< encoding */
        -: 2923:{
        -: 2924:  jerry_assert_api_enabled ();
        -: 2925:
    #####: 2926:  if (!ecma_is_value_string (value))
        -: 2927:  {
    #####: 2928:    return 0;
        -: 2929:  }
        -: 2930:
    #####: 2931:  switch (encoding)
        -: 2932:  {
    #####: 2933:    case JERRY_ENCODING_CESU8:
        -: 2934:    {
    #####: 2935:      return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 2936:    }
    #####: 2937:    case JERRY_ENCODING_UTF8:
        -: 2938:    {
    #####: 2939:      return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 2940:    }
    #####: 2941:    default:
        -: 2942:    {
    #####: 2943:      return 0;
        -: 2944:    }
        -: 2945:  }
        -: 2946:} /* jerry_string_size */
        -: 2947:
        -: 2948:/**
        -: 2949: * Get length of a string value
        -: 2950: *
        -: 2951: * @return number of characters in the string
        -: 2952: *         0 - if value is not a string
        -: 2953: */
        -: 2954:jerry_length_t
    #####: 2955:jerry_string_length (const jerry_value_t value) /**< input string */
        -: 2956:{
        -: 2957:  jerry_assert_api_enabled ();
        -: 2958:
    #####: 2959:  if (!ecma_is_value_string (value))
        -: 2960:  {
    #####: 2961:    return 0;
        -: 2962:  }
        -: 2963:
    #####: 2964:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 2965:} /* jerry_string_length */
        -: 2966:
        -: 2967:/**
        -: 2968: * Copy the characters of a string into the specified buffer using the specified encoding.  The string is truncated to
        -: 2969: * fit the buffer. If the value is not a string, nothing will be copied to the buffer.
        -: 2970: *
        -: 2971: * @return number of bytes copied to the buffer
        -: 2972: */
        -: 2973:jerry_size_t
    #####: 2974:jerry_string_to_buffer (const jerry_value_t value, /**< input string value */
        -: 2975:                        jerry_encoding_t encoding, /**< output encoding */
        -: 2976:                        jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 2977:                        jerry_size_t buffer_size) /**< size of output buffer */
        -: 2978:{
        -: 2979:  jerry_assert_api_enabled ();
        -: 2980:
    #####: 2981:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 2982:  {
    #####: 2983:    return 0;
        -: 2984:  }
        -: 2985:
    #####: 2986:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 2987:
    #####: 2988:  return ecma_string_copy_to_buffer (str_p, (lit_utf8_byte_t *) buffer_p, buffer_size, encoding);
        -: 2989:} /* jerry_string_to_char_buffer */
        -: 2990:
        -: 2991:/**
        -: 2992: * Create a substring of the input string value.
        -: 2993: * Return an empty string if input value is not a string.
        -: 2994: *
        -: 2995: * @param value  the input string value
        -: 2996: * @param start  start position of the substring
        -: 2997: * @param end    end position of the substring
        -: 2998: *
        -: 2999: * @return created string
        -: 3000: */
        -: 3001:jerry_value_t
    #####: 3002:jerry_string_substr (const jerry_value_t value, jerry_length_t start, jerry_length_t end)
        -: 3003:{
    #####: 3004:  if (!ecma_is_value_string (value))
        -: 3005:  {
    #####: 3006:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 3007:  }
        -: 3008:
    #####: 3009:  return ecma_make_string_value (ecma_string_substr (ecma_get_string_from_value (value), start, end));
        -: 3010:} /* jerry_string_substr */
        -: 3011:
        -: 3012:/**
        -: 3013: * Iterate over the input string value in the specified encoding, visiting each byte of the encoded string once. If
        -: 3014: * the input value is not a string, the function will do nothing.
        -: 3015: *
        -: 3016: * @param value     the input string value
        -: 3017: * @param callback  callback function called for each byte of the encoded string.
        -: 3018: * @param encoding  the requested encoding for the string
        -: 3019: * @param user_p    User pointer passed to the callback function
        -: 3020: */
        -: 3021:void
    #####: 3022:jerry_string_iterate (const jerry_value_t value,
        -: 3023:                      jerry_encoding_t encoding,
        -: 3024:                      jerry_string_iterate_cb_t callback,
        -: 3025:                      void *user_p)
        -: 3026:{
    #####: 3027:  if (!ecma_is_value_string (value))
        -: 3028:  {
    #####: 3029:    return;
        -: 3030:  }
        -: 3031:
    #####: 3032:  ecma_string_t *str_p = ecma_get_string_from_value (value);
    #####: 3033:  ECMA_STRING_TO_UTF8_STRING (str_p, buffer_p, buffer_size);
        -: 3034:
    #####: 3035:  const lit_utf8_byte_t *current_p = buffer_p;
    #####: 3036:  const lit_utf8_byte_t *end_p = buffer_p + buffer_size;
        -: 3037:
    #####: 3038:  switch (encoding)
        -: 3039:  {
    #####: 3040:    case JERRY_ENCODING_UTF8:
        -: 3041:    {
    #####: 3042:      while (current_p < end_p)
        -: 3043:      {
    #####: 3044:        if (JERRY_UNLIKELY (*current_p >= LIT_UTF8_3_BYTE_MARKER))
        -: 3045:        {
    #####: 3046:          lit_code_point_t cp;
    #####: 3047:          lit_utf8_size_t read_size = lit_read_code_point_from_cesu8 (current_p, end_p, &cp);
        -: 3048:
    #####: 3049:          lit_utf8_byte_t bytes[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####: 3050:          lit_utf8_size_t encoded_size = lit_code_point_to_utf8 (cp, bytes);
        -: 3051:
    #####: 3052:          for (uint32_t i = 0; i < encoded_size; i++)
        -: 3053:          {
    #####: 3054:            callback (bytes[i], user_p);
        -: 3055:          }
        -: 3056:
    #####: 3057:          current_p += read_size;
    #####: 3058:          continue;
        -: 3059:        }
        -: 3060:
    #####: 3061:        callback (*current_p++, user_p);
        -: 3062:      }
        -: 3063:
    #####: 3064:      break;
        -: 3065:    }
    #####: 3066:    case JERRY_ENCODING_CESU8:
        -: 3067:    {
    #####: 3068:      while (current_p < end_p)
        -: 3069:      {
    #####: 3070:        callback (*current_p++, user_p);
        -: 3071:      }
        -: 3072:
    #####: 3073:      break;
        -: 3074:    }
    #####: 3075:    default:
        -: 3076:    {
    #####: 3077:      break;
        -: 3078:    }
        -: 3079:  }
    #####: 3080:  ECMA_FINALIZE_UTF8_STRING (buffer_p, buffer_size);
        -: 3081:} /* jerry_string_iterate */
        -: 3082:
        -: 3083:/**
        -: 3084: * Print char wrapper that casts the argument to an unsigned type
        -: 3085: *
        -: 3086: * @param byte    encoded byte value
        -: 3087: * @param user_p  user pointer
        -: 3088: */
        -: 3089:static void
    #####: 3090:jerry_print_char_wrapper (uint8_t byte, void *user_p)
        -: 3091:{
        -: 3092:  JERRY_UNUSED (user_p);
        -: 3093:  static const char *const null_str_p = "\\u0000";
        -: 3094:
    #####: 3095:  if (JERRY_UNLIKELY (byte == '\0'))
        -: 3096:  {
    #####: 3097:    const char *curr_p = null_str_p;
        -: 3098:
    #####: 3099:    while (*curr_p != '\0')
        -: 3100:    {
    #####: 3101:      jerry_port_print_char (*curr_p++);
        -: 3102:    }
        -: 3103:
    #####: 3104:    return;
        -: 3105:  }
        -: 3106:
    #####: 3107:  jerry_port_print_char ((char) byte);
        -: 3108:} /* jerry_print_char_wrapper */
        -: 3109:
        -: 3110:/**
        -: 3111: * Print the argument string in utf8 encoding using jerry_port_print_char.
        -: 3112: * If the argument is not a string, the function does nothing.
        -: 3113: *
        -: 3114: * @param value  the input string value
        -: 3115: */
        -: 3116:void
    #####: 3117:jerry_string_print (const jerry_value_t value)
        -: 3118:{
    #####: 3119:  jerry_string_iterate (value, JERRY_ENCODING_UTF8, &jerry_print_char_wrapper, NULL);
    #####: 3120:} /* jerry_string_print */
        -: 3121:
        -: 3122:/**
        -: 3123: * Sets the global callback which is called when an external string is freed.
        -: 3124: */
        -: 3125:void
    #####: 3126:jerry_string_external_on_free (jerry_external_string_free_cb_t callback) /**< free callback */
        -: 3127:{
    #####: 3128:  JERRY_CONTEXT (external_string_free_callback_p) = callback;
    #####: 3129:} /* jerry_string_external_on_free */
        -: 3130:
        -: 3131:/**
        -: 3132: * Returns the user pointer assigned to an external string.
        -: 3133: *
        -: 3134: * @return user pointer, if value is an external string
        -: 3135: *         NULL, otherwise
        -: 3136: */
        -: 3137:void *
    #####: 3138:jerry_string_user_ptr (const jerry_value_t value, /**< string value */
        -: 3139:                       bool *is_external) /**< [out] true - if value is an external string,
        -: 3140:                                           *         false - otherwise */
        -: 3141:{
    #####: 3142:  if (is_external != NULL)
        -: 3143:  {
    #####: 3144:    *is_external = false;
        -: 3145:  }
        -: 3146:
    #####: 3147:  if (!ecma_is_value_string (value))
        -: 3148:  {
    #####: 3149:    return NULL;
        -: 3150:  }
        -: 3151:
    #####: 3152:  ecma_string_t *string_p = ecma_get_string_from_value (value);
        -: 3153:
    #####: 3154:  if (ECMA_IS_DIRECT_STRING (string_p)
    #####: 3155:      || ECMA_STRING_GET_CONTAINER (string_p) != ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 3156:  {
    #####: 3157:    return NULL;
        -: 3158:  }
        -: 3159:
    #####: 3160:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 3161:
    #####: 3162:  if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -: 3163:  {
    #####: 3164:    return NULL;
        -: 3165:  }
        -: 3166:
    #####: 3167:  if (is_external != NULL)
        -: 3168:  {
    #####: 3169:    *is_external = true;
        -: 3170:  }
        -: 3171:
    #####: 3172:  return ((ecma_external_string_t *) string_p)->user_p;
        -: 3173:} /* jerry_string_user_ptr */
        -: 3174:
        -: 3175:/**
        -: 3176: * Checks whether the object or it's prototype objects have the given property.
        -: 3177: *
        -: 3178: * @return raised error - if the operation fail
        -: 3179: *         true/false API value  - depend on whether the property exists
        -: 3180: */
        -: 3181:jerry_value_t
    #####: 3182:jerry_object_has (const jerry_value_t object, /**< object value */
        -: 3183:                  const jerry_value_t key) /**< property name (string value) */
        -: 3184:{
        -: 3185:  jerry_assert_api_enabled ();
        -: 3186:
    #####: 3187:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3188:  {
    #####: 3189:    return ECMA_VALUE_FALSE;
        -: 3190:  }
        -: 3191:
    #####: 3192:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 3193:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
        -: 3194:
    #####: 3195:  return jerry_return (ecma_op_object_has_property (obj_p, prop_name_p));
        -: 3196:} /* jerry_object_has */
        -: 3197:
        -: 3198:/**
        -: 3199: * Checks whether the object has the given property.
        -: 3200: *
        -: 3201: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 3202: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 3203: */
        -: 3204:jerry_value_t
    #####: 3205:jerry_object_has_own (const jerry_value_t object, /**< object value */
        -: 3206:                      const jerry_value_t key) /**< property name (string value) */
        -: 3207:{
        -: 3208:  jerry_assert_api_enabled ();
        -: 3209:
    #####: 3210:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3211:  {
    #####: 3212:    return ECMA_VALUE_FALSE;
        -: 3213:  }
        -: 3214:
    #####: 3215:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 3216:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
        -: 3217:
        -: 3218:#if JERRY_BUILTIN_PROXY
    #####: 3219:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 3220:  {
    #####: 3221:    ecma_property_descriptor_t prop_desc;
        -: 3222:
    #####: 3223:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 3224:
    #####: 3225:    if (ecma_is_value_true (status))
        -: 3226:    {
    #####: 3227:      ecma_free_property_descriptor (&prop_desc);
        -: 3228:    }
        -: 3229:
    #####: 3230:    return jerry_return (status);
        -: 3231:  }
        -: 3232:#endif /* JERRY_BUILTIN_PROXY */
        -: 3233:
        -: 3234:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 3235:  return jerry_return (ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p));
        -: 3236:#else /* !JERRY_BUILTIN_TYPEDARRAY */
    #####: 3237:  return ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p);
        -: 3238:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 3239:} /* jerry_object_has_own */
        -: 3240:
        -: 3241:/**
        -: 3242: * Checks whether the object has the given internal property.
        -: 3243: *
        -: 3244: * @return true  - if the internal property exists
        -: 3245: *         false - otherwise
        -: 3246: */
        -: 3247:bool
    #####: 3248:jerry_object_has_internal (const jerry_value_t object, /**< object value */
        -: 3249:                           const jerry_value_t key) /**< property name value */
        -: 3250:{
        -: 3251:  jerry_assert_api_enabled ();
        -: 3252:
    #####: 3253:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3254:  {
    #####: 3255:    return false;
        -: 3256:  }
        -: 3257:
    #####: 3258:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3259:
    #####: 3260:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3261:
    #####: 3262:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3263:  {
    #####: 3264:    return false;
        -: 3265:  }
        -: 3266:
    #####: 3267:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3268:
    #####: 3269:  if (property_p == NULL)
        -: 3270:  {
    #####: 3271:    return false;
        -: 3272:  }
        -: 3273:
    #####: 3274:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3275:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3276:
    #####: 3277:  return property_p != NULL;
        -: 3278:} /* jerry_object_has_internal */
        -: 3279:
        -: 3280:/**
        -: 3281: * Delete a property from an object.
        -: 3282: *
        -: 3283: * @return boolean value - wether the property was deleted successfully
        -: 3284: *         exception - otherwise
        -: 3285: */
        -: 3286:jerry_value_t
    #####: 3287:jerry_object_delete (const jerry_value_t object, /**< object value */
        -: 3288:                     const jerry_value_t key) /**< property name (string value) */
        -: 3289:{
        -: 3290:  jerry_assert_api_enabled ();
        -: 3291:
    #####: 3292:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3293:  {
    #####: 3294:    return false;
        -: 3295:  }
        -: 3296:
    #####: 3297:  return ecma_op_object_delete (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key), false);
        -: 3298:} /* jerry_object_delete */
        -: 3299:
        -: 3300:/**
        -: 3301: * Delete indexed property from the specified object.
        -: 3302: *
        -: 3303: * @return boolean value - wether the property was deleted successfully
        -: 3304: *         false - otherwise
        -: 3305: */
        -: 3306:jerry_value_t
    #####: 3307:jerry_object_delete_index (const jerry_value_t object, /**< object value */
        -: 3308:                           uint32_t index) /**< index to be written */
        -: 3309:{
        -: 3310:  jerry_assert_api_enabled ();
        -: 3311:
    #####: 3312:  if (!ecma_is_value_object (object))
        -: 3313:  {
    #####: 3314:    return false;
        -: 3315:  }
        -: 3316:
    #####: 3317:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 3318:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (object), str_idx_p, false);
    #####: 3319:  ecma_deref_ecma_string (str_idx_p);
        -: 3320:
    #####: 3321:  return ret_value;
        -: 3322:} /* jerry_object_delete_index */
        -: 3323:
        -: 3324:/**
        -: 3325: * Delete an internal property from an object.
        -: 3326: *
        -: 3327: * @return true  - if property was deleted successfully
        -: 3328: *         false - otherwise
        -: 3329: */
        -: 3330:bool
    #####: 3331:jerry_object_delete_internal (const jerry_value_t object, /**< object value */
        -: 3332:                              const jerry_value_t key) /**< property name value */
        -: 3333:{
        -: 3334:  jerry_assert_api_enabled ();
        -: 3335:
    #####: 3336:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3337:  {
    #####: 3338:    return false;
        -: 3339:  }
        -: 3340:
    #####: 3341:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3342:
    #####: 3343:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3344:
    #####: 3345:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3346:  {
    #####: 3347:    return true;
        -: 3348:  }
        -: 3349:
    #####: 3350:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3351:
    #####: 3352:  if (property_p == NULL)
        -: 3353:  {
    #####: 3354:    return true;
        -: 3355:  }
        -: 3356:
    #####: 3357:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3358:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3359:
    #####: 3360:  if (property_p == NULL)
        -: 3361:  {
    #####: 3362:    return true;
        -: 3363:  }
        -: 3364:
    #####: 3365:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 3366:
    #####: 3367:  return true;
        -: 3368:} /* jerry_object_delete_internal */
        -: 3369:
        -: 3370:/**
        -: 3371: * Get value of a property to the specified object with the given name.
        -: 3372: *
        -: 3373: * Note:
        -: 3374: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3375: *
        -: 3376: * @return value of the property - if success
        -: 3377: *         value marked with error flag - otherwise
        -: 3378: */
        -: 3379:jerry_value_t
    #####: 3380:jerry_object_get (const jerry_value_t object, /**< object value */
        -: 3381:                  const jerry_value_t key) /**< property name (string value) */
        -: 3382:{
        -: 3383:  jerry_assert_api_enabled ();
        -: 3384:
    #####: 3385:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3386:  {
    #####: 3387:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3388:  }
        -: 3389:
    #####: 3390:  jerry_value_t ret_value =
    #####: 3391:    ecma_op_object_get (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key));
    #####: 3392:  return jerry_return (ret_value);
        -: 3393:} /* jerry_object_get */
        -: 3394:
        -: 3395:/**
        -: 3396: * Get value by an index from the specified object.
        -: 3397: *
        -: 3398: * Note:
        -: 3399: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3400: *
        -: 3401: * @return value of the property specified by the index - if success
        -: 3402: *         value marked with error flag - otherwise
        -: 3403: */
        -: 3404:jerry_value_t
    #####: 3405:jerry_object_get_index (const jerry_value_t object, /**< object value */
        -: 3406:                        uint32_t index) /**< index to be written */
        -: 3407:{
        -: 3408:  jerry_assert_api_enabled ();
        -: 3409:
    #####: 3410:  if (!ecma_is_value_object (object))
        -: 3411:  {
    #####: 3412:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3413:  }
        -: 3414:
    #####: 3415:  ecma_value_t ret_value = ecma_op_object_get_by_index (ecma_get_object_from_value (object), index);
        -: 3416:
    #####: 3417:  return jerry_return (ret_value);
        -: 3418:} /* jerry_object_get_index */
        -: 3419:
        -: 3420:/**
        -: 3421: * Get the own property value of an object with the given name.
        -: 3422: *
        -: 3423: * Note:
        -: 3424: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3425: *
        -: 3426: * @return value of the property - if success
        -: 3427: *         value marked with error flag - otherwise
        -: 3428: */
        -: 3429:jerry_value_t
    #####: 3430:jerry_object_find_own (const jerry_value_t object, /**< object value */
        -: 3431:                       const jerry_value_t key, /**< property name (string value) */
        -: 3432:                       const jerry_value_t receiver, /**< receiver object value */
        -: 3433:                       bool *found_p) /**< [out] true, if the property is found
        -: 3434:                                       *   or object is a Proxy object, false otherwise */
        -: 3435:{
        -: 3436:  jerry_assert_api_enabled ();
        -: 3437:
    #####: 3438:  if (found_p != NULL)
        -: 3439:  {
    #####: 3440:    *found_p = false;
        -: 3441:  }
        -: 3442:
    #####: 3443:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key) || !ecma_is_value_object (receiver))
        -: 3444:  {
    #####: 3445:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3446:  }
        -: 3447:
    #####: 3448:  ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####: 3449:  ecma_string_t *property_name_p = ecma_get_prop_name_from_value (key);
        -: 3450:
        -: 3451:#if JERRY_BUILTIN_PROXY
    #####: 3452:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 3453:  {
    #####: 3454:    if (found_p != NULL)
        -: 3455:    {
    #####: 3456:      *found_p = true;
        -: 3457:    }
        -: 3458:
    #####: 3459:    return jerry_return (ecma_proxy_object_get (object_p, property_name_p, receiver));
        -: 3460:  }
        -: 3461:#endif /* JERRY_BUILTIN_PROXY */
        -: 3462:
    #####: 3463:  ecma_value_t ret_value = ecma_op_object_find_own (receiver, object_p, property_name_p);
        -: 3464:
    #####: 3465:  if (ecma_is_value_found (ret_value))
        -: 3466:  {
    #####: 3467:    if (found_p != NULL)
        -: 3468:    {
    #####: 3469:      *found_p = true;
        -: 3470:    }
        -: 3471:
    #####: 3472:    return jerry_return (ret_value);
        -: 3473:  }
        -: 3474:
    #####: 3475:  return ECMA_VALUE_UNDEFINED;
        -: 3476:} /* jerry_object_find_own */
        -: 3477:
        -: 3478:/**
        -: 3479: * Get value of an internal property to the specified object with the given name.
        -: 3480: *
        -: 3481: * Note:
        -: 3482: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3483: *
        -: 3484: * @return value of the internal property - if the internal property exists
        -: 3485: *         undefined value - if the internal does not property exists
        -: 3486: *         value marked with error flag - otherwise
        -: 3487: */
        -: 3488:jerry_value_t
    #####: 3489:jerry_object_get_internal (const jerry_value_t object, /**< object value */
        -: 3490:                           const jerry_value_t key) /**< property name value */
        -: 3491:{
        -: 3492:  jerry_assert_api_enabled ();
        -: 3493:
    #####: 3494:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3495:  {
    #####: 3496:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3497:  }
        -: 3498:
    #####: 3499:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3500:
    #####: 3501:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3502:
    #####: 3503:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3504:  {
    #####: 3505:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3506:  }
        -: 3507:
    #####: 3508:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3509:
    #####: 3510:  if (property_p == NULL)
        -: 3511:  {
    #####: 3512:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3513:  }
        -: 3514:
    #####: 3515:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3516:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3517:
    #####: 3518:  if (property_p == NULL)
        -: 3519:  {
    #####: 3520:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3521:  }
        -: 3522:
    #####: 3523:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3524:} /* jerry_object_get_internal */
        -: 3525:
        -: 3526:/**
        -: 3527: * Set a property to the specified object with the given name.
        -: 3528: *
        -: 3529: * Note:
        -: 3530: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3531: *
        -: 3532: * @return true value - if the operation was successful
        -: 3533: *         value marked with error flag - otherwise
        -: 3534: */
        -: 3535:jerry_value_t
        5: 3536:jerry_object_set (const jerry_value_t object, /**< object value */
        -: 3537:                  const jerry_value_t key, /**< property name (string value) */
        -: 3538:                  const jerry_value_t value) /**< value to set */
        -: 3539:{
        -: 3540:  jerry_assert_api_enabled ();
        -: 3541:
        5: 3542:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3543:  {
    #####: 3544:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3545:  }
        -: 3546:
        5: 3547:  return jerry_return (
        -: 3548:    ecma_op_object_put (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key), value, true));
        -: 3549:} /* jerry_object_set */
        -: 3550:
        -: 3551:/**
        -: 3552: * Set indexed value in the specified object
        -: 3553: *
        -: 3554: * Note:
        -: 3555: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3556: *
        -: 3557: * @return true value - if the operation was successful
        -: 3558: *         value marked with error flag - otherwise
        -: 3559: */
        -: 3560:jerry_value_t
    #####: 3561:jerry_object_set_index (const jerry_value_t object, /**< object value */
        -: 3562:                        uint32_t index, /**< index to be written */
        -: 3563:                        const jerry_value_t value) /**< value to set */
        -: 3564:{
        -: 3565:  jerry_assert_api_enabled ();
        -: 3566:
    #####: 3567:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object))
        -: 3568:  {
    #####: 3569:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3570:  }
        -: 3571:
    #####: 3572:  ecma_value_t ret_value = ecma_op_object_put_by_index (ecma_get_object_from_value (object), index, value, true);
        -: 3573:
    #####: 3574:  return jerry_return (ret_value);
        -: 3575:} /* jerry_object_set_index */
        -: 3576:
        -: 3577:/**
        -: 3578: * Set an internal property to the specified object with the given name.
        -: 3579: *
        -: 3580: * Note:
        -: 3581: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 3582: *      - returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3583: *
        -: 3584: * @return true value - if the operation was successful
        -: 3585: *         value marked with error flag - otherwise
        -: 3586: */
        -: 3587:bool
    #####: 3588:jerry_object_set_internal (const jerry_value_t object, /**< object value */
        -: 3589:                           const jerry_value_t key, /**< property name value */
        -: 3590:                           const jerry_value_t value) /**< value to set */
        -: 3591:{
        -: 3592:  jerry_assert_api_enabled ();
        -: 3593:
    #####: 3594:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3595:  {
    #####: 3596:    return false;
        -: 3597:  }
        -: 3598:
    #####: 3599:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3600:
    #####: 3601:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3602:
    #####: 3603:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3604:  {
    #####: 3605:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3606:  }
        -: 3607:
    #####: 3608:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3609:  ecma_object_t *internal_object_p;
        -: 3610:
    #####: 3611:  if (property_p == NULL)
        -: 3612:  {
    #####: 3613:    ecma_property_value_t *value_p =
        -: 3614:      ecma_create_named_data_property (obj_p, internal_string_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
        -: 3615:
    #####: 3616:    internal_object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -: 3617:    {
    #####: 3618:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 3619:      container_p->u.cls.type = ECMA_OBJECT_CLASS_INTERNAL_OBJECT;
        -: 3620:    }
        -: 3621:
    #####: 3622:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 3623:    ecma_deref_object (internal_object_p);
        -: 3624:  }
        -: 3625:  else
        -: 3626:  {
    #####: 3627:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 3628:  }
        -: 3629:
    #####: 3630:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
    #####: 3631:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 3632:
    #####: 3633:  if (property_p == NULL)
        -: 3634:  {
    #####: 3635:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 3636:                                                                      prop_name_p,
        -: 3637:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3638:                                                                      NULL);
        -: 3639:
    #####: 3640:    value_p->value = ecma_copy_value_if_not_object (value);
        -: 3641:  }
        -: 3642:  else
        -: 3643:  {
    #####: 3644:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);
        -: 3645:  }
        -: 3646:
    #####: 3647:  return true;
        -: 3648:} /* jerry_object_set_internal */
        -: 3649:
        -: 3650:/**
        -: 3651: * Construct empty property descriptor, i.e.:
        -: 3652: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 3653: *
        -: 3654: * @return empty property descriptor
        -: 3655: */
        -: 3656:jerry_property_descriptor_t
    #####: 3657:jerry_property_descriptor (void)
        -: 3658:{
        -: 3659:  jerry_property_descriptor_t prop_desc;
        -: 3660:
    #####: 3661:  prop_desc.flags = JERRY_PROP_NO_OPTS;
    #####: 3662:  prop_desc.value = ECMA_VALUE_UNDEFINED;
    #####: 3663:  prop_desc.getter = ECMA_VALUE_UNDEFINED;
    #####: 3664:  prop_desc.setter = ECMA_VALUE_UNDEFINED;
        -: 3665:
    #####: 3666:  return prop_desc;
        -: 3667:} /* jerry_property_descriptor */
        -: 3668:
        -: 3669:/**
        -: 3670: * Convert a ecma_property_descriptor_t to a jerry_property_descriptor_t
        -: 3671: *
        -: 3672: * if error occurs the property descriptor's value field is filled with ECMA_VALUE_ERROR
        -: 3673: *
        -: 3674: * @return jerry_property_descriptor_t
        -: 3675: */
        -: 3676:static jerry_property_descriptor_t
    #####: 3677:jerry_property_descriptor_from_ecma (const ecma_property_descriptor_t *prop_desc_p) /**<[out] property_descriptor */
        -: 3678:{
    #####: 3679:  jerry_property_descriptor_t prop_desc = jerry_property_descriptor ();
        -: 3680:
    #####: 3681:  prop_desc.flags = prop_desc_p->flags;
        -: 3682:
    #####: 3683:  if (prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED))
        -: 3684:  {
    #####: 3685:    prop_desc.value = prop_desc_p->value;
        -: 3686:  }
        -: 3687:
    #####: 3688:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3689:  {
    #####: 3690:    prop_desc.getter = ECMA_VALUE_NULL;
        -: 3691:
    #####: 3692:    if (prop_desc_p->get_p != NULL)
        -: 3693:    {
    #####: 3694:      prop_desc.getter = ecma_make_object_value (prop_desc_p->get_p);
    #####: 3695:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.getter));
        -: 3696:    }
        -: 3697:  }
        -: 3698:
    #####: 3699:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3700:  {
    #####: 3701:    prop_desc.setter = ECMA_VALUE_NULL;
        -: 3702:
    #####: 3703:    if (prop_desc_p->set_p != NULL)
        -: 3704:    {
    #####: 3705:      prop_desc.setter = ecma_make_object_value (prop_desc_p->set_p);
    #####: 3706:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.setter));
        -: 3707:    }
        -: 3708:  }
        -: 3709:
    #####: 3710:  return prop_desc;
        -: 3711:} /* jerry_property_descriptor_from_ecma */
        -: 3712:
        -: 3713:/**
        -: 3714: * Convert a jerry_property_descriptor_t to a ecma_property_descriptor_t
        -: 3715: *
        -: 3716: * Note:
        -: 3717: *     if error occurs the property descriptor's value field
        -: 3718: *     is set to ECMA_VALUE_ERROR, but no error is thrown
        -: 3719: *
        -: 3720: * @return ecma_property_descriptor_t
        -: 3721: */
        -: 3722:static ecma_property_descriptor_t
    #####: 3723:jerry_property_descriptor_to_ecma (const jerry_property_descriptor_t *prop_desc_p) /**< input property_descriptor */
        -: 3724:{
    #####: 3725:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 3726:
    #####: 3727:  prop_desc.flags = prop_desc_p->flags;
        -: 3728:
        -: 3729:  /* Copy data property info. */
    #####: 3730:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3731:  {
    #####: 3732:    if (ecma_is_value_exception (prop_desc_p->value)
    #####: 3733:        || (prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -: 3734:    {
    #####: 3735:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3736:      return prop_desc;
        -: 3737:    }
        -: 3738:
    #####: 3739:    prop_desc.value = prop_desc_p->value;
        -: 3740:  }
        -: 3741:
        -: 3742:  /* Copy accessor property info. */
    #####: 3743:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3744:  {
    #####: 3745:    ecma_value_t getter = prop_desc_p->getter;
        -: 3746:
    #####: 3747:    if (ecma_is_value_exception (getter))
        -: 3748:    {
    #####: 3749:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3750:      return prop_desc;
        -: 3751:    }
        -: 3752:
    #####: 3753:    if (ecma_op_is_callable (getter))
        -: 3754:    {
    #####: 3755:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 3756:    }
    #####: 3757:    else if (!ecma_is_value_null (getter))
        -: 3758:    {
    #####: 3759:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3760:      return prop_desc;
        -: 3761:    }
        -: 3762:  }
        -: 3763:
    #####: 3764:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3765:  {
    #####: 3766:    ecma_value_t setter = prop_desc_p->setter;
        -: 3767:
    #####: 3768:    if (ecma_is_value_exception (setter))
        -: 3769:    {
    #####: 3770:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3771:      return prop_desc;
        -: 3772:    }
        -: 3773:
    #####: 3774:    if (ecma_op_is_callable (setter))
        -: 3775:    {
    #####: 3776:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 3777:    }
    #####: 3778:    else if (!ecma_is_value_null (setter))
        -: 3779:    {
    #####: 3780:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3781:      return prop_desc;
        -: 3782:    }
        -: 3783:  }
        -: 3784:
    #####: 3785:  const uint16_t configurable_mask = JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED;
    #####: 3786:  const uint16_t enumerable_mask = JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_ENUMERABLE_DEFINED;
    #####: 3787:  const uint16_t writable_mask = JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED;
        -: 3788:
    #####: 3789:  if ((prop_desc_p->flags & configurable_mask) == JERRY_PROP_IS_CONFIGURABLE
    #####: 3790:      || (prop_desc_p->flags & enumerable_mask) == JERRY_PROP_IS_ENUMERABLE
    #####: 3791:      || (prop_desc_p->flags & writable_mask) == JERRY_PROP_IS_WRITABLE)
        -: 3792:  {
    #####: 3793:    prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3794:    return prop_desc;
        -: 3795:  }
        -: 3796:
    #####: 3797:  prop_desc.flags |= (uint16_t) (prop_desc_p->flags | JERRY_PROP_SHOULD_THROW);
        -: 3798:
    #####: 3799:  return prop_desc;
        -: 3800:} /* jerry_property_descriptor_to_ecma */
        -: 3801:
        -: 3802:/** Helper function to return false value or error depending on the given flag.
        -: 3803: *
        -: 3804: * @return value marked with error flag - if is_throw is true
        -: 3805: *         false value - otherwise
        -: 3806: */
        -: 3807:static jerry_value_t
    #####: 3808:jerry_type_error_or_false (ecma_error_msg_t msg, /**< message */
        -: 3809:                           uint16_t flags) /**< property descriptor flags */
        -: 3810:{
    #####: 3811:  if (!(flags & JERRY_PROP_SHOULD_THROW))
        -: 3812:  {
    #####: 3813:    return ECMA_VALUE_FALSE;
        -: 3814:  }
        -: 3815:
    #####: 3816:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (msg));
        -: 3817:} /* jerry_type_error_or_false */
        -: 3818:
        -: 3819:/**
        -: 3820: * Define a property to the specified object with the given name.
        -: 3821: *
        -: 3822: * Note:
        -: 3823: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3824: *
        -: 3825: * @return true value - if the operation was successful
        -: 3826: *         false value - if the property cannot be defined and JERRY_PROP_SHOULD_THROW is not set
        -: 3827: *         value marked with error flag - otherwise
        -: 3828: */
        -: 3829:jerry_value_t
    #####: 3830:jerry_object_define_own_prop (const jerry_value_t object, /**< object value */
        -: 3831:                              const jerry_value_t key, /**< property name (string value) */
        -: 3832:                              const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3833:{
        -: 3834:  jerry_assert_api_enabled ();
        -: 3835:
    #####: 3836:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3837:  {
    #####: 3838:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3839:  }
        -: 3840:
    #####: 3841:  if (prop_desc_p->flags & (JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_VALUE_DEFINED)
    #####: 3842:      && prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 3843:  {
    #####: 3844:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3845:  }
        -: 3846:
    #####: 3847:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (prop_desc_p);
        -: 3848:
    #####: 3849:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 3850:  {
    #####: 3851:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3852:  }
        -: 3853:
    #####: 3854:  return jerry_return (ecma_op_object_define_own_property (ecma_get_object_from_value (object),
        -: 3855:                                                           ecma_get_prop_name_from_value (key),
        -: 3856:                                                           &prop_desc));
        -: 3857:} /* jerry_object_define_own_prop */
        -: 3858:
        -: 3859:/**
        -: 3860: * Construct property descriptor from specified property.
        -: 3861: *
        -: 3862: * @return true - if success, the prop_desc_p fields contains the property info
        -: 3863: *         false - otherwise, the prop_desc_p is unchanged
        -: 3864: */
        -: 3865:jerry_value_t
    #####: 3866:jerry_object_get_own_prop (const jerry_value_t object, /**< object value */
        -: 3867:                           const jerry_value_t key, /**< property name (string value) */
        -: 3868:                           jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3869:{
        -: 3870:  jerry_assert_api_enabled ();
        -: 3871:
    #####: 3872:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3873:  {
    #####: 3874:    return ECMA_VALUE_FALSE;
        -: 3875:  }
        -: 3876:
    #####: 3877:  ecma_property_descriptor_t prop_desc;
        -: 3878:
    #####: 3879:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (object),
        -: 3880:                                                                    ecma_get_prop_name_from_value (key),
        -: 3881:                                                                    &prop_desc);
        -: 3882:
        -: 3883:#if JERRY_BUILTIN_PROXY
    #####: 3884:  if (ECMA_IS_VALUE_ERROR (status))
        -: 3885:  {
    #####: 3886:    return ecma_create_exception_from_context ();
        -: 3887:  }
        -: 3888:#endif /* JERRY_BUILTIN_PROXY */
        -: 3889:
    #####: 3890:  if (!ecma_is_value_true (status))
        -: 3891:  {
    #####: 3892:    return ECMA_VALUE_FALSE;
        -: 3893:  }
        -: 3894:
        -: 3895:  /* The flags are always filled in the returned descriptor. */
    #####: 3896:  JERRY_ASSERT (
        -: 3897:    (prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED) && (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 3898:    && ((prop_desc.flags & JERRY_PROP_IS_WRITABLE_DEFINED) || !(prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED)));
        -: 3899:
    #####: 3900:  prop_desc_p->flags = prop_desc.flags;
    #####: 3901:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 3902:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 3903:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 3904:
    #####: 3905:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3906:  {
    #####: 3907:    prop_desc_p->value = prop_desc.value;
        -: 3908:  }
        -: 3909:
    #####: 3910:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3911:  {
    #####: 3912:    if (prop_desc.get_p != NULL)
        -: 3913:    {
    #####: 3914:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 3915:    }
        -: 3916:    else
        -: 3917:    {
    #####: 3918:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 3919:    }
        -: 3920:  }
        -: 3921:
    #####: 3922:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3923:  {
    #####: 3924:    if (prop_desc.set_p != NULL)
        -: 3925:    {
    #####: 3926:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 3927:    }
        -: 3928:    else
        -: 3929:    {
    #####: 3930:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 3931:    }
        -: 3932:  }
        -: 3933:
    #####: 3934:  return ECMA_VALUE_TRUE;
        -: 3935:} /* jerry_object_get_own_prop */
        -: 3936:
        -: 3937:/**
        -: 3938: * Free fields of property descriptor (setter, getter and value).
        -: 3939: */
        -: 3940:void
    #####: 3941:jerry_property_descriptor_free (jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3942:{
    #####: 3943:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3944:  {
    #####: 3945:    jerry_value_free (prop_desc_p->value);
        -: 3946:  }
        -: 3947:
    #####: 3948:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3949:  {
    #####: 3950:    jerry_value_free (prop_desc_p->getter);
        -: 3951:  }
        -: 3952:
    #####: 3953:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3954:  {
    #####: 3955:    jerry_value_free (prop_desc_p->setter);
        -: 3956:  }
    #####: 3957:} /* jerry_property_descriptor_free */
        -: 3958:
        -: 3959:/**
        -: 3960: * Call function specified by a function value
        -: 3961: *
        -: 3962: * Note:
        -: 3963: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3964: *      error flag must not be set for any arguments of this function.
        -: 3965: *
        -: 3966: * @return returned jerry value of the called function
        -: 3967: */
        -: 3968:jerry_value_t
    #####: 3969:jerry_call (const jerry_value_t func_object, /**< function object to call */
        -: 3970:            const jerry_value_t this_value, /**< object for 'this' binding */
        -: 3971:            const jerry_value_t *args_p, /**< function's call arguments */
        -: 3972:            jerry_size_t args_count) /**< number of the arguments */
        -: 3973:{
        -: 3974:  jerry_assert_api_enabled ();
        -: 3975:
    #####: 3976:  if (ecma_is_value_exception (this_value))
        -: 3977:  {
    #####: 3978:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3979:  }
        -: 3980:
    #####: 3981:  for (jerry_size_t i = 0; i < args_count; i++)
        -: 3982:  {
    #####: 3983:    if (ecma_is_value_exception (args_p[i]))
        -: 3984:    {
    #####: 3985:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 3986:    }
        -: 3987:  }
        -: 3988:
    #####: 3989:  return jerry_return (ecma_op_function_validated_call (func_object, this_value, args_p, args_count));
        -: 3990:} /* jerry_call */
        -: 3991:
        -: 3992:/**
        -: 3993: * Construct object value invoking specified function value as a constructor
        -: 3994: *
        -: 3995: * Note:
        -: 3996: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3997: *      error flag must not be set for any arguments of this function.
        -: 3998: *
        -: 3999: * @return returned jerry value of the invoked constructor
        -: 4000: */
        -: 4001:jerry_value_t
    #####: 4002:jerry_construct (const jerry_value_t func_object, /**< function object to call */
        -: 4003:                 const jerry_value_t *args_p, /**< function's call arguments
        -: 4004:                                               *   (NULL if arguments number is zero) */
        -: 4005:                 jerry_size_t args_count) /**< number of the arguments */
        -: 4006:{
        -: 4007:  jerry_assert_api_enabled ();
        -: 4008:
    #####: 4009:  if (!jerry_value_is_constructor (func_object))
        -: 4010:  {
    #####: 4011:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4012:  }
        -: 4013:
    #####: 4014:  for (jerry_size_t i = 0; i < args_count; i++)
        -: 4015:  {
    #####: 4016:    if (ecma_is_value_exception (args_p[i]))
        -: 4017:    {
    #####: 4018:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 4019:    }
        -: 4020:  }
        -: 4021:
    #####: 4022:  return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_object),
        -: 4023:                                                   ecma_get_object_from_value (func_object),
        -: 4024:                                                   args_p,
        -: 4025:                                                   args_count));
        -: 4026:} /* jerry_construct */
        -: 4027:
        -: 4028:/**
        -: 4029: * Get keys of the specified object value
        -: 4030: *
        -: 4031: * Note:
        -: 4032: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4033: *
        -: 4034: * @return array object value - if success
        -: 4035: *         value marked with error flag - otherwise
        -: 4036: */
        -: 4037:jerry_value_t
    #####: 4038:jerry_object_keys (const jerry_value_t object) /**< object value */
        -: 4039:{
        -: 4040:  jerry_assert_api_enabled ();
        -: 4041:
    #####: 4042:  if (!ecma_is_value_object (object))
        -: 4043:  {
    #####: 4044:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4045:  }
        -: 4046:
    #####: 4047:  ecma_collection_t *prop_names =
    #####: 4048:    ecma_op_object_get_enumerable_property_names (ecma_get_object_from_value (object), ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 4049:
        -: 4050:#if JERRY_BUILTIN_PROXY
    #####: 4051:  if (JERRY_UNLIKELY (prop_names == NULL))
        -: 4052:  {
    #####: 4053:    return ecma_create_exception_from_context ();
        -: 4054:  }
        -: 4055:#endif /* JERRY_BUILTIN_PROXY */
        -: 4056:
    #####: 4057:  return ecma_op_new_array_object_from_collection (prop_names, false);
        -: 4058:} /* jerry_object_keys */
        -: 4059:
        -: 4060:/**
        -: 4061: * Get the prototype of the specified object
        -: 4062: *
        -: 4063: * Note:
        -: 4064: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4065: *
        -: 4066: * @return prototype object or null value - if success
        -: 4067: *         value marked with error flag - otherwise
        -: 4068: */
        -: 4069:jerry_value_t
    #####: 4070:jerry_object_proto (const jerry_value_t object) /**< object value */
        -: 4071:{
        -: 4072:  jerry_assert_api_enabled ();
        -: 4073:
    #####: 4074:  if (!ecma_is_value_object (object))
        -: 4075:  {
    #####: 4076:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4077:  }
        -: 4078:
    #####: 4079:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 4080:
        -: 4081:#if JERRY_BUILTIN_PROXY
    #####: 4082:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4083:  {
    #####: 4084:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 4085:  }
        -: 4086:#endif /* JERRY_BUILTIN_PROXY */
        -: 4087:
    #####: 4088:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 4089:  {
    #####: 4090:    return ECMA_VALUE_NULL;
        -: 4091:  }
        -: 4092:
    #####: 4093:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 4094:  ecma_ref_object (proto_obj_p);
        -: 4095:
    #####: 4096:  return ecma_make_object_value (proto_obj_p);
        -: 4097:} /* jerry_object_proto */
        -: 4098:
        -: 4099:/**
        -: 4100: * Set the prototype of the specified object
        -: 4101: *
        -: 4102: * @return true value - if success
        -: 4103: *         value marked with error flag - otherwise
        -: 4104: */
        -: 4105:jerry_value_t
    #####: 4106:jerry_object_set_proto (const jerry_value_t object, /**< object value */
        -: 4107:                        const jerry_value_t proto) /**< prototype object value */
        -: 4108:{
        -: 4109:  jerry_assert_api_enabled ();
        -: 4110:
    #####: 4111:  if (!ecma_is_value_object (object) || ecma_is_value_exception (proto)
    #####: 4112:      || (!ecma_is_value_object (proto) && !ecma_is_value_null (proto)))
        -: 4113:  {
    #####: 4114:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4115:  }
    #####: 4116:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 4117:
        -: 4118:#if JERRY_BUILTIN_PROXY
    #####: 4119:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4120:  {
    #####: 4121:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto));
        -: 4122:  }
        -: 4123:#endif /* JERRY_BUILTIN_PROXY */
        -: 4124:
    #####: 4125:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto);
        -: 4126:} /* jerry_object_set_proto */
        -: 4127:
        -: 4128:/**
        -: 4129: * Utility to check if a given object can be used for the foreach api calls.
        -: 4130: *
        -: 4131: * Some objects/classes uses extra internal objects to correctly store data.
        -: 4132: * These extre object should never be exposed externally to the API user.
        -: 4133: *
        -: 4134: * @returns true - if the user can access the object in the callback.
        -: 4135: *          false - if the object is an internal object which should no be accessed by the user.
        -: 4136: */
        -: 4137:static bool
    #####: 4138:jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 4139:{
    #####: 4140:  if (ecma_is_lexical_environment (object_p))
        -: 4141:  {
    #####: 4142:    return false;
        -: 4143:  }
        -: 4144:
    #####: 4145:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 4146:
    #####: 4147:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 4148:  {
    #####: 4149:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 4150:    switch (ext_object_p->u.cls.type)
        -: 4151:    {
        -: 4152:      /* An object's internal property object should not be iterable by foreach. */
    #####: 4153:      case ECMA_OBJECT_CLASS_INTERNAL_OBJECT:
        -: 4154:      {
    #####: 4155:        return false;
        -: 4156:      }
        -: 4157:    }
        -: 4158:  }
        -: 4159:
    #####: 4160:  return true;
        -: 4161:} /* jerry_object_is_valid_foreach */
        -: 4162:
        -: 4163:/**
        -: 4164: * Traverse objects.
        -: 4165: *
        -: 4166: * @return true - traversal was interrupted by the callback.
        -: 4167: *         false - otherwise - traversal visited all objects.
        -: 4168: */
        -: 4169:bool
    #####: 4170:jerry_foreach_live_object (jerry_foreach_live_object_cb_t callback, /**< function pointer of the iterator function */
        -: 4171:                           void *user_data_p) /**< pointer to user data */
        -: 4172:{
        -: 4173:  jerry_assert_api_enabled ();
        -: 4174:
    #####: 4175:  JERRY_ASSERT (callback != NULL);
        -: 4176:
    #####: 4177:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4178:
    #####: 4179:  while (iter_cp != JMEM_CP_NULL)
        -: 4180:  {
    #####: 4181:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4182:
    #####: 4183:    if (jerry_object_is_valid_foreach (iter_p) && !callback (ecma_make_object_value (iter_p), user_data_p))
        -: 4184:    {
    #####: 4185:      return true;
        -: 4186:    }
        -: 4187:
    #####: 4188:    iter_cp = iter_p->gc_next_cp;
        -: 4189:  }
        -: 4190:
    #####: 4191:  return false;
        -: 4192:} /* jerry_foreach_live_object */
        -: 4193:
        -: 4194:/**
        -: 4195: * Traverse objects having a given native type info.
        -: 4196: *
        -: 4197: * @return true - traversal was interrupted by the callback.
        -: 4198: *         false - otherwise - traversal visited all objects.
        -: 4199: */
        -: 4200:bool
    #####: 4201:jerry_foreach_live_object_with_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 4202:                                                                                       *   of the native pointer */
        -: 4203:                                     jerry_foreach_live_object_with_info_cb_t callback, /**< function to apply for
        -: 4204:                                                                                         *   each matching object */
        -: 4205:                                     void *user_data_p) /**< pointer to user data */
        -: 4206:{
        -: 4207:  jerry_assert_api_enabled ();
        -: 4208:
    #####: 4209:  JERRY_ASSERT (native_info_p != NULL);
    #####: 4210:  JERRY_ASSERT (callback != NULL);
        -: 4211:
        -: 4212:  ecma_native_pointer_t *native_pointer_p;
        -: 4213:
    #####: 4214:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4215:
    #####: 4216:  while (iter_cp != JMEM_CP_NULL)
        -: 4217:  {
    #####: 4218:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4219:
    #####: 4220:    if (jerry_object_is_valid_foreach (iter_p))
        -: 4221:    {
    #####: 4222:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 4223:      if (native_pointer_p && !callback (ecma_make_object_value (iter_p), native_pointer_p->native_p, user_data_p))
        -: 4224:      {
    #####: 4225:        return true;
        -: 4226:      }
        -: 4227:    }
        -: 4228:
    #####: 4229:    iter_cp = iter_p->gc_next_cp;
        -: 4230:  }
        -: 4231:
    #####: 4232:  return false;
        -: 4233:} /* jerry_foreach_live_object_with_info */
        -: 4234:
        -: 4235:/**
        -: 4236: * Get native pointer and its type information, associated with the given native type info.
        -: 4237: *
        -: 4238: * Note:
        -: 4239: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 4240: *
        -: 4241: * @return found native pointer,
        -: 4242: *         or NULL
        -: 4243: */
        -: 4244:void *
    #####: 4245:jerry_object_get_native_ptr (const jerry_value_t object, /**< object to get native pointer from */
        -: 4246:                             const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 4247:                                                                               *   of the native pointer */
        -: 4248:{
        -: 4249:  jerry_assert_api_enabled ();
        -: 4250:
    #####: 4251:  if (!ecma_is_value_object (object))
        -: 4252:  {
    #####: 4253:    return NULL;
        -: 4254:  }
        -: 4255:
    #####: 4256:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4257:  ecma_native_pointer_t *native_pointer_p = ecma_get_native_pointer_value (obj_p, (void *) native_info_p);
        -: 4258:
    #####: 4259:  if (native_pointer_p == NULL)
        -: 4260:  {
    #####: 4261:    return NULL;
        -: 4262:  }
        -: 4263:
    #####: 4264:  return native_pointer_p->native_p;
        -: 4265:} /* jerry_object_get_native_ptr */
        -: 4266:
        -: 4267:/**
        -: 4268: * Set native pointer and an optional type info for the specified object.
        -: 4269: *
        -: 4270: *
        -: 4271: * Note:
        -: 4272: *      If native pointer was already set for the object, its value is updated.
        -: 4273: *
        -: 4274: * Note:
        -: 4275: *      If a non-NULL free callback is specified in the native type info,
        -: 4276: *      it will be called by the garbage collector when the object is freed.
        -: 4277: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 4278: *      The type info always overwrites the previous value, so passing
        -: 4279: *      a NULL value deletes the current type info.
        -: 4280: */
        -: 4281:void
    #####: 4282:jerry_object_set_native_ptr (const jerry_value_t object, /**< object to set native pointer in */
        -: 4283:                             const jerry_object_native_info_t *native_info_p, /**< object's native type info */
        -: 4284:                             void *native_pointer_p) /**< native pointer */
        -: 4285:{
        -: 4286:  jerry_assert_api_enabled ();
        -: 4287:
    #####: 4288:  if (ecma_is_value_object (object))
        -: 4289:  {
    #####: 4290:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        -: 4291:
    #####: 4292:    ecma_create_native_pointer_property (object_p, native_pointer_p, native_info_p);
        -: 4293:  }
    #####: 4294:} /* jerry_object_set_native_ptr */
        -: 4295:
        -: 4296:/**
        -: 4297: * Checks wether the argument object has a native poitner set for the specified native type info.
        -: 4298: *
        -: 4299: * @return true if the native pointer has been set,
        -: 4300: *         false otherwise
        -: 4301: */
        -: 4302:bool
    #####: 4303:jerry_object_has_native_ptr (const jerry_value_t object, /**< object to set native pointer in */
        -: 4304:                             const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4305:{
        -: 4306:  jerry_assert_api_enabled ();
        -: 4307:
    #####: 4308:  if (!ecma_is_value_object (object))
        -: 4309:  {
    #####: 4310:    return false;
        -: 4311:  }
        -: 4312:
    #####: 4313:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4314:  ecma_native_pointer_t *native_pointer_p = ecma_get_native_pointer_value (obj_p, (void *) native_info_p);
        -: 4315:
    #####: 4316:  return native_pointer_p != NULL;
        -: 4317:} /* jerry_object_has_native_ptr */
        -: 4318:
        -: 4319:/**
        -: 4320: * Delete the previously set native pointer by the native type info from the specified object.
        -: 4321: *
        -: 4322: * Note:
        -: 4323: *      If the specified object has no matching native pointer for the given native type info
        -: 4324: *      the function has no effect.
        -: 4325: *
        -: 4326: * Note:
        -: 4327: *      This operation cannot throw an exception.
        -: 4328: *
        -: 4329: * @return true - if the native pointer has been deleted succesfully
        -: 4330: *         false - otherwise
        -: 4331: */
        -: 4332:bool
    #####: 4333:jerry_object_delete_native_ptr (const jerry_value_t object, /**< object to delete native pointer from */
        -: 4334:                                const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4335:{
        -: 4336:  jerry_assert_api_enabled ();
        -: 4337:
    #####: 4338:  if (ecma_is_value_object (object))
        -: 4339:  {
    #####: 4340:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        -: 4341:
    #####: 4342:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 4343:  }
        -: 4344:
    #####: 4345:  return false;
        -: 4346:} /* jerry_object_delete_native_ptr */
        -: 4347:
        -: 4348:/**
        -: 4349: * Initialize the references stored in a buffer pointed by a native pointer.
        -: 4350: * The references are initialized to undefined.
        -: 4351: */
        -: 4352:void
    #####: 4353:jerry_native_ptr_init (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4354:                       const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4355:                                                                         *   the native pointer */
        -: 4356:{
        -: 4357:  jerry_assert_api_enabled ();
        -: 4358:
    #####: 4359:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4360:  {
    #####: 4361:    return;
        -: 4362:  }
        -: 4363:
    #####: 4364:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4365:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4366:
    #####: 4367:  while (value_p < end_p)
        -: 4368:  {
    #####: 4369:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4370:  }
        -: 4371:} /* jerry_native_ptr_init */
        -: 4372:
        -: 4373:/**
        -: 4374: * Release the value references after a buffer pointed by a native pointer
        -: 4375: * is not attached to an object anymore. All references are set to undefined
        -: 4376: * similar to jerry_native_ptr_init.
        -: 4377: */
        -: 4378:void
    #####: 4379:jerry_native_ptr_free (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4380:                       const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4381:                                                                         *   the native pointer */
        -: 4382:{
        -: 4383:  jerry_assert_api_enabled ();
        -: 4384:
    #####: 4385:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4386:  {
    #####: 4387:    return;
        -: 4388:  }
        -: 4389:
    #####: 4390:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4391:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4392:
    #####: 4393:  while (value_p < end_p)
        -: 4394:  {
    #####: 4395:    ecma_free_value_if_not_object (*value_p);
    #####: 4396:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4397:  }
        -: 4398:} /* jerry_native_ptr_free */
        -: 4399:
        -: 4400:/**
        -: 4401: * Updates a value reference inside the area specified by the number_of_references and
        -: 4402: * offset_of_references fields in its corresponding jerry_object_native_info_t data.
        -: 4403: * The area must be part of a buffer which is currently assigned to an object.
        -: 4404: *
        -: 4405: * Note:
        -: 4406: *      Error references are not supported, they are replaced by undefined values.
        -: 4407: */
        -: 4408:void
    #####: 4409:jerry_native_ptr_set (jerry_value_t *reference_p, /**< a valid non-NULL pointer to
        -: 4410:                                                   *   a reference in a native buffer. */
        -: 4411:                      jerry_value_t value) /**< new value of the reference */
        -: 4412:{
        -: 4413:  jerry_assert_api_enabled ();
        -: 4414:
    #####: 4415:  if (reference_p == NULL)
        -: 4416:  {
    #####: 4417:    return;
        -: 4418:  }
        -: 4419:
    #####: 4420:  if (ecma_is_value_exception (value))
        -: 4421:  {
    #####: 4422:    value = ECMA_VALUE_UNDEFINED;
        -: 4423:  }
        -: 4424:
    #####: 4425:  ecma_free_value_if_not_object (*reference_p);
    #####: 4426:  *reference_p = ecma_copy_value_if_not_object (value);
        -: 4427:} /* jerry_native_ptr_set */
        -: 4428:
        -: 4429:/**
        -: 4430: * Applies the given function to the every property in the object.
        -: 4431: *
        -: 4432: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 4433: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 4434: *                - object fields traversal was stopped on callback that returned false;
        -: 4435: *         false - otherwise,
        -: 4436: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 4437: */
        -: 4438:bool
    #####: 4439:jerry_object_foreach (const jerry_value_t object, /**< object value */
        -: 4440:                      jerry_object_property_foreach_cb_t foreach_p, /**< foreach function */
        -: 4441:                      void *user_data_p) /**< user data for foreach function */
        -: 4442:{
        -: 4443:  jerry_assert_api_enabled ();
        -: 4444:
    #####: 4445:  if (!ecma_is_value_object (object))
        -: 4446:  {
    #####: 4447:    return false;
        -: 4448:  }
        -: 4449:
    #####: 4450:  ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####: 4451:  ecma_collection_t *names_p = ecma_op_object_enumerate (object_p);
        -: 4452:
        -: 4453:#if JERRY_BUILTIN_PROXY
    #####: 4454:  if (names_p == NULL)
        -: 4455:  {
        -: 4456:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 4457:    jcontext_release_exception ();
    #####: 4458:    return false;
        -: 4459:  }
        -: 4460:#endif /* JERRY_BUILTIN_PROXY */
        -: 4461:
    #####: 4462:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 4463:
    #####: 4464:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 4465:
    #####: 4466:  bool continuous = true;
        -: 4467:
    #####: 4468:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 4469:  {
    #####: 4470:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 4471:
    #####: 4472:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 4473:
    #####: 4474:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 4475:    {
    #####: 4476:      break;
        -: 4477:    }
        -: 4478:
    #####: 4479:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 4480:    ecma_free_value (property_value);
        -: 4481:  }
        -: 4482:
    #####: 4483:  ecma_collection_free (names_p);
        -: 4484:
    #####: 4485:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 4486:  {
    #####: 4487:    return true;
        -: 4488:  }
        -: 4489:
    #####: 4490:  jcontext_release_exception ();
    #####: 4491:  return false;
        -: 4492:} /* jerry_object_foreach */
        -: 4493:
        -: 4494:/**
        -: 4495: * Gets the property keys for the given object using the selected filters.
        -: 4496: *
        -: 4497: * @return array containing the filtered property keys in successful operation
        -: 4498: *         value marked with error flag - otherwise
        -: 4499: */
        -: 4500:jerry_value_t
    #####: 4501:jerry_object_property_names (const jerry_value_t object, /**< object */
        -: 4502:                             jerry_property_filter_t filter) /**< property filter options */
        -: 4503:{
        -: 4504:  jerry_assert_api_enabled ();
        -: 4505:
    #####: 4506:  if (!ecma_is_value_object (object))
        -: 4507:  {
    #####: 4508:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4509:  }
        -: 4510:
    #####: 4511:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4512:  ecma_object_t *obj_iter_p = obj_p;
    #####: 4513:  ecma_collection_t *result_p = ecma_new_collection ();
        -: 4514:
    #####: 4515:  ecma_ref_object (obj_iter_p);
        -: 4516:
        -: 4517:  while (true)
    #####: 4518:  {
        -: 4519:    /* Step 1. Get Object.[[OwnKeys]] */
    #####: 4520:    ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_iter_p, filter);
        -: 4521:
        -: 4522:#if JERRY_BUILTIN_PROXY
    #####: 4523:    if (prop_names_p == NULL)
        -: 4524:    {
    #####: 4525:      ecma_deref_object (obj_iter_p);
    #####: 4526:      return ecma_create_exception_from_context ();
        -: 4527:    }
        -: 4528:#endif /* JERRY_BUILTIN_PROXY */
        -: 4529:
    #####: 4530:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 4531:    {
    #####: 4532:      ecma_value_t key = prop_names_p->buffer_p[i];
    #####: 4533:      ecma_string_t *key_p = ecma_get_prop_name_from_value (key);
    #####: 4534:      uint32_t index = ecma_string_get_array_index (key_p);
        -: 4535:
        -: 4536:      /* Step 2. Filter by key type */
    #####: 4537:      if (filter
    #####: 4538:          & (JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS | JERRY_PROPERTY_FILTER_EXCLUDE_SYMBOLS
        -: 4539:             | JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES))
        -: 4540:      {
    #####: 4541:        if (ecma_is_value_symbol (key))
        -: 4542:        {
    #####: 4543:          if (filter & JERRY_PROPERTY_FILTER_EXCLUDE_SYMBOLS)
        -: 4544:          {
    #####: 4545:            continue;
        -: 4546:          }
        -: 4547:        }
    #####: 4548:        else if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 4549:        {
    #####: 4550:          if ((filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES)
    #####: 4551:              || ((filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS)
    #####: 4552:                  && !(filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER)))
        -: 4553:          {
    #####: 4554:            continue;
        -: 4555:          }
        -: 4556:        }
    #####: 4557:        else if (filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS)
        -: 4558:        {
    #####: 4559:          continue;
        -: 4560:        }
        -: 4561:      }
        -: 4562:
        -: 4563:      /* Step 3. Filter property attributes */
    #####: 4564:      if (filter
    #####: 4565:          & (JERRY_PROPERTY_FILTER_EXCLUDE_NON_CONFIGURABLE | JERRY_PROPERTY_FILTER_EXCLUDE_NON_ENUMERABLE
        -: 4566:             | JERRY_PROPERTY_FILTER_EXCLUDE_NON_WRITABLE))
        -: 4567:      {
    #####: 4568:        ecma_property_descriptor_t prop_desc;
    #####: 4569:        ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_iter_p, key_p, &prop_desc);
        -: 4570:
        -: 4571:#if JERRY_BUILTIN_PROXY
    #####: 4572:        if (ECMA_IS_VALUE_ERROR (status))
        -: 4573:        {
    #####: 4574:          ecma_collection_free (prop_names_p);
    #####: 4575:          ecma_collection_free (result_p);
    #####: 4576:          ecma_deref_object (obj_iter_p);
    #####: 4577:          return ecma_create_exception_from_context ();
        -: 4578:        }
        -: 4579:#endif /* JERRY_BUILTIN_PROXY */
        -: 4580:
    #####: 4581:        JERRY_ASSERT (ecma_is_value_true (status));
    #####: 4582:        uint16_t flags = prop_desc.flags;
    #####: 4583:        ecma_free_property_descriptor (&prop_desc);
        -: 4584:
    #####: 4585:        if ((!(flags & JERRY_PROP_IS_CONFIGURABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_CONFIGURABLE))
    #####: 4586:            || (!(flags & JERRY_PROP_IS_ENUMERABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_ENUMERABLE))
    #####: 4587:            || (!(flags & JERRY_PROP_IS_WRITABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_WRITABLE)))
        -: 4588:        {
    #####: 4589:          continue;
        -: 4590:        }
        -: 4591:      }
        -: 4592:
    #####: 4593:      if (index != ECMA_STRING_NOT_ARRAY_INDEX && (filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER))
        -: 4594:      {
    #####: 4595:        ecma_deref_ecma_string (key_p);
    #####: 4596:        key = ecma_make_uint32_value (index);
        -: 4597:      }
        -: 4598:      else
        -: 4599:      {
    #####: 4600:        ecma_ref_ecma_string (key_p);
        -: 4601:      }
        -: 4602:
    #####: 4603:      if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) && obj_iter_p != obj_p)
    #####: 4604:      {
    #####: 4605:        uint32_t duplicate_idx = 0;
    #####: 4606:        while (duplicate_idx < result_p->item_count)
        -: 4607:        {
    #####: 4608:          ecma_value_t value = result_p->buffer_p[duplicate_idx];
    #####: 4609:          JERRY_ASSERT (ecma_is_value_prop_name (value) || ecma_is_value_number (value));
    #####: 4610:          if (JERRY_UNLIKELY (ecma_is_value_number (value)))
        -: 4611:          {
    #####: 4612:            if (ecma_get_number_from_value (value) == ecma_get_number_from_value (key))
        -: 4613:            {
    #####: 4614:              break;
        -: 4615:            }
        -: 4616:          }
    #####: 4617:          else if (ecma_compare_ecma_strings (ecma_get_prop_name_from_value (value), key_p))
        -: 4618:          {
    #####: 4619:            break;
        -: 4620:          }
        -: 4621:
    #####: 4622:          duplicate_idx++;
        -: 4623:        }
        -: 4624:
    #####: 4625:        if (duplicate_idx == result_p->item_count)
        -: 4626:        {
    #####: 4627:          ecma_collection_push_back (result_p, key);
        -: 4628:        }
        -: 4629:      }
        -: 4630:      else
        -: 4631:      {
    #####: 4632:        ecma_collection_push_back (result_p, key);
        -: 4633:      }
        -: 4634:    }
        -: 4635:
    #####: 4636:    ecma_collection_free (prop_names_p);
        -: 4637:
        -: 4638:    /* Step 4: Traverse prototype chain */
        -: 4639:
    #####: 4640:    if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) != JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN)
        -: 4641:    {
    #####: 4642:      break;
        -: 4643:    }
        -: 4644:
    #####: 4645:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_iter_p);
        -: 4646:
    #####: 4647:    if (proto_p == NULL)
        -: 4648:    {
    #####: 4649:      break;
        -: 4650:    }
        -: 4651:
    #####: 4652:    ecma_deref_object (obj_iter_p);
        -: 4653:
    #####: 4654:    if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 4655:    {
    #####: 4656:      ecma_collection_free (result_p);
    #####: 4657:      return ecma_create_exception_from_context ();
        -: 4658:    }
        -: 4659:
    #####: 4660:    obj_iter_p = proto_p;
        -: 4661:  }
        -: 4662:
    #####: 4663:  ecma_deref_object (obj_iter_p);
        -: 4664:
    #####: 4665:  return ecma_op_new_array_object_from_collection (result_p, false);
        -: 4666:} /* jerry_object_property_names */
        -: 4667:
        -: 4668:/**
        -: 4669: * FromPropertyDescriptor abstract operation.
        -: 4670: *
        -: 4671: * @return new jerry_value_t - if success
        -: 4672: *         value marked with error flag - otherwise
        -: 4673: */
        -: 4674:jerry_value_t
    #####: 4675:jerry_property_descriptor_to_object (const jerry_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -: 4676:{
        -: 4677:  jerry_assert_api_enabled ();
        -: 4678:
    #####: 4679:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (src_prop_desc_p);
        -: 4680:
    #####: 4681:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 4682:  {
    #####: 4683:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4684:  }
        -: 4685:
    #####: 4686:  ecma_object_t *desc_obj_p = ecma_op_from_property_descriptor (&prop_desc);
        -: 4687:
    #####: 4688:  return ecma_make_object_value (desc_obj_p);
        -: 4689:} /* jerry_property_descriptor_to_object */
        -: 4690:
        -: 4691:/**
        -: 4692: * ToPropertyDescriptor abstract operation.
        -: 4693: *
        -: 4694: * @return true - if the conversion is successful
        -: 4695: *         thrown error - otherwise
        -: 4696: */
        -: 4697:jerry_value_t
    #####: 4698:jerry_property_descriptor_from_object (const jerry_value_t object, /**< object value */
        -: 4699:                                       jerry_property_descriptor_t *out_prop_desc_p) /**< [out] filled property
        -: 4700:                                                                                      * descriptor if return value is
        -: 4701:                                                                                      * true, unmodified otherwise */
        -: 4702:{
        -: 4703:  jerry_assert_api_enabled ();
        -: 4704:
    #####: 4705:  ecma_property_descriptor_t prop_desc;
    #####: 4706:  jerry_value_t result = ecma_op_to_property_descriptor (object, &prop_desc);
        -: 4707:
    #####: 4708:  if (ECMA_IS_VALUE_ERROR (result))
        -: 4709:  {
    #####: 4710:    return ecma_create_exception_from_context ();
        -: 4711:  }
        -: 4712:
    #####: 4713:  JERRY_ASSERT (result == ECMA_VALUE_EMPTY);
        -: 4714:
    #####: 4715:  *out_prop_desc_p = jerry_property_descriptor_from_ecma (&prop_desc);
    #####: 4716:  return ECMA_VALUE_TRUE;
        -: 4717:} /* jerry_property_descriptor_from_object */
        -: 4718:
        -: 4719:/**
        -: 4720: * Resolve a promise value with an argument.
        -: 4721: *
        -: 4722: * @return undefined - if success,
        -: 4723: *         exception - otherwise
        -: 4724: */
        -: 4725:jerry_value_t
    #####: 4726:jerry_promise_resolve (jerry_value_t promise, /**< the promise value */
        -: 4727:                       const jerry_value_t argument) /**< the argument */
        -: 4728:{
        -: 4729:  jerry_assert_api_enabled ();
        -: 4730:
        -: 4731:#if JERRY_ESNEXT
    #####: 4732:  if (!jerry_value_is_promise (promise))
        -: 4733:  {
    #####: 4734:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4735:  }
        -: 4736:
    #####: 4737:  if (ecma_is_value_exception (argument))
        -: 4738:  {
    #####: 4739:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 4740:  }
        -: 4741:
    #####: 4742:  return ecma_fulfill_promise_with_checks (promise, argument);
        -: 4743:#else /* !JERRY_ESNEXT */
        -: 4744:  JERRY_UNUSED (promise);
        -: 4745:  JERRY_UNUSED (argument);
        -: 4746:
    #####: 4747:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4748:#endif /* JERRY_ESNEXT */
        -: 4749:} /* jerry_promise_resolve */
        -: 4750:
        -: 4751:/**
        -: 4752: * Reject a promise value with an argument.
        -: 4753: *
        -: 4754: * @return undefined - if success,
        -: 4755: *         exception - otherwise
        -: 4756: */
        -: 4757:jerry_value_t
    #####: 4758:jerry_promise_reject (jerry_value_t promise, /**< the promise value */
        -: 4759:                      const jerry_value_t argument) /**< the argument */
        -: 4760:{
        -: 4761:  jerry_assert_api_enabled ();
        -: 4762:
        -: 4763:#if JERRY_ESNEXT
    #####: 4764:  if (!jerry_value_is_promise (promise))
        -: 4765:  {
    #####: 4766:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4767:  }
        -: 4768:
    #####: 4769:  if (ecma_is_value_exception (argument))
        -: 4770:  {
    #####: 4771:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 4772:  }
        -: 4773:
    #####: 4774:  return ecma_reject_promise_with_checks (promise, argument);
        -: 4775:#else /* !JERRY_ESNEXT */
        -: 4776:  JERRY_UNUSED (promise);
        -: 4777:  JERRY_UNUSED (argument);
        -: 4778:
    #####: 4779:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4780:#endif /* JERRY_ESNEXT */
        -: 4781:} /* jerry_promise_reject */
        -: 4782:
        -: 4783:/**
        -: 4784: * Get the result of a promise.
        -: 4785: *
        -: 4786: * @return - Promise result
        -: 4787: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 4788: */
        -: 4789:jerry_value_t
    #####: 4790:jerry_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 4791:{
        -: 4792:  jerry_assert_api_enabled ();
        -: 4793:
        -: 4794:#if JERRY_ESNEXT
    #####: 4795:  if (!jerry_value_is_promise (promise))
        -: 4796:  {
    #####: 4797:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4798:  }
        -: 4799:
    #####: 4800:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 4801:#else /* !JERRY_ESNEXT */
        -: 4802:  JERRY_UNUSED (promise);
    #####: 4803:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4804:#endif /* JERRY_ESNEXT */
        -: 4805:} /* jerry_promise_result */
        -: 4806:
        -: 4807:/**
        -: 4808: * Get the state of a promise object.
        -: 4809: *
        -: 4810: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 4811: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 4812: *           or the promise support was not enabled.
        -: 4813: */
        -: 4814:jerry_promise_state_t
    #####: 4815:jerry_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 4816:{
        -: 4817:  jerry_assert_api_enabled ();
        -: 4818:
        -: 4819:#if JERRY_ESNEXT
    #####: 4820:  if (!jerry_value_is_promise (promise))
        -: 4821:  {
    #####: 4822:    return JERRY_PROMISE_STATE_NONE;
        -: 4823:  }
        -: 4824:
    #####: 4825:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 4826:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 4827:
    #####: 4828:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 4829:#else /* !JERRY_ESNEXT */
        -: 4830:  JERRY_UNUSED (promise);
    #####: 4831:  return JERRY_PROMISE_STATE_NONE;
        -: 4832:#endif /* JERRY_ESNEXT */
        -: 4833:} /* jerry_promise_state */
        -: 4834:
        -: 4835:/**
        -: 4836: * Sets a callback for tracking Promise and async operations.
        -: 4837: *
        -: 4838: * Note:
        -: 4839: *     the previous callback is overwritten
        -: 4840: */
        -: 4841:void
        1: 4842:jerry_promise_on_event (jerry_promise_event_filter_t filters, /**< combination of event filters */
        -: 4843:                        jerry_promise_event_cb_t callback, /**< notification callback */
        -: 4844:                        void *user_p) /**< user pointer passed to the callback */
        -: 4845:{
        -: 4846:  jerry_assert_api_enabled ();
        -: 4847:
        -: 4848:#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK
    #####: 4849:  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)
        -: 4850:  {
    #####: 4851:    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;
    #####: 4852:    return;
        -: 4853:  }
        -: 4854:
    #####: 4855:  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;
    #####: 4856:  JERRY_CONTEXT (promise_callback) = callback;
    #####: 4857:  JERRY_CONTEXT (promise_callback_user_p) = user_p;
        -: 4858:#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */
        -: 4859:  JERRY_UNUSED (filters);
        -: 4860:  JERRY_UNUSED (callback);
        -: 4861:  JERRY_UNUSED (user_p);
        -: 4862:#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */
        1: 4863:} /* jerry_promise_on_event */
        -: 4864:
        -: 4865:/**
        -: 4866: * Get the well-knwon symbol represented by the given `symbol` enum value.
        -: 4867: *
        -: 4868: * Note:
        -: 4869: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4870: *
        -: 4871: * @return undefined value - if invalid well-known symbol was requested
        -: 4872: *         well-known symbol value - otherwise
        -: 4873: */
        -: 4874:jerry_value_t
    #####: 4875:jerry_symbol (jerry_well_known_symbol_t symbol) /**< jerry_well_known_symbol_t enum value */
        -: 4876:{
        -: 4877:  jerry_assert_api_enabled ();
        -: 4878:
        -: 4879:#if JERRY_ESNEXT
    #####: 4880:  lit_magic_string_id_t id = (lit_magic_string_id_t) (LIT_GLOBAL_SYMBOL__FIRST + symbol);
        -: 4881:
    #####: 4882:  if (!LIT_IS_GLOBAL_SYMBOL (id))
        -: 4883:  {
    #####: 4884:    return ECMA_VALUE_UNDEFINED;
        -: 4885:  }
        -: 4886:
    #####: 4887:  return ecma_make_symbol_value (ecma_op_get_global_symbol (id));
        -: 4888:#else /* !JERRY_ESNEXT */
        -: 4889:  JERRY_UNUSED (symbol);
        -: 4890:
    #####: 4891:  return ECMA_VALUE_UNDEFINED;
        -: 4892:#endif /* JERRY_ESNEXT */
        -: 4893:} /* jerry_symbol */
        -: 4894:
        -: 4895:/**
        -: 4896: * Returns the description internal property of a symbol.
        -: 4897: *
        -: 4898: * Note:
        -: 4899: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4900: *
        -: 4901: * @return string or undefined value containing the symbol's description - if success
        -: 4902: *         thrown error - otherwise
        -: 4903: */
        -: 4904:jerry_value_t
    #####: 4905:jerry_symbol_description (const jerry_value_t symbol) /**< symbol value */
        -: 4906:{
        -: 4907:  jerry_assert_api_enabled ();
        -: 4908:
        -: 4909:#if JERRY_ESNEXT
    #####: 4910:  if (!ecma_is_value_symbol (symbol))
        -: 4911:  {
    #####: 4912:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4913:  }
        -: 4914:
        -: 4915:  /* Note: This operation cannot throw an error */
    #####: 4916:  return ecma_copy_value (ecma_get_symbol_description (ecma_get_symbol_from_value (symbol)));
        -: 4917:#else /* !JERRY_ESNEXT */
        -: 4918:  JERRY_UNUSED (symbol);
        -: 4919:
    #####: 4920:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 4921:#endif /* JERRY_ESNEXT */
        -: 4922:} /* jerry_symbol_description */
        -: 4923:
        -: 4924:/**
        -: 4925: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 4926: *
        -: 4927: * Note:
        -: 4928: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4929: *
        -: 4930: * @return string value containing the symbol's descriptive string - if success
        -: 4931: *         thrown error - otherwise
        -: 4932: */
        -: 4933:jerry_value_t
    #####: 4934:jerry_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 4935:{
        -: 4936:  jerry_assert_api_enabled ();
        -: 4937:
        -: 4938:#if JERRY_ESNEXT
    #####: 4939:  if (!ecma_is_value_symbol (symbol))
        -: 4940:  {
    #####: 4941:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4942:  }
        -: 4943:
        -: 4944:  /* Note: This operation cannot throw an error */
    #####: 4945:  return ecma_get_symbol_descriptive_string (symbol);
        -: 4946:#else /* !JERRY_ESNEXT */
        -: 4947:  JERRY_UNUSED (symbol);
        -: 4948:
    #####: 4949:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 4950:#endif /* JERRY_ESNEXT */
        -: 4951:} /* jerry_symbol_descriptive_string */
        -: 4952:
        -: 4953:/**
        -: 4954: * Get the number of uint64 digits of a BigInt value
        -: 4955: *
        -: 4956: * @return number of uint64 digits
        -: 4957: */
        -: 4958:uint32_t
    #####: 4959:jerry_bigint_digit_count (const jerry_value_t value) /**< BigInt value */
        -: 4960:{
        -: 4961:  jerry_assert_api_enabled ();
        -: 4962:
        -: 4963:#if JERRY_BUILTIN_BIGINT
    #####: 4964:  if (!ecma_is_value_bigint (value))
        -: 4965:  {
    #####: 4966:    return 0;
        -: 4967:  }
        -: 4968:
    #####: 4969:  return ecma_bigint_get_size_in_digits (value);
        -: 4970:#else /* !JERRY_BUILTIN_BIGINT */
        -: 4971:  JERRY_UNUSED (value);
    #####: 4972:  return 0;
        -: 4973:#endif /* JERRY_BUILTIN_BIGINT */
        -: 4974:} /* jerry_bigint_digit_count */
        -: 4975:
        -: 4976:/**
        -: 4977: * Get the uint64 digits of a BigInt value (lowest digit first)
        -: 4978: */
        -: 4979:void
    #####: 4980:jerry_bigint_to_digits (jerry_value_t value, /**< BigInt value */
        -: 4981:                        uint64_t *digits_p, /**< [out] buffer for digits */
        -: 4982:                        uint32_t digit_count, /**< buffer size in digits */
        -: 4983:                        bool *sign_p) /**< [out] sign of BigInt */
        -: 4984:{
        -: 4985:#if JERRY_BUILTIN_BIGINT
    #####: 4986:  if (!ecma_is_value_bigint (value))
        -: 4987:  {
    #####: 4988:    if (sign_p != NULL)
        -: 4989:    {
    #####: 4990:      *sign_p = false;
        -: 4991:    }
    #####: 4992:    memset (digits_p, 0, digit_count * sizeof (uint64_t));
        -: 4993:  }
        -: 4994:
    #####: 4995:  ecma_bigint_get_digits_and_sign (value, digits_p, digit_count, sign_p);
        -: 4996:#else /* !JERRY_BUILTIN_BIGINT */
        -: 4997:  JERRY_UNUSED (value);
        -: 4998:
    #####: 4999:  if (sign_p != NULL)
        -: 5000:  {
    #####: 5001:    *sign_p = false;
        -: 5002:  }
    #####: 5003:  memset (digits_p, 0, digit_count * sizeof (uint64_t));
        -: 5004:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 5005:} /* jerry_bigint_to_digits */
        -: 5006:
        -: 5007:/**
        -: 5008: * Get the target object of a Proxy object
        -: 5009: *
        -: 5010: * @return type error - if proxy_value is not a Proxy object
        -: 5011: *         target object - otherwise
        -: 5012: */
        -: 5013:jerry_value_t
    #####: 5014:jerry_proxy_target (const jerry_value_t proxy_value) /**< proxy value */
        -: 5015:{
        -: 5016:  jerry_assert_api_enabled ();
        -: 5017:
        -: 5018:#if JERRY_BUILTIN_PROXY
    #####: 5019:  if (ecma_is_value_object (proxy_value))
        -: 5020:  {
    #####: 5021:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5022:
    #####: 5023:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5024:    {
    #####: 5025:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5026:
    #####: 5027:      if (!ecma_is_value_null (proxy_object_p->target))
        -: 5028:      {
    #####: 5029:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->target));
        -: 5030:      }
    #####: 5031:      return proxy_object_p->target;
        -: 5032:    }
        -: 5033:  }
        -: 5034:#else /* !JERRY_BUILTIN_PROXY */
        -: 5035:  JERRY_UNUSED (proxy_value);
        -: 5036:#endif /* JERRY_BUILTIN_PROXY */
        -: 5037:
    #####: 5038:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_IS_NOT_A_PROXY));
        -: 5039:} /* jerry_proxy_target */
        -: 5040:
        -: 5041:/**
        -: 5042: * Get the handler object of a Proxy object
        -: 5043: *
        -: 5044: * @return type error - if proxy_value is not a Proxy object
        -: 5045: *         handler object - otherwise
        -: 5046: */
        -: 5047:jerry_value_t
    #####: 5048:jerry_proxy_handler (const jerry_value_t proxy_value) /**< proxy value */
        -: 5049:{
        -: 5050:  jerry_assert_api_enabled ();
        -: 5051:
        -: 5052:#if JERRY_BUILTIN_PROXY
    #####: 5053:  if (ecma_is_value_object (proxy_value))
        -: 5054:  {
    #####: 5055:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5056:
    #####: 5057:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5058:    {
    #####: 5059:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5060:
    #####: 5061:      if (!ecma_is_value_null (proxy_object_p->handler))
        -: 5062:      {
    #####: 5063:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->handler));
        -: 5064:      }
    #####: 5065:      return proxy_object_p->handler;
        -: 5066:    }
        -: 5067:  }
        -: 5068:#else /* !JERRY_BUILTIN_PROXY */
        -: 5069:  JERRY_UNUSED (proxy_value);
        -: 5070:#endif /* JERRY_BUILTIN_PROXY */
        -: 5071:
    #####: 5072:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_IS_NOT_A_PROXY));
        -: 5073:} /* jerry_proxy_handler */
        -: 5074:
        -: 5075:/**
        -: 5076: * Validate string buffer for the specified encoding
        -: 5077: *
        -: 5078: * @return true - if string is well-formed
        -: 5079: *         false - otherwise
        -: 5080: */
        -: 5081:bool
        7: 5082:jerry_validate_string (const jerry_char_t *buffer_p, /**< string buffer */
        -: 5083:                       jerry_size_t buffer_size, /**< buffer size */
        -: 5084:                       jerry_encoding_t encoding) /**< buffer encoding */
        -: 5085:{
        7: 5086:  switch (encoding)
        -: 5087:  {
        5: 5088:    case JERRY_ENCODING_CESU8:
        -: 5089:    {
        5: 5090:      return lit_is_valid_cesu8_string (buffer_p, buffer_size);
        -: 5091:    }
        2: 5092:    case JERRY_ENCODING_UTF8:
        -: 5093:    {
        2: 5094:      return lit_is_valid_utf8_string (buffer_p, buffer_size, true);
        -: 5095:    }
    #####: 5096:    default:
        -: 5097:    {
    #####: 5098:      return false;
        -: 5099:    }
        -: 5100:  }
        -: 5101:} /* jerry_validate_string */
        -: 5102:
        -: 5103:/**
        -: 5104: * Allocate memory on the engine's heap.
        -: 5105: *
        -: 5106: * Note:
        -: 5107: *      This function may take away memory from the executed JavaScript code.
        -: 5108: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 5109: *      malloc), it should be used instead.
        -: 5110: *
        -: 5111: * @return allocated memory on success
        -: 5112: *         NULL otherwise
        -: 5113: */
        -: 5114:void *
    #####: 5115:jerry_heap_alloc (jerry_size_t size) /**< size of the memory block */
        -: 5116:{
        -: 5117:  jerry_assert_api_enabled ();
        -: 5118:
    #####: 5119:  return jmem_heap_alloc_block_null_on_error (size);
        -: 5120:} /* jerry_heap_alloc */
        -: 5121:
        -: 5122:/**
        -: 5123: * Free memory allocated on the engine's heap.
        -: 5124: */
        -: 5125:void
    #####: 5126:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 5127:                 jerry_size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 5128:{
        -: 5129:  jerry_assert_api_enabled ();
        -: 5130:
    #####: 5131:  jmem_heap_free_block (mem_p, size);
    #####: 5132:} /* jerry_heap_free */
        -: 5133:
        -: 5134:/**
        -: 5135: * Create an external engine context.
        -: 5136: *
        -: 5137: * @return the pointer to the context.
        -: 5138: */
        -: 5139:jerry_context_t *
    #####: 5140:jerry_context_alloc (jerry_size_t heap_size, /**< the size of heap */
        -: 5141:                     jerry_context_alloc_cb_t alloc, /**< the alloc function */
        -: 5142:                     void *cb_data_p) /**< the cb_data for alloc function */
        -: 5143:{
        -: 5144:  JERRY_UNUSED (heap_size);
        -: 5145:
        -: 5146:#if JERRY_EXTERNAL_CONTEXT
        -: 5147:
        -: 5148:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 5149:
        -: 5150:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5151:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 5152:
        -: 5153:  /* Minimum heap size is 1Kbyte. */
        -: 5154:  if (heap_size < 1024)
        -: 5155:  {
        -: 5156:    return NULL;
        -: 5157:  }
        -: 5158:
        -: 5159:  total_size += heap_size;
        -: 5160:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5161:
        -: 5162:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 5163:
        -: 5164:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 5165:
        -: 5166:  if (context_p == NULL)
        -: 5167:  {
        -: 5168:    return NULL;
        -: 5169:  }
        -: 5170:
        -: 5171:  memset (context_p, 0, total_size);
        -: 5172:
        -: 5173:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 5174:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 5175:
        -: 5176:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 5177:
        -: 5178:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5179:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 5180:  context_p->heap_size = heap_size;
        -: 5181:  byte_p += heap_size;
        -: 5182:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5183:
        -: 5184:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 5185:
        -: 5186:  JERRY_UNUSED (byte_p);
        -: 5187:  return context_p;
        -: 5188:
        -: 5189:#else /* !JERRY_EXTERNAL_CONTEXT */
        -: 5190:
        -: 5191:  JERRY_UNUSED (alloc);
        -: 5192:  JERRY_UNUSED (cb_data_p);
        -: 5193:
    #####: 5194:  return NULL;
        -: 5195:
        -: 5196:#endif /* JERRY_EXTERNAL_CONTEXT */
        -: 5197:} /* jerry_context_alloc */
        -: 5198:
        -: 5199:/**
        -: 5200: * When JERRY_VM_HALT is enabled, the callback passed to this function
        -: 5201: * is periodically called with the user_p argument. If interval is greater
        -: 5202: * than 1, the callback is only called at every interval ticks.
        -: 5203: */
        -: 5204:void
    #####: 5205:jerry_halt_handler (uint32_t interval, /**< interval of the function call */
        -: 5206:                    jerry_halt_cb_t callback, /**< periodically called user function */
        -: 5207:                    void *user_p) /**< pointer passed to the function */
        -: 5208:{
        -: 5209:#if JERRY_VM_HALT
    #####: 5210:  if (interval == 0)
        -: 5211:  {
    #####: 5212:    interval = 1;
        -: 5213:  }
        -: 5214:
    #####: 5215:  JERRY_CONTEXT (vm_exec_stop_frequency) = interval;
    #####: 5216:  JERRY_CONTEXT (vm_exec_stop_counter) = interval;
    #####: 5217:  JERRY_CONTEXT (vm_exec_stop_cb) = callback;
    #####: 5218:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
        -: 5219:#else /* !JERRY_VM_HALT */
        -: 5220:  JERRY_UNUSED (interval);
        -: 5221:  JERRY_UNUSED (callback);
        -: 5222:  JERRY_UNUSED (user_p);
        -: 5223:#endif /* JERRY_VM_HALT */
    #####: 5224:} /* jerry_halt_handler */
        -: 5225:
        -: 5226:/**
        -: 5227: * Get backtrace. The backtrace is an array of strings where
        -: 5228: * each string contains the position of the corresponding frame.
        -: 5229: * The array length is zero if the backtrace is not available.
        -: 5230: *
        -: 5231: * @return array value
        -: 5232: */
        -: 5233:jerry_value_t
    #####: 5234:jerry_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 5235:{
    #####: 5236:  return vm_get_backtrace (max_depth);
        -: 5237:} /* jerry_backtrace */
        -: 5238:
        -: 5239:/**
        -: 5240: * Low-level function to capture each backtrace frame.
        -: 5241: * The captured frame data is passed to a callback function.
        -: 5242: */
        -: 5243:void
    #####: 5244:jerry_backtrace_capture (jerry_backtrace_cb_t callback, /**< callback function */
        -: 5245:                         void *user_p) /**< user pointer passed to the callback function */
        -: 5246:{
    #####: 5247:  jerry_frame_t frame;
    #####: 5248:  vm_frame_ctx_t *context_p = JERRY_CONTEXT (vm_top_context_p);
        -: 5249:
    #####: 5250:  while (context_p != NULL)
        -: 5251:  {
    #####: 5252:    frame.context_p = context_p;
    #####: 5253:    frame.frame_type = JERRY_BACKTRACE_FRAME_JS;
        -: 5254:
    #####: 5255:    if (!callback (&frame, user_p))
        -: 5256:    {
    #####: 5257:      return;
        -: 5258:    }
        -: 5259:
    #####: 5260:    context_p = context_p->prev_context_p;
        -: 5261:  }
        -: 5262:} /* jerry_backtrace */
        -: 5263:
        -: 5264:/**
        -: 5265: * Returns with the type of the backtrace frame.
        -: 5266: *
        -: 5267: * @return frame type listed in jerry_frame_type_t
        -: 5268: */
        -: 5269:jerry_frame_type_t
    #####: 5270:jerry_frame_type (const jerry_frame_t *frame_p) /**< frame pointer */
        -: 5271:{
    #####: 5272:  return (jerry_frame_type_t) frame_p->frame_type;
        -: 5273:} /* jerry_frame_type */
        -: 5274:
        -: 5275:/**
        -: 5276: * Initialize and return with the location private field of a backtrace frame.
        -: 5277: *
        -: 5278: * @return pointer to the location private field - if the location is available,
        -: 5279: *         NULL - otherwise
        -: 5280: */
        -: 5281:const jerry_frame_location_t *
    #####: 5282:jerry_frame_location (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5283:{
        -: 5284:  JERRY_UNUSED (frame_p);
        -: 5285:
        -: 5286:#if JERRY_LINE_INFO
    #####: 5287:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5288:  {
    #####: 5289:    vm_frame_ctx_t *context_p = frame_p->context_p;
    #####: 5290:    const ecma_compiled_code_t *bytecode_header_p = context_p->shared_p->bytecode_header_p;
        -: 5291:
    #####: 5292:    if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO))
        -: 5293:    {
    #####: 5294:      return NULL;
        -: 5295:    }
        -: 5296:
    #####: 5297:    frame_p->location.source_name = ecma_get_source_name (bytecode_header_p);
        -: 5298:
    #####: 5299:    ecma_line_info_get (ecma_compiled_code_get_line_info (bytecode_header_p),
    #####: 5300:                        (uint32_t) (context_p->byte_code_p - context_p->byte_code_start_p),
        -: 5301:                        &frame_p->location);
        -: 5302:
    #####: 5303:    return &frame_p->location;
        -: 5304:  }
        -: 5305:#endif /* JERRY_LINE_INFO */
        -: 5306:
    #####: 5307:  return NULL;
        -: 5308:} /* jerry_frame_location */
        -: 5309:
        -: 5310:/**
        -: 5311: * Initialize and return with the called function private field of a backtrace frame.
        -: 5312: * The backtrace frame is created for running the code bound to this function.
        -: 5313: *
        -: 5314: * @return pointer to the called function - if the function is available,
        -: 5315: *         NULL - otherwise
        -: 5316: */
        -: 5317:const jerry_value_t *
    #####: 5318:jerry_frame_callee (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5319:{
    #####: 5320:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5321:  {
    #####: 5322:    vm_frame_ctx_t *context_p = frame_p->context_p;
        -: 5323:
    #####: 5324:    if (context_p->shared_p->function_object_p != NULL)
        -: 5325:    {
    #####: 5326:      frame_p->function = ecma_make_object_value (context_p->shared_p->function_object_p);
    #####: 5327:      return &frame_p->function;
        -: 5328:    }
        -: 5329:  }
        -: 5330:
    #####: 5331:  return NULL;
        -: 5332:} /* jerry_frame_callee */
        -: 5333:
        -: 5334:/**
        -: 5335: * Initialize and return with the 'this' binding private field of a backtrace frame.
        -: 5336: * The 'this' binding is a hidden value passed to the called function. As for arrow
        -: 5337: * functions, the 'this' binding is assigned at function creation.
        -: 5338: *
        -: 5339: * @return pointer to the 'this' binding - if the binding is available,
        -: 5340: *         NULL - otherwise
        -: 5341: */
        -: 5342:const jerry_value_t *
    #####: 5343:jerry_frame_this (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5344:{
    #####: 5345:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5346:  {
    #####: 5347:    frame_p->this_binding = frame_p->context_p->this_binding;
    #####: 5348:    return &frame_p->this_binding;
        -: 5349:  }
        -: 5350:
    #####: 5351:  return NULL;
        -: 5352:} /* jerry_frame_this */
        -: 5353:
        -: 5354:/**
        -: 5355: * Returns true, if the code bound to the backtrace frame is strict mode code.
        -: 5356: *
        -: 5357: * @return true - if strict mode code is bound to the frame,
        -: 5358: *         false - otherwise
        -: 5359: */
        -: 5360:bool
    #####: 5361:jerry_frame_is_strict (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5362:{
    #####: 5363:  return (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS
    #####: 5364:          && (frame_p->context_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0);
        -: 5365:} /* jerry_frame_is_strict */
        -: 5366:
        -: 5367:/**
        -: 5368: * Get the source name (usually a file name) of the currently executed script or the given function object
        -: 5369: *
        -: 5370: * Note: returned value must be freed with jerry_value_free, when it is no longer needed
        -: 5371: *
        -: 5372: * @return JS string constructed from
        -: 5373: *         - the currently executed function object's source name, if the given value is undefined
        -: 5374: *         - source name of the function object, if the given value is a function object
        -: 5375: *         - "<anonymous>", otherwise
        -: 5376: */
        -: 5377:jerry_value_t
    #####: 5378:jerry_source_name (const jerry_value_t value) /**< jerry api value */
        -: 5379:{
        -: 5380:#if JERRY_SOURCE_NAME
    #####: 5381:  if (ecma_is_value_undefined (value) && JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 5382:  {
    #####: 5383:    return ecma_copy_value (ecma_get_source_name (JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p));
        -: 5384:  }
        -: 5385:
    #####: 5386:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5387:
    #####: 5388:  if (script_value == JMEM_CP_NULL)
        -: 5389:  {
    #####: 5390:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 5391:  }
        -: 5392:
    #####: 5393:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5394:
    #####: 5395:  return ecma_copy_value (script_p->source_name);
        -: 5396:#else /* !JERRY_SOURCE_NAME */
        -: 5397:  JERRY_UNUSED (value);
        -: 5398:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 5399:#endif /* JERRY_SOURCE_NAME */
        -: 5400:} /* jerry_source_name */
        -: 5401:
        -: 5402:/**
        -: 5403: * Returns the user value assigned to a script / module / function.
        -: 5404: *
        -: 5405: * Note:
        -: 5406: *    This value is usually set by the parser when
        -: 5407: *    the JERRY_PARSE_HAS_USER_VALUE flag is passed.
        -: 5408: *
        -: 5409: * @return user value
        -: 5410: */
        -: 5411:jerry_value_t
    #####: 5412:jerry_source_user_value (const jerry_value_t value) /**< jerry api value */
        -: 5413:{
    #####: 5414:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5415:
    #####: 5416:  if (script_value == JMEM_CP_NULL)
        -: 5417:  {
    #####: 5418:    return ECMA_VALUE_UNDEFINED;
        -: 5419:  }
        -: 5420:
    #####: 5421:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5422:
    #####: 5423:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE))
        -: 5424:  {
    #####: 5425:    return ECMA_VALUE_UNDEFINED;
        -: 5426:  }
        -: 5427:
    #####: 5428:  return ecma_copy_value (CBC_SCRIPT_GET_USER_VALUE (script_p));
        -: 5429:} /* jerry_source_user_value */
        -: 5430:
        -: 5431:/**
        -: 5432: * Checks whether an ECMAScript code is compiled by eval
        -: 5433: * like (eval, new Function, jerry_eval, etc.) command.
        -: 5434: *
        -: 5435: * @return true, if code is compiled by eval like command
        -: 5436: *         false, otherwise
        -: 5437: */
        -: 5438:bool
    #####: 5439:jerry_function_is_dynamic (const jerry_value_t value) /**< jerry api value */
        -: 5440:{
    #####: 5441:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5442:
    #####: 5443:  if (script_value == JMEM_CP_NULL)
        -: 5444:  {
    #####: 5445:    return false;
        -: 5446:  }
        -: 5447:
    #####: 5448:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5449:
    #####: 5450:  return (script_p->refs_and_type & CBC_SCRIPT_IS_EVAL_CODE) != 0;
        -: 5451:} /* jerry_function_is_dynamic */
        -: 5452:
        -: 5453:/**
        -: 5454: * Returns a newly created source info structure corresponding to the passed script/module/function.
        -: 5455: *
        -: 5456: * @return a newly created source info, if at least one field is available, NULL otherwise
        -: 5457: */
        -: 5458:jerry_source_info_t *
    #####: 5459:jerry_source_info (const jerry_value_t value) /**< jerry api value */
        -: 5460:{
        -: 5461:  jerry_assert_api_enabled ();
        -: 5462:
        -: 5463:#if JERRY_FUNCTION_TO_STRING
    #####: 5464:  if (!ecma_is_value_object (value))
        -: 5465:  {
        -: 5466:    return NULL;
        -: 5467:  }
        -: 5468:
        -: 5469:  jerry_source_info_t source_info;
        -: 5470:
    #####: 5471:  source_info.enabled_fields = 0;
    #####: 5472:  source_info.source_code = ECMA_VALUE_UNDEFINED;
    #####: 5473:  source_info.function_arguments = ECMA_VALUE_UNDEFINED;
    #####: 5474:  source_info.source_range_start = 0;
    #####: 5475:  source_info.source_range_length = 0;
        -: 5476:
    #####: 5477:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 5478:  cbc_script_t *script_p = NULL;
        -: 5479:
        -: 5480:  while (true)
        -: 5481:  {
    #####: 5482:    switch (ecma_get_object_type (object_p))
        -: 5483:    {
    #####: 5484:      case ECMA_OBJECT_TYPE_CLASS:
        -: 5485:      {
    #####: 5486:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 5487:        const ecma_compiled_code_t *bytecode_p = NULL;
        -: 5488:
    #####: 5489:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 5490:        {
    #####: 5491:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 5492:        }
        -: 5493:#if JERRY_MODULE_SYSTEM
    #####: 5494:        else if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 5495:        {
    #####: 5496:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 5497:
    #####: 5498:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 5499:          {
    #####: 5500:            bytecode_p = module_p->u.compiled_code_p;
        -: 5501:          }
        -: 5502:        }
        -: 5503:#endif /* JERRY_MODULE_SYSTEM */
        -: 5504:
    #####: 5505:        if (bytecode_p == NULL)
        -: 5506:        {
        -: 5507:          return NULL;
        -: 5508:        }
        -: 5509:
    #####: 5510:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5511:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5512:        break;
        -: 5513:      }
    #####: 5514:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 5515:      {
        -: 5516:        const ecma_compiled_code_t *bytecode_p;
    #####: 5517:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
        -: 5518:
    #####: 5519:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5520:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5521:
    #####: 5522:        if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -: 5523:        {
    #####: 5524:          uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####: 5525:          uint8_t extended_info = *extended_info_p;
        -: 5526:
        -: 5527:#if JERRY_ESNEXT
    #####: 5528:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -: 5529:          {
    #####: 5530:            ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5531:          }
        -: 5532:#endif /* JERRY_ESNEXT */
        -: 5533:
    #####: 5534:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 5535:          {
    #####: 5536:            ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5537:
    #####: 5538:            ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5539:
    #####: 5540:            source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5541:            source_info.source_code = function_arguments;
    #####: 5542:            script_p = NULL;
        -: 5543:          }
        -: 5544:
    #####: 5545:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_RANGE;
    #####: 5546:          source_info.source_range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####: 5547:          source_info.source_range_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5548:        }
        -: 5549:
        -: 5550:        JERRY_ASSERT (script_p != NULL || (source_info.enabled_fields & JERRY_SOURCE_INFO_HAS_SOURCE_CODE));
        -: 5551:
    #####: 5552:        if (source_info.enabled_fields == 0 && (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -: 5553:        {
    #####: 5554:          ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5555:
    #####: 5556:          ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5557:
    #####: 5558:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_FUNCTION_ARGUMENTS;
    #####: 5559:          source_info.function_arguments = function_arguments;
        -: 5560:        }
        -: 5561:        break;
        -: 5562:      }
    #####: 5563:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 5564:      {
    #####: 5565:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 5566:
    #####: 5567:        object_p =
    #####: 5568:          ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_object_p->u.bound_function.target_function);
    #####: 5569:        continue;
        -: 5570:      }
        -: 5571:#if JERRY_ESNEXT
    #####: 5572:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 5573:      {
    #####: 5574:        ecma_value_t script_value = ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
    #####: 5575:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5576:        break;
        -: 5577:      }
        -: 5578:#endif /* JERRY_ESNEXT */
        -: 5579:      default:
        -: 5580:      {
        -: 5581:        return NULL;
        -: 5582:      }
        -: 5583:    }
        -: 5584:
        -: 5585:    break;
        -: 5586:  }
        -: 5587:
    #####: 5588:  jerry_source_info_t *source_info_p = jmem_heap_alloc_block_null_on_error (sizeof (jerry_source_info_t));
        -: 5589:
    #####: 5590:  if (source_info_p == NULL)
        -: 5591:  {
        -: 5592:    return NULL;
        -: 5593:  }
        -: 5594:
    #####: 5595:  if (script_p != NULL)
        -: 5596:  {
    #####: 5597:    ecma_ref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 5598:
    #####: 5599:    source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5600:    source_info.source_code = script_p->source_code;
        -: 5601:  }
        -: 5602:
        -: 5603:  JERRY_ASSERT (source_info.enabled_fields != 0);
        -: 5604:
    #####: 5605:  *source_info_p = source_info;
    #####: 5606:  return source_info_p;
        -: 5607:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5608:  JERRY_UNUSED (value);
    #####: 5609:  return NULL;
        -: 5610:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 5611:} /* jerry_source_info */
        -: 5612:
        -: 5613:/**
        -: 5614: * Frees the the source info structure returned by jerry_source_info.
        -: 5615: */
        -: 5616:void
    #####: 5617:jerry_source_info_free (jerry_source_info_t *source_info_p) /**< source info block */
        -: 5618:{
        -: 5619:  jerry_assert_api_enabled ();
        -: 5620:
        -: 5621:#if JERRY_FUNCTION_TO_STRING
    #####: 5622:  if (source_info_p != NULL)
        -: 5623:  {
    #####: 5624:    ecma_free_value (source_info_p->source_code);
    #####: 5625:    ecma_free_value (source_info_p->function_arguments);
    #####: 5626:    jmem_heap_free_block (source_info_p, sizeof (jerry_source_info_t));
        -: 5627:  }
        -: 5628:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5629:  JERRY_UNUSED (source_info_p);
        -: 5630:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 5631:} /* jerry_source_info_free */
        -: 5632:
        -: 5633:/**
        -: 5634: * Replaces the currently active realm with another realm.
        -: 5635: *
        -: 5636: * The replacement should be temporary, and the original realm must be
        -: 5637: * restored after the tasks are completed. During the replacement, the
        -: 5638: * realm must be referenced by the application (i.e. the gc must not
        -: 5639: * reclaim it). This is also true to the returned previously active
        -: 5640: * realm, so there is no need to free the value after the restoration.
        -: 5641: *
        -: 5642: * @return previous realm value - if the passed value is a realm
        -: 5643: *         exception - otherwise
        -: 5644: */
        -: 5645:jerry_value_t
    #####: 5646:jerry_set_realm (jerry_value_t realm_value) /**< jerry api value */
        -: 5647:{
        -: 5648:  jerry_assert_api_enabled ();
        -: 5649:
        -: 5650:#if JERRY_BUILTIN_REALMS
    #####: 5651:  if (ecma_is_value_object (realm_value))
        -: 5652:  {
    #####: 5653:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5654:
    #####: 5655:    if (ecma_builtin_is_global (object_p))
        -: 5656:    {
    #####: 5657:      ecma_global_object_t *previous_global_object_p = JERRY_CONTEXT (global_object_p);
    #####: 5658:      JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) object_p;
    #####: 5659:      return ecma_make_object_value ((ecma_object_t *) previous_global_object_p);
        -: 5660:    }
        -: 5661:  }
        -: 5662:
    #####: 5663:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PASSED_ARGUMENT_IS_NOT_A_REALM));
        -: 5664:#else /* !JERRY_BUILTIN_REALMS */
        -: 5665:  JERRY_UNUSED (realm_value);
    #####: 5666:  return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_REALM_IS_NOT_AVAILABLE));
        -: 5667:#endif /* JERRY_BUILTIN_REALMS */
        -: 5668:} /* jerry_set_realm */
        -: 5669:
        -: 5670:/**
        -: 5671: * Gets the 'this' binding of a realm
        -: 5672: *
        -: 5673: * @return type error - if realm_value is not a realm
        -: 5674: *         this value - otherwise
        -: 5675: */
        -: 5676:jerry_value_t
    #####: 5677:jerry_realm_this (jerry_value_t realm) /**< realm value */
        -: 5678:{
        -: 5679:  jerry_assert_api_enabled ();
        -: 5680:
        -: 5681:#if JERRY_BUILTIN_REALMS
    #####: 5682:  if (ecma_is_value_object (realm))
        -: 5683:  {
    #####: 5684:    ecma_object_t *object_p = ecma_get_object_from_value (realm);
        -: 5685:
    #####: 5686:    if (ecma_builtin_is_global (object_p))
        -: 5687:    {
    #####: 5688:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -: 5689:
    #####: 5690:      ecma_ref_object (ecma_get_object_from_value (global_object_p->this_binding));
    #####: 5691:      return global_object_p->this_binding;
        -: 5692:    }
        -: 5693:  }
        -: 5694:
        -: 5695:#else /* !JERRY_BUILTIN_REALMS */
    #####: 5696:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 5697:
    #####: 5698:  if (realm == ecma_make_object_value (global_object_p))
        -: 5699:  {
    #####: 5700:    ecma_ref_object (global_object_p);
    #####: 5701:    return realm;
        -: 5702:  }
        -: 5703:#endif /* JERRY_BUILTIN_REALMS */
        -: 5704:
    #####: 5705:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PASSED_ARGUMENT_IS_NOT_A_REALM));
        -: 5706:} /* jerry_realm_this */
        -: 5707:
        -: 5708:/**
        -: 5709: * Sets the 'this' binding of a realm
        -: 5710: *
        -: 5711: * This function must be called before executing any script on the realm.
        -: 5712: * Otherwise the operation is undefined.
        -: 5713: *
        -: 5714: * @return type error - if realm_value is not a realm or this_value is not object
        -: 5715: *         true - otherwise
        -: 5716: */
        -: 5717:jerry_value_t
    #####: 5718:jerry_realm_set_this (jerry_value_t realm, /**< realm value */
        -: 5719:                      jerry_value_t this_value) /**< this value */
        -: 5720:{
        -: 5721:  jerry_assert_api_enabled ();
        -: 5722:
        -: 5723:#if JERRY_BUILTIN_REALMS
    #####: 5724:  if (!ecma_is_value_object (this_value))
        -: 5725:  {
    #####: 5726:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SECOND_ARGUMENT_MUST_BE_AN_OBJECT));
        -: 5727:  }
        -: 5728:
    #####: 5729:  if (ecma_is_value_object (realm))
        -: 5730:  {
    #####: 5731:    ecma_object_t *object_p = ecma_get_object_from_value (realm);
        -: 5732:
    #####: 5733:    if (ecma_builtin_is_global (object_p))
        -: 5734:    {
    #####: 5735:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
    #####: 5736:      global_object_p->this_binding = this_value;
        -: 5737:
    #####: 5738:      ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, ecma_get_object_from_value (this_value));
        -: 5739:
    #####: 5740:      ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -: 5741:#if JERRY_ESNEXT
    #####: 5742:      global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -: 5743:#endif /* JERRY_ESNEXT */
    #####: 5744:      ecma_deref_object (global_lex_env_p);
    #####: 5745:      return ECMA_VALUE_TRUE;
        -: 5746:    }
        -: 5747:  }
        -: 5748:
    #####: 5749:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_FIRST_ARGUMENT_IS_NOT_A_REALM));
        -: 5750:#else /* !JERRY_BUILTIN_REALMS */
        -: 5751:  JERRY_UNUSED (realm);
        -: 5752:  JERRY_UNUSED (this_value);
    #####: 5753:  return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_REALM_IS_NOT_AVAILABLE));
        -: 5754:#endif /* JERRY_BUILTIN_REALMS */
        -: 5755:} /* jerry_realm_set_this */
        -: 5756:
        -: 5757:/**
        -: 5758: * Check if the given value is an ArrayBuffer object.
        -: 5759: *
        -: 5760: * @return true - if it is an ArrayBuffer object
        -: 5761: *         false - otherwise
        -: 5762: */
        -: 5763:bool
    #####: 5764:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 5765:{
        -: 5766:  jerry_assert_api_enabled ();
        -: 5767:
        -: 5768:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5769:  return ecma_is_arraybuffer (value);
        -: 5770:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5771:  JERRY_UNUSED (value);
    #####: 5772:  return false;
        -: 5773:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5774:} /* jerry_value_is_arraybuffer */
        -: 5775:
        -: 5776:/**
        -: 5777: * Creates an ArrayBuffer object with the given length (size).
        -: 5778: *
        -: 5779: * Notes:
        -: 5780: *      * the length is specified in bytes.
        -: 5781: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 5782: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5783: *
        -: 5784: * @return value of the constructed ArrayBuffer object
        -: 5785: */
        -: 5786:jerry_value_t
    #####: 5787:jerry_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 5788:                                               *   for the array buffer in bytes */
        -: 5789:{
        -: 5790:  jerry_assert_api_enabled ();
        -: 5791:
        -: 5792:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5793:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 5794:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5795:  JERRY_UNUSED (size);
    #####: 5796:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 5797:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5798:} /* jerry_arraybuffer */
        -: 5799:
        -: 5800:/**
        -: 5801: * Creates an ArrayBuffer object with user specified buffer.
        -: 5802: *
        -: 5803: * Notes:
        -: 5804: *     * the size is specified in bytes.
        -: 5805: *     * the buffer passed should be at least the specified bytes big.
        -: 5806: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5807: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 5808: *
        -: 5809: * @return value of the newly constructed array buffer object
        -: 5810: */
        -: 5811:jerry_value_t
    #####: 5812:jerry_arraybuffer_external (uint8_t *buffer_p, /**< the backing store used by the array buffer object */
        -: 5813:                            const jerry_length_t size, /**< size of the buffer in bytes */
        -: 5814:                            void *user_p) /**< user pointer assigned to the array buffer object */
        -: 5815:{
        -: 5816:  jerry_assert_api_enabled ();
        -: 5817:
        -: 5818:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5819:  ecma_object_t *arraybuffer_p;
        -: 5820:
    #####: 5821:  if (JERRY_UNLIKELY (size == 0))
        -: 5822:  {
    #####: 5823:    arraybuffer_p = ecma_arraybuffer_new_object (0);
        -: 5824:  }
        -: 5825:  else
        -: 5826:  {
    #####: 5827:    arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_ARRAY_BUFFER, size);
        -: 5828:
    #####: 5829:    ecma_arraybuffer_pointer_t *arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) arraybuffer_p;
    #####: 5830:    arraybuffer_pointer_p->arraybuffer_user_p = user_p;
        -: 5831:
    #####: 5832:    if (buffer_p != NULL)
        -: 5833:    {
    #####: 5834:      arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 5835:      arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 5836:    }
        -: 5837:  }
        -: 5838:
    #####: 5839:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 5840:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5841:  JERRY_UNUSED (size);
        -: 5842:  JERRY_UNUSED (buffer_p);
        -: 5843:  JERRY_UNUSED (user_p);
    #####: 5844:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 5845:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5846:} /* jerry_arraybuffer_external */
        -: 5847:
        -: 5848:/**
        -: 5849: * Check if the given value is a SharedArrayBuffer object.
        -: 5850: *
        -: 5851: * @return true - if it is a SharedArrayBuffer object
        -: 5852: *         false - otherwise
        -: 5853: */
        -: 5854:bool
    #####: 5855:jerry_value_is_shared_arraybuffer (const jerry_value_t value) /**< value to check if it is a SharedArrayBuffer */
        -: 5856:{
        -: 5857:  jerry_assert_api_enabled ();
        -: 5858:
    #####: 5859:  return ecma_is_shared_arraybuffer (value);
        -: 5860:} /* jerry_value_is_shared_arraybuffer */
        -: 5861:
        -: 5862:/**
        -: 5863: * Creates a SharedArrayBuffer object with the given length (size).
        -: 5864: *
        -: 5865: * Notes:
        -: 5866: *      * the length is specified in bytes.
        -: 5867: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 5868: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5869: *
        -: 5870: * @return value of the constructed SharedArrayBuffer object
        -: 5871: */
        -: 5872:jerry_value_t
    #####: 5873:jerry_shared_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 5874:                                                      *   for the shared array buffer in bytes */
        -: 5875:{
        -: 5876:  jerry_assert_api_enabled ();
        -: 5877:
        -: 5878:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 5879:  return jerry_return (ecma_make_object_value (ecma_shared_arraybuffer_new_object (size)));
        -: 5880:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5881:  JERRY_UNUSED (size);
    #####: 5882:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SHARED_ARRAYBUFFER_NOT_SUPPORTED));
        -: 5883:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5884:} /* jerry_shared_arraybuffer */
        -: 5885:
        -: 5886:/**
        -: 5887: * Creates a SharedArrayBuffer object with user specified buffer.
        -: 5888: *
        -: 5889: * Notes:
        -: 5890: *     * the size is specified in bytes.
        -: 5891: *     * the buffer passed should be at least the specified bytes big.
        -: 5892: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5893: *     * if the size is zero or buffer_p is a null pointer this will return an empty SharedArrayBuffer.
        -: 5894: *
        -: 5895: * @return value of the newly constructed shared array buffer object
        -: 5896: */
        -: 5897:jerry_value_t
    #####: 5898:jerry_shared_arraybuffer_external (uint8_t *buffer_p, /**< the backing store used by the
        -: 5899:                                                       *   shared array buffer object */
        -: 5900:                                   const jerry_length_t size, /**< size of the buffer in bytes */
        -: 5901:                                   void *user_p) /**< user pointer assigned to the
        -: 5902:                                                  *   shared array buffer object */
        -: 5903:{
        -: 5904:  jerry_assert_api_enabled ();
        -: 5905:
        -: 5906:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 5907:  ecma_object_t *shared_arraybuffer_p;
        -: 5908:
    #####: 5909:  if (JERRY_UNLIKELY (size == 0))
        -: 5910:  {
    #####: 5911:    shared_arraybuffer_p = ecma_shared_arraybuffer_new_object (0);
        -: 5912:  }
        -: 5913:  else
        -: 5914:  {
    #####: 5915:    shared_arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER, size);
        -: 5916:
    #####: 5917:    ecma_arraybuffer_pointer_t *shared_arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) shared_arraybuffer_p;
    #####: 5918:    shared_arraybuffer_pointer_p->arraybuffer_user_p = user_p;
        -: 5919:
    #####: 5920:    if (buffer_p != NULL)
        -: 5921:    {
    #####: 5922:      shared_arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 5923:      shared_arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 5924:    }
        -: 5925:  }
        -: 5926:
    #####: 5927:  return ecma_make_object_value (shared_arraybuffer_p);
        -: 5928:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5929:  JERRY_UNUSED (size);
        -: 5930:  JERRY_UNUSED (buffer_p);
        -: 5931:  JERRY_UNUSED (user_p);
    #####: 5932:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SHARED_ARRAYBUFFER_NOT_SUPPORTED));
        -: 5933:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5934:} /* jerry_shared_arraybuffer_external */
        -: 5935:
        -: 5936:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5937:
        -: 5938:/**
        -: 5939: * Allocate a backing store for an array buffer, ignores allocation fails.
        -: 5940: *
        -: 5941: * @return true on success,
        -: 5942: *         false otherwise
        -: 5943: */
        -: 5944:static bool
    #####: 5945:jerry_arraybuffer_allocate_buffer_no_throw (ecma_object_t *arraybuffer_p) /**< ArrayBuffer object */
        -: 5946:{
    #####: 5947:  JERRY_ASSERT (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED));
        -: 5948:
    #####: 5949:  if (ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_DETACHED)
        -: 5950:  {
    #####: 5951:    return false;
        -: 5952:  }
        -: 5953:
    #####: 5954:  return ecma_arraybuffer_allocate_buffer (arraybuffer_p) != ECMA_VALUE_ERROR;
        -: 5955:} /* jerry_arraybuffer_allocate_buffer_no_throw */
        -: 5956:
        -: 5957:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5958:
        -: 5959:/**
        -: 5960: * Copy bytes into the ArrayBuffer or SharedArrayBuffer from a buffer.
        -: 5961: *
        -: 5962: * Note:
        -: 5963: *     * returns 0, if the passed object is not an ArrayBuffer or SharedArrayBuffer
        -: 5964: *
        -: 5965: * @return number of bytes copied into the ArrayBuffer or SharedArrayBuffer.
        -: 5966: */
        -: 5967:jerry_length_t
    #####: 5968:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer or SharedArrayBuffer */
        -: 5969:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 5970:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 5971:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 5972:{
        -: 5973:  jerry_assert_api_enabled ();
        -: 5974:
        -: 5975:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5976:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 5977:  {
    #####: 5978:    return 0;
        -: 5979:  }
        -: 5980:
    #####: 5981:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
        -: 5982:
    #####: 5983:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 5984:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 5985:  {
    #####: 5986:    return 0;
        -: 5987:  }
        -: 5988:
    #####: 5989:  jerry_length_t length = ecma_arraybuffer_get_length (arraybuffer_p);
        -: 5990:
    #####: 5991:  if (offset >= length)
        -: 5992:  {
    #####: 5993:    return 0;
        -: 5994:  }
        -: 5995:
    #####: 5996:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 5997:
    #####: 5998:  if (copy_count > 0)
        -: 5999:  {
    #####: 6000:    lit_utf8_byte_t *buffer_p = ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 6001:
    #####: 6002:    memcpy ((void *) (buffer_p + offset), (void *) buf_p, copy_count);
        -: 6003:  }
        -: 6004:
    #####: 6005:  return copy_count;
        -: 6006:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6007:  JERRY_UNUSED (value);
        -: 6008:  JERRY_UNUSED (offset);
        -: 6009:  JERRY_UNUSED (buf_p);
        -: 6010:  JERRY_UNUSED (buf_size);
    #####: 6011:  return 0;
        -: 6012:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6013:} /* jerry_arraybuffer_write */
        -: 6014:
        -: 6015:/**
        -: 6016: * Copy bytes from a buffer into an ArrayBuffer or SharedArrayBuffer.
        -: 6017: *
        -: 6018: * Note:
        -: 6019: *     * if the object passed is not an ArrayBuffer or SharedArrayBuffer will return 0.
        -: 6020: *
        -: 6021: * @return number of bytes read from the ArrayBuffer.
        -: 6022: */
        -: 6023:jerry_length_t
    #####: 6024:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer or SharedArrayBuffer to read from */
        -: 6025:                        jerry_length_t offset, /**< start offset of the ArrayBuffer or SharedArrayBuffer */
        -: 6026:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 6027:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 6028:{
        -: 6029:  jerry_assert_api_enabled ();
        -: 6030:
        -: 6031:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6032:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6033:  {
    #####: 6034:    return 0;
        -: 6035:  }
        -: 6036:
    #####: 6037:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
        -: 6038:
    #####: 6039:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 6040:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 6041:  {
    #####: 6042:    return 0;
        -: 6043:  }
        -: 6044:
    #####: 6045:  jerry_length_t length = ecma_arraybuffer_get_length (arraybuffer_p);
        -: 6046:
    #####: 6047:  if (offset >= length)
        -: 6048:  {
    #####: 6049:    return 0;
        -: 6050:  }
        -: 6051:
    #####: 6052:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6053:
    #####: 6054:  if (copy_count > 0)
        -: 6055:  {
    #####: 6056:    lit_utf8_byte_t *buffer_p = ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 6057:
    #####: 6058:    memcpy ((void *) buf_p, (void *) (buffer_p + offset), copy_count);
        -: 6059:  }
        -: 6060:
    #####: 6061:  return copy_count;
        -: 6062:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6063:  JERRY_UNUSED (value);
        -: 6064:  JERRY_UNUSED (offset);
        -: 6065:  JERRY_UNUSED (buf_p);
        -: 6066:  JERRY_UNUSED (buf_size);
    #####: 6067:  return 0;
        -: 6068:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6069:} /* jerry_arraybuffer_read */
        -: 6070:
        -: 6071:/**
        -: 6072: * Get the length (size) of the ArrayBuffer or SharedArrayBuffer in bytes.
        -: 6073: *
        -: 6074: * Note:
        -: 6075: *     This is the 'byteLength' property of an ArrayBuffer or SharedArrayBuffer.
        -: 6076: *
        -: 6077: * @return the length of the ArrayBuffer in bytes.
        -: 6078: */
        -: 6079:jerry_length_t
    #####: 6080:jerry_arraybuffer_size (const jerry_value_t value) /**< ArrayBuffer or SharedArrayBuffer */
        -: 6081:{
        -: 6082:  jerry_assert_api_enabled ();
        -: 6083:
        -: 6084:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6085:  if (ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value))
        -: 6086:  {
    #####: 6087:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
    #####: 6088:    return ecma_arraybuffer_get_length (arraybuffer_p);
        -: 6089:  }
        -: 6090:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6091:  JERRY_UNUSED (value);
        -: 6092:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6093:  return 0;
        -: 6094:} /* jerry_arraybuffer_size */
        -: 6095:
        -: 6096:/**
        -: 6097: * Get a pointer for the start of the ArrayBuffer.
        -: 6098: *
        -: 6099: * Note:
        -: 6100: *    * This is a high-risk operation as the bounds are not checked
        -: 6101: *      when accessing the pointer elements.
        -: 6102: *
        -: 6103: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 6104: *         pointer is NULL if:
        -: 6105: *            - the parameter is not an ArrayBuffer
        -: 6106: *            - an external ArrayBuffer has been detached
        -: 6107: */
        -: 6108:uint8_t *
    #####: 6109:jerry_arraybuffer_data (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 6110:{
        -: 6111:  jerry_assert_api_enabled ();
        -: 6112:
        -: 6113:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6114:  if (!(ecma_is_arraybuffer (array_buffer) || ecma_is_shared_arraybuffer (array_buffer)))
        -: 6115:  {
    #####: 6116:    return NULL;
        -: 6117:  }
        -: 6118:
    #####: 6119:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (array_buffer);
        -: 6120:
    #####: 6121:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 6122:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 6123:  {
    #####: 6124:    return NULL;
        -: 6125:  }
        -: 6126:
    #####: 6127:  return (uint8_t *) ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 6128:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6129:  JERRY_UNUSED (array_buffer);
        -: 6130:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6131:
    #####: 6132:  return NULL;
        -: 6133:} /* jerry_arraybuffer_data */
        -: 6134:
        -: 6135:/**
        -: 6136: * Get if the ArrayBuffer is detachable.
        -: 6137: *
        -: 6138: * @return boolean value - if success
        -: 6139: *         value marked with error flag - otherwise
        -: 6140: */
        -: 6141:bool
    #####: 6142:jerry_arraybuffer_is_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 6143:{
        -: 6144:  jerry_assert_api_enabled ();
        -: 6145:
        -: 6146:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6147:  if (ecma_is_arraybuffer (value))
        -: 6148:  {
    #####: 6149:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6150:    return !ecma_arraybuffer_is_detached (buffer_p);
        -: 6151:  }
        -: 6152:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6153:  JERRY_UNUSED (value);
        -: 6154:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6155:  return false;
        -: 6156:} /* jerry_arraybuffer_is_detachable */
        -: 6157:
        -: 6158:/**
        -: 6159: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 6160: *
        -: 6161: * Note: if the ArrayBuffer has a separate data buffer, the free callback set by
        -: 6162: *       jerry_arraybuffer_set_allocation_callbacks is called for this buffer
        -: 6163: *
        -: 6164: * @return null value - if success
        -: 6165: *         value marked with error flag - otherwise
        -: 6166: */
        -: 6167:jerry_value_t
    #####: 6168:jerry_arraybuffer_detach (const jerry_value_t value) /**< ArrayBuffer */
        -: 6169:{
        -: 6170:  jerry_assert_api_enabled ();
        -: 6171:
        -: 6172:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6173:  if (ecma_is_arraybuffer (value))
        -: 6174:  {
    #####: 6175:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6176:    if (ecma_arraybuffer_detach (buffer_p))
        -: 6177:    {
    #####: 6178:      return ECMA_VALUE_NULL;
        -: 6179:    }
    #####: 6180:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARRAY_BUFFER_DETACHED));
        -: 6181:  }
        -: 6182:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6183:  JERRY_UNUSED (value);
        -: 6184:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6185:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_EXPECTED_AN_ARRAYBUFFER));
        -: 6186:} /* jerry_arraybuffer_detach */
        -: 6187:
        -: 6188:/**
        -: 6189: * Checks whether a buffer is currently allocated for an array buffer or typed array.
        -: 6190: *
        -: 6191: * @return true, if a buffer is allocated for an array buffer or typed array
        -: 6192: *         false, otherwise
        -: 6193: */
        -: 6194:bool
    #####: 6195:jerry_arraybuffer_has_buffer (const jerry_value_t value) /**< array buffer or typed array value */
        -: 6196:{
        -: 6197:  jerry_assert_api_enabled ();
        -: 6198:
        -: 6199:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6200:  if (!ecma_is_value_object (value))
        -: 6201:  {
    #####: 6202:    return false;
        -: 6203:  }
        -: 6204:
    #####: 6205:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 6206:
    #####: 6207:  if (ecma_object_is_typedarray (object_p))
        -: 6208:  {
    #####: 6209:    object_p = ecma_typedarray_get_arraybuffer (object_p);
        -: 6210:  }
    #####: 6211:  else if (!(ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####: 6212:             || ecma_object_is_shared_arraybuffer (object_p)))
        -: 6213:  {
    #####: 6214:    return false;
        -: 6215:  }
        -: 6216:
    #####: 6217:  return (ECMA_ARRAYBUFFER_GET_FLAGS (object_p) & ECMA_ARRAYBUFFER_ALLOCATED) != 0;
        -: 6218:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6219:  JERRY_UNUSED (value);
    #####: 6220:  return false;
        -: 6221:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6222:} /* jerry_arraybuffer_has_buffer */
        -: 6223:
        -: 6224:/**
        -: 6225: * Array buffers which size is less or equal than the limit passed to this function are allocated in
        -: 6226: * a single memory block. The allocator callbacks set by jerry_arraybuffer_set_allocation_callbacks
        -: 6227: * are not called for these array buffers. The default limit is 256 bytes.
        -: 6228: */
        -: 6229:void
    #####: 6230:jerry_arraybuffer_heap_allocation_limit (const jerry_length_t allocation_limit) /**< maximum size of
        -: 6231:                                                                                 *   compact allocation */
        -: 6232:{
        -: 6233:  jerry_assert_api_enabled ();
        -: 6234:
        -: 6235:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6236:  JERRY_CONTEXT (arraybuffer_compact_allocation_limit) = allocation_limit;
        -: 6237:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6238:  JERRY_UNUSED (allocation_limit);
        -: 6239:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6240:} /* jerry_arraybuffer_heap_allocation_limit */
        -: 6241:
        -: 6242:/**
        -: 6243: * Set callbacks for allocating and freeing backing stores for array buffer objects.
        -: 6244: */
        -: 6245:void
    #####: 6246:jerry_arraybuffer_allocator (jerry_arraybuffer_allocate_cb_t allocate_callback, /**< callback for allocating
        -: 6247:                                                                                 *   array buffer memory */
        -: 6248:                             jerry_arraybuffer_free_cb_t free_callback, /**< callback for freeing
        -: 6249:                                                                         *   array buffer memory */
        -: 6250:                             void *user_p) /**< user pointer passed to the callbacks */
        -: 6251:{
        -: 6252:  jerry_assert_api_enabled ();
        -: 6253:
        -: 6254:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6255:  JERRY_CONTEXT (arraybuffer_allocate_callback) = allocate_callback;
    #####: 6256:  JERRY_CONTEXT (arraybuffer_free_callback) = free_callback;
    #####: 6257:  JERRY_CONTEXT (arraybuffer_allocate_callback_user_p) = user_p;
        -: 6258:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6259:  JERRY_UNUSED (allocate_callback);
        -: 6260:  JERRY_UNUSED (free_callback);
        -: 6261:  JERRY_UNUSED (user_p);
        -: 6262:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6263:} /* jerry_arraybuffer_allocator */
        -: 6264:
        -: 6265:/**
        -: 6266: * DataView related functions
        -: 6267: */
        -: 6268:
        -: 6269:/**
        -: 6270: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 6271: *
        -: 6272: * Notes:
        -: 6273: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 6274: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 6275: *
        -: 6276: * @return value of the constructed DataView object - if success
        -: 6277: *         created error - otherwise
        -: 6278: */
        -: 6279:jerry_value_t
    #####: 6280:jerry_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 6281:                const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 6282:                const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 6283:{
        -: 6284:  jerry_assert_api_enabled ();
        -: 6285:
        -: 6286:#if JERRY_BUILTIN_DATAVIEW
    #####: 6287:  if (ecma_is_value_exception (array_buffer))
        -: 6288:  {
    #####: 6289:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 6290:  }
        -: 6291:
    #####: 6292:  ecma_value_t arguments_p[3] = { array_buffer,
    #####: 6293:                                  ecma_make_uint32_value (byte_offset),
    #####: 6294:                                  ecma_make_uint32_value (byte_length) };
    #####: 6295:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
    #####: 6296:  if (old_new_target_p == NULL)
        -: 6297:  {
    #####: 6298:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ECMA_BUILTIN_ID_DATAVIEW);
        -: 6299:  }
        -: 6300:
    #####: 6301:  ecma_value_t dataview_value = ecma_op_dataview_create (arguments_p, 3);
    #####: 6302:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6303:  return jerry_return (dataview_value);
        -: 6304:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6305:  JERRY_UNUSED (array_buffer);
        -: 6306:  JERRY_UNUSED (byte_offset);
        -: 6307:  JERRY_UNUSED (byte_length);
    #####: 6308:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_DATA_VIEW_NOT_SUPPORTED));
        -: 6309:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6310:} /* jerry_dataview */
        -: 6311:
        -: 6312:/**
        -: 6313: * Check if the given value is a DataView object.
        -: 6314: *
        -: 6315: * @return true - if it is a DataView object
        -: 6316: *         false - otherwise
        -: 6317: */
        -: 6318:bool
    #####: 6319:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 6320:{
        -: 6321:  jerry_assert_api_enabled ();
        -: 6322:
        -: 6323:#if JERRY_BUILTIN_DATAVIEW
    #####: 6324:  return ecma_is_dataview (value);
        -: 6325:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6326:  JERRY_UNUSED (value);
    #####: 6327:  return false;
        -: 6328:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6329:} /* jerry_value_is_dataview */
        -: 6330:
        -: 6331:/**
        -: 6332: * Get the underlying ArrayBuffer from a DataView.
        -: 6333: *
        -: 6334: * Additionally the byteLength and byteOffset properties are also returned
        -: 6335: * which were specified when the DataView was created.
        -: 6336: *
        -: 6337: * Note:
        -: 6338: *     the returned value must be freed with a jerry_value_free call
        -: 6339: *
        -: 6340: * @return ArrayBuffer of a DataView
        -: 6341: *         TypeError if the object is not a DataView.
        -: 6342: */
        -: 6343:jerry_value_t
    #####: 6344:jerry_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 6345:                       jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6346:                       jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6347:{
        -: 6348:  jerry_assert_api_enabled ();
        -: 6349:
        -: 6350:#if JERRY_BUILTIN_DATAVIEW
    #####: 6351:  if (ecma_is_value_exception (value))
        -: 6352:  {
    #####: 6353:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 6354:  }
        -: 6355:
    #####: 6356:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 6357:
    #####: 6358:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 6359:  {
    #####: 6360:    return ecma_create_exception_from_context ();
        -: 6361:  }
        -: 6362:
    #####: 6363:  if (byte_offset != NULL)
        -: 6364:  {
    #####: 6365:    *byte_offset = dataview_p->byte_offset;
        -: 6366:  }
        -: 6367:
    #####: 6368:  if (byte_length != NULL)
        -: 6369:  {
    #####: 6370:    *byte_length = dataview_p->header.u.cls.u3.length;
        -: 6371:  }
        -: 6372:
    #####: 6373:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 6374:  ecma_ref_object (arraybuffer_p);
        -: 6375:
    #####: 6376:  return ecma_make_object_value (arraybuffer_p);
        -: 6377:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6378:  JERRY_UNUSED (value);
        -: 6379:  JERRY_UNUSED (byte_offset);
        -: 6380:  JERRY_UNUSED (byte_length);
    #####: 6381:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_DATA_VIEW_NOT_SUPPORTED));
        -: 6382:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6383:} /* jerry_dataview_buffer */
        -: 6384:
        -: 6385:/**
        -: 6386: * TypedArray related functions
        -: 6387: */
        -: 6388:
        -: 6389:/**
        -: 6390: * Check if the given value is a TypedArray object.
        -: 6391: *
        -: 6392: * @return true - if it is a TypedArray object
        -: 6393: *         false - otherwise
        -: 6394: */
        -: 6395:bool
    #####: 6396:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 6397:{
        -: 6398:  jerry_assert_api_enabled ();
        -: 6399:
        -: 6400:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6401:  return ecma_is_typedarray (value);
        -: 6402:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6403:  JERRY_UNUSED (value);
    #####: 6404:  return false;
        -: 6405:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6406:} /* jerry_value_is_typedarray */
        -: 6407:
        -: 6408:#if JERRY_BUILTIN_TYPEDARRAY
        -: 6409:/**
        -: 6410: * TypedArray mapping type
        -: 6411: */
        -: 6412:typedef struct
        -: 6413:{
        -: 6414:  jerry_typedarray_type_t api_type; /**< api type */
        -: 6415:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 6416:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 6417:  uint8_t element_size_shift; /**< element size shift */
        -: 6418:} jerry_typedarray_mapping_t;
        -: 6419:
        -: 6420:/**
        -: 6421: * List of TypedArray mappings
        -: 6422: */
        -: 6423:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] = {
        -: 6424:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT)                                                      \
        -: 6425:  {                                                                                                       \
        -: 6426:    JERRY_TYPEDARRAY_##NAME, ECMA_BUILTIN_ID_##NAME##ARRAY_PROTOTYPE, ECMA_##LIT_NAME##_ARRAY, SIZE_SHIFT \
        -: 6427:  }
        -: 6428:
        -: 6429:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),       TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 6430:  TYPEDARRAY_ENTRY (INT8, INT8, 0),         TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 6431:  TYPEDARRAY_ENTRY (INT16, INT16, 1),       TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 6432:  TYPEDARRAY_ENTRY (INT32, INT32, 2),       TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 6433:#if JERRY_NUMBER_TYPE_FLOAT64
        -: 6434:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 6435:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 6436:#if JERRY_BUILTIN_BIGINT
        -: 6437:  TYPEDARRAY_ENTRY (BIGINT64, BIGINT64, 3), TYPEDARRAY_ENTRY (BIGUINT64, BIGUINT64, 3),
        -: 6438:#endif /* JERRY_BUILTIN_BIGINT */
        -: 6439:#undef TYPEDARRAY_ENTRY
        -: 6440:};
        -: 6441:
        -: 6442:/**
        -: 6443: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 6444: * information.
        -: 6445: *
        -: 6446: * @return true - if the TypedArray information was found
        -: 6447: *         false - if there is no such TypedArray type
        -: 6448: */
        -: 6449:static bool
    #####: 6450:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 6451:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 6452:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 6453:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 6454:{
    #####: 6455:  JERRY_ASSERT (prototype_id != NULL);
    #####: 6456:  JERRY_ASSERT (id != NULL);
    #####: 6457:  JERRY_ASSERT (element_size_shift != NULL);
        -: 6458:
    #####: 6459:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6460:  {
    #####: 6461:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 6462:    {
    #####: 6463:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 6464:      *id = jerry_typedarray_mappings[i].id;
    #####: 6465:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 6466:      return true;
        -: 6467:    }
        -: 6468:  }
        -: 6469:
    #####: 6470:  return false;
        -: 6471:} /* jerry_typedarray_find_by_type */
        -: 6472:
        -: 6473:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6474:
        -: 6475:/**
        -: 6476: * Create a TypedArray object with a given type and length.
        -: 6477: *
        -: 6478: * Notes:
        -: 6479: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6480: *      * byteOffset property will be set to 0.
        -: 6481: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 6482: *
        -: 6483: * @return - new TypedArray object
        -: 6484: */
        -: 6485:jerry_value_t
    #####: 6486:jerry_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6487:                  jerry_length_t length) /**< element count of the new TypedArray */
        -: 6488:{
        -: 6489:  jerry_assert_api_enabled ();
        -: 6490:
        -: 6491:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6492:  ecma_builtin_id_t prototype_id = 0;
    #####: 6493:  ecma_typedarray_type_t id = 0;
    #####: 6494:  uint8_t element_size_shift = 0;
        -: 6495:
    #####: 6496:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6497:  {
    #####: 6498:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_FOR_TYPEDARRAY));
        -: 6499:  }
        -: 6500:
    #####: 6501:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 6502:
    #####: 6503:  ecma_value_t array_value =
    #####: 6504:    ecma_typedarray_create_object_with_length (length, NULL, prototype_obj_p, element_size_shift, id);
        -: 6505:
    #####: 6506:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 6507:
    #####: 6508:  return array_value;
        -: 6509:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6510:  JERRY_UNUSED (type_name);
        -: 6511:  JERRY_UNUSED (length);
    #####: 6512:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6513:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6514:} /* jerry_typedarray */
        -: 6515:
        -: 6516:/**
        -: 6517: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6518: *
        -: 6519: * Notes:
        -: 6520: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6521: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 6522: *
        -: 6523: * @return - new TypedArray object
        -: 6524: */
        -: 6525:jerry_value_t
    #####: 6526:jerry_typedarray_with_buffer_span (jerry_typedarray_type_t type, /**< type of TypedArray to create */
        -: 6527:                                   const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 6528:                                   jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 6529:                                   jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 6530:{
        -: 6531:  jerry_assert_api_enabled ();
        -: 6532:
        -: 6533:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6534:  if (ecma_is_value_exception (arraybuffer))
        -: 6535:  {
    #####: 6536:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6537:  }
        -: 6538:
    #####: 6539:  ecma_builtin_id_t prototype_id = 0;
    #####: 6540:  ecma_typedarray_type_t id = 0;
    #####: 6541:  uint8_t element_size_shift = 0;
        -: 6542:
    #####: 6543:  if (!jerry_typedarray_find_by_type (type, &prototype_id, &id, &element_size_shift))
        -: 6544:  {
    #####: 6545:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_FOR_TYPEDARRAY));
        -: 6546:  }
        -: 6547:
    #####: 6548:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 6549:  {
    #####: 6550:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_NOT_ARRAY_BUFFER));
        -: 6551:  }
        -: 6552:
    #####: 6553:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 6554:  ecma_value_t arguments_p[3] = { arraybuffer, ecma_make_uint32_value (byte_offset), ecma_make_uint32_value (length) };
        -: 6555:
    #####: 6556:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 6557:  ecma_free_value (arguments_p[1]);
    #####: 6558:  ecma_free_value (arguments_p[2]);
        -: 6559:
    #####: 6560:  return jerry_return (array_value);
        -: 6561:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6562:  JERRY_UNUSED (type);
        -: 6563:  JERRY_UNUSED (arraybuffer);
        -: 6564:  JERRY_UNUSED (byte_offset);
        -: 6565:  JERRY_UNUSED (length);
    #####: 6566:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6567:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6568:} /* jerry_typedarray_with_buffer_span */
        -: 6569:
        -: 6570:/**
        -: 6571: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6572: *
        -: 6573: * Notes:
        -: 6574: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6575: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 6576: *
        -: 6577: * @return - new TypedArray object
        -: 6578: */
        -: 6579:jerry_value_t
    #####: 6580:jerry_typedarray_with_buffer (jerry_typedarray_type_t type, /**< type of TypedArray to create */
        -: 6581:                              const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 6582:{
        -: 6583:  jerry_assert_api_enabled ();
        -: 6584:
        -: 6585:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6586:  if (ecma_is_value_exception (arraybuffer))
        -: 6587:  {
    #####: 6588:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6589:  }
        -: 6590:
    #####: 6591:  jerry_length_t byte_length = jerry_arraybuffer_size (arraybuffer);
    #####: 6592:  return jerry_typedarray_with_buffer_span (type, arraybuffer, 0, byte_length);
        -: 6593:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6594:  JERRY_UNUSED (type);
        -: 6595:  JERRY_UNUSED (arraybuffer);
    #####: 6596:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6597:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6598:} /* jerry_typedarray_with_buffer */
        -: 6599:
        -: 6600:/**
        -: 6601: * Get the type of the TypedArray.
        -: 6602: *
        -: 6603: * @return - type of the TypedArray
        -: 6604: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 6605: */
        -: 6606:jerry_typedarray_type_t
    #####: 6607:jerry_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 6608:{
        -: 6609:  jerry_assert_api_enabled ();
        -: 6610:
        -: 6611:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6612:  if (!ecma_is_typedarray (value))
        -: 6613:  {
    #####: 6614:    return JERRY_TYPEDARRAY_INVALID;
        -: 6615:  }
        -: 6616:
    #####: 6617:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6618:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 6619:
    #####: 6620:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6621:  {
    #####: 6622:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 6623:    {
    #####: 6624:      return jerry_typedarray_mappings[i].api_type;
        -: 6625:    }
        -: 6626:  }
        -: 6627:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6628:  JERRY_UNUSED (value);
        -: 6629:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6630:
    #####: 6631:  return JERRY_TYPEDARRAY_INVALID;
        -: 6632:} /* jerry_typedarray_type */
        -: 6633:
        -: 6634:/**
        -: 6635: * Get the element count of the TypedArray.
        -: 6636: *
        -: 6637: * @return length of the TypedArray.
        -: 6638: */
        -: 6639:jerry_length_t
    #####: 6640:jerry_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 6641:{
        -: 6642:  jerry_assert_api_enabled ();
        -: 6643:
        -: 6644:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6645:  if (ecma_is_typedarray (value))
        -: 6646:  {
    #####: 6647:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6648:    return ecma_typedarray_get_length (array_p);
        -: 6649:  }
        -: 6650:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6651:  JERRY_UNUSED (value);
        -: 6652:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6653:
    #####: 6654:  return 0;
        -: 6655:} /* jerry_typedarray_length */
        -: 6656:
        -: 6657:/**
        -: 6658: * Get the underlying ArrayBuffer from a TypedArray.
        -: 6659: *
        -: 6660: * Additionally the byteLength and byteOffset properties are also returned
        -: 6661: * which were specified when the TypedArray was created.
        -: 6662: *
        -: 6663: * Note:
        -: 6664: *     the returned value must be freed with a jerry_value_free call
        -: 6665: *
        -: 6666: * @return ArrayBuffer of a TypedArray
        -: 6667: *         TypeError if the object is not a TypedArray.
        -: 6668: */
        -: 6669:jerry_value_t
    #####: 6670:jerry_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 6671:                         jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6672:                         jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6673:{
        -: 6674:  jerry_assert_api_enabled ();
        -: 6675:
        -: 6676:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6677:  if (!ecma_is_typedarray (value))
        -: 6678:  {
    #####: 6679:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_OBJECT_IS_NOT_A_TYPEDARRAY));
        -: 6680:  }
        -: 6681:
    #####: 6682:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6683:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 6684:
    #####: 6685:  if (byte_length != NULL)
        -: 6686:  {
    #####: 6687:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 6688:  }
        -: 6689:
    #####: 6690:  if (byte_offset != NULL)
        -: 6691:  {
    #####: 6692:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 6693:  }
        -: 6694:
    #####: 6695:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 6696:  ecma_ref_object (arraybuffer_p);
    #####: 6697:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 6698:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6699:  JERRY_UNUSED (value);
        -: 6700:  JERRY_UNUSED (byte_length);
        -: 6701:  JERRY_UNUSED (byte_offset);
    #####: 6702:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6703:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6704:} /* jerry_typedarray_buffer */
        -: 6705:
        -: 6706:/**
        -: 6707: * Parse the given input buffer as a JSON string. The behaviour is equivalent with the "JSON.parse(string)" JS
        -: 6708: * call. The input buffer can be encoded as either cesu-8 or utf-8, but it is the callers responsibility to make sure
        -: 6709: * the encoding is valid.
        -: 6710: *
        -: 6711: *
        -: 6712: * @return object value, or exception
        -: 6713: */
        -: 6714:jerry_value_t
    #####: 6715:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 6716:                  jerry_size_t string_size) /**< json string size */
        -: 6717:{
        -: 6718:  jerry_assert_api_enabled ();
        -: 6719:
        -: 6720:#if JERRY_BUILTIN_JSON
    #####: 6721:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 6722:
    #####: 6723:  if (ecma_is_value_undefined (ret_value))
        -: 6724:  {
    #####: 6725:    ret_value = jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_STRING_PARSE_ERROR));
        -: 6726:  }
        -: 6727:
    #####: 6728:  return jerry_return (ret_value);
        -: 6729:#else /* !JERRY_BUILTIN_JSON */
        -: 6730:  JERRY_UNUSED (string_p);
        -: 6731:  JERRY_UNUSED (string_size);
        -: 6732:
        -: 6733:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_NOT_SUPPORTED));
        -: 6734:#endif /* JERRY_BUILTIN_JSON */
        -: 6735:} /* jerry_json_parse */
        -: 6736:
        -: 6737:/**
        -: 6738: * Create a JSON string from a JavaScript value.
        -: 6739: *
        -: 6740: * The behaviour is equivalent with the "JSON.stringify(input_value)" JS call.
        -: 6741: *
        -: 6742: * Note:
        -: 6743: *      The returned value must be freed with jerry_value_free,
        -: 6744: *
        -: 6745: * @return - jerry_value_t containing a JSON string.
        -: 6746: *         - Error value if there was a problem during the stringification.
        -: 6747: */
        -: 6748:jerry_value_t
    #####: 6749:jerry_json_stringify (const jerry_value_t input_value) /**< a value to stringify */
        -: 6750:{
        -: 6751:  jerry_assert_api_enabled ();
        -: 6752:#if JERRY_BUILTIN_JSON
    #####: 6753:  if (ecma_is_value_exception (input_value))
        -: 6754:  {
    #####: 6755:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6756:  }
        -: 6757:
    #####: 6758:  ecma_value_t ret_value = ecma_builtin_json_stringify_no_opts (input_value);
        -: 6759:
    #####: 6760:  if (ecma_is_value_undefined (ret_value))
        -: 6761:  {
    #####: 6762:    ret_value = jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_STRINGIFY_ERROR));
        -: 6763:  }
        -: 6764:
    #####: 6765:  return jerry_return (ret_value);
        -: 6766:#else /* JERRY_BUILTIN_JSON */
        -: 6767:  JERRY_UNUSED (input_value);
        -: 6768:
        -: 6769:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_NOT_SUPPORTED));
        -: 6770:#endif /* JERRY_BUILTIN_JSON */
        -: 6771:} /* jerry_json_stringify */
        -: 6772:
        -: 6773:/**
        -: 6774: * Create a container type specified in jerry_container_type_t.
        -: 6775: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 6776: * inserted to the container.
        -: 6777: *
        -: 6778: * Note:
        -: 6779: *      The returned value must be freed with jerry_value_free
        -: 6780: * @return jerry_value_t representing a container with the given type.
        -: 6781: */
        -: 6782:jerry_value_t
    #####: 6783:jerry_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 6784:                 const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 6785:                 jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 6786:{
        -: 6787:  jerry_assert_api_enabled ();
        -: 6788:
        -: 6789:#if JERRY_BUILTIN_CONTAINER
    #####: 6790:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 6791:  {
    #####: 6792:    if (ecma_is_value_exception (arguments_list_p[i]))
        -: 6793:    {
    #####: 6794:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6795:    }
        -: 6796:  }
        -: 6797:
        -: 6798:  lit_magic_string_id_t lit_id;
        -: 6799:  ecma_builtin_id_t proto_id;
        -: 6800:  ecma_builtin_id_t ctor_id;
        -: 6801:
    #####: 6802:  switch (container_type)
        -: 6803:  {
    #####: 6804:    case JERRY_CONTAINER_TYPE_MAP:
        -: 6805:    {
    #####: 6806:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 6807:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 6808:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 6809:      break;
        -: 6810:    }
    #####: 6811:    case JERRY_CONTAINER_TYPE_SET:
        -: 6812:    {
    #####: 6813:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 6814:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 6815:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 6816:      break;
        -: 6817:    }
    #####: 6818:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 6819:    {
    #####: 6820:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 6821:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 6822:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 6823:      break;
        -: 6824:    }
    #####: 6825:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 6826:    {
    #####: 6827:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 6828:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 6829:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 6830:      break;
        -: 6831:    }
    #####: 6832:    default:
        -: 6833:    {
    #####: 6834:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_CONTAINER_TYPE));
        -: 6835:    }
        -: 6836:  }
    #####: 6837:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
        -: 6838:
    #####: 6839:  if (old_new_target_p == NULL)
        -: 6840:  {
    #####: 6841:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ctor_id);
        -: 6842:  }
        -: 6843:
    #####: 6844:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p, arguments_list_len, lit_id, proto_id);
        -: 6845:
    #####: 6846:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6847:  return jerry_return (container_value);
        -: 6848:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6849:  JERRY_UNUSED (arguments_list_p);
        -: 6850:  JERRY_UNUSED (arguments_list_len);
        -: 6851:  JERRY_UNUSED (container_type);
    #####: 6852:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 6853:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6854:} /* jerry_container */
        -: 6855:
        -: 6856:/**
        -: 6857: * Get the type of the given container object.
        -: 6858: *
        -: 6859: * @return Corresponding type to the given container object.
        -: 6860: */
        -: 6861:jerry_container_type_t
    #####: 6862:jerry_container_type (const jerry_value_t value) /**< the container object */
        -: 6863:{
        -: 6864:  jerry_assert_api_enabled ();
        -: 6865:
        -: 6866:#if JERRY_BUILTIN_CONTAINER
    #####: 6867:  if (ecma_is_value_object (value))
        -: 6868:  {
    #####: 6869:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6870:
    #####: 6871:    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_CONTAINER))
        -: 6872:    {
    #####: 6873:      switch (((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id)
        -: 6874:      {
    #####: 6875:        case LIT_MAGIC_STRING_MAP_UL:
        -: 6876:        {
    #####: 6877:          return JERRY_CONTAINER_TYPE_MAP;
        -: 6878:        }
    #####: 6879:        case LIT_MAGIC_STRING_SET_UL:
        -: 6880:        {
    #####: 6881:          return JERRY_CONTAINER_TYPE_SET;
        -: 6882:        }
    #####: 6883:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 6884:        {
    #####: 6885:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 6886:        }
    #####: 6887:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 6888:        {
    #####: 6889:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 6890:        }
    #####: 6891:        default:
        -: 6892:        {
    #####: 6893:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 6894:        }
        -: 6895:      }
        -: 6896:    }
        -: 6897:  }
        -: 6898:
        -: 6899:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6900:  JERRY_UNUSED (value);
        -: 6901:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 6902:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 6903:} /* jerry_container_type */
        -: 6904:
        -: 6905:/**
        -: 6906: * Return a new array containing elements from a Container or a Container Iterator.
        -: 6907: * Sets the boolean input value to `true` if the container object has key/value pairs.
        -: 6908: *
        -: 6909: * Note:
        -: 6910: *     the returned value must be freed with a jerry_value_free call
        -: 6911: *
        -: 6912: * @return an array of items for maps/sets or their iterators, error otherwise
        -: 6913: */
        -: 6914:jerry_value_t
    #####: 6915:jerry_container_to_array (jerry_value_t value, /**< the container or iterator object */
        -: 6916:                          bool *is_key_value_p) /**< [out] is key-value structure */
        -: 6917:{
        -: 6918:  jerry_assert_api_enabled ();
        -: 6919:
        -: 6920:#if JERRY_BUILTIN_CONTAINER
    #####: 6921:  if (!ecma_is_value_object (value))
        -: 6922:  {
    #####: 6923:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6924:  }
        -: 6925:
    #####: 6926:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6927:
    #####: 6928:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 6929:  {
    #####: 6930:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6931:  }
        -: 6932:
    #####: 6933:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 6934:
        -: 6935:  uint32_t entry_count;
        -: 6936:  uint8_t entry_size;
        -: 6937:
    #####: 6938:  uint32_t index = 0;
    #####: 6939:  uint8_t iterator_kind = ECMA_ITERATOR__COUNT;
        -: 6940:  ecma_value_t *start_p;
        -: 6941:
    #####: 6942:  *is_key_value_p = false;
        -: 6943:
    #####: 6944:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_MAP_ITERATOR
    #####: 6945:      || ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_SET_ITERATOR)
    #####: 6946:  {
    #####: 6947:    ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 6948:
    #####: 6949:    if (ecma_is_value_empty (iterated_value))
        -: 6950:    {
    #####: 6951:      return ecma_op_new_array_object_from_collection (ecma_new_collection (), false);
        -: 6952:    }
        -: 6953:
    #####: 6954:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
        -: 6955:
    #####: 6956:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####: 6957:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6958:    index = ext_obj_p->u.cls.u2.iterator_index;
        -: 6959:
    #####: 6960:    entry_size = ecma_op_container_entry_size (map_object_p->u.cls.u2.container_id);
    #####: 6961:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6962:
    #####: 6963:    iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
        -: 6964:  }
    #####: 6965:  else if (jerry_container_type (value) != JERRY_CONTAINER_TYPE_INVALID)
        -: 6966:  {
    #####: 6967:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, ext_obj_p->u.cls.u3.value);
    #####: 6968:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6969:    entry_size = ecma_op_container_entry_size (ext_obj_p->u.cls.u2.container_id);
        -: 6970:
    #####: 6971:    index = 0;
    #####: 6972:    iterator_kind = ECMA_ITERATOR_KEYS;
    #####: 6973:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6974:
    #####: 6975:    if (ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL
    #####: 6976:        || ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 6977:    {
    #####: 6978:      iterator_kind = ECMA_ITERATOR_ENTRIES;
        -: 6979:    }
        -: 6980:  }
        -: 6981:  else
        -: 6982:  {
    #####: 6983:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6984:  }
        -: 6985:
    #####: 6986:  *is_key_value_p = (iterator_kind == ECMA_ITERATOR_ENTRIES);
    #####: 6987:  ecma_collection_t *collection_buffer = ecma_new_collection ();
        -: 6988:
    #####: 6989:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 6990:  {
    #####: 6991:    ecma_value_t *entry_p = start_p + i;
        -: 6992:
    #####: 6993:    if (ecma_is_value_empty (*entry_p))
        -: 6994:    {
    #####: 6995:      continue;
        -: 6996:    }
        -: 6997:
    #####: 6998:    if (iterator_kind != ECMA_ITERATOR_VALUES)
        -: 6999:    {
    #####: 7000:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[0]));
        -: 7001:    }
        -: 7002:
    #####: 7003:    if (iterator_kind != ECMA_ITERATOR_KEYS)
        -: 7004:    {
    #####: 7005:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[1]));
        -: 7006:    }
        -: 7007:  }
    #####: 7008:  return ecma_op_new_array_object_from_collection (collection_buffer, false);
        -: 7009:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 7010:  JERRY_UNUSED (value);
        -: 7011:  JERRY_UNUSED (is_key_value_p);
    #####: 7012:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 7013:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7014:} /* jerry_container_to_array */
        -: 7015:
        -: 7016:/**
        -: 7017: * Perform container operation on the given operands (add, get, set, has, delete, size, clear).
        -: 7018: *
        -: 7019: * @return error - if argument is invalid or operation is unsuccessful or unsupported
        -: 7020: *                 result of the container operation - otherwise.
        -: 7021: */
        -: 7022:jerry_value_t
    #####: 7023:jerry_container_op (jerry_container_op_t operation, /**< container operation */
        -: 7024:                    jerry_value_t container, /**< container */
        -: 7025:                    const jerry_value_t *arguments, /**< list of arguments */
        -: 7026:                    uint32_t arguments_number) /**< number of arguments */
        -: 7027:{
        -: 7028:  jerry_assert_api_enabled ();
        -: 7029:#if JERRY_BUILTIN_CONTAINER
    #####: 7030:  if (!ecma_is_value_object (container))
        -: 7031:  {
    #####: 7032:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_IS_NOT_AN_OBJECT));
        -: 7033:  }
        -: 7034:
    #####: 7035:  ecma_object_t *obj_p = ecma_get_object_from_value (container);
        -: 7036:
    #####: 7037:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 7038:  {
    #####: 7039:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_IS_NOT_A_CONTAINER_OBJECT));
        -: 7040:  }
    #####: 7041:  uint16_t type = ((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id;
    #####: 7042:  ecma_extended_object_t *container_object_p = ecma_op_container_get_object (container, type);
        -: 7043:
    #####: 7044:  if (container_object_p == NULL)
        -: 7045:  {
    #####: 7046:    return ecma_create_exception_from_context ();
        -: 7047:  }
        -: 7048:
    #####: 7049:  switch (operation)
        -: 7050:  {
    #####: 7051:    case JERRY_CONTAINER_OP_ADD:
        -: 7052:    case JERRY_CONTAINER_OP_DELETE:
        -: 7053:    case JERRY_CONTAINER_OP_GET:
        -: 7054:    case JERRY_CONTAINER_OP_HAS:
        -: 7055:    {
    #####: 7056:      if (arguments_number != 1 || ecma_is_value_exception (arguments[0]))
        -: 7057:      {
    #####: 7058:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7059:      }
    #####: 7060:      break;
        -: 7061:    }
    #####: 7062:    case JERRY_CONTAINER_OP_SET:
        -: 7063:    {
    #####: 7064:      if (arguments_number != 2 || ecma_is_value_exception (arguments[0]) || ecma_is_value_exception (arguments[1]))
        -: 7065:      {
    #####: 7066:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7067:      }
    #####: 7068:      break;
        -: 7069:    }
    #####: 7070:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7071:    case JERRY_CONTAINER_OP_SIZE:
        -: 7072:    {
    #####: 7073:      if (arguments_number != 0)
        -: 7074:      {
    #####: 7075:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7076:      }
    #####: 7077:      break;
        -: 7078:    }
    #####: 7079:    default:
        -: 7080:    {
    #####: 7081:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7082:    }
        -: 7083:  }
        -: 7084:
        -: 7085:  jerry_value_t result;
        -: 7086:
    #####: 7087:  switch (operation)
        -: 7088:  {
    #####: 7089:    case JERRY_CONTAINER_OP_ADD:
        -: 7090:    {
    #####: 7091:      if (type == LIT_MAGIC_STRING_MAP_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7092:      {
    #####: 7093:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7094:      }
    #####: 7095:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[0], type);
    #####: 7096:      break;
        -: 7097:    }
    #####: 7098:    case JERRY_CONTAINER_OP_GET:
        -: 7099:    {
    #####: 7100:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7101:      {
    #####: 7102:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7103:      }
    #####: 7104:      result = ecma_op_container_get (container_object_p, arguments[0], type);
    #####: 7105:      break;
        -: 7106:    }
    #####: 7107:    case JERRY_CONTAINER_OP_SET:
        -: 7108:    {
    #####: 7109:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7110:      {
    #####: 7111:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7112:      }
    #####: 7113:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[1], type);
    #####: 7114:      break;
        -: 7115:    }
    #####: 7116:    case JERRY_CONTAINER_OP_HAS:
        -: 7117:    {
    #####: 7118:      result = ecma_op_container_has (container_object_p, arguments[0], type);
    #####: 7119:      break;
        -: 7120:    }
    #####: 7121:    case JERRY_CONTAINER_OP_DELETE:
        -: 7122:    {
    #####: 7123:      if (type == LIT_MAGIC_STRING_WEAKMAP_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7124:      {
    #####: 7125:        result = ecma_op_container_delete_weak (container_object_p, arguments[0], type);
    #####: 7126:        break;
        -: 7127:      }
    #####: 7128:      result = ecma_op_container_delete (container_object_p, arguments[0], type);
    #####: 7129:      break;
        -: 7130:    }
    #####: 7131:    case JERRY_CONTAINER_OP_SIZE:
        -: 7132:    {
    #####: 7133:      result = ecma_op_container_size (container_object_p);
    #####: 7134:      break;
        -: 7135:    }
    #####: 7136:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7137:    {
    #####: 7138:      if (type == LIT_MAGIC_STRING_WEAKSET_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7139:      {
    #####: 7140:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7141:      }
    #####: 7142:      result = ecma_op_container_clear (container_object_p);
    #####: 7143:      break;
        -: 7144:    }
    #####: 7145:    default:
        -: 7146:    {
    #####: 7147:      result = jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_UNSUPPORTED_CONTAINER_OPERATION));
    #####: 7148:      break;
        -: 7149:    }
        -: 7150:  }
    #####: 7151:  return jerry_return (result);
        -: 7152:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 7153:  JERRY_UNUSED (operation);
        -: 7154:  JERRY_UNUSED (container);
        -: 7155:  JERRY_UNUSED (arguments);
        -: 7156:  JERRY_UNUSED (arguments_number);
    #####: 7157:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 7158:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7159:} /* jerry_container_op */
        -: 7160:
        -: 7161:/**
        -: 7162: * @}
        -: 7163: */
