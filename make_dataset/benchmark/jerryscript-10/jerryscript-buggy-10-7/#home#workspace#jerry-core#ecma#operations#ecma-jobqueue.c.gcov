        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-jobqueue.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-jobqueue.h"
        -:   17:
        -:   18:#include "ecma-async-generator-object.h"
        -:   19:#include "ecma-function-object.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "ecma-objects.h"
        -:   23:#include "ecma-promise-object.h"
        -:   24:
        -:   25:#include "jcontext.h"
        -:   26:#include "opcodes.h"
        -:   27:#include "vm-stack.h"
        -:   28:
        -:   29:#if JERRY_ESNEXT
        -:   30:
        -:   31:/**
        -:   32: * Mask for job queue type.
        -:   33: */
        -:   34:#define ECMA_JOB_QUEURE_TYPE_MASK ((uintptr_t) 0x07)
        -:   35:
        -:   36:/** \addtogroup ecma ECMA
        -:   37: * @{
        -:   38: *
        -:   39: * \addtogroup ecmajobqueue ECMA Job Queue related routines
        -:   40: * @{
        -:   41: */
        -:   42:
        -:   43:/**
        -:   44: * Description of the PromiseReactionJob
        -:   45: */
        -:   46:typedef struct
        -:   47:{
        -:   48:  ecma_job_queue_item_t header; /**< job queue item header */
        -:   49:  ecma_value_t capability; /**< capability object */
        -:   50:  ecma_value_t handler; /**< handler function */
        -:   51:  ecma_value_t argument; /**< argument for the reaction */
        -:   52:} ecma_job_promise_reaction_t;
        -:   53:
        -:   54:/**
        -:   55: * Description of the PromiseAsyncReactionJob
        -:   56: */
        -:   57:typedef struct
        -:   58:{
        -:   59:  ecma_job_queue_item_t header; /**< job queue item header */
        -:   60:  ecma_value_t executable_object; /**< executable object */
        -:   61:  ecma_value_t argument; /**< argument for the reaction */
        -:   62:} ecma_job_promise_async_reaction_t;
        -:   63:
        -:   64:/**
        -:   65: * Description of the PromiseAsyncGeneratorJob
        -:   66: */
        -:   67:typedef struct
        -:   68:{
        -:   69:  ecma_job_queue_item_t header; /**< job queue item header */
        -:   70:  ecma_value_t executable_object; /**< executable object */
        -:   71:} ecma_job_promise_async_generator_t;
        -:   72:
        -:   73:/**
        -:   74: * Description of the PromiseResolveThenableJob
        -:   75: */
        -:   76:typedef struct
        -:   77:{
        -:   78:  ecma_job_queue_item_t header; /**< job queue item header */
        -:   79:  ecma_value_t promise; /**< promise to be resolved */
        -:   80:  ecma_value_t thenable; /**< thenable object */
        -:   81:  ecma_value_t then; /**< 'then' function */
        -:   82:} ecma_job_promise_resolve_thenable_t;
        -:   83:
        -:   84:/**
        -:   85: * Initialize the jobqueue.
        -:   86: */
        -:   87:void
        1:   88:ecma_job_queue_init (void)
        -:   89:{
        1:   90:  JERRY_CONTEXT (job_queue_head_p) = NULL;
        1:   91:  JERRY_CONTEXT (job_queue_tail_p) = NULL;
        1:   92:} /* ecma_job_queue_init */
        -:   93:
        -:   94:/**
        -:   95: * Get the type of the job.
        -:   96: *
        -:   97: * @return type of the job
        -:   98: */
        -:   99:static inline ecma_job_queue_item_type_t JERRY_ATTR_ALWAYS_INLINE
        -:  100:ecma_job_queue_get_type (ecma_job_queue_item_t *job_p) /**< the job */
        -:  101:{
    #####:  102:  return (ecma_job_queue_item_type_t) (job_p->next_and_type & ECMA_JOB_QUEURE_TYPE_MASK);
        -:  103:} /* ecma_job_queue_get_type */
        -:  104:
        -:  105:/**
        -:  106: * Get the next job of the job queue.
        -:  107: *
        -:  108: * @return next job
        -:  109: */
        -:  110:static inline ecma_job_queue_item_t *JERRY_ATTR_ALWAYS_INLINE
        -:  111:ecma_job_queue_get_next (ecma_job_queue_item_t *job_p) /**< the job */
        -:  112:{
    #####:  113:  return (ecma_job_queue_item_t *) (job_p->next_and_type & ~ECMA_JOB_QUEURE_TYPE_MASK);
        -:  114:} /* ecma_job_queue_get_next */
        -:  115:
        -:  116:/**
        -:  117: * Free the heap and the member of the PromiseReactionJob.
        -:  118: */
        -:  119:static void
    #####:  120:ecma_free_promise_reaction_job (ecma_job_promise_reaction_t *job_p) /**< points to the PromiseReactionJob */
        -:  121:{
    #####:  122:  JERRY_ASSERT (job_p != NULL);
        -:  123:
    #####:  124:  ecma_free_value (job_p->capability);
    #####:  125:  ecma_free_value (job_p->handler);
    #####:  126:  ecma_free_value (job_p->argument);
        -:  127:
    #####:  128:  jmem_heap_free_block (job_p, sizeof (ecma_job_promise_reaction_t));
    #####:  129:} /* ecma_free_promise_reaction_job */
        -:  130:
        -:  131:/**
        -:  132: * Free the heap and the member of the PromiseAsyncReactionJob.
        -:  133: */
        -:  134:static void
    #####:  135:ecma_free_promise_async_reaction_job (ecma_job_promise_async_reaction_t *job_p) /**< points to the
        -:  136:                                                                                 *   PromiseAsyncReactionJob */
        -:  137:{
    #####:  138:  JERRY_ASSERT (job_p != NULL);
        -:  139:
    #####:  140:  ecma_free_value (job_p->executable_object);
    #####:  141:  ecma_free_value (job_p->argument);
        -:  142:
    #####:  143:  jmem_heap_free_block (job_p, sizeof (ecma_job_promise_async_reaction_t));
    #####:  144:} /* ecma_free_promise_async_reaction_job */
        -:  145:
        -:  146:/**
        -:  147: * Free the heap and the member of the PromiseAsyncGeneratorJob.
        -:  148: */
        -:  149:static void
    #####:  150:ecma_free_promise_async_generator_job (ecma_job_promise_async_generator_t *job_p) /**< points to the
        -:  151:                                                                                   *   PromiseAsyncReactionJob */
        -:  152:{
    #####:  153:  JERRY_ASSERT (job_p != NULL);
        -:  154:
    #####:  155:  ecma_free_value (job_p->executable_object);
        -:  156:
    #####:  157:  jmem_heap_free_block (job_p, sizeof (ecma_job_promise_async_generator_t));
    #####:  158:} /* ecma_free_promise_async_generator_job */
        -:  159:
        -:  160:/**
        -:  161: * Free the heap and the member of the PromiseResolveThenableJob.
        -:  162: */
        -:  163:static void
    #####:  164:ecma_free_promise_resolve_thenable_job (ecma_job_promise_resolve_thenable_t *job_p) /**< points to the
        -:  165:                                                                                     *   PromiseResolveThenableJob */
        -:  166:{
    #####:  167:  JERRY_ASSERT (job_p != NULL);
        -:  168:
    #####:  169:  ecma_free_value (job_p->promise);
    #####:  170:  ecma_free_value (job_p->thenable);
    #####:  171:  ecma_free_value (job_p->then);
        -:  172:
    #####:  173:  jmem_heap_free_block (job_p, sizeof (ecma_job_promise_resolve_thenable_t));
    #####:  174:} /* ecma_free_promise_resolve_thenable_job */
        -:  175:
        -:  176:/**
        -:  177: * The processor for PromiseReactionJob.
        -:  178: *
        -:  179: * See also: ES2015 25.4.2.1
        -:  180: *
        -:  181: * @return ecma value
        -:  182: *         Returned value must be freed with ecma_free_value
        -:  183: */
        -:  184:static ecma_value_t
    #####:  185:ecma_process_promise_reaction_job (ecma_job_promise_reaction_t *job_p) /**< the job to be operated */
        -:  186:{
        -:  187:  /* 2. */
    #####:  188:  JERRY_ASSERT (
        -:  189:    ecma_object_class_is (ecma_get_object_from_value (job_p->capability), ECMA_OBJECT_CLASS_PROMISE_CAPABILITY));
        -:  190:  ecma_promise_capabality_t *capability_p;
    #####:  191:  capability_p = (ecma_promise_capabality_t *) ecma_get_object_from_value (job_p->capability);
        -:  192:
        -:  193:#if JERRY_PROMISE_CALLBACK
    #####:  194:  if (JERRY_UNLIKELY (JERRY_CONTEXT (promise_callback_filters) & JERRY_PROMISE_EVENT_FILTER_REACTION_JOB))
        -:  195:  {
        -:  196:    JERRY_ASSERT (JERRY_CONTEXT (promise_callback) != NULL);
    #####:  197:    JERRY_CONTEXT (promise_callback)
        -:  198:    (JERRY_PROMISE_EVENT_BEFORE_REACTION_JOB,
        -:  199:     capability_p->header.u.cls.u3.promise,
        -:  200:     ECMA_VALUE_UNDEFINED,
        -:  201:     JERRY_CONTEXT (promise_callback_user_p));
        -:  202:  }
        -:  203:#endif /* JERRY_PROMISE_CALLBACK */
        -:  204:
        -:  205:  /* 3. */
    #####:  206:  ecma_value_t handler = job_p->handler;
        -:  207:
    #####:  208:  JERRY_ASSERT (ecma_is_value_boolean (handler) || ecma_op_is_callable (handler));
        -:  209:
    #####:  210:  ecma_value_t handler_result;
        -:  211:
    #####:  212:  if (ecma_is_value_boolean (handler))
        -:  213:  {
        -:  214:    /* 4-5. True indicates "identity" and false indicates "thrower" */
    #####:  215:    handler_result = ecma_copy_value (job_p->argument);
        -:  216:  }
        -:  217:  else
        -:  218:  {
        -:  219:    /* 6. */
    #####:  220:    handler_result =
    #####:  221:      ecma_op_function_call (ecma_get_object_from_value (handler), ECMA_VALUE_UNDEFINED, &(job_p->argument), 1);
        -:  222:  }
        -:  223:
        -:  224:  ecma_value_t status;
        -:  225:
    #####:  226:  if (ecma_is_value_false (handler) || ECMA_IS_VALUE_ERROR (handler_result))
        -:  227:  {
    #####:  228:    if (ECMA_IS_VALUE_ERROR (handler_result))
        -:  229:    {
    #####:  230:      handler_result = jcontext_take_exception ();
        -:  231:    }
        -:  232:
        -:  233:    /* 7. */
    #####:  234:    status = ecma_op_function_call (ecma_get_object_from_value (capability_p->reject),
        -:  235:                                    ECMA_VALUE_UNDEFINED,
        -:  236:                                    &handler_result,
        -:  237:                                    1);
        -:  238:  }
        -:  239:  else
        -:  240:  {
        -:  241:    /* 8. */
    #####:  242:    status = ecma_op_function_call (ecma_get_object_from_value (capability_p->resolve),
        -:  243:                                    ECMA_VALUE_UNDEFINED,
        -:  244:                                    &handler_result,
        -:  245:                                    1);
        -:  246:  }
        -:  247:
    #####:  248:  ecma_free_value (handler_result);
        -:  249:
        -:  250:#if JERRY_PROMISE_CALLBACK
    #####:  251:  if (JERRY_UNLIKELY (JERRY_CONTEXT (promise_callback_filters) & JERRY_PROMISE_EVENT_FILTER_REACTION_JOB))
        -:  252:  {
        -:  253:    JERRY_ASSERT (JERRY_CONTEXT (promise_callback) != NULL);
    #####:  254:    JERRY_CONTEXT (promise_callback)
        -:  255:    (JERRY_PROMISE_EVENT_AFTER_REACTION_JOB,
        -:  256:     capability_p->header.u.cls.u3.promise,
        -:  257:     ECMA_VALUE_UNDEFINED,
        -:  258:     JERRY_CONTEXT (promise_callback_user_p));
        -:  259:  }
        -:  260:#endif /* JERRY_PROMISE_CALLBACK */
        -:  261:
    #####:  262:  ecma_free_promise_reaction_job (job_p);
        -:  263:
    #####:  264:  return status;
        -:  265:} /* ecma_process_promise_reaction_job */
        -:  266:
        -:  267:/**
        -:  268: * The processor for PromiseAsyncReactionJob.
        -:  269: *
        -:  270: * @return ecma value
        -:  271: *         Returned value must be freed with ecma_free_value
        -:  272: */
        -:  273:static ecma_value_t
    #####:  274:ecma_process_promise_async_reaction_job (ecma_job_promise_async_reaction_t *job_p) /**< the job to be operated */
        -:  275:{
        -:  276:#if JERRY_PROMISE_CALLBACK
    #####:  277:  if (JERRY_UNLIKELY (JERRY_CONTEXT (promise_callback_filters) & JERRY_PROMISE_EVENT_FILTER_ASYNC_REACTION_JOB))
        -:  278:  {
    #####:  279:    jerry_promise_event_type_t type = JERRY_PROMISE_EVENT_ASYNC_BEFORE_RESOLVE;
        -:  280:
    #####:  281:    if (ecma_job_queue_get_type (&job_p->header) == ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED)
        -:  282:    {
    #####:  283:      type = JERRY_PROMISE_EVENT_ASYNC_BEFORE_REJECT;
        -:  284:    }
        -:  285:
        -:  286:    JERRY_ASSERT (JERRY_CONTEXT (promise_callback) != NULL);
    #####:  287:    JERRY_CONTEXT (promise_callback)
        -:  288:    (type, job_p->executable_object, job_p->argument, JERRY_CONTEXT (promise_callback_user_p));
        -:  289:  }
        -:  290:#endif /* JERRY_PROMISE_CALLBACK */
        -:  291:
    #####:  292:  ecma_object_t *object_p = ecma_get_object_from_value (job_p->executable_object);
    #####:  293:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  294:
    #####:  295:  if (ecma_job_queue_get_type (&job_p->header) == ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED)
        -:  296:  {
    #####:  297:    if (!(executable_object_p->extended_object.u.cls.u2.executable_obj_flags
    #####:  298:          & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD))
        -:  299:    {
    #####:  300:      executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  301:    }
    #####:  302:    else if (ECMA_AWAIT_GET_STATE (executable_object_p) == ECMA_AWAIT_YIELD_RETURN)
        -:  303:    {
        -:  304:      /* Unlike other operations, return captures rejected promises as well. */
    #####:  305:      ECMA_AWAIT_CHANGE_STATE (executable_object_p, YIELD_RETURN, YIELD_OPERATION);
        -:  306:    }
        -:  307:    else
        -:  308:    {
    #####:  309:      if (ECMA_AWAIT_GET_STATE (executable_object_p) <= ECMA_AWAIT_YIELD_END)
        -:  310:      {
    #####:  311:        JERRY_ASSERT (ecma_is_value_object (executable_object_p->iterator));
    #####:  312:        executable_object_p->iterator = ECMA_VALUE_UNDEFINED;
        -:  313:
    #####:  314:        JERRY_ASSERT (executable_object_p->frame_ctx.stack_top_p[-1] == ECMA_VALUE_UNDEFINED
        -:  315:                      || ecma_is_value_object (executable_object_p->frame_ctx.stack_top_p[-1]));
    #####:  316:        executable_object_p->frame_ctx.stack_top_p--;
        -:  317:      }
    #####:  318:      else if (ECMA_AWAIT_GET_STATE (executable_object_p) == ECMA_AWAIT_FOR_CLOSE
    #####:  319:               && VM_GET_CONTEXT_TYPE (executable_object_p->frame_ctx.stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -:  320:      {
    #####:  321:        ecma_free_value (job_p->argument);
    #####:  322:        job_p->argument = ecma_copy_value (executable_object_p->frame_ctx.stack_top_p[-2]);
        -:  323:      }
        -:  324:
        -:  325:      /* Exception: Abort iterators, clear all status. */
    #####:  326:      executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= ECMA_AWAIT_CLEAR_MASK;
    #####:  327:      executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  328:    }
        -:  329:  }
        -:  330:
        -:  331:  ecma_value_t result;
        -:  332:
    #####:  333:  if (executable_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD)
        -:  334:  {
    #####:  335:    job_p->argument = ecma_await_continue (executable_object_p, job_p->argument);
        -:  336:
    #####:  337:    if (ECMA_IS_VALUE_ERROR (job_p->argument))
        -:  338:    {
    #####:  339:      job_p->argument = jcontext_take_exception ();
    #####:  340:      executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  341:    }
    #####:  342:    else if (executable_object_p->extended_object.u.cls.u2.executable_obj_flags
    #####:  343:             & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD)
        -:  344:    {
        -:  345:      /* Continue iteration. */
    #####:  346:      JERRY_ASSERT (job_p->argument == ECMA_VALUE_UNDEFINED);
    #####:  347:      result = ECMA_VALUE_UNDEFINED;
    #####:  348:      goto free_job;
        -:  349:    }
        -:  350:
    #####:  351:    if (ECMA_AWAIT_GET_STATE (executable_object_p) <= ECMA_AWAIT_YIELD_END)
        -:  352:    {
    #####:  353:      JERRY_ASSERT (ecma_is_value_object (executable_object_p->iterator));
    #####:  354:      executable_object_p->iterator = ECMA_VALUE_UNDEFINED;
        -:  355:
    #####:  356:      JERRY_ASSERT (executable_object_p->frame_ctx.stack_top_p[-1] == ECMA_VALUE_UNDEFINED
        -:  357:                    || ecma_is_value_object (executable_object_p->frame_ctx.stack_top_p[-1]));
    #####:  358:      executable_object_p->frame_ctx.stack_top_p--;
        -:  359:    }
        -:  360:
        -:  361:    /* Clear all status. */
    #####:  362:    executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= ECMA_AWAIT_CLEAR_MASK;
        -:  363:  }
        -:  364:
    #####:  365:  result = opfunc_resume_executable_object (executable_object_p, job_p->argument);
        -:  366:  /* Argument reference has been taken by opfunc_resume_executable_object. */
    #####:  367:  job_p->argument = ECMA_VALUE_UNDEFINED;
        -:  368:
    #####:  369:  const uint16_t expected_bits = (ECMA_EXECUTABLE_OBJECT_COMPLETED | ECMA_ASYNC_GENERATOR_CALLED);
    #####:  370:  if ((executable_object_p->extended_object.u.cls.u2.executable_obj_flags & expected_bits) == expected_bits)
        -:  371:  {
    #####:  372:    ecma_async_generator_finalize (executable_object_p, result);
    #####:  373:    result = ECMA_VALUE_UNDEFINED;
        -:  374:  }
        -:  375:
    #####:  376:free_job:
        -:  377:
        -:  378:#if JERRY_PROMISE_CALLBACK
    #####:  379:  if (JERRY_UNLIKELY (JERRY_CONTEXT (promise_callback_filters) & JERRY_PROMISE_EVENT_FILTER_ASYNC_REACTION_JOB))
        -:  380:  {
    #####:  381:    jerry_promise_event_type_t type = JERRY_PROMISE_EVENT_ASYNC_AFTER_RESOLVE;
        -:  382:
    #####:  383:    if (ecma_job_queue_get_type (&job_p->header) == ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED)
        -:  384:    {
    #####:  385:      type = JERRY_PROMISE_EVENT_ASYNC_AFTER_REJECT;
        -:  386:    }
        -:  387:
        -:  388:    JERRY_ASSERT (JERRY_CONTEXT (promise_callback) != NULL);
    #####:  389:    JERRY_CONTEXT (promise_callback)
        -:  390:    (type, job_p->executable_object, job_p->argument, JERRY_CONTEXT (promise_callback_user_p));
        -:  391:  }
        -:  392:#endif /* JERRY_PROMISE_CALLBACK */
        -:  393:
    #####:  394:  ecma_free_promise_async_reaction_job (job_p);
    #####:  395:  return result;
        -:  396:} /* ecma_process_promise_async_reaction_job */
        -:  397:
        -:  398:/**
        -:  399: * The processor for PromiseAsyncGeneratorJob.
        -:  400: *
        -:  401: * @return ecma value
        -:  402: *         Returned value must be freed with ecma_free_value
        -:  403: */
        -:  404:static ecma_value_t
    #####:  405:ecma_process_promise_async_generator_job (ecma_job_promise_async_generator_t *job_p) /**< the job to be operated */
        -:  406:{
    #####:  407:  ecma_object_t *object_p = ecma_get_object_from_value (job_p->executable_object);
        -:  408:
    #####:  409:  ecma_value_t result = ecma_async_generator_run ((vm_executable_object_t *) object_p);
        -:  410:
    #####:  411:  ecma_free_value (job_p->executable_object);
    #####:  412:  jmem_heap_free_block (job_p, sizeof (ecma_job_promise_async_generator_t));
    #####:  413:  return result;
        -:  414:} /* ecma_process_promise_async_generator_job */
        -:  415:
        -:  416:/**
        -:  417: * Process the PromiseResolveThenableJob.
        -:  418: *
        -:  419: * See also: ES2015 25.4.2.2
        -:  420: *
        -:  421: * @return ecma value
        -:  422: *         Returned value must be freed with ecma_free_value
        -:  423: */
        -:  424:static ecma_value_t
    #####:  425:ecma_process_promise_resolve_thenable_job (ecma_job_promise_resolve_thenable_t *job_p) /**< the job to be operated */
        -:  426:{
    #####:  427:  ecma_promise_object_t *promise_p = (ecma_promise_object_t *) ecma_get_object_from_value (job_p->promise);
        -:  428:
    #####:  429:  promise_p->header.u.cls.u1.promise_flags &= (uint8_t) ~ECMA_PROMISE_ALREADY_RESOLVED;
        -:  430:
    #####:  431:  ecma_value_t ret = ecma_promise_run_executor ((ecma_object_t *) promise_p, job_p->then, job_p->thenable);
        -:  432:
    #####:  433:  if (ECMA_IS_VALUE_ERROR (ret))
        -:  434:  {
    #####:  435:    ret = jcontext_take_exception ();
    #####:  436:    ecma_reject_promise_with_checks (job_p->promise, ret);
    #####:  437:    ecma_free_value (ret);
    #####:  438:    ret = ECMA_VALUE_UNDEFINED;
        -:  439:  }
        -:  440:
    #####:  441:  ecma_free_promise_resolve_thenable_job (job_p);
        -:  442:
    #####:  443:  return ret;
        -:  444:} /* ecma_process_promise_resolve_thenable_job */
        -:  445:
        -:  446:/**
        -:  447: * Enqueue a Promise job into the jobqueue.
        -:  448: */
        -:  449:static void
    #####:  450:ecma_enqueue_job (ecma_job_queue_item_t *job_p) /**< the job */
        -:  451:{
    #####:  452:  JERRY_ASSERT (job_p->next_and_type <= ECMA_JOB_QUEURE_TYPE_MASK);
        -:  453:
    #####:  454:  if (JERRY_CONTEXT (job_queue_head_p) == NULL)
        -:  455:  {
    #####:  456:    JERRY_CONTEXT (job_queue_head_p) = job_p;
    #####:  457:    JERRY_CONTEXT (job_queue_tail_p) = job_p;
        -:  458:  }
        -:  459:  else
        -:  460:  {
    #####:  461:    JERRY_ASSERT ((JERRY_CONTEXT (job_queue_tail_p)->next_and_type & ~ECMA_JOB_QUEURE_TYPE_MASK) == 0);
        -:  462:
    #####:  463:    JERRY_CONTEXT (job_queue_tail_p)->next_and_type |= (uintptr_t) job_p;
    #####:  464:    JERRY_CONTEXT (job_queue_tail_p) = job_p;
        -:  465:  }
    #####:  466:} /* ecma_enqueue_job */
        -:  467:
        -:  468:/**
        -:  469: * Enqueue a PromiseReactionJob into the job queue.
        -:  470: */
        -:  471:void
    #####:  472:ecma_enqueue_promise_reaction_job (ecma_value_t capability, /**< capability object */
        -:  473:                                   ecma_value_t handler, /**< handler function */
        -:  474:                                   ecma_value_t argument) /**< argument for the reaction */
        -:  475:{
        -:  476:  ecma_job_promise_reaction_t *job_p;
    #####:  477:  job_p = (ecma_job_promise_reaction_t *) jmem_heap_alloc_block (sizeof (ecma_job_promise_reaction_t));
    #####:  478:  job_p->header.next_and_type = ECMA_JOB_PROMISE_REACTION;
    #####:  479:  job_p->capability = ecma_copy_value (capability);
    #####:  480:  job_p->handler = ecma_copy_value (handler);
    #####:  481:  job_p->argument = ecma_copy_value (argument);
        -:  482:
    #####:  483:  ecma_enqueue_job (&job_p->header);
    #####:  484:} /* ecma_enqueue_promise_reaction_job */
        -:  485:
        -:  486:/**
        -:  487: * Enqueue a PromiseAsyncReactionJob into the job queue.
        -:  488: */
        -:  489:void
    #####:  490:ecma_enqueue_promise_async_reaction_job (ecma_value_t executable_object, /**< executable object */
        -:  491:                                         ecma_value_t argument, /**< argument */
        -:  492:                                         bool is_rejected) /**< is_fulfilled */
        -:  493:{
        -:  494:  ecma_job_promise_async_reaction_t *job_p;
    #####:  495:  job_p = (ecma_job_promise_async_reaction_t *) jmem_heap_alloc_block (sizeof (ecma_job_promise_async_reaction_t));
    #####:  496:  job_p->header.next_and_type =
    #####:  497:    (is_rejected ? ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED : ECMA_JOB_PROMISE_ASYNC_REACTION_FULFILLED);
    #####:  498:  job_p->executable_object = ecma_copy_value (executable_object);
    #####:  499:  job_p->argument = ecma_copy_value (argument);
        -:  500:
    #####:  501:  ecma_enqueue_job (&job_p->header);
    #####:  502:} /* ecma_enqueue_promise_async_reaction_job */
        -:  503:
        -:  504:/**
        -:  505: * Enqueue a PromiseAsyncGeneratorJob into the job queue.
        -:  506: */
        -:  507:void
    #####:  508:ecma_enqueue_promise_async_generator_job (ecma_value_t executable_object) /**< executable object */
        -:  509:{
        -:  510:  ecma_job_promise_async_generator_t *job_p;
    #####:  511:  job_p = (ecma_job_promise_async_generator_t *) jmem_heap_alloc_block (sizeof (ecma_job_promise_async_generator_t));
    #####:  512:  job_p->header.next_and_type = ECMA_JOB_PROMISE_ASYNC_GENERATOR;
    #####:  513:  job_p->executable_object = ecma_copy_value (executable_object);
        -:  514:
    #####:  515:  ecma_enqueue_job (&job_p->header);
    #####:  516:} /* ecma_enqueue_promise_async_generator_job */
        -:  517:
        -:  518:/**
        -:  519: * Enqueue a PromiseResolveThenableJob into the job queue.
        -:  520: */
        -:  521:void
    #####:  522:ecma_enqueue_promise_resolve_thenable_job (ecma_value_t promise, /**< promise to be resolved */
        -:  523:                                           ecma_value_t thenable, /**< thenable object */
        -:  524:                                           ecma_value_t then) /**< 'then' function */
        -:  525:{
    #####:  526:  JERRY_ASSERT (ecma_is_promise (ecma_get_object_from_value (promise)));
    #####:  527:  JERRY_ASSERT (ecma_is_value_object (thenable));
    #####:  528:  JERRY_ASSERT (ecma_op_is_callable (then));
        -:  529:
        -:  530:  ecma_job_promise_resolve_thenable_t *job_p;
    #####:  531:  job_p = (ecma_job_promise_resolve_thenable_t *) jmem_heap_alloc_block (sizeof (ecma_job_promise_resolve_thenable_t));
    #####:  532:  job_p->header.next_and_type = ECMA_JOB_PROMISE_THENABLE;
    #####:  533:  job_p->promise = ecma_copy_value (promise);
    #####:  534:  job_p->thenable = ecma_copy_value (thenable);
    #####:  535:  job_p->then = ecma_copy_value (then);
        -:  536:
    #####:  537:  ecma_enqueue_job (&job_p->header);
    #####:  538:} /* ecma_enqueue_promise_resolve_thenable_job */
        -:  539:
        -:  540:/**
        -:  541: * Process enqueued Promise jobs until the first thrown error or until the
        -:  542: * jobqueue becomes empty.
        -:  543: *
        -:  544: * @return result of the last processed job - if the jobqueue was non-empty,
        -:  545: *         undefined - otherwise.
        -:  546: */
        -:  547:ecma_value_t
    #####:  548:ecma_process_all_enqueued_jobs (void)
        -:  549:{
    #####:  550:  ecma_value_t ret = ECMA_VALUE_UNDEFINED;
        -:  551:
    #####:  552:  while (JERRY_CONTEXT (job_queue_head_p) != NULL)
        -:  553:  {
    #####:  554:    ecma_job_queue_item_t *job_p = JERRY_CONTEXT (job_queue_head_p);
    #####:  555:    JERRY_CONTEXT (job_queue_head_p) = ecma_job_queue_get_next (job_p);
        -:  556:
    #####:  557:    ecma_fast_free_value (ret);
        -:  558:
    #####:  559:    switch (ecma_job_queue_get_type (job_p))
        -:  560:    {
    #####:  561:      case ECMA_JOB_PROMISE_REACTION:
        -:  562:      {
    #####:  563:        ret = ecma_process_promise_reaction_job ((ecma_job_promise_reaction_t *) job_p);
    #####:  564:        break;
        -:  565:      }
    #####:  566:      case ECMA_JOB_PROMISE_ASYNC_REACTION_FULFILLED:
        -:  567:      case ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED:
        -:  568:      {
    #####:  569:        ret = ecma_process_promise_async_reaction_job ((ecma_job_promise_async_reaction_t *) job_p);
    #####:  570:        break;
        -:  571:      }
    #####:  572:      case ECMA_JOB_PROMISE_ASYNC_GENERATOR:
        -:  573:      {
    #####:  574:        ret = ecma_process_promise_async_generator_job ((ecma_job_promise_async_generator_t *) job_p);
    #####:  575:        break;
        -:  576:      }
    #####:  577:      default:
        -:  578:      {
    #####:  579:        JERRY_ASSERT (ecma_job_queue_get_type (job_p) == ECMA_JOB_PROMISE_THENABLE);
        -:  580:
    #####:  581:        ret = ecma_process_promise_resolve_thenable_job ((ecma_job_promise_resolve_thenable_t *) job_p);
    #####:  582:        break;
        -:  583:      }
        -:  584:    }
        -:  585:
    #####:  586:    if (ECMA_IS_VALUE_ERROR (ret))
        -:  587:    {
    #####:  588:      return ret;
        -:  589:    }
        -:  590:  }
        -:  591:
    #####:  592:  ecma_free_value (ret);
    #####:  593:  return ECMA_VALUE_UNDEFINED;
        -:  594:} /* ecma_process_all_enqueued_jobs */
        -:  595:
        -:  596:/**
        -:  597: * Release enqueued Promise jobs.
        -:  598: */
        -:  599:void
    #####:  600:ecma_free_all_enqueued_jobs (void)
        -:  601:{
    #####:  602:  while (JERRY_CONTEXT (job_queue_head_p) != NULL)
        -:  603:  {
    #####:  604:    ecma_job_queue_item_t *job_p = JERRY_CONTEXT (job_queue_head_p);
    #####:  605:    JERRY_CONTEXT (job_queue_head_p) = ecma_job_queue_get_next (job_p);
        -:  606:
    #####:  607:    switch (ecma_job_queue_get_type (job_p))
        -:  608:    {
    #####:  609:      case ECMA_JOB_PROMISE_REACTION:
        -:  610:      {
    #####:  611:        ecma_free_promise_reaction_job ((ecma_job_promise_reaction_t *) job_p);
    #####:  612:        break;
        -:  613:      }
    #####:  614:      case ECMA_JOB_PROMISE_ASYNC_REACTION_FULFILLED:
        -:  615:      case ECMA_JOB_PROMISE_ASYNC_REACTION_REJECTED:
        -:  616:      {
    #####:  617:        ecma_free_promise_async_reaction_job ((ecma_job_promise_async_reaction_t *) job_p);
    #####:  618:        break;
        -:  619:      }
    #####:  620:      case ECMA_JOB_PROMISE_ASYNC_GENERATOR:
        -:  621:      {
    #####:  622:        ecma_free_promise_async_generator_job ((ecma_job_promise_async_generator_t *) job_p);
    #####:  623:        break;
        -:  624:      }
    #####:  625:      default:
        -:  626:      {
    #####:  627:        JERRY_ASSERT (ecma_job_queue_get_type (job_p) == ECMA_JOB_PROMISE_THENABLE);
        -:  628:
    #####:  629:        ecma_free_promise_resolve_thenable_job ((ecma_job_promise_resolve_thenable_t *) job_p);
    #####:  630:        break;
        -:  631:      }
        -:  632:    }
        -:  633:  }
    #####:  634:} /* ecma_free_all_enqueued_jobs */
        -:  635:
        -:  636:/**
        -:  637: * @}
        -:  638: * @}
        -:  639: */
        -:  640:#endif /* JERRY_ESNEXT */
