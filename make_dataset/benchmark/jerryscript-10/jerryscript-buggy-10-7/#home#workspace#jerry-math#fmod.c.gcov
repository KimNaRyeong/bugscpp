        -:    0:Source:/home/workspace/jerry-math/fmod.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Developed at SunSoft, a Sun Microsystems, Inc. business.
        -:   21: *     Permission to use, copy, modify, and distribute this
        -:   22: *     software is freely granted, provided that this notice
        -:   23: *     is preserved.
        -:   24: *
        -:   25: *     @(#)e_fmod.c 1.3 95/01/18
        -:   26: */
        -:   27:
        -:   28:#include "jerry-math-internal.h"
        -:   29:
        -:   30:/* fmod(x,y)
        -:   31: * Return x mod y in exact arithmetic
        -:   32: *
        -:   33: * Method: shift and subtract
        -:   34: */
        -:   35:
        -:   36:static const double Zero[] = {
        -:   37:  0.0,
        -:   38:  -0.0,
        -:   39:};
        -:   40:
        -:   41:double
    #####:   42:fmod (double x, double y)
        -:   43:{
        -:   44:  int n, hx, hy, hz, ix, iy, sx, i;
        -:   45:  unsigned lx, ly, lz;
        -:   46:
    #####:   47:  hx = __HI (x); /* high word of x */
    #####:   48:  lx = __LO (x); /* low  word of x */
    #####:   49:  hy = __HI (y); /* high word of y */
    #####:   50:  ly = __LO (y); /* low  word of y */
    #####:   51:  sx = hx & 0x80000000; /* sign of x */
    #####:   52:  hx ^= sx; /* |x| */
    #####:   53:  hy &= 0x7fffffff; /* |y| */
        -:   54:
        -:   55:  /* purge off exception values */
    #####:   56:  if ((hy | ly) == 0 || (hx >= 0x7ff00000) || /* y = 0, or x not finite */
    #####:   57:      ((hy | ((ly | -ly) >> 31)) > 0x7ff00000)) /* or y is NaN */
        -:   58:  {
    #####:   59:    return NAN;
        -:   60:  }
    #####:   61:  if (hx <= hy)
        -:   62:  {
    #####:   63:    if ((hx < hy) || (lx < ly)) /* |x| < |y| return x */
        -:   64:    {
        -:   65:      return x;
        -:   66:    }
    #####:   67:    if (lx == ly) /* |x| = |y| return x * 0 */
        -:   68:    {
    #####:   69:      return Zero[(unsigned) sx >> 31];
        -:   70:    }
        -:   71:  }
        -:   72:
        -:   73:  /* determine ix = ilogb(x) */
    #####:   74:  if (hx < 0x00100000) /* subnormal x */
        -:   75:  {
    #####:   76:    if (hx == 0)
        -:   77:    {
    #####:   78:      for (ix = -1043, i = lx; i > 0; i <<= 1)
        -:   79:      {
    #####:   80:        ix -= 1;
        -:   81:      }
        -:   82:    }
        -:   83:    else
        -:   84:    {
    #####:   85:      for (ix = -1022, i = (hx << 11); i > 0; i <<= 1)
        -:   86:      {
    #####:   87:        ix -= 1;
        -:   88:      }
        -:   89:    }
        -:   90:  }
        -:   91:  else
        -:   92:  {
    #####:   93:    ix = (hx >> 20) - 1023;
        -:   94:  }
        -:   95:
        -:   96:  /* determine iy = ilogb(y) */
    #####:   97:  if (hy < 0x00100000) /* subnormal y */
        -:   98:  {
    #####:   99:    if (hy == 0)
        -:  100:    {
    #####:  101:      for (iy = -1043, i = ly; i > 0; i <<= 1)
        -:  102:      {
    #####:  103:        iy -= 1;
        -:  104:      }
        -:  105:    }
        -:  106:    else
        -:  107:    {
    #####:  108:      for (iy = -1022, i = (hy << 11); i > 0; i <<= 1)
        -:  109:      {
    #####:  110:        iy -= 1;
        -:  111:      }
        -:  112:    }
        -:  113:  }
        -:  114:  else
        -:  115:  {
    #####:  116:    iy = (hy >> 20) - 1023;
        -:  117:  }
        -:  118:
        -:  119:  /* set up {hx,lx}, {hy,ly} and align y to x */
    #####:  120:  if (ix >= -1022)
        -:  121:  {
    #####:  122:    hx = 0x00100000 | (0x000fffff & hx);
        -:  123:  }
        -:  124:  else /* subnormal x, shift x to normal */
        -:  125:  {
    #####:  126:    n = -1022 - ix;
    #####:  127:    if (n <= 31)
        -:  128:    {
    #####:  129:      hx = (((unsigned int) hx) << n) | (lx >> (32 - n));
    #####:  130:      lx <<= n;
        -:  131:    }
        -:  132:    else
        -:  133:    {
    #####:  134:      hx = lx << (n - 32);
    #####:  135:      lx = 0;
        -:  136:    }
        -:  137:  }
    #####:  138:  if (iy >= -1022)
        -:  139:  {
    #####:  140:    hy = 0x00100000 | (0x000fffff & hy);
        -:  141:  }
        -:  142:  else /* subnormal y, shift y to normal */
        -:  143:  {
    #####:  144:    n = -1022 - iy;
    #####:  145:    if (n <= 31)
        -:  146:    {
    #####:  147:      hy = (((unsigned int) hy) << n) | (ly >> (32 - n));
    #####:  148:      ly <<= n;
        -:  149:    }
        -:  150:    else
        -:  151:    {
    #####:  152:      hy = ly << (n - 32);
    #####:  153:      ly = 0;
        -:  154:    }
        -:  155:  }
        -:  156:
        -:  157:  /* fix point fmod */
    #####:  158:  n = ix - iy;
    #####:  159:  while (n--)
        -:  160:  {
    #####:  161:    hz = hx - hy;
    #####:  162:    lz = lx - ly;
    #####:  163:    if (lx < ly)
        -:  164:    {
    #####:  165:      hz -= 1;
        -:  166:    }
    #####:  167:    if (hz < 0)
        -:  168:    {
    #####:  169:      hx = hx + hx + (lx >> 31);
    #####:  170:      lx = lx + lx;
        -:  171:    }
        -:  172:    else
        -:  173:    {
    #####:  174:      if ((hz | lz) == 0) /* return sign(x) * 0 */
        -:  175:      {
    #####:  176:        return Zero[(unsigned) sx >> 31];
        -:  177:      }
    #####:  178:      hx = hz + hz + (lz >> 31);
    #####:  179:      lx = lz + lz;
        -:  180:    }
        -:  181:  }
    #####:  182:  hz = hx - hy;
    #####:  183:  lz = lx - ly;
    #####:  184:  if (lx < ly)
        -:  185:  {
    #####:  186:    hz -= 1;
        -:  187:  }
    #####:  188:  if (hz >= 0)
        -:  189:  {
    #####:  190:    hx = hz;
    #####:  191:    lx = lz;
        -:  192:  }
        -:  193:
        -:  194:  /* convert back to floating value and restore the sign */
    #####:  195:  if ((hx | lx) == 0) /* return sign(x) * 0 */
        -:  196:  {
    #####:  197:    return Zero[(unsigned) sx >> 31];
        -:  198:  }
    #####:  199:  while (hx < 0x00100000) /* normalize x */
        -:  200:  {
    #####:  201:    hx = hx + hx + (lx >> 31);
    #####:  202:    lx = lx + lx;
    #####:  203:    iy -= 1;
        -:  204:  }
        -:  205:
        -:  206:  double_accessor ret;
    #####:  207:  if (iy >= -1022) /* normalize output */
        -:  208:  {
    #####:  209:    hx = ((hx - 0x00100000) | ((iy + 1023) << 20));
    #####:  210:    ret.as_int.hi = hx | sx;
    #####:  211:    ret.as_int.lo = lx;
        -:  212:  }
        -:  213:  else /* subnormal output */
        -:  214:  {
    #####:  215:    n = -1022 - iy;
    #####:  216:    if (n <= 20)
        -:  217:    {
    #####:  218:      lx = (lx >> n) | ((unsigned) hx << (32 - n));
    #####:  219:      hx >>= n;
        -:  220:    }
    #####:  221:    else if (n <= 31)
        -:  222:    {
    #####:  223:      lx = (hx << (32 - n)) | (lx >> n);
    #####:  224:      hx = sx;
        -:  225:    }
        -:  226:    else
        -:  227:    {
    #####:  228:      lx = hx >> (n - 32);
    #####:  229:      hx = sx;
        -:  230:    }
    #####:  231:    ret.as_int.hi = hx | sx;
    #####:  232:    ret.as_int.lo = lx;
        -:  233:  }
    #####:  234:  return ret.dbl; /* exact output */
        -:  235:} /* fmod */
