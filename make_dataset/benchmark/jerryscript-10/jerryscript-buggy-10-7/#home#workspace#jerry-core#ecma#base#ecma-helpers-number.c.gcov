        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-number.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers-number.h"
        -:   17:
        -:   18:#include <math.h>
        -:   19:
        -:   20:#include "ecma-conversion.h"
        -:   21:
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:/** \addtogroup ecma ECMA
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   28: * @{
        -:   29: */
        -:   30:
        -:   31:JERRY_STATIC_ASSERT (sizeof (ecma_value_t) == sizeof (ecma_integer_value_t),
        -:   32:                     size_of_ecma_value_t_must_be_equal_to_the_size_of_ecma_integer_value_t);
        -:   33:
        -:   34:JERRY_STATIC_ASSERT (ECMA_DIRECT_SHIFT == ECMA_VALUE_SHIFT + 1, currently_directly_encoded_values_has_one_extra_flag);
        -:   35:
        -:   36:JERRY_STATIC_ASSERT (((1 << (ECMA_DIRECT_SHIFT - 1)) | ECMA_TYPE_DIRECT) == ECMA_DIRECT_TYPE_SIMPLE_VALUE,
        -:   37:                     currently_directly_encoded_values_start_after_direct_type_simple_value);
        -:   38:
        -:   39:JERRY_STATIC_ASSERT (sizeof (ecma_number_t) == sizeof (ecma_binary_num_t),
        -:   40:                     size_of_ecma_number_t_must_be_equal_to_binary_representation);
        -:   41:
        -:   42:/**
        -:   43: * Convert an ecma-number to it's binary representation.
        -:   44: *
        -:   45: * @return binary representation
        -:   46: */
        -:   47:extern inline ecma_binary_num_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        1:   48:ecma_number_to_binary (ecma_number_t number) /**< ecma number */
        -:   49:{
        -:   50:  ecma_number_accessor_t f;
       20:   51:  f.as_number = number;
        -:   52:
       20:   53:  return f.as_binary;
        -:   54:} /* ecma_number_to_binary */
        -:   55:
        -:   56:/**
        -:   57: * Convert a binary representation to the corresponding ecma-number.
        -:   58: *
        -:   59: * @return ecma-number
        -:   60: */
        -:   61:extern inline ecma_number_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:   62:ecma_number_from_binary (ecma_binary_num_t binary) /**< binary representation */
        -:   63:{
        -:   64:  ecma_number_accessor_t f;
        2:   65:  f.as_binary = binary;
        -:   66:
        2:   67:  return f.as_number;
        -:   68:} /* ecma_number_from_binary */
        -:   69:
        -:   70:/**
        -:   71: * Check signedness of the binary number.
        -:   72: *
        -:   73: * @return true  - if sign bit is set
        -:   74: *         false - otherwise
        -:   75: */
        -:   76:extern inline bool JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:   77:ecma_number_sign (ecma_binary_num_t binary) /**< binary representation */
        -:   78:{
    #####:   79:  return (binary & ECMA_NUMBER_SIGN_BIT) != 0;
        -:   80:} /* ecma_number_sign */
        -:   81:
        -:   82:/**
        -:   83: * Get biased exponent field of the binary number.
        -:   84: *
        -:   85: * @return unsigned integer value of the biased exponent field
        -:   86: */
        -:   87:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:   88:ecma_number_biased_exp (ecma_binary_num_t binary) /**< binary representation */
        -:   89:{
        6:   90:  return (uint32_t) ((binary & ~ECMA_NUMBER_SIGN_BIT) >> ECMA_NUMBER_FRACTION_WIDTH);
        -:   91:} /* ecma_number_biased_exp */
        -:   92:
        -:   93:/**
        -:   94: * Get fraction field of the binary number.
        -:   95: *
        -:   96: * @return unsigned integer value of the fraction field
        -:   97: */
        -:   98:extern inline uint64_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:   99:ecma_number_fraction (ecma_binary_num_t binary) /**< binary representation */
        -:  100:{
        6:  101:  return binary & ((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1);
        -:  102:} /* ecma_number_fraction */
        -:  103:
        -:  104:/**
        -:  105: * Packing sign, fraction and biased exponent to ecma-number
        -:  106: *
        -:  107: * @return ecma-number with specified sign, biased_exponent and fraction
        -:  108: */
        -:  109:ecma_number_t
        2:  110:ecma_number_create (bool sign, /**< sign */
        -:  111:                    uint32_t biased_exp, /**< biased exponent */
        -:  112:                    uint64_t fraction) /**< fraction */
        -:  113:{
        2:  114:  JERRY_ASSERT ((biased_exp & ~((1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)) == 0);
        2:  115:  JERRY_ASSERT ((fraction & ~((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1)) == 0);
        -:  116:
        2:  117:  ecma_binary_num_t binary = biased_exp;
        2:  118:  binary <<= ECMA_NUMBER_FRACTION_WIDTH;
        -:  119:
        2:  120:  binary |= fraction;
        -:  121:
        2:  122:  if (sign)
        -:  123:  {
    #####:  124:    binary |= ECMA_NUMBER_SIGN_BIT;
        -:  125:  }
        -:  126:
        2:  127:  return ecma_number_from_binary (binary);
        -:  128:} /* ecma_number_create */
        -:  129:
        -:  130:/**
        -:  131: * Check if ecma-number is NaN
        -:  132: *
        -:  133: * @return true - if biased exponent is filled with 1 bits and
        -:  134:                  fraction is filled with anything but not all zero bits,
        -:  135: *         false - otherwise
        -:  136: */
        -:  137:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        3:  138:ecma_number_is_nan (ecma_number_t num) /**< ecma-number */
        -:  139:{
        6:  140:  bool is_nan = (num != num);
        -:  141:
        -:  142:#ifndef JERRY_NDEBUG
        -:  143:  /* IEEE-754 2008, 3.4, a */
        6:  144:  ecma_binary_num_t binary = ecma_number_to_binary (num);
        6:  145:  bool is_nan_exponent = (ecma_number_biased_exp (binary) == (1 << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1);
        6:  146:  bool is_nan_fraction = (ecma_number_fraction (binary) > 0);
        -:  147:
        6:  148:  bool is_nan_ieee754 = is_nan_exponent && is_nan_fraction;
        6:  149:  JERRY_ASSERT (is_nan == is_nan_ieee754);
        -:  150:#endif /* !JERRY_NDEBUG */
        -:  151:
        6:  152:  return is_nan;
        -:  153:} /* ecma_number_is_nan */
        -:  154:
        -:  155:/**
        -:  156: * Make a NaN.
        -:  157: *
        -:  158: * @return NaN value
        -:  159: */
        -:  160:extern inline ecma_number_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:  161:ecma_number_make_nan (void)
        -:  162:{
        -:  163:  ecma_number_accessor_t f;
    #####:  164:  f.as_binary = ECMA_NUMBER_BINARY_QNAN;
        -:  165:
    #####:  166:  return f.as_number;
        -:  167:} /* ecma_number_make_nan */
        -:  168:
        -:  169:/**
        -:  170: * Make an Infinity.
        -:  171: *
        -:  172: * @return if !sign - +Infinity value,
        -:  173: *         else - -Infinity value.
        -:  174: */
        -:  175:extern inline ecma_number_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        1:  176:ecma_number_make_infinity (bool sign) /**< sign of the value */
        -:  177:{
        -:  178:  ecma_number_accessor_t f;
        1:  179:  f.as_binary = ECMA_NUMBER_BINARY_INF;
        -:  180:
        1:  181:  if (sign)
        -:  182:  {
    #####:  183:    f.as_binary |= ECMA_NUMBER_SIGN_BIT;
        -:  184:  }
        -:  185:
        1:  186:  return f.as_number;
        -:  187:} /* ecma_number_make_infinity */
        -:  188:
        -:  189:/**
        -:  190: * Check if ecma-number is negative
        -:  191: *
        -:  192: * @return true - if sign bit of ecma-number is set
        -:  193: *         false - otherwise
        -:  194: */
        -:  195:extern inline bool JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        3:  196:ecma_number_is_negative (ecma_number_t num) /**< ecma-number */
        -:  197:{
        3:  198:  JERRY_ASSERT (!ecma_number_is_nan (num));
        -:  199:
        3:  200:  return (ecma_number_to_binary (num) & ECMA_NUMBER_SIGN_BIT) != 0;
        -:  201:} /* ecma_number_is_negative */
        -:  202:
        -:  203:/**
        -:  204: * Check if ecma-number is zero
        -:  205: *
        -:  206: * @return true - if fraction is zero and biased exponent is zero,
        -:  207: *         false - otherwise
        -:  208: */
        -:  209:extern inline bool JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        8:  210:ecma_number_is_zero (ecma_number_t num) /**< ecma-number */
        -:  211:{
        8:  212:  bool is_zero = (num == ECMA_NUMBER_ZERO);
        -:  213:
        -:  214:#ifndef JERRY_NDEBUG
        8:  215:  bool is_zero_ieee754 = ((ecma_number_to_binary (num) & ~ECMA_NUMBER_SIGN_BIT) == 0);
        8:  216:  JERRY_ASSERT (is_zero == is_zero_ieee754);
        -:  217:#endif /* !JERRY_NDEBUG */
        -:  218:
        8:  219:  return is_zero;
        -:  220:} /* ecma_number_is_zero */
        -:  221:
        -:  222:/**
        -:  223: * Check if number is infinity
        -:  224: *
        -:  225: * @return true - if biased exponent is filled with 1 bits and
        -:  226: *                fraction is filled with zero bits,
        -:  227: *         false - otherwise
        -:  228: */
        -:  229:extern inline bool JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        2:  230:ecma_number_is_infinity (ecma_number_t num) /**< ecma-number */
        -:  231:{
        2:  232:  return (ecma_number_to_binary (num) & ~ECMA_NUMBER_SIGN_BIT) == ECMA_NUMBER_BINARY_INF;
        -:  233:} /* ecma_number_is_infinity */
        -:  234:
        -:  235:/**
        -:  236: * Check if number is finite
        -:  237: *
        -:  238: * @return true  - if number is finite
        -:  239: *         false - if number is NaN or infinity
        -:  240: */
        -:  241:extern inline bool JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        2:  242:ecma_number_is_finite (ecma_number_t num) /**< ecma-number */
        -:  243:{
        -:  244:#if defined(__GNUC__) || defined(__clang__)
        2:  245:  return __builtin_isfinite (num);
        -:  246:#elif defined(_WIN32)
        -:  247:  return isfinite (num);
        -:  248:#else /* !(defined(__GNUC__) || defined(__clang__) || defined(_WIN32)) */
        -:  249:  return !ecma_number_is_nan (num) && !ecma_number_is_infinity (num);
        -:  250:#endif /* defined (__GNUC__) || defined (__clang__) */
        -:  251:} /* ecma_number_is_finite */
        -:  252:
        -:  253:/**
        -:  254: * Get previous representable ecma-number
        -:  255: *
        -:  256: * @return maximum ecma-number that is less compared to passed argument
        -:  257: */
        -:  258:ecma_number_t JERRY_ATTR_CONST
    #####:  259:ecma_number_get_prev (ecma_number_t num) /**< ecma-number */
        -:  260:{
        -:  261:#if defined(__GNUC__) || defined(__clang__)
    #####:  262:  return __builtin_nextafter (num, -INFINITY);
        -:  263:#else /* !defined (__GNUC__) && !defined (__clang__) */
        -:  264:  JERRY_ASSERT (!ecma_number_is_nan (num));
        -:  265:  ecma_binary_num_t binary = ecma_number_to_binary (num);
        -:  266:
        -:  267:  /* If -Infinity, return self */
        -:  268:  if (binary == (ECMA_NUMBER_SIGN_BIT | ECMA_NUMBER_BINARY_INF))
        -:  269:  {
        -:  270:    return num;
        -:  271:  }
        -:  272:
        -:  273:  /* If +0.0, return -0.0 */
        -:  274:  if (binary == ECMA_NUMBER_BINARY_ZERO)
        -:  275:  {
        -:  276:    return -num;
        -:  277:  }
        -:  278:
        -:  279:  if (ecma_number_sign (binary))
        -:  280:  {
        -:  281:    return ecma_number_from_binary (binary + 1);
        -:  282:  }
        -:  283:
        -:  284:  return ecma_number_from_binary (binary - 1);
        -:  285:#endif /* !defined (__GNUC__) && !defined (__clang__) */
        -:  286:} /* ecma_number_get_prev */
        -:  287:
        -:  288:/**
        -:  289: * Get next representable ecma-number
        -:  290: *
        -:  291: * @return minimum ecma-number that is greater compared to passed argument
        -:  292: */
        -:  293:ecma_number_t JERRY_ATTR_CONST
    #####:  294:ecma_number_get_next (ecma_number_t num) /**< ecma-number */
        -:  295:{
        -:  296:#if defined(__GNUC__) || defined(__clang__)
    #####:  297:  return __builtin_nextafter (num, INFINITY);
        -:  298:#else /* !defined (__GNUC__) && !defined (__clang__) */
        -:  299:  JERRY_ASSERT (!ecma_number_is_nan (num));
        -:  300:  ecma_binary_num_t binary = ecma_number_to_binary (num);
        -:  301:
        -:  302:  /* If +Infinity, return self */
        -:  303:  if (binary == ECMA_NUMBER_BINARY_INF)
        -:  304:  {
        -:  305:    return num;
        -:  306:  }
        -:  307:
        -:  308:  /* If -0.0, return +0.0 */
        -:  309:  if (binary == (ECMA_NUMBER_SIGN_BIT | ECMA_NUMBER_BINARY_ZERO))
        -:  310:  {
        -:  311:    return -num;
        -:  312:  }
        -:  313:
        -:  314:  if (ecma_number_sign (binary))
        -:  315:  {
        -:  316:    return ecma_number_from_binary (binary - 1);
        -:  317:  }
        -:  318:
        -:  319:  return ecma_number_from_binary (binary + 1);
        -:  320:#endif /* !defined (__GNUC__) && !defined (__clang__) */
        -:  321:} /* ecma_number_get_next */
        -:  322:
        -:  323:/**
        -:  324: * Truncate fractional part of the number
        -:  325: *
        -:  326: * @return integer part of the number
        -:  327: */
        -:  328:ecma_number_t JERRY_ATTR_CONST
    #####:  329:ecma_number_trunc (ecma_number_t num) /**< ecma-number */
        -:  330:{
    #####:  331:  JERRY_ASSERT (!ecma_number_is_nan (num));
        -:  332:
    #####:  333:  ecma_binary_num_t binary = ecma_number_to_binary (num);
    #####:  334:  uint32_t exponent = ecma_number_biased_exp (binary);
        -:  335:
    #####:  336:  if (exponent < ECMA_NUMBER_EXPONENT_BIAS)
        -:  337:  {
    #####:  338:    return ECMA_NUMBER_ZERO;
        -:  339:  }
        -:  340:
    #####:  341:  uint32_t unbiased_exp = exponent - ECMA_NUMBER_EXPONENT_BIAS;
        -:  342:
    #####:  343:  if (unbiased_exp >= ECMA_NUMBER_FRACTION_WIDTH)
        -:  344:  {
    #####:  345:    return num;
        -:  346:  }
        -:  347:
    #####:  348:  binary &= ~((1ull << (ECMA_NUMBER_FRACTION_WIDTH - unbiased_exp)) - 1);
    #####:  349:  return ecma_number_from_binary (binary);
        -:  350:} /* ecma_number_trunc */
        -:  351:
        -:  352:/**
        -:  353: * Calculate remainder of division of two numbers,
        -:  354: * as specified in ECMA-262 v5, 11.5.3, item 6.
        -:  355: *
        -:  356: * Note:
        -:  357: *      operands shouldn't contain NaN, Infinity, or zero.
        -:  358: *
        -:  359: * @return number - calculated remainder.
        -:  360: */
        -:  361:ecma_number_t JERRY_ATTR_CONST
    #####:  362:ecma_number_remainder (ecma_number_t left_num, /**< left operand */
        -:  363:                       ecma_number_t right_num) /**< right operand */
        -:  364:{
    #####:  365:  JERRY_ASSERT (ecma_number_is_finite (left_num) && !ecma_number_is_zero (left_num));
    #####:  366:  JERRY_ASSERT (ecma_number_is_finite (right_num) && !ecma_number_is_zero (right_num));
        -:  367:
    #####:  368:  const ecma_number_t q = ecma_number_trunc (left_num / right_num);
    #####:  369:  ecma_number_t r = left_num - right_num * q;
        -:  370:
    #####:  371:  if (ecma_number_is_zero (r) && ecma_number_is_negative (left_num))
        -:  372:  {
    #####:  373:    r = -r;
        -:  374:  }
        -:  375:
    #####:  376:  return r;
        -:  377:} /* ecma_number_remainder */
        -:  378:
        -:  379:/**
        -:  380: * Compute power operation according to the ES standard.
        -:  381: *
        -:  382: * @return x ** y
        -:  383: */
        -:  384:ecma_number_t JERRY_ATTR_CONST
    #####:  385:ecma_number_pow (ecma_number_t x, /**< left operand */
        -:  386:                 ecma_number_t y) /**< right operand */
        -:  387:{
    #####:  388:  if (ecma_number_is_nan (y) || (ecma_number_is_infinity (y) && (x == ECMA_NUMBER_ONE || x == ECMA_NUMBER_MINUS_ONE)))
        -:  389:  {
        -:  390:    /* Handle differences between ES5.1 and ISO C standards for pow. */
    #####:  391:    return ecma_number_make_nan ();
        -:  392:  }
        -:  393:
    #####:  394:  if (ecma_number_is_zero (y))
        -:  395:  {
        -:  396:    /* Handle differences between ES5.1 and ISO C standards for pow. */
    #####:  397:    return ECMA_NUMBER_ONE;
        -:  398:  }
        -:  399:
    #####:  400:  return DOUBLE_TO_ECMA_NUMBER_T (pow (x, y));
        -:  401:} /* ecma_number_pow */
        -:  402:
        -:  403:/**
        -:  404: * ECMA-integer number multiplication.
        -:  405: *
        -:  406: * @return number - result of multiplication.
        -:  407: */
        -:  408:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:  409:ecma_integer_multiply (ecma_integer_value_t left_integer, /**< left operand */
        -:  410:                       ecma_integer_value_t right_integer) /**< right operand */
        -:  411:{
        -:  412:#if defined(__GNUC__) || defined(__clang__)
        -:  413:  /* Check if either integer is power of 2 */
    #####:  414:  if (JERRY_UNLIKELY ((left_integer & (left_integer - 1)) == 0))
        -:  415:  {
        -:  416:    /* Right shift right_integer with log2 (left_integer) */
    #####:  417:    return ecma_make_integer_value (right_integer << (__builtin_ctz ((unsigned int) left_integer)));
        -:  418:  }
        -:  419:
    #####:  420:  if (JERRY_UNLIKELY ((right_integer & (right_integer - 1)) == 0))
        -:  421:  {
        -:  422:    /* Right shift left_integer with log2 (right_integer) */
    #####:  423:    return ecma_make_integer_value (left_integer << (__builtin_ctz ((unsigned int) right_integer)));
        -:  424:  }
        -:  425:#endif /* defined (__GNUC__) || defined (__clang__) */
        -:  426:
    #####:  427:  return ecma_make_integer_value (left_integer * right_integer);
        -:  428:} /* ecma_integer_multiply */
        -:  429:
        -:  430:/**
        -:  431: * The Number object's 'parseInt' routine
        -:  432: *
        -:  433: * See also:
        -:  434: *          ECMA-262 v5, 15.1.2.2
        -:  435: *
        -:  436: * @return ecma value
        -:  437: *         Returned value must be freed with ecma_free_value.
        -:  438: */
        -:  439:ecma_value_t
    #####:  440:ecma_number_parse_int (const lit_utf8_byte_t *str_p, /**< routine's first argument's
        -:  441:                                                      *   string buffer */
        -:  442:                       lit_utf8_size_t str_size, /**< routine's first argument's
        -:  443:                                                  *   string buffer's size */
        -:  444:                       ecma_value_t radix_value) /**< routine's second argument */
        -:  445:{
        -:  446:  /* 2. Remove leading whitespace. */
    #####:  447:  ecma_string_trim_helper (&str_p, &str_size);
        -:  448:
    #####:  449:  if (str_size == 0)
        -:  450:  {
    #####:  451:    return ecma_make_nan_value ();
        -:  452:  }
        -:  453:
    #####:  454:  const lit_utf8_byte_t *str_end_p = str_p + str_size;
        -:  455:
        -:  456:  /* 3. */
    #####:  457:  bool sign = false;
        -:  458:
        -:  459:  /* 4. */
    #####:  460:  if (*str_p == LIT_CHAR_MINUS)
        -:  461:  {
    #####:  462:    sign = true;
    #####:  463:    str_p++;
        -:  464:  }
        -:  465:  /* 5. */
    #####:  466:  else if (*str_p == LIT_CHAR_PLUS)
        -:  467:  {
    #####:  468:    str_p++;
        -:  469:  }
        -:  470:
        -:  471:  /* 6. */
    #####:  472:  ecma_number_t radix_num;
    #####:  473:  radix_value = ecma_op_to_number (radix_value, &radix_num);
        -:  474:
    #####:  475:  if (ECMA_IS_VALUE_ERROR (radix_value))
        -:  476:  {
    #####:  477:    return ECMA_VALUE_ERROR;
        -:  478:  }
        -:  479:
    #####:  480:  int32_t radix = ecma_number_to_int32 (radix_num);
        -:  481:
        -:  482:  /* 7.*/
    #####:  483:  bool strip_prefix = true;
        -:  484:
        -:  485:  /* 8. */
    #####:  486:  if (radix != 0)
        -:  487:  {
        -:  488:    /* 8.a */
    #####:  489:    if (radix < 2 || radix > 36)
        -:  490:    {
    #####:  491:      return ecma_make_nan_value ();
        -:  492:    }
        -:  493:    /* 8.b */
    #####:  494:    else if (radix != 16)
        -:  495:    {
    #####:  496:      strip_prefix = false;
        -:  497:    }
        -:  498:  }
        -:  499:  /* 9. */
        -:  500:  else
        -:  501:  {
    #####:  502:    radix = 10;
        -:  503:  }
        -:  504:
        -:  505:  /* 10. */
    #####:  506:  if (strip_prefix && ((str_end_p - str_p) >= 2) && (str_p[0] == LIT_CHAR_0)
    #####:  507:      && (LEXER_TO_ASCII_LOWERCASE (str_p[1]) == LIT_CHAR_LOWERCASE_X))
        -:  508:  {
    #####:  509:    str_p += 2;
    #####:  510:    radix = 16;
        -:  511:  }
        -:  512:
    #####:  513:  ecma_number_t value = ECMA_NUMBER_ZERO;
    #####:  514:  const lit_utf8_byte_t *digit_start_p = str_p;
        -:  515:
        -:  516:  /* 11. Check if characters are in [0, Radix - 1]. We also convert them to number values in the process. */
    #####:  517:  while (str_p < str_end_p)
        -:  518:  {
    #####:  519:    ecma_char_t ch = *str_p;
        -:  520:
    #####:  521:    int32_t digit = 0;
        -:  522:
    #####:  523:    if (lit_char_is_decimal_digit (ch))
        -:  524:    {
    #####:  525:      digit = ch - LIT_CHAR_0;
        -:  526:    }
    #####:  527:    else if (LEXER_TO_ASCII_LOWERCASE (ch) >= LIT_CHAR_LOWERCASE_A
    #####:  528:             && LEXER_TO_ASCII_LOWERCASE (ch) <= LIT_CHAR_LOWERCASE_Z)
        -:  529:    {
    #####:  530:      digit = LEXER_TO_ASCII_LOWERCASE (ch) - LIT_CHAR_LOWERCASE_A + 10;
        -:  531:    }
        -:  532:    else
        -:  533:    {
        -:  534:      /* Not a valid digit char, set to invalid value */
    #####:  535:      digit = radix;
        -:  536:    }
        -:  537:
    #####:  538:    if (digit >= radix)
        -:  539:    {
    #####:  540:      break;
        -:  541:    }
        -:  542:
    #####:  543:    value *= radix;
    #####:  544:    value += digit;
        -:  545:
    #####:  546:    str_p++;
        -:  547:  }
        -:  548:
        -:  549:  /* 12. */
    #####:  550:  if (str_p == digit_start_p)
        -:  551:  {
    #####:  552:    return ecma_make_nan_value ();
        -:  553:  }
        -:  554:
        -:  555:  /* 15. */
    #####:  556:  if (sign)
        -:  557:  {
    #####:  558:    value *= ECMA_NUMBER_MINUS_ONE;
        -:  559:  }
        -:  560:
    #####:  561:  return ecma_make_number_value (value);
        -:  562:} /* ecma_number_parse_int */
        -:  563:
        -:  564:/**
        -:  565: * The Number object's 'parseFloat' routine
        -:  566: *
        -:  567: * See also:
        -:  568: *          ECMA-262 v5, 15.1.2.2
        -:  569: *
        -:  570: * @return ecma value
        -:  571: *         Returned value must be freed with ecma_free_value.
        -:  572: */
        -:  573:ecma_value_t
    #####:  574:ecma_number_parse_float (const lit_utf8_byte_t *str_p, /**< routine's first argument's
        -:  575:                                                        *   string buffer */
        -:  576:                         lit_utf8_size_t str_size) /**< routine's first argument's
        -:  577:                                                    *   string buffer's size */
        -:  578:{
        -:  579:  /* 2. Remove leading whitespace. */
    #####:  580:  ecma_string_trim_helper (&str_p, &str_size);
        -:  581:
    #####:  582:  const lit_utf8_byte_t *str_end_p = str_p + str_size;
    #####:  583:  bool sign = false;
        -:  584:
    #####:  585:  if (str_size == 0)
        -:  586:  {
    #####:  587:    return ecma_make_nan_value ();
        -:  588:  }
        -:  589:
    #####:  590:  if (*str_p == LIT_CHAR_PLUS)
        -:  591:  {
    #####:  592:    str_p++;
        -:  593:  }
    #####:  594:  else if (*str_p == LIT_CHAR_MINUS)
        -:  595:  {
    #####:  596:    sign = true;
    #####:  597:    str_p++;
        -:  598:  }
        -:  599:
        -:  600:  /* Check if string is equal to "Infinity". */
    #####:  601:  const lit_utf8_byte_t *infinity_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);
    #####:  602:  const lit_utf8_size_t infinity_length = lit_get_magic_string_size (LIT_MAGIC_STRING_INFINITY_UL);
        -:  603:
        -:  604:  /* The input string should be at least the length of "Infinity" to be correctly processed as
        -:  605:   * the infinity value.
        -:  606:   */
    #####:  607:  if ((lit_utf8_size_t) (str_end_p - str_p) >= infinity_length && memcmp (infinity_str_p, str_p, infinity_length) == 0)
        -:  608:  {
    #####:  609:    return ecma_make_number_value (ecma_number_make_infinity (sign));
        -:  610:  }
        -:  611:
    #####:  612:  const lit_utf8_byte_t *num_start_p = str_p;
    #####:  613:  const lit_utf8_byte_t *num_end_p = str_p;
        -:  614:
    #####:  615:  while (str_p < str_end_p && lit_char_is_decimal_digit (*str_p))
        -:  616:  {
    #####:  617:    str_p++;
        -:  618:  }
        -:  619:
    #####:  620:  if (str_p < str_end_p && *str_p == LIT_CHAR_DOT)
        -:  621:  {
    #####:  622:    str_p++;
        -:  623:
    #####:  624:    while (str_p < str_end_p && lit_char_is_decimal_digit (*str_p))
        -:  625:    {
    #####:  626:      str_p++;
        -:  627:    }
        -:  628:  }
        -:  629:
    #####:  630:  num_end_p = str_p;
        -:  631:
    #####:  632:  if (str_p < str_end_p && LEXER_TO_ASCII_LOWERCASE (*str_p) == LIT_CHAR_LOWERCASE_E)
        -:  633:  {
    #####:  634:    str_p++;
        -:  635:
    #####:  636:    if (str_p < str_end_p && (*str_p == LIT_CHAR_PLUS || *str_p == LIT_CHAR_MINUS))
        -:  637:    {
    #####:  638:      str_p++;
        -:  639:    }
        -:  640:
    #####:  641:    if (str_p < str_end_p && lit_char_is_decimal_digit (*str_p))
        -:  642:    {
    #####:  643:      str_p++;
        -:  644:
    #####:  645:      while (str_p < str_end_p && lit_char_is_decimal_digit (*str_p))
        -:  646:      {
    #####:  647:        str_p++;
        -:  648:      }
        -:  649:
    #####:  650:      num_end_p = str_p;
        -:  651:    }
        -:  652:  }
        -:  653:
    #####:  654:  lit_utf8_size_t num_size = (lit_utf8_size_t) (num_end_p - num_start_p);
        -:  655:
    #####:  656:  if (num_size == 0)
        -:  657:  {
    #####:  658:    return ecma_make_nan_value ();
        -:  659:  }
        -:  660:
        -:  661:  /* 5. */
    #####:  662:  ecma_number_t ret_num = ecma_utf8_string_to_number (num_start_p, num_size, 0);
        -:  663:
    #####:  664:  if (sign)
        -:  665:  {
    #####:  666:    ret_num *= ECMA_NUMBER_MINUS_ONE;
        -:  667:  }
        -:  668:
    #####:  669:  return ecma_make_number_value (ret_num);
        -:  670:} /* ecma_number_parse_float */
        -:  671:
        -:  672:/**
        -:  673: * @}
        -:  674: * @}
        -:  675: */
