        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-function-object.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-lcache.h"
        -:   25:#include "ecma-line-info.h"
        -:   26:#include "ecma-property-hashmap.h"
        -:   27:
        -:   28:#include "byte-code.h"
        -:   29:#include "jcontext.h"
        -:   30:#include "jrt-bit-fields.h"
        -:   31:#include "re-compiler.h"
        -:   32:
        -:   33:#if JERRY_DEBUGGER
        -:   34:#include "debugger.h"
        -:   35:#endif /* JERRY_DEBUGGER */
        -:   36:
        -:   37:/** \addtogroup ecma ECMA
        -:   38: * @{
        -:   39: *
        -:   40: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   41: * @{
        -:   42: */
        -:   43:
        -:   44:JERRY_STATIC_ASSERT (ECMA_OBJECT_TYPE_MASK >= ECMA_OBJECT_TYPE__MAX - 1,
        -:   45:                     ecma_object_types_must_be_lower_than_the_container_mask);
        -:   46:
        -:   47:JERRY_STATIC_ASSERT (ECMA_OBJECT_TYPE_MASK >= ECMA_LEXICAL_ENVIRONMENT_TYPE__MAX,
        -:   48:                     ecma_lexical_environment_types_must_be_lower_than_the_container_mask);
        -:   49:
        -:   50:JERRY_STATIC_ASSERT (ECMA_OBJECT_FLAG_EXTENSIBLE == ECMA_OBJECT_TYPE_MASK + 1,
        -:   51:                     ecma_extensible_flag_must_follow_the_object_type);
        -:   52:
        -:   53:JERRY_STATIC_ASSERT (ECMA_OBJECT_REF_ONE == (ECMA_OBJECT_FLAG_EXTENSIBLE << 1),
        -:   54:                     ecma_object_ref_one_must_follow_the_extensible_flag);
        -:   55:
        -:   56:JERRY_STATIC_ASSERT ((ECMA_OBJECT_MAX_REF + ECMA_OBJECT_REF_ONE) == ECMA_OBJECT_REF_MASK,
        -:   57:                     ecma_object_max_ref_does_not_fill_the_remaining_bits);
        -:   58:
        -:   59:JERRY_STATIC_ASSERT ((ECMA_OBJECT_REF_MASK & (ECMA_OBJECT_TYPE_MASK | ECMA_OBJECT_FLAG_EXTENSIBLE)) == 0,
        -:   60:                     ecma_object_ref_mask_overlaps_with_object_type_or_extensible);
        -:   61:
        -:   62:JERRY_STATIC_ASSERT (ECMA_PROPERTY_FLAGS_MASK == ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:   63:                     ecma_property_flags_mask_must_use_the_configurable_enumerable_writable_flags);
        -:   64:
        -:   65:/* These checks are needed by ecma_get_object_base_type. */
        -:   66:JERRY_STATIC_ASSERT ((int) ECMA_OBJECT_TYPE_BUILT_IN_GENERAL == ((int) ECMA_OBJECT_TYPE_GENERAL | 0x1)
        -:   67:                       && ((int) ECMA_OBJECT_TYPE_GENERAL & 0x1) == 0,
        -:   68:                     ecma_object_type_built_in_general_has_unexpected_value);
        -:   69:JERRY_STATIC_ASSERT ((int) ECMA_OBJECT_TYPE_BUILT_IN_CLASS == ((int) ECMA_OBJECT_TYPE_CLASS | 0x1)
        -:   70:                       && ((int) ECMA_OBJECT_TYPE_CLASS & 0x1) == 0,
        -:   71:                     ecma_object_type_built_in_class_has_unexpected_value);
        -:   72:JERRY_STATIC_ASSERT ((int) ECMA_OBJECT_TYPE_BUILT_IN_ARRAY == ((int) ECMA_OBJECT_TYPE_ARRAY | 0x1)
        -:   73:                       && ((int) ECMA_OBJECT_TYPE_ARRAY & 0x1) == 0,
        -:   74:                     ecma_object_type_built_in_array_has_unexpected_value);
        -:   75:
        -:   76:/**
        -:   77: * Create an object with specified prototype object
        -:   78: * (or NULL prototype if there is not prototype for the object)
        -:   79: * and value of 'Extensible' attribute.
        -:   80: *
        -:   81: * Reference counter's value will be set to one.
        -:   82: *
        -:   83: * @return pointer to the object's descriptor
        -:   84: */
        -:   85:ecma_object_t *
       17:   86:ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */
        -:   87:                    size_t ext_object_size, /**< size of extended objects */
        -:   88:                    ecma_object_type_t type) /**< object type */
        -:   89:{
        -:   90:  ecma_object_t *new_object_p;
        -:   91:
       17:   92:  if (ext_object_size > 0)
        -:   93:  {
       17:   94:    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);
        -:   95:  }
        -:   96:  else
        -:   97:  {
    #####:   98:    new_object_p = ecma_alloc_object ();
        -:   99:  }
        -:  100:
       17:  101:  new_object_p->type_flags_refs = (ecma_object_descriptor_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);
        -:  102:
       17:  103:  ecma_init_gc_info (new_object_p);
        -:  104:
       17:  105:  new_object_p->u1.property_list_cp = JMEM_CP_NULL;
        -:  106:
       17:  107:  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);
        -:  108:
       17:  109:  return new_object_p;
        -:  110:} /* ecma_create_object */
        -:  111:
        -:  112:/**
        -:  113: * Create a declarative lexical environment with specified outer lexical environment
        -:  114: * (or NULL if the environment is not nested).
        -:  115: *
        -:  116: * See also: ECMA-262 v5, 10.2.1.1
        -:  117: *
        -:  118: * Reference counter's value will be set to one.
        -:  119: *
        -:  120: * @return pointer to the descriptor of lexical environment
        -:  121: */
        -:  122:ecma_object_t *
        1:  123:ecma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */
        -:  124:{
        1:  125:  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();
        -:  126:
        1:  127:  new_lexical_environment_p->type_flags_refs = ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE;
        -:  128:
        1:  129:  ecma_init_gc_info (new_lexical_environment_p);
        -:  130:
        1:  131:  new_lexical_environment_p->u1.property_list_cp = JMEM_CP_NULL;
        -:  132:
        1:  133:  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);
        -:  134:
        1:  135:  return new_lexical_environment_p;
        -:  136:} /* ecma_create_decl_lex_env */
        -:  137:
        -:  138:/**
        -:  139: * Create a object lexical environment with specified outer lexical environment
        -:  140: * (or NULL if the environment is not nested), and binding object.
        -:  141: *
        -:  142: * See also: ECMA-262 v5, 10.2.1.2
        -:  143: *
        -:  144: * Reference counter's value will be set to one.
        -:  145: *
        -:  146: * @return pointer to the descriptor of lexical environment
        -:  147: */
        -:  148:ecma_object_t *
        1:  149:ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */
        -:  150:                            ecma_object_t *binding_obj_p) /**< binding object */
        -:  151:{
        1:  152:  JERRY_ASSERT (binding_obj_p != NULL && !ecma_is_lexical_environment (binding_obj_p));
        -:  153:
        1:  154:  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();
        -:  155:
        1:  156:  new_lexical_environment_p->type_flags_refs = ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND;
        -:  157:
        1:  158:  ecma_init_gc_info (new_lexical_environment_p);
        -:  159:
        1:  160:  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp, binding_obj_p);
        -:  161:
        1:  162:  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);
        -:  163:
        1:  164:  return new_lexical_environment_p;
        -:  165:} /* ecma_create_object_lex_env */
        -:  166:
        -:  167:#if JERRY_ESNEXT
        -:  168:
        -:  169:/**
        -:  170: * Create a lexical environment with a specified size.
        -:  171: *
        -:  172: * @return pointer to the descriptor of the lexical environment
        -:  173: */
        -:  174:ecma_object_t *
    #####:  175:ecma_create_lex_env_class (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */
        -:  176:                           size_t lexical_env_size) /**< size of the lexical environment */
        -:  177:{
        -:  178:  ecma_object_t *new_lexical_environment_p;
        -:  179:
    #####:  180:  ecma_object_descriptor_t type_flags_refs = ECMA_LEXICAL_ENVIRONMENT_CLASS;
        -:  181:
    #####:  182:  if (lexical_env_size > 0)
        -:  183:  {
    #####:  184:    new_lexical_environment_p = (ecma_object_t *) ecma_alloc_extended_object (lexical_env_size);
    #####:  185:    type_flags_refs |= ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA;
        -:  186:  }
        -:  187:  else
        -:  188:  {
    #####:  189:    new_lexical_environment_p = ecma_alloc_object ();
        -:  190:  }
        -:  191:
    #####:  192:  new_lexical_environment_p->type_flags_refs = type_flags_refs;
        -:  193:
    #####:  194:  ecma_init_gc_info (new_lexical_environment_p);
        -:  195:
    #####:  196:  new_lexical_environment_p->u1.property_list_cp = JMEM_CP_NULL;
        -:  197:
    #####:  198:  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);
        -:  199:
    #####:  200:  return new_lexical_environment_p;
        -:  201:} /* ecma_create_lex_env_class */
        -:  202:
        -:  203:#endif /* JERRY_ESNEXT */
        -:  204:
        -:  205:/**
        -:  206: * Check if the object is lexical environment.
        -:  207: *
        -:  208: * @return true  - if object is a lexical environment
        -:  209: *         false - otherwise
        -:  210: */
        -:  211:extern inline bool JERRY_ATTR_PURE
   633668:  212:ecma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */
        -:  213:{
   633668:  214:  JERRY_ASSERT (object_p != NULL);
        -:  215:
   633668:  216:  return (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK) >= ECMA_LEXICAL_ENVIRONMENT_TYPE_START;
        -:  217:} /* ecma_is_lexical_environment */
        -:  218:
        -:  219:/**
        -:  220: * Set value of [[Extensible]] object's internal property.
        -:  221: */
        -:  222:extern inline void
        5:  223:ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */
        -:  224:{
        5:  225:  JERRY_ASSERT (object_p != NULL);
        5:  226:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  227:
        5:  228:  object_p->type_flags_refs |= ECMA_OBJECT_FLAG_EXTENSIBLE;
        5:  229:} /* ecma_op_ordinary_object_set_extensible */
        -:  230:
        -:  231:/**
        -:  232: * Get the internal type of an object.
        -:  233: *
        -:  234: * @return type of the object (ecma_object_type_t)
        -:  235: */
        -:  236:extern inline ecma_object_type_t JERRY_ATTR_PURE
   218530:  237:ecma_get_object_type (const ecma_object_t *object_p) /**< object */
        -:  238:{
   218530:  239:  JERRY_ASSERT (object_p != NULL);
   218530:  240:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  241:
   218530:  242:  return (ecma_object_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);
        -:  243:} /* ecma_get_object_type */
        -:  244:
        -:  245:/**
        -:  246: * Get the internal base type of an object.
        -:  247: *
        -:  248: * @return base type of the object (ecma_object_base_type_t)
        -:  249: */
        -:  250:extern inline ecma_object_base_type_t JERRY_ATTR_PURE
   283971:  251:ecma_get_object_base_type (const ecma_object_t *object_p) /**< object */
        -:  252:{
   283971:  253:  JERRY_ASSERT (object_p != NULL);
   283971:  254:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  255:
   283971:  256:  return (ecma_object_base_type_t) (object_p->type_flags_refs & (ECMA_OBJECT_TYPE_MASK - 0x1));
        -:  257:} /* ecma_get_object_base_type */
        -:  258:
        -:  259:/**
        -:  260: * Get value of an object if the class matches
        -:  261: *
        -:  262: * @return value of the object if the class matches
        -:  263: *         ECMA_VALUE_NOT_FOUND otherwise
        -:  264: */
        -:  265:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        1:  266:ecma_object_class_is (ecma_object_t *object_p, /**< object */
        -:  267:                      ecma_object_class_type_t class_id) /**< class id */
        -:  268:{
        1:  269:  if (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -:  270:  {
        1:  271:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  272:
        1:  273:    if (ext_object_p->u.cls.type == (uint8_t) class_id)
        -:  274:    {
        1:  275:      return true;
        -:  276:    }
        -:  277:  }
        -:  278:
    #####:  279:  return false;
        -:  280:} /* ecma_object_class_is */
        -:  281:
        -:  282:/**
        -:  283: * Get type of lexical environment.
        -:  284: *
        -:  285: * @return type of the lexical environment (ecma_lexical_environment_type_t)
        -:  286: */
        -:  287:extern inline ecma_lexical_environment_type_t JERRY_ATTR_PURE
       24:  288:ecma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */
        -:  289:{
       24:  290:  JERRY_ASSERT (object_p != NULL);
       24:  291:  JERRY_ASSERT (ecma_is_lexical_environment (object_p));
        -:  292:
       24:  293:  return (ecma_lexical_environment_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);
        -:  294:} /* ecma_get_lex_env_type */
        -:  295:
        -:  296:/**
        -:  297: * Get lexical environment's bound object.
        -:  298: *
        -:  299: * @return pointer to ecma object
        -:  300: */
        -:  301:extern inline ecma_object_t *JERRY_ATTR_PURE
        8:  302:ecma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */
        -:  303:{
        8:  304:  JERRY_ASSERT (object_p != NULL);
        8:  305:  JERRY_ASSERT (ecma_is_lexical_environment (object_p));
        -:  306:#if JERRY_ESNEXT
        8:  307:  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND
        -:  308:                || (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -:  309:                    && !ECMA_LEX_ENV_CLASS_IS_MODULE (object_p)));
        -:  310:#else /* !JERRY_ESNEXT */
        -:  311:  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  312:#endif /* JERRY_ESNEXT */
        -:  313:
        8:  314:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u1.bound_object_cp);
        -:  315:} /* ecma_get_lex_env_binding_object */
        -:  316:
        -:  317:/**
        -:  318: * Create a new lexical environment with the same property list as the passed lexical environment
        -:  319: *
        -:  320: * @return pointer to the newly created lexical environment
        -:  321: */
        -:  322:ecma_object_t *
    #####:  323:ecma_clone_decl_lexical_environment (ecma_object_t *lex_env_p, /**< declarative lexical environment */
        -:  324:                                     bool copy_values) /**< copy property values as well */
        -:  325:{
    #####:  326:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####:  327:  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
        -:  328:
    #####:  329:  ecma_object_t *outer_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####:  330:  ecma_object_t *new_lex_env_p = ecma_create_decl_lex_env (outer_lex_env_p);
        -:  331:
    #####:  332:  jmem_cpointer_t prop_iter_cp = lex_env_p->u1.property_list_cp;
        -:  333:  ecma_property_header_t *prop_iter_p;
        -:  334:
    #####:  335:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  336:
        -:  337:#if JERRY_PROPERTY_HASHMAP
    #####:  338:  prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  339:
    #####:  340:  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  341:  {
    #####:  342:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  343:  }
        -:  344:
    #####:  345:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  346:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  347:
        -:  348:  do
        -:  349:  {
    #####:  350:    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  351:
    #####:  352:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  353:
    #####:  354:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  355:
    #####:  356:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  357:    {
    #####:  358:      if (prop_iter_p->types[i] != ECMA_PROPERTY_TYPE_DELETED)
        -:  359:      {
    #####:  360:        JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (prop_iter_p->types[i]));
        -:  361:
    #####:  362:        uint8_t prop_attributes = (uint8_t) (prop_iter_p->types[i] & ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  363:        ecma_string_t *name_p = ecma_string_from_property_name (prop_iter_p->types[i], prop_pair_p->names_cp[i]);
        -:  364:
        -:  365:        ecma_property_value_t *property_value_p;
    #####:  366:        property_value_p = ecma_create_named_data_property (new_lex_env_p, name_p, prop_attributes, NULL);
        -:  367:
    #####:  368:        ecma_deref_ecma_string (name_p);
        -:  369:
    #####:  370:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -:  371:
    #####:  372:        if (copy_values)
        -:  373:        {
    #####:  374:          property_value_p->value = ecma_copy_value_if_not_object (prop_pair_p->values[i].value);
        -:  375:        }
        -:  376:        else
        -:  377:        {
    #####:  378:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -:  379:        }
        -:  380:      }
        -:  381:    }
        -:  382:
    #####:  383:    prop_iter_cp = prop_iter_p->next_property_cp;
    #####:  384:  } while (prop_iter_cp != JMEM_CP_NULL);
        -:  385:
    #####:  386:  ecma_deref_object (lex_env_p);
    #####:  387:  return new_lex_env_p;
        -:  388:} /* ecma_clone_decl_lexical_environment */
        -:  389:
        -:  390:/**
        -:  391: * Create a property in an object and link it into
        -:  392: * the object's properties' linked-list (at start of the list).
        -:  393: *
        -:  394: * @return pointer to the newly created property value
        -:  395: */
        -:  396:static ecma_property_value_t *
       13:  397:ecma_create_property (ecma_object_t *object_p, /**< the object */
        -:  398:                      ecma_string_t *name_p, /**< property name */
        -:  399:                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */
        -:  400:                      ecma_property_value_t value, /**< property value */
        -:  401:                      ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  402:                                                     *         if this field is non-NULL */
        -:  403:{
        -:  404:  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);
       13:  405:  JERRY_ASSERT (name_p != NULL);
       13:  406:  JERRY_ASSERT (object_p != NULL);
        -:  407:
       13:  408:  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;
        -:  409:
       13:  410:  if (*property_list_head_p != ECMA_NULL_POINTER)
        -:  411:  {
        -:  412:    /* If the first entry is free (deleted), it is reused. */
        9:  413:    ecma_property_header_t *first_property_p =
        9:  414:      ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);
        -:  415:
        -:  416:#if JERRY_PROPERTY_HASHMAP
        9:  417:    bool has_hashmap = false;
        -:  418:
        9:  419:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  420:    {
    #####:  421:      property_list_head_p = &first_property_p->next_property_cp;
    #####:  422:      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);
    #####:  423:      has_hashmap = true;
        -:  424:    }
        -:  425:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  426:
        9:  427:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));
        -:  428:
        9:  429:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)
        -:  430:    {
        5:  431:      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;
        -:  432:
        5:  433:      ecma_property_t name_type;
        5:  434:      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p, &name_type);
        5:  435:      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);
        -:  436:
        5:  437:      ecma_property_t *property_p = first_property_p->types + 0;
        -:  438:
        5:  439:      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);
        -:  440:
        5:  441:      if (out_prop_p != NULL)
        -:  442:      {
        3:  443:        *out_prop_p = property_p;
        -:  444:      }
        -:  445:
        5:  446:      first_property_pair_p->values[0] = value;
        -:  447:
        -:  448:#if JERRY_PROPERTY_HASHMAP
        -:  449:      /* The property must be fully initialized before ecma_property_hashmap_insert
        -:  450:       * is called, because the insert operation may reallocate the hashmap, and
        -:  451:       * that triggers garbage collection which scans all properties of all objects.
        -:  452:       * A not fully initialized but queued property may cause a crash. */
        -:  453:
        5:  454:      if (has_hashmap)
        -:  455:      {
    #####:  456:        ecma_property_hashmap_insert (object_p, name_p, first_property_pair_p, 0);
        -:  457:      }
        -:  458:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  459:
        5:  460:      return first_property_pair_p->values + 0;
        -:  461:    }
        -:  462:  }
        -:  463:
        -:  464:  /* Otherwise we create a new property pair and use its second value. */
        8:  465:  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();
        -:  466:
        -:  467:  /* Need to query property_list_head_p again and recheck the existennce
        -:  468:   * of property hasmap, because ecma_alloc_property_pair may delete them. */
        8:  469:  property_list_head_p = &object_p->u1.property_list_cp;
        -:  470:#if JERRY_PROPERTY_HASHMAP
        8:  471:  bool has_hashmap = false;
        -:  472:
        8:  473:  if (*property_list_head_p != ECMA_NULL_POINTER)
        -:  474:  {
        4:  475:    ecma_property_header_t *first_property_p =
        4:  476:      ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, *property_list_head_p);
        -:  477:
        4:  478:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  479:    {
    #####:  480:      property_list_head_p = &first_property_p->next_property_cp;
    #####:  481:      has_hashmap = true;
        -:  482:    }
        -:  483:  }
        -:  484:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  485:
        -:  486:  /* Just copy the previous value (no need to decompress, compress). */
        8:  487:  first_property_pair_p->header.next_property_cp = *property_list_head_p;
        8:  488:  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;
        8:  489:  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  490:
        8:  491:  ecma_property_t name_type;
        8:  492:  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p, &name_type);
        -:  493:
        8:  494:  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);
        -:  495:
        8:  496:  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);
        -:  497:
        8:  498:  ecma_property_t *property_p = first_property_pair_p->header.types + 1;
        -:  499:
        8:  500:  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);
        -:  501:
        8:  502:  if (out_prop_p != NULL)
        -:  503:  {
        4:  504:    *out_prop_p = property_p;
        -:  505:  }
        -:  506:
        8:  507:  first_property_pair_p->values[1] = value;
        -:  508:
        -:  509:#if JERRY_PROPERTY_HASHMAP
        -:  510:  /* See the comment before the other ecma_property_hashmap_insert above. */
        -:  511:
        8:  512:  if (has_hashmap)
        -:  513:  {
    #####:  514:    ecma_property_hashmap_insert (object_p, name_p, first_property_pair_p, 1);
        -:  515:  }
        -:  516:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  517:
        8:  518:  return first_property_pair_p->values + 1;
        -:  519:} /* ecma_create_property */
        -:  520:
        -:  521:/**
        -:  522: * Create named data property with given name, attributes and undefined value
        -:  523: * in the specified object.
        -:  524: *
        -:  525: * @return pointer to the newly created property value
        -:  526: */
        -:  527:ecma_property_value_t *
       12:  528:ecma_create_named_data_property (ecma_object_t *object_p, /**< object */
        -:  529:                                 ecma_string_t *name_p, /**< property name */
        -:  530:                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */
        -:  531:                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  532:                                                                *         if this field is non-NULL */
        -:  533:{
       12:  534:  JERRY_ASSERT (object_p != NULL && name_p != NULL);
       12:  535:  JERRY_ASSERT (ecma_is_lexical_environment (object_p) || !ecma_op_object_is_fast_array (object_p));
       12:  536:  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);
       12:  537:  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);
        -:  538:
       12:  539:  uint8_t type_and_flags = ECMA_PROPERTY_FLAG_DATA | prop_attributes;
        -:  540:
        -:  541:  ecma_property_value_t value;
       12:  542:  value.value = ECMA_VALUE_UNDEFINED;
        -:  543:
       12:  544:  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);
        -:  545:} /* ecma_create_named_data_property */
        -:  546:
        -:  547:/**
        -:  548: * Create named accessor property with given name, attributes, getter and setter.
        -:  549: *
        -:  550: * @return pointer to the newly created property value
        -:  551: */
        -:  552:ecma_property_value_t *
        1:  553:ecma_create_named_accessor_property (ecma_object_t *object_p, /**< object */
        -:  554:                                     ecma_string_t *name_p, /**< property name */
        -:  555:                                     ecma_object_t *get_p, /**< getter */
        -:  556:                                     ecma_object_t *set_p, /**< setter */
        -:  557:                                     uint8_t prop_attributes, /**< property attributes */
        -:  558:                                     ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  559:                                                                    *         if this field is non-NULL */
        -:  560:{
        1:  561:  JERRY_ASSERT (object_p != NULL && name_p != NULL);
        1:  562:  JERRY_ASSERT (ecma_is_lexical_environment (object_p) || !ecma_op_object_is_fast_array (object_p));
        1:  563:  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);
        1:  564:  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE) == 0);
        -:  565:
        1:  566:  uint8_t type_and_flags = prop_attributes;
        -:  567:
        -:  568:  ecma_property_value_t value;
        -:  569:#if JERRY_CPOINTER_32_BIT
        -:  570:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
        1:  571:  getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        1:  572:  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, get_p);
        1:  573:  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, set_p);
        1:  574:  ECMA_SET_NON_NULL_POINTER (value.getter_setter_pair_cp, getter_setter_pair_p);
        -:  575:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  576:  ECMA_SET_POINTER (value.getter_setter_pair.getter_cp, get_p);
    #####:  577:  ECMA_SET_POINTER (value.getter_setter_pair.setter_cp, set_p);
        -:  578:#endif /* JERRY_CPOINTER_32_BIT */
        -:  579:
        1:  580:  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);
        -:  581:} /* ecma_create_named_accessor_property */
        -:  582:
        -:  583:#if JERRY_MODULE_SYSTEM
        -:  584:/**
        -:  585: * Create property reference
        -:  586: */
        -:  587:void
    #####:  588:ecma_create_named_reference_property (ecma_object_t *object_p, /**< object */
        -:  589:                                      ecma_string_t *name_p, /**< property name */
        -:  590:                                      ecma_value_t reference) /**< property reference */
        -:  591:{
    #####:  592:  JERRY_ASSERT (object_p != NULL && name_p != NULL);
    #####:  593:  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);
    #####:  594:  JERRY_ASSERT ((ecma_is_lexical_environment (object_p)
        -:  595:                 && ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -:  596:                 && ECMA_LEX_ENV_CLASS_IS_MODULE (object_p))
        -:  597:                || ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_MODULE_NAMESPACE));
        -:  598:
    #####:  599:  uint8_t type_and_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE;
        -:  600:  ecma_property_value_t value;
        -:  601:
    #####:  602:  value.value = reference;
        -:  603:
    #####:  604:  ecma_create_property (object_p, name_p, type_and_flags, value, NULL);
    #####:  605:} /* ecma_create_named_reference_property */
        -:  606:
        -:  607:#endif /* JERRY_MODULE_SYSTEM */
        -:  608:
        -:  609:/**
        -:  610: * Find named data property or named accessor property in a specified object.
        -:  611: *
        -:  612: * @return pointer to the property, if it is found,
        -:  613: *         NULL - otherwise.
        -:  614: */
        -:  615:ecma_property_t *
    43716:  616:ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */
        -:  617:                          ecma_string_t *name_p) /**< property's name */
        -:  618:{
    43716:  619:  JERRY_ASSERT (obj_p != NULL);
    43716:  620:  JERRY_ASSERT (name_p != NULL);
    43716:  621:  JERRY_ASSERT (ecma_is_lexical_environment (obj_p) || !ecma_op_object_is_fast_array (obj_p));
        -:  622:
        -:  623:#if JERRY_LCACHE
    43716:  624:  ecma_property_t *property_p = ecma_lcache_lookup (obj_p, name_p);
    43716:  625:  if (property_p != NULL)
        -:  626:  {
        4:  627:    return property_p;
        -:  628:  }
        -:  629:#else /* !JERRY_LCACHE */
        -:  630:  ecma_property_t *property_p = NULL;
        -:  631:#endif /* JERRY_LCACHE */
        -:  632:
    43712:  633:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -:  634:
        -:  635:#if JERRY_PROPERTY_HASHMAP
    43712:  636:  if (prop_iter_cp != JMEM_CP_NULL)
        -:  637:  {
    21863:  638:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    21863:  639:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  640:    {
    #####:  641:      jmem_cpointer_t property_real_name_cp;
    #####:  642:      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p, name_p, &property_real_name_cp);
        -:  643:#if JERRY_LCACHE
    #####:  644:      if (property_p != NULL && !ecma_is_property_lcached (property_p))
        -:  645:      {
    #####:  646:        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);
        -:  647:      }
        -:  648:#endif /* JERRY_LCACHE */
    #####:  649:      return property_p;
        -:  650:    }
        -:  651:  }
        -:  652:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  653:
        -:  654:#if JERRY_PROPERTY_HASHMAP
    43712:  655:  uint32_t steps = 0;
        -:  656:#endif /* JERRY_PROPERTY_HASHMAP */
    43712:  657:  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;
        -:  658:
    43712:  659:  if (ECMA_IS_DIRECT_STRING (name_p))
        -:  660:  {
    43684:  661:    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);
    43684:  662:    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);
        -:  663:
    43684:  664:    JERRY_ASSERT (prop_name_type > 0);
        -:  665:
   131055:  666:    while (prop_iter_cp != JMEM_CP_NULL)
        -:  667:    {
    43689:  668:      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  669:
    43689:  670:      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  671:
    43689:  672:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  673:
    43689:  674:      if (prop_pair_p->names_cp[0] == property_name_cp
        1:  675:          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)
        -:  676:      {
        1:  677:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));
        -:  678:
        1:  679:        property_p = prop_iter_p->types + 0;
        1:  680:        break;
        -:  681:      }
        -:  682:
    43688:  683:      if (prop_pair_p->names_cp[1] == property_name_cp
        1:  684:          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)
        -:  685:      {
        1:  686:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));
        -:  687:
        1:  688:        property_p = prop_iter_p->types + 1;
        1:  689:        break;
        -:  690:      }
        -:  691:
        -:  692:#if JERRY_PROPERTY_HASHMAP
    43687:  693:      steps++;
        -:  694:#endif /* JERRY_PROPERTY_HASHMAP */
    43687:  695:      prop_iter_cp = prop_iter_p->next_property_cp;
        -:  696:    }
        -:  697:  }
        -:  698:  else
        -:  699:  {
       79:  700:    while (prop_iter_cp != JMEM_CP_NULL)
        -:  701:    {
       25:  702:      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  703:
       25:  704:      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  705:
       25:  706:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  707:
       25:  708:      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)
        -:  709:      {
       15:  710:        property_name_cp = prop_pair_p->names_cp[0];
       15:  711:        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);
        -:  712:
       15:  713:        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))
        -:  714:        {
        1:  715:          property_p = prop_iter_p->types + 0;
        1:  716:          break;
        -:  717:        }
        -:  718:      }
        -:  719:
       24:  720:      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)
        -:  721:      {
       22:  722:        property_name_cp = prop_pair_p->names_cp[1];
       22:  723:        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);
        -:  724:
       22:  725:        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))
        -:  726:        {
        1:  727:          property_p = prop_iter_p->types + 1;
        1:  728:          break;
        -:  729:        }
        -:  730:      }
        -:  731:
        -:  732:#if JERRY_PROPERTY_HASHMAP
       23:  733:      steps++;
        -:  734:#endif /* JERRY_PROPERTY_HASHMAP */
       23:  735:      prop_iter_cp = prop_iter_p->next_property_cp;
        -:  736:    }
        -:  737:  }
        -:  738:
        -:  739:#if JERRY_PROPERTY_HASHMAP
    43712:  740:  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))
        -:  741:  {
    #####:  742:    ecma_property_hashmap_create (obj_p);
        -:  743:  }
        -:  744:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  745:
        -:  746:#if JERRY_LCACHE
    43716:  747:  if (property_p != NULL && !ecma_is_property_lcached (property_p))
        -:  748:  {
        4:  749:    ecma_lcache_insert (obj_p, property_name_cp, property_p);
        -:  750:  }
        -:  751:#endif /* JERRY_LCACHE */
        -:  752:
    43712:  753:  return property_p;
        -:  754:} /* ecma_find_named_property */
        -:  755:
        -:  756:/**
        -:  757: * Get named data property or named access property in specified object.
        -:  758: *
        -:  759: * Warning:
        -:  760: *         the property must exist
        -:  761: *
        -:  762: * @return pointer to the property, if it is found,
        -:  763: *         NULL - otherwise.
        -:  764: */
        -:  765:ecma_property_value_t *
    #####:  766:ecma_get_named_data_property (ecma_object_t *obj_p, /**< object to find property in */
        -:  767:                              ecma_string_t *name_p) /**< property's name */
        -:  768:{
    #####:  769:  JERRY_ASSERT (obj_p != NULL);
    #####:  770:  JERRY_ASSERT (name_p != NULL);
    #####:  771:  JERRY_ASSERT (ecma_is_lexical_environment (obj_p) || !ecma_op_object_is_fast_array (obj_p));
        -:  772:
    #####:  773:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  774:
    #####:  775:  JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p));
        -:  776:
    #####:  777:  return ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  778:} /* ecma_get_named_data_property */
        -:  779:
        -:  780:/**
        -:  781: * Delete the object's property referenced by its value pointer.
        -:  782: *
        -:  783: * Note: specified property must be owned by specified object.
        -:  784: */
        -:  785:void
    #####:  786:ecma_delete_property (ecma_object_t *object_p, /**< object */
        -:  787:                      ecma_property_value_t *prop_value_p) /**< property value reference */
        -:  788:{
    #####:  789:  jmem_cpointer_t cur_prop_cp = object_p->u1.property_list_cp;
        -:  790:
    #####:  791:  ecma_property_header_t *prev_prop_p = NULL;
        -:  792:
        -:  793:#if JERRY_PROPERTY_HASHMAP
    #####:  794:  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;
        -:  795:
    #####:  796:  if (cur_prop_cp != JMEM_CP_NULL)
        -:  797:  {
    #####:  798:    ecma_property_header_t *cur_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, cur_prop_cp);
        -:  799:
    #####:  800:    if (cur_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  801:    {
    #####:  802:      prev_prop_p = cur_prop_p;
    #####:  803:      cur_prop_cp = cur_prop_p->next_property_cp;
    #####:  804:      hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  805:    }
        -:  806:  }
        -:  807:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  808:
    #####:  809:  while (cur_prop_cp != JMEM_CP_NULL)
        -:  810:  {
    #####:  811:    ecma_property_header_t *cur_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, cur_prop_cp);
        -:  812:
    #####:  813:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (cur_prop_p));
        -:  814:
    #####:  815:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) cur_prop_p;
        -:  816:
    #####:  817:    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  818:    {
    #####:  819:      if ((prop_pair_p->values + i) == prop_value_p)
        -:  820:      {
    #####:  821:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (cur_prop_p->types[i]));
        -:  822:
        -:  823:#if JERRY_PROPERTY_HASHMAP
    #####:  824:        if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)
        -:  825:        {
    #####:  826:          hashmap_status = ecma_property_hashmap_delete (object_p, prop_pair_p->names_cp[i], cur_prop_p->types + i);
        -:  827:        }
        -:  828:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  829:
    #####:  830:        ecma_gc_free_property (object_p, prop_pair_p, i);
    #####:  831:        cur_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  832:        prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  833:
        -:  834:        JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);
        -:  835:
    #####:  836:        if (cur_prop_p->types[1 - i] != ECMA_PROPERTY_TYPE_DELETED)
        -:  837:        {
        -:  838:#if JERRY_PROPERTY_HASHMAP
        -:  839:          /* The other property is still valid. */
    #####:  840:          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  841:          {
    #####:  842:            ecma_property_hashmap_free (object_p);
    #####:  843:            ecma_property_hashmap_create (object_p);
        -:  844:          }
        -:  845:#endif /* JERRY_PROPERTY_HASHMAP */
    #####:  846:          return;
        -:  847:        }
        -:  848:
    #####:  849:        JERRY_ASSERT (cur_prop_p->types[i] == ECMA_PROPERTY_TYPE_DELETED);
        -:  850:
    #####:  851:        if (prev_prop_p == NULL)
        -:  852:        {
    #####:  853:          object_p->u1.property_list_cp = cur_prop_p->next_property_cp;
        -:  854:        }
        -:  855:        else
        -:  856:        {
    #####:  857:          prev_prop_p->next_property_cp = cur_prop_p->next_property_cp;
        -:  858:        }
        -:  859:
    #####:  860:        ecma_dealloc_property_pair ((ecma_property_pair_t *) cur_prop_p);
        -:  861:
        -:  862:#if JERRY_PROPERTY_HASHMAP
    #####:  863:        if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  864:        {
    #####:  865:          ecma_property_hashmap_free (object_p);
    #####:  866:          ecma_property_hashmap_create (object_p);
        -:  867:        }
        -:  868:#endif /* JERRY_PROPERTY_HASHMAP */
    #####:  869:        return;
        -:  870:      }
        -:  871:    }
        -:  872:
    #####:  873:    prev_prop_p = cur_prop_p;
    #####:  874:    cur_prop_cp = cur_prop_p->next_property_cp;
        -:  875:  }
        -:  876:} /* ecma_delete_property */
        -:  877:
        -:  878:/**
        -:  879: * Check whether the object contains a property
        -:  880: */
        -:  881:static void
    #####:  882:ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */
        -:  883:                                          const ecma_property_value_t *prop_value_p, /**< property value */
        -:  884:                                          bool is_data) /**< property should be data property */
        -:  885:{
        -:  886:#ifndef JERRY_NDEBUG
    #####:  887:  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;
    #####:  888:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  889:
    #####:  890:  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  891:
    #####:  892:  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  893:  {
    #####:  894:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  895:  }
        -:  896:
    #####:  897:  while (prop_iter_cp != JMEM_CP_NULL)
        -:  898:  {
    #####:  899:    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  900:
    #####:  901:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  902:
    #####:  903:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  904:
    #####:  905:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  906:    {
    #####:  907:      if ((prop_pair_p->values + i) == prop_value_p)
        -:  908:      {
    #####:  909:        JERRY_ASSERT (is_data == ((prop_pair_p->header.types[i] & ECMA_PROPERTY_FLAG_DATA) != 0));
    #####:  910:        return;
        -:  911:      }
        -:  912:    }
        -:  913:
    #####:  914:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  915:  }
        -:  916:#else /* JERRY_NDEBUG */
        -:  917:  JERRY_UNUSED (object_p);
        -:  918:  JERRY_UNUSED (prop_value_p);
        -:  919:  JERRY_UNUSED (is_data);
        -:  920:#endif /* !JERRY_NDEBUG */
        -:  921:} /* ecma_assert_object_contains_the_property */
        -:  922:
        -:  923:/**
        -:  924: * Assign value to named data property
        -:  925: *
        -:  926: * Note:
        -:  927: *      value previously stored in the property is freed
        -:  928: */
        -:  929:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  930:ecma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */
        -:  931:                                       ecma_property_value_t *prop_value_p, /**< property value reference */
        -:  932:                                       ecma_value_t value) /**< value to assign */
        -:  933:{
    #####:  934:  ecma_assert_object_contains_the_property (obj_p, prop_value_p, true);
        -:  935:
    #####:  936:  ecma_value_assign_value (&prop_value_p->value, value);
    #####:  937:} /* ecma_named_data_property_assign_value */
        -:  938:
        -:  939:/**
        -:  940: * Get named accessor property getter-setter-pair
        -:  941: *
        -:  942: * @return pointer to object's getter-setter pair
        -:  943: */
        -:  944:ecma_getter_setter_pointers_t *
        2:  945:ecma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */
        -:  946:{
        -:  947:#if JERRY_CPOINTER_32_BIT
        2:  948:  return ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);
        -:  949:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  950:  return (ecma_getter_setter_pointers_t *) &prop_value_p->getter_setter_pair;
        -:  951:#endif /* JERRY_CPOINTER_32_BIT */
        -:  952:} /* ecma_get_named_accessor_property */
        -:  953:
        -:  954:/**
        -:  955: * Set getter of named accessor property
        -:  956: */
        -:  957:void
    #####:  958:ecma_set_named_accessor_property_getter (ecma_object_t *object_p, /**< the property's container */
        -:  959:                                         ecma_property_value_t *prop_value_p, /**< property value reference */
        -:  960:                                         ecma_object_t *getter_p) /**< getter object */
        -:  961:{
    #####:  962:  ecma_assert_object_contains_the_property (object_p, prop_value_p, false);
        -:  963:
        -:  964:#if JERRY_CPOINTER_32_BIT
        -:  965:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:  966:  getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);
    #####:  967:  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_p);
        -:  968:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  969:  ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_p);
        -:  970:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  971:} /* ecma_set_named_accessor_property_getter */
        -:  972:
        -:  973:/**
        -:  974: * Set setter of named accessor property
        -:  975: */
        -:  976:void
    #####:  977:ecma_set_named_accessor_property_setter (ecma_object_t *object_p, /**< the property's container */
        -:  978:                                         ecma_property_value_t *prop_value_p, /**< property value reference */
        -:  979:                                         ecma_object_t *setter_p) /**< setter object */
        -:  980:{
    #####:  981:  ecma_assert_object_contains_the_property (object_p, prop_value_p, false);
        -:  982:
        -:  983:#if JERRY_CPOINTER_32_BIT
        -:  984:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:  985:  getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);
    #####:  986:  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_p);
        -:  987:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  988:  ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_p);
        -:  989:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  990:} /* ecma_set_named_accessor_property_setter */
        -:  991:
        -:  992:#if JERRY_MODULE_SYSTEM
        -:  993:
        -:  994:/**
        -:  995: * Construct a reference to a given property
        -:  996: *
        -:  997: * @return property reference
        -:  998: */
        -:  999:ecma_value_t
    #####: 1000:ecma_property_to_reference (ecma_property_t *property_p) /**< data or reference property */
        -: 1001:{
    #####: 1002:  ecma_property_value_t *referenced_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1003:
    #####: 1004:  if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -: 1005:  {
    #####: 1006:    return referenced_value_p->value;
        -: 1007:  }
        -: 1008:
    #####: 1009:  jmem_cpointer_tag_t offset = (jmem_cpointer_tag_t) (((uintptr_t) property_p) & 0x1);
        -: 1010:
        -: 1011:#if JERRY_CPOINTER_32_BIT
    #####: 1012:  if (offset != 0)
        -: 1013:  {
    #####: 1014:    --referenced_value_p;
        -: 1015:  }
        -: 1016:#else /* !JERRY_CPOINTER_32_BIT */
    #####: 1017:  if (offset == 0)
        -: 1018:  {
    #####: 1019:    ++referenced_value_p;
        -: 1020:  }
        -: 1021:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1022:
    #####: 1023:  JERRY_ASSERT ((((uintptr_t) referenced_value_p) & (((uintptr_t) 1 << JMEM_ALIGNMENT_LOG) - 1)) == 0);
        -: 1024:
        -: 1025:  ecma_value_t result;
    #####: 1026:  ECMA_SET_NON_NULL_POINTER_TAG (result, referenced_value_p, offset);
    #####: 1027:  return result;
        -: 1028:} /* ecma_property_to_reference */
        -: 1029:
        -: 1030:/**
        -: 1031: * Gets the referenced property value
        -: 1032: *
        -: 1033: * @return pointer to the value
        -: 1034: */
        -: 1035:extern inline ecma_property_value_t *JERRY_ATTR_ALWAYS_INLINE
    #####: 1036:ecma_get_property_value_from_named_reference (ecma_property_value_t *reference_p) /**< data property reference */
        -: 1037:{
    #####: 1038:  ecma_value_t value = reference_p->value;
    #####: 1039:  reference_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_property_value_t, value);
        -: 1040:
        -: 1041:#if JERRY_CPOINTER_32_BIT
    #####: 1042:  if (ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (value))
        -: 1043:  {
    #####: 1044:    ++reference_p;
        -: 1045:  }
        -: 1046:#else /* !JERRY_CPOINTER_32_BIT */
    #####: 1047:  if (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (value))
        -: 1048:  {
    #####: 1049:    --reference_p;
        -: 1050:  }
        -: 1051:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1052:
    #####: 1053:  return reference_p;
        -: 1054:} /* ecma_get_property_value_from_named_reference */
        -: 1055:
        -: 1056:#endif /* JERRY_MODULE_SYSTEM */
        -: 1057:
        -: 1058:/**
        -: 1059: * Get property's 'Writable' attribute value
        -: 1060: *
        -: 1061: * @return true - property is writable,
        -: 1062: *         false - otherwise
        -: 1063: */
        -: 1064:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        2: 1065:ecma_is_property_writable (ecma_property_t property) /**< property */
        -: 1066:{
        2: 1067:  JERRY_ASSERT (property & ECMA_PROPERTY_FLAG_DATA);
        -: 1068:
        2: 1069:  return (property & ECMA_PROPERTY_FLAG_WRITABLE) != 0;
        -: 1070:} /* ecma_is_property_writable */
        -: 1071:
        -: 1072:/**
        -: 1073: * Set property's 'Writable' attribute value
        -: 1074: */
        -: 1075:void
    #####: 1076:ecma_set_property_writable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1077:                                 bool is_writable) /**< new value for writable flag */
        -: 1078:{
    #####: 1079:  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (*property_p));
        -: 1080:
    #####: 1081:  if (is_writable)
        -: 1082:  {
    #####: 1083:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_WRITABLE);
        -: 1084:  }
        -: 1085:  else
        -: 1086:  {
    #####: 1087:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_WRITABLE);
        -: 1088:  }
    #####: 1089:} /* ecma_set_property_writable_attr */
        -: 1090:
        -: 1091:/**
        -: 1092: * Get property's 'Enumerable' attribute value
        -: 1093: *
        -: 1094: * @return true - property is enumerable,
        -: 1095: *         false - otherwise
        -: 1096: */
        -: 1097:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1098:ecma_is_property_enumerable (ecma_property_t property) /**< property */
        -: 1099:{
    #####: 1100:  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (property));
        -: 1101:
    #####: 1102:  return (property & ECMA_PROPERTY_FLAG_ENUMERABLE) != 0;
        -: 1103:} /* ecma_is_property_enumerable */
        -: 1104:
        -: 1105:/**
        -: 1106: * Set property's 'Enumerable' attribute value
        -: 1107: */
        -: 1108:void
    #####: 1109:ecma_set_property_enumerable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1110:                                   bool is_enumerable) /**< new value for enumerable flag */
        -: 1111:{
    #####: 1112:  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -: 1113:
    #####: 1114:  if (is_enumerable)
        -: 1115:  {
    #####: 1116:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_ENUMERABLE);
        -: 1117:  }
        -: 1118:  else
        -: 1119:  {
    #####: 1120:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
        -: 1121:  }
    #####: 1122:} /* ecma_set_property_enumerable_attr */
        -: 1123:
        -: 1124:/**
        -: 1125: * Get property's 'Configurable' attribute value
        -: 1126: *
        -: 1127: * @return true - property is configurable,
        -: 1128: *         false - otherwise
        -: 1129: */
        -: 1130:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1131:ecma_is_property_configurable (ecma_property_t property) /**< property */
        -: 1132:{
    #####: 1133:  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (property));
        -: 1134:
    #####: 1135:  return (property & ECMA_PROPERTY_FLAG_CONFIGURABLE) != 0;
        -: 1136:} /* ecma_is_property_configurable */
        -: 1137:
        -: 1138:/**
        -: 1139: * Set property's 'Configurable' attribute value
        -: 1140: */
        -: 1141:void
    #####: 1142:ecma_set_property_configurable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1143:                                     bool is_configurable) /**< new value for configurable flag */
        -: 1144:{
    #####: 1145:  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -: 1146:
    #####: 1147:  if (is_configurable)
        -: 1148:  {
    #####: 1149:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -: 1150:  }
        -: 1151:  else
        -: 1152:  {
    #####: 1153:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -: 1154:  }
    #####: 1155:} /* ecma_set_property_configurable_attr */
        -: 1156:
        -: 1157:#if JERRY_LCACHE
        -: 1158:
        -: 1159:/**
        -: 1160: * Check whether the property is registered in LCache
        -: 1161: *
        -: 1162: * @return true / false
        -: 1163: */
        -: 1164:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        8: 1165:ecma_is_property_lcached (ecma_property_t *property_p) /**< property */
        -: 1166:{
       12: 1167:  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));
        -: 1168:
       12: 1169:  return (*property_p & ECMA_PROPERTY_FLAG_LCACHED) != 0;
        -: 1170:} /* ecma_is_property_lcached */
        -: 1171:
        -: 1172:/**
        -: 1173: * Set value of flag indicating whether the property is registered in LCache
        -: 1174: */
        -: 1175:extern inline void JERRY_ATTR_ALWAYS_INLINE
        4: 1176:ecma_set_property_lcached (ecma_property_t *property_p, /**< property */
        -: 1177:                           bool is_lcached) /**< new value for lcached flag */
        -: 1178:{
        4: 1179:  JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (*property_p));
        -: 1180:
        4: 1181:  if (is_lcached)
        -: 1182:  {
        4: 1183:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_LCACHED);
        -: 1184:  }
        -: 1185:  else
        -: 1186:  {
    #####: 1187:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_LCACHED);
        -: 1188:  }
        4: 1189:} /* ecma_set_property_lcached */
        -: 1190:
        -: 1191:#endif /* JERRY_LCACHE */
        -: 1192:
        -: 1193:/**
        -: 1194: * Construct empty property descriptor, i.e.:
        -: 1195: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 1196: *
        -: 1197: * @return empty property descriptor
        -: 1198: */
        -: 1199:ecma_property_descriptor_t
        5: 1200:ecma_make_empty_property_descriptor (void)
        -: 1201:{
        -: 1202:  ecma_property_descriptor_t prop_desc;
        -: 1203:
        5: 1204:  prop_desc.flags = 0;
        5: 1205:  prop_desc.value = ECMA_VALUE_UNDEFINED;
        5: 1206:  prop_desc.get_p = NULL;
        5: 1207:  prop_desc.set_p = NULL;
        -: 1208:
        5: 1209:  return prop_desc;
        -: 1210:} /* ecma_make_empty_property_descriptor */
        -: 1211:
        -: 1212:/**
        -: 1213: * Free values contained in the property descriptor
        -: 1214: * and make it empty property descriptor
        -: 1215: */
        -: 1216:void
    #####: 1217:ecma_free_property_descriptor (ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 1218:{
    #####: 1219:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1220:  {
    #####: 1221:    ecma_free_value (prop_desc_p->value);
        -: 1222:  }
        -: 1223:
    #####: 1224:  if ((prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED) && prop_desc_p->get_p != NULL)
        -: 1225:  {
    #####: 1226:    ecma_deref_object (prop_desc_p->get_p);
        -: 1227:  }
        -: 1228:
    #####: 1229:  if ((prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED) && prop_desc_p->set_p != NULL)
        -: 1230:  {
    #####: 1231:    ecma_deref_object (prop_desc_p->set_p);
        -: 1232:  }
        -: 1233:
    #####: 1234:  *prop_desc_p = ecma_make_empty_property_descriptor ();
    #####: 1235:} /* ecma_free_property_descriptor */
        -: 1236:
        -: 1237:/**
        -: 1238: * Increase ref count of an extended primitve value.
        -: 1239: */
        -: 1240:void
    #####: 1241:ecma_ref_extended_primitive (ecma_extended_primitive_t *primitve_p) /**< extended primitve value */
        -: 1242:{
    #####: 1243:  if (JERRY_LIKELY (primitve_p->refs_and_type < ECMA_EXTENDED_PRIMITIVE_MAX_REF))
        -: 1244:  {
    #####: 1245:    primitve_p->refs_and_type += ECMA_EXTENDED_PRIMITIVE_REF_ONE;
        -: 1246:  }
        -: 1247:  else
        -: 1248:  {
    #####: 1249:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1250:  }
    #####: 1251:} /* ecma_ref_extended_primitive */
        -: 1252:
        -: 1253:/**
        -: 1254: * Decrease ref count of an error reference.
        -: 1255: */
        -: 1256:void
    #####: 1257:ecma_deref_exception (ecma_extended_primitive_t *error_ref_p) /**< error reference */
        -: 1258:{
    #####: 1259:  JERRY_ASSERT (error_ref_p->refs_and_type >= ECMA_EXTENDED_PRIMITIVE_REF_ONE);
        -: 1260:
    #####: 1261:  error_ref_p->refs_and_type -= ECMA_EXTENDED_PRIMITIVE_REF_ONE;
        -: 1262:
    #####: 1263:  if (error_ref_p->refs_and_type < ECMA_EXTENDED_PRIMITIVE_REF_ONE)
        -: 1264:  {
    #####: 1265:    ecma_free_value (error_ref_p->u.value);
    #####: 1266:    jmem_pools_free (error_ref_p, sizeof (ecma_extended_primitive_t));
        -: 1267:  }
    #####: 1268:} /* ecma_deref_exception */
        -: 1269:
        -: 1270:#if JERRY_BUILTIN_BIGINT
        -: 1271:
        -: 1272:/**
        -: 1273: * Decrease ref count of a bigint value.
        -: 1274: */
        -: 1275:void
    #####: 1276:ecma_deref_bigint (ecma_extended_primitive_t *bigint_p) /**< bigint value */
        -: 1277:{
    #####: 1278:  JERRY_ASSERT (bigint_p->refs_and_type >= ECMA_EXTENDED_PRIMITIVE_REF_ONE);
        -: 1279:
    #####: 1280:  bigint_p->refs_and_type -= ECMA_EXTENDED_PRIMITIVE_REF_ONE;
        -: 1281:
    #####: 1282:  if (bigint_p->refs_and_type >= ECMA_EXTENDED_PRIMITIVE_REF_ONE)
        -: 1283:  {
    #####: 1284:    return;
        -: 1285:  }
        -: 1286:
    #####: 1287:  uint32_t size = ECMA_BIGINT_GET_SIZE (bigint_p);
        -: 1288:
    #####: 1289:  JERRY_ASSERT (size > 0);
        -: 1290:
    #####: 1291:  size_t mem_size = ECMA_BIGINT_GET_BYTE_SIZE (size) + sizeof (ecma_extended_primitive_t);
    #####: 1292:  jmem_heap_free_block (bigint_p, mem_size);
        -: 1293:} /* ecma_deref_bigint */
        -: 1294:
        -: 1295:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1296:
        -: 1297:/**
        -: 1298: * Create an error reference from a given value.
        -: 1299: *
        -: 1300: * Note:
        -: 1301: *   Reference of the value is taken.
        -: 1302: *
        -: 1303: * @return error reference value
        -: 1304: */
        -: 1305:ecma_value_t
    #####: 1306:ecma_create_exception (ecma_value_t value, /**< referenced value */
        -: 1307:                       uint32_t options) /**< ECMA_ERROR_API_* options */
        -: 1308:{
        -: 1309:  ecma_extended_primitive_t *error_ref_p;
    #####: 1310:  error_ref_p = (ecma_extended_primitive_t *) jmem_pools_alloc (sizeof (ecma_extended_primitive_t));
        -: 1311:
    #####: 1312:  error_ref_p->refs_and_type = ECMA_EXTENDED_PRIMITIVE_REF_ONE | options;
    #####: 1313:  error_ref_p->u.value = value;
    #####: 1314:  return ecma_make_extended_primitive_value (error_ref_p, ECMA_TYPE_ERROR);
        -: 1315:} /* ecma_create_exception */
        -: 1316:
        -: 1317:/**
        -: 1318: * Create an error reference from the currently thrown error value.
        -: 1319: *
        -: 1320: * @return error reference value
        -: 1321: */
        -: 1322:ecma_value_t
    #####: 1323:ecma_create_exception_from_context (void)
        -: 1324:{
    #####: 1325:  uint32_t options = 0;
    #####: 1326:  uint32_t status_flags = JERRY_CONTEXT (status_flags);
        -: 1327:
    #####: 1328:  if (status_flags & ECMA_STATUS_ABORT)
        -: 1329:  {
    #####: 1330:    options |= ECMA_ERROR_API_FLAG_ABORT;
        -: 1331:  }
        -: 1332:
        -: 1333:#if JERRY_VM_THROW
    #####: 1334:  if (status_flags & ECMA_STATUS_ERROR_THROWN)
        -: 1335:  {
    #####: 1336:    options |= ECMA_ERROR_API_FLAG_THROW_CAPTURED;
        -: 1337:  }
        -: 1338:#endif /* JERRY_VM_THROW */
        -: 1339:
    #####: 1340:  return ecma_create_exception (jcontext_take_exception (), options);
        -: 1341:} /* ecma_create_exception_from_context */
        -: 1342:
        -: 1343:/**
        -: 1344: * Create an exception from a given object.
        -: 1345: *
        -: 1346: * Note:
        -: 1347: *   Reference of the object is taken.
        -: 1348: *
        -: 1349: * @return exception value
        -: 1350: */
        -: 1351:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1352:ecma_create_exception_from_object (ecma_object_t *object_p) /**< referenced object */
        -: 1353:{
    #####: 1354:  return ecma_create_exception (ecma_make_object_value (object_p), 0);
        -: 1355:} /* ecma_create_exception_from_object */
        -: 1356:
        -: 1357:/**
        -: 1358: * Raise a new exception from the argument exception value.
        -: 1359: *
        -: 1360: * Note: the argument exceptions reference count is decreased
        -: 1361: */
        -: 1362:void
    #####: 1363:ecma_throw_exception (ecma_value_t value) /**< error reference */
        -: 1364:{
    #####: 1365:  JERRY_ASSERT (!jcontext_has_pending_exception () && !jcontext_has_pending_abort ());
    #####: 1366:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1367:
    #####: 1368:  JERRY_ASSERT (error_ref_p->refs_and_type >= ECMA_EXTENDED_PRIMITIVE_REF_ONE);
        -: 1369:
    #####: 1370:  ecma_value_t referenced_value = error_ref_p->u.value;
    #####: 1371:  uint32_t status_flags = JERRY_CONTEXT (status_flags);
        -: 1372:
    #####: 1373:  status_flags |= (ECMA_STATUS_EXCEPTION
        -: 1374:#if JERRY_VM_THROW
        -: 1375:                   | ECMA_STATUS_ERROR_THROWN
        -: 1376:#endif /* JERRY_VM_THROW */
        -: 1377:                   | ECMA_STATUS_ABORT);
        -: 1378:
    #####: 1379:  if (!(error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_ABORT))
        -: 1380:  {
    #####: 1381:    status_flags &= ~(uint32_t) ECMA_STATUS_ABORT;
        -: 1382:  }
        -: 1383:
        -: 1384:#if JERRY_VM_THROW
    #####: 1385:  if (!(error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_THROW_CAPTURED))
        -: 1386:  {
    #####: 1387:    status_flags &= ~(uint32_t) ECMA_STATUS_ERROR_THROWN;
        -: 1388:  }
        -: 1389:#endif /* JERRY_VM_THROW */
        -: 1390:
    #####: 1391:  JERRY_CONTEXT (status_flags) = status_flags;
        -: 1392:
    #####: 1393:  if (error_ref_p->refs_and_type >= 2 * ECMA_EXTENDED_PRIMITIVE_REF_ONE)
        -: 1394:  {
    #####: 1395:    error_ref_p->refs_and_type -= ECMA_EXTENDED_PRIMITIVE_REF_ONE;
    #####: 1396:    referenced_value = ecma_copy_value (referenced_value);
        -: 1397:  }
        -: 1398:  else
        -: 1399:  {
    #####: 1400:    jmem_pools_free (error_ref_p, sizeof (ecma_extended_primitive_t));
        -: 1401:  }
        -: 1402:
    #####: 1403:  JERRY_CONTEXT (error_value) = referenced_value;
    #####: 1404:} /* ecma_throw_exception */
        -: 1405:
        -: 1406:/**
        -: 1407: * Decrease the reference counter of a script value.
        -: 1408: */
        -: 1409:void
    #####: 1410:ecma_script_deref (ecma_value_t script_value) /**< script value */
        -: 1411:{
    #####: 1412:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 1413:  script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -: 1414:
    #####: 1415:  if (script_p->refs_and_type >= CBC_SCRIPT_REF_ONE)
        -: 1416:  {
    #####: 1417:    return;
        -: 1418:  }
        -: 1419:
    #####: 1420:  size_t script_size = sizeof (cbc_script_t);
    #####: 1421:  uint32_t type = script_p->refs_and_type;
        -: 1422:
    #####: 1423:  if (type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 1424:  {
    #####: 1425:    script_size += sizeof (ecma_value_t);
        -: 1426:
    #####: 1427:    if (!(type & CBC_SCRIPT_USER_VALUE_IS_OBJECT))
        -: 1428:    {
    #####: 1429:      ecma_value_t user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 1430:
    #####: 1431:      JERRY_ASSERT (!ecma_is_value_object (user_value));
    #####: 1432:      ecma_free_value (user_value);
        -: 1433:    }
        -: 1434:  }
        -: 1435:
        -: 1436:#if JERRY_SOURCE_NAME
    #####: 1437:  ecma_deref_ecma_string (ecma_get_string_from_value (script_p->source_name));
        -: 1438:#endif /* JERRY_SOURCE_NAME */
        -: 1439:
        -: 1440:#if JERRY_MODULE_SYSTEM
    #####: 1441:  if (type & CBC_SCRIPT_HAS_IMPORT_META)
        -: 1442:  {
    #####: 1443:    JERRY_ASSERT (!(type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS));
    #####: 1444:    JERRY_ASSERT (ecma_is_value_object (CBC_SCRIPT_GET_IMPORT_META (script_p, type)));
        -: 1445:
    #####: 1446:    script_size += sizeof (ecma_value_t);
        -: 1447:  }
        -: 1448:#endif /* JERRY_MODULE_SYSTEM */
        -: 1449:
        -: 1450:#if JERRY_FUNCTION_TO_STRING
    #####: 1451:  ecma_deref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 1452:
    #####: 1453:  if (type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS)
        -: 1454:  {
    #####: 1455:    ecma_deref_ecma_string (ecma_get_string_from_value (CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, type)));
    #####: 1456:    script_size += sizeof (ecma_value_t);
        -: 1457:  }
        -: 1458:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1459:
    #####: 1460:  jmem_heap_free_block (script_p, script_size);
        -: 1461:} /* ecma_script_deref */
        -: 1462:
        -: 1463:/**
        -: 1464: * Increase reference counter of Compact
        -: 1465: * Byte Code or regexp byte code.
        -: 1466: */
        -: 1467:void
    #####: 1468:ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */
        -: 1469:{
        -: 1470:  /* Abort program if maximum reference number is reached. */
    #####: 1471:  if (bytecode_p->refs >= UINT16_MAX)
        -: 1472:  {
    #####: 1473:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1474:  }
        -: 1475:
    #####: 1476:  bytecode_p->refs++;
    #####: 1477:} /* ecma_bytecode_ref */
        -: 1478:
        -: 1479:/**
        -: 1480: * Decrease reference counter of Compact
        -: 1481: * Byte Code or regexp byte code.
        -: 1482: */
        -: 1483:void
    #####: 1484:ecma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */
        -: 1485:{
    #####: 1486:  JERRY_ASSERT (bytecode_p->refs > 0);
    #####: 1487:  JERRY_ASSERT (!CBC_IS_FUNCTION (bytecode_p->status_flags)
        -: 1488:                || !(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));
        -: 1489:
    #####: 1490:  bytecode_p->refs--;
        -: 1491:
    #####: 1492:  if (bytecode_p->refs > 0)
        -: 1493:  {
        -: 1494:    /* Non-zero reference counter. */
    #####: 1495:    return;
        -: 1496:  }
        -: 1497:
    #####: 1498:  if (CBC_IS_FUNCTION (bytecode_p->status_flags))
        -: 1499:  {
    #####: 1500:    ecma_value_t *literal_start_p = NULL;
        -: 1501:    uint32_t literal_end;
        -: 1502:    uint32_t const_literal_end;
        -: 1503:
    #####: 1504:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1505:    {
    #####: 1506:      cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_p;
    #####: 1507:      literal_end = args_p->literal_end;
    #####: 1508:      const_literal_end = args_p->const_literal_end;
        -: 1509:
    #####: 1510:      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint16_arguments_t));
    #####: 1511:      literal_start_p -= args_p->register_end;
        -: 1512:    }
        -: 1513:    else
        -: 1514:    {
    #####: 1515:      cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_p;
    #####: 1516:      literal_end = args_p->literal_end;
    #####: 1517:      const_literal_end = args_p->const_literal_end;
        -: 1518:
    #####: 1519:      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint8_arguments_t));
    #####: 1520:      literal_start_p -= args_p->register_end;
        -: 1521:    }
        -: 1522:
    #####: 1523:    for (uint32_t i = const_literal_end; i < literal_end; i++)
        -: 1524:    {
    #####: 1525:      ecma_compiled_code_t *bytecode_literal_p =
    #####: 1526:        ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[i]);
        -: 1527:
        -: 1528:      /* Self references are ignored. */
    #####: 1529:      if (bytecode_literal_p != bytecode_p)
        -: 1530:      {
    #####: 1531:        ecma_bytecode_deref (bytecode_literal_p);
        -: 1532:      }
        -: 1533:    }
        -: 1534:
    #####: 1535:    ecma_script_deref (((cbc_uint8_arguments_t *) bytecode_p)->script_value);
        -: 1536:
        -: 1537:#if JERRY_ESNEXT
    #####: 1538:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS)
        -: 1539:    {
    #####: 1540:      ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_p);
        -: 1541:
        -: 1542:      /* Since the objects in the tagged template collection are not strong referenced anymore by the compiled code
        -: 1543:         we can treat them as 'new' objects. */
    #####: 1544:      JERRY_CONTEXT (ecma_gc_new_objects) += collection_p->item_count * 2;
    #####: 1545:      ecma_collection_free_template_literal (collection_p);
        -: 1546:    }
        -: 1547:#endif /* JERRY_ESNEXT */
        -: 1548:
        -: 1549:#if JERRY_LINE_INFO
    #####: 1550:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO)
        -: 1551:    {
    #####: 1552:      ecma_line_info_free (ecma_compiled_code_get_line_info (bytecode_p));
        -: 1553:    }
        -: 1554:#endif /* JERRY_LINE_INFO */
        -: 1555:
        -: 1556:#if JERRY_DEBUGGER
        -: 1557:    if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1558:        && !(bytecode_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE)
        -: 1559:        && jerry_debugger_send_function_cp (JERRY_DEBUGGER_RELEASE_BYTE_CODE_CP, bytecode_p))
        -: 1560:    {
        -: 1561:      /* Delay the byte code free until the debugger client is notified.
        -: 1562:       * If the connection is aborted the pointer is still freed by
        -: 1563:       * jerry_debugger_close_connection(). */
        -: 1564:      jerry_debugger_byte_code_free_t *byte_code_free_p = (jerry_debugger_byte_code_free_t *) bytecode_p;
        -: 1565:      jmem_cpointer_t byte_code_free_head = JERRY_CONTEXT (debugger_byte_code_free_head);
        -: 1566:
        -: 1567:      byte_code_free_p->prev_cp = ECMA_NULL_POINTER;
        -: 1568:
        -: 1569:      jmem_cpointer_t byte_code_free_cp;
        -: 1570:      JMEM_CP_SET_NON_NULL_POINTER (byte_code_free_cp, byte_code_free_p);
        -: 1571:
        -: 1572:      if (byte_code_free_head == ECMA_NULL_POINTER)
        -: 1573:      {
        -: 1574:        JERRY_CONTEXT (debugger_byte_code_free_tail) = byte_code_free_cp;
        -: 1575:      }
        -: 1576:      else
        -: 1577:      {
        -: 1578:        jerry_debugger_byte_code_free_t *first_byte_code_free_p;
        -: 1579:
        -: 1580:        first_byte_code_free_p = JMEM_CP_GET_NON_NULL_POINTER (jerry_debugger_byte_code_free_t, byte_code_free_head);
        -: 1581:        first_byte_code_free_p->prev_cp = byte_code_free_cp;
        -: 1582:      }
        -: 1583:
        -: 1584:      JERRY_CONTEXT (debugger_byte_code_free_head) = byte_code_free_cp;
        -: 1585:      return;
        -: 1586:    }
        -: 1587:#endif /* JERRY_DEBUGGER */
        -: 1588:
        -: 1589:#if JERRY_MEM_STATS
    #####: 1590:    jmem_stats_free_byte_code_bytes (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
        -: 1591:#endif /* JERRY_MEM_STATS */
        -: 1592:  }
        -: 1593:  else
        -: 1594:  {
        -: 1595:#if JERRY_BUILTIN_REGEXP
    #####: 1596:    re_compiled_code_t *re_bytecode_p = (re_compiled_code_t *) bytecode_p;
        -: 1597:
    #####: 1598:    ecma_deref_ecma_string (ecma_get_string_from_value (re_bytecode_p->source));
        -: 1599:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1600:  }
        -: 1601:
    #####: 1602:  jmem_heap_free_block (bytecode_p, ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
        -: 1603:} /* ecma_bytecode_deref */
        -: 1604:
        -: 1605:/**
        -: 1606: * Gets the script data asigned to a script / module / function
        -: 1607: *
        -: 1608: * @return script data - if available, JMEM_CP_NULL - otherwise
        -: 1609: */
        -: 1610:ecma_value_t
    #####: 1611:ecma_script_get_from_value (ecma_value_t value) /**< compiled code */
        -: 1612:{
    #####: 1613:  if (!ecma_is_value_object (value))
        -: 1614:  {
    #####: 1615:    return JMEM_CP_NULL;
        -: 1616:  }
        -: 1617:
    #####: 1618:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 1619:  const ecma_compiled_code_t *bytecode_p = NULL;
        -: 1620:
        -: 1621:  while (true)
        -: 1622:  {
    #####: 1623:    switch (ecma_get_object_type (object_p))
        -: 1624:    {
    #####: 1625:      case ECMA_OBJECT_TYPE_CLASS:
        -: 1626:      {
    #####: 1627:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1628:
    #####: 1629:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 1630:        {
    #####: 1631:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
    #####: 1632:          break;
        -: 1633:        }
        -: 1634:
        -: 1635:#if JERRY_MODULE_SYSTEM
    #####: 1636:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 1637:        {
    #####: 1638:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 1639:
    #####: 1640:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 1641:          {
    #####: 1642:            bytecode_p = module_p->u.compiled_code_p;
    #####: 1643:            break;
        -: 1644:          }
        -: 1645:        }
        -: 1646:#endif /* JERRY_MODULE_SYSTEM */
    #####: 1647:        return JMEM_CP_NULL;
        -: 1648:      }
    #####: 1649:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1650:      {
    #####: 1651:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
    #####: 1652:        break;
        -: 1653:      }
    #####: 1654:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1655:      {
    #####: 1656:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1657:
    #####: 1658:        object_p =
    #####: 1659:          ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_object_p->u.bound_function.target_function);
    #####: 1660:        continue;
        -: 1661:      }
        -: 1662:#if JERRY_ESNEXT
    #####: 1663:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 1664:      {
    #####: 1665:        return ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
        -: 1666:      }
        -: 1667:#endif /* JERRY_ESNEXT */
    #####: 1668:      default:
        -: 1669:      {
    #####: 1670:        return JMEM_CP_NULL;
        -: 1671:      }
        -: 1672:    }
        -: 1673:
    #####: 1674:    JERRY_ASSERT (bytecode_p != NULL);
    #####: 1675:    return ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
        -: 1676:  }
        -: 1677:} /* ecma_script_get_from_value */
        -: 1678:
        -: 1679:/**
        -: 1680: * Resolve the position of the arguments list start of the compiled code
        -: 1681: *
        -: 1682: * @return start position of the arguments list start of the compiled code
        -: 1683: */
        -: 1684:ecma_value_t *
    #####: 1685:ecma_compiled_code_resolve_arguments_start (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1686:{
    #####: 1687:  JERRY_ASSERT (bytecode_header_p != NULL);
        -: 1688:
    #####: 1689:  uint8_t *byte_p = (uint8_t *) bytecode_header_p;
    #####: 1690:  byte_p += ((size_t) bytecode_header_p->size) << JMEM_ALIGNMENT_LOG;
        -: 1691:
    #####: 1692:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED))
        -: 1693:  {
    #####: 1694:    return ((ecma_value_t *) byte_p);
        -: 1695:  }
        -: 1696:
    #####: 1697:  if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)))
        -: 1698:  {
    #####: 1699:    return ((ecma_value_t *) byte_p) - ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 1700:  }
        -: 1701:
    #####: 1702:  return ((ecma_value_t *) byte_p) - ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 1703:} /* ecma_compiled_code_resolve_arguments_start */
        -: 1704:
        -: 1705:#if JERRY_ESNEXT
        -: 1706:
        -: 1707:/**
        -: 1708: * Resolve the position of the function name of the compiled code
        -: 1709: *
        -: 1710: * @return position of the function name of the compiled code
        -: 1711: */
        -: 1712:extern inline ecma_value_t *JERRY_ATTR_ALWAYS_INLINE
    #####: 1713:ecma_compiled_code_resolve_function_name (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1714:{
    #####: 1715:  JERRY_ASSERT (bytecode_header_p != NULL);
    #####: 1716:  ecma_value_t *base_p = ecma_compiled_code_resolve_arguments_start (bytecode_header_p);
        -: 1717:
    #####: 1718:  if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)
        -: 1719:  {
    #####: 1720:    base_p--;
        -: 1721:  }
        -: 1722:
    #####: 1723:  return base_p;
        -: 1724:} /* ecma_compiled_code_resolve_function_name */
        -: 1725:
        -: 1726:/**
        -: 1727: * Get the tagged template collection of the compiled code
        -: 1728: *
        -: 1729: * @return pointer to the tagged template collection
        -: 1730: */
        -: 1731:ecma_collection_t *
    #####: 1732:ecma_compiled_code_get_tagged_template_collection (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1733:{
    #####: 1734:  JERRY_ASSERT (bytecode_header_p != NULL);
    #####: 1735:  JERRY_ASSERT (bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS);
        -: 1736:
    #####: 1737:  ecma_value_t *base_p = ecma_compiled_code_resolve_function_name (bytecode_header_p);
    #####: 1738:  return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, base_p[-1]);
        -: 1739:} /* ecma_compiled_code_get_tagged_template_collection */
        -: 1740:
        -: 1741:#endif /* JERRY_ESNEXT */
        -: 1742:
        -: 1743:#if JERRY_LINE_INFO
        -: 1744:
        -: 1745:/**
        -: 1746: * Get the line info data from the byte code
        -: 1747: *
        -: 1748: * @return pointer to the line info data
        -: 1749: */
        -: 1750:uint8_t *
    #####: 1751:ecma_compiled_code_get_line_info (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1752:{
    #####: 1753:  JERRY_ASSERT (bytecode_header_p != NULL);
    #####: 1754:  JERRY_ASSERT (bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO);
        -: 1755:
    #####: 1756:  ecma_value_t *base_p = ecma_compiled_code_resolve_arguments_start (bytecode_header_p);
        -: 1757:
        -: 1758:#if JERRY_ESNEXT
    #####: 1759:  if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)
        -: 1760:  {
    #####: 1761:    base_p--;
        -: 1762:  }
        -: 1763:
    #####: 1764:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS)
        -: 1765:  {
    #####: 1766:    base_p--;
        -: 1767:  }
        -: 1768:#endif /* JERRY_ESNEXT */
        -: 1769:
    #####: 1770:  return ECMA_GET_INTERNAL_VALUE_POINTER (uint8_t, base_p[-1]);
        -: 1771:} /* ecma_compiled_code_get_line_info */
        -: 1772:
        -: 1773:#endif /* JERRY_LINE_INFO */
        -: 1774:
        -: 1775:/**
        -: 1776: * Get the source name of a compiled code.
        -: 1777: *
        -: 1778: * @return source name value
        -: 1779: */
        -: 1780:ecma_value_t
    #####: 1781:ecma_get_source_name (const ecma_compiled_code_t *bytecode_p) /**< compiled code */
        -: 1782:{
        -: 1783:#if JERRY_SOURCE_NAME
        -: 1784:#if JERRY_SNAPSHOT_EXEC
    #####: 1785:  if (JERRY_UNLIKELY (bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1786:  {
    #####: 1787:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 1788:  }
        -: 1789:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1790:
    #####: 1791:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 1792:  return ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value)->source_name;
        -: 1793:#else /* !JERRY_SOURCE_NAME */
        -: 1794:  JERRY_UNUSED (bytecode_p);
        -: 1795:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 1796:#endif /* !JERRY_SOURCE_NAME */
        -: 1797:} /* ecma_get_source_name */
        -: 1798:
        -: 1799:#if (JERRY_STACK_LIMIT != 0)
        -: 1800:/**
        -: 1801: * Check the current stack usage by calculating the difference from the initial stack base.
        -: 1802: *
        -: 1803: * @return current stack usage in bytes
        -: 1804: */
        -: 1805:uintptr_t JERRY_ATTR_NOINLINE
        4: 1806:ecma_get_current_stack_usage (void)
        -: 1807:{
        4: 1808:  volatile int __sp;
        4: 1809:  return (uintptr_t) (JERRY_CONTEXT (stack_base) - (uintptr_t) &__sp);
        -: 1810:} /* ecma_get_current_stack_usage */
        -: 1811:
        -: 1812:#endif /* (JERRY_STACK_LIMIT != 0) */
        -: 1813:
        -: 1814:/**
        -: 1815: * @}
        -: 1816: * @}
        -: 1817: */
