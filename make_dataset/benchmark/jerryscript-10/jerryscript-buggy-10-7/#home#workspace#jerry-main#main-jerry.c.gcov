        -:    0:Source:/home/workspace/jerry-main/main-jerry.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <assert.h>
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:#include "jerryscript-port-default.h"
        -:   22:#include "jerryscript-port.h"
        -:   23:#include "jerryscript.h"
        -:   24:
        -:   25:#include "jerryscript-ext/debugger.h"
        -:   26:#include "jerryscript-ext/handler.h"
        -:   27:#include "main-options.h"
        -:   28:#include "main-utils.h"
        -:   29:
        -:   30:/**
        -:   31: * Temporal buffer size.
        -:   32: */
        -:   33:#define JERRY_BUFFER_SIZE 256u
        -:   34:
        -:   35:#if defined(JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:   36:/**
        -:   37: * The alloc function passed to jerry_context_create
        -:   38: */
        -:   39:static void *
        -:   40:context_alloc (size_t size, void *cb_data_p)
        -:   41:{
        -:   42:  (void) cb_data_p; /* unused */
        -:   43:  return malloc (size);
        -:   44:} /* context_alloc */
        -:   45:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:   46:
        -:   47:
        -:   48:#ifdef DPP_ENABLE_GCOV
        -:   49:#include <gcov.h>
        -:   50:void __asan_on_error(void);
        1:   51:void __asan_on_error(void) {
        1:   52:  __gcov_flush();
    #####:   53:}
        -:   54:#endif
        -:   55:
        -:   56:int
        1:   57:main (int argc, char **argv)
        1:   58:{
        -:   59:  union
        -:   60:  {
        -:   61:    double d;
        -:   62:    unsigned u;
        1:   63:  } now = { .d = jerry_port_get_current_time () };
        1:   64:  srand (now.u);
        -:   65:
        1:   66:  JERRY_VLA (main_source_t, sources_p, argc);
        -:   67:
        1:   68:  main_args_t arguments;
        1:   69:  arguments.sources_p = sources_p;
        -:   70:
        1:   71:  main_parse_args (argc, argv, &arguments);
        -:   72:
        -:   73:#if defined(JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:   74:  jerry_context_t *context_p = jerry_context_alloc (JERRY_GLOBAL_HEAP_SIZE * 1024, context_alloc, NULL);
        -:   75:  jerry_port_default_set_current_context (context_p);
        -:   76:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:   77:
        1:   78:restart:
        1:   79:  main_init_engine (&arguments);
        1:   80:  int return_code = JERRY_STANDALONE_EXIT_CODE_FAIL;
        1:   81:  jerry_value_t ret_value;
        -:   82:
        1:   83:  for (uint32_t source_index = 0; source_index < arguments.source_count; source_index++)
        -:   84:  {
        1:   85:    main_source_t *source_file_p = sources_p + source_index;
        1:   86:    const char *file_path_p = argv[source_file_p->path_index];
        -:   87:
        1:   88:    if (source_file_p->type == SOURCE_MODULE)
        -:   89:    {
    #####:   90:      jerry_value_t specifier =
    #####:   91:        jerry_string ((const jerry_char_t *) file_path_p, (jerry_size_t) strlen (file_path_p), JERRY_ENCODING_UTF8);
    #####:   92:      jerry_value_t referrer = jerry_undefined ();
    #####:   93:      ret_value = jerry_port_module_resolve (specifier, referrer, NULL);
    #####:   94:      jerry_value_free (referrer);
    #####:   95:      jerry_value_free (specifier);
        -:   96:
    #####:   97:      if (!jerry_value_is_exception (ret_value))
        -:   98:      {
    #####:   99:        if (jerry_module_state (ret_value) != JERRY_MODULE_STATE_UNLINKED)
        -:  100:        {
        -:  101:          /* A module can be evaluated only once. */
    #####:  102:          jerry_value_free (ret_value);
    #####:  103:          continue;
        -:  104:        }
        -:  105:
    #####:  106:        jerry_value_t link_val = jerry_module_link (ret_value, NULL, NULL);
        -:  107:
    #####:  108:        if (jerry_value_is_exception (link_val))
        -:  109:        {
    #####:  110:          jerry_value_free (ret_value);
    #####:  111:          ret_value = link_val;
        -:  112:        }
        -:  113:        else
        -:  114:        {
    #####:  115:          jerry_value_free (link_val);
        -:  116:
    #####:  117:          jerry_value_t module_val = ret_value;
    #####:  118:          ret_value = jerry_module_evaluate (module_val);
    #####:  119:          jerry_value_free (module_val);
        -:  120:        }
        -:  121:      }
        -:  122:
    #####:  123:      if (jerry_value_is_exception (ret_value))
        -:  124:      {
    #####:  125:        main_print_unhandled_exception (ret_value);
    #####:  126:        goto exit;
        -:  127:      }
        -:  128:
    #####:  129:      jerry_value_free (ret_value);
    #####:  130:      continue;
        -:  131:    }
        -:  132:
        1:  133:    size_t source_size;
        1:  134:    uint8_t *source_p = jerry_port_read_source (file_path_p, &source_size);
        -:  135:
        1:  136:    if (source_p == NULL)
        -:  137:    {
    #####:  138:      goto exit;
        -:  139:    }
        -:  140:
        1:  141:    switch (source_file_p->type)
        -:  142:    {
    #####:  143:      case SOURCE_SNAPSHOT:
        -:  144:      {
    #####:  145:        ret_value = jerry_exec_snapshot ((uint32_t *) source_p,
        -:  146:                                         source_size,
    #####:  147:                                         source_file_p->snapshot_index,
        -:  148:                                         JERRY_SNAPSHOT_EXEC_COPY_DATA,
        -:  149:                                         NULL);
        -:  150:
    #####:  151:        jerry_port_release_source (source_p);
    #####:  152:        break;
        -:  153:      }
        1:  154:      default:
        -:  155:      {
        1:  156:        assert (source_file_p->type == SOURCE_SCRIPT || source_file_p->type == SOURCE_MODULE);
        -:  157:
        1:  158:        if (!jerry_validate_string ((jerry_char_t *) source_p, (jerry_size_t) source_size, JERRY_ENCODING_UTF8))
        -:  159:        {
    #####:  160:          jerry_port_release_source (source_p);
    #####:  161:          jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Input must be a valid UTF-8 string.");
    #####:  162:          goto exit;
        -:  163:        }
        -:  164:
        1:  165:        jerry_parse_options_t parse_options;
        1:  166:        parse_options.options = JERRY_PARSE_HAS_SOURCE_NAME;
        1:  167:        parse_options.source_name =
        1:  168:          jerry_string ((const jerry_char_t *) file_path_p, (jerry_size_t) strlen (file_path_p), JERRY_ENCODING_UTF8);
        -:  169:
        1:  170:        ret_value = jerry_parse (source_p, source_size, &parse_options);
        -:  171:
        1:  172:        jerry_value_free (parse_options.source_name);
        1:  173:        jerry_port_release_source (source_p);
        -:  174:
        1:  175:        if (!jerry_value_is_exception (ret_value) && !(arguments.option_flags & OPT_FLAG_PARSE_ONLY))
        -:  176:        {
        1:  177:          jerry_value_t func_val = ret_value;
        1:  178:          ret_value = jerry_run (func_val);
    #####:  179:          jerry_value_free (func_val);
        -:  180:        }
        -:  181:
    #####:  182:        break;
        -:  183:      }
        -:  184:    }
        -:  185:
    #####:  186:    if (jerry_value_is_exception (ret_value))
        -:  187:    {
    #####:  188:      if (main_is_value_reset (ret_value))
        -:  189:      {
    #####:  190:        jerry_cleanup ();
        -:  191:
    #####:  192:        goto restart;
        -:  193:      }
        -:  194:
    #####:  195:      main_print_unhandled_exception (ret_value);
    #####:  196:      goto exit;
        -:  197:    }
        -:  198:
    #####:  199:    jerry_value_free (ret_value);
        -:  200:  }
        -:  201:
    #####:  202:  if (arguments.option_flags & OPT_FLAG_WAIT_SOURCE)
        -:  203:  {
        -:  204:    while (true)
    #####:  205:    {
        -:  206:      jerry_debugger_wait_for_source_status_t receive_status;
    #####:  207:      receive_status = jerry_debugger_wait_for_client_source (main_wait_for_source_callback, NULL, &ret_value);
        -:  208:
    #####:  209:      if (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVE_FAILED)
        -:  210:      {
    #####:  211:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Connection aborted before source arrived.");
    #####:  212:        goto exit;
        -:  213:      }
        -:  214:
    #####:  215:      if (receive_status == JERRY_DEBUGGER_SOURCE_END)
        -:  216:      {
    #####:  217:        jerry_port_log (JERRY_LOG_LEVEL_DEBUG, "No more client source.\n");
    #####:  218:        break;
        -:  219:      }
        -:  220:
    #####:  221:      assert (receive_status == JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED
        -:  222:              || receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);
        -:  223:
    #####:  224:      if (receive_status == JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED || main_is_value_reset (ret_value))
        -:  225:      {
    #####:  226:        jerry_cleanup ();
    #####:  227:        goto restart;
        -:  228:      }
        -:  229:
    #####:  230:      assert (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);
    #####:  231:      jerry_value_free (ret_value);
        -:  232:    }
        -:  233:  }
    #####:  234:  else if (arguments.option_flags & OPT_FLAG_USE_STDIN)
        -:  235:  {
    #####:  236:    char buffer[JERRY_BUFFER_SIZE];
    #####:  237:    char *source_p = NULL;
    #####:  238:    size_t source_size = 0;
        -:  239:
    #####:  240:    while (!feof (stdin))
        -:  241:    {
    #####:  242:      size_t read_bytes = fread (buffer, 1u, JERRY_BUFFER_SIZE, stdin);
        -:  243:
    #####:  244:      size_t new_size = source_size + read_bytes;
    #####:  245:      source_p = realloc (source_p, new_size);
        -:  246:
    #####:  247:      memcpy (source_p + source_size, buffer, read_bytes);
    #####:  248:      source_size = new_size;
        -:  249:    }
        -:  250:
    #####:  251:    ret_value = jerry_parse ((jerry_char_t *) source_p, source_size, NULL);
    #####:  252:    free (source_p);
        -:  253:
    #####:  254:    if (jerry_value_is_exception (ret_value))
        -:  255:    {
    #####:  256:      main_print_unhandled_exception (ret_value);
    #####:  257:      goto exit;
        -:  258:    }
        -:  259:
    #####:  260:    jerry_value_t func_val = ret_value;
    #####:  261:    ret_value = jerry_run (func_val);
    #####:  262:    jerry_value_free (func_val);
        -:  263:
    #####:  264:    if (jerry_value_is_exception (ret_value))
        -:  265:    {
    #####:  266:      main_print_unhandled_exception (ret_value);
    #####:  267:      goto exit;
        -:  268:    }
        -:  269:
    #####:  270:    jerry_value_free (ret_value);
        -:  271:  }
    #####:  272:  else if (arguments.source_count == 0)
        -:  273:  {
    #####:  274:    const char *prompt = (arguments.option_flags & OPT_FLAG_NO_PROMPT) ? "" : "jerry> ";
    #####:  275:    char buffer[JERRY_BUFFER_SIZE];
        -:  276:
        -:  277:    while (true)
    #####:  278:    {
    #####:  279:      printf ("%s", prompt);
    #####:  280:      char *str_p = fgets (buffer, JERRY_BUFFER_SIZE, stdin);
        -:  281:
    #####:  282:      if (str_p == NULL)
        -:  283:      {
    #####:  284:        printf ("\n");
    #####:  285:        break;
        -:  286:      }
        -:  287:
    #####:  288:      size_t len = strlen (str_p);
        -:  289:
    #####:  290:      if (len == 0)
        -:  291:      {
    #####:  292:        continue;
        -:  293:      }
        -:  294:
    #####:  295:      if (!jerry_validate_string ((jerry_char_t *) str_p, (jerry_size_t) len, JERRY_ENCODING_UTF8))
        -:  296:      {
    #####:  297:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Input must be a valid UTF-8 string.\n");
    #####:  298:        continue;
        -:  299:      }
        -:  300:
    #####:  301:      ret_value = jerry_parse ((jerry_char_t *) str_p, len, NULL);
        -:  302:
    #####:  303:      if (jerry_value_is_exception (ret_value))
        -:  304:      {
    #####:  305:        main_print_unhandled_exception (ret_value);
    #####:  306:        continue;
        -:  307:      }
        -:  308:
    #####:  309:      jerry_value_t func_val = ret_value;
    #####:  310:      ret_value = jerry_run (func_val);
    #####:  311:      jerry_value_free (func_val);
        -:  312:
    #####:  313:      if (jerry_value_is_exception (ret_value))
        -:  314:      {
    #####:  315:        main_print_unhandled_exception (ret_value);
    #####:  316:        continue;
        -:  317:      }
        -:  318:
    #####:  319:      const jerry_value_t args[] = { ret_value };
    #####:  320:      jerry_value_t ret_val_print = jerryx_handler_print (NULL, args, 1);
    #####:  321:      jerry_value_free (ret_val_print);
    #####:  322:      jerry_value_free (ret_value);
    #####:  323:      ret_value = jerry_run_jobs ();
        -:  324:
    #####:  325:      if (jerry_value_is_exception (ret_value))
        -:  326:      {
    #####:  327:        main_print_unhandled_exception (ret_value);
    #####:  328:        continue;
        -:  329:      }
        -:  330:
    #####:  331:      jerry_value_free (ret_value);
        -:  332:    }
        -:  333:  }
        -:  334:
    #####:  335:  ret_value = jerry_run_jobs ();
        -:  336:
    #####:  337:  if (jerry_value_is_exception (ret_value))
        -:  338:  {
    #####:  339:    main_print_unhandled_exception (ret_value);
    #####:  340:    goto exit;
        -:  341:  }
        -:  342:
    #####:  343:  jerry_value_free (ret_value);
        -:  344:
    #####:  345:  if (arguments.exit_cb_name_p != NULL)
        -:  346:  {
    #####:  347:    jerry_value_t global = jerry_current_realm ();
    #####:  348:    jerry_value_t name_str = jerry_string_sz (arguments.exit_cb_name_p);
    #####:  349:    jerry_value_t callback_fn = jerry_object_get (global, name_str);
        -:  350:
    #####:  351:    jerry_value_free (global);
    #####:  352:    jerry_value_free (name_str);
        -:  353:
    #####:  354:    if (jerry_value_is_function (callback_fn))
        -:  355:    {
    #####:  356:      ret_value = jerry_call (callback_fn, jerry_undefined (), NULL, 0);
        -:  357:
    #####:  358:      if (jerry_value_is_exception (ret_value))
        -:  359:      {
    #####:  360:        main_print_unhandled_exception (ret_value);
    #####:  361:        goto exit;
        -:  362:      }
        -:  363:
    #####:  364:      jerry_value_free (ret_value);
        -:  365:    }
        -:  366:
    #####:  367:    jerry_value_free (callback_fn);
        -:  368:  }
        -:  369:
    #####:  370:  return_code = JERRY_STANDALONE_EXIT_CODE_OK;
        -:  371:
    #####:  372:exit:
    #####:  373:  jerry_cleanup ();
        -:  374:
        -:  375:#if defined(JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1)
        -:  376:  free (context_p);
        -:  377:#endif /* defined (JERRY_EXTERNAL_CONTEXT) && (JERRY_EXTERNAL_CONTEXT == 1) */
        -:  378:
    #####:  379:  return return_code;
        -:  380:} /* main */
