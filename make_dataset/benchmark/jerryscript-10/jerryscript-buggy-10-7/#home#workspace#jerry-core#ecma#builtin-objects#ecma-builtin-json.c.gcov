        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-json.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-objects-general.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#include "jrt-libc-includes.h"
        -:   30:#include "jrt.h"
        -:   31:#include "lit-char-helpers.h"
        -:   32:#include "lit-globals.h"
        -:   33:
        -:   34:#if JERRY_BUILTIN_JSON
        -:   35:
        -:   36:#define ECMA_BUILTINS_INTERNAL
        -:   37:#include "ecma-builtins-internal.h"
        -:   38:
        -:   39:/**
        -:   40: * This object has a custom dispatch function.
        -:   41: */
        -:   42:#define BUILTIN_CUSTOM_DISPATCH
        -:   43:
        -:   44:/**
        -:   45: * List of built-in routine identifiers.
        -:   46: */
        -:   47:enum
        -:   48:{
        -:   49:  ECMA_BUILTIN_JSON_ROUTINE_START = 0,
        -:   50:  ECMA_BUILTIN_JSON_PARSE,
        -:   51:  ECMA_BUILTIN_JSON_STRINGIFY,
        -:   52:};
        -:   53:
        -:   54:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-json.inc.h"
        -:   55:#define BUILTIN_UNDERSCORED_ID  json
        -:   56:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   57:
        -:   58:/**
        -:   59: * The number of expected hexidecimal characters in a hex escape sequence
        -:   60: */
        -:   61:#define ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH (4)
        -:   62:
        -:   63:/** \addtogroup ecma ECMA
        -:   64: * @{
        -:   65: *
        -:   66: * \addtogroup ecmabuiltins
        -:   67: * @{
        -:   68: *
        -:   69: * \addtogroup json ECMA JSON object built-in
        -:   70: * @{
        -:   71: */
        -:   72:
        -:   73:/**
        -:   74: * JSON token type
        -:   75: */
        -:   76:typedef enum
        -:   77:{
        -:   78:  TOKEN_INVALID, /**< error token */
        -:   79:  TOKEN_END, /**< end of stream reached */
        -:   80:  TOKEN_NUMBER, /**< JSON number */
        -:   81:  TOKEN_STRING, /**< JSON string */
        -:   82:  TOKEN_NULL, /**< JSON null primitive value */
        -:   83:  TOKEN_TRUE, /**< JSON true primitive value */
        -:   84:  TOKEN_FALSE, /**< JSON false primitive value */
        -:   85:  TOKEN_LEFT_BRACE, /**< JSON left brace */
        -:   86:  TOKEN_RIGHT_BRACE, /**< JSON right brace */
        -:   87:  TOKEN_LEFT_SQUARE, /**< JSON left square bracket */
        -:   88:  TOKEN_RIGHT_SQUARE, /**< JSON right square bracket */
        -:   89:  TOKEN_COMMA, /**< JSON comma */
        -:   90:  TOKEN_COLON /**< JSON colon */
        -:   91:} ecma_json_token_type_t;
        -:   92:
        -:   93:/**
        -:   94: * JSON token
        -:   95: */
        -:   96:typedef struct
        -:   97:{
        -:   98:  ecma_json_token_type_t type; /**< type of the current token */
        -:   99:  const lit_utf8_byte_t *current_p; /**< current position of the string processed by the parser */
        -:  100:  const lit_utf8_byte_t *end_p; /**< end of the string processed by the parser */
        -:  101:
        -:  102:  /**
        -:  103:   * Fields depending on type.
        -:  104:   */
        -:  105:  union
        -:  106:  {
        -:  107:    ecma_string_t *string_p; /**< when type is string_token it contains the string */
        -:  108:    ecma_number_t number; /**< when type is number_token, it contains the value of the number */
        -:  109:  } u;
        -:  110:} ecma_json_token_t;
        -:  111:
        -:  112:/**
        -:  113: * Parse and extract string token.
        -:  114: */
        -:  115:static void
    #####:  116:ecma_builtin_json_parse_string (ecma_json_token_t *token_p) /**< token argument */
        -:  117:{
    #####:  118:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  119:  const lit_utf8_byte_t *end_p = token_p->end_p;
        -:  120:
    #####:  121:  ecma_stringbuilder_t result_builder = ecma_stringbuilder_create ();
    #####:  122:  const lit_utf8_byte_t *unappended_p = current_p;
        -:  123:
        -:  124:  while (true)
        -:  125:  {
    #####:  126:    if (current_p >= end_p || *current_p <= 0x1f)
        -:  127:    {
        -:  128:      goto invalid_string;
        -:  129:    }
        -:  130:
    #####:  131:    if (*current_p == LIT_CHAR_DOUBLE_QUOTE)
        -:  132:    {
    #####:  133:      break;
        -:  134:    }
        -:  135:
    #####:  136:    if (*current_p >= LIT_UTF8_4_BYTE_MARKER)
        -:  137:    {
    #####:  138:      ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
    #####:  139:      JERRY_ASSERT (current_p + 4 <= end_p);
        -:  140:
    #####:  141:      lit_code_point_t cp;
    #####:  142:      lit_utf8_size_t read_size = lit_read_code_point_from_utf8 (current_p, 4, &cp);
    #####:  143:      JERRY_ASSERT (read_size == 4);
        -:  144:
    #####:  145:      ecma_stringbuilder_append_codepoint (&result_builder, cp);
    #####:  146:      current_p += 4;
        -:  147:
    #####:  148:      unappended_p = current_p;
    #####:  149:      continue;
        -:  150:    }
        -:  151:
    #####:  152:    if (*current_p == LIT_CHAR_BACKSLASH)
        -:  153:    {
    #####:  154:      ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
        -:  155:
    #####:  156:      current_p++;
        -:  157:
        -:  158:      /* If there is an escape sequence but there's no escapable character just return */
    #####:  159:      if (current_p >= end_p)
        -:  160:      {
    #####:  161:        goto invalid_string;
        -:  162:      }
        -:  163:
    #####:  164:      const lit_utf8_byte_t c = *current_p;
    #####:  165:      switch (c)
        -:  166:      {
    #####:  167:        case LIT_CHAR_DOUBLE_QUOTE:
        -:  168:        case LIT_CHAR_SLASH:
        -:  169:        case LIT_CHAR_BACKSLASH:
        -:  170:        {
    #####:  171:          ecma_stringbuilder_append_byte (&result_builder, c);
    #####:  172:          current_p++;
    #####:  173:          break;
        -:  174:        }
    #####:  175:        case LIT_CHAR_LOWERCASE_B:
        -:  176:        {
    #####:  177:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_BS);
    #####:  178:          current_p++;
    #####:  179:          break;
        -:  180:        }
    #####:  181:        case LIT_CHAR_LOWERCASE_F:
        -:  182:        {
    #####:  183:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_FF);
    #####:  184:          current_p++;
    #####:  185:          break;
        -:  186:        }
    #####:  187:        case LIT_CHAR_LOWERCASE_N:
        -:  188:        {
    #####:  189:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_LF);
    #####:  190:          current_p++;
    #####:  191:          break;
        -:  192:        }
    #####:  193:        case LIT_CHAR_LOWERCASE_R:
        -:  194:        {
    #####:  195:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_CR);
    #####:  196:          current_p++;
    #####:  197:          break;
        -:  198:        }
    #####:  199:        case LIT_CHAR_LOWERCASE_T:
        -:  200:        {
    #####:  201:          ecma_stringbuilder_append_byte (&result_builder, LIT_CHAR_TAB);
    #####:  202:          current_p++;
    #####:  203:          break;
        -:  204:        }
    #####:  205:        case LIT_CHAR_LOWERCASE_U:
        -:  206:        {
    #####:  207:          uint32_t hex_value = lit_char_hex_lookup (current_p + 1, end_p, ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH);
    #####:  208:          if (hex_value == UINT32_MAX)
        -:  209:          {
    #####:  210:            goto invalid_string;
        -:  211:          }
        -:  212:
    #####:  213:          ecma_stringbuilder_append_char (&result_builder, (ecma_char_t) hex_value);
    #####:  214:          current_p += ECMA_JSON_HEX_ESCAPE_SEQUENCE_LENGTH + 1;
    #####:  215:          break;
        -:  216:        }
    #####:  217:        default:
        -:  218:        {
    #####:  219:          goto invalid_string;
        -:  220:        }
        -:  221:      }
        -:  222:
    #####:  223:      unappended_p = current_p;
    #####:  224:      continue;
        -:  225:    }
        -:  226:
    #####:  227:    current_p++;
        -:  228:  }
        -:  229:
    #####:  230:  ecma_stringbuilder_append_raw (&result_builder, unappended_p, (lit_utf8_size_t) (current_p - unappended_p));
    #####:  231:  token_p->u.string_p = ecma_stringbuilder_finalize (&result_builder);
    #####:  232:  token_p->current_p = current_p + 1;
    #####:  233:  token_p->type = TOKEN_STRING;
    #####:  234:  return;
        -:  235:
    #####:  236:invalid_string:
    #####:  237:  ecma_stringbuilder_destroy (&result_builder);
        -:  238:} /* ecma_builtin_json_parse_string */
        -:  239:
        -:  240:/**
        -:  241: * Parse and extract string token.
        -:  242: */
        -:  243:static void
    #####:  244:ecma_builtin_json_parse_number (ecma_json_token_t *token_p) /**< token argument */
        -:  245:{
    #####:  246:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  247:  const lit_utf8_byte_t *end_p = token_p->end_p;
    #####:  248:  const lit_utf8_byte_t *start_p = current_p;
        -:  249:
    #####:  250:  JERRY_ASSERT (current_p < end_p);
        -:  251:
    #####:  252:  if (*current_p == LIT_CHAR_MINUS)
        -:  253:  {
    #####:  254:    current_p++;
        -:  255:  }
        -:  256:
    #####:  257:  if (current_p >= end_p)
        -:  258:  {
    #####:  259:    return;
        -:  260:  }
        -:  261:
    #####:  262:  if (*current_p == LIT_CHAR_0)
        -:  263:  {
    #####:  264:    current_p++;
        -:  265:
    #####:  266:    if (current_p < end_p && lit_char_is_decimal_digit (*current_p))
        -:  267:    {
    #####:  268:      return;
        -:  269:    }
        -:  270:  }
    #####:  271:  else if (lit_char_is_decimal_digit (*current_p))
        -:  272:  {
        -:  273:    do
        -:  274:    {
    #####:  275:      current_p++;
    #####:  276:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  277:  }
        -:  278:
    #####:  279:  if (current_p < end_p && *current_p == LIT_CHAR_DOT)
        -:  280:  {
    #####:  281:    current_p++;
        -:  282:
    #####:  283:    if (current_p >= end_p || !lit_char_is_decimal_digit (*current_p))
        -:  284:    {
    #####:  285:      return;
        -:  286:    }
        -:  287:
        -:  288:    do
        -:  289:    {
    #####:  290:      current_p++;
    #####:  291:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  292:  }
        -:  293:
    #####:  294:  if (current_p < end_p && (*current_p == LIT_CHAR_LOWERCASE_E || *current_p == LIT_CHAR_UPPERCASE_E))
        -:  295:  {
    #####:  296:    current_p++;
        -:  297:
    #####:  298:    if (current_p < end_p && (*current_p == LIT_CHAR_PLUS || *current_p == LIT_CHAR_MINUS))
        -:  299:    {
    #####:  300:      current_p++;
        -:  301:    }
        -:  302:
    #####:  303:    if (current_p >= end_p || !lit_char_is_decimal_digit (*current_p))
        -:  304:    {
    #####:  305:      return;
        -:  306:    }
        -:  307:
        -:  308:    do
        -:  309:    {
    #####:  310:      current_p++;
    #####:  311:    } while (current_p < end_p && lit_char_is_decimal_digit (*current_p));
        -:  312:  }
        -:  313:
    #####:  314:  token_p->type = TOKEN_NUMBER;
    #####:  315:  token_p->u.number = ecma_utf8_string_to_number (start_p, (lit_utf8_size_t) (current_p - start_p), 0);
        -:  316:
    #####:  317:  token_p->current_p = current_p;
        -:  318:} /* ecma_builtin_json_parse_number */
        -:  319:
        -:  320:/**
        -:  321: * Parse next token.
        -:  322: *
        -:  323: * The function fills the fields of the ecma_json_token_t
        -:  324: * argument and advances the string pointer.
        -:  325: */
        -:  326:static void
    #####:  327:ecma_builtin_json_parse_next_token (ecma_json_token_t *token_p, /**< token argument */
        -:  328:                                    bool parse_string) /**< strings are allowed to parse */
        -:  329:{
    #####:  330:  const lit_utf8_byte_t *current_p = token_p->current_p;
    #####:  331:  const lit_utf8_byte_t *end_p = token_p->end_p;
    #####:  332:  token_p->type = TOKEN_INVALID;
        -:  333:
    #####:  334:  while (current_p < end_p
    #####:  335:         && (*current_p == LIT_CHAR_SP || *current_p == LIT_CHAR_CR || *current_p == LIT_CHAR_LF
    #####:  336:             || *current_p == LIT_CHAR_TAB))
        -:  337:  {
    #####:  338:    current_p++;
        -:  339:  }
        -:  340:
    #####:  341:  if (current_p == end_p)
        -:  342:  {
    #####:  343:    token_p->type = TOKEN_END;
    #####:  344:    return;
        -:  345:  }
        -:  346:
    #####:  347:  switch (*current_p)
        -:  348:  {
    #####:  349:    case LIT_CHAR_LEFT_BRACE:
        -:  350:    {
    #####:  351:      token_p->type = TOKEN_LEFT_BRACE;
    #####:  352:      token_p->current_p = current_p + 1;
    #####:  353:      return;
        -:  354:    }
    #####:  355:    case LIT_CHAR_RIGHT_BRACE:
        -:  356:    {
    #####:  357:      token_p->type = TOKEN_RIGHT_BRACE;
    #####:  358:      token_p->current_p = current_p + 1;
    #####:  359:      return;
        -:  360:    }
    #####:  361:    case LIT_CHAR_LEFT_SQUARE:
        -:  362:    {
    #####:  363:      token_p->type = TOKEN_LEFT_SQUARE;
    #####:  364:      token_p->current_p = current_p + 1;
    #####:  365:      return;
        -:  366:    }
    #####:  367:    case LIT_CHAR_RIGHT_SQUARE:
        -:  368:    {
    #####:  369:      token_p->type = TOKEN_RIGHT_SQUARE;
    #####:  370:      token_p->current_p = current_p + 1;
    #####:  371:      return;
        -:  372:    }
    #####:  373:    case LIT_CHAR_COMMA:
        -:  374:    {
    #####:  375:      token_p->type = TOKEN_COMMA;
    #####:  376:      token_p->current_p = current_p + 1;
    #####:  377:      return;
        -:  378:    }
    #####:  379:    case LIT_CHAR_COLON:
        -:  380:    {
    #####:  381:      token_p->type = TOKEN_COLON;
    #####:  382:      token_p->current_p = current_p + 1;
    #####:  383:      return;
        -:  384:    }
    #####:  385:    case LIT_CHAR_DOUBLE_QUOTE:
        -:  386:    {
    #####:  387:      if (parse_string)
        -:  388:      {
    #####:  389:        token_p->current_p = current_p + 1;
    #####:  390:        ecma_builtin_json_parse_string (token_p);
        -:  391:      }
    #####:  392:      return;
        -:  393:    }
    #####:  394:    case LIT_CHAR_LOWERCASE_N:
        -:  395:    {
    #####:  396:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_NULL);
    #####:  397:      if (current_p + size <= end_p)
        -:  398:      {
    #####:  399:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_NULL), current_p, size))
        -:  400:        {
    #####:  401:          token_p->type = TOKEN_NULL;
    #####:  402:          token_p->current_p = current_p + size;
    #####:  403:          return;
        -:  404:        }
        -:  405:      }
    #####:  406:      break;
        -:  407:    }
    #####:  408:    case LIT_CHAR_LOWERCASE_T:
        -:  409:    {
    #####:  410:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_TRUE);
    #####:  411:      if (current_p + size <= end_p)
        -:  412:      {
    #####:  413:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_TRUE), current_p, size))
        -:  414:        {
    #####:  415:          token_p->type = TOKEN_TRUE;
    #####:  416:          token_p->current_p = current_p + size;
    #####:  417:          return;
        -:  418:        }
        -:  419:      }
    #####:  420:      break;
        -:  421:    }
    #####:  422:    case LIT_CHAR_LOWERCASE_F:
        -:  423:    {
    #####:  424:      lit_utf8_size_t size = lit_get_magic_string_size (LIT_MAGIC_STRING_FALSE);
    #####:  425:      if (current_p + size <= end_p)
        -:  426:      {
    #####:  427:        if (!memcmp (lit_get_magic_string_utf8 (LIT_MAGIC_STRING_FALSE), current_p, size))
        -:  428:        {
    #####:  429:          token_p->type = TOKEN_FALSE;
    #####:  430:          token_p->current_p = current_p + size;
    #####:  431:          return;
        -:  432:        }
        -:  433:      }
    #####:  434:      break;
        -:  435:    }
    #####:  436:    default:
        -:  437:    {
    #####:  438:      if (*current_p == LIT_CHAR_MINUS || lit_char_is_decimal_digit (*current_p))
        -:  439:      {
    #####:  440:        token_p->current_p = current_p;
    #####:  441:        ecma_builtin_json_parse_number (token_p);
    #####:  442:        return;
        -:  443:      }
    #####:  444:      break;
        -:  445:    }
        -:  446:  }
        -:  447:} /* ecma_builtin_json_parse_next_token */
        -:  448:
        -:  449:/**
        -:  450: * Utility for defining properties.
        -:  451: *
        -:  452: * It silently ignores all errors.
        -:  453: */
        -:  454:static void
    #####:  455:ecma_builtin_json_define_value_property (ecma_object_t *obj_p, /**< this object */
        -:  456:                                         ecma_string_t *property_name_p, /**< property name */
        -:  457:                                         ecma_value_t value) /**< value */
        -:  458:{
    #####:  459:  ecma_value_t completion_value =
        -:  460:    ecma_builtin_helper_def_prop (obj_p, property_name_p, value, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  461:
    #####:  462:  JERRY_ASSERT (ecma_is_value_boolean (completion_value));
    #####:  463:} /* ecma_builtin_json_define_value_property */
        -:  464:
        -:  465:/**
        -:  466: * Parse next value.
        -:  467: *
        -:  468: * The function fills the fields of the ecma_json_token_t
        -:  469: * argument and advances the string pointer.
        -:  470: *
        -:  471: * @return ecma_value with the property value
        -:  472: */
        -:  473:static ecma_value_t
    #####:  474:ecma_builtin_json_parse_value (ecma_json_token_t *token_p) /**< token argument */
        -:  475:{
    #####:  476:  switch (token_p->type)
        -:  477:  {
    #####:  478:    case TOKEN_NUMBER:
        -:  479:    {
    #####:  480:      return ecma_make_number_value (token_p->u.number);
        -:  481:    }
    #####:  482:    case TOKEN_STRING:
        -:  483:    {
    #####:  484:      return ecma_make_string_value (token_p->u.string_p);
        -:  485:    }
    #####:  486:    case TOKEN_NULL:
        -:  487:    {
    #####:  488:      return ECMA_VALUE_NULL;
        -:  489:    }
    #####:  490:    case TOKEN_TRUE:
        -:  491:    {
    #####:  492:      return ECMA_VALUE_TRUE;
        -:  493:    }
    #####:  494:    case TOKEN_FALSE:
        -:  495:    {
    #####:  496:      return ECMA_VALUE_FALSE;
        -:  497:    }
    #####:  498:    case TOKEN_LEFT_BRACE:
        -:  499:    {
    #####:  500:      ecma_object_t *object_p = ecma_op_create_object_object_noarg ();
        -:  501:
    #####:  502:      ecma_builtin_json_parse_next_token (token_p, true);
        -:  503:
    #####:  504:      if (token_p->type == TOKEN_RIGHT_BRACE)
        -:  505:      {
    #####:  506:        return ecma_make_object_value (object_p);
        -:  507:      }
        -:  508:
        -:  509:      while (true)
    #####:  510:      {
    #####:  511:        if (token_p->type != TOKEN_STRING)
        -:  512:        {
    #####:  513:          break;
        -:  514:        }
        -:  515:
    #####:  516:        ecma_string_t *name_p = token_p->u.string_p;
        -:  517:
    #####:  518:        ecma_builtin_json_parse_next_token (token_p, false);
    #####:  519:        if (token_p->type != TOKEN_COLON)
        -:  520:        {
    #####:  521:          ecma_deref_ecma_string (name_p);
    #####:  522:          break;
        -:  523:        }
        -:  524:
    #####:  525:        ecma_builtin_json_parse_next_token (token_p, true);
    #####:  526:        ecma_value_t value = ecma_builtin_json_parse_value (token_p);
        -:  527:
    #####:  528:        if (ecma_is_value_empty (value))
        -:  529:        {
    #####:  530:          ecma_deref_ecma_string (name_p);
    #####:  531:          break;
        -:  532:        }
        -:  533:
    #####:  534:        ecma_builtin_json_define_value_property (object_p, name_p, value);
    #####:  535:        ecma_deref_ecma_string (name_p);
    #####:  536:        ecma_free_value (value);
        -:  537:
    #####:  538:        ecma_builtin_json_parse_next_token (token_p, false);
    #####:  539:        if (token_p->type == TOKEN_RIGHT_BRACE)
        -:  540:        {
    #####:  541:          return ecma_make_object_value (object_p);
        -:  542:        }
        -:  543:
    #####:  544:        if (token_p->type != TOKEN_COMMA)
        -:  545:        {
    #####:  546:          break;
        -:  547:        }
        -:  548:
    #####:  549:        ecma_builtin_json_parse_next_token (token_p, true);
        -:  550:      }
        -:  551:
        -:  552:      /*
        -:  553:       * Parse error occurred.
        -:  554:       */
    #####:  555:      ecma_deref_object (object_p);
    #####:  556:      return ECMA_VALUE_EMPTY;
        -:  557:    }
    #####:  558:    case TOKEN_LEFT_SQUARE:
        -:  559:    {
    #####:  560:      uint32_t length = 0;
    #####:  561:      ecma_object_t *array_p = ecma_op_new_array_object (0);
        -:  562:
    #####:  563:      ecma_builtin_json_parse_next_token (token_p, true);
        -:  564:
    #####:  565:      if (token_p->type == TOKEN_RIGHT_SQUARE)
        -:  566:      {
    #####:  567:        return ecma_make_object_value (array_p);
        -:  568:      }
        -:  569:
        -:  570:      while (true)
    #####:  571:      {
    #####:  572:        ecma_value_t value = ecma_builtin_json_parse_value (token_p);
        -:  573:
    #####:  574:        if (ecma_is_value_empty (value))
        -:  575:        {
    #####:  576:          JERRY_ASSERT (token_p->type != TOKEN_STRING);
    #####:  577:          break;
        -:  578:        }
        -:  579:
        -:  580:        ecma_value_t completion;
    #####:  581:        completion = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  582:                                                            length,
        -:  583:                                                            value,
        -:  584:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  585:        JERRY_ASSERT (ecma_is_value_true (completion));
    #####:  586:        ecma_free_value (value);
        -:  587:
    #####:  588:        ecma_builtin_json_parse_next_token (token_p, false);
        -:  589:
    #####:  590:        if (token_p->type == TOKEN_RIGHT_SQUARE)
        -:  591:        {
    #####:  592:          return ecma_make_object_value (array_p);
        -:  593:        }
        -:  594:
    #####:  595:        if (token_p->type != TOKEN_COMMA)
        -:  596:        {
    #####:  597:          JERRY_ASSERT (token_p->type != TOKEN_STRING);
    #####:  598:          break;
        -:  599:        }
        -:  600:
    #####:  601:        ecma_builtin_json_parse_next_token (token_p, true);
    #####:  602:        length++;
        -:  603:      }
        -:  604:
    #####:  605:      ecma_deref_object (array_p);
    #####:  606:      return ECMA_VALUE_EMPTY;
        -:  607:    }
    #####:  608:    default:
        -:  609:    {
    #####:  610:      return ECMA_VALUE_EMPTY;
        -:  611:    }
        -:  612:  }
        -:  613:} /* ecma_builtin_json_parse_value */
        -:  614:
        -:  615:static ecma_value_t ecma_builtin_json_internalize_process_property (ecma_object_t *reviver_p,
        -:  616:                                                                    ecma_object_t *object_p,
        -:  617:                                                                    ecma_string_t *prop_name);
        -:  618:
        -:  619:/**
        -:  620: * Abstract operation InternalizeJSONProperty
        -:  621: *
        -:  622: * See also:
        -:  623: *         ECMA-262 v5, 24.3.1.1
        -:  624: *         ECMA-262 v11, 24.5.1.1
        -:  625: *
        -:  626: * @return ecma value
        -:  627: *         Returned value must be freed with ecma_free_value.
        -:  628: */
        -:  629:static ecma_value_t
    #####:  630:ecma_builtin_json_internalize_property (ecma_object_t *reviver_p, /**< reviver function */
        -:  631:                                        ecma_object_t *holder_p, /**< holder object */
        -:  632:                                        ecma_string_t *name_p) /**< property name */
        -:  633:{
    #####:  634:  JERRY_ASSERT (reviver_p);
    #####:  635:  JERRY_ASSERT (holder_p);
    #####:  636:  JERRY_ASSERT (name_p);
        -:  637:
        -:  638:  /* 1. */
    #####:  639:  ecma_value_t value = ecma_op_object_get (holder_p, name_p);
        -:  640:
        -:  641:  /* 2. */
    #####:  642:  if (ECMA_IS_VALUE_ERROR (value))
        -:  643:  {
    #####:  644:    return value;
        -:  645:  }
        -:  646:
        -:  647:  /* 3. */
    #####:  648:  if (ecma_is_value_object (value))
        -:  649:  {
        -:  650:    /* 3.a */
    #####:  651:    ecma_value_t is_array = ecma_is_value_array (value);
        -:  652:
        -:  653:#if JERRY_ESNEXT
    #####:  654:    if (ECMA_IS_VALUE_ERROR (is_array))
        -:  655:    {
    #####:  656:      ecma_free_value (value);
    #####:  657:      return is_array;
        -:  658:    }
        -:  659:#endif /* JERRY_ESNEXT */
        -:  660:
    #####:  661:    ecma_object_t *object_p = ecma_get_object_from_value (value);
        -:  662:
        -:  663:    /* 3.c */
    #####:  664:    if (ecma_is_value_true (is_array))
        -:  665:    {
        -:  666:      /* 3.c.ii */
    #####:  667:      ecma_length_t length;
    #####:  668:      ecma_value_t to_len = ecma_op_object_get_length (object_p, &length);
        -:  669:
        -:  670:      /* 3.c.iii */
        -:  671:#if JERRY_BUILTIN_PROXY
    #####:  672:      if (ECMA_IS_VALUE_ERROR (to_len))
        -:  673:      {
    #####:  674:        ecma_deref_object (object_p);
    #####:  675:        return to_len;
        -:  676:      }
        -:  677:#endif /* JERRY_BUILTIN_PROXY */
    #####:  678:      JERRY_ASSERT (ecma_is_value_empty (to_len));
        -:  679:
        -:  680:      /* 3.c.iv */
    #####:  681:      for (ecma_length_t i = 0; i < length; i++)
        -:  682:      {
    #####:  683:        ecma_string_t *prop_index = ecma_new_ecma_string_from_length (i);
    #####:  684:        ecma_value_t result = ecma_builtin_json_internalize_process_property (reviver_p, object_p, prop_index);
        -:  685:
    #####:  686:        ecma_deref_ecma_string (prop_index);
        -:  687:
    #####:  688:        if (ECMA_IS_VALUE_ERROR (result))
        -:  689:        {
    #####:  690:          ecma_deref_object (object_p);
    #####:  691:          return result;
        -:  692:        }
        -:  693:
    #####:  694:        JERRY_ASSERT (result == ECMA_VALUE_TRUE);
        -:  695:      }
        -:  696:    }
        -:  697:    /* 3.d */
        -:  698:    else
        -:  699:    {
    #####:  700:      ecma_collection_t *props_p =
        -:  701:        ecma_op_object_get_enumerable_property_names (object_p, ECMA_ENUMERABLE_PROPERTY_KEYS);
        -:  702:#if JERRY_ESNEXT
    #####:  703:      if (JERRY_UNLIKELY (props_p == NULL))
        -:  704:      {
    #####:  705:        ecma_deref_object (object_p);
    #####:  706:        return ECMA_VALUE_ERROR;
        -:  707:      }
        -:  708:#else /* !JERRY_ESNEXT */
        -:  709:      JERRY_ASSERT (props_p != NULL);
        -:  710:#endif /* JERRY_ESNEXT */
        -:  711:
    #####:  712:      ecma_value_t *buffer_p = props_p->buffer_p;
        -:  713:
        -:  714:      /* 3.d.iii */
    #####:  715:      for (uint32_t i = 0; i < props_p->item_count; i++)
        -:  716:      {
    #####:  717:        ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
    #####:  718:        ecma_value_t result = ecma_builtin_json_internalize_process_property (reviver_p, object_p, property_name_p);
        -:  719:
    #####:  720:        if (ECMA_IS_VALUE_ERROR (result))
        -:  721:        {
    #####:  722:          ecma_collection_free (props_p);
    #####:  723:          ecma_deref_object (object_p);
    #####:  724:          return result;
        -:  725:        }
        -:  726:
    #####:  727:        JERRY_ASSERT (result == ECMA_VALUE_TRUE);
        -:  728:      }
        -:  729:
    #####:  730:      ecma_collection_free (props_p);
        -:  731:    }
        -:  732:  }
        -:  733:
    #####:  734:  ecma_value_t arguments_list[2];
    #####:  735:  arguments_list[0] = ecma_make_string_value (name_p);
    #####:  736:  arguments_list[1] = value;
        -:  737:
        -:  738:  /* 4. */
    #####:  739:  ecma_value_t ret_value = ecma_op_function_call (reviver_p, ecma_make_object_value (holder_p), arguments_list, 2);
    #####:  740:  ecma_free_value (value);
    #####:  741:  return ret_value;
        -:  742:} /* ecma_builtin_json_internalize_property */
        -:  743:
        -:  744:/**
        -:  745: * Part of the InternalizeJSONProperty abstract method.
        -:  746: *
        -:  747: * See also:
        -:  748: *         ECMA-262 v5, 15.12.2
        -:  749: *         ECMA-262 v11, 24.5.1.1 in step 2
        -:  750: *
        -:  751: * @return ECMA_VALUE_TRUE - if no error occurred.
        -:  752: *         error if one of the operation failed.
        -:  753: */
        -:  754:static ecma_value_t
    #####:  755:ecma_builtin_json_internalize_process_property (ecma_object_t *reviver_p, /**< reviver function */
        -:  756:                                                ecma_object_t *object_p, /**< holder object */
        -:  757:                                                ecma_string_t *prop_name) /**< property name */
        -:  758:{
        -:  759:  /* ES11: 2.b.iii.1 / 2.c.ii.1 */
    #####:  760:  ecma_value_t new_element = ecma_builtin_json_internalize_property (reviver_p, object_p, prop_name);
        -:  761:
    #####:  762:  if (ECMA_IS_VALUE_ERROR (new_element))
        -:  763:  {
    #####:  764:    return new_element;
        -:  765:  }
        -:  766:
        -:  767:  /* ES11: 2.b.iii.2 / 2.c.ii.2 */
    #####:  768:  if (ecma_is_value_undefined (new_element))
        -:  769:  {
        -:  770:    /* ES11: 2.b.iii.2.a / 2.c.ii.2.a */
    #####:  771:    ecma_value_t delete_val = ecma_op_object_delete (object_p, prop_name, false);
        -:  772:
        -:  773:#if JERRY_ESNEXT
    #####:  774:    if (ECMA_IS_VALUE_ERROR (delete_val))
        -:  775:    {
    #####:  776:      return delete_val;
        -:  777:    }
        -:  778:#endif /* JERRY_ESNEXT */
        -:  779:
    #####:  780:    JERRY_ASSERT (ecma_is_value_boolean (delete_val));
        -:  781:  }
        -:  782:  else
        -:  783:  {
        -:  784:    /* ES11: 2.b.iii.3.a / 2.c.ii.3.a */
    #####:  785:    ecma_value_t def_value =
        -:  786:      ecma_builtin_helper_def_prop (object_p, prop_name, new_element, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  787:    ecma_free_value (new_element);
        -:  788:
        -:  789:#if JERRY_ESNEXT
    #####:  790:    if (ECMA_IS_VALUE_ERROR (def_value))
        -:  791:    {
    #####:  792:      return def_value;
        -:  793:    }
        -:  794:#endif /* JERRY_ESNEXT */
        -:  795:
    #####:  796:    JERRY_ASSERT (ecma_is_value_boolean (def_value));
        -:  797:  }
        -:  798:
    #####:  799:  return ECMA_VALUE_TRUE;
        -:  800:} /* ecma_builtin_json_internalize_process_property */
        -:  801:
        -:  802:/**
        -:  803: * Function to set a string token from the given arguments, fills its fields and advances the string pointer.
        -:  804: *
        -:  805: * @return ecma_value_t containing an object or an error massage
        -:  806: *         Returned value must be freed with ecma_free_value.
        -:  807: */
        -:  808:ecma_value_t
    #####:  809:ecma_builtin_json_parse_buffer (const lit_utf8_byte_t *str_start_p, /**< String to parse */
        -:  810:                                lit_utf8_size_t string_size) /**< size of the string */
        -:  811:{
    #####:  812:  ecma_json_token_t token;
    #####:  813:  token.current_p = str_start_p;
    #####:  814:  token.end_p = str_start_p + string_size;
        -:  815:
    #####:  816:  ecma_builtin_json_parse_next_token (&token, true);
    #####:  817:  ecma_value_t result = ecma_builtin_json_parse_value (&token);
        -:  818:
    #####:  819:  if (!ecma_is_value_empty (result))
        -:  820:  {
    #####:  821:    ecma_builtin_json_parse_next_token (&token, false);
    #####:  822:    if (token.type == TOKEN_END)
        -:  823:    {
    #####:  824:      return result;
        -:  825:    }
        -:  826:
    #####:  827:    ecma_free_value (result);
        -:  828:  }
        -:  829:
    #####:  830:  return ecma_raise_syntax_error (ECMA_ERR_INVALID_JSON_FORMAT);
        -:  831:} /* ecma_builtin_json_parse_buffer */
        -:  832:
        -:  833:/**
        -:  834: * The JSON object's 'parse' routine
        -:  835: *
        -:  836: * See also:
        -:  837: *          ECMA-262 v5, 15.12.2
        -:  838: *
        -:  839: * @return ecma value
        -:  840: *         Returned value must be freed with ecma_free_value.
        -:  841: */
        -:  842:static ecma_value_t
    #####:  843:ecma_builtin_json_parse (ecma_value_t arg1, /**< string argument */
        -:  844:                         ecma_value_t arg2) /**< reviver argument */
        -:  845:{
    #####:  846:  ecma_string_t *text_string_p = ecma_op_to_string (arg1);
        -:  847:
    #####:  848:  if (JERRY_UNLIKELY (text_string_p == NULL))
        -:  849:  {
    #####:  850:    return ECMA_VALUE_ERROR;
        -:  851:  }
        -:  852:
    #####:  853:  ECMA_STRING_TO_UTF8_STRING (text_string_p, str_start_p, string_size);
    #####:  854:  ecma_value_t result = ecma_builtin_json_parse_buffer (str_start_p, string_size);
    #####:  855:  ECMA_FINALIZE_UTF8_STRING (str_start_p, string_size);
    #####:  856:  ecma_deref_ecma_string (text_string_p);
        -:  857:
    #####:  858:  if (!ECMA_IS_VALUE_ERROR (result) && ecma_op_is_callable (arg2))
        -:  859:  {
    #####:  860:    ecma_object_t *object_p = ecma_op_create_object_object_noarg ();
        -:  861:
        -:  862:    ecma_property_value_t *prop_value_p;
    #####:  863:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  864:                                                    ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY),
        -:  865:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  866:                                                    NULL);
        -:  867:
    #####:  868:    ecma_named_data_property_assign_value (object_p, prop_value_p, result);
        -:  869:
    #####:  870:    ecma_free_value (result);
    #####:  871:    result = ecma_builtin_json_internalize_property (ecma_get_object_from_value (arg2),
        -:  872:                                                     object_p,
        -:  873:                                                     ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY));
    #####:  874:    ecma_deref_object (object_p);
        -:  875:  }
        -:  876:
    #####:  877:  return result;
        -:  878:} /* ecma_builtin_json_parse */
        -:  879:
        -:  880:/**
        -:  881: * Abstract operation 'QuoteJSONString' defined in 24.3.2.2
        -:  882: */
        -:  883:static void
    #####:  884:ecma_builtin_json_quote (ecma_stringbuilder_t *builder_p, /**< builder for the result */
        -:  885:                         ecma_string_t *string_p) /**< string that should be quoted */
        -:  886:{
    #####:  887:  ECMA_STRING_TO_UTF8_STRING (string_p, string_buff, string_buff_size);
    #####:  888:  const lit_utf8_byte_t *str_p = string_buff;
    #####:  889:  const lit_utf8_byte_t *regular_str_start_p = string_buff;
    #####:  890:  const lit_utf8_byte_t *str_end_p = str_p + string_buff_size;
        -:  891:
    #####:  892:  ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_DOUBLE_QUOTE);
        -:  893:
    #####:  894:  while (str_p < str_end_p)
        -:  895:  {
    #####:  896:    ecma_char_t c = lit_cesu8_read_next (&str_p);
        -:  897:
    #####:  898:    bool should_escape = false;
        -:  899:
        -:  900:#if JERRY_ESNEXT
    #####:  901:    if (lit_is_code_point_utf16_high_surrogate (c))
        -:  902:    {
    #####:  903:      if (str_p < str_end_p)
        -:  904:      {
    #####:  905:        const ecma_char_t next_ch = lit_cesu8_peek_next (str_p);
    #####:  906:        if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  907:        {
    #####:  908:          str_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
    #####:  909:          continue;
        -:  910:        }
    #####:  911:        should_escape = true;
        -:  912:      }
        -:  913:      else
        -:  914:      {
    #####:  915:        should_escape = true;
        -:  916:      }
        -:  917:    }
    #####:  918:    else if (lit_is_code_point_utf16_low_surrogate (c))
        -:  919:    {
    #####:  920:      should_escape = true;
        -:  921:    }
        -:  922:#endif /* JERRY_ESNEXT */
        -:  923:
    #####:  924:    if (c == LIT_CHAR_BACKSLASH || c == LIT_CHAR_DOUBLE_QUOTE)
        -:  925:    {
    #####:  926:      ecma_stringbuilder_append_raw (builder_p,
        -:  927:                                     regular_str_start_p,
    #####:  928:                                     (lit_utf8_size_t) (str_p - regular_str_start_p - 1));
    #####:  929:      regular_str_start_p = str_p;
    #####:  930:      ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_BACKSLASH);
    #####:  931:      ecma_stringbuilder_append_byte (builder_p, (lit_utf8_byte_t) c);
        -:  932:    }
    #####:  933:    else if (c < LIT_CHAR_SP || should_escape)
        -:  934:    {
        -:  935:      /**
        -:  936:       * In ES10 we should escape high or low surrogate characters,
        -:  937:       * so we shouldn't append the unescaped character to the stringbuilder
        -:  938:       */
    #####:  939:      uint8_t offset = should_escape ? LIT_UTF8_MAX_BYTES_IN_CODE_UNIT : 1;
        -:  940:
    #####:  941:      ecma_stringbuilder_append_raw (builder_p,
        -:  942:                                     regular_str_start_p,
    #####:  943:                                     (lit_utf8_size_t) (str_p - regular_str_start_p - offset));
        -:  944:
    #####:  945:      regular_str_start_p = str_p;
        -:  946:
    #####:  947:      switch (c)
        -:  948:      {
    #####:  949:        case LIT_CHAR_BS:
        -:  950:        {
    #####:  951:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\b", 2);
    #####:  952:          break;
        -:  953:        }
    #####:  954:        case LIT_CHAR_FF:
        -:  955:        {
    #####:  956:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\f", 2);
    #####:  957:          break;
        -:  958:        }
    #####:  959:        case LIT_CHAR_LF:
        -:  960:        {
    #####:  961:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\n", 2);
    #####:  962:          break;
        -:  963:        }
    #####:  964:        case LIT_CHAR_CR:
        -:  965:        {
    #####:  966:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\r", 2);
    #####:  967:          break;
        -:  968:        }
    #####:  969:        case LIT_CHAR_TAB:
        -:  970:        {
    #####:  971:          ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\t", 2);
    #####:  972:          break;
        -:  973:        }
    #####:  974:        default: /* Hexadecimal. */
        -:  975:        {
    #####:  976:          lit_char_unicode_escape (builder_p, c);
    #####:  977:          break;
        -:  978:        }
        -:  979:      }
    #####:  980:    }
        -:  981:  }
        -:  982:
    #####:  983:  ecma_stringbuilder_append_raw (builder_p, regular_str_start_p, (lit_utf8_size_t) (str_end_p - regular_str_start_p));
    #####:  984:  ecma_stringbuilder_append_byte (builder_p, LIT_CHAR_DOUBLE_QUOTE);
        -:  985:
    #####:  986:  ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);
    #####:  987:} /* ecma_builtin_json_quote */
        -:  988:
        -:  989:static ecma_value_t ecma_builtin_json_serialize_property (ecma_json_stringify_context_t *context_p,
        -:  990:                                                          ecma_object_t *holder_p,
        -:  991:                                                          ecma_string_t *key_p);
        -:  992:
        -:  993:/**
        -:  994: * Abstract operation 'SerializeJSONObject' defined in 24.3.2.3
        -:  995: *
        -:  996: * @return ecma value
        -:  997: *         Returned value must be freed with ecma_free_value.
        -:  998: */
        -:  999:static ecma_value_t
    #####: 1000:ecma_builtin_json_serialize_object (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1001:                                    ecma_object_t *obj_p) /**< the object*/
        -: 1002:{
        -: 1003:  /* 1. */
    #####: 1004:  if (ecma_json_has_object_in_stack (context_p->occurrence_stack_last_p, obj_p))
        -: 1005:  {
    #####: 1006:    return ecma_raise_type_error (ECMA_ERR_THE_STRUCTURE_IS_CYCLICAL);
        -: 1007:  }
        -: 1008:
        -: 1009:  /* 2. */
    #####: 1010:  ecma_json_occurrence_stack_item_t stack_item;
    #####: 1011:  stack_item.next_p = context_p->occurrence_stack_last_p;
    #####: 1012:  stack_item.object_p = obj_p;
    #####: 1013:  context_p->occurrence_stack_last_p = &stack_item;
        -: 1014:
        -: 1015:  /* 3. - 4.*/
    #####: 1016:  const lit_utf8_size_t stepback_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
    #####: 1017:  ecma_stringbuilder_append (&context_p->indent_builder, context_p->gap_str_p);
        -: 1018:
    #####: 1019:  const bool has_gap = !ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY);
    #####: 1020:  const lit_utf8_size_t separator_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
        -: 1021:
        -: 1022:  ecma_collection_t *property_keys_p;
        -: 1023:  /* 5. */
    #####: 1024:  if (context_p->property_list_p != NULL)
        -: 1025:  {
    #####: 1026:    property_keys_p = context_p->property_list_p;
        -: 1027:  }
        -: 1028:  /* 6. */
        -: 1029:  else
        -: 1030:  {
    #####: 1031:    property_keys_p = ecma_op_object_get_enumerable_property_names (obj_p, ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 1032:
        -: 1033:#if JERRY_BUILTIN_PROXY
    #####: 1034:    if (property_keys_p == NULL)
        -: 1035:    {
    #####: 1036:      return ECMA_VALUE_ERROR;
        -: 1037:    }
        -: 1038:#endif /* JERRY_BUILTIN_PROXY */
        -: 1039:  }
        -: 1040:
        -: 1041:  /* 8. */
    #####: 1042:  ecma_value_t *buffer_p = property_keys_p->buffer_p;
        -: 1043:
    #####: 1044:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_LEFT_BRACE);
    #####: 1045:  const lit_utf8_size_t left_brace = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1046:  lit_utf8_size_t last_prop = left_brace;
    #####: 1047:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 1048:
    #####: 1049:  for (uint32_t i = 0; i < property_keys_p->item_count; i++)
        -: 1050:  {
    #####: 1051:    if (has_gap)
        -: 1052:    {
    #####: 1053:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1054:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1055:                                     separator_size);
        -: 1056:    }
        -: 1057:
    #####: 1058:    ecma_string_t *key_p = ecma_get_string_from_value (buffer_p[i]);
    #####: 1059:    ecma_builtin_json_quote (&context_p->result_builder, key_p);
    #####: 1060:    ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COLON);
        -: 1061:
        -: 1062:    /* 8.c.iii */
    #####: 1063:    if (has_gap)
        -: 1064:    {
    #####: 1065:      ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_SP);
        -: 1066:    }
        -: 1067:
    #####: 1068:    result = ecma_builtin_json_serialize_property (context_p, obj_p, key_p);
        -: 1069:
    #####: 1070:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1071:    {
    #####: 1072:      goto cleanup;
        -: 1073:    }
        -: 1074:
        -: 1075:    /* 8.b */
    #####: 1076:    if (!ecma_is_value_undefined (result))
        -: 1077:    {
        -: 1078:      /* ecma_builtin_json_serialize_property already appended the result. */
    #####: 1079:      JERRY_ASSERT (ecma_is_value_empty (result));
        -: 1080:
    #####: 1081:      ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COMMA);
    #####: 1082:      last_prop = ecma_stringbuilder_get_size (&context_p->result_builder);
        -: 1083:    }
        -: 1084:    else
        -: 1085:    {
        -: 1086:      /* The property should not be appended, we must backtrack. */
    #####: 1087:      ecma_stringbuilder_revert (&context_p->result_builder, last_prop);
        -: 1088:    }
        -: 1089:  }
        -: 1090:
    #####: 1091:  if (last_prop != left_brace)
        -: 1092:  {
        -: 1093:    /* Remove the last comma. */
    #####: 1094:    ecma_stringbuilder_revert (&context_p->result_builder, last_prop - 1);
        -: 1095:
    #####: 1096:    if (has_gap)
        -: 1097:    {
        -: 1098:      /* We appended at least one element, and have a separator, so must append the stepback. */
    #####: 1099:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1100:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1101:                                     stepback_size);
        -: 1102:    }
        -: 1103:  }
        -: 1104:
    #####: 1105:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_RIGHT_BRACE);
    #####: 1106:  result = ECMA_VALUE_EMPTY;
        -: 1107:
        -: 1108:  /* 11. */
    #####: 1109:  context_p->occurrence_stack_last_p = stack_item.next_p;
        -: 1110:
        -: 1111:  /* 12. */
    #####: 1112:  ecma_stringbuilder_revert (&context_p->indent_builder, stepback_size);
        -: 1113:
    #####: 1114:cleanup:
    #####: 1115:  if (context_p->property_list_p == NULL)
        -: 1116:  {
    #####: 1117:    ecma_collection_free (property_keys_p);
        -: 1118:  }
        -: 1119:
    #####: 1120:  return result;
        -: 1121:} /* ecma_builtin_json_serialize_object */
        -: 1122:
        -: 1123:/**
        -: 1124: * Abstract operation 'SerializeJSONArray' defined in 24.3.2.4
        -: 1125: *
        -: 1126: * @return ecma value
        -: 1127: *         Returned value must be freed with ecma_free_value.
        -: 1128: */
        -: 1129:static ecma_value_t
    #####: 1130:ecma_builtin_json_serialize_array (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1131:                                   ecma_object_t *obj_p) /**< the array object*/
        -: 1132:{
        -: 1133:#ifndef JERRY_NDEBUG
    #####: 1134:  ecma_value_t obj_value = ecma_make_object_value (obj_p);
    #####: 1135:  ecma_value_t is_array = ecma_is_value_array (obj_value);
        -: 1136:
    #####: 1137:  JERRY_ASSERT (ecma_is_value_true (is_array));
        -: 1138:#endif /* !JERRY_NDEBUG */
        -: 1139:
        -: 1140:  /* 1. */
    #####: 1141:  if (ecma_json_has_object_in_stack (context_p->occurrence_stack_last_p, obj_p))
        -: 1142:  {
    #####: 1143:    return ecma_raise_type_error (ECMA_ERR_THE_STRUCTURE_IS_CYCLICAL);
        -: 1144:  }
        -: 1145:
        -: 1146:  /* 2. */
    #####: 1147:  ecma_json_occurrence_stack_item_t stack_item;
    #####: 1148:  stack_item.next_p = context_p->occurrence_stack_last_p;
    #####: 1149:  stack_item.object_p = obj_p;
    #####: 1150:  context_p->occurrence_stack_last_p = &stack_item;
        -: 1151:
        -: 1152:  /* 3. - 4.*/
    #####: 1153:  const lit_utf8_size_t stepback_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
    #####: 1154:  ecma_stringbuilder_append (&context_p->indent_builder, context_p->gap_str_p);
    #####: 1155:  const lit_utf8_size_t separator_size = ecma_stringbuilder_get_size (&context_p->indent_builder);
        -: 1156:
    #####: 1157:  const bool has_gap = !ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY);
        -: 1158:
        -: 1159:  /* 6. */
    #####: 1160:  ecma_length_t array_length;
    #####: 1161:  ecma_value_t length_value = ecma_op_object_get_length (obj_p, &array_length);
        -: 1162:
        -: 1163:#if JERRY_BUILTIN_PROXY
    #####: 1164:  if (ECMA_IS_VALUE_ERROR (length_value))
        -: 1165:  {
    #####: 1166:    return length_value;
        -: 1167:  }
        -: 1168:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1169:  JERRY_ASSERT (ecma_is_value_empty (length_value));
        -: 1170:
    #####: 1171:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_LEFT_SQUARE);
        -: 1172:
    #####: 1173:  const lit_utf8_size_t left_square = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1174:  lit_utf8_size_t last_prop = left_square;
        -: 1175:
        -: 1176:  /* 8. - 9. */
    #####: 1177:  for (ecma_length_t index = 0; index < array_length; index++)
        -: 1178:  {
        -: 1179:    /* 9.a */
    #####: 1180:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
        -: 1181:
    #####: 1182:    if (has_gap)
        -: 1183:    {
    #####: 1184:      ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1185:                                     ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1186:                                     separator_size);
        -: 1187:    }
        -: 1188:
    #####: 1189:    ecma_value_t result = ecma_builtin_json_serialize_property (context_p, obj_p, index_str_p);
    #####: 1190:    ecma_deref_ecma_string (index_str_p);
        -: 1191:
    #####: 1192:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1193:    {
    #####: 1194:      return result;
        -: 1195:    }
        -: 1196:
    #####: 1197:    if (ecma_is_value_undefined (result))
        -: 1198:    {
        -: 1199:      /* 9.c */
    #####: 1200:      ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
        -: 1201:    }
        -: 1202:    else
        -: 1203:    {
    #####: 1204:      JERRY_ASSERT (ecma_is_value_empty (result));
        -: 1205:    }
        -: 1206:
    #####: 1207:    last_prop = ecma_stringbuilder_get_size (&context_p->result_builder);
    #####: 1208:    ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_COMMA);
        -: 1209:  }
        -: 1210:
        -: 1211:  /* Remove the last comma. */
    #####: 1212:  ecma_stringbuilder_revert (&context_p->result_builder, last_prop);
        -: 1213:
        -: 1214:  /* 11.b.iii */
    #####: 1215:  if (last_prop != left_square && has_gap)
        -: 1216:  {
        -: 1217:    /* We appended at least one element, and have a separator, so must append the stepback. */
    #####: 1218:    ecma_stringbuilder_append_raw (&context_p->result_builder,
    #####: 1219:                                   ecma_stringbuilder_get_data (&context_p->indent_builder),
        -: 1220:                                   stepback_size);
        -: 1221:  }
        -: 1222:
    #####: 1223:  ecma_stringbuilder_append_byte (&context_p->result_builder, LIT_CHAR_RIGHT_SQUARE);
        -: 1224:
        -: 1225:  /* 12. */
    #####: 1226:  context_p->occurrence_stack_last_p = stack_item.next_p;
        -: 1227:
        -: 1228:  /* 13. */
    #####: 1229:  ecma_stringbuilder_revert (&context_p->indent_builder, stepback_size);
        -: 1230:
    #####: 1231:  return ECMA_VALUE_EMPTY;
        -: 1232:} /* ecma_builtin_json_serialize_array */
        -: 1233:
        -: 1234:/**
        -: 1235: * Abstract operation 'SerializeJSONProperty' defined in 24.3.2.1
        -: 1236: *
        -: 1237: * @return ecma value
        -: 1238: *         Returned value must be freed with ecma_free_value.
        -: 1239: */
        -: 1240:static ecma_value_t
    #####: 1241:ecma_builtin_json_serialize_property (ecma_json_stringify_context_t *context_p, /**< context*/
        -: 1242:                                      ecma_object_t *holder_p, /**< the object*/
        -: 1243:                                      ecma_string_t *key_p) /**< property key*/
        -: 1244:{
        -: 1245:  /* 1. */
    #####: 1246:  ecma_value_t value = ecma_op_object_get (holder_p, key_p);
        -: 1247:
        -: 1248:  /* 2. */
    #####: 1249:  if (ECMA_IS_VALUE_ERROR (value))
        -: 1250:  {
    #####: 1251:    return value;
        -: 1252:  }
        -: 1253:
        -: 1254:  /* 3. */
    #####: 1255:  if (ecma_is_value_object (value) || ecma_is_value_bigint (value))
        -: 1256:  {
    #####: 1257:    ecma_value_t to_object_value = ecma_op_to_object (value);
        -: 1258:
    #####: 1259:    if (ECMA_IS_VALUE_ERROR (to_object_value))
        -: 1260:    {
    #####: 1261:      ecma_free_value (value);
    #####: 1262:      return to_object_value;
        -: 1263:    }
        -: 1264:
    #####: 1265:    ecma_object_t *value_obj_p = ecma_get_object_from_value (to_object_value);
    #####: 1266:    ecma_value_t to_json =
    #####: 1267:      ecma_op_object_get_with_receiver (value_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_TO_JSON_UL), value);
        -: 1268:
    #####: 1269:    ecma_deref_object (value_obj_p);
        -: 1270:
    #####: 1271:    if (ECMA_IS_VALUE_ERROR (to_json))
        -: 1272:    {
    #####: 1273:      ecma_free_value (value);
    #####: 1274:      return to_json;
        -: 1275:    }
        -: 1276:
        -: 1277:    /* 3.c */
    #####: 1278:    if (ecma_op_is_callable (to_json))
        -: 1279:    {
    #####: 1280:      ecma_value_t key_value = ecma_make_string_value (key_p);
    #####: 1281:      ecma_value_t call_args[] = { key_value };
    #####: 1282:      ecma_object_t *to_json_obj_p = ecma_get_object_from_value (to_json);
        -: 1283:
    #####: 1284:      ecma_value_t result = ecma_op_function_call (to_json_obj_p, value, call_args, 1);
    #####: 1285:      ecma_free_value (value);
        -: 1286:
    #####: 1287:      if (ECMA_IS_VALUE_ERROR (result))
        -: 1288:      {
    #####: 1289:        ecma_deref_object (to_json_obj_p);
    #####: 1290:        return result;
        -: 1291:      }
    #####: 1292:      value = result;
        -: 1293:    }
    #####: 1294:    ecma_free_value (to_json);
        -: 1295:  }
        -: 1296:
        -: 1297:  /* 4. */
    #####: 1298:  if (context_p->replacer_function_p)
        -: 1299:  {
    #####: 1300:    ecma_value_t holder_value = ecma_make_object_value (holder_p);
    #####: 1301:    ecma_value_t key_value = ecma_make_string_value (key_p);
    #####: 1302:    ecma_value_t call_args[] = { key_value, value };
        -: 1303:
    #####: 1304:    ecma_value_t result = ecma_op_function_call (context_p->replacer_function_p, holder_value, call_args, 2);
    #####: 1305:    ecma_free_value (value);
        -: 1306:
    #####: 1307:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1308:    {
    #####: 1309:      return result;
        -: 1310:    }
        -: 1311:
    #####: 1312:    value = result;
        -: 1313:  }
        -: 1314:
        -: 1315:  /* 5. */
    #####: 1316:  if (ecma_is_value_object (value))
        -: 1317:  {
    #####: 1318:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1319:
    #####: 1320:    if (ecma_get_object_base_type (obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1321:    {
    #####: 1322:      switch (((ecma_extended_object_t *) obj_p)->u.cls.type)
        -: 1323:      {
        -: 1324:        /* 5.a */
    #####: 1325:        case ECMA_OBJECT_CLASS_NUMBER:
        -: 1326:        {
    #####: 1327:          ecma_number_t num;
    #####: 1328:          value = ecma_op_to_number (value, &num);
    #####: 1329:          ecma_deref_object (obj_p);
        -: 1330:
    #####: 1331:          if (ECMA_IS_VALUE_ERROR (value))
        -: 1332:          {
    #####: 1333:            return value;
        -: 1334:          }
        -: 1335:
    #####: 1336:          value = ecma_make_number_value (num);
    #####: 1337:          break;
        -: 1338:        }
        -: 1339:        /* 5.b */
    #####: 1340:        case ECMA_OBJECT_CLASS_STRING:
        -: 1341:        {
    #####: 1342:          ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 1343:          ecma_deref_object (obj_p);
        -: 1344:
    #####: 1345:          if (JERRY_UNLIKELY (str_p == NULL))
        -: 1346:          {
    #####: 1347:            return ECMA_VALUE_ERROR;
        -: 1348:          }
        -: 1349:
    #####: 1350:          value = ecma_make_string_value (str_p);
    #####: 1351:          break;
        -: 1352:        }
        -: 1353:        /* 5.c */
    #####: 1354:        case ECMA_OBJECT_CLASS_BOOLEAN:
        -: 1355:        {
    #####: 1356:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####: 1357:          value = ext_object_p->u.cls.u3.value;
    #####: 1358:          ecma_deref_object (obj_p);
    #####: 1359:          break;
        -: 1360:        }
        -: 1361:#if JERRY_BUILTIN_BIGINT
        -: 1362:        /* 5.d */
    #####: 1363:        case ECMA_OBJECT_CLASS_BIGINT:
        -: 1364:        {
    #####: 1365:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####: 1366:          value = ecma_copy_value (ext_object_p->u.cls.u3.value);
    #####: 1367:          ecma_deref_object (obj_p);
    #####: 1368:          break;
        -: 1369:        }
        -: 1370:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1371:      }
        -: 1372:    }
        -: 1373:  }
        -: 1374:
        -: 1375:  /* 6. - 8. */
    #####: 1376:  if (ecma_is_value_null (value))
        -: 1377:  {
    #####: 1378:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
    #####: 1379:    return ECMA_VALUE_EMPTY;
        -: 1380:  }
        -: 1381:
    #####: 1382:  if (ecma_is_value_true (value))
        -: 1383:  {
    #####: 1384:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_TRUE);
    #####: 1385:    return ECMA_VALUE_EMPTY;
        -: 1386:  }
        -: 1387:
    #####: 1388:  if (ecma_is_value_false (value))
        -: 1389:  {
    #####: 1390:    ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_FALSE);
    #####: 1391:    return ECMA_VALUE_EMPTY;
        -: 1392:  }
        -: 1393:
        -: 1394:  /* 9. */
    #####: 1395:  if (ecma_is_value_string (value))
        -: 1396:  {
    #####: 1397:    ecma_string_t *value_str_p = ecma_get_string_from_value (value);
        -: 1398:    /* Quote will append the result. */
    #####: 1399:    ecma_builtin_json_quote (&context_p->result_builder, value_str_p);
    #####: 1400:    ecma_deref_ecma_string (value_str_p);
        -: 1401:
    #####: 1402:    return ECMA_VALUE_EMPTY;
        -: 1403:  }
        -: 1404:
        -: 1405:  /* 10. */
    #####: 1406:  if (ecma_is_value_number (value))
        -: 1407:  {
    #####: 1408:    ecma_number_t num_value = ecma_get_number_from_value (value);
        -: 1409:
        -: 1410:    /* 10.a */
    #####: 1411:    if (!ecma_number_is_nan (num_value) && !ecma_number_is_infinity (num_value))
    #####: 1412:    {
    #####: 1413:      ecma_string_t *result_string_p = ecma_op_to_string (value);
    #####: 1414:      JERRY_ASSERT (result_string_p != NULL);
        -: 1415:
    #####: 1416:      ecma_stringbuilder_append (&context_p->result_builder, result_string_p);
    #####: 1417:      ecma_deref_ecma_string (result_string_p);
        -: 1418:    }
        -: 1419:    else
        -: 1420:    {
        -: 1421:      /* 10.b */
    #####: 1422:      ecma_stringbuilder_append_magic (&context_p->result_builder, LIT_MAGIC_STRING_NULL);
        -: 1423:    }
        -: 1424:
    #####: 1425:    ecma_free_value (value);
    #####: 1426:    return ECMA_VALUE_EMPTY;
        -: 1427:  }
        -: 1428:
        -: 1429:#if JERRY_BUILTIN_BIGINT
    #####: 1430:  if (ecma_is_value_bigint (value))
        -: 1431:  {
    #####: 1432:    ecma_free_value (value);
    #####: 1433:    return ecma_raise_type_error (ECMA_ERR_BIGINT_SERIALIZED);
        -: 1434:  }
        -: 1435:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1436:
        -: 1437:  /* 11. */
    #####: 1438:  if (ecma_is_value_object (value) && !ecma_op_is_callable (value))
        -: 1439:  {
    #####: 1440:    ecma_value_t is_array = ecma_is_value_array (value);
        -: 1441:
        -: 1442:#if JERRY_BUILTIN_BIGINT
    #####: 1443:    if (ECMA_IS_VALUE_ERROR (is_array))
        -: 1444:    {
    #####: 1445:      ecma_free_value (value);
    #####: 1446:      return is_array;
        -: 1447:    }
        -: 1448:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1449:
    #####: 1450:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1451:
        -: 1452:    ecma_value_t ret_value;
        -: 1453:    /* 10.a */
    #####: 1454:    if (ecma_is_value_true (is_array))
        -: 1455:    {
    #####: 1456:      ret_value = ecma_builtin_json_serialize_array (context_p, obj_p);
        -: 1457:    }
        -: 1458:    /* 10.b */
        -: 1459:    else
        -: 1460:    {
    #####: 1461:      ret_value = ecma_builtin_json_serialize_object (context_p, obj_p);
        -: 1462:    }
        -: 1463:
    #####: 1464:    ecma_deref_object (obj_p);
    #####: 1465:    return ret_value;
        -: 1466:  }
        -: 1467:
        -: 1468:  /* 12. */
    #####: 1469:  ecma_free_value (value);
    #####: 1470:  return ECMA_VALUE_UNDEFINED;
        -: 1471:} /* ecma_builtin_json_serialize_property */
        -: 1472:
        -: 1473:/**
        -: 1474: * Helper function to stringify an object in JSON format representing an ecma_value.
        -: 1475: *
        -: 1476: *  @return ecma_value_t string created from an abject formating by a given context
        -: 1477: *          Returned value must be freed with ecma_free_value.
        -: 1478: *
        -: 1479: */
        -: 1480:static ecma_value_t
    #####: 1481:ecma_builtin_json_str_helper (ecma_json_stringify_context_t *context_p, /**< context argument */
        -: 1482:                              const ecma_value_t arg1) /**< object argument */
        -: 1483:{
    #####: 1484:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 1485:  ecma_object_t *obj_wrapper_p = ecma_op_create_object_object_noarg ();
    #####: 1486:  ecma_string_t *empty_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
    #####: 1487:  ecma_value_t put_comp_val =
        -: 1488:    ecma_builtin_helper_def_prop (obj_wrapper_p, empty_str_p, arg1, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1489:
    #####: 1490:  JERRY_ASSERT (ecma_is_value_true (put_comp_val));
        -: 1491:
    #####: 1492:  context_p->result_builder = ecma_stringbuilder_create ();
        -: 1493:
    #####: 1494:  if (!ecma_compare_ecma_string_to_magic_id (context_p->gap_str_p, LIT_MAGIC_STRING__EMPTY))
        -: 1495:  {
    #####: 1496:    ecma_stringbuilder_append_byte (&context_p->indent_builder, LIT_CHAR_LF);
        -: 1497:  }
        -: 1498:
    #####: 1499:  ret_value = ecma_builtin_json_serialize_property (context_p, obj_wrapper_p, empty_str_p);
    #####: 1500:  ecma_deref_object (obj_wrapper_p);
        -: 1501:
    #####: 1502:  if (ECMA_IS_VALUE_ERROR (ret_value) || ecma_is_value_undefined (ret_value))
        -: 1503:  {
    #####: 1504:    ecma_stringbuilder_destroy (&context_p->result_builder);
    #####: 1505:    return ret_value;
        -: 1506:  }
        -: 1507:
    #####: 1508:  return ecma_make_string_value (ecma_stringbuilder_finalize (&context_p->result_builder));
        -: 1509:} /* ecma_builtin_json_str_helper */
        -: 1510:
        -: 1511:/**
        -: 1512: * Function to create a JSON string from a JS value.
        -: 1513: *
        -: 1514: * Note:
        -: 1515: *      The returned value must be freed with ecma_free_value.
        -: 1516: *
        -: 1517: * @return - ecma_value_t containing a json string.
        -: 1518: *         - Error value in case of any errors.
        -: 1519: */
        -: 1520:ecma_value_t
    #####: 1521:ecma_builtin_json_stringify_no_opts (const ecma_value_t value) /**< value to stringify */
        -: 1522:{
    #####: 1523:  ecma_json_stringify_context_t context;
    #####: 1524:  context.occurrence_stack_last_p = NULL;
    #####: 1525:  context.indent_builder = ecma_stringbuilder_create ();
    #####: 1526:  context.property_list_p = NULL;
    #####: 1527:  context.replacer_function_p = NULL;
    #####: 1528:  context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1529:
    #####: 1530:  ecma_value_t ret_value = ecma_builtin_json_str_helper (&context, value);
        -: 1531:
    #####: 1532:  ecma_deref_ecma_string (context.gap_str_p);
    #####: 1533:  ecma_stringbuilder_destroy (&context.indent_builder);
    #####: 1534:  return ret_value;
        -: 1535:} /* ecma_builtin_json_stringify_no_opts */
        -: 1536:
        -: 1537:/**
        -: 1538: * The JSON object's 'stringify' routine
        -: 1539: *
        -: 1540: * See also:
        -: 1541: *          ECMA-262 v5, 15.12.3
        -: 1542: *          ECMA-262 v11, 24.5.2
        -: 1543: *
        -: 1544: * @return ecma value
        -: 1545: *         Returned value must be freed with ecma_free_value.
        -: 1546: */
        -: 1547:static ecma_value_t
    #####: 1548:ecma_builtin_json_stringify (ecma_value_t arg1, /**< value */
        -: 1549:                             ecma_value_t arg2, /**< replacer */
        -: 1550:                             ecma_value_t arg3) /**< space */
        -: 1551:{
    #####: 1552:  ecma_json_stringify_context_t context;
    #####: 1553:  context.replacer_function_p = NULL;
    #####: 1554:  context.property_list_p = NULL;
        -: 1555:
        -: 1556:  /* 4. */
    #####: 1557:  if (ecma_is_value_object (arg2))
        -: 1558:  {
    #####: 1559:    ecma_object_t *obj_p = ecma_get_object_from_value (arg2);
        -: 1560:
        -: 1561:    /* 4.a */
    #####: 1562:    if (ecma_op_is_callable (arg2))
        -: 1563:    {
    #####: 1564:      context.replacer_function_p = obj_p;
        -: 1565:    }
        -: 1566:    /* 4.b */
        -: 1567:    else
        -: 1568:    {
    #####: 1569:      ecma_value_t is_array = ecma_is_value_array (arg2);
        -: 1570:
        -: 1571:#if JERRY_ESNEXT
    #####: 1572:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 1573:      {
    #####: 1574:        return is_array;
        -: 1575:      }
        -: 1576:#endif /* JERRY_ESNEXT */
        -: 1577:
    #####: 1578:      if (ecma_is_value_true (is_array))
        -: 1579:      {
    #####: 1580:        ecma_length_t array_length;
    #####: 1581:        ecma_value_t to_len = ecma_op_object_get_length (obj_p, &array_length);
        -: 1582:
        -: 1583:#if JERRY_BUILTIN_PROXY
    #####: 1584:        if (ECMA_IS_VALUE_ERROR (to_len))
        -: 1585:        {
    #####: 1586:          return to_len;
        -: 1587:        }
        -: 1588:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1589:        JERRY_ASSERT (ecma_is_value_empty (to_len));
        -: 1590:
    #####: 1591:        context.property_list_p = ecma_new_collection ();
        -: 1592:
    #####: 1593:        uint32_t index = 0;
        -: 1594:
        -: 1595:        /* 4.b.iii.5 */
    #####: 1596:        while (index < array_length)
        -: 1597:        {
    #####: 1598:          ecma_value_t value = ecma_op_object_get_by_index (obj_p, index);
        -: 1599:
    #####: 1600:          if (ECMA_IS_VALUE_ERROR (value))
        -: 1601:          {
    #####: 1602:            ecma_collection_free (context.property_list_p);
    #####: 1603:            return value;
        -: 1604:          }
        -: 1605:
        -: 1606:          /* 4.b.iii.5.c */
    #####: 1607:          ecma_value_t item = ECMA_VALUE_UNDEFINED;
        -: 1608:
        -: 1609:          /* 4.b.iii.5.d */
    #####: 1610:          if (ecma_is_value_string (value))
        -: 1611:          {
    #####: 1612:            ecma_ref_ecma_string (ecma_get_string_from_value (value));
    #####: 1613:            item = value;
        -: 1614:          }
        -: 1615:          /* 4.b.iii.5.e */
    #####: 1616:          else if (ecma_is_value_number (value))
        -: 1617:          {
    #####: 1618:            ecma_string_t *number_str_p = ecma_op_to_string (value);
    #####: 1619:            JERRY_ASSERT (number_str_p != NULL);
    #####: 1620:            item = ecma_make_string_value (number_str_p);
        -: 1621:          }
        -: 1622:          /* 4.b.iii.5.f */
    #####: 1623:          else if (ecma_is_value_object (value))
        -: 1624:          {
    #####: 1625:            ecma_object_t *value_obj_p = ecma_get_object_from_value (value);
        -: 1626:
    #####: 1627:            if (ecma_get_object_base_type (value_obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1628:            {
    #####: 1629:              uint8_t class_type = ((ecma_extended_object_t *) value_obj_p)->u.cls.type;
        -: 1630:
    #####: 1631:              if (class_type == ECMA_OBJECT_CLASS_NUMBER || class_type == ECMA_OBJECT_CLASS_STRING)
        -: 1632:              {
    #####: 1633:                ecma_string_t *str_p = ecma_op_to_string (value);
        -: 1634:
    #####: 1635:                if (JERRY_UNLIKELY (str_p == NULL))
        -: 1636:                {
    #####: 1637:                  ecma_collection_free (context.property_list_p);
    #####: 1638:                  ecma_free_value (value);
    #####: 1639:                  return ECMA_VALUE_ERROR;
        -: 1640:                }
        -: 1641:
    #####: 1642:                item = ecma_make_string_value (str_p);
        -: 1643:              }
        -: 1644:            }
        -: 1645:          }
        -: 1646:
    #####: 1647:          ecma_free_value (value);
        -: 1648:
        -: 1649:          /* 4.b.iii.5.g */
    #####: 1650:          if (!ecma_is_value_undefined (item))
        -: 1651:          {
    #####: 1652:            JERRY_ASSERT (ecma_is_value_string (item));
    #####: 1653:            ecma_string_t *string_p = ecma_get_string_from_value (item);
        -: 1654:
    #####: 1655:            if (!ecma_collection_has_string_value (context.property_list_p, string_p))
        -: 1656:            {
    #####: 1657:              ecma_collection_push_back (context.property_list_p, item);
        -: 1658:            }
        -: 1659:            else
        -: 1660:            {
    #####: 1661:              ecma_deref_ecma_string (string_p);
        -: 1662:            }
        -: 1663:          }
        -: 1664:
    #####: 1665:          index++;
        -: 1666:        }
        -: 1667:      }
        -: 1668:    }
        -: 1669:  }
        -: 1670:
    #####: 1671:  ecma_value_t space = ECMA_VALUE_EMPTY;
        -: 1672:
        -: 1673:  /* 5. */
    #####: 1674:  if (ecma_is_value_object (arg3))
        -: 1675:  {
    #####: 1676:    ecma_object_t *obj_p = ecma_get_object_from_value (arg3);
        -: 1677:
    #####: 1678:    if (ecma_get_object_base_type (obj_p) == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1679:    {
    #####: 1680:      uint8_t class_type = ((ecma_extended_object_t *) obj_p)->u.cls.type;
        -: 1681:
        -: 1682:      /* 5.a */
    #####: 1683:      if (class_type == ECMA_OBJECT_CLASS_NUMBER)
        -: 1684:      {
    #####: 1685:        ecma_number_t num;
    #####: 1686:        ecma_value_t value = ecma_op_to_number (arg3, &num);
        -: 1687:
    #####: 1688:        if (ECMA_IS_VALUE_ERROR (value))
        -: 1689:        {
    #####: 1690:          if (context.property_list_p != NULL)
        -: 1691:          {
    #####: 1692:            ecma_collection_free (context.property_list_p);
        -: 1693:          }
    #####: 1694:          return value;
        -: 1695:        }
        -: 1696:
    #####: 1697:        space = ecma_make_number_value (num);
        -: 1698:      }
        -: 1699:      /* 5.b */
    #####: 1700:      else if (class_type == ECMA_OBJECT_CLASS_STRING)
        -: 1701:      {
    #####: 1702:        ecma_string_t *value_str_p = ecma_op_to_string (arg3);
        -: 1703:
    #####: 1704:        if (JERRY_UNLIKELY (value_str_p == NULL))
        -: 1705:        {
    #####: 1706:          if (context.property_list_p != NULL)
        -: 1707:          {
    #####: 1708:            ecma_collection_free (context.property_list_p);
        -: 1709:          }
    #####: 1710:          return ECMA_VALUE_ERROR;
        -: 1711:        }
        -: 1712:
    #####: 1713:        space = ecma_make_string_value (value_str_p);
        -: 1714:      }
        -: 1715:    }
        -: 1716:  }
        -: 1717:
    #####: 1718:  if (space == ECMA_VALUE_EMPTY)
        -: 1719:  {
    #####: 1720:    space = ecma_copy_value (arg3);
        -: 1721:  }
        -: 1722:
        -: 1723:  /* 6. */
    #####: 1724:  if (ecma_is_value_number (space))
        -: 1725:  {
        -: 1726:    /* 6.a */
    #####: 1727:    ecma_number_t num_of_spaces;
    #####: 1728:    ecma_op_to_integer (space, &num_of_spaces);
        -: 1729:
    #####: 1730:    num_of_spaces = JERRY_MIN (10, num_of_spaces);
        -: 1731:
        -: 1732:    /* 6.b */
    #####: 1733:    if (num_of_spaces < 1)
        -: 1734:    {
    #####: 1735:      context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1736:    }
        -: 1737:    else
        -: 1738:    {
    #####: 1739:      JMEM_DEFINE_LOCAL_ARRAY (space_buff, num_of_spaces, char);
        -: 1740:
    #####: 1741:      memset (space_buff, LIT_CHAR_SP, (size_t) num_of_spaces);
    #####: 1742:      context.gap_str_p =
    #####: 1743:        ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) space_buff, (lit_utf8_size_t) num_of_spaces);
        -: 1744:
    #####: 1745:      JMEM_FINALIZE_LOCAL_ARRAY (space_buff);
        -: 1746:    }
        -: 1747:  }
        -: 1748:  /* 7. */
    #####: 1749:  else if (ecma_is_value_string (space))
        -: 1750:  {
    #####: 1751:    ecma_string_t *space_str_p = ecma_get_string_from_value (space);
    #####: 1752:    lit_utf8_size_t num_of_chars = ecma_string_get_length (space_str_p);
        -: 1753:
    #####: 1754:    if (num_of_chars < 10)
        -: 1755:    {
    #####: 1756:      ecma_ref_ecma_string (space_str_p);
    #####: 1757:      context.gap_str_p = space_str_p;
        -: 1758:    }
        -: 1759:    else
        -: 1760:    {
    #####: 1761:      context.gap_str_p = ecma_string_substr (space_str_p, 0, 10);
        -: 1762:    }
        -: 1763:  }
        -: 1764:  /* 8. */
        -: 1765:  else
        -: 1766:  {
    #####: 1767:    context.gap_str_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1768:  }
        -: 1769:
    #####: 1770:  ecma_free_value (space);
        -: 1771:
        -: 1772:  /* 1., 2., 3. */
    #####: 1773:  context.occurrence_stack_last_p = NULL;
    #####: 1774:  context.indent_builder = ecma_stringbuilder_create ();
        -: 1775:
        -: 1776:  /* 9. */
    #####: 1777:  ecma_value_t ret_value = ecma_builtin_json_str_helper (&context, arg1);
        -: 1778:
    #####: 1779:  ecma_deref_ecma_string (context.gap_str_p);
    #####: 1780:  ecma_stringbuilder_destroy (&context.indent_builder);
        -: 1781:
    #####: 1782:  if (context.property_list_p != NULL)
        -: 1783:  {
    #####: 1784:    ecma_collection_free (context.property_list_p);
        -: 1785:  }
        -: 1786:
    #####: 1787:  return ret_value;
        -: 1788:} /* ecma_builtin_json_stringify */
        -: 1789:
        -: 1790:/**
        -: 1791: * Dispatcher of the built-in's routines
        -: 1792: *
        -: 1793: * @return ecma value
        -: 1794: *         Returned value must be freed with ecma_free_value.
        -: 1795: */
        -: 1796:ecma_value_t
    #####: 1797:ecma_builtin_json_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 1798:                                    ecma_value_t this_arg, /**< 'this' argument value */
        -: 1799:                                    const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1800:                                                                            *   passed to routine */
        -: 1801:                                    uint32_t arguments_number) /**< length of arguments' list */
        -: 1802:{
        -: 1803:  JERRY_UNUSED_2 (this_arg, arguments_number);
        -: 1804:
    #####: 1805:  switch (builtin_routine_id)
        -: 1806:  {
    #####: 1807:    case ECMA_BUILTIN_JSON_PARSE:
        -: 1808:    {
    #####: 1809:      return ecma_builtin_json_parse (arguments_list_p[0], arguments_list_p[1]);
        -: 1810:    }
    #####: 1811:    case ECMA_BUILTIN_JSON_STRINGIFY:
        -: 1812:    {
    #####: 1813:      return ecma_builtin_json_stringify (arguments_list_p[0], arguments_list_p[1], arguments_list_p[2]);
        -: 1814:    }
    #####: 1815:    default:
        -: 1816:    {
    #####: 1817:      JERRY_UNREACHABLE ();
        -: 1818:    }
        -: 1819:  }
        -: 1820:} /* ecma_builtin_json_dispatch_routine */
        -: 1821:
        -: 1822:/**
        -: 1823: * @}
        -: 1824: * @}
        -: 1825: * @}
        -: 1826: */
        -: 1827:
        -: 1828:#endif /* JERRY_BUILTIN_JSON */
