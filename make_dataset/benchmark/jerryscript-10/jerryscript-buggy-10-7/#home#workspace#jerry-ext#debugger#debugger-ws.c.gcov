        -:    0:Source:/home/workspace/jerry-ext/debugger/debugger-ws.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "debugger-sha1.h"
        -:   17:#include "jerryscript-ext/debugger.h"
        -:   18:#include "jext-common.h"
        -:   19:
        -:   20:#if defined(JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)
        -:   21:
        -:   22:/* JerryScript debugger protocol is a simplified version of RFC-6455 (WebSockets). */
        -:   23:
        -:   24:/**
        -:   25: * Last fragment of a Websocket package.
        -:   26: */
        -:   27:#define JERRYX_DEBUGGER_WEBSOCKET_FIN_BIT 0x80
        -:   28:
        -:   29:/**
        -:   30: * Masking-key is available.
        -:   31: */
        -:   32:#define JERRYX_DEBUGGER_WEBSOCKET_MASK_BIT 0x80
        -:   33:
        -:   34:/**
        -:   35: * Opcode type mask.
        -:   36: */
        -:   37:#define JERRYX_DEBUGGER_WEBSOCKET_OPCODE_MASK 0x0fu
        -:   38:
        -:   39:/**
        -:   40: * Packet length mask.
        -:   41: */
        -:   42:#define JERRYX_DEBUGGER_WEBSOCKET_LENGTH_MASK 0x7fu
        -:   43:
        -:   44:/**
        -:   45: * Size of websocket header size.
        -:   46: */
        -:   47:#define JERRYX_DEBUGGER_WEBSOCKET_HEADER_SIZE 2
        -:   48:
        -:   49:/**
        -:   50: * Payload mask size in bytes of a websocket package.
        -:   51: */
        -:   52:#define JERRYX_DEBUGGER_WEBSOCKET_MASK_SIZE 4
        -:   53:
        -:   54:/**
        -:   55: * Maximum message size with 1 byte size field.
        -:   56: */
        -:   57:#define JERRYX_DEBUGGER_WEBSOCKET_ONE_BYTE_LEN_MAX 125
        -:   58:
        -:   59:/**
        -:   60: * WebSocket opcode types.
        -:   61: */
        -:   62:typedef enum
        -:   63:{
        -:   64:  JERRYX_DEBUGGER_WEBSOCKET_TEXT_FRAME = 1, /**< text frame */
        -:   65:  JERRYX_DEBUGGER_WEBSOCKET_BINARY_FRAME = 2, /**< binary frame */
        -:   66:  JERRYX_DEBUGGER_WEBSOCKET_CLOSE_CONNECTION = 8, /**< close connection */
        -:   67:  JERRYX_DEBUGGER_WEBSOCKET_PING = 9, /**< ping (keep alive) frame */
        -:   68:  JERRYX_DEBUGGER_WEBSOCKET_PONG = 10, /**< reply to ping frame */
        -:   69:} jerryx_websocket_opcode_type_t;
        -:   70:
        -:   71:/**
        -:   72: * Header for incoming packets.
        -:   73: */
        -:   74:typedef struct
        -:   75:{
        -:   76:  uint8_t ws_opcode; /**< websocket opcode */
        -:   77:  uint8_t size; /**< size of the message */
        -:   78:  uint8_t mask[4]; /**< mask bytes */
        -:   79:} jerryx_websocket_receive_header_t;
        -:   80:
        -:   81:/**
        -:   82: * Convert a 6-bit value to a Base64 character.
        -:   83: *
        -:   84: * @return Base64 character
        -:   85: */
        -:   86:static uint8_t
        -:   87:jerryx_to_base64_character (uint8_t value) /**< 6-bit value */
        -:   88:{
        -:   89:  if (value < 26)
        -:   90:  {
        -:   91:    return (uint8_t) (value + 'A');
        -:   92:  }
        -:   93:
        -:   94:  if (value < 52)
        -:   95:  {
        -:   96:    return (uint8_t) (value - 26 + 'a');
        -:   97:  }
        -:   98:
        -:   99:  if (value < 62)
        -:  100:  {
        -:  101:    return (uint8_t) (value - 52 + '0');
        -:  102:  }
        -:  103:
        -:  104:  if (value == 62)
        -:  105:  {
        -:  106:    return (uint8_t) '+';
        -:  107:  }
        -:  108:
        -:  109:  return (uint8_t) '/';
        -:  110:} /* jerryx_to_base64_character */
        -:  111:
        -:  112:/**
        -:  113: * Encode a byte sequence into Base64 string.
        -:  114: */
        -:  115:static void
        -:  116:jerryx_to_base64 (const uint8_t *source_p, /**< source data */
        -:  117:                  uint8_t *destination_p, /**< destination buffer */
        -:  118:                  size_t length) /**< length of source, must be divisible by 3 */
        -:  119:{
        -:  120:  while (length >= 3)
        -:  121:  {
        -:  122:    uint8_t value = (source_p[0] >> 2);
        -:  123:    destination_p[0] = jerryx_to_base64_character (value);
        -:  124:
        -:  125:    value = (uint8_t) (((source_p[0] << 4) | (source_p[1] >> 4)) & 0x3f);
        -:  126:    destination_p[1] = jerryx_to_base64_character (value);
        -:  127:
        -:  128:    value = (uint8_t) (((source_p[1] << 2) | (source_p[2] >> 6)) & 0x3f);
        -:  129:    destination_p[2] = jerryx_to_base64_character (value);
        -:  130:
        -:  131:    value = (uint8_t) (source_p[2] & 0x3f);
        -:  132:    destination_p[3] = jerryx_to_base64_character (value);
        -:  133:
        -:  134:    source_p += 3;
        -:  135:    destination_p += 4;
        -:  136:    length -= 3;
        -:  137:  }
        -:  138:} /* jerryx_to_base64 */
        -:  139:
        -:  140:/**
        -:  141: * Process WebSocket handshake.
        -:  142: *
        -:  143: * @return true - if the handshake was completed successfully
        -:  144: *         false - otherwise
        -:  145: */
        -:  146:static bool
        -:  147:jerryx_process_handshake (uint8_t *request_buffer_p) /**< temporary buffer */
        -:  148:{
        -:  149:  size_t request_buffer_size = 1024;
        -:  150:  uint8_t *request_end_p = request_buffer_p;
        -:  151:
        -:  152:  /* Buffer request text until the double newlines are received. */
        -:  153:  while (true)
        -:  154:  {
        -:  155:    jerry_debugger_transport_receive_context_t context;
        -:  156:    if (!jerry_debugger_transport_receive (&context))
        -:  157:    {
        -:  158:      JERRYX_ASSERT (!jerry_debugger_transport_is_connected ());
        -:  159:      return false;
        -:  160:    }
        -:  161:
        -:  162:    if (context.message_p == NULL)
        -:  163:    {
        -:  164:      jerry_debugger_transport_sleep ();
        -:  165:      continue;
        -:  166:    }
        -:  167:
        -:  168:    size_t length = request_buffer_size - 1u - (size_t) (request_end_p - request_buffer_p);
        -:  169:
        -:  170:    if (length < context.message_length)
        -:  171:    {
        -:  172:      JERRYX_ERROR_MSG ("Handshake buffer too small.\n");
        -:  173:      return false;
        -:  174:    }
        -:  175:
        -:  176:    /* Both stream and datagram packets are supported. */
        -:  177:    memcpy (request_end_p, context.message_p, context.message_length);
        -:  178:
        -:  179:    jerry_debugger_transport_receive_completed (&context);
        -:  180:
        -:  181:    request_end_p += (size_t) context.message_length;
        -:  182:    *request_end_p = 0;
        -:  183:
        -:  184:    if (request_end_p > request_buffer_p + 4 && memcmp (request_end_p - 4, "\r\n\r\n", 4) == 0)
        -:  185:    {
        -:  186:      break;
        -:  187:    }
        -:  188:  }
        -:  189:
        -:  190:  /* Check protocol. */
        -:  191:  const char get_text[] = "GET /jerry-debugger";
        -:  192:  size_t text_len = sizeof (get_text) - 1;
        -:  193:
        -:  194:  if ((size_t) (request_end_p - request_buffer_p) < text_len || memcmp (request_buffer_p, get_text, text_len) != 0)
        -:  195:  {
        -:  196:    JERRYX_ERROR_MSG ("Invalid handshake format.\n");
        -:  197:    return false;
        -:  198:  }
        -:  199:
        -:  200:  uint8_t *websocket_key_p = request_buffer_p + text_len;
        -:  201:
        -:  202:  const char key_text[] = "Sec-WebSocket-Key:";
        -:  203:  text_len = sizeof (key_text) - 1;
        -:  204:
        -:  205:  while (true)
        -:  206:  {
        -:  207:    if ((size_t) (request_end_p - websocket_key_p) < text_len)
        -:  208:    {
        -:  209:      JERRYX_ERROR_MSG ("Sec-WebSocket-Key not found.\n");
        -:  210:      return false;
        -:  211:    }
        -:  212:
        -:  213:    if (websocket_key_p[0] == 'S' && websocket_key_p[-1] == '\n' && websocket_key_p[-2] == '\r'
        -:  214:        && memcmp (websocket_key_p, key_text, text_len) == 0)
        -:  215:    {
        -:  216:      websocket_key_p += text_len;
        -:  217:      break;
        -:  218:    }
        -:  219:
        -:  220:    websocket_key_p++;
        -:  221:  }
        -:  222:
        -:  223:  /* String terminated by double newlines. */
        -:  224:
        -:  225:  while (*websocket_key_p == ' ')
        -:  226:  {
        -:  227:    websocket_key_p++;
        -:  228:  }
        -:  229:
        -:  230:  uint8_t *websocket_key_end_p = websocket_key_p;
        -:  231:
        -:  232:  while (*websocket_key_end_p > ' ')
        -:  233:  {
        -:  234:    websocket_key_end_p++;
        -:  235:  }
        -:  236:
        -:  237:  /* Since the request_buffer_p is not needed anymore it can
        -:  238:   * be reused for storing the SHA-1 key and Base64 string. */
        -:  239:
        -:  240:  const size_t sha1_length = 20;
        -:  241:
        -:  242:  jerryx_debugger_compute_sha1 (websocket_key_p,
        -:  243:                                (size_t) (websocket_key_end_p - websocket_key_p),
        -:  244:                                (const uint8_t *) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
        -:  245:                                36,
        -:  246:                                request_buffer_p);
        -:  247:
        -:  248:  /* The SHA-1 key is 20 bytes long but jerryx_to_base64 expects
        -:  249:   * a length divisible by 3 so an extra 0 is appended at the end. */
        -:  250:  request_buffer_p[sha1_length] = 0;
        -:  251:
        -:  252:  jerryx_to_base64 (request_buffer_p, request_buffer_p + sha1_length + 1, sha1_length + 1);
        -:  253:
        -:  254:  /* Last value must be replaced by equal sign. */
        -:  255:
        -:  256:  const uint8_t response_prefix[] =
        -:  257:    "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ";
        -:  258:
        -:  259:  if (!jerry_debugger_transport_send (response_prefix, sizeof (response_prefix) - 1)
        -:  260:      || !jerry_debugger_transport_send (request_buffer_p + sha1_length + 1, 27))
        -:  261:  {
        -:  262:    return false;
        -:  263:  }
        -:  264:
        -:  265:  const uint8_t response_suffix[] = "=\r\n\r\n";
        -:  266:  return jerry_debugger_transport_send (response_suffix, sizeof (response_suffix) - 1);
        -:  267:} /* jerryx_process_handshake */
        -:  268:
        -:  269:/**
        -:  270: * Close a tcp connection.
        -:  271: */
        -:  272:static void
        -:  273:jerryx_debugger_ws_close (jerry_debugger_transport_header_t *header_p) /**< tcp implementation */
        -:  274:{
        -:  275:  JERRYX_ASSERT (!jerry_debugger_transport_is_connected ());
        -:  276:
        -:  277:  jerry_heap_free ((void *) header_p, sizeof (jerry_debugger_transport_header_t));
        -:  278:} /* jerryx_debugger_ws_close */
        -:  279:
        -:  280:/**
        -:  281: * Send data over a websocket connection.
        -:  282: *
        -:  283: * @return true - if the data has been sent successfully
        -:  284: *         false - otherwise
        -:  285: */
        -:  286:static bool
        -:  287:jerryx_debugger_ws_send (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  288:                         uint8_t *message_p, /**< message to be sent */
        -:  289:                         size_t message_length) /**< message length in bytes */
        -:  290:{
        -:  291:  JERRYX_ASSERT (message_length <= JERRYX_DEBUGGER_WEBSOCKET_ONE_BYTE_LEN_MAX);
        -:  292:
        -:  293:  message_p[-2] = JERRYX_DEBUGGER_WEBSOCKET_FIN_BIT | JERRYX_DEBUGGER_WEBSOCKET_BINARY_FRAME;
        -:  294:  message_p[-1] = (uint8_t) message_length;
        -:  295:
        -:  296:  return header_p->next_p->send (header_p->next_p, message_p - 2, message_length + 2);
        -:  297:} /* jerryx_debugger_ws_send */
        -:  298:
        -:  299:/**
        -:  300: * Receive data from a websocket connection.
        -:  301: */
        -:  302:static bool
        -:  303:jerryx_debugger_ws_receive (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  304:                            jerry_debugger_transport_receive_context_t *receive_context_p) /**< receive context */
        -:  305:{
        -:  306:  if (!header_p->next_p->receive (header_p->next_p, receive_context_p))
        -:  307:  {
        -:  308:    return false;
        -:  309:  }
        -:  310:
        -:  311:  if (receive_context_p->message_p == NULL)
        -:  312:  {
        -:  313:    return true;
        -:  314:  }
        -:  315:
        -:  316:  size_t message_total_length = receive_context_p->message_total_length;
        -:  317:
        -:  318:  if (message_total_length == 0)
        -:  319:  {
        -:  320:    /* Byte stream. */
        -:  321:    if (receive_context_p->message_length < sizeof (jerryx_websocket_receive_header_t))
        -:  322:    {
        -:  323:      receive_context_p->message_p = NULL;
        -:  324:      return true;
        -:  325:    }
        -:  326:  }
        -:  327:  else
        -:  328:  {
        -:  329:    /* Datagram packet. */
        -:  330:    JERRYX_ASSERT (receive_context_p->message_length >= sizeof (jerryx_websocket_receive_header_t));
        -:  331:  }
        -:  332:
        -:  333:  uint8_t *message_p = receive_context_p->message_p;
        -:  334:
        -:  335:  if ((message_p[0] & ~JERRYX_DEBUGGER_WEBSOCKET_OPCODE_MASK) != JERRYX_DEBUGGER_WEBSOCKET_FIN_BIT
        -:  336:      || (message_p[1] & JERRYX_DEBUGGER_WEBSOCKET_LENGTH_MASK) > JERRYX_DEBUGGER_WEBSOCKET_ONE_BYTE_LEN_MAX
        -:  337:      || !(message_p[1] & JERRYX_DEBUGGER_WEBSOCKET_MASK_BIT))
        -:  338:  {
        -:  339:    JERRYX_ERROR_MSG ("Unsupported Websocket message.\n");
        -:  340:    jerry_debugger_transport_close ();
        -:  341:    return false;
        -:  342:  }
        -:  343:
        -:  344:  if ((message_p[0] & JERRYX_DEBUGGER_WEBSOCKET_OPCODE_MASK) != JERRYX_DEBUGGER_WEBSOCKET_BINARY_FRAME)
        -:  345:  {
        -:  346:    JERRYX_ERROR_MSG ("Unsupported Websocket opcode.\n");
        -:  347:    jerry_debugger_transport_close ();
        -:  348:    return false;
        -:  349:  }
        -:  350:
        -:  351:  size_t message_length = (size_t) (message_p[1] & JERRYX_DEBUGGER_WEBSOCKET_LENGTH_MASK);
        -:  352:
        -:  353:  if (message_total_length == 0)
        -:  354:  {
        -:  355:    size_t new_total_length = message_length + sizeof (jerryx_websocket_receive_header_t);
        -:  356:
        -:  357:    /* Byte stream. */
        -:  358:    if (receive_context_p->message_length < new_total_length)
        -:  359:    {
        -:  360:      receive_context_p->message_p = NULL;
        -:  361:      return true;
        -:  362:    }
        -:  363:
        -:  364:    receive_context_p->message_total_length = new_total_length;
        -:  365:  }
        -:  366:  else
        -:  367:  {
        -:  368:    /* Datagram packet. */
        -:  369:    JERRYX_ASSERT (receive_context_p->message_length == (message_length + sizeof (jerryx_websocket_receive_header_t)));
        -:  370:  }
        -:  371:
        -:  372:  message_p += sizeof (jerryx_websocket_receive_header_t);
        -:  373:
        -:  374:  receive_context_p->message_p = message_p;
        -:  375:  receive_context_p->message_length = message_length;
        -:  376:
        -:  377:  /* Unmask data bytes. */
        -:  378:  const uint8_t *mask_p = message_p - JERRYX_DEBUGGER_WEBSOCKET_MASK_SIZE;
        -:  379:  const uint8_t *mask_end_p = message_p;
        -:  380:  const uint8_t *message_end_p = message_p + message_length;
        -:  381:
        -:  382:  while (message_p < message_end_p)
        -:  383:  {
        -:  384:    /* Invert certain bits with xor operation. */
        -:  385:    *message_p = *message_p ^ *mask_p;
        -:  386:
        -:  387:    message_p++;
        -:  388:    mask_p++;
        -:  389:
        -:  390:    if (JERRY_UNLIKELY (mask_p >= mask_end_p))
        -:  391:    {
        -:  392:      mask_p -= JERRYX_DEBUGGER_WEBSOCKET_MASK_SIZE;
        -:  393:    }
        -:  394:  }
        -:  395:
        -:  396:  return true;
        -:  397:} /* jerryx_debugger_ws_receive */
        -:  398:
        -:  399:/**
        -:  400: * Initialize the websocket transportation layer.
        -:  401: *
        -:  402: * @return true - if the connection succeeded
        -:  403: *         false - otherwise
        -:  404: */
        -:  405:bool
        -:  406:jerryx_debugger_ws_create (void)
        -:  407:{
        -:  408:  bool is_handshake_ok = false;
        -:  409:
        -:  410:  const jerry_size_t buffer_size = 1024;
        -:  411:  uint8_t *request_buffer_p = (uint8_t *) jerry_heap_alloc (buffer_size);
        -:  412:
        -:  413:  if (!request_buffer_p)
        -:  414:  {
        -:  415:    return false;
        -:  416:  }
        -:  417:
        -:  418:  is_handshake_ok = jerryx_process_handshake (request_buffer_p);
        -:  419:
        -:  420:  jerry_heap_free ((void *) request_buffer_p, buffer_size);
        -:  421:
        -:  422:  if (!is_handshake_ok && jerry_debugger_transport_is_connected ())
        -:  423:  {
        -:  424:    return false;
        -:  425:  }
        -:  426:
        -:  427:  const jerry_size_t interface_size = sizeof (jerry_debugger_transport_header_t);
        -:  428:  jerry_debugger_transport_header_t *header_p;
        -:  429:  header_p = (jerry_debugger_transport_header_t *) jerry_heap_alloc (interface_size);
        -:  430:
        -:  431:  if (!header_p)
        -:  432:  {
        -:  433:    return false;
        -:  434:  }
        -:  435:
        -:  436:  header_p->close = jerryx_debugger_ws_close;
        -:  437:  header_p->send = jerryx_debugger_ws_send;
        -:  438:  header_p->receive = jerryx_debugger_ws_receive;
        -:  439:
        -:  440:  jerry_debugger_transport_add (header_p,
        -:  441:                                JERRYX_DEBUGGER_WEBSOCKET_HEADER_SIZE,
        -:  442:                                JERRYX_DEBUGGER_WEBSOCKET_ONE_BYTE_LEN_MAX,
        -:  443:                                JERRYX_DEBUGGER_WEBSOCKET_HEADER_SIZE + JERRYX_DEBUGGER_WEBSOCKET_MASK_SIZE,
        -:  444:                                JERRYX_DEBUGGER_WEBSOCKET_ONE_BYTE_LEN_MAX);
        -:  445:
        -:  446:  return true;
        -:  447:} /* jerryx_debugger_ws_create */
        -:  448:
        -:  449:#else /* !(defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)) */
        -:  450:
        -:  451:/**
        -:  452: * Dummy function when debugger is disabled.
        -:  453: *
        -:  454: * @return false
        -:  455: */
        -:  456:bool
    #####:  457:jerryx_debugger_ws_create (void)
        -:  458:{
    #####:  459:  return false;
        -:  460:} /* jerryx_debugger_ws_create */
        -:  461:
        -:  462:#endif /* defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1) */
