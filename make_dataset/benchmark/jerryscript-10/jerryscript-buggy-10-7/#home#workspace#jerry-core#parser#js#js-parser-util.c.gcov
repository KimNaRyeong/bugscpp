        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-util.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:
        -:   18:#include "js-parser-internal.h"
        -:   19:
        -:   20:#if JERRY_PARSER
        -:   21:
        -:   22:#if JERRY_LINE_INFO
        -:   23:#include "jcontext.h"
        -:   24:#endif /* JERRY_LINE_INFO */
        -:   25:
        -:   26:/** \addtogroup parser Parser
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser JavaScript
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup jsparser_utils Utility
        -:   33: * @{
        -:   34: */
        -:   35:
        -:   36:/**********************************************************************/
        -:   37:/* Emitting byte codes                                                */
        -:   38:/**********************************************************************/
        -:   39:
        -:   40:/**
        -:   41: * Append two bytes to the cbc stream.
        -:   42: */
        -:   43:static void
       10:   44:parser_emit_two_bytes (parser_context_t *context_p, /**< context */
        -:   45:                       uint8_t first_byte, /**< first byte */
        -:   46:                       uint8_t second_byte) /**< second byte */
        -:   47:{
       10:   48:  uint32_t last_position = context_p->byte_code.last_position;
        -:   49:
       10:   50:  if (last_position + 2 <= PARSER_CBC_STREAM_PAGE_SIZE)
        -:   51:  {
       10:   52:    parser_mem_page_t *page_p = context_p->byte_code.last_p;
        -:   53:
       10:   54:    page_p->bytes[last_position] = first_byte;
       10:   55:    page_p->bytes[last_position + 1] = second_byte;
       10:   56:    context_p->byte_code.last_position = last_position + 2;
        -:   57:  }
    #####:   58:  else if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:   59:  {
        -:   60:    parser_mem_page_t *page_p;
        -:   61:
    #####:   62:    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);
    #####:   63:    page_p = context_p->byte_code.last_p;
    #####:   64:    page_p->bytes[0] = first_byte;
    #####:   65:    page_p->bytes[1] = second_byte;
    #####:   66:    context_p->byte_code.last_position = 2;
        -:   67:  }
        -:   68:  else
        -:   69:  {
    #####:   70:    context_p->byte_code.last_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] = first_byte;
    #####:   71:    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);
    #####:   72:    context_p->byte_code.last_p->bytes[0] = second_byte;
    #####:   73:    context_p->byte_code.last_position = 1;
        -:   74:  }
       10:   75:} /* parser_emit_two_bytes */
        -:   76:
        -:   77:/**
        -:   78: * Append byte to the end of the current byte code stream.
        -:   79: *
        -:   80: * @param context_p parser context
        -:   81: * @param byte byte
        -:   82: */
        -:   83:#define PARSER_APPEND_TO_BYTE_CODE(context_p, byte)                        \
        -:   84:  if ((context_p)->byte_code.last_position >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:   85:  {                                                                        \
        -:   86:    parser_cbc_stream_alloc_page ((context_p), &(context_p)->byte_code);   \
        -:   87:  }                                                                        \
        -:   88:  (context_p)->byte_code.last_p->bytes[(context_p)->byte_code.last_position++] = (uint8_t) (byte)
        -:   89:
        -:   90:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:   91:
        -:   92:/**
        -:   93: * Print literal corresponding to the current index
        -:   94: */
        -:   95:static void
        -:   96:parser_print_literal (parser_context_t *context_p, /**< context */
        -:   97:                      uint16_t literal_index) /**< index of literal */
        -:   98:{
        -:   99:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p;
        -:  100:  parser_scope_stack_t *scope_stack_end_p = scope_stack_p + context_p->scope_stack_top;
        -:  101:  bool in_scope_literal = false;
        -:  102:
        -:  103:  while (scope_stack_p < scope_stack_end_p)
        -:  104:  {
        -:  105:    scope_stack_end_p--;
        -:  106:
        -:  107:    if (scope_stack_end_p->map_from == PARSER_SCOPE_STACK_FUNC)
        -:  108:    {
        -:  109:      if (literal_index == scope_stack_end_p->map_to)
        -:  110:      {
        -:  111:        in_scope_literal = true;
        -:  112:        break;
        -:  113:      }
        -:  114:    }
        -:  115:    else if (literal_index == scanner_decode_map_to (scope_stack_end_p))
        -:  116:    {
        -:  117:      in_scope_literal = true;
        -:  118:      break;
        -:  119:    }
        -:  120:  }
        -:  121:
        -:  122:  if (literal_index < PARSER_REGISTER_START)
        -:  123:  {
        -:  124:    JERRY_DEBUG_MSG (in_scope_literal ? " IDX:%d->" : " idx:%d->", literal_index);
        -:  125:    lexer_literal_t *literal_p = PARSER_GET_LITERAL (literal_index);
        -:  126:    util_print_literal (literal_p);
        -:  127:    return;
        -:  128:  }
        -:  129:
        -:  130:  if (!in_scope_literal)
        -:  131:  {
        -:  132:    JERRY_DEBUG_MSG (" reg:%d", (int) (literal_index - PARSER_REGISTER_START));
        -:  133:    return;
        -:  134:  }
        -:  135:
        -:  136:  JERRY_DEBUG_MSG (" REG:%d->", (int) (literal_index - PARSER_REGISTER_START));
        -:  137:
        -:  138:  lexer_literal_t *literal_p = PARSER_GET_LITERAL (scope_stack_end_p->map_from);
        -:  139:  util_print_literal (literal_p);
        -:  140:} /* parser_print_literal */
        -:  141:
        -:  142:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  143:
        -:  144:/**
        -:  145: * Append the current byte code to the stream
        -:  146: */
        -:  147:void
       15:  148:parser_flush_cbc (parser_context_t *context_p) /**< context */
        -:  149:{
        -:  150:  uint8_t flags;
       15:  151:  uint16_t last_opcode = context_p->last_cbc_opcode;
        -:  152:
       15:  153:  if (last_opcode == PARSER_CBC_UNAVAILABLE)
        -:  154:  {
        2:  155:    return;
        -:  156:  }
        -:  157:
       13:  158:  context_p->status_flags |= PARSER_NO_END_LABEL;
        -:  159:
       13:  160:  if (PARSER_IS_BASIC_OPCODE (last_opcode))
        -:  161:  {
       13:  162:    cbc_opcode_t opcode = (cbc_opcode_t) last_opcode;
        -:  163:
       13:  164:    JERRY_ASSERT (opcode < CBC_END);
       13:  165:    flags = cbc_flags[opcode];
        -:  166:
       13:  167:    PARSER_APPEND_TO_BYTE_CODE (context_p, opcode);
       13:  168:    context_p->byte_code_size++;
        -:  169:  }
        -:  170:  else
        -:  171:  {
    #####:  172:    cbc_ext_opcode_t opcode = (cbc_ext_opcode_t) PARSER_GET_EXT_OPCODE (last_opcode);
        -:  173:
    #####:  174:    JERRY_ASSERT (opcode < CBC_EXT_END);
    #####:  175:    flags = cbc_ext_flags[opcode];
    #####:  176:    parser_emit_two_bytes (context_p, CBC_EXT_OPCODE, (uint8_t) opcode);
    #####:  177:    context_p->byte_code_size += 2;
        -:  178:  }
        -:  179:
       13:  180:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  181:                || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
       13:  182:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  183:
       13:  184:  if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  185:  {
        8:  186:    uint16_t literal_index = context_p->last_cbc.literal_index;
        -:  187:
        8:  188:    parser_emit_two_bytes (context_p, (uint8_t) (literal_index & 0xff), (uint8_t) (literal_index >> 8));
        8:  189:    context_p->byte_code_size += 2;
        -:  190:  }
        -:  191:
       13:  192:  if (flags & CBC_HAS_LITERAL_ARG2)
        -:  193:  {
        2:  194:    uint16_t literal_index = context_p->last_cbc.value;
        -:  195:
        2:  196:    parser_emit_two_bytes (context_p, (uint8_t) (literal_index & 0xff), (uint8_t) (literal_index >> 8));
        2:  197:    context_p->byte_code_size += 2;
        -:  198:
        2:  199:    if (!(flags & CBC_HAS_LITERAL_ARG))
        -:  200:    {
    #####:  201:      literal_index = context_p->last_cbc.third_literal_index;
        -:  202:
    #####:  203:      parser_emit_two_bytes (context_p, (uint8_t) (literal_index & 0xff), (uint8_t) (literal_index >> 8));
    #####:  204:      context_p->byte_code_size += 2;
        -:  205:    }
        -:  206:  }
        -:  207:
       13:  208:  if (flags & CBC_HAS_BYTE_ARG)
        -:  209:  {
        3:  210:    uint8_t byte_argument = (uint8_t) context_p->last_cbc.value;
        -:  211:
        3:  212:    JERRY_ASSERT (context_p->last_cbc.value <= CBC_MAXIMUM_BYTE_VALUE);
        -:  213:
        3:  214:    if (flags & CBC_POP_STACK_BYTE_ARG)
        -:  215:    {
        1:  216:      JERRY_ASSERT (context_p->stack_depth >= byte_argument);
        1:  217:      PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, byte_argument);
        -:  218:    }
        -:  219:
        3:  220:    PARSER_APPEND_TO_BYTE_CODE (context_p, byte_argument);
        3:  221:    context_p->byte_code_size++;
        -:  222:  }
        -:  223:
        -:  224:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  225:  if (context_p->is_show_opcodes)
        -:  226:  {
        -:  227:    JERRY_DEBUG_MSG ("  [%3d] %s",
        -:  228:                     (int) context_p->stack_depth,
        -:  229:                     PARSER_IS_BASIC_OPCODE (last_opcode) ? cbc_names[last_opcode]
        -:  230:                                                          : cbc_ext_names[PARSER_GET_EXT_OPCODE (last_opcode)]);
        -:  231:
        -:  232:    if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  233:    {
        -:  234:      parser_print_literal (context_p, context_p->last_cbc.literal_index);
        -:  235:    }
        -:  236:
        -:  237:    if (flags & CBC_HAS_LITERAL_ARG2)
        -:  238:    {
        -:  239:      parser_print_literal (context_p, context_p->last_cbc.value);
        -:  240:
        -:  241:      if (!(flags & CBC_HAS_LITERAL_ARG))
        -:  242:      {
        -:  243:        parser_print_literal (context_p, context_p->last_cbc.third_literal_index);
        -:  244:      }
        -:  245:    }
        -:  246:
        -:  247:    if (flags & CBC_HAS_BYTE_ARG)
        -:  248:    {
        -:  249:      if (last_opcode == CBC_PUSH_NUMBER_POS_BYTE || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)
        -:  250:      {
        -:  251:        JERRY_DEBUG_MSG (" number:%d", (int) context_p->last_cbc.value + 1);
        -:  252:      }
        -:  253:      else if (last_opcode == CBC_PUSH_NUMBER_NEG_BYTE || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE)
        -:  254:      {
        -:  255:        JERRY_DEBUG_MSG (" number:%d", -((int) context_p->last_cbc.value + 1));
        -:  256:      }
        -:  257:      else
        -:  258:      {
        -:  259:        JERRY_DEBUG_MSG (" byte_arg:%d", (int) context_p->last_cbc.value);
        -:  260:      }
        -:  261:    }
        -:  262:
        -:  263:    JERRY_DEBUG_MSG ("\n");
        -:  264:  }
        -:  265:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  266:
       13:  267:  if (context_p->stack_depth > context_p->stack_limit)
        -:  268:  {
        5:  269:    context_p->stack_limit = context_p->stack_depth;
        5:  270:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  271:    {
    #####:  272:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  273:    }
        -:  274:  }
        -:  275:
       13:  276:  context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -:  277:} /* parser_flush_cbc */
        -:  278:
        -:  279:/**
        -:  280: * Append a byte code
        -:  281: */
        -:  282:void
        2:  283:parser_emit_cbc (parser_context_t *context_p, /**< context */
        -:  284:                 uint16_t opcode) /**< opcode */
        -:  285:{
        2:  286:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, 0));
        -:  287:
        2:  288:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  289:  {
        2:  290:    parser_flush_cbc (context_p);
        -:  291:  }
        -:  292:
        2:  293:  context_p->last_cbc_opcode = opcode;
        2:  294:} /* parser_emit_cbc */
        -:  295:
        -:  296:/**
        -:  297: * Append a byte code with a literal argument
        -:  298: */
        -:  299:void
        3:  300:parser_emit_cbc_literal (parser_context_t *context_p, /**< context */
        -:  301:                         uint16_t opcode, /**< opcode */
        -:  302:                         uint16_t literal_index) /**< literal index */
        -:  303:{
        3:  304:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));
        -:  305:
        3:  306:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  307:  {
        1:  308:    parser_flush_cbc (context_p);
        -:  309:  }
        -:  310:
        3:  311:  context_p->last_cbc_opcode = opcode;
        3:  312:  context_p->last_cbc.literal_index = literal_index;
        3:  313:  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;
        3:  314:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
        3:  315:} /* parser_emit_cbc_literal */
        -:  316:
        -:  317:/**
        -:  318: * Append a byte code with a literal and value argument
        -:  319: */
        -:  320:void
    #####:  321:parser_emit_cbc_literal_value (parser_context_t *context_p, /**< context */
        -:  322:                               uint16_t opcode, /**< opcode */
        -:  323:                               uint16_t literal_index, /**< literal index */
        -:  324:                               uint16_t value) /**< value */
        -:  325:{
    #####:  326:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -:  327:
    #####:  328:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  329:  {
    #####:  330:    parser_flush_cbc (context_p);
        -:  331:  }
        -:  332:
    #####:  333:  context_p->last_cbc_opcode = opcode;
    #####:  334:  context_p->last_cbc.literal_index = literal_index;
    #####:  335:  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;
    #####:  336:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####:  337:  context_p->last_cbc.value = value;
    #####:  338:} /* parser_emit_cbc_literal_value */
        -:  339:
        -:  340:/**
        -:  341: * Append a byte code with the current literal argument
        -:  342: */
        -:  343:void
        5:  344:parser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */
        -:  345:                                    uint16_t opcode) /**< opcode */
        -:  346:{
        5:  347:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));
        -:  348:
        5:  349:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  350:  {
        2:  351:    parser_flush_cbc (context_p);
        -:  352:  }
        -:  353:
        5:  354:  context_p->last_cbc_opcode = opcode;
        5:  355:  context_p->last_cbc.literal_index = context_p->lit_object.index;
        5:  356:  context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        5:  357:  context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        5:  358:} /* parser_emit_cbc_literal_from_token */
        -:  359:
        -:  360:/**
        -:  361: * Append a byte code with a call argument
        -:  362: */
        -:  363:void
        1:  364:parser_emit_cbc_call (parser_context_t *context_p, /**< context */
        -:  365:                      uint16_t opcode, /**< opcode */
        -:  366:                      size_t call_arguments) /**< number of arguments */
        -:  367:{
        1:  368:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_BYTE_ARG));
        1:  369:  JERRY_ASSERT (call_arguments <= CBC_MAXIMUM_BYTE_VALUE);
        -:  370:
        1:  371:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  372:  {
        1:  373:    parser_flush_cbc (context_p);
        -:  374:  }
        -:  375:
        1:  376:  context_p->last_cbc_opcode = opcode;
        1:  377:  context_p->last_cbc.value = (uint16_t) call_arguments;
        1:  378:} /* parser_emit_cbc_call */
        -:  379:
        -:  380:/**
        -:  381: * Append a push number 1/2 byte code
        -:  382: */
        -:  383:void
        3:  384:parser_emit_cbc_push_number (parser_context_t *context_p, /**< context */
        -:  385:                             bool is_negative_number) /**< sign is negative */
        -:  386:{
        3:  387:  uint16_t value = context_p->lit_object.index;
        3:  388:  uint16_t lit_value = PARSER_INVALID_LITERAL_INDEX;
        -:  389:
        3:  390:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  391:  {
        3:  392:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  393:    {
        1:  394:      lit_value = context_p->last_cbc.literal_index;
        -:  395:    }
        -:  396:    else
        -:  397:    {
        2:  398:      if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  399:      {
    #####:  400:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  401:        lit_value = context_p->last_cbc.value;
        -:  402:      }
        2:  403:      else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -:  404:      {
    #####:  405:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  406:        lit_value = context_p->last_cbc.third_literal_index;
        -:  407:      }
        -:  408:
        2:  409:      parser_flush_cbc (context_p);
        -:  410:    }
        -:  411:  }
        -:  412:
        3:  413:  if (value == 0)
        -:  414:  {
        1:  415:    if (lit_value == PARSER_INVALID_LITERAL_INDEX)
        -:  416:    {
        1:  417:      context_p->last_cbc_opcode = CBC_PUSH_NUMBER_0;
        1:  418:      return;
        -:  419:    }
        -:  420:
    #####:  421:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL_PUSH_NUMBER_0;
    #####:  422:    context_p->last_cbc.literal_index = lit_value;
    #####:  423:    return;
        -:  424:  }
        -:  425:
        -:  426:  uint16_t opcode;
        -:  427:
        2:  428:  if (lit_value == PARSER_INVALID_LITERAL_INDEX)
        -:  429:  {
        1:  430:    opcode = (is_negative_number ? CBC_PUSH_NUMBER_NEG_BYTE : CBC_PUSH_NUMBER_POS_BYTE);
        -:  431:
        1:  432:    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 1);
        -:  433:  }
        -:  434:  else
        -:  435:  {
        1:  436:    opcode = (is_negative_number ? CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE);
        1:  437:    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 2);
        -:  438:
        1:  439:    context_p->last_cbc.literal_index = lit_value;
        -:  440:  }
        -:  441:
        2:  442:  JERRY_ASSERT (value > 0 && value <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -:  443:
        2:  444:  context_p->last_cbc_opcode = opcode;
        2:  445:  context_p->last_cbc.value = (uint16_t) (value - 1);
        -:  446:} /* parser_emit_cbc_push_number */
        -:  447:
        -:  448:/**
        -:  449: * Append a byte code with a branch argument
        -:  450: */
        -:  451:void
    #####:  452:parser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */
        -:  453:                                uint16_t opcode, /**< opcode */
        -:  454:                                parser_branch_t *branch_p) /**< branch result */
        -:  455:{
        -:  456:  uint8_t flags;
        -:  457:  uint32_t extra_byte_code_increase;
        -:  458:
    #####:  459:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  460:  {
    #####:  461:    parser_flush_cbc (context_p);
        -:  462:  }
        -:  463:
    #####:  464:  context_p->status_flags |= PARSER_NO_END_LABEL;
        -:  465:
    #####:  466:  if (PARSER_IS_BASIC_OPCODE (opcode))
        -:  467:  {
    #####:  468:    JERRY_ASSERT (opcode < CBC_END);
    #####:  469:    flags = cbc_flags[opcode];
    #####:  470:    extra_byte_code_increase = 0;
        -:  471:  }
        -:  472:  else
        -:  473:  {
    #####:  474:    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);
    #####:  475:    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);
        -:  476:
    #####:  477:    JERRY_ASSERT (opcode < CBC_EXT_END);
    #####:  478:    flags = cbc_ext_flags[opcode];
    #####:  479:    extra_byte_code_increase = 1;
        -:  480:  }
        -:  481:
    #####:  482:  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
    #####:  483:  JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
    #####:  484:  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);
        -:  485:
        -:  486:  /* Branch opcodes never push anything onto the stack. */
    #####:  487:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  488:                || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
    #####:  489:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  490:
        -:  491:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  492:  if (context_p->is_show_opcodes)
        -:  493:  {
        -:  494:    JERRY_DEBUG_MSG ("  [%3d] %s\n",
        -:  495:                     (int) context_p->stack_depth,
        -:  496:                     extra_byte_code_increase == 0 ? cbc_names[opcode] : cbc_ext_names[opcode]);
        -:  497:  }
        -:  498:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  499:
    #####:  500:  PARSER_PLUS_EQUAL_U16 (opcode, PARSER_MAX_BRANCH_LENGTH - 1);
        -:  501:
    #####:  502:  parser_emit_two_bytes (context_p, (uint8_t) opcode, 0);
    #####:  503:  branch_p->page_p = context_p->byte_code.last_p;
    #####:  504:  branch_p->offset = (context_p->byte_code.last_position - 1) | (context_p->byte_code_size << 8);
        -:  505:
    #####:  506:  context_p->byte_code_size += extra_byte_code_increase;
        -:  507:
        -:  508:#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX
        -:  509:  PARSER_APPEND_TO_BYTE_CODE (context_p, 0);
        -:  510:#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
    #####:  511:  parser_emit_two_bytes (context_p, 0, 0);
        -:  512:#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */
        -:  513:
    #####:  514:  context_p->byte_code_size += PARSER_MAX_BRANCH_LENGTH + 1;
        -:  515:
    #####:  516:  if (context_p->stack_depth > context_p->stack_limit)
        -:  517:  {
    #####:  518:    context_p->stack_limit = context_p->stack_depth;
    #####:  519:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  520:    {
    #####:  521:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  522:    }
        -:  523:  }
    #####:  524:} /* parser_emit_cbc_forward_branch */
        -:  525:
        -:  526:/**
        -:  527: * Append a branch byte code and create an item.
        -:  528: *
        -:  529: * @return newly created parser branch node
        -:  530: */
        -:  531:parser_branch_node_t *
    #####:  532:parser_emit_cbc_forward_branch_item (parser_context_t *context_p, /**< context */
        -:  533:                                     uint16_t opcode, /**< opcode */
        -:  534:                                     parser_branch_node_t *next_p) /**< next branch */
        -:  535:{
    #####:  536:  parser_branch_t branch;
        -:  537:  parser_branch_node_t *new_item;
        -:  538:
        -:  539:  /* Since byte code insertion may throw an out-of-memory error,
        -:  540:   * the branch is constructed locally, and copied later. */
    #####:  541:  parser_emit_cbc_forward_branch (context_p, opcode, &branch);
        -:  542:
    #####:  543:  new_item = (parser_branch_node_t *) parser_malloc (context_p, sizeof (parser_branch_node_t));
    #####:  544:  new_item->branch = branch;
    #####:  545:  new_item->next_p = next_p;
    #####:  546:  return new_item;
        -:  547:} /* parser_emit_cbc_forward_branch_item */
        -:  548:
        -:  549:/**
        -:  550: * Append a byte code with a branch argument
        -:  551: */
        -:  552:void
    #####:  553:parser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */
        -:  554:                                 uint16_t opcode, /**< opcode */
        -:  555:                                 uint32_t offset) /**< destination offset */
        -:  556:{
        -:  557:  uint8_t flags;
        -:  558:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  559:  const char *name;
        -:  560:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  561:
    #####:  562:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  563:  {
    #####:  564:    parser_flush_cbc (context_p);
        -:  565:  }
        -:  566:
    #####:  567:  context_p->status_flags |= PARSER_NO_END_LABEL;
    #####:  568:  offset = context_p->byte_code_size - offset;
        -:  569:
    #####:  570:  if (PARSER_IS_BASIC_OPCODE (opcode))
        -:  571:  {
    #####:  572:    JERRY_ASSERT (opcode < CBC_END);
    #####:  573:    flags = cbc_flags[opcode];
        -:  574:
        -:  575:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  576:    name = cbc_names[opcode];
        -:  577:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  578:  }
        -:  579:  else
        -:  580:  {
    #####:  581:    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);
    #####:  582:    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);
        -:  583:
    #####:  584:    JERRY_ASSERT (opcode < CBC_EXT_END);
    #####:  585:    flags = cbc_ext_flags[opcode];
    #####:  586:    context_p->byte_code_size++;
        -:  587:
        -:  588:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  589:    name = cbc_ext_names[opcode];
        -:  590:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  591:  }
        -:  592:
    #####:  593:  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
    #####:  594:  JERRY_ASSERT (CBC_BRANCH_IS_BACKWARD (flags));
    #####:  595:  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);
    #####:  596:  JERRY_ASSERT (offset <= context_p->byte_code_size);
        -:  597:
        -:  598:  /* Branch opcodes never push anything onto the stack. */
    #####:  599:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  600:                || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
    #####:  601:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  602:
        -:  603:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  604:  if (context_p->is_show_opcodes)
        -:  605:  {
        -:  606:    JERRY_DEBUG_MSG ("  [%3d] %s\n", (int) context_p->stack_depth, name);
        -:  607:  }
        -:  608:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  609:
    #####:  610:  context_p->byte_code_size += 2;
        -:  611:#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX
    #####:  612:  if (offset > UINT16_MAX)
        -:  613:  {
    #####:  614:    opcode++;
    #####:  615:    context_p->byte_code_size++;
        -:  616:  }
        -:  617:#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        -:  618:
    #####:  619:  if (offset > UINT8_MAX)
        -:  620:  {
    #####:  621:    opcode++;
    #####:  622:    context_p->byte_code_size++;
        -:  623:  }
        -:  624:
    #####:  625:  PARSER_APPEND_TO_BYTE_CODE (context_p, (uint8_t) opcode);
        -:  626:
        -:  627:#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX
    #####:  628:  if (offset > UINT16_MAX)
        -:  629:  {
    #####:  630:    PARSER_APPEND_TO_BYTE_CODE (context_p, offset >> 16);
        -:  631:  }
        -:  632:#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        -:  633:
    #####:  634:  if (offset > UINT8_MAX)
        -:  635:  {
    #####:  636:    PARSER_APPEND_TO_BYTE_CODE (context_p, (offset >> 8) & 0xff);
        -:  637:  }
        -:  638:
    #####:  639:  PARSER_APPEND_TO_BYTE_CODE (context_p, offset & 0xff);
    #####:  640:} /* parser_emit_cbc_backward_branch */
        -:  641:
        -:  642:#undef PARSER_CHECK_LAST_POSITION
        -:  643:#undef PARSER_APPEND_TO_BYTE_CODE
        -:  644:
        -:  645:/**
        -:  646: * Helper function for parser.
        -:  647: *
        -:  648: * @return a new string based on encode.
        -:  649: */
        -:  650:ecma_string_t *
    #####:  651:parser_new_ecma_string_from_literal (lexer_literal_t *literal_p) /**< literal */
        -:  652:{
    #####:  653:  JERRY_ASSERT (literal_p != NULL);
        -:  654:
    #####:  655:  ecma_string_t *new_string = NULL;
        -:  656:
    #####:  657:  if (literal_p->status_flags & LEXER_FLAG_ASCII)
        -:  658:  {
    #####:  659:    new_string = ecma_new_ecma_string_from_ascii (literal_p->u.char_p, literal_p->prop.length);
        -:  660:  }
        -:  661:  else
        -:  662:  {
    #####:  663:    new_string = ecma_new_ecma_string_from_utf8 (literal_p->u.char_p, literal_p->prop.length);
        -:  664:  }
        -:  665:
    #####:  666:  return new_string;
        -:  667:} /* parser_new_ecma_string_from_literal */
        -:  668:
        -:  669:/**
        -:  670: * Set a branch to the current byte code position
        -:  671: */
        -:  672:void
    #####:  673:parser_set_branch_to_current_position (parser_context_t *context_p, /**< context */
        -:  674:                                       parser_branch_t *branch_p) /**< branch result */
        -:  675:{
        -:  676:  uint32_t delta;
        -:  677:  size_t offset;
    #####:  678:  parser_mem_page_t *page_p = branch_p->page_p;
        -:  679:
    #####:  680:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  681:  {
    #####:  682:    parser_flush_cbc (context_p);
        -:  683:  }
        -:  684:
    #####:  685:  context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  686:
    #####:  687:  JERRY_ASSERT (context_p->byte_code_size > (branch_p->offset >> 8));
        -:  688:
    #####:  689:  delta = context_p->byte_code_size - (branch_p->offset >> 8);
    #####:  690:  offset = (branch_p->offset & CBC_LOWER_SEVEN_BIT_MASK);
        -:  691:
    #####:  692:  JERRY_ASSERT (delta <= PARSER_MAXIMUM_CODE_SIZE);
        -:  693:
        -:  694:#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX
        -:  695:  page_p->bytes[offset++] = (uint8_t) (delta >> 8);
        -:  696:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  697:  {
        -:  698:    page_p = page_p->next_p;
        -:  699:    offset = 0;
        -:  700:  }
        -:  701:#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
    #####:  702:  page_p->bytes[offset++] = (uint8_t) (delta >> 16);
    #####:  703:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  704:  {
    #####:  705:    page_p = page_p->next_p;
    #####:  706:    offset = 0;
        -:  707:  }
    #####:  708:  page_p->bytes[offset++] = (uint8_t) ((delta >> 8) & 0xff);
    #####:  709:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  710:  {
    #####:  711:    page_p = page_p->next_p;
    #####:  712:    offset = 0;
        -:  713:  }
        -:  714:#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */
    #####:  715:  page_p->bytes[offset] = delta & 0xff;
    #####:  716:} /* parser_set_branch_to_current_position */
        -:  717:
        -:  718:/**
        -:  719: * Set breaks to the current byte code position
        -:  720: */
        -:  721:void
    #####:  722:parser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */
        -:  723:                                       parser_branch_node_t *current_p) /**< branch list */
        -:  724:{
    #####:  725:  while (current_p != NULL)
        -:  726:  {
    #####:  727:    parser_branch_node_t *next_p = current_p->next_p;
        -:  728:
    #####:  729:    if (!(current_p->branch.offset & CBC_HIGHEST_BIT_MASK))
        -:  730:    {
    #####:  731:      parser_set_branch_to_current_position (context_p, &current_p->branch);
        -:  732:    }
    #####:  733:    parser_free (current_p, sizeof (parser_branch_node_t));
    #####:  734:    current_p = next_p;
        -:  735:  }
    #####:  736:} /* parser_set_breaks_to_current_position */
        -:  737:
        -:  738:/**
        -:  739: * Set continues to the current byte code position
        -:  740: */
        -:  741:void
    #####:  742:parser_set_continues_to_current_position (parser_context_t *context_p, /**< context */
        -:  743:                                          parser_branch_node_t *current_p) /**< branch list */
        -:  744:{
    #####:  745:  while (current_p != NULL)
        -:  746:  {
    #####:  747:    if (current_p->branch.offset & CBC_HIGHEST_BIT_MASK)
        -:  748:    {
    #####:  749:      parser_set_branch_to_current_position (context_p, &current_p->branch);
        -:  750:    }
    #####:  751:    current_p = current_p->next_p;
        -:  752:  }
    #####:  753:} /* parser_set_continues_to_current_position */
        -:  754:
        -:  755:#if JERRY_ESNEXT
        -:  756:
        -:  757:/**
        -:  758: * Return the size of internal record corresponding to a class field
        -:  759: *
        -:  760: * @return internal record size
        -:  761: */
        -:  762:static size_t
    #####:  763:parser_get_class_field_info_size (uint8_t class_field_type) /**< class field type */
        -:  764:{
    #####:  765:  if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -:  766:  {
    #####:  767:    return sizeof (scanner_range_t) + 1;
        -:  768:  }
        -:  769:
    #####:  770:  if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -:  771:  {
    #####:  772:    return sizeof (scanner_location_t) + 1;
        -:  773:  }
        -:  774:
    #####:  775:  return 1;
        -:  776:} /* parser_get_class_field_info_size */
        -:  777:
        -:  778:/**
        -:  779: * Reverse the field list of a class
        -:  780: */
        -:  781:void
    #####:  782:parser_reverse_class_fields (parser_context_t *context_p, /**< context */
        -:  783:                             size_t fields_size) /**< size of consumed memory */
        -:  784:{
    #####:  785:  uint8_t *data_p = (uint8_t *) parser_malloc (context_p, fields_size);
    #####:  786:  uint8_t *data_end_p = data_p + fields_size;
    #####:  787:  uint8_t *current_p = data_p;
    #####:  788:  bool has_fields = false;
    #####:  789:  parser_stack_iterator_t iterator;
        -:  790:
    #####:  791:  JERRY_ASSERT (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -:  792:
    #####:  793:  parser_stack_iterator_init (context_p, &iterator);
        -:  794:
        -:  795:  do
        -:  796:  {
    #####:  797:    uint8_t class_field_type = parser_stack_iterator_read_uint8 (&iterator);
    #####:  798:    size_t info_size = parser_get_class_field_info_size (class_field_type);
        -:  799:
    #####:  800:    parser_stack_iterator_read (&iterator, current_p, info_size);
    #####:  801:    parser_stack_iterator_skip (&iterator, info_size);
    #####:  802:    current_p += info_size;
        -:  803:
    #####:  804:    if (!(class_field_type & PARSER_CLASS_FIELD_STATIC))
        -:  805:    {
    #####:  806:      has_fields = true;
    #####:  807:      context_p->stack_top_uint8 = class_field_type;
        -:  808:    }
    #####:  809:  } while (current_p < data_end_p);
        -:  810:
    #####:  811:  parser_stack_iterator_init (context_p, &iterator);
    #####:  812:  current_p = data_end_p;
        -:  813:
    #####:  814:  bool has_static_fields = false;
        -:  815:
    #####:  816:  if (has_fields)
        -:  817:  {
        -:  818:    do
        -:  819:    {
    #####:  820:      uint8_t class_field_type = current_p[-1];
        -:  821:
    #####:  822:      size_t info_size = parser_get_class_field_info_size (class_field_type);
        -:  823:
    #####:  824:      if (!(class_field_type & PARSER_CLASS_FIELD_STATIC))
        -:  825:      {
    #####:  826:        current_p -= info_size;
    #####:  827:        parser_stack_iterator_write (&iterator, current_p, info_size);
    #####:  828:        parser_stack_iterator_skip (&iterator, info_size);
    #####:  829:        continue;
        -:  830:      }
        -:  831:
    #####:  832:      if (!has_static_fields)
        -:  833:      {
    #####:  834:        has_static_fields = true;
    #####:  835:        current_p[-1] |= PARSER_CLASS_FIELD_END;
        -:  836:      }
    #####:  837:      current_p -= info_size;
    #####:  838:    } while (current_p > data_p);
        -:  839:  }
        -:  840:  else
        -:  841:  {
        -:  842:    /* All class fields are static. */
    #####:  843:    has_static_fields = true;
    #####:  844:    JERRY_ASSERT (data_end_p[-1] & PARSER_CLASS_FIELD_STATIC);
    #####:  845:    context_p->stack_top_uint8 = data_end_p[-1];
        -:  846:  }
        -:  847:
    #####:  848:  if (has_static_fields)
        -:  849:  {
    #####:  850:    current_p = data_end_p;
        -:  851:
        -:  852:    do
        -:  853:    {
    #####:  854:      uint8_t class_field_type = current_p[-1];
        -:  855:
    #####:  856:      size_t info_size = parser_get_class_field_info_size (class_field_type);
    #####:  857:      current_p -= info_size;
        -:  858:
    #####:  859:      if (class_field_type & PARSER_CLASS_FIELD_STATIC)
        -:  860:      {
    #####:  861:        parser_stack_iterator_write (&iterator, current_p, info_size);
    #####:  862:        parser_stack_iterator_skip (&iterator, info_size);
        -:  863:      }
    #####:  864:    } while (current_p > data_p);
        -:  865:  }
        -:  866:
    #####:  867:  parser_free (data_p, fields_size);
    #####:  868:} /* parser_reverse_class_fields */
        -:  869:
        -:  870:#endif /* JERRY_ESNEXT */
        -:  871:
        -:  872:/**
        -:  873: * @}
        -:  874: * @}
        -:  875: * @}
        -:  876: */
        -:  877:
        -:  878:#endif /* JERRY_PARSER */
