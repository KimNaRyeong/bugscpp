        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "vm.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtin-object.h"
        -:   23:#include "ecma-builtins.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-errors.h"
        -:   27:#include "ecma-exceptions.h"
        -:   28:#include "ecma-function-object.h"
        -:   29:#include "ecma-gc.h"
        -:   30:#include "ecma-helpers.h"
        -:   31:#include "ecma-iterator-object.h"
        -:   32:#include "ecma-lcache.h"
        -:   33:#include "ecma-lex-env.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-objects.h"
        -:   36:#include "ecma-promise-object.h"
        -:   37:#include "ecma-regexp-object.h"
        -:   38:
        -:   39:#include "common.h"
        -:   40:#include "jcontext.h"
        -:   41:#include "opcodes.h"
        -:   42:#include "vm-stack.h"
        -:   43:
        -:   44:/** \addtogroup vm Virtual machine
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup vm_executor Executor
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((sizeof (vm_frame_ctx_t) % sizeof (ecma_value_t)) == 0,
        -:   52:                     sizeof_vm_frame_ctx_must_be_sizeof_ecma_value_t_aligned);
        -:   53:
        -:   54:/**
        -:   55: * Get the value of object[property].
        -:   56: *
        -:   57: * @return ecma value
        -:   58: */
        -:   59:static ecma_value_t
        2:   60:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   61:                 ecma_value_t property) /**< property name */
        -:   62:{
        2:   63:  if (ecma_is_value_object (object))
        -:   64:  {
        2:   65:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        2:   66:    ecma_string_t *property_name_p = NULL;
        -:   67:
        2:   68:    if (ecma_is_value_integer_number (property))
        -:   69:    {
    #####:   70:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   71:
    #####:   72:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   73:      {
    #####:   74:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   75:        {
    #####:   76:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   77:
    #####:   78:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   79:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   80:          {
    #####:   81:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   82:
    #####:   83:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   84:            {
    #####:   85:              return ecma_fast_copy_value (values_p[int_value]);
        -:   86:            }
        -:   87:          }
        -:   88:        }
        -:   89:
    #####:   90:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) int_value);
        -:   91:      }
        -:   92:    }
        2:   93:    else if (ecma_is_value_string (property))
        -:   94:    {
        2:   95:      property_name_p = ecma_get_string_from_value (property);
        -:   96:    }
        -:   97:
        -:   98:#if JERRY_ESNEXT
        2:   99:    if (ecma_is_value_symbol (property))
        -:  100:    {
    #####:  101:      property_name_p = ecma_get_symbol_from_value (property);
        -:  102:    }
        -:  103:#endif /* JERRY_ESNEXT */
        -:  104:
        2:  105:    if (property_name_p != NULL)
        -:  106:    {
        -:  107:#if JERRY_LCACHE
        2:  108:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  109:
        2:  110:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  111:      {
    #####:  112:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  113:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  114:      }
        -:  115:#endif /* JERRY_LCACHE */
        -:  116:
        -:  117:      /* There is no need to free the name. */
        2:  118:      return ecma_op_object_get (object_p, property_name_p);
        -:  119:    }
        -:  120:  }
        -:  121:
    #####:  122:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  123:  {
        -:  124:#if JERRY_ERROR_MESSAGES
    #####:  125:    ecma_value_t error_value =
        -:  126:      ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot read property '%' of %", property, object);
        -:  127:#else /* !JERRY_ERROR_MESSAGES */
        -:  128:    ecma_value_t error_value = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  129:#endif /* JERRY_ERROR_MESSAGES */
    #####:  130:    return error_value;
        -:  131:  }
        -:  132:
    #####:  133:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  134:
    #####:  135:  if (property_name_p == NULL)
        -:  136:  {
    #####:  137:    return ECMA_VALUE_ERROR;
        -:  138:  }
        -:  139:
    #####:  140:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  141:
    #####:  142:  ecma_deref_ecma_string (property_name_p);
    #####:  143:  return get_value_result;
        -:  144:} /* vm_op_get_value */
        -:  145:
        -:  146:/**
        -:  147: * Set the value of object[property].
        -:  148: *
        -:  149: * Note:
        -:  150: *  this function frees its object and property arguments
        -:  151: *
        -:  152: * @return an ecma value which contains an error
        -:  153: *         if the property setting is unsuccessful
        -:  154: */
        -:  155:static ecma_value_t
    #####:  156:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  157:                 ecma_value_t property, /**< property name */
        -:  158:                 ecma_value_t value, /**< ecma value */
        -:  159:                 bool is_strict) /**< strict mode */
        -:  160:{
    #####:  161:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  162:  ecma_object_t *object_p;
        -:  163:  ecma_string_t *property_p;
        -:  164:
    #####:  165:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  166:  {
    #####:  167:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  168:    {
        -:  169:#if JERRY_ERROR_MESSAGES
    #####:  170:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot set property '%' of %", property, base);
        -:  171:#else /* !JERRY_ERROR_MESSAGES */
        -:  172:      result = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  173:#endif /* JERRY_ERROR_MESSAGES */
    #####:  174:      ecma_free_value (property);
    #####:  175:      return result;
        -:  176:    }
        -:  177:
    #####:  178:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  179:    {
    #####:  180:      property_p = ecma_op_to_string (property);
    #####:  181:      ecma_fast_free_value (property);
        -:  182:
    #####:  183:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  184:      {
    #####:  185:        ecma_free_value (base);
    #####:  186:        return ECMA_VALUE_ERROR;
        -:  187:      }
        -:  188:    }
        -:  189:    else
        -:  190:    {
    #####:  191:      property_p = ecma_get_prop_name_from_value (property);
        -:  192:    }
        -:  193:
    #####:  194:    ecma_value_t object = ecma_op_to_object (base);
    #####:  195:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  196:
    #####:  197:    object_p = ecma_get_object_from_value (object);
    #####:  198:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  199:
    #####:  200:    result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  201:
    #####:  202:    ecma_free_value (base);
        -:  203:  }
        -:  204:  else
        -:  205:  {
    #####:  206:    object_p = ecma_get_object_from_value (base);
        -:  207:
    #####:  208:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  209:    {
    #####:  210:      property_p = ecma_op_to_string (property);
    #####:  211:      ecma_fast_free_value (property);
        -:  212:
    #####:  213:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  214:      {
    #####:  215:        ecma_deref_object (object_p);
    #####:  216:        return ECMA_VALUE_ERROR;
        -:  217:      }
        -:  218:    }
        -:  219:    else
        -:  220:    {
    #####:  221:      property_p = ecma_get_prop_name_from_value (property);
        -:  222:    }
        -:  223:
    #####:  224:    if (!ecma_is_lexical_environment (object_p))
        -:  225:    {
    #####:  226:      result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  227:    }
        -:  228:    else
        -:  229:    {
    #####:  230:      result = ecma_op_set_mutable_binding (object_p, property_p, value, is_strict);
        -:  231:    }
        -:  232:  }
        -:  233:
    #####:  234:  ecma_deref_object (object_p);
    #####:  235:  ecma_deref_ecma_string (property_p);
    #####:  236:  return result;
        -:  237:} /* vm_op_set_value */
        -:  238:
        -:  239:/** Compact bytecode define */
        -:  240:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  241:
        -:  242:/**
        -:  243: * Decode table for both opcodes and extended opcodes.
        -:  244: */
        -:  245:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA = { CBC_OPCODE_LIST CBC_EXT_OPCODE_LIST };
        -:  246:
        -:  247:#undef CBC_OPCODE
        -:  248:
        -:  249:/**
        -:  250: * Run global code
        -:  251: *
        -:  252: * Note:
        -:  253: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  254: *
        -:  255: * @return ecma value
        -:  256: */
        -:  257:ecma_value_t
        1:  258:vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  259:               ecma_object_t *function_object_p) /**< function object if available */
        -:  260:{
        -:  261:#if JERRY_BUILTIN_REALMS
        1:  262:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  263:#else /* !JERRY_BUILTIN_REALMS */
    #####:  264:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  265:#endif /* JERRY_BUILTIN_REALMS */
        -:  266:
        -:  267:#if JERRY_ESNEXT
        1:  268:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  269:  {
        1:  270:    ecma_create_global_lexical_block (global_obj_p);
        -:  271:  }
        -:  272:#endif /* JERRY_ESNEXT */
        -:  273:
        1:  274:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  275:
        1:  276:  vm_frame_ctx_shared_t shared;
        1:  277:  shared.bytecode_header_p = bytecode_p;
        1:  278:  shared.function_object_p = function_object_p;
        1:  279:  shared.status_flags = 0;
        -:  280:
        -:  281:#if JERRY_BUILTIN_REALMS
        1:  282:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  283:
        1:  284:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  285:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  286:#else /* !JERRY_BUILTIN_REALMS */
    #####:  287:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  288:#endif /* JERRY_BUILTIN_REALMS */
        -:  289:
        1:  290:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  291:
        -:  292:#if JERRY_BUILTIN_REALMS
    #####:  293:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  294:#endif /* JERRY_BUILTIN_REALMS */
        -:  295:
    #####:  296:  return result;
        -:  297:} /* vm_run_global */
        -:  298:
        -:  299:/**
        -:  300: * Run specified eval-mode bytecode
        -:  301: *
        -:  302: * @return ecma value
        -:  303: */
        -:  304:ecma_value_t
    #####:  305:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  306:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  307:{
        -:  308:  ecma_value_t this_binding;
        -:  309:  ecma_object_t *lex_env_p;
        -:  310:
        -:  311:  /* ECMA-262 v5, 10.4.2 */
    #####:  312:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  313:  {
    #####:  314:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  315:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  316:
        -:  317:#if JERRY_DEBUGGER
        -:  318:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  319:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  320:
        -:  321:    while (chain_index != 0)
        -:  322:    {
        -:  323:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  324:      {
        -:  325:        ecma_bytecode_deref (bytecode_data_p);
        -:  326:        ecma_free_value (this_binding);
        -:  327:        return ecma_raise_range_error (ECMA_ERR_INVALID_SCOPE_CHAIN_INDEX_FOR_EVAL);
        -:  328:      }
        -:  329:
        -:  330:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  331:
        -:  332:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  333:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  334:      {
        -:  335:        chain_index--;
        -:  336:      }
        -:  337:    }
        -:  338:#endif /* JERRY_DEBUGGER */
        -:  339:  }
        -:  340:  else
        -:  341:  {
        -:  342:#if JERRY_BUILTIN_REALMS
    #####:  343:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  344:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  345:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  346:#else /* !JERRY_BUILTIN_REALMS */
    #####:  347:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  348:    ecma_ref_object (global_obj_p);
    #####:  349:    this_binding = ecma_make_object_value (global_obj_p);
        -:  350:#endif /* JERRY_BUILTIN_REALMS */
    #####:  351:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  352:  }
        -:  353:
    #####:  354:  ecma_ref_object (lex_env_p);
        -:  355:
    #####:  356:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  357:  {
    #####:  358:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  359:
    #####:  360:    ecma_deref_object (lex_env_p);
    #####:  361:    lex_env_p = strict_lex_env_p;
        -:  362:  }
        -:  363:
    #####:  364:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  365:  {
    #####:  366:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  367:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  368:
    #####:  369:    ecma_deref_object (lex_env_p);
    #####:  370:    lex_env_p = lex_block_p;
        -:  371:  }
        -:  372:
    #####:  373:  vm_frame_ctx_shared_t shared;
    #####:  374:  shared.bytecode_header_p = bytecode_data_p;
    #####:  375:  shared.function_object_p = NULL;
    #####:  376:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  377:
    #####:  378:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  379:
    #####:  380:  ecma_deref_object (lex_env_p);
    #####:  381:  ecma_free_value (this_binding);
        -:  382:
        -:  383:#if JERRY_SNAPSHOT_EXEC
    #####:  384:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  385:  {
    #####:  386:    ecma_bytecode_deref (bytecode_data_p);
        -:  387:  }
        -:  388:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  389:  ecma_bytecode_deref (bytecode_data_p);
        -:  390:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  391:
    #####:  392:  return completion_value;
        -:  393:} /* vm_run_eval */
        -:  394:
        -:  395:#if JERRY_MODULE_SYSTEM
        -:  396:
        -:  397:/**
        -:  398: * Run module code
        -:  399: *
        -:  400: * Note:
        -:  401: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  402: *
        -:  403: * @return ecma value
        -:  404: */
        -:  405:ecma_value_t
    #####:  406:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  407:{
    #####:  408:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  409:
    #####:  410:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  411:  {
    #####:  412:    return module_init_result;
        -:  413:  }
        -:  414:
    #####:  415:  vm_frame_ctx_shared_t shared;
    #####:  416:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  417:  shared.function_object_p = &module_p->header.object;
    #####:  418:  shared.status_flags = 0;
        -:  419:
    #####:  420:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  421:} /* vm_run_module */
        -:  422:
        -:  423:#endif /* JERRY_MODULE_SYSTEM */
        -:  424:
        -:  425:/**
        -:  426: * Construct object
        -:  427: *
        -:  428: * @return object value
        -:  429: */
        -:  430:static ecma_value_t
    #####:  431:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  432:                             ecma_value_t lit_value) /**< literal */
        -:  433:{
        -:  434:  ecma_compiled_code_t *bytecode_p;
        -:  435:
        -:  436:#if JERRY_SNAPSHOT_EXEC
    #####:  437:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  438:  {
        -:  439:#endif /* JERRY_SNAPSHOT_EXEC */
    #####:  440:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, lit_value);
        -:  441:#if JERRY_SNAPSHOT_EXEC
        -:  442:  }
        -:  443:  else
        -:  444:  {
    #####:  445:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  446:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  447:  }
        -:  448:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  449:
        -:  450:#if JERRY_BUILTIN_REGEXP
    #####:  451:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  452:  {
    #####:  453:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  454:
    #####:  455:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  456:    {
    #####:  457:      return ECMA_VALUE_ERROR;
        -:  458:    }
        -:  459:
    #####:  460:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  461:  }
        -:  462:#else /* !JERRY_BUILTIN_REGEXP */
        -:  463:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  464:#endif /* JERRY_BUILTIN_REGEXP */
        -:  465:
        -:  466:  ecma_object_t *func_obj_p;
        -:  467:
        -:  468:#if JERRY_ESNEXT
    #####:  469:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  470:  {
    #####:  471:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p, bytecode_p, frame_ctx_p->this_binding);
        -:  472:  }
        -:  473:  else
        -:  474:  {
    #####:  475:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  476:  }
        -:  477:#else /* !JERRY_ESNEXT */
    #####:  478:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  479:#endif /* JERRY_ESNEXT */
        -:  480:
    #####:  481:  return ecma_make_object_value (func_obj_p);
        -:  482:} /* vm_construct_literal_object */
        -:  483:
        -:  484:/**
        -:  485: * Get implicit this value
        -:  486: *
        -:  487: * @return true - if the implicit 'this' value is updated,
        -:  488: *         false - otherwise
        -:  489: */
        -:  490:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  491:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  492:{
    #####:  493:  if (ecma_is_value_object (*this_value_p))
        -:  494:  {
    #####:  495:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  496:
    #####:  497:    if (ecma_is_lexical_environment (this_obj_p))
        -:  498:    {
    #####:  499:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  500:
    #####:  501:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  502:
    #####:  503:      *this_value_p = completion_value;
    #####:  504:      return true;
        -:  505:    }
        -:  506:  }
    #####:  507:  return false;
        -:  508:} /* vm_get_implicit_this_value */
        -:  509:
        -:  510:/**
        -:  511: * Special bytecode sequence for error handling while the vm_loop
        -:  512: * is preserved for an execute operation
        -:  513: */
        -:  514:static const uint8_t vm_error_byte_code_p[] = { CBC_EXT_OPCODE, CBC_EXT_ERROR };
        -:  515:
        -:  516:#if JERRY_ESNEXT
        -:  517:
        -:  518:static ecma_object_t *
    #####:  519:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  520:{
    #####:  521:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  522:
    #####:  523:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  524:  {
    #####:  525:    return frame_ctx_p->shared_p->function_object_p;
        -:  526:  }
        -:  527:
    #####:  528:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  529:
    #####:  530:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  531:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  532:} /* vm_get_class_function */
        -:  533:
        -:  534:/**
        -:  535: * 'super(...)' function call handler.
        -:  536: */
        -:  537:static void
    #####:  538:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  539:{
    #####:  540:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  541:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  542:
    #####:  543:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  544:  uint8_t opcode = byte_code_p[-2];
        -:  545:  uint32_t arguments_list_len;
        -:  546:
    #####:  547:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  548:
    #####:  549:  ecma_collection_t *collection_p = NULL;
        -:  550:  ecma_value_t *arguments_p;
        -:  551:
    #####:  552:  if (spread_arguments)
        -:  553:  {
    #####:  554:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  555:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  556:    arguments_p = collection_p->buffer_p;
    #####:  557:    arguments_list_len = collection_p->item_count;
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    arguments_list_len = byte_code_p[-1];
    #####:  562:    arguments_p = frame_ctx_p->stack_top_p;
        -:  563:  }
        -:  564:
    #####:  565:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  566:  ecma_value_t completion_value;
        -:  567:
    #####:  568:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  569:
    #####:  570:  if (!ecma_is_constructor (func_value))
        -:  571:  {
    #####:  572:    completion_value = ecma_raise_type_error (ECMA_ERR_VALUE_FOR_CLASS_HERITAGE_IS_NOT_A_CONSTRUCTOR);
        -:  573:  }
        -:  574:  else
        -:  575:  {
    #####:  576:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  577:    completion_value =
    #####:  578:      ecma_op_function_construct (func_obj_p, JERRY_CONTEXT (current_new_target_p), arguments_p, arguments_list_len);
        -:  579:
    #####:  580:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  581:    {
    #####:  582:      ecma_free_value (completion_value);
    #####:  583:      completion_value = ecma_raise_reference_error (ECMA_ERR_SUPER_CONSTRUCTOR_MAY_ONLY_BE_CALLED_ONCE);
        -:  584:    }
        -:  585:  }
        -:  586:
        -:  587:  /* Free registers. */
    #####:  588:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  589:  {
    #####:  590:    ecma_fast_free_value (arguments_p[i]);
        -:  591:  }
        -:  592:
    #####:  593:  if (collection_p != NULL)
        -:  594:  {
    #####:  595:    ecma_collection_destroy (collection_p);
        -:  596:  }
        -:  597:
    #####:  598:  if (ecma_is_value_object (completion_value))
        -:  599:  {
    #####:  600:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  601:    frame_ctx_p->this_binding = completion_value;
        -:  602:
    #####:  603:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  604:
    #####:  605:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  606:    {
    #####:  607:      ecma_free_value (completion_value);
    #####:  608:      completion_value = ECMA_VALUE_ERROR;
        -:  609:    }
        -:  610:  }
        -:  611:
    #####:  612:  ecma_free_value (func_value);
        -:  613:
    #####:  614:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  615:  {
        -:  616:#if JERRY_DEBUGGER
        -:  617:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  618:#endif /* JERRY_DEBUGGER */
    #####:  619:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  620:  }
        -:  621:  else
        -:  622:  {
    #####:  623:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  624:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  625:
    #####:  626:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  627:    {
    #####:  628:      ecma_fast_free_value (completion_value);
        -:  629:    }
    #####:  630:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  631:    {
    #####:  632:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  633:    }
        -:  634:    else
        -:  635:    {
    #####:  636:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  637:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  638:    }
        -:  639:  }
    #####:  640:} /* vm_super_call */
        -:  641:
        -:  642:/**
        -:  643: * Perform one of the following call/construct operation with spreaded argument list
        -:  644: *   - f(...args)
        -:  645: *   - o.f(...args)
        -:  646: *   - new O(...args)
        -:  647: */
        -:  648:static void
    #####:  649:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  650:{
    #####:  651:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  652:
    #####:  653:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  654:  ecma_value_t completion_value;
    #####:  655:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  656:
    #####:  657:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  658:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  659:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  660:
    #####:  661:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  662:  {
    #####:  663:    ecma_error_msg_t constructor_message_id = ecma_check_constructor (func_value);
    #####:  664:    if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  665:    {
    #####:  666:      completion_value = ecma_raise_type_error (constructor_message_id);
        -:  667:    }
        -:  668:    else
        -:  669:    {
    #####:  670:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  671:
    #####:  672:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  673:                                                     constructor_obj_p,
    #####:  674:                                                     collection_p->buffer_p,
        -:  675:                                                     collection_p->item_count);
        -:  676:    }
        -:  677:  }
        -:  678:  else
        -:  679:  {
    #####:  680:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  681:
    #####:  682:    if (!ecma_is_value_object (func_value) || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  683:    {
    #####:  684:      completion_value = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);
        -:  685:    }
        -:  686:    else
        -:  687:    {
    #####:  688:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  689:
    #####:  690:      completion_value =
    #####:  691:        ecma_op_function_call (func_obj_p, this_value, collection_p->buffer_p, collection_p->item_count);
        -:  692:    }
        -:  693:
    #####:  694:    if (is_call_prop)
        -:  695:    {
    #####:  696:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  697:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  698:    }
        -:  699:  }
        -:  700:
    #####:  701:  ecma_collection_free (collection_p);
    #####:  702:  ecma_free_value (func_value);
        -:  703:
    #####:  704:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  705:  {
        -:  706:#if JERRY_DEBUGGER
        -:  707:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  708:#endif /* JERRY_DEBUGGER */
    #####:  709:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  710:  }
        -:  711:  else
        -:  712:  {
    #####:  713:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  714:
    #####:  715:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  716:    {
    #####:  717:      ecma_fast_free_value (completion_value);
        -:  718:    }
    #####:  719:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  720:    {
    #####:  721:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  722:    }
        -:  723:    else
        -:  724:    {
    #####:  725:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  726:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  727:    }
        -:  728:
        -:  729:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  730:    frame_ctx_p->byte_code_p += 3;
        -:  731:  }
    #####:  732:} /* vm_spread_operation */
        -:  733:#endif /* JERRY_ESNEXT */
        -:  734:
        -:  735:/**
        -:  736: * 'Function call' opcode handler.
        -:  737: *
        -:  738: * See also: ECMA-262 v5, 11.2.3
        -:  739: */
        -:  740:static void
        2:  741:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  742:{
        2:  743:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        2:  744:  uint8_t opcode = byte_code_p[-1];
        -:  745:  uint32_t arguments_list_len;
        -:  746:
        2:  747:  if (opcode >= CBC_CALL0)
        -:  748:  {
        1:  749:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  750:  }
        -:  751:  else
        -:  752:  {
        1:  753:    arguments_list_len = *byte_code_p++;
        -:  754:  }
        -:  755:
        2:  756:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  757:
        2:  758:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        2:  759:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
        2:  760:  ecma_value_t func_value = stack_top_p[-1];
        -:  761:
        2:  762:  ecma_value_t completion_value =
        -:  763:    ecma_op_function_validated_call (func_value, this_value, stack_top_p, arguments_list_len);
        -:  764:
        1:  765:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  766:
        -:  767:  /* Free registers. */
        4:  768:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  769:  {
        3:  770:    ecma_fast_free_value (stack_top_p[i]);
        -:  771:  }
        -:  772:
        1:  773:  if (is_call_prop)
        -:  774:  {
        1:  775:    ecma_free_value (*(--stack_top_p));
        1:  776:    ecma_free_value (*(--stack_top_p));
        -:  777:  }
        -:  778:
        1:  779:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  780:  {
        -:  781:#if JERRY_DEBUGGER
        -:  782:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  783:#endif /* JERRY_DEBUGGER */
    #####:  784:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  785:  }
        -:  786:  else
        -:  787:  {
        1:  788:    frame_ctx_p->byte_code_p = byte_code_p;
        1:  789:    ecma_free_value (*(--stack_top_p));
        1:  790:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  791:
        1:  792:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  793:    {
    #####:  794:      ecma_fast_free_value (completion_value);
        -:  795:    }
        1:  796:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  797:    {
    #####:  798:      *stack_top_p++ = completion_value;
        -:  799:    }
        -:  800:    else
        -:  801:    {
        1:  802:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
        1:  803:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  804:    }
        -:  805:  }
        -:  806:
        1:  807:  frame_ctx_p->stack_top_p = stack_top_p;
        1:  808:} /* opfunc_call */
        -:  809:
        -:  810:/**
        -:  811: * 'Constructor call' opcode handler.
        -:  812: *
        -:  813: * See also: ECMA-262 v5, 11.2.2
        -:  814: */
        -:  815:static void
        1:  816:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  817:{
        1:  818:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        1:  819:  uint8_t opcode = byte_code_p[-1];
        -:  820:  unsigned int arguments_list_len;
        -:  821:
        1:  822:  if (opcode >= CBC_NEW0)
        -:  823:  {
        1:  824:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  825:  }
        -:  826:  else
        -:  827:  {
    #####:  828:    arguments_list_len = *byte_code_p++;
        -:  829:  }
        -:  830:
        1:  831:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        1:  832:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  833:  ecma_value_t completion_value;
        -:  834:
        1:  835:  ecma_error_msg_t constructor_message_id = ecma_check_constructor (constructor_value);
        1:  836:  if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  837:  {
    #####:  838:    completion_value = ecma_raise_type_error (constructor_message_id);
        -:  839:  }
        -:  840:  else
        -:  841:  {
        1:  842:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  843:
        1:  844:    completion_value =
        -:  845:      ecma_op_function_construct (constructor_obj_p, constructor_obj_p, stack_top_p, arguments_list_len);
        -:  846:  }
        -:  847:
        -:  848:  /* Free registers. */
        2:  849:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  850:  {
        1:  851:    ecma_fast_free_value (stack_top_p[i]);
        -:  852:  }
        -:  853:
        1:  854:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  855:  {
        -:  856:#if JERRY_DEBUGGER
        -:  857:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  858:#endif /* JERRY_DEBUGGER */
    #####:  859:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  860:  }
        -:  861:  else
        -:  862:  {
        1:  863:    ecma_free_value (stack_top_p[-1]);
        1:  864:    frame_ctx_p->byte_code_p = byte_code_p;
        1:  865:    stack_top_p[-1] = completion_value;
        -:  866:  }
        -:  867:
        1:  868:  frame_ctx_p->stack_top_p = stack_top_p;
        1:  869:} /* opfunc_construct */
        -:  870:
        -:  871:/**
        -:  872: * Read literal index from the byte code stream into destination.
        -:  873: *
        -:  874: * @param destination destination
        -:  875: */
        -:  876:#define READ_LITERAL_INDEX(destination)                                                      \
        -:  877:  do                                                                                         \
        -:  878:  {                                                                                          \
        -:  879:    (destination) = *byte_code_p++;                                                          \
        -:  880:    if ((destination) >= encoding_limit)                                                     \
        -:  881:    {                                                                                        \
        -:  882:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  883:    }                                                                                        \
        -:  884:  } while (0)
        -:  885:
        -:  886:/**
        -:  887: * Get literal value by literal index.
        -:  888: *
        -:  889: * @param literal_index literal index
        -:  890: * @param target_value target value
        -:  891: *
        -:  892: * TODO: For performance reasons, we define this as a macro.
        -:  893: * When we are able to construct a function with similar speed,
        -:  894: * we can remove this macro.
        -:  895: */
        -:  896:#define READ_LITERAL(literal_index, target_value)                                                 \
        -:  897:  do                                                                                              \
        -:  898:  {                                                                                               \
        -:  899:    if ((literal_index) < ident_end)                                                              \
        -:  900:    {                                                                                             \
        -:  901:      if ((literal_index) < register_end)                                                         \
        -:  902:      {                                                                                           \
        -:  903:        /* Note: There should be no specialization for arguments. */                              \
        -:  904:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));     \
        -:  905:      }                                                                                           \
        -:  906:      else                                                                                        \
        -:  907:      {                                                                                           \
        -:  908:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);      \
        -:  909:                                                                                                  \
        -:  910:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, name_p);                \
        -:  911:                                                                                                  \
        -:  912:        if (ECMA_IS_VALUE_ERROR (result))                                                         \
        -:  913:        {                                                                                         \
        -:  914:          goto error;                                                                             \
        -:  915:        }                                                                                         \
        -:  916:        (target_value) = result;                                                                  \
        -:  917:      }                                                                                           \
        -:  918:    }                                                                                             \
        -:  919:    else if (literal_index < const_literal_end)                                                   \
        -:  920:    {                                                                                             \
        -:  921:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]);                     \
        -:  922:    }                                                                                             \
        -:  923:    else                                                                                          \
        -:  924:    {                                                                                             \
        -:  925:      /* Object construction. */                                                                  \
        -:  926:      (target_value) = vm_construct_literal_object (frame_ctx_p, literal_start_p[literal_index]); \
        -:  927:    }                                                                                             \
        -:  928:  } while (0)
        -:  929:
        -:  930:/**
        -:  931: * Store the original value for post increase/decrease operators
        -:  932: *
        -:  933: * @param value original value
        -:  934: */
        -:  935:#define POST_INCREASE_DECREASE_PUT_RESULT(value)                                                             \
        -:  936:  if (opcode_data & VM_OC_PUT_STACK)                                                                         \
        -:  937:  {                                                                                                          \
        -:  938:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)                                                  \
        -:  939:    {                                                                                                        \
        -:  940:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  941:      *stack_top_p++ = (value);                                                                              \
        -:  942:    }                                                                                                        \
        -:  943:    else                                                                                                     \
        -:  944:    {                                                                                                        \
        -:  945:      /* The parser ensures there is enough space for the                                                    \
        -:  946:       * extra value on the stack. See js-parser-expr.c. */                                                  \
        -:  947:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT || opcode == CBC_POST_DECR_PUSH_RESULT);             \
        -:  948:      stack_top_p++;                                                                                         \
        -:  949:      stack_top_p[-1] = stack_top_p[-2];                                                                     \
        -:  950:      stack_top_p[-2] = stack_top_p[-3];                                                                     \
        -:  951:      stack_top_p[-3] = (value);                                                                             \
        -:  952:    }                                                                                                        \
        -:  953:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;                                                              \
        -:  954:  }                                                                                                          \
        -:  955:  else                                                                                                       \
        -:  956:  {                                                                                                          \
        -:  957:    JERRY_ASSERT (opcode_data &VM_OC_PUT_BLOCK);                                                             \
        -:  958:    ecma_free_value (VM_GET_REGISTER (frame_ctx_p, 0));                                                      \
        -:  959:    VM_GET_REGISTERS (frame_ctx_p)[0] = (value);                                                             \
        -:  960:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;                                                              \
        -:  961:  }
        -:  962:
        -:  963:/**
        -:  964: * Get the end of the existing topmost context
        -:  965: */
        -:  966:#define VM_LAST_CONTEXT_END() (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -:  967:
        -:  968:/**
        -:  969: * Run generic byte code.
        -:  970: *
        -:  971: * @return ecma value
        -:  972: */
        -:  973:static ecma_value_t JERRY_ATTR_NOINLINE
        3:  974:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  975:{
        3:  976:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        3:  977:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
        3:  978:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -:  979:
        3:  980:  ecma_value_t *stack_top_p;
        -:  981:  uint16_t encoding_limit;
        -:  982:  uint16_t encoding_delta;
        -:  983:  uint16_t register_end;
        -:  984:  uint16_t ident_end;
        -:  985:  uint16_t const_literal_end;
        3:  986:  int32_t branch_offset = 0;
        3:  987:  uint8_t branch_offset_length = 0;
        3:  988:  ecma_value_t left_value;
        -:  989:  ecma_value_t right_value;
        3:  990:  ecma_value_t result = ECMA_VALUE_EMPTY;
        3:  991:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -:  992:
        -:  993:  /* Prepare for byte code execution. */
        3:  994:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  995:  {
        3:  996:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        3:  997:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  998:  }
        -:  999:  else
        -: 1000:  {
    #####: 1001:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1002:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1003:  }
        -: 1004:
        3: 1005:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1006:  {
    #####: 1007:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1008:    register_end = args_p->register_end;
    #####: 1009:    ident_end = args_p->ident_end;
    #####: 1010:    const_literal_end = args_p->const_literal_end;
        -: 1011:  }
        -: 1012:  else
        -: 1013:  {
        3: 1014:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
        3: 1015:    register_end = args_p->register_end;
        3: 1016:    ident_end = args_p->ident_end;
        3: 1017:    const_literal_end = args_p->const_literal_end;
        -: 1018:  }
        -: 1019:
        3: 1020:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1021:
        -: 1022:  /* Outer loop for exception handling. */
    #####: 1023:  while (true)
        -: 1024:  {
        -: 1025:    /* Internal loop for byte code execution. */
        -: 1026:    while (true)
       10: 1027:    {
       13: 1028:      const uint8_t *byte_code_start_p = byte_code_p;
       13: 1029:      uint8_t opcode = *byte_code_p++;
       13: 1030:      uint32_t opcode_data = opcode;
        -: 1031:
       13: 1032:      if (opcode == CBC_EXT_OPCODE)
        -: 1033:      {
    #####: 1034:        opcode = *byte_code_p++;
    #####: 1035:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1036:      }
        -: 1037:
       13: 1038:      opcode_data = vm_decode_table[opcode_data];
        -: 1039:
       13: 1040:      left_value = ECMA_VALUE_UNDEFINED;
       13: 1041:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1042:
       13: 1043:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1044:
       13: 1045:      if (operands >= VM_OC_GET_LITERAL)
        -: 1046:      {
        -: 1047:        uint16_t literal_index;
        5: 1048:        READ_LITERAL_INDEX (literal_index);
        5: 1049:        READ_LITERAL (literal_index, left_value);
        -: 1050:
        5: 1051:        if (operands != VM_OC_GET_LITERAL)
        -: 1052:        {
        2: 1053:          switch (operands)
        -: 1054:          {
        2: 1055:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1056:            {
        -: 1057:              uint16_t second_literal_index;
        2: 1058:              READ_LITERAL_INDEX (second_literal_index);
        2: 1059:              READ_LITERAL (second_literal_index, right_value);
        2: 1060:              break;
        -: 1061:            }
    #####: 1062:            case VM_OC_GET_STACK_LITERAL:
        -: 1063:            {
    #####: 1064:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1065:              right_value = left_value;
    #####: 1066:              left_value = *(--stack_top_p);
    #####: 1067:              break;
        -: 1068:            }
    #####: 1069:            default:
        -: 1070:            {
    #####: 1071:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1072:
    #####: 1073:              right_value = left_value;
    #####: 1074:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1075:              break;
        -: 1076:            }
        -: 1077:          }
        3: 1078:        }
        -: 1079:      }
        8: 1080:      else if (operands >= VM_OC_GET_STACK)
        -: 1081:      {
        1: 1082:        JERRY_ASSERT (operands == VM_OC_GET_STACK || operands == VM_OC_GET_STACK_STACK);
        -: 1083:
        1: 1084:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        1: 1085:        left_value = *(--stack_top_p);
        -: 1086:
        1: 1087:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1088:        {
    #####: 1089:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1090:          right_value = left_value;
    #####: 1091:          left_value = *(--stack_top_p);
        -: 1092:        }
        -: 1093:      }
        7: 1094:      else if (operands == VM_OC_GET_BRANCH)
        -: 1095:      {
    #####: 1096:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
    #####: 1097:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1098:
    #####: 1099:        branch_offset = *(byte_code_p++);
        -: 1100:
    #####: 1101:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1102:        {
    #####: 1103:          branch_offset <<= 8;
    #####: 1104:          branch_offset |= *(byte_code_p++);
        -: 1105:
    #####: 1106:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1107:          {
    #####: 1108:            branch_offset <<= 8;
    #####: 1109:            branch_offset |= *(byte_code_p++);
        -: 1110:          }
        -: 1111:        }
        -: 1112:
    #####: 1113:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1114:        {
        -: 1115:#if JERRY_VM_HALT
    #####: 1116:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1117:          {
    #####: 1118:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1119:
    #####: 1120:            if (ecma_is_value_undefined (result))
        -: 1121:            {
    #####: 1122:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1123:            }
        -: 1124:            else
        -: 1125:            {
    #####: 1126:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1127:
    #####: 1128:              if (ecma_is_value_exception (result))
        -: 1129:              {
    #####: 1130:                ecma_throw_exception (result);
        -: 1131:              }
        -: 1132:              else
        -: 1133:              {
    #####: 1134:                jcontext_raise_exception (result);
        -: 1135:              }
        -: 1136:
        -: 1137:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1138:              jcontext_set_abort_flag (true);
    #####: 1139:              result = ECMA_VALUE_ERROR;
    #####: 1140:              goto error;
        -: 1141:            }
        -: 1142:          }
        -: 1143:#endif /* JERRY_VM_HALT */
        -: 1144:
    #####: 1145:          branch_offset = -branch_offset;
        -: 1146:        }
        -: 1147:      }
        -: 1148:
       13: 1149:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1150:      {
    #####: 1151:        case VM_OC_POP:
        -: 1152:        {
    #####: 1153:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1154:          ecma_free_value (*(--stack_top_p));
    #####: 1155:          continue;
        -: 1156:        }
    #####: 1157:        case VM_OC_POP_BLOCK:
        -: 1158:        {
    #####: 1159:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 1160:          VM_GET_REGISTERS (frame_ctx_p)[0] = *(--stack_top_p);
    #####: 1161:          continue;
        -: 1162:        }
        2: 1163:        case VM_OC_PUSH:
        -: 1164:        {
        2: 1165:          *stack_top_p++ = left_value;
        2: 1166:          continue;
        -: 1167:        }
    #####: 1168:        case VM_OC_PUSH_TWO:
        -: 1169:        {
    #####: 1170:          *stack_top_p++ = left_value;
    #####: 1171:          *stack_top_p++ = right_value;
    #####: 1172:          continue;
        -: 1173:        }
    #####: 1174:        case VM_OC_PUSH_THREE:
        -: 1175:        {
        -: 1176:          uint16_t literal_index;
        -: 1177:
    #####: 1178:          *stack_top_p++ = left_value;
    #####: 1179:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1180:
    #####: 1181:          READ_LITERAL_INDEX (literal_index);
    #####: 1182:          READ_LITERAL (literal_index, left_value);
        -: 1183:
    #####: 1184:          *stack_top_p++ = right_value;
    #####: 1185:          *stack_top_p++ = left_value;
    #####: 1186:          continue;
        -: 1187:        }
    #####: 1188:        case VM_OC_PUSH_UNDEFINED:
        -: 1189:        {
    #####: 1190:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1191:          continue;
        -: 1192:        }
    #####: 1193:        case VM_OC_PUSH_TRUE:
        -: 1194:        {
    #####: 1195:          *stack_top_p++ = ECMA_VALUE_TRUE;
    #####: 1196:          continue;
        -: 1197:        }
    #####: 1198:        case VM_OC_PUSH_FALSE:
        -: 1199:        {
    #####: 1200:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1201:          continue;
        -: 1202:        }
    #####: 1203:        case VM_OC_PUSH_NULL:
        -: 1204:        {
    #####: 1205:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1206:          continue;
        -: 1207:        }
    #####: 1208:        case VM_OC_PUSH_THIS:
        -: 1209:        {
    #####: 1210:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1211:          continue;
        -: 1212:        }
        1: 1213:        case VM_OC_PUSH_0:
        -: 1214:        {
        1: 1215:          *stack_top_p++ = ecma_make_integer_value (0);
        1: 1216:          continue;
        -: 1217:        }
        1: 1218:        case VM_OC_PUSH_POS_BYTE:
        -: 1219:        {
        1: 1220:          ecma_integer_value_t number = *byte_code_p++;
        1: 1221:          *stack_top_p++ = ecma_make_integer_value (number + 1);
        1: 1222:          continue;
        -: 1223:        }
    #####: 1224:        case VM_OC_PUSH_NEG_BYTE:
        -: 1225:        {
    #####: 1226:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1227:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1228:          continue;
        -: 1229:        }
    #####: 1230:        case VM_OC_PUSH_LIT_0:
        -: 1231:        {
    #####: 1232:          stack_top_p[0] = left_value;
    #####: 1233:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1234:          stack_top_p += 2;
    #####: 1235:          continue;
        -: 1236:        }
        1: 1237:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1238:        {
        1: 1239:          ecma_integer_value_t number = *byte_code_p++;
        1: 1240:          stack_top_p[0] = left_value;
        1: 1241:          stack_top_p[1] = ecma_make_integer_value (number + 1);
        1: 1242:          stack_top_p += 2;
        1: 1243:          continue;
        -: 1244:        }
    #####: 1245:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1246:        {
    #####: 1247:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1248:          stack_top_p[0] = left_value;
    #####: 1249:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1250:          stack_top_p += 2;
    #####: 1251:          continue;
        -: 1252:        }
    #####: 1253:        case VM_OC_PUSH_OBJECT:
        -: 1254:        {
    #####: 1255:          ecma_object_t *obj_p =
    #####: 1256:            ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE), 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 1257:
    #####: 1258:          *stack_top_p++ = ecma_make_object_value (obj_p);
    #####: 1259:          continue;
        -: 1260:        }
    #####: 1261:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1262:        {
    #####: 1263:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1264:
    #####: 1265:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1266:
    #####: 1267:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1268:
    #####: 1269:          JERRY_ASSERT (frame_ctx_p->lex_env_p
        -: 1270:                        == ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1271:
    #####: 1272:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1273:
    #####: 1274:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1275:
    #####: 1276:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1277:
    #####: 1278:          ecma_free_value (right_value);
    #####: 1279:          ecma_deref_object (name_lex_env);
    #####: 1280:          *stack_top_p++ = left_value;
    #####: 1281:          continue;
        -: 1282:        }
        1: 1283:        case VM_OC_CREATE_BINDING:
        -: 1284:        {
        -: 1285:#if !JERRY_ESNEXT
        -: 1286:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1287:#endif /* !JERRY_ESNEXT */
        -: 1288:
        -: 1289:          uint32_t literal_index;
        -: 1290:
        1: 1291:          READ_LITERAL_INDEX (literal_index);
        -: 1292:
        1: 1293:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1294:
        1: 1295:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        1: 1296:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1297:
        1: 1298:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1299:
        -: 1300:#if JERRY_ESNEXT
        1: 1301:          if (opcode == CBC_CREATE_LET)
        -: 1302:          {
        1: 1303:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1304:          }
    #####: 1305:          else if (opcode == CBC_CREATE_CONST)
        -: 1306:          {
    #####: 1307:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1308:          }
        -: 1309:
        -: 1310:          ecma_property_value_t *property_value_p;
        1: 1311:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1312:
        1: 1313:          if (opcode != CBC_CREATE_VAR)
        -: 1314:          {
        1: 1315:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1316:          }
        -: 1317:#else /* !JERRY_ESNEXT */
    #####: 1318:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1319:#endif /* JERRY_ESNEXT */
        -: 1320:
        1: 1321:          continue;
        -: 1322:        }
    #####: 1323:        case VM_OC_VAR_EVAL:
        -: 1324:        {
        -: 1325:          uint32_t literal_index;
    #####: 1326:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1327:
    #####: 1328:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1329:          {
        -: 1330:            uint32_t value_index;
    #####: 1331:            READ_LITERAL_INDEX (value_index);
    #####: 1332:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1333:
    #####: 1334:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1335:          }
        -: 1336:
    #####: 1337:          READ_LITERAL_INDEX (literal_index);
    #####: 1338:          JERRY_ASSERT (literal_index >= register_end);
        -: 1339:
    #####: 1340:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1341:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1342:
    #####: 1343:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1344:          {
        -: 1345:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1346:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1347:            {
    #####: 1348:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1349:
    #####: 1350:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1351:            }
        -: 1352:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1353:
    #####: 1354:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1355:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1356:          }
        -: 1357:
        -: 1358:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1359:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1360:          {
    #####: 1361:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1362:
    #####: 1363:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1364:          }
        -: 1365:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1366:
        -: 1367:          /* 'Variable declaration' */
    #####: 1368:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1369:
        -: 1370:#if JERRY_BUILTIN_PROXY
    #####: 1371:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1372:          {
    #####: 1373:            goto error;
        -: 1374:          }
        -: 1375:#endif /* JERRY_BUILTIN_PROXY */
        -: 1376:
    #####: 1377:          ecma_property_t *prop_p = NULL;
        -: 1378:
    #####: 1379:          if (ecma_is_value_false (result))
        -: 1380:          {
    #####: 1381:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
    #####: 1382:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1383:
    #####: 1384:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1385:            {
    #####: 1386:              result = ECMA_VALUE_ERROR;
    #####: 1387:              goto error;
        -: 1388:            }
        -: 1389:          }
        -: 1390:
    #####: 1391:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1392:          {
    #####: 1393:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1394:
    #####: 1395:            if (prop_p != NULL)
        -: 1396:            {
    #####: 1397:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1398:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1399:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1400:              ecma_free_object (lit_value);
        -: 1401:            }
        -: 1402:            else
        -: 1403:            {
    #####: 1404:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
    #####: 1405:              ecma_free_object (lit_value);
        -: 1406:
    #####: 1407:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1408:              {
    #####: 1409:                goto error;
        -: 1410:              }
        -: 1411:            }
        -: 1412:          }
    #####: 1413:          continue;
        -: 1414:        }
        -: 1415:#if JERRY_ESNEXT
    #####: 1416:        case VM_OC_EXT_VAR_EVAL:
        -: 1417:        {
        -: 1418:          uint32_t literal_index;
    #####: 1419:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1420:
    #####: 1421:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1422:
    #####: 1423:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1424:          {
        -: 1425:            uint32_t value_index;
    #####: 1426:            READ_LITERAL_INDEX (value_index);
    #####: 1427:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1428:
    #####: 1429:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1430:          }
        -: 1431:
    #####: 1432:          READ_LITERAL_INDEX (literal_index);
    #####: 1433:          JERRY_ASSERT (literal_index >= register_end);
        -: 1434:
    #####: 1435:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1436:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1437:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1438:
    #####: 1439:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1440:          {
        -: 1441:#if !(defined JERRY_NDEBUG)
    #####: 1442:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1443:            {
    #####: 1444:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1445:
    #####: 1446:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1447:            }
        -: 1448:#endif /* !JERRY_NDEBUG */
        -: 1449:
    #####: 1450:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1451:            prev_lex_env_p = lex_env_p;
    #####: 1452:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1453:          }
        -: 1454:
    #####: 1455:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1456:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1457:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1458:
    #####: 1459:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1460:          ecma_property_value_t *property_value_p;
        -: 1461:
    #####: 1462:          if (property_p == NULL)
        -: 1463:          {
    #####: 1464:            property_value_p =
        -: 1465:              ecma_create_named_data_property (prev_lex_env_p, name_p, ECMA_PROPERTY_CONFIGURABLE_WRITABLE, NULL);
        -: 1466:
    #####: 1467:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1468:            {
    #####: 1469:              continue;
        -: 1470:            }
        -: 1471:          }
        -: 1472:          else
        -: 1473:          {
    #####: 1474:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1475:            {
    #####: 1476:              continue;
        -: 1477:            }
        -: 1478:
    #####: 1479:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1480:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1481:          }
        -: 1482:
    #####: 1483:          property_value_p->value = lit_value;
    #####: 1484:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1485:          continue;
        -: 1486:        }
        -: 1487:#endif /* JERRY_ESNEXT */
    #####: 1488:        case VM_OC_CREATE_ARGUMENTS:
        -: 1489:        {
        -: 1490:          uint32_t literal_index;
    #####: 1491:          READ_LITERAL_INDEX (literal_index);
        -: 1492:
    #####: 1493:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1494:
    #####: 1495:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1496:                                                    frame_ctx_p->lex_env_p);
        -: 1497:
    #####: 1498:          if (literal_index < register_end)
        -: 1499:          {
    #####: 1500:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1501:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1502:            continue;
        -: 1503:          }
        -: 1504:
    #####: 1505:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1506:
    #####: 1507:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1508:
    #####: 1509:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1510:          ecma_property_value_t *property_value_p;
        -: 1511:
    #####: 1512:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1513:          property_value_p->value = result;
        -: 1514:
    #####: 1515:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1516:          continue;
        -: 1517:        }
        -: 1518:#if JERRY_SNAPSHOT_EXEC
    #####: 1519:        case VM_OC_SET_BYTECODE_PTR:
        -: 1520:        {
    #####: 1521:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1522:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1523:          continue;
        -: 1524:        }
        -: 1525:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 1526:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1527:        {
        -: 1528:          uint32_t literal_index, value_index;
        -: 1529:          ecma_value_t lit_value;
    #####: 1530:          bool release = false;
        -: 1531:
    #####: 1532:          READ_LITERAL_INDEX (value_index);
        -: 1533:
    #####: 1534:          if (value_index < register_end)
        -: 1535:          {
        -: 1536:            /* Take (not copy) the reference. */
    #####: 1537:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1538:          }
        -: 1539:          else
        -: 1540:          {
    #####: 1541:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
    #####: 1542:            release = true;
        -: 1543:          }
        -: 1544:
    #####: 1545:          READ_LITERAL_INDEX (literal_index);
        -: 1546:
    #####: 1547:          JERRY_ASSERT (value_index != literal_index);
    #####: 1548:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1549:
    #####: 1550:          if (literal_index < register_end)
        -: 1551:          {
    #####: 1552:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1553:            JERRY_ASSERT (release);
    #####: 1554:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1555:            continue;
        -: 1556:          }
        -: 1557:
    #####: 1558:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1559:
    #####: 1560:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1561:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1562:
        -: 1563:          ecma_property_value_t *property_value_p;
    #####: 1564:          property_value_p =
    #####: 1565:            ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1566:
    #####: 1567:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 1568:          property_value_p->value = lit_value;
        -: 1569:
    #####: 1570:          if (release)
        -: 1571:          {
    #####: 1572:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1573:          }
    #####: 1574:          continue;
        -: 1575:        }
        -: 1576:#if JERRY_ESNEXT
    #####: 1577:        case VM_OC_CHECK_VAR:
        -: 1578:        {
    #####: 1579:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1580:                        == CBC_FUNCTION_SCRIPT);
        -: 1581:
        -: 1582:          uint32_t literal_index;
    #####: 1583:          READ_LITERAL_INDEX (literal_index);
        -: 1584:
    #####: 1585:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1586:          {
    #####: 1587:            continue;
        -: 1588:          }
        -: 1589:
    #####: 1590:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1591:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1592:
    #####: 1593:          if (binding_p != NULL)
        -: 1594:          {
    #####: 1595:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1596:            goto error;
        -: 1597:          }
        -: 1598:
    #####: 1599:          continue;
        -: 1600:        }
        1: 1601:        case VM_OC_CHECK_LET:
        -: 1602:        {
        1: 1603:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1604:                        == CBC_FUNCTION_SCRIPT);
        -: 1605:
        -: 1606:          uint32_t literal_index;
        1: 1607:          READ_LITERAL_INDEX (literal_index);
        -: 1608:
        1: 1609:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1610:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1611:
        1: 1612:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1613:          {
        1: 1614:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1615:
        1: 1616:            if (!ecma_is_value_false (result))
        -: 1617:            {
    #####: 1618:              if (ecma_is_value_true (result))
        -: 1619:              {
    #####: 1620:                result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
        -: 1621:              }
        -: 1622:
    #####: 1623:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1624:              goto error;
        -: 1625:            }
        -: 1626:
        1: 1627:            continue;
        -: 1628:          }
        -: 1629:
    #####: 1630:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1631:
        -: 1632:#if JERRY_BUILTIN_PROXY
    #####: 1633:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1634:          {
    #####: 1635:            goto error;
        -: 1636:          }
        -: 1637:#endif /* JERRY_BUILTIN_PROXY */
        -: 1638:
    #####: 1639:          if (ecma_is_value_true (result))
        -: 1640:          {
    #####: 1641:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1642:            goto error;
        -: 1643:          }
        -: 1644:
    #####: 1645:          continue;
        -: 1646:        }
        1: 1647:        case VM_OC_ASSIGN_LET_CONST:
        -: 1648:        {
        -: 1649:          uint32_t literal_index;
        1: 1650:          READ_LITERAL_INDEX (literal_index);
        -: 1651:
        1: 1652:          JERRY_ASSERT (literal_index >= register_end);
        1: 1653:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1654:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1655:                            && ECMA_LEX_ENV_CLASS_IS_MODULE (frame_ctx_p->lex_env_p)));
        -: 1656:
        1: 1657:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1658:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1659:
        1: 1660:          JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1661:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
        1: 1662:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1663:
        1: 1664:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1665:
        1: 1666:          if (ecma_is_value_object (left_value))
        -: 1667:          {
        1: 1668:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1669:          }
        1: 1670:          continue;
        -: 1671:        }
    #####: 1672:        case VM_OC_INIT_BINDING:
        -: 1673:        {
        -: 1674:          uint32_t literal_index;
        -: 1675:
    #####: 1676:          READ_LITERAL_INDEX (literal_index);
        -: 1677:
    #####: 1678:          JERRY_ASSERT (literal_index >= register_end);
        -: 1679:
    #####: 1680:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1681:
    #####: 1682:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1683:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1684:
    #####: 1685:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1686:
    #####: 1687:          if (opcode == CBC_INIT_LET)
        -: 1688:          {
    #####: 1689:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1690:          }
    #####: 1691:          else if (opcode == CBC_INIT_CONST)
        -: 1692:          {
    #####: 1693:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1694:          }
        -: 1695:
        -: 1696:          ecma_property_value_t *property_value_p;
    #####: 1697:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1698:
    #####: 1699:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1700:
    #####: 1701:          ecma_value_t value = *(--stack_top_p);
        -: 1702:
    #####: 1703:          property_value_p->value = value;
    #####: 1704:          ecma_deref_if_object (value);
    #####: 1705:          continue;
        -: 1706:        }
    #####: 1707:        case VM_OC_THROW_CONST_ERROR:
        -: 1708:        {
    #####: 1709:          result = ecma_raise_type_error (ECMA_ERR_CONSTANT_BINDINGS_CANNOT_BE_REASSIGNED);
    #####: 1710:          goto error;
        -: 1711:        }
    #####: 1712:        case VM_OC_COPY_TO_GLOBAL:
        -: 1713:        {
        -: 1714:          uint32_t literal_index;
    #####: 1715:          READ_LITERAL_INDEX (literal_index);
        -: 1716:
    #####: 1717:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1718:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1719:
    #####: 1720:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1721:          {
        -: 1722:#ifndef JERRY_NDEBUG
    #####: 1723:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1724:            {
    #####: 1725:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1726:
    #####: 1727:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1728:            }
        -: 1729:#endif /* !JERRY_NDEBUG */
        -: 1730:
    #####: 1731:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1732:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1733:          }
        -: 1734:
    #####: 1735:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1736:          {
    #####: 1737:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1738:            ecma_property_value_t *prop_value_p;
        -: 1739:
    #####: 1740:            if (property_p == NULL)
        -: 1741:            {
    #####: 1742:              prop_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1743:            }
        -: 1744:            else
        -: 1745:            {
        -: 1746:#ifndef JERRY_NDEBUG
    #####: 1747:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1748:#endif /* !JERRY_NDEBUG */
    #####: 1749:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1750:            }
        -: 1751:
    #####: 1752:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1753:          }
        -: 1754:          else
        -: 1755:          {
    #####: 1756:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1757:
    #####: 1758:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1759:            {
    #####: 1760:              goto error;
        -: 1761:            }
        -: 1762:          }
        -: 1763:
    #####: 1764:          goto free_left_value;
        -: 1765:        }
    #####: 1766:        case VM_OC_COPY_FROM_ARG:
        -: 1767:        {
        -: 1768:          uint32_t literal_index;
    #####: 1769:          READ_LITERAL_INDEX (literal_index);
    #####: 1770:          JERRY_ASSERT (literal_index >= register_end);
        -: 1771:
    #####: 1772:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1773:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1774:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1775:
    #####: 1776:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1777:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1778:          JERRY_ASSERT (arg_lex_env_p != NULL && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1779:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1780:
        -: 1781:          ecma_property_value_t *property_value_p;
    #####: 1782:          property_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1783:
    #####: 1784:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1785:          JERRY_ASSERT (property_p != NULL);
        -: 1786:
    #####: 1787:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1788:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1789:          continue;
        -: 1790:        }
    #####: 1791:        case VM_OC_CLONE_CONTEXT:
        -: 1792:        {
    #####: 1793:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1794:
    #####: 1795:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1796:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1797:          continue;
        -: 1798:        }
    #####: 1799:        case VM_OC_SET__PROTO__:
        -: 1800:        {
    #####: 1801:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1802:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1803:          {
    #####: 1804:            goto error;
        -: 1805:          }
    #####: 1806:          goto free_left_value;
        -: 1807:        }
    #####: 1808:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1809:        {
    #####: 1810:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1811:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1812:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1813:
    #####: 1814:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1815:          ecma_value_t value = stack_top_p[-1];
        -: 1816:
    #####: 1817:          if (!push_computed)
        -: 1818:          {
    #####: 1819:            stack_top_p++;
        -: 1820:          }
        -: 1821:
    #####: 1822:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1823:          stack_top_p[-4] = left_value;
        -: 1824:
    #####: 1825:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1826:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
    #####: 1827:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, class_object_p, class_object_p, initializer_func_p);
        -: 1828:
    #####: 1829:          if (!push_computed)
        -: 1830:          {
    #####: 1831:            continue;
        -: 1832:          }
        -: 1833:
    #####: 1834:          left_value = value;
        -: 1835:          /* FALLTHRU */
        -: 1836:        }
    #####: 1837:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1838:        {
    #####: 1839:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1840:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1841:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1842:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1843:
    #####: 1844:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1845:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1846:
    #####: 1847:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1848:          {
    #####: 1849:            goto error;
        -: 1850:          }
    #####: 1851:          goto free_left_value;
        -: 1852:        }
    #####: 1853:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1854:        {
    #####: 1855:          left_value = *(--stack_top_p);
        -: 1856:
    #####: 1857:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1858:          {
    #####: 1859:            continue;
        -: 1860:          }
        -: 1861:
    #####: 1862:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1863:
    #####: 1864:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1865:          {
    #####: 1866:            goto error;
        -: 1867:          }
        -: 1868:
    #####: 1869:          goto free_left_value;
        -: 1870:        }
    #####: 1871:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1872:        {
        -: 1873:          /* Swap values. */
    #####: 1874:          left_value ^= right_value;
    #####: 1875:          right_value ^= left_value;
    #####: 1876:          left_value ^= right_value;
        -: 1877:          /* FALLTHRU */
        -: 1878:        }
        -: 1879:#endif /* JERRY_ESNEXT */
    #####: 1880:        case VM_OC_SET_PROPERTY:
        -: 1881:        {
        -: 1882:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1883:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1884:
    #####: 1885:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1886:
    #####: 1887:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1888:
    #####: 1889:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1890:          {
    #####: 1891:            result = ECMA_VALUE_ERROR;
    #####: 1892:            goto error;
        -: 1893:          }
        -: 1894:
        -: 1895:#if JERRY_ESNEXT
    #####: 1896:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1897:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1898:          {
    #####: 1899:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1900:            goto error;
        -: 1901:          }
        -: 1902:
    #####: 1903:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1904:#else /* !JERRY_ESNEXT */
    #####: 1905:          const int index = -1;
        -: 1906:#endif /* JERRY_ESNEXT */
        -: 1907:
    #####: 1908:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1909:
    #####: 1910:          opfunc_set_data_property (object_p, prop_name_p, left_value);
    #####: 1911:          ecma_deref_ecma_string (prop_name_p);
        -: 1912:
    #####: 1913:          goto free_both_values;
        -: 1914:        }
    #####: 1915:        case VM_OC_SET_GETTER:
        -: 1916:        case VM_OC_SET_SETTER:
        -: 1917:        {
    #####: 1918:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1919:
    #####: 1920:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1921:
    #####: 1922:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1923:          {
    #####: 1924:            result = ECMA_VALUE_ERROR;
    #####: 1925:            goto error;
        -: 1926:          }
        -: 1927:
        -: 1928:#if JERRY_ESNEXT
    #####: 1929:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1930:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1931:          {
    #####: 1932:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1933:            goto error;
        -: 1934:          }
        -: 1935:
    #####: 1936:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1937:#else /* !JERRY_ESNEXT */
    #####: 1938:          const int index = -1;
        -: 1939:#endif /* JERRY_ESNEXT */
        -: 1940:
    #####: 1941:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
    #####: 1942:                               stack_top_p[index],
        -: 1943:                               prop_name_p,
        -: 1944:                               right_value);
        -: 1945:
    #####: 1946:          ecma_deref_ecma_string (prop_name_p);
        -: 1947:
    #####: 1948:          goto free_both_values;
        -: 1949:        }
    #####: 1950:        case VM_OC_PUSH_ARRAY:
        -: 1951:        {
        -: 1952:          /* Note: this operation cannot throw an exception */
    #####: 1953:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
    #####: 1954:          continue;
        -: 1955:        }
        -: 1956:#if JERRY_ESNEXT
    #####: 1957:        case VM_OC_LOCAL_EVAL:
        -: 1958:        {
    #####: 1959:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 1960:          uint8_t parse_opts = *byte_code_p++;
    #####: 1961:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 1962:          continue;
        -: 1963:        }
    #####: 1964:        case VM_OC_SUPER_CALL:
        -: 1965:        {
    #####: 1966:          uint8_t arguments_list_len = *byte_code_p++;
        -: 1967:
    #####: 1968:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 1969:          {
    #####: 1970:            stack_top_p -= arguments_list_len;
    #####: 1971:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 1972:
    #####: 1973:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 1974:            {
    #####: 1975:              result = ECMA_VALUE_ERROR;
    #####: 1976:              goto error;
        -: 1977:            }
        -: 1978:
    #####: 1979:            stack_top_p++;
    #####: 1980:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 1981:          }
        -: 1982:          else
        -: 1983:          {
    #####: 1984:            stack_top_p -= arguments_list_len;
        -: 1985:          }
        -: 1986:
    #####: 1987:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 1988:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 1989:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 1990:          return ECMA_VALUE_UNDEFINED;
        -: 1991:        }
    #####: 1992:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 1993:        {
        -: 1994:          uint16_t literal_index;
        -: 1995:
    #####: 1996:          READ_LITERAL_INDEX (literal_index);
    #####: 1997:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
    #####: 1998:          continue;
        -: 1999:        }
    #####: 2000:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2001:        {
    #####: 2002:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode, frame_ctx_p->shared_p->bytecode_header_p);
    #####: 2003:          continue;
        -: 2004:        }
    #####: 2005:        case VM_OC_DEFINE_FIELD:
        -: 2006:        {
    #####: 2007:          result = opfunc_define_field (frame_ctx_p->this_binding, right_value, left_value);
        -: 2008:
    #####: 2009:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2010:          {
    #####: 2011:            goto error;
        -: 2012:          }
        -: 2013:
    #####: 2014:          goto free_both_values;
        -: 2015:        }
    #####: 2016:        case VM_OC_ASSIGN_PRIVATE:
        -: 2017:        {
    #####: 2018:          result = opfunc_private_set (stack_top_p[-3], stack_top_p[-2], stack_top_p[-1]);
        -: 2019:
    #####: 2020:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2021:          {
    #####: 2022:            goto error;
        -: 2023:          }
        -: 2024:
    #####: 2025:          ecma_free_value (stack_top_p[-3]);
    #####: 2026:          ecma_free_value (stack_top_p[-2]);
    #####: 2027:          ecma_free_value (stack_top_p[-1]);
    #####: 2028:          stack_top_p -= 3;
        -: 2029:
    #####: 2030:          if (opcode_data & VM_OC_PUT_STACK)
        -: 2031:          {
    #####: 2032:            *stack_top_p++ = result;
        -: 2033:          }
    #####: 2034:          else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2035:          {
    #####: 2036:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 2037:            VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 2038:          }
        -: 2039:          else
        -: 2040:          {
    #####: 2041:            ecma_free_value (result);
        -: 2042:          }
        -: 2043:
    #####: 2044:          goto free_both_values;
        -: 2045:        }
    #####: 2046:        case VM_OC_PRIVATE_FIELD_ADD:
        -: 2047:        {
    #####: 2048:          result = opfunc_private_field_add (frame_ctx_p->this_binding, right_value, left_value);
        -: 2049:
    #####: 2050:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2051:          {
    #####: 2052:            goto error;
        -: 2053:          }
        -: 2054:
    #####: 2055:          goto free_both_values;
        -: 2056:        }
    #####: 2057:        case VM_OC_PRIVATE_PROP_GET:
        -: 2058:        {
    #####: 2059:          result = opfunc_private_get (left_value, right_value);
        -: 2060:
    #####: 2061:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2062:          {
    #####: 2063:            goto error;
        -: 2064:          }
        -: 2065:
    #####: 2066:          *stack_top_p++ = result;
    #####: 2067:          goto free_both_values;
        -: 2068:        }
    #####: 2069:        case VM_OC_PRIVATE_PROP_REFERENCE:
        -: 2070:        {
    #####: 2071:          result = opfunc_private_get (stack_top_p[-1], left_value);
        -: 2072:
    #####: 2073:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2074:          {
    #####: 2075:            goto error;
        -: 2076:          }
        -: 2077:
    #####: 2078:          *stack_top_p++ = left_value;
    #####: 2079:          *stack_top_p++ = result;
    #####: 2080:          continue;
        -: 2081:        }
    #####: 2082:        case VM_OC_PRIVATE_IN:
        -: 2083:        {
    #####: 2084:          result = opfunc_private_in (left_value, right_value);
        -: 2085:
    #####: 2086:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2087:          {
    #####: 2088:            goto error;
        -: 2089:          }
        -: 2090:
    #####: 2091:          *stack_top_p++ = result;
    #####: 2092:          goto free_both_values;
        -: 2093:        }
    #####: 2094:        case VM_OC_COLLECT_PRIVATE_PROPERTY:
        -: 2095:        {
    #####: 2096:          opfunc_collect_private_properties (stack_top_p[-2], left_value, right_value, opcode);
    #####: 2097:          continue;
        -: 2098:        }
    #####: 2099:        case VM_OC_INIT_CLASS:
        -: 2100:        {
    #####: 2101:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2102:
    #####: 2103:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2104:          {
    #####: 2105:            goto error;
        -: 2106:          }
    #####: 2107:          continue;
        -: 2108:        }
    #####: 2109:        case VM_OC_FINALIZE_CLASS:
        -: 2110:        {
    #####: 2111:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2112:
    #####: 2113:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2114:          {
        -: 2115:            uint16_t literal_index;
    #####: 2116:            READ_LITERAL_INDEX (literal_index);
    #####: 2117:            left_value = literal_start_p[literal_index];
        -: 2118:          }
        -: 2119:
    #####: 2120:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 2121:          continue;
        -: 2122:        }
    #####: 2123:        case VM_OC_SET_FIELD_INIT:
        -: 2124:        {
    #####: 2125:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2126:          ecma_object_t *proto_object_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####: 2127:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 2128:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
        -: 2129:
    #####: 2130:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, proto_object_p, class_object_p, initializer_func_p);
        -: 2131:
    #####: 2132:          ecma_property_value_t *property_value_p =
        -: 2133:            ecma_create_named_data_property (class_object_p, property_name_p, ECMA_PROPERTY_FIXED, NULL);
    #####: 2134:          property_value_p->value = left_value;
        -: 2135:
    #####: 2136:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2137:          ecma_property_t *property_p = ecma_find_named_property (class_object_p, property_name_p);
        -: 2138:
    #####: 2139:          if (property_p != NULL)
        -: 2140:          {
    #####: 2141:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2142:            ecma_value_t *compact_collection_p =
    #####: 2143:              ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
    #####: 2144:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2145:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2146:          }
        -: 2147:
    #####: 2148:          goto free_left_value;
        -: 2149:        }
    #####: 2150:        case VM_OC_RUN_FIELD_INIT:
        -: 2151:        {
    #####: 2152:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2153:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2154:
    #####: 2155:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2156:          {
    #####: 2157:            goto error;
        -: 2158:          }
    #####: 2159:          continue;
        -: 2160:        }
    #####: 2161:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2162:        {
    #####: 2163:          left_value = stack_top_p[-2];
    #####: 2164:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2165:          stack_top_p--;
        -: 2166:
    #####: 2167:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2168:
    #####: 2169:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2170:          {
    #####: 2171:            goto error;
        -: 2172:          }
    #####: 2173:          goto free_left_value;
        -: 2174:        }
    #####: 2175:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2176:        {
    #####: 2177:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2178:          stack_top_p[-2] = ecma_make_integer_value (next_index);
        -: 2179:
    #####: 2180:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2181:
    #####: 2182:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2183:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
    #####: 2184:          ecma_value_t prop_name = computed_class_fields_p[next_index];
        -: 2185:
    #####: 2186:          if (opcode == CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC)
        -: 2187:          {
    #####: 2188:            ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2189:
    #####: 2190:            JERRY_ASSERT (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) == NULL);
        -: 2191:            ecma_property_value_t *value_p;
    #####: 2192:            value_p = ecma_create_named_data_property (func_obj_p,
        -: 2193:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2194:                                                       ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2195:                                                       NULL);
        -: 2196:
    #####: 2197:            if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2198:            {
    #####: 2199:              ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2200:            }
        -: 2201:
    #####: 2202:            value_p->value = ecma_copy_value (prop_name);
        -: 2203:          }
        -: 2204:
    #####: 2205:          result = opfunc_define_field (frame_ctx_p->this_binding, prop_name, stack_top_p[-1]);
        -: 2206:
    #####: 2207:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2208:          {
    #####: 2209:            goto error;
        -: 2210:          }
        -: 2211:
    #####: 2212:          ecma_free_value (*(--stack_top_p));
    #####: 2213:          continue;
        -: 2214:        }
    #####: 2215:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2216:        {
    #####: 2217:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2218:
    #####: 2219:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2220:          {
    #####: 2221:            goto error;
        -: 2222:          }
        -: 2223:
    #####: 2224:          *stack_top_p++ = result;
    #####: 2225:          continue;
        -: 2226:        }
    #####: 2227:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2228:        {
    #####: 2229:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2230:
    #####: 2231:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2232:          {
    #####: 2233:            goto error;
        -: 2234:          }
        -: 2235:
    #####: 2236:          *stack_top_p++ = result;
    #####: 2237:          continue;
        -: 2238:        }
    #####: 2239:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2240:        {
    #####: 2241:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2242:          {
    #####: 2243:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2244:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2245:
    #####: 2246:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2247:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2248:            *stack_top_p++ = obj_value;
        -: 2249:          }
        -: 2250:          else
        -: 2251:          {
    #####: 2252:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2253:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2254:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2255:            stack_top_p--;
        -: 2256:          }
    #####: 2257:          continue;
        -: 2258:        }
    #####: 2259:        case VM_OC_SET_HOME_OBJECT:
        -: 2260:        {
    #####: 2261:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2262:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2263:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2264:          continue;
        -: 2265:        }
    #####: 2266:        case VM_OC_SUPER_REFERENCE:
        -: 2267:        {
    #####: 2268:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2269:
    #####: 2270:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2271:          {
    #####: 2272:            goto error;
        -: 2273:          }
        -: 2274:
    #####: 2275:          goto free_left_value;
        -: 2276:        }
    #####: 2277:        case VM_OC_SET_FUNCTION_NAME:
        -: 2278:        {
    #####: 2279:          char *prefix_p = NULL;
    #####: 2280:          lit_utf8_size_t prefix_size = 0;
        -: 2281:
    #####: 2282:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2283:          {
        -: 2284:            ecma_value_t prop_name_value;
        -: 2285:
    #####: 2286:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2287:            {
        -: 2288:              uint16_t literal_index;
    #####: 2289:              READ_LITERAL_INDEX (literal_index);
    #####: 2290:              prop_name_value = literal_start_p[literal_index];
        -: 2291:            }
        -: 2292:            else
        -: 2293:            {
    #####: 2294:              prop_name_value = stack_top_p[-2];
        -: 2295:            }
        -: 2296:
    #####: 2297:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2298:
    #####: 2299:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2300:            {
    #####: 2301:              result = ECMA_VALUE_ERROR;
    #####: 2302:              goto error;
        -: 2303:            }
        -: 2304:
    #####: 2305:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2306:
    #####: 2307:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2308:            {
    #####: 2309:              ecma_ref_ecma_string (prop_name_p);
    #####: 2310:              ecma_free_value (stack_top_p[-2]);
    #####: 2311:              stack_top_p[-2] = left_value;
        -: 2312:            }
        -: 2313:
    #####: 2314:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2315:            {
    #####: 2316:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2317:              prefix_size = 4;
        -: 2318:            }
        -: 2319:          }
        -: 2320:
    #####: 2321:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2322:
    #####: 2323:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2324:          {
    #####: 2325:            ecma_free_value (left_value);
    #####: 2326:            continue;
        -: 2327:          }
        -: 2328:
        -: 2329:          ecma_property_value_t *value_p;
    #####: 2330:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2331:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2332:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2333:                                                     NULL);
        -: 2334:
    #####: 2335:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2336:          {
    #####: 2337:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2338:          }
        -: 2339:
    #####: 2340:          value_p->value =
    #####: 2341:            ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value), prefix_p, prefix_size);
    #####: 2342:          ecma_free_value (left_value);
    #####: 2343:          continue;
        -: 2344:        }
    #####: 2345:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2346:        {
    #####: 2347:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2348:          continue;
        -: 2349:        }
    #####: 2350:        case VM_OC_PUSH_REST_OBJECT:
        -: 2351:        {
    #####: 2352:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2353:
    #####: 2354:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2355:
    #####: 2356:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2357:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2358:          uint16_t argument_end;
        -: 2359:
    #####: 2360:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2361:          {
    #####: 2362:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2363:          }
        -: 2364:          else
        -: 2365:          {
    #####: 2366:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2367:          }
        -: 2368:
    #####: 2369:          if (arg_list_len < argument_end)
        -: 2370:          {
    #####: 2371:            arg_list_len = argument_end;
        -: 2372:          }
        -: 2373:
    #####: 2374:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end, arg_list_len - argument_end);
        -: 2375:
    #####: 2376:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2377:          *stack_top_p++ = result;
    #####: 2378:          continue;
        -: 2379:        }
    #####: 2380:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2381:        {
    #####: 2382:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2383:
    #####: 2384:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2385:          {
    #####: 2386:            goto error;
        -: 2387:          }
        -: 2388:
    #####: 2389:          uint32_t context_size =
    #####: 2390:            (uint32_t) (stack_top_p + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION - VM_LAST_CONTEXT_END ());
    #####: 2391:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2392:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2393:
    #####: 2394:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2395:          stack_top_p[-2] = result;
    #####: 2396:          stack_top_p[-3] = left_value;
        -: 2397:
    #####: 2398:          continue;
        -: 2399:        }
    #####: 2400:        case VM_OC_ITERATOR_STEP:
        -: 2401:        {
    #####: 2402:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2403:
    #####: 2404:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2405:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2406:
    #####: 2407:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2408:
    #####: 2409:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2410:          {
    #####: 2411:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2412:            goto error;
        -: 2413:          }
        -: 2414:
    #####: 2415:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2416:
    #####: 2417:          if (!ecma_is_value_false (result))
        -: 2418:          {
    #####: 2419:            value = ecma_op_iterator_value (result);
    #####: 2420:            ecma_free_value (result);
        -: 2421:
    #####: 2422:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2423:            {
    #####: 2424:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2425:              result = value;
    #####: 2426:              goto error;
        -: 2427:            }
        -: 2428:          }
        -: 2429:          else
        -: 2430:          {
    #####: 2431:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2432:          }
        -: 2433:
    #####: 2434:          *stack_top_p++ = value;
    #####: 2435:          continue;
        -: 2436:        }
    #####: 2437:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2438:        {
    #####: 2439:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2440:
    #####: 2441:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2442:          {
    #####: 2443:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2444:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2445:
    #####: 2446:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2447:            {
    #####: 2448:              goto error;
        -: 2449:            }
        -: 2450:          }
        -: 2451:
    #####: 2452:          stack_top_p =
    #####: 2453:            vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2454:          continue;
        -: 2455:        }
    #####: 2456:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2457:        {
    #####: 2458:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2459:
    #####: 2460:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2461:          {
    #####: 2462:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2463:            continue;
        -: 2464:          }
        -: 2465:
    #####: 2466:          stack_top_p--;
    #####: 2467:          continue;
        -: 2468:        }
    #####: 2469:        case VM_OC_REST_INITIALIZER:
        -: 2470:        {
    #####: 2471:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2472:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2473:
    #####: 2474:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2475:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2476:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2477:          uint32_t index = 0;
        -: 2478:
        -: 2479:          while (true)
    #####: 2480:          {
    #####: 2481:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2482:
    #####: 2483:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2484:            {
    #####: 2485:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2486:              ecma_deref_object (array_p);
    #####: 2487:              goto error;
        -: 2488:            }
        -: 2489:
    #####: 2490:            if (ecma_is_value_false (result))
        -: 2491:            {
    #####: 2492:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2493:              break;
        -: 2494:            }
        -: 2495:
    #####: 2496:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2497:            ecma_free_value (result);
        -: 2498:
    #####: 2499:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2500:            {
    #####: 2501:              ecma_deref_object (array_p);
    #####: 2502:              result = value;
    #####: 2503:              goto error;
        -: 2504:            }
        -: 2505:
    #####: 2506:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2507:            JERRY_ASSERT (set_result);
    #####: 2508:            ecma_free_value (value);
        -: 2509:          }
        -: 2510:
    #####: 2511:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2512:          continue;
        -: 2513:        }
    #####: 2514:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2515:        {
    #####: 2516:          left_value = stack_top_p[-1];
    #####: 2517:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2518:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2519:
    #####: 2520:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2521:          {
    #####: 2522:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2523:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2524:          }
        -: 2525:
    #####: 2526:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2527:          stack_top_p += context_stack_allocation;
    #####: 2528:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2529:
    #####: 2530:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2531:          stack_top_p[-2] = left_value;
        -: 2532:
    #####: 2533:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2534:          {
    #####: 2535:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2536:          }
    #####: 2537:          continue;
        -: 2538:        }
    #####: 2539:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2540:        {
    #####: 2541:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2542:
    #####: 2543:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2544:
    #####: 2545:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2546:          {
    #####: 2547:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2548:          }
        -: 2549:
    #####: 2550:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, context_stack_allocation);
    #####: 2551:          continue;
        -: 2552:        }
    #####: 2553:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2554:        {
    #####: 2555:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2556:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2557:          {
    #####: 2558:            result = ECMA_VALUE_ERROR;
    #####: 2559:            goto error;
        -: 2560:          }
        -: 2561:
    #####: 2562:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2563:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2564:
    #####: 2565:          left_value = ecma_make_object_value (result_object_p);
    #####: 2566:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2567:
    #####: 2568:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2569:          {
    #####: 2570:            goto error;
        -: 2571:          }
        -: 2572:
    #####: 2573:          ecma_free_value (last_context_end_p[-3]);
    #####: 2574:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2575:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2576:
    #####: 2577:          *stack_top_p++ = left_value;
    #####: 2578:          continue;
        -: 2579:        }
    #####: 2580:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2581:        {
    #####: 2582:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2583:          {
    #####: 2584:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2585:
    #####: 2586:            if (property_key == NULL)
        -: 2587:            {
    #####: 2588:              result = ECMA_VALUE_ERROR;
    #####: 2589:              goto error;
        -: 2590:            }
        -: 2591:
    #####: 2592:            ecma_free_value (left_value);
    #####: 2593:            left_value = ecma_make_string_value (property_key);
        -: 2594:          }
        -: 2595:
    #####: 2596:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2597:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2598:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2599:
    #####: 2600:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2601:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2602:          /* FALLTHRU */
        -: 2603:        }
    #####: 2604:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2605:        {
    #####: 2606:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2607:          ecma_value_t base = last_context_end_p[-2];
        -: 2608:
    #####: 2609:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2610:          {
    #####: 2611:            left_value = *last_context_end_p++;
    #####: 2612:            while (last_context_end_p < stack_top_p)
        -: 2613:            {
    #####: 2614:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2615:              last_context_end_p++;
        -: 2616:            }
    #####: 2617:            stack_top_p--;
        -: 2618:          }
        -: 2619:
    #####: 2620:          result = vm_op_get_value (base, left_value);
        -: 2621:
    #####: 2622:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2623:          {
    #####: 2624:            goto error;
        -: 2625:          }
        -: 2626:
    #####: 2627:          *stack_top_p++ = result;
    #####: 2628:          goto free_left_value;
        -: 2629:        }
    #####: 2630:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2631:        {
    #####: 2632:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2633:          stack_top_p -= arguments_list_len;
        -: 2634:
    #####: 2635:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2636:
    #####: 2637:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2638:          {
    #####: 2639:            result = ECMA_VALUE_ERROR;
    #####: 2640:            goto error;
        -: 2641:          }
        -: 2642:
    #####: 2643:          stack_top_p++;
    #####: 2644:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2645:
    #####: 2646:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2647:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2648:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2649:          return ECMA_VALUE_UNDEFINED;
        -: 2650:        }
    #####: 2651:        case VM_OC_CREATE_GENERATOR:
        -: 2652:        {
    #####: 2653:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2654:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2655:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2656:
        -: 2657:          vm_executable_object_t *executable_object_p;
    #####: 2658:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2659:
    #####: 2660:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2661:        }
    #####: 2662:        case VM_OC_YIELD:
        -: 2663:        {
    #####: 2664:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2665:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2666:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2667:          return *stack_top_p;
        -: 2668:        }
    #####: 2669:        case VM_OC_ASYNC_YIELD:
        -: 2670:        {
    #####: 2671:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2672:
    #####: 2673:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2674:
    #####: 2675:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2676:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2677:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2678:          return ECMA_VALUE_UNDEFINED;
        -: 2679:        }
    #####: 2680:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2681:        {
    #####: 2682:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2683:
    #####: 2684:          JERRY_ASSERT (
        -: 2685:            !(async_generator_object_p->u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2686:
        -: 2687:          /* Byte code is executed at the first time. */
    #####: 2688:          left_value = stack_top_p[-1];
    #####: 2689:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2690:
    #####: 2691:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2692:          {
    #####: 2693:            goto error;
        -: 2694:          }
        -: 2695:
    #####: 2696:          ecma_free_value (left_value);
    #####: 2697:          left_value = result;
    #####: 2698:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2699:
    #####: 2700:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2701:          {
    #####: 2702:            goto error;
        -: 2703:          }
        -: 2704:
    #####: 2705:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2706:
    #####: 2707:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2708:          {
    #####: 2709:            goto error;
        -: 2710:          }
        -: 2711:
    #####: 2712:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2713:          *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = left_value;
        -: 2714:
    #####: 2715:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2716:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2717:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2718:          return ECMA_VALUE_UNDEFINED;
        -: 2719:        }
    #####: 2720:        case VM_OC_AWAIT:
        -: 2721:        {
    #####: 2722:          if (JERRY_UNLIKELY (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE)))
        -: 2723:          {
    #####: 2724:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2725:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2726:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2727:
    #####: 2728:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2729:
    #####: 2730:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2731:            {
    #####: 2732:              goto error;
        -: 2733:            }
    #####: 2734:            return result;
        -: 2735:          }
        -: 2736:          /* FALLTHRU */
        -: 2737:        }
        -: 2738:        case VM_OC_GENERATOR_AWAIT:
        -: 2739:        {
    #####: 2740:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2741:
    #####: 2742:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2743:
    #####: 2744:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2745:          {
    #####: 2746:            goto error;
        -: 2747:          }
        -: 2748:
    #####: 2749:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2750:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2751:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2752:          return ECMA_VALUE_UNDEFINED;
        -: 2753:        }
    #####: 2754:        case VM_OC_EXT_RETURN:
        -: 2755:        {
    #####: 2756:          result = left_value;
    #####: 2757:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2758:
    #####: 2759:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2760:
    #####: 2761:          while (stack_top_p > stack_bottom_p)
        -: 2762:          {
    #####: 2763:            ecma_fast_free_value (*(--stack_top_p));
        -: 2764:          }
        -: 2765:
    #####: 2766:          goto error;
        -: 2767:        }
    #####: 2768:        case VM_OC_ASYNC_EXIT:
        -: 2769:        {
    #####: 2770:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2771:
    #####: 2772:          if (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 2773:          {
    #####: 2774:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2775:          }
        -: 2776:          else
        -: 2777:          {
    #####: 2778:            result = *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p);
    #####: 2779:            *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = ECMA_VALUE_UNDEFINED;
        -: 2780:          }
        -: 2781:
    #####: 2782:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2783:
    #####: 2784:          if (context_type == VM_CONTEXT_TRY)
        -: 2785:          {
    #####: 2786:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2787:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2788:          }
        -: 2789:          else
        -: 2790:          {
    #####: 2791:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2792:            left_value = stack_top_p[-2];
        -: 2793:          }
        -: 2794:
    #####: 2795:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2796:          {
    #####: 2797:            ecma_reject_promise (result, left_value);
        -: 2798:          }
        -: 2799:          else
        -: 2800:          {
    #####: 2801:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2802:            ecma_fulfill_promise (result, left_value);
        -: 2803:          }
        -: 2804:
    #####: 2805:          ecma_free_value (left_value);
        -: 2806:
    #####: 2807:          frame_ctx_p->context_depth = 0;
    #####: 2808:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2809:          return result;
        -: 2810:        }
    #####: 2811:        case VM_OC_STRING_CONCAT:
        -: 2812:        {
    #####: 2813:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2814:
    #####: 2815:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2816:          {
    #####: 2817:            result = ECMA_VALUE_ERROR;
    #####: 2818:            goto error;
        -: 2819:          }
    #####: 2820:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2821:
    #####: 2822:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2823:          {
    #####: 2824:            ecma_deref_ecma_string (left_str_p);
    #####: 2825:            result = ECMA_VALUE_ERROR;
    #####: 2826:            goto error;
        -: 2827:          }
        -: 2828:
    #####: 2829:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2830:          ecma_deref_ecma_string (right_str_p);
        -: 2831:
    #####: 2832:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2833:          goto free_both_values;
        -: 2834:        }
    #####: 2835:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2836:        {
    #####: 2837:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2838:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2839:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2840:
    #####: 2841:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2842:          continue;
        -: 2843:        }
    #####: 2844:        case VM_OC_PUSH_NEW_TARGET:
        -: 2845:        {
    #####: 2846:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2847:          if (new_target_object_p == NULL)
        -: 2848:          {
    #####: 2849:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2850:          }
        -: 2851:          else
        -: 2852:          {
    #####: 2853:            ecma_ref_object (new_target_object_p);
    #####: 2854:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2855:          }
    #####: 2856:          continue;
        -: 2857:        }
    #####: 2858:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2859:        {
    #####: 2860:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2861:          {
    #####: 2862:            result = ECMA_VALUE_ERROR;
    #####: 2863:            goto error;
        -: 2864:          }
    #####: 2865:          continue;
        -: 2866:        }
    #####: 2867:        case VM_OC_ASSIGN_SUPER:
        -: 2868:        {
    #####: 2869:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2870:
    #####: 2871:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2872:          {
    #####: 2873:            goto error;
        -: 2874:          }
    #####: 2875:          continue;
        -: 2876:        }
        -: 2877:#endif /* JERRY_ESNEXT */
    #####: 2878:        case VM_OC_PUSH_ELISON:
        -: 2879:        {
    #####: 2880:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2881:          continue;
        -: 2882:        }
    #####: 2883:        case VM_OC_APPEND_ARRAY:
        -: 2884:        {
    #####: 2885:          uint16_t values_length = *byte_code_p++;
    #####: 2886:          stack_top_p -= values_length;
        -: 2887:
        -: 2888:#if JERRY_ESNEXT
    #####: 2889:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2890:          {
    #####: 2891:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2892:          }
        -: 2893:#endif /* JERRY_ESNEXT */
    #####: 2894:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2895:
        -: 2896:#if JERRY_ESNEXT
    #####: 2897:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2898:          {
    #####: 2899:            goto error;
        -: 2900:          }
        -: 2901:#else /* !JERRY_ESNEXT */
        -: 2902:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2903:#endif /* JERRY_ESNEXT */
    #####: 2904:          continue;
        -: 2905:        }
    #####: 2906:        case VM_OC_IDENT_REFERENCE:
        -: 2907:        {
        -: 2908:          uint16_t literal_index;
        -: 2909:
    #####: 2910:          READ_LITERAL_INDEX (literal_index);
        -: 2911:
    #####: 2912:          JERRY_ASSERT (literal_index < ident_end);
        -: 2913:
    #####: 2914:          if (literal_index < register_end)
        -: 2915:          {
    #####: 2916:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2917:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2918:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2919:          }
        -: 2920:          else
        -: 2921:          {
    #####: 2922:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2923:
    #####: 2924:            ecma_object_t *ref_base_lex_env_p;
        -: 2925:
    #####: 2926:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 2927:
    #####: 2928:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2929:            {
    #####: 2930:              goto error;
        -: 2931:            }
        -: 2932:
    #####: 2933:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2934:            ecma_ref_ecma_string (name_p);
    #####: 2935:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2936:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2937:            *stack_top_p++ = result;
        -: 2938:          }
    #####: 2939:          continue;
        -: 2940:        }
    #####: 2941:        case VM_OC_PROP_GET:
        -: 2942:        {
    #####: 2943:          result = vm_op_get_value (left_value, right_value);
        -: 2944:
    #####: 2945:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2946:          {
    #####: 2947:            goto error;
        -: 2948:          }
        -: 2949:
    #####: 2950:          *stack_top_p++ = result;
    #####: 2951:          goto free_both_values;
        -: 2952:        }
        2: 2953:        case VM_OC_PROP_REFERENCE:
        -: 2954:        {
        -: 2955:          /* Forms with reference requires preserving the base and offset. */
        -: 2956:
        2: 2957:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2958:          {
    #####: 2959:            left_value = stack_top_p[-2];
    #####: 2960:            right_value = stack_top_p[-1];
        -: 2961:          }
        2: 2962:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2963:          {
    #####: 2964:            *stack_top_p++ = left_value;
    #####: 2965:            right_value = left_value;
    #####: 2966:            left_value = stack_top_p[-2];
        -: 2967:          }
        -: 2968:          else
        -: 2969:          {
        2: 2970:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2971:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
        2: 2972:            *stack_top_p++ = left_value;
        2: 2973:            *stack_top_p++ = right_value;
        -: 2974:          }
        -: 2975:          /* FALLTHRU */
        -: 2976:        }
        -: 2977:        case VM_OC_PROP_PRE_INCR:
        -: 2978:        case VM_OC_PROP_PRE_DECR:
        -: 2979:        case VM_OC_PROP_POST_INCR:
        -: 2980:        case VM_OC_PROP_POST_DECR:
        -: 2981:        {
        2: 2982:          result = vm_op_get_value (left_value, right_value);
        -: 2983:
        2: 2984:          if (opcode < CBC_PRE_INCR)
        -: 2985:          {
        2: 2986:            left_value = ECMA_VALUE_UNDEFINED;
        2: 2987:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2988:          }
        -: 2989:
        2: 2990:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2991:          {
    #####: 2992:            goto error;
        -: 2993:          }
        -: 2994:
        2: 2995:          if (opcode < CBC_PRE_INCR)
        -: 2996:          {
        2: 2997:            break;
        -: 2998:          }
        -: 2999:
    #####: 3000:          stack_top_p += 2;
    #####: 3001:          left_value = result;
    #####: 3002:          right_value = ECMA_VALUE_UNDEFINED;
        -: 3003:          /* FALLTHRU */
        -: 3004:        }
    #####: 3005:        case VM_OC_PRE_INCR:
        -: 3006:        case VM_OC_PRE_DECR:
        -: 3007:        case VM_OC_POST_INCR:
        -: 3008:        case VM_OC_POST_DECR:
        -: 3009:        {
    #####: 3010:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
    #####: 3011:          ecma_number_t result_number;
        -: 3012:
    #####: 3013:          byte_code_p = byte_code_start_p + 1;
        -: 3014:
    #####: 3015:          if (ecma_is_value_integer_number (left_value))
        -: 3016:          {
    #####: 3017:            result = left_value;
    #####: 3018:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3019:
    #####: 3020:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
    #####: 3021:            ecma_integer_value_t int_increase = 0;
        -: 3022:
    #####: 3023:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3024:            {
    #####: 3025:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 3026:              {
    #####: 3027:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 3028:              }
        -: 3029:            }
    #####: 3030:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 3031:            {
    #####: 3032:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 3033:            }
        -: 3034:
    #####: 3035:            if (JERRY_LIKELY (int_increase != 0))
        -: 3036:            {
        -: 3037:              /* Postfix operators require the unmodifed number value. */
    #####: 3038:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3039:              {
    #####: 3040:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3041:              }
        -: 3042:
    #####: 3043:              result = (ecma_value_t) (int_value + int_increase);
    #####: 3044:              break;
        -: 3045:            }
    #####: 3046:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3047:          }
    #####: 3048:          else if (ecma_is_value_float_number (left_value))
        -: 3049:          {
    #####: 3050:            result = left_value;
    #####: 3051:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3052:            result_number = ecma_get_number_from_value (result);
        -: 3053:          }
        -: 3054:          else
        -: 3055:          {
    #####: 3056:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3057:
    #####: 3058:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3059:            {
    #####: 3060:              goto error;
        -: 3061:            }
        -: 3062:
    #####: 3063:            ecma_free_value (left_value);
    #####: 3064:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3065:
        -: 3066:#if JERRY_BUILTIN_BIGINT
    #####: 3067:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3068:            {
    #####: 3069:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3070:
    #####: 3071:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3072:              {
    #####: 3073:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3074:              }
        -: 3075:
        -: 3076:              /* Postfix operators require the unmodifed number value. */
    #####: 3077:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3078:              {
    #####: 3079:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3080:
    #####: 3081:                result = ecma_bigint_unary (result, operation_type);
        -: 3082:              }
        -: 3083:              else
        -: 3084:              {
    #####: 3085:                ecma_value_t original_value = result;
    #####: 3086:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3087:                ecma_free_value (original_value);
        -: 3088:              }
        -: 3089:
    #####: 3090:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3091:              {
    #####: 3092:                goto error;
        -: 3093:              }
    #####: 3094:              break;
        -: 3095:            }
        -: 3096:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3097:
    #####: 3098:            result = ecma_make_number_value (result_number);
        -: 3099:          }
        -: 3100:
    #####: 3101:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3102:
    #####: 3103:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3104:          {
        -: 3105:            /* For decrement operators */
    #####: 3106:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3107:          }
        -: 3108:
        -: 3109:          /* Postfix operators require the unmodifed number value. */
    #####: 3110:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3111:          {
    #####: 3112:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3113:
    #####: 3114:            result = ecma_make_number_value (result_number + increase);
    #####: 3115:            break;
        -: 3116:          }
        -: 3117:
    #####: 3118:          if (ecma_is_value_integer_number (result))
        -: 3119:          {
    #####: 3120:            result = ecma_make_number_value (result_number + increase);
        -: 3121:          }
        -: 3122:          else
        -: 3123:          {
    #####: 3124:            result = ecma_update_float_number (result, result_number + increase);
        -: 3125:          }
    #####: 3126:          break;
        -: 3127:        }
    #####: 3128:        case VM_OC_ASSIGN:
        -: 3129:        {
    #####: 3130:          result = left_value;
    #####: 3131:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3132:          break;
        -: 3133:        }
    #####: 3134:        case VM_OC_MOV_IDENT:
        -: 3135:        {
        -: 3136:          uint32_t literal_index;
        -: 3137:
    #####: 3138:          READ_LITERAL_INDEX (literal_index);
        -: 3139:
    #####: 3140:          JERRY_ASSERT (literal_index < register_end);
    #####: 3141:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3142:
    #####: 3143:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 3144:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
    #####: 3145:          continue;
        -: 3146:        }
    #####: 3147:        case VM_OC_ASSIGN_PROP:
        -: 3148:        {
    #####: 3149:          result = stack_top_p[-1];
    #####: 3150:          stack_top_p[-1] = left_value;
    #####: 3151:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3152:          break;
        -: 3153:        }
    #####: 3154:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3155:        {
    #####: 3156:          result = stack_top_p[-1];
    #####: 3157:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 3158:          *stack_top_p++ = left_value;
    #####: 3159:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3160:          break;
        -: 3161:        }
    #####: 3162:        case VM_OC_RETURN_FUNCTION_END:
        -: 3163:        {
    #####: 3164:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_SCRIPT)
        -: 3165:          {
    #####: 3166:            result = VM_GET_REGISTER (frame_ctx_p, 0);
    #####: 3167:            VM_GET_REGISTERS (frame_ctx_p)[0] = ECMA_VALUE_UNDEFINED;
        -: 3168:          }
        -: 3169:          else
        -: 3170:          {
    #####: 3171:            result = ECMA_VALUE_UNDEFINED;
        -: 3172:          }
        -: 3173:
    #####: 3174:          goto error;
        -: 3175:        }
    #####: 3176:        case VM_OC_RETURN:
        -: 3177:        {
    #####: 3178:          JERRY_ASSERT (opcode == CBC_RETURN || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3179:
    #####: 3180:          result = left_value;
    #####: 3181:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3182:          goto error;
        -: 3183:        }
    #####: 3184:        case VM_OC_THROW:
        -: 3185:        {
    #####: 3186:          jcontext_raise_exception (left_value);
        -: 3187:
    #####: 3188:          result = ECMA_VALUE_ERROR;
    #####: 3189:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3190:          goto error;
        -: 3191:        }
    #####: 3192:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3193:        {
    #####: 3194:          result = ecma_raise_reference_error (ECMA_ERR_UNDEFINED_REFERENCE);
    #####: 3195:          goto error;
        -: 3196:        }
    #####: 3197:        case VM_OC_EVAL:
        -: 3198:        {
    #####: 3199:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3200:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3201:                        || (*byte_code_p == CBC_EXT_OPCODE && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3202:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3203:          continue;
        -: 3204:        }
        2: 3205:        case VM_OC_CALL:
        -: 3206:        {
        2: 3207:          frame_ctx_p->call_operation = VM_EXEC_CALL;
        2: 3208:          frame_ctx_p->byte_code_p = byte_code_start_p;
        2: 3209:          frame_ctx_p->stack_top_p = stack_top_p;
        2: 3210:          return ECMA_VALUE_UNDEFINED;
        -: 3211:        }
        1: 3212:        case VM_OC_NEW:
        -: 3213:        {
        1: 3214:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
        1: 3215:          frame_ctx_p->byte_code_p = byte_code_start_p;
        1: 3216:          frame_ctx_p->stack_top_p = stack_top_p;
        1: 3217:          return ECMA_VALUE_UNDEFINED;
        -: 3218:        }
    #####: 3219:        case VM_OC_ERROR:
        -: 3220:        {
    #####: 3221:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3222:#if JERRY_DEBUGGER
        -: 3223:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3224:#endif /* JERRY_DEBUGGER */
        -: 3225:
    #####: 3226:          result = ECMA_VALUE_ERROR;
    #####: 3227:          goto error;
        -: 3228:        }
    #####: 3229:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3230:        {
    #####: 3231:          ecma_value_t this_value = stack_top_p[-3];
        -: 3232:
    #####: 3233:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3234:          {
        -: 3235:            /* Lexical environment cannot be 'this' value. */
    #####: 3236:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3237:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3238:          }
    #####: 3239:          else if (vm_get_implicit_this_value (&this_value))
        -: 3240:          {
    #####: 3241:            ecma_free_value (stack_top_p[-3]);
    #####: 3242:            stack_top_p[-3] = this_value;
        -: 3243:          }
        -: 3244:
    #####: 3245:          continue;
        -: 3246:        }
    #####: 3247:        case VM_OC_PROP_DELETE:
        -: 3248:        {
    #####: 3249:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3250:
    #####: 3251:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3252:          {
    #####: 3253:            goto error;
        -: 3254:          }
        -: 3255:
    #####: 3256:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3257:
    #####: 3258:          *stack_top_p++ = result;
    #####: 3259:          goto free_both_values;
        -: 3260:        }
    #####: 3261:        case VM_OC_DELETE:
        -: 3262:        {
        -: 3263:          uint16_t literal_index;
        -: 3264:
    #####: 3265:          READ_LITERAL_INDEX (literal_index);
        -: 3266:
    #####: 3267:          if (literal_index < register_end)
        -: 3268:          {
    #####: 3269:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3270:            continue;
        -: 3271:          }
        -: 3272:
    #####: 3273:          result = vm_op_delete_var (literal_start_p[literal_index], frame_ctx_p->lex_env_p);
        -: 3274:
    #####: 3275:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3276:          {
    #####: 3277:            goto error;
        -: 3278:          }
        -: 3279:
    #####: 3280:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3281:
    #####: 3282:          *stack_top_p++ = result;
    #####: 3283:          continue;
        -: 3284:        }
    #####: 3285:        case VM_OC_JUMP:
        -: 3286:        {
    #####: 3287:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 3288:          continue;
        -: 3289:        }
    #####: 3290:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3291:        {
    #####: 3292:          ecma_value_t value = *(--stack_top_p);
        -: 3293:
    #####: 3294:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3295:
    #####: 3296:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3297:          {
    #####: 3298:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3299:            ecma_free_value (*--stack_top_p);
        -: 3300:          }
    #####: 3301:          ecma_free_value (value);
    #####: 3302:          continue;
        -: 3303:        }
    #####: 3304:        case VM_OC_BRANCH_IF_TRUE:
        -: 3305:        case VM_OC_BRANCH_IF_FALSE:
        -: 3306:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3307:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3308:        {
    #####: 3309:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 3310:          ecma_value_t value = *(--stack_top_p);
        -: 3311:
    #####: 3312:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3313:
    #####: 3314:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3315:          {
    #####: 3316:            boolean_value = !boolean_value;
        -: 3317:          }
        -: 3318:
    #####: 3319:          if (boolean_value)
        -: 3320:          {
    #####: 3321:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3322:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3323:            {
        -: 3324:              /* "Push" the value back to the stack. */
    #####: 3325:              ++stack_top_p;
    #####: 3326:              continue;
        -: 3327:            }
        -: 3328:          }
        -: 3329:
    #####: 3330:          ecma_fast_free_value (value);
    #####: 3331:          continue;
        -: 3332:        }
        -: 3333:#if JERRY_ESNEXT
    #####: 3334:        case VM_OC_POP_REFERENCE:
        -: 3335:        {
    #####: 3336:          ecma_free_value (stack_top_p[-2]);
    #####: 3337:          ecma_free_value (stack_top_p[-3]);
    #####: 3338:          stack_top_p[-3] = stack_top_p[-1];
    #####: 3339:          stack_top_p -= 2;
    #####: 3340:          continue;
        -: 3341:        }
    #####: 3342:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3343:        {
    #####: 3344:          left_value = stack_top_p[-1];
        -: 3345:
    #####: 3346:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3347:          {
    #####: 3348:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3349:            continue;
        -: 3350:          }
    #####: 3351:          --stack_top_p;
    #####: 3352:          continue;
        -: 3353:        }
        -: 3354:#endif /* JERRY_ESNEXT */
    #####: 3355:        case VM_OC_PLUS:
        -: 3356:        case VM_OC_MINUS:
        -: 3357:        {
    #####: 3358:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3359:
    #####: 3360:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3361:          {
    #####: 3362:            goto error;
        -: 3363:          }
        -: 3364:
    #####: 3365:          *stack_top_p++ = result;
    #####: 3366:          goto free_left_value;
        -: 3367:        }
    #####: 3368:        case VM_OC_NOT:
        -: 3369:        {
    #####: 3370:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3371:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3372:          goto free_left_value;
        -: 3373:        }
    #####: 3374:        case VM_OC_BIT_NOT:
        -: 3375:        {
        -: 3376:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3377:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3378:
    #####: 3379:          if (ecma_is_value_integer_number (left_value))
        -: 3380:          {
    #####: 3381:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3382:            goto free_left_value;
        -: 3383:          }
        -: 3384:
    #####: 3385:          result = do_number_bitwise_not (left_value);
        -: 3386:
    #####: 3387:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3388:          {
    #####: 3389:            goto error;
        -: 3390:          }
        -: 3391:
    #####: 3392:          *stack_top_p++ = result;
    #####: 3393:          goto free_left_value;
        -: 3394:        }
    #####: 3395:        case VM_OC_VOID:
        -: 3396:        {
    #####: 3397:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3398:          goto free_left_value;
        -: 3399:        }
    #####: 3400:        case VM_OC_TYPEOF_IDENT:
        -: 3401:        {
        -: 3402:          uint16_t literal_index;
        -: 3403:
    #####: 3404:          READ_LITERAL_INDEX (literal_index);
        -: 3405:
    #####: 3406:          JERRY_ASSERT (literal_index < ident_end);
        -: 3407:
    #####: 3408:          if (literal_index < register_end)
        -: 3409:          {
    #####: 3410:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3411:          }
        -: 3412:          else
        -: 3413:          {
    #####: 3414:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3415:
    #####: 3416:            ecma_object_t *ref_base_lex_env_p;
        -: 3417:
    #####: 3418:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 3419:
    #####: 3420:            if (ref_base_lex_env_p == NULL)
        -: 3421:            {
    #####: 3422:              jcontext_release_exception ();
    #####: 3423:              result = ECMA_VALUE_UNDEFINED;
        -: 3424:            }
    #####: 3425:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3426:            {
    #####: 3427:              goto error;
        -: 3428:            }
        -: 3429:
    #####: 3430:            left_value = result;
        -: 3431:          }
        -: 3432:          /* FALLTHRU */
        -: 3433:        }
        -: 3434:        case VM_OC_TYPEOF:
        -: 3435:        {
    #####: 3436:          result = opfunc_typeof (left_value);
        -: 3437:
    #####: 3438:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3439:          {
    #####: 3440:            goto error;
        -: 3441:          }
        -: 3442:
    #####: 3443:          *stack_top_p++ = result;
    #####: 3444:          goto free_left_value;
        -: 3445:        }
    #####: 3446:        case VM_OC_ADD:
        -: 3447:        {
    #####: 3448:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3449:          {
    #####: 3450:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3451:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3452:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3453:            continue;
        -: 3454:          }
        -: 3455:
    #####: 3456:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3457:          {
    #####: 3458:            ecma_number_t new_value =
    #####: 3459:              (ecma_get_float_from_value (left_value) + ecma_get_number_from_value (right_value));
        -: 3460:
    #####: 3461:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3462:            ecma_free_number (right_value);
    #####: 3463:            continue;
        -: 3464:          }
        -: 3465:
    #####: 3466:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3467:          {
    #####: 3468:            ecma_number_t new_value =
    #####: 3469:              ((ecma_number_t) ecma_get_integer_from_value (left_value) + ecma_get_float_from_value (right_value));
        -: 3470:
    #####: 3471:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3472:            continue;
        -: 3473:          }
        -: 3474:
    #####: 3475:          result = opfunc_addition (left_value, right_value);
        -: 3476:
    #####: 3477:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3478:          {
    #####: 3479:            goto error;
        -: 3480:          }
        -: 3481:
    #####: 3482:          *stack_top_p++ = result;
    #####: 3483:          goto free_both_values;
        -: 3484:        }
    #####: 3485:        case VM_OC_SUB:
        -: 3486:        {
        -: 3487:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3488:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3489:
    #####: 3490:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3491:
    #####: 3492:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3493:          {
    #####: 3494:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3495:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3496:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3497:            continue;
        -: 3498:          }
        -: 3499:
    #####: 3500:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3501:          {
    #####: 3502:            ecma_number_t new_value =
    #####: 3503:              (ecma_get_float_from_value (left_value) - ecma_get_number_from_value (right_value));
        -: 3504:
    #####: 3505:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3506:            ecma_free_number (right_value);
    #####: 3507:            continue;
        -: 3508:          }
        -: 3509:
    #####: 3510:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3511:          {
    #####: 3512:            ecma_number_t new_value =
    #####: 3513:              ((ecma_number_t) ecma_get_integer_from_value (left_value) - ecma_get_float_from_value (right_value));
        -: 3514:
    #####: 3515:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3516:            continue;
        -: 3517:          }
        -: 3518:
    #####: 3519:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION, left_value, right_value);
        -: 3520:
    #####: 3521:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3522:          {
    #####: 3523:            goto error;
        -: 3524:          }
        -: 3525:
    #####: 3526:          *stack_top_p++ = result;
    #####: 3527:          goto free_both_values;
        -: 3528:        }
    #####: 3529:        case VM_OC_MUL:
        -: 3530:        {
    #####: 3531:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3532:
        -: 3533:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3534:                                 && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3535:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3536:
    #####: 3537:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3538:          {
    #####: 3539:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3540:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3541:
    #####: 3542:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3543:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3544:                && left_integer != 0 && right_integer != 0)
        -: 3545:            {
    #####: 3546:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3547:              continue;
        -: 3548:            }
        -: 3549:
    #####: 3550:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3551:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3552:            continue;
        -: 3553:          }
        -: 3554:
    #####: 3555:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3556:          {
    #####: 3557:            ecma_number_t new_value =
    #####: 3558:              (ecma_get_float_from_value (left_value) * ecma_get_number_from_value (right_value));
        -: 3559:
    #####: 3560:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3561:            ecma_free_number (right_value);
    #####: 3562:            continue;
        -: 3563:          }
        -: 3564:
    #####: 3565:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3566:          {
    #####: 3567:            ecma_number_t new_value =
    #####: 3568:              ((ecma_number_t) ecma_get_integer_from_value (left_value) * ecma_get_float_from_value (right_value));
        -: 3569:
    #####: 3570:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3571:            continue;
        -: 3572:          }
        -: 3573:
    #####: 3574:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION, left_value, right_value);
        -: 3575:
    #####: 3576:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3577:          {
    #####: 3578:            goto error;
        -: 3579:          }
        -: 3580:
    #####: 3581:          *stack_top_p++ = result;
    #####: 3582:          goto free_both_values;
        -: 3583:        }
    #####: 3584:        case VM_OC_DIV:
        -: 3585:        {
    #####: 3586:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3587:
    #####: 3588:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION, left_value, right_value);
        -: 3589:
    #####: 3590:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3591:          {
    #####: 3592:            goto error;
        -: 3593:          }
        -: 3594:
    #####: 3595:          *stack_top_p++ = result;
    #####: 3596:          goto free_both_values;
        -: 3597:        }
    #####: 3598:        case VM_OC_MOD:
        -: 3599:        {
    #####: 3600:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3601:
    #####: 3602:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3603:          {
    #####: 3604:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3605:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3606:
    #####: 3607:            if (right_integer != 0)
        -: 3608:            {
    #####: 3609:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3610:
    #####: 3611:              if (mod_result != 0 || left_integer >= 0)
        -: 3612:              {
    #####: 3613:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3614:                continue;
        -: 3615:              }
        -: 3616:            }
        -: 3617:          }
        -: 3618:
    #####: 3619:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER, left_value, right_value);
        -: 3620:
    #####: 3621:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3622:          {
    #####: 3623:            goto error;
        -: 3624:          }
        -: 3625:
    #####: 3626:          *stack_top_p++ = result;
    #####: 3627:          goto free_both_values;
        -: 3628:        }
        -: 3629:#if JERRY_ESNEXT
    #####: 3630:        case VM_OC_EXP:
        -: 3631:        {
    #####: 3632:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION, left_value, right_value);
        -: 3633:
    #####: 3634:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3635:          {
    #####: 3636:            goto error;
        -: 3637:          }
        -: 3638:
    #####: 3639:          *stack_top_p++ = result;
    #####: 3640:          goto free_both_values;
        -: 3641:        }
        -: 3642:#endif /* JERRY_ESNEXT */
    #####: 3643:        case VM_OC_EQUAL:
        -: 3644:        {
    #####: 3645:          result = opfunc_equality (left_value, right_value);
        -: 3646:
    #####: 3647:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3648:          {
    #####: 3649:            goto error;
        -: 3650:          }
        -: 3651:
    #####: 3652:          *stack_top_p++ = result;
    #####: 3653:          goto free_both_values;
        -: 3654:        }
    #####: 3655:        case VM_OC_NOT_EQUAL:
        -: 3656:        {
    #####: 3657:          result = opfunc_equality (left_value, right_value);
        -: 3658:
    #####: 3659:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3660:          {
    #####: 3661:            goto error;
        -: 3662:          }
        -: 3663:
    #####: 3664:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3665:          goto free_both_values;
        -: 3666:        }
    #####: 3667:        case VM_OC_STRICT_EQUAL:
        -: 3668:        {
    #####: 3669:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3670:
    #####: 3671:          result = ecma_make_boolean_value (is_equal);
        -: 3672:
    #####: 3673:          *stack_top_p++ = result;
    #####: 3674:          goto free_both_values;
        -: 3675:        }
    #####: 3676:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3677:        {
    #####: 3678:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3679:
    #####: 3680:          result = ecma_make_boolean_value (!is_equal);
        -: 3681:
    #####: 3682:          *stack_top_p++ = result;
    #####: 3683:          goto free_both_values;
        -: 3684:        }
    #####: 3685:        case VM_OC_BIT_OR:
        -: 3686:        {
        -: 3687:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3688:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3689:
    #####: 3690:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3691:          {
    #####: 3692:            *stack_top_p++ = left_value | right_value;
    #####: 3693:            continue;
        -: 3694:          }
        -: 3695:
    #####: 3696:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR, left_value, right_value);
        -: 3697:
    #####: 3698:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3699:          {
    #####: 3700:            goto error;
        -: 3701:          }
        -: 3702:
    #####: 3703:          *stack_top_p++ = result;
    #####: 3704:          goto free_both_values;
        -: 3705:        }
    #####: 3706:        case VM_OC_BIT_XOR:
        -: 3707:        {
        -: 3708:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3709:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3710:
    #####: 3711:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3712:          {
    #####: 3713:            *stack_top_p++ = left_value ^ right_value;
    #####: 3714:            continue;
        -: 3715:          }
        -: 3716:
    #####: 3717:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR, left_value, right_value);
        -: 3718:
    #####: 3719:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3720:          {
    #####: 3721:            goto error;
        -: 3722:          }
        -: 3723:
    #####: 3724:          *stack_top_p++ = result;
    #####: 3725:          goto free_both_values;
        -: 3726:        }
    #####: 3727:        case VM_OC_BIT_AND:
        -: 3728:        {
        -: 3729:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3730:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3731:
    #####: 3732:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3733:          {
    #####: 3734:            *stack_top_p++ = left_value & right_value;
    #####: 3735:            continue;
        -: 3736:          }
        -: 3737:
    #####: 3738:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND, left_value, right_value);
        -: 3739:
    #####: 3740:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3741:          {
    #####: 3742:            goto error;
        -: 3743:          }
        -: 3744:
    #####: 3745:          *stack_top_p++ = result;
    #####: 3746:          goto free_both_values;
        -: 3747:        }
    #####: 3748:        case VM_OC_LEFT_SHIFT:
        -: 3749:        {
        -: 3750:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3751:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3752:
    #####: 3753:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3754:          {
    #####: 3755:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3756:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3757:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 3758:            continue;
        -: 3759:          }
        -: 3760:
    #####: 3761:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT, left_value, right_value);
        -: 3762:
    #####: 3763:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3764:          {
    #####: 3765:            goto error;
        -: 3766:          }
        -: 3767:
    #####: 3768:          *stack_top_p++ = result;
    #####: 3769:          goto free_both_values;
        -: 3770:        }
    #####: 3771:        case VM_OC_RIGHT_SHIFT:
        -: 3772:        {
        -: 3773:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3774:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3775:
    #####: 3776:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3777:          {
    #####: 3778:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3779:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3780:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3781:            continue;
        -: 3782:          }
        -: 3783:
    #####: 3784:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT, left_value, right_value);
        -: 3785:
    #####: 3786:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3787:          {
    #####: 3788:            goto error;
        -: 3789:          }
        -: 3790:
    #####: 3791:          *stack_top_p++ = result;
    #####: 3792:          goto free_both_values;
        -: 3793:        }
    #####: 3794:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3795:        {
        -: 3796:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3797:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3798:
    #####: 3799:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3800:          {
    #####: 3801:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3802:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3803:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3804:            continue;
        -: 3805:          }
        -: 3806:
    #####: 3807:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT, left_value, right_value);
        -: 3808:
    #####: 3809:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3810:          {
    #####: 3811:            goto error;
        -: 3812:          }
        -: 3813:
    #####: 3814:          *stack_top_p++ = result;
    #####: 3815:          goto free_both_values;
        -: 3816:        }
    #####: 3817:        case VM_OC_LESS:
        -: 3818:        {
    #####: 3819:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3820:          {
    #####: 3821:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3822:#if !JERRY_VM_HALT
        -: 3823:            /* This is a lookahead to the next opcode to improve performance.
        -: 3824:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
    #####: 3825:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3826:            {
    #####: 3827:              byte_code_start_p = byte_code_p++;
    #####: 3828:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
    #####: 3829:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3830:
    #####: 3831:              if (is_less)
        -: 3832:              {
    #####: 3833:                branch_offset = *(byte_code_p++);
        -: 3834:
    #####: 3835:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3836:                {
    #####: 3837:                  branch_offset <<= 8;
    #####: 3838:                  branch_offset |= *(byte_code_p++);
    #####: 3839:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3840:                  {
    #####: 3841:                    branch_offset <<= 8;
    #####: 3842:                    branch_offset |= *(byte_code_p++);
        -: 3843:                  }
        -: 3844:                }
        -: 3845:
        -: 3846:                /* Note: The opcode is a backward branch. */
    #####: 3847:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3848:              }
        -: 3849:              else
        -: 3850:              {
    #####: 3851:                byte_code_p += branch_offset_length;
        -: 3852:              }
        -: 3853:
    #####: 3854:              continue;
        -: 3855:            }
        -: 3856:#endif /* !JERRY_VM_HALT */
    #####: 3857:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3858:            continue;
        -: 3859:          }
        -: 3860:
    #####: 3861:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3862:          {
    #####: 3863:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3864:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3865:
    #####: 3866:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3867:            goto free_both_values;
        -: 3868:          }
        -: 3869:
    #####: 3870:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3871:
    #####: 3872:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3873:          {
    #####: 3874:            goto error;
        -: 3875:          }
        -: 3876:
    #####: 3877:          *stack_top_p++ = result;
    #####: 3878:          goto free_both_values;
        -: 3879:        }
    #####: 3880:        case VM_OC_GREATER:
        -: 3881:        {
    #####: 3882:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3883:          {
    #####: 3884:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3885:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3886:
    #####: 3887:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3888:            continue;
        -: 3889:          }
        -: 3890:
    #####: 3891:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3892:          {
    #####: 3893:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3894:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3895:
    #####: 3896:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3897:            goto free_both_values;
        -: 3898:          }
        -: 3899:
    #####: 3900:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3901:
    #####: 3902:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3903:          {
    #####: 3904:            goto error;
        -: 3905:          }
        -: 3906:
    #####: 3907:          *stack_top_p++ = result;
    #####: 3908:          goto free_both_values;
        -: 3909:        }
    #####: 3910:        case VM_OC_LESS_EQUAL:
        -: 3911:        {
    #####: 3912:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3913:          {
    #####: 3914:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3915:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3916:
    #####: 3917:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3918:            continue;
        -: 3919:          }
        -: 3920:
    #####: 3921:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3922:          {
    #####: 3923:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3924:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3925:
    #####: 3926:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3927:            goto free_both_values;
        -: 3928:          }
        -: 3929:
    #####: 3930:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3931:
    #####: 3932:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3933:          {
    #####: 3934:            goto error;
        -: 3935:          }
        -: 3936:
    #####: 3937:          *stack_top_p++ = result;
    #####: 3938:          goto free_both_values;
        -: 3939:        }
    #####: 3940:        case VM_OC_GREATER_EQUAL:
        -: 3941:        {
    #####: 3942:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3943:          {
    #####: 3944:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3945:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3946:
    #####: 3947:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3948:            continue;
        -: 3949:          }
        -: 3950:
    #####: 3951:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3952:          {
    #####: 3953:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3954:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3955:
    #####: 3956:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3957:            goto free_both_values;
        -: 3958:          }
        -: 3959:
    #####: 3960:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3961:
    #####: 3962:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3963:          {
    #####: 3964:            goto error;
        -: 3965:          }
        -: 3966:
    #####: 3967:          *stack_top_p++ = result;
    #####: 3968:          goto free_both_values;
        -: 3969:        }
    #####: 3970:        case VM_OC_IN:
        -: 3971:        {
    #####: 3972:          result = opfunc_in (left_value, right_value);
        -: 3973:
    #####: 3974:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3975:          {
    #####: 3976:            goto error;
        -: 3977:          }
        -: 3978:
    #####: 3979:          *stack_top_p++ = result;
    #####: 3980:          goto free_both_values;
        -: 3981:        }
    #####: 3982:        case VM_OC_INSTANCEOF:
        -: 3983:        {
    #####: 3984:          result = opfunc_instanceof (left_value, right_value);
        -: 3985:
    #####: 3986:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3987:          {
    #####: 3988:            goto error;
        -: 3989:          }
        -: 3990:
    #####: 3991:          *stack_top_p++ = result;
    #####: 3992:          goto free_both_values;
        -: 3993:        }
    #####: 3994:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3995:        {
        -: 3996:#if JERRY_ESNEXT
        -: 3997:          ecma_value_t *stack_context_top_p;
    #####: 3998:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3999:
    #####: 4000:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 4001:
    #####: 4002:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 4003:          {
    #####: 4004:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4005:
    #####: 4006:            if (stack_context_top_p != stack_top_p)
        -: 4007:            {
        -: 4008:              /* Preserve the value of switch statement. */
    #####: 4009:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 4010:            }
        -: 4011:
    #####: 4012:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 4013:
    #####: 4014:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 4015:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 4016:          }
        -: 4017:          else
        -: 4018:          {
    #####: 4019:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 4020:
    #####: 4021:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4022:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4023:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4024:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4025:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4026:
    #####: 4027:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4028:
    #####: 4029:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4030:          }
        -: 4031:#else /* !JERRY_ESNEXT */
        -: 4032:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4033:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4034:
    #####: 4035:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4036:#endif /* JERRY_ESNEXT */
        -: 4037:
    #####: 4038:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4039:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4040:
    #####: 4041:          continue;
        -: 4042:        }
    #####: 4043:        case VM_OC_WITH:
        -: 4044:        {
    #####: 4045:          ecma_value_t value = *(--stack_top_p);
        -: 4046:          ecma_object_t *object_p;
        -: 4047:          ecma_object_t *with_env_p;
        -: 4048:
    #####: 4049:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4050:
    #####: 4051:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4052:
    #####: 4053:          result = ecma_op_to_object (value);
    #####: 4054:          ecma_free_value (value);
        -: 4055:
    #####: 4056:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4057:          {
    #####: 4058:            goto error;
        -: 4059:          }
        -: 4060:
    #####: 4061:          object_p = ecma_get_object_from_value (result);
        -: 4062:
    #####: 4063:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4064:          ecma_deref_object (object_p);
        -: 4065:
    #####: 4066:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4067:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4068:
    #####: 4069:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4070:
    #####: 4071:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4072:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4073:          continue;
        -: 4074:        }
    #####: 4075:        case VM_OC_FOR_IN_INIT:
        -: 4076:        {
    #####: 4077:          ecma_value_t value = *(--stack_top_p);
        -: 4078:
    #####: 4079:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4080:
    #####: 4081:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 4082:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 4083:          ecma_free_value (value);
        -: 4084:
    #####: 4085:          if (prop_names_p == NULL)
        -: 4086:          {
        -: 4087:#if JERRY_ESNEXT
    #####: 4088:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4089:            {
    #####: 4090:              result = expr_obj_value;
    #####: 4091:              goto error;
        -: 4092:            }
        -: 4093:#endif /* JERRY_ESNEXT */
        -: 4094:
        -: 4095:            /* The collection is already released */
    #####: 4096:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4097:            continue;
        -: 4098:          }
        -: 4099:
    #####: 4100:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4101:
    #####: 4102:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4103:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 4104:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 4105:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 4106:          stack_top_p[-3] = 0;
    #####: 4107:          stack_top_p[-4] = expr_obj_value;
        -: 4108:
        -: 4109:#if JERRY_ESNEXT
    #####: 4110:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4111:          {
        -: 4112:            /* No need to duplicate the first context. */
    #####: 4113:            byte_code_p += 2;
        -: 4114:          }
        -: 4115:#endif /* JERRY_ESNEXT */
    #####: 4116:          continue;
        -: 4117:        }
    #####: 4118:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4119:        {
    #####: 4120:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4121:
        -: 4122:          ecma_collection_t *collection_p;
    #####: 4123:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4124:
    #####: 4125:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4126:
    #####: 4127:          uint32_t index = context_top_p[-3];
    #####: 4128:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4129:
    #####: 4130:          *stack_top_p++ = buffer_p[index];
    #####: 4131:          context_top_p[-3]++;
    #####: 4132:          continue;
        -: 4133:        }
    #####: 4134:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4135:        {
    #####: 4136:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4137:
        -: 4138:          ecma_collection_t *collection_p;
    #####: 4139:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4140:
    #####: 4141:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4142:
    #####: 4143:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 4144:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 4145:          uint32_t index = stack_top_p[-3];
        -: 4146:
    #####: 4147:          while (index < collection_p->item_count)
        -: 4148:          {
    #####: 4149:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4150:
    #####: 4151:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4152:
    #####: 4153:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4154:            {
    #####: 4155:              stack_top_p[-3] = index;
    #####: 4156:              goto error;
        -: 4157:            }
        -: 4158:
    #####: 4159:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4160:            {
    #####: 4161:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4162:              break;
        -: 4163:            }
        -: 4164:
    #####: 4165:            ecma_deref_ecma_string (prop_name_p);
    #####: 4166:            index++;
        -: 4167:          }
        -: 4168:
    #####: 4169:          if (index == collection_p->item_count)
        -: 4170:          {
    #####: 4171:            ecma_deref_object (object_p);
    #####: 4172:            ecma_collection_destroy (collection_p);
    #####: 4173:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4174:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4175:          }
        -: 4176:          else
        -: 4177:          {
    #####: 4178:            stack_top_p[-3] = index;
        -: 4179:          }
    #####: 4180:          continue;
        -: 4181:        }
        -: 4182:#if JERRY_ESNEXT
    #####: 4183:        case VM_OC_FOR_OF_INIT:
        -: 4184:        {
    #####: 4185:          ecma_value_t value = *(--stack_top_p);
        -: 4186:
    #####: 4187:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4188:
    #####: 4189:          ecma_value_t next_method;
    #####: 4190:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4191:
    #####: 4192:          ecma_free_value (value);
        -: 4193:
    #####: 4194:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4195:          {
    #####: 4196:            result = iterator;
    #####: 4197:            goto error;
        -: 4198:          }
        -: 4199:
    #####: 4200:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4201:
    #####: 4202:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4203:          {
    #####: 4204:            ecma_free_value (iterator);
    #####: 4205:            ecma_free_value (next_method);
    #####: 4206:            goto error;
        -: 4207:          }
        -: 4208:
    #####: 4209:          if (ecma_is_value_false (result))
        -: 4210:          {
    #####: 4211:            ecma_free_value (iterator);
    #####: 4212:            ecma_free_value (next_method);
    #####: 4213:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4214:            continue;
        -: 4215:          }
        -: 4216:
    #####: 4217:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4218:          ecma_free_value (result);
        -: 4219:
    #####: 4220:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4221:          {
    #####: 4222:            result = next_value;
    #####: 4223:            ecma_free_value (iterator);
    #####: 4224:            ecma_free_value (next_method);
    #####: 4225:            goto error;
        -: 4226:          }
        -: 4227:
    #####: 4228:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4229:
    #####: 4230:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4231:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4232:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4233:          stack_top_p[-2] = next_value;
    #####: 4234:          stack_top_p[-3] = iterator;
    #####: 4235:          stack_top_p[-4] = next_method;
        -: 4236:
    #####: 4237:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4238:          {
        -: 4239:            /* No need to duplicate the first context. */
    #####: 4240:            byte_code_p += 2;
        -: 4241:          }
    #####: 4242:          continue;
        -: 4243:        }
    #####: 4244:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4245:        {
    #####: 4246:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4247:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4248:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4249:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4250:
    #####: 4251:          *stack_top_p++ = context_top_p[-2];
    #####: 4252:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4253:          continue;
        -: 4254:        }
    #####: 4255:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4256:        {
    #####: 4257:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4258:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4259:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4260:
    #####: 4261:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4262:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4263:
    #####: 4264:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4265:          {
    #####: 4266:            goto error;
        -: 4267:          }
        -: 4268:
    #####: 4269:          if (ecma_is_value_false (result))
        -: 4270:          {
    #####: 4271:            ecma_free_value (stack_top_p[-2]);
    #####: 4272:            ecma_free_value (stack_top_p[-3]);
    #####: 4273:            ecma_free_value (stack_top_p[-4]);
    #####: 4274:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4275:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4276:            continue;
        -: 4277:          }
        -: 4278:
    #####: 4279:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4280:          ecma_free_value (result);
        -: 4281:
    #####: 4282:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4283:          {
    #####: 4284:            result = next_value;
    #####: 4285:            goto error;
        -: 4286:          }
        -: 4287:
    #####: 4288:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4289:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4290:          stack_top_p[-2] = next_value;
    #####: 4291:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4292:          continue;
        -: 4293:        }
    #####: 4294:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4295:        {
    #####: 4296:          ecma_value_t value = *(--stack_top_p);
        -: 4297:
    #####: 4298:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4299:
    #####: 4300:          ecma_value_t next_method;
    #####: 4301:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4302:
    #####: 4303:          ecma_free_value (value);
        -: 4304:
    #####: 4305:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4306:          {
    #####: 4307:            goto error;
        -: 4308:          }
        -: 4309:
    #####: 4310:          ecma_value_t iterator = result;
    #####: 4311:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4312:
    #####: 4313:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4314:          {
    #####: 4315:            ecma_free_value (iterator);
    #####: 4316:            ecma_free_value (next_method);
    #####: 4317:            goto error;
        -: 4318:          }
        -: 4319:
    #####: 4320:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4321:
    #####: 4322:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4323:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4324:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4325:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4326:          stack_top_p[-3] = iterator;
    #####: 4327:          stack_top_p[-4] = next_method;
        -: 4328:
    #####: 4329:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4330:          {
        -: 4331:            /* No need to duplicate the first context. */
    #####: 4332:            byte_code_p += 2;
        -: 4333:          }
        -: 4334:
    #####: 4335:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4336:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4337:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4338:
    #####: 4339:          uint16_t extra_flags =
        -: 4340:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4341:
    #####: 4342:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4343:              || (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 4344:          {
    #####: 4345:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4346:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4347:
    #####: 4348:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4349:            {
    #####: 4350:              goto error;
        -: 4351:            }
        -: 4352:
    #####: 4353:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4354:            return ECMA_VALUE_UNDEFINED;
        -: 4355:          }
        -: 4356:
    #####: 4357:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4358:
    #####: 4359:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4360:          {
    #####: 4361:            goto error;
        -: 4362:          }
    #####: 4363:          return result;
        -: 4364:        }
    #####: 4365:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4366:        {
    #####: 4367:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4368:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4369:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4370:
    #####: 4371:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4372:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4373:
    #####: 4374:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4375:          {
    #####: 4376:            goto error;
        -: 4377:          }
        -: 4378:
    #####: 4379:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4380:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4381:
    #####: 4382:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4383:          {
    #####: 4384:            goto error;
        -: 4385:          }
        -: 4386:
    #####: 4387:          uint16_t extra_flags =
        -: 4388:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4389:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4390:
    #####: 4391:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4392:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4393:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4394:          return ECMA_VALUE_UNDEFINED;
        -: 4395:        }
        -: 4396:#endif /* JERRY_ESNEXT */
    #####: 4397:        case VM_OC_TRY:
        -: 4398:        {
        -: 4399:          /* Try opcode simply creates the try context. */
    #####: 4400:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4401:
    #####: 4402:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4403:
    #####: 4404:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 4405:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4406:
    #####: 4407:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
    #####: 4408:          continue;
        -: 4409:        }
    #####: 4410:        case VM_OC_CATCH:
        -: 4411:        {
        -: 4412:          /* Catches are ignored and turned to jumps. */
    #####: 4413:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4414:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4415:
    #####: 4416:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4417:          continue;
        -: 4418:        }
    #####: 4419:        case VM_OC_FINALLY:
        -: 4420:        {
    #####: 4421:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4422:
    #####: 4423:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4424:
    #####: 4425:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4426:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4427:
    #####: 4428:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4429:          {
    #####: 4430:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4431:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4432:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4433:            ecma_deref_object (lex_env_p);
        -: 4434:          }
        -: 4435:
    #####: 4436:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4437:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4438:
    #####: 4439:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4440:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4441:          continue;
        -: 4442:        }
    #####: 4443:        case VM_OC_CONTEXT_END:
        -: 4444:        {
    #####: 4445:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4446:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4447:
    #####: 4448:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4449:
    #####: 4450:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4451:          {
    #####: 4452:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4453:
    #####: 4454:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4455:            continue;
        -: 4456:          }
        -: 4457:
        -: 4458:#if JERRY_ESNEXT
    #####: 4459:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4460:          {
    #####: 4461:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4462:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4463:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4464:            ecma_deref_object (lex_env_p);
        -: 4465:          }
        -: 4466:#endif /* JERRY_ESNEXT */
        -: 4467:
    #####: 4468:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4469:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4470:
    #####: 4471:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4472:          {
    #####: 4473:            result = *stack_top_p;
    #####: 4474:            goto error;
        -: 4475:          }
        -: 4476:
    #####: 4477:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4478:          {
    #####: 4479:            jcontext_raise_exception (*stack_top_p);
        -: 4480:#if JERRY_VM_THROW
    #####: 4481:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4482:#endif /* JERRY_VM_THROW */
    #####: 4483:            result = ECMA_VALUE_ERROR;
        -: 4484:
        -: 4485:#if JERRY_DEBUGGER
        -: 4486:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4487:#endif /* JERRY_DEBUGGER */
    #####: 4488:            goto error;
        -: 4489:          }
        -: 4490:
    #####: 4491:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4492:
    #####: 4493:          uint32_t jump_target = *stack_top_p;
        -: 4494:
    #####: 4495:          vm_stack_found_type type =
    #####: 4496:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, jump_target);
    #####: 4497:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4498:          switch (type)
        -: 4499:          {
    #####: 4500:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4501:            {
    #####: 4502:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4503:
    #####: 4504:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4505:              stack_top_p[-2] = jump_target;
    #####: 4506:              break;
        -: 4507:            }
        -: 4508:#if JERRY_ESNEXT
    #####: 4509:            case VM_CONTEXT_FOUND_ERROR:
        -: 4510:            {
    #####: 4511:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4512:              result = ECMA_VALUE_ERROR;
    #####: 4513:              goto error;
        -: 4514:            }
    #####: 4515:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4516:            {
    #####: 4517:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4518:              stack_top_p[-2] = jump_target;
    #####: 4519:              return ECMA_VALUE_UNDEFINED;
        -: 4520:            }
        -: 4521:#endif /* JERRY_ESNEXT */
    #####: 4522:            default:
        -: 4523:            {
    #####: 4524:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4525:              break;
        -: 4526:            }
        -: 4527:          }
        -: 4528:
    #####: 4529:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4530:          continue;
        -: 4531:        }
    #####: 4532:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4533:        {
    #####: 4534:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4535:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4536:
    #####: 4537:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4538:
    #####: 4539:          vm_stack_found_type type =
    #####: 4540:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, (uint32_t) branch_offset);
    #####: 4541:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4542:          switch (type)
        -: 4543:          {
    #####: 4544:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4545:            {
    #####: 4546:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4547:
    #####: 4548:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4549:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4550:              break;
        -: 4551:            }
        -: 4552:#if JERRY_ESNEXT
    #####: 4553:            case VM_CONTEXT_FOUND_ERROR:
        -: 4554:            {
    #####: 4555:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4556:              result = ECMA_VALUE_ERROR;
    #####: 4557:              goto error;
        -: 4558:            }
    #####: 4559:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4560:            {
    #####: 4561:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4562:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4563:              return ECMA_VALUE_UNDEFINED;
        -: 4564:            }
        -: 4565:#endif /* JERRY_ESNEXT */
    #####: 4566:            default:
        -: 4567:            {
    #####: 4568:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4569:              break;
        -: 4570:            }
        -: 4571:          }
        -: 4572:
    #####: 4573:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4574:          continue;
        -: 4575:        }
        -: 4576:#if JERRY_MODULE_SYSTEM
    #####: 4577:        case VM_OC_MODULE_IMPORT:
        -: 4578:        {
    #####: 4579:          left_value = *(--stack_top_p);
        -: 4580:
    #####: 4581:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4582:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4583:
        -: 4584:#if JERRY_SNAPSHOT_EXEC
    #####: 4585:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4586:          {
        -: 4587:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4588:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4589:
    #####: 4590:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4591:            {
    #####: 4592:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4593:            }
        -: 4594:#if JERRY_SNAPSHOT_EXEC
        -: 4595:          }
        -: 4596:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4597:
    #####: 4598:          result = ecma_module_import (left_value, user_value);
    #####: 4599:          ecma_free_value (left_value);
        -: 4600:
    #####: 4601:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4602:          {
    #####: 4603:            goto error;
        -: 4604:          }
        -: 4605:
    #####: 4606:          *stack_top_p++ = result;
    #####: 4607:          continue;
        -: 4608:        }
    #####: 4609:        case VM_OC_MODULE_IMPORT_META:
        -: 4610:        {
    #####: 4611:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4612:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4613:
    #####: 4614:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4615:
    #####: 4616:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4617:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4618:
    #####: 4619:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4620:          {
    #####: 4621:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4622:
    #####: 4623:            ecma_value_t module = import_meta;
    #####: 4624:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4625:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4626:
    #####: 4627:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4628:            {
    #####: 4629:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4630:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4631:            }
        -: 4632:
    #####: 4633:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4634:          }
        -: 4635:          else
        -: 4636:          {
    #####: 4637:            ecma_ref_object (import_meta_object_p);
        -: 4638:          }
        -: 4639:
    #####: 4640:          *stack_top_p++ = import_meta;
    #####: 4641:          continue;
        -: 4642:        }
        -: 4643:#endif /* JERRY_MODULE_SYSTEM */
        -: 4644:#if JERRY_DEBUGGER
        -: 4645:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4646:        {
        -: 4647:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4648:          {
        -: 4649:            continue;
        -: 4650:          }
        -: 4651:
        -: 4652:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4653:
        -: 4654:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4655:
        -: 4656:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4657:
        -: 4658:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4659:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4660:          {
        -: 4661:            result = ECMA_VALUE_ERROR;
        -: 4662:            goto error;
        -: 4663:          }
        -: 4664:          continue;
        -: 4665:        }
        -: 4666:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4667:        {
        -: 4668:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4669:          {
        -: 4670:            continue;
        -: 4671:          }
        -: 4672:
        -: 4673:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4674:
        -: 4675:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4676:
        -: 4677:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4678:
        -: 4679:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4680:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4681:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4682:          {
        -: 4683:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4684:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4685:            {
        -: 4686:              result = ECMA_VALUE_ERROR;
        -: 4687:              goto error;
        -: 4688:            }
        -: 4689:            continue;
        -: 4690:          }
        -: 4691:
        -: 4692:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4693:          {
        -: 4694:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4695:            continue;
        -: 4696:          }
        -: 4697:
        -: 4698:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4699:
        -: 4700:          if (jerry_debugger_receive (NULL))
        -: 4701:          {
        -: 4702:            continue;
        -: 4703:          }
        -: 4704:
        -: 4705:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4706:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4707:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4708:          {
        -: 4709:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4710:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4711:            {
        -: 4712:              result = ECMA_VALUE_ERROR;
        -: 4713:              goto error;
        -: 4714:            }
        -: 4715:          }
        -: 4716:          continue;
        -: 4717:        }
        -: 4718:#endif /* JERRY_DEBUGGER */
    #####: 4719:        case VM_OC_NONE:
        -: 4720:        default:
        -: 4721:        {
    #####: 4722:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4723:
    #####: 4724:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4725:        }
        -: 4726:      }
        -: 4727:
        2: 4728:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4729:
        2: 4730:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4731:      {
        -: 4732:        uint16_t literal_index;
        -: 4733:
    #####: 4734:        READ_LITERAL_INDEX (literal_index);
        -: 4735:
    #####: 4736:        if (literal_index < register_end)
        -: 4737:        {
    #####: 4738:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4739:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4740:
    #####: 4741:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4742:          {
    #####: 4743:            result = ecma_fast_copy_value (result);
        -: 4744:          }
        -: 4745:        }
        -: 4746:        else
        -: 4747:        {
    #####: 4748:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4749:
    #####: 4750:          ecma_value_t put_value_result =
    #####: 4751:            ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p, var_name_str_p, is_strict, result);
        -: 4752:
    #####: 4753:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4754:          {
    #####: 4755:            ecma_free_value (result);
    #####: 4756:            result = put_value_result;
    #####: 4757:            goto error;
        -: 4758:          }
        -: 4759:
    #####: 4760:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4761:          {
    #####: 4762:            ecma_fast_free_value (result);
        -: 4763:          }
        -: 4764:        }
        -: 4765:      }
        2: 4766:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4767:      {
    #####: 4768:        ecma_value_t property = *(--stack_top_p);
    #####: 4769:        ecma_value_t base = *(--stack_top_p);
        -: 4770:
    #####: 4771:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4772:        {
    #####: 4773:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 4774:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 4775:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4776:
    #####: 4777:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4778:          {
    #####: 4779:            goto free_both_values;
        -: 4780:          }
    #####: 4781:          result = ecma_fast_copy_value (result);
        -: 4782:        }
        -: 4783:        else
        -: 4784:        {
    #####: 4785:          ecma_value_t set_value_result = vm_op_set_value (base, property, result, is_strict);
        -: 4786:
    #####: 4787:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4788:          {
    #####: 4789:            ecma_free_value (result);
    #####: 4790:            result = set_value_result;
    #####: 4791:            goto error;
        -: 4792:          }
        -: 4793:
    #####: 4794:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4795:          {
    #####: 4796:            ecma_fast_free_value (result);
    #####: 4797:            goto free_both_values;
        -: 4798:          }
        -: 4799:        }
        -: 4800:      }
        -: 4801:
        2: 4802:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4803:      {
        2: 4804:        *stack_top_p++ = result;
        -: 4805:      }
    #####: 4806:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4807:      {
    #####: 4808:        ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 4809:        VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 4810:      }
        -: 4811:
        2: 4812:free_both_values:
        2: 4813:      ecma_fast_free_value (right_value);
        2: 4814:free_left_value:
        2: 4815:      ecma_fast_free_value (left_value);
        -: 4816:    }
        -: 4817:
    #####: 4818:error:
    #####: 4819:    ecma_fast_free_value (left_value);
    #####: 4820:    ecma_fast_free_value (right_value);
        -: 4821:
    #####: 4822:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4823:    {
    #####: 4824:      JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4825:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4826:
    #####: 4827:      while (stack_top_p > stack_bottom_p)
        -: 4828:      {
    #####: 4829:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4830:#if JERRY_ESNEXT
    #####: 4831:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4832:        {
    #####: 4833:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4834:          continue;
        -: 4835:        }
        -: 4836:#endif /* JERRY_ESNEXT */
    #####: 4837:        ecma_fast_free_value (stack_item);
        -: 4838:      }
        -: 4839:
        -: 4840:#if JERRY_VM_THROW
    #####: 4841:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4842:      {
    #####: 4843:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4844:
    #####: 4845:        jerry_throw_cb_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4846:
    #####: 4847:        if (vm_throw_callback_p != NULL)
        -: 4848:        {
    #####: 4849:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4850:        }
        -: 4851:      }
        -: 4852:#endif /* JERRY_VM_THROW */
        -: 4853:
        -: 4854:#if JERRY_DEBUGGER
        -: 4855:      const uint32_t dont_stop =
        -: 4856:        (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION | JERRY_DEBUGGER_VM_IGNORE | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4857:
        -: 4858:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4859:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4860:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4861:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4862:      {
        -: 4863:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4864:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4865:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4866:
        -: 4867:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4868:        {
        -: 4869:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4870:
        -: 4871:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4872:          {
        -: 4873:            ecma_free_value (current_error_value);
        -: 4874:          }
        -: 4875:          else
        -: 4876:          {
        -: 4877:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4878:          }
        -: 4879:
        -: 4880:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4881:        }
        -: 4882:      }
        -: 4883:#endif /* JERRY_DEBUGGER */
        -: 4884:    }
        -: 4885:
    #####: 4886:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4887:
    #####: 4888:    if (frame_ctx_p->context_depth == 0)
        -: 4889:    {
        -: 4890:      /* In most cases there is no context. */
    #####: 4891:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4892:      return result;
        -: 4893:    }
        -: 4894:
    #####: 4895:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4896:    {
    #####: 4897:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_RETURN, 0))
        -: 4898:      {
    #####: 4899:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4900:        {
    #####: 4901:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4902:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4903:
    #####: 4904:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4905:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4906:          stack_top_p[-2] = result;
    #####: 4907:          continue;
        -: 4908:        }
        -: 4909:#if JERRY_ESNEXT
    #####: 4910:        case VM_CONTEXT_FOUND_ERROR:
        -: 4911:        {
    #####: 4912:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4913:
    #####: 4914:          ecma_free_value (result);
    #####: 4915:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4916:          result = ECMA_VALUE_ERROR;
    #####: 4917:          break;
        -: 4918:        }
    #####: 4919:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4920:        {
    #####: 4921:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4922:
    #####: 4923:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4924:          stack_top_p[-2] = result;
    #####: 4925:          return ECMA_VALUE_UNDEFINED;
        -: 4926:        }
        -: 4927:#endif /* JERRY_ESNEXT */
    #####: 4928:        default:
        -: 4929:        {
    #####: 4930:          goto finish;
        -: 4931:        }
        -: 4932:      }
    #####: 4933:    }
        -: 4934:
    #####: 4935:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4936:
    #####: 4937:    if (!jcontext_has_pending_abort ())
        -: 4938:    {
    #####: 4939:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_THROW, 0))
        -: 4940:      {
    #####: 4941:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4942:        {
    #####: 4943:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4944:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4945:
    #####: 4946:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4947:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4948:
        -: 4949:#if JERRY_DEBUGGER
        -: 4950:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4951:#endif /* JERRY_DEBUGGER */
        -: 4952:
    #####: 4953:          result = jcontext_take_exception ();
        -: 4954:
    #####: 4955:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4956:          {
    #####: 4957:            stack_top_p[-2] = result;
    #####: 4958:            continue;
        -: 4959:          }
        -: 4960:
    #####: 4961:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4962:
    #####: 4963:          *stack_top_p++ = result;
    #####: 4964:          continue;
        -: 4965:        }
        -: 4966:#if JERRY_ESNEXT
    #####: 4967:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4968:        {
    #####: 4969:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4970:          return ECMA_VALUE_UNDEFINED;
        -: 4971:        }
        -: 4972:#endif /* JERRY_ESNEXT */
    #####: 4973:        default:
        -: 4974:        {
    #####: 4975:          break;
        -: 4976:        }
        -: 4977:      }
        -: 4978:    }
        -: 4979:    else
        -: 4980:    {
        -: 4981:      do
        -: 4982:      {
    #####: 4983:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4984:
    #####: 4985:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
    #####: 4986:      } while (frame_ctx_p->context_depth > 0);
        -: 4987:    }
        -: 4988:
    #####: 4989:finish:
    #####: 4990:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4991:    return result;
        -: 4992:  }
        -: 4993:} /* vm_loop */
        -: 4994:
        -: 4995:#if JERRY_MODULE_SYSTEM
        -: 4996:
        -: 4997:/**
        -: 4998: * Create and initialize module scope with all data properties
        -: 4999: *
        -: 5000: * @return ECMA_VALUE_EMPTY on success,
        -: 5001: *         ECMA_VALUE_ERROR on failure
        -: 5002: */
        -: 5003:ecma_value_t
    #####: 5004:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5005:{
        -: 5006:  ecma_object_t *global_object_p;
        -: 5007:#if JERRY_BUILTIN_REALMS
    #####: 5008:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5009:#else /* !JERRY_BUILTIN_REALMS */
        -: 5010:  global_object_p = ecma_builtin_get_global ();
        -: 5011:#endif /* JERRY_BUILTIN_REALMS */
        -: 5012:
    #####: 5013:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5014:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5015:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5016:  ecma_value_t *literal_start_p;
        -: 5017:  uint8_t *byte_code_p;
        -: 5018:  uint16_t encoding_limit;
        -: 5019:  uint16_t encoding_delta;
        -: 5020:
    #####: 5021:  ((ecma_lexical_environment_class_t *) scope_p)->object_p = (ecma_object_t *) module_p;
    #####: 5022:  ((ecma_lexical_environment_class_t *) scope_p)->type = ECMA_LEX_ENV_CLASS_TYPE_MODULE;
        -: 5023:
    #####: 5024:  module_p->scope_p = scope_p;
    #####: 5025:  ecma_deref_object (scope_p);
        -: 5026:
    #####: 5027:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5028:  {
    #####: 5029:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5030:
    #####: 5031:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5032:    literal_start_p -= args_p->register_end;
    #####: 5033:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5034:  }
        -: 5035:  else
        -: 5036:  {
    #####: 5037:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5038:
    #####: 5039:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5040:    literal_start_p -= args_p->register_end;
    #####: 5041:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5042:  }
        -: 5043:
        -: 5044:  /* Prepare for byte code execution. */
    #####: 5045:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5046:  {
    #####: 5047:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5048:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5049:  }
        -: 5050:  else
        -: 5051:  {
    #####: 5052:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5053:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5054:  }
        -: 5055:
    #####: 5056:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5057:
    #####: 5058:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5059:
        -: 5060:  while (true)
    #####: 5061:  {
    #####: 5062:    uint8_t opcode = *byte_code_p++;
        -: 5063:
    #####: 5064:    switch (opcode)
        -: 5065:    {
    #####: 5066:      case CBC_CREATE_VAR:
        -: 5067:      case CBC_CREATE_LET:
        -: 5068:      case CBC_CREATE_CONST:
        -: 5069:      {
        -: 5070:        uint32_t literal_index;
        -: 5071:
    #####: 5072:        READ_LITERAL_INDEX (literal_index);
        -: 5073:
    #####: 5074:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5075:
    #####: 5076:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5077:
    #####: 5078:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5079:
    #####: 5080:        if (opcode == CBC_CREATE_LET)
        -: 5081:        {
    #####: 5082:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5083:        }
    #####: 5084:        else if (opcode == CBC_CREATE_CONST)
        -: 5085:        {
    #####: 5086:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5087:        }
        -: 5088:
        -: 5089:        ecma_property_value_t *property_value_p;
    #####: 5090:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5091:
    #####: 5092:        if (opcode != CBC_CREATE_VAR)
        -: 5093:        {
    #####: 5094:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5095:        }
    #####: 5096:        break;
        -: 5097:      }
    #####: 5098:      case CBC_INIT_ARG_OR_FUNC:
        -: 5099:      {
        -: 5100:        uint32_t literal_index;
        -: 5101:
    #####: 5102:        READ_LITERAL_INDEX (literal_index);
        -: 5103:
        -: 5104:        ecma_compiled_code_t *function_bytecode_p;
        -: 5105:#if JERRY_SNAPSHOT_EXEC
    #####: 5106:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5107:        {
        -: 5108:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5109:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[literal_index]);
        -: 5110:#if JERRY_SNAPSHOT_EXEC
        -: 5111:        }
        -: 5112:        else
        -: 5113:        {
    #####: 5114:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5115:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5116:        }
        -: 5117:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5118:
    #####: 5119:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5120:
        -: 5121:        ecma_object_t *function_obj_p;
        -: 5122:
    #####: 5123:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5124:        {
    #####: 5125:          function_obj_p = ecma_op_create_arrow_function_object (scope_p, function_bytecode_p, ECMA_VALUE_UNDEFINED);
        -: 5126:        }
        -: 5127:        else
        -: 5128:        {
    #####: 5129:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5130:        }
        -: 5131:
    #####: 5132:        READ_LITERAL_INDEX (literal_index);
    #####: 5133:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5134:
    #####: 5135:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5136:
        -: 5137:        ecma_property_value_t *property_value_p;
    #####: 5138:        property_value_p = ecma_create_named_data_property (scope_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 5139:
    #####: 5140:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5141:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5142:        ecma_deref_object (function_obj_p);
    #####: 5143:        break;
        -: 5144:      }
    #####: 5145:      default:
        -: 5146:      {
    #####: 5147:        JERRY_ASSERT (opcode == CBC_RETURN_FUNCTION_END);
    #####: 5148:        return ECMA_VALUE_EMPTY;
        -: 5149:      }
        -: 5150:    }
        -: 5151:  }
        -: 5152:} /* vm_init_module_scope */
        -: 5153:
        -: 5154:#endif /* JERRY_MODULE_SYSTEM */
        -: 5155:
        -: 5156:#undef READ_LITERAL
        -: 5157:#undef READ_LITERAL_INDEX
        -: 5158:
        -: 5159:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5160:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5161:
        -: 5162:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5163:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5164:
        -: 5165:/**
        -: 5166: * Initialize code block execution
        -: 5167: *
        -: 5168: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5169: *         ECMA_VALUE_EMPTY - otherwise
        -: 5170: */
        -: 5171:static void JERRY_ATTR_NOINLINE
        1: 5172:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5173:{
        1: 5174:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        1: 5175:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5176:
        1: 5177:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
        1: 5178:  frame_ctx_p->context_depth = 0;
        2: 5179:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
        1: 5180:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5181:
        -: 5182:  uint16_t argument_end, register_end;
        -: 5183:  ecma_value_t *literal_p;
        -: 5184:
        1: 5185:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5186:  {
    #####: 5187:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5188:
    #####: 5189:    argument_end = args_p->argument_end;
    #####: 5190:    register_end = args_p->register_end;
        -: 5191:
    #####: 5192:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5193:    literal_p -= register_end;
    #####: 5194:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5195:    literal_p += args_p->literal_end;
        -: 5196:  }
        -: 5197:  else
        -: 5198:  {
        1: 5199:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5200:
        1: 5201:    argument_end = args_p->argument_end;
        1: 5202:    register_end = args_p->register_end;
        -: 5203:
        1: 5204:    literal_p = (ecma_value_t *) (args_p + 1);
        1: 5205:    literal_p -= register_end;
        1: 5206:    frame_ctx_p->literal_start_p = literal_p;
        1: 5207:    literal_p += args_p->literal_end;
        -: 5208:  }
        -: 5209:
        1: 5210:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
        1: 5211:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
        1: 5212:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5213:
        1: 5214:  uint32_t arg_list_len = 0;
        -: 5215:
        1: 5216:  if (argument_end > 0)
        -: 5217:  {
    #####: 5218:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5219:
    #####: 5220:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 5221:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5222:
    #####: 5223:    if (arg_list_len > argument_end)
        -: 5224:    {
    #####: 5225:      arg_list_len = argument_end;
        -: 5226:    }
        -: 5227:
    #####: 5228:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5229:    {
    #####: 5230:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5231:    }
        -: 5232:  }
        -: 5233:
        -: 5234:  /* The arg_list_len contains the end of the copied arguments.
        -: 5235:   * Fill everything else with undefined. */
        1: 5236:  if (register_end > arg_list_len)
        -: 5237:  {
        1: 5238:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5239:
        2: 5240:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5241:    {
        1: 5242:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5243:    }
        -: 5244:  }
        -: 5245:
        1: 5246:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        1: 5247:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
        1: 5248:} /* vm_init_exec */
        -: 5249:
        -: 5250:/**
        -: 5251: * Resume execution of a code block.
        -: 5252: *
        -: 5253: * @return ecma value
        -: 5254: */
        -: 5255:ecma_value_t JERRY_ATTR_NOINLINE
        3: 5256:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5257:{
        -: 5258:  while (true)
        2: 5259:  {
        3: 5260:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5261:
        3: 5262:    switch (frame_ctx_p->call_operation)
        -: 5263:    {
        2: 5264:      case VM_EXEC_CALL:
        -: 5265:      {
        2: 5266:        opfunc_call (frame_ctx_p);
        1: 5267:        break;
        -: 5268:      }
        -: 5269:#if JERRY_ESNEXT
    #####: 5270:      case VM_EXEC_SUPER_CALL:
        -: 5271:      {
    #####: 5272:        vm_super_call (frame_ctx_p);
    #####: 5273:        break;
        -: 5274:      }
    #####: 5275:      case VM_EXEC_SPREAD_OP:
        -: 5276:      {
    #####: 5277:        vm_spread_operation (frame_ctx_p);
    #####: 5278:        break;
        -: 5279:      }
    #####: 5280:      case VM_EXEC_RETURN:
        -: 5281:      {
    #####: 5282:        return completion_value;
        -: 5283:      }
        -: 5284:#endif /* JERRY_ESNEXT */
        1: 5285:      case VM_EXEC_CONSTRUCT:
        -: 5286:      {
        1: 5287:        opfunc_construct (frame_ctx_p);
        1: 5288:        break;
        -: 5289:      }
    #####: 5290:      default:
        -: 5291:      {
    #####: 5292:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5293:
    #####: 5294:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5295:        uint32_t register_end;
        -: 5296:
    #####: 5297:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5298:        {
    #####: 5299:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5300:        }
        -: 5301:        else
        -: 5302:        {
    #####: 5303:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5304:        }
        -: 5305:
        -: 5306:        /* Free arguments and registers */
    #####: 5307:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
    #####: 5308:        for (uint32_t i = 0; i < register_end; i++)
        -: 5309:        {
    #####: 5310:          ecma_fast_free_value (registers_p[i]);
        -: 5311:        }
        -: 5312:
        -: 5313:#if JERRY_DEBUGGER
        -: 5314:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5315:        {
        -: 5316:          /* The engine will stop when the next breakpoint is reached. */
        -: 5317:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5318:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5319:        }
        -: 5320:#endif /* JERRY_DEBUGGER */
        -: 5321:
    #####: 5322:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
    #####: 5323:        return completion_value;
        -: 5324:      }
        -: 5325:    }
        -: 5326:  }
        -: 5327:} /* vm_execute */
        -: 5328:
        -: 5329:/**
        -: 5330: * Run the code.
        -: 5331: *
        -: 5332: * @return ecma value
        -: 5333: */
        -: 5334:ecma_value_t
        1: 5335:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5336:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5337:        ecma_object_t *lex_env_p) /**< lexical environment to use */
        1: 5338:{
        1: 5339:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5340:  vm_frame_ctx_t *frame_ctx_p;
        -: 5341:  size_t frame_size;
        -: 5342:
        1: 5343:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5344:  {
    #####: 5345:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5346:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5347:  }
        -: 5348:  else
        -: 5349:  {
        1: 5350:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        1: 5351:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5352:  }
        -: 5353:
        1: 5354:  JERRY_VLA (ecma_value_t, stack, frame_size + (sizeof (vm_frame_ctx_t) / sizeof (ecma_value_t)));
        -: 5355:
        1: 5356:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5357:
        1: 5358:  frame_ctx_p->shared_p = shared_p;
        1: 5359:  frame_ctx_p->lex_env_p = lex_env_p;
        1: 5360:  frame_ctx_p->this_binding = this_binding_value;
        -: 5361:
        1: 5362:  vm_init_exec (frame_ctx_p);
        1: 5363:  return vm_execute (frame_ctx_p);
        -: 5364:} /* vm_run */
        -: 5365:
        -: 5366:/**
        -: 5367: * @}
        -: 5368: * @}
        -: 5369: */
