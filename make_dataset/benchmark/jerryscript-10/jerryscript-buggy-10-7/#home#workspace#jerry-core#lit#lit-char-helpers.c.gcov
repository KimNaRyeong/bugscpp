        -:    0:Source:/home/workspace/jerry-core/lit/lit-char-helpers.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "lit-char-helpers.h"
        -:   17:
        -:   18:#include "ecma-helpers.h"
        -:   19:
        -:   20:#include "config.h"
        -:   21:#include "lit-strings.h"
        -:   22:#include "lit-unicode-ranges.inc.h"
        -:   23:#if JERRY_ESNEXT
        -:   24:#include "lit-unicode-ranges-sup.inc.h"
        -:   25:#endif /* JERRY_ESNEXT */
        -:   26:
        -:   27:#if JERRY_UNICODE_CASE_CONVERSION
        -:   28:#include "lit-unicode-conversions.inc.h"
        -:   29:#if JERRY_ESNEXT
        -:   30:#include "lit-unicode-conversions-sup.inc.h"
        -:   31:#include "lit-unicode-folding.inc.h"
        -:   32:#endif /* JERRY_ESNEXT */
        -:   33:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:   34:
        -:   35:#define NUM_OF_ELEMENTS(array) (sizeof (array) / sizeof ((array)[0]))
        -:   36:
        -:   37:/**
        -:   38: * Binary search algorithm that searches the a
        -:   39: * character in the given char array.
        -:   40: *
        -:   41: * @return true - if the character is in the given array
        -:   42: *         false - otherwise
        -:   43: */
        -:   44:#define LIT_SEARCH_CHAR_IN_ARRAY_FN(function_name, char_type, array_type)   \
        -:   45:  static bool function_name (char_type c, /**< code unit */                 \
        -:   46:                             const array_type *array, /**< array */         \
        -:   47:                             int size_of_array) /**< length of the array */ \
        -:   48:  {                                                                         \
        -:   49:    int bottom = 0;                                                         \
        -:   50:    int top = size_of_array - 1;                                            \
        -:   51:                                                                            \
        -:   52:    while (bottom <= top)                                                   \
        -:   53:    {                                                                       \
        -:   54:      int middle = (bottom + top) / 2;                                      \
        -:   55:      char_type current = array[middle];                                    \
        -:   56:                                                                            \
        -:   57:      if (current == c)                                                     \
        -:   58:      {                                                                     \
        -:   59:        return true;                                                        \
        -:   60:      }                                                                     \
        -:   61:                                                                            \
        -:   62:      if (c < current)                                                      \
        -:   63:      {                                                                     \
        -:   64:        top = middle - 1;                                                   \
        -:   65:      }                                                                     \
        -:   66:      else                                                                  \
        -:   67:      {                                                                     \
        -:   68:        bottom = middle + 1;                                                \
        -:   69:      }                                                                     \
        -:   70:    }                                                                       \
        -:   71:                                                                            \
        -:   72:    return false;                                                           \
        -:   73:  } /* __function_name */
        -:   74:
    #####:   75:LIT_SEARCH_CHAR_IN_ARRAY_FN (lit_search_char_in_array, ecma_char_t, uint16_t)
        -:   76:
        -:   77:#if JERRY_ESNEXT
    #####:   78:LIT_SEARCH_CHAR_IN_ARRAY_FN (lit_search_codepoint_in_array, lit_code_point_t, uint32_t)
        -:   79:#endif /* JERRY_ESNEXT */
        -:   80:
        -:   81:/**
        -:   82: * Binary search algorithm that searches a character in the given intervals.
        -:   83: * Intervals specifed by two arrays. The first one contains the starting points
        -:   84: * of the intervals, the second one contains the length of them.
        -:   85: *
        -:   86: * @return true - if the the character is included (inclusively) in one of the intervals in the given array
        -:   87: *         false - otherwise
        -:   88: */
        -:   89:#define LIT_SEARCH_CHAR_IN_INTERVAL_ARRAY_FN(function_name, char_type, array_type, interval_type)  \
        -:   90:  static bool function_name (char_type c, /**< code unit */                                        \
        -:   91:                             const array_type *array_sp, /**< array of interval starting points */ \
        -:   92:                             const interval_type *lengths, /**< array of interval lengths */       \
        -:   93:                             int size_of_array) /**< length of the array */                        \
        -:   94:  {                                                                                                \
        -:   95:    int bottom = 0;                                                                                \
        -:   96:    int top = size_of_array - 1;                                                                   \
        -:   97:                                                                                                   \
        -:   98:    while (bottom <= top)                                                                          \
        -:   99:    {                                                                                              \
        -:  100:      int middle = (bottom + top) / 2;                                                             \
        -:  101:      char_type current_sp = array_sp[middle];                                                     \
        -:  102:                                                                                                   \
        -:  103:      if (current_sp <= c && c <= current_sp + lengths[middle])                                    \
        -:  104:      {                                                                                            \
        -:  105:        return true;                                                                               \
        -:  106:      }                                                                                            \
        -:  107:                                                                                                   \
        -:  108:      if (c > current_sp)                                                                          \
        -:  109:      {                                                                                            \
        -:  110:        bottom = middle + 1;                                                                       \
        -:  111:      }                                                                                            \
        -:  112:      else                                                                                         \
        -:  113:      {                                                                                            \
        -:  114:        top = middle - 1;                                                                          \
        -:  115:      }                                                                                            \
        -:  116:    }                                                                                              \
        -:  117:                                                                                                   \
        -:  118:    return false;                                                                                  \
        -:  119:  } /* function_name */
        -:  120:
    #####:  121:LIT_SEARCH_CHAR_IN_INTERVAL_ARRAY_FN (lit_search_char_in_interval_array, ecma_char_t, uint16_t, uint8_t)
        -:  122:
        -:  123:#if JERRY_ESNEXT
    #####:  124:LIT_SEARCH_CHAR_IN_INTERVAL_ARRAY_FN (lit_search_codepoint_in_interval_array, lit_code_point_t, uint32_t, uint16_t)
        -:  125:#endif /* JERRY_ESNEXT */
        -:  126:
        -:  127:/**
        -:  128: * Check if specified character is one of the Whitespace characters including those that fall into
        -:  129: * "Space, Separator" ("Zs") Unicode character category or one of the Line Terminator characters.
        -:  130: *
        -:  131: * @return true - if the character is one of characters, listed in ECMA-262 v5, Table 2,
        -:  132: *         false - otherwise
        -:  133: */
        -:  134:bool
        6:  135:lit_char_is_white_space (lit_code_point_t c) /**< code point */
        -:  136:{
        6:  137:  if (c <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  138:  {
        6:  139:    return (c == LIT_CHAR_SP || (c >= LIT_CHAR_TAB && c <= LIT_CHAR_CR));
        -:  140:  }
        -:  141:
    #####:  142:  if (c == LIT_CHAR_BOM
        -:  143:#if !JERRY_ESNEXT
        -:  144:      /* Mongolian Vowel Separator (u180e) used to be a whitespace character. */
    #####:  145:      || c == LIT_CHAR_MVS
        -:  146:#endif /* !JERRY_ESNEXT */
    #####:  147:      || c == LIT_CHAR_LS || c == LIT_CHAR_PS)
        -:  148:  {
    #####:  149:    return true;
        -:  150:  }
        -:  151:
        -:  152:  return (c <= LIT_UTF16_CODE_UNIT_MAX
    #####:  153:          && ((c >= lit_unicode_white_space_interval_starts[0]
    #####:  154:               && c <= lit_unicode_white_space_interval_starts[0] + lit_unicode_white_space_interval_lengths[0])
    #####:  155:              || lit_search_char_in_array ((ecma_char_t) c,
        -:  156:                                           lit_unicode_white_space_chars,
        -:  157:                                           NUM_OF_ELEMENTS (lit_unicode_white_space_chars))));
        -:  158:} /* lit_char_is_white_space */
        -:  159:
        -:  160:/**
        -:  161: * Check if specified character is one of LineTerminator characters
        -:  162: *
        -:  163: * @return true - if the character is one of characters, listed in ECMA-262 v5, Table 3,
        -:  164: *         false - otherwise
        -:  165: */
        -:  166:bool
    #####:  167:lit_char_is_line_terminator (ecma_char_t c) /**< code unit */
        -:  168:{
    #####:  169:  return (c == LIT_CHAR_LF || c == LIT_CHAR_CR || c == LIT_CHAR_LS || c == LIT_CHAR_PS);
        -:  170:} /* lit_char_is_line_terminator */
        -:  171:
        -:  172:/**
        -:  173: * Check if specified character is a Unicode ID_Start
        -:  174: *
        -:  175: * See also:
        -:  176: *          ECMA-262 v1, 11.6: UnicodeIDStart
        -:  177: *
        -:  178: * @return true - if the codepoint has Unicode property "ID_Start"
        -:  179: *         false - otherwise
        -:  180: */
        -:  181:static bool
    #####:  182:lit_char_is_unicode_id_start (lit_code_point_t code_point) /**< code unit */
        -:  183:{
        -:  184:#if JERRY_ESNEXT
    #####:  185:  if (JERRY_UNLIKELY (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN))
        -:  186:  {
    #####:  187:    return (lit_search_codepoint_in_interval_array (code_point,
        -:  188:                                                    lit_unicode_id_start_interval_starts_sup,
        -:  189:                                                    lit_unicode_id_start_interval_lengths_sup,
        -:  190:                                                    NUM_OF_ELEMENTS (lit_unicode_id_start_interval_starts_sup))
    #####:  191:            || lit_search_codepoint_in_array (code_point,
        -:  192:                                              lit_unicode_id_start_chars_sup,
        -:  193:                                              NUM_OF_ELEMENTS (lit_unicode_id_start_chars_sup)));
        -:  194:  }
        -:  195:#else /* !JERRY_ESNEXT */
        -:  196:  JERRY_ASSERT (code_point < LIT_UTF8_4_BYTE_CODE_POINT_MIN);
        -:  197:#endif /* JERRY_ESNEXT */
        -:  198:
    #####:  199:  ecma_char_t c = (ecma_char_t) code_point;
        -:  200:
    #####:  201:  return (lit_search_char_in_interval_array (c,
        -:  202:                                             lit_unicode_id_start_interval_starts,
        -:  203:                                             lit_unicode_id_start_interval_lengths,
        -:  204:                                             NUM_OF_ELEMENTS (lit_unicode_id_start_interval_starts))
    #####:  205:          || lit_search_char_in_array (c, lit_unicode_id_start_chars, NUM_OF_ELEMENTS (lit_unicode_id_start_chars)));
        -:  206:} /* lit_char_is_unicode_id_start */
        -:  207:
        -:  208:/**
        -:  209: * Check if specified character is a Unicode ID_Continue
        -:  210: *
        -:  211: * See also:
        -:  212: *          ECMA-262 v1, 11.6: UnicodeIDContinue
        -:  213: *
        -:  214: * @return true - if the codepoint has Unicode property "ID_Continue"
        -:  215: *         false - otherwise
        -:  216: */
        -:  217:static bool
    #####:  218:lit_char_is_unicode_id_continue (lit_code_point_t code_point) /**< code unit */
        -:  219:{
        -:  220:  /* Each ID_Start codepoint is ID_Continue as well. */
    #####:  221:  if (lit_char_is_unicode_id_start (code_point))
        -:  222:  {
    #####:  223:    return true;
        -:  224:  }
        -:  225:
        -:  226:#if JERRY_ESNEXT
    #####:  227:  if (JERRY_UNLIKELY (code_point >= LIT_UTF8_4_BYTE_CODE_POINT_MIN))
        -:  228:  {
    #####:  229:    return (lit_search_codepoint_in_interval_array (code_point,
        -:  230:                                                    lit_unicode_id_continue_interval_starts_sup,
        -:  231:                                                    lit_unicode_id_continue_interval_lengths_sup,
        -:  232:                                                    NUM_OF_ELEMENTS (lit_unicode_id_continue_interval_starts_sup))
    #####:  233:            || lit_search_codepoint_in_array (code_point,
        -:  234:                                              lit_unicode_id_continue_chars_sup,
        -:  235:                                              NUM_OF_ELEMENTS (lit_unicode_id_continue_chars_sup)));
        -:  236:  }
        -:  237:#else /* !JERRY_ESNEXT */
        -:  238:  JERRY_ASSERT (code_point < LIT_UTF8_4_BYTE_CODE_POINT_MIN);
        -:  239:#endif /* JERRY_ESNEXT */
        -:  240:
    #####:  241:  ecma_char_t c = (ecma_char_t) code_point;
        -:  242:
        -:  243:  return (
    #####:  244:    lit_search_char_in_interval_array (c,
        -:  245:                                       lit_unicode_id_continue_interval_starts,
        -:  246:                                       lit_unicode_id_continue_interval_lengths,
        -:  247:                                       NUM_OF_ELEMENTS (lit_unicode_id_continue_interval_starts))
    #####:  248:    || lit_search_char_in_array (c, lit_unicode_id_continue_chars, NUM_OF_ELEMENTS (lit_unicode_id_continue_chars)));
        -:  249:} /* lit_char_is_unicode_id_continue */
        -:  250:
        -:  251:/**
        -:  252: * Checks whether the character is a valid identifier start.
        -:  253: *
        -:  254: * @return true if it is.
        -:  255: */
        -:  256:bool
       60:  257:lit_code_point_is_identifier_start (lit_code_point_t code_point) /**< code point */
        -:  258:{
        -:  259:  /* Fast path for ASCII-defined letters. */
       60:  260:  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  261:  {
       60:  262:    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A
       20:  263:             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)
      100:  264:            || code_point == LIT_CHAR_DOLLAR_SIGN || code_point == LIT_CHAR_UNDERSCORE);
        -:  265:  }
        -:  266:
    #####:  267:  return lit_char_is_unicode_id_start (code_point);
        -:  268:} /* lit_code_point_is_identifier_start */
        -:  269:
        -:  270:/**
        -:  271: * Checks whether the character is a valid identifier part.
        -:  272: *
        -:  273: * @return true if it is.
        -:  274: */
        -:  275:bool
       98:  276:lit_code_point_is_identifier_part (lit_code_point_t code_point) /**< code point */
        -:  277:{
        -:  278:  /* Fast path for ASCII-defined letters. */
       98:  279:  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  280:  {
       98:  281:    return ((LEXER_TO_ASCII_LOWERCASE (code_point) >= LIT_CHAR_LOWERCASE_A
       78:  282:             && LEXER_TO_ASCII_LOWERCASE (code_point) <= LIT_CHAR_LOWERCASE_Z)
       20:  283:            || (code_point >= LIT_CHAR_0 && code_point <= LIT_CHAR_9) || code_point == LIT_CHAR_DOLLAR_SIGN
      118:  284:            || code_point == LIT_CHAR_UNDERSCORE);
        -:  285:  }
        -:  286:
    #####:  287:  return lit_char_is_unicode_id_continue (code_point);
        -:  288:} /* lit_code_point_is_identifier_part */
        -:  289:
        -:  290:/**
        -:  291: * Check if specified character is one of OctalDigit characters (ECMA-262 v5, B.1.2)
        -:  292: *
        -:  293: * @return true / false
        -:  294: */
        -:  295:bool
    #####:  296:lit_char_is_octal_digit (ecma_char_t c) /**< code unit */
        -:  297:{
    #####:  298:  return (c >= LIT_CHAR_ASCII_OCTAL_DIGITS_BEGIN && c <= LIT_CHAR_ASCII_OCTAL_DIGITS_END);
        -:  299:} /* lit_char_is_octal_digit */
        -:  300:
        -:  301:/**
        -:  302: * Check if specified character is one of DecimalDigit characters (ECMA-262 v5, 7.8.3)
        -:  303: *
        -:  304: * @return true / false
        -:  305: */
        -:  306:bool
        3:  307:lit_char_is_decimal_digit (ecma_char_t c) /**< code unit */
        -:  308:{
        3:  309:  return (c >= LIT_CHAR_ASCII_DIGITS_BEGIN && c <= LIT_CHAR_ASCII_DIGITS_END);
        -:  310:} /* lit_char_is_decimal_digit */
        -:  311:
        -:  312:/**
        -:  313: * Check if specified character is one of HexDigit characters (ECMA-262 v5, 7.8.3)
        -:  314: *
        -:  315: * @return true / false
        -:  316: */
        -:  317:bool
    #####:  318:lit_char_is_hex_digit (ecma_char_t c) /**< code unit */
        -:  319:{
    #####:  320:  return ((c >= LIT_CHAR_ASCII_DIGITS_BEGIN && c <= LIT_CHAR_ASCII_DIGITS_END)
    #####:  321:          || (LEXER_TO_ASCII_LOWERCASE (c) >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_HEX_BEGIN
    #####:  322:              && LEXER_TO_ASCII_LOWERCASE (c) <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_HEX_END));
        -:  323:} /* lit_char_is_hex_digit */
        -:  324:
        -:  325:#if JERRY_ESNEXT
        -:  326:/**
        -:  327: * Check if specified character is one of BinaryDigits characters (ECMA-262 v6, 11.8.3)
        -:  328: *
        -:  329: * @return true / false
        -:  330: */
        -:  331:bool
    #####:  332:lit_char_is_binary_digit (ecma_char_t c) /** code unit */
        -:  333:{
    #####:  334:  return (c == LIT_CHAR_0 || c == LIT_CHAR_1);
        -:  335:} /* lit_char_is_binary_digit */
        -:  336:#endif /* JERRY_ESNEXT */
        -:  337:
        -:  338:/**
        -:  339: * @return radix value
        -:  340: */
        -:  341:uint8_t
    #####:  342:lit_char_to_radix (lit_utf8_byte_t c) /** code unit */
        -:  343:{
    #####:  344:  switch (LEXER_TO_ASCII_LOWERCASE (c))
        -:  345:  {
    #####:  346:    case LIT_CHAR_LOWERCASE_X:
        -:  347:    {
    #####:  348:      return 16;
        -:  349:    }
        -:  350:#if JERRY_ESNEXT
    #####:  351:    case LIT_CHAR_LOWERCASE_O:
        -:  352:    {
    #####:  353:      return 8;
        -:  354:    }
    #####:  355:    case LIT_CHAR_LOWERCASE_B:
        -:  356:    {
    #####:  357:      return 2;
        -:  358:    }
        -:  359:#endif /* JERRY_ESNEXT */
    #####:  360:    default:
        -:  361:    {
    #####:  362:      return 10;
        -:  363:    }
        -:  364:  }
        -:  365:} /* lit_char_to_radix */
        -:  366:
        -:  367:/**
        -:  368: * UnicodeEscape abstract method
        -:  369: *
        -:  370: * See also: ECMA-262 v10, 24.5.2.3
        -:  371: */
        -:  372:void
    #####:  373:lit_char_unicode_escape (ecma_stringbuilder_t *builder_p, /**< stringbuilder to append */
        -:  374:                         ecma_char_t c) /**< code unit to convert */
        -:  375:{
    #####:  376:  ecma_stringbuilder_append_raw (builder_p, (lit_utf8_byte_t *) "\\u", 2);
        -:  377:
    #####:  378:  for (int8_t i = 3; i >= 0; i--)
        -:  379:  {
    #####:  380:    int32_t result_char = (c >> (i * 4)) & 0xF;
    #####:  381:    ecma_stringbuilder_append_byte (
        -:  382:      builder_p,
    #####:  383:      (lit_utf8_byte_t) (result_char + (result_char <= 9 ? LIT_CHAR_0 : (LIT_CHAR_LOWERCASE_A - 10))));
        -:  384:  }
    #####:  385:} /* lit_char_unicode_escape */
        -:  386:
        -:  387:/**
        -:  388: * Convert a HexDigit character to its numeric value, as defined in ECMA-262 v5, 7.8.3
        -:  389: *
        -:  390: * @return digit value, corresponding to the hex char
        -:  391: */
        -:  392:uint32_t
    #####:  393:lit_char_hex_to_int (ecma_char_t c) /**< code unit, corresponding to
        -:  394:                                     *    one of HexDigit characters */
        -:  395:{
    #####:  396:  JERRY_ASSERT (lit_char_is_hex_digit (c));
        -:  397:
    #####:  398:  if (c >= LIT_CHAR_ASCII_DIGITS_BEGIN && c <= LIT_CHAR_ASCII_DIGITS_END)
        -:  399:  {
    #####:  400:    return (uint32_t) (c - LIT_CHAR_ASCII_DIGITS_BEGIN);
        -:  401:  }
        -:  402:
    #####:  403:  const uint32_t hex_offset = 10 - (LIT_CHAR_LOWERCASE_A % 32);
    #####:  404:  return (c % 32) + hex_offset;
        -:  405:} /* lit_char_hex_to_int */
        -:  406:
        -:  407:/**
        -:  408: * Converts a character to UTF8 bytes.
        -:  409: *
        -:  410: * @return length of the UTF8 representation.
        -:  411: */
        -:  412:size_t
    #####:  413:lit_code_point_to_cesu8_bytes (uint8_t *dst_p, /**< destination buffer */
        -:  414:                               lit_code_point_t code_point) /**< code point */
        -:  415:{
    #####:  416:  if (code_point < LIT_UTF8_2_BYTE_CODE_POINT_MIN)
        -:  417:  {
        -:  418:    /* 00000000 0xxxxxxx -> 0xxxxxxx */
    #####:  419:    dst_p[0] = (uint8_t) code_point;
    #####:  420:    return 1;
        -:  421:  }
        -:  422:
    #####:  423:  if (code_point < LIT_UTF8_3_BYTE_CODE_POINT_MIN)
        -:  424:  {
        -:  425:    /* 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx */
    #####:  426:    dst_p[0] = (uint8_t) (LIT_UTF8_2_BYTE_MARKER | ((code_point >> 6) & LIT_UTF8_LAST_5_BITS_MASK));
    #####:  427:    dst_p[1] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | (code_point & LIT_UTF8_LAST_6_BITS_MASK));
    #####:  428:    return 2;
        -:  429:  }
        -:  430:
    #####:  431:  if (code_point < LIT_UTF8_4_BYTE_CODE_POINT_MIN)
        -:  432:  {
        -:  433:    /* zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx */
    #####:  434:    dst_p[0] = (uint8_t) (LIT_UTF8_3_BYTE_MARKER | ((code_point >> 12) & LIT_UTF8_LAST_4_BITS_MASK));
    #####:  435:    dst_p[1] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | ((code_point >> 6) & LIT_UTF8_LAST_6_BITS_MASK));
    #####:  436:    dst_p[2] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | (code_point & LIT_UTF8_LAST_6_BITS_MASK));
    #####:  437:    return 3;
        -:  438:  }
        -:  439:
    #####:  440:  JERRY_ASSERT (code_point <= LIT_UNICODE_CODE_POINT_MAX);
        -:  441:
    #####:  442:  code_point -= LIT_UTF8_4_BYTE_CODE_POINT_MIN;
        -:  443:
    #####:  444:  dst_p[0] = (uint8_t) (LIT_UTF8_3_BYTE_MARKER | 0xd);
    #####:  445:  dst_p[1] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | 0x20 | ((code_point >> 16) & LIT_UTF8_LAST_4_BITS_MASK));
    #####:  446:  dst_p[2] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | ((code_point >> 10) & LIT_UTF8_LAST_6_BITS_MASK));
        -:  447:
    #####:  448:  dst_p[3] = (uint8_t) (LIT_UTF8_3_BYTE_MARKER | 0xd);
    #####:  449:  dst_p[4] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | 0x30 | ((code_point >> 6) & LIT_UTF8_LAST_4_BITS_MASK));
    #####:  450:  dst_p[5] = (uint8_t) (LIT_UTF8_EXTRA_BYTE_MARKER | (code_point & LIT_UTF8_LAST_6_BITS_MASK));
        -:  451:
    #####:  452:  return 3 * 2;
        -:  453:} /* lit_code_point_to_cesu8_bytes */
        -:  454:
        -:  455:/**
        -:  456: * Returns the length of the UTF8 representation of a character.
        -:  457: *
        -:  458: * @return length of the UTF8 representation.
        -:  459: */
        -:  460:size_t
    #####:  461:lit_code_point_get_cesu8_length (lit_code_point_t code_point) /**< code point */
        -:  462:{
    #####:  463:  if (code_point < LIT_UTF8_2_BYTE_CODE_POINT_MIN)
        -:  464:  {
        -:  465:    /* 00000000 0xxxxxxx */
    #####:  466:    return 1;
        -:  467:  }
        -:  468:
    #####:  469:  if (code_point < LIT_UTF8_3_BYTE_CODE_POINT_MIN)
        -:  470:  {
        -:  471:    /* 00000yyy yyxxxxxx */
    #####:  472:    return 2;
        -:  473:  }
        -:  474:
    #####:  475:  if (code_point < LIT_UTF8_4_BYTE_CODE_POINT_MIN)
        -:  476:  {
        -:  477:    /* zzzzyyyy yyxxxxxx */
    #####:  478:    return 3;
        -:  479:  }
        -:  480:
        -:  481:  /* high + low surrogate */
    #####:  482:  return 2 * 3;
        -:  483:} /* lit_code_point_get_cesu8_length */
        -:  484:
        -:  485:/**
        -:  486: * Convert a four byte long utf8 character to two three byte long cesu8 characters
        -:  487: */
        -:  488:void
    #####:  489:lit_four_byte_utf8_char_to_cesu8 (uint8_t *dst_p, /**< destination buffer */
        -:  490:                                  const uint8_t *source_p) /**< source buffer */
        -:  491:{
    #####:  492:  lit_code_point_t code_point = ((((uint32_t) source_p[0]) & LIT_UTF8_LAST_3_BITS_MASK) << 18);
    #####:  493:  code_point |= ((((uint32_t) source_p[1]) & LIT_UTF8_LAST_6_BITS_MASK) << 12);
    #####:  494:  code_point |= ((((uint32_t) source_p[2]) & LIT_UTF8_LAST_6_BITS_MASK) << 6);
    #####:  495:  code_point |= (((uint32_t) source_p[3]) & LIT_UTF8_LAST_6_BITS_MASK);
        -:  496:
    #####:  497:  lit_code_point_to_cesu8_bytes (dst_p, code_point);
    #####:  498:} /* lit_four_byte_utf8_char_to_cesu8 */
        -:  499:
        -:  500:/**
        -:  501: * Lookup hex digits in a buffer
        -:  502: *
        -:  503: * @return UINT32_MAX - if next 'lookup' number of characters do not form a valid hex number
        -:  504: *         value of hex number, otherwise
        -:  505: */
        -:  506:uint32_t
    #####:  507:lit_char_hex_lookup (const lit_utf8_byte_t *buf_p, /**< buffer */
        -:  508:                     const lit_utf8_byte_t *const buf_end_p, /**< buffer end */
        -:  509:                     uint32_t lookup) /**< size of lookup */
        -:  510:{
    #####:  511:  JERRY_ASSERT (lookup <= 4);
        -:  512:
    #####:  513:  if (JERRY_UNLIKELY (buf_p + lookup > buf_end_p))
        -:  514:  {
    #####:  515:    return UINT32_MAX;
        -:  516:  }
        -:  517:
    #####:  518:  uint32_t value = 0;
        -:  519:
    #####:  520:  while (lookup--)
        -:  521:  {
    #####:  522:    lit_utf8_byte_t ch = *buf_p++;
    #####:  523:    if (!lit_char_is_hex_digit (ch))
        -:  524:    {
    #####:  525:      return UINT32_MAX;
        -:  526:    }
        -:  527:
    #####:  528:    value <<= 4;
    #####:  529:    value += lit_char_hex_to_int (ch);
        -:  530:  }
        -:  531:
    #####:  532:  JERRY_ASSERT (value <= LIT_UTF16_CODE_UNIT_MAX);
    #####:  533:  return value;
        -:  534:} /* lit_char_hex_lookup */
        -:  535:
        -:  536:/**
        -:  537: * Parse a decimal number with the value clamped to UINT32_MAX.
        -:  538: *
        -:  539: * @returns uint32_t number
        -:  540: */
        -:  541:uint32_t
    #####:  542:lit_parse_decimal (const lit_utf8_byte_t **buffer_p, /**< [in/out] character buffer */
        -:  543:                   const lit_utf8_byte_t *buffer_end_p) /**< buffer end */
        -:  544:{
    #####:  545:  const lit_utf8_byte_t *current_p = *buffer_p;
    #####:  546:  JERRY_ASSERT (lit_char_is_decimal_digit (*current_p));
        -:  547:
    #####:  548:  uint32_t value = (uint32_t) (*current_p++ - LIT_CHAR_0);
        -:  549:
    #####:  550:  while (current_p < buffer_end_p && lit_char_is_decimal_digit (*current_p))
        -:  551:  {
    #####:  552:    const uint32_t digit = (uint32_t) (*current_p++ - LIT_CHAR_0);
    #####:  553:    uint32_t new_value = value * 10 + digit;
        -:  554:
    #####:  555:    if (JERRY_UNLIKELY (value > UINT32_MAX / 10) || JERRY_UNLIKELY (new_value < value))
        -:  556:    {
    #####:  557:      value = UINT32_MAX;
    #####:  558:      continue;
        -:  559:    }
        -:  560:
    #####:  561:    value = new_value;
        -:  562:  }
        -:  563:
    #####:  564:  *buffer_p = current_p;
    #####:  565:  return value;
        -:  566:} /* lit_parse_decimal */
        -:  567:
        -:  568:/**
        -:  569: * Check if specified character is a word character (part of IsWordChar abstract operation)
        -:  570: *
        -:  571: * See also: ECMA-262 v5, 15.10.2.6 (IsWordChar)
        -:  572: *
        -:  573: * @return true - if the character is a word character
        -:  574: *         false - otherwise
        -:  575: */
        -:  576:bool
    #####:  577:lit_char_is_word_char (lit_code_point_t c) /**< code point */
        -:  578:{
    #####:  579:  return ((c >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && c <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END)
    #####:  580:          || (c >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && c <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)
    #####:  581:          || (c >= LIT_CHAR_ASCII_DIGITS_BEGIN && c <= LIT_CHAR_ASCII_DIGITS_END) || c == LIT_CHAR_UNDERSCORE);
        -:  582:} /* lit_char_is_word_char */
        -:  583:
        -:  584:#if JERRY_UNICODE_CASE_CONVERSION
        -:  585:
        -:  586:/**
        -:  587: * Check if the specified character is in one of those tables which contain bidirectional conversions.
        -:  588: *
        -:  589: * @return codepoint of the converted character if it is found the the tables
        -:  590: *         LIT_INVALID_CP - otherwise.
        -:  591: */
        -:  592:static lit_code_point_t
    #####:  593:lit_search_in_bidirectional_conversion_tables (lit_code_point_t cp, /**< code point */
        -:  594:                                               bool is_lowercase) /**< is lowercase conversion */
        -:  595:{
        -:  596:  /* 1, Check if the specified character is part of the lit_unicode_character_case_ranges_{sup} table. */
        -:  597:  int number_of_case_ranges;
        -:  598:#if JERRY_ESNEXT
    #####:  599:  bool is_supplementary = cp > LIT_UTF16_CODE_UNIT_MAX;
    #####:  600:  if (is_supplementary)
        -:  601:  {
    #####:  602:    number_of_case_ranges = NUM_OF_ELEMENTS (lit_unicode_character_case_ranges_sup);
        -:  603:  }
        -:  604:  else
        -:  605:#endif /* JERRY_ESNEXT */
        -:  606:  {
    #####:  607:    number_of_case_ranges = NUM_OF_ELEMENTS (lit_unicode_character_case_ranges);
        -:  608:  }
        -:  609:
    #####:  610:  int conv_counter = 0;
        -:  611:
    #####:  612:  for (int i = 0; i < number_of_case_ranges; i++)
        -:  613:  {
    #####:  614:    if (i % 2 == 0 && i > 0)
        -:  615:    {
    #####:  616:      conv_counter++;
        -:  617:    }
        -:  618:
        -:  619:    size_t range_length;
        -:  620:    lit_code_point_t start_point;
        -:  621:#if JERRY_ESNEXT
    #####:  622:    if (is_supplementary)
        -:  623:    {
    #####:  624:      range_length = lit_unicode_character_case_range_lengths_sup[conv_counter];
    #####:  625:      start_point = lit_unicode_character_case_ranges_sup[i];
        -:  626:    }
        -:  627:    else
        -:  628:#endif /* JERRY_ESNEXT */
        -:  629:    {
    #####:  630:      range_length = lit_unicode_character_case_range_lengths[conv_counter];
    #####:  631:      start_point = lit_unicode_character_case_ranges[i];
        -:  632:    }
        -:  633:
    #####:  634:    if (start_point > cp || cp >= start_point + range_length)
        -:  635:    {
    #####:  636:      continue;
        -:  637:    }
        -:  638:
    #####:  639:    uint32_t char_dist = (uint32_t) cp - start_point;
        -:  640:    int offset;
    #####:  641:    if (i % 2 == 0)
        -:  642:    {
    #####:  643:      if (!is_lowercase)
        -:  644:      {
    #####:  645:        return cp;
        -:  646:      }
        -:  647:
    #####:  648:      offset = i + 1;
        -:  649:    }
        -:  650:    else
        -:  651:    {
    #####:  652:      if (is_lowercase)
        -:  653:      {
    #####:  654:        return cp;
        -:  655:      }
        -:  656:
    #####:  657:      offset = i - 1;
        -:  658:    }
        -:  659:
        -:  660:#if JERRY_ESNEXT
    #####:  661:    if (is_supplementary)
        -:  662:    {
    #####:  663:      start_point = lit_unicode_character_case_ranges_sup[offset];
        -:  664:    }
        -:  665:    else
        -:  666:#endif /* JERRY_ESNEXT */
        -:  667:    {
    #####:  668:      start_point = lit_unicode_character_case_ranges[offset];
        -:  669:    }
        -:  670:
    #####:  671:    return (lit_code_point_t) (start_point + char_dist);
        -:  672:  }
        -:  673:
        -:  674:  /* Note: After this point based on the latest unicode standard(13.0.0.6) no conversion characters are
        -:  675:     defined for supplementary planes */
        -:  676:#if JERRY_ESNEXT
    #####:  677:  if (is_supplementary)
        -:  678:  {
    #####:  679:    return cp;
        -:  680:  }
        -:  681:#endif /* JERRY_ESNEXT */
        -:  682:
        -:  683:  /* 2, Check if the specified character is part of the character_pair_ranges table. */
    #####:  684:  int bottom = 0;
    #####:  685:  int top = NUM_OF_ELEMENTS (lit_unicode_character_pair_ranges) - 1;
        -:  686:
    #####:  687:  while (bottom <= top)
        -:  688:  {
    #####:  689:    int middle = (bottom + top) / 2;
    #####:  690:    lit_code_point_t current_sp = lit_unicode_character_pair_ranges[middle];
        -:  691:
    #####:  692:    if (current_sp <= cp && cp < current_sp + lit_unicode_character_pair_range_lengths[middle])
        -:  693:    {
    #####:  694:      uint32_t char_dist = (uint32_t) (cp - current_sp);
        -:  695:
    #####:  696:      if ((cp - current_sp) % 2 == 0)
        -:  697:      {
    #####:  698:        return is_lowercase ? (lit_code_point_t) (current_sp + char_dist + 1) : cp;
        -:  699:      }
        -:  700:
    #####:  701:      return is_lowercase ? cp : (lit_code_point_t) (current_sp + char_dist - 1);
        -:  702:    }
        -:  703:
    #####:  704:    if (cp > current_sp)
        -:  705:    {
    #####:  706:      bottom = middle + 1;
        -:  707:    }
        -:  708:    else
        -:  709:    {
    #####:  710:      top = middle - 1;
        -:  711:    }
        -:  712:  }
        -:  713:
        -:  714:  /* 3, Check if the specified character is part of the character_pairs table. */
    #####:  715:  int number_of_character_pairs = NUM_OF_ELEMENTS (lit_unicode_character_pairs);
        -:  716:
    #####:  717:  for (int i = 0; i < number_of_character_pairs; i++)
        -:  718:  {
    #####:  719:    if (cp != lit_unicode_character_pairs[i])
        -:  720:    {
    #####:  721:      continue;
        -:  722:    }
        -:  723:
    #####:  724:    if (i % 2 == 0)
        -:  725:    {
    #####:  726:      return is_lowercase ? lit_unicode_character_pairs[i + 1] : cp;
        -:  727:    }
        -:  728:
    #####:  729:    return is_lowercase ? cp : lit_unicode_character_pairs[i - 1];
        -:  730:  }
        -:  731:
    #####:  732:  return LIT_INVALID_CP;
        -:  733:} /* lit_search_in_bidirectional_conversion_tables */
        -:  734:
        -:  735:/**
        -:  736: * Check if the specified character is in the given conversion table.
        -:  737: *
        -:  738: * @return LIT_MULTIPLE_CU if the converted character consist more than a single code unit
        -:  739: *         converted code point - otherwise
        -:  740: */
        -:  741:static lit_code_point_t
    #####:  742:lit_search_in_conversion_table (ecma_char_t character, /**< code unit */
        -:  743:                                ecma_stringbuilder_t *builder_p, /**< string builder */
        -:  744:                                const ecma_char_t *array, /**< array */
        -:  745:                                const uint8_t *counters) /**< case_values counter */
        -:  746:{
    #####:  747:  int end_point = 0;
        -:  748:
    #####:  749:  for (int i = 0; i < 3; i++)
        -:  750:  {
    #####:  751:    int start_point = end_point;
    #####:  752:    int size_of_case_value = i + 1;
    #####:  753:    end_point += counters[i] * (size_of_case_value + 1);
        -:  754:
    #####:  755:    int bottom = start_point;
    #####:  756:    int top = end_point - size_of_case_value;
        -:  757:
    #####:  758:    while (bottom <= top)
        -:  759:    {
    #####:  760:      int middle = (bottom + top) / 2;
        -:  761:
    #####:  762:      middle -= ((middle - bottom) % (size_of_case_value + 1));
        -:  763:
    #####:  764:      ecma_char_t current = array[middle];
        -:  765:
    #####:  766:      if (current == character)
        -:  767:      {
    #####:  768:        if (builder_p != NULL)
        -:  769:        {
    #####:  770:          ecma_stringbuilder_append_char (builder_p, array[middle + 1]);
        -:  771:
    #####:  772:          if (size_of_case_value > 1)
        -:  773:          {
    #####:  774:            ecma_stringbuilder_append_char (builder_p, array[middle + 2]);
        -:  775:          }
    #####:  776:          if (size_of_case_value > 2)
        -:  777:          {
    #####:  778:            ecma_stringbuilder_append_char (builder_p, array[middle + 3]);
        -:  779:          }
        -:  780:        }
        -:  781:
    #####:  782:        return size_of_case_value == 1 ? array[middle + 1] : LIT_MULTIPLE_CU;
        -:  783:      }
        -:  784:
    #####:  785:      if (character < current)
        -:  786:      {
    #####:  787:        top = middle - (size_of_case_value + 1);
        -:  788:      }
        -:  789:      else
        -:  790:      {
    #####:  791:        bottom = middle + (size_of_case_value + 1);
        -:  792:      }
        -:  793:    }
        -:  794:  }
        -:  795:
    #####:  796:  if (builder_p != NULL)
        -:  797:  {
    #####:  798:    ecma_stringbuilder_append_char (builder_p, character);
        -:  799:  }
        -:  800:
    #####:  801:  return (lit_code_point_t) character;
        -:  802:} /* lit_search_in_conversion_table */
        -:  803:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:  804:
        -:  805:/**
        -:  806: * Append the converted lowercase codeunit sequence of an a given codepoint into the stringbuilder if it is present.
        -:  807: *
        -:  808: * @return LIT_MULTIPLE_CU if the converted codepoint consist more than a single code unit
        -:  809: *         converted code point - otherwise
        -:  810: */
        -:  811:lit_code_point_t
    #####:  812:lit_char_to_lower_case (lit_code_point_t cp, /**< code point */
        -:  813:                        ecma_stringbuilder_t *builder_p) /**< string builder */
        -:  814:{
    #####:  815:  if (cp <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  816:  {
    #####:  817:    if (cp >= LIT_CHAR_UPPERCASE_A && cp <= LIT_CHAR_UPPERCASE_Z)
        -:  818:    {
    #####:  819:      cp = (lit_utf8_byte_t) (cp + (LIT_CHAR_LOWERCASE_A - LIT_CHAR_UPPERCASE_A));
        -:  820:    }
        -:  821:
    #####:  822:    if (builder_p != NULL)
        -:  823:    {
    #####:  824:      ecma_stringbuilder_append_byte (builder_p, (lit_utf8_byte_t) cp);
        -:  825:    }
        -:  826:
    #####:  827:    return cp;
        -:  828:  }
        -:  829:
        -:  830:#if JERRY_UNICODE_CASE_CONVERSION
    #####:  831:  lit_code_point_t lowercase_cp = lit_search_in_bidirectional_conversion_tables (cp, true);
        -:  832:
    #####:  833:  if (lowercase_cp != LIT_INVALID_CP)
        -:  834:  {
    #####:  835:    if (builder_p != NULL)
        -:  836:    {
    #####:  837:      ecma_stringbuilder_append_codepoint (builder_p, lowercase_cp);
        -:  838:    }
        -:  839:
    #####:  840:    return lowercase_cp;
        -:  841:  }
        -:  842:
    #####:  843:  JERRY_ASSERT (cp < LIT_UTF8_4_BYTE_CODE_POINT_MIN);
        -:  844:
    #####:  845:  int num_of_lowercase_ranges = NUM_OF_ELEMENTS (lit_unicode_lower_case_ranges);
        -:  846:
    #####:  847:  for (int i = 0, j = 0; i < num_of_lowercase_ranges; i += 2, j++)
        -:  848:  {
    #####:  849:    JERRY_ASSERT (lit_unicode_lower_case_range_lengths[j] > 0);
    #####:  850:    uint32_t range_length = (uint32_t) (lit_unicode_lower_case_range_lengths[j] - 1);
    #####:  851:    lit_code_point_t start_point = lit_unicode_lower_case_ranges[i];
        -:  852:
    #####:  853:    if (start_point <= cp && cp <= start_point + range_length)
        -:  854:    {
    #####:  855:      lowercase_cp = lit_unicode_lower_case_ranges[i + 1] + (cp - start_point);
    #####:  856:      if (builder_p != NULL)
        -:  857:      {
    #####:  858:        ecma_stringbuilder_append_codepoint (builder_p, lowercase_cp);
        -:  859:      }
        -:  860:
    #####:  861:      return lowercase_cp;
        -:  862:    }
        -:  863:  }
        -:  864:
    #####:  865:  return lit_search_in_conversion_table ((ecma_char_t) cp,
        -:  866:                                         builder_p,
        -:  867:                                         lit_unicode_lower_case_conversions,
        -:  868:                                         lit_unicode_lower_case_conversion_counters);
        -:  869:#else /* !JERRY_UNICODE_CASE_CONVERSION */
        -:  870:  if (builder_p != NULL)
        -:  871:  {
        -:  872:    ecma_stringbuilder_append_codepoint (builder_p, cp);
        -:  873:  }
        -:  874:
        -:  875:  return cp;
        -:  876:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:  877:} /* lit_char_to_lower_case */
        -:  878:
        -:  879:/**
        -:  880: * Append the converted uppercase codeunit sequence of an a given codepoint into the stringbuilder if it is present.
        -:  881: *
        -:  882: * @return LIT_MULTIPLE_CU if the converted codepoint consist more than a single code unit
        -:  883: *         converted code point - otherwise
        -:  884: */
        -:  885:lit_code_point_t
    #####:  886:lit_char_to_upper_case (lit_code_point_t cp, /**< code point */
        -:  887:                        ecma_stringbuilder_t *builder_p) /**< string builder */
        -:  888:{
    #####:  889:  if (cp <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  890:  {
    #####:  891:    if (cp >= LIT_CHAR_LOWERCASE_A && cp <= LIT_CHAR_LOWERCASE_Z)
        -:  892:    {
    #####:  893:      cp = (lit_utf8_byte_t) (cp - (LIT_CHAR_LOWERCASE_A - LIT_CHAR_UPPERCASE_A));
        -:  894:    }
        -:  895:
    #####:  896:    if (builder_p != NULL)
        -:  897:    {
    #####:  898:      ecma_stringbuilder_append_byte (builder_p, (lit_utf8_byte_t) cp);
        -:  899:    }
        -:  900:
    #####:  901:    return cp;
        -:  902:  }
        -:  903:
        -:  904:#if JERRY_UNICODE_CASE_CONVERSION
    #####:  905:  lit_code_point_t uppercase_cp = lit_search_in_bidirectional_conversion_tables (cp, false);
        -:  906:
    #####:  907:  if (uppercase_cp != LIT_INVALID_CP)
        -:  908:  {
    #####:  909:    if (builder_p != NULL)
        -:  910:    {
    #####:  911:      ecma_stringbuilder_append_codepoint (builder_p, uppercase_cp);
        -:  912:    }
        -:  913:
    #####:  914:    return uppercase_cp;
        -:  915:  }
        -:  916:
    #####:  917:  int num_of_upper_case_special_ranges = NUM_OF_ELEMENTS (lit_unicode_upper_case_special_ranges);
        -:  918:
    #####:  919:  for (int i = 0, j = 0; i < num_of_upper_case_special_ranges; i += 3, j++)
        -:  920:  {
    #####:  921:    uint32_t range_length = lit_unicode_upper_case_special_range_lengths[j];
    #####:  922:    ecma_char_t start_point = lit_unicode_upper_case_special_ranges[i];
        -:  923:
    #####:  924:    if (start_point <= cp && cp <= start_point + range_length)
        -:  925:    {
    #####:  926:      if (builder_p != NULL)
        -:  927:      {
    #####:  928:        uppercase_cp = lit_unicode_upper_case_special_ranges[i + 1] + (cp - start_point);
    #####:  929:        ecma_stringbuilder_append_codepoint (builder_p, uppercase_cp);
    #####:  930:        ecma_stringbuilder_append_codepoint (builder_p, lit_unicode_upper_case_special_ranges[i + 2]);
        -:  931:      }
        -:  932:
    #####:  933:      return LIT_MULTIPLE_CU;
        -:  934:    }
        -:  935:  }
        -:  936:
    #####:  937:  return lit_search_in_conversion_table ((ecma_char_t) cp,
        -:  938:                                         builder_p,
        -:  939:                                         lit_unicode_upper_case_conversions,
        -:  940:                                         lit_unicode_upper_case_conversion_counters);
        -:  941:#else /* !JERRY_UNICODE_CASE_CONVERSION */
        -:  942:  if (builder_p != NULL)
        -:  943:  {
        -:  944:    ecma_stringbuilder_append_codepoint (builder_p, cp);
        -:  945:  }
        -:  946:
        -:  947:  return cp;
        -:  948:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:  949:} /* lit_char_to_upper_case */
        -:  950:
        -:  951:#if JERRY_ESNEXT
        -:  952:/*
        -:  953: * Look up whether the character should be folded to the lowercase variant.
        -:  954: *
        -:  955: * @return true, if character should be lowercased
        -:  956: *         false, otherwise
        -:  957: */
        -:  958:bool
    #####:  959:lit_char_fold_to_lower (lit_code_point_t cp) /**< code point */
        -:  960:{
        -:  961:#if JERRY_UNICODE_CASE_CONVERSION
    #####:  962:  return (cp <= LIT_UTF8_1_BYTE_CODE_POINT_MAX || cp > LIT_UTF16_CODE_UNIT_MAX
    #####:  963:          || (!lit_search_char_in_interval_array ((ecma_char_t) cp,
        -:  964:                                                  lit_unicode_folding_skip_to_lower_interval_starts,
        -:  965:                                                  lit_unicode_folding_skip_to_lower_interval_lengths,
        -:  966:                                                  NUM_OF_ELEMENTS (lit_unicode_folding_skip_to_lower_interval_starts))
    #####:  967:              && !lit_search_char_in_array ((ecma_char_t) cp,
        -:  968:                                            lit_unicode_folding_skip_to_lower_chars,
        -:  969:                                            NUM_OF_ELEMENTS (lit_unicode_folding_skip_to_lower_chars))));
        -:  970:#else /* !JERRY_UNICODE_CASE_CONVERSION */
        -:  971:  return true;
        -:  972:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:  973:} /* lit_char_fold_to_lower */
        -:  974:
        -:  975:/*
        -:  976: * Look up whether the character should be folded to the uppercase variant.
        -:  977: *
        -:  978: * @return true, if character should be uppercased
        -:  979: *         false, otherwise
        -:  980: */
        -:  981:bool
    #####:  982:lit_char_fold_to_upper (lit_code_point_t cp) /**< code point */
        -:  983:{
        -:  984:#if JERRY_UNICODE_CASE_CONVERSION
    #####:  985:  return (cp > LIT_UTF8_1_BYTE_CODE_POINT_MAX && cp <= LIT_UTF16_CODE_UNIT_MAX
    #####:  986:          && (lit_search_char_in_interval_array ((ecma_char_t) cp,
        -:  987:                                                 lit_unicode_folding_to_upper_interval_starts,
        -:  988:                                                 lit_unicode_folding_to_upper_interval_lengths,
        -:  989:                                                 NUM_OF_ELEMENTS (lit_unicode_folding_to_upper_interval_starts))
    #####:  990:              || lit_search_char_in_array ((ecma_char_t) cp,
        -:  991:                                           lit_unicode_folding_to_upper_chars,
        -:  992:                                           NUM_OF_ELEMENTS (lit_unicode_folding_to_upper_chars))));
        -:  993:#else /* !JERRY_UNICODE_CASE_CONVERSION */
        -:  994:  return false;
        -:  995:#endif /* JERRY_UNICODE_CASE_CONVERSION */
        -:  996:} /* lit_char_fold_to_upper */
        -:  997:#endif /* JERRY_ESNEXT */
        -:  998:
        -:  999:/**
        -: 1000: * Helper method to find a specific character in a string
        -: 1001: *
        -: 1002: * Used by:
        -: 1003: *         ecma_builtin_string_prototype_object_replace_helper
        -: 1004: *
        -: 1005: * @return true - if the given character is in the string
        -: 1006: *         false - otherwise
        -: 1007: */
        -: 1008:bool
    #####: 1009:lit_find_char_in_string (ecma_string_t *str_p, /**< source string */
        -: 1010:                         lit_utf8_byte_t c) /**< character to find*/
        -: 1011:{
    #####: 1012:  ECMA_STRING_TO_UTF8_STRING (str_p, start_p, start_size);
        -: 1013:
    #####: 1014:  const lit_utf8_byte_t *str_curr_p = start_p;
    #####: 1015:  const lit_utf8_byte_t *str_end_p = start_p + start_size;
    #####: 1016:  bool have_char = false;
        -: 1017:
    #####: 1018:  while (str_curr_p < str_end_p)
        -: 1019:  {
    #####: 1020:    if (*str_curr_p++ == c)
        -: 1021:    {
    #####: 1022:      have_char = true;
    #####: 1023:      break;
        -: 1024:    }
        -: 1025:  }
        -: 1026:
    #####: 1027:  ECMA_FINALIZE_UTF8_STRING (start_p, start_size);
        -: 1028:
    #####: 1029:  return have_char;
        -: 1030:} /* lit_find_char_in_string */
