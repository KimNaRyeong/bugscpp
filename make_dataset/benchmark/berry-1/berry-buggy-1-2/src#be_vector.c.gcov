        -:    0:Source:src/be_vector.c
        -:    0:Graph:./src/be_vector.gcno
        -:    0:Data:./src/be_vector.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_vector.h"
        -:    9:#include "be_mem.h"
        -:   10:#include <string.h>
        -:   11:
        -:   12:/* initialize a vector, the vector structure itself is usually allocated
        -:   13: * on the stack, and the data is allocated from the heap.
        -:   14: **/
       10:   15:void be_vector_init(bvm *vm, bvector *vector, int size)
        -:   16:{
       10:   17:    vector->capacity = 2; /* the default capacity */
       10:   18:    vector->size = size;
       10:   19:    vector->count = 0;
       10:   20:    vector->data = be_malloc(vm, (size_t)vector->capacity * size);
       10:   21:    vector->end = (char*)vector->data - size;
       10:   22:    memset(vector->data, 0, (size_t)vector->capacity * size);
       10:   23:}
        -:   24:
        5:   25:void be_vector_delete(bvm *vm, bvector *vector)
        -:   26:{
        5:   27:    be_free(vm, vector->data, (size_t)vector->capacity * vector->size);
        5:   28:}
        -:   29:
       28:   30:void* be_vector_at(bvector *vector, int index)
        -:   31:{
       28:   32:    return (char*)vector->data + (size_t)index * vector->size;
        -:   33:}
        -:   34:
       78:   35:void be_vector_push(bvm *vm, bvector *vector, void *data)
        -:   36:{
       78:   37:    size_t size = vector->size;
       78:   38:    size_t capacity = vector->capacity;
       78:   39:    size_t count = vector->count++;
       78:   40:    if (count >= capacity) {
       18:   41:        int newcap = be_nextsize(vector->capacity);
       36:   42:        vector->data = be_realloc(vm,
       18:   43:                vector->data, vector->capacity * size, newcap * size);
       18:   44:        vector->end = (char*)vector->data + count * size;
       18:   45:        vector->capacity = newcap;
        -:   46:    } else {
       60:   47:        vector->end = (char*)vector->end + size;
        -:   48:    }
       78:   49:    if (data != NULL) {
       56:   50:        memcpy(vector->end, data, size);
        -:   51:    }
       78:   52:}
        -:   53:
        -:   54:/* clear the expanded portion if the memory expands */
       56:   55:void be_vector_push_c(bvm *vm, bvector *vector, void *data)
        -:   56:{
       56:   57:    int capacity = vector->capacity + 1;
       56:   58:    be_vector_push(vm, vector, data);
       56:   59:    if (vector->capacity > capacity) {
       14:   60:        size_t size = ((size_t)vector->capacity - capacity) * vector->size;
       14:   61:        memset(be_vector_at(vector, capacity), 0, size);
        -:   62:    }
       56:   63:}
        -:   64:
        9:   65:void be_vector_remove_end(bvector *vector)
        -:   66:{
        -:   67:    be_assert(vector->count > 0);
        9:   68:    vector->count--;
        9:   69:    vector->end = (char*)vector->end - vector->size;
        9:   70:}
        -:   71:
        3:   72:void be_vector_resize(bvm *vm, bvector *vector, int count)
        -:   73:{
        3:   74:    size_t size = vector->size;
        -:   75:    be_assert(count >= 0);
        3:   76:    if (count != be_vector_count(vector)) {
        3:   77:        int newcap = be_nextsize(count);
        3:   78:        if (newcap > vector->capacity) { /* extended capacity */
        2:   79:            vector->data = be_realloc(vm,
        1:   80:                vector->data, vector->capacity * size, newcap * size);
        1:   81:            vector->capacity = newcap;
        -:   82:        }
        3:   83:        vector->count = count;
        3:   84:        vector->end = (char*)vector->data + size * ((size_t)count - 1);
        -:   85:    }
        3:   86:}
        -:   87:
        1:   88:void be_vector_clear(bvector *vector)
        -:   89:{
        1:   90:    vector->count = 0;
        1:   91:    vector->end = (char*)vector->data - vector->size;
        1:   92:}
        -:   93:
        -:   94:/* free not used */
        6:   95:void* be_vector_release(bvm *vm, bvector *vector)
        -:   96:{
        6:   97:    size_t size = vector->size;
        6:   98:    int count = be_vector_count(vector);
        6:   99:    if (count == 0) {
        3:  100:        be_free(vm, vector->data, vector->capacity * size);
        3:  101:        vector->capacity = 0;
        3:  102:        vector->data = NULL;
        3:  103:        vector->end = NULL;
        3:  104:    } else if (count < vector->capacity) {
        6:  105:        vector->data = be_realloc(vm,
        3:  106:            vector->data, vector->capacity * size, count * size);
        3:  107:        vector->end = (char*)vector->data + ((size_t)count - 1) * size;
        3:  108:        vector->capacity = count;
        -:  109:    }
        6:  110:    return vector->data;
        -:  111:}
        -:  112:
        -:  113:/* use binary search to find the vector capacity between 0-1024 */
       21:  114:static int binary_search(int value)
        -:  115:{
        -:  116:    static const uint16_t tab[] = {
        -:  117:        0, 2, 4, 6, 8, 10, 12, 14, 16,
        -:  118:        20, 24, 28, 32, 40, 48, 64, 96, 128,
        -:  119:        192, 256, 384, 512, 768, 1024
        -:  120:    };
       21:  121:    const uint16_t *low = tab;
       21:  122:    const uint16_t *high = tab + array_count(tab) - 1;
       85:  123:    while (low <= high) {
       84:  124:        const uint16_t *mid = low + ((high - low) >> 1);
       84:  125:        if (*mid == value) {
       20:  126:            return mid[1];
        -:  127:        }
       64:  128:        if (*mid < value) {
       23:  129:            low = mid + 1;
        -:  130:        } else {
       41:  131:            high = mid - 1;
        -:  132:        }
        -:  133:    }
        1:  134:    return *low;
        -:  135:}
        -:  136:
    #####:  137:static int nextpow(int value)
        -:  138:{
    #####:  139:    value |= value >> 1;
    #####:  140:    value |= value >> 2;
    #####:  141:    value |= value >> 4;
    #####:  142:    value |= value >> 8;
    #####:  143:    value |= value >> 16;
    #####:  144:    return value + 1;
        -:  145:}
        -:  146:
       21:  147:int be_nextsize(int size)
        -:  148:{
       21:  149:    if (size < 1024) {
       21:  150:        return binary_search(size);
        -:  151:    }
    #####:  152:    return nextpow(size);
        -:  153:}
