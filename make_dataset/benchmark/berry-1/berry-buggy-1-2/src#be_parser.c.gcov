        -:    0:Source:src/be_parser.c
        -:    0:Graph:./src/be_parser.gcno
        -:    0:Data:./src/be_parser.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_parser.h"
        -:    9:#include "be_lexer.h"
        -:   10:#include "be_vector.h"
        -:   11:#include "be_mem.h"
        -:   12:#include "be_vm.h"
        -:   13:#include "be_map.h"
        -:   14:#include "be_list.h"
        -:   15:#include "be_var.h"
        -:   16:#include "be_code.h"
        -:   17:#include "be_string.h"
        -:   18:#include "be_func.h"
        -:   19:#include "be_class.h"
        -:   20:#include "be_decoder.h"
        -:   21:#include "be_debug.h"
        -:   22:#include "be_exec.h"
        -:   23:
        -:   24:#define OP_NOT_BINARY           TokenNone
        -:   25:#define OP_NOT_UNARY            TokenNone
        -:   26:#define OP_NOT_ASSIGN           TokenNone
        -:   27:#define UNARY_OP_PRIO           3
        -:   28:#define ASSIGN_OP_PRIO          16
        -:   29:
        -:   30:#define FUNC_METHOD             1
        -:   31:#define FUNC_ANONYMOUS          2
        -:   32:
        -:   33:/* get binary operator priority */
        -:   34:#define binary_op_prio(op)      (binary_op_prio_tab[cast_int(op) - OptAdd])
        -:   35:
        -:   36:#define scan_next_token(parser) (be_lexer_scan_next(&(parser)->lexer))
        -:   37:#define next_token(parser)      ((parser)->lexer.token)
        -:   38:#define next_type(parser)       (next_token(parser).type)
        -:   39:#define max(a, b)               ((a) > (b) ? (a) : (b))
        -:   40:#define token2str(parser)       be_token2str((parser)->vm, &next_token(parser))
        -:   41:#define funcname(parser)        ((parser)->islocal ? "loader" : "main")
        -:   42:
        -:   43:#define upval_index(v)          ((v) & 0xFF)
        -:   44:#define upval_target(v)         ((bbyte)(((v) >> 8) & 0xFF))
        -:   45:#define upval_instack(v)        ((bbyte)(((v) >> 16) != 0))
        -:   46:#define upval_desc(i, t, s)     (((i) & 0xFF) | (((t) & 0xFF) << 8) \
        -:   47:                                | (((s) != 0) << 16))
        -:   48:
        -:   49:#define match_id(parser, s)     ((s) = _match_id(parser))
        -:   50:
        -:   51:#define parser_newstr(p, str)   be_lexer_newstr(&(p)->lexer, (str))
        -:   52:
        -:   53:#define parser_error(p, msg)    be_lexerror(&(p)->lexer, msg)
        -:   54:
        -:   55:#define push_error(parser, ...) \
        -:   56:    parser_error(parser, be_pushfstring(parser->vm, __VA_ARGS__))
        -:   57:
        -:   58:typedef struct {
        -:   59:    blexer lexer;
        -:   60:    bvm *vm;
        -:   61:    bfuncinfo *finfo;
        -:   62:    bclosure *cl;
        -:   63:    bbyte islocal;
        -:   64:} bparser;
        -:   65:
        -:   66:#if BE_USE_SCRIPT_COMPILER
        -:   67:
        -:   68:static void stmtlist(bparser *parser);
        -:   69:static void block(bparser *parser, int type);
        -:   70:static void expr(bparser *parser, bexpdesc *e);
        -:   71:static void sub_expr(bparser *parser, bexpdesc *e, int prio);
        -:   72:
        -:   73:static const bbyte binary_op_prio_tab[] = {
        -:   74:    5, 5, 4, 4, 4, /* + - * / % */
        -:   75:    11, 11, 12, 12, 11, 11, /* < <= == != > >= */
        -:   76:    7, 9, 8, 6, 6, 10, 13, 14 /*  & | ^ << >> .. && || */
        -:   77:};
        -:   78:
        9:   79:static void match_token(bparser *parser, btokentype type)
        -:   80:{
        9:   81:    if (next_type(parser) != type) { /* error when token is no match */
    #####:   82:        btoken *token = &next_token(parser);
    #####:   83:        const char *s1 = be_tokentype2str(type);
    #####:   84:        const char *s2 = be_token2str(parser->vm, token);
    #####:   85:        push_error(parser, "expected '%s' before '%s'", s1, s2);
        -:   86:    }
        9:   87:    scan_next_token(parser); /* skip this token */
        9:   88:}
        -:   89:
        -:   90:/* Check that the next token is not of type `type` */
        -:   91:/* or raise an exception */
    #####:   92:static void match_notoken(bparser *parser, btokentype type)
        -:   93:{
    #####:   94:    if (next_type(parser) == type) { /* error when token is match */
    #####:   95:        push_error(parser,
        -:   96:            "expected statement before '%s'", token2str(parser));
        -:   97:    }
    #####:   98:}
        -:   99:
        -:  100:/* check that if the expdesc is a symbol, it is a valid one or raise an exception */
       58:  101:static void check_symbol(bparser *parser, bexpdesc *e)
        -:  102:{
       58:  103:    if (e->type == ETVOID && e->v.s == NULL) { /* error when token is not a symbol */
    #####:  104:        push_error(parser,
        -:  105:            "unexpected symbol near '%s'", token2str(parser));
        -:  106:    }
       58:  107:}
        -:  108:
        -:  109:/* check that the value in `e` is valid for a variable, i.e. contains a value or a valid symbol */
       49:  110:static void check_var(bparser *parser, bexpdesc *e)
        -:  111:{
       49:  112:    check_symbol(parser, e); /* check the token is a symbol */
       49:  113:    if (e->type == ETVOID) { /* error when symbol is undefined */
    #####:  114:        int line = parser->lexer.linenumber;
    #####:  115:        parser->lexer.linenumber = parser->lexer.lastline;
    #####:  116:        push_error(parser,
        -:  117:            "'%s' undeclared (first use in this function)", str(e->v.s));
    #####:  118:        parser->lexer.linenumber = line;
        -:  119:    }
       49:  120:}
        -:  121:
        8:  122:static int match_skip(bparser *parser, btokentype type)
        -:  123:{
        8:  124:    if (next_type(parser) == type) { /* match */
    #####:  125:        scan_next_token(parser); /* skip this token */
    #####:  126:        return btrue;
        -:  127:    }
        8:  128:    return bfalse;
        -:  129:}
        -:  130:
    #####:  131:static bstring* _match_id(bparser *parser)
        -:  132:{
    #####:  133:    if (next_type(parser) == TokenId) {
    #####:  134:        bstring *str = next_token(parser).u.s;
    #####:  135:        scan_next_token(parser); /* skip ID */
    #####:  136:        return str;
        -:  137:    }
    #####:  138:    return NULL;
        -:  139:}
        -:  140:
        -:  141:#if BE_DEBUG_VAR_INFO
        -:  142:
    #####:  143:void begin_varinfo(bparser *parser, bstring *name)
        -:  144:{
        -:  145:    bvarinfo *var;
    #####:  146:    bfuncinfo *finfo = parser->finfo;
    #####:  147:    be_vector_push_c(parser->vm, &finfo->varvec, NULL);
    #####:  148:    var = be_vector_end(&finfo->varvec);
    #####:  149:    var->name = name;
    #####:  150:    var->beginpc = finfo->pc;
    #####:  151:    var->endpc = 0; /*  */
    #####:  152:    finfo->proto->varinfo = be_vector_data(&finfo->varvec);
    #####:  153:    finfo->proto->nvarinfo = be_vector_capacity(&finfo->varvec);
    #####:  154:}
        -:  155:
        1:  156:void end_varinfo(bparser *parser, int beginpc)
        -:  157:{
        1:  158:    bfuncinfo *finfo = parser->finfo;
        1:  159:    bblockinfo *binfo = finfo->binfo;
        1:  160:    bvarinfo *it = be_vector_data(&finfo->varvec);
        1:  161:    bvarinfo *end = be_vector_end(&finfo->varvec);
        1:  162:    if (beginpc == -1) /* use block->beginpc by default */
        1:  163:        beginpc = binfo->beginpc;
        -:  164:    /* skip the variable of the previous blocks */
       1*:  165:    for (; it->beginpc < beginpc; ++it);
       1*:  166:    for (; it <= end; ++it) {
    #####:  167:        if (!it->endpc) /* write to endpc only once */
    #####:  168:            it->endpc = finfo->pc;
        -:  169:    }
        1:  170:}
        -:  171:
        -:  172:#else
        -:  173:
        -:  174:#define begin_varinfo(parser, name)
        -:  175:#define end_varinfo(parser, beginpc) (void)(beginpc)
        -:  176:
        -:  177:#endif
        -:  178:
        -:  179:/* Initialize bblockinfo structure */
        1:  180:static void begin_block(bfuncinfo *finfo, bblockinfo *binfo, int type)
        -:  181:{
        1:  182:    binfo->prev = finfo->binfo; /* save previous block */
        1:  183:    finfo->binfo = binfo; /* tell parser this is the current block */
        1:  184:    binfo->type = (bbyte)type;
        1:  185:    binfo->hasupval = 0;
        1:  186:    binfo->beginpc = finfo->pc; /* set starting pc for this block */
        1:  187:    binfo->nactlocals = (bbyte)be_list_count(finfo->local); /* count number of local variables in previous block */
        1:  188:    if (type & BLOCK_LOOP) {
    #####:  189:        binfo->breaklist = NO_JUMP;
    #####:  190:        binfo->continuelist = NO_JUMP;
        -:  191:    }
        1:  192:}
        -:  193:
        1:  194:static void end_block_ex(bparser *parser, int beginpc)
        -:  195:{
        1:  196:    bfuncinfo *finfo = parser->finfo;
        1:  197:    bblockinfo *binfo = finfo->binfo;
        1:  198:    be_code_close(finfo, 0); /* close upvalues */
        1:  199:    if (binfo->type & BLOCK_LOOP) {
    #####:  200:        be_code_jumpto(finfo, binfo->beginpc);
    #####:  201:        be_code_patchjump(finfo, binfo->breaklist);
    #####:  202:        be_code_patchlist(finfo, binfo->continuelist, binfo->beginpc);
        -:  203:    }
        1:  204:    end_varinfo(parser, beginpc);
        1:  205:    be_list_resize(parser->vm, finfo->local, binfo->nactlocals); /* remove local variables from this block, they are now out of scope */
        1:  206:    finfo->freereg = binfo->nactlocals; /* adjust first free register accordingly */
        1:  207:    finfo->binfo = binfo->prev; /* restore previous block */
        1:  208:}
        -:  209:
        1:  210:static void end_block(bparser *parser)
        -:  211:{
        1:  212:    end_block_ex(parser, -1);
        1:  213:}
        -:  214:
        -:  215:/* Return the name of the source for this parser, could be `string`,
        -:  216:   `stdin` or the name of the current function */
        1:  217:static bstring* parser_source(bparser *parser)
        -:  218:{
        1:  219:    if (parser->finfo) {
    #####:  220:        return parser->finfo->proto->source;
        -:  221:    }
        1:  222:    return be_newstr(parser->vm, parser->lexer.fname);
        -:  223:}
        -:  224:
        -:  225:/* Initialize a function block and create a new `bprotoˋ */
        1:  226:static void begin_func(bparser *parser, bfuncinfo *finfo, bblockinfo *binfo)
        -:  227:{
        1:  228:    bvm *vm = parser->vm;
        1:  229:    bproto *proto = be_newproto(vm);
        1:  230:    var_setproto(vm->top, proto);
        1:  231:    be_stackpush(vm);
        1:  232:    be_vector_init(vm, &finfo->code, sizeof(binstruction)); /* vector for code, vectors are not gced */
        1:  233:    proto->code = be_vector_data(&finfo->code);
        1:  234:    proto->codesize = be_vector_capacity(&finfo->code);
        1:  235:    be_vector_init(vm, &finfo->kvec, sizeof(bvalue)); /* vector for constants */
        1:  236:    proto->ktab = be_vector_data(&finfo->kvec);
        1:  237:    proto->nconst = be_vector_capacity(&finfo->kvec);
        1:  238:    be_vector_init(vm, &finfo->pvec, sizeof(bproto*)); /* vector for subprotos */
        1:  239:    proto->ptab = be_vector_data(&finfo->pvec);
        1:  240:    proto->nproto = be_vector_capacity(&finfo->pvec);
        1:  241:    proto->source = parser_source(parser); /* keep a copy of source for function */
        1:  242:    finfo->local = be_list_new(vm); /* list for local variables */
        1:  243:    var_setlist(vm->top, finfo->local); /* push list of local variables on the stack (avoid gc) */
        1:  244:    be_stackpush(vm);
        1:  245:    finfo->upval = be_map_new(vm); /* push a map for upvals on stack */
        1:  246:    var_setmap(vm->top, finfo->upval);
        1:  247:    be_stackpush(vm);
        1:  248:    finfo->prev = parser->finfo; /* init finfo */
        1:  249:    finfo->lexer = &parser->lexer;
        1:  250:    finfo->proto = proto;
        1:  251:    finfo->freereg = 0;
        1:  252:    finfo->binfo = NULL;
        1:  253:    finfo->pc = 0;
        1:  254:    finfo->flags = 0;
        1:  255:    parser->finfo = finfo;
        -:  256:#if BE_DEBUG_RUNTIME_INFO
        1:  257:    be_vector_init(vm, &finfo->linevec, sizeof(blineinfo));
        1:  258:    proto->lineinfo = be_vector_data(&finfo->linevec);
        1:  259:    proto->nlineinfo = be_vector_capacity(&finfo->linevec);
        -:  260:#endif
        -:  261:#if BE_DEBUG_VAR_INFO
        1:  262:    be_vector_init(vm, &finfo->varvec, sizeof(bvarinfo));
        1:  263:    proto->varinfo = be_vector_data(&finfo->varvec);
        1:  264:    proto->nvarinfo = be_vector_capacity(&finfo->varvec);
        -:  265:#endif
        1:  266:    begin_block(finfo, binfo, 0);
        1:  267:}
        -:  268:
        -:  269:/* compute the upval structure */
        1:  270:static void setupvals(bfuncinfo *finfo)
        -:  271:{
        1:  272:    bproto *proto = finfo->proto;
        1:  273:    int nupvals = be_map_count(finfo->upval);
        1:  274:    if (nupvals) {
        -:  275:        bmapnode *node;
    #####:  276:        bmap *map = finfo->upval;
    #####:  277:        bmapiter iter = be_map_iter();
    #####:  278:        bupvaldesc *upvals = be_malloc(
        -:  279:                finfo->lexer->vm, sizeof(bupvaldesc) * nupvals);
    #####:  280:        while ((node = be_map_next(map, &iter)) != NULL) {
    #####:  281:            uint32_t v = (uint32_t)var_toint(&node->value);
    #####:  282:            bupvaldesc *uv = upvals + upval_index(v);
    #####:  283:            uv->idx = upval_target(v);
    #####:  284:            uv->instack = upval_instack(v);
        -:  285:#if BE_DEBUG_VAR_INFO
    #####:  286:            uv->name = var_tostr(&node->key);
        -:  287:#endif
        -:  288:        }
    #####:  289:        proto->upvals = upvals;
    #####:  290:        proto->nupvals = (bbyte)nupvals;
        -:  291:    }
        1:  292:}
        -:  293:
        -:  294:/* Function is complete, finalize bproto */
        1:  295:static void end_func(bparser *parser)
        -:  296:{
        1:  297:    bvm *vm = parser->vm;
        1:  298:    bfuncinfo *finfo = parser->finfo;
        1:  299:    bproto *proto = finfo->proto;
        -:  300:
        1:  301:    be_code_ret(finfo, NULL); /* append a return to last code */
        1:  302:    end_block(parser); /* close block */
        1:  303:    setupvals(finfo); /* close upvals */
        1:  304:    proto->code = be_vector_release(vm, &finfo->code); /* compact all vectors and return NULL if empty */
        1:  305:    proto->codesize = finfo->pc;
        1:  306:    proto->ktab = be_vector_release(vm, &finfo->kvec);
        1:  307:    proto->nconst = be_vector_count(&finfo->kvec);
        1:  308:    proto->ptab = be_vector_release(vm, &finfo->pvec);
        1:  309:    proto->nproto = be_vector_count(&finfo->pvec);
        -:  310:#if BE_DEBUG_RUNTIME_INFO
        1:  311:    proto->lineinfo = be_vector_release(vm, &finfo->linevec);
        1:  312:    proto->nlineinfo = be_vector_count(&finfo->linevec);
        -:  313:#endif
        -:  314:#if BE_DEBUG_VAR_INFO
        1:  315:    proto->varinfo = be_vector_release(vm, &finfo->varvec);
        1:  316:    proto->nvarinfo = be_vector_count(&finfo->varvec);
        -:  317:#endif
        1:  318:    parser->finfo = parser->finfo->prev; /* restore previous `finfo` */
        1:  319:    be_stackpop(vm, 2); /* pop upval and local */
        1:  320:}
        -:  321:
        -:  322:/* is the next token a binary operator? If yes return the operator or `OP_NOT_BINARY` */
       50:  323:static btokentype get_binop(bparser *parser)
        -:  324:{
       50:  325:    btokentype op = next_type(parser);
       50:  326:    if (op >= OptAdd && op <= OptOr) {
       22:  327:        return op;
        -:  328:    }
       28:  329:    return OP_NOT_BINARY;
        -:  330:}
        -:  331:
        -:  332:/* is the next token a unary operator? If yes return the operator or `OP_NOT_BINARY` */
        -:  333:/* operator 'negative' 'not' and 'flip' */
       36:  334:static btokentype get_unary_op(bparser *parser)
        -:  335:{
       36:  336:    btokentype op = next_type(parser);
       36:  337:    if (op == OptSub || op == OptNot || op == OptFlip) {
        4:  338:        return op; /* operator 'negative' 'not' and 'flip' */
        -:  339:    }
       32:  340:    return OP_NOT_UNARY;
        -:  341:}
        -:  342:
        -:  343:/* is the next token an assignment operator? If yes return the operator or `OP_NOT_BINARY` */
        -:  344:/* `=`, `+=`, ... `>>=` */
        9:  345:static btokentype get_assign_op(bparser *parser)
        -:  346:{
        9:  347:    btokentype op = next_type(parser);
        9:  348:    if (op >= OptAssign && op <= OptRsfAssign) {
        1:  349:        return op;
        -:  350:    }
        8:  351:    return OP_NOT_ASSIGN;
        -:  352:}
        -:  353:
        -:  354:/* Initialize bexpdesc structure with specific type and value as int */
       65:  355:static void init_exp(bexpdesc *e, exptype_t type, bint i)
        -:  356:{
       65:  357:    e->type = (bbyte)type;
       65:  358:    e->t = NO_JUMP;
       65:  359:    e->f = NO_JUMP;
       65:  360:    e->not = 0;
       65:  361:    e->v.s = NULL;
       65:  362:    e->v.i = i;
       65:  363:}
        -:  364:
        -:  365:/* find local variable by name, starting at index `begin` */
        -:  366:/* linear search, returns -1 if not found */
       13:  367:static int find_localvar(bfuncinfo *finfo, bstring *s, int begin)
        -:  368:{
       13:  369:    int i, count = be_list_count(finfo->local);
       13:  370:    bvalue *var = be_list_data(finfo->local);
      13*:  371:    for (i = count - 1; i >= begin; --i) {
    #####:  372:        if (be_eqstr(var[i].v.s, s)) {
    #####:  373:            return i;
        -:  374:        }
        -:  375:    }
       13:  376:    return -1; /* not found */
        -:  377:}
        -:  378:
        -:  379:/* create a new local variable by name, or return the current register if already exists */
        -:  380:/* returns the Reg number for the variable */
        -:  381:/* If STRICT, we don't allow a var to hide a var from outer scope */
        -:  382:/* We don't allow the same var to be defined twice in same scope */
    #####:  383:static int new_localvar(bparser *parser, bstring *name)
        -:  384:{
    #####:  385:    bfuncinfo *finfo = parser->finfo;
    #####:  386:    int reg = find_localvar(finfo, name, finfo->binfo->nactlocals); /* look if already exists skipping the local variables from upper blocks */
        -:  387:    /* 'strict': raise an exception if the local variable shadows another local variable */
    #####:  388:    if (reg == -1) {
        -:  389:        bvalue *var;
    #####:  390:        if (comp_is_strict(parser->vm)) {
    #####:  391:            if (find_localvar(finfo, name, 0) >= 0 && str(name)[0] != '.') {  /* we do accept nested redifinition of internal variables starting with ':' */
    #####:  392:                push_error(parser, "strict: redefinition of '%s' from outer scope", str(name));
        -:  393:            }
        -:  394:        }
    #####:  395:        reg = be_list_count(finfo->local); /* new local index */
    #####:  396:        var = be_list_push(parser->vm, finfo->local, NULL);
    #####:  397:        var_setstr(var, name);
    #####:  398:        if (reg >= finfo->freereg) {
    #####:  399:            be_code_allocregs(finfo, 1); /* use a register */
        -:  400:        }
    #####:  401:        begin_varinfo(parser, name);
        -:  402:    } else {
    #####:  403:        push_error(parser, "redefinition of '%s'", str(name));
        -:  404:    }
    #####:  405:    return reg;
        -:  406:}
        -:  407:
        -:  408:/* Find upval by name, if found return its index number, or -1 */
       13:  409:static int find_upval(bfuncinfo *finfo, bstring *s)
        -:  410:{
       13:  411:    bvm *vm = finfo->lexer->vm;
       13:  412:    bvalue *desc = be_map_findstr(vm, finfo->upval, s);
       13:  413:    if (desc) {
    #####:  414:        return upval_index(desc->v.i);
        -:  415:    }
       13:  416:    return -1;
        -:  417:}
        -:  418:
        -:  419:/* Recursively search for upper blocks that are referenced in upvals */
        -:  420:/* and mark them with `hasupval` */
    #####:  421:static void mark_upval(bfuncinfo *finfo, int level)
        -:  422:{
    #####:  423:    bblockinfo *binfo = finfo->prev->binfo;
    #####:  424:    while (binfo->nactlocals > level) {
    #####:  425:        binfo = binfo->prev;
        -:  426:    }
    #####:  427:    binfo->hasupval = 1;
    #####:  428:}
        -:  429:
    #####:  430:static int new_upval(bvm *vm, bfuncinfo *finfo, bstring *name, bexpdesc *var)
        -:  431:{
        -:  432:    int index;
        -:  433:    bvalue *desc;
    #####:  434:    int target = var->v.idx;
    #####:  435:    int instack = var->type == ETLOCAL;
    #####:  436:    if (instack) { /* mark upvalue's block */
    #####:  437:        mark_upval(finfo, target);
        -:  438:    }
    #####:  439:    index = be_map_count(finfo->upval);
    #####:  440:    if (index >= 255) {
    #####:  441:        be_lexerror(finfo->lexer, be_pushfstring(vm,
        -:  442:            "too many upvalues (in '%s')", str(name)));
        -:  443:    }
    #####:  444:    desc = be_map_insertstr(vm, finfo->upval, name, NULL);
    #####:  445:    var_setint(desc, upval_desc(index, target, instack));
    #####:  446:    return index;
        -:  447:}
        -:  448:
        -:  449:/* create a new variable in currenr context as name, and create expdesc for it */
        -:  450:/* If within a block, create as local, otherwise as global */
        1:  451:static void new_var(bparser *parser, bstring *name, bexpdesc *var)
        -:  452:{
        1:  453:    bfuncinfo *finfo = parser->finfo;
        1:  454:    if (finfo->prev || finfo->binfo->prev || parser->islocal) {
    #####:  455:        init_exp(var, ETLOCAL, 0);
    #####:  456:        var->v.idx = new_localvar(parser, name); /* if local, contains the index in current local var list */
        -:  457:    } else {
        1:  458:        init_exp(var, ETGLOBAL, 0);
        1:  459:        var->v.idx = be_global_new(parser->vm, name);
        1:  460:        if (var->v.idx > (int)IBx_MASK) {
    #####:  461:            push_error(parser,
        -:  462:                "too many global variables (in '%s')", str(name));
        -:  463:        }
        1:  464:        if (comp_is_named_gbl(parser->vm)) {
        -:  465:            /* change to ETNGLBAL */
        -:  466:            bexpdesc key;
    #####:  467:            init_exp(&key, ETSTRING, 0);
    #####:  468:            key.v.s = name;
    #####:  469:            init_exp(var, ETNGLOBAL, 0);
    #####:  470:            var->v.idx = be_code_nglobal(parser->finfo, &key);
        -:  471:        }
        -:  472:    }
        1:  473:}
        -:  474:
       26:  475:static int singlevaraux(bvm *vm, bfuncinfo *finfo, bstring *s, bexpdesc *var)
        -:  476:{
       26:  477:    if (finfo == NULL) {
       13:  478:        return ETVOID;
        -:  479:    } else {
       13:  480:        int idx = find_localvar(finfo, s, 0);
       13:  481:        if (idx >= 0) { /* local variable */
    #####:  482:            init_exp(var, ETLOCAL, 0);
    #####:  483:            var->v.idx = idx;
    #####:  484:            return ETLOCAL;
        -:  485:        } else {
       13:  486:            idx = find_upval(finfo, s);
       13:  487:            if (idx < 0) {
        -:  488:                /* find the previous scope  */
       13:  489:                int res = singlevaraux(vm, finfo->prev, s, var);
       13:  490:                if (res == ETUPVAL || res == ETLOCAL) {
    #####:  491:                    idx = new_upval(vm, finfo, s, var); /* new upvalue */
        -:  492:                } else {
       13:  493:                    idx = be_global_find(vm, s);
       13:  494:                    if (idx >= 0) {
       12:  495:                        if (idx < be_builtin_count(vm)) {
        8:  496:                            return ETGLOBAL; /* global variable */
        -:  497:                        } else {
       4*:  498:                            return comp_is_named_gbl(vm) ? ETNGLOBAL : ETGLOBAL; /* global variable */
        -:  499:                        }
        -:  500:                    } else {
        1:  501:                        return ETVOID; /* unknow (new variable or error) */
        -:  502:                    }
        -:  503:                }
        -:  504:            }
    #####:  505:            init_exp(var, ETUPVAL, idx);
    #####:  506:            return ETUPVAL;
        -:  507:        }
        -:  508:    }
        -:  509:}
        -:  510:
        -:  511:/* get variable from next toden as name */
        -:  512:/* and create an expdesc from it */
        -:  513:/* can be new, global, named global, upval */
       13:  514:static void singlevar(bparser *parser, bexpdesc *var)
        -:  515:{
        -:  516:    bexpdesc key;
       13:  517:    bstring *varname = next_token(parser).u.s;
       13:  518:    int type = singlevaraux(parser->vm, parser->finfo, varname, var);
       13:  519:    switch (type) {
        1:  520:    case ETVOID:
        1:  521:        init_exp(var, ETVOID, 0);
        1:  522:        var->v.s = varname;
        1:  523:        break;
       12:  524:    case ETGLOBAL:
       12:  525:        init_exp(var, ETGLOBAL, 0);
       12:  526:        var->v.idx = be_global_find(parser->vm, varname);
       12:  527:        break;
    #####:  528:    case ETNGLOBAL:
    #####:  529:        init_exp(&key, ETSTRING, 0);
    #####:  530:        key.v.s = varname;
    #####:  531:        init_exp(var, ETNGLOBAL, 0);
    #####:  532:        var->v.idx = be_code_nglobal(parser->finfo, &key);
    #####:  533:        break;
    #####:  534:    default:
    #####:  535:        break;
        -:  536:    }
       13:  537:}
        -:  538:
        -:  539:/* parse a vararg argument in the form `def f(a, *b) end` */
        -:  540:/* Munch the '*', read the token, create variable and declare the function as vararg */
    #####:  541:static void func_vararg(bparser *parser) {
        -:  542:    bexpdesc v;
        -:  543:    bstring *str;
    #####:  544:    match_token(parser, OptMul); /* skip '*' */
    #####:  545:    str = next_token(parser).u.s;
    #####:  546:    match_token(parser, TokenId); /* match and skip ID */
    #####:  547:    new_var(parser, str, &v); /* new variable */
    #####:  548:    parser->finfo->proto->varg = 1;   /* set varg flag */
    #####:  549:}
        -:  550:
        -:  551:/* Parse function or method definition variable list */
        -:  552:/* Create an implicit local variable for each argument starting at R0 */
        -:  553:/* Update function proto argc to the expected number or arguments */
        -:  554:/* Raise an exception if multiple arguments have the same name */
        -:  555:/* New: vararg support */
    #####:  556:static void func_varlist(bparser *parser)
        -:  557:{
        -:  558:    bexpdesc v;
        -:  559:    bstring *str;
        -:  560:    /* '(' [ ID {',' ID}] ')' or */
        -:  561:    /* '(' '*' ID ')' or */
        -:  562:    /* '(' [ ID {',' ID}] ',' '*' ID ')' */
    #####:  563:    match_token(parser, OptLBK); /* skip '(' */
    #####:  564:    if (next_type(parser) == OptMul) {
    #####:  565:        func_vararg(parser);
    #####:  566:    } else if (match_id(parser, str) != NULL) {
    #####:  567:        new_var(parser, str, &v); /* new variable */
    #####:  568:        while (match_skip(parser, OptComma)) { /* ',' */
    #####:  569:            if (next_type(parser) == OptMul) {
    #####:  570:                func_vararg(parser);
    #####:  571:                break;
        -:  572:            } else {
    #####:  573:                str = next_token(parser).u.s;
    #####:  574:                match_token(parser, TokenId); /* match and skip ID */
        -:  575:                /* new local variable */
    #####:  576:                new_var(parser, str, &v);
        -:  577:            }
        -:  578:        }
        -:  579:    }
    #####:  580:    match_token(parser, OptRBK); /* skip ')' */
    #####:  581:    parser->finfo->proto->argc = parser->finfo->freereg;
    #####:  582:}
        -:  583:
        -:  584:/* Parse a function includind arg list and body */
        -:  585:/* Given name and type (function or method) */
        -:  586:/* Returns `bproto` object */
    #####:  587:static bproto* funcbody(bparser *parser, bstring *name, int type)
        -:  588:{
        -:  589:    bfuncinfo finfo;
        -:  590:    bblockinfo binfo;
        -:  591:
        -:  592:    /* '(' varlist ')' block 'end' */
    #####:  593:    begin_func(parser, &finfo, &binfo); /* init new function context */
    #####:  594:    finfo.proto->name = name;
    #####:  595:    if (type & FUNC_METHOD) { /* If method, add an implicit first argument `self` */
    #####:  596:        new_localvar(parser, parser_newstr(parser, "self"));
        -:  597:    }
    #####:  598:    func_varlist(parser); /* parse arg list */
    #####:  599:    stmtlist(parser); /* parse statement without final `end` */
    #####:  600:    end_func(parser); /* close function context */
    #####:  601:    match_token(parser, KeyEnd); /* skip 'end' */
    #####:  602:    return finfo.proto; /* return fully constructed `bproto` */
        -:  603:}
        -:  604:
        -:  605:/* anonymous function, build `bproto` object with name `<anonymous>` */
        -:  606:/* and build a expdesc for the bproto */
    #####:  607:static void anon_func(bparser *parser, bexpdesc *e)
        -:  608:{
        -:  609:    bproto *proto;
    #####:  610:    bstring *name = parser_newstr(parser, "<anonymous>");
        -:  611:    /* 'def' ID '(' varlist ')' block 'end' */
    #####:  612:    scan_next_token(parser); /* skip 'def' */
    #####:  613:    proto = funcbody(parser, name, FUNC_ANONYMOUS);
    #####:  614:    init_exp(e, ETPROTO, be_code_proto(parser->finfo, proto));
    #####:  615:    be_stackpop(parser->vm, 1);
    #####:  616:}
        -:  617:
    #####:  618:static void lambda_varlist(bparser *parser)
        -:  619:{
        -:  620:    bexpdesc v;
        -:  621:    bstring *str;
        -:  622:    /* [ID {',' ID}] | {ID}] */
    #####:  623:    if (match_id(parser, str) != NULL) {
        -:  624:        bbool comma;
    #####:  625:        new_var(parser, str, &v); /* new variable */
    #####:  626:        comma = next_type(parser) == OptComma;
    #####:  627:        while (next_type(parser) != OptArrow) {
    #####:  628:            if (comma) {
    #####:  629:                match_token(parser, OptComma); /* match and skip ',' */
        -:  630:            }
    #####:  631:            str = next_token(parser).u.s;
    #####:  632:            match_token(parser, TokenId); /* match and skip ID */
        -:  633:            /* new local variable */
    #####:  634:            new_var(parser, str, &v);
        -:  635:        }
        -:  636:    }
    #####:  637:    match_token(parser, OptArrow); /* skip '->' */
    #####:  638:    parser->finfo->proto->argc = parser->finfo->freereg;
    #####:  639:}
        -:  640:
        -:  641:/* lambda expression */
    #####:  642:static void lambda_expr(bparser *parser, bexpdesc *e)
        -:  643:{
        -:  644:    bexpdesc e1;
        -:  645:    bfuncinfo finfo;
        -:  646:    bblockinfo binfo;
    #####:  647:    bstring *name = parser_newstr(parser, "<lambda>");
        -:  648:    /* '/' ID {[',' ID]} '->' expr */
    #####:  649:    scan_next_token(parser); /* skip '/' */
    #####:  650:    begin_func(parser, &finfo, &binfo);
    #####:  651:    finfo.proto->name = name;
    #####:  652:    lambda_varlist(parser);
    #####:  653:    expr(parser, &e1);
    #####:  654:    check_var(parser, &e1);
    #####:  655:    be_code_ret(parser->finfo, &e1);
    #####:  656:    end_func(parser);
    #####:  657:    init_exp(e, ETPROTO, be_code_proto(parser->finfo, finfo.proto));
    #####:  658:    be_stackpop(parser->vm, 1);
    #####:  659:}
        -:  660:
        -:  661:/* Instanciate a builtin type by name */
        -:  662:/* Allocates a new register for the value, and call empty constructor */
        -:  663:/* Is allocated as LOCAL and must be changed to REG when completed */
    #####:  664:static void new_primtype(bparser *parser, const char *type, bexpdesc *e)
        -:  665:{
        -:  666:    int idx;
    #####:  667:    bvm *vm = parser->vm;
    #####:  668:    bfuncinfo *finfo = parser->finfo;
        -:  669:
    #####:  670:    scan_next_token(parser);
    #####:  671:    idx = be_builtin_find(vm, parser_newstr(parser, type));
    #####:  672:    init_exp(e, ETGLOBAL, idx);
    #####:  673:    idx = be_code_nextreg(finfo, e);
    #####:  674:    be_code_call(finfo, idx, 0);
    #####:  675:    e->type = ETLOCAL;  /* declare as local, will be changed to ETREG when completely initialized */
    #####:  676:}
        -:  677:
        -:  678:/* Parse next member within a list */
        -:  679:/* `l` contains the current list. The expr is evaluated and added to the list */
    #####:  680:static void list_nextmember(bparser *parser, bexpdesc *l)
        -:  681:{
    #####:  682:    bexpdesc e, v = *l;
    #####:  683:    bfuncinfo *finfo = parser->finfo;
    #####:  684:    expr(parser, &e); /* value */
    #####:  685:    check_var(parser, &e); /* check that we don´t have an unknown symbol */
    #####:  686:    be_code_binop(finfo, OptConnect, &v, &e, -1); /* add it to list with CONNECT */
    #####:  687:    be_code_freeregs(finfo, 1);  /* since left arg is LOCAL, an ETREG was allocated. Free it */
    #####:  688:}
        -:  689:
    #####:  690:static void map_nextmember(bparser *parser, bexpdesc *l)
        -:  691:{
    #####:  692:    bexpdesc e, v = *l;
    #####:  693:    bfuncinfo *finfo = parser->finfo;
    #####:  694:    expr(parser, &e); /* key */
    #####:  695:    check_var(parser, &e);  /* check if value is valid */
    #####:  696:    be_code_index(finfo, &v, &e);  /* package as `v` as INDEX suffix for value `e` */
    #####:  697:    match_token(parser, OptColon); /* ':' */
    #####:  698:    expr(parser, &e); /* value in `e` */
    #####:  699:    check_var(parser, &e);  /* check if value is correct */
    #####:  700:    be_code_setvar(finfo, &v, &e);  /* set suffi  INDEX value to e */
    #####:  701:}
        -:  702:
    #####:  703:static void list_expr(bparser *parser, bexpdesc *e)
        -:  704:{
        -:  705:    /* '[' {expr ','} [expr] ']' */
    #####:  706:    new_primtype(parser, "list", e); /* new list, created as LOCAL first */
    #####:  707:    while (next_type(parser) != OptRSB) {
    #####:  708:        list_nextmember(parser, e);
    #####:  709:        if (!match_skip(parser, OptComma)) { /* ',' */
    #####:  710:            break;
        -:  711:        }
        -:  712:    }
    #####:  713:    e->type = ETREG; /* then turned to REG */
    #####:  714:    match_token(parser, OptRSB); /* skip ']' */
    #####:  715:}
        -:  716:
    #####:  717:static void map_expr(bparser *parser, bexpdesc *e)
        -:  718:{
        -:  719:    /* '{' {expr ':' expr ','} [expr ':' expr] '}' */
    #####:  720:    new_primtype(parser, "map", e); /* new map */
    #####:  721:    while (next_type(parser) != OptRBR) {
    #####:  722:        map_nextmember(parser, e);
    #####:  723:        if (!match_skip(parser, OptComma)) { /* ',' */
    #####:  724:            break;
        -:  725:        }
        -:  726:    }
    #####:  727:    e->type = ETREG;
    #####:  728:    match_token(parser, OptRBR); /* skip '}' */
    #####:  729:}
        -:  730:
        -:  731:/* push each argument as new reg and return number of args */
        -:  732:/* TODO `e` is ignored by caller */
        8:  733:static int exprlist(bparser *parser, bexpdesc *e)
        -:  734:{
        8:  735:    bfuncinfo *finfo = parser->finfo;
        8:  736:    int n = 1;
        -:  737:    /* expr { ',' expr } */
        8:  738:    expr(parser, e);  /* parse expr */
        8:  739:    check_var(parser, e);  /* check if valid */
        8:  740:    be_code_nextreg(finfo, e);  /* move result to next reg */
        8:  741:    while (match_skip(parser, OptComma)) { /* ',' */
    #####:  742:        expr(parser, e);
    #####:  743:        check_var(parser, e);
    #####:  744:        be_code_nextreg(finfo, e);
    #####:  745:        ++n;
        -:  746:    }
        8:  747:    return n;
        -:  748:}
        -:  749:
        -:  750:/* parse call to method or function */
        -:  751:/* `e` can be a member (method) or a register */
        -:  752:/* On return, `e` is ETREG to the result of the call */
        8:  753:static void call_expr(bparser *parser, bexpdesc *e)
        -:  754:{
        -:  755:    bexpdesc args;
        8:  756:    bfuncinfo *finfo = parser->finfo;
        8:  757:    int argc = 0, base;
        8:  758:    int ismember = e->type == ETMEMBER;
        -:  759:
        -:  760:    /* func '(' [exprlist] ')' */
        8:  761:    check_var(parser, e);
        -:  762:    /* code function index to next register */
        8:  763:    if (ismember) {
    #####:  764:        base = be_code_getmethod(finfo, e);
        -:  765:    } else {
        8:  766:        base = be_code_nextreg(finfo, e); /* allocate a new base reg if not at top already */
        -:  767:    }
        -:  768:    /* base is always taken at top of freereg and allocates 1 reg for function and 2 regs for method */
        8:  769:    scan_next_token(parser); /* skip '(' */
        8:  770:    if (next_type(parser) != OptRBK) {  /* if arg list is not empty */
        8:  771:        argc = exprlist(parser, &args);  /* push each argument as new reg and return number of args */
        -:  772:    }
        8:  773:    match_token(parser, OptRBK); /* skip ')' */
        8:  774:    argc += ismember;   /* if method there is an additional implicit arg */
        8:  775:    be_code_call(finfo, base, argc);
        8:  776:    if (e->type != ETREG) {
    #####:  777:        e->type = ETREG;
    #####:  778:        e->v.idx = base;
        -:  779:    }
        8:  780:}
        -:  781:
        -:  782:/* Parse member expression */
        -:  783:/* Generates an ETMEMBER object that is materialized later into GETMBR, GETMET or SETMBR */
    #####:  784:static void member_expr(bparser *parser, bexpdesc *e)
        -:  785:{
        -:  786:    bstring *str;
        -:  787:    /* . ID */
    #####:  788:    check_var(parser, e);
    #####:  789:    scan_next_token(parser); /* skip '.' */
    #####:  790:    if (match_id(parser, str) != NULL) {
        -:  791:        bexpdesc key;
    #####:  792:        init_exp(&key, ETSTRING, 0);
    #####:  793:        key.v.s = str;
    #####:  794:        be_code_member(parser->finfo, e, &key);
    #####:  795:    } else if (next_type(parser) == OptLBK) {
    #####:  796:        scan_next_token(parser); /* skip '(' */
        -:  797:        bexpdesc key;
    #####:  798:        expr(parser, &key);
    #####:  799:        check_var(parser, &key);
    #####:  800:        match_token(parser, OptRBK); /* skip ')' */
    #####:  801:        be_code_member(parser->finfo, e, &key);
        -:  802:    } else {
    #####:  803:        push_error(parser, "invalid syntax near '%s'",
        -:  804:            be_token2str(parser->vm, &next_token(parser)));
        -:  805:    }
    #####:  806:}
        -:  807:
    #####:  808:static void index_expr(bparser *parser, bexpdesc *e)
        -:  809:{
        -:  810:    bexpdesc e1;
        -:  811:    /* [expr] */
    #####:  812:    check_var(parser, e);
    #####:  813:    scan_next_token(parser); /* skip '[' */
    #####:  814:    expr(parser, &e1);
    #####:  815:    check_var(parser, &e1);
    #####:  816:    be_code_index(parser->finfo, e, &e1);
    #####:  817:    match_token(parser, OptRSB); /* skip ']' */
    #####:  818:}
        -:  819:
       32:  820:static void simple_expr(bparser *parser, bexpdesc *e)
        -:  821:{
       32:  822:    switch (next_type(parser)) {
       19:  823:    case TokenInteger:
       19:  824:        init_exp(e, ETINT, next_token(parser).u.i);
       19:  825:        break;
    #####:  826:    case TokenReal:
    #####:  827:        init_exp(e, ETREAL, 0);
    #####:  828:        e->v.r = next_token(parser).u.r;
    #####:  829:        break;
    #####:  830:    case TokenString:
    #####:  831:        init_exp(e, ETSTRING, 0);
    #####:  832:        e->v.s = next_token(parser).u.s;
    #####:  833:        break;
       13:  834:    case TokenId:
       13:  835:        singlevar(parser, e);
       13:  836:        break;
    #####:  837:    case KeyTrue:
    #####:  838:        init_exp(e, ETBOOL, 1);
    #####:  839:        break;
    #####:  840:    case KeyFalse:
    #####:  841:        init_exp(e, ETBOOL, 0);
    #####:  842:        break;
    #####:  843:    case KeyNil:
    #####:  844:        init_exp(e, ETNIL, 0);
    #####:  845:        break;
    #####:  846:    default: /* unknow expr */
    #####:  847:        return;
        -:  848:    }
       32:  849:    scan_next_token(parser);
        -:  850:}
        -:  851:
       32:  852:static void primary_expr(bparser *parser, bexpdesc *e)
        -:  853:{
       32:  854:    switch (next_type(parser)) {
    #####:  855:    case OptLBK: /* '(' expr ')' */
    #####:  856:        scan_next_token(parser); /* skip '(' */
        -:  857:        /* sub_expr() is more efficient because there is no need to initialize e. */
    #####:  858:        sub_expr(parser, e, ASSIGN_OP_PRIO);
    #####:  859:        check_var(parser, e);
    #####:  860:        match_token(parser, OptRBK); /* skip ')' */
    #####:  861:        break;
    #####:  862:    case OptLSB: /* list */
    #####:  863:        list_expr(parser, e);
    #####:  864:        break;
    #####:  865:    case OptLBR: /* map */
    #####:  866:        map_expr(parser, e);
    #####:  867:        break;
    #####:  868:    case KeyDef: /* anonymous function */
    #####:  869:        anon_func(parser, e);
    #####:  870:        break;
    #####:  871:    case OptDiv: /* lambda expression */
    #####:  872:        lambda_expr(parser, e);
    #####:  873:        break;
       32:  874:    default: /* simple expr */
       32:  875:        simple_expr(parser, e);
       32:  876:        break;
        -:  877:    }
       32:  878:}
        -:  879:
       32:  880:static void suffix_expr(bparser *parser, bexpdesc *e)
        -:  881:{
       32:  882:    primary_expr(parser, e);
        -:  883:    for (;;) {
       40:  884:        switch (next_type(parser)) {
        8:  885:        case OptLBK: /* '(' function call */
        8:  886:            call_expr(parser, e);
        8:  887:            break;
    #####:  888:        case OptDot: /* '.' member */
    #####:  889:            member_expr(parser, e);
    #####:  890:            break;
    #####:  891:        case OptLSB: /* '[' index */
    #####:  892:            index_expr(parser, e);
    #####:  893:            break;
       32:  894:        default:
       32:  895:            return;
        -:  896:        }
        -:  897:    }
        -:  898:}
        -:  899:
    #####:  900:static void suffix_alloc_reg(bparser *parser, bexpdesc *l)
        -:  901:{
    #####:  902:    bfuncinfo *finfo = parser->finfo;
    #####:  903:    bbool is_suffix = l->type == ETINDEX || l->type == ETMEMBER;   /* is suffix */
    #####:  904:    bbool is_suffix_reg = l->v.ss.tt == ETREG || l->v.ss.tt == ETLOCAL || l->v.ss.tt == ETGLOBAL || l->v.ss.tt == ETNGLOBAL;   /* if suffix, does it need a register */
    #####:  905:    bbool is_global = l->type == ETGLOBAL || l->type == ETNGLOBAL;
        -:  906:    /* in the suffix expression, if the object is a temporary
        -:  907:     * variable (l->v.ss.tt == ETREG), it needs to be cached. */
    #####:  908:    if (is_global || (is_suffix && is_suffix_reg)) {
    #####:  909:        be_code_allocregs(finfo, 1);
        -:  910:    }
    #####:  911:}
        -:  912:
        -:  913:/* compound assignment */
        1:  914:static void compound_assign(bparser *parser, int op, bexpdesc *l, bexpdesc *r)
        -:  915:{
        1:  916:    int dst = -1;  /* destination register in case of compound assignment */
        1:  917:    if (op != OptAssign) { /* check left variable */
    #####:  918:        check_var(parser, l);
        -:  919:        /* cache the register of the object when continuously assigning */
    #####:  920:        dst = parser->finfo->freereg;
    #####:  921:        suffix_alloc_reg(parser, l);
        -:  922:    }
        1:  923:    expr(parser, r); /* right expression */
        1:  924:    check_var(parser, r);
        1:  925:    if (op != OptAssign) { /* compound assignment */
    #####:  926:        bexpdesc e = *l;
    #####:  927:        op = op < OptAndAssign ? op - OptAddAssign + OptAdd
    #####:  928:                : op - OptAndAssign + OptBitAnd;
    #####:  929:        be_code_binop(parser->finfo, op, &e, r, dst); /* coding operation */
    #####:  930:        *r = e;
        -:  931:    }
        1:  932:}
        -:  933:
        -:  934:/* check if we need to create a new local variable with this name to be assigned to */
        -:  935:/* Returns true if it´s a new local variable */
        -:  936:/* A new implicit local variable is created if no global has the same name (excluding builtins) */
        -:  937:/* This means that you can override a builtin silently */
        -:  938:/* This also means that a function cannot create a global, they must preexist or create with `global` module */
        -:  939:/* TODO add warning in strict mode */
        1:  940:static int check_newvar(bparser *parser, bexpdesc *e)
        -:  941:{
        1:  942:    if (e->type == ETGLOBAL) {
    #####:  943:        if (e->v.idx < be_builtin_count(parser->vm)) {
    #####:  944:            e->v.s = be_builtin_name(parser->vm, e->v.idx);
    #####:  945:            if (comp_is_strict(parser->vm)) {
    #####:  946:                push_error(parser, "strict: redefinition of builtin '%s'",
        -:  947:                    str(e->v.s));
        -:  948:            }
    #####:  949:            return btrue;
        -:  950:        }
    #####:  951:        return bfalse;
        -:  952:    }
        1:  953:    if (comp_is_strict(parser->vm)) {
    #####:  954:        bfuncinfo *finfo = parser->finfo;
    #####:  955:        if ((e->type == ETVOID) && (finfo->prev || finfo->binfo->prev || parser->islocal)) {
    #####:  956:            push_error(parser, "strict: no global '%s', did you mean 'var %s'?",
        -:  957:                str(e->v.s), str(e->v.s));
        -:  958:        }
        -:  959:    }
        1:  960:    return e->type == ETVOID;
        -:  961:}
        -:  962:
        9:  963:static void assign_expr(bparser *parser)
        -:  964:{
        -:  965:    bexpdesc e;
        -:  966:    btokentype op;
        9:  967:    int line = parser->lexer.linenumber;
        9:  968:    expr(parser, &e); /* left expression */
        9:  969:    check_symbol(parser, &e);
        9:  970:    op = get_assign_op(parser);
        9:  971:    if (op != OP_NOT_ASSIGN) { /* assign operator */
        -:  972:        bexpdesc e1;
        1:  973:        scan_next_token(parser);
        1:  974:        compound_assign(parser, op, &e, &e1);
        1:  975:        if (check_newvar(parser, &e)) { /* new variable */
        1:  976:            new_var(parser, e.v.s, &e);
        -:  977:        }
        1:  978:        if (be_code_setvar(parser->finfo, &e, &e1)) {
    #####:  979:            parser->lexer.linenumber = line;
    #####:  980:            parser_error(parser,
        -:  981:                "try to assign constant expressions.");
        -:  982:        }
        8:  983:    } else if (e.type >= ETMEMBER) {
        8:  984:        bfuncinfo *finfo = parser->finfo;
        -:  985:        /* these expressions occupy a register and need to be freed */
        8:  986:        finfo->freereg = (bbyte)be_list_count(finfo->local);
    #####:  987:    } else if (e.type == ETVOID) { /* not assign expression */
        -:  988:        /* undeclared symbol */
    #####:  989:        parser->lexer.linenumber = line;
    #####:  990:        check_var(parser, &e);
        -:  991:    } 
        9:  992:}
        -:  993:
        -:  994:/* conditional expression */
       18:  995:static void cond_expr(bparser *parser, bexpdesc *e)
        -:  996:{
        -:  997:    /* expr '?' expr ':' expr */
       18:  998:    if (next_type(parser) == OptQuestion) {
    #####:  999:        int jf, jl = NO_JUMP; /* jump list */
    #####: 1000:        bfuncinfo *finfo = parser->finfo;
    #####: 1001:        check_var(parser, e);  /* check if valid */
    #####: 1002:        scan_next_token(parser); /* skip '?' */
    #####: 1003:        be_code_jumpbool(finfo, e, bfalse); /* go if true */
    #####: 1004:        jf = e->f;
    #####: 1005:        expr(parser, e);
    #####: 1006:        check_var(parser, e);
    #####: 1007:        be_code_nextreg(finfo, e);
    #####: 1008:        be_code_freeregs(finfo, 1);
    #####: 1009:        be_code_conjump(finfo, &jl, be_code_jump(finfo)); /* connect jump */
    #####: 1010:        be_code_patchjump(finfo, jf);
    #####: 1011:        match_token(parser, OptColon); /* match and skip ':' */
    #####: 1012:        expr(parser, e);
    #####: 1013:        check_var(parser, e);
    #####: 1014:        e->v.idx = be_code_nextreg(finfo, e);
    #####: 1015:        be_code_patchjump(finfo, jl);
    #####: 1016:        e->type = ETREG;
        -: 1017:    }
       18: 1018:}
        -: 1019:
        -: 1020:/* binary operator: + - * / % && || < <= == != > >=
        -: 1021: * unary operator: + - !
        -: 1022: */
       36: 1023:static void sub_expr(bparser *parser, bexpdesc *e, int prio)
        -: 1024:{
       36: 1025:    bfuncinfo *finfo = parser->finfo;
       36: 1026:    btokentype op = get_unary_op(parser);  /* check if first token in unary op */
       36: 1027:    if (op != OP_NOT_UNARY) {  /* unary op found */
        -: 1028:        int line, res;
        4: 1029:        scan_next_token(parser);  /* move to next token */
        4: 1030:        line = parser->lexer.linenumber;  /* remember line number for error reporting */
        4: 1031:        sub_expr(parser, e, UNARY_OP_PRIO);  /* parse subexpr with new prio */
        4: 1032:        check_var(parser, e);  /* check that the value is ok */
        4: 1033:        res = be_code_unop(finfo, op, e);  /* apply unary op with optimizations if the token is a value */
        4: 1034:        if (res) { /* encode unary op */
    #####: 1035:            parser->lexer.linenumber = line;
    #####: 1036:            push_error(parser, "wrong type argument to unary '%s'",
        -: 1037:                res == 1 ? "negative" : "bit-flip");
        -: 1038:        }
        -: 1039:    } else {
       32: 1040:        suffix_expr(parser, e);  /* parse left part of binop */
        -: 1041:    }
       36: 1042:    op = get_binop(parser);  /* check if binop */
       50: 1043:    while (op != OP_NOT_BINARY && prio > binary_op_prio(op)) {  /* is binop applicable */
        -: 1044:        bexpdesc e2;
       14: 1045:        check_var(parser, e);  /* check that left part is valid */
       14: 1046:        scan_next_token(parser);  /* move to next token */
       14: 1047:        be_code_prebinop(finfo, op, e); /* and or */
       14: 1048:        init_exp(&e2, ETVOID, 0);
       14: 1049:        sub_expr(parser, &e2, binary_op_prio(op));  /* parse right side */
       14: 1050:        check_var(parser, &e2);  /* check if valid */
       14: 1051:        be_code_binop(finfo, op, e, &e2, -1); /* encode binary op */
       14: 1052:        op = get_binop(parser);  /* is there a following binop? */
        -: 1053:    }
       36: 1054:    if (prio == ASSIGN_OP_PRIO) {
       18: 1055:        cond_expr(parser, e);
        -: 1056:    }
       36: 1057:}
        -: 1058:
        -: 1059:/* Parse new expression and return value in `e` (overwritten) */
        -: 1060:/* Initializes an empty expdes  and parse subexpr */
        -: 1061:/* Always allocates a new temp register at top of freereg */
       18: 1062:static void expr(bparser *parser, bexpdesc *e)
        -: 1063:{
       18: 1064:    init_exp(e, ETVOID, 0);
       18: 1065:    sub_expr(parser, e, ASSIGN_OP_PRIO);
       18: 1066:}
        -: 1067:
        9: 1068:static void expr_stmt(bparser *parser)
        -: 1069:{
        9: 1070:    assign_expr(parser);
        9: 1071:}
        -: 1072:
       10: 1073:static int block_follow(bparser *parser)
        -: 1074:{
       10: 1075:    switch (next_type(parser)) {
        1: 1076:    case KeyElse: case KeyElif:
        -: 1077:    case KeyEnd: case KeyExcept:
        -: 1078:    case TokenEOS:
        1: 1079:        return 0;
        9: 1080:    default:
        9: 1081:        return 1;
        -: 1082:    }
        -: 1083:}
        -: 1084:
    #####: 1085:static int cond_stmt(bparser *parser)
        -: 1086:{
        -: 1087:    bexpdesc e;
        -: 1088:    /* expr */
    #####: 1089:    match_notoken(parser, OptRBK);
    #####: 1090:    expr(parser, &e);
    #####: 1091:    check_var(parser, &e);
    #####: 1092:    be_code_jumpbool(parser->finfo, &e, bfalse); /* go if true */
    #####: 1093:    return e.f;
        -: 1094:}
        -: 1095:
    #####: 1096:static void condition_block(bparser *parser, int *jmp)
        -: 1097:{
    #####: 1098:    bfuncinfo *finfo = parser->finfo;
    #####: 1099:    int br = cond_stmt(parser);
    #####: 1100:    block(parser, 0);
    #####: 1101:    if (next_type(parser) == KeyElif
    #####: 1102:            || next_type(parser) == KeyElse) {
    #####: 1103:        be_code_conjump(finfo, jmp, be_code_jump(finfo)); /* connect jump */
        -: 1104:    }
    #####: 1105:    be_code_patchjump(finfo, br);
    #####: 1106:}
        -: 1107:
    #####: 1108:static void if_stmt(bparser *parser)
        -: 1109:{
    #####: 1110:    int jl = NO_JUMP; /* jump list */
        -: 1111:    /* IF expr block {ELSEIF expr block}, [ELSE block], end */
    #####: 1112:    scan_next_token(parser); /* skip 'if' */
    #####: 1113:    condition_block(parser, &jl);
    #####: 1114:    while (match_skip(parser, KeyElif)) { /* 'elif' */
    #####: 1115:        condition_block(parser, &jl);
        -: 1116:    }
    #####: 1117:    if (match_skip(parser, KeyElse)) { /* 'else' */
    #####: 1118:        block(parser, 0);
        -: 1119:    }
    #####: 1120:    match_token(parser, KeyEnd); /* skip end */
    #####: 1121:    be_code_patchjump(parser->finfo, jl);
    #####: 1122:}
        -: 1123:
    #####: 1124:static void do_stmt(bparser *parser)
        -: 1125:{
        -: 1126:    /* DO block END */
    #####: 1127:    scan_next_token(parser); /* skip 'do' */
    #####: 1128:    block(parser, 0);
    #####: 1129:    match_token(parser, KeyEnd); /* skip 'end' */
    #####: 1130:}
        -: 1131:
    #####: 1132:static void while_stmt(bparser *parser)
        -: 1133:{
        -: 1134:    int brk;
        -: 1135:    bblockinfo binfo;
    #####: 1136:    bfuncinfo *finfo = parser->finfo;
        -: 1137:    /* WHILE expr block END */
    #####: 1138:    scan_next_token(parser); /* skip 'while' */
    #####: 1139:    begin_block(parser->finfo, &binfo, BLOCK_LOOP);
    #####: 1140:    brk = cond_stmt(parser);
    #####: 1141:    stmtlist(parser);
    #####: 1142:    end_block(parser);
    #####: 1143:    be_code_patchjump(finfo, brk);
    #####: 1144:    match_token(parser, KeyEnd); /* skip 'end' */
    #####: 1145:}
        -: 1146:
    #####: 1147:static bstring* for_itvar(bparser *parser)
        -: 1148:{
        -: 1149:    bstring *str;
    #####: 1150:    if (match_id(parser, str) == NULL) {
    #####: 1151:        push_error(parser,
        -: 1152:            "missing iteration variable before '%s'",
        -: 1153:            token2str(parser));
        -: 1154:    }
    #####: 1155:    return str;
        -: 1156:}
        -: 1157:
    #####: 1158:static void for_init(bparser *parser, bexpdesc *v)
        -: 1159:{
        -: 1160:    bexpdesc e;
        -: 1161:    bstring *s;
    #####: 1162:    bfuncinfo *finfo = parser->finfo;
        -: 1163:    /* .it = __iterator__(expr) */
    #####: 1164:    s = parser_newstr(parser, "__iterator__");
    #####: 1165:    init_exp(&e, ETGLOBAL, be_builtin_find(parser->vm, s));
    #####: 1166:    be_code_nextreg(finfo, &e); /* code function '__iterator__' */
    #####: 1167:    expr(parser, v);
    #####: 1168:    check_var(parser, v);
    #####: 1169:    be_code_nextreg(finfo, v);
    #####: 1170:    be_code_call(finfo, e.v.idx, 1); /* call __iterator__(expr) */
    #####: 1171:    be_code_freeregs(finfo, 1); /* free register of __iterator__ */
    #####: 1172:    s = parser_newstr(parser, ".it");
    #####: 1173:    init_exp(v, ETLOCAL, new_localvar(parser, s));
    #####: 1174:}
        -: 1175:
    #####: 1176:static void for_iter(bparser *parser, bstring *var, bexpdesc *it)
        -: 1177:{
        -: 1178:    bexpdesc e;
    #####: 1179:    bfuncinfo *finfo = parser->finfo;
        -: 1180:    /* reset the jump head PC of the for loop body */
    #####: 1181:    finfo->binfo->beginpc = finfo->pc;
        -: 1182:    /* itvar = .it() */
    #####: 1183:    init_exp(&e, ETLOCAL, new_localvar(parser, var)); /* new itvar */
    #####: 1184:    be_code_setvar(finfo, &e, it); /* code function to variable '.it' */
    #####: 1185:    be_code_call(finfo, e.v.idx, 0); /* itvar <- call .it() */
    #####: 1186:    stmtlist(parser);
    #####: 1187:}
        -: 1188:
    #####: 1189:static void for_leave(bparser *parser, int jcatch, int beginpc)
        -: 1190:{
        -: 1191:    bexpdesc e;
    #####: 1192:    bfuncinfo *finfo = parser->finfo;
    #####: 1193:    int jbrk = finfo->binfo->breaklist;
    #####: 1194:    init_exp(&e, ETSTRING, 0);
    #####: 1195:    e.v.s = parser_newstr(parser, "stop_iteration");
    #####: 1196:    end_block_ex(parser, beginpc); /* leave except & loop block */
    #####: 1197:    if (jbrk != NO_JUMP) { /* has `break` statement in iteration block */
    #####: 1198:        be_code_exblk(finfo, 1);
    #####: 1199:        jbrk = be_code_jump(finfo);
        -: 1200:    }
    #####: 1201:    be_code_conjump(finfo, &jcatch, finfo->pc);
    #####: 1202:    be_code_catch(finfo, be_code_nextreg(finfo, &e), 1, 0, NULL);
    #####: 1203:    be_code_raise(finfo, NULL, NULL);
    #####: 1204:    be_code_conjump(finfo, &jbrk, finfo->pc);
    #####: 1205:    be_code_freeregs(finfo, 1);
    #####: 1206:}
        -: 1207:
        -: 1208:/* approximate equivalent script code:
        -: 1209: * .it = __iter__(expr)
        -: 1210: * try
        -: 1211: *     while (1)
        -: 1212: *         itvar = .it()
        -: 1213: *         stmtlist
        -: 1214: *     end
        -: 1215: * except ('stop_iteration')
        -: 1216: * end
        -: 1217: * */
    #####: 1218:static void for_stmt(bparser *parser)
        -: 1219:{
        -: 1220:    bstring *var;
        -: 1221:    bexpdesc iter;
        -: 1222:    bblockinfo binfo;
    #####: 1223:    int jcatch, beginpc = parser->finfo->pc;
        -: 1224:    /* FOR ID : expr block END */
    #####: 1225:    scan_next_token(parser); /* skip 'for' */
    #####: 1226:    begin_block(parser->finfo, &binfo, BLOCK_EXCEPT | BLOCK_LOOP);
    #####: 1227:    var = for_itvar(parser);
    #####: 1228:    match_token(parser, OptColon); /* skip ':' */
    #####: 1229:    for_init(parser, &iter);
    #####: 1230:    jcatch = be_code_exblk(parser->finfo, 0);
    #####: 1231:    for_iter(parser, var, &iter);
    #####: 1232:    for_leave(parser, jcatch, beginpc);
    #####: 1233:    match_token(parser, KeyEnd); /* skip 'end' */
    #####: 1234:}
        -: 1235:
    #####: 1236:static bblockinfo* break_block(bparser *parser)
        -: 1237:{
    #####: 1238:    int try_depth = 0; /* count of exception catch blocks */
    #####: 1239:    bblockinfo *binfo = parser->finfo->binfo;
        -: 1240:    /* BREAK | CONTINUE */
    #####: 1241:    scan_next_token(parser); /* skip 'break' or 'continue' */
    #####: 1242:    while (binfo && !(binfo->type & BLOCK_LOOP)) {
    #####: 1243:        if (binfo->type & BLOCK_EXCEPT) {
    #####: 1244:            ++try_depth; /* leave the exception catch block */
        -: 1245:        }
    #####: 1246:        binfo = binfo->prev;
        -: 1247:    }
    #####: 1248:    if (binfo && try_depth) { /* exception catch blocks that needs to leave */
    #####: 1249:        be_code_exblk(parser->finfo, try_depth);
        -: 1250:    }
    #####: 1251:    return binfo;
        -: 1252:}
        -: 1253:
    #####: 1254:static void break_stmt(bparser *parser)
        -: 1255:{
    #####: 1256:    bfuncinfo *f = parser->finfo;
    #####: 1257:    bblockinfo *binfo = break_block(parser);
    #####: 1258:    if (binfo != NULL) { /* connect jump */
    #####: 1259:        be_code_conjump(f, &binfo->breaklist, be_code_jump(f));
        -: 1260:    } else {
    #####: 1261:        parser_error(parser, "break not loop");
        -: 1262:    }
    #####: 1263:}
        -: 1264:
    #####: 1265:static void continue_stmt(bparser *parser)
        -: 1266:{
    #####: 1267:    bfuncinfo *f = parser->finfo;
    #####: 1268:    bblockinfo *b = break_block(parser);
    #####: 1269:    if (b != NULL) { /* connect jump */
    #####: 1270:        be_code_conjump(f, &b->continuelist, be_code_jump(f));
        -: 1271:    } else {
    #####: 1272:        parser_error(parser, "continue not loop");
        -: 1273:    }
    #####: 1274:}
        -: 1275:
    #####: 1276:static bbool isoverloadable(btokentype type)
        -: 1277:{
    #####: 1278:    return (type >= OptAdd && type <= OptConnect) /* overloaded binary operator */
    #####: 1279:        || type == OptFlip || type == OptLBK;     /* '~' and '()' operator */
        -: 1280:}
        -: 1281:
    #####: 1282:static bstring* func_name(bparser* parser, bexpdesc* e, int ismethod)
        -: 1283:{
    #####: 1284:    btokentype type = next_type(parser);
    #####: 1285:    if (type == TokenId) {
    #####: 1286:        bstring *name = next_token(parser).u.s;
    #####: 1287:        if (!ismethod) {
    #####: 1288:            new_var(parser, name, e); /* new variable */
        -: 1289:        }
    #####: 1290:        scan_next_token(parser); /* skip name */
    #####: 1291:        return name;
    #####: 1292:    } else if (ismethod && isoverloadable(type)) {
    #####: 1293:        scan_next_token(parser); /* skip token */
        -: 1294:        /* '-*' negative operator */
    #####: 1295:        if (type == OptSub && next_type(parser) == OptMul) {
    #####: 1296:            scan_next_token(parser); /* skip '*' */
    #####: 1297:            return parser_newstr(parser, "-*");
        -: 1298:        }
        -: 1299:        /* '()' call operator */
    #####: 1300:        if (type == OptLBK && next_type(parser) == OptRBK) {
    #####: 1301:            scan_next_token(parser); /* skip ')' */
    #####: 1302:            return parser_newstr(parser, "()");
        -: 1303:        }
    #####: 1304:        return parser_newstr(parser, be_tokentype2str(type));
        -: 1305:    }
    #####: 1306:    push_error(parser,
        -: 1307:        "the token '%s' is not a valid function name.",
        -: 1308:        token2str(parser));
    #####: 1309:    return NULL;
        -: 1310:}
        -: 1311:
    #####: 1312:static void def_stmt(bparser *parser)
        -: 1313:{
        -: 1314:    bexpdesc e;
        -: 1315:    bproto *proto;
    #####: 1316:    bfuncinfo *finfo = parser->finfo;
        -: 1317:    /* 'def' ID '(' varlist ')' block 'end' */
    #####: 1318:    scan_next_token(parser); /* skip 'def' */
    #####: 1319:    proto = funcbody(parser, func_name(parser, &e, 0), 0);
    #####: 1320:    be_code_closure(finfo, &e, be_code_proto(finfo, proto));
    #####: 1321:    be_stackpop(parser->vm, 1);
    #####: 1322:}
        -: 1323:
    #####: 1324:static void return_stmt(bparser *parser)
        -: 1325:{
        -: 1326:    bexpdesc e;
        -: 1327:    /* 'return' expr */
    #####: 1328:    scan_next_token(parser); /* skip 'return' */
    #####: 1329:    expr(parser, &e);
    #####: 1330:    if (e.v.s) { /* expression is not empty */
    #####: 1331:        check_var(parser, &e);
        -: 1332:    }
    #####: 1333:    be_code_ret(parser->finfo, &e);
    #####: 1334:}
        -: 1335:
    #####: 1336:static void check_class_attr(bparser *parser, bclass *c, bstring *attr)
        -: 1337:{
    #####: 1338:    if (be_class_attribute(parser->vm, c, attr) != BE_NONE) {
    #####: 1339:        push_error(parser,
        -: 1340:            "redefinition of the attribute '%s'", str(attr));
        -: 1341:    }
    #####: 1342:}
        -: 1343:
    #####: 1344:static void classvar_stmt(bparser *parser, bclass *c)
        -: 1345:{
        -: 1346:    bstring *name;
        -: 1347:    /* 'var' ID {',' ID} */
    #####: 1348:    scan_next_token(parser); /* skip 'var' */
    #####: 1349:    if (match_id(parser, name) != NULL) {
    #####: 1350:        check_class_attr(parser, c, name);
    #####: 1351:        be_member_bind(parser->vm, c, name, btrue);
    #####: 1352:        while (match_skip(parser, OptComma)) { /* ',' */
    #####: 1353:            if (match_id(parser, name) != NULL) {
    #####: 1354:                check_class_attr(parser, c, name);
    #####: 1355:                be_member_bind(parser->vm, c, name, btrue);
        -: 1356:            } else {
    #####: 1357:                parser_error(parser, "class var error");
        -: 1358:            }
        -: 1359:        }
        -: 1360:    } else {
    #####: 1361:        parser_error(parser, "class var error");
        -: 1362:    }
    #####: 1363:}
        -: 1364:
    #####: 1365:static void class_static_assignment_expr(bparser *parser, bexpdesc *e, bstring *name)
        -: 1366:{
    #####: 1367:    if (match_skip(parser, OptAssign)) { /* '=' */
        -: 1368:        bexpdesc e1, e2;
        -: 1369:        /* parse the right expression */
    #####: 1370:        expr(parser, &e2);
        -: 1371:
    #####: 1372:        e1 = *e;        /* copy the class description */
        -: 1373:        bexpdesc key;   /* build the member key */
    #####: 1374:        init_exp(&key, ETSTRING, 0);
    #####: 1375:        key.v.s = name;
        -: 1376:
    #####: 1377:        be_code_member(parser->finfo, &e1, &key);   /* compute member accessor */
    #####: 1378:        be_code_setvar(parser->finfo, &e1, &e2);    /* set member */
        -: 1379:    }
    #####: 1380:}
        -: 1381:
    #####: 1382:static void classstatic_stmt(bparser *parser, bclass *c, bexpdesc *e)
        -: 1383:{
        -: 1384:    bstring *name;
        -: 1385:    /* 'static' ID ['=' expr] {',' ID ['=' expr] } */
    #####: 1386:    scan_next_token(parser); /* skip 'static' */
    #####: 1387:    if (match_id(parser, name) != NULL) {
    #####: 1388:        check_class_attr(parser, c, name);
    #####: 1389:        be_member_bind(parser->vm, c, name, bfalse);
    #####: 1390:        class_static_assignment_expr(parser, e, name);
        -: 1391:
    #####: 1392:        while (match_skip(parser, OptComma)) { /* ',' */
    #####: 1393:            if (match_id(parser, name) != NULL) {
    #####: 1394:                check_class_attr(parser, c, name);
    #####: 1395:                be_member_bind(parser->vm, c, name, bfalse);
    #####: 1396:                class_static_assignment_expr(parser, e, name);
        -: 1397:            } else {
    #####: 1398:                parser_error(parser, "class static error");
        -: 1399:            }
        -: 1400:        }
        -: 1401:    } else {
    #####: 1402:        parser_error(parser, "class static error");
        -: 1403:    }
    #####: 1404:}
        -: 1405:
    #####: 1406:static void classdef_stmt(bparser *parser, bclass *c)
        -: 1407:{
        -: 1408:    bexpdesc e;
        -: 1409:    bstring *name;
        -: 1410:    bproto *proto;
        -: 1411:    /* 'def' ID '(' varlist ')' block 'end' */
    #####: 1412:    scan_next_token(parser); /* skip 'def' */
    #####: 1413:    name = func_name(parser, &e, 1);
    #####: 1414:    check_class_attr(parser, c, name);
    #####: 1415:    proto = funcbody(parser, name, FUNC_METHOD);
    #####: 1416:    be_method_bind(parser->vm, c, proto->name, proto);
    #####: 1417:    be_stackpop(parser->vm, 1);
    #####: 1418:}
        -: 1419:
    #####: 1420:static void class_inherit(bparser *parser, bexpdesc *e)
        -: 1421:{
    #####: 1422:    if (next_type(parser) == OptColon) { /* ':' */
        -: 1423:        bexpdesc e1;
    #####: 1424:        scan_next_token(parser); /* skip ':' */
    #####: 1425:        expr(parser, &e1);
    #####: 1426:        check_var(parser, &e1);
    #####: 1427:        be_code_setsuper(parser->finfo, e, &e1);
        -: 1428:    }
    #####: 1429:}
        -: 1430:
    #####: 1431:static void class_block(bparser *parser, bclass *c, bexpdesc *e)
        -: 1432:{
        -: 1433:    /* { [;] } */
    #####: 1434:    while (block_follow(parser)) {
    #####: 1435:        switch (next_type(parser)) {
    #####: 1436:        case KeyVar: classvar_stmt(parser, c); break;
    #####: 1437:        case KeyStatic: classstatic_stmt(parser, c, e); break;
    #####: 1438:        case KeyDef: classdef_stmt(parser, c); break;
    #####: 1439:        case OptSemic: scan_next_token(parser); break;
    #####: 1440:        default: push_error(parser,
        -: 1441:                "unexpected token '%s'", token2str(parser));
        -: 1442:        }
        -: 1443:    }
    #####: 1444:}
        -: 1445:
    #####: 1446:static void class_stmt(bparser *parser)
        -: 1447:{
        -: 1448:    bstring *name;
        -: 1449:    /* 'class' ID [':' ID] class_block 'end' */
    #####: 1450:    scan_next_token(parser); /* skip 'class' */
    #####: 1451:    if (match_id(parser, name) != NULL) {
        -: 1452:        bexpdesc e;
    #####: 1453:        bclass *c = be_newclass(parser->vm, name, NULL);
    #####: 1454:        new_var(parser, name, &e);
    #####: 1455:        be_code_class(parser->finfo, &e, c);
    #####: 1456:        class_inherit(parser, &e);
    #####: 1457:        class_block(parser, c, &e);
    #####: 1458:        be_class_compress(parser->vm, c); /* compress class size */
    #####: 1459:        match_token(parser, KeyEnd); /* skip 'end' */
        -: 1460:    } else {
    #####: 1461:        parser_error(parser, "class name error");
        -: 1462:    }
    #####: 1463:}
        -: 1464:
    #####: 1465:static void import_stmt(bparser *parser)
        -: 1466:{
        -: 1467:    bstring *name; /* variable name */
        -: 1468:    bexpdesc m, v;
        -: 1469:    /* 'import' (ID (['as' ID] | {',' ID}) | STRING 'as' ID ) */
    #####: 1470:    scan_next_token(parser); /* skip 'import' */
    #####: 1471:    init_exp(&m, ETSTRING, 0);
    #####: 1472:    m.v.s = name = next_token(parser).u.s;
    #####: 1473:    if (next_type(parser) == TokenString) { /* STRING 'as' ID */
    #####: 1474:        scan_next_token(parser); /* skip the module path */
    #####: 1475:        match_token(parser, KeyAs); /* match and skip 'as' */
    #####: 1476:        name = next_token(parser).u.s;
    #####: 1477:        match_token(parser, TokenId); /* match and skip ID */
        -: 1478:    } else { /* ID (['as' ID] | {',' ID}) */
    #####: 1479:        match_token(parser, TokenId); /* match and skip ID */
    #####: 1480:        if (match_skip(parser, KeyAs)) { /* 'as' */
    #####: 1481:            name = next_token(parser).u.s;
    #####: 1482:            match_token(parser, TokenId); /* match and skip ID */
        -: 1483:        } else { /* {',' ID} */
    #####: 1484:            while (match_skip(parser, OptComma)) { /* ',' */
    #####: 1485:                new_var(parser, name, &v);
    #####: 1486:                be_code_import(parser->finfo, &m, &v); /* code import */
    #####: 1487:                init_exp(&m, ETSTRING, 0); /* scanning for next node */
    #####: 1488:                m.v.s = name = next_token(parser).u.s;
    #####: 1489:                match_token(parser, TokenId); /* match and skip ID */
        -: 1490:            }
        -: 1491:        }
        -: 1492:    }
    #####: 1493:    new_var(parser, name, &v);
    #####: 1494:    be_code_import(parser->finfo, &m, &v);
    #####: 1495:}
        -: 1496:
    #####: 1497:static void var_field(bparser *parser)
        -: 1498:{
        -: 1499:    /* ID ['=' expr] */
        -: 1500:    bexpdesc e1, e2;
        -: 1501:    bstring *name;
    #####: 1502:    name = next_token(parser).u.s;
    #####: 1503:    match_token(parser, TokenId); /* match and skip ID */
    #####: 1504:    if (match_skip(parser, OptAssign)) { /* '=' */
    #####: 1505:        expr(parser, &e2);
    #####: 1506:        check_var(parser, &e2);
        -: 1507:    } else {
    #####: 1508:        init_exp(&e2, ETNIL, 0);
        -: 1509:    }
    #####: 1510:    new_var(parser, name, &e1); /* new variable */
    #####: 1511:    be_code_setvar(parser->finfo, &e1, &e2);
    #####: 1512:}
        -: 1513:
    #####: 1514:static void var_stmt(bparser *parser)
        -: 1515:{
        -: 1516:    /* 'var' ID ['=' expr] {',' ID ['=' expr]} */
    #####: 1517:    scan_next_token(parser); /* skip 'var' */
    #####: 1518:    var_field(parser);
    #####: 1519:    while (match_skip(parser, OptComma)) { /* ',' */
    #####: 1520:        var_field(parser);
        -: 1521:    }
    #####: 1522:}
        -: 1523:
    #####: 1524:static int except_case_list(bparser *parser, int *base)
        -: 1525:{
        -: 1526:    int idx;
        -: 1527:    bexpdesc e;
    #####: 1528:    bfuncinfo *finfo = parser->finfo;
        -: 1529:    /* expr {',' expr} | '..' */
    #####: 1530:    if (match_skip(parser, OptConnect)) { /* '..' */
    #####: 1531:        *base = finfo->freereg;
    #####: 1532:        return 0;
        -: 1533:    }
    #####: 1534:    expr(parser, &e); /* first exception expression */
    #####: 1535:    check_var(parser, &e);
    #####: 1536:    *base = idx = be_code_nextreg(finfo, &e);
    #####: 1537:    while (match_skip(parser, OptComma)) { /* ',' */
    #####: 1538:        expr(parser, &e);
    #####: 1539:        check_var(parser, &e);
    #####: 1540:        idx = be_code_nextreg(finfo, &e);
        -: 1541:    }
    #####: 1542:    idx = idx - *base + 1; /* count of exception expression */
    #####: 1543:    be_code_freeregs(finfo, idx);
    #####: 1544:    return idx;
        -: 1545:}
        -: 1546:
    #####: 1547:static int except_var_list(bparser *parser, int base)
        -: 1548:{
        -: 1549:    bexpdesc v;
        -: 1550:    (void)base; /* unused variable (no debugging) */
        -: 1551:    /* [as ID [, ID]] */
    #####: 1552:    if (match_skip(parser, KeyAs)) { /* 'as' */
    #####: 1553:        bstring *name = next_token(parser).u.s;
    #####: 1554:        match_token(parser, TokenId); /* match and skip ID */
    #####: 1555:        new_var(parser, name, &v); /* new local variable */
        -: 1556:        be_assert(v.type == ETLOCAL && v.v.idx == base);
    #####: 1557:        if (match_skip(parser, OptComma)) { /* match and skip ',' */
    #####: 1558:            name = next_token(parser).u.s;
    #####: 1559:            match_token(parser, TokenId); /* match and skip ID */
    #####: 1560:            new_var(parser, name, &v); /* new local variable */
        -: 1561:            be_assert(v.type == ETLOCAL && v.v.idx == base + 1);
    #####: 1562:            return 2;
        -: 1563:        }
    #####: 1564:        return 1;
        -: 1565:    }
    #####: 1566:    return 0;
        -: 1567:}
        -: 1568:
    #####: 1569:static void except_block(bparser *parser, int *jmp, int *jbrk)
        -: 1570:{
    #####: 1571:    int base = 0; /* the first register of the catch opcode */
    #####: 1572:    int ecnt = 0; /* exception cases count */
    #####: 1573:    int vcnt = 0; /* exception variable count */
        -: 1574:    bblockinfo binfo;
    #####: 1575:    bfuncinfo *finfo = parser->finfo;
        -: 1576:    /* 'except' (expr {',' expr} | '..') ['as' ID [',' ID]] */
    #####: 1577:    match_token(parser, KeyExcept); /* skip 'except' */
    #####: 1578:    begin_block(finfo, &binfo, 0); /* begin catch block */
        -: 1579:    /* link from the previous except failure point */
    #####: 1580:    be_code_conjump(finfo, jmp, finfo->pc);
        -: 1581:    /* (expr {',' expr} | '..') ['as' ID [',' ID]] */
    #####: 1582:    ecnt = except_case_list(parser, &base);
    #####: 1583:    vcnt = except_var_list(parser, base);
    #####: 1584:    be_code_catch(finfo, base, ecnt, vcnt, jmp);
    #####: 1585:    stmtlist(parser);
    #####: 1586:    be_code_conjump(finfo, jbrk, be_code_jump(finfo));
    #####: 1587:    end_block(parser); /* leave catch block */
    #####: 1588:}
        -: 1589:
    #####: 1590:static void try_stmt(bparser *parser)
        -: 1591:{
        -: 1592:    int jcatch, jbrk;
        -: 1593:    /* 'try' block 'except' except_stmt block 'end' */
    #####: 1594:    scan_next_token(parser); /* skip 'try' */
    #####: 1595:    jcatch = be_code_exblk(parser->finfo, 0);
    #####: 1596:    block(parser, BLOCK_EXCEPT);
    #####: 1597:    be_code_exblk(parser->finfo, 1);
    #####: 1598:    jbrk = be_code_jump(parser->finfo);
    #####: 1599:    except_block(parser, &jcatch, &jbrk);
    #####: 1600:    while (next_type(parser) == KeyExcept) {
    #####: 1601:        except_block(parser, &jcatch, &jbrk);
        -: 1602:    }
    #####: 1603:    be_code_patchjump(parser->finfo, jcatch);
    #####: 1604:    be_code_raise(parser->finfo, NULL, NULL);
    #####: 1605:    be_code_patchjump(parser->finfo, jbrk);
    #####: 1606:    match_token(parser, KeyEnd); /* skip 'end' */
    #####: 1607:}
        -: 1608:
    #####: 1609:static void throw_stmt(bparser *parser)
        -: 1610:{
        -: 1611:    bexpdesc e1, e2;
        -: 1612:    /* 'raise' expr */
    #####: 1613:    scan_next_token(parser); /* skip 'raise' */
    #####: 1614:    expr(parser, &e1);
    #####: 1615:    check_var(parser, &e1);
    #####: 1616:    if (match_skip(parser, OptComma)) {
    #####: 1617:        expr(parser, &e2);
    #####: 1618:        check_var(parser, &e2);
    #####: 1619:        be_code_raise(parser->finfo, &e1, &e2);
        -: 1620:    } else {
    #####: 1621:        be_code_raise(parser->finfo, &e1, NULL);
        -: 1622:    }
    #####: 1623:}
        -: 1624:
        9: 1625:static void statement(bparser *parser)
        -: 1626:{
        9: 1627:    switch (next_type(parser)) {
    #####: 1628:    case KeyIf: if_stmt(parser); break;
    #####: 1629:    case KeyWhile: while_stmt(parser); break;
    #####: 1630:    case KeyFor: for_stmt(parser); break;
    #####: 1631:    case KeyDo: do_stmt(parser); break;
    #####: 1632:    case KeyBreak: break_stmt(parser); break;
    #####: 1633:    case KeyContinue: continue_stmt(parser); break;
    #####: 1634:    case KeyDef: def_stmt(parser); break;
    #####: 1635:    case KeyClass: class_stmt(parser); break;
    #####: 1636:    case KeyReturn: return_stmt(parser); break;
    #####: 1637:    case KeyImport: import_stmt(parser); break;
    #####: 1638:    case KeyVar: var_stmt(parser); break;
    #####: 1639:    case KeyTry: try_stmt(parser); break;
    #####: 1640:    case KeyRaise: throw_stmt(parser); break;
    #####: 1641:    case OptSemic: scan_next_token(parser); break; /* empty statement */
        9: 1642:    default: expr_stmt(parser); break;
        -: 1643:    }
        -: 1644:    be_assert(parser->finfo->freereg == be_list_count(parser->finfo->local));
        9: 1645:}
        -: 1646:
        1: 1647:static void stmtlist(bparser *parser)
        -: 1648:{
       10: 1649:    while (block_follow(parser)) {
        9: 1650:        statement(parser);
        -: 1651:    }
        1: 1652:}
        -: 1653:
    #####: 1654:static void block(bparser *parser, int type)
        -: 1655:{
        -: 1656:    bblockinfo binfo;
    #####: 1657:    begin_block(parser->finfo, &binfo, type);
    #####: 1658:    stmtlist(parser);
    #####: 1659:    end_block(parser);
    #####: 1660:}
        -: 1661:
        1: 1662:static void mainfunc(bparser *parser, bclosure *cl)
        -: 1663:{
        -: 1664:    bblockinfo binfo;
        -: 1665:    bfuncinfo finfo;
        1: 1666:    begin_func(parser, &finfo, &binfo);
        1: 1667:    finfo.proto->argc = 0; /* args */
       1*: 1668:    finfo.proto->name = be_newstr(parser->vm, funcname(parser));
        1: 1669:    cl->proto = finfo.proto;
        1: 1670:    be_remove(parser->vm, -3);  /* pop proto from stack */
        1: 1671:    stmtlist(parser);
        1: 1672:    end_func(parser);
        1: 1673:    match_token(parser, TokenEOS); /* skip EOS */
        1: 1674:}
        -: 1675:
        1: 1676:bclosure* be_parser_source(bvm *vm,
        -: 1677:    const char *fname, breader reader, void *data, bbool islocal)
        -: 1678:{
        -: 1679:    bparser parser;
        1: 1680:    bclosure *cl = be_newclosure(vm, 0);
        1: 1681:    parser.vm = vm;
        1: 1682:    parser.finfo = NULL;
        1: 1683:    parser.cl = cl;
        1: 1684:    parser.islocal = (bbyte)islocal;
        1: 1685:    var_setclosure(vm->top, cl);
        1: 1686:    be_stackpush(vm);
        1: 1687:    be_lexer_init(&parser.lexer, vm, fname, reader, data);
        1: 1688:    scan_next_token(&parser); /* scan first token */
        1: 1689:    mainfunc(&parser, cl);
        1: 1690:    be_lexer_deinit(&parser.lexer);
        1: 1691:    be_global_release_space(vm); /* clear global space */
        1: 1692:    be_stackpop(vm, 2); /* pop strtab */
        1: 1693:    scan_next_token(&parser); /* clear lexer */
        1: 1694:    return cl;
        -: 1695:}
        -: 1696:
        -: 1697:#endif
