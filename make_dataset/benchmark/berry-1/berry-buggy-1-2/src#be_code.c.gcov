        -:    0:Source:src/be_code.c
        -:    0:Graph:./src/be_code.gcno
        -:    0:Data:./src/be_code.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_code.h"
        -:    9:#include "be_decoder.h"
        -:   10:#include "be_parser.h"
        -:   11:#include "be_lexer.h"
        -:   12:#include "be_vector.h"
        -:   13:#include "be_list.h"
        -:   14:#include "be_var.h"
        -:   15:#include "be_exec.h"
        -:   16:#include "be_vm.h"
        -:   17:
        -:   18:#define NOT_MASK                (1 << 0)
        -:   19:#define NOT_EXPR                (1 << 1)
        -:   20:#define FUNC_RET_FLAG           (1 << 0)
        -:   21:
        -:   22:#define isset(v, mask)          (((v) & (mask)) != 0)
        -:   23:#define min(a, b)               ((a) < (b) ? (a) : (b))
        -:   24:#define notexpr(e)              isset((e)->not, NOT_EXPR)
        -:   25:#define notmask(e)              isset((e)->not, NOT_MASK)
        -:   26:#define exp2anyreg(f, e)        exp2reg(f, e, -1)   /* -1 means allocate a new register if needed */
        -:   27:#define var2anyreg(f, e)        var2reg(f, e, -1)   /* -1 means allocate a new register if needed */
        -:   28:#define hasjump(e)              ((e)->t != (e)->f || notexpr(e))
        -:   29:#define code_bool(f, r, b, j)   codeABC(f, OP_LDBOOL, r, b, j)
        -:   30:#define code_call(f, a, b)      codeABC(f, OP_CALL, a, b, 0)
        -:   31:#define code_getmbr(f, a, b, c) codeABC(f, OP_GETMBR, a, b, c)
        -:   32:#define jumpboolop(e, b)        ((b) != notmask(e) ? OP_JMPT : OP_JMPF)
        -:   33:
        -:   34:#if BE_USE_SCRIPT_COMPILER
        -:   35:
        -:   36:static int var2reg(bfuncinfo *finfo, bexpdesc *e, int dst);
        -:   37:
        -:   38:#if BE_DEBUG_RUNTIME_INFO
       56:   39:static void codelineinfo(bfuncinfo *finfo)
        -:   40:{
       56:   41:    bvector *vec = &finfo->linevec;
       56:   42:    int line = finfo->lexer->lastline;
       56:   43:    blineinfo *li = be_vector_end(vec);
       56:   44:    if (be_vector_isempty(vec) || li->linenumber != line) {
        9:   45:        be_vector_push(finfo->lexer->vm, vec, NULL);
        9:   46:        li = be_vector_end(vec);
        9:   47:        li->endpc = finfo->pc;
        9:   48:        li->linenumber = line;
        9:   49:        finfo->proto->lineinfo = be_vector_data(vec);
        9:   50:        finfo->proto->nlineinfo = be_vector_capacity(vec);
        -:   51:    } else {
       47:   52:        li->endpc = finfo->pc;
        -:   53:    }
       56:   54:}
        -:   55:#else
        -:   56:    #define codelineinfo(finfo)
        -:   57:#endif
        -:   58:
        -:   59:/* Add new instruction in the code vector */
       56:   60:static int codeinst(bfuncinfo *finfo, binstruction ins)
        -:   61:{
        -:   62:    /* put new instruction in code array */
       56:   63:    be_vector_push_c(finfo->lexer->vm, &finfo->code, &ins);
       56:   64:    finfo->proto->code = be_vector_data(&finfo->code);
       56:   65:    finfo->proto->codesize = be_vector_capacity(&finfo->code);
       56:   66:    codelineinfo(finfo);
       56:   67:    return finfo->pc++;
        -:   68:}
        -:   69:
       24:   70:static int codeABC(bfuncinfo *finfo, bopcode op, int a, int b, int c)
        -:   71:{
       48:   72:    return codeinst(finfo, ISET_OP(op)
       24:   73:        | ISET_RA(a) | ISET_RKB(b) | ISET_RKC(c));
        -:   74:}
        -:   75:
       32:   76:static int codeABx(bfuncinfo *finfo, bopcode op, int a, int bx)
        -:   77:{
       32:   78:    return codeinst(finfo, ISET_OP(op) | ISET_RA(a) | ISET_Bx(bx));
        -:   79:}
        -:   80:
        -:   81:/* Move value from register b to register a */
        -:   82:/* Check the previous instruction to compact both instruction as one if possible */
        -:   83:/* If b is a constant, add LDCONST or add MOVE otherwise */
    #####:   84:static void code_move(bfuncinfo *finfo, int a, int b)
        -:   85:{
    #####:   86:    if (finfo->pc) {  /* If not the first instruction of the function */
    #####:   87:        binstruction *i = be_vector_end(&finfo->code);  /* get the last instruction */
    #####:   88:        bopcode op = IGET_OP(*i);
    #####:   89:        if (op <= OP_LDNIL) { /* binop or unop */
        -:   90:            /* remove redundant MOVE instruction */
    #####:   91:            int x = IGET_RA(*i), y = IGET_RKB(*i), z = IGET_RKC(*i);
    #####:   92:            if (b == x && (a == y || (op < OP_NEG && a == z))) {
    #####:   93:                *i = (*i & ~IRA_MASK) | ISET_RA(a);
    #####:   94:                return;
        -:   95:            }
        -:   96:        }
        -:   97:    }
    #####:   98:    if (isK(b)) {
    #####:   99:        codeABx(finfo, OP_LDCONST, a, b & 0xFF);
        -:  100:    } else {
    #####:  101:        codeABC(finfo, OP_MOVE, a, b, 0);
        -:  102:    }
        -:  103:}
        -:  104:
        -:  105:/* Free register at top (checks that it´s a register) */
        -:  106:/* Warning: the register must be at top of stack */
        1:  107:static void free_expreg(bfuncinfo *finfo, bexpdesc *e)
        -:  108:{
        -:  109:    /* release temporary register */
        1:  110:    if (e && e->type == ETREG) {
        1:  111:        be_code_freeregs(finfo, 1);
        -:  112:    }
        1:  113:}
        -:  114:
        -:  115:/* Privat. Allocate `count` new registers on the stack and uptade proto´s max nstack accordingly */
        -:  116:/* Note: deallocate is simpler and handled by a macro */
       31:  117:static void allocstack(bfuncinfo *finfo, int count)
        -:  118:{
       31:  119:    int nstack = finfo->freereg + count;
       31:  120:    if (nstack > finfo->proto->nstack) {
        3:  121:        if (nstack >= 255) {
    #####:  122:            be_lexerror(finfo->lexer, "register overflow (more than 255)");
        -:  123:        }
        3:  124:        finfo->proto->nstack = (bbyte)nstack;
        -:  125:    }
       31:  126:}
        -:  127:
        -:  128:/* Allocate `count` registers at top of stack, update stack accordingly */
       31:  129:int be_code_allocregs(bfuncinfo *finfo, int count)
        -:  130:{
       31:  131:    int base = finfo->freereg;
       31:  132:    allocstack(finfo, count);
       31:  133:    finfo->freereg += (char)count;
       31:  134:    return base;
        -:  135:}
        -:  136:
    #####:  137:static void setjump(bfuncinfo *finfo, int pc, int dst)
        -:  138:{
    #####:  139:    binstruction *p = be_vector_at(&finfo->code, pc);
    #####:  140:    int offset = dst - (pc + 1);
        -:  141:    /* instruction edit jump destination */
    #####:  142:    *p = (*p & ~IBx_MASK) | ISET_sBx(offset);
    #####:  143:}
        -:  144:
    #####:  145:static int isjumpbool(bfuncinfo *finfo, int pc)
        -:  146:{
    #####:  147:    binstruction *p = be_vector_at(&finfo->code, pc);
    #####:  148:    bopcode op = IGET_OP(*p);
        -:  149:
    #####:  150:    if (op == OP_JMPT || op == OP_JMPF) {
    #####:  151:        return 1;
        -:  152:    }
    #####:  153:    return 0;
        -:  154:}
        -:  155:
    #####:  156:static int get_jump(bfuncinfo *finfo, int pc)
        -:  157:{
    #####:  158:    binstruction *i = be_vector_at(&finfo->code, pc);
    #####:  159:    int offset = IGET_sBx(*i);
    #####:  160:    return offset == NO_JUMP ? NO_JUMP : pc + 1 + offset;
        -:  161:}
        -:  162:
    #####:  163:static void patchlistaux(bfuncinfo *finfo, int list, int vtarget, int dtarget)
        -:  164:{
    #####:  165:    while (list != NO_JUMP) {
    #####:  166:        int next = get_jump(finfo, list);
    #####:  167:        if (isjumpbool(finfo, list)) {
    #####:  168:            setjump(finfo, list, dtarget);  /* jump to default target */
        -:  169:        } else {
    #####:  170:            setjump(finfo, list, vtarget);
        -:  171:        }
    #####:  172:        list = next;
        -:  173:    }
    #####:  174:}
        -:  175:
    #####:  176:static int appendjump(bfuncinfo *finfo, bopcode op, bexpdesc *e)
        -:  177:{
    #####:  178:    int reg = e ? var2anyreg(finfo, e) : 0;
    #####:  179:    if (isK(reg)) {
    #####:  180:        reg = be_code_allocregs(finfo, 1);
    #####:  181:        code_move(finfo, reg, e->v.idx);
    #####:  182:        e->v.idx = reg;
    #####:  183:        e->type = ETREG;
        -:  184:    }
    #####:  185:    return codeABx(finfo, op, reg, NO_JUMP + IsBx_MAX);
        -:  186:}
        -:  187:
    #####:  188:int be_code_jump(bfuncinfo *finfo)
        -:  189:{
    #####:  190:    return appendjump(finfo, OP_JMP, NULL);
        -:  191:}
        -:  192:
    #####:  193:void be_code_jumpto(bfuncinfo *finfo, int dst)
        -:  194:{
    #####:  195:    be_code_patchlist(finfo, be_code_jump(finfo), dst);
    #####:  196:}
        -:  197:
    #####:  198:void be_code_jumpbool(bfuncinfo *finfo, bexpdesc *e, int jture)
        -:  199:{
    #####:  200:    int pc = appendjump(finfo, jumpboolop(e, jture), e);
    #####:  201:    be_code_conjump(finfo, jture ? &e->t : &e->f, pc);
    #####:  202:    be_code_patchjump(finfo, jture ? e->f : e->t);
    #####:  203:    free_expreg(finfo, e);
    #####:  204:    jture ? (e->f = NO_JUMP) : (e->t = NO_JUMP);
    #####:  205:    e->not = 0;
    #####:  206:}
        -:  207:
        -:  208:/* connect jump */
    #####:  209:void be_code_conjump(bfuncinfo *finfo, int *list, int jmp)
        -:  210:{
    #####:  211:    if (jmp == NO_JUMP) {
    #####:  212:        return;
        -:  213:    }
    #####:  214:    if (*list == NO_JUMP) {
    #####:  215:        *list = jmp;
        -:  216:    } else {
    #####:  217:        int next, l = *list;
    #####:  218:        while ((next = (get_jump(finfo, l))) != NO_JUMP) {
    #####:  219:            l = next;
        -:  220:        }
    #####:  221:        setjump(finfo, l, jmp);
        -:  222:    }
        -:  223:}
        -:  224:
    #####:  225:void be_code_patchlist(bfuncinfo *finfo, int list, int dst)
        -:  226:{
    #####:  227:    if (dst == finfo->pc) {
    #####:  228:        be_code_patchjump(finfo, list);
        -:  229:    } else {
    #####:  230:        patchlistaux(finfo, list, dst, dst);
        -:  231:    }
    #####:  232:}
        -:  233:
    #####:  234:void be_code_patchjump(bfuncinfo *finfo, int jmp)
        -:  235:{
    #####:  236:    patchlistaux(finfo, jmp, finfo->pc, finfo->pc);
    #####:  237:}
        -:  238:
        -:  239:/* Allocate new constant for value k */
        -:  240:/* If k is NULL then push `nil` value */
    #####:  241:static int newconst(bfuncinfo *finfo, bvalue *k)
        -:  242:{
    #####:  243:    int idx = be_vector_count(&finfo->kvec);
    #####:  244:    be_vector_push_c(finfo->lexer->vm, &finfo->kvec, k);
    #####:  245:    finfo->proto->ktab = be_vector_data(&finfo->kvec);
    #####:  246:    finfo->proto->nconst = be_vector_capacity(&finfo->kvec);
    #####:  247:    if (k == NULL) {
    #####:  248:        var_setnil(&finfo->proto->ktab[idx]);
        -:  249:    }
    #####:  250:    return idx;
        -:  251:}
        -:  252:
        -:  253:/* Find constant by value and return constant number, or -1 if constant does not exist */
        -:  254:/* The search is linear and limited to BE_CONST_SEARCH_SIZE elements for performance reasons */
    #####:  255:static int findconst(bfuncinfo *finfo, bexpdesc *e)
        -:  256:{
    #####:  257:    int i, count = be_vector_count(&finfo->kvec);
        -:  258:    /* if the constant table is too large, the lookup
        -:  259:     * operation will become very time consuming.
        -:  260:     * so only search the constant table for the
        -:  261:     * previous value.
        -:  262:     **/
    #####:  263:    count = count < BE_CONST_SEARCH_SIZE ? count : BE_CONST_SEARCH_SIZE;
    #####:  264:    for (i = 0; i < count; ++i) {
    #####:  265:        bvalue *k = be_vector_at(&finfo->kvec, i);
    #####:  266:        switch (e->type) {
    #####:  267:        case ETINT:
    #####:  268:            if (var_isint(k) && k->v.i == e->v.i) {
    #####:  269:                return i;
        -:  270:            }
    #####:  271:            break;
    #####:  272:        case ETREAL:
    #####:  273:            if (var_isreal(k) && k->v.r == e->v.r) {
    #####:  274:                return i;
        -:  275:            }
    #####:  276:            break;
    #####:  277:        case ETSTRING:
    #####:  278:            if (var_isstr(k) && be_eqstr(k->v.p, e->v.s)) {
    #####:  279:                return i;
        -:  280:            }
    #####:  281:            break;
    #####:  282:        default:
    #####:  283:            break;
        -:  284:        }
        -:  285:    }
    #####:  286:    return -1;
        -:  287:}
        -:  288:
        -:  289:/* convert expdesc to constant and return kreg index (either constant kindex or register number) */
    #####:  290:static int exp2const(bfuncinfo *finfo, bexpdesc *e)
        -:  291:{
    #####:  292:    int idx = findconst(finfo, e); /* does the constant already exist? */
    #####:  293:    if (idx == -1) { /* if not add it */
        -:  294:        bvalue k;
    #####:  295:        switch (e->type) {
    #####:  296:        case ETINT:
    #####:  297:            k.type = BE_INT;
    #####:  298:            k.v.i = e->v.i;
    #####:  299:            break;
    #####:  300:        case ETREAL:
    #####:  301:            k.type = BE_REAL;
    #####:  302:            k.v.r = e->v.r;
    #####:  303:            break;
    #####:  304:        case ETSTRING:
    #####:  305:            k.type = BE_STRING;
    #####:  306:            k.v.s = e->v.s;
    #####:  307:            break;
    #####:  308:        default: /* all other values are filled later */
    #####:  309:            break;
        -:  310:        }
    #####:  311:        idx = newconst(finfo, &k);  /* create new constant */
        -:  312:    }
    #####:  313:    if (idx < 256) {  /* if constant number fits in KB or KC */
    #####:  314:        e->type = ETCONST;  /* new type is constant by index */
    #####:  315:        e->v.idx = setK(idx);
        -:  316:    } else { /* index value is too large */
    #####:  317:        e->type = ETREG;  /* does not fit in compact mode, allocate an explicit register and emit LDCONTS */
    #####:  318:        e->v.idx = be_code_allocregs(finfo, 1);
    #####:  319:        codeABx(finfo, OP_LDCONST, e->v.idx, idx);
        -:  320:    }
    #####:  321:    return e->v.idx;
        -:  322:}
        -:  323:
    #####:  324:static void free_suffix(bfuncinfo *finfo, bexpdesc *e)
        -:  325:{
    #####:  326:    int idx = e->v.ss.idx;
    #####:  327:    int nlocal = be_list_count(finfo->local);
        -:  328:    /* release suffix register */
    #####:  329:    if (!isK(idx) && idx >= nlocal) {
    #####:  330:        be_code_freeregs(finfo, 1);
        -:  331:    }
        -:  332:    /* release object register */
    #####:  333:    if (e->v.ss.tt == ETREG && (int)e->v.ss.obj >= nlocal && (e->v.ss.obj + 1 >= finfo->freereg)) {
    #####:  334:        be_code_freeregs(finfo, 1);
        -:  335:    }
    #####:  336:}
        -:  337:
    #####:  338:static int suffix_destreg(bfuncinfo *finfo, bexpdesc *e1, int dst)
        -:  339:{
    #####:  340:    int cand_dst = dst;  /* candidate for new dst */
    #####:  341:    int nlocal = be_list_count(finfo->local);
    #####:  342:    int reg1 = (e1->v.ss.tt == ETREG) ? e1->v.ss.obj : -1;  /* check if obj is ETREG or -1 */
    #####:  343:    int reg2 = (!isK(e1->v.ss.idx) && e1->v.ss.idx >= nlocal) ? e1->v.ss.idx : -1;  /* check if idx is ETREG or -1 */
        -:  344:
    #####:  345:    if (reg1 >= 0 && reg2 >= 0) {
        -:  346:        /* both are ETREG, we keep the lowest and discard the other */
    #####:  347:        if (reg1 != reg2) {
    #####:  348:            cand_dst = min(reg1, reg2);
    #####:  349:            be_code_freeregs(finfo, 1);  /* and free the other one */
        -:  350:        } else {
    #####:  351:            cand_dst = reg1;  /* both ETREG are equal, we return its value */
        -:  352:        }
    #####:  353:    } else if (reg1 >= 0) {
    #####:  354:        cand_dst = reg1;
    #####:  355:    } else if (reg2 >= 0) {
    #####:  356:        cand_dst = reg2;
        -:  357:    } else {
        -:  358:        // dst unchanged
        -:  359:    }
        -:  360:
    #####:  361:    if (dst >= finfo->freereg) {
    #####:  362:        dst = cand_dst;  /* if dst was allocating a new register, use the more precise candidate */
        -:  363:    }
    #####:  364:    return dst;
        -:  365:}
        -:  366:
    #####:  367:static int code_suffix(bfuncinfo *finfo, bopcode op, bexpdesc *e, int dst)
        -:  368:{
    #####:  369:    dst = suffix_destreg(finfo, e, dst);
    #####:  370:    if (dst > finfo->freereg) {
    #####:  371:        dst = finfo->freereg;
        -:  372:    }
    #####:  373:    codeABC(finfo, op, dst, e->v.ss.obj, e->v.ss.idx);
    #####:  374:    return dst;
        -:  375:}
        -:  376:
        -:  377:/* idx: the proto index in proto_table
        -:  378: * dst: the destination register
        -:  379: **/
    #####:  380:static void code_closure(bfuncinfo *finfo, int idx, int dst)
        -:  381:{
    #####:  382:    codeABx(finfo, OP_CLOSURE, dst, idx); /* load closure to register */
    #####:  383:}
        -:  384:
        -:  385:/* Given an integer, check if we should create a constant */
        -:  386:/* True for values 0..3 and if there is room for kindex */
        -:  387:/* This optimization makes code more compact for commonly used ints */
       19:  388:static bbool constint(bfuncinfo *finfo, bint i)
        -:  389:{
        -:  390:    /* cache common numbers */
       19:  391:    if ((i < IsBx_MIN || i > IsBx_MAX) ||
      16*:  392:        (i >= 0 && i <= 3 && be_vector_count(&finfo->kvec) < 256)) {
    #####:  393:        return btrue;
        -:  394:    }
       19:  395:    return bfalse;
        -:  396:}
        -:  397:
        -:  398:/* Compute variable from an expdesc */
        -:  399:/* Return constant index, or existing register or fallback to dst */
        -:  400:/* At exit, If dst is `freereg`, the register is allocated */
       60:  401:static int var2reg(bfuncinfo *finfo, bexpdesc *e, int dst)
        -:  402:{
       60:  403:    if (dst < 0) {  /* if unspecified, allocate a new register if needed */
       46:  404:        dst = finfo->freereg;
        -:  405:    }
        -:  406:    be_assert(e != NULL);
       60:  407:    switch (e->type) {
       19:  408:    case ETINT:
       19:  409:        if (constint(finfo, e->v.i)) {
    #####:  410:            return exp2const(finfo, e);
        -:  411:        } else {
       19:  412:            codeABx(finfo, OP_LDINT, dst, var_toidx(e) + IsBx_MAX);
        -:  413:        }
       19:  414:        break;
    #####:  415:    case ETBOOL:
    #####:  416:        code_bool(finfo, dst, e->v.i != 0, 0);
    #####:  417:        break;
    #####:  418:    case ETNIL:
    #####:  419:        codeABx(finfo, OP_LDNIL, dst, 0);
    #####:  420:        break;
    #####:  421:    case ETREAL:
        -:  422:    case ETSTRING:
    #####:  423:        return exp2const(finfo, e);
    #####:  424:    case ETPROTO:
    #####:  425:        code_closure(finfo, e->v.idx, dst);
    #####:  426:        break;
       12:  427:    case ETGLOBAL:
       12:  428:        codeABx(finfo, OP_GETGBL, dst, e->v.idx);
       12:  429:        break;
    #####:  430:    case ETNGLOBAL:
    #####:  431:        codeABC(finfo, OP_GETNGBL, dst, e->v.ss.idx, 0);
    #####:  432:        break;
    #####:  433:    case ETUPVAL:
    #####:  434:        codeABx(finfo, OP_GETUPV, dst, e->v.idx);
    #####:  435:        break;
    #####:  436:    case ETMEMBER:
    #####:  437:        dst = code_suffix(finfo, OP_GETMBR, e, dst);
    #####:  438:        break;
    #####:  439:    case ETINDEX:
    #####:  440:        dst = code_suffix(finfo, OP_GETIDX, e, dst);
    #####:  441:        break;
       29:  442:    case ETLOCAL: case ETREG: case ETCONST:
       29:  443:        return e->v.idx;
    #####:  444:    default:
    #####:  445:        return dst; /* error */
        -:  446:    }
       31:  447:    if (dst == finfo->freereg) { /* use a new register */
       31:  448:        be_code_allocregs(finfo, 1);
        -:  449:    }
       31:  450:    e->type = ETREG;
       31:  451:    e->v.idx = dst;
       31:  452:    return dst;
        -:  453:}
        -:  454:
       60:  455:static int exp2reg(bfuncinfo *finfo, bexpdesc *e, int dst)
        -:  456:{
       60:  457:    int reg = var2reg(finfo, e, dst);
       60:  458:    if (hasjump(e)) { /* if conditional expression */
    #####:  459:        int pcf = NO_JUMP;  /* position of an eventual LOAD false */
    #####:  460:        int pct = NO_JUMP;  /* position of an eventual LOAD true */
    #####:  461:        int jpt = appendjump(finfo, jumpboolop(e, 1), e);
    #####:  462:        reg = e->v.idx;
    #####:  463:        be_code_conjump(finfo, &e->t, jpt);
    #####:  464:        pcf = code_bool(finfo, reg, 0, 1);
    #####:  465:        pct = code_bool(finfo, reg, 1, 0);
    #####:  466:        patchlistaux(finfo, e->f, finfo->pc, pcf);
    #####:  467:        patchlistaux(finfo, e->t, finfo->pc, pct);
    #####:  468:        e->t = NO_JUMP;
    #####:  469:        e->f = NO_JUMP;
    #####:  470:        e->not = 0;
        -:  471:    }
       60:  472:    return reg;
        -:  473:}
        -:  474:
        -:  475:/* Select dest registers from both expressions */
        -:  476:/* If one of them is already a register, keep it */
        -:  477:/* If e1 or e2 are registers, we keep the lowest and free the highest (that must be at top) */
        -:  478:/* If none is a register, allocate a new one */
        -:  479:/* Returns the destination register, guaranteed to be ETREG */
       14:  480:static int codedestreg(bfuncinfo *finfo, bexpdesc *e1, bexpdesc *e2, int dst)
        -:  481:{
       14:  482:    int cand_dst = dst;
       14:  483:    int con1 = e1->type == ETREG, con2 = e2->type == ETREG;
        -:  484:
       14:  485:    if (con1 && con2) {
       14:  486:        cand_dst = min(e1->v.idx, e2->v.idx);
       14:  487:        be_code_freeregs(finfo, 1);
    #####:  488:    } else if (con1) {
    #####:  489:        cand_dst = e1->v.idx;
    #####:  490:    } else if (con2) {
    #####:  491:        cand_dst = e2->v.idx;
        -:  492:    } else {
    #####:  493:        if (dst >= finfo->freereg) {
    #####:  494:            cand_dst = be_code_allocregs(finfo, 1);
    #####:  495:            return cand_dst;
        -:  496:        }
        -:  497:    }
       14:  498:    if (dst >= finfo->freereg) {
       14:  499:        return cand_dst;
        -:  500:    } else {
    #####:  501:        return dst;
        -:  502:    }
        -:  503:}
        -:  504:
        -:  505:/* compute binary expression and update e1 as result */
        -:  506:/* On exit, e1 is guaranteed to be ETREG, which may have been allocated */
       14:  507:static void binaryexp(bfuncinfo *finfo, bopcode op, bexpdesc *e1, bexpdesc *e2, int dst)
        -:  508:{
       14:  509:    if (dst < 0) { dst = finfo->freereg; }
       14:  510:    int src1 = exp2reg(finfo, e1, dst);  /* potentially force the target for src1 reg */
       14:  511:    int src2 = exp2anyreg(finfo, e2);
       14:  512:    dst = codedestreg(finfo, e1, e2, dst);
       14:  513:    codeABC(finfo, op, dst, src1, src2);
       14:  514:    e1->type = ETREG;
       14:  515:    e1->v.idx = dst; /* update register as output */
       14:  516:}
        -:  517:
       14:  518:void be_code_prebinop(bfuncinfo *finfo, int op, bexpdesc *e)
        -:  519:{
       14:  520:    switch (op) {
    #####:  521:    case OptAnd:
    #####:  522:        be_code_jumpbool(finfo, e, bfalse);
    #####:  523:        break;
    #####:  524:    case OptOr:
    #####:  525:        be_code_jumpbool(finfo, e, btrue);
    #####:  526:        break;
       14:  527:    default:
       14:  528:        exp2anyreg(finfo, e);
       14:  529:        break;
        -:  530:    }
       14:  531:}
        -:  532:
        -:  533:/* Apply binary operator `op` to e1 and e2, result in e1 */
       14:  534:void be_code_binop(bfuncinfo *finfo, int op, bexpdesc *e1, bexpdesc *e2, int dst)
        -:  535:{
       14:  536:    switch (op) {
    #####:  537:    case OptAnd:
    #####:  538:        var2anyreg(finfo, e2);
    #####:  539:        be_code_conjump(finfo, &e2->f, e1->f);
    #####:  540:        *e1 = *e2;
    #####:  541:        break;
    #####:  542:    case OptOr:
    #####:  543:        var2anyreg(finfo, e2);
    #####:  544:        be_code_conjump(finfo, &e2->t, e1->t);
    #####:  545:        *e1 = *e2;
    #####:  546:        break;
       14:  547:    case OptAdd: case OptSub: case OptMul: case OptDiv:
        -:  548:    case OptMod: case OptLT: case OptLE: case OptEQ:
        -:  549:    case OptNE: case OptGT: case OptGE: case OptConnect:
        -:  550:    case OptBitAnd: case OptBitOr: case OptBitXor:
        -:  551:    case OptShiftL: case OptShiftR:
       14:  552:        binaryexp(finfo, (bopcode)(op - OptAdd), e1, e2, dst);
       14:  553:        break;
    #####:  554:    default: break;
        -:  555:    }
       14:  556:}
        -:  557:
        -:  558:/* Apply unary operator and return register number */
        -:  559:/* If input is register, change in place or allocate new register */
        1:  560:static void unaryexp(bfuncinfo *finfo, bopcode op, bexpdesc *e)
        -:  561:{
        1:  562:    int src = exp2anyreg(finfo, e);
       1*:  563:    int dst = e->type == ETREG ? src : be_code_allocregs(finfo, 1);
        1:  564:    codeABC(finfo, op, dst, src, 0);
        1:  565:    e->type = ETREG;
        1:  566:    e->v.idx = dst;
        1:  567:}
        -:  568:
        -:  569:/* Apply not to conditional expression */
        -:  570:/* If literal compute the value */
        -:  571:/* Or invert t/f subexpressions */
    #####:  572:static void code_not(bexpdesc *e)
        -:  573:{
    #####:  574:    switch (e->type) {
    #####:  575:    case ETINT: e->v.i = e->v.i == 0; break;
    #####:  576:    case ETREAL: e->v.i = e->v.r == cast(breal, 0); break;
    #####:  577:    case ETNIL: e->v.i = 1; break;
    #####:  578:    case ETBOOL: e->v.i = !e->v.i; break;
    #####:  579:    case ETSTRING: e->v.i = 0; break;
    #####:  580:    default: {
    #####:  581:        int temp = e->t;
    #####:  582:        e->t = e->f;
    #####:  583:        e->f = temp;
    #####:  584:        e->not = NOT_EXPR | (e->not ^ NOT_MASK);
    #####:  585:        return;
        -:  586:    }
        -:  587:    }
    #####:  588:    e->type = ETBOOL;
        -:  589:}
        -:  590:
        -:  591:/* Negative value of literal or emit NEG opcode */
        2:  592:static int code_neg(bfuncinfo *finfo, bexpdesc *e)
        -:  593:{
        2:  594:    switch (e->type) {
        2:  595:    case ETINT: e->v.i = -e->v.i; break;
    #####:  596:    case ETREAL: e->v.r = -e->v.r; break;
    #####:  597:    case ETNIL: case ETBOOL: case ETSTRING:
    #####:  598:        return 1; /* error */
    #####:  599:    default:
    #####:  600:        unaryexp(finfo, OP_NEG, e);
        -:  601:    }
        2:  602:    return 0;
        -:  603:}
        -:  604:
        -:  605:/* Bit flip of literal or emit FLIP opcode */
        2:  606:static int code_flip(bfuncinfo *finfo, bexpdesc *e)
        -:  607:{
        2:  608:    switch (e->type) {
        1:  609:    case ETINT: e->v.i = ~e->v.i; break;
    #####:  610:    case ETREAL: case ETNIL: case ETBOOL: case ETSTRING:
    #####:  611:        return 2; /* error */
        1:  612:    default:
        1:  613:        unaryexp(finfo, OP_FLIP, e);
        -:  614:    }
        2:  615:    return 0;
        -:  616:}
        -:  617:
        -:  618:/* Apply unary operator: not, neg or bitflip */
        4:  619:int be_code_unop(bfuncinfo *finfo, int op, bexpdesc *e)
        -:  620:{
        4:  621:    switch (op) {
    #####:  622:    case OptNot:
    #####:  623:        code_not(e); break;
        2:  624:    case OptFlip: /* do nothing */
        2:  625:        return code_flip(finfo, e);
        2:  626:    case OptSub:
        2:  627:        return code_neg(finfo, e);
    #####:  628:    default:
    #####:  629:        break;
        -:  630:    }
    #####:  631:    return 0;
        -:  632:}
        -:  633:
    #####:  634:static void setbgblvar(bfuncinfo *finfo, bopcode op, bexpdesc *e1, int src)
        -:  635:{
    #####:  636:    if (isK(src)) { /* move const to register */
    #####:  637:        code_move(finfo, finfo->freereg, src);
    #####:  638:        src = finfo->freereg;
        -:  639:    }
    #####:  640:    codeABC(finfo, op, src, e1->v.idx, 0);
    #####:  641:}
        -:  642:
        1:  643:static void setsupvar(bfuncinfo *finfo, bopcode op, bexpdesc *e1, int src)
        -:  644:{
        1:  645:    if (isK(src)) { /* move const to register */
    #####:  646:        code_move(finfo, finfo->freereg, src);
    #####:  647:        src = finfo->freereg;
        -:  648:    }
        1:  649:    codeABx(finfo, op, src, e1->v.idx);
        1:  650:}
        -:  651:
    #####:  652:static void setsfxvar(bfuncinfo *finfo, bopcode op, bexpdesc *e1, int src)
        -:  653:{
    #####:  654:    int obj = e1->v.ss.obj;
    #####:  655:    free_suffix(finfo, e1);
    #####:  656:    if (isK(obj)) { /* move const to register */
    #####:  657:        code_move(finfo, finfo->freereg, obj);
    #####:  658:        obj = finfo->freereg;
        -:  659:    }
    #####:  660:    codeABC(finfo, op, obj, e1->v.ss.idx, src);
    #####:  661:}
        -:  662:
        -:  663:/* Assign expr e2 to e1 */
        -:  664:/* e1 must be in a register and have a valid idx */
        -:  665:/* return 1 if assignment was possible, 0 if type is not compatible */
        1:  666:int be_code_setvar(bfuncinfo *finfo, bexpdesc *e1, bexpdesc *e2)
        -:  667:{
       1*:  668:    int src = exp2reg(finfo, e2,
        1:  669:        e1->type == ETLOCAL ? e1->v.idx : -1); /* Convert e2 to kreg */
        -:  670:        /* If e1 is a local variable, use the register */
        -:  671:
       1*:  672:    if (e1->type != ETLOCAL || e1->v.idx != src) {
        1:  673:        free_expreg(finfo, e2); /* free source (checks only ETREG) */ /* TODO e2 is at top */
        -:  674:    }
        1:  675:    switch (e1->type) {
    #####:  676:    case ETLOCAL: /* It can't be ETREG. */
    #####:  677:        if (e1->v.idx != src) {
    #####:  678:            code_move(finfo, e1->v.idx, src); /* do explicit move only if needed */
        -:  679:        }
    #####:  680:        break;
        1:  681:    case ETGLOBAL: /* store to grobal R(A) -> G(Bx) by global index */
        1:  682:        setsupvar(finfo, OP_SETGBL, e1, src);
        1:  683:        break;
    #####:  684:    case ETNGLOBAL: /* store to global R(A) -> G(Bx) by name */
    #####:  685:        setbgblvar(finfo, OP_SETNGBL, e1, src);
    #####:  686:        break;
    #####:  687:    case ETUPVAL:
    #####:  688:        setsupvar(finfo, OP_SETUPV, e1, src);
    #####:  689:        break;
    #####:  690:    case ETMEMBER: /* store to member R(A).RK(B) <- RK(C) */
    #####:  691:        setsfxvar(finfo, OP_SETMBR, e1, src);
    #####:  692:        break;
    #####:  693:    case ETINDEX: /* store to member R(A)[RK(B)] <- RK(C) */
    #####:  694:        setsfxvar(finfo, OP_SETIDX, e1, src);
    #####:  695:        break;
    #####:  696:    default:
    #####:  697:        return 1;
        -:  698:    }
        1:  699:    return 0;
        -:  700:}
        -:  701:
        -:  702:/* Get the expdesc as a register */
        -:  703:/* if already in a register, use the existing register */
        -:  704:/* if local or const, allocate a new register and copy value */
       16:  705:int be_code_nextreg(bfuncinfo *finfo, bexpdesc *e)
        -:  706:{
       16:  707:    int dst = finfo->freereg;
       16:  708:    int src = exp2anyreg(finfo, e); /* get variable register index */
       16:  709:    if (e->type != ETREG) { /* move local and const to new register */
    #####:  710:        code_move(finfo, dst, src);
    #####:  711:        be_code_allocregs(finfo, 1);
        -:  712:    } else {
       16:  713:        dst = src;
        -:  714:    }
       16:  715:    return dst;
        -:  716:}
        -:  717:
    #####:  718:int be_code_getmethod(bfuncinfo *finfo, bexpdesc *e)
        -:  719:{
    #####:  720:    int dst = finfo->freereg;
        -:  721:    be_assert(e->type == ETMEMBER);
    #####:  722:    dst = code_suffix(finfo, OP_GETMET, e, dst);
        -:  723:    /* method [object] args */
    #####:  724:    be_code_allocregs(finfo, dst == finfo->freereg ? 2 : 1);
    #####:  725:    return dst;
        -:  726:}
        -:  727:
        -:  728:/* Generate a CALL instruction at base register with argc consecutive values */
        -:  729:/* i.e. arg1 is base+1... */
        -:  730:/* Important: argc registers are freed upon call, which are supposed to be registers above base */
        8:  731:void be_code_call(bfuncinfo *finfo, int base, int argc)
        -:  732:{
        8:  733:    codeABC(finfo, OP_CALL, base, argc, 0);
        8:  734:    be_code_freeregs(finfo, argc);
        8:  735:}
        -:  736:
    #####:  737:int be_code_proto(bfuncinfo *finfo, bproto *proto)
        -:  738:{
    #####:  739:    int idx = be_vector_count(&finfo->pvec);
        -:  740:    /* append proto to current function proto table */
    #####:  741:    be_vector_push_c(finfo->lexer->vm, &finfo->pvec, &proto);
    #####:  742:    finfo->proto->ptab = be_vector_data(&finfo->pvec);
    #####:  743:    finfo->proto->nproto = be_vector_capacity(&finfo->pvec);
    #####:  744:    return idx;
        -:  745:}
        -:  746:
    #####:  747:void be_code_closure(bfuncinfo *finfo, bexpdesc *e, int idx)
        -:  748:{
    #####:  749:    int reg = (e->type == ETGLOBAL || e->type == ETNGLOBAL) ? finfo->freereg: e->v.idx;
    #####:  750:    code_closure(finfo, idx, reg);
    #####:  751:    if (e->type == ETGLOBAL) { /* store to global R(A) -> G(Bx) */
    #####:  752:        codeABx(finfo, OP_SETGBL, reg, e->v.idx);
    #####:  753:    } else if (e->type == ETNGLOBAL) { /* store R(A) -> GLOBAL[RK(B)] */
    #####:  754:        codeABC(finfo, OP_SETNGBL, reg, e->v.idx, 0);
        -:  755:    }
    #####:  756:}
        -:  757:
        2:  758:void be_code_close(bfuncinfo *finfo, int isret)
        -:  759:{
        2:  760:    bblockinfo *binfo = finfo->binfo;
        2:  761:    if (isret) { /* in 'return' */
        2:  762:        while (binfo && !binfo->hasupval) {
        1:  763:            binfo = binfo->prev;
        -:  764:        }
        1:  765:        if (binfo) {
    #####:  766:            codeABC(finfo, OP_CLOSE, 0, 0, 0);
        -:  767:        }
        1:  768:    } else if (binfo->prev) { /* leave block */
    #####:  769:        if (binfo->hasupval) {
    #####:  770:            codeABC(finfo, OP_CLOSE, binfo->nactlocals, 0, 0);
        -:  771:        }
        -:  772:    }
        2:  773:}
        -:  774:
    #####:  775:static void leave_function(bfuncinfo *finfo)
        -:  776:{
    #####:  777:    int try_depth = 0; /* count of exception catch blocks */
    #####:  778:    bblockinfo *binfo = finfo->binfo;
    #####:  779:    for (; binfo; binfo = binfo->prev) {
    #####:  780:        if (binfo->type & BLOCK_EXCEPT) {
    #####:  781:            ++try_depth; /* leave the exception catch block */
        -:  782:        }
        -:  783:    }
    #####:  784:    if (try_depth) { /* exception catch blocks that needs to leave */
    #####:  785:        be_code_exblk(finfo, try_depth);
        -:  786:    }
    #####:  787:}
        -:  788:
        1:  789:void be_code_ret(bfuncinfo *finfo, bexpdesc *e)
        -:  790:{
        1:  791:    if (finfo->binfo->prev == NULL) {
        1:  792:        if (finfo->flags & FUNC_RET_FLAG) {
    #####:  793:            return;
        -:  794:        }
        1:  795:        finfo->flags |= FUNC_RET_FLAG;
        -:  796:    }
        1:  797:    if (e) {
    #####:  798:        int reg = exp2anyreg(finfo, e);
    #####:  799:        be_code_close(finfo, 1);
    #####:  800:        leave_function(finfo);
    #####:  801:        codeABC(finfo, OP_RET, e->type != ETVOID, reg, 0);
    #####:  802:        free_expreg(finfo, e);
        -:  803:    } else {
        1:  804:        be_code_close(finfo, 1);
        1:  805:        codeABC(finfo, OP_RET, 0, 0, 0);
        -:  806:    }
        -:  807:}
        -:  808:
        -:  809:/* Package a suffix object from `c` with key `k` */
        -:  810:/* Both expdesc are materialized in kregs */
    #####:  811:static void package_suffix(bfuncinfo *finfo, bexpdesc *c, bexpdesc *k)
        -:  812:{
    #####:  813:    int key = exp2anyreg(finfo, k);
    #####:  814:    c->v.ss.obj = exp2anyreg(finfo, c);
    #####:  815:    c->v.ss.tt = c->type;
    #####:  816:    c->v.ss.idx = key;
    #####:  817:}
        -:  818:
    #####:  819:int be_code_nglobal(bfuncinfo *finfo, bexpdesc *k)
        -:  820:{
    #####:  821:    return exp2anyreg(finfo, k);
        -:  822:}
        -:  823:
        -:  824:/* Package a MEMBER suffix object from `c` with key `k` */
    #####:  825:void be_code_member(bfuncinfo *finfo, bexpdesc *c, bexpdesc *k)
        -:  826:{
    #####:  827:    package_suffix(finfo, c, k);
    #####:  828:    c->type = ETMEMBER;
    #####:  829:}
        -:  830:
        -:  831:/* Package a INDEX suffix object from `c` with key `k` */
    #####:  832:void be_code_index(bfuncinfo *finfo, bexpdesc *c, bexpdesc *k)
        -:  833:{
    #####:  834:    package_suffix(finfo, c, k);
    #####:  835:    c->type = ETINDEX;
    #####:  836:}
        -:  837:
    #####:  838:void be_code_class(bfuncinfo *finfo, bexpdesc *dst, bclass *c)
        -:  839:{
        -:  840:    int src;
        -:  841:    bvalue var;
    #####:  842:    var_setclass(&var, c);  /* new var of CLASS type */
    #####:  843:    src = newconst(finfo, &var);  /* allocate a new constant and return kreg */
    #####:  844:    if (dst->type == ETLOCAL) {  /* if target is a local variable, just assign */
    #####:  845:        codeABx(finfo, OP_LDCONST, dst->v.idx, src);
    #####:  846:    } else if (dst->type == ETGLOBAL) {  /* otherwise set as global with same name as class name */
    #####:  847:        codeABx(finfo, OP_LDCONST, finfo->freereg, src);
    #####:  848:        codeABx(finfo, OP_SETGBL, finfo->freereg, dst->v.idx);
    #####:  849:    } else if (dst->type == ETNGLOBAL) {
    #####:  850:        codeABx(finfo, OP_LDCONST, finfo->freereg, src);
    #####:  851:        codeABC(finfo, OP_SETNGBL, finfo->freereg, dst->v.idx, 0);
        -:  852:    }
    #####:  853:    codeABx(finfo, OP_CLASS, 0, src);  /* emit CLASS opcode to register class */
    #####:  854:}
        -:  855:
    #####:  856:void be_code_setsuper(bfuncinfo *finfo, bexpdesc *c, bexpdesc *s)
        -:  857:{
    #####:  858:    int self = exp2anyreg(finfo, c);
    #####:  859:    int super = exp2anyreg(finfo, s);
    #####:  860:    codeABC(finfo, OP_SETSUPER, self, super, 0);
    #####:  861:    free_expreg(finfo, c);
    #####:  862:    free_expreg(finfo, s);
    #####:  863:}
        -:  864:
        -:  865:/* Emit IMPORT opcode for import module */
        -:  866:/* `m` is module name, is copied to register if not already */
        -:  867:/* `v` is destination where the imported module is stored */
        -:  868:/* If destination is a local variable, it is the destination of the IMPORT opcode */
        -:  869:/* otherwise the value is copied to a temporary register and stored to the destination */
        -:  870:/* TODO is this optilization useful, isn´t it done anyways by be_code_move optim? */
    #####:  871:void be_code_import(bfuncinfo *finfo, bexpdesc *m, bexpdesc *v)
        -:  872:{
    #####:  873:    int dst, src = exp2anyreg(finfo, m);
    #####:  874:    if (v->type == ETLOCAL) {
    #####:  875:        dst = v->v.idx;
    #####:  876:        codeABC(finfo, OP_IMPORT, dst, src, 0);
        -:  877:    } else {
    #####:  878:        dst = be_code_allocregs(finfo, 1);
    #####:  879:        codeABC(finfo, OP_IMPORT, dst, src, 0);
    #####:  880:        m->type = ETREG;
    #####:  881:        m->v.idx = dst;
    #####:  882:        be_code_setvar(finfo, v, m);
        -:  883:    }
    #####:  884:}
        -:  885:
    #####:  886:int be_code_exblk(bfuncinfo *finfo, int depth)
        -:  887:{
    #####:  888:    if (depth == 0) {
    #####:  889:        return appendjump(finfo, OP_EXBLK, NULL);
        -:  890:    }
    #####:  891:    codeABx(finfo, OP_EXBLK, 1, depth);
    #####:  892:    return 0;
        -:  893:}
        -:  894:
    #####:  895:void be_code_catch(bfuncinfo *finfo, int base, int ecnt, int vcnt, int *jmp)
        -:  896:{
    #####:  897:    codeABC(finfo, OP_CATCH, base, ecnt, vcnt);
    #####:  898:    if (jmp) {
    #####:  899:        *jmp = NO_JUMP; /* reset jump point */
    #####:  900:        be_code_conjump(finfo, jmp, be_code_jump(finfo));
        -:  901:    }
    #####:  902:}
        -:  903:
        -:  904:/* Emit RAISE opcode */
        -:  905:/* e1 is the exception code */
        -:  906:/* e2 is the exception description */
        -:  907:/* both are materialized to a temp register (if not null) */
    #####:  908:void be_code_raise(bfuncinfo *finfo, bexpdesc *e1, bexpdesc *e2)
        -:  909:{
    #####:  910:    if (e1) {
    #####:  911:        int src1 = exp2anyreg(finfo, e1);
    #####:  912:        int src2 = e2 ? exp2anyreg(finfo, e2) : 0;
    #####:  913:        codeABC(finfo, OP_RAISE, e2 != NULL, src1, src2);
        -:  914:    } else {
    #####:  915:        codeABC(finfo, OP_RAISE, 2, 0, 0); /* rethrow the current exception with parameters already on top of stack */
        -:  916:    }
        -:  917:    /* release the register occupied by the expression */
    #####:  918:    free_expreg(finfo, e1);
    #####:  919:    free_expreg(finfo, e2);
    #####:  920:}
        -:  921:
        -:  922:#endif
