        -:    0:Source:src/be_listlib.c
        -:    0:Graph:./src/be_listlib.gcno
        -:    0:Data:./src/be_listlib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_string.h"
        -:   10:#include "be_strlib.h"
        -:   11:#include "be_list.h"
        -:   12:#include "be_func.h"
        -:   13:#include "be_exec.h"
        -:   14:#include "be_vm.h"
        -:   15:#include <string.h>
        -:   16:
        -:   17:#define list_check_data(vm, argc)                       \
        -:   18:    if (!be_islist(vm, -1) || be_top(vm) - 1 < argc) {  \
        -:   19:        be_return_nil(vm);                              \
        -:   20:    }
        -:   21:
        -:   22:#define list_check_ref(vm)                              \
        -:   23:    if (be_refcontains(vm, 1)) {                        \
        -:   24:        be_pushstring(vm, "[...]");                     \
        -:   25:        be_return(vm);                                  \
        -:   26:    }
        -:   27:
    #####:   28:static void list_getindex(bvm *vm, int index)
        -:   29:{
    #####:   30:    if (!be_getindex(vm, index)) {
    #####:   31:        be_raise(vm, "index_error", "list index out of range");
        -:   32:    }
    #####:   33:}
        -:   34:
        1:   35:static int m_init(bvm *vm)
        -:   36:{
        1:   37:    int i, argc = be_top(vm);
       1*:   38:    if (argc > 1 && be_islist(vm, 2)) {
    #####:   39:        be_pushvalue(vm, 2);
    #####:   40:        be_setmember(vm, 1, ".p");
        -:   41:    } else {
        1:   42:        be_newlist(vm);
        1:   43:        be_setmember(vm, 1, ".p");
       1*:   44:        for (i = 2; i <= argc; ++i) {
    #####:   45:            be_pushvalue(vm, i);
    #####:   46:            be_data_push(vm, -2);
    #####:   47:            be_pop(vm, 1);
        -:   48:        }
        -:   49:    }
        1:   50:    be_return_nil(vm);
        -:   51:}
        -:   52:
    #####:   53:static void push_element(bvm *vm)
        -:   54:{
    #####:   55:    be_toescape(vm, -1, 'x'); /* escape string */
    #####:   56:    be_strconcat(vm, -3);
    #####:   57:    be_pop(vm, 1);
    #####:   58:}
        -:   59:
    #####:   60:static int m_tostring(bvm *vm)
        -:   61:{
    #####:   62:    be_getmember(vm, 1, ".p");
    #####:   63:    list_check_data(vm, 1);
    #####:   64:    list_check_ref(vm);
    #####:   65:    be_refpush(vm, 1);
    #####:   66:    be_pushstring(vm, "[");
    #####:   67:    be_pushiter(vm, -2);
    #####:   68:    while (be_iter_hasnext(vm, -3)) {
    #####:   69:        be_iter_next(vm, -3);
    #####:   70:        push_element(vm);
    #####:   71:        if (be_iter_hasnext(vm, -3)) {
    #####:   72:            be_pushstring(vm, ", ");
    #####:   73:            be_strconcat(vm, -3);
    #####:   74:            be_pop(vm, 1);
        -:   75:        }
        -:   76:    }
    #####:   77:    be_pop(vm, 1); /* pop iterator */
    #####:   78:    be_pushstring(vm, "]");
    #####:   79:    be_strconcat(vm, -2);
    #####:   80:    be_pop(vm, 1);
    #####:   81:    be_refpop(vm);
    #####:   82:    be_return(vm);
        -:   83:}
        -:   84:
    #####:   85:static int m_push(bvm *vm)
        -:   86:{
    #####:   87:    be_getmember(vm, 1, ".p");
    #####:   88:    list_check_data(vm, 2);
    #####:   89:    be_pushvalue(vm, 2);
    #####:   90:    be_data_push(vm, -2);
    #####:   91:    be_return_nil(vm);
        -:   92:}
        -:   93:
    #####:   94:static int m_pop(bvm *vm)
        -:   95:{
    #####:   96:    int argc = be_top(vm);
    #####:   97:    be_getmember(vm, 1, ".p");
    #####:   98:    list_check_data(vm, 1);
    #####:   99:    if (argc >= 2) {
    #####:  100:        be_pushvalue(vm, 2);
        -:  101:    } else {
    #####:  102:        be_pushint(vm, -1);
        -:  103:    }
    #####:  104:    list_getindex(vm, -2);
    #####:  105:    be_pushvalue(vm, -2);
    #####:  106:    be_data_remove(vm, -4);
    #####:  107:    be_pop(vm, 1);
    #####:  108:    be_return(vm);
        -:  109:}
        -:  110:
    #####:  111:static int m_insert(bvm *vm)
        -:  112:{
    #####:  113:    be_getmember(vm, 1, ".p");
    #####:  114:    list_check_data(vm, 3);
    #####:  115:    be_pushvalue(vm, 2);
    #####:  116:    be_pushvalue(vm, 3);
    #####:  117:    be_data_insert(vm, -3);
    #####:  118:    be_return_nil(vm);
        -:  119:}
        -:  120:
    #####:  121:static int m_remove(bvm *vm)
        -:  122:{
    #####:  123:    be_getmember(vm, 1, ".p");
    #####:  124:    list_check_data(vm, 2);
    #####:  125:    be_pushvalue(vm, 2);
    #####:  126:    be_data_remove(vm, -2);
    #####:  127:    be_return_nil(vm);
        -:  128:}
        -:  129:
    #####:  130:static int item_range(bvm *vm)
        -:  131:{
        -:  132:    bint lower, upper;
    #####:  133:    bint size = be_data_size(vm, -1); /* get source list size */
        -:  134:    /* get index range */
    #####:  135:    be_getmember(vm, 2, "__lower__");
    #####:  136:    lower = be_toint(vm, -1);
    #####:  137:    be_pop(vm, 1);
    #####:  138:    be_getmember(vm, 2, "__upper__");
    #####:  139:    upper = be_toint(vm, -1);
    #####:  140:    be_pop(vm, 1);
        -:  141:    /* protection scope */
    #####:  142:    upper = upper < size ? upper : size - 1;
    #####:  143:    lower = lower < 0 ? 0 : lower;
        -:  144:    /* construction result list instance */
    #####:  145:    be_newobject(vm, "list"); /* result list */
    #####:  146:    be_getmember(vm, 1, ".p"); /* source list */
        -:  147:    /* copy elements */
    #####:  148:    for (; lower <= upper; ++lower) {
    #####:  149:        be_pushint(vm, lower);
    #####:  150:        list_getindex(vm, -2);
    #####:  151:        be_data_push(vm, -4);
    #####:  152:        be_pop(vm, 2);
        -:  153:    }
    #####:  154:    be_pop(vm, 2);
    #####:  155:    be_return(vm);
        -:  156:}
        -:  157:
    #####:  158:static int item_list(bvm *vm)
        -:  159:{
        -:  160:    int i, srcsize, idxsize;
    #####:  161:    be_getmember(vm, 2, ".p"); /* get index list */
    #####:  162:    srcsize = be_data_size(vm, -2); /* get source list size */
    #####:  163:    idxsize = be_data_size(vm, -1); /* get index list size */
        -:  164:    /* construction result list instance */
    #####:  165:    be_newobject(vm, "list"); /* result list */
    #####:  166:    be_getmember(vm, 1, ".p"); /* source list */
        -:  167:    /* copy elements */
    #####:  168:    for (i = 0; i < idxsize; ++i) {
    #####:  169:        be_pushint(vm, i);
    #####:  170:        be_getindex(vm, -5);
    #####:  171:        if (be_isint(vm, -1)) {
    #####:  172:            int idx = be_toindex(vm, -1);
    #####:  173:            if (idx >= 0 && idx < srcsize) {
    #####:  174:                be_getindex(vm, -3);
        -:  175:            } else {
    #####:  176:                be_pushnil(vm);
        -:  177:            }
        -:  178:        } else {
    #####:  179:            be_pushnil(vm);
        -:  180:        }
    #####:  181:        be_data_push(vm, -5);
    #####:  182:        be_pop(vm, 3);
        -:  183:    }
    #####:  184:    be_pop(vm, 2);
    #####:  185:    be_return(vm);
        -:  186:}
        -:  187:
    #####:  188:static int m_item(bvm *vm)
        -:  189:{
    #####:  190:    be_getmember(vm, 1, ".p");
    #####:  191:    list_check_data(vm, 2);
    #####:  192:    if (be_isint(vm, 2)) {
    #####:  193:        be_pushvalue(vm, 2);
    #####:  194:        list_getindex(vm, -2);
    #####:  195:        be_return(vm);
        -:  196:    }
    #####:  197:    if (be_isinstance(vm, 2)) {
    #####:  198:        const char *cname = be_classname(vm, 2);
    #####:  199:        if (!strcmp(cname, "range")) {
    #####:  200:            return item_range(vm);
        -:  201:        }
    #####:  202:        if (!strcmp(cname, "list")) {
    #####:  203:            return item_list(vm);
        -:  204:        }
        -:  205:    }
    #####:  206:    be_raise(vm, "index_error", "list index out of range");
    #####:  207:    be_return_nil(vm);
        -:  208:}
        -:  209:
    #####:  210:static int m_find(bvm *vm)
        -:  211:{
    #####:  212:    bbool found = bfalse;
        -:  213:    int idx;
    #####:  214:    be_getmember(vm, 1, ".p");
    #####:  215:    list_check_data(vm, 2);
    #####:  216:    list_check_ref(vm);
    #####:  217:    be_refpush(vm, 1);
    #####:  218:    be_pushiter(vm, -1);
    #####:  219:    for (idx=0; be_iter_hasnext(vm, -2); idx++) {
    #####:  220:        be_iter_next(vm, -2);
    #####:  221:        be_pushvalue(vm, 2);    /* push needle to compare */
    #####:  222:        if (be_iseq(vm)) {
    #####:  223:            found = btrue;
    #####:  224:            be_pop(vm, 2);
    #####:  225:            break;
        -:  226:        }
    #####:  227:        be_pop(vm, 2);
        -:  228:    }
    #####:  229:    be_pop(vm, 1); /* pop iterator */
    #####:  230:    be_refpop(vm);
    #####:  231:    if (found) {
    #####:  232:        be_pushint(vm, idx);
    #####:  233:        be_return(vm);
        -:  234:    } else {
    #####:  235:        be_return_nil(vm);
        -:  236:    }
        -:  237:}
        -:  238:
    #####:  239:static int m_setitem(bvm *vm)
        -:  240:{
    #####:  241:    be_getmember(vm, 1, ".p");
    #####:  242:    list_check_data(vm, 3);
    #####:  243:    be_pushvalue(vm, 2);
    #####:  244:    be_pushvalue(vm, 3);
    #####:  245:    if (!be_setindex(vm, -3)) {
    #####:  246:        be_raise(vm, "index_error", "list assignment index out of range");
        -:  247:    }
    #####:  248:    be_return_nil(vm);
        -:  249:}
        -:  250:
    #####:  251:static int m_size(bvm *vm)
        -:  252:{
    #####:  253:    be_getmember(vm, 1, ".p");
    #####:  254:    list_check_data(vm, 1);
    #####:  255:    be_pushint(vm, be_data_size(vm, -1));
    #####:  256:    be_return(vm);
        -:  257:}
        -:  258:
    #####:  259:static int m_resize(bvm *vm)
        -:  260:{
    #####:  261:    be_getmember(vm, 1, ".p");
    #####:  262:    list_check_data(vm, 2);
    #####:  263:    be_pushvalue(vm, 2);
    #####:  264:    be_data_resize(vm, -2);
    #####:  265:    be_return_nil(vm);
        -:  266:}
        -:  267:
    #####:  268:static int m_clear(bvm *vm)
        -:  269:{
    #####:  270:    be_getmember(vm, 1, ".p");
    #####:  271:    list_check_data(vm, 1);
    #####:  272:    be_pushint(vm, 0);
    #####:  273:    be_data_resize(vm, -2);
    #####:  274:    be_return_nil(vm);
        -:  275:}
        -:  276:
    #####:  277:static int iter_closure(bvm *vm)
        -:  278:{
        -:  279:    /* for better performance, we operate the upvalues
        -:  280:     * directly without using by the stack. */
    #####:  281:    bntvclos *func = var_toobj(vm->cf->func);
    #####:  282:    bvalue *uv0 = be_ntvclos_upval(func, 0)->value; /* list value */
    #####:  283:    bvalue *uv1 = be_ntvclos_upval(func, 1)->value; /* iter value */
    #####:  284:    bvalue *next = cast(bvalue*, var_toobj(uv1)) + 1;
    #####:  285:    blist *list = var_toobj(uv0);
    #####:  286:    if (next >= be_list_end(list)) {
    #####:  287:        be_stop_iteration(vm);
        -:  288:    }
    #####:  289:    var_toobj(uv1) = next; /* set upvale[1] (iter value) */
        -:  290:    /* push next value to top */
    #####:  291:    var_setval(vm->top, next);
    #####:  292:    be_incrtop(vm);
    #####:  293:    be_return(vm);
        -:  294:}
        -:  295:
    #####:  296:static int m_iter(bvm *vm)
        -:  297:{
    #####:  298:    be_pushntvclosure(vm, iter_closure, 2);
    #####:  299:    be_getmember(vm, 1, ".p");
    #####:  300:    be_setupval(vm, -2, 0);
    #####:  301:    be_pushiter(vm, -1);
    #####:  302:    be_setupval(vm, -3, 1);
    #####:  303:    be_pop(vm, 2);
    #####:  304:    be_return(vm);
        -:  305:}
        -:  306:
    #####:  307:static int m_connect(bvm *vm)
        -:  308:{
    #####:  309:    int argc = be_top(vm);
    #####:  310:    if (argc >= 2) {
    #####:  311:        be_getmember(vm, 1, ".p");
    #####:  312:        be_pushvalue(vm, 2);
    #####:  313:        be_data_push(vm, -2);
    #####:  314:        be_pop(vm, argc + 1);
        -:  315:    }
    #####:  316:    be_return(vm); /* return self */
        -:  317:}
        -:  318:
    #####:  319:static int m_merge(bvm *vm)
        -:  320:{
    #####:  321:    int argc = be_top(vm);
    #####:  322:    if (argc >= 2) {
    #####:  323:        be_newobject(vm, "list"); /* stack contains instance and .p */
    #####:  324:        be_getmember(vm, 1, ".p");
    #####:  325:        be_data_merge(vm, -2);
    #####:  326:        be_getmember(vm, 2, ".p");
    #####:  327:        if (!be_islist(vm, -1)) {
    #####:  328:            be_raise(vm, "type_error", "operand must be a list");
        -:  329:        }
    #####:  330:        be_data_merge(vm, -3);
    #####:  331:        be_pop(vm, 3);
        -:  332:    }
    #####:  333:    be_return(vm); /* return self */
        -:  334:}
        -:  335:
    #####:  336:static void connect(bvm *vm, bvalue *begin, bvalue *end)
        -:  337:{
    #####:  338:    size_t l0 = be_strlen(vm, -1), len = l0;
        -:  339:    char *buf, *p;
        -:  340:    bvalue *it;
    #####:  341:    for (it = begin; it < end; ++it) {
    #####:  342:        len += str_len(var_tostr(it));
        -:  343:    }
    #####:  344:    buf = be_pushbuffer(vm, len);
    #####:  345:    memcpy(buf, be_tostring(vm, -2), l0);
    #####:  346:    p = buf + l0;
    #####:  347:    for (it = begin; it < end; ++it) {
    #####:  348:        bstring *s = var_tostr(it);
    #####:  349:        size_t l = str_len(s);
    #####:  350:        memcpy(p, str(s), l);
    #####:  351:        p += l;
        -:  352:    }
    #####:  353:    be_pushstring(vm, buf);
    #####:  354:    be_moveto(vm, -1, -3);
    #####:  355:    be_pop(vm, 2);
    #####:  356:}
        -:  357:
    #####:  358:static void list_concat(bvm *vm, blist *list)
        -:  359:{
    #####:  360:    bvalue *it, *begin = be_list_data(list);
    #####:  361:    bvalue *end = be_list_end(list);
    #####:  362:    be_pushstring(vm, ""); /* push a empty string */
    #####:  363:    for (it = begin; it < end;) {
    #####:  364:        for (; it < end && var_isstr(it); ++it);
    #####:  365:        connect(vm, begin, it); /* connect string list */
    #####:  366:        if (it < end) {
        -:  367:            /* connect other value */
    #####:  368:            var_setval(vm->top, it);
    #####:  369:            be_incrtop(vm);
    #####:  370:            be_val2str(vm, -1);
    #####:  371:            be_strconcat(vm, -2);
    #####:  372:            be_pop(vm, 1);
    #####:  373:            begin = ++it;
        -:  374:        }
        -:  375:    }
    #####:  376:}
        -:  377:
    #####:  378:static int m_concat(bvm *vm)
        -:  379:{
        -:  380:    bvalue *value;
    #####:  381:    be_getmember(vm, 1, ".p");
    #####:  382:    list_check_data(vm, 1);
    #####:  383:    value = be_indexof(vm, -1);
    #####:  384:    list_concat(vm, var_toobj(value));
    #####:  385:    be_return(vm);
        -:  386:}
        -:  387:
    #####:  388:static int m_reverse(bvm *vm)
        -:  389:{
    #####:  390:    int top = be_top(vm);
    #####:  391:    be_getmember(vm, 1, ".p");
    #####:  392:    list_check_data(vm, 1);
    #####:  393:    be_data_reverse(vm, -1);
    #####:  394:    be_pop(vm, top);
    #####:  395:    be_return(vm);
        -:  396:}
        -:  397:
    #####:  398:static int m_copy(bvm *vm)
        -:  399:{
    #####:  400:    be_getmember(vm, 1, ".p");
    #####:  401:    list_check_data(vm, 1);
    #####:  402:    be_getbuiltin(vm, "list");
    #####:  403:    be_copy(vm, -2);
    #####:  404:    be_call(vm, 1);
    #####:  405:    be_pop(vm, 1);
    #####:  406:    be_return(vm);
        -:  407:}
        -:  408:
    #####:  409:static int list_equal(bvm *vm, bbool iseq)
        -:  410:{
        -:  411:    int i, j, res;
    #####:  412:    bbool (*eqfunc)(bvm*) = iseq ? be_iseq : be_isneq;
    #####:  413:    be_getmember(vm, 1, ".p");
    #####:  414:    be_getmember(vm, 2, ".p");
    #####:  415:    i = be_data_size(vm, -2);
    #####:  416:    j = be_data_size(vm, -1);
    #####:  417:    if (i == j) {
    #####:  418:        res = iseq;
    #####:  419:        for (i = 0; res == iseq && i < j; ++i) {
    #####:  420:            be_pushint(vm, i);
    #####:  421:            be_getindex(vm, -3);
    #####:  422:            be_pushint(vm, i);
    #####:  423:            be_getindex(vm, -4);
    #####:  424:            be_remove(vm, -2);
    #####:  425:            res = eqfunc(vm);
    #####:  426:            be_pop(vm, 3);
        -:  427:        }
        -:  428:    } else {
    #####:  429:        res = !iseq;
        -:  430:    }
    #####:  431:    be_pushbool(vm, res);
    #####:  432:    be_return(vm);
        -:  433:}
        -:  434:
    #####:  435:static int m_equal(bvm *vm)
        -:  436:{
    #####:  437:    return list_equal(vm, btrue);
        -:  438:}
        -:  439:
    #####:  440:static int m_nequal(bvm *vm)
        -:  441:{
    #####:  442:    return list_equal(vm, bfalse);
        -:  443:}
        -:  444:
        -:  445:#if !BE_USE_PRECOMPILED_OBJECT
        -:  446:void be_load_listlib(bvm *vm)
        -:  447:{
        -:  448:    static const bnfuncinfo members[] = {
        -:  449:        { ".p", NULL },
        -:  450:        { "init", m_init },
        -:  451:        { "tostring", m_tostring },
        -:  452:        { "push", m_push },
        -:  453:        { "pop", m_pop },
        -:  454:        { "insert", m_insert },
        -:  455:        { "remove", m_remove },
        -:  456:        { "item", m_item },
        -:  457:        { "find", m_find },
        -:  458:        { "setitem", m_setitem },
        -:  459:        { "size", m_size },
        -:  460:        { "resize", m_resize },
        -:  461:        { "clear", m_clear },
        -:  462:        { "iter", m_iter },
        -:  463:        { "concat", m_concat },
        -:  464:        { "reverse", m_reverse },
        -:  465:        { "copy", m_copy },
        -:  466:        { "..", m_connect },
        -:  467:        { "+", m_merge },
        -:  468:        { "==", m_equal },
        -:  469:        { "!=", m_nequal },
        -:  470:        { NULL, NULL }
        -:  471:    };
        -:  472:    be_regclass(vm, "list", members);
        -:  473:}
        -:  474:#else
        -:  475:/* @const_object_info_begin
        -:  476:class be_class_list (scope: global, name: list) {
        -:  477:    .p, var
        -:  478:    init, func(m_init)
        -:  479:    tostring, func(m_tostring)
        -:  480:    push, func(m_push)
        -:  481:    pop, func(m_pop)
        -:  482:    insert, func(m_insert)
        -:  483:    remove, func(m_remove)
        -:  484:    item, func(m_item)
        -:  485:    find, func(m_find)
        -:  486:    setitem, func(m_setitem)
        -:  487:    size, func(m_size)
        -:  488:    resize, func(m_resize)
        -:  489:    clear, func(m_clear)
        -:  490:    iter, func(m_iter)
        -:  491:    concat, func(m_concat)
        -:  492:    reverse, func(m_reverse)
        -:  493:    copy, func(m_copy)
        -:  494:    .., func(m_connect)
        -:  495:    +, func(m_merge)
        -:  496:    ==, func(m_equal)
        -:  497:    !=, func(m_nequal)
        -:  498:}
        -:  499:@const_object_info_end */
        -:  500:#include "../generate/be_fixed_be_class_list.h"
        -:  501:#endif
