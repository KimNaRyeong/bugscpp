        -:    0:Source:src/be_debug.c
        -:    0:Graph:./src/be_debug.gcno
        -:    0:Data:./src/be_debug.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_debug.h"
        -:    9:#include "be_func.h"
        -:   10:#include "be_decoder.h"
        -:   11:#include "be_string.h"
        -:   12:#include "be_class.h"
        -:   13:#include "be_vm.h"
        -:   14:#include "be_vector.h"
        -:   15:#include "be_strlib.h"
        -:   16:#include "be_exec.h"
        -:   17:#include "be_mem.h"
        -:   18:#include <stdio.h>
        -:   19:#include <string.h>
        -:   20:
        -:   21:#if BE_USE_DEBUG_HOOK && !BE_DEBUG_RUNTIME_INFO
        -:   22:  #error This macro BE_USE_DEBUG_HOOK requires BE_DEBUG_RUNTIME_INFO != 0
        -:   23:#endif
        -:   24:
        -:   25:#ifndef INST_BUF_SIZE
        -:   26:#define INST_BUF_SIZE   96
        -:   27:#endif
        -:   28:
        -:   29:#define logbuf(...)     snprintf(__lbuf, sizeof(__lbuf), __VA_ARGS__)
        -:   30:
        -:   31:#define logfmt(...)                     \
        -:   32:    do {                                \
        -:   33:        char __lbuf[INST_BUF_SIZE];     \
        -:   34:        logbuf(__VA_ARGS__);            \
        -:   35:        be_writestring(__lbuf);         \
        -:   36:    } while (0)
        -:   37:
        -:   38:#if BE_USE_DEBUG_MODULE
    #####:   39:static const char* opc2str(bopcode op)
        -:   40:{
        -:   41:    static const char* const opc_tab[] = {
        -:   42:        #define OPCODE(opc) #opc
        -:   43:        #include "be_opcodes.h"
        -:   44:        #undef OPCODE
        -:   45:    };
    #####:   46:    return op < array_count(opc_tab) ? opc_tab[op] : "ERROP";
        -:   47:}
        -:   48:
    #####:   49:void be_print_inst(binstruction ins, int pc)
        -:   50:{
        -:   51:    char __lbuf[INST_BUF_SIZE];
    #####:   52:    bopcode op = IGET_OP(ins);
        -:   53:
    #####:   54:    logbuf("  %.4X  ", pc);
    #####:   55:    be_writestring(__lbuf);
    #####:   56:    switch (op) {
    #####:   57:    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
        -:   58:    case OP_MOD: case OP_LT: case OP_LE: case OP_EQ:
        -:   59:    case OP_NE:  case OP_GT:  case OP_GE: case OP_CONNECT:
        -:   60:    case OP_GETMBR: case OP_SETMBR:  case OP_GETMET:
        -:   61:    case OP_GETIDX: case OP_SETIDX: case OP_AND:
        -:   62:    case OP_OR: case OP_XOR: case OP_SHL: case OP_SHR:
    #####:   63:        logbuf("%s\tR%d\t%c%d\t%c%d", opc2str(op), IGET_RA(ins),
        -:   64:                isKB(ins) ? 'K' : 'R', IGET_RKB(ins) & KR_MASK,
        -:   65:                isKC(ins) ? 'K' : 'R', IGET_RKC(ins) & KR_MASK);
    #####:   66:        break;
    #####:   67:    case OP_GETNGBL: case OP_SETNGBL:
    #####:   68:        logbuf("%s\tR%d\t%c%d", opc2str(op), IGET_RA(ins),
        -:   69:                isKB(ins) ? 'K' : 'R', IGET_RKB(ins) & KR_MASK);
    #####:   70:        break;
    #####:   71:    case OP_GETGBL: case OP_SETGBL:
    #####:   72:        logbuf("%s\tR%d\tG%d", opc2str(op), IGET_RA(ins), IGET_Bx(ins));
    #####:   73:        break;
    #####:   74:    case OP_MOVE: case OP_SETSUPER: case OP_NEG: case OP_FLIP: case OP_IMPORT:
    #####:   75:        logbuf("%s\tR%d\t%c%d", opc2str(op), IGET_RA(ins),
        -:   76:                isKB(ins) ? 'K' : 'R', IGET_RKB(ins) & KR_MASK);
    #####:   77:        break;
    #####:   78:    case OP_JMP:
    #####:   79:        logbuf("%s\t\t#%.4X", opc2str(op), IGET_sBx(ins) + pc + 1);
    #####:   80:        break;
    #####:   81:    case OP_JMPT: case OP_JMPF:
    #####:   82:        logbuf("%s\tR%d\t#%.4X", opc2str(op), IGET_RA(ins), IGET_sBx(ins) + pc + 1);
    #####:   83:        break;
    #####:   84:    case OP_LDINT:
    #####:   85:        logbuf("%s\tR%d\t%d", opc2str(op), IGET_RA(ins), IGET_sBx(ins));
    #####:   86:        break;
    #####:   87:    case OP_LDBOOL:
    #####:   88:        logbuf("%s\tR%d\t%d\t%d", opc2str(op),  IGET_RA(ins), IGET_RKB(ins), IGET_RKC(ins));
    #####:   89:        break;
    #####:   90:    case OP_RET:
    #####:   91:        if (IGET_RA(ins)) {
    #####:   92:            logbuf("%s\t%d\t%c%d", opc2str(op), IGET_RA(ins),
        -:   93:                isKB(ins) ? 'K' : 'R', IGET_RKB(ins) & KR_MASK);
        -:   94:        } else {
    #####:   95:            logbuf("%s\t%d", opc2str(op), IGET_RA(ins)); /* RET 0 does not take an additional parameter */
        -:   96:        }
    #####:   97:        break;
    #####:   98:    case OP_GETUPV: case OP_SETUPV:
    #####:   99:        logbuf("%s\tR%d\tU%d", opc2str(op), IGET_RA(ins), IGET_Bx(ins));
    #####:  100:        break;
    #####:  101:    case OP_LDCONST:
    #####:  102:        logbuf("%s\tR%d\tK%d", opc2str(op), IGET_RA(ins), IGET_Bx(ins));
    #####:  103:        break;
    #####:  104:    case OP_CALL:
    #####:  105:        logbuf("%s\tR%d\t%d", opc2str(op), IGET_RA(ins), IGET_RKB(ins));
    #####:  106:        break;
    #####:  107:    case OP_CLOSURE:
    #####:  108:        logbuf("%s\tR%d\tP%d", opc2str(op), IGET_RA(ins), IGET_Bx(ins));
    #####:  109:        break;
    #####:  110:    case OP_CLASS:
    #####:  111:        logbuf("%s\tK%d", opc2str(op), IGET_Bx(ins));
    #####:  112:        break;
    #####:  113:    case OP_CLOSE: case OP_LDNIL:
    #####:  114:        logbuf("%s\tR%d", opc2str(op), IGET_RA(ins));
    #####:  115:        break;
    #####:  116:    case OP_RAISE:
    #####:  117:        logbuf("%s\t%d\t%c%d\t%c%d", opc2str(op), IGET_RA(ins),
        -:  118:                isKB(ins) ? 'K' : 'R', IGET_RKB(ins) & KR_MASK,
        -:  119:                isKC(ins) ? 'K' : 'R', IGET_RKC(ins) & KR_MASK);
    #####:  120:        break;
    #####:  121:    case OP_EXBLK:
    #####:  122:        if (IGET_RA(ins)) {
    #####:  123:            logbuf("%s\t%d\t%d", opc2str(op), IGET_RA(ins), IGET_Bx(ins));
        -:  124:        } else {
    #####:  125:            logbuf("%s\t%d\t#%.4X", opc2str(op), IGET_RA(ins), IGET_sBx(ins) + pc + 1);
        -:  126:        }
    #####:  127:        break;
    #####:  128:    case OP_CATCH:
    #####:  129:        logbuf("%s\tR%d\t%d\t%d", opc2str(op), IGET_RA(ins), IGET_RKB(ins), IGET_RKC(ins));
    #####:  130:        break;
    #####:  131:    default:
    #####:  132:        logbuf("%s", opc2str(op));
    #####:  133:        break;
        -:  134:    }
    #####:  135:    be_writestring(__lbuf);
    #####:  136:    be_writenewline();
    #####:  137:}
        -:  138:#endif
        -:  139:
        -:  140:#if BE_USE_DEBUG_MODULE
    #####:  141:void be_dumpclosure(bclosure *cl)
        -:  142:{
        -:  143:    int pc;
    #####:  144:    bproto *proto = cl->proto;
    #####:  145:    binstruction *code = proto->code;
        -:  146:#if BE_DEBUG_RUNTIME_INFO
    #####:  147:    blineinfo *lineinfo = proto->lineinfo;
        -:  148:#endif
    #####:  149:    logfmt("source '%s', ", str(proto->source));
    #####:  150:    logfmt("function '%s':\n", str(proto->name));
        -:  151:#if BE_DEBUG_RUNTIME_INFO
    #####:  152:    if (lineinfo) { /* first line */
    #####:  153:        logfmt("; line %d\n", lineinfo->linenumber);
        -:  154:    }
        -:  155:#endif
    #####:  156:    for (pc = 0; pc < proto->codesize; pc++) {
        -:  157:#if BE_DEBUG_RUNTIME_INFO
    #####:  158:        if (lineinfo && pc > lineinfo->endpc) {
    #####:  159:            logfmt("; line %d\n", (++lineinfo)->linenumber);
        -:  160:        }
        -:  161:#endif
    #####:  162:        be_print_inst(*code++, pc);
        -:  163:    }
    #####:  164:}
        -:  165:#endif
        -:  166:
        1:  167:static void sourceinfo(bproto *proto, binstruction *ip)
        -:  168:{
        -:  169:#if BE_DEBUG_RUNTIME_INFO
        -:  170:    char buf[24];
        -:  171:    be_assert(proto != NULL);
        2:  172:    if (proto->lineinfo && proto->nlineinfo) {
        1:  173:        blineinfo *it = proto->lineinfo;
        1:  174:        blineinfo *end = it + proto->nlineinfo;
        1:  175:        int pc = cast_int(ip - proto->code - 1); /* now vm->ip has been increased */
        8:  176:        for (; it < end && pc > it->endpc; ++it);
        1:  177:        sprintf(buf, ":%d:", it->linenumber);
        1:  178:        be_writestring(str(proto->source));
        1:  179:        be_writestring(buf);
        -:  180:    } else {
    #####:  181:        be_writestring("<unknow source>:");
        -:  182:    }
        -:  183:#else
        -:  184:    (void)proto; (void)ip;
        -:  185:    be_writestring("<unknow source>:");
        -:  186:#endif
        1:  187:}
        -:  188:
        1:  189:static void tracestack(bvm *vm)
        -:  190:{
        -:  191:    bcallsnapshot *cf;
        1:  192:    bcallsnapshot *base = be_stack_base(&vm->tracestack);
        1:  193:    bcallsnapshot *top = be_stack_top(&vm->tracestack);
        1:  194:    be_writestring("stack traceback:\n");
        3:  195:    for (cf = top; cf >= base; --cf) {
       2*:  196:        if (cf <= top - 10 && cf >= base + 10) {
    #####:  197:            if (cf == top - 10)
    #####:  198:                be_writestring("\t...\n");
    #####:  199:            continue;
        -:  200:        }
        2:  201:        if (var_isclosure(&cf->func)) {
        1:  202:            bclosure *cl = var_toobj(&cf->func);
        1:  203:            be_writestring("\t");
        1:  204:            sourceinfo(cl->proto, cf->ip);
        1:  205:            be_writestring(" in function `");
        1:  206:            be_writestring(str(cl->proto->name));
        1:  207:            be_writestring("`\n");
        -:  208:        } else {
        1:  209:            be_writestring("\t<native>: in native function\n");
        -:  210:        }
        -:  211:    }
        1:  212:}
        -:  213:
        1:  214:static void repair_stack(bvm *vm)
        -:  215:{
        -:  216:    bcallsnapshot *cf;
        1:  217:    bcallsnapshot *base = be_stack_base(&vm->tracestack);
        1:  218:    bcallsnapshot *top = be_stack_top(&vm->tracestack);
        -:  219:    /* Because the native function does not push `ip` to the
        -:  220:     * stack, the ip on the native function frame corresponds
        -:  221:     * to the previous Berry closure. */
        2:  222:    for (cf = top; cf >= base; --cf) {
        1:  223:        if (!var_isclosure(&cf->func)) {
        -:  224:            /* the last native function stack frame has the `ip` of
        -:  225:             * the previous Berry frame */
        1:  226:            binstruction *ip = cf->ip;
        -:  227:            /* skip native function stack frames */
        2:  228:            for (; cf >= base && !var_isclosure(&cf->func); --cf);
        -:  229:            /* fixed `ip` of Berry closure frame near native function frame */
        1:  230:            if (cf >= base) cf->ip = ip;
        -:  231:        }
        -:  232:    }
        1:  233:}
        -:  234:
        1:  235:void be_tracestack(bvm *vm)
        -:  236:{
        1:  237:    if (be_stack_count(&vm->tracestack)) {
        1:  238:        repair_stack(vm);
        1:  239:        tracestack(vm);
        -:  240:    }
        1:  241:}
        -:  242:
        -:  243:#if BE_USE_DEBUG_HOOK
        -:  244:
    #####:  245:static void hook_callnative(bvm *vm, int mask)
        -:  246:{
        -:  247:    bhookinfo info;
    #####:  248:    int top = be_top(vm);
    #####:  249:    bcallframe *cf = vm->cf;
    #####:  250:    bclosure *cl = var_toobj(cf->func);
    #####:  251:    struct bhookblock *hb = var_toobj(&vm->hook);
    #####:  252:    be_stack_require(vm, BE_STACK_FREE_MIN + 2);
    #####:  253:    info.type = mask;
    #####:  254:    info.line = cf->lineinfo->linenumber;
    #####:  255:    info.source = str(cl->proto->source);
    #####:  256:    info.func_name = str(cl->proto->name);
    #####:  257:    info.data = hb->data;
    #####:  258:    hb->hook(vm, &info);
    #####:  259:    vm->top += 2;
    #####:  260:    be_pop(vm, be_top(vm) - top);
    #####:  261:}
        -:  262:
    #####:  263:static int hook_pushargs(bvm *vm, int mask)
        -:  264:{
    #####:  265:    bcallframe *cf = vm->cf;
    #####:  266:    if (mask == BE_HOOK_LINE) {
    #####:  267:        be_pushstring(vm, "line");
    #####:  268:        be_pushint(vm, cf->lineinfo->linenumber);
    #####:  269:        return 2;
        -:  270:    }
    #####:  271:    if (mask == BE_HOOK_CALL) {
    #####:  272:        bclosure *cl = var_toobj(cf->func);
    #####:  273:        be_pushstring(vm, "call");
    #####:  274:        var_setstr(vm->top, cl->proto->name);
    #####:  275:        vm->top++;
    #####:  276:        return 2;
        -:  277:    }
    #####:  278:    if (mask == BE_HOOK_RET) {
    #####:  279:        be_pushstring(vm, "return");
    #####:  280:        return 1;
        -:  281:    }
    #####:  282:    return 0;
        -:  283:}
        -:  284:
    #####:  285:static void hook_call(bvm *vm, int mask)
        -:  286:{
        -:  287:    int argc;
    #####:  288:    vm->top[2] = vm->hook;
    #####:  289:    be_stack_require(vm, 5);
    #####:  290:    vm->top += 3;
    #####:  291:    argc = hook_pushargs(vm, mask);
    #####:  292:    be_call(vm, argc);
    #####:  293:    be_pop(vm, 3 + argc);
    #####:  294:}
        -:  295:
        1:  296:void be_callhook(bvm *vm, int mask)
        -:  297:{
        1:  298:    if (vm->hookmask & mask) {
    #####:  299:        int hookmask = vm->hookmask;
    #####:  300:        vm->hookmask = 0;
    #####:  301:        if (var_istype(&vm->hook, BE_COMPTR)) {
    #####:  302:            hook_callnative(vm, mask);
        -:  303:        } else {
    #####:  304:            hook_call(vm, mask);
        -:  305:        }
    #####:  306:        vm->hookmask = (bbyte)hookmask;
        -:  307:    }
        1:  308:}
        -:  309:
    #####:  310:static bbyte parse_hookmask(const char *mask)
        -:  311:{
    #####:  312:    int c, res = 0;
    #####:  313:    if (mask) {
    #####:  314:        while ((c = *mask++) != '\0') {
    #####:  315:            switch (c) {
    #####:  316:            case 'l': res |= BE_HOOK_LINE; break;
    #####:  317:            case 'c': res |= BE_HOOK_CALL; break;
    #####:  318:            case 'r': res |= BE_HOOK_RET; break;
    #####:  319:            default: break;
        -:  320:            }
        -:  321:        }
        -:  322:    }
    #####:  323:    return (bbyte)res;
        -:  324:}
        -:  325:
    #####:  326:BERRY_API void be_sethook(bvm *vm, const char *mask)
        -:  327:{
    #####:  328:    vm->hookmask = parse_hookmask(mask);
    #####:  329:    if (vm->hookmask && var_istype(&vm->hook, BE_COMPTR)) /* free native hook */
    #####:  330:        be_free(vm, var_toobj(&vm->hook), sizeof(struct bhookblock));
    #####:  331:    if (vm->hookmask) {
    #####:  332:        vm->hook = *be_indexof(vm, -1);
    #####:  333:    } else if (!var_istype(&vm->hook, BE_COMPTR)) {
    #####:  334:        var_setnil(&vm->hook);
        -:  335:    }
    #####:  336:}
        -:  337:
    #####:  338:BERRY_API void be_setntvhook(bvm *vm, bntvhook hook, void *data, int mask)
        -:  339:{
        -:  340:    struct bhookblock *hb;
    #####:  341:    if (mask) {
    #####:  342:        if (!var_istype(&vm->hook, BE_COMPTR)) {
    #####:  343:            var_setobj(&vm->hook, BE_COMPTR,
        -:  344:                be_malloc(vm, sizeof(struct bhookblock)));
        -:  345:        }
    #####:  346:        hb = var_toobj(&vm->hook);
        -:  347:        be_assert(hb != NULL);
    #####:  348:        hb->hook = hook;
    #####:  349:        hb->data = data;
    #####:  350:    } else if (!var_istype(&vm->hook, BE_COMPTR)) {
    #####:  351:        var_setnil(&vm->hook);
        -:  352:    }
    #####:  353:    vm->hookmask = (bbyte)mask;
    #####:  354:}
        -:  355:
        -:  356:#endif
        -:  357:
        -:  358:#if BE_DEBUG_VAR_INFO
    #####:  359:static binstruction* callstack_fixip(bvm *vm, int level)
        -:  360:{
    #####:  361:    bcallframe *top = (bcallframe*)be_stack_top(&vm->callstack);
    #####:  362:    bcallframe *cf = top - level + 2;
    #####:  363:    for (; cf <= top && cf->status & PRIM_FUNC; ++cf);
    #####:  364:    return cf <= top ? cf->ip : vm->ip;
        -:  365:}
        -:  366:
    #####:  367:bbool be_debug_varname(bvm *vm, int level, int index)
        -:  368:{
    #####:  369:    int depth = be_stack_count(&vm->callstack);
    #####:  370:    if (level > 0 && level <= depth) {
    #####:  371:        bcallframe *cf = be_vector_at(&vm->callstack, depth - level);
    #####:  372:        if ((cf->status & PRIM_FUNC) == 0) {
    #####:  373:            bproto *proto = cast(bclosure*, var_toobj(cf->func))->proto;
    #####:  374:            int pc = (int)(callstack_fixip(vm, level) - proto->code);
    #####:  375:            bstring *name = be_func_varname(proto, index, pc);
    #####:  376:            if (name) {
    #####:  377:                bvalue *reg = be_incrtop(vm);
    #####:  378:                var_setstr(reg, name);
    #####:  379:                return btrue;
        -:  380:            }
        -:  381:        }
        -:  382:    }
    #####:  383:    return bfalse;
        -:  384:}
        -:  385:
    #####:  386:bbool be_debug_upvname(bvm *vm, int level, int index)
        -:  387:{
    #####:  388:    int depth = be_stack_count(&vm->callstack);
    #####:  389:    if (level > 0 && level <= depth) {
    #####:  390:        bcallframe *cf = be_vector_at(&vm->callstack, depth - level);
    #####:  391:        if ((cf->status & PRIM_FUNC) == 0) {
    #####:  392:            bproto *proto = cast(bclosure*, var_toobj(cf->func))->proto;
    #####:  393:            if (index >= 0 && index < proto->nupvals) {
    #####:  394:                bvalue *reg = be_incrtop(vm);
    #####:  395:                var_setstr(reg, proto->upvals[index].name);
    #####:  396:                return btrue;
        -:  397:            }
        -:  398:        }
        -:  399:    }
    #####:  400:    return bfalse;
        -:  401:}
        -:  402:#endif
