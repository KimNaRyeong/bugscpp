        -:    0:Source:src/be_func.c
        -:    0:Graph:./src/be_func.gcno
        -:    0:Data:./src/be_func.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_func.h"
        -:    9:#include "be_gc.h"
        -:   10:#include "be_mem.h"
        -:   11:#include "be_vm.h"
        -:   12:#include "be_exec.h"
        -:   13:#include <string.h>
        -:   14:
        -:   15:#define clousersize(n) \
        -:   16:    (sizeof(bclosure) + sizeof(bupval*) * ((size_t)(n) - 1))
        -:   17:
    #####:   18:static bupval* findupval(bvm *vm, bvalue *level)
        -:   19:{
    #####:   20:    bupval *node = vm->upvalist;
    #####:   21:    while (node != NULL && node->value > level) {
    #####:   22:        node = node->u.next;
        -:   23:    }
    #####:   24:    if (!node || node->value != level) {
        -:   25:        /* not found */
    #####:   26:        node = be_malloc(vm, sizeof(bupval));
    #####:   27:        node->value = level;
    #####:   28:        node->refcnt = 0;
        -:   29:        /* insert to list head */
    #####:   30:        node->u.next = vm->upvalist;
    #####:   31:        vm->upvalist = node;
        -:   32:    }
    #####:   33:    return node;
        -:   34:}
        -:   35:
    #####:   36:void be_initupvals(bvm *vm, bclosure *cl)
        -:   37:{
    #####:   38:    int count = cl->proto->nupvals;
    #####:   39:    bupvaldesc *desc = cl->proto->upvals;
    #####:   40:    bvalue *stack = vm->reg;
    #####:   41:    bupval **uv = cl->upvals;
    #####:   42:    bupval **superuv = cast(bclosure*, var_toobj(vm->cf->func))->upvals;
    #####:   43:    for (; count--; desc++, uv++) {
    #####:   44:        if (desc->instack) {
    #####:   45:            bvalue *ref = stack + desc->idx;
    #####:   46:            *uv = findupval(vm, ref);
        -:   47:        } else {
    #####:   48:            *uv = superuv[desc->idx];
        -:   49:        }
    #####:   50:        (*uv)->refcnt++;
        -:   51:    }
    #####:   52:}
        -:   53:
    #####:   54:void be_upvals_close(bvm *vm, bvalue *level)
        -:   55:{
    #####:   56:    bupval *node = vm->upvalist, *next;
    #####:   57:    bupval **prev = &vm->upvalist;
    #####:   58:    while (node) {
    #####:   59:        next = node->u.next;
    #####:   60:        if (node->value >= level) {
    #####:   61:            if (!node->refcnt) {
    #####:   62:                be_free(vm, node, sizeof(bupval));
        -:   63:            } else {
    #####:   64:                node->u.value = *node->value; /* move value to upvalue slot */
    #####:   65:                node->value = &node->u.value;
        -:   66:            }
    #####:   67:            *prev = next;   /* remove from linked list */
        -:   68:        } else {
    #####:   69:            prev = &node->u.next;
        -:   70:        }
    #####:   71:        node = next;
        -:   72:    }
    #####:   73:}
        -:   74:
        1:   75:void be_release_upvalues(bvm *vm, bclosure *cl)
        -:   76:{
        1:   77:    int i, count = cl->nupvals;
       1*:   78:    for (i = 0; i < count; ++i) {
    #####:   79:        bupval *uv = cl->upvals[i];
    #####:   80:        if (uv) {
    #####:   81:            if (uv->refcnt) {
    #####:   82:                --uv->refcnt;
        -:   83:            }
        -:   84:            /* delete non-referenced closed upvalue */
    #####:   85:            if (uv->value == &uv->u.value && !uv->refcnt) {
    #####:   86:                be_free(vm, uv, sizeof(bupval));
        -:   87:            }
        -:   88:        }
        -:   89:    }
        1:   90:}
        -:   91:
        1:   92:bproto* be_newproto(bvm *vm)
        -:   93:{
        1:   94:    bgcobject *gco = be_gcnew(vm, BE_PROTO, bproto);
       1*:   95:    bproto *p = cast_proto(gco);
        1:   96:    if (p) {
        1:   97:        p->upvals = NULL;
        1:   98:        p->ktab = NULL;
        1:   99:        p->ptab = NULL;
        1:  100:        p->code = NULL;
        1:  101:        p->name = NULL;
        1:  102:        p->gray = NULL;
        1:  103:        p->codesize = 0;
        1:  104:        p->nupvals = 0;
        1:  105:        p->nproto = 0;
        1:  106:        p->nconst = 0;
        1:  107:        p->nstack = 0;
        1:  108:        p->codesize = 0;
        1:  109:        p->argc = 0;
        1:  110:        p->varg = 0;
        1:  111:        p->source = NULL;
        -:  112:#if BE_DEBUG_RUNTIME_INFO
        1:  113:        p->lineinfo = NULL;
        1:  114:        p->nlineinfo = 0;
        -:  115:#endif
        -:  116:#if BE_DEBUG_VAR_INFO
        1:  117:        p->varinfo = NULL;
        1:  118:        p->nvarinfo = 0;
        -:  119:#endif
        -:  120:    }
        1:  121:    return p;
        -:  122:}
        -:  123:
        1:  124:bclosure* be_newclosure(bvm *vm, int nupval)
        -:  125:{
        1:  126:    bgcobject *gco = be_newgcobj(vm, BE_CLOSURE, clousersize(nupval));
       1*:  127:    bclosure *cl = cast_closure(gco);
        1:  128:    if (cl) {
        1:  129:        cl->proto = NULL;
        1:  130:        cl->nupvals = (bbyte)nupval;
        1:  131:        while (nupval--) {
    #####:  132:            cl->upvals[nupval] = NULL;
        -:  133:        }
        -:  134:    }
        1:  135:    return cl;
        -:  136:}
        -:  137:
    #####:  138:static void init_upvals(bvm *vm, bntvclos *f)
        -:  139:{
    #####:  140:    int count = f->nupvals;
    #####:  141:    bupval **upvals = &be_ntvclos_upval(f, 0);
    #####:  142:    while (count--) {
    #####:  143:        bupval *uv = be_malloc(vm, sizeof(bupval)); /* was closed */
    #####:  144:        uv->value = &uv->u.value;
    #####:  145:        uv->refcnt = 1;
    #####:  146:        var_setnil(uv->value);
    #####:  147:        *upvals++ = uv;
        -:  148:    }
    #####:  149:}
        -:  150:
    #####:  151:bntvclos* be_newntvclosure(bvm *vm, bntvfunc cf, int nupvals)
        -:  152:{
    #####:  153:    size_t size = sizeof(bntvclos) + sizeof(bupval*) * nupvals;
    #####:  154:    bgcobject *gco = be_newgcobj(vm, BE_NTVCLOS, size);
    #####:  155:    bntvclos *f = cast_ntvclos(gco);
    #####:  156:    if (f) {
    #####:  157:        f->f = cf;
    #####:  158:        f->nupvals = (bbyte)nupvals;
    #####:  159:        if (nupvals) {
    #####:  160:            var_setntvclos(vm->top, f);
    #####:  161:            be_incrtop(vm);
    #####:  162:            init_upvals(vm, f); /* may be GC */
    #####:  163:            be_stackpop(vm, 1);
        -:  164:        }
        -:  165:    }
    #####:  166:    return f;
        -:  167:}
        -:  168:
        -:  169:#if BE_DEBUG_VAR_INFO
    #####:  170:bstring* be_func_varname(bproto *proto, int index, int pc)
        -:  171:{
    #####:  172:    int i, nvarinfo = proto->nvarinfo;
    #####:  173:    bvarinfo *varinfo = proto->varinfo;
    #####:  174:    for (i = 0; i < nvarinfo && varinfo[i].beginpc <= pc; ++i) {
    #####:  175:        if (pc <= varinfo[i].endpc && index-- == 0) {
    #####:  176:            return varinfo[i].name;
        -:  177:        }
        -:  178:    }
    #####:  179:    return NULL;
        -:  180:}
        -:  181:#endif
