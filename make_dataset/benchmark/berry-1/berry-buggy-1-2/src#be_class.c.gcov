        -:    0:Source:src/be_class.c
        -:    0:Graph:./src/be_class.gcno
        -:    0:Data:./src/be_class.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_class.h"
        -:    9:#include "be_string.h"
        -:   10:#include "be_vector.h"
        -:   11:#include "be_map.h"
        -:   12:#include "be_exec.h"
        -:   13:#include "be_gc.h"
        -:   14:#include "be_vm.h"
        -:   15:#include "be_func.h"
        -:   16:#include "be_var.h"
        -:   17:#include <string.h>
        -:   18:
        -:   19:#define check_members(vm, c)            \
        -:   20:    if (!(c)->members) {                \
        -:   21:        (c)->members = be_map_new(vm);  \
        -:   22:    }
        -:   23:
    #####:   24:bclass* be_newclass(bvm *vm, bstring *name, bclass *super)
        -:   25:{
    #####:   26:    bgcobject *gco = be_gcnew(vm, BE_CLASS, bclass);
    #####:   27:    bclass *obj = cast_class(gco);
    #####:   28:    bvalue *buf = be_incrtop(vm); /* protect new objects from GC */
    #####:   29:    var_setclass(buf, obj);
    #####:   30:    if (obj) {
    #####:   31:        obj->super = super;
    #####:   32:        obj->members = NULL; /* gc protection */
    #####:   33:        obj->nvar = 0;
    #####:   34:        obj->name = name;
        -:   35:    }
    #####:   36:    be_stackpop(vm, 1);
    #####:   37:    return obj;
        -:   38:}
        -:   39:
    #####:   40:void be_class_compress(bvm *vm, bclass *c)
        -:   41:{
    #####:   42:    if (!gc_isconst(c) && c->members) {
    #####:   43:        be_map_release(vm, c->members); /* clear space */
        -:   44:    }
    #####:   45:}
        -:   46:
    #####:   47:int be_class_attribute(bvm *vm, bclass *c, bstring *attr)
        -:   48:{
    #####:   49:    for (; c; c = c->super) {
    #####:   50:        if (c->members) {
    #####:   51:            bvalue *v = be_map_findstr(vm, c->members, attr);
    #####:   52:            if (v) {
    #####:   53:                return var_type(v);
        -:   54:            }
        -:   55:        }
        -:   56:    }
    #####:   57:    return BE_NONE;
        -:   58:}
        -:   59:
    #####:   60:void be_member_bind(bvm *vm, bclass *c, bstring *name, bbool var)
        -:   61:{
        -:   62:    bvalue *attr;
    #####:   63:    set_fixed(name);
    #####:   64:    check_members(vm, c);
    #####:   65:    attr = be_map_insertstr(vm, c->members, name, NULL);
    #####:   66:    restore_fixed(name);
    #####:   67:    if (var) {
        -:   68:        /* this is an instance variable so we set it as MT_VARIABLE */
    #####:   69:        attr->v.i = c->nvar++;
    #####:   70:        attr->type = MT_VARIABLE;
        -:   71:    } else {
        -:   72:        /* this is a static class constant, leave it as BE_NIL */
    #####:   73:        attr->v.i = 0;
    #####:   74:        attr->type = BE_NIL;
        -:   75:    }
    #####:   76:}
        -:   77:
    #####:   78:void be_method_bind(bvm *vm, bclass *c, bstring *name, bproto *p)
        -:   79:{
        -:   80:    bclosure *cl;
        -:   81:    bvalue *attr;
    #####:   82:    set_fixed(name);
    #####:   83:    check_members(vm, c);
    #####:   84:    attr = be_map_insertstr(vm, c->members, name, NULL);
    #####:   85:    restore_fixed(name);
    #####:   86:    var_setnil(attr);
    #####:   87:    cl = be_newclosure(vm, p->nupvals);
    #####:   88:    cl->proto = p;
    #####:   89:    var_setclosure(attr, cl);
    #####:   90:}
        -:   91:
    #####:   92:void be_prim_method_bind(bvm *vm, bclass *c, bstring *name, bntvfunc f)
        -:   93:{
        -:   94:    bvalue *attr;
    #####:   95:    set_fixed(name);
    #####:   96:    check_members(vm, c);
    #####:   97:    attr = be_map_insertstr(vm, c->members, name, NULL);
    #####:   98:    restore_fixed(name);
    #####:   99:    attr->v.nf = f;
    #####:  100:    attr->type = MT_PRIMMETHOD;
    #####:  101:}
        -:  102:
    #####:  103:void be_closure_method_bind(bvm *vm, bclass *c, bstring *name, bclosure *cl)
        -:  104:{
        -:  105:    bvalue *attr;
    #####:  106:    check_members(vm, c);
    #####:  107:    attr = be_map_insertstr(vm, c->members, name, NULL);
    #####:  108:    attr->v.gc = (bgcobject*) cl;
    #####:  109:    attr->type = MT_METHOD;
    #####:  110:}
        -:  111:
        -:  112:/* get the closure method count that need upvalues */
    #####:  113:int be_class_closure_count(bclass *c)
        -:  114:{
    #####:  115:    int count = 0;
    #####:  116:    if (c->members) {
        -:  117:        bmapnode *node;
    #####:  118:        bmap *members = c->members;
    #####:  119:        bmapiter iter = be_map_iter();
    #####:  120:        while ((node = be_map_next(members, &iter)) != NULL) {
    #####:  121:            if (var_isproto(&node->value)) {
    #####:  122:                ++count;
        -:  123:            }
        -:  124:        }
        -:  125:    }
    #####:  126:    return count;
        -:  127:}
        -:  128:
        4:  129:static binstance* instance_member(bvm *vm,
        -:  130:    binstance *obj, bstring *name, bvalue *dst)
        -:  131:{
        5:  132:    for (; obj; obj = obj->super) {
        4:  133:        bmap *members = obj->_class->members;
        4:  134:        if (members) {
        4:  135:            bvalue *v = be_map_findstr(vm, members, name);
        4:  136:            if (v) {
        3:  137:                *dst = *v;
        3:  138:                return obj;
        -:  139:            }
        -:  140:        }
        -:  141:    }
        1:  142:    var_setnil(dst);
        1:  143:    return NULL;
        -:  144:}
        -:  145:
    #####:  146:static bclass* class_member(bvm *vm,
        -:  147:    bclass *obj, bstring *name, bvalue *dst)
        -:  148:{
    #####:  149:    for (; obj; obj = obj->super) {
    #####:  150:        bmap *members = obj->members;
    #####:  151:        if (members) {
    #####:  152:            bvalue *v = be_map_findstr(vm, members, name);
    #####:  153:            if (v) {
    #####:  154:                *dst = *v;
    #####:  155:                return obj;
        -:  156:            }
        -:  157:        }
        -:  158:    }
    #####:  159:    var_setnil(dst);
    #####:  160:    return NULL;
        -:  161:}
        -:  162:
    #####:  163:void be_class_upvalue_init(bvm *vm, bclass *c)
        -:  164:{
    #####:  165:    bmap *mbr = c->members;
    #####:  166:    if (mbr != NULL) {
        -:  167:        bmapnode *node;
    #####:  168:        bmapiter iter = be_map_iter();
    #####:  169:        while ((node = be_map_next(mbr, &iter)) != NULL) {
    #####:  170:            if (var_isclosure(&node->value)) {
    #####:  171:                bclosure *cl = var_toobj(&node->value);
    #####:  172:                if (cl->proto->nupvals) {
        -:  173:                    /* initialize the closure's upvalues */
    #####:  174:                    be_release_upvalues(vm, cl);
    #####:  175:                    be_initupvals(vm, cl);
        -:  176:                }
        -:  177:            }
        -:  178:        }
        -:  179:    }
    #####:  180:}
        -:  181:
        -:  182:/* (internal) Instanciate an instance for a single class and initialize variables to nil */
        1:  183:static binstance* newobjself(bvm *vm, bclass *c)
        -:  184:{
        1:  185:    size_t size = sizeof(binstance) + sizeof(bvalue) * (c->nvar - 1);
        1:  186:    bgcobject *gco = be_newgcobj(vm, BE_INSTANCE, size);
       1*:  187:    binstance *obj = cast_instance(gco);
        -:  188:    be_assert(obj != NULL);
        1:  189:    if (obj) { /* initialize members */
        1:  190:        bvalue *v = obj->members, *end = v + c->nvar;  /* instance variables is a simple array of pointers at obj->members of size c->nvar */
        2:  191:        while (v < end) { var_setnil(v); ++v; }  /* Initialize all instance variables to `nil` */
        1:  192:        obj->_class = c;  /* set its class object */
        1:  193:        obj->super = NULL;  /* no super class instance for now */
        1:  194:        obj->sub = NULL;  /* no subclass instance for now */
        -:  195:    }
        1:  196:    return obj;
        -:  197:}
        -:  198:
        -:  199:/* (internal) Instanciate the whole chain of instances when there is a class hierarchy */
        -:  200:/* All variables set to nil, constructors are not called here */
        1:  201:static binstance* newobject(bvm *vm, bclass *c)
        -:  202:{
        -:  203:    binstance *obj, *prev;
        -:  204:    be_assert(c != NULL);
        1:  205:    obj = prev = newobjself(vm, c);
        1:  206:    var_setinstance(vm->top, obj);
        1:  207:    be_incrtop(vm); /* protect new objects from GC */
       1*:  208:    for (c = c->super; c; c = c->super) {  /* initialize one instance object per class and per superclass */
    #####:  209:        prev->super = newobjself(vm, c);
    #####:  210:        prev->super->sub = prev;  /* link the super/sub classes instances */
    #####:  211:        prev = prev->super;
        -:  212:    }
        1:  213:    be_stackpop(vm, 1);
        1:  214:    return obj;
        -:  215:}
        -:  216:
        -:  217:/* Instanciate new instance from stack with argc parameters */
        -:  218:/* Pushes the constructor on the stack to be executed if a construtor is found */
        -:  219:/* Returns true if a constructor is found */
        1:  220:bbool be_class_newobj(bvm *vm, bclass *c, bvalue *reg, int argc, int mode)
        -:  221:{
        -:  222:    bvalue init;
        1:  223:    size_t pos = reg - vm->reg;
        1:  224:    binstance *obj = newobject(vm, c);  /* create empty object hierarchy from class hierarchy */
        1:  225:    reg = vm->reg + pos - mode; /* the stack may have changed, mode=1 when class is instanciated from module #104 */
        1:  226:    var_setinstance(reg, obj);
        1:  227:    var_setinstance(reg + mode, obj);  /* copy to reg and reg+1 if mode==1 */
        -:  228:    /* find constructor */
        1:  229:    obj = instance_member(vm, obj, str_literal(vm, "init"), &init);
        1:  230:    if (obj && var_type(&init) != MT_VARIABLE) {
        -:  231:        /* copy argv */
        2:  232:        for (reg = vm->reg + pos + 1; argc > 0; --argc) {
        1:  233:            reg[argc] = reg[argc - 2];
        -:  234:        }
        1:  235:        *reg = init; /* set constructor */
        1:  236:        return btrue;
        -:  237:    }
    #####:  238:    return bfalse;
        -:  239:}
        -:  240:
        -:  241:/* Default empty constructor */
    #####:  242:static int default_init_native_method(bvm *vm) {
    #####:  243:    be_return_nil(vm);
        -:  244:}
        -:  245:
        -:  246:/* Find instance member by name and copy value to `dst` */
        -:  247:/* Do not look into virtual members */
        1:  248:int be_instance_member_simple(bvm *vm, binstance *instance, bstring *name, bvalue *dst)
        -:  249:{
        -:  250:    int type;
        -:  251:    be_assert(name != NULL);
        1:  252:    binstance * obj = instance_member(vm, instance, name, dst);
        1:  253:    type = var_type(dst);
       1*:  254:    if (obj && type == MT_VARIABLE) {
    #####:  255:        *dst = obj->members[dst->v.i];
        -:  256:    }
        1:  257:    return type;
        -:  258:}
        -:  259:
        -:  260:/* Find instance member by name and copy value to `dst` */
        -:  261:/* Input: none of `obj`, `name` and `dst` may not be NULL */
        -:  262:/* Returns the type of the member or BE_NONE if member not found */
        -:  263:/* TODO need to support synthetic members */
        1:  264:int be_instance_member(bvm *vm, binstance *instance, bstring *name, bvalue *dst)
        -:  265:{
        -:  266:    int type;
        -:  267:    be_assert(name != NULL);
        1:  268:    binstance * obj = instance_member(vm, instance, name, dst);
        1:  269:    type = var_type(dst);
        1:  270:    if (obj && type == MT_VARIABLE) {
        1:  271:        *dst = obj->members[dst->v.i];
        -:  272:    }
        1:  273:    if (obj) {
        1:  274:        return type;
        -:  275:    } else {  /* if no method found, try virtual */
        -:  276:        /* if 'init' does not exist, create a virtual empty constructor */
    #####:  277:        if (strcmp(str(name), "init") == 0) {
    #####:  278:            var_setntvfunc(dst, default_init_native_method);
    #####:  279:            return var_type(dst);
        -:  280:        } else {
        -:  281:            /* get method 'member' */
    #####:  282:            obj = instance_member(vm, instance, str_literal(vm, "member"), vm->top);
    #####:  283:            if (obj && basetype(var_type(vm->top)) == BE_FUNCTION) {
    #####:  284:                bvalue *top = vm->top;
    #####:  285:                var_setinstance(&top[1], instance);
    #####:  286:                var_setstr(&top[2], name);
    #####:  287:                vm->top += 3;   /* prevent gc collection results */
    #####:  288:                be_dofunc(vm, top, 2); /* call method 'member' */
    #####:  289:                vm->top -= 3;
    #####:  290:                *dst = *vm->top;   /* copy result to R(A) */
    #####:  291:                if (obj && var_type(dst) == MT_VARIABLE) {
    #####:  292:                    *dst = obj->members[dst->v.i];
        -:  293:                }
    #####:  294:                type = var_type(dst);
    #####:  295:                if (type != BE_NIL) {
    #####:  296:                    return type;
        -:  297:                }
        -:  298:            }
        -:  299:        }
        -:  300:    }
    #####:  301:    return BE_NONE;
        -:  302:}
        -:  303:
    #####:  304:int be_class_member(bvm *vm, bclass *obj, bstring *name, bvalue *dst)
        -:  305:{
        -:  306:    int type;
        -:  307:    be_assert(name != NULL);
    #####:  308:    obj = class_member(vm, obj, name, dst);
    #####:  309:    type = var_type(dst);
    #####:  310:    if (obj) {
    #####:  311:        return type;
        -:  312:    } else {
    #####:  313:        return BE_NONE;
        -:  314:    }
        -:  315:}
        -:  316:
        1:  317:bbool be_instance_setmember(bvm *vm, binstance *o, bstring *name, bvalue *src)
        -:  318:{
        -:  319:    bvalue v;
        -:  320:    be_assert(name != NULL);
        1:  321:    binstance * obj = instance_member(vm, o, name, &v);
        1:  322:    if (obj && var_istype(&v, MT_VARIABLE)) {
        1:  323:        obj->members[var_toint(&v)] = *src;
        1:  324:        return btrue;
        -:  325:    } else {
    #####:  326:        obj = instance_member(vm, o, str_literal(vm, "setmember"), &v);
    #####:  327:        if (obj && var_type(&v) == MT_VARIABLE) {
    #####:  328:            v = obj->members[v.v.i];
        -:  329:        }
    #####:  330:        if (var_basetype(&v) == BE_FUNCTION) {
    #####:  331:            bvalue *top = vm->top;
    #####:  332:            var_setval(top, &v);
    #####:  333:            var_setinstance(top + 1, o); /* move instance to argv[0] */
    #####:  334:            var_setstr(top + 2, name); /* move method name to argv[1] */
    #####:  335:            var_setval(top + 3, src); /* move method name to argv[1] */
    #####:  336:            vm->top += 4;   /* prevent collection results */
    #####:  337:            be_dofunc(vm, top, 3); /* call method 'member' */
    #####:  338:            vm->top -= 4;
    #####:  339:            return var_tobool(top);
        -:  340:        }
        -:  341:    }
    #####:  342:    return bfalse;
        -:  343:}
        -:  344:
    #####:  345:bbool be_class_setmember(bvm *vm, bclass *o, bstring *name, bvalue *src)
        -:  346:{
        -:  347:    bvalue v;
        -:  348:    be_assert(name != NULL);
    #####:  349:    bclass * obj = class_member(vm, o, name, &v);
    #####:  350:    if (obj && !var_istype(&v, MT_VARIABLE)) {
    #####:  351:        be_map_insertstr(vm, obj->members, name, src);
    #####:  352:        return btrue;
        -:  353:    }
    #####:  354:    return bfalse;
        -:  355:}
