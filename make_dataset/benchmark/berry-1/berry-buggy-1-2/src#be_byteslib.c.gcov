        -:    0:Source:src/be_byteslib.c
        -:    0:Graph:./src/be_byteslib.gcno
        -:    0:Data:./src/be_byteslib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang - Stephan Hadinger
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_string.h"
        -:   10:#include "be_strlib.h"
        -:   11:#include "be_list.h"
        -:   12:#include "be_func.h"
        -:   13:#include "be_exec.h"
        -:   14:#include "be_vm.h"
        -:   15:#include "be_mem.h"
        -:   16:#include "be_constobj.h"
        -:   17:#include <string.h>
        -:   18:#include <ctype.h>
        -:   19:
        -:   20:#define BYTES_DEFAULT_SIZE          28              // default pre-reserved size for buffer (keep 4 bytes for len/size)
        -:   21:#define BYTES_MAX_SIZE              (32*1024)       // max 32Kb
        -:   22:#define BYTES_OVERHEAD              4               // bytes overhead to be added when allocating (used to store len and size)
        -:   23:#define BYTES_HEADROOM              8               // keep a natural headroom of 8 bytes when resizing
        -:   24:
        -:   25:typedef struct buf_impl {
        -:   26:  uint16_t size;                // size in bytes of the buffer
        -:   27:  uint16_t len;                 // current size of the data in buffer. Invariant: len <= size
        -:   28:  uint8_t buf[];                // the actual data
        -:   29:} buf_impl;
        -:   30:
        -:   31:/********************************************************************
        -:   32:** Base64 lib from https://github.com/Densaugeo/base64_arduino
        -:   33:**
        -:   34:********************************************************************/
        -:   35:
        -:   36:/* binary_to_base64:
        -:   37: *   Description:
        -:   38: *     Converts a single byte from a binary value to the corresponding base64 character
        -:   39: *   Parameters:
        -:   40: *     v - Byte to convert
        -:   41: *   Returns:
        -:   42: *     ascii code of base64 character. If byte is >= 64, then there is not corresponding base64 character
        -:   43: *     and 255 is returned
        -:   44: */
        -:   45:static unsigned char binary_to_base64(unsigned char v);
        -:   46:
        -:   47:/* base64_to_binary:
        -:   48: *   Description:
        -:   49: *     Converts a single byte from a base64 character to the corresponding binary value
        -:   50: *   Parameters:
        -:   51: *     c - Base64 character (as ascii code)
        -:   52: *   Returns:
        -:   53: *     6-bit binary value
        -:   54: */
        -:   55:static unsigned char base64_to_binary(unsigned char c);
        -:   56:
        -:   57:/* encode_base64_length:
        -:   58: *   Description:
        -:   59: *     Calculates length of base64 string needed for a given number of binary bytes
        -:   60: *   Parameters:
        -:   61: *     input_length - Amount of binary data in bytes
        -:   62: *   Returns:
        -:   63: *     Number of base64 characters needed to encode input_length bytes of binary data
        -:   64: */
        -:   65:static unsigned int encode_base64_length(unsigned int input_length);
        -:   66:
        -:   67:/* decode_base64_length:
        -:   68: *   Description:
        -:   69: *     Calculates number of bytes of binary data in a base64 string
        -:   70: *   Parameters:
        -:   71: *     input - Base64-encoded null-terminated string
        -:   72: *   Returns:
        -:   73: *     Number of bytes of binary data in input
        -:   74: */
        -:   75:static unsigned int decode_base64_length(unsigned char input[]);
        -:   76:
        -:   77:/* encode_base64:
        -:   78: *   Description:
        -:   79: *     Converts an array of bytes to a base64 null-terminated string
        -:   80: *   Parameters:
        -:   81: *     input - Pointer to input data
        -:   82: *     input_length - Number of bytes to read from input pointer
        -:   83: *     output - Pointer to output string. Null terminator will be added automatically
        -:   84: *   Returns:
        -:   85: *     Length of encoded string in bytes (not including null terminator)
        -:   86: */
        -:   87:static unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]);
        -:   88:
        -:   89:/* decode_base64:
        -:   90: *   Description:
        -:   91: *     Converts a base64 null-terminated string to an array of bytes
        -:   92: *   Parameters:
        -:   93: *     input - Pointer to input string
        -:   94: *     output - Pointer to output array
        -:   95: *   Returns:
        -:   96: *     Number of bytes in the decoded binary
        -:   97: */
        -:   98:static unsigned int decode_base64(unsigned char input[], unsigned char output[]);
        -:   99:
    #####:  100:static unsigned char binary_to_base64(unsigned char v) {
        -:  101:  // Capital letters - 'A' is ascii 65 and base64 0
    #####:  102:  if(v < 26) return v + 'A';
        -:  103:  
        -:  104:  // Lowercase letters - 'a' is ascii 97 and base64 26
    #####:  105:  if(v < 52) return v + 71;
        -:  106:  
        -:  107:  // Digits - '0' is ascii 48 and base64 52
    #####:  108:  if(v < 62) return v - 4;
        -:  109:  
        -:  110:  // '+' is ascii 43 and base64 62
    #####:  111:  if(v == 62) return '+';
        -:  112:  
        -:  113:  // '/' is ascii 47 and base64 63
    #####:  114:  if(v == 63) return '/';
        -:  115:  
    #####:  116:  return 64;
        -:  117:}
        -:  118:
    #####:  119:static unsigned char base64_to_binary(unsigned char c) {
        -:  120:  // Capital letters - 'A' is ascii 65 and base64 0
    #####:  121:  if('A' <= c && c <= 'Z') return c - 'A';
        -:  122:  
        -:  123:  // Lowercase letters - 'a' is ascii 97 and base64 26
    #####:  124:  if('a' <= c && c <= 'z') return c - 71;
        -:  125:  
        -:  126:  // Digits - '0' is ascii 48 and base64 52
    #####:  127:  if('0' <= c && c <= '9') return c + 4;
        -:  128:  
        -:  129:  // '+' is ascii 43 and base64 62
    #####:  130:  if(c == '+') return 62;
        -:  131:  
        -:  132:  // '/' is ascii 47 and base64 63
    #####:  133:  if(c == '/') return 63;
        -:  134:  
    #####:  135:  return 255;
        -:  136:}
        -:  137:
    #####:  138:static unsigned int encode_base64_length(unsigned int input_length) {
    #####:  139:  return (input_length + 2)/3*4;
        -:  140:}
        -:  141:
    #####:  142:static unsigned int decode_base64_length(unsigned char input[]) {
    #####:  143:  unsigned char *start = input;
        -:  144:  
    #####:  145:  while(base64_to_binary(input[0]) < 64) {
    #####:  146:    ++input;
        -:  147:  }
        -:  148:  
    #####:  149:  unsigned int input_length = input - start;
        -:  150:  
    #####:  151:  unsigned int output_length = input_length/4*3;
        -:  152:  
    #####:  153:  switch(input_length % 4) {
    #####:  154:    default: return output_length;
    #####:  155:    case 2: return output_length + 1;
    #####:  156:    case 3: return output_length + 2;
        -:  157:  }
        -:  158:}
        -:  159:
    #####:  160:static unsigned int encode_base64(unsigned char input[], unsigned int input_length, unsigned char output[]) {
    #####:  161:  unsigned int full_sets = input_length/3;
        -:  162:  
        -:  163:  // While there are still full sets of 24 bits...
    #####:  164:  for(unsigned int i = 0; i < full_sets; ++i) {
    #####:  165:    output[0] = binary_to_base64(                         input[0] >> 2);
    #####:  166:    output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    #####:  167:    output[2] = binary_to_base64((input[1] & 0x0F) << 2 | input[2] >> 6);
    #####:  168:    output[3] = binary_to_base64( input[2] & 0x3F);
        -:  169:    
    #####:  170:    input += 3;
    #####:  171:    output += 4;
        -:  172:  }
        -:  173:  
    #####:  174:  switch(input_length % 3) {
    #####:  175:    case 0:
    #####:  176:      output[0] = '\0';
    #####:  177:      break;
    #####:  178:    case 1:
    #####:  179:      output[0] = binary_to_base64(                         input[0] >> 2);
    #####:  180:      output[1] = binary_to_base64((input[0] & 0x03) << 4);
    #####:  181:      output[2] = '=';
    #####:  182:      output[3] = '=';
    #####:  183:      output[4] = '\0';
    #####:  184:      break;
    #####:  185:    case 2:
    #####:  186:      output[0] = binary_to_base64(                         input[0] >> 2);
    #####:  187:      output[1] = binary_to_base64((input[0] & 0x03) << 4 | input[1] >> 4);
    #####:  188:      output[2] = binary_to_base64((input[1] & 0x0F) << 2);
    #####:  189:      output[3] = '=';
    #####:  190:      output[4] = '\0';
    #####:  191:      break;
        -:  192:  }
        -:  193:  
    #####:  194:  return encode_base64_length(input_length);
        -:  195:}
        -:  196:
    #####:  197:static unsigned int decode_base64(unsigned char input[], unsigned char output[]) {
    #####:  198:  unsigned int output_length = decode_base64_length(input);
        -:  199:  
        -:  200:  // While there are still full sets of 24 bits...
    #####:  201:  for(unsigned int i = 2; i < output_length; i += 3) {
    #####:  202:    output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    #####:  203:    output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    #####:  204:    output[2] = base64_to_binary(input[2]) << 6 | base64_to_binary(input[3]);
        -:  205:    
    #####:  206:    input += 4;
    #####:  207:    output += 3;
        -:  208:  }
        -:  209:  
    #####:  210:  switch(output_length % 3) {
    #####:  211:    case 1:
    #####:  212:      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    #####:  213:      break;
    #####:  214:    case 2:
    #####:  215:      output[0] = base64_to_binary(input[0]) << 2 | base64_to_binary(input[1]) >> 4;
    #####:  216:      output[1] = base64_to_binary(input[1]) << 4 | base64_to_binary(input[2]) >> 2;
    #####:  217:      break;
        -:  218:  }
        -:  219:  
    #####:  220:  return output_length;
        -:  221:}
        -:  222:
        -:  223:/********************************************************************
        -:  224:** Buffer low-level implementation
        -:  225:**
        -:  226:** Extracted from Tasmota SBuffer lib
        -:  227:********************************************************************/
    #####:  228:static inline uint8_t* buf_get_buf(buf_impl* buf)
        -:  229:{
    #####:  230:    return &buf->buf[0];
        -:  231:}
        -:  232:
        -:  233:// shrink or increase. If increase, fill with zeores. Cannot go beyond `size`
    #####:  234:static void buf_set_len(buf_impl* buf, const size_t len)
        -:  235:{
    #####:  236:    uint16_t old_len = buf->len;
    #####:  237:    buf->len = (len <= buf->size) ? len : buf->size;
    #####:  238:    if (old_len < buf->len) {
    #####:  239:        memset((void*) &buf->buf[old_len], 0, buf->len - old_len);
        -:  240:    }
    #####:  241:}
        -:  242:
    #####:  243:static size_t buf_add1(buf_impl* buf, const uint8_t data) // append 8 bits value
        -:  244:{
    #####:  245:    if (buf->len < buf->size) {       // do we have room for 1 byte
    #####:  246:        buf->buf[buf->len++] = data;
        -:  247:    }
    #####:  248:    return buf->len;
        -:  249:}
        -:  250:
    #####:  251:static size_t buf_add2_le(buf_impl* buf, const uint16_t data) // append 16 bits value
        -:  252:{
    #####:  253:    if (buf->len < buf->size - 1) {    // do we have room for 2 bytes
    #####:  254:        buf->buf[buf->len++] = data;
    #####:  255:        buf->buf[buf->len++] = data >> 8;
        -:  256:    }
    #####:  257:    return buf->len;
        -:  258:}
        -:  259:
    #####:  260:static size_t buf_add2_be(buf_impl* buf, const uint16_t data) // append 16 bits value
        -:  261:{
    #####:  262:    if (buf->len < buf->size - 1) {    // do we have room for 2 bytes
    #####:  263:        buf->buf[buf->len++] = data >> 8;
    #####:  264:        buf->buf[buf->len++] = data;
        -:  265:    }
    #####:  266:    return buf->len;
        -:  267:}
        -:  268:
    #####:  269:static size_t buf_add4_le(buf_impl* buf, const uint32_t data) // append 32 bits value
        -:  270:{
    #####:  271:    if (buf->len < buf->size - 3) {     // do we have room for 4 bytes
    #####:  272:        buf->buf[buf->len++] = data;
    #####:  273:        buf->buf[buf->len++] = data >> 8;
    #####:  274:        buf->buf[buf->len++] = data >> 16;
    #####:  275:        buf->buf[buf->len++] = data >> 24;
        -:  276:    }
    #####:  277:    return buf->len;
        -:  278:}
        -:  279:
    #####:  280:size_t buf_add4_be(buf_impl* buf, const uint32_t data) // append 32 bits value
        -:  281:{
    #####:  282:    if (buf->len < buf->size - 3) {     // do we have room for 4 bytes
    #####:  283:        buf->buf[buf->len++] = data >> 24;
    #####:  284:        buf->buf[buf->len++] = data >> 16;
    #####:  285:        buf->buf[buf->len++] = data >> 8;
    #####:  286:        buf->buf[buf->len++] = data;
        -:  287:    }
    #####:  288:    return buf->len;
        -:  289:}
        -:  290:
    #####:  291:static size_t buf_add_buf(buf_impl* buf, buf_impl* buf2)
        -:  292:{
    #####:  293:    if (buf->len + buf2->len <= buf->size) {
    #####:  294:        for (uint32_t i = 0; i < buf2->len; i++) {
    #####:  295:            buf->buf[buf->len++] = buf2->buf[i];
        -:  296:        }
        -:  297:    }
    #####:  298:    return buf->len;
        -:  299:}
        -:  300:
    #####:  301:static uint8_t buf_get1(buf_impl* buf, int offset)
        -:  302:{
    #####:  303:    if ((offset >= 0) && (offset < buf->len)) {
    #####:  304:        return buf->buf[offset];
        -:  305:    }
    #####:  306:    return 0;
        -:  307:}
        -:  308:
    #####:  309:static void buf_set1(buf_impl* buf, size_t offset, uint8_t data)
        -:  310:{
    #####:  311:    if (offset < buf->len) {
    #####:  312:        buf->buf[offset] = data;
        -:  313:    }
    #####:  314:}
        -:  315:
    #####:  316:static void buf_set2_le(buf_impl* buf, size_t offset, uint16_t data)
        -:  317:{
    #####:  318:    if (offset + 1 < buf->len) {
    #####:  319:        buf->buf[offset] = data & 0xFF;
    #####:  320:        buf->buf[offset+1] = data >> 8;
        -:  321:    }
    #####:  322:}
        -:  323:
    #####:  324:static void buf_set2_be(buf_impl* buf, size_t offset, uint16_t data)
        -:  325:{
    #####:  326:    if (offset + 1 < buf->len) {
    #####:  327:        buf->buf[offset+1] = data & 0xFF;
    #####:  328:        buf->buf[offset] = data >> 8;
        -:  329:    }
    #####:  330:}
        -:  331:
    #####:  332:static uint16_t buf_get2_le(buf_impl* buf, size_t offset)
        -:  333:{
    #####:  334:    if (offset + 1 < buf->len) {
    #####:  335:        return buf->buf[offset] | (buf->buf[offset+1] << 8);
        -:  336:    }
    #####:  337:    return 0;
        -:  338:}
        -:  339:
    #####:  340:static uint16_t buf_get2_be(buf_impl* buf, size_t offset)
        -:  341:{
    #####:  342:    if (offset + 1 < buf->len) {
    #####:  343:        return buf->buf[offset+1] | (buf->buf[offset] << 8);
        -:  344:    }
    #####:  345:    return 0;
        -:  346:}
        -:  347:
    #####:  348:static void buf_set4_le(buf_impl* buf, size_t offset, uint32_t data)
        -:  349:{
    #####:  350:    if (offset + 3 < buf->len) {
    #####:  351:        buf->buf[offset] = data & 0xFF;
    #####:  352:        buf->buf[offset+1] = (data >> 8) & 0xFF;
    #####:  353:        buf->buf[offset+2] = (data >> 16) & 0xFF;
    #####:  354:        buf->buf[offset+3] = data >> 24;
        -:  355:    }
    #####:  356:}
        -:  357:
    #####:  358:static void buf_set4_be(buf_impl* buf, size_t offset, uint32_t data)
        -:  359:{
    #####:  360:    if (offset + 3 < buf->len) {
    #####:  361:        buf->buf[offset+3] = data & 0xFF;
    #####:  362:        buf->buf[offset+2] = (data >> 8) & 0xFF;
    #####:  363:        buf->buf[offset+1] = (data >> 16) & 0xFF;
    #####:  364:        buf->buf[offset] = data >> 24;
        -:  365:    }
    #####:  366:}
        -:  367:
    #####:  368:static uint32_t buf_get4_le(buf_impl* buf, size_t offset)
        -:  369:{
    #####:  370:    if (offset + 3 < buf->len) {
    #####:  371:        return buf->buf[offset] | (buf->buf[offset+1] << 8) |
    #####:  372:            (buf->buf[offset+2] << 16) | (buf->buf[offset+3] << 24);
        -:  373:    }
    #####:  374:    return 0;
        -:  375:}
        -:  376:
    #####:  377:static uint32_t buf_get4_be(buf_impl* buf, size_t offset)
        -:  378:{
    #####:  379:    if (offset + 3 < buf->len) {
    #####:  380:        return buf->buf[offset+3] | (buf->buf[offset+2] << 8) |
    #####:  381:            (buf->buf[offset+1] << 16) | (buf->buf[offset] << 24);
        -:  382:    }
    #####:  383:    return 0;
        -:  384:}
        -:  385:
        -:  386:// nullptr accepted
    #####:  387:static bbool buf_equals(buf_impl* buf1, buf_impl* buf2)
        -:  388:{
    #####:  389:    if (buf1 == buf2) { return btrue; }
    #####:  390:    if (!buf1 || !buf2) { return bfalse; }   // at least one buf is not empty
        -:  391:    // we know that both buf1 and buf2 are non-null
    #####:  392:    if (buf1->len != buf2->len) { return bfalse; }
    #####:  393:    size_t len = buf1->len;
    #####:  394:    for (uint32_t i=0; i<len; i++) {
    #####:  395:        if (buf_get1(buf1, i) != buf_get1(buf2, i)) { return bfalse; }
        -:  396:    }
    #####:  397:    return btrue;
        -:  398:}
        -:  399:
    #####:  400:static uint8_t asc2byte(char chr)
        -:  401:{
    #####:  402:    uint8_t rVal = 0;
    #####:  403:    if (isdigit(chr)) { rVal = chr - '0'; }
    #####:  404:    else if (chr >= 'A' && chr <= 'F') { rVal = chr + 10 - 'A'; }
    #####:  405:    else if (chr >= 'a' && chr <= 'f') { rVal = chr + 10 - 'a'; }
    #####:  406:    return rVal;
        -:  407:}
        -:  408:// does not check if there is enough room before hand, truncated if buffer too small
    #####:  409:static void buf_add_hex(buf_impl* buf, const char *hex, size_t len)
        -:  410:{
        -:  411:    uint8_t val;
    #####:  412:    for (; len > 1; len -= 2) {
    #####:  413:        val = asc2byte(*hex++) << 4;
    #####:  414:        val |= asc2byte(*hex++);
    #####:  415:        buf_add1(buf, val);
        -:  416:    }
    #####:  417:}
        -:  418:
        -:  419:/********************************************************************
        -:  420:** Wrapping into lib
        -:  421:********************************************************************/
        -:  422:
    #####:  423:buf_impl * bytes_realloc(bvm *vm, buf_impl *oldbuf, int32_t size)
        -:  424:{
    #####:  425:    if (size < 4) { size = 4; }
    #####:  426:    if (size > BYTES_MAX_SIZE) { size = BYTES_MAX_SIZE; }
    #####:  427:    size_t oldsize = oldbuf ? oldbuf->size + BYTES_OVERHEAD : 0;
    #####:  428:    buf_impl * next = (buf_impl*) be_realloc(vm, oldbuf, oldsize, size + BYTES_OVERHEAD);  /* malloc */
    #####:  429:    next->size = size;
    #####:  430:    if (!oldbuf) {
    #####:  431:        next->len = 0; /* allocate a new buffer */
        -:  432:    }
    #####:  433:    return next;
        -:  434:}
        -:  435:
        -:  436:/* allocate a new `bytes` object with pre-allocated size */
    #####:  437:static void bytes_new_object(bvm *vm, size_t size)
        -:  438:{
    #####:  439:    be_getglobal(vm, "bytes"); /* eventually change with be_getbuiltin */
    #####:  440:    be_call(vm, 0); /* stack has only instance */
    #####:  441:    be_getmember(vm, -1, "init");
    #####:  442:    be_pushvalue(vm, -2);
    #####:  443:    be_pushint(vm, size); /* stack: instance, init func, instance, size */
    #####:  444:    be_call(vm, 2); /* stack: instance, ret, instance, size */
    #####:  445:    be_pop(vm, 3); /* remove ret, instance, size */
    #####:  446:}
        -:  447:
    #####:  448:static int m_init(bvm *vm)
        -:  449:{
    #####:  450:    int argc = be_top(vm);
    #####:  451:    int size = BYTES_DEFAULT_SIZE;
    #####:  452:    const char * hex_in = NULL;
    #####:  453:    if (argc > 1 && be_isint(vm, 2)) {
    #####:  454:        int new_size = be_toint(vm, 2) + BYTES_HEADROOM;
    #####:  455:        if (new_size > size) {
    #####:  456:            size = new_size;
        -:  457:        }
    #####:  458:    } else if (argc > 1 && be_isstring(vm, 2)) {
    #####:  459:        hex_in = be_tostring(vm, 2);
    #####:  460:        if (hex_in) {
    #####:  461:            size = strlen(hex_in) / 2 + BYTES_HEADROOM;        /* allocate headroom */
        -:  462:        }
        -:  463:    }
    #####:  464:    buf_impl * buf = bytes_realloc(vm, NULL, size); /* allocate new buffer */
    #####:  465:    if (!buf) {
    #####:  466:        be_throw(vm, BE_MALLOC_FAIL);
        -:  467:    }
        -:  468:    
    #####:  469:    if (hex_in) {
    #####:  470:        buf_add_hex(buf, hex_in, strlen(hex_in));
        -:  471:    } 
    #####:  472:    be_pushcomptr(vm, buf);
    #####:  473:    be_setmember(vm, 1, ".p");
    #####:  474:    be_return_nil(vm);
        -:  475:}
        -:  476:
        -:  477:/* deallocate buffer */
    #####:  478:static int m_deinit(bvm *vm) {
        -:  479:{
    #####:  480:    be_getmember(vm, 1, ".p");
    #####:  481:    buf_impl * buf = be_tocomptr(vm, -1);
    #####:  482:    be_pop(vm, 1);
    #####:  483:    if (buf != NULL) {
    #####:  484:        be_realloc(vm, buf, buf->size + BYTES_OVERHEAD, 0);
        -:  485:    }
    #####:  486:    be_pushcomptr(vm, NULL);  /* push NULL pointer instead, just in case */
    #####:  487:    be_setmember(vm, 1, ".p");
    #####:  488:    be_return_nil(vm);
        -:  489:}
        -:  490:}
        -:  491:
        -:  492:/* grow or shrink to the exact value */
        -:  493:/* stack item 1 must contain the instance */
    #####:  494:static buf_impl * _bytes_resize(bvm *vm, buf_impl * buf, size_t new_size) {
    #####:  495:    buf_impl *new_buf = bytes_realloc(vm, buf, new_size);
    #####:  496:    if (!new_buf) {
    #####:  497:        be_throw(vm, BE_MALLOC_FAIL);
        -:  498:    }
        -:  499:    /* replace the .p attribute since address may have changed */
    #####:  500:    be_pushcomptr(vm, new_buf);
    #####:  501:    be_setmember(vm, 1, ".p");
    #####:  502:    be_pop(vm, 1); /* remove comobj from stack */
        -:  503:    /* the old buffer will be garbage collected later */
    #####:  504:    return new_buf;
        -:  505:}
        -:  506:
        -:  507:/* grow if needed but don't shrink */
        -:  508:/* if grow, then add some headroom */
        -:  509:/* stack item 1 must contain the instance */
    #####:  510:static buf_impl * bytes_resize(bvm *vm, buf_impl * buf, size_t new_size) {
        -:  511:    /* when resized to smaller, we introduce a new heurstic */
        -:  512:    /* If the buffer is 64 bytes or smaller, don't shrink */
        -:  513:    /* Shrink buffer only if target size is smaller than half the original size */
    #####:  514:    if (buf->size >= new_size) {  /* enough room, consider if need to shrink */
    #####:  515:        if (buf->size <= 64) { return buf; }  /* don't shrink if below 64 bytes */
    #####:  516:        if (buf->size < new_size * 2) { return buf; }
        -:  517:    }
    #####:  518:    return _bytes_resize(vm, buf, new_size + BYTES_HEADROOM);
        -:  519:}
        -:  520:
    #####:  521:static buf_impl * bytes_check_data(bvm *vm, size_t add_size) {
    #####:  522:    be_getmember(vm, 1, ".p");
    #####:  523:    buf_impl * buf = be_tocomptr(vm, -1);
    #####:  524:    be_pop(vm, 1); /* remove member from stack */
        -:  525:    /* check if the `size` is big enough */
    #####:  526:    if (buf->len + add_size > buf->size) {
        -:  527:        /* it does not fit so we need to realocate the buffer */
    #####:  528:        buf = bytes_resize(vm, buf, buf->len + add_size);
        -:  529:    }
    #####:  530:    return buf;
        -:  531:}
        -:  532:
    #####:  533:static size_t tohex(char * out, size_t outsz, const uint8_t * in, size_t insz) {
        -:  534:  static const char * hex = "0123456789ABCDEF";
    #####:  535:  const uint8_t * pin = in;
    #####:  536:  char * pout = out;
    #####:  537:  for (; pin < in + insz; pout += 2, pin++) {
    #####:  538:    pout[0] = hex[((*pin)>>4) & 0xF];
    #####:  539:    pout[1] = hex[ (*pin)     & 0xF];
    #####:  540:    if (pout + 3 > out + outsz) { break; } /* check overflow */
        -:  541:  }
    #####:  542:  pout[0] = 0; /* terminating Nul char */
    #####:  543:  return pout - out;
        -:  544:}
        -:  545:
    #####:  546:static int m_tostring(bvm *vm)
        -:  547:{
    #####:  548:    int argc = be_top(vm);
    #####:  549:    size_t max_len = 32;  /* limit to 32 bytes by default */
    #####:  550:    int truncated = 0;
    #####:  551:    if (argc > 1 && be_isint(vm, 2)) {
    #####:  552:        max_len = be_toint(vm, 2);  /* you can specify the len as second argument, or 0 for unlimited */
        -:  553:    }
    #####:  554:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  555:    size_t len = buf->len;
    #####:  556:    if (max_len > 0 && len > max_len) {
    #####:  557:        len = max_len;  /* limit output size */
    #####:  558:        truncated = 1;
        -:  559:    }
    #####:  560:    size_t hex_len = len * 2 + 5 + 2 + 2 + 1 + truncated * 3;  /* reserve size for `bytes("")\0` - 9 chars */
        -:  561:
    #####:  562:    char * hex_out = be_pushbuffer(vm, hex_len);
    #####:  563:    size_t l = be_strlcpy(hex_out, "bytes('", hex_len);
    #####:  564:    l += tohex(&hex_out[l], hex_len - l, buf_get_buf(buf), len);
    #####:  565:    if (truncated) {
    #####:  566:        l += be_strlcpy(&hex_out[l], "...", hex_len - l);
        -:  567:    }
    #####:  568:    l += be_strlcpy(&hex_out[l], "')", hex_len - l);
        -:  569:
    #####:  570:    be_pushnstring(vm, hex_out, l); /* make escape string from buffer */
    #####:  571:    be_remove(vm, -2); /* remove buffer */
    #####:  572:    be_return(vm);
        -:  573:}
        -:  574:
        -:  575:/*
        -:  576: * Copy the buffer into a string without any changes
        -:  577: */
    #####:  578:static int m_asstring(bvm *vm)
        -:  579:{
    #####:  580:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  581:    be_pushnstring(vm, (const char*) buf_get_buf(buf), buf->len);
    #####:  582:    be_return(vm);
        -:  583:}
        -:  584:
    #####:  585:static int m_fromstring(bvm *vm)
        -:  586:{
    #####:  587:    int argc = be_top(vm);
    #####:  588:    if (argc >= 2 && be_isstring(vm, 2)) {
    #####:  589:        const char *s = be_tostring(vm, 2);
    #####:  590:        size_t len = be_strlen(vm, 2);
    #####:  591:        buf_impl * buf = bytes_check_data(vm, 0);
    #####:  592:        buf = bytes_resize(vm, buf, len); /* resize if needed */
    #####:  593:        if (len > buf->size) { len = buf->size; } /* avoid overflow */
    #####:  594:        memmove(buf_get_buf(buf), s, len);
    #####:  595:        buf->len = len;
    #####:  596:        be_pop(vm, 1); /* remove arg to leave instance */
    #####:  597:        be_return(vm);
        -:  598:    }
    #####:  599:    be_raise(vm, "type_error", "operand must be a string");
    #####:  600:    be_return_nil(vm);
        -:  601:}
        -:  602:
        -:  603:/*
        -:  604: * Add an int made of 1, 2 or 4 bytes, in little or big endian
        -:  605: * `add(value:int[, size:int = 1]) -> instance`
        -:  606: * 
        -:  607: * size: may be 1, 2, 4 (little endian), or -1, -2, -4 (big endian)
        -:  608: *       obvisouly -1 is idntical to 1
        -:  609: *       size==0 does nothing
        -:  610: */
    #####:  611:static int m_add(bvm *vm)
        -:  612:{
    #####:  613:    int argc = be_top(vm);
    #####:  614:    buf_impl * buf = bytes_check_data(vm, 4); /* we reserve 4 bytes anyways */
    #####:  615:    if (argc >= 2 && be_isint(vm, 2)) {
    #####:  616:        int32_t v = be_toint(vm, 2);
    #####:  617:        int vsize = 1;
    #####:  618:        if (argc >= 3 && be_isint(vm, 3)) {
    #####:  619:            vsize = be_toint(vm, 3);
        -:  620:        }
    #####:  621:        switch (vsize) {
    #####:  622:            case 0:                             break;
    #####:  623:            case -1:    /* fallback below */
    #####:  624:            case 1:     buf_add1(buf, v);       break;
    #####:  625:            case 2:     buf_add2_le(buf, v);    break;
    #####:  626:            case 4:     buf_add4_le(buf, v);    break;
    #####:  627:            case -2:    buf_add2_be(buf, v);    break;
    #####:  628:            case -4:    buf_add4_be(buf, v);    break;
    #####:  629:            default:    be_raise(vm, "type_error", "size must be -4, -2, -1, 0, 1, 2 or 4.");
        -:  630:        }
    #####:  631:        be_pop(vm, argc - 1);
    #####:  632:        be_return(vm);
        -:  633:    }
    #####:  634:    be_return_nil(vm);
        -:  635:}
        -:  636:
        -:  637:/*
        -:  638: * Get an int made of 1, 2 or 4 bytes, in little or big endian
        -:  639: * `get(index:int[, size:int = 1]) -> int`
        -:  640: * 
        -:  641: * size: may be 1, 2, 4 (little endian), or -1, -2, -4 (big endian)
        -:  642: *       obvisouly -1 is identical to 1
        -:  643: *       0 returns nil
        -:  644: */
    #####:  645:static int m_get(bvm *vm, bbool sign)
        -:  646:{
    #####:  647:    int argc = be_top(vm);
    #####:  648:    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */
    #####:  649:    if (argc >=2 && be_isint(vm, 2)) {
    #####:  650:        int32_t idx = be_toint(vm, 2);
    #####:  651:        int vsize = 1;
    #####:  652:        if (argc >= 3 && be_isint(vm, 3)) {
    #####:  653:            vsize = be_toint(vm, 3);
        -:  654:        }
    #####:  655:        int ret = 0;
    #####:  656:        switch (vsize) {
    #####:  657:            case 0:                                     break;
    #####:  658:            case -1:    /* fallback below */
    #####:  659:            case 1:     ret = buf_get1(buf, idx);
    #####:  660:                        if (sign) { ret = (int8_t)(uint8_t) ret; }
    #####:  661:                        break;
    #####:  662:            case 2:     ret = buf_get2_le(buf, idx);
    #####:  663:                        if (sign) { ret = (int16_t)(uint16_t) ret; }
    #####:  664:                        break;
    #####:  665:            case 4:     ret = buf_get4_le(buf, idx);    break;
    #####:  666:            case -2:    ret = buf_get2_be(buf, idx);
    #####:  667:                        if (sign) { ret = (int16_t)(uint16_t) ret; }
    #####:  668:                        break;
    #####:  669:            case -4:    ret = buf_get4_be(buf, idx);    break;
    #####:  670:            default:    be_raise(vm, "type_error", "size must be -4, -2, -1, 0, 1, 2 or 4.");
        -:  671:        }
    #####:  672:        be_pop(vm, argc - 1);
    #####:  673:        if (vsize != 0) {
    #####:  674:            be_pushint(vm, ret);
        -:  675:        } else {
    #####:  676:            be_pushnil(vm);
        -:  677:        }
    #####:  678:        be_return(vm);
        -:  679:    }
    #####:  680:    be_return_nil(vm);
        -:  681:}
        -:  682:
        -:  683:/* signed int */
    #####:  684:static int m_geti(bvm *vm)
        -:  685:{
    #####:  686:    return m_get(vm, 1);
        -:  687:}
        -:  688:
        -:  689:/* unsigned int */
    #####:  690:static int m_getu(bvm *vm)
        -:  691:{
    #####:  692:    return m_get(vm, 0);
        -:  693:}
        -:  694:
        -:  695:/*
        -:  696: * Set an int made of 1, 2 or 4 bytes, in little or big endian
        -:  697: * `set(index:int, value:int[, size:int = 1]) -> nil`
        -:  698: * 
        -:  699: * size: may be 1, 2, 4 (little endian), or -1, -2, -4 (big endian)
        -:  700: *       obvisouly -1 is identical to 1
        -:  701: *       0 returns nil
        -:  702: */
    #####:  703:static int m_set(bvm *vm)
        -:  704:{
    #####:  705:    int argc = be_top(vm);
    #####:  706:    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */
    #####:  707:    if (argc >=3 && be_isint(vm, 2) && be_isint(vm, 3)) {
    #####:  708:        int32_t idx = be_toint(vm, 2);
    #####:  709:        int32_t value = be_toint(vm, 3);
    #####:  710:        int vsize = 1;
    #####:  711:        if (argc >= 4 && be_isint(vm, 4)) {
    #####:  712:            vsize = be_toint(vm, 4);
        -:  713:        }
    #####:  714:        switch (vsize) {
    #####:  715:            case 0:                                     break;
    #####:  716:            case -1:    /* fallback below */
    #####:  717:            case 1:     buf_set1(buf, idx, value);      break;
    #####:  718:            case 2:     buf_set2_le(buf, idx, value);   break;
    #####:  719:            case 4:     buf_set4_le(buf, idx, value);   break;
    #####:  720:            case -2:    buf_set2_be(buf, idx, value);   break;
    #####:  721:            case -4:    buf_set4_be(buf, idx, value);   break;
    #####:  722:            default:    be_raise(vm, "type_error", "size must be -4, -2, -1, 0, 1, 2 or 4.");
        -:  723:        }
    #####:  724:        be_pop(vm, argc - 1);
    #####:  725:        be_return_nil(vm);
        -:  726:    }
    #####:  727:    be_return_nil(vm);
        -:  728:}
        -:  729:
    #####:  730:static int m_setitem(bvm *vm)
        -:  731:{
    #####:  732:    int argc = be_top(vm);
    #####:  733:    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */
    #####:  734:    if (argc >=3 && be_isint(vm, 2) && be_isint(vm, 3)) {
    #####:  735:        int index = be_toint(vm, 2);
    #####:  736:        int val = be_toint(vm, 3);
    #####:  737:        if (index >= 0 && index < buf->len) {
    #####:  738:            buf_set1(buf, index, val);
    #####:  739:            be_return_nil(vm);
        -:  740:        }
        -:  741:    }
    #####:  742:    be_raise(vm, "index_error", "bytes index out of range or value non int");
    #####:  743:    be_return_nil(vm);
        -:  744:}
        -:  745:
    #####:  746:static int m_item(bvm *vm)
        -:  747:{
    #####:  748:    int argc = be_top(vm);
    #####:  749:    buf_impl * buf = bytes_check_data(vm, 0); /* we reserve 4 bytes anyways */
    #####:  750:    if (argc >=2 && be_isint(vm, 2)) {
    #####:  751:        int index = be_toint(vm,2);
    #####:  752:        if (index >= 0 && index < buf->len) {
    #####:  753:            be_pushint(vm, buf_get1(buf, index));
    #####:  754:            be_return(vm);
        -:  755:        }
        -:  756:    }
    #####:  757:    if (argc >= 2 && be_isinstance(vm, 2)) {
    #####:  758:        const char *cname = be_classname(vm, 2);
    #####:  759:        if (!strcmp(cname, "range")) {
        -:  760:            bint lower, upper;
    #####:  761:            bint size = buf->len;
        -:  762:            /* get index range */
    #####:  763:            be_getmember(vm, 2, "__lower__");
    #####:  764:            lower = be_toint(vm, -1);
    #####:  765:            be_pop(vm, 1);
    #####:  766:            be_getmember(vm, 2, "__upper__");
    #####:  767:            upper = be_toint(vm, -1);
    #####:  768:            be_pop(vm, 1);
        -:  769:            /* protection scope */
    #####:  770:            upper = upper < size ? upper : size - 1;
    #####:  771:            lower = lower < 0 ? 0 : lower;
        -:  772:            /* construction result list instance */
    #####:  773:            bytes_new_object(vm, upper > lower ? upper-lower : 0);
    #####:  774:            be_getmember(vm, -1, ".p");
    #####:  775:            buf_impl * buf2 = be_tocomptr(vm, -1);
    #####:  776:            be_pop(vm, 1);  /* remove .p and leave bytes instance */
    #####:  777:            for (; lower <= upper; ++lower) {
    #####:  778:                buf_add1(buf2, buf->buf[lower]);
        -:  779:            }
    #####:  780:            be_return(vm);    
        -:  781:        }
        -:  782:    }
    #####:  783:    be_raise(vm, "index_error", "bytes index out of range");
    #####:  784:    be_return_nil(vm);
        -:  785:}
        -:  786:
    #####:  787:static int m_size(bvm *vm)
        -:  788:{
    #####:  789:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  790:    be_pushint(vm, buf->len);
    #####:  791:    be_return(vm);
        -:  792:}
        -:  793:
    #####:  794:static int m_resize(bvm *vm)
        -:  795:{
    #####:  796:    int argc = be_top(vm);
    #####:  797:    be_getmember(vm, 1, ".p");
    #####:  798:    buf_impl * buf = be_tocomptr(vm, -1);
    #####:  799:    be_pop(vm, 1);
        -:  800:
    #####:  801:    if (argc <= 1 || !be_isint(vm, 2)) {
    #####:  802:        be_raise(vm, "type_error", "size must be of type 'int'");
        -:  803:    }
    #####:  804:    int new_len = be_toint(vm, 2);
    #####:  805:    if (new_len < 0) {
    #####:  806:        new_len = 0;
        -:  807:    }
        -:  808:
    #####:  809:    buf = bytes_resize(vm, buf, new_len);
    #####:  810:    buf_set_len(buf, new_len);
    #####:  811:    be_pop(vm, 1);
    #####:  812:    be_return(vm);
        -:  813:}
        -:  814:
    #####:  815:static int m_clear(bvm *vm)
        -:  816:{
    #####:  817:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  818:    buf->len = 0;
    #####:  819:    be_return_nil(vm);
        -:  820:}
        -:  821:
    #####:  822:static int m_merge(bvm *vm)
        -:  823:{
    #####:  824:    int argc = be_top(vm);
    #####:  825:    buf_impl * buf1 = bytes_check_data(vm, 0); /* no resize yet */
    #####:  826:    if (argc >= 2 && be_isinstance(vm, 2)) {
    #####:  827:        be_getglobal(vm, "bytes"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */
    #####:  828:        if (be_isderived(vm, 2)) {
    #####:  829:            be_getmember(vm, 2, ".p");
    #####:  830:            buf_impl * buf2 = be_tocomptr(vm, -1);
    #####:  831:            be_pop(vm, 4); /* remove class, member, and 2 operands */
        -:  832:
        -:  833:            /* allocate new object */
    #####:  834:            bytes_new_object(vm, buf1->len + buf2->len);
    #####:  835:            be_getmember(vm, -1, ".p");
        -:  836:            /* .p is on top of stack, then instance */
    #####:  837:            buf_impl * buf3 = be_tocomptr(vm, -1);
    #####:  838:            be_pop(vm, 1);
    #####:  839:            buf_add_buf(buf3, buf1);
    #####:  840:            buf_add_buf(buf3, buf2);
        -:  841:
    #####:  842:            be_return(vm); /* return self */
        -:  843:        }
        -:  844:    }
    #####:  845:    be_raise(vm, "type_error", "operand must be bytes");
    #####:  846:    be_return_nil(vm); /* return self */
        -:  847:}
        -:  848:
    #####:  849:static int m_copy(bvm *vm)
        -:  850:{
    #####:  851:    buf_impl * buf1 = bytes_check_data(vm, 0); /* no resize */
    #####:  852:    bytes_new_object(vm, buf1->len);
    #####:  853:    be_getmember(vm, -1, ".p");
    #####:  854:    buf_impl * buf2 = be_tocomptr(vm, -1);
    #####:  855:    be_pop(vm, 1);
    #####:  856:    buf_add_buf(buf2, buf1);
    #####:  857:    be_return(vm); /* return self */
        -:  858:}
        -:  859:
        -:  860:/* accept bytes or int as operand */
    #####:  861:static int m_connect(bvm *vm)
        -:  862:{
    #####:  863:    int argc = be_top(vm);
    #####:  864:    buf_impl * buf1 = bytes_check_data(vm, 0); /* don't resize yet */
    #####:  865:    if (argc >= 2 && (be_isinstance(vm, 2) || be_isint(vm, 2))) {
    #####:  866:        if (be_isint(vm, 2)) {
    #####:  867:            buf1 = bytes_resize(vm, buf1, buf1->len + 1); /* resize */
    #####:  868:            buf_add1(buf1, be_toint(vm, 2));
    #####:  869:            be_pop(vm, 1);  /* remove operand */
    #####:  870:            be_return(vm); /* return self */
        -:  871:        } else {
    #####:  872:            be_getglobal(vm, "bytes"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */
    #####:  873:            if (be_isderived(vm, 2)) {
    #####:  874:                be_getmember(vm, 2, ".p");
    #####:  875:                buf_impl * buf2 = be_tocomptr(vm, -1);
    #####:  876:                buf1 = bytes_resize(vm, buf1, buf1->len + buf2->len); /* resize buf1 for total size */
    #####:  877:                buf_add_buf(buf1, buf2);
    #####:  878:                be_pop(vm, 3); /* remove class, member, and last operand */
    #####:  879:                be_return(vm); /* return self */
        -:  880:            }
        -:  881:        }
        -:  882:    }
    #####:  883:    be_raise(vm, "type_error", "operand must be bytes or int");
    #####:  884:    be_return_nil(vm); /* return self */
        -:  885:}
        -:  886:
    #####:  887:static int bytes_equal(bvm *vm, bbool iseq)
        -:  888:{
    #####:  889:    be_getmember(vm, 1, ".p");
    #####:  890:    buf_impl * buf1 = be_tocomptr(vm, -1);
    #####:  891:    be_pop(vm, 1);
        -:  892:
    #####:  893:    be_getmember(vm, 2, ".p");
    #####:  894:    buf_impl * buf2 = be_tocomptr(vm, -1);
    #####:  895:    be_pop(vm, 1);
        -:  896:
        -:  897:    bbool ret;
    #####:  898:    if (buf_equals(buf1, buf2)) {
    #####:  899:        ret = iseq;
        -:  900:    } else {
    #####:  901:        ret = !iseq;
        -:  902:    }
    #####:  903:    be_pushbool(vm, ret);
    #####:  904:    be_return(vm);
        -:  905:}
        -:  906:
    #####:  907:static int m_equal(bvm *vm)
        -:  908:{
    #####:  909:    return bytes_equal(vm, btrue);
        -:  910:}
        -:  911:
    #####:  912:static int m_nequal(bvm *vm)
        -:  913:{
    #####:  914:    return bytes_equal(vm, bfalse);
        -:  915:}
        -:  916:
        -:  917:/*
        -:  918: * Converts bytes() to a base64 string
        -:  919: * 
        -:  920: * Note: there are no line breaks inserted
        -:  921: * 
        -:  922: * `b.tob64() -> string`
        -:  923: */
    #####:  924:static int m_tob64(bvm *vm)
        -:  925:{
    #####:  926:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  927:    size_t len = buf->len;
    #####:  928:    size_t b64_len = encode_base64_length(len) + 1;  /* size of base64 encoded string for this binary length, add NULL terminator */
        -:  929:
    #####:  930:    char * b64_out = be_pushbuffer(vm, b64_len);
    #####:  931:    size_t converted = encode_base64(buf_get_buf(buf), len, (unsigned char*)b64_out);
        -:  932:
    #####:  933:    be_pushnstring(vm, b64_out, converted); /* make string from buffer */
    #####:  934:    be_remove(vm, -2); /* remove buffer */
    #####:  935:    be_return(vm);
        -:  936:}
        -:  937:
        -:  938:/*
        -:  939: * Converts base63 to bytes()
        -:  940: * 
        -:  941: * `bytes().fromb64() -> bytes()`
        -:  942: */
    #####:  943:static int m_fromb64(bvm *vm)
        -:  944:{
    #####:  945:    int argc = be_top(vm);
    #####:  946:    if (argc >= 2 && be_isstring(vm, 2)) {
    #####:  947:        const char *s = be_tostring(vm, 2);
    #####:  948:        size_t bin_len = decode_base64_length((unsigned char*)s);   /* do a first pass to calculate the buffer size */
        -:  949:
    #####:  950:        buf_impl * buf = bytes_check_data(vm, 0);
    #####:  951:        buf = bytes_resize(vm, buf, bin_len); /* resize if needed */
    #####:  952:        if (bin_len > buf->size) { /* avoid overflow */
    #####:  953:            be_raise(vm, "memory_error", "cannot allocate buffer");
        -:  954:        }
        -:  955:
    #####:  956:        size_t bin_len_final = decode_base64((unsigned char*)s, buf_get_buf(buf));  /* decode */
    #####:  957:        buf->len = bin_len_final;
    #####:  958:        be_pop(vm, 1); /* remove arg to leave instance */
    #####:  959:        be_return(vm);
        -:  960:    }
    #####:  961:    be_raise(vm, "type_error", "operand must be a string");
    #####:  962:    be_return_nil(vm);
        -:  963:}
        -:  964:
        -:  965:
        -:  966:/*
        -:  967: * Advanced API
        -:  968: */
        -:  969:
        -:  970:/*
        -:  971: * Retrieve the memory address of the raw buffer
        -:  972: * to be used in C functions.
        -:  973: * 
        -:  974: * Note: the address is guaranteed not to move unless you
        -:  975: * resize the buffer
        -:  976: * 
        -:  977: * `_buffer() -> comptr`
        -:  978: */
    #####:  979:static int m_buffer(bvm *vm)
        -:  980:{
    #####:  981:    buf_impl * buf = bytes_check_data(vm, 0);
    #####:  982:    be_pushcomptr(vm, &buf->buf);
    #####:  983:    be_return(vm);
        -:  984:}
        -:  985:
        -:  986:/*
        -:  987: * External API
        -:  988: */
    #####:  989:BERRY_API void be_pushbytes(bvm *vm, const void * bytes, size_t len)
        -:  990:{
    #####:  991:    bytes_new_object(vm, len);
    #####:  992:    be_getmember(vm, -1, ".p");
    #####:  993:    buf_impl * buf = be_tocomptr(vm, -1);
    #####:  994:    be_pop(vm, 1); /* remove .p1 and leave instance */
    #####:  995:    if (len > buf->size) { len = buf->size; } /* double check if the buffer allocated was smaller */
    #####:  996:    memmove((void*)buf_get_buf(buf), bytes, len);
    #####:  997:    buf->len = len;
        -:  998:    /* bytes instance is on top of stack */
    #####:  999:}
        -: 1000:
    #####: 1001:BERRY_API const void *be_tobytes(bvm *vm, int rel_index, size_t *len)
        -: 1002:{
    #####: 1003:    int index = be_absindex(vm, rel_index);
    #####: 1004:    if (be_isinstance(vm, index)) {
    #####: 1005:        be_getglobal(vm, "bytes"); /* get the bytes class */ /* TODO eventually replace with be_getbuiltin */
    #####: 1006:        if (be_isderived(vm, index)) {
    #####: 1007:            be_getmember(vm, index, ".p");
    #####: 1008:            buf_impl * buf = be_tocomptr(vm, -1);
    #####: 1009:            be_pop(vm, 2); /* class and .p */
    #####: 1010:            if (len) { *len = buf->len; }
    #####: 1011:            return (void*) buf_get_buf(buf);
        -: 1012:        } else {
    #####: 1013:            be_pop(vm, 1);  /* remove class */
        -: 1014:        }
        -: 1015:    }
    #####: 1016:    if (len) { *len = 0; }
    #####: 1017:    return NULL;
        -: 1018:}
        -: 1019:
    #####: 1020:BERRY_API bbool be_isbytes(bvm *vm, int rel_index)
        -: 1021:{
    #####: 1022:    bbool ret = bfalse;
    #####: 1023:    int index = be_absindex(vm, rel_index);
    #####: 1024:    if (be_isinstance(vm, index)) {
    #####: 1025:        be_getbuiltin(vm, "bytes");
    #####: 1026:        if (be_isderived(vm, index)) {
    #####: 1027:            ret = btrue;
        -: 1028:        }
    #####: 1029:        be_pop(vm, 1);
        -: 1030:    }
    #####: 1031:    return ret;
        -: 1032:}
        -: 1033:
        -: 1034:/* Helper code to compile bytecode
        -: 1035:
        -: 1036:
        -: 1037:class Bytes : bytes
        -: 1038:#-------------------------------------------------------------
        -: 1039:#- 'getbits' function
        -: 1040:#-
        -: 1041:#- Reads a bit-field in a `bytes()` object
        -: 1042:#-
        -: 1043:#- Input:
        -: 1044:#-   offset_bits  (int): bit number to start reading from (0 = LSB)
        -: 1045:#-   len_bits     (int): how many bits to read
        -: 1046:#- Output:
        -: 1047:#-   valuer (int)
        -: 1048:#-------------------------------------------------------------#
        -: 1049:  def getbits(offset_bits, len_bits)
        -: 1050:    if len_bits <= 0 || len_bits > 32 raise "value_error", "length in bits must be between 0 and 32" end
        -: 1051:    var ret = 0
        -: 1052:  
        -: 1053:    var offset_bytes = offset_bits >> 3
        -: 1054:    offset_bits = offset_bits % 8
        -: 1055:
        -: 1056:    var bit_shift = 0                   #- bit number to write to -#
        -: 1057:  
        -: 1058:    while (len_bits > 0)
        -: 1059:      var block_bits = 8 - offset_bits    # how many bits to read in the current block (block = byte) -#
        -: 1060:      if block_bits > len_bits  block_bits = len_bits end
        -: 1061:  
        -: 1062:      var mask = ( (1<<block_bits) - 1) << offset_bits
        -: 1063:      ret = ret | ( ((self[offset_bytes] & mask) >> offset_bits) << bit_shift)
        -: 1064:  
        -: 1065:      #- move the input window -#
        -: 1066:      bit_shift += block_bits
        -: 1067:      len_bits -= block_bits
        -: 1068:      offset_bits = 0                   #- start at full next byte -#
        -: 1069:      offset_bytes += 1
        -: 1070:    end
        -: 1071:  
        -: 1072:    return ret
        -: 1073:  end
        -: 1074:  
        -: 1075:  #-------------------------------------------------------------
        -: 1076:  #- 'setbits' function
        -: 1077:  #-
        -: 1078:  #- Writes a bit-field in a `bytes()` object
        -: 1079:  #-
        -: 1080:  #- Input:
        -: 1081:  #-   offset_bits  (int): bit number to start writing to (0 = LSB)
        -: 1082:  #-   len_bits     (int): how many bits to write
        -: 1083:  #-   val          (int): value to set
        -: 1084:  #-------------------------------------------------------------#
        -: 1085:  def setbits(offset_bits, len_bits, val)
        -: 1086:    if len_bits < 0 || len_bits > 32 raise "value_error", "length in bits must be between 0 and 32" end
        -: 1087:
        -: 1088:    var offset_bytes = offset_bits >> 3
        -: 1089:    offset_bits = offset_bits % 8
        -: 1090:  
        -: 1091:    while (len_bits > 0)
        -: 1092:      var block_bits = 8 - offset_bits    #- how many bits to write in the current block (block = byte) -#
        -: 1093:      if block_bits > len_bits  block_bits = len_bits end
        -: 1094:  
        -: 1095:      var mask_val = (1<<block_bits) - 1  #- mask to the n bits to get for this block -#
        -: 1096:      var mask_b_inv = 0xFF - (mask_val << offset_bits)
        -: 1097:      self[offset_bytes] = (self[offset_bytes] & mask_b_inv) | ((val & mask_val) << offset_bits)
        -: 1098:  
        -: 1099:      #- move the input window -#
        -: 1100:      val >>= block_bits
        -: 1101:      len_bits -= block_bits
        -: 1102:      offset_bits = 0                   #- start at full next byte -#
        -: 1103:      offset_bytes += 1
        -: 1104:    end
        -: 1105:    return self
        -: 1106:  end
        -: 1107:end
        -: 1108:
        -: 1109:*/
        -: 1110:
        -: 1111:/********************************************************************
        -: 1112:** Solidified function: getbits
        -: 1113:********************************************************************/
        -: 1114:be_local_closure(getbits,   /* name */
        -: 1115:  be_nested_proto(
        -: 1116:    9,                          /* nstack */
        -: 1117:    3,                          /* argc */
        -: 1118:    0,                          /* varg */
        -: 1119:    0,                          /* has upvals */
        -: 1120:    NULL,                       /* no upvals */
        -: 1121:    0,                          /* has sup protos */
        -: 1122:    NULL,                       /* no sub protos */
        -: 1123:    1,                          /* has constants */
        -: 1124:    ( &(const bvalue[ 5]) {     /* constants */
        -: 1125:      { { .i=0 }, BE_INT},
        -: 1126:      { { .s=be_nested_const_str("value_error", 773297791, 11) }, BE_STRING},
        -: 1127:      { { .s=be_nested_const_str("length in bits must be between 0 and 32", -1710458168, 39) }, BE_STRING},
        -: 1128:      { { .i=3 }, BE_INT},
        -: 1129:      { { .i=1 }, BE_INT},
        -: 1130:    }),
        -: 1131:    (be_nested_const_str("getbits", -1200798317, 7)),
        -: 1132:    (be_nested_const_str("stdin", -1529146723, 5)),
        -: 1133:    ( &(const binstruction[32]) {  /* code */
        -: 1134:      0x180C0500,  //  0000  LE R3  R2  R256
        -: 1135:      0x740E0002,  //  0001  JMPT R3  #0005
        -: 1136:      0x540E001F,  //  0002  LDINT  R3  32
        -: 1137:      0x240C0403,  //  0003  GT R3  R2  R3
        -: 1138:      0x780E0000,  //  0004  JMPF R3  #0006
        -: 1139:      0xB0060302,  //  0005  RAISE  1 R257  R258
        -: 1140:      0x580C0000,  //  0006  LDCONST  R3  K0
        -: 1141:      0x3C100303,  //  0007  SHR  R4  R1  R259
        -: 1142:      0x54160007,  //  0008  LDINT  R5  8
        -: 1143:      0x10040205,  //  0009  MOD  R1  R1  R5
        -: 1144:      0x58140000,  //  000A  LDCONST  R5  K0
        -: 1145:      0x24180500,  //  000B  GT R6  R2  R256
        -: 1146:      0x781A0011,  //  000C  JMPF R6  #001F
        -: 1147:      0x541A0007,  //  000D  LDINT  R6  8
        -: 1148:      0x04180C01,  //  000E  SUB  R6  R6  R1
        -: 1149:      0x241C0C02,  //  000F  GT R7  R6  R2
        -: 1150:      0x781E0000,  //  0010  JMPF R7  #0012
        -: 1151:      0x5C180400,  //  0011  MOVE R6  R2
        -: 1152:      0x381E0806,  //  0012  SHL  R7  R260  R6
        -: 1153:      0x041C0F04,  //  0013  SUB  R7  R7  R260
        -: 1154:      0x381C0E01,  //  0014  SHL  R7  R7  R1
        -: 1155:      0x94200004,  //  0015  GETIDX R8  R0  R4
        -: 1156:      0x2C201007,  //  0016  AND  R8  R8  R7
        -: 1157:      0x3C201001,  //  0017  SHR  R8  R8  R1
        -: 1158:      0x38201005,  //  0018  SHL  R8  R8  R5
        -: 1159:      0x300C0608,  //  0019  OR R3  R3  R8
        -: 1160:      0x00140A06,  //  001A  ADD  R5  R5  R6
        -: 1161:      0x04080406,  //  001B  SUB  R2  R2  R6
        -: 1162:      0x58040000,  //  001C  LDCONST  R1  K0
        -: 1163:      0x00100904,  //  001D  ADD  R4  R4  R260
        -: 1164:      0x7001FFEB,  //  001E  JMP    #000B
        -: 1165:      0x80040600,  //  001F  RET  1 R3
        -: 1166:    })
        -: 1167:  )
        -: 1168:);
        -: 1169:/*******************************************************************/
        -: 1170:
        -: 1171:/********************************************************************
        -: 1172:** Solidified function: setbits
        -: 1173:********************************************************************/
        -: 1174:be_local_closure(setbits,   /* name */
        -: 1175:  be_nested_proto(
        -: 1176:    10,                          /* nstack */
        -: 1177:    4,                          /* argc */
        -: 1178:    0,                          /* varg */
        -: 1179:    0,                          /* has upvals */
        -: 1180:    NULL,                       /* no upvals */
        -: 1181:    0,                          /* has sup protos */
        -: 1182:    NULL,                       /* no sub protos */
        -: 1183:    1,                          /* has constants */
        -: 1184:    ( &(const bvalue[ 5]) {     /* constants */
        -: 1185:      { { .i=0 }, BE_INT},
        -: 1186:      { { .s=be_nested_const_str("value_error", 773297791, 11) }, BE_STRING},
        -: 1187:      { { .s=be_nested_const_str("length in bits must be between 0 and 32", -1710458168, 39) }, BE_STRING},
        -: 1188:      { { .i=3 }, BE_INT},
        -: 1189:      { { .i=1 }, BE_INT},
        -: 1190:    }),
        -: 1191:    (be_nested_const_str("setbits", -1532559129, 7)),
        -: 1192:    (be_nested_const_str("stdin", -1529146723, 5)),
        -: 1193:    ( &(const binstruction[33]) {  /* code */
        -: 1194:      0x14100500,  //  0000  LT R4  R2  R256
        -: 1195:      0x74120002,  //  0001  JMPT R4  #0005
        -: 1196:      0x5412001F,  //  0002  LDINT  R4  32
        -: 1197:      0x24100404,  //  0003  GT R4  R2  R4
        -: 1198:      0x78120000,  //  0004  JMPF R4  #0006
        -: 1199:      0xB0060302,  //  0005  RAISE  1 R257  R258
        -: 1200:      0x3C100303,  //  0006  SHR  R4  R1  R259
        -: 1201:      0x54160007,  //  0007  LDINT  R5  8
        -: 1202:      0x10040205,  //  0008  MOD  R1  R1  R5
        -: 1203:      0x24140500,  //  0009  GT R5  R2  R256
        -: 1204:      0x78160014,  //  000A  JMPF R5  #0020
        -: 1205:      0x54160007,  //  000B  LDINT  R5  8
        -: 1206:      0x04140A01,  //  000C  SUB  R5  R5  R1
        -: 1207:      0x24180A02,  //  000D  GT R6  R5  R2
        -: 1208:      0x781A0000,  //  000E  JMPF R6  #0010
        -: 1209:      0x5C140400,  //  000F  MOVE R5  R2
        -: 1210:      0x381A0805,  //  0010  SHL  R6  R260  R5
        -: 1211:      0x04180D04,  //  0011  SUB  R6  R6  R260
        -: 1212:      0x541E00FE,  //  0012  LDINT  R7  255
        -: 1213:      0x38200C01,  //  0013  SHL  R8  R6  R1
        -: 1214:      0x041C0E08,  //  0014  SUB  R7  R7  R8
        -: 1215:      0x94200004,  //  0015  GETIDX R8  R0  R4
        -: 1216:      0x2C201007,  //  0016  AND  R8  R8  R7
        -: 1217:      0x2C240606,  //  0017  AND  R9  R3  R6
        -: 1218:      0x38241201,  //  0018  SHL  R9  R9  R1
        -: 1219:      0x30201009,  //  0019  OR R8  R8  R9
        -: 1220:      0x98000808,  //  001A  SETIDX R0  R4  R8
        -: 1221:      0x3C0C0605,  //  001B  SHR  R3  R3  R5
        -: 1222:      0x04080405,  //  001C  SUB  R2  R2  R5
        -: 1223:      0x58040000,  //  001D  LDCONST  R1  K0
        -: 1224:      0x00100904,  //  001E  ADD  R4  R4  R260
        -: 1225:      0x7001FFE8,  //  001F  JMP    #0009
        -: 1226:      0x80040000,  //  0020  RET  1 R0
        -: 1227:    })
        -: 1228:  )
        -: 1229:);
        -: 1230:/*******************************************************************/
        -: 1231:
        -: 1232:#if !BE_USE_PRECOMPILED_OBJECT
        -: 1233:void be_load_byteslib(bvm *vm)
        -: 1234:{
        -: 1235:    static const bnfuncinfo members[] = {
        -: 1236:        { ".p", NULL },
        -: 1237:        { "_buffer", m_buffer },
        -: 1238:        { "init", m_init },
        -: 1239:        { "deinit", m_deinit },
        -: 1240:        { "tostring", m_tostring },
        -: 1241:        { "asstring", m_asstring },
        -: 1242:        { "fromstring", m_fromstring },
        -: 1243:        { "tob64", m_tob64 },
        -: 1244:        { "fromb64", m_fromb64 },
        -: 1245:        { "add", m_add },
        -: 1246:        { "get", m_getu },
        -: 1247:        { "geti", m_geti },
        -: 1248:        { "set", m_set },
        -: 1249:        { "seti", m_set },      // setters for signed and unsigned are identical
        -: 1250:        { "item", m_item },
        -: 1251:        { "setitem", m_setitem },
        -: 1252:        { "size", m_size },
        -: 1253:        { "resize", m_resize },
        -: 1254:        { "clear", m_clear },
        -: 1255:        { "copy", m_copy },
        -: 1256:        { "+", m_merge },
        -: 1257:        { "..", m_connect },
        -: 1258:        { "==", m_equal },
        -: 1259:        { "!=", m_nequal },
        -: 1260:
        -: 1261:        { NULL, (bntvfunc) BE_CLOSURE }, /* mark section for berry closures */
        -: 1262:        { "getbits", (bntvfunc) &getbits_closure },
        -: 1263:        { "setbits", (bntvfunc) &setbits_closure },
        -: 1264:
        -: 1265:        { NULL, NULL }
        -: 1266:    };
        -: 1267:    be_regclass(vm, "bytes", members);
        -: 1268:}
        -: 1269:#else
        -: 1270:/* @const_object_info_begin
        -: 1271:class be_class_bytes (scope: global, name: bytes) {
        -: 1272:    .p, var
        -: 1273:    _buffer, func(m_buffer)
        -: 1274:    init, func(m_init)
        -: 1275:    deinit, func(m_deinit)
        -: 1276:    tostring, func(m_tostring)
        -: 1277:    asstring, func(m_asstring)
        -: 1278:    fromstring, func(m_fromstring)
        -: 1279:    tob64, func(m_tob64)
        -: 1280:    fromb64, func(m_fromb64)
        -: 1281:    add, func(m_add)
        -: 1282:    get, func(m_getu)
        -: 1283:    geti, func(m_geti)
        -: 1284:    set, func(m_set)
        -: 1285:    seti, func(m_set)
        -: 1286:    item, func(m_item)
        -: 1287:    setitem, func(m_setitem)
        -: 1288:    size, func(m_size)
        -: 1289:    resize, func(m_resize)
        -: 1290:    clear, func(m_clear)
        -: 1291:    copy, func(m_copy)
        -: 1292:    +, func(m_merge)
        -: 1293:    .., func(m_connect)
        -: 1294:    ==, func(m_equal)
        -: 1295:    !=, func(m_nequal)
        -: 1296:
        -: 1297:    getbits, closure(getbits_closure)
        -: 1298:    setbits, closure(setbits_closure)
        -: 1299:}
        -: 1300:@const_object_info_end */
        -: 1301:#include "../generate/be_fixed_be_class_bytes.h"
        -: 1302:#endif
