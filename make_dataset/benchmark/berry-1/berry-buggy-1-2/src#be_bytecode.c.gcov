        -:    0:Source:src/be_bytecode.c
        -:    0:Graph:./src/be_bytecode.gcno
        -:    0:Data:./src/be_bytecode.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_bytecode.h"
        -:    9:#include "be_decoder.h"
        -:   10:#include "be_vector.h"
        -:   11:#include "be_string.h"
        -:   12:#include "be_class.h"
        -:   13:#include "be_func.h"
        -:   14:#include "be_exec.h"
        -:   15:#include "be_list.h"
        -:   16:#include "be_map.h"
        -:   17:#include "be_mem.h"
        -:   18:#include "be_sys.h"
        -:   19:#include "be_var.h"
        -:   20:#include "be_vm.h"
        -:   21:#include <string.h>
        -:   22:
        -:   23:#define MAGIC_NUMBER1       0xBE
        -:   24:#define MAGIC_NUMBER2       0xCD
        -:   25:#define MAGIC_NUMBER3       0xFE
        -:   26:#define BYTECODE_VERSION    2
        -:   27:
        -:   28:#define USE_64BIT_INT       (BE_INTGER_TYPE == 2 \
        -:   29:    || BE_INTGER_TYPE == 1 && LONG_MAX == 9223372036854775807L)
        -:   30:
        -:   31:#if !BE_USE_SCRIPT_COMPILER && BE_USE_BYTECODE_SAVER
        -:   32:#error bytecode generation dependent compiler (require BE_USE_SCRIPT_COMPILER != 0)
        -:   33:#endif
        -:   34:
        -:   35:#if BE_USE_BYTECODE_SAVER || BE_USE_BYTECODE_LOADER
    #####:   36:static void bytecode_error(bvm *vm, const char *msg)
        -:   37:{
    #####:   38:    be_raise(vm, "io_error", msg);
    #####:   39:}
        -:   40:
    #####:   41:static uint8_t vm_sizeinfo(void)
        -:   42:{
    #####:   43:    uint8_t res = sizeof(bint) == 8;
    #####:   44:    res |= (sizeof(breal) == 8) << 1;
    #####:   45:    return res;
        -:   46:}
        -:   47:#endif
        -:   48:
        -:   49:#if BE_USE_BYTECODE_SAVER
        -:   50:static void save_proto(bvm *vm, void *fp, bproto *proto);
        -:   51:
    #####:   52:static void save_byte(void *fp, uint8_t value)
        -:   53:{
    #####:   54:    be_fwrite(fp, &value, 1);
    #####:   55:}
        -:   56:
    #####:   57:static void save_word(void *fp, uint16_t value)
        -:   58:{
        -:   59:    uint8_t buffer[2];
    #####:   60:    buffer[0] = value & 0xff;
    #####:   61:    buffer[1] = value >> 8;
    #####:   62:    be_fwrite(fp, buffer, sizeof(buffer));
    #####:   63:}
        -:   64:
    #####:   65:static void save_long(void *fp, uint32_t value)
        -:   66:{
        -:   67:    uint8_t buffer[4];
    #####:   68:    buffer[0] = value & 0xff;
    #####:   69:    buffer[1] = (value >> 8) & 0xff;
    #####:   70:    buffer[2] = (value >> 16) & 0xff;
    #####:   71:    buffer[3] = (value >> 24) & 0xff;
    #####:   72:    be_fwrite(fp, buffer, sizeof(buffer));
    #####:   73:}
        -:   74:
    #####:   75:static void save_header(void *fp)
        -:   76:{
    #####:   77:    uint8_t buffer[8] = { 0 };
    #####:   78:    buffer[0] = MAGIC_NUMBER1;
    #####:   79:    buffer[1] = MAGIC_NUMBER2;
    #####:   80:    buffer[2] = MAGIC_NUMBER3;
    #####:   81:    buffer[3] = BYTECODE_VERSION;
    #####:   82:    buffer[4] = vm_sizeinfo();
    #####:   83:    be_fwrite(fp, buffer, sizeof(buffer));
    #####:   84:}
        -:   85:
    #####:   86:static void save_int(void *fp, bint i)
        -:   87:{
        -:   88:#if USE_64BIT_INT
    #####:   89:    save_long(fp, i & 0xffffffff);
    #####:   90:    save_long(fp, (i >> 32) & 0xffffffff);
        -:   91:#else
        -:   92:    save_long(fp, (uint32_t)i);
        -:   93:#endif
    #####:   94:}
        -:   95:
    #####:   96:static void save_real(void *fp, breal r)
        -:   97:{
        -:   98:#if BE_USE_SINGLE_FLOAT
        -:   99:    union { breal r; uint32_t i; } u;
        -:  100:    u.r = r;
        -:  101:    save_long(fp, u.i);
        -:  102:#else
        -:  103:    union { breal r; uint64_t i; } u;
    #####:  104:    u.r = r;
    #####:  105:    save_long(fp, u.i & 0xffffffff);
    #####:  106:    save_long(fp, (u.i >> 32) & 0xffffffff);
        -:  107:#endif
    #####:  108:}
        -:  109:
    #####:  110:static void save_string(void *fp, bstring *s)
        -:  111:{
    #####:  112:    if (s) {
    #####:  113:        uint16_t length = (uint16_t)str_len(s);
    #####:  114:        const char *data = str(s);
    #####:  115:        save_word(fp, length);
    #####:  116:        be_fwrite(fp, data, length);
        -:  117:    }
    #####:  118:}
        -:  119:
    #####:  120:static bstring** save_members(bvm *vm, void *fp, bclass *c, int nvar)
        -:  121:{
        -:  122:    bmapnode *node;
    #####:  123:    bstring **vars = NULL;
    #####:  124:    bmap *members = c->members;
    #####:  125:    bmapiter iter = be_map_iter();
    #####:  126:    if (nvar) {
        -:  127:        /* allocate the member-variable name cache */
    #####:  128:        vars = be_malloc(vm, sizeof(bstring *) * nvar);
        -:  129:    }
    #####:  130:    while ((node = be_map_next(members, &iter)) != NULL) {
        -:  131:        be_assert(var_isstr(&node->key));
    #####:  132:        if (var_isindex(&node->value)) { /* cache member name */
    #####:  133:            if (vars == NULL) {
    #####:  134:                return NULL; /* should never be executed */
        -:  135:            }
    #####:  136:            vars[var_toidx(&node->value)] = var_tostr(&node->key);
        -:  137:        } else { /* save method's name and function */
        -:  138:            bproto *proto;
    #####:  139:            bvalue *value = &node->value;
        -:  140:            be_assert(var_isclosure(value) || var_isproto(value) || var_isnil(value));
    #####:  141:            save_string(fp, var_tostr(&node->key)); /* save method name */
    #####:  142:            if (var_isproto(value)) { /* the method is a prototype */
    #####:  143:                proto = var_toobj(value);
    #####:  144:                save_proto(vm, fp, proto); /* only save prototype */
    #####:  145:            } else if (var_isclosure(value)) { /* the method is a closure */
    #####:  146:                proto = cast(bclosure *, var_toobj(value))->proto;            
    #####:  147:                save_proto(vm, fp, proto); /* only save prototype */
    #####:  148:            } else if (var_isnil(value)) {
        -:  149:                /* this is a static member (nil default) */
    #####:  150:                save_word(fp, 0);  /* store a zero byte that will be seen as a zero length method name which is invalid */
        -:  151:            } else {
    #####:  152:                be_raise(vm, "internal_error", "unsupported member in class");
    #####:  153:                return NULL; /* should never be executed */
        -:  154:            }
        -:  155:        }
        -:  156:    }
    #####:  157:    return vars;
        -:  158:}
        -:  159:
    #####:  160:static void save_class(bvm *vm, void *fp, bclass *c)
        -:  161:{
        -:  162:    bstring **vars;
    #####:  163:    int i, count = be_map_count(c->members);
    #####:  164:    int nvar = c->nvar - be_class_closure_count(c);
    #####:  165:    save_string(fp, c->name);
    #####:  166:    save_long(fp, nvar); /* member variables count */
    #####:  167:    save_long(fp, count - nvar); /* method count */
    #####:  168:    vars = save_members(vm, fp, c, nvar);
    #####:  169:    if (vars != NULL) {
    #####:  170:        for (i = 0; i < nvar; ++i) {
    #####:  171:            save_string(fp, vars[i]);
        -:  172:        }
    #####:  173:        be_free(vm, vars, sizeof(bstring *) * nvar);
        -:  174:    }
    #####:  175:}
        -:  176:
    #####:  177:static void save_value(bvm *vm, void *fp, bvalue *v)
        -:  178:{
    #####:  179:    save_byte(fp, (uint8_t)var_type(v)); /* type */
    #####:  180:    switch (var_type(v)) {
    #####:  181:    case BE_INT: save_int(fp, var_toint(v)); break;
    #####:  182:    case BE_REAL: save_real(fp, var_toreal(v)); break;
    #####:  183:    case BE_STRING: save_string(fp, var_tostr(v)); break;
    #####:  184:    case BE_CLASS: save_class(vm, fp, var_toobj(v)); break;
    #####:  185:    default: break;
        -:  186:    }
    #####:  187:}
        -:  188:
    #####:  189:static void save_bytecode(bvm *vm, void *fp, bproto *proto)
        -:  190:{
    #####:  191:    int forbid_gbl = comp_is_named_gbl(vm);
    #####:  192:    binstruction *code = proto->code, *end;
    #####:  193:    save_long(fp, (uint32_t)proto->codesize);
    #####:  194:    for (end = code + proto->codesize; code < end; ++code) {
    #####:  195:        save_long(fp, (uint32_t)*code);
    #####:  196:        if (forbid_gbl) {   /* we are saving only named globals, so make sure we don't save OP_GETGBL or OP_SETGBL */
    #####:  197:            if ((uint32_t)*code == OP_GETGBL || (uint32_t)*code == OP_SETGBL) {
    #####:  198:                be_raise(vm, "internal_error", "GETGBL/SETGBL found when saving with named globals");
        -:  199:            }
        -:  200:        }
        -:  201:    }
    #####:  202:}
        -:  203:
    #####:  204:static void save_constants(bvm *vm, void *fp, bproto *proto)
        -:  205:{
    #####:  206:    bvalue *v = proto->ktab, *end;
    #####:  207:    save_long(fp, proto->nconst); /* constants count */
    #####:  208:    for (end = v + proto->nconst; v < end; ++v) {
    #####:  209:        save_value(vm, fp, v);
        -:  210:    }
    #####:  211:}
        -:  212:
    #####:  213:static void save_proto_table(bvm *vm, void *fp, bproto *proto)
        -:  214:{
    #####:  215:    bproto **p = proto->ptab, **end;
    #####:  216:    save_long(fp, proto->nproto); /* proto count */
    #####:  217:    for (end = p + proto->nproto; p < end; ++p) {
    #####:  218:        save_proto(vm, fp, *p);
        -:  219:    }
    #####:  220:}
        -:  221:
    #####:  222:static void save_upvals(void *fp, bproto *proto)
        -:  223:{
    #####:  224:    bupvaldesc *uv = proto->upvals, *end;
    #####:  225:    save_byte(fp, proto->nupvals); /* upvals count */
    #####:  226:    for (end = uv + proto->nupvals; uv < end; ++uv) {
    #####:  227:        save_byte(fp, uv->instack);
    #####:  228:        save_byte(fp, uv->idx);
        -:  229:    }
    #####:  230:}
        -:  231:
    #####:  232:static void save_proto(bvm *vm, void *fp, bproto *proto)
        -:  233:{
    #####:  234:    if (proto) {
    #####:  235:        save_string(fp, proto->name); /* name */
    #####:  236:        save_string(fp, proto->source); /* source */
    #####:  237:        save_byte(fp, proto->argc); /* argc */
    #####:  238:        save_byte(fp, proto->nstack); /* nstack */
    #####:  239:        save_byte(fp, proto->varg); /* varg */
    #####:  240:        save_byte(fp, 0x00); /* reserved */
    #####:  241:        save_bytecode(vm, fp, proto); /* bytecode */
    #####:  242:        save_constants(vm, fp, proto); /* constant */
    #####:  243:        save_proto_table(vm, fp, proto); /* proto table */
    #####:  244:        save_upvals(fp, proto); /* upvals description table */
        -:  245:    }
    #####:  246:}
        -:  247:
    #####:  248:static void save_globals(bvm *vm, void *fp)
        -:  249:{
        -:  250:    bmapnode *node;
    #####:  251:    bmapiter iter = be_map_iter();
    #####:  252:    bmap *map = vm->gbldesc.global.vtab;
    #####:  253:    int i, count = be_global_count(vm);
    #####:  254:    bstring **list = be_malloc(vm, sizeof(bstring*) * count);
    #####:  255:    while ((node = be_map_next(map, &iter)) != NULL) {
    #####:  256:        if (var_isstr(&node->key)) {
    #####:  257:            int idx = var_toidx(&node->value);
        -:  258:            be_assert(idx < count);
    #####:  259:            list[idx] = var_tostr(&node->key);
        -:  260:        }
        -:  261:    }
    #####:  262:    for (i = 0; i < count; ++i) {
    #####:  263:        save_string(fp, list[i]);
        -:  264:    }
    #####:  265:    be_free(vm, list, sizeof(bstring*) * count);
    #####:  266:}
        -:  267:
    #####:  268:static void save_global_info(bvm *vm, void *fp)
        -:  269:{
    #####:  270:    save_long(fp, be_builtin_count(vm));
    #####:  271:    if (comp_is_named_gbl(vm)) {
        -:  272:        /* named globals only so no need to save current globals */
    #####:  273:        save_long(fp, 0);
        -:  274:    } else {
    #####:  275:        save_long(fp, be_global_count(vm));
    #####:  276:        save_globals(vm, fp);
        -:  277:    }
    #####:  278:}
        -:  279:
    #####:  280:void be_bytecode_save(bvm *vm, const char *filename, bproto *proto)
        -:  281:{
    #####:  282:    void *fp = be_fopen(filename, "wb");
    #####:  283:    if (fp == NULL) {
    #####:  284:        bytecode_error(vm, be_pushfstring(vm,
        -:  285:            "can not open file '%s'.", filename));
        -:  286:    } else {
    #####:  287:        save_header(fp);
    #####:  288:        save_global_info(vm, fp);
    #####:  289:        save_proto(vm, fp, proto);
    #####:  290:        be_fclose(fp);
        -:  291:    }
    #####:  292:}
        -:  293:#endif /* BE_USE_BYTECODE_SAVER */
        -:  294:
        -:  295:#if BE_USE_BYTECODE_LOADER
        -:  296:static bbool load_proto(bvm *vm, void *fp, bproto **proto, int info, int version);
        -:  297:
    #####:  298:static uint8_t load_byte(void *fp)
        -:  299:{
        -:  300:    uint8_t buffer[1];
    #####:  301:    if (be_fread(fp, buffer, sizeof(buffer)) == sizeof(buffer)) {
    #####:  302:        return buffer[0];
        -:  303:    }
    #####:  304:    return 0;
        -:  305:}
        -:  306:
    #####:  307:static uint16_t load_word(void *fp)
        -:  308:{
        -:  309:    uint8_t buffer[2];
    #####:  310:    if (be_fread(fp, buffer, sizeof(buffer)) == sizeof(buffer)) {
    #####:  311:        return ((uint16_t)buffer[1] << 8) | buffer[0];
        -:  312:    }
    #####:  313:    return 0;
        -:  314:}
        -:  315:
    #####:  316:static uint32_t load_long(void *fp)
        -:  317:{
        -:  318:    uint8_t buffer[4];
    #####:  319:    if (be_fread(fp, buffer, sizeof(buffer)) == sizeof(buffer)) {
    #####:  320:        return ((uint32_t)buffer[3] << 24)
    #####:  321:            | ((uint32_t)buffer[2] << 16)
    #####:  322:            | ((uint32_t)buffer[1] << 8)
    #####:  323:            | buffer[0];
        -:  324:    }
    #####:  325:    return 0;
        -:  326:}
        -:  327:
    #####:  328:static int load_head(void *fp)
        -:  329:{
        -:  330:    int res;
    #####:  331:    uint8_t buffer[8] = { 0 };
    #####:  332:    be_fread(fp, buffer, sizeof(buffer));
    #####:  333:    res = buffer[0] == MAGIC_NUMBER1 &&
    #####:  334:          buffer[1] == MAGIC_NUMBER2 &&
    #####:  335:          buffer[2] == MAGIC_NUMBER3 &&
    #####:  336:          buffer[3] <= BYTECODE_VERSION &&
    #####:  337:          buffer[4] == vm_sizeinfo();
    #####:  338:    if (res) {
    #####:  339:        return buffer[3];
        -:  340:    } else {
    #####:  341:        return 0;
        -:  342:    }
        -:  343:}
        -:  344:
        1:  345:bbool be_bytecode_check(const char *path)
        -:  346:{
        1:  347:    void *fp = be_fopen(path, "r");
        1:  348:    if (fp) {
        -:  349:        uint8_t buffer[3], rb;
        1:  350:        rb = (uint8_t)be_fread(fp, buffer, 3);
        1:  351:        be_fclose(fp);
        -:  352:        /* check magic number */
        1:  353:        return rb == 3 &&
       1*:  354:            buffer[0] == MAGIC_NUMBER1 &&
       2*:  355:            buffer[1] == MAGIC_NUMBER2 &&
    #####:  356:            buffer[2] == MAGIC_NUMBER3;
        -:  357:    }
    #####:  358:    return bfalse;
        -:  359:}
        -:  360:
    #####:  361:static bint load_int(void *fp)
        -:  362:{
        -:  363:#if USE_64BIT_INT
        -:  364:    bint i;
    #####:  365:    i = load_long(fp);
    #####:  366:    i |= (bint)load_long(fp) << 32;
    #####:  367:    return i;
        -:  368:#else
        -:  369:    return load_long(fp);
        -:  370:#endif
        -:  371:}
        -:  372:
    #####:  373:static breal load_real(void *fp)
        -:  374:{
        -:  375:#if BE_USE_SINGLE_FLOAT
        -:  376:    union { breal r; uint32_t i; } u;
        -:  377:    u.i = load_long(fp);
        -:  378:    return u.r;
        -:  379:#else
        -:  380:    union {
        -:  381:        breal r;
        -:  382:        uint64_t i;
        -:  383:    } u;
    #####:  384:    u.i = load_long(fp);
    #####:  385:    u.i |= (uint64_t)load_long(fp) << 32;
    #####:  386:    return u.r;
        -:  387:#endif
        -:  388:}
        -:  389:
    #####:  390:static bstring* load_string(bvm *vm, void *fp)
        -:  391:{
    #####:  392:    uint16_t len = load_word(fp);
    #####:  393:    if (len > 0) {
        -:  394:        bstring *str;
    #####:  395:        char *buf = be_malloc(vm, len);
    #####:  396:        be_fread(fp, buf, len);
    #####:  397:        str = be_newstrn(vm, buf, len);
    #####:  398:        be_free(vm, buf, len);
    #####:  399:        return str;
        -:  400:    }
    #####:  401:    return str_literal(vm, "");
        -:  402:}
        -:  403:
    #####:  404:static bstring* cache_string(bvm *vm, void *fp)
        -:  405:{
    #####:  406:    bstring *str = load_string(vm, fp);
    #####:  407:    var_setstr(vm->top, str);
    #####:  408:    be_incrtop(vm);
    #####:  409:    return str;
        -:  410:}
        -:  411:
    #####:  412:static void load_class(bvm *vm, void *fp, bvalue *v, int version)
        -:  413:{
        -:  414:    int nvar, count;
    #####:  415:    bclass *c = be_newclass(vm, NULL, NULL);
    #####:  416:    var_setclass(v, c);
    #####:  417:    c->name = load_string(vm, fp);
    #####:  418:    nvar = load_long(fp);
    #####:  419:    count = load_long(fp);
    #####:  420:    while (count--) { /* load method table */
        -:  421:        bvalue *value;
    #####:  422:        bstring *name = cache_string(vm, fp);
    #####:  423:        value = vm->top;
    #####:  424:        var_setproto(value, NULL);
    #####:  425:        be_incrtop(vm);
    #####:  426:        if (load_proto(vm, fp, (bproto**)&var_toobj(value), -3, version)) {
        -:  427:            /* actual method */
    #####:  428:            be_method_bind(vm, c, name, var_toobj(value));
        -:  429:        } else {
        -:  430:            /* no proto, static member set to nil */
    #####:  431:            be_member_bind(vm, c, name, bfalse);
        -:  432:        }
    #####:  433:        be_stackpop(vm, 2); /* pop the cached string and proto */
        -:  434:    }
    #####:  435:    for (count = 0; count < nvar; ++count) { /* load member-variable table */
    #####:  436:        bstring *name = cache_string(vm, fp);
    #####:  437:        be_member_bind(vm, c, name, btrue);
    #####:  438:        be_stackpop(vm, 1); /* pop the cached string */
        -:  439:    }
    #####:  440:}
        -:  441:
    #####:  442:static void load_value(bvm *vm, void *fp, bvalue *v, int version)
        -:  443:{
    #####:  444:    switch (load_byte(fp)) {
    #####:  445:    case BE_INT: var_setint(v, load_int(fp)); break;
    #####:  446:    case BE_REAL: var_setreal(v, load_real(fp)); break;
    #####:  447:    case BE_STRING: var_setstr(v, load_string(vm, fp)); break;
    #####:  448:    case BE_CLASS: load_class(vm, fp, v, version); break;
    #####:  449:    default: break;
        -:  450:    }
    #####:  451:}
        -:  452:
    #####:  453:static void load_bytecode(bvm *vm, void *fp, bproto *proto, int info)
        -:  454:{
    #####:  455:    int size = (int)load_long(fp);
    #####:  456:    if (size) {
        -:  457:        binstruction *code, *end;
    #####:  458:        int bcnt = be_builtin_count(vm);
    #####:  459:        blist *list = var_toobj(be_indexof(vm, info));
        -:  460:        be_assert(be_islist(vm, info));
    #####:  461:        proto->code = be_malloc(vm, sizeof(binstruction) * size);
    #####:  462:        proto->codesize = size;
    #####:  463:        code = proto->code;
    #####:  464:        for (end = code + size; code < end; ++code) {
    #####:  465:            binstruction ins = (binstruction)load_long(fp);
    #####:  466:            binstruction op = IGET_OP(ins);
        -:  467:            /* fix global variable index */
    #####:  468:            if (op == OP_GETGBL || op == OP_SETGBL) {
    #####:  469:                int idx = IGET_Bx(ins);
    #####:  470:                if (idx >= bcnt) { /* does not fix builtin index */
    #####:  471:                    bvalue *name = be_list_at(list, idx - bcnt);
    #####:  472:                    idx = be_global_find(vm, var_tostr(name));
    #####:  473:                    ins = (ins & ~IBx_MASK) | ISET_Bx(idx);
        -:  474:                }
        -:  475:            }
    #####:  476:            *code = ins;
        -:  477:        }
        -:  478:    }
    #####:  479:}
        -:  480:
    #####:  481:static void load_constant(bvm *vm, void *fp, bproto *proto, int version)
        -:  482:{
    #####:  483:    int size = (int)load_long(fp); /* nconst */
    #####:  484:    if (size) {
    #####:  485:        bvalue *end, *v = be_malloc(vm, sizeof(bvalue) * size);
    #####:  486:        memset(v, 0, sizeof(bvalue) * size);
    #####:  487:        proto->ktab = v;
    #####:  488:        proto->nconst = size;
    #####:  489:        for (end = v + size; v < end; ++v) {
    #####:  490:            load_value(vm, fp, v, version);
        -:  491:        }
        -:  492:    }
    #####:  493:}
        -:  494:
    #####:  495:static void load_proto_table(bvm *vm, void *fp, bproto *proto, int version)
        -:  496:{
    #####:  497:    int size = (int)load_long(fp); /* proto count */
    #####:  498:    if (size) {
    #####:  499:        bproto **p = be_malloc(vm, sizeof(bproto *) * size);
    #####:  500:        memset(p, 0, sizeof(bproto *) * size);
    #####:  501:        proto->ptab = p;
    #####:  502:        proto->nproto = size;
    #####:  503:        while (size--) {
    #####:  504:            load_proto(vm, fp, p++, -1, version);
        -:  505:        }
        -:  506:    }
    #####:  507:}
        -:  508:
    #####:  509:static void load_upvals(bvm *vm, void *fp, bproto *proto)
        -:  510:{
    #####:  511:    int size = (int)load_byte(fp);
    #####:  512:    if (size) {
        -:  513:        bupvaldesc *uv, *end;
    #####:  514:        proto->upvals = be_malloc(vm, sizeof(bupvaldesc) * size);
    #####:  515:        proto->nupvals = (bbyte)size;
    #####:  516:        uv = proto->upvals;
    #####:  517:        for (end = uv + size; uv < end; ++uv) {
    #####:  518:            uv->instack = load_byte(fp);
    #####:  519:            uv->idx = load_byte(fp);
        -:  520:        }
        -:  521:    }
    #####:  522:}
        -:  523:
    #####:  524:static bbool load_proto(bvm *vm, void *fp, bproto **proto, int info, int version)
        -:  525:{
        -:  526:    /* first load the name */
        -:  527:    /* if empty, it's a static member so don't allocate an actual proto */
    #####:  528:    bstring *name = load_string(vm, fp);
    #####:  529:    if (str_len(name)) {
    #####:  530:        *proto = be_newproto(vm);
    #####:  531:        (*proto)->name = name;
    #####:  532:        (*proto)->source = load_string(vm, fp);
    #####:  533:        (*proto)->argc = load_byte(fp);
    #####:  534:        (*proto)->nstack = load_byte(fp);
    #####:  535:        if (version > 1) {
    #####:  536:            (*proto)->varg = load_byte(fp);
    #####:  537:            load_byte(fp); /* discard reserved byte */
        -:  538:        }
    #####:  539:        load_bytecode(vm, fp, *proto, info);
    #####:  540:        load_constant(vm, fp, *proto, version);
    #####:  541:        load_proto_table(vm, fp, *proto, version);
    #####:  542:        load_upvals(vm, fp, *proto);
    #####:  543:        return btrue;
        -:  544:    }
    #####:  545:    return bfalse;  /* no proto read */
        -:  546:}
        -:  547:
    #####:  548:void load_global_info(bvm *vm, void *fp)
        -:  549:{
        -:  550:    int i;
    #####:  551:    int bcnt = (int)load_long(fp); /* builtin count */
    #####:  552:    int gcnt = (int)load_long(fp); /* global count */
    #####:  553:    if (bcnt > be_builtin_count(vm)) {
    #####:  554:        bytecode_error(vm, be_pushfstring(vm,
        -:  555:            "inconsistent number of builtin objects."));
        -:  556:    }
    #####:  557:    be_newlist(vm);
    #####:  558:    for (i = 0; i < gcnt; ++i) {
    #####:  559:        bstring *name = cache_string(vm, fp);
    #####:  560:        be_global_new(vm, name);
    #####:  561:        be_data_push(vm, -2); /* push the variable name to list */
    #####:  562:        be_stackpop(vm, 1); /* pop the cached string */
        -:  563:    }
    #####:  564:    be_global_release_space(vm);
    #####:  565:}
        -:  566:
    #####:  567:bclosure* be_bytecode_load(bvm *vm, const char *filename)
        -:  568:{
    #####:  569:    void *fp = be_fopen(filename, "rb");
    #####:  570:    if (fp == NULL) {
    #####:  571:        bytecode_error(vm, be_pushfstring(vm,
        -:  572:            "can not open file '%s'.", filename));
        -:  573:    } else {
    #####:  574:        int version = load_head(fp);
    #####:  575:        if (version) {
    #####:  576:            bclosure *cl = be_newclosure(vm, 0);
    #####:  577:            var_setclosure(vm->top, cl);
    #####:  578:            be_stackpush(vm);
    #####:  579:            load_global_info(vm, fp);
    #####:  580:            load_proto(vm, fp, &cl->proto, -1, version);
    #####:  581:            be_stackpop(vm, 2); /* pop the closure and list */
    #####:  582:            be_fclose(fp);
    #####:  583:            return cl;
        -:  584:        }
        -:  585:    }
    #####:  586:    bytecode_error(vm, be_pushfstring(vm,
        -:  587:        "invalid bytecode file '%s'.", filename));
    #####:  588:    return NULL;
        -:  589:}
        -:  590:#endif /* BE_USE_BYTECODE_LOADER */
