        -:    0:Source:src/be_mem.c
        -:    0:Graph:./src/be_mem.gcno
        -:    0:Data:./src/be_mem.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_mem.h"
        -:    9:#include "be_exec.h"
        -:   10:#include "be_vm.h"
        -:   11:#include "be_gc.h"
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:
        -:   15:#define GC_ALLOC    (1 << 2) /* GC in alloc */
        -:   16:
        -:   17:#ifdef BE_EXPLICIT_MALLOC
        -:   18:  #define malloc                BE_EXPLICIT_MALLOC
        -:   19:#endif
        -:   20:
        -:   21:#ifdef BE_EXPLICIT_FREE
        -:   22:  #define free                  BE_EXPLICIT_FREE
        -:   23:#endif
        -:   24:
        -:   25:#ifdef BE_EXPLICIT_REALLOC
        -:   26:  #define realloc               BE_EXPLICIT_REALLOC
        -:   27:#endif
        -:   28:
        1:   29:BERRY_API void* be_os_malloc(size_t size)
        -:   30:{
        1:   31:    return malloc(size);
        -:   32:}
        -:   33:
        1:   34:BERRY_API void be_os_free(void *ptr)
        -:   35:{
        1:   36:    free(ptr);
        1:   37:}
        -:   38:
    #####:   39:BERRY_API void* be_os_realloc(void *ptr, size_t size)
        -:   40:{
    #####:   41:    return realloc(ptr, size);
        -:   42:}
        -:   43:
      104:   44:static void* _realloc(void *ptr, size_t old_size, size_t new_size)
        -:   45:{
      104:   46:    if (old_size == new_size) { /* the block unchanged */
        7:   47:        return ptr;
        -:   48:    }
       97:   49:    if (ptr && new_size) { /* realloc block */
       23:   50:        return realloc(ptr, new_size);
        -:   51:    }
       74:   52:    if (new_size) { /* alloc a new block */
        -:   53:        be_assert(ptr == NULL && old_size == 0);
       37:   54:        return malloc(new_size);
        -:   55:    }
        -:   56:    be_assert(new_size == 0);
        -:   57:
        -:   58:#if BE_USE_DEBUG_GC
        -:   59:    memset(ptr, 0xFF, old_size); /* fill the structure with invalid pointers */
        -:   60:#endif
       37:   61:    free(ptr);
       37:   62:    return NULL;
        -:   63:}
        -:   64:
      104:   65:BERRY_API void* be_realloc(bvm *vm, void *ptr, size_t old_size, size_t new_size)
        -:   66:{
      104:   67:    void *block = _realloc(ptr, old_size, new_size);
      104:   68:    if (!block && new_size) { /* allocation failure */
    #####:   69:        vm->gc.status |= GC_ALLOC;
    #####:   70:        be_gc_collect(vm); /* try to allocate again after GC */
    #####:   71:        vm->gc.status &= ~GC_ALLOC;
    #####:   72:        block = _realloc(ptr, old_size, new_size);
    #####:   73:        if (!block) { /* lack of heap space */
    #####:   74:            be_throw(vm, BE_MALLOC_FAIL);
        -:   75:        }
        -:   76:    }
      104:   77:    vm->gc.usage = vm->gc.usage + new_size - old_size; /* update allocated count */
      104:   78:    return block;
        -:   79:}
