        -:    0:Source:src/be_filelib.c
        -:    0:Graph:./src/be_filelib.gcno
        -:    0:Data:./src/be_filelib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_mem.h"
        -:   10:#include "be_sys.h"
        -:   11:#include "be_gc.h"
        -:   12:#include <string.h>
        -:   13:
        -:   14:#define READLINE_STEP           100
        -:   15:
    #####:   16:static int i_write(bvm *vm)
        -:   17:{
    #####:   18:    be_getmember(vm, 1, ".p");
    #####:   19:    if(be_iscomptr(vm, -1) && (be_isstring(vm, 2) || be_isbytes(vm, 2))) {
    #####:   20:        void *fh = be_tocomptr(vm, -1);
    #####:   21:        size_t size = 0;
    #####:   22:        const char *data = NULL;
    #####:   23:        if (be_isstring(vm, 2)) {
    #####:   24:            data = be_tostring(vm, 2);
    #####:   25:            size = be_strlen(vm, 2);
        -:   26:        } else {
    #####:   27:            data = be_tobytes(vm, 2, &size);
        -:   28:        }
    #####:   29:        be_fwrite(fh, data, size);
        -:   30:    }
    #####:   31:    be_return_nil(vm);
        -:   32:}
        -:   33:
    #####:   34:static size_t readsize(bvm *vm, int argc, void *fh)
        -:   35:{
    #####:   36:    if (argc >=2 && be_isint(vm, 2)) {
    #####:   37:        return be_toindex(vm, 2);
        -:   38:    }
    #####:   39:    return be_fsize(fh) - be_ftell(fh);
        -:   40:}
        -:   41:
    #####:   42:static int i_read(bvm *vm)
        -:   43:{
    #####:   44:    int argc = be_top(vm);
    #####:   45:    be_getmember(vm, 1, ".p");
    #####:   46:    if (be_iscomptr(vm, -1)) {
    #####:   47:        void *fh = be_tocomptr(vm, -1);
    #####:   48:        size_t size = readsize(vm, argc, fh);
    #####:   49:        if (size) {
    #####:   50:            char *buffer = be_malloc(vm, size);
    #####:   51:            size = be_fread(fh, buffer, size);
    #####:   52:            be_pushnstring(vm, buffer, size);
    #####:   53:            be_free(vm, buffer, size);
        -:   54:        } else {
    #####:   55:            be_pushstring(vm, "");
        -:   56:        }
    #####:   57:        be_return(vm);
        -:   58:    }
    #####:   59:    be_return_nil(vm);
        -:   60:}
        -:   61:
    #####:   62:static int i_readbytes(bvm *vm)
        -:   63:{
    #####:   64:    int argc = be_top(vm);
    #####:   65:    be_getmember(vm, 1, ".p");
    #####:   66:    if (be_iscomptr(vm, -1)) {
    #####:   67:        void *fh = be_tocomptr(vm, -1);
    #####:   68:        size_t size = readsize(vm, argc, fh);
    #####:   69:        if (size) {
        -:   70:            /* avoid double allocation, using directly the internal buffer of bytes() */
    #####:   71:            be_getbuiltin(vm, "bytes");
    #####:   72:            be_pushint(vm, size);
    #####:   73:            be_call(vm, 1);  /* call bytes() constructor with pre-sized buffer */
    #####:   74:            be_pop(vm, 1);  /* bytes() instance is at top */
        -:   75:
    #####:   76:            be_getmember(vm, -1, "resize");
    #####:   77:            be_pushvalue(vm, -2);
    #####:   78:            be_pushint(vm, size);
    #####:   79:            be_call(vm, 2); /* call b.resize(size) */
    #####:   80:            be_pop(vm, 3);  /* bytes() instance is at top */
        -:   81:
    #####:   82:            char *buffer = (char*) be_tobytes(vm, -1, NULL); /* we get the address of the internam buffer of size 'size' */
    #####:   83:            size = be_fread(fh, buffer, size);
        -:   84:
        -:   85:            /* resize if something went wrong */
    #####:   86:            be_getmember(vm, -1, "resize");
    #####:   87:            be_pushvalue(vm, -2);
    #####:   88:            be_pushint(vm, size);
    #####:   89:            be_call(vm, 2); /* call b.resize(size) */
    #####:   90:            be_pop(vm, 3);  /* bytes() instance is at top */
        -:   91:        } else {
    #####:   92:            be_pushbytes(vm, NULL, 0);
        -:   93:        }
    #####:   94:        be_return(vm);
        -:   95:    }
    #####:   96:    be_return_nil(vm);
        -:   97:}
        -:   98:
    #####:   99:static int i_readline(bvm *vm)
        -:  100:{
    #####:  101:    be_getmember(vm, 1, ".p");
    #####:  102:    if (be_iscomptr(vm, -1)) {
    #####:  103:        void *fh = be_tocomptr(vm, -1);
    #####:  104:        size_t pos = 0, size = READLINE_STEP;
    #####:  105:        char *buffer = be_malloc(vm, size);
    #####:  106:        char *res = be_fgets(fh, buffer, (int)size);
    #####:  107:        while (res) {
    #####:  108:            pos += strlen(buffer + pos);
    #####:  109:            if (!pos || buffer[pos - 1] == '\n') {
        -:  110:                break;
        -:  111:            }
    #####:  112:            buffer = be_realloc(vm, buffer, size, size + READLINE_STEP);
    #####:  113:            res = be_fgets(fh, buffer + pos, READLINE_STEP);
    #####:  114:            size += READLINE_STEP;
        -:  115:        }
    #####:  116:        be_pushnstring(vm, buffer, pos);
    #####:  117:        be_free(vm, buffer, size);
    #####:  118:        be_return(vm);
        -:  119:    }
    #####:  120:    be_return_nil(vm);
        -:  121:}
        -:  122:
    #####:  123:static int i_seek(bvm *vm)
        -:  124:{
    #####:  125:    be_getmember(vm, 1, ".p");
    #####:  126:    if (be_iscomptr(vm, -1) && be_isint(vm, 2)) {
    #####:  127:        void *fh = be_tocomptr(vm, -1);
    #####:  128:        be_fseek(fh, be_toindex(vm, 2));
        -:  129:    }
    #####:  130:    be_return_nil(vm);
        -:  131:}
        -:  132:
    #####:  133:static int i_tell(bvm *vm)
        -:  134:{
    #####:  135:    be_getmember(vm, 1, ".p");
    #####:  136:    if (be_iscomptr(vm, -1)) {
    #####:  137:        void *fh = be_tocomptr(vm, -1);
    #####:  138:        size_t pos = be_ftell(fh);
    #####:  139:        be_pushint(vm, cast(bint, pos));
    #####:  140:        be_return(vm);
        -:  141:    }
    #####:  142:    be_return_nil(vm);
        -:  143:}
        -:  144:
    #####:  145:static int i_size(bvm *vm)
        -:  146:{
    #####:  147:    be_getmember(vm, 1, ".p");
    #####:  148:    if (be_iscomptr(vm, -1)) {
    #####:  149:        void *fh = be_tocomptr(vm, -1);
    #####:  150:        size_t pos = be_fsize(fh);
    #####:  151:        be_pushint(vm, cast(bint, pos));
    #####:  152:        be_return(vm);
        -:  153:    }
    #####:  154:    be_return_nil(vm);
        -:  155:}
        -:  156:
    #####:  157:static int i_flush(bvm *vm)
        -:  158:{
    #####:  159:    be_getmember(vm, 1, ".p");
    #####:  160:    if (be_iscomptr(vm, -1)) {
    #####:  161:        void *fh = be_tocomptr(vm, -1);
    #####:  162:        be_fflush(fh);
        -:  163:    }
    #####:  164:    be_return_nil(vm);
        -:  165:}
        -:  166:
    #####:  167:static int i_close(bvm *vm)
        -:  168:{
    #####:  169:    be_getmember(vm, 1, ".p");
    #####:  170:    if (be_iscomptr(vm, -1)) {
    #####:  171:        void *fh = be_tocomptr(vm, -1);
    #####:  172:        be_fclose(fh);
    #####:  173:        be_pushnil(vm);
    #####:  174:        be_setmember(vm, 1, ".p");
        -:  175:    }
    #####:  176:    be_return_nil(vm);
        -:  177:}
        -:  178:
        -:  179:#if !BE_USE_PRECOMPILED_OBJECT
        -:  180:static int m_open(bvm *vm)
        -:  181:#else
    #####:  182:int be_nfunc_open(bvm *vm)
        -:  183:#endif
        -:  184:{
    #####:  185:    int argc = be_top(vm);
        -:  186:    const char *fname, *mode;
        -:  187:    static const bnfuncinfo members[] = {
        -:  188:        { ".p", NULL },
        -:  189:        { "write", i_write },
        -:  190:        { "read", i_read },
        -:  191:        { "readbytes", i_readbytes },
        -:  192:        { "readline", i_readline },
        -:  193:        { "seek", i_seek },
        -:  194:        { "tell", i_tell },
        -:  195:        { "size", i_size },
        -:  196:        { "flush", i_flush },
        -:  197:        { "close", i_close },
        -:  198:        { "deinit", i_close },
        -:  199:        { NULL, NULL }
        -:  200:    };
    #####:  201:    fname = argc >= 1 && be_isstring(vm, 1) ? be_tostring(vm, 1) : NULL;
    #####:  202:    mode = argc >= 2 && be_isstring(vm, 2) ? be_tostring(vm, 2) : "r";
    #####:  203:    if (fname) {
    #####:  204:        void *fh = be_fopen(fname, mode);
    #####:  205:        if (fh == NULL) {
    #####:  206:            be_raise(vm, "io_error",
        -:  207:                be_pushfstring(vm, "cannot open file '%s'", fname));
        -:  208:        }
    #####:  209:        be_pushclass(vm, "file", members);
    #####:  210:        be_call(vm, 0);
    #####:  211:        be_pushcomptr(vm, fh);
    #####:  212:        be_setmember(vm, -2, ".p");
    #####:  213:        be_pop(vm, 1);
    #####:  214:        be_return(vm);
        -:  215:    }
    #####:  216:    be_return_nil(vm);
        -:  217:}
        -:  218:
        -:  219:#if !BE_USE_PRECOMPILED_OBJECT
        -:  220:void be_load_filelib(bvm *vm)
        -:  221:{
        -:  222:    be_regfunc(vm, "open", m_open);
        -:  223:}
        -:  224:#endif
