        -:    0:Source:src/be_solidifylib.c
        -:    0:Graph:./src/be_solidifylib.gcno
        -:    0:Data:./src/be_solidifylib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_module.h"
        -:   10:#include "be_string.h"
        -:   11:#include "be_vector.h"
        -:   12:#include "be_class.h"
        -:   13:#include "be_debug.h"
        -:   14:#include "be_map.h"
        -:   15:#include "be_vm.h"
        -:   16:#include "be_decoder.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:
        -:   20:#if BE_USE_SOLIDIFY_MODULE
        -:   21:#include <inttypes.h>
        -:   22:
        -:   23:#ifndef INST_BUF_SIZE
        -:   24:#define INST_BUF_SIZE   96
        -:   25:#endif
        -:   26:
        -:   27:#define logbuf(...)     snprintf(__lbuf, sizeof(__lbuf), __VA_ARGS__)
        -:   28:
        -:   29:#define logfmt(...)                     \
        -:   30:    do {                                \
        -:   31:        char __lbuf[INST_BUF_SIZE];     \
        -:   32:        logbuf(__VA_ARGS__);            \
        -:   33:        be_writestring(__lbuf);         \
        -:   34:    } while (0)
        -:   35:
    #####:   36:static void m_solidify_bvalue(bvm *vm, bvalue * value)
        -:   37:{
    #####:   38:    int type = var_type(value);
    #####:   39:    switch (type) {
    #####:   40:    case BE_NIL:
    #####:   41:        logfmt("be_const_nil()");
    #####:   42:        break;
    #####:   43:    case BE_BOOL:
    #####:   44:        logfmt("be_const_bool(%i)", var_tobool(value));
    #####:   45:        break;
    #####:   46:    case BE_INT:
        -:   47:#if BE_INTGER_TYPE == 2
    #####:   48:        logfmt("be_const_int(%lli)", var_toint(value));
        -:   49:#else
        -:   50:        logfmt("be_const_int(%i)", var_toint(value));
        -:   51:#endif
    #####:   52:        break;
    #####:   53:    case BE_INDEX:
        -:   54:#if BE_INTGER_TYPE == 2
    #####:   55:        logfmt("be_const_var(%lli)", var_toint(value));
        -:   56:#else
        -:   57:        logfmt("be_const_var(%i)", var_toint(value));
        -:   58:#endif
    #####:   59:        break;
    #####:   60:    case BE_REAL:
        -:   61:#if BE_USE_SINGLE_FLOAT
        -:   62:        logfmt("be_const_real_hex(0x%08X)", (uint32_t) var_toobj(value));
        -:   63:#else
    #####:   64:        logfmt("be_const_real_hex(0x%016" PRIx64 ")", (uint64_t)var_toobj(value));
        -:   65:#endif
    #####:   66:        break;
    #####:   67:    case BE_STRING:
        -:   68:        {
    #####:   69:            logfmt("be_nested_string(\"");
    #####:   70:            be_writestring(str(var_tostr(value)));
    #####:   71:            size_t len = strlen(str(var_tostr(value)));
    #####:   72:            if (len >= 255) {
    #####:   73:                be_raise(vm, "internal_error", "Strings greater than 255 chars not supported yet");
        -:   74:            }
    #####:   75:            logfmt("\", %i, %zu)", be_strhash(var_tostr(value)), len >= 255 ? 255 : len);
        -:   76:        }
    #####:   77:        break;
    #####:   78:    case BE_CLOSURE:
    #####:   79:        logfmt("be_const_closure(%s_closure)", str(((bclosure*) var_toobj(value))->proto->name));
    #####:   80:        break;
    #####:   81:    default:
        -:   82:        {
        -:   83:            char error[64];
    #####:   84:            snprintf(error, sizeof(error), "Unsupported type in function constants: %i", type);
    #####:   85:            be_raise(vm, "internal_error", error);
        -:   86:        }
        -:   87:    }
    #####:   88:}
        -:   89:
    #####:   90:static void m_solidify_proto(bvm *vm, bproto *pr, const char * func_name, int builtins, int indent)
        -:   91:{
        -:   92:    // const char * func_name = str(pr->name);
    #####:   93:    const char * func_source = str(pr->source);
        -:   94:
    #####:   95:    logfmt("%*sbe_nested_proto(\n", indent, "");
    #####:   96:    indent += 2;
        -:   97:
    #####:   98:    logfmt("%*s%d,                          /* nstack */\n", indent, "", pr->nstack);
    #####:   99:    logfmt("%*s%d,                          /* argc */\n", indent, "", pr->argc);
    #####:  100:    logfmt("%*s%d,                          /* varg */\n", indent, "", pr->varg);
    #####:  101:    logfmt("%*s%d,                          /* has upvals */\n", indent, "", (pr->nupvals > 0) ? 1 : 0);
        -:  102:
    #####:  103:    if (pr->nupvals > 0) {
    #####:  104:        logfmt("%*s( &(const bupvaldesc[%2d]) {  /* upvals */\n", indent, "", pr->nupvals);
    #####:  105:        for (int32_t i = 0; i < pr->nupvals; i++) {
    #####:  106:            logfmt("%*s  be_local_const_upval(%i, %i),\n", indent, "", pr->upvals[i].instack, pr->upvals[i].idx);
        -:  107:        }
    #####:  108:        logfmt("%*s}),\n", indent, "");
        -:  109:    } else {
    #####:  110:        logfmt("%*sNULL,                       /* no upvals */\n", indent, "");
        -:  111:    }
        -:  112:
    #####:  113:    logfmt("%*s%d,                          /* has sup protos */\n", indent, "", (pr->nproto > 0) ? 1 : 0);
    #####:  114:    if (pr->nproto > 0) {
    #####:  115:        logfmt("%*s( &(const struct bproto*[%2d]) {\n", indent, "", pr->nproto);
    #####:  116:        for (int32_t i = 0; i < pr->nproto; i++) {
    #####:  117:            size_t sub_len = strlen(func_name) + 10;
    #####:  118:            char sub_name[sub_len];
    #####:  119:            snprintf(sub_name, sizeof(sub_name), "%s_%d", func_name, i);
    #####:  120:            m_solidify_proto(vm, pr->ptab[i], sub_name, builtins, indent+2);
    #####:  121:            logfmt(",\n");
        -:  122:        }
    #####:  123:        logfmt("%*s}),\n", indent, "");
        -:  124:    } else {
    #####:  125:        logfmt("%*sNULL,                       /* no sub protos */\n", indent, "");
        -:  126:    }
        -:  127:
    #####:  128:    logfmt("%*s%d,                          /* has constants */\n", indent, "", (pr->nconst > 0) ? 1 : 0);
    #####:  129:    if (pr->nconst > 0) {
    #####:  130:        logfmt("%*s( &(const bvalue[%2d]) {     /* constants */\n", indent, "", pr->nconst);
    #####:  131:        for (int k = 0; k < pr->nconst; k++) {
    #####:  132:            logfmt("%*s/* K%-3d */  ", indent, "", k);
    #####:  133:            m_solidify_bvalue(vm, &pr->ktab[k]);
    #####:  134:            logfmt(",\n");
        -:  135:        }
    #####:  136:        logfmt("%*s}),\n", indent, "");
        -:  137:    } else {
    #####:  138:        logfmt("%*sNULL,                       /* no const */\n", indent, "");
        -:  139:    }
        -:  140:
    #####:  141:    logfmt("%*s(be_nested_const_str(\"%s\", %i, %i)),\n", indent, "", str(pr->name), be_strhash(pr->name), str_len(pr->name));
    #####:  142:    logfmt("%*s(be_nested_const_str(\"%s\", %i, %i)),\n", indent, "", func_source, be_strhash(pr->source), str_len(pr->source));
        -:  143:
    #####:  144:    logfmt("%*s( &(const binstruction[%2d]) {  /* code */\n", indent, "", pr->codesize);
    #####:  145:    for (int pc = 0; pc < pr->codesize; pc++) {
    #####:  146:        uint32_t ins = pr->code[pc];
    #####:  147:        logfmt("%*s  0x%08X,  //", indent, "", ins);
    #####:  148:        be_print_inst(ins, pc);
    #####:  149:        bopcode op = IGET_OP(ins);
    #####:  150:        if (op == OP_GETGBL || op == OP_SETGBL) {
        -:  151:            // check if the global is in built-ins
    #####:  152:            int glb = IGET_Bx(ins);
    #####:  153:            if (glb > builtins) {
        -:  154:                // not supported
    #####:  155:                logfmt("\n===== unsupported global G%d\n", glb);
    #####:  156:                be_raise(vm, "internal_error", "Unsupported access to non-builtin global");
        -:  157:            }
        -:  158:        }
        -:  159:    }
    #####:  160:    logfmt("%*s})\n", indent, "");
    #####:  161:    indent -= 2;
    #####:  162:    logfmt("%*s)", indent, "");
        -:  163:
    #####:  164:}
        -:  165:
    #####:  166:static void m_solidify_closure(bvm *vm, bclosure *cl, int builtins)
        -:  167:{   
    #####:  168:    bproto *pr = cl->proto;
    #####:  169:    const char * func_name = str(pr->name);
        -:  170:
    #####:  171:    if (cl->nupvals > 0) {
    #####:  172:        be_raise(vm, "internal_error", "Unsupported upvals in closure");
        -:  173:    }
        -:  174:
    #####:  175:    logfmt("\n");
    #####:  176:    logfmt("/********************************************************************\n");
    #####:  177:    logfmt("** Solidified function: %s\n", func_name);
    #####:  178:    logfmt("********************************************************************/\n");
        -:  179:
    #####:  180:    int indent = 2;
    #####:  181:    logfmt("be_local_closure(%s,   /* name */\n", func_name);
        -:  182:
    #####:  183:    m_solidify_proto(vm, pr, func_name, builtins, indent);
    #####:  184:    logfmt("\n");
        -:  185:
        -:  186:    // closure
    #####:  187:    logfmt(");\n");
    #####:  188:    logfmt("/*******************************************************************/\n\n");
    #####:  189:}
        -:  190:
        -:  191:
    #####:  192:static void m_solidify_class(bvm *vm, bclass *cl, int builtins)
        -:  193:{
    #####:  194:    const char * class_name = str(cl->name);
        -:  195:
        -:  196:    /* iterate on members to dump closures */
    #####:  197:    if (cl->members) {
        -:  198:        bmapnode *node;
    #####:  199:        bmapiter iter = be_map_iter();
    #####:  200:        while ((node = be_map_next(cl->members, &iter)) != NULL) {
    #####:  201:            if (var_isstr(&node->key) && var_isclosure(&node->value)) {
    #####:  202:                bclosure *f = var_toobj(&node->value);
    #####:  203:                m_solidify_closure(vm, f, builtins);
        -:  204:            }
        -:  205:        }
        -:  206:    }
        -:  207:
        -:  208:
    #####:  209:    logfmt("\n");
    #####:  210:    logfmt("/********************************************************************\n");
    #####:  211:    logfmt("** Solidified class: %s\n", class_name);
    #####:  212:    logfmt("********************************************************************/\n");
        -:  213:
    #####:  214:    if (cl->super) {
    #####:  215:        logfmt("extern const bclass be_class_%s;\n", str(cl->super->name));
        -:  216:    }
        -:  217:
    #####:  218:    logfmt("be_local_class(%s,\n", class_name);
    #####:  219:    logfmt("    %i,\n", cl->nvar);
    #####:  220:    if (cl->super) {
    #####:  221:        logfmt("    &be_class_%s,\n", str(cl->super->name));
        -:  222:    } else {
    #####:  223:        logfmt("    NULL,\n");
        -:  224:    }
        -:  225:
    #####:  226:    if (cl->members) {
    #####:  227:        logfmt("    be_nested_map(%i,\n", cl->members->count);
        -:  228:
    #####:  229:        logfmt("    ( (struct bmapnode*) &(const bmapnode[]) {\n");
    #####:  230:        for (int i = 0; i < cl->members->count; i++) {
    #####:  231:            bmapnode * node = &cl->members->slots[i];
    #####:  232:            if (node->key.type != BE_STRING) {
        -:  233:                char error[64];
    #####:  234:                snprintf(error, sizeof(error), "Unsupported type in key: %i", node->key.type);
    #####:  235:                be_raise(vm, "internal_error", error);
        -:  236:            }
    #####:  237:            int key_next = node->key.next;
    #####:  238:            size_t len = strlen(str(node->key.v.s));
    #####:  239:            if (0xFFFFFF == key_next) {
    #####:  240:                key_next = -1;      /* more readable */
        -:  241:            }
    #####:  242:            logfmt("        { be_nested_key(\"%s\", %i, %zu, %i), ", str(node->key.v.s), be_strhash(node->key.v.s), len >= 255 ? 255 : len, key_next);
    #####:  243:            m_solidify_bvalue(vm, &node->value);
        -:  244:
    #####:  245:            logfmt(" },\n");
        -:  246:        }
    #####:  247:        logfmt("    })),\n");
        -:  248:    } else {
    #####:  249:        logfmt("    NULL,\n");
        -:  250:    }
        -:  251:
    #####:  252:    logfmt("    (be_nested_const_str(\"%s\", %i, %i))\n", class_name, be_strhash(cl->name), str_len(cl->name));
    #####:  253:    logfmt(");\n");
    #####:  254:    logfmt("/*******************************************************************/\n\n");
        -:  255:
    #####:  256:    logfmt("void be_load_%s_class(bvm *vm) {\n", class_name);
    #####:  257:    logfmt("    be_pushntvclass(vm, &be_class_%s);\n", class_name);
    #####:  258:    logfmt("    be_setglobal(vm, \"%s\");\n", class_name);
    #####:  259:    logfmt("    be_pop(vm, 1);\n");
    #####:  260:    logfmt("}\n");
    #####:  261:}
        -:  262:
        -:  263:#define be_builtin_count(vm) \
        -:  264:    be_vector_count(&(vm)->gbldesc.builtin.vlist)
        -:  265:
    #####:  266:static int m_dump(bvm *vm)
        -:  267:{
    #####:  268:    if (be_top(vm) >= 1) {
    #####:  269:        bvalue *v = be_indexof(vm, 1);
    #####:  270:        if (var_isclosure(v)) {
    #####:  271:            m_solidify_closure(vm, var_toobj(v), be_builtin_count(vm));
    #####:  272:        } else if (var_isclass(v)) {
    #####:  273:            m_solidify_class(vm, var_toobj(v), be_builtin_count(vm));
        -:  274:        }
        -:  275:    }
    #####:  276:    be_return_nil(vm);
        -:  277:}
        -:  278:
        -:  279:#if !BE_USE_PRECOMPILED_OBJECT
        -:  280:be_native_module_attr_table(solidify) {
        -:  281:    be_native_module_function("dump", m_dump),
        -:  282:};
        -:  283:
        -:  284:be_define_native_module(solidify, NULL);
        -:  285:#else
        -:  286:/* @const_object_info_begin
        -:  287:module solidify (scope: global, depend: BE_USE_SOLIDIFY_MODULE) {
        -:  288:    dump, func(m_dump)
        -:  289:}
        -:  290:@const_object_info_end */
        -:  291:#include "../generate/be_fixed_solidify.h"
        -:  292:#endif
        -:  293:
        -:  294:#endif /* BE_USE_SOLIFIDY_MODULE */
