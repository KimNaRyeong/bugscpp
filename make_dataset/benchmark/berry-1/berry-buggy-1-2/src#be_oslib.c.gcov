        -:    0:Source:src/be_oslib.c
        -:    0:Graph:./src/be_oslib.gcno
        -:    0:Data:./src/be_oslib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_strlib.h"
        -:   10:#include "be_mem.h"
        -:   11:#include "be_sys.h"
        -:   12:#include <string.h>
        -:   13:#include <stdlib.h>
        -:   14:
        -:   15:#define FNAME_BUF_SIZE 512
        -:   16:
        -:   17:#if BE_USE_OS_MODULE
        -:   18:
        -:   19:#if !BE_USE_FILE_SYSTEM
        -:   20:  #error the dependent macro BE_USE_FILE_SYSTEM must be enabled
        -:   21:#endif
        -:   22:
    #####:   23:static int m_getcwd(bvm *vm)
        -:   24:{
    #####:   25:    char *buf = be_malloc(vm, FNAME_BUF_SIZE);
    #####:   26:    if (be_getcwd(buf, FNAME_BUF_SIZE)) {
    #####:   27:        be_pushstring(vm, buf);
        -:   28:    } else {
    #####:   29:        be_pushstring(vm, "");
        -:   30:    }
    #####:   31:    be_free(vm, buf, FNAME_BUF_SIZE);
    #####:   32:    be_return(vm);
        -:   33:}
        -:   34:
    #####:   35:static int m_chdir(bvm *vm)
        -:   36:{
    #####:   37:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:   38:        int res = be_chdir(be_tostring(vm, 1));
    #####:   39:        be_pushbool(vm, res == 0);
        -:   40:    }
    #####:   41:    be_return(vm);
        -:   42:}
        -:   43:
    #####:   44:static int m_mkdir(bvm *vm)
        -:   45:{
    #####:   46:    int res = 1;
    #####:   47:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:   48:        res = be_mkdir(be_tostring(vm, 1));
        -:   49:    }
    #####:   50:    be_pushbool(vm, res == 0);
    #####:   51:    be_return(vm);
        -:   52:}
        -:   53:
    #####:   54:static int m_remove(bvm *vm)
        -:   55:{
    #####:   56:    int res = 1;
    #####:   57:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:   58:        res = be_unlink(be_tostring(vm, 1));
        -:   59:    }
    #####:   60:    be_pushbool(vm, res == 0);
    #####:   61:    be_return(vm);
        -:   62:}
        -:   63:
    #####:   64:static int m_listdir(bvm *vm)
        -:   65:{
        -:   66:    int res;
        -:   67:    bdirinfo info;
    #####:   68:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:   69:        res = be_dirfirst(&info, be_tostring(vm, 1));
        -:   70:    } else {
    #####:   71:        res = be_dirfirst(&info, ".");
        -:   72:    }
    #####:   73:    be_newobject(vm, "list");
    #####:   74:    while (res == 0) {
    #####:   75:        const char *fn = info.name;
    #####:   76:        if (strcmp(fn, ".") && strcmp(fn, "..")) {
    #####:   77:            be_pushstring(vm, fn);
    #####:   78:            be_data_push(vm, -2);
    #####:   79:            be_pop(vm, 1);
        -:   80:        }
    #####:   81:        res = be_dirnext(&info);
        -:   82:    }
    #####:   83:    be_dirclose(&info);
    #####:   84:    be_pop(vm, 1);
    #####:   85:    be_return(vm);
        -:   86:}
        -:   87:
    #####:   88:static int m_system(bvm *vm)
        -:   89:{
    #####:   90:    int res = -1, i, argc = be_top(vm);
    #####:   91:    if (argc > 0) {
    #####:   92:        be_tostring(vm, 1);
    #####:   93:        be_pushstring(vm, " ");
    #####:   94:        for (i = 2; i <= argc; ++i) {
    #####:   95:            be_strconcat(vm, 1); /* add " " */
    #####:   96:            be_tostring(vm, i);
    #####:   97:            be_pushvalue(vm, i);
    #####:   98:            be_strconcat(vm, 1); /* concat arg */
    #####:   99:            be_pop(vm, 1);
        -:  100:        }
    #####:  101:        be_pop(vm, argc);
    #####:  102:        res = system(be_tostring(vm, 1));
        -:  103:    }
    #####:  104:    be_pushint(vm, res);
    #####:  105:    be_return(vm);
        -:  106:}
        -:  107:
    #####:  108:static int m_exit(bvm *vm)
        -:  109:{
    #####:  110:    int status = 0;
    #####:  111:    if (be_top(vm)) {
    #####:  112:        if (be_isint(vm, 1)) {
    #####:  113:            status = be_toindex(vm, 1); /* get the exit code */
    #####:  114:        } else if (be_isbool(vm, 1)) {
    #####:  115:            status = be_tobool(vm, 1) - 1; /* true: 0, false: -1 */
        -:  116:        } else {
    #####:  117:            status = -1;
        -:  118:        }
        -:  119:    }
    #####:  120:    be_exit(vm, status);
    #####:  121:    be_return_nil(vm);
        -:  122:}
        -:  123:
    #####:  124:static int m_path_isdir(bvm *vm)
        -:  125:{
    #####:  126:    const char *path = NULL;
    #####:  127:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:  128:        path = be_tostring(vm, 1);
        -:  129:    }
    #####:  130:    be_pushbool(vm, be_isdir(path));
    #####:  131:    be_return(vm);
        -:  132:}
        -:  133:
    #####:  134:static int m_path_isfile(bvm *vm)
        -:  135:{
    #####:  136:    const char *path = NULL;
    #####:  137:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:  138:        path = be_tostring(vm, 1);
        -:  139:    }
    #####:  140:    be_pushbool(vm, be_isfile(path));
    #####:  141:    be_return(vm);
        -:  142:}
        -:  143:
    #####:  144:static int m_path_split(bvm *vm)
        -:  145:{
    #####:  146:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:  147:        const char *path = be_tostring(vm, 1);
    #####:  148:        const char *split = be_splitpath(path);
    #####:  149:        size_t len = split - path;
    #####:  150:        if (split > path + 1 && split[-1] == '/') {
    #####:  151:            const char *p = split - 1;
    #####:  152:            for (; p >= path && *p == '/'; --p);
    #####:  153:            if (p >= path) {
    #####:  154:                len = p - path + 1;
        -:  155:            }
        -:  156:        }
    #####:  157:        be_getbuiltin(vm, "list");
    #####:  158:        be_pushnstring(vm, path, len);
    #####:  159:        be_pushstring(vm, split);
    #####:  160:        be_call(vm, 2);
    #####:  161:        be_return(vm);
        -:  162:    }
    #####:  163:    be_return_nil(vm);
        -:  164:}
        -:  165:
    #####:  166:static int m_path_splitext(bvm *vm)
        -:  167:{
    #####:  168:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:  169:        const char *path = be_tostring(vm, 1);
    #####:  170:        const char *split = be_splitname(path);
    #####:  171:        be_getbuiltin(vm, "list");
    #####:  172:        be_pushnstring(vm, path, split - path);
    #####:  173:        be_pushstring(vm, split);
    #####:  174:        be_call(vm, 2);
    #####:  175:        be_return(vm);
        -:  176:    }
    #####:  177:    be_return_nil(vm);
        -:  178:}
        -:  179:
    #####:  180:static int m_path_exists(bvm *vm)
        -:  181:{
    #####:  182:    const char *path = NULL;
    #####:  183:    if (be_top(vm) >= 1 && be_isstring(vm, 1)) {
    #####:  184:        path = be_tostring(vm, 1);
        -:  185:    }
    #####:  186:    be_pushbool(vm, be_isexist(path));
    #####:  187:    be_return(vm);
        -:  188:}
        -:  189:
    #####:  190:static int m_path_join(bvm *vm)
        -:  191:{
        -:  192:    char *buf, *p;
    #####:  193:    int i, len = 0, argc = be_top(vm);
    #####:  194:    for (i = 1; i <= argc; ++i) {
    #####:  195:        if (be_isstring(vm, i)) {
    #####:  196:            len += be_strlen(vm, i) + 1;
        -:  197:        } else {
    #####:  198:            be_raise(vm, "type_error", "arguments must be string");
        -:  199:        }
        -:  200:    }
    #####:  201:    buf = p = be_malloc(vm, (size_t)len + 1);
    #####:  202:    for (i = 1; i <= argc; ++i) {
    #####:  203:        int l = be_strlen(vm, i);
    #####:  204:        const char *s = be_tostring(vm, i);
    #####:  205:        if (s[0] == '/') {
    #####:  206:            p = buf;
        -:  207:        }
    #####:  208:        strcpy(p, s);
    #####:  209:        p += l;
    #####:  210:        if (l && s[l - 1] != '/' && i != argc) {
    #####:  211:            *p++ = '/';
        -:  212:        }
        -:  213:    }
    #####:  214:    be_pushnstring(vm, buf, p - buf);
    #####:  215:    be_free(vm, buf, (size_t)len + 1);
    #####:  216:    be_return(vm);
        -:  217:}
        -:  218:
        -:  219:#if !BE_USE_PRECOMPILED_OBJECT
        -:  220:be_native_module_attr_table(path) {
        -:  221:    be_native_module_function("isdir", m_path_isdir),
        -:  222:    be_native_module_function("isfile", m_path_isfile),
        -:  223:    be_native_module_function("exists", m_path_exists),
        -:  224:    be_native_module_function("split", m_path_split),
        -:  225:    be_native_module_function("splitext", m_path_splitext),
        -:  226:    be_native_module_function("join", m_path_join)
        -:  227:};
        -:  228:
        -:  229:static be_define_native_module(path, NULL);
        -:  230:
        -:  231:be_native_module_attr_table(os) {
        -:  232:    be_native_module_function("getcwd", m_getcwd),
        -:  233:    be_native_module_function("chdir", m_chdir),
        -:  234:    be_native_module_function("mkdir", m_mkdir),
        -:  235:    be_native_module_function("remove", m_remove),
        -:  236:    be_native_module_function("listdir", m_listdir),
        -:  237:    be_native_module_function("system", m_system),
        -:  238:    be_native_module_function("exit", m_exit),
        -:  239:    be_native_module_module("path", be_native_module(path))
        -:  240:};
        -:  241:
        -:  242:be_define_native_module(os, NULL);
        -:  243:#else
        -:  244:/* @const_object_info_begin
        -:  245:module path (scope: local, file: os_path, depend: BE_USE_OS_MODULE) {
        -:  246:    isdir, func(m_path_isdir)
        -:  247:    isfile, func(m_path_isfile)
        -:  248:    exists, func(m_path_exists)
        -:  249:    split, func(m_path_split)
        -:  250:    splitext, func(m_path_splitext)
        -:  251:    join, func(m_path_join)
        -:  252:}
        -:  253:@const_object_info_end */
        -:  254:#include "../generate/be_fixed_os_path.h"
        -:  255:
        -:  256:/* @const_object_info_begin
        -:  257:module os (scope: global, depend: BE_USE_OS_MODULE) {
        -:  258:    getcwd, func(m_getcwd)
        -:  259:    chdir, func(m_chdir)
        -:  260:    mkdir, func(m_mkdir)
        -:  261:    remove, func(m_remove)
        -:  262:    listdir, func(m_listdir)
        -:  263:    system, func(m_system)
        -:  264:    exit, func(m_exit)
        -:  265:    path, module(m_libpath)
        -:  266:}
        -:  267:@const_object_info_end */
        -:  268:#include "../generate/be_fixed_os.h"
        -:  269:#endif
        -:  270:
        -:  271:#endif /* BE_USE_OS_MODULE */
