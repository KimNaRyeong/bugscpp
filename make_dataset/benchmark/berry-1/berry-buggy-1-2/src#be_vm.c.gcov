        -:    0:Source:src/be_vm.c
        -:    0:Graph:./src/be_vm.gcno
        -:    0:Data:./src/be_vm.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_vm.h"
        -:    9:#include "be_decoder.h"
        -:   10:#include "be_string.h"
        -:   11:#include "be_strlib.h"
        -:   12:#include "be_class.h"
        -:   13:#include "be_func.h"
        -:   14:#include "be_vector.h"
        -:   15:#include "be_list.h"
        -:   16:#include "be_map.h"
        -:   17:#include "be_module.h"
        -:   18:#include "be_mem.h"
        -:   19:#include "be_var.h"
        -:   20:#include "be_gc.h"
        -:   21:#include "be_exec.h"
        -:   22:#include "be_debug.h"
        -:   23:#include "be_libs.h"
        -:   24:#include <string.h>
        -:   25:#include <math.h>
        -:   26:
        -:   27:#define NOT_METHOD          BE_NONE
        -:   28:
        -:   29:#define vm_error(vm, except, ...) \
        -:   30:    be_raise(vm, except, be_pushfstring(vm, __VA_ARGS__))
        -:   31:
        -:   32:#define RA()   (reg + IGET_RA(ins))  /* Get value of register A */
        -:   33:#define RKB()  ((isKB(ins) ? ktab : reg) + KR2idx(IGET_RKB(ins)))  /* Get value of register or constant B */
        -:   34:#define RKC()  ((isKC(ins) ? ktab : reg) + KR2idx(IGET_RKC(ins)))  /* Get value of register or constant C */
        -:   35:
        -:   36:#define var2cl(_v)          cast(bclosure*, var_toobj(_v))  /* cast var to closure */
        -:   37:#define var2real(_v)        (var_isreal(_v) ? (_v)->v.r : (breal)(_v)->v.i)  /* get var as real or convert to real if integer */
        -:   38:#define val2bool(v)         ((v) ? btrue : bfalse)  /* get var as bool (trur if non zero) */
        -:   39:#define ibinop(op, a, b)    ((a)->v.i op (b)->v.i)  /* apply binary operator to both arguments as integers */
        -:   40:
        -:   41:#if BE_USE_DEBUG_HOOK
        -:   42:  #define DEBUG_HOOK() \
        -:   43:    if (vm->hookmask & BE_HOOK_LINE) { \
        -:   44:        do_linehook(vm); \
        -:   45:        reg = vm->reg; \
        -:   46:    }
        -:   47:#else
        -:   48:  #define DEBUG_HOOK()
        -:   49:#endif
        -:   50:
        -:   51:#define vm_exec_loop() \
        -:   52:    loop: \
        -:   53:        DEBUG_HOOK(); \
        -:   54:        switch (IGET_OP(ins = *vm->ip++))
        -:   55:
        -:   56:#if BE_USE_SINGLE_FLOAT
        -:   57:  #define mathfunc(func)    func##f
        -:   58:#else
        -:   59:  #define mathfunc(func)    func
        -:   60:#endif
        -:   61:
        -:   62:#define opcase(opcode)      case OP_##opcode
        -:   63:#define dispatch()          goto loop
        -:   64:
        -:   65:#define equal_rule(op, iseq) \
        -:   66:    bbool res; \
        -:   67:    if (var_isint(a) && var_isint(b)) { \
        -:   68:        res = ibinop(op, a, b); \
        -:   69:    } else if (var_isnumber(a) && var_isnumber(b)) { \
        -:   70:        res = var2real(a) op var2real(b); \
        -:   71:    } else if (var_isinstance(a)) { \
        -:   72:        res = object_eqop(vm, #op, iseq, a, b); \
        -:   73:    } else if (var_type(a) == var_type(b)) { /* same types */ \
        -:   74:        if (var_isnil(a)) { /* nil op nil */ \
        -:   75:            res = 1 op 1; \
        -:   76:        } else if (var_isbool(a)) { /* bool op bool */ \
        -:   77:            res = var_tobool(a) op var_tobool(b); \
        -:   78:        } else if (var_isstr(a)) { /* string op string */ \
        -:   79:            res = 1 op be_eqstr(a->v.s, b->v.s); \
        -:   80:        } else if (var_isclass(a) || var_isfunction(a)) { \
        -:   81:            res = var_toobj(a) op var_toobj(b); \
        -:   82:        } else { \
        -:   83:            binop_error(vm, #op, a, b); \
        -:   84:            res = bfalse; /* will not be executed */ \
        -:   85:        } \
        -:   86:    } else { /* different types */ \
        -:   87:        res = 1 op 0; \
        -:   88:    } \
        -:   89:    return res
        -:   90:
        -:   91:#define relop_rule(op) \
        -:   92:    bbool res; \
        -:   93:    if (var_isint(a) && var_isint(b)) { \
        -:   94:        res = ibinop(op, a, b); \
        -:   95:    } else if (var_isnumber(a) && var_isnumber(b)) { \
        -:   96:        res = var2real(a) op var2real(b); \
        -:   97:    } else if (var_isstr(a) && var_isstr(b)) { \
        -:   98:        bstring *s1 = var_tostr(a), *s2 = var_tostr(b); \
        -:   99:        res = be_strcmp(s1, s2) op 0; \
        -:  100:    } else if (var_isinstance(a)) { \
        -:  101:        binstance *obj = var_toobj(a); \
        -:  102:        object_binop(vm, #op, *a, *b); \
        -:  103:        check_bool(vm, obj, #op); \
        -:  104:        res = var_tobool(vm->top); \
        -:  105:    } else { \
        -:  106:        binop_error(vm, #op, a, b); \
        -:  107:        res = bfalse; /* will not be executed */ \
        -:  108:    } \
        -:  109:    return res
        -:  110:
        -:  111:#define bitwise_block(op) \
        -:  112:    bvalue *dst = RA(), *a = RKB(), *b = RKC(); \
        -:  113:    if (var_isint(a) && var_isint(b)) { \
        -:  114:        var_setint(dst, ibinop(op, a, b)); \
        -:  115:    } else if (var_isinstance(a)) { \
        -:  116:        ins_binop(vm, #op, ins); \
        -:  117:    } else { \
        -:  118:        binop_error(vm, #op, a, b); \
        -:  119:    }
        -:  120:
        -:  121:#define push_native(_vm, _f, _ns, _t) { \
        -:  122:    precall(_vm, _f, _ns, _t); \
        -:  123:    _vm->cf->status = PRIM_FUNC; \
        -:  124:}
        -:  125:
        -:  126:static void prep_closure(bvm *vm, bvalue *reg, int argc, int mode);
        -:  127:
    #####:  128:static void attribute_error(bvm *vm, const char *t, bvalue *b, bvalue *c)
        -:  129:{
    #####:  130:    const char *attr = var_isstr(c) ? str(var_tostr(c)) : be_vtype2str(c);
    #####:  131:    vm_error(vm, "attribute_error",
        -:  132:        "'%s' value has no %s '%s'", be_vtype2str(b), t, attr);
    #####:  133:}
        -:  134:
    #####:  135:static void binop_error(bvm *vm, const char *op, bvalue *a, bvalue *b)
        -:  136:{
    #####:  137:    vm_error(vm, "type_error",
        -:  138:        "unsupported operand type(s) for %s: '%s' and '%s'",
        -:  139:        op, be_vtype2str(a), be_vtype2str(b));
    #####:  140:}
        -:  141:
    #####:  142:static void unop_error(bvm *vm, const char *op, bvalue *a)
        -:  143:{
    #####:  144:    vm_error(vm, "type_error",
        -:  145:        "unsupported operand type(s) for %s: '%s'",
        -:  146:        op, be_vtype2str(a));
    #####:  147:}
        -:  148:
    #####:  149:static void call_error(bvm *vm, bvalue *v)
        -:  150:{
    #####:  151:    vm_error(vm, "type_error",
        -:  152:        "'%s' value is not callable", be_vtype2str(v));
    #####:  153:}
        -:  154:
        -:  155:/* Check that the return value is bool or raise an exception */
        -:  156:/* `obj` and `method` are only passed for error reporting */
    #####:  157:static void check_bool(bvm *vm, binstance *obj, const char *method)
        -:  158:{
    #####:  159:    if (!var_isbool(vm->top)) {
    #####:  160:        const char *name = str(be_instance_name(obj));
    #####:  161:        vm_error(vm, "type_error",
        -:  162:            "`%s::%s` return value error, the expected type is 'bool'",
        -:  163:            strlen(name) ? name : "<anonymous>", method);
        -:  164:    }
    #####:  165:}
        -:  166:
        -:  167:#if BE_USE_DEBUG_HOOK
    #####:  168:static void do_linehook(bvm *vm)
        -:  169:{
    #####:  170:    bcallframe *cf = vm->cf;
    #####:  171:    bclosure *cl = var_toobj(cf->func);
    #####:  172:    int pc = cast_int(vm->ip - cl->proto->code);
    #####:  173:    if (!pc || pc > cf->lineinfo->endpc) {
    #####:  174:        while (pc > cf->lineinfo->endpc)
    #####:  175:            cf->lineinfo++;
    #####:  176:        be_callhook(vm, BE_HOOK_LINE);
        -:  177:    } else {
    #####:  178:        blineinfo *linfo = cf->lineinfo;
    #####:  179:        blineinfo *base = cl->proto->lineinfo;
    #####:  180:        while (linfo > base && pc <= linfo[-1].endpc)
    #####:  181:            linfo--;
    #####:  182:        if (cf->lineinfo != linfo) {
    #####:  183:            cf->lineinfo = linfo;
    #####:  184:            be_callhook(vm, BE_HOOK_LINE);
        -:  185:        }
        -:  186:    }
    #####:  187:}
        -:  188:#endif
        -:  189:
        -:  190:/* Prepare the stack for the function/method call */
        -:  191:/* `func` is a pointer to the function/method on the stack, it contains the closure before call and the result after the call */
        -:  192:/* `nstackË‹ is the stack depth used by the function (determined by compiler), we add BE_STACK_FREE_MIN as a safety margin */
       11:  193:static void precall(bvm *vm, bvalue *func, int nstack, int mode)
        -:  194:{
        -:  195:    bcallframe *cf;
       11:  196:    int expan = nstack + BE_STACK_FREE_MIN; /* `expan` is the minimum required space on the stack */
       11:  197:    if (vm->stacktop < func + expan) {  /* do we have too little space left on the stack? */
        1:  198:        size_t fpos = func - vm->stack;  /* compute offset of `func` from base stack, in case stack is reallocated and base address changes */
        1:  199:        be_stack_expansion(vm, expan);  /* expand stack (vector object), warning stack address changes */
        1:  200:        func = vm->stack + fpos;  /* recompute `func` address with new stack address */
        -:  201:    }
       11:  202:    be_stack_push(vm, &vm->callstack, NULL);  /* push a NULL value on callstack */
       11:  203:    cf = be_stack_top(&vm->callstack);  /* get address of new callframe at top of callstack */
       11:  204:    cf->func = func - mode;
       11:  205:    cf->top = vm->top;  /* save previous stack top */
       11:  206:    cf->reg = vm->reg;  /* save previous stack base */
       11:  207:    vm->reg = func + 1;  /* new stack base is right after function */
       11:  208:    vm->top = vm->reg + nstack; /* new stack top is above the registers used by the function, so we donÂ´t mess with them */
       11:  209:    vm->cf = cf;  /* set new current callframe */
       11:  210:}
        -:  211:
        -:  212:/* Prepare call of closure, setting the instruction pointer (ip) */
        1:  213:static void push_closure(bvm *vm, bvalue *func, int nstack, int mode)
        -:  214:{
        1:  215:    bclosure *cl = var_toobj(func);
        1:  216:    precall(vm, func, nstack, mode);
        1:  217:    vm->cf->ip = vm->ip;
        1:  218:    vm->cf->status = NONE_FLAG;
        1:  219:    vm->ip = cl->proto->code;
        -:  220:#if BE_USE_DEBUG_HOOK
        1:  221:    vm->cf->lineinfo = cl->proto->lineinfo;
        1:  222:    be_callhook(vm, BE_HOOK_CALL);
        -:  223:#endif
        1:  224:}
        -:  225:
        9:  226:static void ret_native(bvm *vm)
        -:  227:{
        9:  228:    bcallframe *_cf = vm->cf;
        9:  229:    vm->reg = _cf->reg;
        9:  230:    vm->top = _cf->top;
        9:  231:    be_stack_pop(&vm->callstack);
        9:  232:    vm->cf = be_stack_top(&vm->callstack);
        9:  233:}
        -:  234:
    #####:  235:static bbool obj2bool(bvm *vm, bvalue *var)
        -:  236:{
    #####:  237:    binstance *obj = var_toobj(var);
    #####:  238:    bstring *tobool = str_literal(vm, "tobool");
        -:  239:    /* get operator method */
    #####:  240:    int type = be_instance_member(vm, obj, tobool, vm->top);
    #####:  241:    if (type != BE_NONE && type != BE_NIL) {
    #####:  242:        vm->top[1] = *var; /* move self to argv[0] */
    #####:  243:        be_dofunc(vm, vm->top, 1); /* call method 'tobool' */
        -:  244:        /* check the return value */
    #####:  245:        check_bool(vm, obj, "tobool");
    #####:  246:        return var_tobool(vm->top);
        -:  247:    }
    #####:  248:    return btrue;
        -:  249:}
        -:  250:
        7:  251:bbool be_value2bool(bvm *vm, bvalue *v)
        -:  252:{
        7:  253:    switch (var_basetype(v)) {
    #####:  254:    case BE_NIL:
    #####:  255:        return bfalse;
        7:  256:    case BE_BOOL:
        7:  257:        return var_tobool(v);
    #####:  258:    case BE_INT:
    #####:  259:        return val2bool(v->v.i);
    #####:  260:    case BE_REAL:
    #####:  261:        return val2bool(v->v.r);
    #####:  262:    case BE_INSTANCE:
    #####:  263:        return obj2bool(vm, v);
    #####:  264:    default:
    #####:  265:        return btrue;
        -:  266:    }
        -:  267:}
        -:  268:
    #####:  269:static void obj_method(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)
        -:  270:{
    #####:  271:    binstance *obj = var_toobj(o);
    #####:  272:    int type = be_instance_member_simple(vm, obj, attr, dst);
    #####:  273:    if (basetype(type) != BE_FUNCTION) {
    #####:  274:        vm_error(vm, "attribute_error",
        -:  275:            "the '%s' object has no method '%s'",
        -:  276:            str(be_instance_name(obj)), str(attr));
        -:  277:    }
    #####:  278:}
        -:  279:
    #####:  280:static int obj_attribute(bvm *vm, bvalue *o, bstring *attr, bvalue *dst)
        -:  281:{
    #####:  282:    binstance *obj = var_toobj(o);
    #####:  283:    int type = be_instance_member(vm, obj, attr, dst);
    #####:  284:    if (type == BE_NONE) {
    #####:  285:        vm_error(vm, "attribute_error",
        -:  286:            "the '%s' object has no attribute '%s'",
        -:  287:            str(be_instance_name(obj)), str(attr));
        -:  288:    }
    #####:  289:    return type;
        -:  290:}
        -:  291:
    #####:  292:static int class_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)
        -:  293:{
    #####:  294:    bstring *attr = var_tostr(c);
    #####:  295:    bclass *obj = var_toobj(o);
    #####:  296:    int type = be_class_member(vm, obj, attr, dst);
    #####:  297:    if (type == BE_NONE || type == BE_INDEX) {
    #####:  298:        vm_error(vm, "attribute_error",
        -:  299:            "the '%s' class has no static attribute '%s'",
        -:  300:            str(obj->name), str(attr));
        -:  301:    }
    #####:  302:    return type;
        -:  303:}
        -:  304:
    #####:  305:static int module_attribute(bvm *vm, bvalue *o, bvalue *c, bvalue *dst)
        -:  306:{
    #####:  307:    bstring *attr = var_tostr(c);
    #####:  308:    bmodule *module = var_toobj(o);
    #####:  309:    int type = be_module_attr(vm, module, attr, dst);
    #####:  310:    if (type == BE_NONE) {
    #####:  311:        vm_error(vm, "attribute_error",
        -:  312:            "module '%s' has no member '%s'",
        -:  313:            be_module_name(module), str(attr));
        -:  314:    }
    #####:  315:    return type;
        -:  316:}
        -:  317:
    #####:  318:static bbool object_eqop(bvm *vm,
        -:  319:    const char *op, bbool iseq, bvalue *a, bvalue *b)
        -:  320:{
    #####:  321:    binstance *o = var_toobj(a);
    #####:  322:    bvalue self = *a, other = *b;
    #####:  323:    bbool isself = var_isinstance(b) && o == var_toobj(b);
        -:  324:    /* first, try to call the overloaded operator of the object */
    #####:  325:    int type = be_instance_member(vm, o, be_newstr(vm, op), vm->top);
    #####:  326:    if (basetype(type) == BE_FUNCTION) { /* call method */
    #####:  327:        bvalue *top = vm->top;
    #####:  328:        top[1] = self;  /* move self to argv[0] */
    #####:  329:        top[2] = other; /* move other to argv[1] */
    #####:  330:        be_incrtop(vm); /* prevent collection results */
    #####:  331:        be_dofunc(vm, top, 2); /* call method 'item' */
    #####:  332:        be_stackpop(vm, 1);
    #####:  333:        check_bool(vm, o, op); /* check return value */
    #####:  334:        return var_tobool(vm->top); /* copy result to dst */
        -:  335:    }
        -:  336:    /* the default equal operation rule */
    #####:  337:    return iseq == isself; /* check object self */
        -:  338:}
        -:  339:
    #####:  340:static void object_binop(bvm *vm, const char *op, bvalue self, bvalue other)
        -:  341:{
    #####:  342:    bvalue *top = vm->top;
        -:  343:    /* get operator method (possible GC) */
    #####:  344:    obj_method(vm, &self, be_newstr(vm, op), vm->top);
    #####:  345:    top[1] = self; /* move self to argv[0] */
    #####:  346:    top[2] = other; /* move other to argv[1] */
    #####:  347:    be_incrtop(vm); /* prevent collection results */
    #####:  348:    be_dofunc(vm, top, 2); /* call method 'item' */
    #####:  349:    be_stackpop(vm, 1);
    #####:  350:}
        -:  351:
        -:  352:#define ins_binop(vm, op, ins) { \
        -:  353:    object_binop(vm, op, *RKB(), *RKC()); \
        -:  354:    reg = vm->reg; \
        -:  355:    *RA() = *vm->top; /* copy result to dst */ \
        -:  356:}
        -:  357:
    #####:  358:static void ins_unop(bvm *vm, const char *op, bvalue self)
        -:  359:{
    #####:  360:    bvalue *top = vm->top;
        -:  361:    /* get operator method (possible GC) */
    #####:  362:    obj_method(vm, &self, be_newstr(vm, op), vm->top);
    #####:  363:    top[1] = self; /* move self to argv[0] */
    #####:  364:    be_dofunc(vm, top, 1); /* call method 'item' */
    #####:  365:}
        -:  366:
        7:  367:bbool be_vm_iseq(bvm *vm, bvalue *a, bvalue *b)
        -:  368:{
       7*:  369:    equal_rule(==, btrue);
        -:  370:}
        -:  371:
    #####:  372:bbool be_vm_isneq(bvm *vm, bvalue *a, bvalue *b)
        -:  373:{
    #####:  374:    equal_rule(!=, bfalse);
        -:  375:}
        -:  376:
    #####:  377:bbool be_vm_islt(bvm *vm, bvalue *a, bvalue *b)
        -:  378:{
    #####:  379:    relop_rule(<);
        -:  380:}
        -:  381:
    #####:  382:bbool be_vm_isle(bvm *vm, bvalue *a, bvalue *b)
        -:  383:{
    #####:  384:    relop_rule(<=);
        -:  385:}
        -:  386:
    #####:  387:bbool be_vm_isgt(bvm *vm, bvalue *a, bvalue *b)
        -:  388:{
    #####:  389:    relop_rule(>);
        -:  390:}
        -:  391:
    #####:  392:bbool be_vm_isge(bvm *vm, bvalue *a, bvalue *b)
        -:  393:{
    #####:  394:    relop_rule(>=);
        -:  395:}
        -:  396:
    #####:  397:static void make_range(bvm *vm, bvalue lower, bvalue upper)
        -:  398:{
        -:  399:    /* get method 'item' (possible GC) */
    #####:  400:    int idx = be_builtin_find(vm, str_literal(vm, "range"));
    #####:  401:    bvalue *top = vm->top;
    #####:  402:    top[0] = *be_global_var(vm, idx);
    #####:  403:    top[1] = lower; /* move lower to argv[0] */
    #####:  404:    top[2] = upper; /* move upper to argv[1] */
    #####:  405:    vm->top += 3; /* prevent collection results */
    #####:  406:    be_dofunc(vm, top, 2); /* call method 'item' */
    #####:  407:    vm->top -= 3;
    #####:  408:}
        -:  409:
    #####:  410:static void connect_str(bvm *vm, bstring *a, bvalue *b)
        -:  411:{
        -:  412:    bstring *s;
    #####:  413:    if (var_isstr(b)) {
    #####:  414:        s = be_strcat(vm, a, var_tostr(b));
    #####:  415:        var_setstr(vm->top, s);
        -:  416:    } else {
    #####:  417:        *vm->top++ = *b;
    #####:  418:        be_val2str(vm, -1);
    #####:  419:        b = vm->top - 1;
    #####:  420:        s = be_strcat(vm, a, var_tostr(b));
    #####:  421:        var_setstr(b, s);
    #####:  422:        vm->top -= 1;
        -:  423:    }
    #####:  424:}
        -:  425:
        1:  426:BERRY_API bvm* be_vm_new(void)
        -:  427:{
        1:  428:    bvm *vm = be_os_malloc(sizeof(bvm));
        -:  429:    be_assert(vm != NULL);
        1:  430:    memset(vm, 0, sizeof(bvm)); /* clear all members */
        1:  431:    be_gc_init(vm);
        1:  432:    be_string_init(vm);
        1:  433:    be_stack_init(vm, &vm->callstack, sizeof(bcallframe));
        1:  434:    be_stack_init(vm, &vm->refstack, sizeof(binstance*));
        1:  435:    be_stack_init(vm, &vm->exceptstack, sizeof(struct bexecptframe));
        1:  436:    be_stack_init(vm, &vm->tracestack, sizeof(bcallsnapshot));
        1:  437:    vm->stack = be_malloc(vm, sizeof(bvalue) * BE_STACK_FREE_MIN);
        1:  438:    vm->stacktop = vm->stack + BE_STACK_FREE_MIN;
        1:  439:    vm->reg = vm->stack;
        1:  440:    vm->top = vm->reg;
        1:  441:    be_globalvar_init(vm);
        1:  442:    be_gc_setpause(vm, 1);
        1:  443:    be_loadlibs(vm);
        1:  444:    vm->compopt = 0;
        -:  445:#if BE_USE_OBSERVABILITY_HOOK
        -:  446:    vm->obshook = NULL;
        -:  447:#endif
        1:  448:    return vm;
        -:  449:}
        -:  450:
        1:  451:BERRY_API void be_vm_delete(bvm *vm)
        -:  452:{
        1:  453:    be_gc_deleteall(vm);
        1:  454:    be_string_deleteall(vm);
        1:  455:    be_stack_delete(vm, &vm->callstack);
        1:  456:    be_stack_delete(vm, &vm->refstack);
        1:  457:    be_stack_delete(vm, &vm->exceptstack);
        1:  458:    be_stack_delete(vm, &vm->tracestack);
        1:  459:    be_free(vm, vm->stack, (vm->stacktop - vm->stack) * sizeof(bvalue));
        1:  460:    be_globalvar_deinit(vm);
        -:  461:#if BE_USE_DEBUG_HOOK
        -:  462:    /* free native hook */
        1:  463:    if (var_istype(&vm->hook, BE_COMPTR))
    #####:  464:        be_free(vm, var_toobj(&vm->hook), sizeof(struct bhookblock));
        -:  465:#endif
        -:  466:    /* free VM structure */
        1:  467:    be_os_free(vm);
        1:  468:}
        -:  469:
        1:  470:static void vm_exec(bvm *vm)
        -:  471:{
        -:  472:    bclosure *clos;
        -:  473:    bvalue *ktab, *reg;
        -:  474:    binstruction ins;
        1:  475:    vm->cf->status |= BASE_FRAME;
        1:  476:newframe: /* a new call frame */
        -:  477:    be_assert(var_isclosure(vm->cf->func));
        1:  478:    clos = var_toobj(vm->cf->func);  /* `clos` is the current function/closure */
        1:  479:    ktab = clos->proto->ktab;  /* `ktab` is the current constant table */
        1:  480:    reg = vm->reg;  /* `reg` is the current stack base for the callframe */
      50*:  481:    vm_exec_loop() {
    #####:  482:        opcase(LDNIL): {
    #####:  483:            var_setnil(RA());
    #####:  484:            dispatch();
        -:  485:        }
    #####:  486:        opcase(LDBOOL): {
    #####:  487:            bvalue *v = RA();
    #####:  488:            var_setbool(v, IGET_RKB(ins));
    #####:  489:            if (IGET_RKC(ins)) { /* skip next instruction */
    #####:  490:                vm->ip += 1;
        -:  491:            }
    #####:  492:            dispatch();
        -:  493:        }
       17:  494:        opcase(LDINT): {
       17:  495:            bvalue *v = RA();
       17:  496:            var_setint(v, IGET_sBx(ins));
       17:  497:            dispatch();
        -:  498:        }
    #####:  499:        opcase(LDCONST): {
    #####:  500:            bvalue *dst = RA();
    #####:  501:            *dst = ktab[IGET_Bx(ins)];
    #####:  502:            dispatch();
        -:  503:        }
       11:  504:        opcase(GETGBL): {
       11:  505:            bvalue *v = RA();
       11:  506:            int idx = IGET_Bx(ins);
       11:  507:            *v = *be_global_var(vm, idx);
       11:  508:            dispatch();
        -:  509:        }
    #####:  510:        opcase(GETNGBL): {  /* get Global by name */
    #####:  511:            bvalue *v = RA();
    #####:  512:            bvalue *b = RKB();
    #####:  513:            if (var_isstr(b)) {
    #####:  514:                bstring *name = var_tostr(b);
    #####:  515:                int idx = be_global_find(vm, name);
    #####:  516:                if (idx > -1) {
    #####:  517:                    *v = *be_global_var(vm, idx);
        -:  518:                } else {
    #####:  519:                    vm_error(vm, "attribute_error", "'%s' undeclared", str(name));
        -:  520:                }
        -:  521:            } else {
    #####:  522:                vm_error(vm, "internal_error", "global name must be a string");
        -:  523:            }
    #####:  524:            dispatch();
        -:  525:        }
    #####:  526:        opcase(SETNGBL): {  /* set Global by name */
    #####:  527:            bvalue *v = RA();
    #####:  528:            bvalue *b = RKB();
    #####:  529:            if (var_isstr(b)) {
    #####:  530:                bstring *name = var_tostr(b);
    #####:  531:                int idx = be_global_new(vm, name);
    #####:  532:                *be_global_var(vm, idx) = *v;
        -:  533:            } else {
    #####:  534:                vm_error(vm, "internal_error", "global name must be a string");
        -:  535:            }
    #####:  536:            dispatch();
        -:  537:        }
        1:  538:        opcase(SETGBL): {
        1:  539:            bvalue *v = RA();
        1:  540:            int idx = IGET_Bx(ins);
        1:  541:            *be_global_var(vm, idx) = *v;
        1:  542:            dispatch();
        -:  543:        }
    #####:  544:        opcase(GETUPV): {
    #####:  545:            bvalue *v = RA();
    #####:  546:            int idx = IGET_Bx(ins);
        -:  547:            be_assert(*clos->upvals != NULL);
    #####:  548:            *v = *clos->upvals[idx]->value;
    #####:  549:            dispatch();
        -:  550:        }
    #####:  551:        opcase(SETUPV): {
    #####:  552:            bvalue *v = RA();
    #####:  553:            int idx = IGET_Bx(ins);
        -:  554:            be_assert(*clos->upvals != NULL);
    #####:  555:            *clos->upvals[idx]->value = *v;
    #####:  556:            dispatch();
        -:  557:        }
    #####:  558:        opcase(MOVE): {
    #####:  559:            bvalue *dst = RA();
    #####:  560:            *dst = *RKB();
    #####:  561:            dispatch();
        -:  562:        }
    #####:  563:        opcase(ADD): {
    #####:  564:            bvalue *dst = RA(), *a = RKB(), *b = RKC();
    #####:  565:            if (var_isint(a) && var_isint(b)) {
    #####:  566:                var_setint(dst, ibinop(+, a, b));
    #####:  567:            } else if (var_isnumber(a) && var_isnumber(b)) {
    #####:  568:                breal x = var2real(a), y = var2real(b);
    #####:  569:                var_setreal(dst, x + y);
    #####:  570:            } else if (var_isstr(a) && var_isstr(b)) { /* strcat */
    #####:  571:                bstring *s = be_strcat(vm, var_tostr(a), var_tostr(b));
    #####:  572:                reg = vm->reg;
    #####:  573:                dst = RA();
    #####:  574:                var_setstr(dst, s);
    #####:  575:            } else if (var_isinstance(a)) {
    #####:  576:                ins_binop(vm, "+", ins);
        -:  577:            } else {
    #####:  578:                binop_error(vm, "+", a, b);
        -:  579:            }
    #####:  580:            dispatch();
        -:  581:        }
    #####:  582:        opcase(SUB): {
    #####:  583:            bvalue *dst = RA(), *a = RKB(), *b = RKC();
    #####:  584:            if (var_isint(a) && var_isint(b)) {
    #####:  585:                var_setint(dst, ibinop(-, a, b));
    #####:  586:            } else if (var_isnumber(a) && var_isnumber(b)) {
    #####:  587:                breal x = var2real(a), y = var2real(b);
    #####:  588:                var_setreal(dst, x - y);
    #####:  589:            } else if (var_isinstance(a)) {
    #####:  590:                ins_binop(vm, "-", ins);
        -:  591:            } else {
    #####:  592:                binop_error(vm, "-", a, b);
        -:  593:            }
    #####:  594:            dispatch();
        -:  595:        }
    #####:  596:        opcase(MUL): {
    #####:  597:            bvalue *dst = RA(), *a = RKB(), *b = RKC();
    #####:  598:            if (var_isint(a) && var_isint(b)) {
    #####:  599:                var_setint(dst, ibinop(*, a, b));
    #####:  600:            } else if (var_isnumber(a) && var_isnumber(b)) {
    #####:  601:                breal x = var2real(a), y = var2real(b);
    #####:  602:                var_setreal(dst, x * y);
    #####:  603:            } else if (var_isinstance(a)) {
    #####:  604:                ins_binop(vm, "*", ins);
        -:  605:            } else {
    #####:  606:                binop_error(vm, "*", a, b);
        -:  607:            }
    #####:  608:            dispatch();
        -:  609:        }
    #####:  610:        opcase(DIV): {
    #####:  611:            bvalue *dst = RA(), *a = RKB(), *b = RKC();
    #####:  612:            if (var_isint(a) && var_isint(b)) {
    #####:  613:                bint x = var_toint(a), y = var_toint(b);
    #####:  614:                if (y == 0) {
    #####:  615:                    vm_error(vm, "divzero_error", "division by zero");
        -:  616:                } else {
    #####:  617:                    var_setint(dst, x / y);
        -:  618:                }
    #####:  619:            } else if (var_isnumber(a) && var_isnumber(b)) {
    #####:  620:                breal x = var2real(a), y = var2real(b);
    #####:  621:                if (y == cast(breal, 0)) {
    #####:  622:                    vm_error(vm, "divzero_error", "division by zero");
        -:  623:                }
    #####:  624:                var_setreal(dst, x / y);
    #####:  625:            } else if (var_isinstance(a)) {
    #####:  626:                ins_binop(vm, "/", ins);
        -:  627:            } else {
    #####:  628:                binop_error(vm, "/", a, b);
        -:  629:            }
    #####:  630:            dispatch();
        -:  631:        }
    #####:  632:        opcase(MOD): {
    #####:  633:            bvalue *dst = RA(), *a = RKB(), *b = RKC();
    #####:  634:            if (var_isint(a) && var_isint(b)) {
    #####:  635:                var_setint(dst, ibinop(%, a, b));
    #####:  636:            } else if (var_isnumber(a) && var_isnumber(b)) {
    #####:  637:                var_setreal(dst, mathfunc(fmod)(var_toreal(a), var_toreal(b)));
    #####:  638:            } else if (var_isinstance(a)) {
    #####:  639:                ins_binop(vm, "%", ins);
        -:  640:            } else {
    #####:  641:                binop_error(vm, "%", a, b);
        -:  642:            }
    #####:  643:            dispatch();
        -:  644:        }
    #####:  645:        opcase(LT): {
    #####:  646:            bbool res = be_vm_islt(vm, RKB(), RKC());
        -:  647:            bvalue *dst;
    #####:  648:            reg = vm->reg;
    #####:  649:            dst = RA();
    #####:  650:            var_setbool(dst, res);
    #####:  651:            dispatch();
        -:  652:        }
    #####:  653:        opcase(LE): {
    #####:  654:            bbool res = be_vm_isle(vm, RKB(), RKC());
        -:  655:            bvalue *dst;
    #####:  656:            reg = vm->reg;
    #####:  657:            dst = RA();
    #####:  658:            var_setbool(dst, res);
    #####:  659:            dispatch();
        -:  660:        }
        7:  661:        opcase(EQ): {
       7*:  662:            bbool res = be_vm_iseq(vm, RKB(), RKC());
        -:  663:            bvalue *dst;
        7:  664:            reg = vm->reg;
        7:  665:            dst = RA();
        7:  666:            var_setbool(dst, res);
        7:  667:            dispatch();
        -:  668:        }
    #####:  669:        opcase(NE): {
    #####:  670:            bbool res = be_vm_isneq(vm, RKB(), RKC());
        -:  671:            bvalue *dst;
    #####:  672:            reg = vm->reg;
    #####:  673:            dst = RA();
    #####:  674:            var_setbool(dst, res);
    #####:  675:            dispatch();
        -:  676:        }
    #####:  677:        opcase(GT): {
    #####:  678:            bbool res = be_vm_isgt(vm, RKB(), RKC());
        -:  679:            bvalue *dst;
    #####:  680:            reg = vm->reg;
    #####:  681:            dst = RA();
    #####:  682:            var_setbool(dst, res);
    #####:  683:            dispatch();
        -:  684:        }
    #####:  685:        opcase(GE): {
    #####:  686:            bbool res = be_vm_isge(vm, RKB(), RKC());
        -:  687:            bvalue *dst;
    #####:  688:            reg = vm->reg;
    #####:  689:            dst = RA();
    #####:  690:            var_setbool(dst, res);
    #####:  691:            dispatch();
        -:  692:        }
    #####:  693:        opcase(CONNECT): {
    #####:  694:            bvalue *a = RKB(), *b = RKC();
    #####:  695:            if (var_isint(a) && var_isint(b)) {
    #####:  696:                make_range(vm, *RKB(), *RKC());
    #####:  697:            } else if (var_isstr(a)) {
    #####:  698:                connect_str(vm, var_tostr(a), b);
    #####:  699:            } else if (var_isinstance(a)) {
    #####:  700:                object_binop(vm, "..", *RKB(), *RKC());
        -:  701:            } else {
    #####:  702:                binop_error(vm, "..", RKB(), RKC());
        -:  703:            }
    #####:  704:            reg = vm->reg;
    #####:  705:            *RA() = *vm->top; /* copy result to R(A) */
    #####:  706:            dispatch();
        -:  707:        }
        2:  708:        opcase(AND): {
       2*:  709:            bitwise_block(&);
        2:  710:            dispatch();
        -:  711:        }
        2:  712:        opcase(OR): {
       2*:  713:            bitwise_block(|);
        2:  714:            dispatch();
        -:  715:        }
        2:  716:        opcase(XOR): {
       2*:  717:            bitwise_block(^);
        2:  718:            dispatch();
        -:  719:        }
    #####:  720:        opcase(SHL): {
    #####:  721:            bitwise_block(<<);
    #####:  722:            dispatch();
        -:  723:        }
    #####:  724:        opcase(SHR): {
    #####:  725:            bitwise_block(>>);
    #####:  726:            dispatch();
        -:  727:        }
    #####:  728:        opcase(NEG): {
    #####:  729:            bvalue *dst = RA(), *a = RKB();
    #####:  730:            if (var_isint(a)) {
    #####:  731:                var_setint(dst, -a->v.i);
    #####:  732:            } else if (var_isreal(a)) {
    #####:  733:                var_setreal(dst, -a->v.r);
    #####:  734:            } else if (var_isinstance(a)) {
    #####:  735:                ins_unop(vm, "-*", *RKB());
    #####:  736:                reg = vm->reg;
    #####:  737:                *RA() = *vm->top; /* copy result to dst */
        -:  738:            } else {
    #####:  739:                unop_error(vm, "-", a);
        -:  740:            }
    #####:  741:            dispatch();
        -:  742:        }
        1:  743:        opcase(FLIP): {
       1*:  744:            bvalue *dst = RA(), *a = RKB();
        1:  745:            if (var_isint(a)) {
        1:  746:                var_setint(dst, -a->v.i);
    #####:  747:            } else if (var_isinstance(a)) {
    #####:  748:                ins_unop(vm, "~", *RKB());
    #####:  749:                reg = vm->reg;
    #####:  750:                *RA() = *vm->top; /* copy result to dst */
        -:  751:            } else {
    #####:  752:                unop_error(vm, "~", a);
        -:  753:            }
        1:  754:            dispatch();
        -:  755:        }
    #####:  756:        opcase(JMP): {
    #####:  757:            vm->ip += IGET_sBx(ins);
    #####:  758:            dispatch();
        -:  759:        }
    #####:  760:        opcase(JMPT): {
    #####:  761:            if (be_value2bool(vm, RA())) {
    #####:  762:                vm->ip += IGET_sBx(ins);
        -:  763:            }
    #####:  764:            dispatch();
        -:  765:        }
    #####:  766:        opcase(JMPF): {
    #####:  767:            if (!be_value2bool(vm, RA())) {
    #####:  768:                vm->ip += IGET_sBx(ins);
        -:  769:            }
    #####:  770:            dispatch();
        -:  771:        }
    #####:  772:        opcase(CLOSURE): {
        -:  773:            bvalue *dst;
    #####:  774:            bproto *p = clos->proto->ptab[IGET_Bx(ins)];
    #####:  775:            bclosure *cl = be_newclosure(vm, p->nupvals);
    #####:  776:            cl->proto = p;
    #####:  777:            reg = vm->reg;
    #####:  778:            dst = RA();
    #####:  779:            var_setclosure(dst, cl);
    #####:  780:            be_initupvals(vm, cl);
    #####:  781:            dispatch();
        -:  782:        }
    #####:  783:        opcase(CLASS): {
    #####:  784:            bclass *c = var_toobj(ktab + IGET_Bx(ins));
    #####:  785:            be_class_upvalue_init(vm, c);
    #####:  786:            dispatch();
        -:  787:        }
    #####:  788:        opcase(GETMBR): {
    #####:  789:            bvalue *a = RA(), *b = RKB(), *c = RKC();
    #####:  790:            if (var_isinstance(b) && var_isstr(c)) {
    #####:  791:                obj_attribute(vm, b, var_tostr(c), a);
    #####:  792:                reg = vm->reg;
    #####:  793:            } else if (var_isclass(b) && var_isstr(c)) {
    #####:  794:                class_attribute(vm, b, c, a);
    #####:  795:                reg = vm->reg;
    #####:  796:            } else if (var_ismodule(b) && var_isstr(c)) {
    #####:  797:                module_attribute(vm, b, c, a);
    #####:  798:                reg = vm->reg;
        -:  799:            } else {
    #####:  800:                attribute_error(vm, "attribute", b, c);
        -:  801:            }
    #####:  802:            dispatch();
        -:  803:        }
    #####:  804:        opcase(GETMET): {
    #####:  805:            bvalue *a = RA(), *b = RKB(), *c = RKC();
    #####:  806:            if (var_isinstance(b) && var_isstr(c)) {
    #####:  807:                binstance *obj = var_toobj(b);
    #####:  808:                int type = obj_attribute(vm, b, var_tostr(c), a);
    #####:  809:                reg = vm->reg;
    #####:  810:                if (basetype(type) == BE_FUNCTION) {
        -:  811:                    /* check if the object is a superinstance, if so get the lowest possible subclass */
    #####:  812:                    while (obj->sub) {
    #####:  813:                        obj = obj->sub;
        -:  814:                    }
    #####:  815:                    var_setinstance(&a[1], obj);  /* replace superinstance by lowest subinstance */
        -:  816:                } else {
    #####:  817:                    vm_error(vm, "attribute_error",
        -:  818:                        "class '%s' has no method '%s'",
        -:  819:                        str(be_instance_name(obj)), str(var_tostr(c)));
        -:  820:                }
    #####:  821:            } else if (var_ismodule(b) && var_isstr(c)) {
    #####:  822:                module_attribute(vm, b, c, &a[1]);
    #####:  823:                var_settype(a, NOT_METHOD);
        -:  824:            } else {
    #####:  825:                attribute_error(vm, "method", b, c);
        -:  826:            }
    #####:  827:            dispatch();
        -:  828:        }
    #####:  829:        opcase(SETMBR): {
    #####:  830:            bvalue *a = RA(), *b = RKB(), *c = RKC();
    #####:  831:            if (var_isinstance(a) && var_isstr(b)) {
    #####:  832:                binstance *obj = var_toobj(a);
    #####:  833:                bstring *attr = var_tostr(b);
    #####:  834:                if (!be_instance_setmember(vm, obj, attr, c)) {
    #####:  835:                    vm_error(vm, "attribute_error",
        -:  836:                        "class '%s' cannot assign to attribute '%s'",
        -:  837:                        str(be_instance_name(obj)), str(attr));
        -:  838:                }
    #####:  839:                dispatch();
        -:  840:            }
    #####:  841:            if (var_isclass(a) && var_isstr(b)) {
    #####:  842:                bclass *obj = var_toobj(a);
    #####:  843:                bstring *attr = var_tostr(b);
    #####:  844:                if (!be_class_setmember(vm, obj, attr, c)) {
    #####:  845:                    vm_error(vm, "attribute_error",
        -:  846:                        "class '%s' cannot assign to static attribute '%s'",
        -:  847:                        str(be_class_name(obj)), str(attr));
        -:  848:                }
    #####:  849:                dispatch();
        -:  850:            }
    #####:  851:            if (var_ismodule(a) && var_isstr(b)) {
    #####:  852:                bmodule *obj = var_toobj(a);
    #####:  853:                bstring *attr = var_tostr(b);
    #####:  854:                if (be_module_setmember(vm, obj, attr, c)) {
    #####:  855:                    dispatch();
        -:  856:                } else {
        -:  857:                    // fall through exception below
        -:  858:                }
        -:  859:            }
    #####:  860:            attribute_error(vm, "writable attribute", a, b);
    #####:  861:            dispatch();
        -:  862:        }
    #####:  863:        opcase(GETIDX): {
    #####:  864:            bvalue *b = RKB(), *c = RKC();
    #####:  865:            if (var_isinstance(b)) {
    #####:  866:                bvalue *top = vm->top;
        -:  867:                /* get method 'item' */
    #####:  868:                obj_method(vm, b, str_literal(vm, "item"), vm->top);
    #####:  869:                top[1] = *b; /* move object to argv[0] */
    #####:  870:                top[2] = *c; /* move key to argv[1] */
    #####:  871:                vm->top += 3;   /* prevent collection results */
    #####:  872:                be_dofunc(vm, top, 2); /* call method 'item' */
    #####:  873:                vm->top -= 3;
    #####:  874:                reg = vm->reg;
    #####:  875:                *RA() = *vm->top;   /* copy result to R(A) */
    #####:  876:            } else if (var_isstr(b)) {
    #####:  877:                bstring *s = be_strindex(vm, var_tostr(b), c);
    #####:  878:                reg = vm->reg;
    #####:  879:                var_setstr(RA(), s);
        -:  880:            } else {
    #####:  881:                vm_error(vm, "type_error",
        -:  882:                    "value '%s' does not support subscriptable",
        -:  883:                    be_vtype2str(b));
        -:  884:            }
    #####:  885:            dispatch();
        -:  886:        }
    #####:  887:        opcase(SETIDX): {
    #####:  888:            bvalue *a = RA(), *b = RKB(), *c = RKC();
    #####:  889:            if (var_isinstance(a)) {
    #####:  890:                bvalue *top = vm->top;
        -:  891:                /* get method 'setitem' */
    #####:  892:                obj_method(vm, a, str_literal(vm, "setitem"), vm->top);
    #####:  893:                top[1] = *a; /* move object to argv[0] */
    #####:  894:                top[2] = *b; /* move key to argv[1] */
    #####:  895:                top[3] = *c; /* move src to argv[2] */
    #####:  896:                vm->top += 4;
    #####:  897:                be_dofunc(vm, top, 3); /* call method 'setitem' */
    #####:  898:                vm->top -= 4;
    #####:  899:                reg = vm->reg;
        -:  900:            } else {
    #####:  901:                vm_error(vm, "type_error",
        -:  902:                    "value '%s' does not support index assignment",
        -:  903:                    be_vtype2str(a));
        -:  904:            }
    #####:  905:            dispatch();
        -:  906:        }
    #####:  907:        opcase(SETSUPER): {
    #####:  908:            bvalue *a = RA(), *b = RKB();
    #####:  909:            if (var_isclass(a) && var_isclass(b)) {
    #####:  910:                bclass *obj = var_toobj(a);
    #####:  911:                be_class_setsuper(obj, var_toobj(b));
        -:  912:            } else {
    #####:  913:                vm_error(vm, "type_error",
        -:  914:                    "value '%s' does not support set super",
        -:  915:                    be_vtype2str(b));
        -:  916:            }
    #####:  917:            dispatch();
        -:  918:        }
    #####:  919:        opcase(CLOSE): {
    #####:  920:            be_upvals_close(vm, RA());
    #####:  921:            dispatch();
        -:  922:        }
    #####:  923:        opcase(IMPORT): {
    #####:  924:            bvalue *b = RKB();
    #####:  925:            if (var_isstr(b)) {
    #####:  926:                bstring *name = var_tostr(b);
    #####:  927:                int res = be_module_load(vm, name);
    #####:  928:                reg = vm->reg;
        -:  929:                switch (res) {
    #####:  930:                case BE_OK: /* find the module */
    #####:  931:                    be_stackpop(vm, 1);
    #####:  932:                    *RA() = *vm->top;
    #####:  933:                    break;
    #####:  934:                case BE_EXCEPTION: /* pop the exception value and message */
    #####:  935:                    be_pop(vm, 2);
    #####:  936:                    be_throw(vm, BE_EXCEPTION);
    #####:  937:                    break;
    #####:  938:                default:
    #####:  939:                    vm_error(vm, "import_error", "module '%s' not found", str(name));
        -:  940:                }
        -:  941:            } else {
    #####:  942:                vm_error(vm, "type_error",
        -:  943:                    "import '%s' does not support import",
        -:  944:                    be_vtype2str(b));
        -:  945:            }
    #####:  946:            dispatch();
        -:  947:        }
    #####:  948:        opcase(CATCH): {
    #####:  949:            bvalue *base = RA(), *top = vm->top;
    #####:  950:            int i = 0, ecnt = IGET_RKB(ins), vcnt = IGET_RKC(ins);
    #####:  951:            while (i < ecnt && !be_vm_iseq(vm, top, base + i)) {
    #####:  952:                ++i;
        -:  953:            }
    #####:  954:            if (!ecnt || i < ecnt) { /* exception catched */
    #####:  955:                base = RA(), top = vm->top;
    #####:  956:                for (i = 0; i < vcnt; ++i) {
    #####:  957:                    *base++ = *top++;
        -:  958:                }
    #####:  959:                vm->ip += 1; /* skip next instruction */
        -:  960:            }
    #####:  961:            dispatch();
        -:  962:        }
    #####:  963:        opcase(RAISE): {
    #####:  964:            if (IGET_RA(ins) < 2) {  /* A==2 means no arguments are passed to RAISE, i.e. rethrow with current exception */
    #####:  965:                bvalue *top = vm->top;
    #####:  966:                top[0] = *RKB(); /* push the exception value to top */
    #####:  967:                if (IGET_RA(ins)) { /* has exception argument? */
    #####:  968:                    top[1] = *RKC(); /* push the exception argument to top + 1 */
        -:  969:                } else {
    #####:  970:                    var_setnil(top + 1);
        -:  971:                }
    #####:  972:                be_save_stacktrace(vm);
        -:  973:            }
    #####:  974:            be_throw(vm, BE_EXCEPTION); /* throw / rethrow the exception */
    #####:  975:            dispatch();
        -:  976:        }
    #####:  977:        opcase(EXBLK): {
    #####:  978:            if (!IGET_RA(ins)) {
    #####:  979:                be_except_block_setup(vm);
    #####:  980:                if (be_setjmp(vm->errjmp->b)) {
    #####:  981:                    be_except_block_resume(vm);
    #####:  982:                    goto newframe;
        -:  983:                }
    #####:  984:                reg = vm->reg;
        -:  985:            } else {
    #####:  986:                be_except_block_close(vm, IGET_Bx(ins));
        -:  987:            }
    #####:  988:            dispatch();
        -:  989:        }
        7:  990:        opcase(CALL): {
        7:  991:            bvalue *var = RA();  /* `var` is the register for the call followed by arguments */
        7:  992:            int mode = 0, argc = IGET_RKB(ins);  /* B contains number of arguments pushed on stack */
        7:  993:        recall: /* goto: instantiation class and call constructor */
        7:  994:            switch (var_type(var)) {
    #####:  995:            case NOT_METHOD:
    #####:  996:                var[0] = var[1];
    #####:  997:                ++var, --argc, mode = 1;
    #####:  998:                goto recall;
    #####:  999:            case BE_CLASS:
    #####: 1000:                if (be_class_newobj(vm, var_toobj(var), var, ++argc, mode)) {  /* instanciate object and find constructor */
    #####: 1001:                    reg = vm->reg + mode;  /* constructor found */
    #####: 1002:                    mode = 0;
    #####: 1003:                    var = RA() + 1; /* to next register */
    #####: 1004:                    goto recall; /* call constructor */
        -: 1005:                }
    #####: 1006:                break;
    #####: 1007:            case BE_INSTANCE: {
    #####: 1008:                bvalue *v = var + argc++, temp;
        -: 1009:                /* load the '()' method to `temp' */
    #####: 1010:                obj_method(vm, var, str_literal(vm, "()"), &temp);
    #####: 1011:                for (; v >= var; --v) v[1] = v[0];
    #####: 1012:                *var = temp;
    #####: 1013:                goto recall; /* call '()' method */
        -: 1014:            }
    #####: 1015:            case BE_CLOSURE: {
        -: 1016:                // bvalue *v, *end;
        -: 1017:                // bproto *proto = var2cl(var)->proto;  /* get proto for closure */
        -: 1018:                // push_closure(vm, var, proto->nstack, mode);  /* prepare stack for closure */
        -: 1019:                // reg = vm->reg;  /* `reg` has changed, now new base register */
        -: 1020:                // v = reg + argc;  /* end of provided arguments */
        -: 1021:                // end = reg + proto->argc;  /* end of expected arguments */
        -: 1022:                // for (; v < end; ++v) {  /* set all not provided arguments to nil */
        -: 1023:                //     var_setnil(v);
        -: 1024:                // }
        -: 1025:                // if (proto->varg) {  /* there are vararg at the last argument, build the list */
        -: 1026:                //     /* code below uses mostly low-level calls for performance */
        -: 1027:                //     be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */
        -: 1028:                //     bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */
        -: 1029:                //     vm->top = v;  /* move top of stack right after last argument */
        -: 1030:                //     be_newobject(vm, "list");  /* this creates 2 objects on stack: list instance, BE_LIST object */
        -: 1031:                //     blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */
        -: 1032:                //     v = reg + proto->argc - 1;  /* last argument */
        -: 1033:                //     for (; v < reg + argc; v++) {
        -: 1034:                //         be_list_push(vm, list, v); /* push all varargs into list */       
        -: 1035:                //     }
        -: 1036:                //     *(reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */
        -: 1037:                //     vm->top = top_save;  /* restore top of stack pointer */
        -: 1038:                // }
    #####: 1039:                prep_closure(vm, var, argc, mode);
    #####: 1040:                reg = vm->reg;  /* `reg` has changed, now new base register */
    #####: 1041:                goto newframe;  /* continue execution of the closure */
        -: 1042:            }
    #####: 1043:            case BE_NTVCLOS: {
    #####: 1044:                bntvclos *f = var_toobj(var);
    #####: 1045:                push_native(vm, var, argc, mode);
    #####: 1046:                f->f(vm); /* call C primitive function */
    #####: 1047:                ret_native(vm);
    #####: 1048:                break;
        -: 1049:            }
        7: 1050:            case BE_NTVFUNC: {
        7: 1051:                bntvfunc f = var_tontvfunc(var);
        7: 1052:                push_native(vm, var, argc, mode);
        7: 1053:                f(vm); /* call C primitive function */
        6: 1054:                ret_native(vm);
        6: 1055:                break;
        -: 1056:            }
    #####: 1057:            case BE_MODULE: {
        -: 1058:                bvalue attr;
    #####: 1059:                var_setstr(&attr, str_literal(vm, "()"));
    #####: 1060:                module_attribute(vm, var, &attr, var);  /* exception if not found */
    #####: 1061:                goto recall; /* call '()' method */
        -: 1062:                break;
        -: 1063:            }
    #####: 1064:            default:
    #####: 1065:                call_error(vm, var);
        -: 1066:            }
        6: 1067:            reg = vm->reg;
        6: 1068:            dispatch();
        -: 1069:        }
    #####: 1070:        opcase(RET): {
        -: 1071:            bcallframe *cf;
        -: 1072:            bvalue *ret;
        -: 1073:#if BE_USE_DEBUG_HOOK
    #####: 1074:            be_callhook(vm, BE_HOOK_RET);
        -: 1075:#endif
    #####: 1076:            cf = vm->cf;
    #####: 1077:            ret = vm->cf->func;
        -: 1078:            /* copy return value */
    #####: 1079:            if (IGET_RA(ins)) {
    #####: 1080:                *ret = *RKB();
        -: 1081:            } else {
    #####: 1082:                var_setnil(ret);
        -: 1083:            }
    #####: 1084:            vm->reg = cf->reg;
    #####: 1085:            vm->top = cf->top;
    #####: 1086:            vm->ip = cf->ip;
    #####: 1087:            be_stack_pop(&vm->callstack); /* pop don't delete */
    #####: 1088:            if (cf->status & BASE_FRAME) { /* entrance function */
    #####: 1089:                bstack *cs = &vm->callstack;
    #####: 1090:                if (!be_stack_isempty(cs)) {
    #####: 1091:                    vm->cf = be_stack_top(cs);
        -: 1092:                }
    #####: 1093:                return;
        -: 1094:            }
    #####: 1095:            vm->cf = be_stack_top(&vm->callstack);
    #####: 1096:            goto newframe;
        -: 1097:        }
        -: 1098:    }
        -: 1099:}
        -: 1100:
        1: 1101:static void prep_closure(bvm *vm, bvalue *reg, int argc, int mode)
        -: 1102:{
        -: 1103:    bvalue *v, *end;
        1: 1104:    bproto *proto = var2cl(reg)->proto;
        1: 1105:    push_closure(vm, reg, proto->nstack, mode);
        1: 1106:    v = vm->reg + argc;
        1: 1107:    end = vm->reg + proto->argc;
        2: 1108:    for (; v <= end; ++v) {
        1: 1109:        var_setnil(v);
        -: 1110:    }
        1: 1111:    if (proto->varg) {  /* there are vararg at the last argument, build the list */
        -: 1112:        /* code below uses mostly low-level calls for performance */
    #####: 1113:        be_stack_require(vm, argc + 2);   /* make sure we don't overflow the stack */
    #####: 1114:        bvalue *top_save = vm->top;  /* save original stack, we need fresh slots to create the 'list' instance */
    #####: 1115:        vm->top = v;  /* move top of stack right after last argument */
    #####: 1116:        be_newobject(vm, "list");  /* this creates 2 objects on stack: list instance, BE_LIST object */
    #####: 1117:        blist *list = var_toobj(vm->top-1);  /* get low-level BE_LIST structure */
    #####: 1118:        v = vm->reg + proto->argc - 1;  /* last argument */
    #####: 1119:        for (; v < vm->reg + argc; v++) {
    #####: 1120:            be_list_push(vm, list, v); /* push all varargs into list */       
        -: 1121:        }
    #####: 1122:        *(vm->reg + proto->argc - 1) = *(vm->top-2);  /* change the vararg argument to now contain the list instance */
    #####: 1123:        vm->top = top_save;  /* restore top of stack pointer */
        -: 1124:    }
        1: 1125:}
        -: 1126:
        1: 1127:static void do_closure(bvm *vm, bvalue *reg, int argc)
        -: 1128:{
        -: 1129:    // bvalue *v, *end;
        -: 1130:    // bproto *proto = var2cl(reg)->proto;
        -: 1131:    // push_closure(vm, reg, proto->nstack, 0);
        -: 1132:    // v = vm->reg + argc;
        -: 1133:    // end = vm->reg + proto->argc;
        -: 1134:    // for (; v <= end; ++v) {
        -: 1135:    //     var_setnil(v);
        -: 1136:    // }
        1: 1137:    prep_closure(vm, reg, argc, 0);
        1: 1138:    vm_exec(vm);
    #####: 1139:}
        -: 1140:
    #####: 1141:static void do_ntvclos(bvm *vm, bvalue *reg, int argc)
        -: 1142:{
    #####: 1143:    bntvclos *f = var_toobj(reg);
    #####: 1144:    push_native(vm, reg, argc, 0);
    #####: 1145:    f->f(vm); /* call C primitive function */
    #####: 1146:    ret_native(vm);
    #####: 1147:}
        -: 1148:
        3: 1149:static void do_ntvfunc(bvm *vm, bvalue *reg, int argc)
        -: 1150:{
        3: 1151:    bntvfunc f = var_tontvfunc(reg);
        3: 1152:    push_native(vm, reg, argc, 0);
        3: 1153:    f(vm); /* call C primitive function */
        3: 1154:    ret_native(vm);
        3: 1155:}
        -: 1156:
        1: 1157:static void do_class(bvm *vm, bvalue *reg, int argc)
        -: 1158:{
        1: 1159:    if (be_class_newobj(vm, var_toobj(reg), reg, ++argc, 0)) {
        1: 1160:        be_incrtop(vm);
        1: 1161:        be_dofunc(vm, reg + 1, argc);
        1: 1162:        be_stackpop(vm, 1);
        -: 1163:    }
        1: 1164:}
        -: 1165:
        5: 1166:void be_dofunc(bvm *vm, bvalue *v, int argc)
        -: 1167:{
        -: 1168:    be_assert(vm->reg <= v && v < vm->stacktop);
        -: 1169:    be_assert(vm->stack <= vm->reg && vm->reg < vm->stacktop);
        5: 1170:    switch (var_type(v)) {
        1: 1171:    case BE_CLASS: do_class(vm, v, argc); break;
        1: 1172:    case BE_CLOSURE: do_closure(vm, v, argc); break;
    #####: 1173:    case BE_NTVCLOS: do_ntvclos(vm, v, argc); break;
        3: 1174:    case BE_NTVFUNC: do_ntvfunc(vm, v, argc); break;
    #####: 1175:    default: call_error(vm, v);
        -: 1176:    }
        4: 1177:}
        -: 1178:
    #####: 1179:BERRY_API void be_set_obs_hook(bvm *vm, bobshook hook)
        -: 1180:{
        -: 1181:    (void)vm;       /* avoid comiler warning */
        -: 1182:    (void)hook;     /* avoid comiler warning */
        -: 1183:
        -: 1184:#if BE_USE_OBSERVABILITY_HOOK
        -: 1185:    vm->obshook = hook;
        -: 1186:#endif
    #####: 1187:}
