        -:    0:Source:src/be_debuglib.c
        -:    0:Graph:./src/be_debuglib.gcno
        -:    0:Data:./src/be_debuglib.gcda
        -:    0:Runs:1
        -:    1:/********************************************************************
        -:    2:** Copyright (c) 2018-2020 Guan Wenliang
        -:    3:** This file is part of the Berry default interpreter.
        -:    4:** skiars@qq.com, https://github.com/Skiars/berry
        -:    5:** See Copyright Notice in the LICENSE file or at
        -:    6:** https://github.com/Skiars/berry/blob/master/LICENSE
        -:    7:********************************************************************/
        -:    8:#include "be_object.h"
        -:    9:#include "be_module.h"
        -:   10:#include "be_string.h"
        -:   11:#include "be_vector.h"
        -:   12:#include "be_class.h"
        -:   13:#include "be_debug.h"
        -:   14:#include "be_map.h"
        -:   15:#include "be_vm.h"
        -:   16:#include <string.h>
        -:   17:
        -:   18:#if BE_USE_DEBUG_MODULE
        -:   19:
    #####:   20:static void dump_map(bmap *map)
        -:   21:{
        -:   22:    bmapnode *node;
    #####:   23:    bmapiter iter = be_map_iter();
    #####:   24:    while ((node = be_map_next(map, &iter)) != NULL) {
    #####:   25:        if (var_isstr(&node->key)) {
    #####:   26:            bstring *s = var_tostr(&node->key);
    #####:   27:            be_writestring("\t");
    #####:   28:            be_writebuffer(str(s), str_len(s));
    #####:   29:            be_writestring(": <");
    #####:   30:            be_writestring(be_vtype2str(&node->value));
    #####:   31:            be_writestring(">\n");
        -:   32:        }
        -:   33:    }
    #####:   34:}
        -:   35:
    #####:   36:static void dump_module(bmodule *module)
        -:   37:{
    #####:   38:    dump_map(module->table);
    #####:   39:}
        -:   40:
    #####:   41:static void dump_class(bclass *class)
        -:   42:{
    #####:   43:    if (class->members) {
    #####:   44:        dump_map(class->members);
        -:   45:    }
    #####:   46:}
        -:   47:
    #####:   48:static void dump_instanse(binstance *ins)
        -:   49:{
    #####:   50:    dump_class(ins->_class);
    #####:   51:}
        -:   52:
    #####:   53:static void dump_value(bvalue *value)
        -:   54:{
    #####:   55:    be_writestring("value type <");
    #####:   56:    be_writestring(be_vtype2str(value));
    #####:   57:    be_writestring(">, attributes:\n");
    #####:   58:}
        -:   59:
    #####:   60:static int m_attrdump(bvm *vm)
        -:   61:{
    #####:   62:    if (be_top(vm) >= 1) {
    #####:   63:        bvalue *v = be_indexof(vm, 1);
    #####:   64:        void *obj = var_toobj(v);
    #####:   65:        dump_value(v);
    #####:   66:        switch (var_type(v)) {
    #####:   67:        case BE_MODULE: dump_module(obj); break;
    #####:   68:        case BE_CLASS: dump_class(obj); break;
    #####:   69:        case BE_INSTANCE: dump_instanse(obj); break;
    #####:   70:        default: break;
        -:   71:        }
    #####:   72:    }
    #####:   73:    be_return_nil(vm);
        -:   74:}
        -:   75:
    #####:   76:static int m_codedump(bvm *vm)
        -:   77:{
    #####:   78:    if (be_top(vm) >= 1) {
    #####:   79:        bvalue *v = be_indexof(vm, 1);
    #####:   80:        if (var_isclosure(v)) {
    #####:   81:            be_dumpclosure(var_toobj(v));
        -:   82:        }
        -:   83:    }
    #####:   84:    be_return_nil(vm);
        -:   85:}
        -:   86:
    #####:   87:static int m_traceback(bvm *vm)
        -:   88:{
    #####:   89:    be_tracestack(vm);
    #####:   90:    be_return_nil(vm);
        -:   91:}
        -:   92:
        -:   93:#if BE_USE_DEBUG_HOOK
    #####:   94:static int m_sethook(bvm *vm)
        -:   95:{
    #####:   96:    if (be_top(vm) >= 2) {
    #####:   97:        be_pushvalue(vm, 1);
    #####:   98:        be_sethook(vm, be_tostring(vm, 2));
        -:   99:    } else {
    #####:  100:        be_sethook(vm, NULL);
        -:  101:    }
    #####:  102:    be_return_nil(vm);
        -:  103:}
        -:  104:#endif
        -:  105:
    #####:  106:static int m_top(bvm *vm)
        -:  107:{
    #####:  108:    bint top = vm->top - vm->stack + 1;
    #####:  109:    be_pushint(vm, top);
    #####:  110:    be_return(vm);
        -:  111:}
        -:  112:
    #####:  113:static int m_calldepth(bvm *vm)
        -:  114:{
    #####:  115:    bint depth = be_stack_count(&vm->callstack);
    #####:  116:    be_pushint(vm, depth);
    #####:  117:    be_return(vm);
        -:  118:}
        -:  119:
        -:  120:#if BE_DEBUG_VAR_INFO
    #####:  121:static int v_getname(bvm *vm, bbool(*getter)(bvm *vm, int, int))
        -:  122:{
    #####:  123:    int index, level = 1;
    #####:  124:    if (be_top(vm) < 1)
    #####:  125:        be_raise(vm, "value_error", "too few arguments");
    #####:  126:    if (!be_isint(vm, 1) || (be_top(vm) >= 2 && !be_isint(vm, 2)))
    #####:  127:        be_raise(vm, "value_error", "invalid argument(s) value");
    #####:  128:    if (be_top(vm) >= 2)
    #####:  129:        level = be_toindex(vm, 2);
    #####:  130:    index = be_toindex(vm, 1);
    #####:  131:    if (index < 0)
    #####:  132:        be_raise(vm, "value_error", "variable index cannot be less than 0");
    #####:  133:    if (level < 1 || level >= be_stack_count(&vm->callstack))
    #####:  134:        be_raise(vm, "value_error", "invalid call depth level");
    #####:  135:    if (getter(vm, level + 1, index)) {
    #####:  136:        be_return(vm);
        -:  137:    }
    #####:  138:    be_return_nil(vm);
        -:  139:}
        -:  140:
    #####:  141:static int m_varname(bvm *vm)
        -:  142:{
    #####:  143:    return v_getname(vm, be_debug_varname);
        -:  144:}
        -:  145:
    #####:  146:static int m_upvname(bvm *vm)
        -:  147:{
    #####:  148:    return v_getname(vm, be_debug_upvname);
        -:  149:}
        -:  150:#endif
        -:  151:
        -:  152:#if !BE_USE_PRECOMPILED_OBJECT
        -:  153:be_native_module_attr_table(debug) {
        -:  154:    be_native_module_function("attrdump", m_attrdump),
        -:  155:    be_native_module_function("codedump", m_codedump),
        -:  156:    be_native_module_function("traceback", m_traceback),
        -:  157:#if BE_USE_DEBUG_HOOK
        -:  158:    be_native_module_function("sethook", m_sethook),
        -:  159:#endif
        -:  160:    be_native_module_function("calldepth", m_calldepth),
        -:  161:    be_native_module_function("top", m_top),
        -:  162:#if BE_DEBUG_VAR_INFO
        -:  163:    be_native_module_function("varname", m_varname),
        -:  164:    be_native_module_function("upvname", m_upvname)
        -:  165:#endif
        -:  166:};
        -:  167:
        -:  168:be_define_native_module(debug, NULL);
        -:  169:#else
        -:  170:/* @const_object_info_begin
        -:  171:module debug (scope: global, depend: BE_USE_DEBUG_MODULE) {
        -:  172:    attrdump, func(m_attrdump)
        -:  173:    codedump, func(m_codedump)
        -:  174:    traceback, func(m_traceback)
        -:  175:    sethook, func(m_sethook), BE_USE_DEBUG_HOOK
        -:  176:    calldepth, func(m_calldepth)
        -:  177:    top, func(m_top)
        -:  178:    varname, func(m_varname), BE_DEBUG_VAR_INFO
        -:  179:    upvname, func(m_upvname), BE_DEBUG_VAR_INFO
        -:  180:}
        -:  181:@const_object_info_end */
        -:  182:#include "../generate/be_fixed_debug.h"
        -:  183:#endif
        -:  184:
        -:  185:#endif /* BE_USE_DEBUG_MODULE */
