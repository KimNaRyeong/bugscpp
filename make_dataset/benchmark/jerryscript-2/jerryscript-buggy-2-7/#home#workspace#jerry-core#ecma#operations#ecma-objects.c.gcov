        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-objects.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-array-object.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-lex-env.h"
        -:   25:#include "ecma-lcache.h"
        -:   26:#include "ecma-string-object.h"
        -:   27:#include "ecma-arguments-object.h"
        -:   28:#include "ecma-objects-general.h"
        -:   29:#include "ecma-objects.h"
        -:   30:#include "ecma-proxy-object.h"
        -:   31:#include "ecma-bigint.h"
        -:   32:#include "jcontext.h"
        -:   33:
        -:   34:#if JERRY_BUILTIN_TYPEDARRAY
        -:   35:#include "ecma-typedarray-object.h"
        -:   36:#include "ecma-arraybuffer-object.h"
        -:   37:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:   38:
        -:   39:/** \addtogroup ecma ECMA
        -:   40: * @{
        -:   41: *
        -:   42: * \addtogroup ecmaobjectsinternalops ECMA objects' operations
        -:   43: * @{
        -:   44: */
        -:   45:
        -:   46:/**
        -:   47: * Hash bitmap size for ecma objects
        -:   48: */
        -:   49:#define ECMA_OBJECT_HASH_BITMAP_SIZE 256
        -:   50:
        -:   51:/**
        -:   52: * Assert that specified object type value is valid
        -:   53: *
        -:   54: * @param type object's implementation-defined type
        -:   55: */
        -:   56:#ifndef JERRY_NDEBUG
        -:   57:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type) \
        -:   58:  JERRY_ASSERT (type < ECMA_OBJECT_TYPE__MAX);
        -:   59:#else /* JERRY_NDEBUG */
        -:   60:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type)
        -:   61:#endif /* !JERRY_NDEBUG */
        -:   62:
        -:   63:/**
        -:   64: * [[GetOwnProperty]] ecma object's operation
        -:   65: *
        -:   66: * See also:
        -:   67: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:   68: *
        -:   69: * @return pointer to a property - if it exists,
        -:   70: *         NULL (i.e. ecma-undefined) - otherwise.
        -:   71: */
        -:   72:ecma_property_t
       97:   73:ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */
        -:   74:                                 ecma_string_t *property_name_p, /**< property name */
        -:   75:                                 ecma_property_ref_t *property_ref_p, /**< property reference */
        -:   76:                                 uint32_t options) /**< option bits */
        -:   77:{
       97:   78:  JERRY_ASSERT (object_p != NULL
        -:   79:                && !ecma_is_lexical_environment (object_p));
        -:   80:#if JERRY_BUILTIN_PROXY
       97:   81:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:   82:#endif /* JERRY_BUILTIN_PROXY */
       97:   83:  JERRY_ASSERT (property_name_p != NULL);
       97:   84:  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS
        -:   85:                || property_ref_p != NULL);
        -:   86:
       97:   87:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -:   88:
       97:   89:  switch (base_type)
        -:   90:  {
    #####:   91:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -:   92:    {
    #####:   93:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   94:
    #####:   95:      switch (ext_object_p->u.cls.type)
        -:   96:      {
    #####:   97:        case ECMA_OBJECT_CLASS_STRING:
        -:   98:        {
    #####:   99:          if (ecma_string_is_length (property_name_p))
        -:  100:          {
    #####:  101:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  102:            {
    #####:  103:              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####:  104:              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  105:
    #####:  106:              lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);
    #####:  107:              property_ref_p->virtual_value = ecma_make_uint32_value (length);
        -:  108:            }
        -:  109:
    #####:  110:            return ECMA_PROPERTY_VIRTUAL;
        -:  111:          }
        -:  112:
    #####:  113:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  114:
    #####:  115:          if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  116:          {
    #####:  117:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####:  118:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  119:
    #####:  120:            if (index < ecma_string_get_length (prim_value_str_p))
        -:  121:            {
    #####:  122:              if (options & ECMA_PROPERTY_GET_VALUE)
        -:  123:              {
    #####:  124:                ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  125:                ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);
    #####:  126:                property_ref_p->virtual_value = ecma_make_string_value (char_str_p);
        -:  127:              }
        -:  128:
    #####:  129:              return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_VIRTUAL;
        -:  130:            }
        -:  131:          }
    #####:  132:          break;
        -:  133:        }
        -:  134:#if JERRY_BUILTIN_TYPEDARRAY
        -:  135:        /* ES2015 9.4.5.1 */
    #####:  136:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -:  137:        {
    #####:  138:          if (ecma_prop_name_is_symbol (property_name_p))
        -:  139:          {
    #####:  140:            break;
        -:  141:          }
    #####:  142:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  143:          bool is_same;
    #####:  144:          if (num <= 0)
        -:  145:          {
    #####:  146:            is_same = true;
        -:  147:          }
        -:  148:          else
        -:  149:          {
    #####:  150:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####:  151:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####:  152:            ecma_deref_ecma_string (num_to_str);
        -:  153:          }
        -:  154:
    #####:  155:          if (is_same)
        -:  156:          {
    #####:  157:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####:  158:            ecma_value_t value = ecma_get_typedarray_element (&info, num);
        -:  159:
    #####:  160:            if (ECMA_IS_VALUE_ERROR (value))
        -:  161:            {
    #####:  162:              property_ref_p->virtual_value = value;
    #####:  163:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  164:            }
        -:  165:
    #####:  166:            if (!ecma_is_value_undefined (value))
        -:  167:            {
    #####:  168:              if (options & ECMA_PROPERTY_GET_VALUE)
        -:  169:              {
    #####:  170:                property_ref_p->virtual_value = value;
        -:  171:              }
        -:  172:              else
        -:  173:              {
    #####:  174:                ecma_fast_free_value (value);
        -:  175:              }
        -:  176:
    #####:  177:              return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  178:            }
        -:  179:            else
        -:  180:            {
    #####:  181:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  182:            }
        -:  183:          }
    #####:  184:          break;
        -:  185:        }
        -:  186:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  187:#if JERRY_MODULE_SYSTEM
    #####:  188:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -:  189:        {
    #####:  190:          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -:  191:          {
    #####:  192:            if (!ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))
        -:  193:            {
    #####:  194:              return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  195:            }
        -:  196:
        -:  197:            /* ECMA-262 v11, 26.3.1 */
    #####:  198:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  199:            {
    #####:  200:              property_ref_p->virtual_value = ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);
        -:  201:            }
        -:  202:
    #####:  203:            return ECMA_PROPERTY_VIRTUAL;
        -:  204:          }
        -:  205:
    #####:  206:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  207:
    #####:  208:          if (property_p == NULL)
        -:  209:          {
    #####:  210:            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  211:          }
        -:  212:
    #####:  213:          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  214:
    #####:  215:          if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  216:          {
    #####:  217:            if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)
        -:  218:            {
    #####:  219:              ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;
        -:  220:            }
        -:  221:
    #####:  222:            if (property_ref_p != NULL)
        -:  223:            {
    #####:  224:              property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  225:            }
        -:  226:
    #####:  227:            return *property_p;
        -:  228:          }
        -:  229:
    #####:  230:          if (options & ECMA_PROPERTY_GET_VALUE)
        -:  231:          {
    #####:  232:            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  233:            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);
    #####:  234:            property_ref_p->virtual_value = ecma_fast_copy_value (prop_value_p->value);
        -:  235:          }
        -:  236:
    #####:  237:          return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  238:        }
        -:  239:#endif /* JERRY_MODULE_SYSTEM */
        -:  240:      }
    #####:  241:      break;
        -:  242:    }
    #####:  243:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -:  244:    {
    #####:  245:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  246:
    #####:  247:      if (ecma_string_is_length (property_name_p))
        -:  248:      {
    #####:  249:        if (options & ECMA_PROPERTY_GET_VALUE)
        -:  250:        {
    #####:  251:          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  252:        }
        -:  253:
    #####:  254:        uint32_t length_prop = ext_object_p->u.array.length_prop_and_hole_count;
    #####:  255:        return length_prop & (ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL);
        -:  256:      }
        -:  257:
    #####:  258:      if (ecma_op_array_is_fast_array (ext_object_p))
        -:  259:      {
    #####:  260:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  261:
    #####:  262:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  263:        {
    #####:  264:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  265:          {
    #####:  266:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  267:
    #####:  268:            if (ecma_is_value_array_hole (values_p[index]))
        -:  269:            {
    #####:  270:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  271:            }
        -:  272:
    #####:  273:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  274:            {
    #####:  275:              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);
        -:  276:            }
        -:  277:
    #####:  278:            return ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  279:          }
        -:  280:        }
        -:  281:
    #####:  282:        return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  283:      }
        -:  284:
    #####:  285:      break;
        -:  286:    }
       97:  287:    default:
        -:  288:    {
       97:  289:      break;
        -:  290:    }
        -:  291:  }
        -:  292:
       97:  293:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
       97:  294:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -:  295:
       97:  296:  if (property_p == NULL)
        -:  297:  {
       81:  298:    switch (type)
        -:  299:    {
    #####:  300:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -:  301:      {
    #####:  302:        if (ecma_builtin_function_is_routine (object_p))
        -:  303:        {
    #####:  304:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####:  305:          break;
        -:  306:        }
        -:  307:        /* FALLTHRU */
        -:  308:      }
        -:  309:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -:  310:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -:  311:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -:  312:      {
       81:  313:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
       81:  314:        break;
        -:  315:      }
    #####:  316:      case ECMA_OBJECT_TYPE_CLASS:
        -:  317:      {
    #####:  318:        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)
        -:  319:        {
    #####:  320:          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  321:        }
    #####:  322:        break;
        -:  323:      }
    #####:  324:      case ECMA_OBJECT_TYPE_FUNCTION:
        -:  325:      {
        -:  326:#if !JERRY_ESNEXT
    #####:  327:        if (ecma_string_is_length (property_name_p))
        -:  328:        {
    #####:  329:          if (options & ECMA_PROPERTY_GET_VALUE)
        -:  330:          {
        -:  331:            /* Get length virtual property. */
    #####:  332:            ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  333:            const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  334:
        -:  335:            uint32_t len;
    #####:  336:            if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  337:            {
    #####:  338:              cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  339:              len = args_p->argument_end;
        -:  340:            }
        -:  341:            else
        -:  342:            {
    #####:  343:              cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  344:              len = args_p->argument_end;
        -:  345:            }
        -:  346:
    #####:  347:            property_ref_p->virtual_value = ecma_make_uint32_value (len);
        -:  348:          }
        -:  349:
        -:  350:          return ECMA_PROPERTY_VIRTUAL;
        -:  351:        }
        -:  352:#endif /* !JERRY_ESNEXT */
        -:  353:
        -:  354:        /* Get prototype physical property. */
    #####:  355:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  356:        break;
        -:  357:      }
    #####:  358:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -:  359:      {
    #####:  360:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  361:        break;
        -:  362:      }
    #####:  363:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -:  364:      {
    #####:  365:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  366:        break;
        -:  367:      }
    #####:  368:      default:
        -:  369:      {
    #####:  370:        break;
        -:  371:      }
        -:  372:    }
        -:  373:
       81:  374:    if (property_p == NULL)
        -:  375:    {
       13:  376:      return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  377:    }
        -:  378:  }
       16:  379:  else if (type == ECMA_OBJECT_TYPE_CLASS
    #####:  380:           && ((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS
    #####:  381:           && (((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  382:  {
    #####:  383:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  384:
    #####:  385:    uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  386:
    #####:  387:    if (index < ext_object_p->u.cls.u2.formal_params_number)
        -:  388:    {
    #####:  389:      ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -:  390:
    #####:  391:      ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  392:
    #####:  393:      if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  394:      {
        -:  395:#if JERRY_LCACHE
        -:  396:        /* Mapped arguments initialized properties MUST not be lcached */
    #####:  397:        if (ecma_is_property_lcached (property_p))
        -:  398:        {
        -:  399:          jmem_cpointer_t prop_name_cp;
        -:  400:
    #####:  401:          if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (property_name_p)))
        -:  402:          {
    #####:  403:            prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (property_name_p);
        -:  404:          }
        -:  405:          else
        -:  406:          {
    #####:  407:            ECMA_SET_NON_NULL_POINTER (prop_name_cp, property_name_p);
        -:  408:          }
    #####:  409:          ecma_lcache_invalidate (object_p, prop_name_cp, property_p);
        -:  410:        }
        -:  411:#endif /* JERRY_LCACHE */
    #####:  412:        ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  413:        ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  414:
    #####:  415:        ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, name_p, true);
        -:  416:
    #####:  417:        ecma_named_data_property_assign_value (object_p,
    #####:  418:                                               ECMA_PROPERTY_VALUE_PTR (property_p),
        -:  419:                                               binding_value);
    #####:  420:        ecma_free_value (binding_value);
        -:  421:      }
        -:  422:    }
        -:  423:  }
        -:  424:
       84:  425:  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)
        -:  426:  {
    #####:  427:    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;
        -:  428:  }
        -:  429:
       84:  430:  if (property_ref_p != NULL)
        -:  431:  {
       82:  432:    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  433:  }
        -:  434:
       84:  435:  return *property_p;
        -:  436:} /* ecma_op_object_get_own_property */
        -:  437:
        -:  438:/**
        -:  439: * Generic [[HasProperty]] operation
        -:  440: *
        -:  441: * See also:
        -:  442: *          ECMAScript v6, 9.1.7.1
        -:  443: *
        -:  444: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  445: *         ECMA_VALUE_{TRUE_FALSE} - whether the property is found
        -:  446: */
        -:  447:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        9:  448:ecma_op_object_has_property (ecma_object_t *object_p, /**< the object */
        -:  449:                             ecma_string_t *property_name_p) /**< property name */
        -:  450:{
        -:  451:  while (true)
        1:  452:  {
        -:  453:#if JERRY_BUILTIN_PROXY
        9:  454:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  455:    {
        5:  456:      return ecma_proxy_object_has (object_p, property_name_p);
        -:  457:    }
        -:  458:#endif /* JERRY_BUILTIN_PROXY */
        -:  459:
        -:  460:#if JERRY_BUILTIN_TYPEDARRAY
        4:  461:    if (ecma_object_is_typedarray (object_p) && !ecma_prop_name_is_symbol (property_name_p))
        -:  462:    {
    #####:  463:      ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  464:      bool is_same;
    #####:  465:      if (num <= 0)
        -:  466:      {
    #####:  467:        is_same = true;
        -:  468:      }
        -:  469:      else
        -:  470:      {
    #####:  471:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####:  472:        is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####:  473:        ecma_deref_ecma_string (num_to_str);
        -:  474:      }
        -:  475:
    #####:  476:      if (is_same)
        -:  477:      {
    #####:  478:        ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
        -:  479:
    #####:  480:        if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -:  481:        {
    #####:  482:          return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  483:        }
        -:  484:
    #####:  485:        if (!ecma_op_is_integer (num)
    #####:  486:            || num >= info.length
    #####:  487:            || num < 0
    #####:  488:            || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -:  489:        {
    #####:  490:          return ECMA_VALUE_FALSE;
        -:  491:        }
        -:  492:
    #####:  493:        return ECMA_VALUE_TRUE;
        -:  494:      }
        -:  495:    }
        -:  496:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  497:
        -:  498:    /* 2 - 3. */
        4:  499:    if (ecma_op_ordinary_object_has_own_property (object_p, property_name_p))
        -:  500:    {
        2:  501:      return ECMA_VALUE_TRUE;
        -:  502:    }
        -:  503:
        2:  504:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  505:
        -:  506:    /* 7. */
        2:  507:    if (proto_cp == JMEM_CP_NULL)
        -:  508:    {
        1:  509:      return ECMA_VALUE_FALSE;
        -:  510:    }
        -:  511:
        1:  512:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  513:  }
        -:  514:} /* ecma_op_object_has_property */
        -:  515:
        -:  516:/**
        -:  517: * Search the value corresponding to a property name
        -:  518: *
        -:  519: * Note: search includes prototypes
        -:  520: *
        -:  521: * @return ecma value if property is found
        -:  522: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  523: *         Returned value must be freed with ecma_free_value
        -:  524: */
        -:  525:ecma_value_t
      178:  526:ecma_op_object_find_own (ecma_value_t base_value, /**< base value */
        -:  527:                         ecma_object_t *object_p, /**< target object */
        -:  528:                         ecma_string_t *property_name_p) /**< property name */
        -:  529:{
      178:  530:  JERRY_ASSERT (object_p != NULL
        -:  531:                && !ecma_is_lexical_environment (object_p));
      178:  532:  JERRY_ASSERT (property_name_p != NULL);
      178:  533:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:  534:
      178:  535:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -:  536:
      178:  537:  switch (base_type)
        -:  538:  {
        1:  539:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -:  540:    {
        1:  541:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  542:
        1:  543:      switch (ext_object_p->u.cls.type)
        -:  544:      {
    #####:  545:        case ECMA_OBJECT_CLASS_STRING:
        -:  546:        {
    #####:  547:          if (ecma_string_is_length (property_name_p))
        -:  548:          {
    #####:  549:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
        -:  550:
    #####:  551:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
    #####:  552:            lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);
        -:  553:
    #####:  554:            return ecma_make_uint32_value (length);
        -:  555:          }
        -:  556:
    #####:  557:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  558:
    #####:  559:          if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  560:          {
    #####:  561:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
        -:  562:
    #####:  563:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  564:
    #####:  565:            if (index < ecma_string_get_length (prim_value_str_p))
        -:  566:            {
    #####:  567:              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  568:              return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));
        -:  569:            }
        -:  570:          }
    #####:  571:          break;
        -:  572:        }
    #####:  573:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -:  574:        {
    #####:  575:          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  576:          {
    #####:  577:            break;
        -:  578:          }
        -:  579:
    #####:  580:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  581:
    #####:  582:          if (index < ext_object_p->u.cls.u2.formal_params_number)
        -:  583:          {
    #####:  584:            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -:  585:
    #####:  586:            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  587:
    #####:  588:            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  589:            {
    #####:  590:              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  591:              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  592:
    #####:  593:              return ecma_op_get_binding_value (lex_env_p, name_p, true);
        -:  594:            }
        -:  595:          }
    #####:  596:          break;
        -:  597:        }
        -:  598:#if JERRY_BUILTIN_TYPEDARRAY
        -:  599:        /* ES2015 9.4.5.4 */
        1:  600:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -:  601:        {
        1:  602:          if (ecma_prop_name_is_symbol (property_name_p))
        -:  603:          {
    #####:  604:            break;
        -:  605:          }
        -:  606:
        1:  607:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  608:          bool is_same;
        1:  609:          if (num <= 0)
        -:  610:          {
    #####:  611:            is_same = true;
        -:  612:          }
        -:  613:          else
        -:  614:          {
        1:  615:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
        1:  616:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
        1:  617:            ecma_deref_ecma_string (num_to_str);
        -:  618:          }
        -:  619:
        1:  620:          if (is_same)
        -:  621:          {
    #####:  622:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####:  623:            return ecma_get_typedarray_element (&info, num);
        -:  624:          }
        -:  625:
        1:  626:          break;
        -:  627:        }
        -:  628:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  629:#if JERRY_MODULE_SYSTEM
    #####:  630:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -:  631:        {
    #####:  632:          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -:  633:          {
        -:  634:            /* ECMA-262 v11, 26.3.1 */
    #####:  635:            if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))
        -:  636:            {
    #####:  637:              return ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);
        -:  638:            }
        -:  639:
    #####:  640:            return ECMA_VALUE_NOT_FOUND;
        -:  641:          }
        -:  642:
    #####:  643:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  644:
    #####:  645:          if (property_p == NULL)
        -:  646:          {
    #####:  647:            return ECMA_VALUE_NOT_FOUND;
        -:  648:          }
        -:  649:
    #####:  650:          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  651:
    #####:  652:          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  653:
    #####:  654:          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  655:          {
    #####:  656:            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);
        -:  657:
    #####:  658:            if (JERRY_UNLIKELY (prop_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  659:            {
    #####:  660:              return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:  661:            }
        -:  662:          }
        -:  663:
    #####:  664:          return ecma_fast_copy_value (prop_value_p->value);
        -:  665:        }
        -:  666:#endif /* JERRY_MODULE_SYSTEM */
        -:  667:      }
        1:  668:      break;
        -:  669:    }
    #####:  670:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -:  671:    {
    #####:  672:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  673:
    #####:  674:      if (ecma_string_is_length (property_name_p))
        -:  675:      {
    #####:  676:        return ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  677:      }
        -:  678:
    #####:  679:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -:  680:      {
    #####:  681:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  682:
    #####:  683:        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))
        -:  684:        {
    #####:  685:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  686:          {
    #####:  687:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  688:
    #####:  689:            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND
    #####:  690:                                                               : ecma_fast_copy_value (values_p[index]));
        -:  691:          }
        -:  692:        }
    #####:  693:        return ECMA_VALUE_NOT_FOUND;
        -:  694:      }
        -:  695:
    #####:  696:      break;
        -:  697:    }
      177:  698:    default:
        -:  699:    {
      177:  700:      break;
        -:  701:    }
        -:  702:  }
        -:  703:
      178:  704:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  705:
      177:  706:  if (property_p == NULL)
        -:  707:  {
      165:  708:    switch (ecma_get_object_type (object_p))
        -:  709:    {
        1:  710:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -:  711:      {
        1:  712:        if (ecma_builtin_function_is_routine (object_p))
        -:  713:        {
    #####:  714:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####:  715:          break;
        -:  716:        }
        -:  717:        /* FALLTHRU */
        -:  718:      }
        -:  719:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -:  720:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -:  721:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -:  722:      {
       98:  723:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
       98:  724:        break;
        -:  725:      }
        1:  726:      case ECMA_OBJECT_TYPE_CLASS:
        -:  727:      {
        1:  728:        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)
        -:  729:        {
    #####:  730:          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  731:        }
        1:  732:        break;
        -:  733:      }
    #####:  734:      case ECMA_OBJECT_TYPE_FUNCTION:
        -:  735:      {
        -:  736:#if !JERRY_ESNEXT
    #####:  737:        if (ecma_string_is_length (property_name_p))
        -:  738:        {
        -:  739:          /* Get length virtual property. */
    #####:  740:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  741:          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  742:
        -:  743:          uint32_t len;
    #####:  744:          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  745:          {
    #####:  746:            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  747:            len = args_p->argument_end;
        -:  748:          }
        -:  749:          else
        -:  750:          {
    #####:  751:            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  752:            len = args_p->argument_end;
        -:  753:          }
        -:  754:
    #####:  755:          return ecma_make_uint32_value (len);
        -:  756:        }
        -:  757:#endif /* !JERRY_ESNEXT */
        -:  758:
        -:  759:        /* Get prototype physical property. */
    #####:  760:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  761:        break;
        -:  762:      }
    #####:  763:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -:  764:      {
    #####:  765:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  766:        break;
        -:  767:      }
    #####:  768:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -:  769:      {
    #####:  770:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  771:        break;
        -:  772:      }
       66:  773:      default:
        -:  774:      {
       66:  775:        break;
        -:  776:      }
        -:  777:    }
        -:  778:
      165:  779:    if (property_p == NULL)
        -:  780:    {
      159:  781:      return ECMA_VALUE_NOT_FOUND;
        -:  782:    }
        -:  783:  }
        -:  784:
       18:  785:  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  786:
       18:  787:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  788:
       18:  789:  if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  790:  {
       18:  791:    return ecma_fast_copy_value (prop_value_p->value);
        -:  792:  }
        -:  793:
    #####:  794:  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);
        -:  795:
    #####:  796:  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -:  797:  {
    #####:  798:    return ECMA_VALUE_UNDEFINED;
        -:  799:  }
        -:  800:
    #####:  801:  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
        -:  802:
    #####:  803:  return ecma_op_function_call (getter_p, base_value, NULL, 0);
        -:  804:} /* ecma_op_object_find_own */
        -:  805:
        -:  806:/**
        -:  807: * Search the value corresponding to a property index
        -:  808: *
        -:  809: * Note: this method falls back to the general ecma_op_object_find
        -:  810: *
        -:  811: * @return ecma value if property is found
        -:  812: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  813: *         Returned value must be freed with ecma_free_value
        -:  814: */
        -:  815:ecma_value_t
    #####:  816:ecma_op_object_find_by_index (ecma_object_t *object_p, /**< the object */
        -:  817:                              ecma_length_t index) /**< property index */
        -:  818:{
    #####:  819:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  820:  {
    #####:  821:    return ecma_op_object_find (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  822:  }
        -:  823:
    #####:  824:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  825:  ecma_value_t ret_value = ecma_op_object_find (object_p, index_str_p);
    #####:  826:  ecma_deref_ecma_string (index_str_p);
        -:  827:
    #####:  828:  return ret_value;
        -:  829:} /* ecma_op_object_find_by_index */
        -:  830:
        -:  831:/**
        -:  832: * Search the value corresponding to a property name
        -:  833: *
        -:  834: * Note: search includes prototypes
        -:  835: *
        -:  836: * @return ecma value if property is found
        -:  837: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  838: *         Returned value must be freed with ecma_free_value
        -:  839: */
        -:  840:ecma_value_t
        4:  841:ecma_op_object_find (ecma_object_t *object_p, /**< the object */
        -:  842:                     ecma_string_t *property_name_p) /**< property name */
        -:  843:{
        4:  844:  ecma_value_t base_value = ecma_make_object_value (object_p);
        -:  845:
        -:  846:  while (true)
    #####:  847:  {
        -:  848:#if JERRY_BUILTIN_PROXY
        4:  849:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  850:    {
    #####:  851:      return ecma_proxy_object_find (object_p, property_name_p);
        -:  852:    }
        -:  853:#endif /* JERRY_BUILTIN_PROXY */
        -:  854:
        4:  855:    ecma_value_t value = ecma_op_object_find_own (base_value, object_p, property_name_p);
        -:  856:
        3:  857:    if (ecma_is_value_found (value))
        -:  858:    {
        3:  859:      return value;
        -:  860:    }
        -:  861:
    #####:  862:    if (object_p->u2.prototype_cp == JMEM_CP_NULL)
        -:  863:    {
    #####:  864:      break;
        -:  865:    }
        -:  866:
    #####:  867:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);
        -:  868:  }
        -:  869:
    #####:  870:  return ECMA_VALUE_NOT_FOUND;
        -:  871:} /* ecma_op_object_find */
        -:  872:
        -:  873:/**
        -:  874: * [[Get]] operation of ecma object
        -:  875: *
        -:  876: * This function returns the value of a named property, or undefined
        -:  877: * if the property is not found in the prototype chain. If the property
        -:  878: * is an accessor, it calls the "get" callback function and returns
        -:  879: * with its result (including error throws).
        -:  880: *
        -:  881: * See also:
        -:  882: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  883: *
        -:  884: * @return ecma value
        -:  885: *         Returned value must be freed with ecma_free_value
        -:  886: */
        -:  887:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        2:  888:ecma_op_object_get (ecma_object_t *object_p, /**< the object */
        -:  889:                    ecma_string_t *property_name_p) /**< property name */
        -:  890:{
       92:  891:  return ecma_op_object_get_with_receiver (object_p, property_name_p, ecma_make_object_value (object_p));
        -:  892:} /* ecma_op_object_get */
        -:  893:
        -:  894:/**
        -:  895: * [[Get]] operation of ecma object with the specified receiver
        -:  896: *
        -:  897: * This function returns the value of a named property, or undefined
        -:  898: * if the property is not found in the prototype chain. If the property
        -:  899: * is an accessor, it calls the "get" callback function and returns
        -:  900: * with its result (including error throws).
        -:  901: *
        -:  902: * See also:
        -:  903: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  904: *
        -:  905: * @return ecma value
        -:  906: *         Returned value must be freed with ecma_free_value
        -:  907: */
        -:  908:ecma_value_t
      175:  909:ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */
        -:  910:                                  ecma_string_t *property_name_p, /**< property name */
        -:  911:                                  ecma_value_t receiver) /**< receiver to invoke getter function */
        -:  912:{
        -:  913:  while (true)
       83:  914:  {
        -:  915:#if JERRY_BUILTIN_PROXY
      175:  916:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  917:    {
        1:  918:      return ecma_proxy_object_get (object_p, property_name_p, receiver);
        -:  919:    }
        -:  920:#endif /* JERRY_BUILTIN_PROXY */
        -:  921:
      174:  922:    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);
        -:  923:
      174:  924:    if (ecma_is_value_found (value))
        -:  925:    {
       15:  926:      return value;
        -:  927:    }
        -:  928:
      159:  929:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  930:
      159:  931:    if (proto_cp == JMEM_CP_NULL)
        -:  932:    {
       76:  933:      break;
        -:  934:    }
        -:  935:
       83:  936:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  937:  }
        -:  938:
       76:  939:  return ECMA_VALUE_UNDEFINED;
        -:  940:} /* ecma_op_object_get_with_receiver */
        -:  941:
        -:  942:/**
        -:  943: * [[Get]] operation of ecma object specified for property index
        -:  944: *
        -:  945: * @return ecma value
        -:  946: *         Returned value must be freed with ecma_free_value
        -:  947: */
        -:  948:ecma_value_t
    #####:  949:ecma_op_object_get_by_index (ecma_object_t *object_p, /**< the object */
        -:  950:                             ecma_length_t index) /**< property index */
        -:  951:{
    #####:  952:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  953:  {
    #####:  954:    return ecma_op_object_get (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  955:  }
        -:  956:
    #####:  957:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  958:  ecma_value_t ret_value = ecma_op_object_get (object_p, index_str_p);
    #####:  959:  ecma_deref_ecma_string (index_str_p);
        -:  960:
    #####:  961:  return ret_value;
        -:  962:} /* ecma_op_object_get_by_index */
        -:  963:
        -:  964:/**
        -:  965: * Perform ToLength(O.[[Get]]("length")) operation
        -:  966: *
        -:  967: * The property is converted to uint32 during the operation
        -:  968: *
        -:  969: * @return ECMA_VALUE_ERROR - if there was any error during the operation
        -:  970: *         ECMA_VALUE_EMPTY - otherwise
        -:  971: */
        -:  972:ecma_value_t
    #####:  973:ecma_op_object_get_length (ecma_object_t *object_p, /**< the object */
        -:  974:                           ecma_length_t *length_p) /**< [out] length value converted to uint32 */
        -:  975:{
    #####:  976:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -:  977:  {
    #####:  978:    *length_p = (ecma_length_t) ecma_array_get_length (object_p);
    #####:  979:    return ECMA_VALUE_EMPTY;
        -:  980:  }
        -:  981:
    #####:  982:  ecma_value_t len_value = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_LENGTH);
    #####:  983:  ecma_value_t len_number = ecma_op_to_length (len_value, length_p);
    #####:  984:  ecma_free_value (len_value);
        -:  985:
    #####:  986:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (len_number) || ecma_is_value_empty (len_number));
        -:  987:
    #####:  988:  return len_number;
        -:  989:} /* ecma_op_object_get_length */
        -:  990:
        -:  991:/**
        -:  992: * [[Get]] operation of ecma object where the property name is a magic string
        -:  993: *
        -:  994: * This function returns the value of a named property, or undefined
        -:  995: * if the property is not found in the prototype chain. If the property
        -:  996: * is an accessor, it calls the "get" callback function and returns
        -:  997: * with its result (including error throws).
        -:  998: *
        -:  999: * See also:
        -: 1000: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1001: *
        -: 1002: * @return ecma value
        -: 1003: *         Returned value must be freed with ecma_free_value
        -: 1004: */
        -: 1005:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        8: 1006:ecma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */
        -: 1007:                                lit_magic_string_id_t property_id) /**< property magic string id */
        -: 1008:{
       16: 1009:  return ecma_op_object_get (object_p, ecma_get_magic_string (property_id));
        -: 1010:} /* ecma_op_object_get_by_magic_id */
        -: 1011:
        -: 1012:#if JERRY_ESNEXT
        -: 1013:
        -: 1014:/**
        -: 1015: * Descriptor string for each global symbol
        -: 1016: */
        -: 1017:static const uint16_t ecma_global_symbol_descriptions[] =
        -: 1018:{
        -: 1019:  LIT_MAGIC_STRING_ASYNC_ITERATOR,
        -: 1020:  LIT_MAGIC_STRING_HAS_INSTANCE,
        -: 1021:  LIT_MAGIC_STRING_IS_CONCAT_SPREADABLE,
        -: 1022:  LIT_MAGIC_STRING_ITERATOR,
        -: 1023:  LIT_MAGIC_STRING_MATCH,
        -: 1024:  LIT_MAGIC_STRING_REPLACE,
        -: 1025:  LIT_MAGIC_STRING_SEARCH,
        -: 1026:  LIT_MAGIC_STRING_SPECIES,
        -: 1027:  LIT_MAGIC_STRING_SPLIT,
        -: 1028:  LIT_MAGIC_STRING_TO_PRIMITIVE,
        -: 1029:  LIT_MAGIC_STRING_TO_STRING_TAG,
        -: 1030:  LIT_MAGIC_STRING_UNSCOPABLES,
        -: 1031:  LIT_MAGIC_STRING_MATCH_ALL,
        -: 1032:};
        -: 1033:
        -: 1034:JERRY_STATIC_ASSERT (sizeof (ecma_global_symbol_descriptions) / sizeof (uint16_t) == ECMA_BUILTIN_GLOBAL_SYMBOL_COUNT,
        -: 1035:                     ecma_global_symbol_descriptions_must_have_global_symbol_count_elements);
        -: 1036:
        -: 1037:/**
        -: 1038: * [[Get]] a well-known symbol by the given property id
        -: 1039: *
        -: 1040: * @return pointer to the requested well-known symbol
        -: 1041: */
        -: 1042:ecma_string_t *
       10: 1043:ecma_op_get_global_symbol (lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1044:{
       10: 1045:  JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (property_id));
        -: 1046:
       10: 1047:  uint32_t symbol_index = (uint32_t) property_id - (uint32_t) LIT_GLOBAL_SYMBOL__FIRST;
       10: 1048:  jmem_cpointer_t symbol_cp = JERRY_CONTEXT (global_symbols_cp)[symbol_index];
        -: 1049:
       10: 1050:  if (symbol_cp != JMEM_CP_NULL)
        -: 1051:  {
        8: 1052:    ecma_string_t *symbol_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, symbol_cp);
        8: 1053:    ecma_ref_ecma_string (symbol_p);
        8: 1054:    return symbol_p;
        -: 1055:  }
        -: 1056:
        2: 1057:  ecma_string_t *symbol_dot_p = ecma_get_magic_string (LIT_MAGIC_STRING_SYMBOL_DOT_UL);
        2: 1058:  uint16_t description = ecma_global_symbol_descriptions[symbol_index];
        2: 1059:  ecma_string_t *name_p = ecma_get_magic_string ((lit_magic_string_id_t) description);
        2: 1060:  ecma_string_t *descriptor_p = ecma_concat_ecma_strings (symbol_dot_p, name_p);
        -: 1061:
        2: 1062:  ecma_string_t *symbol_p = ecma_new_symbol_from_descriptor_string (ecma_make_string_value (descriptor_p));
        2: 1063:  symbol_p->u.hash = (uint16_t) ((property_id << ECMA_GLOBAL_SYMBOL_SHIFT) | ECMA_GLOBAL_SYMBOL_FLAG);
        -: 1064:
        2: 1065:  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (global_symbols_cp)[symbol_index], symbol_p);
        -: 1066:
        2: 1067:  ecma_ref_ecma_string (symbol_p);
        2: 1068:  return symbol_p;
        -: 1069:} /* ecma_op_get_global_symbol */
        -: 1070:
        -: 1071:/**
        -: 1072: * Checks whether the string equals to the global symbol.
        -: 1073: *
        -: 1074: * @return true - if the string equals to the global symbol
        -: 1075: *         false - otherwise
        -: 1076: */
        -: 1077:bool
    #####: 1078:ecma_op_compare_string_to_global_symbol (ecma_string_t *string_p, /**< string to compare */
        -: 1079:                                         lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1080:{
    #####: 1081:  JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (property_id));
        -: 1082:
    #####: 1083:  uint32_t symbol_index = (uint32_t) property_id - (uint32_t) LIT_GLOBAL_SYMBOL__FIRST;
    #####: 1084:  jmem_cpointer_t symbol_cp = JERRY_CONTEXT (global_symbols_cp)[symbol_index];
        -: 1085:
        -: 1086:  return (symbol_cp != JMEM_CP_NULL
    #####: 1087:          && string_p == ECMA_GET_NON_NULL_POINTER (ecma_string_t, symbol_cp));
        -: 1088:} /* ecma_op_compare_string_to_global_symbol */
        -: 1089:
        -: 1090:/**
        -: 1091: * [[Get]] operation of ecma object where the property is a well-known symbol
        -: 1092: *
        -: 1093: * @return ecma value
        -: 1094: *         Returned value must be freed with ecma_free_value
        -: 1095: */
        -: 1096:ecma_value_t
        5: 1097:ecma_op_object_get_by_symbol_id (ecma_object_t *object_p, /**< the object */
        -: 1098:                                 lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1099:{
        5: 1100:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (property_id);
        5: 1101:  ecma_value_t ret_value = ecma_op_object_get (object_p, symbol_p);
        5: 1102:  ecma_deref_ecma_string (symbol_p);
        -: 1103:
        5: 1104:  return ret_value;
        -: 1105:} /* ecma_op_object_get_by_symbol_id */
        -: 1106:
        -: 1107:/**
        -: 1108: * GetMethod operation
        -: 1109: *
        -: 1110: * See also: ECMA-262 v6, 7.3.9
        -: 1111: *
        -: 1112: * Note:
        -: 1113: *      Returned value must be freed with ecma_free_value.
        -: 1114: *
        -: 1115: * @return iterator function object - if success
        -: 1116: *         raised error - otherwise
        -: 1117: */
        -: 1118:static ecma_value_t
       77: 1119:ecma_op_get_method (ecma_value_t value, /**< ecma value */
        -: 1120:                    ecma_string_t *prop_name_p) /** property name */
        -: 1121:{
        -: 1122:  /* 2. */
       77: 1123:  ecma_value_t obj_value = ecma_op_to_object (value);
        -: 1124:
       77: 1125:  if (ECMA_IS_VALUE_ERROR (obj_value))
        -: 1126:  {
    #####: 1127:    return obj_value;
        -: 1128:  }
        -: 1129:
       77: 1130:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
        -: 1131:  ecma_value_t func;
        -: 1132:
       77: 1133:  func = ecma_op_object_get (obj_p, prop_name_p);
       77: 1134:  ecma_deref_object (obj_p);
        -: 1135:
        -: 1136:  /* 3. */
       77: 1137:  if (ECMA_IS_VALUE_ERROR (func))
        -: 1138:  {
    #####: 1139:    return func;
        -: 1140:  }
        -: 1141:
        -: 1142:  /* 4. */
       77: 1143:  if (ecma_is_value_undefined (func) || ecma_is_value_null (func))
        -: 1144:  {
       71: 1145:    return ECMA_VALUE_UNDEFINED;
        -: 1146:  }
        -: 1147:
        -: 1148:  /* 5. */
        6: 1149:  if (!ecma_op_is_callable (func))
        -: 1150:  {
    #####: 1151:    ecma_free_value (func);
    #####: 1152:    return ecma_raise_type_error (ECMA_ERR_MSG ("Iterator is not callable"));
        -: 1153:  }
        -: 1154:
        -: 1155:  /* 6. */
        6: 1156:  return func;
        -: 1157:} /* ecma_op_get_method */
        -: 1158:
        -: 1159:/**
        -: 1160: * GetMethod operation when the property is a well-known symbol
        -: 1161: *
        -: 1162: * See also: ECMA-262 v6, 7.3.9
        -: 1163: *
        -: 1164: * Note:
        -: 1165: *      Returned value must be freed with ecma_free_value.
        -: 1166: *
        -: 1167: * @return iterator function object - if success
        -: 1168: *         raised error - otherwise
        -: 1169: */
        -: 1170:ecma_value_t
        5: 1171:ecma_op_get_method_by_symbol_id (ecma_value_t value, /**< ecma value */
        -: 1172:                                 lit_magic_string_id_t symbol_id) /**< property symbol id */
        -: 1173:{
        5: 1174:  ecma_string_t *prop_name_p = ecma_op_get_global_symbol (symbol_id);
        5: 1175:  ecma_value_t ret_value = ecma_op_get_method (value, prop_name_p);
        5: 1176:  ecma_deref_ecma_string (prop_name_p);
        -: 1177:
        5: 1178:  return ret_value;
        -: 1179:} /* ecma_op_get_method_by_symbol_id */
        -: 1180:
        -: 1181:/**
        -: 1182: * GetMethod operation when the property is a magic string
        -: 1183: *
        -: 1184: * See also: ECMA-262 v6, 7.3.9
        -: 1185: *
        -: 1186: * Note:
        -: 1187: *      Returned value must be freed with ecma_free_value.
        -: 1188: *
        -: 1189: * @return iterator function object - if success
        -: 1190: *         raised error - otherwise
        -: 1191: */
        -: 1192:ecma_value_t
       72: 1193:ecma_op_get_method_by_magic_id (ecma_value_t value, /**< ecma value */
        -: 1194:                                lit_magic_string_id_t magic_id) /**< property magic id */
        -: 1195:{
       72: 1196:  return ecma_op_get_method (value, ecma_get_magic_string (magic_id));
        -: 1197:} /* ecma_op_get_method_by_magic_id */
        -: 1198:#endif /* JERRY_ESNEXT */
        -: 1199:
        -: 1200:/**
        -: 1201: * [[Put]] ecma general object's operation specialized for property index
        -: 1202: *
        -: 1203: * Note: This function falls back to the general ecma_op_object_put
        -: 1204: *
        -: 1205: * @return ecma value
        -: 1206: *         The returned value must be freed with ecma_free_value.
        -: 1207: */
        -: 1208:ecma_value_t
    #####: 1209:ecma_op_object_put_by_index (ecma_object_t *object_p, /**< the object */
        -: 1210:                             ecma_length_t index, /**< property index */
        -: 1211:                             ecma_value_t value, /**< ecma value */
        -: 1212:                             bool is_throw) /**< flag that controls failure handling */
        -: 1213:{
    #####: 1214:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1215:  {
    #####: 1216:    return ecma_op_object_put (object_p,
    #####: 1217:                               ECMA_CREATE_DIRECT_UINT32_STRING (index),
        -: 1218:                               value,
        -: 1219:                               is_throw);
        -: 1220:  }
        -: 1221:
    #####: 1222:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####: 1223:  ecma_value_t ret_value = ecma_op_object_put (object_p, index_str_p, value, is_throw);
    #####: 1224:  ecma_deref_ecma_string (index_str_p);
        -: 1225:
    #####: 1226:  return ret_value;
        -: 1227:} /* ecma_op_object_put_by_index */
        -: 1228:
        -: 1229:/**
        -: 1230: * [[Put]] ecma general object's operation
        -: 1231: *
        -: 1232: * See also:
        -: 1233: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1234: *          ECMA-262 v5, 8.12.5
        -: 1235: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1236: *
        -: 1237: * @return ecma value
        -: 1238: *         The returned value must be freed with ecma_free_value.
        -: 1239: *
        -: 1240: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1241: *         successful. Otherwise it returns with an error object
        -: 1242: *         or ECMA_VALUE_FALSE.
        -: 1243: *
        -: 1244: *         Note: even if is_throw is false, the setter can throw an
        -: 1245: *         error, and this function returns with that error.
        -: 1246: */
        -: 1247:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        7: 1248:ecma_op_object_put (ecma_object_t *object_p, /**< the object */
        -: 1249:                    ecma_string_t *property_name_p, /**< property name */
        -: 1250:                    ecma_value_t value, /**< ecma value */
        -: 1251:                    bool is_throw) /**< flag that controls failure handling */
        -: 1252:{
        7: 1253:  return ecma_op_object_put_with_receiver (object_p,
        -: 1254:                                           property_name_p,
        -: 1255:                                           value,
        -: 1256:                                           ecma_make_object_value (object_p),
        -: 1257:                                           is_throw);
        -: 1258:} /* ecma_op_object_put */
        -: 1259:
        -: 1260:#if JERRY_ESNEXT
        -: 1261:/**
        -: 1262: * [[Set]] ( P, V, Receiver) operation part for ordinary objects
        -: 1263: *
        -: 1264: * See also: ECMAScript v6, 9.19.9
        -: 1265: *
        -: 1266: * @return ecma value
        -: 1267: *         The returned value must be freed with ecma_free_value.
        -: 1268: */
        -: 1269:static ecma_value_t
        5: 1270:ecma_op_object_put_apply_receiver (ecma_value_t receiver, /**< receiver */
        -: 1271:                                   ecma_string_t *property_name_p, /**< property name */
        -: 1272:                                   ecma_value_t value, /**< value to set */
        -: 1273:                                   bool is_throw) /**< flag that controls failure handling */
        -: 1274:{
        -: 1275:  /* 5.b */
        5: 1276:  if (!ecma_is_value_object (receiver))
        -: 1277:  {
    #####: 1278:    return ECMA_REJECT (is_throw, "Receiver must be an object");
        -: 1279:  }
        -: 1280:
        5: 1281:  ecma_object_t *receiver_obj_p = ecma_get_object_from_value (receiver);
        -: 1282:
        5: 1283:  ecma_property_descriptor_t prop_desc;
        -: 1284:  /* 5.c */
        5: 1285:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (receiver_obj_p,
        -: 1286:                                                                    property_name_p,
        -: 1287:                                                                    &prop_desc);
        -: 1288:
        -: 1289:  /* 5.d */
        5: 1290:  if (ECMA_IS_VALUE_ERROR (status))
        -: 1291:  {
    #####: 1292:    return status;
        -: 1293:  }
        -: 1294:
        -: 1295:  /* 5.e */
        5: 1296:  if (ecma_is_value_true (status))
        -: 1297:  {
        -: 1298:    ecma_value_t result;
        -: 1299:
        -: 1300:    /* 5.e.i - 5.e.ii */
    #####: 1301:    if (prop_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)
    #####: 1302:        || !(prop_desc.flags & JERRY_PROP_IS_WRITABLE))
        -: 1303:    {
    #####: 1304:      result = ecma_raise_property_redefinition (property_name_p, prop_desc.flags);
        -: 1305:    }
        -: 1306:    else
        -: 1307:    {
        -: 1308:      /* 5.e.iii */
    #####: 1309:      JERRY_ASSERT (prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED);
    #####: 1310:      ecma_free_value (prop_desc.value);
    #####: 1311:      prop_desc.value = ecma_copy_value (value);
        -: 1312:
        -: 1313:      /* 5.e.iv */
    #####: 1314:      result = ecma_op_object_define_own_property (receiver_obj_p, property_name_p, &prop_desc);
        -: 1315:
    #####: 1316:      if (JERRY_UNLIKELY (ecma_is_value_false (result)))
        -: 1317:      {
    #####: 1318:        result = ECMA_REJECT (is_throw, "Proxy trap returned falsish");
        -: 1319:      }
        -: 1320:    }
        -: 1321:
    #####: 1322:    ecma_free_property_descriptor (&prop_desc);
        -: 1323:
    #####: 1324:    return result;
        -: 1325:  }
        -: 1326:
        -: 1327:#if JERRY_BUILTIN_PROXY
        5: 1328:  if (ECMA_OBJECT_IS_PROXY (receiver_obj_p))
        -: 1329:  {
    #####: 1330:    ecma_property_descriptor_t desc;
        -: 1331:    /* Based on: ES6 9.1.9 [[Set]] 4.d.i. / ES11 9.1.9.2 OrdinarySetWithOwnDescriptor 2.c.i. */
    #####: 1332:    desc.flags = (JERRY_PROP_IS_CONFIGURABLE
        -: 1333:                  | JERRY_PROP_IS_CONFIGURABLE_DEFINED
        -: 1334:                  | JERRY_PROP_IS_ENUMERABLE
        -: 1335:                  | JERRY_PROP_IS_ENUMERABLE_DEFINED
        -: 1336:                  | JERRY_PROP_IS_WRITABLE
        -: 1337:                  | JERRY_PROP_IS_WRITABLE_DEFINED
        -: 1338:                  | JERRY_PROP_IS_VALUE_DEFINED);
    #####: 1339:    desc.value = value;
    #####: 1340:    ecma_value_t ret_value = ecma_proxy_object_define_own_property (receiver_obj_p, property_name_p, &desc);
        -: 1341:
    #####: 1342:    if (JERRY_UNLIKELY (ecma_is_value_false (ret_value)))
        -: 1343:    {
    #####: 1344:      ret_value = ECMA_REJECT (is_throw, "Proxy trap returned falsish");
        -: 1345:    }
        -: 1346:
    #####: 1347:    return ret_value;
        -: 1348:  }
        -: 1349:#endif /* JERRY_BUILTIN_PROXY */
        -: 1350:
        5: 1351:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (receiver_obj_p)))
        -: 1352:  {
    #####: 1353:    ecma_fast_array_convert_to_normal (receiver_obj_p);
        -: 1354:  }
        -: 1355:
        -: 1356:  /* 5.f.i */
        -: 1357:  ecma_property_value_t *new_prop_value_p;
        5: 1358:  new_prop_value_p = ecma_create_named_data_property (receiver_obj_p,
        -: 1359:                                                      property_name_p,
        -: 1360:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1361:                                                      NULL);
        5: 1362:  JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
        5: 1363:  new_prop_value_p->value = ecma_copy_value_if_not_object (value);
        -: 1364:
        5: 1365:  return ECMA_VALUE_TRUE;
        -: 1366:} /* ecma_op_object_put_apply_receiver */
        -: 1367:#endif /* JERRY_ESNEXT */
        -: 1368:
        -: 1369:/**
        -: 1370: * [[Put]] ecma general object's operation with given receiver
        -: 1371: *
        -: 1372: * See also:
        -: 1373: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1374: *          ECMA-262 v5, 8.12.5
        -: 1375: *          ECMA-262 v6, 9.1.9
        -: 1376: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1377: *
        -: 1378: * @return ecma value
        -: 1379: *         The returned value must be freed with ecma_free_value.
        -: 1380: *
        -: 1381: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1382: *         successful. Otherwise it returns with an error object
        -: 1383: *         or ECMA_VALUE_FALSE.
        -: 1384: *
        -: 1385: *         Note: even if is_throw is false, the setter can throw an
        -: 1386: *         error, and this function returns with that error.
        -: 1387: */
        -: 1388:ecma_value_t
        7: 1389:ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */
        -: 1390:                                  ecma_string_t *property_name_p, /**< property name */
        -: 1391:                                  ecma_value_t value, /**< ecma value */
        -: 1392:                                  ecma_value_t receiver, /**< receiver */
        -: 1393:                                  bool is_throw) /**< flag that controls failure handling */
        -: 1394:{
        7: 1395:  JERRY_ASSERT (object_p != NULL
        -: 1396:                && !ecma_is_lexical_environment (object_p));
        7: 1397:  JERRY_ASSERT (property_name_p != NULL);
        -: 1398:
        -: 1399:#if JERRY_BUILTIN_PROXY
        7: 1400:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1401:  {
    #####: 1402:    return ecma_proxy_object_set (object_p, property_name_p, value, receiver, is_throw);
        -: 1403:  }
        -: 1404:#endif /* JERRY_BUILTIN_PROXY */
        -: 1405:
        7: 1406:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -: 1407:
        7: 1408:  switch (base_type)
        -: 1409:  {
    #####: 1410:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -: 1411:    {
    #####: 1412:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1413:
    #####: 1414:      switch (ext_object_p->u.cls.type)
        -: 1415:      {
    #####: 1416:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1417:        {
    #####: 1418:          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -: 1419:          {
    #####: 1420:            break;
        -: 1421:          }
        -: 1422:
    #####: 1423:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1424:
    #####: 1425:          if (index < ext_object_p->u.cls.u2.formal_params_number)
        -: 1426:          {
    #####: 1427:            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -: 1428:
    #####: 1429:            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -: 1430:
    #####: 1431:            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -: 1432:            {
    #####: 1433:              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####: 1434:              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
    #####: 1435:              ecma_op_set_mutable_binding (lex_env_p, name_p, value, true);
    #####: 1436:              return ECMA_VALUE_TRUE;
        -: 1437:            }
        -: 1438:          }
    #####: 1439:          break;
        -: 1440:        }
        -: 1441:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1442:        /* ES2015 9.4.5.5 */
    #####: 1443:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 1444:        {
    #####: 1445:          if (ecma_prop_name_is_symbol (property_name_p))
        -: 1446:          {
    #####: 1447:            break;
        -: 1448:          }
        -: 1449:
    #####: 1450:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -: 1451:          bool is_same;
    #####: 1452:          if (num <= 0)
        -: 1453:          {
    #####: 1454:            is_same = true;
        -: 1455:          }
        -: 1456:          else
        -: 1457:          {
    #####: 1458:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####: 1459:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####: 1460:            ecma_deref_ecma_string (num_to_str);
        -: 1461:          }
        -: 1462:
    #####: 1463:          if (is_same)
        -: 1464:          {
    #####: 1465:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####: 1466:            return ecma_set_typedarray_element (&info, value, num);
        -: 1467:          }
    #####: 1468:          break;
        -: 1469:        }
        -: 1470:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1471:#if JERRY_MODULE_SYSTEM
    #####: 1472:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -: 1473:        {
    #####: 1474:          return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1475:        }
        -: 1476:#endif /* JERRY_MODULE_SYSTEM */
        -: 1477:      }
    #####: 1478:      break;
        -: 1479:    }
    #####: 1480:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -: 1481:    {
    #####: 1482:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1483:
    #####: 1484:      if (ecma_string_is_length (property_name_p))
        -: 1485:      {
    #####: 1486:        if (ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1487:        {
    #####: 1488:          return ecma_op_array_object_set_length (object_p, value, 0);
        -: 1489:        }
        -: 1490:
    #####: 1491:        return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1492:      }
        -: 1493:
    #####: 1494:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -: 1495:      {
    #####: 1496:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1497:
    #####: 1498:        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1499:        {
    #####: 1500:          ecma_fast_array_convert_to_normal (object_p);
        -: 1501:        }
    #####: 1502:        else if (ecma_fast_array_set_property (object_p, index, value))
        -: 1503:        {
    #####: 1504:          return ECMA_VALUE_TRUE;
        -: 1505:        }
        -: 1506:      }
        -: 1507:
    #####: 1508:      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
    #####: 1509:      break;
        -: 1510:    }
        7: 1511:    default:
        -: 1512:    {
        7: 1513:      break;
        -: 1514:    }
        -: 1515:  }
        -: 1516:
        7: 1517:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 1518:
        7: 1519:  if (property_p == NULL)
        -: 1520:  {
        5: 1521:    switch (ecma_get_object_type (object_p))
        -: 1522:    {
    #####: 1523:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1524:      {
    #####: 1525:        if (ecma_builtin_function_is_routine (object_p))
        -: 1526:        {
    #####: 1527:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####: 1528:          break;
        -: 1529:        }
        -: 1530:        /* FALLTHRU */
        -: 1531:      }
        -: 1532:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 1533:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1534:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1535:      {
        5: 1536:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        5: 1537:        break;
        -: 1538:      }
    #####: 1539:      case ECMA_OBJECT_TYPE_CLASS:
        -: 1540:      {
    #####: 1541:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1542:
    #####: 1543:        switch (ext_object_p->u.cls.type)
        -: 1544:        {
    #####: 1545:          case ECMA_OBJECT_CLASS_STRING:
        -: 1546:          {
    #####: 1547:            uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1548:
    #####: 1549:            if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1550:            {
    #####: 1551:              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####: 1552:              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -: 1553:
    #####: 1554:              if (index < ecma_string_get_length (prim_value_str_p))
        -: 1555:              {
    #####: 1556:                return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1557:              }
        -: 1558:            }
    #####: 1559:            break;
        -: 1560:          }
    #####: 1561:          case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1562:          {
    #####: 1563:            property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1564:            break;
        -: 1565:          }
        -: 1566:        }
    #####: 1567:        break;
        -: 1568:      }
    #####: 1569:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1570:      {
    #####: 1571:        if (ecma_string_is_length (property_name_p))
        -: 1572:        {
        -: 1573:          /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */
        -: 1574:#if JERRY_ESNEXT
    #####: 1575:          if (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp))
        -: 1576:#endif /* JERRY_ESNEXT */
        -: 1577:          {
    #####: 1578:            return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1579:          }
        -: 1580:        }
        -: 1581:
        -: 1582:        /* Get prototype physical property. */
    #####: 1583:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1584:        break;
        -: 1585:      }
    #####: 1586:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1587:      {
    #####: 1588:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1589:        break;
        -: 1590:      }
    #####: 1591:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1592:      {
    #####: 1593:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1594:        break;
        -: 1595:      }
    #####: 1596:      default:
        -: 1597:      {
    #####: 1598:        break;
        -: 1599:      }
        -: 1600:    }
        2: 1601:  }
        -: 1602:
        7: 1603:  jmem_cpointer_t setter_cp = JMEM_CP_NULL;
        -: 1604:
        7: 1605:  if (property_p != NULL)
        -: 1606:  {
        2: 1607:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -: 1608:
        2: 1609:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1610:    {
        2: 1611:      if (ecma_is_property_writable (*property_p))
        -: 1612:      {
        -: 1613:#if JERRY_ESNEXT
        2: 1614:        if (ecma_make_object_value (object_p) != receiver)
        -: 1615:        {
    #####: 1616:          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1617:        }
        -: 1618:#endif /* JERRY_ESNEXT */
        -: 1619:
        -: 1620:        /* There is no need for special casing arrays here because changing the
        -: 1621:         * value of an existing property never changes the length of an array. */
        4: 1622:        ecma_named_data_property_assign_value (object_p,
        2: 1623:                                               ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1624:                                               value);
        2: 1625:        return ECMA_VALUE_TRUE;
        -: 1626:      }
        -: 1627:    }
        -: 1628:    else
        -: 1629:    {
        -: 1630:      ecma_getter_setter_pointers_t *get_set_pair_p;
    #####: 1631:      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));
    #####: 1632:      setter_cp = get_set_pair_p->setter_cp;
        -: 1633:    }
        -: 1634:  }
        -: 1635:  else
        -: 1636:  {
        5: 1637:    bool create_new_property = true;
        -: 1638:
        -: 1639:    jmem_cpointer_t obj_cp;
        5: 1640:    ECMA_SET_NON_NULL_POINTER (obj_cp, object_p);
        5: 1641:    ecma_object_t *proto_p = object_p;
        -: 1642:
        -: 1643:    while (true)
        5: 1644:    {
       10: 1645:      obj_cp = ecma_op_ordinary_object_get_prototype_of (proto_p);
        -: 1646:
       10: 1647:      if (obj_cp == JMEM_CP_NULL)
        -: 1648:      {
        5: 1649:        break;
        -: 1650:      }
        -: 1651:
        5: 1652:      ecma_property_ref_t property_ref = { NULL };
        5: 1653:      proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_cp);
        -: 1654:
        -: 1655:#if JERRY_BUILTIN_PROXY
        5: 1656:      if (ECMA_OBJECT_IS_PROXY (proto_p))
        -: 1657:      {
    #####: 1658:        return ecma_op_object_put_with_receiver (proto_p,
        -: 1659:                                                 property_name_p,
        -: 1660:                                                 value,
        -: 1661:                                                 receiver,
        -: 1662:                                                 is_throw);
        -: 1663:      }
        -: 1664:#endif /* JERRY_BUILTIN_PROXY */
        -: 1665:
        5: 1666:      ecma_property_t inherited_property = ecma_op_object_get_own_property (proto_p,
        -: 1667:                                                                            property_name_p,
        -: 1668:                                                                            &property_ref,
        -: 1669:                                                                            ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 1670:
        5: 1671:      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND
    #####: 1672:          && inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -: 1673:      {
    #####: 1674:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (inherited_property));
        -: 1675:
    #####: 1676:        if (!(inherited_property & ECMA_PROPERTY_FLAG_DATA))
        -: 1677:        {
    #####: 1678:          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;
    #####: 1679:          create_new_property = false;
    #####: 1680:          break;
        -: 1681:        }
        -: 1682:
    #####: 1683:        create_new_property = ecma_is_property_writable (inherited_property);
    #####: 1684:        break;
        -: 1685:      }
        -: 1686:    }
        -: 1687:
        -: 1688:#if JERRY_BUILTIN_PROXY
        5: 1689:    if (create_new_property
        5: 1690:        && ecma_is_value_object (receiver)
        5: 1691:        && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (receiver)))
        -: 1692:    {
    #####: 1693:      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1694:    }
        -: 1695:#endif /* JERRY_BUILTIN_PROXY */
        -: 1696:
        5: 1697:    if (create_new_property
        5: 1698:        && ecma_op_ordinary_object_is_extensible (object_p))
        -: 1699:    {
        5: 1700:      const ecma_object_base_type_t obj_base_type = ecma_get_object_base_type (object_p);
        -: 1701:
        5: 1702:      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1703:      {
    #####: 1704:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1705:
    #####: 1706:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS
    #####: 1707:            && ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -: 1708:        {
    #####: 1709:          const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 1710:          return ecma_builtin_helper_def_prop (object_p, property_name_p, value, flags);
        -: 1711:        }
        -: 1712:      }
        -: 1713:
        5: 1714:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1715:
        5: 1716:      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_ARRAY
    #####: 1717:          && index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1718:      {
    #####: 1719:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1720:
    #####: 1721:        if (index < UINT32_MAX
    #####: 1722:            && index >= ext_object_p->u.array.length)
        -: 1723:        {
    #####: 1724:          if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1725:          {
    #####: 1726:            return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1727:          }
        -: 1728:
    #####: 1729:          ext_object_p->u.array.length = index + 1;
        -: 1730:        }
        -: 1731:      }
        -: 1732:
        -: 1733:#if JERRY_ESNEXT
        5: 1734:      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1735:#endif /* JERRY_ESNEXT */
        -: 1736:
        -: 1737:      ecma_property_value_t *new_prop_value_p;
    #####: 1738:      new_prop_value_p = ecma_create_named_data_property (object_p,
        -: 1739:                                                          property_name_p,
        -: 1740:                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1741:                                                          NULL);
        -: 1742:
        -: 1743:      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
    #####: 1744:      new_prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####: 1745:      return ECMA_VALUE_TRUE;
        -: 1746:    }
        -: 1747:  }
        -: 1748:
    #####: 1749:  if (setter_cp == JMEM_CP_NULL)
        -: 1750:  {
    #####: 1751:    return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1752:  }
        -: 1753:
    #####: 1754:  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),
        -: 1755:                                                  receiver,
        -: 1756:                                                  &value,
        -: 1757:                                                  1);
        -: 1758:
    #####: 1759:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -: 1760:  {
    #####: 1761:    ecma_fast_free_value (ret_value);
    #####: 1762:    ret_value = ECMA_VALUE_TRUE;
        -: 1763:  }
        -: 1764:
    #####: 1765:  return ret_value;
        -: 1766:} /* ecma_op_object_put_with_receiver */
        -: 1767:
        -: 1768:/**
        -: 1769: * [[Delete]] ecma object's operation specialized for property index
        -: 1770: *
        -: 1771: * Note:
        -: 1772: *      This method falls back to the general ecma_op_object_delete
        -: 1773: *
        -: 1774: * @return true - if deleted successfully
        -: 1775: *         false - or type error otherwise (based in 'is_throw')
        -: 1776: */
        -: 1777:ecma_value_t
    #####: 1778:ecma_op_object_delete_by_index (ecma_object_t *obj_p, /**< the object */
        -: 1779:                                ecma_length_t index, /**< property index */
        -: 1780:                                bool is_throw) /**< flag that controls failure handling */
        -: 1781:{
    #####: 1782:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1783:  {
    #####: 1784:    return ecma_op_object_delete (obj_p, ECMA_CREATE_DIRECT_UINT32_STRING (index), is_throw);;
        -: 1785:  }
        -: 1786:
    #####: 1787:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####: 1788:  ecma_value_t ret_value = ecma_op_object_delete (obj_p, index_str_p, is_throw);
    #####: 1789:  ecma_deref_ecma_string (index_str_p);
        -: 1790:
    #####: 1791:  return ret_value;
        -: 1792:} /* ecma_op_object_delete_by_index */
        -: 1793:
        -: 1794:/**
        -: 1795: * [[Delete]] ecma object's operation
        -: 1796: *
        -: 1797: * See also:
        -: 1798: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1799: *
        -: 1800: * Note:
        -: 1801: *      returned value must be freed with ecma_free_value
        -: 1802: *
        -: 1803: * @return true - if deleted successfully
        -: 1804: *         false - or type error otherwise (based in 'is_throw')
        -: 1805: */
        -: 1806:ecma_value_t
    #####: 1807:ecma_op_object_delete (ecma_object_t *obj_p, /**< the object */
        -: 1808:                       ecma_string_t *property_name_p, /**< property name */
        -: 1809:                       bool is_strict) /**< flag that controls failure handling */
        -: 1810:{
    #####: 1811:  JERRY_ASSERT (obj_p != NULL
        -: 1812:                && !ecma_is_lexical_environment (obj_p));
    #####: 1813:  JERRY_ASSERT (property_name_p != NULL);
        -: 1814:
        -: 1815:#if JERRY_BUILTIN_PROXY
    #####: 1816:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 1817:  {
    #####: 1818:    return ecma_proxy_object_delete_property (obj_p, property_name_p, is_strict);
        -: 1819:  }
        -: 1820:#endif /* JERRY_BUILTIN_PROXY */
        -: 1821:
    #####: 1822:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1823:
    #####: 1824:  return ecma_op_general_object_delete (obj_p,
        -: 1825:                                        property_name_p,
        -: 1826:                                        is_strict);
        -: 1827:} /* ecma_op_object_delete */
        -: 1828:
        -: 1829:/**
        -: 1830: * [[DefaultValue]] ecma object's operation
        -: 1831: *
        -: 1832: * See also:
        -: 1833: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1834: *
        -: 1835: * @return ecma value
        -: 1836: *         Returned value must be freed with ecma_free_value
        -: 1837: */
        -: 1838:ecma_value_t
        5: 1839:ecma_op_object_default_value (ecma_object_t *obj_p, /**< the object */
        -: 1840:                              ecma_preferred_type_hint_t hint) /**< hint on preferred result type */
        -: 1841:{
        5: 1842:  JERRY_ASSERT (obj_p != NULL
        -: 1843:                && !ecma_is_lexical_environment (obj_p));
        -: 1844:
        5: 1845:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1846:
        -: 1847:  /*
        -: 1848:   * typedef ecma_property_t * (*default_value_ptr_t) (ecma_object_t *, ecma_string_t *);
        -: 1849:   * static const default_value_ptr_t default_value [ECMA_OBJECT_TYPE__COUNT] =
        -: 1850:   * {
        -: 1851:   *   [ECMA_OBJECT_TYPE_GENERAL]           = &ecma_op_general_object_default_value,
        -: 1852:   *   [ECMA_OBJECT_TYPE_CLASS]             = &ecma_op_general_object_default_value,
        -: 1853:   *   [ECMA_OBJECT_TYPE_FUNCTION]          = &ecma_op_general_object_default_value,
        -: 1854:   *   [ECMA_OBJECT_TYPE_NATIVE_FUNCTION]   = &ecma_op_general_object_default_value,
        -: 1855:   *   [ECMA_OBJECT_TYPE_ARRAY]             = &ecma_op_general_object_default_value,
        -: 1856:   *   [ECMA_OBJECT_TYPE_BOUND_FUNCTION]    = &ecma_op_general_object_default_value,
        -: 1857:   *   [ECMA_OBJECT_TYPE_PSEUDO_ARRAY]      = &ecma_op_general_object_default_value
        -: 1858:   * };
        -: 1859:   *
        -: 1860:   * return default_value[type] (obj_p, property_name_p);
        -: 1861:   */
        -: 1862:
        5: 1863:  return ecma_op_general_object_default_value (obj_p, hint);
        -: 1864:} /* ecma_op_object_default_value */
        -: 1865:
        -: 1866:/**
        -: 1867: * [[DefineOwnProperty]] ecma object's operation
        -: 1868: *
        -: 1869: * See also:
        -: 1870: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1871: *
        -: 1872: * @return ecma value
        -: 1873: *         Returned value must be freed with ecma_free_value
        -: 1874: */
        -: 1875:ecma_value_t
        1: 1876:ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */
        -: 1877:                                    ecma_string_t *property_name_p, /**< property name */
        -: 1878:                                    const ecma_property_descriptor_t *property_desc_p) /**< property
        -: 1879:                                                                                        *   descriptor */
        -: 1880:{
        1: 1881:  JERRY_ASSERT (obj_p != NULL
        -: 1882:                && !ecma_is_lexical_environment (obj_p));
        1: 1883:  JERRY_ASSERT (property_name_p != NULL);
        -: 1884:
        1: 1885:  const ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 1886:
        1: 1887:  switch (type)
        -: 1888:  {
    #####: 1889:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1890:    {
    #####: 1891:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 1892:
    #####: 1893:      switch (ext_object_p->u.cls.type)
        -: 1894:      {
    #####: 1895:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1896:        {
    #####: 1897:          return ecma_op_arguments_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1898:        }
        -: 1899:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1900:        /* ES2015 9.4.5.1 */
    #####: 1901:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 1902:        {
    #####: 1903:          return ecma_op_typedarray_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1904:        }
        -: 1905:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1906:      }
    #####: 1907:      break;
        -: 1908:    }
    #####: 1909:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1910:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1911:    {
    #####: 1912:      return ecma_op_array_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1913:    }
        -: 1914:#if JERRY_BUILTIN_PROXY
    #####: 1915:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1916:    {
    #####: 1917:      return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1918:    }
        -: 1919:#endif /* JERRY_BUILTIN_PROXY */
        1: 1920:    default:
        -: 1921:    {
        1: 1922:      break;
        -: 1923:    }
        -: 1924:  }
        -: 1925:
        1: 1926:  return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1927:} /* ecma_op_object_define_own_property */
        -: 1928:
        -: 1929:/**
        -: 1930: * Get property descriptor from specified property
        -: 1931: *
        -: 1932: * depending on the property type the following fields are set:
        -: 1933: *   - for named data properties: { [Value], [Writable], [Enumerable], [Configurable] };
        -: 1934: *   - for named accessor properties: { [Get] - if defined,
        -: 1935: *                                      [Set] - if defined,
        -: 1936: *                                      [Enumerable], [Configurable]
        -: 1937: *                                    }.
        -: 1938: *
        -: 1939: * The output property descriptor will always be initialized to an empty descriptor.
        -: 1940: *
        -: 1941: * @return ECMA_VALUE_ERROR - if the Proxy.[[GetOwnProperty]] operation raises error
        -: 1942: *         ECMA_VALUE_{TRUE, FALSE} - if property found or not
        -: 1943: */
        -: 1944:ecma_value_t
      151: 1945:ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */
        -: 1946:                                            ecma_string_t *property_name_p, /**< property name */
        -: 1947:                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 1948:{
      151: 1949:  *prop_desc_p = ecma_make_empty_property_descriptor ();
        -: 1950:
        -: 1951:#if JERRY_BUILTIN_PROXY
      151: 1952:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1953:  {
       64: 1954:    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);
        -: 1955:  }
        -: 1956:#endif /* JERRY_BUILTIN_PROXY */
        -: 1957:
       87: 1958:  ecma_property_ref_t property_ref;
       87: 1959:  property_ref.virtual_value = ECMA_VALUE_EMPTY;
       87: 1960:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 1961:                                                              property_name_p,
        -: 1962:                                                              &property_ref,
        -: 1963:                                                              ECMA_PROPERTY_GET_VALUE);
        -: 1964:
       87: 1965:  if (ECMA_IS_VALUE_ERROR (property_ref.virtual_value))
        -: 1966:  {
    #####: 1967:    return property_ref.virtual_value;
        -: 1968:  }
        -: 1969:
       87: 1970:  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -: 1971:  {
        5: 1972:    return ECMA_VALUE_FALSE;
        -: 1973:  }
        -: 1974:
       82: 1975:  uint32_t flags = ecma_is_property_enumerable (property) ? JERRY_PROP_IS_ENUMERABLE : JERRY_PROP_NO_OPTS;
       82: 1976:  flags |= ecma_is_property_configurable (property) ? JERRY_PROP_IS_CONFIGURABLE: JERRY_PROP_NO_OPTS;
        -: 1977:
       82: 1978:  prop_desc_p->flags = (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE_DEFINED | flags);
        -: 1979:
       82: 1980:  if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1981:  {
       81: 1982:    if (!ECMA_PROPERTY_IS_VIRTUAL (property))
        -: 1983:    {
       81: 1984:      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);
        -: 1985:    }
        -: 1986:    else
        -: 1987:    {
        -: 1988:#if JERRY_MODULE_SYSTEM
    #####: 1989:      if (JERRY_UNLIKELY (property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))
        -: 1990:      {
    #####: 1991:        return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -: 1992:      }
        -: 1993:#endif /* JERRY_MODULE_SYSTEM */
    #####: 1994:      prop_desc_p->value = property_ref.virtual_value;
        -: 1995:    }
        -: 1996:
       81: 1997:    prop_desc_p->flags |= (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED);
       81: 1998:    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? JERRY_PROP_IS_WRITABLE
        -: 1999:                                                                                                : JERRY_PROP_NO_OPTS));
        -: 2000:  }
        -: 2001:  else
        -: 2002:  {
        1: 2003:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);
        1: 2004:    prop_desc_p->flags |= (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED);
        -: 2005:
        1: 2006:    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -: 2007:    {
    #####: 2008:      prop_desc_p->get_p = NULL;
        -: 2009:    }
        -: 2010:    else
        -: 2011:    {
        1: 2012:      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
        1: 2013:      ecma_ref_object (prop_desc_p->get_p);
        -: 2014:    }
        -: 2015:
        1: 2016:    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)
        -: 2017:    {
    #####: 2018:      prop_desc_p->set_p = NULL;
        -: 2019:    }
        -: 2020:    else
        -: 2021:    {
        1: 2022:      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);
        1: 2023:      ecma_ref_object (prop_desc_p->set_p);
        -: 2024:    }
        -: 2025:  }
        -: 2026:
       82: 2027:  return ECMA_VALUE_TRUE;
        -: 2028:} /* ecma_op_object_get_own_property_descriptor */
        -: 2029:
        -: 2030:#if JERRY_BUILTIN_PROXY
        -: 2031:/**
        -: 2032: * Get property descriptor from a target value for a specified property.
        -: 2033: *
        -: 2034: * For more details see ecma_op_object_get_own_property_descriptor
        -: 2035: *
        -: 2036: * @return ECMA_VALUE_ERROR - if the Proxy.[[GetOwnProperty]] operation raises error
        -: 2037: *         ECMA_VALUE_{TRUE, FALSE} - if property found or not
        -: 2038: */
        -: 2039:ecma_value_t
        1: 2040:ecma_op_get_own_property_descriptor (ecma_value_t target, /**< target value */
        -: 2041:                                     ecma_string_t *property_name_p, /**< property name */
        -: 2042:                                     ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 2043:{
        1: 2044:  if (!ecma_is_value_object (target))
        -: 2045:  {
    #####: 2046:    return ECMA_VALUE_FALSE;
        -: 2047:  }
        -: 2048:
        1: 2049:  return ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (target), property_name_p, prop_desc_p);
        -: 2050:} /* ecma_op_get_own_property_descriptor */
        -: 2051:#endif /* JERRY_BUILTIN_PROXY */
        -: 2052:
        -: 2053:/**
        -: 2054: * [[HasInstance]] ecma object's operation
        -: 2055: *
        -: 2056: * See also:
        -: 2057: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 9
        -: 2058: *
        -: 2059: * @return ecma value containing a boolean value or an error
        -: 2060: *         Returned value must be freed with ecma_free_value
        -: 2061: */
        -: 2062:ecma_value_t
    #####: 2063:ecma_op_object_has_instance (ecma_object_t *obj_p, /**< the object */
        -: 2064:                             ecma_value_t value) /**< argument 'V' */
        -: 2065:{
    #####: 2066:  JERRY_ASSERT (obj_p != NULL
        -: 2067:                && !ecma_is_lexical_environment (obj_p));
        -: 2068:
    #####: 2069:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 2070:
    #####: 2071:  if (ecma_op_object_is_callable (obj_p))
        -: 2072:  {
    #####: 2073:    return ecma_op_function_has_instance (obj_p, value);
        -: 2074:  }
        -: 2075:
    #####: 2076:  return ecma_raise_type_error (ECMA_ERR_MSG ("Expected a function object"));
        -: 2077:} /* ecma_op_object_has_instance */
        -: 2078:
        -: 2079:/**
        -: 2080: * General [[GetPrototypeOf]] abstract operation
        -: 2081: *
        -: 2082: * Note: returned valid object must be freed.
        -: 2083: *
        -: 2084: * @return ecma_object_t * - prototype of the input object.
        -: 2085: *         ECMA_OBJECT_POINTER_ERROR - error reported during Proxy resolve.
        -: 2086: *         NULL - the input object does not have a prototype.
        -: 2087: */
        -: 2088:ecma_object_t *
        2: 2089:ecma_op_object_get_prototype_of (ecma_object_t *obj_p) /**< input object */
        -: 2090:{
        2: 2091:  JERRY_ASSERT (obj_p != NULL);
        -: 2092:
        -: 2093:#if JERRY_BUILTIN_PROXY
        2: 2094:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2095:  {
        1: 2096:    ecma_value_t proto = ecma_proxy_object_get_prototype_of (obj_p);
        -: 2097:
        1: 2098:    if (ECMA_IS_VALUE_ERROR (proto))
        -: 2099:    {
    #####: 2100:      return ECMA_OBJECT_POINTER_ERROR;
        -: 2101:    }
        1: 2102:    if (ecma_is_value_null (proto))
        -: 2103:    {
    #####: 2104:      return NULL;
        -: 2105:    }
        -: 2106:
        1: 2107:    JERRY_ASSERT (ecma_is_value_object (proto));
        -: 2108:
        1: 2109:    return ecma_get_object_from_value (proto);
        -: 2110:  }
        -: 2111:  else
        -: 2112:#endif /* JERRY_BUILTIN_PROXY */
        -: 2113:  {
        1: 2114:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (obj_p);
        -: 2115:
        1: 2116:    if (proto_cp == JMEM_CP_NULL)
        -: 2117:    {
        1: 2118:      return NULL;
        -: 2119:    }
        -: 2120:
    #####: 2121:    ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
    #####: 2122:    ecma_ref_object (proto_p);
        -: 2123:
    #####: 2124:    return proto_p;
        -: 2125:  }
        -: 2126:} /* ecma_op_object_get_prototype_of */
        -: 2127:
        -: 2128:/**
        -: 2129: * Object's isPrototypeOf operation
        -: 2130: *
        -: 2131: * See also:
        -: 2132: *          ECMA-262 v5, 15.2.4.6; 3
        -: 2133: *
        -: 2134: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2135: *         ECMA_VALUE_TRUE - if the target object is prototype of the base object
        -: 2136: *         ECMA_VALUE_FALSE - if the target object is not prototype of the base object
        -: 2137: */
        -: 2138:ecma_value_t
    #####: 2139:ecma_op_object_is_prototype_of (ecma_object_t *base_p, /**< base object */
        -: 2140:                                ecma_object_t *target_p) /**< target object */
        -: 2141:{
    #####: 2142:  ecma_ref_object (target_p);
        -: 2143:
        -: 2144:  do
    #####: 2145:  {
    #####: 2146:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (target_p);
    #####: 2147:    ecma_deref_object (target_p);
        -: 2148:
    #####: 2149:    if (proto_p == NULL)
        -: 2150:    {
    #####: 2151:      return ECMA_VALUE_FALSE;
        -: 2152:    }
    #####: 2153:    else if (proto_p == ECMA_OBJECT_POINTER_ERROR)
        -: 2154:    {
    #####: 2155:      return ECMA_VALUE_ERROR;
        -: 2156:    }
    #####: 2157:    else if (proto_p == base_p)
        -: 2158:    {
    #####: 2159:      ecma_deref_object (proto_p);
    #####: 2160:      return ECMA_VALUE_TRUE;
        -: 2161:    }
        -: 2162:
        -: 2163:    /* Advance up on prototype chain. */
    #####: 2164:    target_p = proto_p;
        -: 2165:  }
        -: 2166:  while (true);
        -: 2167:} /* ecma_op_object_is_prototype_of */
        -: 2168:
        -: 2169:/**
        -: 2170: * Object's EnumerableOwnPropertyNames operation
        -: 2171: *
        -: 2172: * See also:
        -: 2173: *          ECMA-262 v11, 7.3.23
        -: 2174: *
        -: 2175: * @return NULL - if operation fails
        -: 2176: *         collection of property names / values / name-value pairs - otherwise
        -: 2177: */
        -: 2178:ecma_collection_t *
    #####: 2179:ecma_op_object_get_enumerable_property_names (ecma_object_t *obj_p, /**< routine's first argument */
        -: 2180:                                              ecma_enumerable_property_names_options_t option) /**< listing option */
        -: 2181:{
        -: 2182:  /* 2. */
    #####: 2183:  ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_p, JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS);
        -: 2184:
        -: 2185:#if JERRY_BUILTIN_PROXY
    #####: 2186:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -: 2187:  {
    #####: 2188:    return prop_names_p;
        -: 2189:  }
        -: 2190:#endif /* JERRY_BUILTIN_PROXY */
        -: 2191:
    #####: 2192:  ecma_value_t *names_buffer_p = prop_names_p->buffer_p;
        -: 2193:  /* 3. */
    #####: 2194:  ecma_collection_t *properties_p = ecma_new_collection ();
        -: 2195:
        -: 2196:  /* 4. */
    #####: 2197:  for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 2198:  {
        -: 2199:    /* 4.a */
    #####: 2200:    if (ecma_is_value_string (names_buffer_p[i]))
        -: 2201:    {
    #####: 2202:      ecma_string_t *key_p = ecma_get_string_from_value (names_buffer_p[i]);
        -: 2203:
        -: 2204:      /* 4.a.i */
    #####: 2205:      ecma_property_descriptor_t prop_desc;
    #####: 2206:      ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_p, key_p, &prop_desc);
        -: 2207:
    #####: 2208:      if (ECMA_IS_VALUE_ERROR (status))
        -: 2209:      {
    #####: 2210:        ecma_collection_free (prop_names_p);
    #####: 2211:        ecma_collection_free (properties_p);
        -: 2212:
    #####: 2213:        return NULL;
        -: 2214:      }
        -: 2215:
    #####: 2216:      const bool is_enumerable = (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE) != 0;
    #####: 2217:      ecma_free_property_descriptor (&prop_desc);
        -: 2218:      /* 4.a.ii */
    #####: 2219:      if (is_enumerable)
        -: 2220:      {
        -: 2221:        /* 4.a.ii.1 */
    #####: 2222:        if (option == ECMA_ENUMERABLE_PROPERTY_KEYS)
        -: 2223:        {
    #####: 2224:          ecma_collection_push_back (properties_p, ecma_copy_value (names_buffer_p[i]));
        -: 2225:        }
        -: 2226:        else
        -: 2227:        {
        -: 2228:          /* 4.a.ii.2.a */
    #####: 2229:          ecma_value_t value = ecma_op_object_get (obj_p, key_p);
        -: 2230:
    #####: 2231:          if (ECMA_IS_VALUE_ERROR (value))
        -: 2232:          {
    #####: 2233:            ecma_collection_free (prop_names_p);
    #####: 2234:            ecma_collection_free (properties_p);
        -: 2235:
    #####: 2236:            return NULL;
        -: 2237:          }
        -: 2238:
        -: 2239:          /* 4.a.ii.2.b */
    #####: 2240:          if (option == ECMA_ENUMERABLE_PROPERTY_VALUES)
        -: 2241:          {
    #####: 2242:            ecma_collection_push_back (properties_p, value);
        -: 2243:          }
        -: 2244:          else
        -: 2245:          {
        -: 2246:            /* 4.a.ii.2.c.i */
    #####: 2247:            JERRY_ASSERT (option == ECMA_ENUMERABLE_PROPERTY_ENTRIES);
        -: 2248:
        -: 2249:            /* 4.a.ii.2.c.ii */
    #####: 2250:            ecma_object_t *entry_p = ecma_op_new_array_object (2);
        -: 2251:
    #####: 2252:            ecma_builtin_helper_def_prop_by_index (entry_p,
        -: 2253:                                                   0,
    #####: 2254:                                                   names_buffer_p[i],
        -: 2255:                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2256:            ecma_builtin_helper_def_prop_by_index (entry_p,
        -: 2257:                                                   1,
        -: 2258:                                                   value,
        -: 2259:                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2260:            ecma_free_value (value);
        -: 2261:
        -: 2262:            /* 4.a.ii.2.c.iii */
    #####: 2263:            ecma_collection_push_back (properties_p, ecma_make_object_value (entry_p));
        -: 2264:          }
        -: 2265:        }
        -: 2266:      }
        -: 2267:    }
        -: 2268:  }
        -: 2269:
    #####: 2270:  ecma_collection_free (prop_names_p);
        -: 2271:
    #####: 2272:  return properties_p;
        -: 2273:} /* ecma_op_object_get_enumerable_property_names */
        -: 2274:
        -: 2275:/**
        -: 2276: * Helper method for getting lazy instantiated properties for [[OwnPropertyKeys]]
        -: 2277: */
        -: 2278:static void
        2: 2279:ecma_object_list_lazy_property_names (ecma_object_t *obj_p, /**< object */
        -: 2280:                                      ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 2281:                                      ecma_property_counter_t *prop_counter_p, /**< property counters */
        -: 2282:                                      jerry_property_filter_t filter) /**< property name filter options */
        -: 2283:{
        2: 2284:  switch (ecma_get_object_type (obj_p))
        -: 2285:  {
    #####: 2286:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 2287:    {
    #####: 2288:      if (ecma_builtin_function_is_routine (obj_p))
        -: 2289:      {
    #####: 2290:        ecma_builtin_routine_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2291:        break;
        -: 2292:      }
        -: 2293:      /* FALLTHRU */
        -: 2294:    }
        -: 2295:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 2296:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 2297:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2298:    {
        2: 2299:      ecma_builtin_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
        2: 2300:      break;
        -: 2301:    }
    #####: 2302:    case ECMA_OBJECT_TYPE_CLASS:
        -: 2303:    {
    #####: 2304:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 2305:
    #####: 2306:      switch (ext_object_p->u.cls.type)
        -: 2307:      {
    #####: 2308:        case ECMA_OBJECT_CLASS_STRING:
        -: 2309:        {
    #####: 2310:          ecma_op_string_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2311:          break;
        -: 2312:        }
    #####: 2313:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 2314:        {
    #####: 2315:          ecma_op_arguments_object_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2316:          break;
        -: 2317:        }
        -: 2318:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2319:        /* ES2015 9.4.5.1 */
    #####: 2320:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 2321:        {
    #####: 2322:          ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2323:          break;
        -: 2324:        }
        -: 2325:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2326:      }
    #####: 2327:      break;
        -: 2328:    }
    #####: 2329:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 2330:    {
    #####: 2331:      ecma_op_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2332:      break;
        -: 2333:    }
    #####: 2334:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 2335:    {
    #####: 2336:      ecma_op_external_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2337:      break;
        -: 2338:    }
    #####: 2339:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 2340:    {
    #####: 2341:      ecma_op_bound_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2342:      break;
        -: 2343:    }
    #####: 2344:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 2345:    {
    #####: 2346:      if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -: 2347:      {
    #####: 2348:        ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####: 2349:        prop_counter_p->string_named_props++;
        -: 2350:      }
    #####: 2351:      break;
        -: 2352:    }
    #####: 2353:    default:
        -: 2354:    {
    #####: 2355:      JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_GENERAL
        -: 2356:                    || ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
    #####: 2357:      break;
        -: 2358:    }
        -: 2359:  }
        2: 2360:} /* ecma_object_list_lazy_property_names */
        -: 2361:
        -: 2362:/**
        -: 2363: * Helper routine for heapsort algorithm.
        -: 2364: */
        -: 2365:static void
    #####: 2366:ecma_op_object_heap_sort_shift_down (ecma_value_t *buffer_p, /**< array of items */
        -: 2367:                                     uint32_t item_count, /**< number of items */
        -: 2368:                                     uint32_t item_index) /**< index of updated item */
        -: 2369:{
        -: 2370:  while (true)
    #####: 2371:  {
    #####: 2372:    uint32_t highest_index = item_index;
    #####: 2373:    uint32_t current_index = (item_index << 1) + 1;
        -: 2374:
    #####: 2375:    if (current_index >= item_count)
        -: 2376:    {
    #####: 2377:      return;
        -: 2378:    }
        -: 2379:
    #####: 2380:    uint32_t value = ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[highest_index]));
    #####: 2381:    uint32_t left_value = ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[current_index]));
        -: 2382:
    #####: 2383:    if (value < left_value)
        -: 2384:    {
    #####: 2385:      highest_index = current_index;
    #####: 2386:      value = left_value;
        -: 2387:    }
        -: 2388:
    #####: 2389:    current_index++;
        -: 2390:
    #####: 2391:    if (current_index < item_count
    #####: 2392:        && value < ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[current_index])))
        -: 2393:    {
    #####: 2394:      highest_index = current_index;
        -: 2395:    }
        -: 2396:
    #####: 2397:    if (highest_index == item_index)
        -: 2398:    {
    #####: 2399:      return;
        -: 2400:    }
        -: 2401:
    #####: 2402:    ecma_value_t tmp = buffer_p[highest_index];
    #####: 2403:    buffer_p[highest_index] = buffer_p[item_index];
    #####: 2404:    buffer_p[item_index] = tmp;
        -: 2405:
    #####: 2406:    item_index = highest_index;
        -: 2407:  }
        -: 2408:} /* ecma_op_object_heap_sort_shift_down */
        -: 2409:
        -: 2410:/**
        -: 2411: * Object's [[OwnPropertyKeys]] internal method
        -: 2412: *
        -: 2413: * Order of names in the collection:
        -: 2414: *  - integer indices in ascending order
        -: 2415: *  - other indices in creation order (for built-ins: the order of the properties are listed in specification).
        -: 2416: *
        -: 2417: * Note:
        -: 2418: *      Implementation of the routine assumes that new properties are appended to beginning of corresponding object's
        -: 2419: *      property list, and the list is not reordered (in other words, properties are stored in order that is reversed
        -: 2420: *      to the properties' addition order).
        -: 2421: *
        -: 2422: * @return NULL - if the Proxy.[[OwnPropertyKeys]] operation raises error
        -: 2423: *         collection of property names - otherwise
        -: 2424: */
        -: 2425:ecma_collection_t *
        3: 2426:ecma_op_object_own_property_keys (ecma_object_t *obj_p, /**< object */
        -: 2427:                                  jerry_property_filter_t filter) /**< name filters */
        -: 2428:{
        -: 2429:#if JERRY_BUILTIN_PROXY
        3: 2430:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2431:  {
        1: 2432:    return ecma_proxy_object_own_property_keys (obj_p);
        -: 2433:  }
        -: 2434:#endif /* JERRY_BUILTIN_PROXY */
        -: 2435:
        2: 2436:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2437:  {
    #####: 2438:    return ecma_fast_array_object_own_property_keys (obj_p, filter);
        -: 2439:  }
        -: 2440:
        2: 2441:  ecma_collection_t *prop_names_p = ecma_new_collection ();
        2: 2442:  ecma_property_counter_t prop_counter = {0, 0, 0};
        -: 2443:
        2: 2444:  ecma_object_list_lazy_property_names (obj_p, prop_names_p, &prop_counter, filter);
        -: 2445:
        2: 2446:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 2447:
        -: 2448:#if JERRY_PROPERTY_HASHMAP
        2: 2449:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 2450:  {
        1: 2451:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -: 2452:
        1: 2453:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 2454:    {
    #####: 2455:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2456:    }
        -: 2457:  }
        -: 2458:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 2459:
        2: 2460:  jmem_cpointer_t counter_prop_iter_cp = prop_iter_cp;
        -: 2461:
        2: 2462:  uint32_t array_index_named_props = 0;
        2: 2463:  uint32_t string_named_props = 0;
        -: 2464:#if JERRY_ESNEXT
        2: 2465:  uint32_t symbol_named_props = 0;
        -: 2466:#endif /* JERRY_ESNEXT */
        -: 2467:
        8: 2468:  while (counter_prop_iter_cp != JMEM_CP_NULL)
        -: 2469:  {
        4: 2470:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, counter_prop_iter_cp);
        4: 2471:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 2472:
       12: 2473:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 2474:    {
        8: 2475:      ecma_property_t *property_p = prop_iter_p->types + i;
        -: 2476:
        8: 2477:      if (!ECMA_PROPERTY_IS_RAW (*property_p)
        8: 2478:          || (*property_p & ECMA_PROPERTY_FLAG_BUILT_IN))
        -: 2479:      {
        2: 2480:        continue;
        -: 2481:      }
        -: 2482:
        6: 2483:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 2484:
        6: 2485:      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
    #####: 2486:          && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 2487:          && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)
        -: 2488:      {
    #####: 2489:        continue;
        -: 2490:      }
        -: 2491:
        6: 2492:      ecma_string_t *name_p = ecma_string_from_property_name (*property_p,
    #####: 2493:                                                              prop_pair_p->names_cp[i]);
        -: 2494:
        6: 2495:      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2496:      {
    #####: 2497:        array_index_named_props++;
        -: 2498:      }
        -: 2499:#if JERRY_ESNEXT
        6: 2500:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2501:      {
    #####: 2502:        symbol_named_props++;
        -: 2503:      }
        -: 2504:#endif /* JERRY_ESNEXT */
        -: 2505:      else
        -: 2506:      {
        6: 2507:        string_named_props++;
        -: 2508:      }
        -: 2509:
        6: 2510:      ecma_deref_ecma_string (name_p);
        -: 2511:    }
        -: 2512:
        4: 2513:    counter_prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2514:  }
        -: 2515:
        2: 2516:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
        -: 2517:  {
    #####: 2518:    JERRY_ASSERT (prop_counter.array_index_named_props == 0);
    #####: 2519:    array_index_named_props = 0;
        -: 2520:  }
        -: 2521:
        2: 2522:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 2523:  {
    #####: 2524:    JERRY_ASSERT (prop_counter.string_named_props == 0);
    #####: 2525:    string_named_props = 0;
        -: 2526:  }
        -: 2527:
        -: 2528:#if JERRY_ESNEXT
        2: 2529:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
        -: 2530:  {
        1: 2531:    JERRY_ASSERT (prop_counter.symbol_named_props == 0);
        1: 2532:    symbol_named_props = 0;
        -: 2533:  }
        -: 2534:
        2: 2535:  uint32_t total = array_index_named_props + string_named_props + symbol_named_props;
        -: 2536:#else /* !JERRY_ESNEXT */
    #####: 2537:  uint32_t total = array_index_named_props + string_named_props;
        -: 2538:#endif /* JERRY_ESNEXT */
        -: 2539:
        2: 2540:  if (total == 0)
        -: 2541:  {
        1: 2542:    return prop_names_p;
        -: 2543:  }
        -: 2544:
        1: 2545:  ecma_collection_reserve (prop_names_p, total);
        1: 2546:  prop_names_p->item_count += total;
        -: 2547:
        1: 2548:  ecma_value_t *buffer_p = prop_names_p->buffer_p;
        1: 2549:  ecma_value_t *array_index_current_p = buffer_p + array_index_named_props + prop_counter.array_index_named_props;
        1: 2550:  ecma_value_t *string_current_p = array_index_current_p + string_named_props + prop_counter.string_named_props;
        -: 2551:
        -: 2552:#if JERRY_ESNEXT
        1: 2553:  ecma_value_t *symbol_current_p = string_current_p + symbol_named_props + prop_counter.symbol_named_props;
        -: 2554:
        1: 2555:  if (prop_counter.symbol_named_props > 0
    #####: 2556:      && (array_index_named_props + string_named_props) > 0)
        -: 2557:  {
    #####: 2558:    memmove ((void *) string_current_p,
    #####: 2559:             (void *) (buffer_p + prop_counter.array_index_named_props + prop_counter.string_named_props),
    #####: 2560:             prop_counter.symbol_named_props * sizeof (ecma_value_t));
        -: 2561:  }
        -: 2562:#endif /* JERRY_ESNEXT */
        -: 2563:
        1: 2564:  if (prop_counter.string_named_props > 0
        1: 2565:      && array_index_named_props > 0)
        -: 2566:  {
    #####: 2567:    memmove ((void *) array_index_current_p,
    #####: 2568:             (void *) (buffer_p + prop_counter.array_index_named_props),
    #####: 2569:             prop_counter.string_named_props * sizeof (ecma_value_t));
        -: 2570:  }
        -: 2571:
        6: 2572:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 2573:  {
        4: 2574:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        4: 2575:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 2576:
       12: 2577:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 2578:    {
        8: 2579:      ecma_property_t *property_p = prop_iter_p->types + i;
        -: 2580:
        8: 2581:      if (!ECMA_PROPERTY_IS_RAW (*property_p)
        8: 2582:          || (*property_p & ECMA_PROPERTY_FLAG_BUILT_IN))
        -: 2583:      {
        2: 2584:        continue;
        -: 2585:      }
        -: 2586:
        6: 2587:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 2588:
        6: 2589:      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
    #####: 2590:          && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 2591:          && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)
        -: 2592:      {
    #####: 2593:        continue;
        -: 2594:      }
        -: 2595:
        6: 2596:      ecma_string_t *name_p = ecma_string_from_property_name (*property_p,
    #####: 2597:                                                              prop_pair_p->names_cp[i]);
        -: 2598:
        6: 2599:      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2600:      {
    #####: 2601:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -: 2602:        {
    #####: 2603:          *(--array_index_current_p) = ecma_make_string_value (name_p);
    #####: 2604:          continue;
        -: 2605:        }
        -: 2606:      }
        -: 2607:#if JERRY_ESNEXT
        6: 2608:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2609:      {
    #####: 2610:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS))
        -: 2611:        {
    #####: 2612:          *(--symbol_current_p) = ecma_make_symbol_value (name_p);
    #####: 2613:          continue;
        -: 2614:        }
        -: 2615:      }
        -: 2616:#endif /* JERRY_ESNEXT */
        -: 2617:      else
        -: 2618:      {
        6: 2619:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -: 2620:        {
        6: 2621:          *(--string_current_p) = ecma_make_string_value (name_p);
        6: 2622:          continue;
        -: 2623:        }
        -: 2624:      }
        -: 2625:
    #####: 2626:      ecma_deref_ecma_string (name_p);
        -: 2627:    }
        -: 2628:
        4: 2629:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2630:  }
        -: 2631:
        1: 2632:  if (array_index_named_props > 1
        1: 2633:      || (array_index_named_props == 1 && prop_counter.array_index_named_props > 0))
        -: 2634:  {
    #####: 2635:    uint32_t prev_value = 0;
    #####: 2636:    ecma_value_t *array_index_p = buffer_p + prop_counter.array_index_named_props;
    #####: 2637:    ecma_value_t *array_index_end_p = array_index_p + array_index_named_props;
        -: 2638:
    #####: 2639:    if (prop_counter.array_index_named_props > 0)
        -: 2640:    {
    #####: 2641:      prev_value = ecma_string_get_array_index (ecma_get_string_from_value (array_index_p[-1]));
        -: 2642:    }
        -: 2643:
        -: 2644:    do
        -: 2645:    {
    #####: 2646:      uint32_t value = ecma_string_get_array_index (ecma_get_string_from_value (*array_index_p++));
        -: 2647:
    #####: 2648:      if (value < prev_value)
        -: 2649:      {
    #####: 2650:        uint32_t array_props = prop_counter.array_index_named_props + array_index_named_props;
    #####: 2651:        uint32_t i = (array_props >> 1) - 1;
        -: 2652:
        -: 2653:        do
        -: 2654:        {
    #####: 2655:          ecma_op_object_heap_sort_shift_down (buffer_p, array_props, i);
        -: 2656:        }
    #####: 2657:        while (i-- > 0);
        -: 2658:
    #####: 2659:        i = array_props - 1;
        -: 2660:
        -: 2661:        do
        -: 2662:        {
    #####: 2663:          ecma_value_t tmp = buffer_p[i];
    #####: 2664:          buffer_p[i] = buffer_p[0];
    #####: 2665:          buffer_p[0] = tmp;
        -: 2666:
    #####: 2667:          ecma_op_object_heap_sort_shift_down (buffer_p, i, 0);
        -: 2668:        }
    #####: 2669:        while (--i > 0);
        -: 2670:
    #####: 2671:        break;
        -: 2672:      }
        -: 2673:
    #####: 2674:      prev_value = value;
        -: 2675:    }
    #####: 2676:    while (array_index_p < array_index_end_p);
        -: 2677:  }
        -: 2678:
        1: 2679:  return prop_names_p;
        -: 2680:} /* ecma_op_object_own_property_keys */
        -: 2681:
        -: 2682:/**
        -: 2683: * EnumerateObjectProperties abstract method
        -: 2684: *
        -: 2685: * See also:
        -: 2686: *          ECMA-262 v11, 13.7.5.15
        -: 2687: *
        -: 2688: * @return NULL - if the Proxy.[[OwnPropertyKeys]] operation raises error
        -: 2689: *         collection of enumerable property names - otherwise
        -: 2690: */
        -: 2691:ecma_collection_t *
        1: 2692:ecma_op_object_enumerate (ecma_object_t *obj_p) /**< object */
        -: 2693:{
        1: 2694:  ecma_collection_t *visited_names_p = ecma_new_collection ();
        1: 2695:  ecma_collection_t *return_names_p = ecma_new_collection ();
        -: 2696:
        1: 2697:  ecma_ref_object (obj_p);
        -: 2698:
        -: 2699:  while (true)
        1: 2700:  {
        2: 2701:    ecma_collection_t *keys = ecma_op_object_own_property_keys (obj_p, JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS);
        -: 2702:
        -: 2703:#if JERRY_ESNEXT
        2: 2704:    if (JERRY_UNLIKELY (keys == NULL))
        -: 2705:    {
    #####: 2706:      ecma_collection_free (return_names_p);
    #####: 2707:      ecma_collection_free (visited_names_p);
    #####: 2708:      ecma_deref_object (obj_p);
    #####: 2709:      return keys;
        -: 2710:    }
        -: 2711:#endif /* JERRY_ESNEXT */
        -: 2712:
       78: 2713:    for (uint32_t i = 0; i < keys->item_count; i++)
        -: 2714:    {
       76: 2715:      ecma_value_t prop_name = keys->buffer_p[i];
       76: 2716:      ecma_string_t *name_p = ecma_get_prop_name_from_value (prop_name);
        -: 2717:
        -: 2718:#if JERRY_ESNEXT
       76: 2719:      if (ecma_prop_name_is_symbol (name_p))
        -: 2720:      {
    #####: 2721:        continue;
        -: 2722:      }
        -: 2723:#endif /* JERRY_ESNEXT */
        -: 2724:
       76: 2725:      ecma_property_descriptor_t prop_desc;
       76: 2726:      ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, name_p, &prop_desc);
        -: 2727:
       76: 2728:      if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 2729:      {
    #####: 2730:        ecma_collection_free (keys);
    #####: 2731:        ecma_collection_free (return_names_p);
    #####: 2732:        ecma_collection_free (visited_names_p);
    #####: 2733:        ecma_deref_object (obj_p);
    #####: 2734:        return NULL;
        -: 2735:      }
        -: 2736:
       76: 2737:      if (ecma_is_value_true (get_desc))
        -: 2738:      {
       76: 2739:        bool is_enumerable = (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE) != 0;
       76: 2740:        ecma_free_property_descriptor (&prop_desc);
        -: 2741:
       76: 2742:        if (ecma_collection_has_string_value (visited_names_p, name_p)
       76: 2743:            || ecma_collection_has_string_value (return_names_p, name_p))
        -: 2744:        {
    #####: 2745:          continue;
        -: 2746:        }
        -: 2747:
       76: 2748:        ecma_ref_ecma_string (name_p);
        -: 2749:
       76: 2750:        if (is_enumerable)
        -: 2751:        {
        6: 2752:          ecma_collection_push_back (return_names_p, prop_name);
        -: 2753:        }
        -: 2754:        else
        -: 2755:        {
       70: 2756:          ecma_collection_push_back (visited_names_p, prop_name);
        -: 2757:        }
        -: 2758:      }
        -: 2759:    }
        -: 2760:
        2: 2761:    ecma_collection_free (keys);
        -: 2762:
        -: 2763:    /* Query the prototype. */
        2: 2764:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_p);
        2: 2765:    ecma_deref_object (obj_p);
        -: 2766:
        2: 2767:    if (proto_p == NULL)
        -: 2768:    {
        1: 2769:      break;
        -: 2770:    }
        1: 2771:    else if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 2772:    {
    #####: 2773:      ecma_collection_free (return_names_p);
    #####: 2774:      ecma_collection_free (visited_names_p);
    #####: 2775:      return NULL;
        -: 2776:    }
        -: 2777:
        -: 2778:    /* Advance up on prototype chain. */
        1: 2779:    obj_p = proto_p;
        -: 2780:  }
        -: 2781:
        1: 2782:  ecma_collection_free (visited_names_p);
        -: 2783:
        1: 2784:  return return_names_p;
        -: 2785:} /* ecma_op_object_enumerate */
        -: 2786:
        -: 2787:#ifndef JERRY_NDEBUG
        -: 2788:
        -: 2789:/**
        -: 2790: * Check if passed object is the instance of specified built-in.
        -: 2791: *
        -: 2792: * @return true  - if the object is instance of the specified built-in
        -: 2793: *         false - otherwise
        -: 2794: */
        -: 2795:static bool
    #####: 2796:ecma_builtin_is (ecma_object_t *object_p, /**< pointer to an object */
        -: 2797:                 ecma_builtin_id_t builtin_id) /**< id of built-in to check on */
        -: 2798:{
    #####: 2799:  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));
    #####: 2800:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
        -: 2801:
    #####: 2802:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -: 2803:
    #####: 2804:  switch (type)
        -: 2805:  {
    #####: 2806:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 2807:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 2808:    {
    #####: 2809:      ecma_extended_object_t *built_in_object_p = (ecma_extended_object_t *) object_p;
        -: 2810:
    #####: 2811:      return (built_in_object_p->u.built_in.id == builtin_id
    #####: 2812:              && built_in_object_p->u.built_in.routine_id == 0);
        -: 2813:    }
    #####: 2814:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 2815:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2816:    {
    #####: 2817:      ecma_extended_built_in_object_t *extended_built_in_object_p = (ecma_extended_built_in_object_t *) object_p;
        -: 2818:
    #####: 2819:      return (extended_built_in_object_p->built_in.id == builtin_id
    #####: 2820:              && extended_built_in_object_p->built_in.routine_id == 0);
        -: 2821:    }
    #####: 2822:    default:
        -: 2823:    {
    #####: 2824:      return false;
        -: 2825:    }
        -: 2826:  }
        -: 2827:} /* ecma_builtin_is */
        -: 2828:
        -: 2829:#endif /* !JERRY_NDEBUG */
        -: 2830:
        -: 2831:/**
        -: 2832: * The function is used in the assert of ecma_object_get_class_name
        -: 2833: *
        -: 2834: * @return true  - if class name is an object
        -: 2835: *         false - otherwise
        -: 2836: */
        -: 2837:static inline bool
        5: 2838:ecma_object_check_class_name_is_object (ecma_object_t *obj_p) /**< object */
        -: 2839:{
        -: 2840:#ifndef JERRY_NDEBUG
        5: 2841:  return (ecma_builtin_is_global (obj_p)
        -: 2842:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 2843:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE)
        -: 2844:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 2845:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SHARED_ARRAYBUFFER_PROTOTYPE)
        -: 2846:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
    #####: 2847:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPEDARRAY_PROTOTYPE)
    #####: 2848:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE)
    #####: 2849:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8ARRAY_PROTOTYPE)
    #####: 2850:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT16ARRAY_PROTOTYPE)
    #####: 2851:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT16ARRAY_PROTOTYPE)
    #####: 2852:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT32ARRAY_PROTOTYPE)
    #####: 2853:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT32ARRAY_PROTOTYPE)
    #####: 2854:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT32ARRAY_PROTOTYPE)
    #####: 2855:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8CLAMPEDARRAY_PROTOTYPE)
        -: 2856:#if JERRY_NUMBER_TYPE_FLOAT64
    #####: 2857:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
        -: 2858:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 2859:#if JERRY_BUILTIN_BIGINT
    #####: 2860:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT64ARRAY_PROTOTYPE)
    #####: 2861:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGUINT64ARRAY_PROTOTYPE)
        -: 2862:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2863:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2864:#if JERRY_ESNEXT
    #####: 2865:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_PROTOTYPE_UNSCOPABLES)
    #####: 2866:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE)
    #####: 2867:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ITERATOR_PROTOTYPE)
    #####: 2868:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE)
    #####: 2869:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE)
    #####: 2870:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE)
    #####: 2871:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE)
    #####: 2872:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE)
    #####: 2873:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE)
    #####: 2874:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE)
    #####: 2875:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE)
    #####: 2876:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_AGGREGATE_ERROR_PROTOTYPE)
    #####: 2877:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE)
    #####: 2878:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ERROR_PROTOTYPE)
    #####: 2879:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATE_PROTOTYPE)
    #####: 2880:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE)
    #####: 2881:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE)
    #####: 2882:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ASYNC_FUNCTION_PROTOTYPE)
    #####: 2883:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_PROMISE_PROTOTYPE)
        -: 2884:#endif /* JERRY_ESNEXT */
        -: 2885:#if JERRY_BUILTIN_CONTAINER
    #####: 2886:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_PROTOTYPE)
    #####: 2887:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_PROTOTYPE)
    #####: 2888:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE)
    #####: 2889:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE)
        -: 2890:#if JERRY_ESNEXT
    #####: 2891:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE)
    #####: 2892:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE)
        -: 2893:#endif /* JERRY_ESNEXT */
        -: 2894:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 2895:#if JERRY_BUILTIN_WEAKREF
    #####: 2896:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKREF_PROTOTYPE)
        -: 2897:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 2898:#if JERRY_BUILTIN_DATAVIEW
    #####: 2899:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE)
        -: 2900:#endif /* JERRY_BUILTIN_DATAVIEW */
        5: 2901:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE));
        -: 2902:#else /* JERRY_NDEBUG */
        -: 2903:  JERRY_UNUSED (obj_p);
        -: 2904:  return true;
        -: 2905:#endif /* !JERRY_NDEBUG */
        -: 2906:} /* ecma_object_check_class_name_is_object */
        -: 2907:
        -: 2908:/**
        -: 2909: * Used by ecma_object_get_class_name to get the magic string id of class objects
        -: 2910: */
        -: 2911:static const uint16_t ecma_class_object_magic_string_id[] =
        -: 2912:{
        -: 2913:  /* These objects require custom property resolving. */
        -: 2914:  LIT_MAGIC_STRING_STRING_UL, /**< magic string id of ECMA_OBJECT_CLASS_STRING */
        -: 2915:  LIT_MAGIC_STRING_ARGUMENTS_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 2916:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2917:  LIT_MAGIC_STRING__EMPTY, /**< ECMA_OBJECT_CLASS_TYPEDARRAY needs special resolver */
        -: 2918:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2919:#if JERRY_MODULE_SYSTEM
        -: 2920:  LIT_MAGIC_STRING_MODULE_UL, /**< magic string id of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 2921:#endif
        -: 2922:
        -: 2923:  /* These objects are marked by Garbage Collector. */
        -: 2924:#if JERRY_ESNEXT
        -: 2925:  LIT_MAGIC_STRING_GENERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_GENERATOR */
        -: 2926:  LIT_MAGIC_STRING_ASYNC_GENERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 2927:  LIT_MAGIC_STRING_ARRAY_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 2928:  LIT_MAGIC_STRING_SET_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 2929:  LIT_MAGIC_STRING_MAP_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 2930:#if JERRY_BUILTIN_REGEXP
        -: 2931:  LIT_MAGIC_STRING_REGEXP_STRING_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 2932:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2933:#endif /* JERRY_ESNEXT */
        -: 2934:#if JERRY_MODULE_SYSTEM
        -: 2935:  LIT_MAGIC_STRING_MODULE_UL, /**< magic string id of ECMA_OBJECT_CLASS_MODULE */
        -: 2936:#endif
        -: 2937:#if JERRY_ESNEXT
        -: 2938:  LIT_MAGIC_STRING_PROMISE_UL, /**< magic string id of ECMA_OBJECT_CLASS_PROMISE */
        -: 2939:  LIT_MAGIC_STRING_OBJECT_UL, /**< magic string id of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 2940:  LIT_MAGIC_STRING_OBJECT_UL, /**< magic string id of ECMA_OBJECT_CLASS_ASYNC_FROM_SYNC_ITERATOR */
        -: 2941:#endif /* JERRY_ESNEXT */
        -: 2942:#if JERRY_BUILTIN_DATAVIEW
        -: 2943:  LIT_MAGIC_STRING_DATAVIEW_UL, /**< magic string id of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 2944:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 2945:#if JERRY_BUILTIN_CONTAINER
        -: 2946:  LIT_MAGIC_STRING__EMPTY, /**< magic string id of ECMA_OBJECT_CLASS_CONTAINER needs special resolver */
        -: 2947:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 2948:
        -: 2949:  /* Normal objects. */
        -: 2950:  LIT_MAGIC_STRING_BOOLEAN_UL, /**< magic string id of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 2951:  LIT_MAGIC_STRING_NUMBER_UL, /**< magic string id of ECMA_OBJECT_CLASS_NUMBER */
        -: 2952:  LIT_MAGIC_STRING_ERROR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ERROR */
        -: 2953:  LIT_MAGIC_STRING_OBJECT_UL, /**< magic string id of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 2954:#if JERRY_PARSER
        -: 2955:  LIT_MAGIC_STRING_SCRIPT_UL, /**< magic string id of ECMA_OBJECT_CLASS_SCRIPT */
        -: 2956:#endif /* JERRY_PARSER */
        -: 2957:#if JERRY_BUILTIN_DATE
        -: 2958:  LIT_MAGIC_STRING_DATE_UL, /**< magic string id of ECMA_OBJECT_CLASS_DATE */
        -: 2959:#endif /* JERRY_BUILTIN_DATE */
        -: 2960:#if JERRY_BUILTIN_REGEXP
        -: 2961:  LIT_MAGIC_STRING_REGEXP_UL, /**< magic string id of ECMA_OBJECT_CLASS_REGEXP */
        -: 2962:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2963:#if JERRY_ESNEXT
        -: 2964:  LIT_MAGIC_STRING_SYMBOL_UL, /**< magic string id of ECMA_OBJECT_CLASS_SYMBOL */
        -: 2965:  LIT_MAGIC_STRING_STRING_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 2966:#endif /* JERRY_ESNEXT */
        -: 2967:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2968:  LIT_MAGIC_STRING_ARRAY_BUFFER_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 2969:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2970:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 2971:  LIT_MAGIC_STRING_SHARED_ARRAY_BUFFER_UL, /**< magic string id of ECMA_OBJECT_CLASS_SHAREDARRAY_BUFFER */
        -: 2972:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 2973:#if JERRY_BUILTIN_BIGINT
        -: 2974:  LIT_MAGIC_STRING_BIGINT_UL, /**< magic string id of ECMA_OBJECT_CLASS_BIGINT */
        -: 2975:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2976:#if JERRY_BUILTIN_WEAKREF
        -: 2977:  LIT_MAGIC_STRING_WEAKREF_UL, /**< magic string id of ECMA_OBJECT_CLASS_WEAKREF */
        -: 2978:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 2979:};
        -: 2980:
        -: 2981:JERRY_STATIC_ASSERT (sizeof (ecma_class_object_magic_string_id) == ECMA_OBJECT_CLASS__MAX * sizeof (uint16_t),
        -: 2982:                     ecma_class_object_magic_string_id_must_have_object_class_max_elements);
        -: 2983:
        -: 2984:/**
        -: 2985: * Get [[Class]] string of specified object
        -: 2986: *
        -: 2987: * @return class name magic string
        -: 2988: */
        -: 2989:lit_magic_string_id_t
        5: 2990:ecma_object_get_class_name (ecma_object_t *obj_p) /**< object */
        -: 2991:{
        5: 2992:  ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 2993:
        5: 2994:  switch (type)
        -: 2995:  {
    #####: 2996:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 2997:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2998:    {
    #####: 2999:      return LIT_MAGIC_STRING_ARRAY_UL;
        -: 3000:    }
    #####: 3001:    case ECMA_OBJECT_TYPE_CLASS:
        -: 3002:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 3003:    {
    #####: 3004:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 3005:
    #####: 3006:      switch (ext_object_p->u.cls.type)
        -: 3007:      {
        -: 3008:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 3009:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 3010:        {
    #####: 3011:          return ecma_get_typedarray_magic_string_id (ext_object_p->u.cls.u1.typedarray_type);
        -: 3012:        }
        -: 3013:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 3014:#if JERRY_BUILTIN_CONTAINER
    #####: 3015:        case ECMA_OBJECT_CLASS_CONTAINER:
        -: 3016:        {
    #####: 3017:          return (lit_magic_string_id_t) ext_object_p->u.cls.u2.container_id;
        -: 3018:        }
        -: 3019:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 3020:        default:
        -: 3021:        {
    #####: 3022:          break;
        -: 3023:        }
        -: 3024:      }
        -: 3025:
    #####: 3026:      JERRY_ASSERT (ext_object_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 3027:      JERRY_ASSERT (ecma_class_object_magic_string_id[ext_object_p->u.cls.type] != LIT_MAGIC_STRING__EMPTY);
        -: 3028:
    #####: 3029:      return (lit_magic_string_id_t) ecma_class_object_magic_string_id[ext_object_p->u.cls.type];
        -: 3030:    }
    #####: 3031:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 3032:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 3033:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 3034:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 3035:    {
    #####: 3036:      return LIT_MAGIC_STRING_FUNCTION_UL;
        -: 3037:    }
        -: 3038:#if JERRY_BUILTIN_PROXY
    #####: 3039:    case ECMA_OBJECT_TYPE_PROXY:
        -: 3040:    {
    #####: 3041:      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;
        -: 3042:
    #####: 3043:      if (!ecma_is_value_null (proxy_obj_p->target) && ecma_is_value_object (proxy_obj_p->target))
        -: 3044:      {
    #####: 3045:        ecma_object_t *target_obj_p = ecma_get_object_from_value (proxy_obj_p->target);
    #####: 3046:        return ecma_object_get_class_name (target_obj_p);
        -: 3047:      }
    #####: 3048:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3049:    }
        -: 3050:#endif /* JERRY_BUILTIN_PROXY */
        5: 3051:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 3052:    {
        5: 3053:      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 3054:
        5: 3055:      switch (ext_obj_p->u.built_in.id)
        -: 3056:      {
        -: 3057:#if JERRY_BUILTIN_MATH
    #####: 3058:        case ECMA_BUILTIN_ID_MATH:
        -: 3059:        {
    #####: 3060:          return LIT_MAGIC_STRING_MATH_UL;
        -: 3061:        }
        -: 3062:#endif /* JERRY_BUILTIN_MATH */
        -: 3063:#if JERRY_BUILTIN_REFLECT
    #####: 3064:        case ECMA_BUILTIN_ID_REFLECT:
        -: 3065:        {
    #####: 3066:          return LIT_MAGIC_STRING_REFLECT_UL;
        -: 3067:        }
        -: 3068:#endif /* JERRY_BUILTIN_REFLECT */
        -: 3069:#if JERRY_ESNEXT
    #####: 3070:        case ECMA_BUILTIN_ID_GENERATOR:
        -: 3071:        {
    #####: 3072:          return LIT_MAGIC_STRING_GENERATOR_UL;
        -: 3073:        }
    #####: 3074:        case ECMA_BUILTIN_ID_ASYNC_GENERATOR:
        -: 3075:        {
    #####: 3076:          return LIT_MAGIC_STRING_ASYNC_GENERATOR_UL;
        -: 3077:        }
        -: 3078:#endif /* JERRY_ESNEXT */
        -: 3079:#if JERRY_BUILTIN_JSON
    #####: 3080:        case ECMA_BUILTIN_ID_JSON:
        -: 3081:        {
    #####: 3082:          return LIT_MAGIC_STRING_JSON_U;
        -: 3083:        }
        -: 3084:#endif /* JERRY_BUILTIN_JSON */
        -: 3085:#if !JERRY_ESNEXT
        -: 3086:#if JERRY_BUILTIN_ERRORS
        -: 3087:        case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:
        -: 3088:        case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:
        -: 3089:        case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:
        -: 3090:        case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:
        -: 3091:        case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:
        -: 3092:        case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:
        -: 3093:#endif /* JERRY_BUILTIN_ERRORS */
        -: 3094:        case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:
        -: 3095:        {
        -: 3096:          return LIT_MAGIC_STRING_ERROR_UL;
        -: 3097:        }
        -: 3098:#endif /* !JERRY_ESNEXT */
        5: 3099:        default:
        -: 3100:        {
        5: 3101:          break;
        -: 3102:        }
        -: 3103:      }
        -: 3104:
        5: 3105:      JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));
        5: 3106:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3107:    }
    #####: 3108:    default:
        -: 3109:    {
    #####: 3110:      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL
        -: 3111:                    || type == ECMA_OBJECT_TYPE_PROXY);
        -: 3112:
    #####: 3113:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3114:    }
        -: 3115:  }
        -: 3116:} /* ecma_object_get_class_name */
        -: 3117:
        -: 3118:#if JERRY_BUILTIN_REGEXP
        -: 3119:/**
        -: 3120: * Checks if the given argument has [[RegExpMatcher]] internal slot
        -: 3121: *
        -: 3122: * @return true - if the given argument is a regexp
        -: 3123: *         false - otherwise
        -: 3124: */
        -: 3125:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 3126:ecma_object_is_regexp_object (ecma_value_t arg) /**< argument */
        -: 3127:{
    #####: 3128:  return (ecma_is_value_object (arg)
    #####: 3129:          && ecma_object_class_is (ecma_get_object_from_value (arg), ECMA_OBJECT_CLASS_REGEXP));
        -: 3130:} /* ecma_object_is_regexp_object */
        -: 3131:#endif /* JERRY_BUILTIN_REGEXP */
        -: 3132:
        -: 3133:#if JERRY_ESNEXT
        -: 3134:/**
        -: 3135: * Object's IsConcatSpreadable operation, used for Array.prototype.concat
        -: 3136: * It checks the argument's [Symbol.isConcatSpreadable] property value
        -: 3137: *
        -: 3138: * See also:
        -: 3139: *          ECMA-262 v6, 22.1.3.1.1;
        -: 3140: *
        -: 3141: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 3142: *         ECMA_VALUE_TRUE - if the argument is concatSpreadable
        -: 3143: *         ECMA_VALUE_FALSE - otherwise
        -: 3144: */
        -: 3145:ecma_value_t
    #####: 3146:ecma_op_is_concat_spreadable (ecma_value_t arg) /**< argument */
        -: 3147:{
    #####: 3148:  if (!ecma_is_value_object (arg))
        -: 3149:  {
    #####: 3150:    return ECMA_VALUE_FALSE;
        -: 3151:  }
        -: 3152:
    #####: 3153:  ecma_value_t spreadable = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 3154:                                                             LIT_GLOBAL_SYMBOL_IS_CONCAT_SPREADABLE);
        -: 3155:
    #####: 3156:  if (ECMA_IS_VALUE_ERROR (spreadable))
        -: 3157:  {
    #####: 3158:    return spreadable;
        -: 3159:  }
        -: 3160:
    #####: 3161:  if (!ecma_is_value_undefined (spreadable))
        -: 3162:  {
    #####: 3163:    const bool to_bool = ecma_op_to_boolean (spreadable);
    #####: 3164:    ecma_free_value (spreadable);
    #####: 3165:    return ecma_make_boolean_value (to_bool);
        -: 3166:  }
        -: 3167:
    #####: 3168:  return ecma_is_value_array (arg);
        -: 3169:} /* ecma_op_is_concat_spreadable */
        -: 3170:
        -: 3171:/**
        -: 3172: * IsRegExp operation
        -: 3173: *
        -: 3174: * See also:
        -: 3175: *          ECMA-262 v6, 22.1.3.1.1;
        -: 3176: *
        -: 3177: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 3178: *         ECMA_VALUE_TRUE - if the argument is regexp
        -: 3179: *         ECMA_VALUE_FALSE - otherwise
        -: 3180: */
        -: 3181:ecma_value_t
    #####: 3182:ecma_op_is_regexp (ecma_value_t arg) /**< argument */
        -: 3183:{
    #####: 3184:  if (!ecma_is_value_object (arg))
        -: 3185:  {
    #####: 3186:    return ECMA_VALUE_FALSE;
        -: 3187:  }
        -: 3188:
    #####: 3189:  ecma_value_t is_regexp = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 3190:                                                            LIT_GLOBAL_SYMBOL_MATCH);
        -: 3191:
    #####: 3192:  if (ECMA_IS_VALUE_ERROR (is_regexp))
        -: 3193:  {
    #####: 3194:    return is_regexp;
        -: 3195:  }
        -: 3196:
    #####: 3197:  if (!ecma_is_value_undefined (is_regexp))
        -: 3198:  {
    #####: 3199:    const bool to_bool = ecma_op_to_boolean (is_regexp);
    #####: 3200:    ecma_free_value (is_regexp);
    #####: 3201:    return ecma_make_boolean_value (to_bool);
        -: 3202:  }
        -: 3203:
    #####: 3204:  return ecma_make_boolean_value (ecma_object_is_regexp_object (arg));
        -: 3205:} /* ecma_op_is_regexp */
        -: 3206:
        -: 3207:/**
        -: 3208: * SpeciesConstructor operation
        -: 3209: * See also:
        -: 3210: *          ECMA-262 v6, 7.3.20;
        -: 3211: *
        -: 3212: * @return ecma_value
        -: 3213: *         returned value must be freed with ecma_free_value
        -: 3214: */
        -: 3215:ecma_value_t
    #####: 3216:ecma_op_species_constructor (ecma_object_t *this_value, /**< This Value */
        -: 3217:                             ecma_builtin_id_t default_constructor_id) /**< Builtin ID of default constructor */
        -: 3218:{
    #####: 3219:  ecma_object_t *default_constructor_p = ecma_builtin_get (default_constructor_id);
    #####: 3220:  ecma_value_t constructor = ecma_op_object_get_by_magic_id (this_value, LIT_MAGIC_STRING_CONSTRUCTOR);
    #####: 3221:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 3222:  {
    #####: 3223:    return constructor;
        -: 3224:  }
        -: 3225:
    #####: 3226:  if (ecma_is_value_undefined (constructor))
        -: 3227:  {
    #####: 3228:    ecma_ref_object (default_constructor_p);
    #####: 3229:    return ecma_make_object_value (default_constructor_p);
        -: 3230:  }
        -: 3231:
    #####: 3232:  if (!ecma_is_value_object (constructor))
        -: 3233:  {
    #####: 3234:    ecma_free_value (constructor);
    #####: 3235:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constructor must be an object"));
        -: 3236:  }
        -: 3237:
    #####: 3238:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####: 3239:  ecma_value_t species = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
    #####: 3240:  ecma_deref_object (ctor_object_p);
        -: 3241:
    #####: 3242:  if (ECMA_IS_VALUE_ERROR (species))
        -: 3243:  {
    #####: 3244:    return species;
        -: 3245:  }
        -: 3246:
    #####: 3247:  if (ecma_is_value_undefined (species) || ecma_is_value_null (species))
        -: 3248:  {
    #####: 3249:    ecma_ref_object (default_constructor_p);
    #####: 3250:    return ecma_make_object_value (default_constructor_p);
        -: 3251:  }
        -: 3252:
    #####: 3253:  if (!ecma_is_constructor (species))
        -: 3254:  {
    #####: 3255:    ecma_free_value (species);
    #####: 3256:    return ecma_raise_type_error (ECMA_ERR_MSG ("Species must be a constructor"));
        -: 3257:  }
        -: 3258:
    #####: 3259:  return species;
        -: 3260:} /* ecma_op_species_constructor */
        -: 3261:
        -: 3262:/**
        -: 3263: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 3264: *
        -: 3265: * @return ecma_value result of the invoked function or raised error
        -: 3266: *         note: returned value must be freed with ecma_free_value
        -: 3267: */
        -: 3268:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3269:ecma_op_invoke_by_symbol_id (ecma_value_t object, /**< Object value */
        -: 3270:                             lit_magic_string_id_t symbol_id, /**< Symbol ID */
        -: 3271:                             ecma_value_t *args_p, /**< Argument list */
        -: 3272:                             uint32_t args_len) /**< Argument list length */
        -: 3273:{
    #####: 3274:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (symbol_id);
    #####: 3275:  ecma_value_t ret_value = ecma_op_invoke (object, symbol_p, args_p, args_len);
    #####: 3276:  ecma_deref_ecma_string (symbol_p);
        -: 3277:
    #####: 3278:  return ret_value;
        -: 3279:} /* ecma_op_invoke_by_symbol_id */
        -: 3280:#endif /* JERRY_ESNEXT */
        -: 3281:
        -: 3282:/**
        -: 3283: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 3284: *
        -: 3285: * @return ecma_value result of the invoked function or raised error
        -: 3286: *         note: returned value must be freed with ecma_free_value
        -: 3287: */
        -: 3288:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3289:ecma_op_invoke_by_magic_id (ecma_value_t object, /**< Object value */
        -: 3290:                            lit_magic_string_id_t magic_string_id, /**< Magic string ID */
        -: 3291:                            ecma_value_t *args_p, /**< Argument list */
        -: 3292:                            uint32_t args_len) /**< Argument list length */
        -: 3293:{
    #####: 3294:  return ecma_op_invoke (object, ecma_get_magic_string (magic_string_id), args_p, args_len);
        -: 3295:} /* ecma_op_invoke_by_magic_id */
        -: 3296:
        -: 3297:/**
        -: 3298: * 7.3.18 Abstract operation Invoke
        -: 3299: *
        -: 3300: * @return ecma_value result of the invoked function or raised error
        -: 3301: *         note: returned value must be freed with ecma_free_value
        -: 3302: */
        -: 3303:ecma_value_t
    #####: 3304:ecma_op_invoke (ecma_value_t object, /**< Object value */
        -: 3305:                ecma_string_t *property_name_p, /**< Property name */
        -: 3306:                ecma_value_t *args_p, /**< Argument list */
        -: 3307:                uint32_t args_len) /**< Argument list length */
        -: 3308:{
        -: 3309:  /* 3. */
    #####: 3310:  ecma_value_t object_value = ecma_op_to_object (object);
    #####: 3311:  if (ECMA_IS_VALUE_ERROR (object_value))
        -: 3312:  {
    #####: 3313:    return object_value;
        -: 3314:  }
        -: 3315:
    #####: 3316:  ecma_object_t *object_p = ecma_get_object_from_value (object_value);
        -: 3317:
        -: 3318:#if JERRY_ESNEXT
    #####: 3319:  ecma_value_t this_arg = object;
        -: 3320:#else /* !JERRY_ESNEXT */
    #####: 3321:  ecma_value_t this_arg = object_value;
        -: 3322:#endif /* JERRY_ESNEXT */
        -: 3323:
    #####: 3324:  ecma_value_t func = ecma_op_object_get_with_receiver (object_p, property_name_p, this_arg);
        -: 3325:
    #####: 3326:  if (ECMA_IS_VALUE_ERROR (func))
        -: 3327:  {
    #####: 3328:    ecma_deref_object (object_p);
    #####: 3329:    return func;
        -: 3330:  }
        -: 3331:
        -: 3332:  /* 4. */
    #####: 3333:  if (!ecma_op_is_callable (func))
        -: 3334:  {
    #####: 3335:    ecma_free_value (func);
    #####: 3336:    ecma_deref_object (object_p);
    #####: 3337:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not callable"));
        -: 3338:  }
        -: 3339:
    #####: 3340:  ecma_object_t *func_obj_p = ecma_get_object_from_value (func);
    #####: 3341:  ecma_value_t call_result = ecma_op_function_call (func_obj_p, this_arg, args_p, args_len);
        -: 3342:
    #####: 3343:  ecma_deref_object (object_p);
    #####: 3344:  ecma_deref_object (func_obj_p);
        -: 3345:
    #####: 3346:  return call_result;
        -: 3347:} /* ecma_op_invoke */
        -: 3348:
        -: 3349:/**
        -: 3350: * Ordinary object [[GetPrototypeOf]] operation
        -: 3351: *
        -: 3352: * See also:
        -: 3353: *          ECMAScript v6, 9.1.1
        -: 3354: *
        -: 3355: * @return the value of the [[Prototype]] internal slot of the given object.
        -: 3356: */
        -: 3357:extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE
        1: 3358:ecma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */
        -: 3359:{
      173: 3360:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
      173: 3361:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3362:
      173: 3363:  return obj_p->u2.prototype_cp;
        -: 3364:} /* ecma_op_ordinary_object_get_prototype_of */
        -: 3365:
        -: 3366:/**
        -: 3367: * Ordinary object [[SetPrototypeOf]] operation
        -: 3368: *
        -: 3369: * See also:
        -: 3370: *          ECMAScript v6, 9.1.2
        -: 3371: *
        -: 3372: * @return ECMA_VALUE_FALSE - if the operation fails
        -: 3373: *         ECMA_VALUE_TRUE - otherwise
        -: 3374: */
        -: 3375:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3376:ecma_op_ordinary_object_set_prototype_of (ecma_object_t *obj_p, /**< base object */
        -: 3377:                                          ecma_value_t proto) /**< prototype object */
        -: 3378:{
    #####: 3379:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
    #####: 3380:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3381:
        -: 3382:  /* 1. */
    #####: 3383:  JERRY_ASSERT (ecma_is_value_object (proto) || ecma_is_value_null (proto));
        -: 3384:
        -: 3385:  /* 3. */
    #####: 3386:  ecma_object_t *current_proto_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (obj_p));
    #####: 3387:  ecma_object_t *new_proto_p = ecma_is_value_null (proto) ? NULL : ecma_get_object_from_value (proto);
        -: 3388:
        -: 3389:  /* 4. */
    #####: 3390:  if (new_proto_p == current_proto_p)
        -: 3391:  {
    #####: 3392:    return ECMA_VALUE_TRUE;
        -: 3393:  }
        -: 3394:
        -: 3395:  /* 2 - 5. */
    #####: 3396:  if (!ecma_op_ordinary_object_is_extensible (obj_p))
        -: 3397:  {
    #####: 3398:    return ECMA_VALUE_FALSE;
        -: 3399:  }
        -: 3400:
        -: 3401:  /**
        -: 3402:   * When the prototype of a fast array changes, it is required to convert the
        -: 3403:   * array to a "normal" array. This ensures that all [[Get]]/[[Set]]/etc.
        -: 3404:   * calls works as expected.
        -: 3405:   */
    #####: 3406:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3407:  {
    #####: 3408:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3409:  }
        -: 3410:
        -: 3411:  /* 6. */
    #####: 3412:  ecma_object_t *iter_p = new_proto_p;
        -: 3413:
        -: 3414:  /* 7 - 8. */
        -: 3415:  while (true)
        -: 3416:  {
        -: 3417:    /* 8.a */
    #####: 3418:    if (iter_p == NULL)
        -: 3419:    {
    #####: 3420:      break;
        -: 3421:    }
        -: 3422:
        -: 3423:    /* 8.b */
    #####: 3424:    if (obj_p == iter_p)
        -: 3425:    {
    #####: 3426:      return ECMA_VALUE_FALSE;
        -: 3427:    }
        -: 3428:
        -: 3429:    /* 8.c.i */
        -: 3430:#if JERRY_BUILTIN_PROXY
    #####: 3431:    if (ECMA_OBJECT_IS_PROXY (iter_p))
        -: 3432:    {
    #####: 3433:      break;
        -: 3434:    }
        -: 3435:#endif /* JERRY_BUILTIN_PROXY */
        -: 3436:
        -: 3437:    /* 8.c.ii */
    #####: 3438:    iter_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (iter_p));
        -: 3439:  }
        -: 3440:
        -: 3441:  /* 9. */
    #####: 3442:  ECMA_SET_POINTER (obj_p->u2.prototype_cp, new_proto_p);
        -: 3443:
        -: 3444:  /* 10. */
    #####: 3445:  return ECMA_VALUE_TRUE;
        -: 3446:} /* ecma_op_ordinary_object_set_prototype_of */
        -: 3447:
        -: 3448:/**
        -: 3449: * [[IsExtensible]] operation for Ordinary object.
        -: 3450: *
        -: 3451: * See also:
        -: 3452: *          ECMAScript v6, 9.1.2
        -: 3453: *
        -: 3454: * @return true  - if object is extensible
        -: 3455: *         false - otherwise
        -: 3456: */
        -: 3457:extern inline bool JERRY_ATTR_PURE
       11: 3458:ecma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */
        -: 3459:{
       11: 3460:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3461:
       11: 3462:  bool is_extensible = (object_p->type_flags_refs & ECMA_OBJECT_FLAG_EXTENSIBLE) != 0;
        -: 3463:
       11: 3464:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p) || is_extensible);
        -: 3465:
       11: 3466:  return is_extensible;
        -: 3467:} /* ecma_op_ordinary_object_is_extensible */
        -: 3468:
        -: 3469:/**
        -: 3470: * Set value of [[Extensible]] object's internal property.
        -: 3471: */
        -: 3472:void JERRY_ATTR_NOINLINE
    #####: 3473:ecma_op_ordinary_object_prevent_extensions (ecma_object_t *object_p) /**< object */
        -: 3474:{
    #####: 3475:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3476:
    #####: 3477:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (object_p)))
        -: 3478:  {
    #####: 3479:    ecma_fast_array_convert_to_normal (object_p);
        -: 3480:  }
        -: 3481:
    #####: 3482:  object_p->type_flags_refs &= (ecma_object_descriptor_t) ~ECMA_OBJECT_FLAG_EXTENSIBLE;
    #####: 3483:} /* ecma_op_ordinary_object_prevent_extensions */
        -: 3484:
        -: 3485:/**
        -: 3486: * Checks whether an object (excluding prototypes) has a named property
        -: 3487: *
        -: 3488: * @return true - if property is found
        -: 3489: *         false - otherwise
        -: 3490: */
        -: 3491:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 3492:ecma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */
        -: 3493:                                          ecma_string_t *property_name_p) /**< property name */
        -: 3494:{
        4: 3495:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3496:
        4: 3497:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 3498:                                                              property_name_p,
        -: 3499:                                                              NULL,
        -: 3500:                                                              ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 3501:
        4: 3502:  return property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -: 3503:} /* ecma_op_ordinary_object_has_own_property */
        -: 3504:
        -: 3505:#if JERRY_BUILTIN_WEAKREF || JERRY_BUILTIN_CONTAINER
        -: 3506:
        -: 3507:/**
        -: 3508: * Set a weak reference from a container or WeakRefObject to a key object
        -: 3509: */
        -: 3510:void
    #####: 3511:ecma_op_object_set_weak (ecma_object_t *object_p, /**< key object */
        -: 3512:                         ecma_object_t *target_p) /**< target object */
        -: 3513:{
    #####: 3514:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (object_p)))
        -: 3515:  {
    #####: 3516:    ecma_fast_array_convert_to_normal (object_p);
        -: 3517:  }
        -: 3518:
    #####: 3519:  ecma_string_t *weak_refs_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
    #####: 3520:  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);
        -: 3521:  ecma_collection_t *refs_p;
        -: 3522:
    #####: 3523:  if (property_p == NULL)
        -: 3524:  {
    #####: 3525:    refs_p = ecma_new_collection ();
        -: 3526:
        -: 3527:    ecma_property_value_t *value_p;
    #####: 3528:    ECMA_CREATE_INTERNAL_PROPERTY (object_p, weak_refs_string_p, property_p, value_p);
    #####: 3529:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, refs_p);
        -: 3530:  }
        -: 3531:  else
        -: 3532:  {
    #####: 3533:    refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3534:  }
        -: 3535:
    #####: 3536:  const ecma_value_t target_value = ecma_make_object_value ((ecma_object_t *) target_p);
    #####: 3537:  for (uint32_t i = 0; i < refs_p->item_count; i++)
        -: 3538:  {
    #####: 3539:    if (ecma_is_value_empty (refs_p->buffer_p[i]))
        -: 3540:    {
    #####: 3541:      refs_p->buffer_p[i] = target_value;
    #####: 3542:      return;
        -: 3543:    }
        -: 3544:  }
        -: 3545:
    #####: 3546:  ecma_collection_push_back (refs_p, target_value);
        -: 3547:} /* ecma_op_object_set_weak */
        -: 3548:
        -: 3549:/**
        -: 3550: * Helper function to remove a weak reference to an object.
        -: 3551: *
        -: 3552: * @return ecma value
        -: 3553: *         Returned value must be freed with ecma_free_value.
        -: 3554: */
        -: 3555:void
    #####: 3556:ecma_op_object_unref_weak (ecma_object_t *object_p, /**< this argument */
        -: 3557:                           ecma_value_t ref_holder) /**< key argument */
        -: 3558:{
    #####: 3559:  ecma_string_t *weak_refs_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
        -: 3560:
    #####: 3561:  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);
    #####: 3562:  JERRY_ASSERT (property_p != NULL);
        -: 3563:
    #####: 3564:  ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 3565:                                                               ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3566:  ecma_value_t *buffer_p = refs_p->buffer_p;
        -: 3567:
        -: 3568:  while (true)
        -: 3569:  {
    #####: 3570:    if (*buffer_p == ref_holder)
        -: 3571:    {
    #####: 3572:      *buffer_p = ECMA_VALUE_EMPTY;
    #####: 3573:      return;
        -: 3574:    }
    #####: 3575:    JERRY_ASSERT (buffer_p < refs_p->buffer_p + refs_p->item_count);
    #####: 3576:    buffer_p++;
        -: 3577:  }
        -: 3578:} /* ecma_op_object_unref_weak */
        -: 3579:
        -: 3580:#endif /* JERRY_BUILTIN_WEAKREF || JERRY_BUILTIN_CONTAINER */
        -: 3581:/**
        -: 3582: * Raise property redefinition error
        -: 3583: *
        -: 3584: * @return ECMA_VALUE_FALSE - if JERRY_PROP_SHOULD_THROW is not set
        -: 3585: *         raised TypeError - otherwise
        -: 3586: */
        -: 3587:ecma_value_t
    #####: 3588:ecma_raise_property_redefinition (ecma_string_t *property_name_p, /**< property name */
        -: 3589:                                  uint16_t flags) /**< property descriptor flags */
        -: 3590:{
        -: 3591:  JERRY_UNUSED (property_name_p);
        -: 3592:
    #####: 3593:  return ECMA_REJECT_WITH_FORMAT (flags & JERRY_PROP_SHOULD_THROW,
        -: 3594:                                  "Cannot redefine property: %",
        -: 3595:                                  ecma_make_prop_name_value (property_name_p));
        -: 3596:} /* ecma_raise_property_redefinition */
        -: 3597:
        -: 3598:/**
        -: 3599: * Raise readonly assignment error
        -: 3600: *
        -: 3601: * @return ECMA_VALUE_FALSE - if is_throw is true
        -: 3602: *         raised TypeError - otherwise
        -: 3603: */
        -: 3604:ecma_value_t
    #####: 3605:ecma_raise_readonly_assignment (ecma_string_t *property_name_p, /**< property name */
        -: 3606:                                bool is_throw) /**< is throw flag */
        -: 3607:{
        -: 3608:  JERRY_UNUSED (property_name_p);
        -: 3609:
    #####: 3610:  return ECMA_REJECT_WITH_FORMAT (is_throw,
        -: 3611:                                  "Cannot assign to read only property '%'",
        -: 3612:                                  ecma_make_prop_name_value (property_name_p));
        -: 3613:} /* ecma_raise_readonly_assignment */
        -: 3614:
        -: 3615:/**
        -: 3616: * @}
        -: 3617: * @}
        -: 3618: */
