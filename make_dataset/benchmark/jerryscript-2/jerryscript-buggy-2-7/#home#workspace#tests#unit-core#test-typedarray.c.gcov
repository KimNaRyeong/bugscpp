        -:    0:Source:/home/workspace/tests/unit-core/test-typedarray.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:#include "jerryscript-port.h"
        -:   18:#include "jerryscript-port-default.h"
        -:   19:#include "test-common.h"
        -:   20:
        -:   21:#include <stdio.h>
        -:   22:
        -:   23:/**
        -:   24: * Type to describe test cases.
        -:   25: */
        -:   26:typedef struct
        -:   27:{
        -:   28:  jerry_typedarray_type_t typedarray_type; /**< what kind of TypedArray */
        -:   29:  char *constructor_name; /**< JS constructor name for TypedArray */
        -:   30:  uint32_t element_count; /**< number of elements for the TypedArray */
        -:   31:  uint32_t bytes_per_element; /**< bytes per elment of the given typedarray_type */
        -:   32:} test_entry_t;
        -:   33:
        -:   34:/**
        -:   35: * Register a JavaScript value in the global object.
        -:   36: */
        -:   37:static void
    #####:   38:register_js_value (const char *name_p, /**< name of the function */
        -:   39:                   jerry_value_t value) /**< function callback */
        -:   40:{
    #####:   41:  jerry_value_t global_obj_val = jerry_get_global_object ();
        -:   42:
    #####:   43:  jerry_value_t name_val = jerry_create_string ((const jerry_char_t *) name_p);
    #####:   44:  jerry_value_t result_val = jerry_set_property (global_obj_val, name_val, value);
        -:   45:
    #####:   46:  jerry_release_value (name_val);
    #####:   47:  jerry_release_value (global_obj_val);
        -:   48:
    #####:   49:  jerry_release_value (result_val);
    #####:   50:} /* register_js_value */
        -:   51:
        -:   52:static jerry_value_t
    #####:   53:assert_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   54:                const jerry_value_t args_p[], /**< function arguments */
        -:   55:                const jerry_length_t args_cnt) /**< number of function arguments */
        -:   56:{
        -:   57:  JERRY_UNUSED (call_info_p);
        -:   58:
    #####:   59:  if (jerry_value_is_true (args_p[0]))
        -:   60:  {
    #####:   61:    return jerry_create_boolean (true);
        -:   62:  }
        -:   63:  else
        -:   64:  {
    #####:   65:    if (args_cnt > 1
    #####:   66:        && jerry_value_is_string (args_p[1]))
    #####:   67:    {
    #####:   68:      jerry_length_t utf8_sz = jerry_get_string_size (args_p[1]);
    #####:   69:      TEST_ASSERT (utf8_sz <= 127); /* 127 is the expected max assert fail message size. */
    #####:   70:      JERRY_VLA (char, string_from_utf8, utf8_sz + 1);
    #####:   71:      string_from_utf8[utf8_sz] = 0;
        -:   72:
    #####:   73:      jerry_string_to_char_buffer (args_p[1], (jerry_char_t *) string_from_utf8, utf8_sz);
        -:   74:
    #####:   75:      printf ("JS assert: %s\n", string_from_utf8);
        -:   76:    }
    #####:   77:    TEST_ASSERT (false);
        -:   78:  }
        -:   79:} /* assert_handler */
        -:   80:
        -:   81:/**
        -:   82: * Do simple TypedArray property validation.
        -:   83: */
        -:   84:static void
    #####:   85:test_typedarray_info (jerry_value_t typedarray, /**< target TypedArray to query */
        -:   86:                      jerry_typedarray_type_t typedarray_type, /**< expected TypedArray type */
        -:   87:                      jerry_length_t element_count, /**< expected element count */
        -:   88:                      jerry_length_t bytes_per_element) /**< bytes per element for the given type */
        -:   89:{
    #####:   90:  TEST_ASSERT (!jerry_value_is_error (typedarray));
    #####:   91:  TEST_ASSERT (jerry_value_is_typedarray (typedarray));
    #####:   92:  TEST_ASSERT (jerry_get_typedarray_type (typedarray) == typedarray_type);
    #####:   93:  TEST_ASSERT (jerry_get_typedarray_length (typedarray) == element_count);
        -:   94:
    #####:   95:  jerry_length_t byte_length = (uint32_t) -1;
    #####:   96:  jerry_length_t byte_offset = (uint32_t) -1;
    #####:   97:  jerry_value_t arraybuffer = jerry_get_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:   98:  TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
        -:   99:
    #####:  100:  TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:  101:  TEST_ASSERT (byte_offset == 0);
        -:  102:
    #####:  103:  jerry_release_value (arraybuffer);
    #####:  104:} /* test_typedarray_info */
        -:  105:
        -:  106:/**
        -:  107: * Test construction of TypedArrays and validate properties.
        -:  108: */
        -:  109:static void
    #####:  110:test_typedarray_queries (test_entry_t test_entries[]) /**< test cases */
        -:  111:{
    #####:  112:  jerry_value_t global_obj_val = jerry_get_global_object ();
        -:  113:
    #####:  114:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  115:  {
        -:  116:    /* Create TypedArray via construct call */
        -:  117:    {
    #####:  118:      jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) test_entries[i].constructor_name);
    #####:  119:      jerry_value_t prop_value = jerry_get_property (global_obj_val, prop_name);
    #####:  120:      TEST_ASSERT (!jerry_value_is_error (prop_value));
    #####:  121:      jerry_value_t length_arg = jerry_create_number (test_entries[i].element_count);
        -:  122:
    #####:  123:      jerry_value_t typedarray = jerry_construct_object (prop_value, &length_arg, 1);
        -:  124:
    #####:  125:      jerry_release_value (prop_name);
    #####:  126:      jerry_release_value (prop_value);
    #####:  127:      jerry_release_value (length_arg);
        -:  128:
    #####:  129:      test_typedarray_info (typedarray,
        -:  130:                            test_entries[i].typedarray_type,
        -:  131:                            test_entries[i].element_count,
        -:  132:                            test_entries[i].bytes_per_element);
    #####:  133:      jerry_release_value (typedarray);
        -:  134:    }
        -:  135:
        -:  136:    /* Create TypedArray via api call */
        -:  137:    {
    #####:  138:      jerry_value_t typedarray = jerry_create_typedarray (test_entries[i].typedarray_type,
        -:  139:                                                          test_entries[i].element_count);
    #####:  140:      test_typedarray_info (typedarray,
        -:  141:                            test_entries[i].typedarray_type,
        -:  142:                            test_entries[i].element_count,
        -:  143:                            test_entries[i].bytes_per_element);
    #####:  144:      jerry_release_value (typedarray);
        -:  145:    }
        -:  146:  }
        -:  147:
    #####:  148:  jerry_release_value (global_obj_val);
    #####:  149:} /* test_typedarray_queries */
        -:  150:
        -:  151:/**
        -:  152: * Test value at given position in the buffer based on TypedArray type.
        -:  153: */
        -:  154:static
    #####:  155:void test_buffer_value (uint64_t value, /**< value to test for */
        -:  156:                        const void *buffer, /**< buffer to read value from */
        -:  157:                        uint32_t start_offset, /**< start offset of the value */
        -:  158:                        jerry_typedarray_type_t typedarray_type, /**< type of TypedArray */
        -:  159:                        uint32_t bytes_per_element) /**< bytes per element for the given type */
        -:  160:{
    #####:  161:  uint32_t offset = start_offset / bytes_per_element;
        -:  162:
        -:  163:#define TEST_VALUE_AT(TYPE, BUFFER, OFFSET, VALUE) TEST_ASSERT (((TYPE *) BUFFER)[OFFSET] == (TYPE) (VALUE))
        -:  164:
    #####:  165:  switch (typedarray_type)
        -:  166:  {
    #####:  167:    case JERRY_TYPEDARRAY_UINT8:      TEST_VALUE_AT (uint8_t,  buffer, offset, value); break;
    #####:  168:    case JERRY_TYPEDARRAY_INT8:       TEST_VALUE_AT (int8_t,   buffer, offset, value); break;
    #####:  169:    case JERRY_TYPEDARRAY_UINT16:     TEST_VALUE_AT (uint16_t, buffer, offset, value); break;
    #####:  170:    case JERRY_TYPEDARRAY_INT16:      TEST_VALUE_AT (int16_t,  buffer, offset, value); break;
    #####:  171:    case JERRY_TYPEDARRAY_UINT32:     TEST_VALUE_AT (uint32_t, buffer, offset, value); break;
    #####:  172:    case JERRY_TYPEDARRAY_INT32:      TEST_VALUE_AT (int32_t,  buffer, offset, value); break;
    #####:  173:    case JERRY_TYPEDARRAY_FLOAT32:    TEST_VALUE_AT (float,    buffer, offset, value); break;
    #####:  174:    case JERRY_TYPEDARRAY_FLOAT64:    TEST_VALUE_AT (double,   buffer, offset, value); break;
    #####:  175:    case JERRY_TYPEDARRAY_BIGINT64:   TEST_VALUE_AT (int64_t,  buffer, offset, value); break;
    #####:  176:    case JERRY_TYPEDARRAY_BIGUINT64:  TEST_VALUE_AT (uint64_t, buffer, offset, value); break;
        -:  177:
    #####:  178:    case JERRY_TYPEDARRAY_UINT8CLAMPED:
        -:  179:    {
    #####:  180:      int64_t signed_value = (int64_t) value;
    #####:  181:      uint8_t expected = (uint8_t) value;
        -:  182:
        -:  183:      /* clamp the value if required*/
    #####:  184:      if (signed_value > 0xFF)
        -:  185:      {
        -:  186:        expected = 0xFF;
        -:  187:      }
    #####:  188:      else if (signed_value < 0)
        -:  189:      {
    #####:  190:        expected = 0;
        -:  191:      }
        -:  192:
    #####:  193:      TEST_VALUE_AT (uint8_t, buffer, offset, expected); break;
        -:  194:    }
    #####:  195:    default: TEST_ASSERT (false); break;
        -:  196:  }
        -:  197:
        -:  198:#undef TEST_VALUE_AT
    #####:  199:} /* test_buffer_value */
        -:  200:
        -:  201:static void
    #####:  202:test_typedarray_complex_creation (test_entry_t test_entries[], /**< test cases */
        -:  203:                                  bool use_external_buffer) /**< run tests using arraybuffer with external memory */
        -:  204:{
    #####:  205:  const uint32_t arraybuffer_size = 256;
        -:  206:
    #####:  207:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  208:  {
    #####:  209:    const uint32_t offset = 8;
    #####:  210:    uint32_t element_count = test_entries[i].element_count;
    #####:  211:    uint32_t bytes_per_element = test_entries[i].bytes_per_element;
    #####:  212:    uint8_t *buffer_p = NULL;
        -:  213:
        -:  214:    /* new %TypedArray% (buffer, offset, length); */
        -:  215:    jerry_value_t typedarray;
        -:  216:    {
        -:  217:      jerry_value_t arraybuffer;
        -:  218:
    #####:  219:      if (use_external_buffer)
        -:  220:      {
    #####:  221:        buffer_p = (uint8_t *) jerry_heap_alloc (arraybuffer_size);
    #####:  222:        arraybuffer = jerry_create_arraybuffer_external (arraybuffer_size, buffer_p, NULL);
        -:  223:      }
        -:  224:      else
        -:  225:      {
    #####:  226:        arraybuffer = jerry_create_arraybuffer (arraybuffer_size);
        -:  227:      }
        -:  228:
    #####:  229:      jerry_value_t js_offset = jerry_create_number (offset);
    #####:  230:      jerry_value_t js_element_count = jerry_create_number (element_count);
        -:  231:
    #####:  232:      register_js_value ("expected_offset", js_offset);
    #####:  233:      register_js_value ("expected_length", js_element_count);
        -:  234:
    #####:  235:      typedarray = jerry_create_typedarray_for_arraybuffer_sz (test_entries[i].typedarray_type,
        -:  236:                                                               arraybuffer,
        -:  237:                                                               offset,
        -:  238:                                                               element_count);
    #####:  239:      TEST_ASSERT (!jerry_value_is_error (typedarray));
        -:  240:
    #####:  241:      jerry_release_value (js_offset);
    #####:  242:      jerry_release_value (js_element_count);
    #####:  243:      jerry_release_value (arraybuffer);
        -:  244:    }
        -:  245:
    #####:  246:    register_js_value ("array", typedarray);
        -:  247:
    #####:  248:    const jerry_char_t test_exptected_src[] = TEST_STRING_LITERAL (
        -:  249:      "assert (array.length == expected_length,"
        -:  250:      "        'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  251:      "assert (array.byteOffset == expected_offset);"
        -:  252:    );
    #####:  253:    jerry_value_t result = jerry_eval (test_exptected_src,
        -:  254:                                       sizeof (test_exptected_src) - 1,
        -:  255:                                       JERRY_PARSE_STRICT_MODE);
    #####:  256:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  257:    jerry_release_value (result);
        -:  258:
    #####:  259:    const jerry_char_t set_element_src[] = TEST_STRING_LITERAL (
        -:  260:      "array[0] = 0x11223344n"
        -:  261:    );
        -:  262:
        -:  263:    /* crop the last 'n' character */
    #####:  264:    size_t src_length = sizeof (set_element_src) - 2;
        -:  265:
    #####:  266:    if (test_entries[i].typedarray_type >= JERRY_TYPEDARRAY_BIGINT64)
        -:  267:    {
        -:  268:      /* use the last 'n' character */
    #####:  269:      src_length++;
        -:  270:    }
        -:  271:
    #####:  272:    result = jerry_eval (set_element_src, src_length, JERRY_PARSE_STRICT_MODE);
    #####:  273:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  274:    jerry_release_value (result);
        -:  275:
    #####:  276:    {
    #####:  277:      jerry_length_t byte_length = 0;
    #####:  278:      jerry_length_t byte_offset = 0;
    #####:  279:      jerry_value_t buffer = jerry_get_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:  280:      TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:  281:      TEST_ASSERT (byte_offset == offset);
        -:  282:
    #####:  283:      JERRY_VLA (uint8_t, test_buffer, arraybuffer_size);
        -:  284:
    #####:  285:      jerry_typedarray_type_t type = jerry_get_typedarray_type (typedarray);
    #####:  286:      jerry_value_t read_count = jerry_arraybuffer_read (buffer, 0, test_buffer, offset + byte_length);
    #####:  287:      TEST_ASSERT (read_count == offset + byte_length);
    #####:  288:      test_buffer_value (0x11223344, test_buffer, offset, type, bytes_per_element);
        -:  289:
    #####:  290:      if (use_external_buffer)
        -:  291:      {
    #####:  292:        test_buffer_value (0x11223344, buffer_p, offset, type, bytes_per_element);
    #####:  293:        TEST_ASSERT (memcmp (buffer_p, test_buffer, offset + byte_length) == 0);
        -:  294:      }
        -:  295:
    #####:  296:      jerry_release_value (buffer);
        -:  297:    }
        -:  298:
    #####:  299:    jerry_release_value (typedarray);
        -:  300:  }
    #####:  301:} /* test_typedarray_complex_creation */
        -:  302:
        -:  303:/**
        -:  304: * Test get/set/delete property by index.
        -:  305: */
    #####:  306:static void test_property_by_index (test_entry_t test_entries[])
        -:  307:{
    #####:  308:  int test_int_numbers[5] = {-5, -70, 13, 0, 56};
    #####:  309:  double test_double_numbers[5] = {-83.153, -35.15, 0, 13.1, 89.8975};
    #####:  310:  uint8_t test_uint_numbers[5] = {83, 15, 36, 0, 43};
    #####:  311:  uint64_t test_uint64_numbers[5] = {83, 0, 1, UINT32_MAX, UINT64_MAX};
    #####:  312:  int64_t test_int64_numbers[5] = {INT64_MAX, INT64_MIN, 0, INT32_MAX, INT32_MIN};
        -:  313:
    #####:  314:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  315:  {
        -:  316:    jerry_value_t test_number;
    #####:  317:    uint32_t test_numbers_length = sizeof (test_int_numbers) / sizeof (int);
    #####:  318:    jerry_value_t typedarray = jerry_create_typedarray (test_entries[i].typedarray_type, test_numbers_length);
    #####:  319:    jerry_typedarray_type_t type = jerry_get_typedarray_type (typedarray);
        -:  320:
        -:  321:    jerry_value_t set_result;
        -:  322:    jerry_value_t get_result;
        -:  323:
    #####:  324:    switch (type)
        -:  325:    {
        -:  326:      case JERRY_TYPEDARRAY_INT8:
        -:  327:      case JERRY_TYPEDARRAY_INT16:
        -:  328:      case JERRY_TYPEDARRAY_INT32:
        -:  329:      {
    #####:  330:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  331:        {
    #####:  332:          test_number = jerry_create_number (test_int_numbers[j]);
    #####:  333:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  334:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  335:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  336:
    #####:  337:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  338:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  339:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  340:          TEST_ASSERT (jerry_get_number_value (get_result) == test_int_numbers[j]);
        -:  341:
    #####:  342:          jerry_release_value (test_number);
    #####:  343:          jerry_release_value (set_result);
    #####:  344:          jerry_release_value (get_result);
        -:  345:        }
        -:  346:        break;
        -:  347:      }
        -:  348:      case JERRY_TYPEDARRAY_FLOAT32:
        -:  349:      case JERRY_TYPEDARRAY_FLOAT64:
        -:  350:      {
    #####:  351:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  352:        {
    #####:  353:          test_number = jerry_create_number (test_double_numbers[j]);
    #####:  354:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  355:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  356:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  357:
    #####:  358:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  359:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  360:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  361:
    #####:  362:          double epsilon = pow (10, -5);
    #####:  363:          double get_abs = fabs (jerry_get_number_value (get_result) - test_double_numbers[j]);
    #####:  364:          TEST_ASSERT (get_abs < epsilon);
        -:  365:
    #####:  366:          jerry_release_value (test_number);
    #####:  367:          jerry_release_value (set_result);
    #####:  368:          jerry_release_value (get_result);
        -:  369:
        -:  370:          /* Testing positive and negative infinity */
    #####:  371:          for (uint8_t k = 0; k < 2; k++)
        -:  372:          {
    #####:  373:            jerry_value_t inf = jerry_create_number_infinity (k);
    #####:  374:            jerry_value_t set_inf = jerry_set_property_by_index (typedarray, 0, inf);
    #####:  375:            TEST_ASSERT (jerry_value_is_boolean (set_inf));
    #####:  376:            TEST_ASSERT (jerry_value_is_true (set_inf));
    #####:  377:            jerry_value_t get_inf = jerry_get_property_by_index (typedarray, 0);
    #####:  378:            TEST_ASSERT (isinf (jerry_get_number_value (get_inf)));
        -:  379:
    #####:  380:            jerry_release_value (inf);
    #####:  381:            jerry_release_value (set_inf);
    #####:  382:            jerry_release_value (get_inf);
        -:  383:          }
        -:  384:        }
        -:  385:        break;
        -:  386:      }
        -:  387:      case JERRY_TYPEDARRAY_BIGINT64:
        -:  388:      {
    #####:  389:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  390:        {
    #####:  391:          test_number = jerry_create_bigint ((uint64_t *) &test_int64_numbers[j], 1, true);
    #####:  392:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  393:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  394:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  395:
    #####:  396:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  397:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  398:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  399:          int64_t get_number;
        -:  400:          bool sign;
    #####:  401:          jerry_get_bigint_digits (get_result, (uint64_t *) &get_number, 1, &sign);
        -:  402:
    #####:  403:          TEST_ASSERT (sign ? get_number : -get_number == test_int64_numbers[j]);
        -:  404:
    #####:  405:          jerry_release_value (test_number);
    #####:  406:          jerry_release_value (set_result);
    #####:  407:          jerry_release_value (get_result);
        -:  408:        }
        -:  409:        break;
        -:  410:      }
        -:  411:      case JERRY_TYPEDARRAY_BIGUINT64:
        -:  412:      {
    #####:  413:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  414:        {
    #####:  415:          test_number = jerry_create_bigint (&test_uint64_numbers[j], 1, false);
    #####:  416:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  417:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  418:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  419:
    #####:  420:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  421:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  422:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
        -:  423:          uint64_t get_number;
        -:  424:          bool sign;
    #####:  425:          jerry_get_bigint_digits (get_result, &get_number, 1, &sign);
        -:  426:
    #####:  427:          TEST_ASSERT (get_number == test_uint64_numbers[j]);
        -:  428:
    #####:  429:          jerry_release_value (test_number);
    #####:  430:          jerry_release_value (set_result);
    #####:  431:          jerry_release_value (get_result);
        -:  432:        }
        -:  433:        break;
        -:  434:      }
        -:  435:      default:
        -:  436:      {
    #####:  437:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  438:        {
    #####:  439:          test_number = jerry_create_number (test_uint_numbers[j]);
    #####:  440:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  441:          set_result = jerry_set_property_by_index (typedarray, j, test_number);
    #####:  442:          get_result = jerry_get_property_by_index (typedarray, j);
        -:  443:
    #####:  444:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  445:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  446:          TEST_ASSERT (!jerry_delete_property_by_index (typedarray, j));
    #####:  447:          TEST_ASSERT (jerry_get_number_value (get_result) == test_uint_numbers[j]);
        -:  448:
    #####:  449:          jerry_release_value (test_number);
    #####:  450:          jerry_release_value (set_result);
    #####:  451:          jerry_release_value (get_result);
        -:  452:        }
        -:  453:        break;
        -:  454:      }
        -:  455:    }
        -:  456:
    #####:  457:    jerry_value_t set_undefined = jerry_set_property_by_index (typedarray, 100, jerry_create_number (50));
        -:  458:
    #####:  459:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  460:    {
    #####:  461:      TEST_ASSERT (jerry_value_is_error (set_undefined));
        -:  462:    }
        -:  463:    else
        -:  464:    {
    #####:  465:      TEST_ASSERT (jerry_value_is_boolean (set_undefined) && !jerry_value_is_true (set_undefined));
        -:  466:    }
        -:  467:
    #####:  468:    jerry_value_t get_undefined = jerry_get_property_by_index (typedarray, 100);
        -:  469:
    #####:  470:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  471:    {
    #####:  472:      TEST_ASSERT (jerry_value_is_error (set_undefined));
        -:  473:    }
        -:  474:    else
        -:  475:    {
    #####:  476:      TEST_ASSERT (jerry_value_is_undefined (get_undefined));
        -:  477:    }
        -:  478:
    #####:  479:    TEST_ASSERT (jerry_value_is_undefined (get_undefined));
    #####:  480:    jerry_release_value (set_undefined);
    #####:  481:    jerry_release_value (get_undefined);
    #####:  482:    jerry_release_value (typedarray);
        -:  483:  }
    #####:  484:} /* test_property_by_index */
        -:  485:
        -:  486:static void
    #####:  487:test_detached_arraybuffer (void)
        -:  488:{
        -:  489:  static jerry_typedarray_type_t types[] =
        -:  490:  {
        -:  491:    JERRY_TYPEDARRAY_UINT8,
        -:  492:    JERRY_TYPEDARRAY_UINT8CLAMPED,
        -:  493:    JERRY_TYPEDARRAY_INT8,
        -:  494:    JERRY_TYPEDARRAY_UINT16,
        -:  495:    JERRY_TYPEDARRAY_INT16,
        -:  496:    JERRY_TYPEDARRAY_UINT32,
        -:  497:    JERRY_TYPEDARRAY_INT32,
        -:  498:    JERRY_TYPEDARRAY_FLOAT32,
        -:  499:    JERRY_TYPEDARRAY_FLOAT64,
        -:  500:    JERRY_TYPEDARRAY_BIGINT64,
        -:  501:    JERRY_TYPEDARRAY_BIGUINT64,
        -:  502:  };
        -:  503:
        -:  504:  /* Creating an TypedArray for a detached array buffer with a given length/offset is invalid */
        -:  505:  {
    #####:  506:    const uint32_t length = 1;
    #####:  507:    uint8_t *buffer_p = (uint8_t *) jerry_heap_alloc (length);
    #####:  508:    jerry_value_t arraybuffer = jerry_create_arraybuffer_external (length, buffer_p, NULL);
    #####:  509:    TEST_ASSERT (!jerry_value_is_error (arraybuffer));
    #####:  510:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  511:    TEST_ASSERT (jerry_get_arraybuffer_byte_length (arraybuffer) == length);
        -:  512:
    #####:  513:    jerry_value_t is_detachable = jerry_is_arraybuffer_detachable (arraybuffer);
    #####:  514:    TEST_ASSERT (!jerry_value_is_error (is_detachable));
    #####:  515:    TEST_ASSERT (jerry_value_is_true (is_detachable));
    #####:  516:    jerry_release_value (is_detachable);
        -:  517:
    #####:  518:    jerry_value_t res = jerry_detach_arraybuffer (arraybuffer);
    #####:  519:    TEST_ASSERT (!jerry_value_is_error (res));
    #####:  520:    jerry_release_value (res);
        -:  521:
    #####:  522:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  523:    {
    #####:  524:      jerry_value_t typedarray = jerry_create_typedarray_for_arraybuffer_sz (types[idx], arraybuffer, 0, 4);
    #####:  525:      TEST_ASSERT (jerry_value_is_error (typedarray));
    #####:  526:      TEST_ASSERT (jerry_get_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  527:      jerry_release_value (typedarray);
        -:  528:    }
        -:  529:
    #####:  530:    jerry_release_value (arraybuffer);
        -:  531:  }
        -:  532:
        -:  533:  /* Creating an TypedArray for a detached array buffer without length/offset is valid */
        -:  534:  {
    #####:  535:    const uint32_t length = 1;
    #####:  536:    uint8_t *buffer_p = (uint8_t *) jerry_heap_alloc (length);
    #####:  537:    jerry_value_t arraybuffer = jerry_create_arraybuffer_external (length, buffer_p, NULL);
    #####:  538:    TEST_ASSERT (!jerry_value_is_error (arraybuffer));
    #####:  539:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  540:    TEST_ASSERT (jerry_get_arraybuffer_byte_length (arraybuffer) == length);
        -:  541:
    #####:  542:    jerry_value_t is_detachable = jerry_is_arraybuffer_detachable (arraybuffer);
    #####:  543:    TEST_ASSERT (!jerry_value_is_error (is_detachable));
    #####:  544:    TEST_ASSERT (jerry_value_is_true (is_detachable));
    #####:  545:    jerry_release_value (is_detachable);
        -:  546:
    #####:  547:    jerry_value_t res = jerry_detach_arraybuffer (arraybuffer);
    #####:  548:    TEST_ASSERT (!jerry_value_is_error (res));
    #####:  549:    jerry_release_value (res);
        -:  550:
    #####:  551:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  552:    {
    #####:  553:      jerry_value_t typedarray = jerry_create_typedarray_for_arraybuffer (types[idx], arraybuffer);
    #####:  554:      TEST_ASSERT (jerry_value_is_error (typedarray));
    #####:  555:      TEST_ASSERT (jerry_get_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  556:      jerry_release_value (typedarray);
        -:  557:    }
        -:  558:
    #####:  559:    jerry_release_value (arraybuffer);
        -:  560:  }
    #####:  561:} /* test_detached_arraybuffer */
        -:  562:
        -:  563:int
    #####:  564:main (void)
        -:  565:{
    #####:  566:  jerry_init (JERRY_INIT_EMPTY);
        -:  567:
    #####:  568:  if (!jerry_is_feature_enabled (JERRY_FEATURE_TYPEDARRAY))
        -:  569:  {
    #####:  570:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TypedArray is disabled!\n");
    #####:  571:    jerry_cleanup ();
    #####:  572:    return 0;
        -:  573:  }
        -:  574:
    #####:  575:  jerry_value_t function_val = jerry_create_external_function (assert_handler);
    #####:  576:  register_js_value ("assert", function_val);
    #####:  577:  jerry_release_value (function_val);
        -:  578:
    #####:  579:  test_entry_t test_entries[] =
        -:  580:  {
        -:  581:#define TEST_ENTRY(TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT) \
        -:  582:      { TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT }
        -:  583:
        -:  584:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8,        "Uint8Array",        12, 1),
        -:  585:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8CLAMPED, "Uint8ClampedArray", 12, 1),
        -:  586:    TEST_ENTRY (JERRY_TYPEDARRAY_INT8,         "Int8Array",         12, 1),
        -:  587:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16,       "Uint16Array",       12, 2),
        -:  588:    TEST_ENTRY (JERRY_TYPEDARRAY_INT16,        "Int16Array",        12, 2),
        -:  589:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16,       "Uint16Array",       12, 2),
        -:  590:    TEST_ENTRY (JERRY_TYPEDARRAY_INT32,        "Int32Array",        12, 4),
        -:  591:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT32,       "Uint32Array",       12, 4),
        -:  592:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT32,      "Float32Array",      12, 4),
        -:  593:  /* TODO: add check if the float64 is supported */
        -:  594:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT64,      "Float64Array",      12, 8),
        -:  595:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGINT64,     "BigInt64Array",     12, 8),
        -:  596:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGUINT64,    "BigUint64Array",    12, 8),
        -:  597:
        -:  598:    TEST_ENTRY (JERRY_TYPEDARRAY_INVALID, NULL, 0, 0)
        -:  599:#undef TEST_ENTRY
        -:  600:  };
        -:  601:
        -:  602:  /* Test TypedArray queries */
    #####:  603:  test_typedarray_queries (test_entries);
        -:  604:
        -:  605:  /* Test TypedArray operations in js */
        -:  606:  {
    #####:  607:    const uint32_t element_count = 14;
        -:  608:
    #####:  609:    jerry_value_t array = jerry_create_typedarray (JERRY_TYPEDARRAY_UINT8, element_count);
        -:  610:
    #####:  611:    {
    #####:  612:      uint8_t expected_value = 42;
    #####:  613:      JERRY_VLA (uint8_t, expected_data, element_count);
    #####:  614:      memset (expected_data, expected_value, element_count);
        -:  615:
        -:  616:      jerry_length_t byte_length;
        -:  617:      jerry_length_t offset;
    #####:  618:      jerry_value_t buffer = jerry_get_typedarray_buffer (array, &offset, &byte_length);
    #####:  619:      TEST_ASSERT (byte_length == element_count);
    #####:  620:      jerry_length_t written = jerry_arraybuffer_write (buffer, offset, expected_data, element_count);
    #####:  621:      TEST_ASSERT (written == element_count);
    #####:  622:      jerry_release_value (buffer);
        -:  623:
    #####:  624:      jerry_value_t js_element_count = jerry_create_number (element_count);
    #####:  625:      jerry_value_t js_expected_value = jerry_create_number (expected_value);
        -:  626:
    #####:  627:      register_js_value ("array", array);
    #####:  628:      register_js_value ("expected_length", js_element_count);
    #####:  629:      register_js_value ("expected_value", js_expected_value);
        -:  630:
    #####:  631:      jerry_release_value (js_element_count);
    #####:  632:      jerry_release_value (js_expected_value);
        -:  633:    }
        -:  634:
        -:  635:    /* Check read and to write */
    #####:  636:    const jerry_char_t eval_src[] = TEST_STRING_LITERAL (
        -:  637:      "assert (array.length == expected_length, 'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  638:      "for (var i = 0; i < array.length; i++)"
        -:  639:      "{"
        -:  640:      "  assert (array[i] == expected_value);"
        -:  641:      "  array[i] = i;"
        -:  642:      "};"
        -:  643:    );
    #####:  644:    jerry_value_t result = jerry_eval (eval_src,
        -:  645:                                       sizeof (eval_src) - 1,
        -:  646:                                       JERRY_PARSE_STRICT_MODE);
        -:  647:
    #####:  648:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:  649:    jerry_release_value (result);
        -:  650:
        -:  651:    /* Check write results */
    #####:  652:    {
        -:  653:      jerry_length_t byte_length;
        -:  654:      jerry_length_t offset;
    #####:  655:      jerry_value_t buffer = jerry_get_typedarray_buffer (array, &offset, &byte_length);
    #####:  656:      TEST_ASSERT (byte_length == element_count);
        -:  657:
    #####:  658:      JERRY_VLA (uint8_t, result_data, element_count);
        -:  659:
    #####:  660:      jerry_length_t read_count = jerry_arraybuffer_read (buffer, offset, result_data, byte_length);
    #####:  661:      TEST_ASSERT (read_count == byte_length);
        -:  662:
    #####:  663:      for (uint8_t i = 0; i < read_count; i++)
        -:  664:      {
    #####:  665:        TEST_ASSERT (result_data[i] == i);
        -:  666:      }
        -:  667:
    #####:  668:      jerry_release_value (buffer);
        -:  669:    }
        -:  670:
    #####:  671:    jerry_release_value (array);
        -:  672:  }
        -:  673:
    #####:  674:  test_typedarray_complex_creation (test_entries, false);
    #####:  675:  test_typedarray_complex_creation (test_entries, true);
        -:  676:
    #####:  677:  test_property_by_index (test_entries);
        -:  678:
        -:  679:  /* test invalid things */
        -:  680:  {
    #####:  681:    jerry_value_t values[] =
        -:  682:    {
    #####:  683:      jerry_create_number (11),
    #####:  684:      jerry_create_boolean (false),
    #####:  685:      jerry_create_string ((const jerry_char_t *) "test"),
    #####:  686:      jerry_create_object (),
    #####:  687:      jerry_create_null (),
    #####:  688:      jerry_create_arraybuffer (16),
    #####:  689:      jerry_create_error (JERRY_ERROR_TYPE, (const jerry_char_t *) "error"),
    #####:  690:      jerry_create_undefined (),
    #####:  691:      jerry_create_promise (),
        -:  692:    };
        -:  693:
    #####:  694:    for (size_t idx = 0; idx < sizeof (values) / sizeof (values[0]); idx++)
        -:  695:    {
        -:  696:      /* A non-TypedArray object should not be regarded a TypedArray. */
    #####:  697:      bool is_typedarray = jerry_value_is_typedarray (values[idx]);
    #####:  698:      TEST_ASSERT (is_typedarray == false);
        -:  699:
        -:  700:      /* JERRY_TYPEDARRAY_INVALID should be returned for non-TypedArray objects */
    #####:  701:      jerry_typedarray_type_t type = jerry_get_typedarray_type (values[idx]);
    #####:  702:      TEST_ASSERT (type == JERRY_TYPEDARRAY_INVALID);
        -:  703:
        -:  704:      /* Zero should be returned for non-TypedArray objects */
    #####:  705:      jerry_length_t length = jerry_get_typedarray_length (values[idx]);
    #####:  706:      TEST_ASSERT (length == 0);
        -:  707:
        -:  708:      /**
        -:  709:       * Getting the ArrayBuffer from a non-TypedArray object(s) should return an error
        -:  710:       * and should not modify the output parameter values.
        -:  711:       */
        -:  712:      {
    #####:  713:        jerry_length_t offset = 22;
    #####:  714:        jerry_length_t byte_count = 23;
    #####:  715:        jerry_value_t error = jerry_get_typedarray_buffer (values[idx], &offset, &byte_count);
    #####:  716:        TEST_ASSERT (jerry_value_is_error (error));
    #####:  717:        TEST_ASSERT (offset == 22);
    #####:  718:        TEST_ASSERT (byte_count == 23);
    #####:  719:        jerry_release_value (error);
        -:  720:      }
        -:  721:
        -:  722:      /**
        -:  723:       * Creating a TypedArray from a non-ArrayBuffer should result an error.
        -:  724:       */
    #####:  725:      if (!jerry_value_is_arraybuffer (values[idx]))
        -:  726:      {
    #####:  727:        jerry_value_t error = jerry_create_typedarray_for_arraybuffer (JERRY_TYPEDARRAY_UINT8, values[idx]);
    #####:  728:        TEST_ASSERT (jerry_value_is_error (error));
    #####:  729:        jerry_release_value (error);
        -:  730:      }
        -:  731:
    #####:  732:      jerry_release_value (values[idx]);
        -:  733:    }
        -:  734:  }
        -:  735:
    #####:  736:  test_detached_arraybuffer ();
        -:  737:
    #####:  738:  jerry_cleanup ();
        -:  739:
    #####:  740:  return 0;
        -:  741:} /* main */
