        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-typedarray-object.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-iterator-object.h"
        -:   19:#include "ecma-typedarray-object.h"
        -:   20:#include "ecma-arraybuffer-object.h"
        -:   21:#include "ecma-shared-arraybuffer-object.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-big-uint.h"
        -:   25:#include "ecma-builtin-helpers.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "ecma-builtins.h"
        -:   29:#include "ecma-exceptions.h"
        -:   30:#include "ecma-gc.h"
        -:   31:#include "ecma-globals.h"
        -:   32:#include "ecma-helpers.h"
        -:   33:#include "jcontext.h"
        -:   34:
        -:   35:#if JERRY_BUILTIN_TYPEDARRAY
        -:   36:
        -:   37:/** \addtogroup ecma ECMA
        -:   38: * @{
        -:   39: *
        -:   40: * \addtogroup ecmatypedarrayobject ECMA TypedArray object related routines
        -:   41: * @{
        -:   42: */
        -:   43:
        -:   44:/**
        -:   45: * Read and copy a number from a given buffer to a value.
        -:   46: **/
        -:   47:#define ECMA_TYPEDARRAY_GET_ELEMENT(src_p, num, type) \
        -:   48:    do \
        -:   49:    { \
        -:   50:      if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   51:      { \
        -:   52:        num = *(type *) ((void*) src_p); \
        -:   53:      } \
        -:   54:      else \
        -:   55:      { \
        -:   56:        memcpy (&num, (void *) src_p, sizeof (type)); \
        -:   57:      } \
        -:   58:    } \
        -:   59:    while (0)
        -:   60:
        -:   61:/**
        -:   62: * Copy a number from a value to the given buffer
        -:   63: **/
        -:   64:#define ECMA_TYPEDARRAY_SET_ELEMENT(src_p, num, type) \
        -:   65:    do \
        -:   66:    { \
        -:   67:      if (JERRY_LIKELY ((((uintptr_t) (src_p)) & (sizeof (type) - 1)) == 0)) \
        -:   68:      { \
        -:   69:        *(type *) ((void*) src_p) = num; \
        -:   70:      } \
        -:   71:      else \
        -:   72:      { \
        -:   73:        memcpy ((void*) src_p, &num, sizeof (type)); \
        -:   74:      } \
        -:   75:    } \
        -:   76:    while (0)
        -:   77:
        -:   78:/**
        -:   79: * Read an int8_t value from the given arraybuffer
        -:   80: */
        -:   81:static ecma_value_t
    #####:   82:ecma_typedarray_get_int8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   83:{
    #####:   84:  int8_t num = (int8_t) *src;
    #####:   85:  return ecma_make_integer_value (num);
        -:   86:} /* ecma_typedarray_get_int8_element */
        -:   87:
        -:   88:/**
        -:   89: * Read an uint8_t value from the given arraybuffer
        -:   90: */
        -:   91:static ecma_value_t
    #####:   92:ecma_typedarray_get_uint8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   93:{
    #####:   94:  uint8_t num = (uint8_t) *src;
    #####:   95:  return ecma_make_integer_value (num);
        -:   96:} /* ecma_typedarray_get_uint8_element */
        -:   97:
        -:   98:/**
        -:   99: * Read an int16_t value from the given arraybuffer
        -:  100: */
        -:  101:static ecma_value_t
    #####:  102:ecma_typedarray_get_int16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  103:{
    #####:  104:  int16_t num;
    #####:  105:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int16_t);
    #####:  106:  return ecma_make_integer_value (num);
        -:  107:} /* ecma_typedarray_get_int16_element */
        -:  108:
        -:  109:/**
        -:  110: * Read an uint16_t value from the given arraybuffer
        -:  111: */
        -:  112:static ecma_value_t
    #####:  113:ecma_typedarray_get_uint16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  114:{
    #####:  115:  uint16_t num;
    #####:  116:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint16_t);
    #####:  117:  return ecma_make_integer_value (num);
        -:  118:} /* ecma_typedarray_get_uint16_element */
        -:  119:
        -:  120:/**
        -:  121: * Read an int32_t value from the given arraybuffer
        -:  122: */
        -:  123:static ecma_value_t
      256:  124:ecma_typedarray_get_int32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  125:{
      256:  126:  int32_t num;
      256:  127:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, int32_t);
      256:  128:  return ecma_make_number_value (num);
        -:  129:} /* ecma_typedarray_get_int32_element */
        -:  130:
        -:  131:/**
        -:  132: * Read an uint32_t value from the given arraybuffer
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_typedarray_get_uint32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  136:{
    #####:  137:  uint32_t num;
    #####:  138:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint32_t);
    #####:  139:  return ecma_make_number_value (num);
        -:  140:} /* ecma_typedarray_get_uint32_element */
        -:  141:
        -:  142:/**
        -:  143: * Read a float value from the given arraybuffer
        -:  144: */
        -:  145:static ecma_value_t
    #####:  146:ecma_typedarray_get_float_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  147:{
    #####:  148:  float num;
    #####:  149:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, float);
    #####:  150:  return ecma_make_number_value (num);
        -:  151:} /* ecma_typedarray_get_float_element */
        -:  152:
        -:  153:/**
        -:  154: * Read a double value from the given arraybuffer
        -:  155: */
        -:  156:static ecma_value_t
    #####:  157:ecma_typedarray_get_double_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  158:{
    #####:  159:  double num;
    #####:  160:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, double);
    #####:  161:  return ecma_make_number_value (num);
        -:  162:} /* ecma_typedarray_get_double_element */
        -:  163:
        -:  164:#if JERRY_BUILTIN_BIGINT
        -:  165:/**
        -:  166: * Read a bigint64 value from the given arraybuffer
        -:  167: */
        -:  168:static ecma_value_t
    #####:  169:ecma_typedarray_get_bigint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  170:{
    #####:  171:  uint64_t num;
    #####:  172:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  173:  bool sign = (num >> 63) != 0;
        -:  174:
    #####:  175:  if (sign)
        -:  176:  {
    #####:  177:    num = (uint64_t) (-(int64_t) num);
        -:  178:  }
        -:  179:
    #####:  180:  return ecma_bigint_create_from_digits (&num, 1, sign);
        -:  181:} /* ecma_typedarray_get_bigint64_element */
        -:  182:
        -:  183:/**
        -:  184: * Read a biguint64 value from the given arraybuffer
        -:  185: */
        -:  186:static ecma_value_t
    #####:  187:ecma_typedarray_get_biguint64_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  188:{
    #####:  189:  uint64_t num;
    #####:  190:  ECMA_TYPEDARRAY_GET_ELEMENT (src, num, uint64_t);
    #####:  191:  return ecma_bigint_create_from_digits (&num, 1, false);
        -:  192:} /* ecma_typedarray_get_biguint64_element */
        -:  193:#endif /* JERRY_BUILTIN_BIGINT */
        -:  194:
        -:  195:/**
        -:  196: * Normalize the given ecma_number_t to an uint32_t value
        -:  197: */
        -:  198:static uint32_t
    #####:  199:ecma_typedarray_setter_number_to_uint32 (ecma_number_t value) /**< the number value to normalize */
        -:  200:{
    #####:  201:  uint32_t uint32_value = 0;
        -:  202:
    #####:  203:  if (!ecma_number_is_nan (value) && !ecma_number_is_infinity (value))
        -:  204:  {
    #####:  205:    bool is_negative = false;
        -:  206:
    #####:  207:    if (value < 0)
        -:  208:    {
    #####:  209:      is_negative = true;
    #####:  210:      value = -value;
        -:  211:    }
        -:  212:
    #####:  213:    if (value > ((ecma_number_t) 0xffffffff))
        -:  214:    {
    #####:  215:      value = (ecma_number_t) (fmod (value, (ecma_number_t) 0x100000000));
        -:  216:    }
        -:  217:
    #####:  218:    uint32_value = (uint32_t) value;
        -:  219:
    #####:  220:    if (is_negative)
        -:  221:    {
    #####:  222:      uint32_value = (uint32_t) (-(int32_t) uint32_value);
        -:  223:    }
        -:  224:  }
        -:  225:
    #####:  226:  return uint32_value;
        -:  227:} /* ecma_typedarray_setter_number_to_uint32 */
        -:  228:
        -:  229:/**
        -:  230: * Write an int8_t value into the given arraybuffer
        -:  231: *
        -:  232: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  233: *         ECMA_VALUE_TRUE - otherwise
        -:  234: */
        -:  235:static ecma_value_t
    #####:  236:ecma_typedarray_set_int8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  237:                                  ecma_value_t value) /**< the number value to set */
        -:  238:{
    #####:  239:  ecma_number_t result_num;
    #####:  240:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  241:
    #####:  242:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  243:  {
    #####:  244:    return to_num;
        -:  245:  }
        -:  246:
    #####:  247:  int8_t num = (int8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  248:  *dst_p = (lit_utf8_byte_t) num;
    #####:  249:  return ECMA_VALUE_TRUE;
        -:  250:} /* ecma_typedarray_set_int8_element */
        -:  251:
        -:  252:/**
        -:  253: * Write an uint8_t value into the given arraybuffer
        -:  254: *
        -:  255: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  256: *         ECMA_VALUE_TRUE - otherwise
        -:  257: */
        -:  258:static ecma_value_t
    #####:  259:ecma_typedarray_set_uint8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  260:                                   ecma_value_t value) /**< the number value to set */
        -:  261:{
    #####:  262:  ecma_number_t result_num;
    #####:  263:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  264:
    #####:  265:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  266:  {
    #####:  267:    return to_num;
        -:  268:  }
        -:  269:
    #####:  270:  uint8_t num = (uint8_t) ecma_typedarray_setter_number_to_uint32 (result_num);
    #####:  271:  *dst_p = (lit_utf8_byte_t) num;
    #####:  272:  return ECMA_VALUE_TRUE;
        -:  273:} /* ecma_typedarray_set_uint8_element */
        -:  274:
        -:  275:/**
        -:  276: * Write an uint8_t clamped value into the given arraybuffer
        -:  277: *
        -:  278: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  279: *         ECMA_VALUE_TRUE - otherwise
        -:  280: */
        -:  281:static ecma_value_t
    #####:  282:ecma_typedarray_set_uint8_clamped_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  283:                                           ecma_value_t value) /**< the number value to set */
        -:  284:{
    #####:  285:  ecma_number_t result_num;
    #####:  286:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  287:
    #####:  288:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  289:  {
    #####:  290:    return to_num;
        -:  291:  }
        -:  292:
        -:  293:  uint8_t clamped;
        -:  294:
    #####:  295:  if (result_num > 255)
        -:  296:  {
    #####:  297:    clamped = 255;
        -:  298:  }
    #####:  299:  else if (result_num <= 0)
        -:  300:  {
    #####:  301:    clamped = 0;
        -:  302:  }
        -:  303:  else
        -:  304:  {
    #####:  305:    clamped = (uint8_t) result_num;
        -:  306:
    #####:  307:    if (clamped + 0.5 < result_num
    #####:  308:        || (clamped + 0.5 == result_num && (clamped % 2) == 1))
        -:  309:    {
    #####:  310:      clamped ++;
        -:  311:    }
        -:  312:  }
        -:  313:
    #####:  314:  *dst_p = (lit_utf8_byte_t) clamped;
    #####:  315:  return ECMA_VALUE_TRUE;
        -:  316:} /* ecma_typedarray_set_uint8_clamped_element */
        -:  317:
        -:  318:/**
        -:  319: * Write an int16_t value into the given arraybuffer
        -:  320: *
        -:  321: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  322: *         ECMA_VALUE_TRUE - otherwise
        -:  323: */
        -:  324:static ecma_value_t
    #####:  325:ecma_typedarray_set_int16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  326:                                   ecma_value_t value) /**< the number value to set */
        -:  327:{
    #####:  328:  ecma_number_t resut_num;
    #####:  329:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  330:
    #####:  331:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  332:  {
    #####:  333:    return to_num;
        -:  334:  }
        -:  335:
    #####:  336:  int16_t num = (int16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  337:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int16_t);
    #####:  338:  return ECMA_VALUE_TRUE;
        -:  339:} /* ecma_typedarray_set_int16_element */
        -:  340:
        -:  341:/**
        -:  342: * Write an uint8_t value into the given arraybuffer
        -:  343: *
        -:  344: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  345: *         ECMA_VALUE_TRUE - otherwise
        -:  346: */
        -:  347:static ecma_value_t
    #####:  348:ecma_typedarray_set_uint16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  349:                                    ecma_value_t value) /**< the number value to set */
        -:  350:{
    #####:  351:  ecma_number_t resut_num;
    #####:  352:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  353:
    #####:  354:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  355:  {
    #####:  356:    return to_num;
        -:  357:  }
        -:  358:
    #####:  359:  uint16_t num = (uint16_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  360:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint16_t);
    #####:  361:  return ECMA_VALUE_TRUE;
        -:  362:} /* ecma_typedarray_set_uint16_element */
        -:  363:
        -:  364:/**
        -:  365: * Write an int32_t value into the given arraybuffer
        -:  366: *
        -:  367: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  368: *         ECMA_VALUE_TRUE - otherwise
        -:  369: */
        -:  370:static ecma_value_t
    #####:  371:ecma_typedarray_set_int32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  372:                                   ecma_value_t value) /**< the number value to set */
        -:  373:{
    #####:  374:  ecma_number_t resut_num;
    #####:  375:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  376:
    #####:  377:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  378:  {
    #####:  379:    return to_num;
        -:  380:  }
        -:  381:
    #####:  382:  int32_t num = (int32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  383:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, int32_t);
    #####:  384:  return ECMA_VALUE_TRUE;
        -:  385:} /* ecma_typedarray_set_int32_element */
        -:  386:
        -:  387:/**
        -:  388: * Write an uint32_t value into the given arraybuffer
        -:  389: *
        -:  390: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  391: *         ECMA_VALUE_TRUE - otherwise
        -:  392: */
        -:  393:static ecma_value_t
    #####:  394:ecma_typedarray_set_uint32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  395:                                    ecma_value_t value) /**< the number value to set */
        -:  396:{
    #####:  397:  ecma_number_t resut_num;
    #####:  398:  ecma_value_t to_num = ecma_op_to_numeric (value, &resut_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  399:
    #####:  400:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  401:  {
    #####:  402:    return to_num;
        -:  403:  }
        -:  404:
    #####:  405:  uint32_t num = (uint32_t) ecma_typedarray_setter_number_to_uint32 (resut_num);
    #####:  406:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint32_t);
    #####:  407:  return ECMA_VALUE_TRUE;
        -:  408:} /* ecma_typedarray_set_uint32_element */
        -:  409:
        -:  410:/**
        -:  411: * Write a float value into the given arraybuffer
        -:  412: *
        -:  413: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  414: *         ECMA_VALUE_TRUE - otherwise
        -:  415: */
        -:  416:static ecma_value_t
    #####:  417:ecma_typedarray_set_float_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  418:                                   ecma_value_t value) /**< the number value to set */
        -:  419:{
    #####:  420:  ecma_number_t result_num;
    #####:  421:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  422:
    #####:  423:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  424:  {
    #####:  425:    return to_num;
        -:  426:  }
        -:  427:
    #####:  428:  float num = (float) result_num;
    #####:  429:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, float);
    #####:  430:  return ECMA_VALUE_TRUE;
        -:  431:} /* ecma_typedarray_set_float_element */
        -:  432:
        -:  433:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  434:/**
        -:  435: * Write a double value into the given arraybuffer
        -:  436: *
        -:  437: * @return ECMA_VALUE_ERROR - if the ToNumber operation fails
        -:  438: *         ECMA_VALUE_TRUE - otherwise
        -:  439: */
        -:  440:static ecma_value_t
    #####:  441:ecma_typedarray_set_double_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  442:                                    ecma_value_t value) /**< the number value to set */
        -:  443:{
    #####:  444:  ecma_number_t result_num;
    #####:  445:  ecma_value_t to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  446:
    #####:  447:  if (ECMA_IS_VALUE_ERROR (to_num))
        -:  448:  {
    #####:  449:    return to_num;
        -:  450:  }
        -:  451:
    #####:  452:  double num = (double) result_num;
    #####:  453:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, double);
    #####:  454:  return ECMA_VALUE_TRUE;
        -:  455:} /* ecma_typedarray_set_double_element */
        -:  456:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  457:
        -:  458:#if JERRY_BUILTIN_BIGINT
        -:  459:/**
        -:  460: * Write a bigint64/biguint64 value into the given arraybuffer
        -:  461: *
        -:  462: * @return ECMA_VALUE_ERROR - if the ToBigInt operation fails
        -:  463: *         ECMA_VALUE_TRUE - otherwise
        -:  464: */
        -:  465:static ecma_value_t
    #####:  466:ecma_typedarray_set_bigint_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  467:                                    ecma_value_t value) /**< the bigint value to set */
        -:  468:{
    #####:  469:  ecma_value_t bigint = ecma_bigint_to_bigint (value, false);
        -:  470:
    #####:  471:  if (ECMA_IS_VALUE_ERROR (bigint))
        -:  472:  {
    #####:  473:    return bigint;
        -:  474:  }
        -:  475:
    #####:  476:  uint64_t num;
    #####:  477:  bool sign;
    #####:  478:  ecma_bigint_get_digits_and_sign (bigint, &num, 1, &sign);
        -:  479:
    #####:  480:  if (sign)
        -:  481:  {
    #####:  482:    num = (uint64_t) (-(int64_t) num);
        -:  483:  }
        -:  484:
    #####:  485:  ECMA_TYPEDARRAY_SET_ELEMENT (dst_p, num, uint64_t);
        -:  486:
    #####:  487:  ecma_free_value (bigint);
        -:  488:
    #####:  489:  return ECMA_VALUE_TRUE;
        -:  490:} /* ecma_typedarray_set_bigint_element */
        -:  491:#endif /* JERRY_BUILTIN_BIGINT */
        -:  492:
        -:  493:/**
        -:  494: * Builtin id of the first %TypedArray% builtin routine intrinsic object
        -:  495: */
        -:  496:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_INT8ARRAY
        -:  497:
        -:  498:#if JERRY_BUILTIN_BIGINT
        -:  499:/**
        -:  500: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  501: */
        -:  502:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_BIGUINT64ARRAY
        -:  503:#elif !JERRY_BUILTIN_BIGINT && JERRY_NUMBER_TYPE_FLOAT64
        -:  504:/**
        -:  505: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  506: */
        -:  507:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT64ARRAY
        -:  508:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  509:/**
        -:  510: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  511: */
        -:  512:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT32ARRAY
        -:  513:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  514:
        -:  515:/**
        -:  516: * Builtin id of the first %TypedArray% builtin prototype intrinsic object
        -:  517: */
        -:  518:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE
        -:  519:
        -:  520:/**
        -:  521: * List of typedarray getters based on their builtin id
        -:  522: */
        -:  523:static const ecma_typedarray_getter_fn_t ecma_typedarray_getters[] =
        -:  524:{
        -:  525:  ecma_typedarray_get_int8_element,   /**< Int8Array */
        -:  526:  ecma_typedarray_get_uint8_element,  /**< Uint8Array */
        -:  527:  ecma_typedarray_get_uint8_element,  /**< Uint8ClampedArray */
        -:  528:  ecma_typedarray_get_int16_element,  /**< Int16Array */
        -:  529:  ecma_typedarray_get_uint16_element, /**< Int32Array */
        -:  530:  ecma_typedarray_get_int32_element,  /**< Uint32Array */
        -:  531:  ecma_typedarray_get_uint32_element, /**< Uint32Array */
        -:  532:  ecma_typedarray_get_float_element,  /**< Float32Array */
        -:  533:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  534:  ecma_typedarray_get_double_element, /**< Float64Array */
        -:  535:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  536:#if JERRY_BUILTIN_BIGINT
        -:  537:  ecma_typedarray_get_bigint64_element,  /**< BigInt64Array*/
        -:  538:  ecma_typedarray_get_biguint64_element, /**< BigUint64Array */
        -:  539:#endif /* JERRY_BUILTIN_BIGINT */
        -:  540:};
        -:  541:
        -:  542:/**
        -:  543: * List of typedarray setters based on their builtin id
        -:  544: */
        -:  545:static const ecma_typedarray_setter_fn_t ecma_typedarray_setters[] =
        -:  546:{
        -:  547:  ecma_typedarray_set_int8_element,          /**< Int8Array */
        -:  548:  ecma_typedarray_set_uint8_element,         /**< Uint8Array */
        -:  549:  ecma_typedarray_set_uint8_clamped_element, /**< Uint8ClampedArray */
        -:  550:  ecma_typedarray_set_int16_element,         /**< Int16Array */
        -:  551:  ecma_typedarray_set_uint16_element,        /**< Int32Array */
        -:  552:  ecma_typedarray_set_int32_element,         /**< Uint32Array */
        -:  553:  ecma_typedarray_set_uint32_element,        /**< Uint32Array */
        -:  554:  ecma_typedarray_set_float_element,         /**< Float32Array */
        -:  555:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  556:  ecma_typedarray_set_double_element,        /**< Float64Array */
        -:  557:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  558:#if JERRY_BUILTIN_BIGINT
        -:  559:  ecma_typedarray_set_bigint_element,      /**< BigInt64Array */
        -:  560:  ecma_typedarray_set_bigint_element,     /**< BigUInt64Array */
        -:  561:#endif /* JERRY_BUILTIN_BIGINT */
        -:  562:};
        -:  563:
        -:  564:/**
        -:  565: * List of typedarray element shift sizes based on their builtin id
        -:  566: */
        -:  567:static const uint8_t ecma_typedarray_element_shift_sizes[] =
        -:  568:{
        -:  569:  0, /**< Int8Array */
        -:  570:  0, /**< Uint8Array */
        -:  571:  0, /**< Uint8ClampedArray */
        -:  572:  1, /**< Int16Array */
        -:  573:  1, /**< Uint16Array */
        -:  574:  2, /**< Int32Array */
        -:  575:  2, /**< Uint32Array */
        -:  576:  2, /**< Float32Array */
        -:  577:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  578:  3, /**< Float64Array */
        -:  579:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  580:#if JERRY_BUILTIN_BIGINT
        -:  581:  3, /**< BigInt64Array */
        -:  582:  3, /**< BigUInt64Array */
        -:  583:#endif /* JERRY_BUILTIN_BIGINT */
        -:  584:};
        -:  585:
        -:  586:/**
        -:  587: * List of typedarray class magic strings based on their builtin id
        -:  588: */
        -:  589:static const uint16_t ecma_typedarray_magic_string_list[] =
        -:  590:{
        -:  591:  (uint16_t) LIT_MAGIC_STRING_INT8_ARRAY_UL,          /**< Int8Array */
        -:  592:  (uint16_t) LIT_MAGIC_STRING_UINT8_ARRAY_UL,         /**< Uint8Array */
        -:  593:  (uint16_t) LIT_MAGIC_STRING_UINT8_CLAMPED_ARRAY_UL, /**< Uint8ClampedArray */
        -:  594:  (uint16_t) LIT_MAGIC_STRING_INT16_ARRAY_UL,         /**< Int16Array */
        -:  595:  (uint16_t) LIT_MAGIC_STRING_UINT16_ARRAY_UL,        /**< Uint16Array */
        -:  596:  (uint16_t) LIT_MAGIC_STRING_INT32_ARRAY_UL,         /**< Int32Array */
        -:  597:  (uint16_t) LIT_MAGIC_STRING_UINT32_ARRAY_UL,        /**< Uint32Array */
        -:  598:  (uint16_t) LIT_MAGIC_STRING_FLOAT32_ARRAY_UL,       /**< Float32Array */
        -:  599:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  600:  (uint16_t) LIT_MAGIC_STRING_FLOAT64_ARRAY_UL,       /**< Float64Array */
        -:  601:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  602:#if JERRY_BUILTIN_BIGINT
        -:  603:  (uint16_t) LIT_MAGIC_STRING_BIGINT64_ARRAY_UL,      /**< BigInt64Array */
        -:  604:  (uint16_t) LIT_MAGIC_STRING_BIGUINT64_ARRAY_UL,     /**< BigUInt64Array */
        -:  605:#endif /* JERRY_BUILTIN_BIGINT */
        -:  606:};
        -:  607:
        -:  608:/**
        -:  609: * Get the magic string id of a typedarray
        -:  610: *
        -:  611: * @return magic string
        -:  612: */
        -:  613:extern inline lit_magic_string_id_t JERRY_ATTR_ALWAYS_INLINE
    #####:  614:ecma_get_typedarray_magic_string_id (ecma_typedarray_type_t typedarray_id)
        -:  615:{
    #####:  616:  return (lit_magic_string_id_t) ecma_typedarray_magic_string_list[typedarray_id];
        -:  617:} /* ecma_get_typedarray_magic_string_id */
        -:  618:
        -:  619:/**
        -:  620: * Get typedarray's getter function callback
        -:  621: *
        -:  622: * @return ecma_typedarray_getter_fn_t: the getter function for the given builtin TypedArray id
        -:  623: */
        -:  624:extern inline ecma_typedarray_getter_fn_t JERRY_ATTR_ALWAYS_INLINE
        1:  625:ecma_get_typedarray_getter_fn (ecma_typedarray_type_t typedarray_id) /**< typedarray id */
        -:  626:{
        1:  627:  return ecma_typedarray_getters[typedarray_id];
        -:  628:} /* ecma_get_typedarray_getter_fn */
        -:  629:
        -:  630:/**
        -:  631: * Get element from a TypedArray
        -:  632: *
        -:  633: * @return the value of the element
        -:  634: */
        -:  635:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  636:ecma_get_typedarray_element (ecma_typedarray_info_t *info_p, /**< typedarray info */
        -:  637:                             ecma_number_t num) /**< element index */
        -:  638:{
    #####:  639:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -:  640:
    #####:  641:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -:  642:  {
    #####:  643:    return ECMA_VALUE_ERROR;
        -:  644:  }
        -:  645:
    #####:  646:  if (ecma_number_is_negative (num)
    #####:  647:      || num >= info_p->length
    #####:  648:      || ((ecma_number_t) (uint32_t) num) != num)
        -:  649:  {
    #####:  650:    return ECMA_VALUE_UNDEFINED;
        -:  651:  }
        -:  652:
    #####:  653:  return ecma_typedarray_getters[info_p->id](buffer_p + ((uint32_t) num << info_p->shift));
        -:  654:} /* ecma_get_typedarray_element */
        -:  655:
        -:  656:/**
        -:  657: * Get typedarray's setter function callback
        -:  658: *
        -:  659: * @return ecma_typedarray_setter_fn_t: the setter function for the given builtin TypedArray id
        -:  660: */
        -:  661:extern inline ecma_typedarray_setter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  662:ecma_get_typedarray_setter_fn (ecma_typedarray_type_t typedarray_id) /**< typedarray id */
        -:  663:{
    #####:  664:  return ecma_typedarray_setters[typedarray_id];
        -:  665:} /* ecma_get_typedarray_setter_fn */
        -:  666:
        -:  667:/**
        -:  668: * set typedarray's element value
        -:  669: */
        -:  670:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  671:ecma_set_typedarray_element (ecma_typedarray_info_t *info_p, /**< typedarray info */
        -:  672:                             ecma_value_t value, /**< value to be set */
        -:  673:                             ecma_number_t num) /**< element index */
        -:  674:{
        -:  675:  ecma_value_t to_num;
    #####:  676:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -:  677:  {
    #####:  678:    to_num = ecma_bigint_to_bigint (value, false);
        -:  679:
    #####:  680:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  681:    {
    #####:  682:      return to_num;
        -:  683:    }
        -:  684:  }
        -:  685:  else
        -:  686:  {
    #####:  687:    ecma_number_t result_num;
    #####:  688:    to_num = ecma_op_to_numeric (value, &result_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  689:
    #####:  690:    if (ECMA_IS_VALUE_ERROR (to_num))
        -:  691:    {
    #####:  692:      return to_num;
        -:  693:    }
        -:  694:  }
        -:  695:
    #####:  696:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -:  697:
    #####:  698:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -:  699:  {
    #####:  700:    ecma_free_value (to_num);
    #####:  701:    return ECMA_VALUE_ERROR;
        -:  702:  }
        -:  703:
    #####:  704:  if (ecma_number_is_negative (num)
    #####:  705:      || num >= info_p->length
    #####:  706:      || ((ecma_number_t) (uint32_t) num) != num)
        -:  707:  {
    #####:  708:    ecma_free_value (to_num);
    #####:  709:    return ECMA_VALUE_FALSE;
        -:  710:  }
        -:  711:
    #####:  712:  ecma_free_value (to_num);
        -:  713:
    #####:  714:  return ecma_typedarray_setters[info_p->id](buffer_p + ((uint32_t) num << info_p->shift), value);
        -:  715:} /* ecma_set_typedarray_element */
        -:  716:
        -:  717:/**
        -:  718: * Get the element shift size of a TypedArray type.
        -:  719: *
        -:  720: * @return uint8_t
        -:  721: */
        -:  722:extern inline uint8_t JERRY_ATTR_ALWAYS_INLINE
        1:  723:ecma_typedarray_helper_get_shift_size (ecma_typedarray_type_t typedarray_id)
        -:  724:{
        3:  725:  return ecma_typedarray_element_shift_sizes[typedarray_id];
        -:  726:} /* ecma_typedarray_helper_get_shift_size */
        -:  727:
        -:  728:/**
        -:  729: * Check if the builtin is a TypedArray type.
        -:  730: *
        -:  731: * @return bool: - true if based on the given id it is a TypedArray
        -:  732: *               - false if based on the given id it is not a TypedArray
        -:  733: */
        -:  734:bool
    #####:  735:ecma_typedarray_helper_is_typedarray (ecma_builtin_id_t builtin_id) /**< the builtin id of a type **/
        -:  736:{
        -:  737:  return ((builtin_id >= ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID)
    #####:  738:          && (builtin_id <= ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID));
        -:  739:} /* ecma_typedarray_helper_is_typedarray */
        -:  740:
        -:  741:/**
        -:  742: * Get the prototype ID of a TypedArray type.
        -:  743: *
        -:  744: * @return ecma_builtin_id_t
        -:  745: */
        -:  746:ecma_builtin_id_t
        1:  747:ecma_typedarray_helper_get_prototype_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  748:{
        1:  749:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID + typedarray_id);
        -:  750:} /* ecma_typedarray_helper_get_prototype_id */
        -:  751:
        -:  752:/**
        -:  753: * Get the constructor ID of a TypedArray type.
        -:  754: *
        -:  755: * @return ecma_builtin_id_t
        -:  756: */
        -:  757:ecma_builtin_id_t
    #####:  758:ecma_typedarray_helper_get_constructor_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  759:{
    #####:  760:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID + typedarray_id);
        -:  761:} /* ecma_typedarray_helper_get_constructor_id */
        -:  762:
        -:  763:/**
        -:  764: * Get the built-in TypedArray type of the given object.
        -:  765: *
        -:  766: * @return ecma_typedarray_type_t
        -:  767: */
        -:  768:ecma_typedarray_type_t
        3:  769:ecma_get_typedarray_id (ecma_object_t *obj_p) /**< typedarray object **/
        -:  770:{
        3:  771:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -:  772:
        3:  773:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  774:
        3:  775:  return (ecma_typedarray_type_t) ext_object_p->u.cls.u1.typedarray_type;
        -:  776:} /* ecma_get_typedarray_id */
        -:  777:
        -:  778:/**
        -:  779: * Get the built-in TypedArray type of the given object.
        -:  780: *
        -:  781: * @return ecma_typedarray_type_t
        -:  782: */
        -:  783:ecma_typedarray_type_t
    #####:  784:ecma_typedarray_helper_builtin_to_typedarray_id (ecma_builtin_id_t builtin_id)
        -:  785:{
    #####:  786:  JERRY_ASSERT (ecma_typedarray_helper_is_typedarray (builtin_id));
        -:  787:
    #####:  788:  return (ecma_typedarray_type_t) (builtin_id - ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID);
        -:  789:} /* ecma_typedarray_helper_builtin_to_typedarray_id */
        -:  790:
        -:  791:/**
        -:  792: * Create a TypedArray object by given array_length
        -:  793: *
        -:  794: * See also: ES2015 22.2.1.2.1
        -:  795: *
        -:  796: * @return ecma value of the new typedarray object
        -:  797: *         Returned value must be freed with ecma_free_value
        -:  798: */
        -:  799:ecma_value_t
        1:  800:ecma_typedarray_create_object_with_length (uint32_t array_length, /**< length of the typedarray */
        -:  801:                                           ecma_object_t *src_buffer_p, /**< source buffer */
        -:  802:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  803:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  804:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  805:{
        1:  806:  uint32_t byte_length = UINT32_MAX;
        -:  807:
        1:  808:  if (array_length <= (UINT32_MAX >> element_size_shift))
        -:  809:  {
        1:  810:    byte_length = array_length << element_size_shift;
        -:  811:  }
        -:  812:
        1:  813:  if (byte_length > UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1)
        -:  814:  {
        -:  815:#if JERRY_ERROR_MESSAGES
    #####:  816:    ecma_value_t array_length_value = ecma_make_number_value (array_length);
        -:  817:
    #####:  818:    ecma_value_t result = ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE,
        -:  819:                                                                 "Invalid typed array length: %",
        -:  820:                                                                 array_length_value);
    #####:  821:    ecma_free_value (array_length_value);
    #####:  822:    return result;
        -:  823:#else /* !JERRY_ERROR_MESSAGES */
        -:  824:    return ecma_raise_range_error (NULL);
        -:  825:#endif /* JERRY_ERROR_MESSAGES */
        -:  826:  }
        -:  827:
        1:  828:  ecma_object_t *new_arraybuffer_p = NULL;
        1:  829:  if (src_buffer_p == NULL)
        -:  830:  {
        1:  831:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  832:  }
        -:  833:  else
        -:  834:  {
    #####:  835:    ecma_value_t ctor_proto = ecma_op_species_constructor (src_buffer_p, ECMA_BUILTIN_ID_ARRAYBUFFER);
        -:  836:
    #####:  837:    if (ECMA_IS_VALUE_ERROR (ctor_proto))
        -:  838:    {
    #####:  839:      return ctor_proto;
        -:  840:    }
        -:  841:
    #####:  842:    ecma_object_t *ctor_proto_p = ecma_get_object_from_value (ctor_proto);
        -:  843:
    #####:  844:    ecma_object_t *prototype_p = ecma_op_get_prototype_from_constructor (ctor_proto_p,
        -:  845:                                                                         ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
        -:  846:
    #####:  847:    ecma_deref_object (ctor_proto_p);
        -:  848:
    #####:  849:    if (JERRY_UNLIKELY (prototype_p == NULL))
        -:  850:    {
    #####:  851:      return ECMA_VALUE_ERROR;
        -:  852:    }
        -:  853:
    #####:  854:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  855:
    #####:  856:    ECMA_SET_NON_NULL_POINTER (new_arraybuffer_p->u2.prototype_cp, prototype_p);
        -:  857:
    #####:  858:    ecma_deref_object (prototype_p);
        -:  859:
    #####:  860:    if (ecma_arraybuffer_is_detached (src_buffer_p))
        -:  861:    {
    #####:  862:      ecma_deref_object (new_arraybuffer_p);
    #####:  863:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  864:    }
        -:  865:  }
        -:  866:
        1:  867:  ecma_object_t *object_p = ecma_create_object (proto_p,
        -:  868:                                                sizeof (ecma_extended_object_t),
        -:  869:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  870:
        1:  871:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  872:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
        1:  873:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
        1:  874:  ext_object_p->u.cls.u2.typedarray_flags = 0;
        1:  875:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (new_arraybuffer_p);
        -:  876:
        1:  877:  ecma_deref_object (new_arraybuffer_p);
        -:  878:
        1:  879:  return ecma_make_object_value (object_p);
        -:  880:} /* ecma_typedarray_create_object_with_length */
        -:  881:
        -:  882:/**
        -:  883: * Create a TypedArray object by given another TypedArray object
        -:  884: *
        -:  885: * See also: ES2015 22.2.1.3
        -:  886: *
        -:  887: * @return ecma value of the new typedarray object
        -:  888: *         Returned value must be freed with ecma_free_value
        -:  889: */
        -:  890:static ecma_value_t
    #####:  891:ecma_typedarray_create_object_with_typedarray (ecma_object_t *typedarray_p, /**< a typedarray object */
        -:  892:                                               ecma_object_t *proto_p, /**< prototype object */
        -:  893:                                               uint8_t element_size_shift, /**< the size shift of the element length */
        -:  894:                                               ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  895:{
    #####:  896:  uint32_t array_length = ecma_typedarray_get_length (typedarray_p);
    #####:  897:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -:  898:
    #####:  899:  if (ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (src_arraybuffer_p))
        -:  900:  {
    #####:  901:    return ECMA_VALUE_ERROR;
        -:  902:  }
        -:  903:
    #####:  904:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (array_length,
        -:  905:                                                                           src_arraybuffer_p,
        -:  906:                                                                           proto_p,
        -:  907:                                                                           element_size_shift,
        -:  908:                                                                           typedarray_id);
        -:  909:
    #####:  910:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  911:  {
    #####:  912:    return new_typedarray;
        -:  913:  }
        -:  914:
    #####:  915:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####:  916:  ecma_object_t *dst_arraybuffer_p = ecma_typedarray_get_arraybuffer (new_typedarray_p);
        -:  917:
    #####:  918:  if (ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (dst_arraybuffer_p))
        -:  919:  {
    #####:  920:    return ECMA_VALUE_ERROR;
        -:  921:  }
        -:  922:
    #####:  923:  lit_utf8_byte_t *src_buf_p = ecma_arraybuffer_get_buffer (src_arraybuffer_p);
    #####:  924:  lit_utf8_byte_t *dst_buf_p = ecma_arraybuffer_get_buffer (dst_arraybuffer_p);
        -:  925:
    #####:  926:  src_buf_p += ecma_typedarray_get_offset (typedarray_p);
        -:  927:
    #####:  928:  ecma_typedarray_type_t src_id = ecma_get_typedarray_id (typedarray_p);
        -:  929:
    #####:  930:  if (src_id == typedarray_id)
        -:  931:  {
    #####:  932:    memcpy (dst_buf_p, src_buf_p, array_length << element_size_shift);
        -:  933:  }
        -:  934:  else
        -:  935:  {
        -:  936:#if JERRY_BUILTIN_BIGINT
    #####:  937:    if ((ECMA_TYPEDARRAY_IS_BIGINT_TYPE (src_id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (typedarray_id)) == 1)
        -:  938:    {
    #####:  939:      ecma_deref_object (new_typedarray_p);
    #####:  940:      return ecma_raise_type_error (ECMA_ERR_MSG ("Incompatible TypedArray types"));
        -:  941:    }
        -:  942:#endif /* JERRY_BUILTIN_BIGINT */
        -:  943:
    #####:  944:    uint32_t src_element_size = 1u << ecma_typedarray_get_element_size_shift (typedarray_p);
    #####:  945:    uint32_t dst_element_size = 1u << element_size_shift;
    #####:  946:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_id);
    #####:  947:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (typedarray_id);
        -:  948:
    #####:  949:    for (uint32_t i = 0; i < array_length; i++)
        -:  950:    {
        -:  951:      /* Convert values from source to destination format. */
    #####:  952:      ecma_value_t tmp = src_typedarray_getter_cb (src_buf_p);
    #####:  953:      ecma_value_t set_element = target_typedarray_setter_cb (dst_buf_p, tmp);
        -:  954:
    #####:  955:      ecma_free_value (tmp);
        -:  956:
    #####:  957:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  958:      {
    #####:  959:        ecma_deref_object (new_typedarray_p);
    #####:  960:        return set_element;
        -:  961:      }
        -:  962:
    #####:  963:      src_buf_p += src_element_size;
    #####:  964:      dst_buf_p += dst_element_size;
        -:  965:    }
        -:  966:  }
        -:  967:
    #####:  968:  return new_typedarray;
        -:  969:} /* ecma_typedarray_create_object_with_typedarray */
        -:  970:
        -:  971:/**
        -:  972: * Helper method for ecma_op_typedarray_from
        -:  973: *
        -:  974: * @return ECMA_VALUE_TRUE - if setting the given value to the new typedarray was successful
        -:  975: *         ECMA_VALUE_ERROR - otherwise
        -:  976: */
        -:  977:static ecma_value_t
    #####:  978:ecma_op_typedarray_from_helper (ecma_value_t this_val, /**< this_arg for the above from function */
        -:  979:                                ecma_value_t current_value, /**< given value to set */
        -:  980:                                uint32_t index, /**< currrent index */
        -:  981:                                ecma_object_t *func_object_p, /**< map function object */
        -:  982:                                uint8_t *buffer_p, /**< target buffer */
        -:  983:                                ecma_typedarray_setter_fn_t setter_cb) /**< setter callback function */
        -:  984:{
    #####:  985:  ecma_value_t mapped_value = current_value;
        -:  986:
    #####:  987:  if (func_object_p != NULL)
        -:  988:  {
        -:  989:    /* 17.d 17.f */
    #####:  990:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  991:    ecma_value_t call_args[] = { current_value, current_index };
        -:  992:
    #####:  993:    ecma_value_t cb_value = ecma_op_function_call (func_object_p, this_val, call_args, 2);
        -:  994:
    #####:  995:    ecma_free_value (current_value);
    #####:  996:    ecma_free_value (current_index);
        -:  997:
    #####:  998:    if (ECMA_IS_VALUE_ERROR (cb_value))
        -:  999:    {
    #####: 1000:      return cb_value;
        -: 1001:    }
        -: 1002:
    #####: 1003:    mapped_value = cb_value;
        -: 1004:  }
        -: 1005:
    #####: 1006:  ecma_value_t set_element = setter_cb (buffer_p, mapped_value);
    #####: 1007:  ecma_free_value (mapped_value);
        -: 1008:
    #####: 1009:  if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1010:  {
    #####: 1011:    return set_element;
        -: 1012:  }
        -: 1013:
    #####: 1014:  return ECMA_VALUE_TRUE;
        -: 1015:} /* ecma_op_typedarray_from_helper */
        -: 1016:
        -: 1017:/**
        -: 1018: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1019: *
        -: 1020: * See also: ES11 22.2.4.4
        -: 1021: *
        -: 1022: * @return ecma value of the new typedarray object
        -: 1023: *         Returned value must be freed with ecma_free_value
        -: 1024: */
        -: 1025:ecma_value_t
    #####: 1026:ecma_typedarray_create_object_with_object (ecma_value_t items_val, /**< the source array-like object */
        -: 1027:                                           ecma_object_t *proto_p, /**< prototype object */
        -: 1028:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1029:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1030:{
        -: 1031:  /* 5 */
    #####: 1032:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (items_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1033:
    #####: 1034:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1035:  {
    #####: 1036:    return using_iterator;
        -: 1037:  }
        -: 1038:
        -: 1039:  /* 6 */
    #####: 1040:  if (!ecma_is_value_undefined (using_iterator))
        -: 1041:  {
        -: 1042:    /* 6.a */
    #####: 1043:    ecma_value_t next_method;
    #####: 1044:    ecma_value_t iterator = ecma_op_get_iterator (items_val, using_iterator, &next_method);
    #####: 1045:    ecma_free_value (using_iterator);
        -: 1046:
    #####: 1047:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1048:    {
    #####: 1049:      return iterator;
        -: 1050:    }
        -: 1051:
    #####: 1052:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1053:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1054:
        -: 1055:    while (true)
    #####: 1056:    {
    #####: 1057:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1058:
    #####: 1059:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1060:      {
    #####: 1061:        ret_value = next;
    #####: 1062:        break;
        -: 1063:      }
        -: 1064:
    #####: 1065:      if (next == ECMA_VALUE_FALSE)
        -: 1066:      {
    #####: 1067:        break;
        -: 1068:      }
        -: 1069:
    #####: 1070:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1071:      ecma_free_value (next);
        -: 1072:
    #####: 1073:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1074:      {
    #####: 1075:        ret_value = next_value;
    #####: 1076:        break;
        -: 1077:      }
        -: 1078:
    #####: 1079:      ecma_collection_push_back (values_p, next_value);
        -: 1080:    }
        -: 1081:
    #####: 1082:    ecma_free_value (iterator);
    #####: 1083:    ecma_free_value (next_method);
        -: 1084:
    #####: 1085:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1086:    {
    #####: 1087:      ecma_collection_free (values_p);
    #####: 1088:      return ret_value;
        -: 1089:    }
        -: 1090:
        -: 1091:    /* 8.c */
    #####: 1092:    ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (values_p->item_count,
        -: 1093:                                                                             NULL,
        -: 1094:                                                                             proto_p,
        -: 1095:                                                                             element_size_shift,
        -: 1096:                                                                             typedarray_id);
        -: 1097:
    #####: 1098:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1099:    {
    #####: 1100:      ecma_collection_free (values_p);
    #####: 1101:      return new_typedarray;
        -: 1102:    }
        -: 1103:
    #####: 1104:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1105:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1106:    ecma_value_t *next_value_p = values_p->buffer_p;
    #####: 1107:    uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1108:
    #####: 1109:    ret_value = ECMA_VALUE_ERROR;
        -: 1110:
    #####: 1111:    if (buffer_p != NULL)
        -: 1112:    {
    #####: 1113:      ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1114:      uint8_t *limit_p = buffer_p + (values_p->item_count << info.shift);
        -: 1115:
    #####: 1116:      ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1117:
        -: 1118:      /* 8.e */
    #####: 1119:      while (buffer_p < limit_p)
        -: 1120:      {
    #####: 1121:        ecma_value_t value = *next_value_p++;
    #####: 1122:        ecma_value_t set_value = setter_cb (buffer_p, value);
    #####: 1123:        ecma_free_value (value);
        -: 1124:
    #####: 1125:        if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1126:        {
    #####: 1127:          ret_value = set_value;
    #####: 1128:          break;
        -: 1129:        }
        -: 1130:
    #####: 1131:        buffer_p += info.element_size;
        -: 1132:      }
        -: 1133:    }
        -: 1134:
    #####: 1135:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1136:    {
    #####: 1137:      ecma_value_t *last_value_p = values_p->buffer_p + values_p->item_count;
        -: 1138:
    #####: 1139:      while (next_value_p < last_value_p)
        -: 1140:      {
    #####: 1141:        ecma_free_value (*next_value_p++);
        -: 1142:      }
        -: 1143:
    #####: 1144:      ecma_deref_object (new_typedarray_p);
        -: 1145:    }
        -: 1146:
    #####: 1147:    ecma_collection_destroy (values_p);
    #####: 1148:    return ret_value;
        -: 1149:  }
        -: 1150:
        -: 1151:  /* 8 */
    #####: 1152:  ecma_value_t arraylike_object_val = ecma_op_to_object (items_val);
        -: 1153:
    #####: 1154:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1155:  {
    #####: 1156:    return arraylike_object_val;
        -: 1157:  }
        -: 1158:
    #####: 1159:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1160:
        -: 1161:  /* 9 */
    #####: 1162:  ecma_length_t length_index;
    #####: 1163:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1164:
    #####: 1165:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1166:  {
    #####: 1167:    ecma_deref_object (arraylike_object_p);
    #####: 1168:    return len_value;
        -: 1169:  }
        -: 1170:
    #####: 1171:  if (length_index >= UINT32_MAX)
        -: 1172:  {
    #####: 1173:    ecma_deref_object (arraylike_object_p);
    #####: 1174:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid TypedArray length"));
        -: 1175:  }
        -: 1176:
    #####: 1177:  uint32_t len = (uint32_t) length_index;
        -: 1178:
        -: 1179:  /* 10 */
    #####: 1180:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (len,
        -: 1181:                                                                           NULL,
        -: 1182:                                                                           proto_p,
        -: 1183:                                                                           element_size_shift,
        -: 1184:                                                                           typedarray_id);
        -: 1185:
    #####: 1186:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1187:  {
    #####: 1188:    ecma_deref_object (arraylike_object_p);
    #####: 1189:    return new_typedarray;
        -: 1190:  }
        -: 1191:
    #####: 1192:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1193:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1194:  uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
    #####: 1195:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -: 1196:
    #####: 1197:  if (buffer_p != NULL)
        -: 1198:  {
    #####: 1199:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1200:
    #####: 1201:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1202:
        -: 1203:    /* 12 */
    #####: 1204:    for (uint32_t index = 0; index < len; index++)
        -: 1205:    {
    #####: 1206:      ecma_value_t value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1207:
    #####: 1208:      if (ECMA_IS_VALUE_ERROR (value))
        -: 1209:      {
    #####: 1210:        ret_value = value;
    #####: 1211:        break;
        -: 1212:      }
        -: 1213:
    #####: 1214:      if (!ecma_is_value_found (value))
        -: 1215:      {
    #####: 1216:        value = ECMA_VALUE_UNDEFINED;
        -: 1217:      }
        -: 1218:
    #####: 1219:      ecma_value_t set_value = setter_cb (buffer_p, value);
    #####: 1220:      ecma_free_value (value);
        -: 1221:
    #####: 1222:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1223:      {
    #####: 1224:        ret_value = set_value;
    #####: 1225:        break;
        -: 1226:      }
        -: 1227:
    #####: 1228:      buffer_p += info.element_size;
        -: 1229:    }
        -: 1230:  }
        -: 1231:
    #####: 1232:  ecma_deref_object (arraylike_object_p);
        -: 1233:
    #####: 1234:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1235:  {
    #####: 1236:    ecma_deref_object (new_typedarray_p);
        -: 1237:  }
        -: 1238:
    #####: 1239:  return ret_value;
        -: 1240:} /* ecma_typedarray_create_object_with_object */
        -: 1241:
        -: 1242:/**
        -: 1243: * Create a TypedArray object by transforming from an array-like object or iterable object
        -: 1244: *
        -: 1245: * See also: ES11 22.2.2.1
        -: 1246: *
        -: 1247: * @return ecma value of the new typedarray object
        -: 1248: *         Returned value must be freed with ecma_free_value
        -: 1249: */
        -: 1250:ecma_value_t
    #####: 1251:ecma_op_typedarray_from (ecma_value_t this_val, /**< this value */
        -: 1252:                         ecma_value_t source_val, /**< source value */
        -: 1253:                         ecma_value_t map_fn_val, /**< mapped function value */
        -: 1254:                         ecma_value_t this_arg) /**< this argument */
        -: 1255:{
        -: 1256:  JERRY_UNUSED (this_arg);
        -: 1257:  /* 3 */
    #####: 1258:  JERRY_ASSERT (ecma_op_is_callable (map_fn_val) || ecma_is_value_undefined (map_fn_val));
        -: 1259:
        -: 1260:  /* 4 */
    #####: 1261:  ecma_object_t *func_object_p = NULL;
        -: 1262:
    #####: 1263:  if (!ecma_is_value_undefined (map_fn_val))
        -: 1264:  {
    #####: 1265:    func_object_p = ecma_get_object_from_value (map_fn_val);
        -: 1266:  }
        -: 1267:
        -: 1268:  /* 5 */
    #####: 1269:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (source_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -: 1270:
    #####: 1271:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -: 1272:  {
    #####: 1273:    return using_iterator;
        -: 1274:  }
        -: 1275:
        -: 1276:  /* 6 */
    #####: 1277:  if (!ecma_is_value_undefined (using_iterator))
        -: 1278:  {
        -: 1279:    /* 6.a */
    #####: 1280:    ecma_value_t next_method;
    #####: 1281:    ecma_value_t iterator = ecma_op_get_iterator (source_val, using_iterator, &next_method);
    #####: 1282:    ecma_free_value (using_iterator);
        -: 1283:
        -: 1284:    /* 6.b */
    #####: 1285:    if (ECMA_IS_VALUE_ERROR (iterator))
        -: 1286:    {
    #####: 1287:      return iterator;
        -: 1288:    }
        -: 1289:
        -: 1290:    /* 6.c */
    #####: 1291:    ecma_collection_t *values_p = ecma_new_collection ();
    #####: 1292:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1293:
        -: 1294:    /* 6.e */
        -: 1295:    while (true)
    #####: 1296:    {
    #####: 1297:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -: 1298:
    #####: 1299:      if (ECMA_IS_VALUE_ERROR (next))
        -: 1300:      {
    #####: 1301:        ret_value = next;
    #####: 1302:        break;
        -: 1303:      }
        -: 1304:
    #####: 1305:      if (next == ECMA_VALUE_FALSE)
        -: 1306:      {
    #####: 1307:        break;
        -: 1308:      }
        -: 1309:
    #####: 1310:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####: 1311:      ecma_free_value (next);
        -: 1312:
    #####: 1313:      if (ECMA_IS_VALUE_ERROR (next_value))
        -: 1314:      {
    #####: 1315:        ret_value = next_value;
    #####: 1316:        break;
        -: 1317:      }
        -: 1318:
    #####: 1319:      ecma_collection_push_back (values_p, next_value);
        -: 1320:    }
        -: 1321:
    #####: 1322:    ecma_free_value (iterator);
    #####: 1323:    ecma_free_value (next_method);
        -: 1324:
    #####: 1325:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1326:    {
    #####: 1327:      ecma_collection_free (values_p);
    #####: 1328:      return ret_value;
        -: 1329:    }
        -: 1330:
        -: 1331:    /* 6.c */
    #####: 1332:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1333:    ecma_value_t len_val = ecma_make_uint32_value (values_p->item_count);
    #####: 1334:    ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1335:    ecma_free_value (len_val);
        -: 1336:
    #####: 1337:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1338:    {
    #####: 1339:      ecma_collection_free (values_p);
    #####: 1340:      return new_typedarray;
        -: 1341:    }
        -: 1342:
    #####: 1343:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1344:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1345:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1346:    ecma_value_t *next_value_p = values_p->buffer_p;
    #####: 1347:    uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
        -: 1348:
    #####: 1349:    ret_value = ECMA_VALUE_ERROR;
        -: 1350:
    #####: 1351:    if (buffer_p != NULL)
        -: 1352:    {
    #####: 1353:      ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1354:
        -: 1355:      /* 6.e */
    #####: 1356:      for (uint32_t index = 0; index < values_p->item_count; index++)
        -: 1357:      {
    #####: 1358:        ecma_value_t set_value = ecma_op_typedarray_from_helper (this_arg,
    #####: 1359:                                                                 *next_value_p++,
        -: 1360:                                                                 index,
        -: 1361:                                                                 func_object_p,
        -: 1362:                                                                 buffer_p,
        -: 1363:                                                                 setter_cb);
        -: 1364:
    #####: 1365:        if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1366:        {
    #####: 1367:          ret_value = set_value;
    #####: 1368:          break;
        -: 1369:        }
        -: 1370:
    #####: 1371:        buffer_p += info.element_size;
        -: 1372:      }
        -: 1373:    }
        -: 1374:
    #####: 1375:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1376:    {
    #####: 1377:      ecma_value_t *last_value_p = values_p->buffer_p + values_p->item_count;
        -: 1378:
    #####: 1379:      while (next_value_p < last_value_p)
        -: 1380:      {
    #####: 1381:        ecma_free_value (*next_value_p++);
        -: 1382:      }
        -: 1383:
    #####: 1384:      ecma_deref_object (new_typedarray_p);
        -: 1385:    }
        -: 1386:
    #####: 1387:    ecma_collection_destroy (values_p);
    #####: 1388:    return ret_value;
        -: 1389:  }
        -: 1390:
        -: 1391:  /* 8 */
    #####: 1392:  ecma_value_t arraylike_object_val = ecma_op_to_object (source_val);
        -: 1393:
    #####: 1394:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -: 1395:  {
    #####: 1396:    return arraylike_object_val;
        -: 1397:  }
        -: 1398:
    #####: 1399:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -: 1400:
        -: 1401:  /* 9 */
    #####: 1402:  ecma_length_t length_index;
    #####: 1403:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &length_index);
        -: 1404:
    #####: 1405:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1406:  {
    #####: 1407:    ecma_deref_object (arraylike_object_p);
    #####: 1408:    return len_value;
        -: 1409:  }
        -: 1410:
    #####: 1411:  if (length_index >= UINT32_MAX)
        -: 1412:  {
    #####: 1413:    ecma_deref_object (arraylike_object_p);
    #####: 1414:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid TypedArray length"));
        -: 1415:  }
        -: 1416:
    #####: 1417:  uint32_t len = (uint32_t) length_index;
        -: 1418:
        -: 1419:  /* 10 */
    #####: 1420:  ecma_object_t *constructor_obj_p = ecma_get_object_from_value (this_val);
    #####: 1421:  ecma_value_t len_val = ecma_make_uint32_value (len);
    #####: 1422:  ecma_value_t new_typedarray = ecma_typedarray_create (constructor_obj_p, &len_val, 1);
    #####: 1423:  ecma_free_value (len_val);
        -: 1424:
    #####: 1425:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1426:  {
    #####: 1427:    ecma_deref_object (arraylike_object_p);
    #####: 1428:    return new_typedarray;
        -: 1429:  }
        -: 1430:
    #####: 1431:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1432:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1433:  uint8_t *buffer_p = ecma_typedarray_get_buffer (&info);
    #####: 1434:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -: 1435:
    #####: 1436:  if (buffer_p != NULL)
        -: 1437:  {
    #####: 1438:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1439:
    #####: 1440:    ret_value = ecma_make_object_value (new_typedarray_p);
        -: 1441:
        -: 1442:    /* 12 */
    #####: 1443:    for (uint32_t index = 0; index < len; index++)
        -: 1444:    {
    #####: 1445:      ecma_value_t value = ecma_op_object_find_by_index (arraylike_object_p, index);
        -: 1446:
    #####: 1447:      if (ECMA_IS_VALUE_ERROR (value))
        -: 1448:      {
    #####: 1449:        ret_value = value;
    #####: 1450:        break;
        -: 1451:      }
        -: 1452:
    #####: 1453:      if (!ecma_is_value_found (value))
        -: 1454:      {
    #####: 1455:        value = ECMA_VALUE_UNDEFINED;
        -: 1456:      }
        -: 1457:
    #####: 1458:      ecma_value_t set_value = ecma_op_typedarray_from_helper (this_arg,
        -: 1459:                                                               value,
        -: 1460:                                                               index,
        -: 1461:                                                               func_object_p,
        -: 1462:                                                               buffer_p,
        -: 1463:                                                               setter_cb);
        -: 1464:
    #####: 1465:      if (ECMA_IS_VALUE_ERROR (set_value))
        -: 1466:      {
    #####: 1467:        ret_value = set_value;
    #####: 1468:        break;
        -: 1469:      }
        -: 1470:
    #####: 1471:      buffer_p += info.element_size;
        -: 1472:    }
        -: 1473:  }
        -: 1474:
    #####: 1475:  ecma_deref_object (arraylike_object_p);
        -: 1476:
    #####: 1477:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1478:  {
    #####: 1479:    ecma_deref_object (new_typedarray_p);
        -: 1480:  }
        -: 1481:
    #####: 1482:  return ret_value;
        -: 1483:} /* ecma_op_typedarray_from */
        -: 1484:
        -: 1485:/**
        -: 1486: * Get the arraybuffer of the typedarray object
        -: 1487: *
        -: 1488: * @return the pointer to the internal arraybuffer
        -: 1489: */
        -: 1490:extern inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE
    #####: 1491:ecma_typedarray_get_arraybuffer (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1492:{
        1: 1493:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1494:
        1: 1495:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1496:
        1: 1497:  return ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
        -: 1498:} /* ecma_typedarray_get_arraybuffer */
        -: 1499:
        -: 1500:/**
        -: 1501: * Get the element size shift in the typedarray object
        -: 1502: *
        -: 1503: * @return the size shift of the element, size is 1 << shift
        -: 1504: */
        -: 1505:uint8_t
        2: 1506:ecma_typedarray_get_element_size_shift (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1507:{
        2: 1508:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1509:
        4: 1510:  return ecma_typedarray_helper_get_shift_size (ecma_get_typedarray_id (typedarray_p));
        -: 1511:} /* ecma_typedarray_get_element_size_shift */
        -: 1512:
        -: 1513:/**
        -: 1514: * Get the array length of the typedarray object
        -: 1515: *
        -: 1516: * @return the array length
        -: 1517: */
        -: 1518:uint32_t
        1: 1519:ecma_typedarray_get_length (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1520:{
        1: 1521:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1522:
        1: 1523:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1524:
        1: 1525:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1526:  {
        1: 1527:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (ext_object_p->u.cls.u3.arraybuffer);
        1: 1528:    ecma_extended_object_t *arraybuffer_object_p = (ecma_extended_object_t *) arraybuffer_p;
        1: 1529:    uint32_t buffer_length = arraybuffer_object_p->u.cls.u3.length;
        1: 1530:    uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        -: 1531:
        1: 1532:    return buffer_length >> shift;
        -: 1533:  }
        -: 1534:
    #####: 1535:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1536:
    #####: 1537:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1538:  {
    #####: 1539:    return 0;
        -: 1540:  }
        -: 1541:
    #####: 1542:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1543:
    #####: 1544:  return info_p->array_length;
        -: 1545:} /* ecma_typedarray_get_length */
        -: 1546:
        -: 1547:/**
        -: 1548: * Get the offset of the internal arraybuffer
        -: 1549: *
        -: 1550: * @return the offset
        -: 1551: */
        -: 1552:uint32_t
        1: 1553:ecma_typedarray_get_offset (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1554:{
        1: 1555:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1556:
        1: 1557:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1558:
        1: 1559:  if (!(ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED))
        -: 1560:  {
        1: 1561:    return 0;
        -: 1562:  }
        -: 1563:
    #####: 1564:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1565:
    #####: 1566:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1567:  {
    #####: 1568:    return 0;
        -: 1569:  }
        -: 1570:
    #####: 1571:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1572:
    #####: 1573:  return info_p->byte_offset;
        -: 1574:} /* ecma_typedarray_get_offset */
        -: 1575:
        -: 1576:/**
        -: 1577: * Utility function: return the pointer of the data buffer referenced by the typedarray info
        -: 1578: *
        -: 1579: * @return pointer to the data buffer if successfull,
        -: 1580: *         NULL otherwise
        -: 1581: */
        -: 1582:uint8_t *
    #####: 1583:ecma_typedarray_get_buffer (ecma_typedarray_info_t *info_p) /**< typedarray info */
        -: 1584:{
    #####: 1585:  ecma_object_t *array_buffer_p = info_p->array_buffer_p;
        -: 1586:
    #####: 1587:  if (ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (array_buffer_p))
        -: 1588:  {
    #####: 1589:    return NULL;
        -: 1590:  }
        -: 1591:
    #####: 1592:  return ecma_arraybuffer_get_buffer (array_buffer_p) + info_p->offset;
        -: 1593:} /* ecma_typedarray_get_buffer */
        -: 1594:
        -: 1595:/**
        -: 1596: * Create a new typedarray object.
        -: 1597: *
        -: 1598: * The struct of the typedarray object
        -: 1599: *   ecma_object_t
        -: 1600: *   extend_part
        -: 1601: *   typedarray_info
        -: 1602: *
        -: 1603: * @return ecma value of the new typedarray object
        -: 1604: *         Returned value must be freed with ecma_free_value
        -: 1605: */
        -: 1606:ecma_value_t
        1: 1607:ecma_op_create_typedarray (const ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 1608:                           uint32_t arguments_list_len, /**< the length of the arguments_list_p */
        -: 1609:                           ecma_object_t *proto_p, /**< prototype object */
        -: 1610:                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1611:                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1612:{
        1: 1613:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -: 1614:
        1: 1615:  if (arguments_list_len == 0)
        -: 1616:  {
        -: 1617:    /* 22.2.1.1 */
    #####: 1618:    return ecma_typedarray_create_object_with_length (0, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1619:  }
        -: 1620:
        1: 1621:  if (!ecma_is_value_object (arguments_list_p[0]))
        -: 1622:  {
        1: 1623:    ecma_number_t num = 0;
        -: 1624:
        1: 1625:    if (!ecma_is_value_undefined (arguments_list_p[0])
        1: 1626:        && ECMA_IS_VALUE_ERROR (ecma_op_to_index (arguments_list_p[0], &num)))
        -: 1627:    {
    #####: 1628:      return ECMA_VALUE_ERROR;
        -: 1629:    }
        -: 1630:
        1: 1631:    JERRY_ASSERT (num >= 0 && num <= ECMA_NUMBER_MAX_SAFE_INTEGER);
        -: 1632:
        1: 1633:    if (num > UINT32_MAX)
        -: 1634:    {
        -: 1635:#if JERRY_ERROR_MESSAGES
    #####: 1636:      return ecma_raise_standard_error_with_format (JERRY_ERROR_RANGE,
        -: 1637:                                                    "Invalid typed array length: %",
        -: 1638:                                                    arguments_list_p[0]);
        -: 1639:#else /* !JERRY_ERROR_MESSAGES */
        -: 1640:      return ecma_raise_range_error (NULL);
        -: 1641:#endif /* JERRY_ERROR_MESSAGES */
        -: 1642:    }
        -: 1643:
        1: 1644:    return ecma_typedarray_create_object_with_length ((uint32_t) num,
        -: 1645:                                                      NULL,
        -: 1646:                                                      proto_p,
        -: 1647:                                                      element_size_shift,
        -: 1648:                                                      typedarray_id);
        -: 1649:  }
        -: 1650:
    #####: 1651:  ecma_object_t *obj_p = ecma_get_object_from_value (arguments_list_p[0]);
        -: 1652:
    #####: 1653:  if (ecma_object_is_typedarray (obj_p))
        -: 1654:  {
        -: 1655:    /* 22.2.1.3 */
    #####: 1656:    ecma_object_t *typedarray_p = obj_p;
    #####: 1657:    return ecma_typedarray_create_object_with_typedarray (typedarray_p,
        -: 1658:                                                          proto_p,
        -: 1659:                                                          element_size_shift,
        -: 1660:                                                          typedarray_id);
        -: 1661:  }
        -: 1662:
    #####: 1663:  if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####: 1664:      && !ecma_object_is_shared_arraybuffer (obj_p))
        -: 1665:  {
        -: 1666:    /* 22.2.1.4 */
    #####: 1667:    return ecma_typedarray_create_object_with_object (arguments_list_p[0],
        -: 1668:                                                      proto_p,
        -: 1669:                                                      element_size_shift,
        -: 1670:                                                      typedarray_id);
        -: 1671:  }
        -: 1672:
        -: 1673:  /* 22.2.1.5 */
    #####: 1674:  ecma_object_t *arraybuffer_p = obj_p;
    #####: 1675:  ecma_value_t byte_offset_value = ((arguments_list_len > 1) ? arguments_list_p[1]
    #####: 1676:                                                             : ECMA_VALUE_UNDEFINED);
        -: 1677:
    #####: 1678:  ecma_value_t length_value = ((arguments_list_len > 2) ? arguments_list_p[2]
    #####: 1679:                                                        : ECMA_VALUE_UNDEFINED);
        -: 1680:
    #####: 1681:  ecma_number_t offset;
        -: 1682:
    #####: 1683:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (byte_offset_value, &offset)))
        -: 1684:  {
    #####: 1685:    return ECMA_VALUE_ERROR;
        -: 1686:  }
        -: 1687:
    #####: 1688:  if (ecma_number_is_negative (offset) || fmod (offset, (1 << element_size_shift)) != 0)
        -: 1689:  {
        -: 1690:    /* ES2015 22.2.1.5: 9 - 10. */
    #####: 1691:    if (ecma_number_is_zero (offset))
        -: 1692:    {
    #####: 1693:      offset = 0;
        -: 1694:    }
        -: 1695:    else
        -: 1696:    {
    #####: 1697:      return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -: 1698:    }
        -: 1699:  }
        -: 1700:
    #####: 1701:  ecma_number_t new_length = 0;
        -: 1702:
    #####: 1703:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_index (length_value, &new_length)))
        -: 1704:  {
    #####: 1705:    return ECMA_VALUE_ERROR;
        -: 1706:  }
        -: 1707:
    #####: 1708:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1709:  {
    #####: 1710:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1711:  }
        -: 1712:
    #####: 1713:  const char *invalid_length_p = ECMA_ERR_MSG ("Invalid length");
        -: 1714:
    #####: 1715:  if (offset > UINT32_MAX)
        -: 1716:  {
    #####: 1717:    return ecma_raise_range_error (invalid_length_p);
        -: 1718:  }
        -: 1719:
    #####: 1720:  uint32_t byte_offset = (uint32_t) offset;
        -: 1721:
    #####: 1722:  uint32_t buf_byte_length = ecma_arraybuffer_get_length (arraybuffer_p);
    #####: 1723:  uint32_t new_byte_length = 0;
        -: 1724:
    #####: 1725:  if (ecma_is_value_undefined (length_value))
        -: 1726:  {
    #####: 1727:    if ((buf_byte_length % (uint32_t) (1 << element_size_shift) != 0)
    #####: 1728:        || (buf_byte_length < byte_offset))
        -: 1729:    {
    #####: 1730:      return ecma_raise_range_error (invalid_length_p);
        -: 1731:    }
        -: 1732:
    #####: 1733:    new_byte_length = (uint32_t) (buf_byte_length - byte_offset);
        -: 1734:  }
        -: 1735:  else
        -: 1736:  {
    #####: 1737:    if (new_length > (UINT32_MAX >> element_size_shift))
        -: 1738:    {
    #####: 1739:      return ecma_raise_range_error (ECMA_ERR_MSG ("Maximum TypedArray size is reached"));
        -: 1740:    }
        -: 1741:
    #####: 1742:    new_byte_length = (uint32_t) new_length << element_size_shift;
        -: 1743:
    #####: 1744:    if (byte_offset > buf_byte_length
    #####: 1745:        || new_byte_length > (buf_byte_length - byte_offset))
        -: 1746:    {
    #####: 1747:      return ecma_raise_range_error (invalid_length_p);
        -: 1748:    }
        -: 1749:  }
        -: 1750:
    #####: 1751:  bool needs_ext_typedarray_obj = (byte_offset != 0 || new_byte_length != buf_byte_length);
        -: 1752:
    #####: 1753:  size_t object_size = (needs_ext_typedarray_obj ? sizeof (ecma_extended_typedarray_object_t)
    #####: 1754:                                                 : sizeof (ecma_extended_object_t));
        -: 1755:
    #####: 1756:  ecma_object_t *object_p = ecma_create_object (proto_p, object_size, ECMA_OBJECT_TYPE_CLASS);
        -: 1757:
    #####: 1758:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 1759:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_TYPEDARRAY;
    #####: 1760:  ext_object_p->u.cls.u1.typedarray_type = (uint8_t) typedarray_id;
    #####: 1761:  ext_object_p->u.cls.u2.typedarray_flags = 0;
    #####: 1762:  ext_object_p->u.cls.u3.arraybuffer = ecma_make_object_value (arraybuffer_p);
        -: 1763:
    #####: 1764:  if (needs_ext_typedarray_obj)
        -: 1765:  {
    #####: 1766:    ext_object_p->u.cls.u2.typedarray_flags |= ECMA_TYPEDARRAY_IS_EXTENDED;
        -: 1767:
    #####: 1768:    ecma_extended_typedarray_object_t *typedarray_info_p = (ecma_extended_typedarray_object_t *) object_p;
    #####: 1769:    typedarray_info_p->array_length = new_byte_length >> element_size_shift;
    #####: 1770:    typedarray_info_p->byte_offset = byte_offset;
        -: 1771:  }
        -: 1772:
    #####: 1773:  return ecma_make_object_value (object_p);
        -: 1774:} /* ecma_op_create_typedarray */
        -: 1775:
        -: 1776:/**
        -: 1777: * Helper function for typedArray.prototype object's {'keys', 'values', 'entries', '@@iterator'}
        -: 1778: * routines common parts.
        -: 1779: *
        -: 1780: * See also:
        -: 1781: *          ECMA-262 v6, 22.2.3.15
        -: 1782: *          ECMA-262 v6, 22.2.3.29
        -: 1783: *          ECMA-262 v6, 22.2.3.6
        -: 1784: *          ECMA-262 v6, 22.1.3.30
        -: 1785: *
        -: 1786: * Note:
        -: 1787: *      Returned value must be freed with ecma_free_value.
        -: 1788: *
        -: 1789: * @return iterator result object, if success
        -: 1790: *         error - otherwise
        -: 1791: */
        -: 1792:ecma_value_t
    #####: 1793:ecma_typedarray_iterators_helper (ecma_value_t this_arg, /**< this argument */
        -: 1794:                                  ecma_iterator_kind_t kind) /**< iterator kind */
        -: 1795:{
    #####: 1796:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
    #####: 1797:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -: 1798:
    #####: 1799:  return ecma_op_create_iterator_object (this_arg,
        -: 1800:                                         prototype_obj_p,
        -: 1801:                                         ECMA_OBJECT_CLASS_ARRAY_ITERATOR,
        -: 1802:                                         kind);
        -: 1803:} /* ecma_typedarray_iterators_helper */
        -: 1804:
        -: 1805:/**
        -: 1806: * Check if the object is typedarray
        -: 1807: *
        -: 1808: * @return true - if object is a TypedArray object
        -: 1809: *         false - otherwise
        -: 1810: */
        -: 1811:bool
       14: 1812:ecma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */
        -: 1813:{
       14: 1814:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -: 1815:
       14: 1816:  return ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_TYPEDARRAY);
        -: 1817:} /* ecma_object_is_typedarray */
        -: 1818:
        -: 1819:/**
        -: 1820: * Check if the value is typedarray
        -: 1821: *
        -: 1822: * @return true - if value is a TypedArray object
        -: 1823: *         false - otherwise
        -: 1824: */
        -: 1825:bool
        2: 1826:ecma_is_typedarray (ecma_value_t value) /**< the target need to be checked */
        -: 1827:{
        2: 1828:  if (!ecma_is_value_object (value))
        -: 1829:  {
    #####: 1830:    return false;
        -: 1831:  }
        -: 1832:
        2: 1833:  return ecma_object_is_typedarray (ecma_get_object_from_value (value));
        -: 1834:} /* ecma_is_typedarray */
        -: 1835:
        -: 1836:/**
        -: 1837: * List names of a TypedArray object's integer indexed properties
        -: 1838: *
        -: 1839: * @return void
        -: 1840: */
        -: 1841:void
    #####: 1842:ecma_op_typedarray_list_lazy_property_names (ecma_object_t *obj_p, /**< a TypedArray object */
        -: 1843:                                             ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 1844:                                             ecma_property_counter_t *prop_counter_p,  /**< property counters */
        -: 1845:                                             jerry_property_filter_t filter) /**< property name filter options */
        -: 1846:{
    #####: 1847:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1848:
    #####: 1849:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
        -: 1850:  {
    #####: 1851:    return;
        -: 1852:  }
        -: 1853:
    #####: 1854:  uint32_t array_length = ecma_typedarray_get_length (obj_p);
        -: 1855:
    #####: 1856:  for (uint32_t i = 0; i < array_length; i++)
        -: 1857:  {
    #####: 1858:    ecma_string_t *name_p = ecma_new_ecma_string_from_uint32 (i);
    #####: 1859:    ecma_collection_push_back (prop_names_p, ecma_make_string_value (name_p));
        -: 1860:  }
        -: 1861:
    #####: 1862:  prop_counter_p->array_index_named_props += array_length;
        -: 1863:} /* ecma_op_typedarray_list_lazy_property_names */
        -: 1864:
        -: 1865:/**
        -: 1866: * [[DefineOwnProperty]] operation for TypedArray objects
        -: 1867: *
        -: 1868: * See also: ES2015 9.4.5.3
        -: 1869: *
        -: 1870: * @return ECMA_VALUE_TRUE - if the property is successfully defined
        -: 1871: *         ECMA_VALUE_FALSE - if is JERRY_PROP_SHOULD_THROW is not set
        -: 1872: *         raised TypeError - otherwise
        -: 1873: */
        -: 1874:ecma_value_t
    #####: 1875:ecma_op_typedarray_define_own_property (ecma_object_t *obj_p, /**< TypedArray object */
        -: 1876:                                        ecma_string_t *prop_name_p, /**< property name */
        -: 1877:                                        const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1878:{
    #####: 1879:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1880:
    #####: 1881:  if (!ecma_prop_name_is_symbol (prop_name_p))
        -: 1882:  {
    #####: 1883:    ecma_number_t num = ecma_string_to_number (prop_name_p);
        -: 1884:    bool is_same;
    #####: 1885:    if (num <= 0)
        -: 1886:    {
    #####: 1887:      is_same = true;
        -: 1888:    }
        -: 1889:    else
        -: 1890:    {
    #####: 1891:      ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####: 1892:      is_same = ecma_compare_ecma_strings (prop_name_p, num_to_str);
    #####: 1893:      ecma_deref_ecma_string (num_to_str);
        -: 1894:    }
        -: 1895:
    #####: 1896:    if (is_same)
        -: 1897:    {
    #####: 1898:      if ((property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
    #####: 1899:          || ((property_desc_p->flags & (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
        -: 1900:              == (JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE))
    #####: 1901:          || ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
    #####: 1902:              && !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE))
    #####: 1903:          || ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
    #####: 1904:              && !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE)))
        -: 1905:      {
    #####: 1906:        return ecma_raise_property_redefinition (prop_name_p, property_desc_p->flags);
        -: 1907:      }
        -: 1908:
    #####: 1909:      ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -: 1910:
    #####: 1911:      if (!ecma_op_is_integer (num)
    #####: 1912:          || num >= info.length
    #####: 1913:          || num < 0
    #####: 1914:          || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -: 1915:      {
    #####: 1916:        return ECMA_VALUE_FALSE;
        -: 1917:      }
        -: 1918:
    #####: 1919:      if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1920:      {
    #####: 1921:        ecma_value_t set_element = ecma_set_typedarray_element (&info, property_desc_p->value, num);
        -: 1922:
    #####: 1923:        if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1924:        {
    #####: 1925:          return set_element;
        -: 1926:        }
        -: 1927:
        -: 1928:      }
        -: 1929:
    #####: 1930:      return ECMA_VALUE_TRUE;
        -: 1931:    }
        -: 1932:  }
        -: 1933:
    #####: 1934:  return ecma_op_general_object_define_own_property (obj_p, prop_name_p, property_desc_p);
        -: 1935:} /* ecma_op_typedarray_define_own_property */
        -: 1936:
        -: 1937:/**
        -: 1938: * Specify the creation of a new TypedArray
        -: 1939: * object using a constructor function.
        -: 1940: *
        -: 1941: * See also: ES11 22.2.4.6
        -: 1942: *
        -: 1943: * Used by:
        -: 1944: *        - ecma_typedarray_species_create
        -: 1945: *
        -: 1946: * @return ecma_value_t function object from created from constructor_p argument
        -: 1947: */
        -: 1948:
        -: 1949:ecma_value_t
    #####: 1950:ecma_typedarray_create (ecma_object_t *constructor_p, /**< constructor function */
        -: 1951:                        ecma_value_t *arguments_list_p, /**< argument list */
        -: 1952:                        uint32_t arguments_list_len) /**< length of argument list */
        -: 1953:{
    #####: 1954:  ecma_value_t ret_val = ecma_op_function_construct (constructor_p,
        -: 1955:                                                     constructor_p,
        -: 1956:                                                     arguments_list_p,
        -: 1957:                                                     arguments_list_len);
    #####: 1958:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -: 1959:  {
    #####: 1960:    return ret_val;
        -: 1961:  }
        -: 1962:
    #####: 1963:  if (!ecma_is_typedarray (ret_val))
        -: 1964:  {
    #####: 1965:    ecma_free_value (ret_val);
    #####: 1966:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constructed object is not TypedArray"));
        -: 1967:  }
        -: 1968:
    #####: 1969:  ecma_object_t *typedarray_p = ecma_get_object_from_value (ret_val);
        -: 1970:
    #####: 1971:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (ecma_get_object_from_value (ret_val));
        -: 1972:
    #####: 1973:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1974:  {
    #####: 1975:    ecma_deref_object (typedarray_p);
    #####: 1976:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1977:  }
        -: 1978:
    #####: 1979:  if ((arguments_list_len == 1) && (ecma_is_value_number (arguments_list_p[0])))
        -: 1980:  {
    #####: 1981:    ecma_number_t num = ecma_get_number_from_value (arguments_list_p[0]);
    #####: 1982:    ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1983:
    #####: 1984:    if (info.length < num)
        -: 1985:    {
    #####: 1986:      ecma_free_value (ret_val);
    #####: 1987:      return ecma_raise_type_error (ECMA_ERR_MSG ("Constructed TypedArray is smaller than filter call result"));
        -: 1988:    }
        -: 1989:  }
    #####: 1990:  return ret_val;
        -: 1991:} /* ecma_typedarray_create */
        -: 1992:
        -: 1993:/* Specify the creation of a new TypedArray object
        -: 1994: * using a constructor function that is derived from this_arg.
        -: 1995: *
        -: 1996: * See also: ES11 22.2.4.7
        -: 1997: *
        -: 1998: * @return ecma value of the new typedarray object, constructed by default or species constructor
        -: 1999: */
        -: 2000:ecma_value_t
    #####: 2001:ecma_typedarray_species_create (ecma_value_t this_arg, /**< this argument */
        -: 2002:                                ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 2003:                                uint32_t arguments_list_len) /**< length of the the arg list */
        -: 2004:{
    #####: 2005:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 2006:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 2007:
    #####: 2008:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
        -: 2009:
    #####: 2010:  ecma_builtin_id_t default_constructor = ecma_typedarray_helper_get_constructor_id (info.id);
        -: 2011:
    #####: 2012:  ecma_value_t constructor = ecma_op_species_constructor (typedarray_p, default_constructor);
        -: 2013:
    #####: 2014:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2015:  {
    #####: 2016:    return constructor;
        -: 2017:  }
        -: 2018:
    #####: 2019:  ecma_object_t *constructor_proto_p = ecma_get_object_from_value (constructor);
        -: 2020:
    #####: 2021:  ecma_value_t result = ecma_typedarray_create (constructor_proto_p, arguments_list_p, arguments_list_len);
    #####: 2022:  ecma_deref_object (constructor_proto_p);
        -: 2023:
    #####: 2024:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2025:  {
    #####: 2026:    return result;
        -: 2027:  }
        -: 2028:
        -: 2029:#if JERRY_BUILTIN_BIGINT
    #####: 2030:  ecma_object_t *result_p = ecma_get_object_from_value (result);
    #####: 2031:  ecma_typedarray_info_t result_info = ecma_typedarray_get_info (result_p);
        -: 2032:  /*
        -: 2033:   * Check result_info.id to to be either bigint type if info.id is one
        -: 2034:   * or be neither of them is info.id is none of them as well.
        -: 2035:   */
    #####: 2036:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info.id) ^ ECMA_TYPEDARRAY_IS_BIGINT_TYPE (result_info.id))
        -: 2037:  {
    #####: 2038:    ecma_free_value (result);
    #####: 2039:    return ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray returned by [[ContentType]] does not match source"));
        -: 2040:  }
        -: 2041:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2042:
    #####: 2043:  return result;
        -: 2044:} /* ecma_typedarray_species_create */
        -: 2045:
        -: 2046:/**
        -: 2047: * Create a typedarray object based on the "type" and arraylength
        -: 2048: * The "type" is same with arg1
        -: 2049: *
        -: 2050: * @return ecma_value_t
        -: 2051: */
        -: 2052:ecma_value_t
    #####: 2053:ecma_op_create_typedarray_with_type_and_length (ecma_typedarray_type_t typedarray_id, /** TypedArray id  */
        -: 2054:                                                uint32_t array_length) /**< length of the typedarray */
        -: 2055:{
        -: 2056:  // TODO: assert validate typedarray_id
    #####: 2057:  ecma_object_t *proto_p = ecma_builtin_get (ecma_typedarray_helper_get_prototype_id (typedarray_id));
    #####: 2058:  uint8_t element_size_shift = ecma_typedarray_helper_get_shift_size (typedarray_id);
        -: 2059:
    #####: 2060:  ecma_value_t new_obj = ecma_typedarray_create_object_with_length (array_length,
        -: 2061:                                                                    NULL,
        -: 2062:                                                                    proto_p,
        -: 2063:                                                                    element_size_shift,
        -: 2064:                                                                    typedarray_id);
        -: 2065:
    #####: 2066:  return new_obj;
        -: 2067:} /* ecma_op_create_typedarray_with_type_and_length */
        -: 2068:
        -: 2069:/**
        -: 2070: * Method for getting the additional typedArray informations.
        -: 2071: */
        -: 2072:ecma_typedarray_info_t
        1: 2073:ecma_typedarray_get_info (ecma_object_t *typedarray_p)
        -: 2074:{
        -: 2075:  ecma_typedarray_info_t info;
        -: 2076:
        1: 2077:  info.id = ecma_get_typedarray_id (typedarray_p);
        1: 2078:  info.length = ecma_typedarray_get_length (typedarray_p);
        1: 2079:  info.shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        1: 2080:  info.element_size = (uint8_t) (1 << info.shift);
        1: 2081:  info.offset = ecma_typedarray_get_offset (typedarray_p);
        1: 2082:  info.array_buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2083:
        1: 2084:  return info;
        -: 2085:} /* ecma_typedarray_get_info */
        -: 2086:
        -: 2087:/**
        -: 2088: * @}
        -: 2089: * @}
        -: 2090: */
        -: 2091:#endif /* JERRY_BUILTIN_TYPEDARRAY */
