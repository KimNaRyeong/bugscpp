        -:    0:Source:/home/workspace/docs/03.API-EXAMPLE.md
        -:    0:Programs:296
        -:    1:JerryScript Engine can be embedded into any application, providing the way to run JavaScript in a large range of environments - from desktops to low-memory microcontrollers.
        -:    2:
        -:    3:This guide is intended to introduce you to JerryScript embedding API and to create a minimal JavaScript shell.
        -:    4:The examples are not using all API methods please also check out the API reference document which contains additional examples.
        -:    5:
        -:    6:
        -:    7:## Before trying out the examples: Get and build JerryScript library
        -:    8:
        -:    9:Before getting started using the JerryScript library it should be cloned and built for a target os/device.
        -:   10:
        -:   11:There are quite a few configuration options but for these examples the JerryScript is built
        -:   12:**with default configuration** and installed to a user directory on a Linux system.
        -:   13:This is done by the following commands:
        -:   14:
        -:   15:```sh
        -:   16:$ mkdir jerry
        -:   17:$ cd jerry
        -:   18:$ git clone https://github.com/jerryscript-project/jerryscript.git
        -:   19:$ jerryscript/tools/build.py --builddir=$(pwd)/example_build --cmake-param="-DCMAKE_INSTALL_PREFIX=$(pwd)/example_install/"
        -:   20:$ make -C $(pwd)/example_build install
        -:   21:```
        -:   22:
        -:   23:With this the JerryScript library is installed into the `$(pwd)/example_install/{include,lib}` directories.
        -:   24:
        -:   25:In this guide we will use `pkg-config` to ease the usage of headers and libraries.
        -:   26:In order to do so, the following export is required (executed from the jerry directory):
        -:   27:
        -:   28:```sh
        -:   29:$ export PKG_CONFIG_PATH=$(pwd)/example_install/lib/pkgconfig/
        -:   30:```
        -:   31:
        -:   32:Test if the `pkg-config` works for JerryScript:
        -:   33:
        -:   34:```sh
        -:   35:$ pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-ext libjerry-math
        -:   36:```
        -:   37:
        -:   38:## Example 1. Execute JavaScript from your application
        -:   39:
        -:   40:The most basic example to test the engine is to create an `api-example-1.c` file containing the following code:
        -:   41:
        -:   42:[doctest]: # ()
        -:   43:
        -:   44:```c
        -:   45:#include "jerryscript.h"
        -:   46:
        -:   47:int
    #####:   48:main (void)
        -:   49:{
    #####:   50:  const jerry_char_t script[] = "var str = 'Hello, World!';";
        -:   51:
    #####:   52:  bool ret_value = jerry_run_simple (script, sizeof (script) - 1, JERRY_INIT_EMPTY);
        -:   53:
    #####:   54:  return (ret_value ? 0 : 1);
        -:   55:}
        -:   56:```
        -:   57:
        -:   58:To compile it one can use the following command:
        -:   59:
        -:   60:```sh
        -:   61:$ gcc api-example-1.c -o api-example-1 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:   62:```
        -:   63:
        -:   64:If everything is correct the application returns with a zero exit code:
        -:   65:
        -:   66:```
        -:   67:$ ./api-example-1
        -:   68:$ echo $?
        -:   69:```
        -:   70:
        -:   71:## Example 2. Split engine initialization and script execution.
        -:   72:
        -:   73:In this example the engine is initialized directly with the `jerry_init` method
        -:   74:and cleaned up with the `jerry_cleanup` method. The example JavaScript code
        -:   75:is directly parsed and executed via the `jerry_eval` method. Each `jerry_value_t`
        -:   76:returned by the API methods is freed with the `jerry_release_value` method.
        -:   77:
        -:   78:To make sure that the code parsing and execution was ok, the `jerry_value_is_error`
        -:   79:method is used to check for any errors.
        -:   80:
        -:   81:Use the following code for the `api-example-2.c` file:
        -:   82:
        -:   83:[doctest]: # ()
        -:   84:
        -:   85:```c
        -:   86:#include "jerryscript.h"
        -:   87:
        -:   88:int
    #####:   89:main (void)
        -:   90:{
    #####:   91:  const jerry_char_t script[] = "var str = 'Hello, World!';";
    #####:   92:  const jerry_length_t script_size = sizeof (script) - 1;
        -:   93:  /* Note: sizeof can be used here only because the compiler knows the static character arrays's size.
        -:   94:   * If this is not the case, strlen should be used instead.
        -:   95:   */
        -:   96:
        -:   97:  /* Initialize engine */
    #####:   98:  jerry_init (JERRY_INIT_EMPTY);
        -:   99:
        -:  100:  /* Run the demo script with 'eval' */
    #####:  101:  jerry_value_t eval_ret = jerry_eval (script,
        -:  102:                                       script_size,
        -:  103:                                       JERRY_PARSE_NO_OPTS);
        -:  104:
        -:  105:  /* Check if there was any error (syntax or runtime) */
    #####:  106:  bool run_ok = !jerry_value_is_error (eval_ret);
        -:  107:
        -:  108:  /* Parsed source code must be freed */
    #####:  109:  jerry_release_value (eval_ret);
        -:  110:
        -:  111:  /* Cleanup engine */
    #####:  112:  jerry_cleanup ();
        -:  113:
        -:  114:  return (run_ok ? 0 : 1);
        -:  115:}
        -:  116:```
        -:  117:
        -:  118:To compile it one can use the following command:
        -:  119:
        -:  120:```sh
        -:  121:$ gcc api-example-2.c -o api-example-2 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  122:```
        -:  123:
        -:  124:If everything is correct the application returns with a zero exit code:
        -:  125:
        -:  126:```
        -:  127:$ ./api-example-2
        -:  128:$ echo $?
        -:  129:```
        -:  130:
        -:  131:## Example 3. Split JavaScript parsing and script execution
        -:  132:
        -:  133:In this example the `jerry_eval` is replaced with a more common API calls:
        -:  134:
        -:  135:- script code setup - `jerry_parse`.
        -:  136:- script execution - `jerry_run`.
        -:  137:
        -:  138:The `api-example-3.c` file should contain the following code:
        -:  139:
        -:  140:[doctest]: # ()
        -:  141:
        -:  142:```c
        -:  143:#include "jerryscript.h"
        -:  144:
        -:  145:int
    #####:  146:main (void)
        -:  147:{
    #####:  148:  bool run_ok = false;
        -:  149:
    #####:  150:  const jerry_char_t script[] = "var str = 'Hello, World!';";
        -:  151:
        -:  152:  /* Initialize engine */
    #####:  153:  jerry_init (JERRY_INIT_EMPTY);
        -:  154:
        -:  155:  /* Setup Global scope code */
    #####:  156:  jerry_value_t parsed_code = jerry_parse (script, sizeof (script) - 1, NULL);
        -:  157:
        -:  158:  /* Check if there is any JS code parse error */
    #####:  159:  if (!jerry_value_is_error (parsed_code))
        -:  160:  {
        -:  161:    /* Execute the parsed source code in the Global scope */
    #####:  162:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  163:
        -:  164:    /* Check the execution return value if there is any error */
    #####:  165:    run_ok = !jerry_value_is_error (ret_value);
        -:  166:
        -:  167:    /* Returned value must be freed */
    #####:  168:    jerry_release_value (ret_value);
        -:  169:  }
        -:  170:
        -:  171:  /* Parsed source code must be freed */
    #####:  172:  jerry_release_value (parsed_code);
        -:  173:
        -:  174:  /* Cleanup engine */
    #####:  175:  jerry_cleanup ();
        -:  176:
    #####:  177:  return (run_ok ? 0 : 1);
        -:  178:}
        -:  179:```
        -:  180:
        -:  181:To compile it one can use the following command:
        -:  182:
        -:  183:```sh
        -:  184:$ gcc api-example-3.c -o api-example-3 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  185:```
        -:  186:
        -:  187:If everything is correct the application returns with a zero exit code:
        -:  188:
        -:  189:```
        -:  190:$ ./api-example-3
        -:  191:$ echo $?
        -:  192:```
        -:  193:
        -:  194:## Example 4. Adding a C method for JavaScript
        -:  195:
        -:  196:The previous examples were not that eye catching as there were no visual output by the JavaScript code
        -:  197:and C program.
        -:  198:
        -:  199:In this example a very simple "print" method is added which prints out a static string.
        -:  200:This method will be implemented in C and will be called from the JavaScript code.
        -:  201:For this a few extra API methods are required:
        -:  202:
        -:  203:- `jerry_get_global_object`
        -:  204:- `jerry_create_string`
        -:  205:- `jerry_set_property`
        -:  206:- `jerry_create_external_function`
        -:  207:
        -:  208:The `api-example-4.c` file should contain the following code:
        -:  209:
        -:  210:[doctest]: # ()
        -:  211:
        -:  212:```c
        -:  213:#include <stdio.h>
        -:  214:#include "jerryscript.h"
        -:  215:
        -:  216:static jerry_value_t
    #####:  217:print_handler (const jerry_call_info_t *call_info_p,
        -:  218:               const jerry_value_t arguments[],
        -:  219:               const jerry_length_t argument_count)
        -:  220:{
        -:  221:  /* No arguments are used in this example */
        -:  222:  /* Print out a static string */
    #####:  223:  printf ("Print handler was called\n");
        -:  224:
        -:  225:  /* Return an "undefined" value to the JavaScript engine */
    #####:  226:  return jerry_create_undefined ();
        -:  227:}
        -:  228:
        -:  229:int
    #####:  230:main (void)
        -:  231:{
    #####:  232:  const jerry_char_t script[] = "print ();";
    #####:  233:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  234:
        -:  235:  /* Initialize engine */
    #####:  236:  jerry_init (JERRY_INIT_EMPTY);
        -:  237:
        -:  238:  /* Add the "print" method for the JavaScript global object */
        -:  239:  {
        -:  240:    /* Get the "global" object */
    #####:  241:    jerry_value_t global_object = jerry_get_global_object ();
        -:  242:    /* Create a "print" JS string */
    #####:  243:    jerry_value_t property_name_print = jerry_create_string ((const jerry_char_t *) "print");
        -:  244:    /* Create a function from a native C method (this function will be called from JS) */
    #####:  245:    jerry_value_t property_value_func = jerry_create_external_function (print_handler);
        -:  246:    /* Add the "print" property with the function value to the "global" object */
    #####:  247:    jerry_value_t set_result = jerry_set_property (global_object, property_name_print, property_value_func);
        -:  248:
        -:  249:    /* Check if there was no error when adding the property (in this case it should never happen) */
    #####:  250:    if (jerry_value_is_error (set_result)) {
        -:  251:      printf ("Failed to add the 'print' property\n");
        -:  252:    }
        -:  253:
        -:  254:    /* Release all jerry_value_t-s */
    #####:  255:    jerry_release_value (set_result);
    #####:  256:    jerry_release_value (property_value_func);
    #####:  257:    jerry_release_value (property_name_print);
    #####:  258:    jerry_release_value (global_object);
        -:  259:  }
        -:  260:
        -:  261:  /* Setup Global scope code */
    #####:  262:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  263:
    #####:  264:  if (!jerry_value_is_error (parsed_code))
        -:  265:  {
        -:  266:    /* Execute the parsed source code in the Global scope */
    #####:  267:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  268:
        -:  269:    /* Returned value must be freed */
    #####:  270:    jerry_release_value (ret_value);
        -:  271:  }
        -:  272:
        -:  273:  /* Parsed source code must be freed */
    #####:  274:  jerry_release_value (parsed_code);
        -:  275:
        -:  276:  /* Cleanup engine */
    #####:  277:  jerry_cleanup ();
        -:  278:
        -:  279:  return 0;
        -:  280:}
        -:  281:```
        -:  282:
        -:  283:
        -:  284:To compile it one can use the following command:
        -:  285:
        -:  286:```sh
        -:  287:$ gcc api-example-4.c -o api-example-4 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  288:```
        -:  289:
        -:  290:If everything is correct the application should print out the message present in the `print_handler` method:
        -:  291:
        -:  292:```
        -:  293:$ ./api-example-4
        -:  294:```
        -:  295:
        -:  296:## Example 5. Passing and processing arguments for native C code
        -:  297:
        -:  298:In the previous example the `print_handler` simply wrote a static string to the standard output.
        -:  299:However in most cases this is not useful, ideally the method's argument(s) should be printed.
        -:  300:
        -:  301:In this example the `print_handler` is extended to convert the first
        -:  302:argument (which probably comes from a JavaScript source) to a JS string and prints it out to the standard output.
        -:  303:
        -:  304:New API methods used:
        -:  305:
        -:  306:- `jerry_value_to_string`
        -:  307:- `jerry_string_to_utf8_char_buffer`
        -:  308:
        -:  309:The `api-example-5.c` file should contain the following code:
        -:  310:
        -:  311:[doctest]: # ()
        -:  312:
        -:  313:```c
        -:  314:#include <stdio.h>
        -:  315:#include "jerryscript.h"
        -:  316:
        -:  317:static jerry_value_t
    #####:  318:print_handler (const jerry_call_info_t *call_info_p,
        -:  319:               const jerry_value_t arguments[],
        -:  320:               const jerry_length_t arguments_count)
        -:  321:{
        -:  322:  /* There should be at least one argument */
    #####:  323:  if (arguments_count > 0)
        -:  324:  {
        -:  325:    /* Convert the first argument to a string (JS "toString" operation) */
    #####:  326:    jerry_value_t string_value = jerry_value_to_string (arguments[0]);
        -:  327:
        -:  328:    /* A naive allocation of buffer for the string */
        -:  329:    jerry_char_t buffer[256];
        -:  330:
        -:  331:    /* Copy the whole string to the buffer, without a null termination character,
        -:  332:     * Please note that if the string does not fit into the buffer nothing will be copied.
        -:  333:     * More details on the API reference page
        -:  334:     */
    #####:  335:    jerry_size_t copied_bytes = jerry_string_to_utf8_char_buffer (string_value, buffer, sizeof (buffer) - 1);
    #####:  336:    buffer[copied_bytes] = '\0';
        -:  337:
        -:  338:    /* Release the "toString" result */
    #####:  339:    jerry_release_value (string_value);
        -:  340:
    #####:  341:    printf ("%s\n", (const char *)buffer);
        -:  342:  }
        -:  343:
        -:  344:  /* Return an "undefined" value to the JavaScript engine */
    #####:  345:  return jerry_create_undefined ();
        -:  346:}
        -:  347:
        -:  348:int
    #####:  349:main (void)
        -:  350:{
    #####:  351:  const jerry_char_t script[] = "print ('Hello from JS!');";
    #####:  352:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  353:
        -:  354:  /* Initialize engine */
    #####:  355:  jerry_init (JERRY_INIT_EMPTY);
        -:  356:
        -:  357:  /* Add the "print" method for the JavaScript global object */
        -:  358:  {
        -:  359:    /* Get the "global" object */
    #####:  360:    jerry_value_t global_object = jerry_get_global_object ();
        -:  361:    /* Create a "print" JS string */
    #####:  362:    jerry_value_t property_name_print = jerry_create_string ((const jerry_char_t *) "print");
        -:  363:    /* Create a function from a native C method (this function will be called from JS) */
    #####:  364:    jerry_value_t property_value_func = jerry_create_external_function (print_handler);
        -:  365:    /* Add the "print" property with the function value to the "global" object */
    #####:  366:    jerry_value_t set_result = jerry_set_property (global_object, property_name_print, property_value_func);
        -:  367:
        -:  368:    /* Check if there was no error when adding the property (in this case it should never happen) */
    #####:  369:    if (jerry_value_is_error (set_result)) {
        -:  370:      printf ("Failed to add the 'print' property\n");
        -:  371:    }
        -:  372:
        -:  373:    /* Release all jerry_value_t-s */
    #####:  374:    jerry_release_value (set_result);
    #####:  375:    jerry_release_value (property_value_func);
    #####:  376:    jerry_release_value (property_name_print);
    #####:  377:    jerry_release_value (global_object);
        -:  378:  }
        -:  379:
        -:  380:  /* Setup Global scope code */
    #####:  381:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  382:
    #####:  383:  if (!jerry_value_is_error (parsed_code))
        -:  384:  {
        -:  385:    /* Execute the parsed source code in the Global scope */
    #####:  386:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  387:
        -:  388:    /* Returned value must be freed */
    #####:  389:    jerry_release_value (ret_value);
        -:  390:  }
        -:  391:
        -:  392:  /* Parsed source code must be freed */
    #####:  393:  jerry_release_value (parsed_code);
        -:  394:
        -:  395:  /* Cleanup engine */
    #####:  396:  jerry_cleanup ();
        -:  397:
        -:  398:  return 0;
        -:  399:}
        -:  400:```
        -:  401:
        -:  402:
        -:  403:To compile it one can use the following command:
        -:  404:
        -:  405:```sh
        -:  406:$ gcc api-example-5.c -o api-example-5 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  407:```
        -:  408:
        -:  409:If everything is correct the application should print out the string passed for the `print` method in the JS code:
        -:  410:
        -:  411:```
        -:  412:$ ./api-example-5
        -:  413:```
        -:  414:
        -:  415:
        -:  416:## Example 6. Using JerryScript Extensions
        -:  417:
        -:  418:Some of the previous examples used a "print" method to write data out to the standard output.
        -:  419:For convenience JerryScript provides an extension to add a simple "print" handler which
        -:  420:can be used by other applications.
        -:  421:
        -:  422:In this example the following extension methods are used:
        -:  423:
        -:  424:- `jerryx_handler_register_global`
        -:  425:- `jerryx_handler_print`
        -:  426:
        -:  427:In further examples this "print" handler will be used.
        -:  428:
        -:  429:```c
        -:  430:#include "jerryscript.h"
        -:  431:#include "jerryscript-ext/handler.h"
        -:  432:
        -:  433:int
        -:  434:main (void)
        -:  435:{
        -:  436:  const jerry_char_t script[] = "print ('Hello from JS with ext!');";
        -:  437:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  438:
        -:  439:  /* Initialize engine */
        -:  440:  jerry_init (JERRY_INIT_EMPTY);
        -:  441:
        -:  442:  /* Register 'print' function from the extensions to the global object */
        -:  443:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -:  444:                                  jerryx_handler_print);
        -:  445:
        -:  446:  /* Setup Global scope code */
        -:  447:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  448:
        -:  449:  if (!jerry_value_is_error (parsed_code))
        -:  450:  {
        -:  451:    /* Execute the parsed source code in the Global scope */
        -:  452:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  453:
        -:  454:    /* Returned value must be freed */
        -:  455:    jerry_release_value (ret_value);
        -:  456:  }
        -:  457:
        -:  458:  /* Parsed source code must be freed */
        -:  459:  jerry_release_value (parsed_code);
        -:  460:
        -:  461:  /* Cleanup engine */
        -:  462:  jerry_cleanup ();
        -:  463:
        -:  464:  return 0;
        -:  465:}
        -:  466:```
        -:  467:
        -:  468:
        -:  469:To compile it one can use the following command:
        -:  470:
        -:  471:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  472:
        -:  473:```sh
        -:  474:$ gcc api-example-6.c -o api-example-6 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  475:```
        -:  476:
        -:  477:If everything is correct the application should print out the string passed for the `print` method in the JS code:
        -:  478:
        -:  479:```
        -:  480:$ ./api-example-6
        -:  481:```
        -:  482:
        -:  483:## Example 7. Interaction with JavaScript environment - adding a string property
        -:  484:
        -:  485:Previously a C method was registered for the global object, now this examples show how one can add a string
        -:  486:property.
        -:  487:
        -:  488:Use the following code as the `api-example-7.c` file:
        -:  489:
        -:  490:[doctest]: # ()
        -:  491:
        -:  492:```c
        -:  493:#include "jerryscript.h"
        -:  494:#include "jerryscript-ext/handler.h"
        -:  495:
        -:  496:int
    #####:  497:main (void)
        -:  498:{
    #####:  499:  const jerry_char_t script[] = "print (my_var);";
        -:  500:
        -:  501:  /* Initializing JavaScript environment */
    #####:  502:  jerry_init (JERRY_INIT_EMPTY);
        -:  503:
        -:  504:  /* Register 'print' function from the extensions */
    #####:  505:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -:  506:                                  jerryx_handler_print);
        -:  507:
        -:  508:  /* Getting pointer to the Global object */
    #####:  509:  jerry_value_t global_object = jerry_get_global_object ();
        -:  510:
        -:  511:  /* Constructing strings */
    #####:  512:  jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "my_var");
    #####:  513:  jerry_value_t prop_value = jerry_create_string ((const jerry_char_t *) "Hello from C!");
        -:  514:
        -:  515:  /* Setting the string value as a property of the Global object */
    #####:  516:  jerry_value_t set_result = jerry_set_property (global_object, prop_name, prop_value);
        -:  517:  /* The 'set_result' should be checked if there was any error */
    #####:  518:  if (jerry_value_is_error (set_result)) {
        -:  519:    printf ("Failed to add the 'my_var' property\n");
        -:  520:  }
    #####:  521:  jerry_release_value (set_result);
        -:  522:
        -:  523:  /* Releasing string values, as it is no longer necessary outside of engine */
    #####:  524:  jerry_release_value (prop_name);
    #####:  525:  jerry_release_value (prop_value);
        -:  526:
        -:  527:  /* Releasing the Global object */
    #####:  528:  jerry_release_value (global_object);
        -:  529:
        -:  530:  /* Now starting script that would output value of just initialized field */
    #####:  531:  jerry_value_t eval_ret = jerry_eval (script,
        -:  532:                                       sizeof (script) - 1,
        -:  533:                                       JERRY_PARSE_NO_OPTS);
        -:  534:
        -:  535:  /* Free JavaScript value, returned by eval */
    #####:  536:  jerry_release_value (eval_ret);
        -:  537:
        -:  538:  /* Freeing engine */
    #####:  539:  jerry_cleanup ();
        -:  540:
        -:  541:  return 0;
        -:  542:}
        -:  543:```
        -:  544:
        -:  545:To compile it one can use the following command:
        -:  546:
        -:  547:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  548:
        -:  549:```sh
        -:  550:$ gcc api-example-7.c -o api-example-7 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  551:```
        -:  552:
        -:  553:The sample will output 'Hello from C!'. However, now it is not just a part of the source script, but the value, dynamically supplied to the engine:
        -:  554:
        -:  555:```
        -:  556:$ ./api-example-7
        -:  557:```
        -:  558:
        -:  559:## Example 8. Description of JerryScript value descriptors
        -:  560:
        -:  561:JerryScript value can be a boolean, number, null, object, string, undefined or some special type of objects (arraybuffer, symbols, etc).
        -:  562:
        -:  563:There is a special "error" value which wraps another value. This "error" can be created by throwing a JavaScript value from JS code
        -:  564:or via API method(s). It is advised to check for this error with the `jerry_value_is_error` method as not all API methods
        -:  565:can process error values. To extract the value from the "error" the API method `jerry_get_value_from_error` should be used.
        -:  566:If an error object is created via API method (for example with `jerry_create_error`) the "error" value is automatically created.
        -:  567:
        -:  568:Notice the difference between error value and error object:
        -:  569:- The error object is a object which was constructed via one of the `Error` objects (available from the global object or from API).
        -:  570:  For example in JS such object be created with the following code example:
        -:  571:
        -:  572:```js
        -:  573:var error_object = new Error ("error message");
        -:  574:```
        -:  575:
        -:  576:- The error value is not an object on its own. This is the exception raised/thrown either via API methods or from JS.
        -:  577:  For example, creating such error value in JS would look like this:
        -:  578:
        -:  579:```js
        -:  580:throw "message";
        -:  581:```
        -:  582:
        -:  583:To check what type a given `jerry_value_t` is the `jerry_value_is_*` methods or the `jerry_value_get_type` could be used.
        -:  584:For example the following code snippet could print out a few types (not all types are checked):
        -:  585:
        -:  586:[doctest]: # (test="compile")
        -:  587:
        -:  588:```c
        -:  589:#include <stdio.h>
        -:  590:#include <stdlib.h>
        -:  591:#include "jerryscript.h"
        -:  592:
        -:  593:static void
        -:  594:print_value (const jerry_value_t jsvalue)
        -:  595:{
        -:  596:  jerry_value_t value;
        -:  597:  /* If there is an error extract the object from it */
        -:  598:  if (jerry_value_is_error (jsvalue))
        -:  599:  {
        -:  600:    printf ("Error value detected: ");
        -:  601:    value = jerry_get_value_from_error (jsvalue, false);
        -:  602:  }
        -:  603:  else
        -:  604:  {
        -:  605:    value = jerry_acquire_value (jsvalue);
        -:  606:  }
        -:  607:
        -:  608:  if (jerry_value_is_undefined (value))
        -:  609:  {
        -:  610:    printf ("undefined");
        -:  611:  }
        -:  612:  else if (jerry_value_is_null (value))
        -:  613:  {
        -:  614:    printf ("null");
        -:  615:  }
        -:  616:  else if (jerry_value_is_boolean (value))
        -:  617:  {
        -:  618:    if (jerry_value_is_true (value))
        -:  619:    {
        -:  620:      printf ("true");
        -:  621:    }
        -:  622:    else
        -:  623:    {
        -:  624:      printf ("false");
        -:  625:    }
        -:  626:  }
        -:  627:  /* Float value */
        -:  628:  else if (jerry_value_is_number (value))
        -:  629:  {
        -:  630:    printf ("number: %lf", jerry_get_number_value (value));
        -:  631:  }
        -:  632:  /* String value */
        -:  633:  else if (jerry_value_is_string (value))
        -:  634:  {
        -:  635:    jerry_char_t str_buf_p[256];
        -:  636:
        -:  637:    /* Determining required buffer size */
        -:  638:    jerry_size_t req_sz = jerry_get_string_size (value);
        -:  639:
        -:  640:    if (req_sz <= 255)
        -:  641:    {
        -:  642:      jerry_string_to_char_buffer (value, str_buf_p, req_sz);
        -:  643:      str_buf_p[req_sz] = '\0';
        -:  644:      printf ("%s", (const char *) str_buf_p);
        -:  645:    }
        -:  646:    else
        -:  647:    {
        -:  648:      printf ("error: buffer isn't big enough");
        -:  649:    }
        -:  650:  }
        -:  651:  /* Object reference */
        -:  652:  else if (jerry_value_is_object (value))
        -:  653:  {
        -:  654:    printf ("[JS object]");
        -:  655:  }
        -:  656:
        -:  657:  printf ("\n");
        -:  658:  jerry_release_value (value);
        -:  659:}
        -:  660:```
        -:  661:
        -:  662:## Example 8: Simple JavaScript shell
        -:  663:
        -:  664:Now all building blocks, necessary to construct JavaScript shell, are ready.
        -:  665:
        -:  666:Shell operation can be described with the following loop:
        -:  667:
        -:  668:- read command;
        -:  669:- if command is 'quit'
        -:  670:  - exit loop;
        -:  671:- else
        -:  672:  - eval (command);
        -:  673:  - print result of eval;
        -:  674:  - loop.
        -:  675:
        -:  676:See the following `api-example-8-shell.c` file:
        -:  677:
        -:  678:[doctest]: # (test="link")
        -:  679:
        -:  680:```c
        -:  681:#include <stdio.h>
        -:  682:#include <stdlib.h>
        -:  683:#include <string.h>
        -:  684:#include "jerryscript.h"
        -:  685:#include "jerryscript-ext/handler.h"
        -:  686:
        -:  687:static void
    #####:  688:print_value (const jerry_value_t jsvalue)
        -:  689:{
        -:  690:  jerry_value_t value;
        -:  691:  /* If there is an error extract the object from it */
    #####:  692:  if (jerry_value_is_error (jsvalue))
        -:  693:  {
    #####:  694:    printf ("Error value detected: ");
    #####:  695:    value = jerry_get_value_from_error (jsvalue, false);
        -:  696:  }
        -:  697:  else
        -:  698:  {
    #####:  699:    value = jerry_acquire_value (jsvalue);
        -:  700:  }
        -:  701:
    #####:  702:  if (jerry_value_is_undefined (value))
        -:  703:  {
        -:  704:    printf ("undefined");
        -:  705:  }
    #####:  706:  else if (jerry_value_is_null (value))
        -:  707:  {
        -:  708:    printf ("null");
        -:  709:  }
    #####:  710:  else if (jerry_value_is_boolean (value))
        -:  711:  {
    #####:  712:    if (jerry_value_is_true (value))
        -:  713:    {
        -:  714:      printf ("true");
        -:  715:    }
        -:  716:    else
        -:  717:    {
        -:  718:      printf ("false");
        -:  719:    }
        -:  720:  }
        -:  721:  /* Float value */
    #####:  722:  else if (jerry_value_is_number (value))
        -:  723:  {
    #####:  724:    printf ("number: %lf", jerry_get_number_value (value));
        -:  725:  }
        -:  726:  /* String value */
    #####:  727:  else if (jerry_value_is_string (value))
        -:  728:  {
        -:  729:    jerry_char_t str_buf_p[256];
        -:  730:
        -:  731:    /* Determining required buffer size */
    #####:  732:    jerry_size_t req_sz = jerry_get_string_size (value);
        -:  733:
    #####:  734:    if (req_sz <= 255)
        -:  735:    {
    #####:  736:      jerry_string_to_char_buffer (value, str_buf_p, req_sz);
    #####:  737:      str_buf_p[req_sz] = '\0';
        -:  738:      printf ("%s", (const char *) str_buf_p);
        -:  739:    }
        -:  740:    else
        -:  741:    {
        -:  742:      printf ("error: buffer isn't big enough");
        -:  743:    }
        -:  744:  }
        -:  745:  /* Object reference */
    #####:  746:  else if (jerry_value_is_object (value))
        -:  747:  {
        -:  748:    printf ("[JS object]");
        -:  749:  }
        -:  750:
    #####:  751:  printf ("\n");
    #####:  752:  jerry_release_value (value);
    #####:  753:}
        -:  754:
        -:  755:int
    #####:  756:main (void)
        -:  757:{
    #####:  758:  bool is_done = false;
        -:  759:
        -:  760:  /* Initialize engine */
    #####:  761:  jerry_init (JERRY_INIT_EMPTY);
        -:  762:
        -:  763:  /* Register 'print' function from the extensions */
    #####:  764:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -:  765:                                  jerryx_handler_print);
        -:  766:
    #####:  767:  while (!is_done)
        -:  768:  {
        -:  769:    char cmd[256];
    #####:  770:    char *cmd_tail = cmd;
    #####:  771:    size_t len = 0;
        -:  772:
        -:  773:    printf ("> ");
        -:  774:
        -:  775:    /* Read next command */
        -:  776:    while (true)
        -:  777:    {
    #####:  778:      if (fread (cmd_tail, 1, 1, stdin) != 1 && len == 0)
        -:  779:      {
        -:  780:        is_done = true;
        -:  781:        break;
        -:  782:      }
    #####:  783:      if (*cmd_tail == '\n')
        -:  784:      {
        -:  785:        break;
        -:  786:      }
        -:  787:
    #####:  788:      cmd_tail++;
    #####:  789:      len++;
        -:  790:    }
        -:  791:
        -:  792:    /* If the command is "quit", break the loop */
    #####:  793:    if (!strncmp (cmd, "quit\n", sizeof ("quit\n") - 1))
        -:  794:    {
        -:  795:      break;
        -:  796:    }
        -:  797:
        -:  798:    jerry_value_t ret_val;
        -:  799:
        -:  800:    /* Evaluate entered command */
    #####:  801:    ret_val = jerry_eval ((const jerry_char_t *) cmd,
        -:  802:                          len,
        -:  803:                          JERRY_PARSE_NO_OPTS);
        -:  804:
        -:  805:    /* Print out the value */
    #####:  806:    print_value (ret_val);
        -:  807:
    #####:  808:    jerry_release_value (ret_val);
        -:  809:  }
        -:  810:
        -:  811:  /* Cleanup engine */
    #####:  812:  jerry_cleanup ();
        -:  813:
        -:  814:  return 0;
        -:  815:}
        -:  816:```
        -:  817:
        -:  818:To compile it one can use the following command:
        -:  819:
        -:  820:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  821:
        -:  822:```sh
        -:  823:$ gcc api-example-8-shell.c -o api-example-8-shell $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  824:```
        -:  825:
        -:  826:The application reads lines from standard input and evaluates them, one after another. To try out run:
        -:  827:
        -:  828:```
        -:  829:$ ./api-example-8-shell
        -:  830:```
        -:  831:
        -:  832:
        -:  833:## Example 9. Creating JS object in global context
        -:  834:
        -:  835:In this example (`api-example-9.c`) an object with a native function is added to the global object.
        -:  836:
        -:  837:[doctest]: # ()
        -:  838:
        -:  839:```c
        -:  840:#include "jerryscript.h"
        -:  841:#include "jerryscript-ext/handler.h"
        -:  842:
        -:  843:struct my_struct
        -:  844:{
        -:  845:  const char *msg;
        -:  846:} my_struct;
        -:  847:
        -:  848:/**
        -:  849: * Get a string from a native object
        -:  850: */
        -:  851:static jerry_value_t
    #####:  852:get_msg_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  853:                 const jerry_value_t *args_p, /**< function arguments */
        -:  854:                 const jerry_length_t args_cnt) /**< number of function arguments */
        -:  855:{
    #####:  856:  return jerry_create_string ((const jerry_char_t *) my_struct.msg);
        -:  857:} /* get_msg_handler */
        -:  858:
        -:  859:int
    #####:  860:main (void)
        -:  861:{
        -:  862:  /* Initialize engine */
    #####:  863:  jerry_init (JERRY_INIT_EMPTY);
        -:  864:
        -:  865:  /* Register 'print' function from the extensions */
    #####:  866:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -:  867:                                  jerryx_handler_print);
        -:  868:
        -:  869:  /* Do something with the native object */
    #####:  870:  my_struct.msg = "Hello, World!";
        -:  871:
        -:  872:  /* Create an empty JS object */
    #####:  873:  jerry_value_t object = jerry_create_object ();
        -:  874:
        -:  875:  /* Create a JS function object and wrap into a jerry value */
    #####:  876:  jerry_value_t func_obj = jerry_create_external_function (get_msg_handler);
        -:  877:
        -:  878:  /* Set the native function as a property of the empty JS object */
    #####:  879:  jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "myFunc");
    #####:  880:  jerry_release_value (jerry_set_property (object, prop_name, func_obj));
    #####:  881:  jerry_release_value (prop_name);
    #####:  882:  jerry_release_value (func_obj);
        -:  883:
        -:  884:  /* Wrap the JS object (not empty anymore) into a jerry api value */
    #####:  885:  jerry_value_t global_object = jerry_get_global_object ();
        -:  886:
        -:  887:  /* Add the JS object to the global context */
    #####:  888:  prop_name = jerry_create_string ((const jerry_char_t *) "MyObject");
    #####:  889:  jerry_release_value (jerry_set_property (global_object, prop_name, object));
    #####:  890:  jerry_release_value (prop_name);
    #####:  891:  jerry_release_value (object);
    #####:  892:  jerry_release_value (global_object);
        -:  893:
        -:  894:  /* Now we have a "builtin" object called MyObject with a function called myFunc()
        -:  895:   *
        -:  896:   * Equivalent JS code:
        -:  897:   *                    var MyObject = { myFunc : function () { return "some string value"; } }
        -:  898:   */
    #####:  899:  const jerry_char_t script[] = " \
        -:  900:    var str = MyObject.myFunc (); \
        -:  901:    print (str); \
        -:  902:  ";
        -:  903:
        -:  904:  /* Evaluate script */
    #####:  905:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -:  906:
        -:  907:  /* Free JavaScript value, returned by eval */
    #####:  908:  jerry_release_value (eval_ret);
        -:  909:
        -:  910:  /* Cleanup engine */
    #####:  911:  jerry_cleanup ();
        -:  912:
        -:  913:  return 0;
        -:  914:}
        -:  915:```
        -:  916:
        -:  917:To compile it one can use the following command:
        -:  918:
        -:  919:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  920:
        -:  921:```sh
        -:  922:$ gcc api-example-9.c -o api-example-9 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  923:```
        -:  924:
        -:  925:Execute the example with:
        -:  926:
        -:  927:```
        -:  928:$ ./api-example-9
        -:  929:```
        -:  930:
        -:  931:The application will generate the following output:
        -:  932:
        -:  933:```bash
        -:  934:Hello, World
        -:  935:```
        -:  936:
        -:  937:## Example 10. Extending JS Objects with native functions
        -:  938:
        -:  939:The example creates a JS Object with `jerry_eval`, then it is extended from C with a native function.
        -:  940:In addition this native function shows how to get a property value from the object and how to manipulate it.
        -:  941:
        -:  942:
        -:  943:Use the following code for `api-example-10.c`:
        -:  944:
        -:  945:[doctest]: # ()
        -:  946:
        -:  947:```c
        -:  948:#include "jerryscript.h"
        -:  949:#include "jerryscript-ext/handler.h"
        -:  950:
        -:  951:/**
        -:  952: * Add param to 'this.x'
        -:  953: */
        -:  954:static jerry_value_t
    #####:  955:add_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  956:             const jerry_value_t args_p[], /**< function arguments */
        -:  957:             const jerry_length_t args_cnt) /**< number of function arguments */
        -:  958:{
        -:  959:  /* The the 'this_val' is the 'MyObject' from the JS code below */
        -:  960:  /* Note: that the argument count check is ignored for the example's case */
        -:  961:
        -:  962:  /* Get 'this.x' */
    #####:  963:  jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "x");
    #####:  964:  jerry_value_t x_val = jerry_get_property (call_info_p->this_value, prop_name);
        -:  965:
    #####:  966:  if (!jerry_value_is_error (x_val))
        -:  967:  {
        -:  968:    /* Convert Jerry API values to double */
    #####:  969:    double x = jerry_get_number_value (x_val);
    #####:  970:    double d = jerry_get_number_value (args_p[0]);
        -:  971:
        -:  972:    /* Add the parameter to 'x' */
    #####:  973:    jerry_value_t res_val = jerry_create_number (x + d);
        -:  974:
        -:  975:    /* Set the new value of 'this.x' */
    #####:  976:    jerry_release_value (jerry_set_property (call_info_p->this_value, prop_name, res_val));
    #####:  977:    jerry_release_value (res_val);
        -:  978:  }
        -:  979:
    #####:  980:  jerry_release_value (x_val);
    #####:  981:  jerry_release_value (prop_name);
        -:  982:
    #####:  983:  return jerry_create_undefined ();
        -:  984:} /* add_handler */
        -:  985:
        -:  986:int
    #####:  987:main (void)
        -:  988:{
        -:  989:  /* Initialize engine */
    #####:  990:  jerry_init (JERRY_INIT_EMPTY);
        -:  991:
        -:  992:  /* Register 'print' function from the extensions */
    #####:  993:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -:  994:                                  jerryx_handler_print);
        -:  995:
        -:  996:  /* Create a JS object */
    #####:  997:  const jerry_char_t my_js_object[] = " \
        -:  998:    MyObject = \
        -:  999:    { x : 12, \
        -: 1000:      y : 'Value of x is ', \
        -: 1001:      foo: function () \
        -: 1002:      { \
        -: 1003:        return this.y + this.x; \
        -: 1004:      } \
        -: 1005:    } \
        -: 1006:  ";
        -: 1007:
        -: 1008:  jerry_value_t my_js_obj_val;
        -: 1009:
        -: 1010:  /* Evaluate script */
    #####: 1011:  my_js_obj_val = jerry_eval (my_js_object,
        -: 1012:                              sizeof (my_js_object) - 1,
        -: 1013:                              JERRY_PARSE_NO_OPTS);
        -: 1014:
        -: 1015:  /* Create a JS function object and wrap into a jerry value */
    #####: 1016:  jerry_value_t add_func_obj = jerry_create_external_function (add_handler);
        -: 1017:
        -: 1018:  /* Set the native function as a property of previously created MyObject */
    #####: 1019:  jerry_value_t prop_name = jerry_create_string ((const jerry_char_t *) "add2x");
    #####: 1020:  jerry_release_value (jerry_set_property (my_js_obj_val, prop_name, add_func_obj));
    #####: 1021:  jerry_release_value (add_func_obj);
    #####: 1022:  jerry_release_value (prop_name);
        -: 1023:
        -: 1024:  /* Free JavaScript value, returned by eval (my_js_object) */
    #####: 1025:  jerry_release_value (my_js_obj_val);
        -: 1026:
    #####: 1027:  const jerry_char_t script[] = " \
        -: 1028:    var str = MyObject.foo (); \
        -: 1029:    print (str); \
        -: 1030:    MyObject.add2x (5); \
        -: 1031:    print (MyObject.foo ()); \
        -: 1032:  ";
        -: 1033:
        -: 1034:  /* Evaluate script */
    #####: 1035:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -: 1036:
        -: 1037:  /* Free JavaScript value, returned by eval */
    #####: 1038:  jerry_release_value (eval_ret);
        -: 1039:
        -: 1040:  /* Cleanup engine */
    #####: 1041:  jerry_cleanup ();
        -: 1042:
        -: 1043:  return 0;
        -: 1044:}
        -: 1045:```
        -: 1046:
        -: 1047:To compile it one can use the following command:
        -: 1048:
        -: 1049:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -: 1050:
        -: 1051:```sh
        -: 1052:$ gcc api-example-10.c -o api-example-10 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -: 1053:```
        -: 1054:
        -: 1055:Execute the example with:
        -: 1056:
        -: 1057:```
        -: 1058:$ ./api-example-10
        -: 1059:```
        -: 1060:
        -: 1061:```bash
        -: 1062:Value of x is 12
        -: 1063:Value of x is 17
        -: 1064:```
        -: 1065:
        -: 1066:## Example 11. Changing the seed of pseudorandom generated numbers
        -: 1067:
        -: 1068:If you want to change the seed of `Math.random()` generated numbers, you have to initialize the seed value with `srand`.
        -: 1069:A recommended method is using `jerry_port_get_current_time()` or something based on a constantly changing value, therefore every run produces truly random numbers.
        -: 1070:
        -: 1071:[doctest]: # ()
        -: 1072:
        -: 1073:```c
        -: 1074:#include <stdlib.h>
        -: 1075:#include "jerryscript.h"
        -: 1076:#include "jerryscript-port.h"
        -: 1077:#include "jerryscript-ext/handler.h"
        -: 1078:
        -: 1079:int
    #####: 1080:main (void)
        -: 1081:{
        -: 1082:  /* Initialize srand value */
    #####: 1083:  union { double d; unsigned u; } now = { .d = jerry_port_get_current_time () };
    #####: 1084:  srand (now.u);
        -: 1085:
        -: 1086:  /* Generate a random number, and print it */
    #####: 1087:  const jerry_char_t script[] = "var a = Math.random (); print(a)";
        -: 1088:
        -: 1089:  /* Initialize the engine */
    #####: 1090:  jerry_init (JERRY_INIT_EMPTY);
        -: 1091:
        -: 1092:  /* Register the print function */
    #####: 1093:  jerryx_handler_register_global ((const jerry_char_t *) "print",
        -: 1094:                                  jerryx_handler_print);
        -: 1095:
        -: 1096:  /* Evaluate the script */
    #####: 1097:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -: 1098:
        -: 1099:  /* Free the JavaScript value returned by eval */
    #####: 1100:  jerry_release_value (eval_ret);
        -: 1101:
        -: 1102:  /* Cleanup the engine */
    #####: 1103:  jerry_cleanup ();
        -: 1104:
        -: 1105:  return 0;
        -: 1106:}
        -: 1107:```
        -: 1108:
        -: 1109:## Further steps
        -: 1110:
        -: 1111:For further API description, please visit [API Reference page](https://jerryscript-project.github.io/jerryscript/api-reference/) on [JerryScript home page](https://jerryscript-project.github.io/jerryscript/).
