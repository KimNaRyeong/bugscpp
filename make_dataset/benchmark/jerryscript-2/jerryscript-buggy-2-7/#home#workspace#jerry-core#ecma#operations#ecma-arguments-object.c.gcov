        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-arguments-object.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-builtin-helpers.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-function-object.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:#include "ecma-lex-env.h"
        -:   24:#include "ecma-objects.h"
        -:   25:#include "ecma-arguments-object.h"
        -:   26:#include "ecma-objects-general.h"
        -:   27:#include "jrt.h"
        -:   28:
        -:   29:/** \addtogroup ecma ECMA
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup ecmaargumentsobject ECMA arguments object related routines
        -:   33: * @{
        -:   34: */
        -:   35:
        -:   36:/**
        -:   37: * Arguments object creation operation.
        -:   38: *
        -:   39: * See also: ECMA-262 v5, 10.6
        -:   40: *
        -:   41: * @return ecma value of arguments object
        -:   42: *         Returned value must be freed with ecma_free_value
        -:   43: */
        -:   44:ecma_value_t
    #####:   45:ecma_op_create_arguments_object (vm_frame_ctx_shared_args_t *shared_p, /**< shared context data */
        -:   46:                                 ecma_object_t *lex_env_p) /**< lexical environment the Arguments
        -:   47:                                                            *   object is created for */
        -:   48:{
    #####:   49:  ecma_object_t *func_obj_p = shared_p->header.function_object_p;
    #####:   50:  const ecma_compiled_code_t *bytecode_data_p = shared_p->header.bytecode_header_p;
        -:   51:  uint16_t formal_params_number;
        -:   52:
    #####:   53:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:   54:  {
    #####:   55:    formal_params_number = ((cbc_uint16_arguments_t *) bytecode_data_p)->argument_end;
        -:   56:  }
        -:   57:  else
        -:   58:  {
    #####:   59:    formal_params_number = ((cbc_uint8_arguments_t *) bytecode_data_p)->argument_end;
        -:   60:  }
        -:   61:
    #####:   62:  uint32_t object_size = sizeof (ecma_unmapped_arguments_t);
    #####:   63:  uint32_t saved_arg_count = JERRY_MAX (shared_p->arg_list_len, formal_params_number);
        -:   64:
    #####:   65:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:   66:  {
    #####:   67:    object_size = sizeof (ecma_mapped_arguments_t);
        -:   68:  }
        -:   69:
    #####:   70:  ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
    #####:   71:                                             object_size + (saved_arg_count * sizeof (ecma_value_t)),
        -:   72:                                             ECMA_OBJECT_TYPE_CLASS);
        -:   73:
    #####:   74:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) obj_p;
        -:   75:
    #####:   76:  arguments_p->header.u.cls.type = ECMA_OBJECT_CLASS_ARGUMENTS;
    #####:   77:  arguments_p->header.u.cls.u1.arguments_flags = ECMA_ARGUMENTS_OBJECT_NO_FLAGS;
    #####:   78:  arguments_p->header.u.cls.u2.formal_params_number = formal_params_number;
    #####:   79:  arguments_p->header.u.cls.u3.arguments_number = 0;
    #####:   80:  arguments_p->callee = ecma_make_object_value (func_obj_p);
        -:   81:
    #####:   82:  ecma_value_t *argv_p = (ecma_value_t *) (((uint8_t *) obj_p) + object_size);
        -:   83:
    #####:   84:  for (uint32_t i = 0; i < shared_p->arg_list_len; i++)
        -:   85:  {
    #####:   86:    argv_p[i] = ecma_copy_value_if_not_object (shared_p->arg_list_p[i]);
        -:   87:  }
        -:   88:
    #####:   89:  for (uint32_t i = shared_p->arg_list_len; i < saved_arg_count; i++)
        -:   90:  {
    #####:   91:    argv_p[i] = ECMA_VALUE_UNDEFINED;
        -:   92:  }
        -:   93:
    #####:   94:  arguments_p->header.u.cls.u3.arguments_number = shared_p->arg_list_len;
        -:   95:
    #####:   96:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:   97:  {
    #####:   98:    ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) obj_p;
        -:   99:
    #####:  100:    ECMA_SET_INTERNAL_VALUE_POINTER (mapped_arguments_p->lex_env, lex_env_p);
    #####:  101:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_MAPPED;
        -:  102:
        -:  103:#if JERRY_SNAPSHOT_EXEC
    #####:  104:    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)
        -:  105:    {
    #####:  106:      arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_STATIC_BYTECODE;
    #####:  107:      mapped_arguments_p->u.byte_code_p = (ecma_compiled_code_t *) bytecode_data_p;
        -:  108:    }
        -:  109:    else
        -:  110:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  111:    {
    #####:  112:      ECMA_SET_INTERNAL_VALUE_POINTER (mapped_arguments_p->u.byte_code, bytecode_data_p);
        -:  113:    }
        -:  114:
        -:  115:    /* Static snapshots are not ref counted. */
    #####:  116:    if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION) == 0)
        -:  117:    {
    #####:  118:      ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);
        -:  119:    }
        -:  120:
        -:  121:    ecma_value_t *formal_parameter_start_p;
    #####:  122:    formal_parameter_start_p = ecma_compiled_code_resolve_arguments_start ((ecma_compiled_code_t *) bytecode_data_p);
        -:  123:
    #####:  124:    for (uint32_t i = 0; i < formal_params_number; i++)
        -:  125:    {
        -:  126:      /* For legacy (non-strict) argument definition the trailing duplicated arguments cannot be lazy instantiated
        -:  127:         E.g: function f (a,a,a,a) {} */
    #####:  128:      if (JERRY_UNLIKELY (ecma_is_value_empty (formal_parameter_start_p[i])))
        -:  129:      {
        -:  130:        ecma_property_value_t *prop_value_p;
    #####:  131:        ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -:  132:
    #####:  133:        prop_value_p = ecma_create_named_data_property (obj_p,
        -:  134:                                                        prop_name_p,
        -:  135:                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  136:                                                        NULL);
        -:  137:
    #####:  138:        ecma_deref_ecma_string (prop_name_p);
        -:  139:
    #####:  140:        prop_value_p->value = argv_p[i];
    #####:  141:        argv_p[i] = ECMA_VALUE_EMPTY;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
    #####:  146:  return ecma_make_object_value (obj_p);
        -:  147:} /* ecma_op_create_arguments_object */
        -:  148:
        -:  149:/**
        -:  150: * [[DefineOwnProperty]] ecma Arguments object's operation
        -:  151: *
        -:  152: * See also:
        -:  153: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  154: *          ECMA-262 v5, 10.6
        -:  155: *
        -:  156: * @return ecma value
        -:  157: *         Returned value must be freed with ecma_free_value
        -:  158: */
        -:  159:ecma_value_t
    #####:  160:ecma_op_arguments_object_define_own_property (ecma_object_t *object_p, /**< the object */
        -:  161:                                              ecma_string_t *property_name_p, /**< property name */
        -:  162:                                              const ecma_property_descriptor_t *property_desc_p) /**< property
        -:  163:                                                                                                  *   descriptor */
        -:  164:{
        -:  165:  /* 3. */
    #####:  166:  ecma_value_t ret_value = ecma_op_general_object_define_own_property (object_p,
        -:  167:                                                                       property_name_p,
        -:  168:                                                                       property_desc_p);
        -:  169:
    #####:  170:  if (ECMA_IS_VALUE_ERROR (ret_value)
    #####:  171:      || !(((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  172:  {
    #####:  173:    return ret_value;
        -:  174:  }
        -:  175:
    #####:  176:  ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) object_p;
    #####:  177:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  178:
    #####:  179:  if (index >= mapped_arguments_p->unmapped.header.u.cls.u2.formal_params_number)
        -:  180:  {
    #####:  181:    return ret_value;
        -:  182:  }
        -:  183:
    #####:  184:  ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  185:
    #####:  186:  if (ecma_is_value_empty (argv_p[index]) || argv_p[index] == ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  187:  {
    #####:  188:    return ret_value;
        -:  189:  }
        -:  190:
    #####:  191:  if (property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -:  192:  {
    #####:  193:    ecma_free_value_if_not_object (argv_p[index]);
    #####:  194:    argv_p[index] = ECMA_VALUE_ARGUMENT_NO_TRACK;
    #####:  195:    return ret_value;
        -:  196:  }
        -:  197:
    #####:  198:  if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -:  199:  {
    #####:  200:    ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  201:    ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  202:
    #####:  203:    ecma_value_t completion = ecma_op_set_mutable_binding (lex_env_p,
        -:  204:                                                           name_p,
        -:  205:                                                           property_desc_p->value,
        -:  206:                                                           true);
        -:  207:
    #####:  208:    JERRY_ASSERT (ecma_is_value_empty (completion));
        -:  209:  }
        -:  210:
    #####:  211:  if ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
    #####:  212:      && !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE))
        -:  213:  {
    #####:  214:    ecma_free_value_if_not_object (argv_p[index]);
    #####:  215:    argv_p[index] = ECMA_VALUE_ARGUMENT_NO_TRACK;
        -:  216:  }
        -:  217:
    #####:  218:  return ret_value;
        -:  219:} /* ecma_op_arguments_object_define_own_property */
        -:  220:
        -:  221:/**
        -:  222: * Try to lazy instantiate the given property of a mapped/unmapped arguments object
        -:  223: *
        -:  224: * @return pointer property, if one was instantiated,
        -:  225: *         NULL - otherwise.
        -:  226: */
        -:  227:ecma_property_t *
    #####:  228:ecma_op_arguments_object_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */
        -:  229:                                                           ecma_string_t *property_name_p) /**< property's name */
        -:  230:{
    #####:  231:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARGUMENTS));
        -:  232:
    #####:  233:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) object_p;
    #####:  234:  ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  235:  ecma_property_value_t *prop_value_p;
    #####:  236:  ecma_property_t *prop_p;
    #####:  237:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
    #####:  238:  uint8_t flags = arguments_p->header.u.cls.u1.arguments_flags;
        -:  239:
    #####:  240:  if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  241:  {
    #####:  242:    argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) object_p) + 1);
        -:  243:  }
        -:  244:
    #####:  245:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  246:
    #####:  247:  if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  248:  {
    #####:  249:    if (index >= arguments_number
    #####:  250:        || ecma_is_value_empty (argv_p[index]))
        -:  251:    {
    #####:  252:      return NULL;
        -:  253:    }
        -:  254:
    #####:  255:    JERRY_ASSERT (argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK);
        -:  256:
    #####:  257:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  258:                                                    property_name_p,
        -:  259:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  260:                                                    &prop_p);
        -:  261:
        -:  262:    /* Passing the reference */
    #####:  263:    prop_value_p->value = argv_p[index];
        -:  264:
    #####:  265:    argv_p[index] = ECMA_VALUE_UNDEFINED;
    #####:  266:    return prop_p;
        -:  267:  }
        -:  268:
    #####:  269:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH)
    #####:  270:      && !(flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED))
        -:  271:  {
    #####:  272:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  273:                                                    ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  274:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  275:                                                    &prop_p);
        -:  276:
    #####:  277:    prop_value_p->value = ecma_make_uint32_value (arguments_number);
    #####:  278:    return prop_p;
        -:  279:  }
        -:  280:
    #####:  281:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_CALLEE)
    #####:  282:      && !(flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED))
        -:  283:  {
    #####:  284:    if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  285:    {
    #####:  286:      prop_value_p = ecma_create_named_data_property (object_p,
        -:  287:                                                      property_name_p,
        -:  288:                                                      ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  289:                                                      &prop_p);
        -:  290:
    #####:  291:      prop_value_p->value = arguments_p->callee;
        -:  292:    }
        -:  293:    else
        -:  294:    {
    #####:  295:      ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);
        -:  296:
    #####:  297:      ecma_create_named_accessor_property (object_p,
        -:  298:                                           ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),
        -:  299:                                           thrower_p,
        -:  300:                                           thrower_p,
        -:  301:                                           ECMA_PROPERTY_BUILT_IN_FIXED,
        -:  302:                                           &prop_p);
        -:  303:    }
    #####:  304:    return prop_p;
        -:  305:  }
        -:  306:
        -:  307:#if !JERRY_ESNEXT
    #####:  308:  if (property_name_p == ecma_get_magic_string (LIT_MAGIC_STRING_CALLER))
        -:  309:  {
    #####:  310:    if (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  311:    {
        -:  312:      return NULL;
        -:  313:    }
        -:  314:
    #####:  315:    ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);
        -:  316:
    #####:  317:    ecma_create_named_accessor_property (object_p,
        -:  318:                                         ecma_get_magic_string (LIT_MAGIC_STRING_CALLER),
        -:  319:                                         thrower_p,
        -:  320:                                         thrower_p,
        -:  321:                                         ECMA_PROPERTY_BUILT_IN_FIXED,
        -:  322:                                         &prop_p);
    #####:  323:    return prop_p;
        -:  324:  }
        -:  325:#else /* JERRY_ESNEXT */
    #####:  326:  if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_ITERATOR)
    #####:  327:      && !(flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED))
        -:  328:  {
    #####:  329:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  330:                                                    property_name_p,
        -:  331:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  332:                                                    &prop_p);
        -:  333:
    #####:  334:    prop_value_p->value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),
        -:  335:                                                          LIT_INTERNAL_MAGIC_STRING_ARRAY_PROTOTYPE_VALUES);
        -:  336:
    #####:  337:    JERRY_ASSERT (ecma_is_value_object (prop_value_p->value));
    #####:  338:    ecma_deref_object (ecma_get_object_from_value (prop_value_p->value));
    #####:  339:    return prop_p;
        -:  340:  }
        -:  341:#endif /* !JERRY_ESNEXT */
        -:  342:
    #####:  343:  return NULL;
        -:  344:} /* ecma_op_arguments_object_try_to_lazy_instantiate_property */
        -:  345:
        -:  346:/**
        -:  347: * Delete configurable properties of arguments object
        -:  348: */
        -:  349:void
    #####:  350:ecma_op_arguments_delete_built_in_property (ecma_object_t *object_p, /**< the object */
        -:  351:                                            ecma_string_t *property_name_p) /**< property name */
        -:  352:{
    #####:  353:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) object_p;
        -:  354:
    #####:  355:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))
        -:  356:  {
    #####:  357:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED));
        -:  358:
    #####:  359:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED;
    #####:  360:    return;
        -:  361:  }
        -:  362:
    #####:  363:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_CALLEE))
        -:  364:  {
    #####:  365:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED));
    #####:  366:    JERRY_ASSERT (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED);
        -:  367:
    #####:  368:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED;
    #####:  369:    return;
        -:  370:  }
        -:  371:
        -:  372:#if JERRY_ESNEXT
    #####:  373:  if (ecma_prop_name_is_symbol (property_name_p))
        -:  374:  {
    #####:  375:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED));
    #####:  376:    JERRY_ASSERT (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_ITERATOR));
        -:  377:
    #####:  378:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED;
    #####:  379:    return;
        -:  380:  }
        -:  381:#endif /* JERRY_ESNEXT */
        -:  382:
    #####:  383:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  384:
    #####:  385:  ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  386:
    #####:  387:  if (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  388:  {
    #####:  389:    argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) object_p) + 1);
        -:  390:  }
        -:  391:
    #####:  392:  JERRY_ASSERT (argv_p[index] == ECMA_VALUE_UNDEFINED
        -:  393:                || argv_p[index] == ECMA_VALUE_ARGUMENT_NO_TRACK);
        -:  394:
    #####:  395:  argv_p[index] = ECMA_VALUE_EMPTY;
        -:  396:} /* ecma_op_arguments_delete_built_in_property */
        -:  397:
        -:  398:/**
        -:  399: * List names of an arguments object's lazy instantiated properties
        -:  400: */
        -:  401:void
    #####:  402:ecma_op_arguments_object_list_lazy_property_names (ecma_object_t *obj_p, /**< arguments object */
        -:  403:                                                   ecma_collection_t *prop_names_p, /**< prop name collection */
        -:  404:                                                   ecma_property_counter_t *prop_counter_p, /**< property counters */
        -:  405:                                                   jerry_property_filter_t filter) /**< property name filter options */
        -:  406:{
    #####:  407:  JERRY_ASSERT (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_ARGUMENTS));
        -:  408:
    #####:  409:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) obj_p;
        -:  410:
    #####:  411:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
    #####:  412:  uint8_t flags = arguments_p->header.u.cls.u1.arguments_flags;
        -:  413:
    #####:  414:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -:  415:  {
    #####:  416:    ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  417:
    #####:  418:    if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  419:    {
    #####:  420:      argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) obj_p) + 1);
        -:  421:    }
        -:  422:
    #####:  423:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  424:    {
    #####:  425:      if (!ecma_is_value_empty (argv_p[index]))
        -:  426:      {
    #####:  427:        ecma_string_t *index_string_p = ecma_new_ecma_string_from_uint32 (index);
    #####:  428:        ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_string_p));
    #####:  429:        prop_counter_p->array_index_named_props++;
        -:  430:      }
        -:  431:    }
        -:  432:  }
        -:  433:
    #####:  434:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -:  435:  {
    #####:  436:    if (!(flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED))
        -:  437:    {
    #####:  438:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####:  439:      prop_counter_p->string_named_props++;
        -:  440:    }
        -:  441:
    #####:  442:    if (!(flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED))
        -:  443:    {
    #####:  444:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_CALLEE));
    #####:  445:      prop_counter_p->string_named_props++;
        -:  446:    }
        -:  447:
        -:  448:#if !JERRY_ESNEXT
    #####:  449:    if (!(flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  450:    {
    #####:  451:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_CALLER));
    #####:  452:      prop_counter_p->string_named_props++;
        -:  453:    }
        -:  454:#endif /* !JERRY_ESNEXT */
        -:  455:  }
        -:  456:
        -:  457:#if JERRY_ESNEXT
    #####:  458:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
    #####:  459:      && !(flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED))
        -:  460:  {
    #####:  461:    ecma_string_t *symbol_p = ecma_op_get_global_symbol (LIT_GLOBAL_SYMBOL_ITERATOR);
    #####:  462:    ecma_collection_push_back (prop_names_p, ecma_make_symbol_value (symbol_p));
    #####:  463:    prop_counter_p->symbol_named_props++;
        -:  464:  }
        -:  465:#endif /* JERRY_ESNEXT */
    #####:  466:} /* ecma_op_arguments_object_list_lazy_property_names */
        -:  467:
        -:  468:/**
        -:  469: * Get the formal parameter name corresponding to the given property index
        -:  470: *
        -:  471: * @return pointer to the formal parameter name
        -:  472: */
        -:  473:ecma_string_t *
    #####:  474:ecma_op_arguments_object_get_formal_parameter (ecma_mapped_arguments_t *mapped_arguments_p, /**< mapped arguments
        -:  475:                                                                                             *   object */
        -:  476:                                               uint32_t index) /**< formal parameter index */
        -:  477:{
    #####:  478:  JERRY_ASSERT (mapped_arguments_p->unmapped.header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED);
    #####:  479:  JERRY_ASSERT (index < mapped_arguments_p->unmapped.header.u.cls.u2.formal_params_number);
        -:  480:
        -:  481:  ecma_compiled_code_t *byte_code_p;
        -:  482:
        -:  483:#if JERRY_SNAPSHOT_EXEC
    #####:  484:  if (mapped_arguments_p->unmapped.header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_STATIC_BYTECODE)
        -:  485:  {
    #####:  486:    byte_code_p = mapped_arguments_p->u.byte_code_p;
        -:  487:  }
        -:  488:  else
        -:  489:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  490:  {
    #####:  491:    byte_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, mapped_arguments_p->u.byte_code);
        -:  492:  }
        -:  493:
    #####:  494:  ecma_value_t *formal_param_names_p = ecma_compiled_code_resolve_arguments_start (byte_code_p);
        -:  495:
    #####:  496:  return ecma_get_string_from_value (formal_param_names_p[index]);
        -:  497:} /* ecma_op_arguments_object_get_formal_parameter */
        -:  498:
        -:  499:/**
        -:  500: * @}
        -:  501: * @}
        -:  502: */
