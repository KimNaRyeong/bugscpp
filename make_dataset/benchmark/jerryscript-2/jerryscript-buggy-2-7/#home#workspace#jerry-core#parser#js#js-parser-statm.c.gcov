        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-statm.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:#include "jcontext.h"
        -:   20:
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:/** \addtogroup parser Parser
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup jsparser JavaScript
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup jsparser_stmt Statement parser
        -:   31: * @{
        -:   32: */
        -:   33:
        -:   34:/**
        -:   35: * Parser statement types.
        -:   36: *
        -:   37: * When a new statement is added, the following
        -:   38: * arrays must be updated as well:
        -:   39: *  - statement_lengths[]
        -:   40: *  - parser_statement_flags[]
        -:   41: */
        -:   42:typedef enum
        -:   43:{
        -:   44:  PARSER_STATEMENT_START,
        -:   45:  PARSER_STATEMENT_BLOCK,
        -:   46:#if JERRY_ESNEXT
        -:   47:  PARSER_STATEMENT_BLOCK_SCOPE,
        -:   48:  PARSER_STATEMENT_PRIVATE_SCOPE,
        -:   49:  PARSER_STATEMENT_BLOCK_CONTEXT,
        -:   50:  PARSER_STATEMENT_PRIVATE_CONTEXT,
        -:   51:#endif /* JERRY_ESNEXT */
        -:   52:  PARSER_STATEMENT_LABEL,
        -:   53:  PARSER_STATEMENT_IF,
        -:   54:  PARSER_STATEMENT_ELSE,
        -:   55:  PARSER_STATEMENT_SWITCH,
        -:   56:  PARSER_STATEMENT_SWITCH_NO_DEFAULT,
        -:   57:  PARSER_STATEMENT_DO_WHILE,
        -:   58:  PARSER_STATEMENT_WHILE,
        -:   59:  PARSER_STATEMENT_FOR,
        -:   60:  PARSER_STATEMENT_FOR_IN,
        -:   61:#if JERRY_ESNEXT
        -:   62:  PARSER_STATEMENT_FOR_OF,
        -:   63:  PARSER_STATEMENT_FOR_AWAIT_OF,
        -:   64:#endif /* JERRY_ESNEXT */
        -:   65:  PARSER_STATEMENT_WITH,
        -:   66:  PARSER_STATEMENT_TRY,
        -:   67:} parser_statement_type_t;
        -:   68:
        -:   69:/**
        -:   70: * Parser statement type flags.
        -:   71: */
        -:   72:typedef enum
        -:   73:{
        -:   74:  PARSER_STATM_NO_OPTS = 0, /**< no options */
        -:   75:  PARSER_STATM_SINGLE_STATM = (1 << 0), /**< statment can form single statement context */
        -:   76:  PARSER_STATM_HAS_BLOCK = (1 << 1), /**< statement always has a code block */
        -:   77:  PARSER_STATM_BREAK_TARGET = (1 << 2), /**< break target statement */
        -:   78:  PARSER_STATM_CONTINUE_TARGET = (1 << 3), /**< continue target statement */
        -:   79:  PARSER_STATM_CONTEXT_BREAK = (1 << 4), /**< uses another instruction form when crosses their borders */
        -:   80:} parser_statement_flags_t;
        -:   81:
        -:   82:/**
        -:   83: * Parser statement attributes.
        -:   84: * Note: the order of the attributes must be keep in sync with parser_statement_type_t
        -:   85: */
        -:   86:static const uint8_t parser_statement_flags[] =
        -:   87:{
        -:   88:  /* PARSER_STATEMENT_START */
        -:   89:  PARSER_STATM_HAS_BLOCK,
        -:   90:  /* PARSER_STATEMENT_BLOCK, */
        -:   91:  PARSER_STATM_HAS_BLOCK,
        -:   92:#if JERRY_ESNEXT
        -:   93:  /* PARSER_STATEMENT_BLOCK_SCOPE, */
        -:   94:  PARSER_STATM_HAS_BLOCK,
        -:   95:  /* PARSER_STATEMENT_PRIVATE_SCOPE, */
        -:   96:  PARSER_STATM_NO_OPTS,
        -:   97:  /* PARSER_STATEMENT_BLOCK_CONTEXT, */
        -:   98:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_CONTEXT_BREAK,
        -:   99:  /* PARSER_STATEMENT_PRIVATE_CONTEXT, */
        -:  100:  PARSER_STATM_CONTEXT_BREAK,
        -:  101:#endif /* JERRY_ESNEXT */
        -:  102:  /* PARSER_STATEMENT_LABEL */
        -:  103:  PARSER_STATM_SINGLE_STATM,
        -:  104:  /* PARSER_STATEMENT_IF */
        -:  105:  PARSER_STATM_SINGLE_STATM,
        -:  106:  /* PARSER_STATEMENT_ELSE */
        -:  107:  PARSER_STATM_SINGLE_STATM,
        -:  108:  /* PARSER_STATEMENT_SWITCH */
        -:  109:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_BREAK_TARGET,
        -:  110:  /* PARSER_STATEMENT_SWITCH_NO_DEFAULT */
        -:  111:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_BREAK_TARGET,
        -:  112:  /* PARSER_STATEMENT_DO_WHILE */
        -:  113:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  114:  /* PARSER_STATEMENT_WHILE */
        -:  115:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  116:  /* PARSER_STATEMENT_FOR */
        -:  117:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  118:  /* PARSER_STATEMENT_FOR_IN */
        -:  119:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  120:#if JERRY_ESNEXT
        -:  121:  /* PARSER_STATEMENT_FOR_OF */
        -:  122:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  123:  /* PARSER_STATEMENT_FOR_AWAIT_OF */
        -:  124:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  125:#endif /* JERRY_ESNEXT */
        -:  126:  /* PARSER_STATEMENT_WITH */
        -:  127:  PARSER_STATM_CONTEXT_BREAK | PARSER_STATM_SINGLE_STATM,
        -:  128:  /* PARSER_STATEMENT_TRY */
        -:  129:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_CONTEXT_BREAK
        -:  130:};
        -:  131:
        -:  132:#if JERRY_ESNEXT
        -:  133:/**
        -:  134: * Block statement.
        -:  135: */
        -:  136:typedef struct
        -:  137:{
        -:  138:  uint16_t scope_stack_top;               /**< preserved top of scope stack */
        -:  139:  uint16_t scope_stack_reg_top;           /**< preserved top register of scope stack */
        -:  140:} parser_block_statement_t;
        -:  141:
        -:  142:/**
        -:  143: * Context of block statement.
        -:  144: */
        -:  145:typedef struct
        -:  146:{
        -:  147:  parser_branch_t branch;                 /**< branch to the end */
        -:  148:} parser_block_context_t;
        -:  149:
        -:  150:#endif /* !JERRY_ESNEXT */
        -:  151:
        -:  152:/**
        -:  153: * Loop statement.
        -:  154: */
        -:  155:typedef struct
        -:  156:{
        -:  157:  parser_branch_node_t *branch_list_p;    /**< list of breaks and continues targeting this statement */
        -:  158:} parser_loop_statement_t;
        -:  159:
        -:  160:/**
        -:  161: * Label statement.
        -:  162: */
        -:  163:typedef struct
        -:  164:{
        -:  165:  lexer_lit_location_t label_ident;       /**< name of the label */
        -:  166:  parser_branch_node_t *break_list_p;     /**< list of breaks targeting this label */
        -:  167:} parser_label_statement_t;
        -:  168:
        -:  169:/**
        -:  170: * If/else statement.
        -:  171: */
        -:  172:typedef struct
        -:  173:{
        -:  174:  parser_branch_t branch;                 /**< branch to the end */
        -:  175:} parser_if_else_statement_t;
        -:  176:
        -:  177:/**
        -:  178: * Switch statement.
        -:  179: */
        -:  180:typedef struct
        -:  181:{
        -:  182:  parser_branch_t default_branch;         /**< branch to the default case */
        -:  183:  parser_branch_node_t *branch_list_p;    /**< branches of case statements */
        -:  184:} parser_switch_statement_t;
        -:  185:
        -:  186:/**
        -:  187: * Do-while statement.
        -:  188: */
        -:  189:typedef struct
        -:  190:{
        -:  191:  uint32_t start_offset;                  /**< start byte code offset */
        -:  192:} parser_do_while_statement_t;
        -:  193:
        -:  194:/**
        -:  195: * While statement.
        -:  196: */
        -:  197:typedef struct
        -:  198:{
        -:  199:  parser_branch_t branch;                 /**< branch to the end */
        -:  200:  scanner_location_t condition_location;  /**< condition part */
        -:  201:  uint32_t start_offset;                  /**< start byte code offset */
        -:  202:} parser_while_statement_t;
        -:  203:
        -:  204:/**
        -:  205: * For statement.
        -:  206: */
        -:  207:typedef struct
        -:  208:{
        -:  209:  parser_branch_t branch;                 /**< branch to the end */
        -:  210:  scanner_location_t condition_location;  /**< condition part */
        -:  211:  scanner_location_t expression_location; /**< expression part */
        -:  212:  uint32_t start_offset;                  /**< start byte code offset */
        -:  213:} parser_for_statement_t;
        -:  214:
        -:  215:/**
        -:  216: * For-in statement.
        -:  217: */
        -:  218:typedef struct
        -:  219:{
        -:  220:  parser_branch_t branch;                 /**< branch to the end */
        -:  221:  uint32_t start_offset;                  /**< start byte code offset */
        -:  222:} parser_for_in_of_statement_t;
        -:  223:
        -:  224:/**
        -:  225: * With statement.
        -:  226: */
        -:  227:typedef struct
        -:  228:{
        -:  229:  parser_branch_t branch;                 /**< branch to the end */
        -:  230:} parser_with_statement_t;
        -:  231:
        -:  232:/**
        -:  233: * Lexer token types.
        -:  234: */
        -:  235:typedef enum
        -:  236:{
        -:  237:  parser_try_block,                       /**< try block */
        -:  238:  parser_catch_block,                     /**< catch block */
        -:  239:  parser_finally_block,                   /**< finally block */
        -:  240:} parser_try_block_type_t;
        -:  241:
        -:  242:/**
        -:  243: * Try statement.
        -:  244: */
        -:  245:typedef struct
        -:  246:{
        -:  247:  parser_try_block_type_t type;           /**< current block type */
        -:  248:  uint16_t scope_stack_top;               /**< current top of scope stack */
        -:  249:  uint16_t scope_stack_reg_top;           /**< current top register of scope stack */
        -:  250:  parser_branch_t branch;                 /**< branch to the end of the current block */
        -:  251:} parser_try_statement_t;
        -:  252:
        -:  253:/**
        -:  254: * Returns the data consumed by a statement. It can be used
        -:  255: * to skip undesired frames on the stack during frame search.
        -:  256: *
        -:  257: * @return size consumed by a statement.
        -:  258: */
        -:  259:static inline size_t
    #####:  260:parser_statement_length (uint8_t type) /**< type of statement */
        -:  261:{
        -:  262:  static const uint8_t statement_lengths[] =
        -:  263:  {
        -:  264:    /* PARSER_STATEMENT_BLOCK */
        -:  265:    1,
        -:  266:#if JERRY_ESNEXT
        -:  267:    /* PARSER_STATEMENT_BLOCK_SCOPE */
        -:  268:    (uint8_t) (sizeof (parser_block_statement_t) + 1),
        -:  269:    /* PARSER_STATEMENT_PRIVATE_SCOPE */
        -:  270:    (uint8_t) (sizeof (parser_block_statement_t) + 1),
        -:  271:    /* PARSER_STATEMENT_BLOCK_CONTEXT */
        -:  272:    (uint8_t) (sizeof (parser_block_statement_t) + sizeof (parser_block_context_t) + 1),
        -:  273:    /* PARSER_STATEMENT_PRIVATE_CONTEXT */
        -:  274:    (uint8_t) (sizeof (parser_block_statement_t) + sizeof (parser_block_context_t) + 1),
        -:  275:#endif /* JERRY_ESNEXT */
        -:  276:    /* PARSER_STATEMENT_LABEL */
        -:  277:    (uint8_t) (sizeof (parser_label_statement_t) + 1),
        -:  278:    /* PARSER_STATEMENT_IF */
        -:  279:    (uint8_t) (sizeof (parser_if_else_statement_t) + 1),
        -:  280:    /* PARSER_STATEMENT_ELSE */
        -:  281:    (uint8_t) (sizeof (parser_if_else_statement_t) + 1),
        -:  282:    /* PARSER_STATEMENT_SWITCH */
        -:  283:    (uint8_t) (sizeof (parser_switch_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  284:    /* PARSER_STATEMENT_SWITCH_NO_DEFAULT */
        -:  285:    (uint8_t) (sizeof (parser_switch_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  286:    /* PARSER_STATEMENT_DO_WHILE */
        -:  287:    (uint8_t) (sizeof (parser_do_while_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  288:    /* PARSER_STATEMENT_WHILE */
        -:  289:    (uint8_t) (sizeof (parser_while_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  290:    /* PARSER_STATEMENT_FOR */
        -:  291:    (uint8_t) (sizeof (parser_for_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  292:    /* PARSER_STATEMENT_FOR_IN */
        -:  293:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  294:#if JERRY_ESNEXT
        -:  295:    /* PARSER_STATEMENT_FOR_OF */
        -:  296:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  297:    /* PARSER_STATEMENT_FOR_AWAIT_OF */
        -:  298:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  299:#endif /* JERRY_ESNEXT */
        -:  300:    /* PARSER_STATEMENT_WITH */
        -:  301:    (uint8_t) (sizeof (parser_with_statement_t) + 1 + 1),
        -:  302:    /* PARSER_STATEMENT_TRY */
        -:  303:    (uint8_t) (sizeof (parser_try_statement_t) + 1),
        -:  304:  };
        -:  305:
    #####:  306:  JERRY_ASSERT (type >= PARSER_STATEMENT_BLOCK && type <= PARSER_STATEMENT_TRY);
        -:  307:
    #####:  308:  return statement_lengths[type - PARSER_STATEMENT_BLOCK];
        -:  309:} /* parser_statement_length */
        -:  310:/**
        -:  311: * Parse expression enclosed in parens.
        -:  312: */
        -:  313:static inline void
    #####:  314:parser_parse_enclosed_expr (parser_context_t *context_p) /**< context */
        -:  315:{
    #####:  316:  lexer_next_token (context_p);
        -:  317:
    #####:  318:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -:  319:  {
    #####:  320:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -:  321:  }
        -:  322:
    #####:  323:  lexer_next_token (context_p);
    #####:  324:  parser_parse_expression (context_p, PARSE_EXPR);
        -:  325:
    #####:  326:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  327:  {
    #####:  328:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -:  329:  }
    #####:  330:  lexer_next_token (context_p);
    #####:  331:} /* parser_parse_enclosed_expr */
        -:  332:
        -:  333:#if JERRY_ESNEXT
        -:  334:
        -:  335:/**
        -:  336: * Create a block context.
        -:  337: *
        -:  338: * @return true - when a context is created, false - otherwise
        -:  339: */
        -:  340:static bool
    #####:  341:parser_push_block_context (parser_context_t *context_p, /**< context */
        -:  342:                           bool is_private) /**< is private (bound to a statement) context */
        -:  343:{
    #####:  344:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -:  345:
    #####:  346:  parser_block_statement_t block_statement;
    #####:  347:  block_statement.scope_stack_top = context_p->scope_stack_top;
    #####:  348:  block_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -:  349:
    #####:  350:  bool is_context_needed = false;
        -:  351:
    #####:  352:  if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -:  353:  {
    #####:  354:    parser_block_context_t block_context;
        -:  355:
        -:  356:#ifndef JERRY_NDEBUG
    #####:  357:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  358:#endif /* !JERRY_NDEBUG */
        -:  359:
    #####:  360:    parser_emit_cbc_forward_branch (context_p,
        -:  361:                                    CBC_BLOCK_CREATE_CONTEXT,
        -:  362:                                    &block_context.branch);
    #####:  363:    parser_stack_push (context_p, &block_context, sizeof (parser_block_context_t));
    #####:  364:    is_context_needed = true;
        -:  365:  }
        -:  366:
    #####:  367:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
    #####:  368:  parser_stack_push (context_p, &block_statement, sizeof (parser_block_statement_t));
        -:  369:
        -:  370:  uint8_t statement_type;
        -:  371:
    #####:  372:  if (is_private)
        -:  373:  {
    #####:  374:    statement_type = (is_context_needed ? PARSER_STATEMENT_PRIVATE_CONTEXT : PARSER_STATEMENT_PRIVATE_SCOPE);
        -:  375:  }
        -:  376:  else
        -:  377:  {
    #####:  378:    statement_type = (is_context_needed ? PARSER_STATEMENT_BLOCK_CONTEXT : PARSER_STATEMENT_BLOCK_SCOPE);
        -:  379:  }
        -:  380:
    #####:  381:  parser_stack_push_uint8 (context_p, statement_type);
        -:  382:
    #####:  383:  return is_context_needed;
        -:  384:} /* parser_push_block_context */
        -:  385:
        -:  386:/**
        -:  387: * Pop block context.
        -:  388: */
        -:  389:static void
    #####:  390:parser_pop_block_context (parser_context_t *context_p) /**< context */
        -:  391:{
    #####:  392:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE
        -:  393:                || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        -:  394:                || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT
        -:  395:                || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT);
        -:  396:
    #####:  397:  uint8_t type = context_p->stack_top_uint8;
        -:  398:
    #####:  399:  parser_block_statement_t block_statement;
        -:  400:
    #####:  401:  parser_stack_pop_uint8 (context_p);
    #####:  402:  parser_stack_pop (context_p, &block_statement, sizeof (parser_block_statement_t));
        -:  403:
    #####:  404:  context_p->scope_stack_top = block_statement.scope_stack_top;
    #####:  405:  context_p->scope_stack_reg_top = block_statement.scope_stack_reg_top;
        -:  406:
    #####:  407:  if (type == PARSER_STATEMENT_BLOCK_CONTEXT || type == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -:  408:  {
    #####:  409:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  410:#ifndef JERRY_NDEBUG
    #####:  411:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  412:#endif /* !JERRY_NDEBUG */
        -:  413:
    #####:  414:    parser_block_context_t block_context;
    #####:  415:    parser_stack_pop (context_p, &block_context, sizeof (parser_block_context_t));
        -:  416:
    #####:  417:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####:  418:    parser_set_branch_to_current_position (context_p, &block_context.branch);
        -:  419:  }
        -:  420:
    #####:  421:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  422:} /* parser_pop_block_context */
        -:  423:
        -:  424:/**
        -:  425: * Validate lexical context for a declaration.
        -:  426: */
        -:  427:static void
    #####:  428:parser_validate_lexical_context (parser_context_t *context_p) /**< context */
        -:  429:{
    #####:  430:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_LET
        -:  431:                || context_p->token.type == LEXER_KEYW_CONST
        -:  432:                || context_p->token.type == LEXER_KEYW_CLASS);
        -:  433:
    #####:  434:  if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -:  435:  {
    #####:  436:    parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  437:  }
    #####:  438:} /* parser_validate_lexical_context */
        -:  439:#endif /* JERRY_ESNEXT */
        -:  440:
        -:  441:/**
        -:  442: * Parse var statement.
        -:  443: */
        -:  444:static void
        3:  445:parser_parse_var_statement (parser_context_t *context_p) /**< context */
        -:  446:{
        3:  447:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_VAR
        -:  448:                || context_p->token.type == LEXER_KEYW_LET
        -:  449:                || context_p->token.type == LEXER_KEYW_CONST);
        -:  450:
        -:  451:#if JERRY_ESNEXT
        3:  452:  uint8_t declaration_type = context_p->token.type;
        -:  453:
        3:  454:  if (declaration_type != LEXER_KEYW_VAR)
        -:  455:  {
    #####:  456:    parser_validate_lexical_context (context_p);
        -:  457:  }
        -:  458:#endif /* JERRY_ESNEXT */
        -:  459:
        -:  460:  while (true)
        -:  461:  {
        -:  462:#if JERRY_ESNEXT
        3:  463:    if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -:  464:    {
    #####:  465:      parser_pattern_flags_t flags = PARSER_PATTERN_BINDING;
        -:  466:
    #####:  467:      if (declaration_type == LEXER_KEYW_LET)
        -:  468:      {
    #####:  469:        flags |= PARSER_PATTERN_LET;
        -:  470:      }
    #####:  471:      else if (declaration_type == LEXER_KEYW_CONST)
        -:  472:      {
    #####:  473:        flags |= PARSER_PATTERN_CONST;
        -:  474:      }
        -:  475:
    #####:  476:      parser_parse_initializer_by_next_char (context_p, flags);
        -:  477:    }
        -:  478:    else
        -:  479:    {
        -:  480:#endif /* JERRY_ESNEXT */
        3:  481:      lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        3:  482:      JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  483:                    && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  484:
        -:  485:#if JERRY_DEBUGGER || JERRY_LINE_INFO
    #####:  486:      parser_line_counter_t ident_line_counter = context_p->token.line;
        -:  487:#endif /* JERRY_DEBUGGER || JERRY_LINE_INFO */
        -:  488:#if JERRY_LINE_INFO
    #####:  489:      parser_line_counter_t ident_column_counter = context_p->token.column;
        -:  490:#endif /* JERRY_LINE_INFO */
        -:  491:
        -:  492:#if JERRY_MODULE_SYSTEM
        3:  493:      parser_module_append_export_name (context_p);
        -:  494:#endif /* JERRY_MODULE_SYSTEM */
        -:  495:
        -:  496:#if JERRY_ESNEXT
        3:  497:      if (declaration_type != LEXER_KEYW_VAR
    #####:  498:          && context_p->token.keyword_type == LEXER_KEYW_LET)
        -:  499:      {
    #####:  500:        parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -:  501:      }
        -:  502:
        3:  503:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  504:      {
    #####:  505:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####:  506:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  507:      }
        -:  508:#endif /* JERRY_ESNEXT */
        -:  509:
        3:  510:      lexer_next_token (context_p);
        -:  511:
        3:  512:      if (context_p->token.type == LEXER_ASSIGN)
        -:  513:      {
        -:  514:#if JERRY_DEBUGGER
        -:  515:        if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  516:            && ident_line_counter != context_p->last_breakpoint_line)
        -:  517:        {
        -:  518:          parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  519:          parser_flush_cbc (context_p);
        -:  520:
        -:  521:          parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -:  522:
        -:  523:          context_p->last_breakpoint_line = ident_line_counter;
        -:  524:        }
        -:  525:#endif /* JERRY_DEBUGGER */
        -:  526:
        -:  527:#if JERRY_LINE_INFO
    #####:  528:        parser_line_info_append (context_p, ident_line_counter, ident_column_counter);
        -:  529:#endif /* JERRY_LINE_INFO */
        -:  530:
        3:  531:        uint16_t index = context_p->lit_object.index;
        -:  532:
        3:  533:        lexer_next_token (context_p);
        3:  534:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  535:
        3:  536:        cbc_opcode_t opcode = CBC_ASSIGN_SET_IDENT;
        -:  537:
        -:  538:#if JERRY_ESNEXT
        3:  539:        uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -:  540:
        3:  541:        if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -:  542:        {
    #####:  543:          uint16_t name_index = scanner_save_literal (context_p, index);
    #####:  544:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -:  545:        }
        3:  546:        else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -:  547:        {
    #####:  548:          parser_set_function_name (context_p, function_literal_index, index, 0);
        -:  549:        }
        -:  550:
        3:  551:        if (declaration_type != LEXER_KEYW_VAR
    #####:  552:            && (index < PARSER_REGISTER_START))
        -:  553:        {
    #####:  554:          opcode = CBC_INIT_LET;
        -:  555:
    #####:  556:          if (scanner_literal_is_created (context_p, index))
        -:  557:          {
    #####:  558:            opcode = CBC_ASSIGN_LET_CONST;
        -:  559:          }
    #####:  560:          else if (declaration_type == LEXER_KEYW_CONST)
        -:  561:          {
    #####:  562:            opcode = CBC_INIT_CONST;
        -:  563:          }
        -:  564:        }
        -:  565:#endif /* JERRY_ESNEXT */
        -:  566:
        3:  567:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -:  568:      }
        -:  569:#if JERRY_ESNEXT
    #####:  570:      else if (declaration_type == LEXER_KEYW_LET)
        -:  571:      {
    #####:  572:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -:  573:
    #####:  574:        uint16_t index = context_p->lit_object.index;
    #####:  575:        cbc_opcode_t opcode = CBC_MOV_IDENT;
        -:  576:
    #####:  577:        if (index < PARSER_REGISTER_START)
        -:  578:        {
    #####:  579:          opcode = (scanner_literal_is_created (context_p, index) ? CBC_ASSIGN_LET_CONST
    #####:  580:                                                                  : CBC_INIT_LET);
        -:  581:        }
        -:  582:
    #####:  583:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -:  584:      }
    #####:  585:      else if (declaration_type == LEXER_KEYW_CONST)
        -:  586:      {
    #####:  587:        parser_raise_error (context_p, PARSER_ERR_MISSING_ASSIGN_AFTER_CONST);
        -:  588:      }
        -:  589:    }
        -:  590:#endif /* JERRY_ESNEXT */
        -:  591:
        3:  592:    if (context_p->token.type != LEXER_COMMA)
        -:  593:    {
        3:  594:      break;
        -:  595:    }
        -:  596:  }
        -:  597:
        -:  598:#if JERRY_MODULE_SYSTEM
        3:  599:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -:  600:#endif /* JERRY_MODULE_SYSTEM */
        3:  601:} /* parser_parse_var_statement */
        -:  602:
        -:  603:/**
        -:  604: * Parse function statement.
        -:  605: */
        -:  606:static void
    #####:  607:parser_parse_function_statement (parser_context_t *context_p) /**< context */
        -:  608:{
    #####:  609:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);
        -:  610:
        -:  611:#if JERRY_ESNEXT
    #####:  612:  if (JERRY_UNLIKELY (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM))
        -:  613:  {
    #####:  614:    if (context_p->status_flags & PARSER_IS_STRICT)
        -:  615:    {
    #####:  616:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  617:    }
        -:  618:
    #####:  619:    if (context_p->stack_top_uint8 == PARSER_STATEMENT_IF
    #####:  620:        || context_p->stack_top_uint8 == PARSER_STATEMENT_ELSE)
        -:  621:    {
        -:  622:      /* There must be a parser error later if this check fails. */
    #####:  623:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  624:      {
    #####:  625:        parser_push_block_context (context_p, true);
        -:  626:      }
        -:  627:    }
    #####:  628:    else if (context_p->stack_top_uint8 == PARSER_STATEMENT_LABEL)
        -:  629:    {
    #####:  630:      parser_stack_iterator_t iterator;
    #####:  631:      parser_stack_iterator_init (context_p, &iterator);
    #####:  632:      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);
        -:  633:
        -:  634:      while (true)
    #####:  635:      {
    #####:  636:        uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
        -:  637:
    #####:  638:        if (type == PARSER_STATEMENT_LABEL)
        -:  639:        {
    #####:  640:          parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);
    #####:  641:          continue;
        -:  642:        }
        -:  643:
    #####:  644:        if (parser_statement_flags[type] & PARSER_STATM_HAS_BLOCK)
        -:  645:        {
    #####:  646:          break;
        -:  647:        }
        -:  648:
    #####:  649:        parser_raise_error (context_p, PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK);
        -:  650:      }
        -:  651:    }
        -:  652:    else
        -:  653:    {
    #####:  654:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  655:    }
        -:  656:  }
        -:  657:#endif /* JERRY_ESNEXT */
        -:  658:
        -:  659:#if JERRY_FUNCTION_TO_STRING
        -:  660:#if JERRY_ESNEXT
    #####:  661:  if (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC))
        -:  662:  {
    #####:  663:    context_p->function_start_p = context_p->token.lit_location.char_p;
        -:  664:  }
        -:  665:#else /* !JERRY_ESNEXT */
        -:  666:  context_p->function_start_p = context_p->token.lit_location.char_p;
        -:  667:#endif /* JERRY_ESNEXT */
        -:  668:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  669:
        -:  670:#if JERRY_DEBUGGER
        -:  671:  parser_line_counter_t debugger_line = context_p->token.line;
        -:  672:  parser_line_counter_t debugger_column = context_p->token.column;
        -:  673:#endif /* JERRY_DEBUGGER */
        -:  674:
        -:  675:#if JERRY_ESNEXT
    #####:  676:  bool is_generator_function = false;
        -:  677:
    #####:  678:  if (lexer_consume_generator (context_p))
        -:  679:  {
    #####:  680:    is_generator_function = true;
        -:  681:  }
        -:  682:#endif /* JERRY_ESNEXT */
        -:  683:
    #####:  684:  lexer_expect_identifier (context_p, LEXER_NEW_IDENT_LITERAL);
    #####:  685:  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  686:                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  687:
        -:  688:#if JERRY_ESNEXT
    #####:  689:  if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####:  690:      && context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED)
        -:  691:  {
    #####:  692:    parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  693:  }
        -:  694:
    #####:  695:  uint16_t function_name_index = context_p->lit_object.index;
        -:  696:#endif /* JERRY_ESNEXT */
        -:  697:
        -:  698:#if JERRY_MODULE_SYSTEM
    #####:  699:  parser_module_append_export_name (context_p);
    #####:  700:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -:  701:#endif /* JERRY_MODULE_SYSTEM */
        -:  702:
    #####:  703:  uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -:  704:
    #####:  705:  if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -:  706:  {
    #####:  707:    status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -:  708:  }
        -:  709:
        -:  710:#if JERRY_ESNEXT
    #####:  711:  if (is_generator_function)
        -:  712:  {
    #####:  713:    status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  714:  }
        -:  715:
    #####:  716:  if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -:  717:  {
    #####:  718:    status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  719:  }
        -:  720:#endif /* JERRY_ESNEXT */
        -:  721:
        -:  722:#if JERRY_DEBUGGER
        -:  723:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  724:  {
        -:  725:    lexer_literal_t *name_p = context_p->lit_object.literal_p;
        -:  726:    jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -:  727:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  728:                                name_p->u.char_p,
        -:  729:                                name_p->prop.length);
        -:  730:
        -:  731:    /* Reset token position for the function. */
        -:  732:    context_p->token.line = debugger_line;
        -:  733:    context_p->token.column = debugger_column;
        -:  734:  }
        -:  735:#endif /* JERRY_DEBUGGER */
        -:  736:
    #####:  737:  JERRY_ASSERT (context_p->scope_stack_top >= 2);
    #####:  738:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top - 2;
        -:  739:
    #####:  740:  uint16_t literal_index = context_p->lit_object.index;
        -:  741:
    #####:  742:  while (literal_index != scope_stack_p->map_from)
        -:  743:  {
    #####:  744:    scope_stack_p--;
        -:  745:
    #####:  746:    JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p);
        -:  747:  }
        -:  748:
    #####:  749:  JERRY_ASSERT (scope_stack_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -:  750:
        -:  751:#if JERRY_ESNEXT
    #####:  752:  if (!(context_p->status_flags & PARSER_IS_STRICT)
    #####:  753:      && (scope_stack_p >= context_p->scope_stack_p + context_p->scope_stack_global_end))
        -:  754:  {
    #####:  755:    bool copy_value = true;
        -:  756:
    #####:  757:    parser_scope_stack_t *stack_p = context_p->scope_stack_p;
        -:  758:
    #####:  759:    while (stack_p < scope_stack_p)
        -:  760:    {
    #####:  761:      if (literal_index == stack_p->map_from
    #####:  762:          && (stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY))
        -:  763:      {
    #####:  764:        copy_value = false;
    #####:  765:        break;
        -:  766:      }
    #####:  767:      stack_p++;
        -:  768:    }
        -:  769:
    #####:  770:    if (copy_value)
        -:  771:    {
    #####:  772:      stack_p = context_p->scope_stack_p;
        -:  773:
    #####:  774:      while (stack_p < scope_stack_p)
        -:  775:      {
    #####:  776:        if (literal_index == stack_p->map_from)
        -:  777:        {
    #####:  778:          JERRY_ASSERT (!(stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY));
        -:  779:
    #####:  780:          uint16_t map_to = scanner_decode_map_to (stack_p);
    #####:  781:          uint16_t opcode = ((map_to >= PARSER_REGISTER_START) ? CBC_ASSIGN_LITERAL_SET_IDENT
        -:  782:                                                               : CBC_COPY_TO_GLOBAL);
        -:  783:
    #####:  784:          parser_emit_cbc_literal_value (context_p,
        -:  785:                                         opcode,
    #####:  786:                                         scanner_decode_map_to (scope_stack_p),
        -:  787:                                         map_to);
    #####:  788:          break;
        -:  789:        }
    #####:  790:        stack_p++;
        -:  791:      }
        -:  792:
    #####:  793:      parser_flush_cbc (context_p);
        -:  794:    }
        -:  795:
    #####:  796:    if (JERRY_UNLIKELY (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        -:  797:                        || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT))
        -:  798:    {
    #####:  799:      parser_pop_block_context (context_p);
        -:  800:    }
        -:  801:  }
        -:  802:#endif /* JERRY_ESNEXT */
        -:  803:
    #####:  804:  lexer_literal_t *literal_p = PARSER_GET_LITERAL ((size_t) scope_stack_p[1].map_to);
        -:  805:
    #####:  806:  JERRY_ASSERT ((literal_p->type == LEXER_UNUSED_LITERAL || literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  807:                && literal_p->status_flags == 0);
        -:  808:
    #####:  809:  ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, status_flags);
        -:  810:
    #####:  811:  if (literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  812:  {
    #####:  813:    ecma_bytecode_deref (literal_p->u.bytecode_p);
        -:  814:  }
        -:  815:
    #####:  816:  literal_p->u.bytecode_p = compiled_code_p;
    #####:  817:  literal_p->type = LEXER_FUNCTION_LITERAL;
        -:  818:
        -:  819:#if JERRY_ESNEXT
    #####:  820:  parser_compiled_code_set_function_name (context_p, compiled_code_p, function_name_index, 0);
        -:  821:#endif /* JERRY_ESNEXT */
        -:  822:
    #####:  823:  lexer_next_token (context_p);
    #####:  824:} /* parser_parse_function_statement */
        -:  825:
        -:  826:/**
        -:  827: * Parse if statement (starting part).
        -:  828: */
        -:  829:static void
    #####:  830:parser_parse_if_statement_start (parser_context_t *context_p) /**< context */
        -:  831:{
    #####:  832:  parser_if_else_statement_t if_statement;
        -:  833:
    #####:  834:  parser_parse_enclosed_expr (context_p);
        -:  835:
    #####:  836:  parser_emit_cbc_forward_branch (context_p,
        -:  837:                                  CBC_BRANCH_IF_FALSE_FORWARD,
        -:  838:                                  &if_statement.branch);
        -:  839:
    #####:  840:  parser_stack_push (context_p, &if_statement, sizeof (parser_if_else_statement_t));
    #####:  841:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_IF);
    #####:  842:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  843:} /* parser_parse_if_statement_start */
        -:  844:
        -:  845:/**
        -:  846: * Parse if statement (ending part).
        -:  847: *
        -:  848: * @return true  - if parsing an 'else' statement
        -:  849: *         false - otherwise
        -:  850: */
        -:  851:static bool
    #####:  852:parser_parse_if_statement_end (parser_context_t *context_p) /**< context */
        -:  853:{
    #####:  854:  parser_if_else_statement_t if_statement;
    #####:  855:  parser_if_else_statement_t else_statement;
    #####:  856:  parser_stack_iterator_t iterator;
        -:  857:
    #####:  858:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_IF);
        -:  859:
    #####:  860:  if (context_p->token.type != LEXER_KEYW_ELSE)
        -:  861:  {
    #####:  862:    parser_stack_pop_uint8 (context_p);
    #####:  863:    parser_stack_pop (context_p, &if_statement, sizeof (parser_if_else_statement_t));
    #####:  864:    parser_stack_iterator_init (context_p, &context_p->last_statement);
        -:  865:
    #####:  866:    parser_set_branch_to_current_position (context_p, &if_statement.branch);
        -:  867:
    #####:  868:    return false;
        -:  869:  }
        -:  870:
    #####:  871:  parser_stack_change_last_uint8 (context_p, PARSER_STATEMENT_ELSE);
    #####:  872:  parser_stack_iterator_init (context_p, &iterator);
    #####:  873:  parser_stack_iterator_skip (&iterator, 1);
    #####:  874:  parser_stack_iterator_read (&iterator, &if_statement, sizeof (parser_if_else_statement_t));
        -:  875:
    #####:  876:  parser_emit_cbc_forward_branch (context_p,
        -:  877:                                  CBC_JUMP_FORWARD,
        -:  878:                                  &else_statement.branch);
        -:  879:
    #####:  880:  parser_set_branch_to_current_position (context_p, &if_statement.branch);
        -:  881:
    #####:  882:  parser_stack_iterator_write (&iterator, &else_statement, sizeof (parser_if_else_statement_t));
        -:  883:
    #####:  884:  lexer_next_token (context_p);
    #####:  885:  return true;
        -:  886:} /* parser_parse_if_statement_end */
        -:  887:
        -:  888:/**
        -:  889: * Parse with statement (starting part).
        -:  890: */
        -:  891:static void
    #####:  892:parser_parse_with_statement_start (parser_context_t *context_p) /**< context */
        -:  893:{
    #####:  894:  parser_with_statement_t with_statement;
        -:  895:
    #####:  896:  if (context_p->status_flags & PARSER_IS_STRICT)
        -:  897:  {
    #####:  898:    parser_raise_error (context_p, PARSER_ERR_WITH_NOT_ALLOWED);
        -:  899:  }
        -:  900:
    #####:  901:  parser_parse_enclosed_expr (context_p);
        -:  902:
        -:  903:#ifndef JERRY_NDEBUG
    #####:  904:  PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  905:#endif /* !JERRY_NDEBUG */
        -:  906:
    #####:  907:  uint8_t inside_with = (context_p->status_flags & PARSER_INSIDE_WITH) != 0;
        -:  908:
    #####:  909:  context_p->status_flags |= PARSER_INSIDE_WITH;
    #####:  910:  parser_emit_cbc_ext_forward_branch (context_p,
        -:  911:                                      CBC_EXT_WITH_CREATE_CONTEXT,
        -:  912:                                      &with_statement.branch);
        -:  913:
    #####:  914:  parser_stack_push (context_p, &with_statement, sizeof (parser_with_statement_t));
    #####:  915:  parser_stack_push_uint8 (context_p, inside_with);
    #####:  916:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_WITH);
    #####:  917:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  918:} /* parser_parse_with_statement_start */
        -:  919:
        -:  920:/**
        -:  921: * Parse with statement (ending part).
        -:  922: */
        -:  923:static void
    #####:  924:parser_parse_with_statement_end (parser_context_t *context_p) /**< context */
        -:  925:{
    #####:  926:  parser_with_statement_t with_statement;
        -:  927:
    #####:  928:  JERRY_ASSERT (context_p->status_flags & PARSER_INSIDE_WITH);
        -:  929:
    #####:  930:  parser_stack_pop_uint8 (context_p);
        -:  931:
    #####:  932:  if (!context_p->stack_top_uint8)
        -:  933:  {
    #####:  934:    context_p->status_flags &= (uint32_t) ~PARSER_INSIDE_WITH;
        -:  935:  }
        -:  936:
    #####:  937:  parser_stack_pop_uint8 (context_p);
    #####:  938:  parser_stack_pop (context_p, &with_statement, sizeof (parser_with_statement_t));
    #####:  939:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -:  940:
    #####:  941:  parser_flush_cbc (context_p);
    #####:  942:  PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  943:#ifndef JERRY_NDEBUG
    #####:  944:  PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  945:#endif /* !JERRY_NDEBUG */
        -:  946:
    #####:  947:  parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####:  948:  parser_set_branch_to_current_position (context_p, &with_statement.branch);
    #####:  949:} /* parser_parse_with_statement_end */
        -:  950:
        -:  951:/**
        -:  952: * Parse do-while statement (ending part).
        -:  953: */
        -:  954:static void
    #####:  955:parser_parse_do_while_statement_end (parser_context_t *context_p) /**< context */
        -:  956:{
    #####:  957:  parser_loop_statement_t loop;
        -:  958:
    #####:  959:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_DO_WHILE);
        -:  960:
    #####:  961:  if (context_p->token.type != LEXER_KEYW_WHILE)
        -:  962:  {
    #####:  963:    parser_raise_error (context_p, PARSER_ERR_WHILE_EXPECTED);
        -:  964:  }
        -:  965:
    #####:  966:  parser_stack_iterator_t iterator;
    #####:  967:  parser_stack_iterator_init (context_p, &iterator);
        -:  968:
    #####:  969:  parser_stack_iterator_skip (&iterator, 1);
    #####:  970:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
        -:  971:
    #####:  972:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -:  973:
    #####:  974:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p);
        -:  975:
    #####:  976:  parser_parse_enclosed_expr (context_p);
        -:  977:
    #####:  978:  if (context_p->last_cbc_opcode != CBC_PUSH_FALSE)
        -:  979:  {
    #####:  980:    cbc_opcode_t opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
    #####:  981:    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -:  982:    {
    #####:  983:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####:  984:      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -:  985:    }
    #####:  986:    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -:  987:    {
    #####:  988:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####:  989:      opcode = CBC_JUMP_BACKWARD;
        -:  990:    }
        -:  991:
    #####:  992:    parser_do_while_statement_t do_while_statement;
    #####:  993:    parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####:  994:    parser_stack_iterator_read (&iterator, &do_while_statement, sizeof (parser_do_while_statement_t));
        -:  995:
    #####:  996:    parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, do_while_statement.start_offset);
        -:  997:  }
        -:  998:  else
        -:  999:  {
    #####: 1000:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1001:  }
        -: 1002:
    #####: 1003:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_do_while_statement_t));
    #####: 1004:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1005:
    #####: 1006:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
    #####: 1007:} /* parser_parse_do_while_statement_end */
        -: 1008:
        -: 1009:/**
        -: 1010: * Parse while statement (starting part).
        -: 1011: */
        -: 1012:static void
    #####: 1013:parser_parse_while_statement_start (parser_context_t *context_p) /**< context */
        -: 1014:{
    #####: 1015:  parser_while_statement_t while_statement;
    #####: 1016:  parser_loop_statement_t loop;
        -: 1017:
    #####: 1018:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_WHILE);
    #####: 1019:  lexer_next_token (context_p);
        -: 1020:
    #####: 1021:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1022:  {
    #####: 1023:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 1024:  }
        -: 1025:
    #####: 1026:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 1027:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_WHILE);
        -: 1028:
    #####: 1029:  if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -: 1030:  {
        -: 1031:    /* The prescanner couldn't find the end of the while condition. */
    #####: 1032:    lexer_next_token (context_p);
    #####: 1033:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1034:
    #####: 1035:    JERRY_ASSERT (context_p->token.type != LEXER_RIGHT_PAREN);
    #####: 1036:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1037:  }
        -: 1038:
    #####: 1039:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &while_statement.branch);
        -: 1040:
    #####: 1041:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1042:
    #####: 1043:  while_statement.start_offset = context_p->byte_code_size;
    #####: 1044:  scanner_get_location (&while_statement.condition_location, context_p);
        -: 1045:
    #####: 1046:  scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 1047:  scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 1048:  scanner_seek (context_p);
    #####: 1049:  lexer_next_token (context_p);
        -: 1050:
    #####: 1051:  loop.branch_list_p = NULL;
        -: 1052:
    #####: 1053:  parser_stack_push (context_p, &while_statement, sizeof (parser_while_statement_t));
    #####: 1054:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 1055:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_WHILE);
    #####: 1056:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 1057:} /* parser_parse_while_statement_start */
        -: 1058:
        -: 1059:/**
        -: 1060: * Parse while statement (ending part).
        -: 1061: */
        -: 1062:static void JERRY_ATTR_NOINLINE
    #####: 1063:parser_parse_while_statement_end (parser_context_t *context_p) /**< context */
        -: 1064:{
    #####: 1065:  parser_while_statement_t while_statement;
    #####: 1066:  parser_loop_statement_t loop;
        -: 1067:  lexer_token_t current_token;
    #####: 1068:  scanner_location_t location;
        -: 1069:  cbc_opcode_t opcode;
        -: 1070:
    #####: 1071:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_WHILE);
        -: 1072:
    #####: 1073:  parser_stack_iterator_t iterator;
    #####: 1074:  parser_stack_iterator_init (context_p, &iterator);
        -: 1075:
    #####: 1076:  parser_stack_iterator_skip (&iterator, 1);
    #####: 1077:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 1078:  parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####: 1079:  parser_stack_iterator_read (&iterator, &while_statement, sizeof (parser_while_statement_t));
        -: 1080:
    #####: 1081:  scanner_get_location (&location, context_p);
    #####: 1082:  current_token = context_p->token;
        -: 1083:
    #####: 1084:  parser_set_branch_to_current_position (context_p, &while_statement.branch);
    #####: 1085:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 1086:
    #####: 1087:  scanner_set_location (context_p, &while_statement.condition_location);
    #####: 1088:  scanner_seek (context_p);
    #####: 1089:  lexer_next_token (context_p);
        -: 1090:
    #####: 1091:  parser_parse_expression (context_p, PARSE_EXPR);
    #####: 1092:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1093:  {
    #####: 1094:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1095:  }
        -: 1096:
    #####: 1097:  opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
    #####: 1098:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 1099:  {
    #####: 1100:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1101:    opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -: 1102:  }
    #####: 1103:  else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -: 1104:  {
    #####: 1105:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1106:    opcode = CBC_JUMP_BACKWARD;
        -: 1107:  }
        -: 1108:
    #####: 1109:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_while_statement_t));
    #####: 1110:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1111:
    #####: 1112:  parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, while_statement.start_offset);
    #####: 1113:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
        -: 1114:
        -: 1115:  /* Calling scanner_seek is unnecessary because all
        -: 1116:   * info blocks inside the while statement should be processed. */
    #####: 1117:  scanner_set_location (context_p, &location);
    #####: 1118:  context_p->token = current_token;
    #####: 1119:} /* parser_parse_while_statement_end */
        -: 1120:
        -: 1121:/**
        -: 1122: * Check whether the opcode is a valid LeftHandSide expression
        -: 1123: * and convert it back to an assignment.
        -: 1124: *
        -: 1125: * @return the compatible assignment opcode
        -: 1126: */
        -: 1127:static uint16_t
    #####: 1128:parser_check_left_hand_side_expression (parser_context_t *context_p, /**< context */
        -: 1129:                                        uint16_t opcode) /**< opcode to check */
        -: 1130:{
    #####: 1131:  if (opcode == CBC_PUSH_LITERAL
    #####: 1132:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 1133:  {
    #####: 1134:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1135:    return CBC_ASSIGN_SET_IDENT;
        -: 1136:  }
    #####: 1137:  else if (opcode == CBC_PUSH_PROP)
        -: 1138:  {
    #####: 1139:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1140:    return CBC_ASSIGN;
        -: 1141:  }
    #####: 1142:  else if (opcode == CBC_PUSH_PROP_LITERAL)
        -: 1143:  {
    #####: 1144:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1145:    return CBC_ASSIGN_PROP_LITERAL;
        -: 1146:  }
    #####: 1147:  else if (opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 1148:  {
    #####: 1149:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1150:    return CBC_ASSIGN;
        -: 1151:  }
    #####: 1152:  else if (opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 1153:  {
    #####: 1154:    context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
    #####: 1155:    return CBC_ASSIGN;
        -: 1156:  }
        -: 1157:  else
        -: 1158:  {
        -: 1159:    /* Invalid LeftHandSide expression. */
        -: 1160:#if JERRY_ESNEXT
    #####: 1161:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_FOR_LOOP);
        -: 1162:#else /* !JERRY_ESNEXT */
    #####: 1163:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 1164:#endif /* JERRY_ESNEXT */
        -: 1165:
    #####: 1166:    return CBC_ASSIGN;
        -: 1167:  }
        -: 1168:
        -: 1169:  return opcode;
        -: 1170:} /* parser_check_left_hand_side_expression */
        -: 1171:
        -: 1172:/**
        -: 1173: * Parse for statement (starting part).
        -: 1174: */
        -: 1175:static void
        1: 1176:parser_parse_for_statement_start (parser_context_t *context_p) /**< context */
        -: 1177:{
        1: 1178:  parser_loop_statement_t loop;
        -: 1179:
        1: 1180:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FOR);
        1: 1181:  lexer_next_token (context_p);
        -: 1182:
        -: 1183:#if JERRY_ESNEXT
        1: 1184:  bool is_for_await = false;
        -: 1185:
        1: 1186:  if (context_p->token.type == LEXER_KEYW_AWAIT)
        -: 1187:  {
    #####: 1188:    if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 1189:    {
    #####: 1190:      parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 1191:    }
    #####: 1192:    lexer_next_token (context_p);
    #####: 1193:    is_for_await = true;
        -: 1194:  }
        -: 1195:#endif /* JERRY_ESNEXT */
        -: 1196:
        1: 1197:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1198:  {
        -: 1199:#if JERRY_ESNEXT
    #####: 1200:    if (context_p->token.type == LEXER_LITERAL
    #####: 1201:        && context_p->token.keyword_type == LEXER_KEYW_AWAIT
    #####: 1202:        && !(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 1203:    {
    #####: 1204:      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_ASYNC);
        -: 1205:    }
        -: 1206:#endif /* JERRY_ESNEXT */
    #####: 1207:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 1208:  }
        -: 1209:
        1: 1210:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1211:  {
        1: 1212:    parser_for_in_of_statement_t for_in_of_statement;
        1: 1213:    scanner_location_t start_location, end_location;
        -: 1214:
        -: 1215:#if JERRY_ESNEXT
        1: 1216:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN
        -: 1217:                  || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_OF);
        -: 1218:
        1: 1219:    bool is_for_in = (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);
        1: 1220:    end_location = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location;
        -: 1221:
        1: 1222:    scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1223:
        1: 1224:    scanner_get_location (&start_location, context_p);
        1: 1225:    lexer_next_token (context_p);
        -: 1226:
        1: 1227:    uint8_t token_type = LEXER_EOS;
        1: 1228:    bool has_context = false;
        -: 1229:
        1: 1230:    if (context_p->token.type == LEXER_KEYW_VAR
    #####: 1231:        || context_p->token.type == LEXER_KEYW_LET
    #####: 1232:        || context_p->token.type == LEXER_KEYW_CONST)
        -: 1233:    {
        1: 1234:      token_type = context_p->token.type;
        1: 1235:      has_context = context_p->next_scanner_info_p->source_p == context_p->source_p;
        1: 1236:      JERRY_ASSERT (!has_context || context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        1: 1237:      scanner_get_location (&start_location, context_p);
        -: 1238:
        -: 1239:      /* TODO: remove this after the pre-scanner supports strict mode detection. */
        2: 1240:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1241:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1242:      {
    #####: 1243:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1244:      }
        -: 1245:    }
    #####: 1246:    else if (context_p->token.type == LEXER_LITERAL && lexer_token_is_let (context_p))
        -: 1247:    {
    #####: 1248:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1249:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1250:      {
    #####: 1251:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1252:      }
        -: 1253:      else
        -: 1254:      {
    #####: 1255:        token_type = LEXER_KEYW_LET;
    #####: 1256:        has_context = (context_p->next_scanner_info_p->source_p == context_p->source_p);
    #####: 1257:        scanner_get_location (&start_location, context_p);
        -: 1258:      }
        -: 1259:    }
        -: 1260:
        1: 1261:    if (has_context)
        -: 1262:    {
    #####: 1263:      has_context = parser_push_block_context (context_p, true);
        -: 1264:    }
        -: 1265:
        1: 1266:    scanner_set_location (context_p, &end_location);
        -: 1267:#else /* !JERRY_ESNEXT */
        -: 1268:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);
        -: 1269:
    #####: 1270:    bool is_for_in = true;
    #####: 1271:    scanner_get_location (&start_location, context_p);
        -: 1272:
    #####: 1273:    scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 1274:    scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1275:#endif /* JERRY_ESNEXT */
        -: 1276:
        -: 1277:    /* The length of both 'in' and 'of' is two. */
        1: 1278:    const uint8_t *source_end_p = context_p->source_p - 2;
        -: 1279:
        1: 1280:    scanner_seek (context_p);
        -: 1281:
        -: 1282:#if JERRY_ESNEXT
        1: 1283:    if (is_for_in && is_for_await)
        -: 1284:    {
    #####: 1285:      context_p->token.line = context_p->line;
    #####: 1286:      context_p->token.column = context_p->column - 2;
    #####: 1287:      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);
        -: 1288:    }
        -: 1289:#endif /* JERRY_ESNEXT */
        -: 1290:
        1: 1291:    lexer_next_token (context_p);
        1: 1292:    int options = is_for_in ? PARSE_EXPR : PARSE_EXPR_LEFT_HAND_SIDE;
        1: 1293:    parser_parse_expression (context_p, options);
        -: 1294:
        1: 1295:    if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1296:    {
    #####: 1297:      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1298:    }
        -: 1299:
        -: 1300:#ifndef JERRY_NDEBUG
        1: 1301:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth,
        -: 1302:                           is_for_in ? PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION
        -: 1303:                                     : PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
        -: 1304:#endif /* !JERRY_NDEBUG */
        -: 1305:
        1: 1306:    cbc_ext_opcode_t init_opcode = CBC_EXT_FOR_IN_INIT;
        -: 1307:
        -: 1308:#if JERRY_ESNEXT
        1: 1309:    if (!is_for_in)
        -: 1310:    {
    #####: 1311:      init_opcode = is_for_await ? CBC_EXT_FOR_AWAIT_OF_INIT : CBC_EXT_FOR_OF_INIT;
        -: 1312:    }
        -: 1313:#endif /* JERRY_ESNEXT */
        -: 1314:
        1: 1315:    parser_emit_cbc_ext_forward_branch (context_p, init_opcode, &for_in_of_statement.branch);
        -: 1316:
        1: 1317:    JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        1: 1318:    for_in_of_statement.start_offset = context_p->byte_code_size;
        -: 1319:
        -: 1320:#if JERRY_ESNEXT
        1: 1321:    if (has_context)
        -: 1322:    {
    #####: 1323:      parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_CONTEXT);
        -: 1324:    }
        -: 1325:#endif /* JERRY_ESNEXT */
        -: 1326:
        -: 1327:    /* The expression parser must not read the 'in' or 'of' tokens. */
        1: 1328:    scanner_get_location (&end_location, context_p);
        1: 1329:    scanner_set_location (context_p, &start_location);
        -: 1330:
        1: 1331:    const uint8_t *original_source_end_p = context_p->source_end_p;
        1: 1332:    context_p->source_end_p = source_end_p;
        1: 1333:    scanner_seek (context_p);
        -: 1334:
        -: 1335:#if JERRY_ESNEXT
        1: 1336:    if (token_type == LEXER_EOS)
        -: 1337:    {
    #####: 1338:      lexer_next_token (context_p);
        -: 1339:
    #####: 1340:      if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1341:      {
    #####: 1342:        token_type = context_p->token.type;
        -: 1343:      }
        -: 1344:    }
        -: 1345:#else /* !JERRY_ESNEXT */
    #####: 1346:    lexer_next_token (context_p);
        -: 1347:
    #####: 1348:    uint8_t token_type = context_p->token.type;
        -: 1349:#endif /* JERRY_ESNEXT */
        -: 1350:
        1: 1351:    switch (token_type)
        -: 1352:    {
        -: 1353:#if JERRY_ESNEXT
        1: 1354:      case LEXER_KEYW_LET:
        -: 1355:      case LEXER_KEYW_CONST:
        -: 1356:#endif /* JERRY_ESNEXT */
    #####: 1357:      case LEXER_KEYW_VAR:
        -: 1358:      {
        -: 1359:#if JERRY_ESNEXT
        1: 1360:        if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -: 1361:        {
    #####: 1362:          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1363:                                                    : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1364:
    #####: 1365:          parser_pattern_flags_t flags = (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK);
        -: 1366:
    #####: 1367:          if (context_p->next_scanner_info_p->source_p == (context_p->source_p + 1))
        -: 1368:          {
    #####: 1369:            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1370:            {
    #####: 1371:              scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1372:            }
        -: 1373:            else
        -: 1374:            {
    #####: 1375:              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
    #####: 1376:              if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1377:              {
    #####: 1378:                flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1379:              }
        -: 1380:
    #####: 1381:              scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1382:            }
        -: 1383:          }
        -: 1384:
    #####: 1385:          if (token_type == LEXER_KEYW_LET)
        -: 1386:          {
    #####: 1387:            flags |= PARSER_PATTERN_LET;
        -: 1388:          }
    #####: 1389:          else if (token_type == LEXER_KEYW_CONST)
        -: 1390:          {
    #####: 1391:            flags |= PARSER_PATTERN_CONST;
        -: 1392:          }
        -: 1393:
    #####: 1394:          parser_parse_initializer_by_next_char (context_p, flags);
    #####: 1395:          break;
        -: 1396:        }
        -: 1397:#endif /* JERRY_ESNEXT */
        -: 1398:
        1: 1399:        lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        -: 1400:
        -: 1401:#if JERRY_ESNEXT
        1: 1402:        if (context_p->token.keyword_type == LEXER_KEYW_LET
    #####: 1403:            && token_type != LEXER_KEYW_VAR)
        -: 1404:        {
    #####: 1405:          parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 1406:        }
        -: 1407:#endif /* JERRY_ESNEXT */
        -: 1408:
        1: 1409:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 1410:                      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1411:
        1: 1412:        uint16_t literal_index = context_p->lit_object.index;
        1: 1413:        lexer_next_token (context_p);
        -: 1414:
        1: 1415:        if (context_p->token.type == LEXER_ASSIGN)
        -: 1416:        {
        -: 1417:#if JERRY_ESNEXT
    #####: 1418:          if ((context_p->status_flags & PARSER_IS_STRICT) || !is_for_in)
        -: 1419:          {
    #####: 1420:            parser_raise_error (context_p, PARSER_ERR_FOR_IN_OF_DECLARATION);
        -: 1421:          }
        -: 1422:#endif /* JERRY_ESNEXT */
    #####: 1423:          parser_branch_t branch;
        -: 1424:
        -: 1425:          /* Initialiser is never executed. */
    #####: 1426:          parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &branch);
    #####: 1427:          lexer_next_token (context_p);
    #####: 1428:          parser_parse_expression_statement (context_p, PARSE_EXPR_NO_COMMA);
    #####: 1429:          parser_set_branch_to_current_position (context_p, &branch);
        -: 1430:        }
        -: 1431:
        1: 1432:        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1433:                                                  : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1434:#if JERRY_ESNEXT
        -: 1435:#ifndef JERRY_NDEBUG
        1: 1436:        if (literal_index < PARSER_REGISTER_START
    #####: 1437:            && has_context
    #####: 1438:            && !scanner_literal_is_created (context_p, literal_index))
        -: 1439:        {
    #####: 1440:          context_p->global_status_flags |= ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR;
        -: 1441:        }
        -: 1442:#endif /* !JERRY_NDEBUG */
        -: 1443:
        1: 1444:        uint16_t opcode = (has_context ? CBC_ASSIGN_LET_CONST : CBC_ASSIGN_SET_IDENT);
        1: 1445:        parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1446:#else /* !JERRY_ESNEXT */
    #####: 1447:        parser_emit_cbc_literal (context_p, CBC_ASSIGN_SET_IDENT, literal_index);
        -: 1448:#endif /* JERRY_ESNEXT */
        1: 1449:        break;
        -: 1450:      }
        -: 1451:#if JERRY_ESNEXT
    #####: 1452:      case LEXER_LEFT_BRACE:
        -: 1453:      case LEXER_LEFT_SQUARE:
        -: 1454:      {
    #####: 1455:        if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1456:            && context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
    #####: 1457:            && (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_DESTRUCTURING_FOR))
        -: 1458:        {
    #####: 1459:          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1460:                                                    : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1461:
    #####: 1462:          uint32_t flags = PARSER_PATTERN_TARGET_ON_STACK;
        -: 1463:
    #####: 1464:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1465:          {
    #####: 1466:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1467:          }
        -: 1468:
    #####: 1469:          scanner_release_next (context_p, sizeof (scanner_info_t));
    #####: 1470:          parser_parse_initializer (context_p, flags);
        -: 1471:          /* Pop the value returned by GET_NEXT. */
    #####: 1472:          parser_emit_cbc (context_p, CBC_POP);
    #####: 1473:          break;
        -: 1474:        }
        -: 1475:        /* FALLTHRU */
        -: 1476:      }
        -: 1477:#endif /* JERRY_ESNEXT */
    #####: 1478:      default:
        -: 1479:      {
        -: 1480:        uint16_t opcode;
        -: 1481:
    #####: 1482:        parser_parse_expression (context_p, PARSE_EXPR_LEFT_HAND_SIDE);
        -: 1483:
    #####: 1484:        opcode = context_p->last_cbc_opcode;
        -: 1485:
        -: 1486:        /* The CBC_EXT_FOR_IN_CREATE_CONTEXT flushed the opcode combiner. */
    #####: 1487:        JERRY_ASSERT (opcode != CBC_PUSH_TWO_LITERALS
        -: 1488:                      && opcode != CBC_PUSH_THREE_LITERALS);
        -: 1489:
    #####: 1490:        opcode = parser_check_left_hand_side_expression (context_p, opcode);
        -: 1491:
    #####: 1492:        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1493:                                                  : CBC_EXT_FOR_OF_GET_NEXT);
    #####: 1494:        parser_flush_cbc (context_p);
        -: 1495:
    #####: 1496:        context_p->last_cbc_opcode = opcode;
    #####: 1497:        break;
        -: 1498:      }
        -: 1499:    }
        -: 1500:
        1: 1501:    if (context_p->token.type != LEXER_EOS)
        -: 1502:    {
        -: 1503:#if JERRY_ESNEXT
    #####: 1504:      parser_raise_error (context_p, is_for_in ? PARSER_ERR_IN_EXPECTED : PARSER_ERR_OF_EXPECTED);
        -: 1505:#else /* !JERRY_ESNEXT */
    #####: 1506:      parser_raise_error (context_p, PARSER_ERR_IN_EXPECTED);
        -: 1507:#endif /* JERRY_ESNEXT */
        -: 1508:    }
        -: 1509:
        1: 1510:    parser_flush_cbc (context_p);
        1: 1511:    scanner_set_location (context_p, &end_location);
        1: 1512:    context_p->source_end_p = original_source_end_p;
        1: 1513:    lexer_next_token (context_p);
        -: 1514:
        1: 1515:    loop.branch_list_p = NULL;
        -: 1516:
        1: 1517:    parser_stack_push (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));
        1: 1518:    parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
        -: 1519:
        1: 1520:    uint8_t for_type = PARSER_STATEMENT_FOR_IN;
        -: 1521:
        -: 1522:#if JERRY_ESNEXT
        1: 1523:    if (!is_for_in)
        -: 1524:    {
    #####: 1525:      for_type = is_for_await ? PARSER_STATEMENT_FOR_AWAIT_OF : PARSER_STATEMENT_FOR_OF;
        -: 1526:    }
        -: 1527:#endif /* JERRY_ESNEXT */
        -: 1528:
        1: 1529:    parser_stack_push_uint8 (context_p, for_type);
        1: 1530:    parser_stack_iterator_init (context_p, &context_p->last_statement);
        1: 1531:    return;
        -: 1532:  }
        -: 1533:
    #####: 1534:  lexer_next_token (context_p);
        -: 1535:
    #####: 1536:  if (context_p->token.type != LEXER_SEMICOLON)
        -: 1537:  {
        -: 1538:#if JERRY_ESNEXT
    #####: 1539:    const uint8_t *source_p = context_p->source_p;
        -: 1540:#endif /* JERRY_ESNEXT */
        -: 1541:
    #####: 1542:    switch (context_p->token.type)
        -: 1543:    {
        -: 1544:#if JERRY_ESNEXT
    #####: 1545:      case LEXER_LITERAL:
        -: 1546:      {
    #####: 1547:        if (!lexer_token_is_let (context_p))
        -: 1548:        {
    #####: 1549:          parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1550:          break;
        -: 1551:        }
        -: 1552:
        -: 1553:        /* FALLTHRU */
        -: 1554:      }
        -: 1555:      case LEXER_KEYW_LET:
        -: 1556:      {
    #####: 1557:        if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1558:            && context_p->next_scanner_info_p->type != SCANNER_TYPE_BLOCK)
        -: 1559:        {
    #####: 1560:          if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1561:          {
    #####: 1562:            scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1563:          }
        -: 1564:
    #####: 1565:          parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1566:          break;
        -: 1567:        }
        -: 1568:
    #####: 1569:        context_p->token.type = LEXER_KEYW_LET;
        -: 1570:
        -: 1571:        /* FALLTHRU */
        -: 1572:      }
    #####: 1573:      case LEXER_KEYW_CONST:
        -: 1574:      {
    #####: 1575:        if (context_p->next_scanner_info_p->source_p == source_p)
        -: 1576:        {
    #####: 1577:          parser_push_block_context (context_p, true);
        -: 1578:        }
        -: 1579:        /* FALLTHRU */
        -: 1580:      }
        -: 1581:#endif /* JERRY_ESNEXT */
    #####: 1582:      case LEXER_KEYW_VAR:
        -: 1583:      {
    #####: 1584:        parser_parse_var_statement (context_p);
    #####: 1585:        break;
        -: 1586:      }
    #####: 1587:      default:
        -: 1588:      {
    #####: 1589:        parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1590:        break;
        -: 1591:      }
        -: 1592:    }
        -: 1593:
    #####: 1594:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1595:    {
    #####: 1596:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1597:    }
        -: 1598:  }
        -: 1599:
        -: 1600:#if JERRY_ESNEXT
    #####: 1601:  if (is_for_await)
        -: 1602:  {
    #####: 1603:    parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);
        -: 1604:  }
        -: 1605:#endif /* JERRY_ESNEXT */
        -: 1606:
    #####: 1607:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 1608:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR);
        -: 1609:
    #####: 1610:  if (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 1611:      || ((scanner_for_info_t *) context_p->next_scanner_info_p)->end_location.source_p == NULL)
        -: 1612:  {
    #####: 1613:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1614:    {
        -: 1615:      /* Even though the scanning is failed, there might be valid statements
        -: 1616:       * inside the for statement which depend on scanner info blocks. */
    #####: 1617:      scanner_release_next (context_p, sizeof (scanner_for_info_t));
        -: 1618:    }
        -: 1619:
        -: 1620:    /* The prescanner couldn't find the second semicolon or the closing paranthesis. */
    #####: 1621:    lexer_next_token (context_p);
    #####: 1622:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1623:
    #####: 1624:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1625:    {
    #####: 1626:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1627:    }
        -: 1628:
    #####: 1629:    lexer_next_token (context_p);
    #####: 1630:    parser_parse_expression_statement (context_p, PARSE_EXPR);
        -: 1631:
    #####: 1632:    JERRY_ASSERT (context_p->token.type != LEXER_RIGHT_PAREN);
    #####: 1633:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1634:  }
        -: 1635:
    #####: 1636:  parser_for_statement_t for_statement;
    #####: 1637:  scanner_for_info_t *for_info_p = (scanner_for_info_t *) context_p->next_scanner_info_p;
        -: 1638:
    #####: 1639:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &for_statement.branch);
        -: 1640:
    #####: 1641:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1642:
    #####: 1643:  for_statement.start_offset = context_p->byte_code_size;
    #####: 1644:  scanner_get_location (&for_statement.condition_location, context_p);
    #####: 1645:  for_statement.expression_location = for_info_p->expression_location;
        -: 1646:
    #####: 1647:  scanner_set_location (context_p, &for_info_p->end_location);
    #####: 1648:  scanner_release_next (context_p, sizeof (scanner_for_info_t));
    #####: 1649:  scanner_seek (context_p);
    #####: 1650:  lexer_next_token (context_p);
        -: 1651:
    #####: 1652:  loop.branch_list_p = NULL;
        -: 1653:
    #####: 1654:  parser_stack_push (context_p, &for_statement, sizeof (parser_for_statement_t));
    #####: 1655:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 1656:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_FOR);
    #####: 1657:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1658:} /* parser_parse_for_statement_start */
        -: 1659:
        -: 1660:/**
        -: 1661: * Parse for statement (ending part).
        -: 1662: */
        -: 1663:static void JERRY_ATTR_NOINLINE
    #####: 1664:parser_parse_for_statement_end (parser_context_t *context_p) /**< context */
        -: 1665:{
    #####: 1666:  parser_for_statement_t for_statement;
    #####: 1667:  parser_loop_statement_t loop;
        -: 1668:  lexer_token_t current_token;
    #####: 1669:  scanner_location_t location;
        -: 1670:  cbc_opcode_t opcode;
        -: 1671:
    #####: 1672:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_FOR);
        -: 1673:
    #####: 1674:  parser_stack_iterator_t iterator;
    #####: 1675:  parser_stack_iterator_init (context_p, &iterator);
        -: 1676:
    #####: 1677:  parser_stack_iterator_skip (&iterator, 1);
    #####: 1678:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 1679:  parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####: 1680:  parser_stack_iterator_read (&iterator, &for_statement, sizeof (parser_for_statement_t));
        -: 1681:
        -: 1682:#if JERRY_ESNEXT
    #####: 1683:  bool has_block_context = false;
    #####: 1684:  uint8_t next_statement_type;
        -: 1685:
    #####: 1686:  parser_stack_iterator_skip (&iterator, sizeof (parser_for_statement_t));
    #####: 1687:  parser_stack_iterator_read (&iterator, &next_statement_type, 1);
        -: 1688:
    #####: 1689:  if (next_statement_type == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 1690:  {
    #####: 1691:    has_block_context = true;
        -: 1692:  }
        -: 1693:#endif
        -: 1694:
    #####: 1695:  scanner_get_location (&location, context_p);
    #####: 1696:  current_token = context_p->token;
        -: 1697:
    #####: 1698:  scanner_set_location (context_p, &for_statement.expression_location);
    #####: 1699:  scanner_seek (context_p);
    #####: 1700:  lexer_next_token (context_p);
        -: 1701:
    #####: 1702:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 1703:
        -: 1704:#if JERRY_ESNEXT
    #####: 1705:  if (has_block_context)
        -: 1706:  {
    #####: 1707:    parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_FULL_CONTEXT);
        -: 1708:  }
        -: 1709:#endif
        -: 1710:
    #####: 1711:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1712:  {
    #####: 1713:    parser_parse_expression_statement (context_p, PARSE_EXPR);
        -: 1714:
    #####: 1715:    if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1716:    {
    #####: 1717:      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1718:    }
        -: 1719:  }
        -: 1720:
    #####: 1721:  parser_set_branch_to_current_position (context_p, &for_statement.branch);
        -: 1722:
    #####: 1723:  scanner_set_location (context_p, &for_statement.condition_location);
    #####: 1724:  scanner_seek (context_p);
    #####: 1725:  lexer_next_token (context_p);
        -: 1726:
    #####: 1727:  if (context_p->token.type != LEXER_SEMICOLON)
        -: 1728:  {
    #####: 1729:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1730:
    #####: 1731:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1732:    {
    #####: 1733:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1734:    }
        -: 1735:
    #####: 1736:    opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
    #####: 1737:    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 1738:    {
    #####: 1739:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1740:      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -: 1741:    }
    #####: 1742:    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -: 1743:    {
    #####: 1744:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1745:      opcode = CBC_JUMP_BACKWARD;
        -: 1746:    }
        -: 1747:  }
        -: 1748:  else
        -: 1749:  {
    #####: 1750:    opcode = CBC_JUMP_BACKWARD;
        -: 1751:  }
        -: 1752:
    #####: 1753:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_for_statement_t));
    #####: 1754:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1755:
    #####: 1756:  parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, for_statement.start_offset);
    #####: 1757:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
        -: 1758:
        -: 1759:#if JERRY_ESNEXT
    #####: 1760:  if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 1761:      || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 1762:  {
    #####: 1763:    parser_pop_block_context (context_p);
        -: 1764:  }
        -: 1765:#endif
        -: 1766:
        -: 1767:  /* Calling scanner_seek is unnecessary because all
        -: 1768:   * info blocks inside the for statement should be processed. */
    #####: 1769:  scanner_set_location (context_p, &location);
    #####: 1770:  context_p->token = current_token;
    #####: 1771:} /* parser_parse_for_statement_end */
        -: 1772:
        -: 1773:/**
        -: 1774: * Parse switch statement (starting part).
        -: 1775: */
        -: 1776:static void JERRY_ATTR_NOINLINE
    #####: 1777:parser_parse_switch_statement_start (parser_context_t *context_p) /**< context */
        -: 1778:{
    #####: 1779:  parser_switch_statement_t switch_statement;
    #####: 1780:  parser_loop_statement_t loop;
    #####: 1781:  parser_stack_iterator_t iterator;
    #####: 1782:  scanner_location_t start_location;
        -: 1783:  bool switch_case_was_found;
        -: 1784:  bool default_case_was_found;
    #####: 1785:  parser_branch_node_t *case_branches_p = NULL;
        -: 1786:
    #####: 1787:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_SWITCH);
        -: 1788:
    #####: 1789:  parser_parse_enclosed_expr (context_p);
        -: 1790:
    #####: 1791:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1792:  {
    #####: 1793:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 1794:  }
        -: 1795:
        -: 1796:#if JERRY_ESNEXT
    #####: 1797:  if (context_p->next_scanner_info_p->source_p == context_p->source_p - 1)
        -: 1798:  {
    #####: 1799:    parser_push_block_context (context_p, true);
        -: 1800:  }
        -: 1801:#endif /* JERRY_ESNEXT */
        -: 1802:
    #####: 1803:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 1804:                && context_p->next_scanner_info_p->type == SCANNER_TYPE_SWITCH);
        -: 1805:
    #####: 1806:  scanner_case_info_t *case_info_p = ((scanner_switch_info_t *) context_p->next_scanner_info_p)->case_p;
    #####: 1807:  scanner_set_active (context_p);
        -: 1808:
    #####: 1809:  if (case_info_p == NULL)
        -: 1810:  {
    #####: 1811:    lexer_next_token (context_p);
        -: 1812:
    #####: 1813:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1814:    {
    #####: 1815:      scanner_release_active (context_p, sizeof (scanner_switch_info_t));
        -: 1816:
    #####: 1817:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1818:      parser_flush_cbc (context_p);
        -: 1819:
    #####: 1820:      parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
    #####: 1821:      parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 1822:      return;
        -: 1823:    }
        -: 1824:
    #####: 1825:    parser_raise_error (context_p, PARSER_ERR_INVALID_SWITCH);
        -: 1826:  }
        -: 1827:
    #####: 1828:  scanner_get_location (&start_location, context_p);
        -: 1829:
        -: 1830:  /* The reason of using an iterator is error management. If an error
        -: 1831:   * occures, parser_free_jumps() free all data. However, the branches
        -: 1832:   * created by parser_emit_cbc_forward_branch_item() would not be freed.
        -: 1833:   * To free these branches, the current switch data is always stored
        -: 1834:   * on the stack. If any change happens, this data is updated. Updates
        -: 1835:   * are done using the iterator. */
        -: 1836:
    #####: 1837:  switch_statement.branch_list_p = NULL;
    #####: 1838:  loop.branch_list_p = NULL;
        -: 1839:
    #####: 1840:  parser_stack_push (context_p, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 1841:  parser_stack_iterator_init (context_p, &iterator);
    #####: 1842:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 1843:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_SWITCH);
    #####: 1844:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1845:
    #####: 1846:  switch_case_was_found = false;
    #####: 1847:  default_case_was_found = false;
        -: 1848:
        -: 1849:  do
        -: 1850:  {
    #####: 1851:    scanner_set_location (context_p, &case_info_p->location);
    #####: 1852:    scanner_seek (context_p);
    #####: 1853:    case_info_p = case_info_p->next_p;
        -: 1854:
        -: 1855:    /* The last letter of case and default is 'e' and 't' respectively.  */
    #####: 1856:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LOWERCASE_E
        -: 1857:                  || context_p->source_p[-1] == LIT_CHAR_LOWERCASE_T);
        -: 1858:
    #####: 1859:    bool is_default = context_p->source_p[-1] == LIT_CHAR_LOWERCASE_T;
    #####: 1860:    lexer_next_token (context_p);
        -: 1861:
    #####: 1862:    if (is_default)
        -: 1863:    {
    #####: 1864:      if (default_case_was_found)
        -: 1865:      {
    #####: 1866:        parser_raise_error (context_p, PARSER_ERR_MULTIPLE_DEFAULTS_NOT_ALLOWED);
        -: 1867:      }
        -: 1868:
    #####: 1869:      if (context_p->token.type != LEXER_COLON)
        -: 1870:      {
    #####: 1871:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1872:      }
        -: 1873:
    #####: 1874:      default_case_was_found = true;
    #####: 1875:      continue;
        -: 1876:    }
        -: 1877:
    #####: 1878:    switch_case_was_found = true;
        -: 1879:
        -: 1880:#if JERRY_LINE_INFO
    #####: 1881:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 1882:#endif /* JERRY_LINE_INFO */
        -: 1883:
    #####: 1884:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1885:
    #####: 1886:    if (context_p->token.type != LEXER_COLON)
        -: 1887:    {
    #####: 1888:      parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1889:    }
        -: 1890:
    #####: 1891:    uint16_t opcode = CBC_BRANCH_IF_STRICT_EQUAL;
        -: 1892:
    #####: 1893:    if (case_info_p == NULL
    #####: 1894:        || (case_info_p->next_p == NULL && case_info_p->location.source_p[-1] == LIT_CHAR_LOWERCASE_T))
        -: 1895:    {
        -: 1896:      /* There are no more 'case' statements in the switch. */
    #####: 1897:      parser_emit_cbc (context_p, CBC_STRICT_EQUAL);
    #####: 1898:      opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 1899:    }
        -: 1900:
    #####: 1901:    parser_branch_node_t *new_case_p = parser_emit_cbc_forward_branch_item (context_p, opcode, NULL);
        -: 1902:
    #####: 1903:    if (case_branches_p == NULL)
        -: 1904:    {
    #####: 1905:      switch_statement.branch_list_p = new_case_p;
    #####: 1906:      parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 1907:    }
        -: 1908:    else
        -: 1909:    {
    #####: 1910:      case_branches_p->next_p = new_case_p;
        -: 1911:    }
        -: 1912:
    #####: 1913:    case_branches_p = new_case_p;
        -: 1914:  }
    #####: 1915:  while (case_info_p != NULL);
        -: 1916:
    #####: 1917:  JERRY_ASSERT (switch_case_was_found || default_case_was_found);
        -: 1918:
    #####: 1919:  if (!switch_case_was_found)
        -: 1920:  {
        -: 1921:    /* There was no case statement, so the expression result
        -: 1922:     * of the switch must be popped from the stack */
    #####: 1923:    parser_emit_cbc (context_p, CBC_POP);
        -: 1924:  }
        -: 1925:
    #####: 1926:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &switch_statement.default_branch);
    #####: 1927:  parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 1928:
    #####: 1929:  if (!default_case_was_found)
        -: 1930:  {
    #####: 1931:    parser_stack_change_last_uint8 (context_p, PARSER_STATEMENT_SWITCH_NO_DEFAULT);
        -: 1932:  }
        -: 1933:
    #####: 1934:  scanner_release_switch_cases (((scanner_switch_info_t *) context_p->active_scanner_info_p)->case_p);
    #####: 1935:  scanner_release_active (context_p, sizeof (scanner_switch_info_t));
        -: 1936:
    #####: 1937:  scanner_set_location (context_p, &start_location);
    #####: 1938:  scanner_seek (context_p);
    #####: 1939:  lexer_next_token (context_p);
        -: 1940:} /* parser_parse_switch_statement_start */
        -: 1941:
        -: 1942:/**
        -: 1943: * Parse try statement (ending part).
        -: 1944: */
        -: 1945:static void
        2: 1946:parser_parse_try_statement_end (parser_context_t *context_p) /**< context */
        -: 1947:{
        2: 1948:  parser_try_statement_t try_statement;
        2: 1949:  parser_stack_iterator_t iterator;
        -: 1950:
        2: 1951:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY);
        -: 1952:
        2: 1953:  parser_stack_iterator_init (context_p, &iterator);
        2: 1954:  parser_stack_iterator_skip (&iterator, 1);
        2: 1955:  parser_stack_iterator_read (&iterator, &try_statement, sizeof (parser_try_statement_t));
        -: 1956:
        -: 1957:#if JERRY_ESNEXT
        2: 1958:  context_p->scope_stack_top = try_statement.scope_stack_top;
        2: 1959:  context_p->scope_stack_reg_top = try_statement.scope_stack_reg_top;
        -: 1960:#endif /* JERRY_ESNEXT */
        -: 1961:
        2: 1962:  lexer_next_token (context_p);
        -: 1963:
        2: 1964:  if (try_statement.type == parser_finally_block)
        -: 1965:  {
    #####: 1966:    parser_flush_cbc (context_p);
    #####: 1967:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
        -: 1968:#ifndef JERRY_NDEBUG
    #####: 1969:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
        -: 1970:#endif /* !JERRY_NDEBUG */
        -: 1971:
    #####: 1972:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####: 1973:    parser_set_branch_to_current_position (context_p, &try_statement.branch);
        -: 1974:  }
        -: 1975:  else
        -: 1976:  {
        2: 1977:    parser_set_branch_to_current_position (context_p, &try_statement.branch);
        -: 1978:
        2: 1979:    if (try_statement.type == parser_catch_block)
        -: 1980:    {
        -: 1981:#if !JERRY_ESNEXT
    #####: 1982:      context_p->scope_stack_top = try_statement.scope_stack_top;
    #####: 1983:      context_p->scope_stack_reg_top = try_statement.scope_stack_reg_top;
        -: 1984:#endif /* !JERRY_ESNEXT */
        -: 1985:
        1: 1986:      if (context_p->token.type != LEXER_KEYW_FINALLY)
        -: 1987:      {
        1: 1988:        parser_flush_cbc (context_p);
        1: 1989:        PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 1990:#ifndef JERRY_NDEBUG
        1: 1991:        PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 1992:#endif /* !JERRY_NDEBUG */
        -: 1993:
        1: 1994:        parser_emit_cbc (context_p, CBC_CONTEXT_END);
        1: 1995:        parser_flush_cbc (context_p);
        -: 1996:
        1: 1997:        try_statement.type = parser_finally_block;
        -: 1998:      }
        -: 1999:    }
        -: 2000:    else
        -: 2001:    {
        1: 2002:      JERRY_ASSERT (try_statement.type == parser_try_block);
        -: 2003:
        1: 2004:      if (context_p->token.type != LEXER_KEYW_CATCH
    #####: 2005:          && context_p->token.type != LEXER_KEYW_FINALLY)
        -: 2006:      {
    #####: 2007:        parser_raise_error (context_p, PARSER_ERR_CATCH_FINALLY_EXPECTED);
        -: 2008:      }
        -: 2009:    }
        -: 2010:  }
        -: 2011:
        2: 2012:  if (try_statement.type == parser_finally_block)
        -: 2013:  {
        1: 2014:    parser_stack_pop (context_p, NULL, (uint32_t) (sizeof (parser_try_statement_t) + 1));
        1: 2015:    parser_stack_iterator_init (context_p, &context_p->last_statement);
        1: 2016:    return;
        -: 2017:  }
        -: 2018:
        1: 2019:  if (context_p->token.type == LEXER_KEYW_CATCH)
        -: 2020:  {
        1: 2021:    lexer_next_token (context_p);
        -: 2022:
        1: 2023:    try_statement.type = parser_catch_block;
        1: 2024:    parser_emit_cbc_ext_forward_branch (context_p,
        -: 2025:                                        CBC_EXT_CATCH,
        -: 2026:                                        &try_statement.branch);
        -: 2027:
        1: 2028:    try_statement.scope_stack_top = context_p->scope_stack_top;
        1: 2029:    try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2030:
        -: 2031:#ifndef JERRY_NDEBUG
        1: 2032:    bool block_found = false;
        -: 2033:#endif /* !JERRY_NDEBUG */
        -: 2034:
        1: 2035:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2036:    {
        1: 2037:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 2038:#ifndef JERRY_NDEBUG
        1: 2039:      block_found = true;
        -: 2040:#endif /* !JERRY_NDEBUG */
        -: 2041:
        1: 2042:      if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 2043:      {
    #####: 2044:        parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 2045:      }
        -: 2046:
        1: 2047:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 2048:    }
        -: 2049:
        1: 2050:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2051:    {
        -: 2052:#if JERRY_ESNEXT
        1: 2053:      if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -: 2054:      {
    #####: 2055:        parser_pattern_flags_t flags = (PARSER_PATTERN_BINDING
        -: 2056:                                        | PARSER_PATTERN_TARGET_ON_STACK
        -: 2057:                                        | PARSER_PATTERN_LET);
        -: 2058:
    #####: 2059:        parser_parse_initializer_by_next_char (context_p, flags);
        -: 2060:      }
        -: 2061:      else
        -: 2062:      {
        -: 2063:#endif /* JERRY_ESNEXT */
        1: 2064:        lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        1: 2065:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 2066:                      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 2067:
        -: 2068:#if JERRY_ESNEXT
        1: 2069:        uint16_t literal_index = context_p->lit_object.index;
        2: 2070:        parser_emit_cbc_literal (context_p,
        1: 2071:                                 (literal_index >= PARSER_REGISTER_START) ? CBC_ASSIGN_SET_IDENT : CBC_ASSIGN_LET_CONST,
        -: 2072:                                 literal_index);
        -: 2073:#else /* !JERRY_ESNEXT */
    #####: 2074:        parser_emit_cbc_literal (context_p, CBC_ASSIGN_SET_IDENT, context_p->lit_object.index);
        -: 2075:#endif /* JERRY_ESNEXT */
        -: 2076:
        1: 2077:        lexer_next_token (context_p);
        -: 2078:
        -: 2079:#ifndef JERRY_NDEBUG
        1: 2080:        JERRY_ASSERT (block_found);
        -: 2081:#endif /* !JERRY_NDEBUG */
        -: 2082:#if JERRY_ESNEXT
        -: 2083:      }
        -: 2084:#endif /* JERRY_ESNEXT */
        -: 2085:
        1: 2086:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2087:      {
    #####: 2088:        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2089:      }
        -: 2090:
        1: 2091:      lexer_next_token (context_p);
        -: 2092:
        1: 2093:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2094:      {
    #####: 2095:        parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2096:      }
        -: 2097:    }
        -: 2098:#if JERRY_ESNEXT
    #####: 2099:    else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2100:    {
    #####: 2101:      parser_emit_cbc (context_p, CBC_POP);
        -: 2102:    }
        -: 2103:#endif /* JERRY_ESNEXT */
        -: 2104:    else
        -: 2105:    {
    #####: 2106:      parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 2107:    }
        -: 2108:
        1: 2109:    parser_flush_cbc (context_p);
        -: 2110:  }
        -: 2111:  else
        -: 2112:  {
    #####: 2113:    JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FINALLY);
        -: 2114:
    #####: 2115:    lexer_next_token (context_p);
        -: 2116:
    #####: 2117:    if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2118:    {
    #####: 2119:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2120:    }
        -: 2121:
        -: 2122:#ifndef JERRY_NDEBUG
    #####: 2123:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
        -: 2124:#endif /* !JERRY_NDEBUG */
        -: 2125:
    #####: 2126:    try_statement.type = parser_finally_block;
    #####: 2127:    parser_emit_cbc_ext_forward_branch (context_p,
        -: 2128:                                        CBC_EXT_FINALLY,
        -: 2129:                                        &try_statement.branch);
        -: 2130:
        -: 2131:#if JERRY_ESNEXT
    #####: 2132:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2133:    {
    #####: 2134:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 2135:
    #####: 2136:      if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 2137:      {
    #####: 2138:        parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 2139:      }
        -: 2140:
    #####: 2141:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 2142:    }
        -: 2143:#endif /* JERRY_ESNEXT */
        -: 2144:  }
        -: 2145:
        1: 2146:  lexer_next_token (context_p);
        1: 2147:  parser_stack_iterator_write (&iterator, &try_statement, sizeof (parser_try_statement_t));
        -: 2148:} /* parser_parse_try_statement_end */
        -: 2149:
        -: 2150:/**
        -: 2151: * Parse default statement.
        -: 2152: */
        -: 2153:static void
    #####: 2154:parser_parse_default_statement (parser_context_t *context_p) /**< context */
        -: 2155:{
    #####: 2156:  parser_stack_iterator_t iterator;
    #####: 2157:  parser_switch_statement_t switch_statement;
        -: 2158:
    #####: 2159:  if (context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH
    #####: 2160:      && context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 2161:  {
    #####: 2162:    parser_raise_error (context_p, PARSER_ERR_DEFAULT_NOT_IN_SWITCH);
        -: 2163:  }
        -: 2164:
    #####: 2165:  lexer_next_token (context_p);
        -: 2166:  /* Already checked in parser_parse_switch_statement_start. */
    #####: 2167:  JERRY_ASSERT (context_p->token.type == LEXER_COLON);
    #####: 2168:  lexer_next_token (context_p);
        -: 2169:
    #####: 2170:  parser_stack_iterator_init (context_p, &iterator);
    #####: 2171:  parser_stack_iterator_skip (&iterator, 1 + sizeof (parser_loop_statement_t));
    #####: 2172:  parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2173:
    #####: 2174:  parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);
    #####: 2175:} /* parser_parse_default_statement */
        -: 2176:
        -: 2177:/**
        -: 2178: * Parse case statement.
        -: 2179: */
        -: 2180:static void
    #####: 2181:parser_parse_case_statement (parser_context_t *context_p) /**< context */
        -: 2182:{
    #####: 2183:  parser_stack_iterator_t iterator;
    #####: 2184:  parser_switch_statement_t switch_statement;
        -: 2185:  parser_branch_node_t *branch_p;
        -: 2186:
    #####: 2187:  if (context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH
    #####: 2188:      && context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 2189:  {
    #####: 2190:    parser_raise_error (context_p, PARSER_ERR_CASE_NOT_IN_SWITCH);
        -: 2191:  }
        -: 2192:
    #####: 2193:  if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -: 2194:  {
    #####: 2195:    lexer_next_token (context_p);
        -: 2196:
    #####: 2197:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 2198:
    #####: 2199:    JERRY_ASSERT (context_p->token.type != LEXER_COLON);
    #####: 2200:    parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 2201:  }
        -: 2202:
    #####: 2203:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CASE);
        -: 2204:
    #####: 2205:  scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 2206:  scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 2207:  scanner_seek (context_p);
    #####: 2208:  lexer_next_token (context_p);
        -: 2209:
    #####: 2210:  parser_stack_iterator_init (context_p, &iterator);
    #####: 2211:  parser_stack_iterator_skip (&iterator, 1 + sizeof (parser_loop_statement_t));
    #####: 2212:  parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2213:
        -: 2214:  /* Free memory after the case statement is found. */
        -: 2215:
    #####: 2216:  branch_p = switch_statement.branch_list_p;
    #####: 2217:  JERRY_ASSERT (branch_p != NULL);
    #####: 2218:  switch_statement.branch_list_p = branch_p->next_p;
    #####: 2219:  parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2220:
    #####: 2221:  parser_set_branch_to_current_position (context_p, &branch_p->branch);
    #####: 2222:  parser_free (branch_p, sizeof (parser_branch_node_t));
    #####: 2223:} /* parser_parse_case_statement */
        -: 2224:
        -: 2225:/**
        -: 2226: * Parse break statement.
        -: 2227: */
        -: 2228:static void
    #####: 2229:parser_parse_break_statement (parser_context_t *context_p) /**< context */
        -: 2230:{
    #####: 2231:  parser_stack_iterator_t iterator;
    #####: 2232:  cbc_opcode_t opcode = CBC_JUMP_FORWARD;
        -: 2233:
    #####: 2234:  lexer_next_token (context_p);
    #####: 2235:  parser_stack_iterator_init (context_p, &iterator);
        -: 2236:
    #####: 2237:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 2238:      && context_p->token.type == LEXER_LITERAL
    #####: 2239:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2240:  {
        -: 2241:    /* The label with the same name is searched on the stack. */
        -: 2242:    while (true)
    #####: 2243:    {
    #####: 2244:      uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2245:      if (type == PARSER_STATEMENT_START)
        -: 2246:      {
    #####: 2247:        parser_raise_error (context_p, PARSER_ERR_INVALID_BREAK_LABEL);
        -: 2248:      }
        -: 2249:
    #####: 2250:      if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2251:      {
    #####: 2252:        opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2253:      }
        -: 2254:
    #####: 2255:      if (type == PARSER_STATEMENT_LABEL)
        -: 2256:      {
    #####: 2257:        parser_label_statement_t label_statement;
        -: 2258:
    #####: 2259:        parser_stack_iterator_skip (&iterator, 1);
    #####: 2260:        parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
        -: 2261:
    #####: 2262:        if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2263:        {
    #####: 2264:          label_statement.break_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2265:                                                                              (uint16_t) opcode,
        -: 2266:                                                                              label_statement.break_list_p);
    #####: 2267:          parser_stack_iterator_write (&iterator, &label_statement, sizeof (parser_label_statement_t));
    #####: 2268:          lexer_next_token (context_p);
    #####: 2269:          return;
        -: 2270:        }
    #####: 2271:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
        -: 2272:      }
        -: 2273:      else
        -: 2274:      {
    #####: 2275:        parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2276:      }
        -: 2277:    }
        -: 2278:  }
        -: 2279:
        -: 2280:  /* The first switch or loop statement is searched. */
        -: 2281:  while (true)
    #####: 2282:  {
    #####: 2283:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2284:    if (type == PARSER_STATEMENT_START)
        -: 2285:    {
    #####: 2286:      parser_raise_error (context_p, PARSER_ERR_INVALID_BREAK);
        -: 2287:    }
        -: 2288:
    #####: 2289:    if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2290:    {
    #####: 2291:      opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2292:    }
        -: 2293:
    #####: 2294:    if (parser_statement_flags[type] & PARSER_STATM_BREAK_TARGET)
        -: 2295:    {
    #####: 2296:      parser_loop_statement_t loop;
        -: 2297:
    #####: 2298:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2299:      parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2300:      loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2301:                                                                (uint16_t) opcode,
        -: 2302:                                                                loop.branch_list_p);
    #####: 2303:      parser_stack_iterator_write (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2304:      return;
        -: 2305:    }
        -: 2306:
    #####: 2307:    parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2308:  }
        -: 2309:} /* parser_parse_break_statement */
        -: 2310:
        -: 2311:/**
        -: 2312: * Parse continue statement.
        -: 2313: */
        -: 2314:static void
    #####: 2315:parser_parse_continue_statement (parser_context_t *context_p) /**< context */
        -: 2316:{
    #####: 2317:  parser_stack_iterator_t iterator;
    #####: 2318:  cbc_opcode_t opcode = CBC_JUMP_FORWARD;
        -: 2319:
    #####: 2320:  lexer_next_token (context_p);
    #####: 2321:  parser_stack_iterator_init (context_p, &iterator);
        -: 2322:
    #####: 2323:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 2324:      && context_p->token.type == LEXER_LITERAL
    #####: 2325:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2326:  {
    #####: 2327:    parser_stack_iterator_t loop_iterator;
        -: 2328:
    #####: 2329:    loop_iterator.current_p = NULL;
        -: 2330:
        -: 2331:    /* The label with the same name is searched on the stack. */
        -: 2332:    while (true)
    #####: 2333:    {
    #####: 2334:      uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
        -: 2335:
    #####: 2336:      if (type == PARSER_STATEMENT_START)
        -: 2337:      {
    #####: 2338:        parser_raise_error (context_p, PARSER_ERR_INVALID_CONTINUE_LABEL);
        -: 2339:      }
        -: 2340:
        -: 2341:      /* Only those labels are checked, whose are label of a loop. */
    #####: 2342:      if (loop_iterator.current_p != NULL && type == PARSER_STATEMENT_LABEL)
        -: 2343:      {
    #####: 2344:        parser_label_statement_t label_statement;
        -: 2345:
    #####: 2346:        parser_stack_iterator_skip (&iterator, 1);
    #####: 2347:        parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
        -: 2348:
    #####: 2349:        if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2350:        {
    #####: 2351:          parser_loop_statement_t loop;
        -: 2352:
    #####: 2353:          parser_stack_iterator_skip (&loop_iterator, 1);
    #####: 2354:          parser_stack_iterator_read (&loop_iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2355:          loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2356:                                                                    (uint16_t) opcode,
        -: 2357:                                                                    loop.branch_list_p);
    #####: 2358:          loop.branch_list_p->branch.offset |= CBC_HIGHEST_BIT_MASK;
    #####: 2359:          parser_stack_iterator_write (&loop_iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2360:          lexer_next_token (context_p);
    #####: 2361:          return;
        -: 2362:        }
    #####: 2363:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
    #####: 2364:        continue;
        -: 2365:      }
        -: 2366:
    #####: 2367:      if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2368:      {
    #####: 2369:        opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2370:      }
        -: 2371:
        -: 2372:#if JERRY_ESNEXT
    #####: 2373:      const bool is_private_scope = (type == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 2374:                                     || type == PARSER_STATEMENT_PRIVATE_CONTEXT);
        -: 2375:#else /* !JERRY_ESNEXT */
    #####: 2376:      const bool is_private_scope = false;
        -: 2377:#endif /* !JERRY_ESNEXT */
        -: 2378:
    #####: 2379:      if (parser_statement_flags[type] & PARSER_STATM_CONTINUE_TARGET)
        -: 2380:      {
    #####: 2381:        loop_iterator = iterator;
        -: 2382:      }
    #####: 2383:      else if (!is_private_scope)
        -: 2384:      {
    #####: 2385:        loop_iterator.current_p = NULL;
        -: 2386:      }
        -: 2387:
    #####: 2388:      parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2389:    }
        -: 2390:  }
        -: 2391:
        -: 2392:  /* The first loop statement is searched. */
        -: 2393:  while (true)
    #####: 2394:  {
    #####: 2395:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2396:    if (type == PARSER_STATEMENT_START)
        -: 2397:    {
    #####: 2398:      parser_raise_error (context_p, PARSER_ERR_INVALID_CONTINUE);
        -: 2399:    }
        -: 2400:
    #####: 2401:    if (parser_statement_flags[type] & PARSER_STATM_CONTINUE_TARGET)
        -: 2402:    {
    #####: 2403:      parser_loop_statement_t loop;
        -: 2404:
    #####: 2405:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2406:      parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2407:      loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2408:                                                                (uint16_t) opcode,
        -: 2409:                                                                loop.branch_list_p);
    #####: 2410:      loop.branch_list_p->branch.offset |= CBC_HIGHEST_BIT_MASK;
    #####: 2411:      parser_stack_iterator_write (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2412:      return;
        -: 2413:    }
        -: 2414:
    #####: 2415:    if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2416:    {
    #####: 2417:      opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2418:    }
        -: 2419:
    #####: 2420:    parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2421:  }
        -: 2422:} /* parser_parse_continue_statement */
        -: 2423:
        -: 2424:#if JERRY_MODULE_SYSTEM
        -: 2425:/**
        -: 2426: * Parse import statement.
        -: 2427: * Note: See 15.2.2
        -: 2428: */
        -: 2429:static void
    #####: 2430:parser_parse_import_statement (parser_context_t *context_p) /**< parser context */
        -: 2431:{
    #####: 2432:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_IMPORT);
    #####: 2433:  JERRY_ASSERT (context_p->module_names_p == NULL);
        -: 2434:
    #####: 2435:  if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_PAREN, LIT_CHAR_DOT))
        -: 2436:  {
    #####: 2437:    if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 2438:    {
    #####: 2439:      parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 2440:      return;
        -: 2441:    }
        -: 2442:
    #####: 2443:    parser_parse_block_expression (context_p, PARSE_EXPR);
    #####: 2444:    return;
        -: 2445:  }
        -: 2446:
    #####: 2447:  parser_module_check_request_place (context_p);
    #####: 2448:  lexer_next_token (context_p);
        -: 2449:
        -: 2450:  /* Check for a ModuleSpecifier*/
    #####: 2451:  if (context_p->token.type != LEXER_LITERAL
    #####: 2452:      || context_p->token.lit_location.type != LEXER_STRING_LITERAL)
        -: 2453:  {
    #####: 2454:    if (!(context_p->token.type == LEXER_LEFT_BRACE
    #####: 2455:          || context_p->token.type == LEXER_MULTIPLY
    #####: 2456:          || (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)))
        -: 2457:    {
    #####: 2458:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_LITERAL_EXPECTED);
        -: 2459:    }
        -: 2460:
    #####: 2461:    if (context_p->token.type == LEXER_LITERAL)
        -: 2462:    {
        -: 2463:      /* Handle ImportedDefaultBinding */
    #####: 2464:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 2465:
    #####: 2466:      ecma_string_t *local_name_p = parser_new_ecma_string_from_literal (context_p->lit_object.literal_p);
        -: 2467:
    #####: 2468:      if (parser_module_check_duplicate_import (context_p, local_name_p))
        -: 2469:      {
    #####: 2470:        ecma_deref_ecma_string (local_name_p);
    #####: 2471:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_IMPORT_BINDING);
        -: 2472:      }
        -: 2473:
    #####: 2474:      ecma_string_t *import_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_DEFAULT);
    #####: 2475:      parser_module_add_names_to_node (context_p, import_name_p, local_name_p);
        -: 2476:
    #####: 2477:      ecma_deref_ecma_string (local_name_p);
    #####: 2478:      ecma_deref_ecma_string (import_name_p);
        -: 2479:
    #####: 2480:      lexer_next_token (context_p);
        -: 2481:
    #####: 2482:      if (context_p->token.type == LEXER_COMMA)
        -: 2483:      {
    #####: 2484:        lexer_next_token (context_p);
    #####: 2485:        if (context_p->token.type != LEXER_MULTIPLY
    #####: 2486:            && context_p->token.type != LEXER_LEFT_BRACE)
        -: 2487:        {
    #####: 2488:          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_EXPECTED);
        -: 2489:        }
        -: 2490:      }
    #####: 2491:      else if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2492:      {
    #####: 2493:        parser_raise_error (context_p, PARSER_ERR_FROM_COMMA_EXPECTED);
        -: 2494:      }
        -: 2495:    }
        -: 2496:
    #####: 2497:    if (context_p->token.type == LEXER_MULTIPLY)
        -: 2498:    {
        -: 2499:      /* NameSpaceImport */
    #####: 2500:      lexer_next_token (context_p);
    #####: 2501:      if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 2502:      {
    #####: 2503:        parser_raise_error (context_p, PARSER_ERR_AS_EXPECTED);
        -: 2504:      }
        -: 2505:
    #####: 2506:      lexer_next_token (context_p);
    #####: 2507:      if (context_p->token.type != LEXER_LITERAL)
        -: 2508:      {
    #####: 2509:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2510:      }
        -: 2511:
    #####: 2512:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 2513:
    #####: 2514:      ecma_string_t *local_name_p = parser_new_ecma_string_from_literal (context_p->lit_object.literal_p);
        -: 2515:
    #####: 2516:      if (parser_module_check_duplicate_import (context_p, local_name_p))
        -: 2517:      {
    #####: 2518:        ecma_deref_ecma_string (local_name_p);
    #####: 2519:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_IMPORT_BINDING);
        -: 2520:      }
        -: 2521:
    #####: 2522:      ecma_string_t *import_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_ASTERIX_CHAR);
        -: 2523:
    #####: 2524:      parser_module_add_names_to_node (context_p, import_name_p, local_name_p);
    #####: 2525:      ecma_deref_ecma_string (local_name_p);
    #####: 2526:      ecma_deref_ecma_string (import_name_p);
        -: 2527:
    #####: 2528:      lexer_next_token (context_p);
        -: 2529:    }
    #####: 2530:    else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2531:    {
        -: 2532:      /* Handle NamedImports */
    #####: 2533:      parser_module_parse_import_clause (context_p);
        -: 2534:    }
        -: 2535:
    #####: 2536:    if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2537:    {
    #####: 2538:      parser_raise_error (context_p, PARSER_ERR_FROM_EXPECTED);
        -: 2539:    }
    #####: 2540:    lexer_next_token (context_p);
        -: 2541:  }
        -: 2542:
    #####: 2543:  parser_module_handle_module_specifier (context_p, NULL);
        -: 2544:} /* parser_parse_import_statement */
        -: 2545:
        -: 2546:/**
        -: 2547: * Parse export statement.
        -: 2548: *
        -: 2549: * @return true - if function of class statement was found
        -: 2550: *         false - otherwise
        -: 2551: */
        -: 2552:static bool
    #####: 2553:parser_parse_export_statement (parser_context_t *context_p) /**< context */
        -: 2554:{
    #####: 2555:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_EXPORT);
    #####: 2556:  JERRY_ASSERT (context_p->module_names_p == NULL);
        -: 2557:
    #####: 2558:  parser_module_check_request_place (context_p);
        -: 2559:
    #####: 2560:  bool consume_last_statement = false;
        -: 2561:
    #####: 2562:  lexer_next_token (context_p);
    #####: 2563:  switch (context_p->token.type)
        -: 2564:  {
    #####: 2565:    case LEXER_KEYW_DEFAULT:
        -: 2566:    {
    #####: 2567:      scanner_location_t location;
    #####: 2568:      scanner_get_location (&location, context_p);
        -: 2569:
    #####: 2570:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
        -: 2571:
    #####: 2572:      lexer_next_token (context_p);
        -: 2573:
    #####: 2574:      if (context_p->token.type == LEXER_LITERAL
    #####: 2575:          && lexer_token_is_async (context_p)
    #####: 2576:          && context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 2577:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)
        -: 2578:      {
        -: 2579:#if JERRY_FUNCTION_TO_STRING
    #####: 2580:        context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2581:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 2582:        lexer_next_token (context_p);
        -: 2583:      }
        -: 2584:
    #####: 2585:      if (context_p->token.type == LEXER_KEYW_CLASS)
        -: 2586:      {
    #####: 2587:        context_p->status_flags |= PARSER_MODULE_DEFAULT_CLASS_OR_FUNC;
    #####: 2588:        parser_parse_class (context_p, true);
    #####: 2589:        consume_last_statement = true;
        -: 2590:      }
    #####: 2591:      else if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 2592:      {
    #####: 2593:        context_p->status_flags |= PARSER_MODULE_DEFAULT_CLASS_OR_FUNC;
    #####: 2594:        parser_parse_function_statement (context_p);
    #####: 2595:        consume_last_statement = true;
        -: 2596:      }
        -: 2597:      else
        -: 2598:      {
        -: 2599:        /* Assignment expression */
    #####: 2600:        scanner_set_location (context_p, &location);
        -: 2601:
        -: 2602:        /* 15.2.3.5 Use the synthetic name '*default*' as the identifier. */
    #####: 2603:        lexer_construct_literal_object (context_p, &lexer_default_literal, lexer_default_literal.type);
        -: 2604:
    #####: 2605:        context_p->token.lit_location.type = LEXER_IDENT_LITERAL;
    #####: 2606:        parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 2607:
        -: 2608:        /* Do not overwrite this identifier. */
    #####: 2609:        context_p->status_flags &= (uint32_t) ~PARSER_MODULE_STORE_IDENT;
    #####: 2610:        context_p->module_identifier_lit_p = context_p->lit_object.literal_p;
        -: 2611:
        -: 2612:        /* Fake an assignment to the default identifier */
    #####: 2613:        context_p->token.type = LEXER_ASSIGN;
        -: 2614:
    #####: 2615:        parser_parse_expression_statement (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_HAS_LITERAL);
        -: 2616:      }
        -: 2617:
    #####: 2618:      ecma_string_t *name_p = parser_new_ecma_string_from_literal (context_p->module_identifier_lit_p);
        -: 2619:
    #####: 2620:      ecma_string_t *export_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_DEFAULT);
        -: 2621:
    #####: 2622:      if (parser_module_check_duplicate_export (context_p, export_name_p))
        -: 2623:      {
    #####: 2624:        ecma_deref_ecma_string (name_p);
    #####: 2625:        ecma_deref_ecma_string (export_name_p);
    #####: 2626:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);
        -: 2627:      }
        -: 2628:
    #####: 2629:      parser_module_add_names_to_node (context_p,
        -: 2630:                                       export_name_p,
        -: 2631:                                       name_p);
    #####: 2632:      ecma_deref_ecma_string (name_p);
    #####: 2633:      ecma_deref_ecma_string (export_name_p);
    #####: 2634:      break;
        -: 2635:    }
    #####: 2636:    case LEXER_MULTIPLY:
        -: 2637:    {
    #####: 2638:      lexer_next_token (context_p);
        -: 2639:
    #####: 2640:      ecma_module_node_t **target_node_list_p = &(JERRY_CONTEXT (module_current_p)->star_exports_p);
        -: 2641:
    #####: 2642:      if (lexer_token_is_identifier (context_p, "as", 2))
        -: 2643:      {
    #####: 2644:        target_node_list_p = &(JERRY_CONTEXT (module_current_p)->indirect_exports_p);
        -: 2645:
    #####: 2646:        lexer_next_token (context_p);
        -: 2647:
    #####: 2648:        if (context_p->token.type != LEXER_LITERAL
    #####: 2649:            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2650:        {
    #####: 2651:          parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2652:        }
        -: 2653:
    #####: 2654:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
        -: 2655:
    #####: 2656:        lexer_literal_t *literal_p = PARSER_GET_LITERAL (context_p->lit_object.index);
    #####: 2657:        ecma_string_t *export_name_p = parser_new_ecma_string_from_literal (literal_p);
        -: 2658:
    #####: 2659:        if (parser_module_check_duplicate_export (context_p, export_name_p))
        -: 2660:        {
    #####: 2661:          ecma_deref_ecma_string (export_name_p);
    #####: 2662:          parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);
        -: 2663:        }
        -: 2664:
    #####: 2665:        ecma_string_t *local_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_ASTERIX_CHAR);
    #####: 2666:        parser_module_add_names_to_node (context_p, export_name_p, local_name_p);
    #####: 2667:        ecma_deref_ecma_string (export_name_p);
        -: 2668:
    #####: 2669:        lexer_next_token (context_p);
        -: 2670:      }
        -: 2671:
    #####: 2672:      if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2673:      {
    #####: 2674:        parser_raise_error (context_p, PARSER_ERR_FROM_EXPECTED);
        -: 2675:      }
        -: 2676:
    #####: 2677:      lexer_next_token (context_p);
    #####: 2678:      parser_module_handle_module_specifier (context_p, target_node_list_p);
    #####: 2679:      return false;
        -: 2680:    }
    #####: 2681:    case LEXER_KEYW_VAR:
        -: 2682:    case LEXER_KEYW_LET:
        -: 2683:    case LEXER_KEYW_CONST:
        -: 2684:    {
    #####: 2685:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2686:      parser_parse_var_statement (context_p);
    #####: 2687:      break;
        -: 2688:    }
    #####: 2689:    case LEXER_KEYW_CLASS:
        -: 2690:    {
    #####: 2691:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2692:      parser_parse_class (context_p, true);
    #####: 2693:      consume_last_statement = true;
    #####: 2694:      break;
        -: 2695:    }
    #####: 2696:    case LEXER_KEYW_FUNCTION:
        -: 2697:    {
    #####: 2698:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2699:      parser_parse_function_statement (context_p);
    #####: 2700:      consume_last_statement = true;
    #####: 2701:      break;
        -: 2702:    }
    #####: 2703:    case LEXER_LEFT_BRACE:
        -: 2704:    {
    #####: 2705:      parser_module_parse_export_clause (context_p);
        -: 2706:
    #####: 2707:      if (lexer_token_is_identifier (context_p, "from", 4))
        -: 2708:      {
    #####: 2709:        lexer_next_token (context_p);
    #####: 2710:        parser_module_handle_module_specifier (context_p, &(JERRY_CONTEXT (module_current_p)->indirect_exports_p));
    #####: 2711:        return false;
        -: 2712:      }
    #####: 2713:      break;
        -: 2714:    }
    #####: 2715:    default:
        -: 2716:    {
    #####: 2717:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_LITERAL_EXPECTED);
    #####: 2718:      break;
        -: 2719:    }
        -: 2720:  }
        -: 2721:
    #####: 2722:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_DEFAULT_CLASS_OR_FUNC | PARSER_MODULE_STORE_IDENT);
    #####: 2723:  parser_module_append_names (context_p, &(JERRY_CONTEXT (module_current_p)->local_exports_p));
        -: 2724:
    #####: 2725:  return consume_last_statement;
        -: 2726:} /* parser_parse_export_statement */
        -: 2727:#endif /* JERRY_MODULE_SYSTEM */
        -: 2728:
        -: 2729:/**
        -: 2730: * Parse label statement.
        -: 2731: */
        -: 2732:static void
    #####: 2733:parser_parse_label (parser_context_t *context_p) /**< context */
        -: 2734:{
    #####: 2735:  parser_stack_iterator_t iterator;
    #####: 2736:  parser_label_statement_t label_statement;
        -: 2737:
    #####: 2738:  parser_stack_iterator_init (context_p, &iterator);
        -: 2739:
        -: 2740:  while (true)
    #####: 2741:  {
    #####: 2742:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2743:    if (type == PARSER_STATEMENT_START)
        -: 2744:    {
    #####: 2745:      break;
        -: 2746:    }
        -: 2747:
    #####: 2748:    if (type == PARSER_STATEMENT_LABEL)
        -: 2749:    {
    #####: 2750:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2751:      parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
    #####: 2752:      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
        -: 2753:
    #####: 2754:      if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2755:      {
    #####: 2756:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_LABEL);
        -: 2757:      }
        -: 2758:    }
        -: 2759:    else
        -: 2760:    {
    #####: 2761:      parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2762:    }
        -: 2763:  }
        -: 2764:
    #####: 2765:  label_statement.label_ident = context_p->token.lit_location;
    #####: 2766:  label_statement.break_list_p = NULL;
    #####: 2767:  parser_stack_push (context_p, &label_statement, sizeof (parser_label_statement_t));
    #####: 2768:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_LABEL);
    #####: 2769:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 2770:} /* parser_parse_label */
        -: 2771:
        -: 2772:/**
        -: 2773: * Strict mode types for statement parsing.
        -: 2774: */
        -: 2775:typedef enum
        -: 2776:{
        -: 2777:  PARSER_USE_STRICT_NOT_FOUND = 0, /**< 'use strict' directive is not found */
        -: 2778:  PARSER_USE_STRICT_FOUND = 1, /**< 'use strict' directive is found but strict mode has already been enabled */
        -: 2779:  PARSER_USE_STRICT_SET = 2, /**< strict mode is enabled after 'use strict' directive is found */
        -: 2780:} parser_strict_mode_type_t;
        -: 2781:
        -: 2782:/**
        -: 2783: * Parse statements.
        -: 2784: */
        -: 2785:void
        3: 2786:parser_parse_statements (parser_context_t *context_p) /**< context */
        -: 2787:{
        -: 2788:  /* Statement parsing cannot be nested. */
        3: 2789:  JERRY_ASSERT (context_p->last_statement.current_p == NULL);
        3: 2790:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_START);
        3: 2791:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 2792:
        -: 2793:#if JERRY_DEBUGGER
        -: 2794:  /* Set lexical enviroment for the debugger. */
        -: 2795:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2796:  {
        -: 2797:    context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2798:    context_p->last_breakpoint_line = 0;
        -: 2799:  }
        -: 2800:#endif /* JERRY_DEBUGGER */
        -: 2801:
        6: 2802:  while (context_p->token.type == LEXER_LITERAL
        1: 2803:         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 2804:  {
    #####: 2805:    lexer_lit_location_t lit_location;
    #####: 2806:    parser_strict_mode_type_t strict_mode = PARSER_USE_STRICT_NOT_FOUND;
        -: 2807:
    #####: 2808:    JERRY_ASSERT (context_p->stack_depth <= 1);
        -: 2809:#ifndef JERRY_NDEBUG
    #####: 2810:    JERRY_ASSERT (context_p->context_stack_depth == context_p->stack_depth);
        -: 2811:#endif /* !JERRY_NDEBUG */
        -: 2812:
    #####: 2813:    if (lexer_string_is_use_strict (context_p))
        -: 2814:    {
    #####: 2815:      strict_mode = PARSER_USE_STRICT_FOUND;
        -: 2816:
    #####: 2817:      if (!(context_p->status_flags & PARSER_IS_STRICT))
        -: 2818:      {
        -: 2819:        /* The next token should be parsed in strict mode. */
    #####: 2820:        context_p->status_flags |= PARSER_IS_STRICT;
    #####: 2821:        strict_mode = PARSER_USE_STRICT_SET;
        -: 2822:      }
        -: 2823:    }
        -: 2824:
    #####: 2825:    lit_location = context_p->token.lit_location;
    #####: 2826:    lexer_next_token (context_p);
        -: 2827:
    #####: 2828:    if (!lexer_string_is_directive (context_p))
        -: 2829:    {
        -: 2830:      /* The string is part of an expression statement. */
    #####: 2831:      if (strict_mode == PARSER_USE_STRICT_SET)
        -: 2832:      {
    #####: 2833:        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 2834:      }
        -: 2835:
        -: 2836:#if JERRY_DEBUGGER
        -: 2837:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2838:      {
        -: 2839:        JERRY_ASSERT (context_p->last_breakpoint_line == 0);
        -: 2840:
        -: 2841:        parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 2842:        parser_flush_cbc (context_p);
        -: 2843:
        -: 2844:        parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -: 2845:
        -: 2846:        context_p->last_breakpoint_line = context_p->token.line;
        -: 2847:      }
        -: 2848:#endif /* JERRY_DEBUGGER */
        -: 2849:#if JERRY_LINE_INFO
    #####: 2850:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2851:#endif /* JERRY_LINE_INFO */
        -: 2852:
    #####: 2853:      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);
    #####: 2854:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 2855:      /* The extra_value is used for saving the token. */
    #####: 2856:      context_p->token.extra_value = context_p->token.type;
    #####: 2857:      context_p->token.type = LEXER_EXPRESSION_START;
    #####: 2858:      break;
        -: 2859:    }
        -: 2860:
        -: 2861:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2862:    if (strict_mode == PARSER_USE_STRICT_SET && context_p->is_show_opcodes)
        -: 2863:    {
        -: 2864:      JERRY_DEBUG_MSG ("  Note: switch to strict mode\n\n");
        -: 2865:    }
        -: 2866:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2867:
        -: 2868:#if JERRY_ESNEXT
    #####: 2869:    if (strict_mode != PARSER_USE_STRICT_NOT_FOUND
    #####: 2870:        && (context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT))
        -: 2871:    {
    #####: 2872:      parser_raise_error (context_p, PARSER_ERR_USE_STRICT_NOT_ALLOWED);
        -: 2873:    }
        -: 2874:#endif /* JERRY_ESNEXT */
        -: 2875:
    #####: 2876:    if (context_p->token.type == LEXER_SEMICOLON)
        -: 2877:    {
    #####: 2878:      lexer_next_token (context_p);
        -: 2879:    }
        -: 2880:
        -: 2881:    /* The last directive prologue can be the result of the script. */
    #####: 2882:    if (!(context_p->status_flags & PARSER_IS_FUNCTION)
    #####: 2883:        && (context_p->token.type != LEXER_LITERAL
    #####: 2884:            || context_p->token.lit_location.type != LEXER_STRING_LITERAL))
        -: 2885:    {
    #####: 2886:      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);
    #####: 2887:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 2888:      parser_emit_cbc (context_p, CBC_POP_BLOCK);
    #####: 2889:      parser_flush_cbc (context_p);
    #####: 2890:      break;
        -: 2891:    }
        -: 2892:  }
        -: 2893:
        3: 2894:  if (context_p->status_flags & PARSER_IS_STRICT
    #####: 2895:      && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2896:  {
    #####: 2897:    parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2898:  }
        -: 2899:
       19: 2900:  while (context_p->token.type != LEXER_EOS
        1: 2901:         || context_p->stack_top_uint8 != PARSER_STATEMENT_START)
        -: 2902:  {
        -: 2903:#ifndef JERRY_NDEBUG
       15: 2904:    JERRY_ASSERT (context_p->stack_depth == context_p->context_stack_depth);
        -: 2905:#endif /* !JERRY_NDEBUG */
        -: 2906:
        -: 2907:#if JERRY_ESNEXT
       15: 2908:    JERRY_ASSERT (context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_SCOPE
        -: 2909:                  && context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_CONTEXT);
        -: 2910:#endif /* JERRY_ESNEXT */
        -: 2911:
        -: 2912:#if JERRY_DEBUGGER
        -: 2913:    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED
        -: 2914:        && context_p->token.line != context_p->last_breakpoint_line
        -: 2915:        && context_p->token.type != LEXER_SEMICOLON
        -: 2916:        && context_p->token.type != LEXER_LEFT_BRACE
        -: 2917:        && context_p->token.type != LEXER_RIGHT_BRACE
        -: 2918:        && context_p->token.type != LEXER_KEYW_VAR
        -: 2919:        && context_p->token.type != LEXER_KEYW_LET
        -: 2920:        && context_p->token.type != LEXER_KEYW_CONST
        -: 2921:        && context_p->token.type != LEXER_KEYW_FUNCTION
        -: 2922:        && context_p->token.type != LEXER_KEYW_CASE
        -: 2923:        && context_p->token.type != LEXER_KEYW_DEFAULT)
        -: 2924:    {
        -: 2925:      parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 2926:      parser_flush_cbc (context_p);
        -: 2927:
        -: 2928:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -: 2929:
        -: 2930:      context_p->last_breakpoint_line = context_p->token.line;
        -: 2931:    }
        -: 2932:#endif /* JERRY_DEBUGGER */
        -: 2933:
        -: 2934:#if JERRY_LINE_INFO
    #####: 2935:    if (context_p->token.type != LEXER_SEMICOLON
    #####: 2936:        && context_p->token.type != LEXER_LEFT_BRACE
    #####: 2937:        && context_p->token.type != LEXER_RIGHT_BRACE
    #####: 2938:        && context_p->token.type != LEXER_KEYW_VAR
    #####: 2939:        && context_p->token.type != LEXER_KEYW_LET
    #####: 2940:        && context_p->token.type != LEXER_KEYW_CONST
    #####: 2941:        && context_p->token.type != LEXER_KEYW_FUNCTION
    #####: 2942:        && context_p->token.type != LEXER_KEYW_CASE
    #####: 2943:        && context_p->token.type != LEXER_KEYW_DEFAULT)
        -: 2944:    {
    #####: 2945:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2946:    }
        -: 2947:#endif /* JERRY_LINE_INFO */
        -: 2948:
       15: 2949:    switch (context_p->token.type)
        -: 2950:    {
    #####: 2951:      case LEXER_SEMICOLON:
        -: 2952:      {
    #####: 2953:        break;
        -: 2954:      }
        -: 2955:
        4: 2956:      case LEXER_RIGHT_BRACE:
        -: 2957:      {
        4: 2958:        if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -: 2959:        {
    #####: 2960:          parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);
        -: 2961:        }
        4: 2962:        break;
        -: 2963:      }
        -: 2964:
    #####: 2965:      case LEXER_LEFT_BRACE:
        -: 2966:      {
        -: 2967:#if JERRY_ESNEXT
    #####: 2968:        if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2969:        {
    #####: 2970:          parser_push_block_context (context_p, false);
        -: 2971:        }
        -: 2972:        else
        -: 2973:        {
    #####: 2974:          parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
        -: 2975:        }
        -: 2976:#else /* !JERRY_ESNEXT */
    #####: 2977:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
        -: 2978:#endif /* JERRY_ESNEXT */
        -: 2979:
    #####: 2980:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 2981:        lexer_next_token (context_p);
    #####: 2982:        continue;
        -: 2983:      }
        -: 2984:
        3: 2985:      case LEXER_KEYW_VAR:
        -: 2986:#if JERRY_ESNEXT
        -: 2987:      case LEXER_KEYW_LET:
        -: 2988:      case LEXER_KEYW_CONST:
        -: 2989:#endif /* JERRY_ESNEXT */
        -: 2990:      {
        3: 2991:        parser_parse_var_statement (context_p);
        3: 2992:        break;
        -: 2993:      }
        -: 2994:
        -: 2995:#if JERRY_ESNEXT
    #####: 2996:      case LEXER_KEYW_CLASS:
        -: 2997:      {
    #####: 2998:        parser_validate_lexical_context (context_p);
    #####: 2999:        parser_parse_class (context_p, true);
    #####: 3000:        goto consume_last_statement;
        -: 3001:      }
        -: 3002:#endif /* JERRY_ESNEXT */
        -: 3003:
        -: 3004:#if JERRY_MODULE_SYSTEM
    #####: 3005:      case LEXER_KEYW_IMPORT:
        -: 3006:      {
    #####: 3007:        parser_parse_import_statement (context_p);
    #####: 3008:        break;
        -: 3009:      }
        -: 3010:
    #####: 3011:      case LEXER_KEYW_EXPORT:
        -: 3012:      {
    #####: 3013:        if (parser_parse_export_statement (context_p))
        -: 3014:        {
    #####: 3015:          goto consume_last_statement;
        -: 3016:        }
    #####: 3017:        break;
        -: 3018:      }
        -: 3019:#endif /* JERRY_MODULE_SYSTEM */
        -: 3020:
    #####: 3021:      case LEXER_KEYW_FUNCTION:
        -: 3022:      {
    #####: 3023:        parser_parse_function_statement (context_p);
    #####: 3024:        goto consume_last_statement;
        -: 3025:      }
        -: 3026:
    #####: 3027:      case LEXER_KEYW_IF:
        -: 3028:      {
    #####: 3029:        parser_parse_if_statement_start (context_p);
    #####: 3030:        continue;
        -: 3031:      }
        -: 3032:
    #####: 3033:      case LEXER_KEYW_SWITCH:
        -: 3034:      {
    #####: 3035:        parser_parse_switch_statement_start (context_p);
    #####: 3036:        continue;
        -: 3037:      }
        -: 3038:
    #####: 3039:      case LEXER_KEYW_DO:
        -: 3040:      {
    #####: 3041:        parser_do_while_statement_t do_while_statement;
    #####: 3042:        parser_loop_statement_t loop;
        -: 3043:
    #####: 3044:        JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 3045:
    #####: 3046:        do_while_statement.start_offset = context_p->byte_code_size;
    #####: 3047:        loop.branch_list_p = NULL;
        -: 3048:
    #####: 3049:        parser_stack_push (context_p, &do_while_statement, sizeof (parser_do_while_statement_t));
    #####: 3050:        parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 3051:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_DO_WHILE);
    #####: 3052:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 3053:        lexer_next_token (context_p);
    #####: 3054:        continue;
        -: 3055:      }
        -: 3056:
    #####: 3057:      case LEXER_KEYW_WHILE:
        -: 3058:      {
    #####: 3059:        parser_parse_while_statement_start (context_p);
    #####: 3060:        continue;
        -: 3061:      }
        -: 3062:
        1: 3063:      case LEXER_KEYW_FOR:
        -: 3064:      {
        1: 3065:        parser_parse_for_statement_start (context_p);
        1: 3066:        continue;
        -: 3067:      }
        -: 3068:
    #####: 3069:      case LEXER_KEYW_WITH:
        -: 3070:      {
    #####: 3071:        parser_parse_with_statement_start (context_p);
    #####: 3072:        continue;
        -: 3073:      }
        -: 3074:
        1: 3075:      case LEXER_KEYW_TRY:
        -: 3076:      {
        1: 3077:        parser_try_statement_t try_statement;
        -: 3078:
        1: 3079:        lexer_next_token (context_p);
        -: 3080:
        1: 3081:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 3082:        {
    #####: 3083:          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 3084:        }
        -: 3085:
        -: 3086:#ifndef JERRY_NDEBUG
        1: 3087:        PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 3088:#endif /* !JERRY_NDEBUG */
        -: 3089:
        1: 3090:        try_statement.type = parser_try_block;
        1: 3091:        parser_emit_cbc_ext_forward_branch (context_p,
        -: 3092:                                            CBC_EXT_TRY_CREATE_CONTEXT,
        -: 3093:                                            &try_statement.branch);
        -: 3094:
        -: 3095:#if JERRY_ESNEXT
        1: 3096:        try_statement.scope_stack_top = context_p->scope_stack_top;
        1: 3097:        try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 3098:
        1: 3099:        if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3100:        {
    #####: 3101:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 3102:
    #####: 3103:          if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 3104:          {
    #####: 3105:            parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 3106:          }
        -: 3107:
    #####: 3108:          scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 3109:        }
        -: 3110:#endif /* JERRY_ESNEXT */
        -: 3111:
        1: 3112:        parser_stack_push (context_p, &try_statement, sizeof (parser_try_statement_t));
        1: 3113:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_TRY);
        1: 3114:        parser_stack_iterator_init (context_p, &context_p->last_statement);
        1: 3115:        lexer_next_token (context_p);
        1: 3116:        continue;
        -: 3117:      }
        -: 3118:
    #####: 3119:      case LEXER_KEYW_DEFAULT:
        -: 3120:      {
    #####: 3121:        parser_parse_default_statement (context_p);
    #####: 3122:        continue;
        -: 3123:      }
        -: 3124:
    #####: 3125:      case LEXER_KEYW_CASE:
        -: 3126:      {
    #####: 3127:        parser_parse_case_statement (context_p);
    #####: 3128:        continue;
        -: 3129:      }
        -: 3130:
    #####: 3131:      case LEXER_KEYW_BREAK:
        -: 3132:      {
    #####: 3133:        parser_parse_break_statement (context_p);
    #####: 3134:        break;
        -: 3135:      }
        -: 3136:
    #####: 3137:      case LEXER_KEYW_CONTINUE:
        -: 3138:      {
    #####: 3139:        parser_parse_continue_statement (context_p);
    #####: 3140:        break;
        -: 3141:      }
        -: 3142:
    #####: 3143:      case LEXER_KEYW_THROW:
        -: 3144:      {
    #####: 3145:        lexer_next_token (context_p);
    #####: 3146:        if (context_p->token.flags & LEXER_WAS_NEWLINE)
        -: 3147:        {
    #####: 3148:          parser_raise_error (context_p, PARSER_ERR_EXPRESSION_EXPECTED);
        -: 3149:        }
    #####: 3150:        parser_parse_expression (context_p, PARSE_EXPR);
    #####: 3151:        parser_emit_cbc (context_p, CBC_THROW);
    #####: 3152:        break;
        -: 3153:      }
        -: 3154:
        1: 3155:      case LEXER_KEYW_RETURN:
        -: 3156:      {
        1: 3157:        if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 3158:        {
    #####: 3159:          parser_raise_error (context_p, PARSER_ERR_INVALID_RETURN);
        -: 3160:        }
        -: 3161:
        1: 3162:        lexer_next_token (context_p);
        -: 3163:
        1: 3164:        if ((context_p->token.flags & LEXER_WAS_NEWLINE)
        1: 3165:            || context_p->token.type == LEXER_SEMICOLON
        1: 3166:            || context_p->token.type == LEXER_EOS
        1: 3167:            || context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3168:        {
        -: 3169:#if JERRY_ESNEXT
    #####: 3170:          if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 3171:          {
    #####: 3172:            parser_emit_cbc_ext (context_p, CBC_EXT_RETURN_UNDEFINED);
    #####: 3173:            break;
        -: 3174:          }
        -: 3175:#endif /* JERRY_ESNEXT */
        -: 3176:
    #####: 3177:          parser_emit_cbc (context_p, CBC_RETURN_FUNCTION_END);
    #####: 3178:          break;
        -: 3179:        }
        -: 3180:
        1: 3181:        parser_parse_expression (context_p, PARSE_EXPR);
        -: 3182:
        1: 3183:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3184:        {
    #####: 3185:          context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
    #####: 3186:          break;
        -: 3187:        }
        -: 3188:
        1: 3189:        parser_emit_cbc (context_p, CBC_RETURN);
        1: 3190:        break;
        -: 3191:      }
        -: 3192:
    #####: 3193:      case LEXER_KEYW_DEBUGGER:
        -: 3194:      {
        -: 3195:#if JERRY_DEBUGGER
        -: 3196:        /* This breakpoint location is not reported to the
        -: 3197:         * debugger, so it is impossible to disable it. */
        -: 3198:        if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3199:        {
        -: 3200:          parser_emit_cbc (context_p, CBC_BREAKPOINT_ENABLED);
        -: 3201:        }
        -: 3202:#endif /* JERRY_DEBUGGER */
    #####: 3203:        lexer_next_token (context_p);
    #####: 3204:        break;
        -: 3205:      }
        -: 3206:
        5: 3207:      case LEXER_LITERAL:
        -: 3208:      {
        5: 3209:        if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 3210:        {
        5: 3211:          if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))
        -: 3212:          {
    #####: 3213:            parser_parse_label (context_p);
    #####: 3214:            lexer_consume_next_character (context_p);
    #####: 3215:            lexer_next_token (context_p);
    #####: 3216:            continue;
        -: 3217:          }
        -: 3218:#if JERRY_ESNEXT
        5: 3219:          if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))
        -: 3220:          {
    #####: 3221:            if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3222:            {
    #####: 3223:              if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 3224:              {
    #####: 3225:                scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3226:              }
        -: 3227:
    #####: 3228:              if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 3229:              {
    #####: 3230:                parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 3231:                break;
        -: 3232:              }
        -: 3233:
    #####: 3234:              parser_parse_block_expression (context_p, PARSE_EXPR);
    #####: 3235:              break;
        -: 3236:            }
        -: 3237:
    #####: 3238:            context_p->token.type = LEXER_KEYW_LET;
    #####: 3239:            parser_parse_var_statement (context_p);
    #####: 3240:            break;
        -: 3241:          }
        -: 3242:
        5: 3243:          if (JERRY_UNLIKELY (lexer_token_is_async (context_p))
    #####: 3244:              && context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3245:          {
    #####: 3246:            bool is_statement = true;
        -: 3247:
    #####: 3248:            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)
        -: 3249:            {
    #####: 3250:              is_statement = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT) != 0;
        -: 3251:
    #####: 3252:              JERRY_ASSERT (!is_statement || (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC));
        -: 3253:            }
        -: 3254:            else
        -: 3255:            {
    #####: 3256:              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);
        -: 3257:
    #####: 3258:              scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3259:            }
        -: 3260:
    #####: 3261:            if (is_statement)
        -: 3262:            {
    #####: 3263:              if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -: 3264:              {
    #####: 3265:                parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -: 3266:              }
        -: 3267:
        -: 3268:#if JERRY_FUNCTION_TO_STRING
    #####: 3269:              context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 3270:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 3271:              lexer_next_token (context_p);
    #####: 3272:              JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);
    #####: 3273:              continue;
        -: 3274:            }
        -: 3275:          }
        -: 3276:#endif /* JERRY_ESNEXT */
        -: 3277:        }
        -: 3278:        /* FALLTHRU */
        -: 3279:      }
        -: 3280:
        -: 3281:      default:
        -: 3282:      {
        5: 3283:        int options = PARSE_EXPR;
        -: 3284:
        5: 3285:        if (context_p->token.type == LEXER_EXPRESSION_START)
        -: 3286:        {
        -: 3287:          /* Restore the token type form the extra_value. */
    #####: 3288:          context_p->token.type = context_p->token.extra_value;
    #####: 3289:          options |= PARSE_EXPR_HAS_LITERAL;
        -: 3290:        }
        -: 3291:
        5: 3292:        if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 3293:        {
        2: 3294:          parser_parse_expression_statement (context_p, options);
        -: 3295:        }
        -: 3296:        else
        -: 3297:        {
        3: 3298:          parser_parse_block_expression (context_p, options);
        -: 3299:        }
        -: 3300:
        5: 3301:        break;
        -: 3302:      }
        -: 3303:    }
        -: 3304:
       13: 3305:    parser_flush_cbc (context_p);
        -: 3306:
       13: 3307:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3308:    {
        4: 3309:      if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK)
        -: 3310:      {
    #####: 3311:        parser_stack_pop_uint8 (context_p);
    #####: 3312:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 3313:        lexer_next_token (context_p);
        -: 3314:      }
        -: 3315:#if JERRY_ESNEXT
        4: 3316:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE
        4: 3317:               || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT)
        -: 3318:      {
    #####: 3319:        parser_pop_block_context (context_p);
    #####: 3320:        lexer_next_token (context_p);
        -: 3321:      }
        -: 3322:#endif /* JERRY_ESNEXT */
        4: 3323:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH
        4: 3324:               || context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 3325:      {
    #####: 3326:        int has_default = (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH);
    #####: 3327:        parser_loop_statement_t loop;
    #####: 3328:        parser_switch_statement_t switch_statement;
        -: 3329:
    #####: 3330:        parser_stack_pop_uint8 (context_p);
    #####: 3331:        parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 3332:        parser_stack_pop (context_p, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 3333:        parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3334:
    #####: 3335:        JERRY_ASSERT (switch_statement.branch_list_p == NULL);
        -: 3336:
    #####: 3337:        if (!has_default)
        -: 3338:        {
    #####: 3339:          parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);
        -: 3340:        }
        -: 3341:
    #####: 3342:        parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
    #####: 3343:        lexer_next_token (context_p);
        -: 3344:
        -: 3345:#if JERRY_ESNEXT
    #####: 3346:        if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 3347:            || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 3348:        {
    #####: 3349:          parser_pop_block_context (context_p);
        -: 3350:        }
        -: 3351:#endif /* JERRY_ESNEXT */
        -: 3352:      }
        4: 3353:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY)
        -: 3354:      {
        2: 3355:        parser_parse_try_statement_end (context_p);
        -: 3356:      }
        2: 3357:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_START)
        -: 3358:      {
        2: 3359:        if (context_p->status_flags & PARSER_IS_CLOSURE)
        -: 3360:        {
        -: 3361:#if JERRY_LINE_INFO
    #####: 3362:          if (context_p->line_info_p == NULL)
        -: 3363:          {
    #####: 3364:            parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3365:          }
        -: 3366:#endif /* JERRY_LINE_INFO */
        -: 3367:
        -: 3368:#if JERRY_FUNCTION_TO_STRING
    #####: 3369:          context_p->function_end_p = context_p->source_p;
        -: 3370:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 3371:
        2: 3372:          parser_stack_pop_uint8 (context_p);
        2: 3373:          context_p->last_statement.current_p = NULL;
        -: 3374:          /* There is no lexer_next_token here, since the
        -: 3375:           * next token belongs to the parent context. */
        2: 3376:          return;
        -: 3377:        }
    #####: 3378:        parser_raise_error (context_p, PARSER_ERR_INVALID_RIGHT_SQUARE);
        -: 3379:      }
        -: 3380:    }
        9: 3381:    else if (context_p->token.type == LEXER_SEMICOLON)
        -: 3382:    {
        9: 3383:      lexer_next_token (context_p);
        -: 3384:    }
    #####: 3385:    else if (context_p->token.type != LEXER_EOS
    #####: 3386:             && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 3387:    {
    #####: 3388:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 3389:    }
        -: 3390:
       11: 3391:consume_last_statement:
        -: 3392:    while (true)
        -: 3393:    {
       13: 3394:      switch (context_p->stack_top_uint8)
        -: 3395:      {
    #####: 3396:        case PARSER_STATEMENT_LABEL:
        -: 3397:        {
    #####: 3398:          parser_label_statement_t label;
        -: 3399:
    #####: 3400:          parser_stack_pop_uint8 (context_p);
    #####: 3401:          parser_stack_pop (context_p, &label, sizeof (parser_label_statement_t));
    #####: 3402:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3403:
    #####: 3404:          parser_set_breaks_to_current_position (context_p, label.break_list_p);
    #####: 3405:          continue;
        -: 3406:        }
        -: 3407:
    #####: 3408:        case PARSER_STATEMENT_IF:
        -: 3409:        {
    #####: 3410:          if (parser_parse_if_statement_end (context_p))
        -: 3411:          {
    #####: 3412:            break;
        -: 3413:          }
    #####: 3414:          continue;
        -: 3415:        }
        -: 3416:
    #####: 3417:        case PARSER_STATEMENT_ELSE:
        -: 3418:        {
    #####: 3419:          parser_if_else_statement_t else_statement;
        -: 3420:
    #####: 3421:          parser_stack_pop_uint8 (context_p);
    #####: 3422:          parser_stack_pop (context_p, &else_statement, sizeof (parser_if_else_statement_t));
    #####: 3423:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3424:
    #####: 3425:          parser_set_branch_to_current_position (context_p, &else_statement.branch);
    #####: 3426:          continue;
        -: 3427:        }
        -: 3428:
    #####: 3429:        case PARSER_STATEMENT_DO_WHILE:
        -: 3430:        {
    #####: 3431:          parser_parse_do_while_statement_end (context_p);
    #####: 3432:          if (context_p->token.type == LEXER_SEMICOLON)
        -: 3433:          {
    #####: 3434:            lexer_next_token (context_p);
        -: 3435:          }
    #####: 3436:          continue;
        -: 3437:        }
        -: 3438:
    #####: 3439:        case PARSER_STATEMENT_WHILE:
        -: 3440:        {
    #####: 3441:          parser_parse_while_statement_end (context_p);
    #####: 3442:          continue;
        -: 3443:        }
        -: 3444:
    #####: 3445:        case PARSER_STATEMENT_FOR:
        -: 3446:        {
    #####: 3447:          parser_parse_for_statement_end (context_p);
    #####: 3448:          continue;
        -: 3449:        }
        -: 3450:
        1: 3451:        case PARSER_STATEMENT_FOR_IN:
        -: 3452:#if JERRY_ESNEXT
        -: 3453:        case PARSER_STATEMENT_FOR_OF:
        -: 3454:        case PARSER_STATEMENT_FOR_AWAIT_OF:
        -: 3455:#endif /* JERRY_ESNEXT */
        -: 3456:        {
        1: 3457:          parser_for_in_of_statement_t for_in_of_statement;
        1: 3458:          parser_loop_statement_t loop;
        -: 3459:
        -: 3460:#if JERRY_ESNEXT
        1: 3461:          uint8_t for_type = context_p->stack_top_uint8;
        -: 3462:#endif /* JERRY_ESNEXT */
        -: 3463:
        1: 3464:          parser_stack_pop_uint8 (context_p);
        1: 3465:          parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));
        1: 3466:          parser_stack_pop (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));
        1: 3467:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3468:
        1: 3469:          parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 3470:
        1: 3471:          parser_flush_cbc (context_p);
        -: 3472:
        1: 3473:          uint16_t stack_allocation = PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 3474:#if JERRY_ESNEXT
        1: 3475:          if (for_type != PARSER_STATEMENT_FOR_IN)
        -: 3476:          {
    #####: 3477:            stack_allocation = (for_type == PARSER_STATEMENT_FOR_OF ? PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION
        -: 3478:                                                                    : PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
        -: 3479:          }
        -: 3480:#endif /* JERRY_ESNEXT */
        -: 3481:
        1: 3482:          PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, stack_allocation);
        -: 3483:#ifndef JERRY_NDEBUG
        1: 3484:          PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, stack_allocation);
        -: 3485:#endif /* !JERRY_NDEBUG */
        -: 3486:
        1: 3487:          cbc_ext_opcode_t opcode = CBC_EXT_BRANCH_IF_FOR_IN_HAS_NEXT;
        -: 3488:
        -: 3489:#if JERRY_ESNEXT
        1: 3490:          if (for_type != PARSER_STATEMENT_FOR_IN)
        -: 3491:          {
    #####: 3492:            opcode = (for_type == PARSER_STATEMENT_FOR_OF ? CBC_EXT_BRANCH_IF_FOR_OF_HAS_NEXT
    #####: 3493:                                                          : CBC_EXT_BRANCH_IF_FOR_AWAIT_OF_HAS_NEXT);
        -: 3494:          }
        -: 3495:#endif /* JERRY_ESNEXT */
        -: 3496:
        1: 3497:          parser_emit_cbc_ext_backward_branch (context_p, opcode, for_in_of_statement.start_offset);
        -: 3498:
        1: 3499:          parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
        1: 3500:          parser_set_branch_to_current_position (context_p, &for_in_of_statement.branch);
        -: 3501:
        -: 3502:#if JERRY_ESNEXT
        1: 3503:          if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        1: 3504:              || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 3505:          {
    #####: 3506:            parser_pop_block_context (context_p);
        -: 3507:          }
        -: 3508:#endif /* JERRY_ESNEXT */
        1: 3509:          continue;
        -: 3510:        }
        -: 3511:
    #####: 3512:        case PARSER_STATEMENT_WITH:
        -: 3513:        {
    #####: 3514:          parser_parse_with_statement_end (context_p);
    #####: 3515:          continue;
        -: 3516:        }
        -: 3517:
       11: 3518:        default:
        -: 3519:        {
       11: 3520:          break;
        -: 3521:        }
        -: 3522:      }
       11: 3523:      break;
        -: 3524:    }
        -: 3525:  }
        -: 3526:
        1: 3527:  parser_stack_pop_uint8 (context_p);
        1: 3528:  context_p->last_statement.current_p = NULL;
        -: 3529:
        1: 3530:  if (context_p->status_flags & PARSER_IS_CLOSURE)
        -: 3531:  {
    #####: 3532:    parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);
        -: 3533:  }
        -: 3534:
        -: 3535:#if JERRY_LINE_INFO
    #####: 3536:  if (context_p->line_info_p == NULL)
        -: 3537:  {
    #####: 3538:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3539:  }
        -: 3540:#endif /* JERRY_LINE_INFO */
        -: 3541:} /* parser_parse_statements */
        -: 3542:
        -: 3543:/**
        -: 3544: * Free jumps stored on the stack if a parse error is occured.
        -: 3545: */
        -: 3546:void JERRY_ATTR_NOINLINE
    #####: 3547:parser_free_jumps (parser_stack_iterator_t iterator) /**< iterator position */
        -: 3548:{
        -: 3549:  while (true)
    #####: 3550:  {
    #####: 3551:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 3552:    parser_branch_node_t *branch_list_p = NULL;
        -: 3553:
    #####: 3554:    switch (type)
        -: 3555:    {
    #####: 3556:      case PARSER_STATEMENT_START:
        -: 3557:      {
    #####: 3558:        return;
        -: 3559:      }
        -: 3560:
    #####: 3561:      case PARSER_STATEMENT_LABEL:
        -: 3562:      {
    #####: 3563:        parser_label_statement_t label;
        -: 3564:
    #####: 3565:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3566:        parser_stack_iterator_read (&iterator, &label, sizeof (parser_label_statement_t));
    #####: 3567:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
    #####: 3568:        branch_list_p = label.break_list_p;
    #####: 3569:        break;
        -: 3570:      }
        -: 3571:
    #####: 3572:      case PARSER_STATEMENT_SWITCH:
        -: 3573:      case PARSER_STATEMENT_SWITCH_NO_DEFAULT:
        -: 3574:      {
    #####: 3575:        parser_switch_statement_t switch_statement;
    #####: 3576:        parser_loop_statement_t loop;
        -: 3577:
    #####: 3578:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3579:        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 3580:        parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####: 3581:        parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 3582:        parser_stack_iterator_skip (&iterator, sizeof (parser_switch_statement_t));
        -: 3583:
    #####: 3584:        branch_list_p = switch_statement.branch_list_p;
    #####: 3585:        while (branch_list_p != NULL)
        -: 3586:        {
    #####: 3587:          parser_branch_node_t *next_p = branch_list_p->next_p;
    #####: 3588:          parser_free (branch_list_p, sizeof (parser_branch_node_t));
    #####: 3589:          branch_list_p = next_p;
        -: 3590:        }
    #####: 3591:        branch_list_p = loop.branch_list_p;
    #####: 3592:        break;
        -: 3593:      }
        -: 3594:
    #####: 3595:      case PARSER_STATEMENT_DO_WHILE:
        -: 3596:      case PARSER_STATEMENT_WHILE:
        -: 3597:      case PARSER_STATEMENT_FOR:
        -: 3598:      case PARSER_STATEMENT_FOR_IN:
        -: 3599:#if JERRY_ESNEXT
        -: 3600:      case PARSER_STATEMENT_FOR_OF:
        -: 3601:#endif /* JERRY_ESNEXT */
        -: 3602:      {
    #####: 3603:        parser_loop_statement_t loop;
        -: 3604:
    #####: 3605:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3606:        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 3607:        parser_stack_iterator_skip (&iterator, parser_statement_length (type) - 1);
    #####: 3608:        branch_list_p = loop.branch_list_p;
    #####: 3609:        break;
        -: 3610:      }
        -: 3611:
    #####: 3612:      default:
        -: 3613:      {
    #####: 3614:        parser_stack_iterator_skip (&iterator, parser_statement_length (type));
    #####: 3615:        continue;
        -: 3616:      }
        -: 3617:    }
        -: 3618:
    #####: 3619:    while (branch_list_p != NULL)
        -: 3620:    {
    #####: 3621:      parser_branch_node_t *next_p = branch_list_p->next_p;
    #####: 3622:      parser_free (branch_list_p, sizeof (parser_branch_node_t));
    #####: 3623:      branch_list_p = next_p;
        -: 3624:    }
        -: 3625:  }
        -: 3626:} /* parser_free_jumps */
        -: 3627:
        -: 3628:/**
        -: 3629: * @}
        -: 3630: * @}
        -: 3631: * @}
        -: 3632: */
        -: 3633:
        -: 3634:#endif /* JERRY_PARSER */
