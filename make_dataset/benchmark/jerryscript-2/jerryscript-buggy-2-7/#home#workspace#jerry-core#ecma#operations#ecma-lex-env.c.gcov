        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-lex-env.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-builtin-helpers.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-gc.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "ecma-lex-env.h"
        -:   23:#include "ecma-objects.h"
        -:   24:#include "ecma-proxy-object.h"
        -:   25:#include "jcontext.h"
        -:   26:
        -:   27:/** \addtogroup ecma ECMA
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup lexicalenvironment Lexical environment
        -:   31: * @{
        -:   32: *
        -:   33: * \addtogroup globallexicalenvironment Global lexical environment
        -:   34: * @{
        -:   35: */
        -:   36:
        -:   37:/**
        -:   38: * Initialize Global environment
        -:   39: */
        -:   40:void
        1:   41:ecma_init_global_environment (void)
        -:   42:{
        1:   43:  JERRY_CONTEXT (global_object_p) = ecma_builtin_create_global_object ();
        1:   44:} /* ecma_init_global_environment */
        -:   45:
        -:   46:/**
        -:   47: * Finalize Global environment
        -:   48: */
        -:   49:void
    #####:   50:ecma_finalize_global_environment (void)
        -:   51:{
        -:   52:  /* After this point the gc can free the global object, but the global_object_p pointer
        -:   53:   * is not set to NULL because the global object might still be used before the free. */
    #####:   54:  ecma_deref_object ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
    #####:   55:} /* ecma_finalize_global_environment */
        -:   56:
        -:   57:/**
        -:   58: * Get reference to Global lexical environment
        -:   59: * without increasing its reference count.
        -:   60: *
        -:   61: * @return pointer to the object's instance
        -:   62: */
        -:   63:ecma_object_t *
    #####:   64:ecma_get_global_environment (ecma_object_t *global_object_p) /**< global object */
        -:   65:{
    #####:   66:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
    #####:   67:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_env_cp);
        -:   68:} /* ecma_get_global_environment */
        -:   69:
        -:   70:#if JERRY_ESNEXT
        -:   71:/**
        -:   72: * Create the global lexical block on top of the global environment.
        -:   73: */
        -:   74:void
    #####:   75:ecma_create_global_lexical_block (ecma_object_t *global_object_p) /**< global object */
        -:   76:{
    #####:   77:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
        -:   78:
    #####:   79:  ecma_global_object_t *real_global_object_p = (ecma_global_object_t *) global_object_p;
        -:   80:
    #####:   81:  if (real_global_object_p->global_scope_cp == real_global_object_p->global_env_cp)
        -:   82:  {
    #####:   83:    ecma_object_t *global_scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:   84:    global_scope_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####:   85:    ECMA_SET_NON_NULL_POINTER (real_global_object_p->global_scope_cp, global_scope_p);
    #####:   86:    ecma_deref_object (global_scope_p);
        -:   87:  }
    #####:   88:} /* ecma_create_global_lexical_block */
        -:   89:#endif /* JERRY_ESNEXT */
        -:   90:
        -:   91:/**
        -:   92: * Raise the appropriate error when setting a binding is failed
        -:   93: *
        -:   94: * @return ECMA_VALUE_EMPTY or ECMA_VALUE_ERROR
        -:   95: */
        -:   96:ecma_value_t
    #####:   97:ecma_op_raise_set_binding_error (ecma_property_t *property_p, /**< property */
        -:   98:                                 bool is_strict) /**< flag indicating strict mode */
        -:   99:{
        -:  100:  JERRY_UNUSED (property_p);
        -:  101:
        -:  102:#if JERRY_ESNEXT
    #####:  103:  const ecma_property_t expected_bits = (ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_ENUMERABLE);
        -:  104:
    #####:  105:  if ((*property_p & expected_bits) == expected_bits)
        -:  106:  {
    #####:  107:    ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  108:
    #####:  109:    if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  110:    {
    #####:  111:      return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:  112:    }
        -:  113:
    #####:  114:    JERRY_ASSERT (!ecma_is_property_writable (*property_p));
        -:  115:
    #####:  116:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constant bindings cannot be reassigned"));
        -:  117:  }
        -:  118:#endif /* JERRY_ESNEXT */
        -:  119:
    #####:  120:  if (is_strict)
        -:  121:  {
    #####:  122:    return ecma_raise_type_error (ECMA_ERR_MSG ("Binding cannot be set"));
        -:  123:  }
    #####:  124:  return ECMA_VALUE_EMPTY;
        -:  125:} /* ecma_op_raise_set_binding_error */
        -:  126:
        -:  127:/**
        -:  128: * Get reference to Global lexical scope
        -:  129: * without increasing its reference count.
        -:  130: *
        -:  131: * @return pointer to the object's instance
        -:  132: */
        -:  133:ecma_object_t *
        1:  134:ecma_get_global_scope (ecma_object_t *global_object_p) /**< global object */
        -:  135:{
        -:  136:#if JERRY_ESNEXT
        1:  137:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
        1:  138:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_scope_cp);
        -:  139:#else /* !JERRY_ESNEXT */
    #####:  140:  return ecma_get_global_environment (global_object_p);
        -:  141:#endif /* !JERRY_ESNEXT */
        -:  142:} /* ecma_get_global_scope */
        -:  143:
        -:  144:/**
        -:  145: * @}
        -:  146: */
        -:  147:
        -:  148:/**
        -:  149: * HasBinding operation.
        -:  150: *
        -:  151: * See also: ECMA-262 v5, 10.2.1
        -:  152: *
        -:  153: * @return true / false
        -:  154: */
        -:  155:ecma_value_t
        1:  156:ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  157:                     ecma_string_t *name_p) /**< argument N */
        -:  158:{
        1:  159:  JERRY_ASSERT (lex_env_p != NULL
        -:  160:                && ecma_is_lexical_environment (lex_env_p));
        -:  161:
        1:  162:  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);
        -:  163:
        1:  164:  switch (lex_env_type)
        -:  165:  {
        -:  166:#if JERRY_ESNEXT
    #####:  167:    case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  168:    {
    #####:  169:      if ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)
        -:  170:      {
    #####:  171:        return ECMA_VALUE_FALSE;
        -:  172:      }
        -:  173:      /* FALLTHRU */
        -:  174:    }
        -:  175:#endif /* JERRY_ESNEXT */
    #####:  176:    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  177:    {
    #####:  178:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  179:
    #####:  180:      return ecma_make_boolean_value (property_p != NULL);
        -:  181:    }
        1:  182:    default:
        -:  183:    {
        1:  184:      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  185:
        1:  186:      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  187:
        1:  188:      return ecma_op_object_has_property (binding_obj_p, name_p);
        -:  189:    }
        -:  190:  }
        -:  191:} /* ecma_op_has_binding */
        -:  192:
        -:  193:/**
        -:  194: * CreateMutableBinding operation.
        -:  195: *
        -:  196: * See also: ECMA-262 v5, 10.2.1
        -:  197: *
        -:  198: * @return ECMA_PROPERTY_POINTER_ERROR - if the operation raises error
        -:  199: *         pointer to the created property - if the binding was created into a declerative environment
        -:  200: *         NULL - otherwise
        -:  201: */
        -:  202:ecma_property_t *
        1:  203:ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  204:                                ecma_string_t *name_p, /**< argument N */
        -:  205:                                bool is_deletable) /**< argument D */
        -:  206:{
        1:  207:  JERRY_ASSERT (lex_env_p != NULL
        -:  208:                && ecma_is_lexical_environment (lex_env_p));
        1:  209:  JERRY_ASSERT (name_p != NULL);
        -:  210:
        1:  211:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  212:  {
    #####:  213:    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -:  214:
    #####:  215:    if (is_deletable)
        -:  216:    {
    #####:  217:      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -:  218:    }
        -:  219:
    #####:  220:    ecma_property_t *prop_p;
        -:  221:
    #####:  222:    ecma_create_named_data_property (lex_env_p,
        -:  223:                                     name_p,
        -:  224:                                     prop_attributes,
        -:  225:                                     &prop_p);
    #####:  226:    return prop_p;
        -:  227:  }
        -:  228:  else
        -:  229:  {
        1:  230:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  231:
        1:  232:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  233:
        -:  234:#if JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS
        1:  235:    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))
        -:  236:    {
    #####:  237:      ecma_value_t result = ecma_proxy_object_is_extensible (binding_obj_p);
        -:  238:
    #####:  239:      if (ECMA_IS_VALUE_ERROR (result))
        -:  240:      {
    #####:  241:        return ECMA_PROPERTY_POINTER_ERROR;
        -:  242:      }
        -:  243:
    #####:  244:      if (result == ECMA_VALUE_FALSE)
        -:  245:      {
    #####:  246:        return NULL;
        -:  247:      }
        -:  248:    }
        1:  249:    else if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))
        -:  250:    {
    #####:  251:      return NULL;
        -:  252:    }
        -:  253:#else /* !JERRY_BUILTIN_PROXY || !JERRY_BUILTIN_REALMS */
    #####:  254:    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))
        -:  255:    {
        -:  256:      return NULL;
        -:  257:    }
        -:  258:#endif /* JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS */
        -:  259:
        1:  260:    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  261:
        1:  262:    ecma_value_t completion = ecma_builtin_helper_def_prop (binding_obj_p,
        -:  263:                                                            name_p,
        -:  264:                                                            ECMA_VALUE_UNDEFINED,
        -:  265:                                                            is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE
        -:  266:                                                                         : flags);
        -:  267:
        1:  268:    if (ECMA_IS_VALUE_ERROR (completion))
        -:  269:    {
    #####:  270:      return ECMA_PROPERTY_POINTER_ERROR;
        -:  271:    }
        -:  272:    else
        -:  273:    {
        1:  274:      JERRY_ASSERT (ecma_is_value_boolean (completion));
        -:  275:    }
        -:  276:  }
        -:  277:
        1:  278:  return NULL;
        -:  279:} /* ecma_op_create_mutable_binding */
        -:  280:
        -:  281:/**
        -:  282: * SetMutableBinding operation.
        -:  283: *
        -:  284: * See also: ECMA-262 v5, 10.2.1
        -:  285: *
        -:  286: * @return ecma value
        -:  287: *         Returned value must be freed with ecma_free_value.
        -:  288: */
        -:  289:ecma_value_t
    #####:  290:ecma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  291:                             ecma_string_t *name_p, /**< argument N */
        -:  292:                             ecma_value_t value, /**< argument V */
        -:  293:                             bool is_strict) /**< argument S */
        -:  294:{
    #####:  295:  JERRY_ASSERT (lex_env_p != NULL
        -:  296:                && ecma_is_lexical_environment (lex_env_p));
    #####:  297:  JERRY_ASSERT (name_p != NULL);
        -:  298:
    #####:  299:  switch (ecma_get_lex_env_type (lex_env_p))
        -:  300:  {
        -:  301:#if JERRY_ESNEXT
    #####:  302:    case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  303:    {
    #####:  304:      if ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)
        -:  305:      {
    #####:  306:        return ECMA_VALUE_EMPTY;
        -:  307:      }
        -:  308:      /* FALLTHRU */
        -:  309:    }
        -:  310:#endif /* JERRY_ESNEXT */
    #####:  311:    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  312:    {
    #####:  313:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  314:
    #####:  315:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  316:      {
    #####:  317:        property_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_strict);
    #####:  318:        JERRY_ASSERT (property_p != ECMA_PROPERTY_POINTER_ERROR);
        -:  319:      }
        -:  320:
    #####:  321:      JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p));
    #####:  322:      JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_WRITABLE)
        -:  323:                    || (*property_p & ECMA_PROPERTY_FLAG_DATA));
        -:  324:
    #####:  325:      if ((*property_p & ECMA_PROPERTY_FLAG_WRITABLE))
        -:  326:      {
    #####:  327:        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  328:
    #####:  329:        JERRY_ASSERT (property_value_p->value != ECMA_VALUE_UNINITIALIZED);
        -:  330:
    #####:  331:        ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);
    #####:  332:        return ECMA_VALUE_EMPTY;
        -:  333:      }
        -:  334:
    #####:  335:      return ecma_op_raise_set_binding_error (property_p, is_strict);
        -:  336:    }
    #####:  337:    default:
        -:  338:    {
    #####:  339:      JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  340:
    #####:  341:      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  342:
    #####:  343:      ecma_value_t completion = ecma_op_object_put (binding_obj_p,
        -:  344:                                                    name_p,
        -:  345:                                                    value,
        -:  346:                                                    is_strict);
        -:  347:
    #####:  348:      if (ECMA_IS_VALUE_ERROR (completion))
        -:  349:      {
    #####:  350:        return completion;
        -:  351:      }
        -:  352:
    #####:  353:      JERRY_ASSERT (ecma_is_value_boolean (completion));
    #####:  354:      return ECMA_VALUE_EMPTY;
        -:  355:    }
        -:  356:  }
        -:  357:} /* ecma_op_set_mutable_binding */
        -:  358:
        -:  359:/**
        -:  360: * GetBindingValue operation.
        -:  361: *
        -:  362: * See also: ECMA-262 v5, 10.2.1
        -:  363: *
        -:  364: * @return ecma value
        -:  365: *         Returned value must be freed with ecma_free_value.
        -:  366: */
        -:  367:ecma_value_t
    #####:  368:ecma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  369:                           ecma_string_t *name_p, /**< argument N */
        -:  370:                           bool is_strict) /**< argument S */
        -:  371:{
    #####:  372:  JERRY_ASSERT (lex_env_p != NULL
        -:  373:                && ecma_is_lexical_environment (lex_env_p));
    #####:  374:  JERRY_ASSERT (name_p != NULL);
        -:  375:
    #####:  376:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  377:  {
    #####:  378:    ecma_property_value_t *prop_value_p = ecma_get_named_data_property (lex_env_p, name_p);
        -:  379:
    #####:  380:    return ecma_copy_value (prop_value_p->value);
        -:  381:  }
        -:  382:  else
        -:  383:  {
    #####:  384:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  385:
    #####:  386:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  387:
    #####:  388:    ecma_value_t result = ecma_op_object_find (binding_obj_p, name_p);
        -:  389:
    #####:  390:    if (ECMA_IS_VALUE_ERROR (result))
        -:  391:    {
    #####:  392:      return result;
        -:  393:    }
        -:  394:
    #####:  395:    if (!ecma_is_value_found (result))
        -:  396:    {
    #####:  397:      if (is_strict)
        -:  398:      {
    #####:  399:        result = ecma_raise_reference_error (ECMA_ERR_MSG ("Binding does not exist or is uninitialised"));
        -:  400:      }
        -:  401:      else
        -:  402:      {
    #####:  403:        result = ECMA_VALUE_UNDEFINED;
        -:  404:      }
        -:  405:    }
        -:  406:
    #####:  407:    return result;
        -:  408:  }
        -:  409:} /* ecma_op_get_binding_value */
        -:  410:
        -:  411:/**
        -:  412: * DeleteBinding operation.
        -:  413: *
        -:  414: * See also: ECMA-262 v5, 10.2.1
        -:  415: *
        -:  416: * @return ecma value
        -:  417: *         Return ECMA_VALUE_ERROR - if the operation fails
        -:  418: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the binding can be deleted
        -:  419: */
        -:  420:ecma_value_t
    #####:  421:ecma_op_delete_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  422:                        ecma_string_t *name_p) /**< argument N */
        -:  423:{
    #####:  424:  JERRY_ASSERT (lex_env_p != NULL
        -:  425:                && ecma_is_lexical_environment (lex_env_p));
    #####:  426:  JERRY_ASSERT (name_p != NULL);
        -:  427:
    #####:  428:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  429:  {
    #####:  430:    ecma_property_t *prop_p = ecma_find_named_property (lex_env_p, name_p);
        -:  431:    ecma_value_t ret_val;
        -:  432:
    #####:  433:    if (prop_p == NULL)
        -:  434:    {
    #####:  435:      ret_val = ECMA_VALUE_TRUE;
        -:  436:    }
        -:  437:    else
        -:  438:    {
    #####:  439:      JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (*prop_p));
        -:  440:
    #####:  441:      if (!ecma_is_property_configurable (*prop_p))
        -:  442:      {
    #####:  443:        ret_val = ECMA_VALUE_FALSE;
        -:  444:      }
        -:  445:      else
        -:  446:      {
    #####:  447:        ecma_delete_property (lex_env_p, ECMA_PROPERTY_VALUE_PTR (prop_p));
        -:  448:
    #####:  449:        ret_val = ECMA_VALUE_TRUE;
        -:  450:      }
        -:  451:    }
        -:  452:
    #####:  453:    return ret_val;
        -:  454:  }
        -:  455:  else
        -:  456:  {
    #####:  457:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  458:
    #####:  459:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  460:
    #####:  461:    return ecma_op_object_delete (binding_obj_p, name_p, false);
        -:  462:  }
        -:  463:} /* ecma_op_delete_binding */
        -:  464:
        -:  465:/**
        -:  466: * ImplicitThisValue operation.
        -:  467: *
        -:  468: * See also: ECMA-262 v5, 10.2.1
        -:  469: *
        -:  470: * @return ecma value
        -:  471: *         Returned value must be freed with ecma_free_value.
        -:  472: */
        -:  473:ecma_value_t
    #####:  474:ecma_op_implicit_this_value (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  475:{
    #####:  476:  JERRY_ASSERT (lex_env_p != NULL
        -:  477:                && ecma_is_lexical_environment (lex_env_p));
        -:  478:
    #####:  479:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  480:  {
    #####:  481:    return ECMA_VALUE_UNDEFINED;
        -:  482:  }
        -:  483:  else
        -:  484:  {
    #####:  485:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  486:
    #####:  487:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
    #####:  488:    ecma_ref_object (binding_obj_p);
        -:  489:
    #####:  490:    return ecma_make_object_value (binding_obj_p);
        -:  491:  }
        -:  492:} /* ecma_op_implicit_this_value */
        -:  493:
        -:  494:/**
        -:  495: * CreateImmutableBinding operation.
        -:  496: *
        -:  497: * See also: ECMA-262 v5, 10.2.1
        -:  498: */
        -:  499:void
    #####:  500:ecma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  501:                                  ecma_string_t *name_p, /**< argument N */
        -:  502:                                  ecma_value_t value) /**< argument V */
        -:  503:{
    #####:  504:  JERRY_ASSERT (lex_env_p != NULL
        -:  505:                && ecma_is_lexical_environment (lex_env_p));
    #####:  506:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -:  507:
        -:  508:  /*
        -:  509:   * Warning:
        -:  510:   *         Whether immutable bindings are deletable seems not to be defined by ECMA v5.
        -:  511:   */
    #####:  512:  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (lex_env_p,
        -:  513:                                                                         name_p,
        -:  514:                                                                         ECMA_PROPERTY_FIXED,
        -:  515:                                                                         NULL);
        -:  516:
    #####:  517:  prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:  518:} /* ecma_op_create_immutable_binding */
        -:  519:
        -:  520:#if JERRY_ESNEXT
        -:  521:/**
        -:  522: * InitializeBinding operation.
        -:  523: *
        -:  524: * See also: ECMA-262 v6, 8.1.1.1.4
        -:  525: */
        -:  526:void
    #####:  527:ecma_op_initialize_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  528:                            ecma_string_t *name_p, /**< argument N */
        -:  529:                            ecma_value_t value) /**< argument V */
        -:  530:{
    #####:  531:  JERRY_ASSERT (lex_env_p != NULL
        -:  532:                && ecma_is_lexical_environment (lex_env_p));
    #####:  533:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -:  534:
    #####:  535:  ecma_property_t *prop_p = ecma_find_named_property (lex_env_p, name_p);
    #####:  536:  JERRY_ASSERT (prop_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*prop_p));
        -:  537:
    #####:  538:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  539:  JERRY_ASSERT (prop_value_p->value == ECMA_VALUE_UNINITIALIZED);
        -:  540:
    #####:  541:  prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:  542:} /* ecma_op_initialize_binding */
        -:  543:
        -:  544:/**
        -:  545: * BindThisValue operation for an empty lexical environment
        -:  546: *
        -:  547: * See also: ECMA-262 v6, 8.1.1.3.1
        -:  548: */
        -:  549:void
    #####:  550:ecma_op_create_environment_record (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  551:                                   ecma_value_t this_binding, /**< this binding value */
        -:  552:                                   ecma_object_t *func_obj_p) /**< function object */
        -:  553:{
    #####:  554:  JERRY_ASSERT (lex_env_p != NULL);
    #####:  555:  JERRY_ASSERT (ecma_is_value_object (this_binding) || this_binding == ECMA_VALUE_UNINITIALIZED);
        -:  556:
        -:  557:  ecma_environment_record_t *environment_record_p;
    #####:  558:  environment_record_p = (ecma_environment_record_t *) jmem_heap_alloc_block (sizeof (ecma_environment_record_t));
        -:  559:
    #####:  560:  environment_record_p->this_binding = this_binding;
    #####:  561:  environment_record_p->function_object = ecma_make_object_value (func_obj_p);
        -:  562:
    #####:  563:  ecma_string_t *property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD);
        -:  564:
    #####:  565:  ecma_property_t *property_p;
        -:  566:  ecma_property_value_t *prop_value_p;
    #####:  567:  ECMA_CREATE_INTERNAL_PROPERTY (lex_env_p, property_name_p, property_p, prop_value_p);
        -:  568:
    #####:  569:  ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, environment_record_p);
    #####:  570:} /* ecma_op_create_environment_record */
        -:  571:
        -:  572:/**
        -:  573: * GetThisEnvironment operation.
        -:  574: *
        -:  575: * See also: ECMA-262 v6, 8.3.2
        -:  576: *
        -:  577: * @return property pointer for the internal [[ThisBindingValue]] property
        -:  578: */
        -:  579:ecma_environment_record_t *
    #####:  580:ecma_op_get_environment_record (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  581:{
    #####:  582:  JERRY_ASSERT (lex_env_p != NULL);
        -:  583:
    #####:  584:  ecma_string_t *property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD);
        -:  585:  while (true)
        -:  586:  {
    #####:  587:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  588:    {
    #####:  589:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, property_name_p);
        -:  590:
    #####:  591:      if (property_p != NULL)
        -:  592:      {
    #####:  593:        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  594:        return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_environment_record_t, property_value_p->value);
        -:  595:      }
        -:  596:    }
        -:  597:
    #####:  598:    JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####:  599:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  600:  }
        -:  601:} /* ecma_op_get_environment_record */
        -:  602:
        -:  603:/**
        -:  604: * Get the environment record [[ThisBindingStatus]] internal property.
        -:  605: *
        -:  606: * See also: ECMA-262 v6, 8.1.1.3
        -:  607: *
        -:  608: * @return true - if the status is "initialzed"
        -:  609: *         false - otherwise
        -:  610: */
        -:  611:bool
    #####:  612:ecma_op_this_binding_is_initialized (ecma_environment_record_t *environment_record_p) /**< environment record */
        -:  613:{
    #####:  614:  JERRY_ASSERT (environment_record_p != NULL);
        -:  615:
    #####:  616:  return environment_record_p->this_binding != ECMA_VALUE_UNINITIALIZED;
        -:  617:} /* ecma_op_this_binding_is_initialized */
        -:  618:
        -:  619:/**
        -:  620: * BindThisValue operation.
        -:  621: *
        -:  622: * See also: ECMA-262 v6, 8.1.1.3.1
        -:  623: */
        -:  624:void
    #####:  625:ecma_op_bind_this_value (ecma_environment_record_t *environment_record_p, /**< environment record */
        -:  626:                         ecma_value_t this_binding) /**< this binding value */
        -:  627:{
    #####:  628:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  629:  JERRY_ASSERT (ecma_is_value_object (this_binding));
    #####:  630:  JERRY_ASSERT (!ecma_op_this_binding_is_initialized (environment_record_p));
        -:  631:
    #####:  632:  environment_record_p->this_binding = this_binding;
    #####:  633:} /* ecma_op_bind_this_value */
        -:  634:
        -:  635:/**
        -:  636: * GetThisBinding operation.
        -:  637: *
        -:  638: * See also: ECMA-262 v6, 8.1.1.3.4
        -:  639: *
        -:  640: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  641: *         ecma-object - otherwise
        -:  642: */
        -:  643:ecma_value_t
    #####:  644:ecma_op_get_this_binding (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  645:{
    #####:  646:  JERRY_ASSERT (lex_env_p != NULL);
        -:  647:
    #####:  648:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (lex_env_p);
    #####:  649:  JERRY_ASSERT (environment_record_p != NULL);
        -:  650:
    #####:  651:  ecma_value_t this_value = environment_record_p->this_binding;
        -:  652:
    #####:  653:  if (this_value == ECMA_VALUE_UNINITIALIZED)
        -:  654:  {
    #####:  655:    return ecma_raise_reference_error (ECMA_ERR_MSG ("Must call super constructor in derived class before "
        -:  656:                                                     "accessing 'this' or returning from it"));
        -:  657:  }
        -:  658:
    #####:  659:  ecma_ref_object (ecma_get_object_from_value (this_value));
        -:  660:
    #####:  661:  return this_value;
        -:  662:} /* ecma_op_get_this_binding */
        -:  663:
        -:  664:#endif /* JERRY_ESNEXT */
        -:  665:
        -:  666:/**
        -:  667: * @}
        -:  668: * @}
        -:  669: */
