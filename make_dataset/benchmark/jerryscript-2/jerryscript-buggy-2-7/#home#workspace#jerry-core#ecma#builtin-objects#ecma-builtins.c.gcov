        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtins.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-gc.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-objects.h"
        -:   24:#include "jcontext.h"
        -:   25:#include "jrt-bit-fields.h"
        -:   26:
        -:   27:#define ECMA_BUILTINS_INTERNAL
        -:   28:#include "ecma-builtins-internal.h"
        -:   29:
        -:   30:/** \addtogroup ecma ECMA
        -:   31: * @{
        -:   32: *
        -:   33: * \addtogroup ecmabuiltins
        -:   34: * @{
        -:   35: */
        -:   36:
        -:   37:JERRY_STATIC_ASSERT (ECMA_BUILTIN_ID_GLOBAL == ECMA_BUILTIN_OBJECTS_COUNT,
        -:   38:                     ecma_builtin_id_global_must_be_the_last_builtin_id);
        -:   39:
        -:   40:/**
        -:   41: * Checks whether the built-in is an ecma_extended_built_in_object_t
        -:   42: */
        -:   43:#define ECMA_BUILTIN_IS_EXTENDED_BUILT_IN(object_type) \
        -:   44:  ((object_type) == ECMA_OBJECT_TYPE_BUILT_IN_CLASS || (object_type) == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY)
        -:   45:
        -:   46:/**
        -:   47: * Helper definition for ecma_builtin_property_list_references.
        -:   48: */
        -:   49:typedef const ecma_builtin_property_descriptor_t *ecma_builtin_property_list_reference_t;
        -:   50:
        -:   51:/**
        -:   52: * Definition of built-in dispatch routine function pointer.
        -:   53: */
        -:   54:typedef ecma_value_t (*ecma_builtin_dispatch_routine_t) (uint8_t builtin_routine_id,
        -:   55:                                                         ecma_value_t this_arg,
        -:   56:                                                         const ecma_value_t arguments_list[],
        -:   57:                                                         uint32_t arguments_number);
        -:   58:/**
        -:   59: * Definition of built-in dispatch call function pointer.
        -:   60: */
        -:   61:typedef ecma_value_t (*ecma_builtin_dispatch_call_t) (const ecma_value_t arguments_list[],
        -:   62:                                                      uint32_t arguments_number);
        -:   63:/**
        -:   64: * Definition of a builtin descriptor which contains the builtin object's:
        -:   65: * - prototype objects's id (13-bits)
        -:   66: * - type (3-bits)
        -:   67: *
        -:   68: * Layout:
        -:   69: *
        -:   70: * |----------------------|---------------|
        -:   71: *     prototype_id(12)      obj_type(4)
        -:   72: */
        -:   73:typedef uint16_t ecma_builtin_descriptor_t;
        -:   74:
        -:   75:/**
        -:   76: * Bitshift index for get the prototype object's id from a builtin descriptor
        -:   77: */
        -:   78:#define ECMA_BUILTIN_PROTOTYPE_ID_SHIFT 4
        -:   79:
        -:   80:/**
        -:   81: * Bitmask for get the object's type from a builtin descriptor
        -:   82: */
        -:   83:#define ECMA_BUILTIN_OBJECT_TYPE_MASK ((1 << ECMA_BUILTIN_PROTOTYPE_ID_SHIFT) - 1)
        -:   84:
        -:   85:/**
        -:   86: * Create a builtin descriptor value
        -:   87: */
        -:   88:#define ECMA_MAKE_BUILTIN_DESCRIPTOR(type, proto_id) \
        -:   89:  (((proto_id) << ECMA_BUILTIN_PROTOTYPE_ID_SHIFT) | (type))
        -:   90:
        -:   91:/**
        -:   92: * List of the built-in descriptors.
        -:   93: */
        -:   94:static const ecma_builtin_descriptor_t ecma_builtin_descriptors[] =
        -:   95:{
        -:   96:/** @cond doxygen_suppress */
        -:   97:#define BUILTIN(a, b, c, d, e)
        -:   98:#define BUILTIN_ROUTINE(builtin_id, \
        -:   99:                        object_type, \
        -:  100:                        object_prototype_builtin_id, \
        -:  101:                        is_extensible, \
        -:  102:                        lowercase_name) \
        -:  103:  ECMA_MAKE_BUILTIN_DESCRIPTOR (object_type, object_prototype_builtin_id),
        -:  104:#include "ecma-builtins.inc.h"
        -:  105:#undef BUILTIN
        -:  106:#undef BUILTIN_ROUTINE
        -:  107:#define BUILTIN_ROUTINE(a, b, c, d, e)
        -:  108:#define BUILTIN(builtin_id, \
        -:  109:                object_type, \
        -:  110:                object_prototype_builtin_id, \
        -:  111:                is_extensible, \
        -:  112:                lowercase_name) \
        -:  113:  ECMA_MAKE_BUILTIN_DESCRIPTOR (object_type, object_prototype_builtin_id),
        -:  114:#include "ecma-builtins.inc.h"
        -:  115:#undef BUILTIN
        -:  116:#undef BUILTIN_ROUTINE
        -:  117:/** @endcond */
        -:  118:};
        -:  119:
        -:  120:#ifndef JERRY_NDEBUG
        -:  121:/** @cond doxygen_suppress */
        -:  122:enum
        -:  123:{
        -:  124:  ECMA_BUILTIN_EXTENSIBLE_CHECK =
        -:  125:#define BUILTIN(a, b, c, d, e)
        -:  126:#define BUILTIN_ROUTINE(builtin_id, \
        -:  127:                        object_type, \
        -:  128:                        object_prototype_builtin_id, \
        -:  129:                        is_extensible, \
        -:  130:                        lowercase_name) \
        -:  131:  (is_extensible != 0 || builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER) &&
        -:  132:#include "ecma-builtins.inc.h"
        -:  133:#undef BUILTIN
        -:  134:#undef BUILTIN_ROUTINE
        -:  135:#define BUILTIN_ROUTINE(a, b, c, d, e)
        -:  136:#define BUILTIN(builtin_id, \
        -:  137:                object_type, \
        -:  138:                object_prototype_builtin_id, \
        -:  139:                is_extensible, \
        -:  140:                lowercase_name) \
        -:  141:  (is_extensible != 0 || builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER) &&
        -:  142:#include "ecma-builtins.inc.h"
        -:  143:#undef BUILTIN
        -:  144:#undef BUILTIN_ROUTINE
        -:  145:  true
        -:  146:};
        -:  147:/** @endcond */
        -:  148:
        -:  149:/**
        -:  150: * All the builtin object must be extensible except the ThrowTypeError object.
        -:  151: */
        -:  152:JERRY_STATIC_ASSERT (ECMA_BUILTIN_EXTENSIBLE_CHECK == true,
        -:  153:                     ecma_builtin_must_be_extensible_except_the_builtin_thorw_type_error_object);
        -:  154:#endif /* !JERRY_NDEBUG */
        -:  155:
        -:  156:/**
        -:  157: * List of the built-in routines.
        -:  158: */
        -:  159:static const ecma_builtin_dispatch_routine_t ecma_builtin_routines[] =
        -:  160:{
        -:  161:/** @cond doxygen_suppress */
        -:  162:#define BUILTIN(a, b, c, d, e)
        -:  163:#define BUILTIN_ROUTINE(builtin_id, \
        -:  164:                        object_type, \
        -:  165:                        object_prototype_builtin_id, \
        -:  166:                        is_extensible, \
        -:  167:                        lowercase_name) \
        -:  168:  ecma_builtin_ ## lowercase_name ## _dispatch_routine,
        -:  169:#include "ecma-builtins.inc.h"
        -:  170:#undef BUILTIN
        -:  171:#undef BUILTIN_ROUTINE
        -:  172:#define BUILTIN_ROUTINE(a, b, c, d, e)
        -:  173:#define BUILTIN(builtin_id, \
        -:  174:                object_type, \
        -:  175:                object_prototype_builtin_id, \
        -:  176:                is_extensible, \
        -:  177:                lowercase_name) \
        -:  178:  ecma_builtin_ ## lowercase_name ## _dispatch_routine,
        -:  179:#include "ecma-builtins.inc.h"
        -:  180:#undef BUILTIN
        -:  181:#undef BUILTIN_ROUTINE
        -:  182:/** @endcond */
        -:  183:};
        -:  184:
        -:  185:/**
        -:  186: * List of the built-in call functions.
        -:  187: */
        -:  188:static const ecma_builtin_dispatch_call_t ecma_builtin_call_functions[] =
        -:  189:{
        -:  190:/** @cond doxygen_suppress */
        -:  191:#define BUILTIN(a, b, c, d, e)
        -:  192:#define BUILTIN_ROUTINE(builtin_id, \
        -:  193:                        object_type, \
        -:  194:                        object_prototype_builtin_id, \
        -:  195:                        is_extensible, \
        -:  196:                        lowercase_name) \
        -:  197:  ecma_builtin_ ## lowercase_name ## _dispatch_call,
        -:  198:#include "ecma-builtins.inc.h"
        -:  199:#undef BUILTIN_ROUTINE
        -:  200:#undef BUILTIN
        -:  201:/** @endcond */
        -:  202:};
        -:  203:
        -:  204:/**
        -:  205: * List of the built-in construct functions.
        -:  206: */
        -:  207:static const ecma_builtin_dispatch_call_t ecma_builtin_construct_functions[] =
        -:  208:{
        -:  209:/** @cond doxygen_suppress */
        -:  210:#define BUILTIN(a, b, c, d, e)
        -:  211:#define BUILTIN_ROUTINE(builtin_id, \
        -:  212:                        object_type, \
        -:  213:                        object_prototype_builtin_id, \
        -:  214:                        is_extensible, \
        -:  215:                        lowercase_name) \
        -:  216:  ecma_builtin_ ## lowercase_name ## _dispatch_construct,
        -:  217:#include "ecma-builtins.inc.h"
        -:  218:#undef BUILTIN_ROUTINE
        -:  219:#undef BUILTIN
        -:  220:/** @endcond */
        -:  221:};
        -:  222:
        -:  223:/**
        -:  224: * Property descriptor lists for all built-ins.
        -:  225: */
        -:  226:static const ecma_builtin_property_list_reference_t ecma_builtin_property_list_references[] =
        -:  227:{
        -:  228:/** @cond doxygen_suppress */
        -:  229:#define BUILTIN(a, b, c, d, e)
        -:  230:#define BUILTIN_ROUTINE(builtin_id, \
        -:  231:                        object_type, \
        -:  232:                        object_prototype_builtin_id, \
        -:  233:                        is_extensible, \
        -:  234:                        lowercase_name) \
        -:  235:  ecma_builtin_ ## lowercase_name ## _property_descriptor_list,
        -:  236:#include "ecma-builtins.inc.h"
        -:  237:#undef BUILTIN
        -:  238:#undef BUILTIN_ROUTINE
        -:  239:#define BUILTIN_ROUTINE(a, b, c, d, e)
        -:  240:#define BUILTIN(builtin_id, \
        -:  241:                object_type, \
        -:  242:                object_prototype_builtin_id, \
        -:  243:                is_extensible, \
        -:  244:                lowercase_name) \
        -:  245:  ecma_builtin_ ## lowercase_name ## _property_descriptor_list,
        -:  246:#include "ecma-builtins.inc.h"
        -:  247:#undef BUILTIN_ROUTINE
        -:  248:#undef BUILTIN
        -:  249:/** @endcond */
        -:  250:};
        -:  251:
        -:  252:/**
        -:  253: * Get the number of properties of a built-in object.
        -:  254: *
        -:  255: * @return the number of properties
        -:  256: */
        -:  257:static size_t
      106:  258:ecma_builtin_get_property_count (ecma_builtin_id_t builtin_id) /**< built-in ID */
        -:  259:{
      106:  260:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
      106:  261:  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];
        -:  262:
      106:  263:  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;
        -:  264:
     1044:  265:  while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)
        -:  266:  {
      832:  267:    curr_property_p++;
        -:  268:  }
        -:  269:
      106:  270:  return (size_t) (curr_property_p - property_list_p);
        -:  271:} /* ecma_builtin_get_property_count */
        -:  272:
        -:  273:/**
        -:  274: * Check if passed object is a global built-in.
        -:  275: *
        -:  276: * @return true  - if the object is a global built-in
        -:  277: *         false - otherwise
        -:  278: */
        -:  279:bool
       14:  280:ecma_builtin_is_global (ecma_object_t *object_p) /**< pointer to an object */
        -:  281:{
       14:  282:  return (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL
       14:  283:          && ((ecma_extended_object_t *) object_p)->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL);
        -:  284:} /* ecma_builtin_is_global */
        -:  285:
        -:  286:/**
        -:  287: * Get reference to the global object
        -:  288: *
        -:  289: * Note:
        -:  290: *   Does not increase the reference counter.
        -:  291: *
        -:  292: * @return pointer to the global object
        -:  293: */
        -:  294:extern inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE
       36:  295:ecma_builtin_get_global (void)
        -:  296:{
       56:  297:  JERRY_ASSERT (JERRY_CONTEXT (global_object_p) != NULL);
        -:  298:
       56:  299:  return (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -:  300:} /* ecma_builtin_get_global */
        -:  301:
        -:  302:/**
        -:  303: * Checks whether the given function is a built-in routine
        -:  304: *
        -:  305: * @return true - if the function object is a built-in routine
        -:  306: *         false - otherwise
        -:  307: */
        -:  308:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        6:  309:ecma_builtin_function_is_routine (ecma_object_t *func_obj_p) /**< function object */
        -:  310:{
       36:  311:  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -:  312:
       36:  313:  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;
       36:  314:  return (ext_func_obj_p->u.built_in.routine_id != 0);
        -:  315:} /* ecma_builtin_function_is_routine */
        -:  316:
        -:  317:#if JERRY_BUILTIN_REALMS
        -:  318:
        -:  319:/**
        -:  320: * Get reference to the realm provided by another built-in object
        -:  321: *
        -:  322: * Note:
        -:  323: *   Does not increase the reference counter.
        -:  324: *
        -:  325: * @return pointer to the global object
        -:  326: */
        -:  327:static ecma_global_object_t *
      142:  328:ecma_builtin_get_realm (ecma_object_t *builtin_object_p) /**< built-in object */
        -:  329:{
      142:  330:  ecma_object_type_t object_type = ecma_get_object_type (builtin_object_p);
        -:  331:  ecma_value_t realm_value;
        -:  332:
      142:  333:  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL
        -:  334:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS
        -:  335:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY
        -:  336:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -:  337:
      142:  338:  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))
        -:  339:  {
    #####:  340:    realm_value = ((ecma_extended_built_in_object_t *) builtin_object_p)->built_in.realm_value;
        -:  341:  }
        -:  342:  else
        -:  343:  {
      142:  344:    realm_value = ((ecma_extended_object_t *) builtin_object_p)->u.built_in.realm_value;
        -:  345:  }
        -:  346:
      142:  347:  return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, realm_value);
        -:  348:} /* ecma_builtin_get_realm */
        -:  349:
        -:  350:#endif /* JERRY_BUILTIN_REALMS */
        -:  351:
        -:  352:/**
        -:  353: * Instantiate specified ECMA built-in object
        -:  354: *
        -:  355: * @return the newly instantiated built-in
        -:  356: */
        -:  357:static ecma_object_t *
      104:  358:ecma_instantiate_builtin (ecma_global_object_t *global_object_p, /**< global object */
        -:  359:                          ecma_builtin_id_t obj_builtin_id) /**< built-in id */
        -:  360:{
      104:  361:  jmem_cpointer_t *builtin_objects = global_object_p->builtin_objects;
        -:  362:
      104:  363:  JERRY_ASSERT (obj_builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);
      104:  364:  JERRY_ASSERT (builtin_objects[obj_builtin_id] == JMEM_CP_NULL);
        -:  365:
      104:  366:  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[obj_builtin_id];
      104:  367:  ecma_builtin_id_t object_prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);
        -:  368:
        -:  369:  ecma_object_t *prototype_obj_p;
        -:  370:
      104:  371:  if (JERRY_UNLIKELY (object_prototype_builtin_id == ECMA_BUILTIN_ID__COUNT))
        -:  372:  {
        4:  373:    prototype_obj_p = NULL;
        -:  374:  }
        -:  375:  else
        -:  376:  {
      100:  377:    if (builtin_objects[object_prototype_builtin_id] == JMEM_CP_NULL)
        -:  378:    {
        6:  379:      ecma_instantiate_builtin (global_object_p, object_prototype_builtin_id);
        -:  380:    }
      100:  381:    prototype_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_objects[object_prototype_builtin_id]);
      100:  382:    JERRY_ASSERT (prototype_obj_p != NULL);
        -:  383:  }
        -:  384:
      104:  385:  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);
        -:  386:
      104:  387:  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL
        -:  388:                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS
        -:  389:                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY
        -:  390:                || obj_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -:  391:
      104:  392:  bool is_extended_built_in = ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (obj_type);
        -:  393:
      104:  394:  size_t ext_object_size = (is_extended_built_in ? sizeof (ecma_extended_built_in_object_t)
      104:  395:                                                 : sizeof (ecma_extended_object_t));
        -:  396:
      104:  397:  size_t property_count = ecma_builtin_get_property_count (obj_builtin_id);
        -:  398:
      104:  399:  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)
        -:  400:  {
        -:  401:    /* Only 64 extra properties supported at the moment.
        -:  402:     * This can be extended to 256 later. */
       22:  403:    JERRY_ASSERT (property_count <= (ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64));
        -:  404:
       22:  405:    ext_object_size += sizeof (uint64_t);
        -:  406:  }
        -:  407:
      104:  408:  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, ext_object_size, obj_type);
        -:  409:
      104:  410:  if (JERRY_UNLIKELY (obj_builtin_id == ECMA_BUILTIN_ID_TYPE_ERROR_THROWER))
        -:  411:  {
    #####:  412:    ecma_op_ordinary_object_prevent_extensions (obj_p);
        -:  413:  }
        -:  414:  else
        -:  415:  {
      104:  416:    ecma_op_ordinary_object_set_extensible (obj_p);
        -:  417:  }
        -:  418:
        -:  419:  /*
        -:  420:   * [[Class]] property of built-in object is not stored explicitly.
        -:  421:   *
        -:  422:   * See also: ecma_object_get_class_name
        -:  423:   */
        -:  424:
        -:  425:  ecma_built_in_props_t *built_in_props_p;
        -:  426:
      104:  427:  if (is_extended_built_in)
        -:  428:  {
    #####:  429:    built_in_props_p = &((ecma_extended_built_in_object_t *) obj_p)->built_in;
        -:  430:  }
        -:  431:  else
        -:  432:  {
      104:  433:    built_in_props_p = &((ecma_extended_object_t *) obj_p)->u.built_in;
        -:  434:  }
        -:  435:
      104:  436:  built_in_props_p->id = (uint8_t) obj_builtin_id;
      104:  437:  built_in_props_p->routine_id = 0;
      104:  438:  built_in_props_p->u.length_and_bitset_size = 0;
      104:  439:  built_in_props_p->u2.instantiated_bitset[0] = 0;
        -:  440:#if JERRY_BUILTIN_REALMS
      104:  441:  ECMA_SET_INTERNAL_VALUE_POINTER (built_in_props_p->realm_value, global_object_p);
        -:  442:#else /* !JERRY_BUILTIN_REALMS */
    #####:  443:  built_in_props_p->continue_instantiated_bitset[0] = 0;
        -:  444:#endif /* JERRY_BUILTIN_REALMS */
        -:  445:
      104:  446:  if (property_count > ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE)
        -:  447:  {
       22:  448:    built_in_props_p->u.length_and_bitset_size = 1 << ECMA_BUILT_IN_BITSET_SHIFT;
        -:  449:
       22:  450:    uint32_t *instantiated_bitset_p = (uint32_t *) (built_in_props_p + 1);
       22:  451:    instantiated_bitset_p[0] = 0;
       22:  452:    instantiated_bitset_p[1] = 0;
        -:  453:  }
        -:  454:
        -:  455:  /** Initializing [[PrimitiveValue]] properties of built-in prototype objects */
      104:  456:  switch (obj_builtin_id)
        -:  457:  {
        -:  458:#if JERRY_BUILTIN_ARRAY
    #####:  459:    case ECMA_BUILTIN_ID_ARRAY_PROTOTYPE:
        -:  460:    {
    #####:  461:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY);
    #####:  462:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  463:
    #####:  464:      ext_object_p->u.array.length = 0;
    #####:  465:      ext_object_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;
    #####:  466:      break;
        -:  467:    }
        -:  468:#endif /* JERRY_BUILTIN_ARRAY */
        -:  469:
        -:  470:#if JERRY_BUILTIN_STRING
    #####:  471:    case ECMA_BUILTIN_ID_STRING_PROTOTYPE:
        -:  472:    {
    #####:  473:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
    #####:  474:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  475:
    #####:  476:      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_STRING;
    #####:  477:      ext_object_p->u.cls.u3.value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
    #####:  478:      break;
        -:  479:    }
        -:  480:#endif /* JERRY_BUILTIN_STRING */
        -:  481:
        -:  482:#if JERRY_BUILTIN_NUMBER
    #####:  483:    case ECMA_BUILTIN_ID_NUMBER_PROTOTYPE:
        -:  484:    {
    #####:  485:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
    #####:  486:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  487:
    #####:  488:      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_NUMBER;
    #####:  489:      ext_object_p->u.cls.u3.value = ecma_make_integer_value (0);
    #####:  490:      break;
        -:  491:    }
        -:  492:#endif /* JERRY_BUILTIN_NUMBER */
        -:  493:
        -:  494:#if JERRY_BUILTIN_BOOLEAN
    #####:  495:    case ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE:
        -:  496:    {
    #####:  497:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
    #####:  498:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  499:
    #####:  500:      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_BOOLEAN;
    #####:  501:      ext_object_p->u.cls.u3.value = ECMA_VALUE_FALSE;
    #####:  502:      break;
        -:  503:    }
        -:  504:#endif /* JERRY_BUILTIN_BOOLEAN */
        -:  505:
        -:  506:#if !JERRY_ESNEXT
        -:  507:#if JERRY_BUILTIN_DATE
        -:  508:    case ECMA_BUILTIN_ID_DATE_PROTOTYPE:
        -:  509:    {
        -:  510:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
    #####:  511:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  512:
    #####:  513:      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_DATE;
        -:  514:
    #####:  515:      ecma_number_t *prim_prop_num_value_p = ecma_alloc_number ();
    #####:  516:      *prim_prop_num_value_p = ecma_number_make_nan ();
    #####:  517:      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, prim_prop_num_value_p);
    #####:  518:      break;
        -:  519:    }
        -:  520:#endif /* JERRY_BUILTIN_DATE */
        -:  521:
        -:  522:#if JERRY_BUILTIN_REGEXP
        -:  523:    case ECMA_BUILTIN_ID_REGEXP_PROTOTYPE:
        -:  524:    {
        -:  525:      JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
    #####:  526:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  527:
    #####:  528:      ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP;
        -:  529:
    #####:  530:      re_compiled_code_t *bc_p = re_compile_bytecode (ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP),
        -:  531:                                                      RE_FLAG_EMPTY);
        -:  532:
        -:  533:      JERRY_ASSERT (bc_p != NULL);
        -:  534:
    #####:  535:      ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bc_p);
    #####:  536:      break;
        -:  537:    }
        -:  538:#endif /* JERRY_BUILTIN_REGEXP */
        -:  539:#endif /* !JERRY_ESNEXT */
      104:  540:    default:
        -:  541:    {
      104:  542:      JERRY_ASSERT (obj_type != ECMA_OBJECT_TYPE_BUILT_IN_CLASS);
      104:  543:      break;
        -:  544:    }
        -:  545:  }
        -:  546:
      104:  547:  ECMA_SET_NON_NULL_POINTER (builtin_objects[obj_builtin_id], obj_p);
      104:  548:  ecma_deref_object (obj_p);
      104:  549:  return obj_p;
        -:  550:} /* ecma_instantiate_builtin */
        -:  551:
        -:  552:/**
        -:  553: * Create a global object
        -:  554: *
        -:  555: * @return a new global object
        -:  556: */
        -:  557:ecma_global_object_t *
        2:  558:ecma_builtin_create_global_object (void)
        -:  559:{
        2:  560:  ecma_builtin_descriptor_t builtin_desc = ecma_builtin_descriptors[ECMA_BUILTIN_ID_GLOBAL];
        2:  561:  ecma_builtin_id_t prototype_builtin_id = (ecma_builtin_id_t) (builtin_desc >> ECMA_BUILTIN_PROTOTYPE_ID_SHIFT);
        2:  562:  ecma_object_type_t obj_type = (ecma_object_type_t) (builtin_desc & ECMA_BUILTIN_OBJECT_TYPE_MASK);
        2:  563:  size_t property_count = ecma_builtin_get_property_count (ECMA_BUILTIN_ID_GLOBAL);
        -:  564:
        2:  565:  JERRY_ASSERT (prototype_builtin_id != ECMA_BUILTIN_ID__COUNT);
        2:  566:  JERRY_ASSERT (obj_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL);
        -:  567:
        -:  568:  /* Whenever this assertion fails, the size of extra_instantiated_bitset in ecma_global_object_t
        -:  569:   * must be increased and 32 must be added to these constants. Furthermore the new uint32 item
        -:  570:   * must be set to zero. */
        -:  571:#if JERRY_BUILTIN_REALMS
        2:  572:  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 64);
        -:  573:#else /* !JERRY_BUILTIN_REALMS */
        -:  574:  JERRY_ASSERT (property_count <= ECMA_BUILTIN_INSTANTIATED_BITSET_MIN_SIZE + 32);
        -:  575:#endif /* JERRY_BUILTIN_REALMS */
        -:  576:
        2:  577:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_global_object_t), obj_type);
        -:  578:
        2:  579:  ecma_op_ordinary_object_set_extensible (object_p);
        -:  580:
        2:  581:  ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -:  582:
        2:  583:  global_object_p->extended_object.u.built_in.id = (uint8_t) ECMA_BUILTIN_ID_GLOBAL;
        2:  584:  global_object_p->extended_object.u.built_in.routine_id = 0;
        -:  585:  /* Bitset size is ignored by the gc. */
        2:  586:  global_object_p->extended_object.u.built_in.u.length_and_bitset_size = 0;
        2:  587:  global_object_p->extended_object.u.built_in.u2.instantiated_bitset[0] = 0;
        2:  588:  global_object_p->extra_instantiated_bitset[0] = 0;
        -:  589:#if JERRY_BUILTIN_REALMS
        2:  590:  ECMA_SET_INTERNAL_VALUE_POINTER (global_object_p->extended_object.u.built_in.realm_value, global_object_p);
        2:  591:  global_object_p->extra_realms_bitset = 0;
        2:  592:  global_object_p->this_binding = ecma_make_object_value (object_p);
        -:  593:#else /* !JERRY_BUILTIN_REALMS */
    #####:  594:  global_object_p->extended_object.u.built_in.continue_instantiated_bitset[0] = 0;
        -:  595:#endif /* JERRY_BUILTIN_REALMS */
        -:  596:
        2:  597:  memset (global_object_p->builtin_objects, 0, (sizeof (jmem_cpointer_t) * ECMA_BUILTIN_OBJECTS_COUNT));
        -:  598:
        -:  599:  /* Temporary self reference for GC mark. */
        2:  600:  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, object_p);
        -:  601:#if JERRY_ESNEXT
        2:  602:  global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -:  603:#endif /* JERRY_ESNEXT */
        -:  604:
        2:  605:  ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, object_p);
        2:  606:  ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -:  607:#if JERRY_ESNEXT
        2:  608:  global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -:  609:#endif /* JERRY_ESNEXT */
        2:  610:  ecma_deref_object (global_lex_env_p);
        -:  611:
        -:  612:  ecma_object_t *prototype_object_p;
        2:  613:  prototype_object_p = ecma_instantiate_builtin (global_object_p, prototype_builtin_id);
        2:  614:  JERRY_ASSERT (prototype_object_p != NULL);
        -:  615:
        2:  616:  ECMA_SET_NON_NULL_POINTER (object_p->u2.prototype_cp, prototype_object_p);
        -:  617:
        2:  618:  return global_object_p;
        -:  619:} /* ecma_builtin_create_global_object */
        -:  620:
        -:  621:/**
        -:  622: * Get reference to specified built-in object
        -:  623: *
        -:  624: * Note:
        -:  625: *   Does not increase the reference counter.
        -:  626: *
        -:  627: * @return pointer to the object's instance
        -:  628: */
        -:  629:ecma_object_t *
       20:  630:ecma_builtin_get (ecma_builtin_id_t builtin_id) /**< id of built-in to check on */
        -:  631:{
       20:  632:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);
        -:  633:
       20:  634:  ecma_global_object_t *global_object_p = (ecma_global_object_t *) ecma_builtin_get_global ();
       20:  635:  jmem_cpointer_t *builtin_p = global_object_p->builtin_objects + builtin_id;
        -:  636:
       20:  637:  if (JERRY_UNLIKELY (*builtin_p == JMEM_CP_NULL))
        -:  638:  {
        6:  639:    return ecma_instantiate_builtin (global_object_p, builtin_id);
        -:  640:  }
        -:  641:
       14:  642:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, *builtin_p);
        -:  643:} /* ecma_builtin_get */
        -:  644:
        -:  645:#if JERRY_BUILTIN_REALMS
        -:  646:
        -:  647:/**
        -:  648: * Get reference to specified built-in object using the realm provided by another built-in object
        -:  649: *
        -:  650: * Note:
        -:  651: *   Does not increase the reference counter.
        -:  652: *
        -:  653: * @return pointer to the object's instance
        -:  654: */
        -:  655:ecma_object_t *
      142:  656:ecma_builtin_get_from_realm (ecma_global_object_t *global_object_p, /**< global object */
        -:  657:                             ecma_builtin_id_t builtin_id) /**< id of built-in to check on */
        -:  658:{
      142:  659:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);
        -:  660:
      142:  661:  jmem_cpointer_t *builtin_p = global_object_p->builtin_objects + builtin_id;
        -:  662:
      142:  663:  if (JERRY_UNLIKELY (*builtin_p == JMEM_CP_NULL))
        -:  664:  {
       90:  665:    return ecma_instantiate_builtin (global_object_p, builtin_id);
        -:  666:  }
        -:  667:
       52:  668:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, *builtin_p);
        -:  669:} /* ecma_builtin_get_from_realm */
        -:  670:
        -:  671:#endif /* JERRY_BUILTIN_REALMS */
        -:  672:
        -:  673:/**
        -:  674: * Get reference to specified built-in object using the realm provided by another built-in object
        -:  675: *
        -:  676: * Note:
        -:  677: *   Does not increase the reference counter.
        -:  678: *
        -:  679: * @return pointer to the object's instance
        -:  680: */
        -:  681:static inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE
        -:  682:ecma_builtin_get_from_builtin (ecma_object_t *builtin_object_p, /**< built-in object */
        -:  683:                               ecma_builtin_id_t builtin_id) /**< id of built-in to check on */
        -:  684:{
      142:  685:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_OBJECTS_COUNT);
        -:  686:
        -:  687:#if JERRY_BUILTIN_REALMS
      142:  688:  return ecma_builtin_get_from_realm (ecma_builtin_get_realm (builtin_object_p), builtin_id);
        -:  689:#else /* !JERRY_BUILTIN_REALMS */
        -:  690:  JERRY_UNUSED (builtin_object_p);
    #####:  691:  return ecma_builtin_get (builtin_id);
        -:  692:#endif /* JERRY_BUILTIN_REALMS */
        -:  693:} /* ecma_builtin_get_from_builtin */
        -:  694:
        -:  695:/**
        -:  696: * Construct a Function object for specified built-in routine
        -:  697: *
        -:  698: * See also: ECMA-262 v5, 15
        -:  699: *
        -:  700: * @return pointer to constructed Function object
        -:  701: */
        -:  702:static ecma_object_t *
       48:  703:ecma_builtin_make_function_object_for_routine (ecma_object_t *builtin_object_p, /**< builtin object */
        -:  704:                                               uint8_t routine_id, /**< builtin-wide identifier of the built-in
        -:  705:                                                                    *   object's routine property */
        -:  706:                                               uint32_t routine_index, /**< property descriptor index of routine */
        -:  707:                                               uint8_t flags) /**< see also: ecma_builtin_routine_flags */
        -:  708:{
       48:  709:  ecma_object_t *prototype_obj_p = ecma_builtin_get_from_builtin (builtin_object_p,
        -:  710:                                                                  ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
        -:  711:
       48:  712:  size_t ext_object_size = sizeof (ecma_extended_object_t);
        -:  713:
       48:  714:  ecma_object_t *func_obj_p = ecma_create_object (prototype_obj_p,
        -:  715:                                                  ext_object_size,
        -:  716:                                                  ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -:  717:
       48:  718:  JERRY_ASSERT (routine_id > 0);
       48:  719:  JERRY_ASSERT (routine_index <= UINT8_MAX);
        -:  720:
        -:  721:  ecma_built_in_props_t *built_in_props_p;
        -:  722:
       48:  723:  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (ecma_get_object_type (builtin_object_p)))
        -:  724:  {
    #####:  725:    built_in_props_p = &((ecma_extended_built_in_object_t *) builtin_object_p)->built_in;
        -:  726:  }
        -:  727:  else
        -:  728:  {
       48:  729:    built_in_props_p = &((ecma_extended_object_t *) builtin_object_p)->u.built_in;
        -:  730:  }
        -:  731:
       48:  732:  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;
       48:  733:  ext_func_obj_p->u.built_in.id = built_in_props_p->id;
       48:  734:  ext_func_obj_p->u.built_in.routine_id = routine_id;
       48:  735:  ext_func_obj_p->u.built_in.u.routine_index = (uint8_t) routine_index;
       48:  736:  ext_func_obj_p->u.built_in.u2.routine_flags = flags;
        -:  737:
        -:  738:#if JERRY_BUILTIN_REALMS
       48:  739:  ext_func_obj_p->u.built_in.realm_value = built_in_props_p->realm_value;
        -:  740:#endif /* JERRY_BUILTIN_REALMS */
        -:  741:
       48:  742:  return func_obj_p;
        -:  743:} /* ecma_builtin_make_function_object_for_routine */
        -:  744:
        -:  745:/**
        -:  746: * Construct a Function object for specified built-in accessor getter
        -:  747: *
        -:  748: * @return pointer to constructed accessor getter Function object
        -:  749: */
        -:  750:static ecma_object_t *
        2:  751:ecma_builtin_make_function_object_for_getter_accessor (ecma_object_t *builtin_object_p, /**< builtin object */
        -:  752:                                                       uint8_t routine_id, /**< builtin-wide id of the built-in
        -:  753:                                                                            *   object's routine property */
        -:  754:                                                       uint32_t routine_index) /**< property descriptor index
        -:  755:                                                                                *   of routine */
        -:  756:{
        2:  757:  return ecma_builtin_make_function_object_for_routine (builtin_object_p,
        -:  758:                                                        routine_id,
        -:  759:                                                        routine_index,
        -:  760:                                                        ECMA_BUILTIN_ROUTINE_GETTER);
        -:  761:} /* ecma_builtin_make_function_object_for_getter_accessor */
        -:  762:
        -:  763:/**
        -:  764: * Construct a Function object for specified built-in accessor setter
        -:  765: *
        -:  766: * @return pointer to constructed accessor getter Function object
        -:  767: */
        -:  768:static ecma_object_t *
        2:  769:ecma_builtin_make_function_object_for_setter_accessor (ecma_object_t *builtin_object_p, /**< builtin object */
        -:  770:                                                       uint8_t routine_id, /**< builtin-wide id of the built-in
        -:  771:                                                                            *   object's routine property */
        -:  772:                                                       uint32_t routine_index) /**< property descriptor index
        -:  773:                                                                                *   of routine */
        -:  774:{
        2:  775:  return ecma_builtin_make_function_object_for_routine (builtin_object_p,
        -:  776:                                                        routine_id,
        -:  777:                                                        routine_index,
        -:  778:                                                        ECMA_BUILTIN_ROUTINE_SETTER);
        -:  779:} /* ecma_builtin_make_function_object_for_setter_accessor */
        -:  780:
        -:  781:#if JERRY_ESNEXT
        -:  782:
        -:  783:/**
        -:  784: * Create specification defined properties for built-in native handlers.
        -:  785: *
        -:  786: * @return pointer property, if one was instantiated,
        -:  787: *         NULL - otherwise.
        -:  788: */
        -:  789:static ecma_property_t *
    #####:  790:ecma_builtin_native_handler_try_to_instantiate_property (ecma_object_t *object_p, /**< object */
        -:  791:                                                         ecma_string_t *property_name_p) /**< property's name */
        -:  792:{
    #####:  793:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -:  794:
    #####:  795:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  796:  ecma_property_t *prop_p = NULL;
        -:  797:
    #####:  798:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_NAME))
        -:  799:  {
    #####:  800:    if ((ext_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_NAME_INITIALIZED) == 0)
        -:  801:    {
    #####:  802:      ecma_property_value_t *value_p = ecma_create_named_data_property (object_p,
        -:  803:                                                                        property_name_p,
        -:  804:                                                                        ECMA_PROPERTY_BUILT_IN_CONFIGURABLE,
        -:  805:                                                                        &prop_p);
        -:  806:
    #####:  807:      value_p->value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  808:    }
        -:  809:  }
    #####:  810:  else if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))
        -:  811:  {
    #####:  812:    if ((ext_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_LENGTH_INITIALIZED) == 0)
        -:  813:    {
    #####:  814:      ecma_property_value_t *value_p = ecma_create_named_data_property (object_p,
        -:  815:                                                                        property_name_p,
        -:  816:                                                                        ECMA_PROPERTY_BUILT_IN_CONFIGURABLE,
        -:  817:                                                                        &prop_p);
        -:  818:
    #####:  819:      const uint8_t length = ecma_builtin_handler_get_length (ext_obj_p->u.built_in.routine_id);
    #####:  820:      value_p->value = ecma_make_integer_value (length);
        -:  821:    }
        -:  822:  }
        -:  823:
    #####:  824:  return prop_p;
        -:  825:} /* ecma_builtin_native_handler_try_to_instantiate_property */
        -:  826:
        -:  827:#endif /* JERRY_ESNEXT */
        -:  828:
        -:  829:/**
        -:  830: * Lazy instantiation of builtin routine property of builtin object
        -:  831: *
        -:  832: * If the property is not instantiated yet, instantiate the property and
        -:  833: * return pointer to the instantiated property.
        -:  834: *
        -:  835: * @return pointer property, if one was instantiated,
        -:  836: *         NULL - otherwise.
        -:  837: */
        -:  838:ecma_property_t *
    #####:  839:ecma_builtin_routine_try_to_instantiate_property (ecma_object_t *object_p, /**< object */
        -:  840:                                                  ecma_string_t *property_name_p) /**< property name */
        -:  841:{
    #####:  842:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
        -:  843:                && ecma_builtin_function_is_routine (object_p));
        -:  844:
    #####:  845:  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
        -:  846:
        -:  847:#if JERRY_ESNEXT
    #####:  848:  if (JERRY_UNLIKELY (ext_func_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER))
        -:  849:  {
    #####:  850:    return ecma_builtin_native_handler_try_to_instantiate_property (object_p, property_name_p);
        -:  851:  }
        -:  852:#endif /* !JERRY_ESNEXT */
        -:  853:
    #####:  854:  if (ecma_string_is_length (property_name_p))
        -:  855:  {
        -:  856:    /*
        -:  857:     * Lazy instantiation of 'length' property
        -:  858:     */
    #####:  859:    ecma_property_t *len_prop_p;
        -:  860:
        -:  861:#if JERRY_ESNEXT
    #####:  862:    uint8_t *bitset_p = &ext_func_p->u.built_in.u2.routine_flags;
        -:  863:
    #####:  864:    if (*bitset_p & ECMA_BUILTIN_ROUTINE_LENGTH_INITIALIZED)
        -:  865:    {
        -:  866:      /* length property was already instantiated */
    #####:  867:      return NULL;
        -:  868:    }
        -:  869:
        -:  870:    /* We mark that the property was lazily instantiated,
        -:  871:     * as it is configurable and so can be deleted (ECMA-262 v6, 19.2.4.1) */
    #####:  872:    ecma_property_value_t *len_prop_value_p = ecma_create_named_data_property (object_p,
        -:  873:                                                                               property_name_p,
        -:  874:                                                                               ECMA_PROPERTY_BUILT_IN_CONFIGURABLE,
        -:  875:                                                                               &len_prop_p);
        -:  876:#else /* !JERRY_ESNEXT */
        -:  877:    /* We don't need to mark that the property was already lazy instantiated,
        -:  878:     * as it is non-configurable and so can't be deleted (ECMA-262 v5, 13.2.5) */
    #####:  879:    ecma_property_value_t *len_prop_value_p = ecma_create_named_data_property (object_p,
        -:  880:                                                                               property_name_p,
        -:  881:                                                                               ECMA_PROPERTY_BUILT_IN_FIXED,
        -:  882:                                                                               &len_prop_p);
        -:  883:#endif /* JERRY_ESNEXT */
        -:  884:
    #####:  885:    uint8_t length = 0;
        -:  886:
    #####:  887:    if (ext_func_p->u.built_in.u2.routine_flags & ECMA_BUILTIN_ROUTINE_SETTER)
        -:  888:    {
    #####:  889:      length = 1;
        -:  890:    }
    #####:  891:    else if (!(ext_func_p->u.built_in.u2.routine_flags & ECMA_BUILTIN_ROUTINE_GETTER))
        -:  892:    {
    #####:  893:      uint8_t routine_index = ext_func_p->u.built_in.u.routine_index;
        -:  894:      const ecma_builtin_property_descriptor_t *property_list_p;
        -:  895:
    #####:  896:      property_list_p = ecma_builtin_property_list_references[ext_func_p->u.built_in.id];
        -:  897:
    #####:  898:      JERRY_ASSERT (property_list_p[routine_index].type == ECMA_BUILTIN_PROPERTY_ROUTINE);
        -:  899:
    #####:  900:      length = ECMA_GET_ROUTINE_LENGTH (property_list_p[routine_index].value);
        -:  901:    }
        -:  902:
    #####:  903:    len_prop_value_p->value = ecma_make_integer_value (length);
    #####:  904:    return len_prop_p;
        -:  905:  }
        -:  906:
        -:  907:#if JERRY_ESNEXT
        -:  908:  /*
        -:  909:   * Lazy instantiation of 'name' property
        -:  910:   */
    #####:  911:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_NAME))
        -:  912:  {
    #####:  913:    uint8_t *bitset_p = &ext_func_p->u.built_in.u2.routine_flags;
        -:  914:
    #####:  915:    if (*bitset_p & ECMA_BUILTIN_ROUTINE_NAME_INITIALIZED)
        -:  916:    {
        -:  917:      /* name property was already instantiated */
    #####:  918:      return NULL;
        -:  919:    }
        -:  920:
        -:  921:    /* We mark that the property was lazily instantiated */
    #####:  922:    ecma_property_t *name_prop_p;
    #####:  923:    ecma_property_value_t *name_prop_value_p = ecma_create_named_data_property (object_p,
        -:  924:                                                                                property_name_p,
        -:  925:                                                                                ECMA_PROPERTY_BUILT_IN_CONFIGURABLE,
        -:  926:                                                                                &name_prop_p);
        -:  927:
    #####:  928:    uint8_t routine_index = ext_func_p->u.built_in.u.routine_index;
        -:  929:    const ecma_builtin_property_descriptor_t *property_list_p;
        -:  930:
    #####:  931:    property_list_p = ecma_builtin_property_list_references[ext_func_p->u.built_in.id];
        -:  932:
    #####:  933:    JERRY_ASSERT (property_list_p[routine_index].type == ECMA_BUILTIN_PROPERTY_ROUTINE
        -:  934:                  || property_list_p[routine_index].type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE
        -:  935:                  || property_list_p[routine_index].type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);
        -:  936:
    #####:  937:    lit_magic_string_id_t name_id = property_list_p[routine_index].magic_string_id;
        -:  938:    ecma_string_t *name_p;
        -:  939:
    #####:  940:    if (JERRY_UNLIKELY (name_id > LIT_NON_INTERNAL_MAGIC_STRING__COUNT))
        -:  941:    {
        -:  942:      /* Note: Whenever new intrinsic routine is being added this mapping should be updated as well! */
    #####:  943:      if (JERRY_UNLIKELY (name_id == LIT_INTERNAL_MAGIC_STRING_ARRAY_PROTOTYPE_VALUES)
    #####:  944:          || JERRY_UNLIKELY (name_id == LIT_INTERNAL_MAGIC_STRING_TYPEDARRAY_PROTOTYPE_VALUES)
    #####:  945:          || JERRY_UNLIKELY (name_id == LIT_INTERNAL_MAGIC_STRING_SET_PROTOTYPE_VALUES))
        -:  946:      {
    #####:  947:        name_p = ecma_get_magic_string (LIT_MAGIC_STRING_VALUES);
        -:  948:      }
    #####:  949:      else if (JERRY_UNLIKELY (name_id == LIT_INTERNAL_MAGIC_STRING_MAP_PROTOTYPE_ENTRIES))
        -:  950:      {
    #####:  951:        name_p = ecma_get_magic_string (LIT_MAGIC_STRING_ENTRIES);
        -:  952:      }
        -:  953:      else
        -:  954:      {
    #####:  955:        JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (name_id));
    #####:  956:        name_p = ecma_op_get_global_symbol (name_id);
        -:  957:      }
        -:  958:    }
        -:  959:    else
        -:  960:    {
    #####:  961:      name_p = ecma_get_magic_string (name_id);
        -:  962:    }
        -:  963:
    #####:  964:    char *prefix_p = NULL;
    #####:  965:    lit_utf8_size_t prefix_size = 0;
        -:  966:
    #####:  967:    if (*bitset_p & (ECMA_BUILTIN_ROUTINE_GETTER | ECMA_BUILTIN_ROUTINE_SETTER))
        -:  968:    {
    #####:  969:      prefix_size = 4;
    #####:  970:      prefix_p = (*bitset_p & ECMA_BUILTIN_ROUTINE_GETTER) ? "get " : "set ";
        -:  971:    }
        -:  972:
    #####:  973:    name_prop_value_p->value = ecma_op_function_form_name (name_p, prefix_p, prefix_size);
        -:  974:
    #####:  975:    if (JERRY_UNLIKELY (name_id > LIT_NON_INTERNAL_MAGIC_STRING__COUNT))
        -:  976:    {
    #####:  977:      ecma_deref_ecma_string (name_p);
        -:  978:    }
        -:  979:
    #####:  980:    return name_prop_p;
        -:  981:  }
        -:  982:#endif /* JERRY_ESNEXT */
        -:  983:
    #####:  984:  return NULL;
        -:  985:} /* ecma_builtin_routine_try_to_instantiate_property */
        -:  986:
        -:  987:/**
        -:  988: * If the property's name is one of built-in properties of the object
        -:  989: * that is not instantiated yet, instantiate the property and
        -:  990: * return pointer to the instantiated property.
        -:  991: *
        -:  992: * @return pointer property, if one was instantiated,
        -:  993: *         NULL - otherwise.
        -:  994: */
        -:  995:ecma_property_t *
      368:  996:ecma_builtin_try_to_instantiate_property (ecma_object_t *object_p, /**< object */
        -:  997:                                          ecma_string_t *property_name_p) /**< property's name */
        -:  998:{
      368:  999:  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (property_name_p);
        -: 1000:
        -: 1001:#if JERRY_ESNEXT
      368: 1002:  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p))
       40: 1003:      && property_name_p->u.hash & ECMA_GLOBAL_SYMBOL_FLAG)
        -: 1004:  {
       40: 1005:    magic_string_id = (property_name_p->u.hash >> ECMA_GLOBAL_SYMBOL_SHIFT);
        -: 1006:  }
        -: 1007:#endif /* JERRY_ESNEXT */
        -: 1008:
      368: 1009:  if (magic_string_id == LIT_MAGIC_STRING__COUNT)
        -: 1010:  {
       36: 1011:    return NULL;
        -: 1012:  }
        -: 1013:
        -: 1014:  ecma_built_in_props_t *built_in_props_p;
      332: 1015:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 1016:
      334: 1017:  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL
        -: 1018:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS
        -: 1019:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY
        -: 1020:                || (object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
        -: 1021:                    && !ecma_builtin_function_is_routine (object_p)));
        -: 1022:
      332: 1023:  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))
        -: 1024:  {
    #####: 1025:    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;
        -: 1026:  }
        -: 1027:  else
        -: 1028:  {
      332: 1029:    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;
        -: 1030:  }
        -: 1031:
      332: 1032:  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;
        -: 1033:
      332: 1034:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
        -: 1035:
      332: 1036:  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];
      332: 1037:  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;
        -: 1038:
     7764: 1039:  while (curr_property_p->magic_string_id != magic_string_id)
        -: 1040:  {
     7284: 1041:    if (curr_property_p->magic_string_id == LIT_MAGIC_STRING__COUNT)
        -: 1042:    {
      184: 1043:      return NULL;
        -: 1044:    }
     7100: 1045:    curr_property_p++;
        -: 1046:  }
        -: 1047:
      148: 1048:  uint32_t index = (uint32_t) (curr_property_p - property_list_p);
      148: 1049:  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + (index >> 3);
        -: 1050:
        -: 1051:#if JERRY_BUILTIN_REALMS
      148: 1052:  if (index >= 8 * sizeof (uint8_t))
        -: 1053:  {
      114: 1054:    bitset_p += sizeof (ecma_value_t);
        -: 1055:  }
        -: 1056:#endif /* JERRY_BUILTIN_REALMS */
        -: 1057:
      148: 1058:  uint8_t bit_for_index = (uint8_t) (1u << (index & 0x7));
        -: 1059:
      148: 1060:  if (*bitset_p & bit_for_index)
        -: 1061:  {
        -: 1062:    /* This property was instantiated before. */
    #####: 1063:    return NULL;
        -: 1064:  }
        -: 1065:
      148: 1066:  ecma_value_t value = ECMA_VALUE_EMPTY;
      148: 1067:  bool is_accessor = false;
      148: 1068:  ecma_object_t *getter_p = NULL;
      148: 1069:  ecma_object_t *setter_p = NULL;
        -: 1070:
      148: 1071:  switch (curr_property_p->type)
        -: 1072:  {
        4: 1073:    case ECMA_BUILTIN_PROPERTY_SIMPLE:
        -: 1074:    {
        4: 1075:      value = curr_property_p->value;
        -: 1076:
        -: 1077:#if JERRY_BUILTIN_GLOBAL_THIS
        4: 1078:      if (value == ECMA_VALUE_GLOBAL_THIS)
        -: 1079:      {
        -: 1080:        /* Only the global object has globalThis property. */
        2: 1081:        JERRY_ASSERT (ecma_builtin_is_global (object_p));
        2: 1082:        ecma_ref_object (object_p);
        2: 1083:        value = ecma_make_object_value (object_p);
        -: 1084:      }
        -: 1085:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        4: 1086:      break;
        -: 1087:    }
        4: 1088:    case ECMA_BUILTIN_PROPERTY_NUMBER:
        -: 1089:    {
        4: 1090:      ecma_number_t num = 0.0;
        -: 1091:
        4: 1092:      if (curr_property_p->value < ECMA_BUILTIN_NUMBER_MAX)
        -: 1093:      {
    #####: 1094:        num = curr_property_p->value;
        -: 1095:      }
        4: 1096:      else if (curr_property_p->value < ECMA_BUILTIN_NUMBER_NAN)
        -: 1097:      {
        -: 1098:        static const ecma_number_t builtin_number_list[] =
        -: 1099:        {
        -: 1100:          ECMA_NUMBER_MAX_VALUE,
        -: 1101:          ECMA_NUMBER_MIN_VALUE,
        -: 1102:#if JERRY_ESNEXT
        -: 1103:          ECMA_NUMBER_EPSILON,
        -: 1104:          ECMA_NUMBER_MAX_SAFE_INTEGER,
        -: 1105:          ECMA_NUMBER_MIN_SAFE_INTEGER,
        -: 1106:#endif /* JERRY_ESNEXT */
        -: 1107:          ECMA_NUMBER_E,
        -: 1108:          ECMA_NUMBER_PI,
        -: 1109:          ECMA_NUMBER_LN10,
        -: 1110:          ECMA_NUMBER_LN2,
        -: 1111:          ECMA_NUMBER_LOG2E,
        -: 1112:          ECMA_NUMBER_LOG10E,
        -: 1113:          ECMA_NUMBER_SQRT2,
        -: 1114:          ECMA_NUMBER_SQRT_1_2,
        -: 1115:        };
        -: 1116:
    #####: 1117:        num = builtin_number_list[curr_property_p->value - ECMA_BUILTIN_NUMBER_MAX];
        -: 1118:      }
        -: 1119:      else
        -: 1120:      {
        4: 1121:        switch (curr_property_p->value)
        -: 1122:        {
        2: 1123:          case ECMA_BUILTIN_NUMBER_POSITIVE_INFINITY:
        -: 1124:          {
        2: 1125:            num = ecma_number_make_infinity (false);
        2: 1126:            break;
        -: 1127:          }
    #####: 1128:          case ECMA_BUILTIN_NUMBER_NEGATIVE_INFINITY:
        -: 1129:          {
    #####: 1130:            num = ecma_number_make_infinity (true);
    #####: 1131:            break;
        -: 1132:          }
        2: 1133:          default:
        -: 1134:          {
        2: 1135:            JERRY_ASSERT (curr_property_p->value == ECMA_BUILTIN_NUMBER_NAN);
        -: 1136:
        2: 1137:            num = ecma_number_make_nan ();
        2: 1138:            break;
        -: 1139:          }
        -: 1140:        }
        -: 1141:      }
        -: 1142:
        4: 1143:      value = ecma_make_number_value (num);
        4: 1144:      break;
        -: 1145:    }
    #####: 1146:    case ECMA_BUILTIN_PROPERTY_STRING:
        -: 1147:    {
    #####: 1148:      value = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->value);
    #####: 1149:      break;
        -: 1150:    }
        -: 1151:#if JERRY_ESNEXT
    #####: 1152:    case ECMA_BUILTIN_PROPERTY_SYMBOL:
        -: 1153:    {
    #####: 1154:      lit_magic_string_id_t symbol_id = (lit_magic_string_id_t) curr_property_p->value;
        -: 1155:
    #####: 1156:      value = ecma_make_symbol_value (ecma_op_get_global_symbol (symbol_id));
    #####: 1157:      break;
        -: 1158:    }
        4: 1159:    case ECMA_BUILTIN_PROPERTY_INTRINSIC_PROPERTY:
        -: 1160:    {
        4: 1161:      ecma_object_t *intrinsic_object_p = ecma_builtin_get_from_builtin (object_p, ECMA_BUILTIN_ID_INTRINSIC_OBJECT);
        4: 1162:      value = ecma_op_object_get_by_magic_id (intrinsic_object_p, (lit_magic_string_id_t) curr_property_p->value);
        4: 1163:      break;
        -: 1164:    }
    #####: 1165:    case ECMA_BUILTIN_PROPERTY_ACCESSOR_BUILTIN_FUNCTION:
        -: 1166:    {
    #####: 1167:      is_accessor = true;
    #####: 1168:      uint16_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);
    #####: 1169:      uint16_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);
    #####: 1170:      getter_p = ecma_builtin_get_from_builtin (object_p, getter_id);
    #####: 1171:      setter_p = ecma_builtin_get_from_builtin (object_p, setter_id);
    #####: 1172:      ecma_ref_object (getter_p);
    #####: 1173:      ecma_ref_object (setter_p);
    #####: 1174:      break;
        -: 1175:    }
        -: 1176:#endif /* JERRY_ESNEXT */
       90: 1177:    case ECMA_BUILTIN_PROPERTY_OBJECT:
        -: 1178:    {
        -: 1179:      ecma_object_t *builtin_object_p;
      180: 1180:      builtin_object_p = ecma_builtin_get_from_builtin (object_p, (ecma_builtin_id_t) curr_property_p->value);
       90: 1181:      ecma_ref_object (builtin_object_p);
       90: 1182:      value = ecma_make_object_value (builtin_object_p);
       90: 1183:      break;
        -: 1184:    }
       44: 1185:    case ECMA_BUILTIN_PROPERTY_ROUTINE:
        -: 1186:    {
        -: 1187:      ecma_object_t *func_obj_p;
       44: 1188:      func_obj_p = ecma_builtin_make_function_object_for_routine (object_p,
       44: 1189:                                                                  ECMA_GET_ROUTINE_ID (curr_property_p->value),
        -: 1190:                                                                  index,
        -: 1191:                                                                  ECMA_BUILTIN_ROUTINE_NO_OPTS);
       44: 1192:      value = ecma_make_object_value (func_obj_p);
       44: 1193:      break;
        -: 1194:    }
        2: 1195:    case ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_WRITE:
        -: 1196:    {
        2: 1197:      is_accessor = true;
        2: 1198:      uint8_t getter_id = ECMA_ACCESSOR_READ_WRITE_GET_GETTER_ID (curr_property_p->value);
        2: 1199:      uint8_t setter_id = ECMA_ACCESSOR_READ_WRITE_GET_SETTER_ID (curr_property_p->value);
        2: 1200:      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);
        2: 1201:      setter_p = ecma_builtin_make_function_object_for_setter_accessor (object_p, setter_id, index);
        2: 1202:      break;
        -: 1203:    }
    #####: 1204:    default:
        -: 1205:    {
    #####: 1206:      JERRY_ASSERT (curr_property_p->type == ECMA_BUILTIN_PROPERTY_ACCESSOR_READ_ONLY);
        -: 1207:
    #####: 1208:      is_accessor = true;
    #####: 1209:      uint8_t getter_id = (uint8_t) curr_property_p->value;
    #####: 1210:      getter_p = ecma_builtin_make_function_object_for_getter_accessor (object_p, getter_id, index);
    #####: 1211:      break;
        -: 1212:    }
        -: 1213:  }
        -: 1214:
      148: 1215:  ecma_property_t *prop_p;
        -: 1216:
      148: 1217:  JERRY_ASSERT (curr_property_p->attributes & ECMA_PROPERTY_FLAG_BUILT_IN);
        -: 1218:
      148: 1219:  if (is_accessor)
        -: 1220:  {
        2: 1221:    ecma_create_named_accessor_property (object_p,
        -: 1222:                                         property_name_p,
        -: 1223:                                         getter_p,
        -: 1224:                                         setter_p,
        2: 1225:                                         curr_property_p->attributes,
        -: 1226:                                         &prop_p);
        -: 1227:
        2: 1228:    if (setter_p)
        -: 1229:    {
        2: 1230:      ecma_deref_object (setter_p);
        -: 1231:    }
        2: 1232:    if (getter_p)
        -: 1233:    {
        2: 1234:      ecma_deref_object (getter_p);
        -: 1235:    }
        -: 1236:  }
        -: 1237:  else
        -: 1238:  {
      146: 1239:    ecma_property_value_t *prop_value_p = ecma_create_named_data_property (object_p,
        -: 1240:                                                                           property_name_p,
      146: 1241:                                                                           curr_property_p->attributes,
        -: 1242:                                                                           &prop_p);
      146: 1243:    prop_value_p->value = value;
        -: 1244:
        -: 1245:    /* Reference count of objects must be decreased. */
      146: 1246:    ecma_deref_if_object (value);
        -: 1247:  }
        -: 1248:
      148: 1249:  return prop_p;
        -: 1250:} /* ecma_builtin_try_to_instantiate_property */
        -: 1251:
        -: 1252:#if JERRY_ESNEXT
        -: 1253:
        -: 1254:/**
        -: 1255: * Delete configurable properties of native handlers.
        -: 1256: */
        -: 1257:static void
    #####: 1258:ecma_builtin_native_handler_delete_built_in_property (ecma_object_t *object_p, /**< object */
        -: 1259:                                                      ecma_string_t *property_name_p) /**< property name */
        -: 1260:{
    #####: 1261:  ecma_extended_object_t *extended_obj_p = (ecma_extended_object_t *) object_p;
        -: 1262:
    #####: 1263:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))
        -: 1264:  {
    #####: 1265:    JERRY_ASSERT (!(extended_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_LENGTH_INITIALIZED));
        -: 1266:
    #####: 1267:    extended_obj_p->u.built_in.u2.routine_flags |= ECMA_NATIVE_HANDLER_FLAGS_LENGTH_INITIALIZED;
    #####: 1268:    return;
        -: 1269:  }
        -: 1270:
    #####: 1271:  JERRY_ASSERT (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_NAME));
    #####: 1272:  JERRY_ASSERT (!(extended_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_NAME_INITIALIZED));
        -: 1273:
    #####: 1274:  extended_obj_p->u.built_in.u2.routine_flags |= ECMA_NATIVE_HANDLER_FLAGS_NAME_INITIALIZED;
        -: 1275:} /* ecma_builtin_native_handler_delete_built_in_property */
        -: 1276:
        -: 1277:/**
        -: 1278: * Delete configurable properties of built-in routines.
        -: 1279: */
        -: 1280:void
    #####: 1281:ecma_builtin_routine_delete_built_in_property (ecma_object_t *object_p, /**< object */
        -: 1282:                                               ecma_string_t *property_name_p) /**< property name */
        -: 1283:{
    #####: 1284:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
        -: 1285:                && ecma_builtin_function_is_routine (object_p));
        -: 1286:
    #####: 1287:  ecma_extended_object_t *extended_obj_p = (ecma_extended_object_t *) object_p;
        -: 1288:
    #####: 1289:  if (JERRY_UNLIKELY (extended_obj_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER))
        -: 1290:  {
    #####: 1291:    ecma_builtin_native_handler_delete_built_in_property (object_p, property_name_p);
    #####: 1292:    return;
        -: 1293:  }
        -: 1294:
    #####: 1295:  uint8_t *bitset_p = &extended_obj_p->u.built_in.u2.routine_flags;
        -: 1296:
    #####: 1297:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))
        -: 1298:  {
    #####: 1299:    JERRY_ASSERT (!(*bitset_p & ECMA_BUILTIN_ROUTINE_LENGTH_INITIALIZED));
        -: 1300:
    #####: 1301:    *bitset_p |= ECMA_BUILTIN_ROUTINE_LENGTH_INITIALIZED;
    #####: 1302:    return;
        -: 1303:  }
        -: 1304:
    #####: 1305:  JERRY_ASSERT (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_NAME));
    #####: 1306:  JERRY_ASSERT (!(*bitset_p & ECMA_BUILTIN_ROUTINE_NAME_INITIALIZED));
        -: 1307:
    #####: 1308:  *bitset_p |= ECMA_BUILTIN_ROUTINE_NAME_INITIALIZED;
        -: 1309:} /* ecma_builtin_routine_delete_built_in_property */
        -: 1310:
        -: 1311:#endif /* JERRY_ESNEXT */
        -: 1312:
        -: 1313:/**
        -: 1314: * Delete configurable properties of built-ins.
        -: 1315: */
        -: 1316:void
    #####: 1317:ecma_builtin_delete_built_in_property (ecma_object_t *object_p, /**< object */
        -: 1318:                                       ecma_string_t *property_name_p) /**< property name */
        -: 1319:{
    #####: 1320:  lit_magic_string_id_t magic_string_id = ecma_get_string_magic (property_name_p);
        -: 1321:
        -: 1322:#if JERRY_ESNEXT
    #####: 1323:  if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -: 1324:  {
    #####: 1325:    if (property_name_p->u.hash & ECMA_GLOBAL_SYMBOL_FLAG)
        -: 1326:    {
    #####: 1327:      magic_string_id = (property_name_p->u.hash >> ECMA_GLOBAL_SYMBOL_SHIFT);
        -: 1328:    }
        -: 1329:  }
        -: 1330:#endif /* JERRY_ESNEXT */
        -: 1331:
        -: 1332:  ecma_built_in_props_t *built_in_props_p;
    #####: 1333:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 1334:
    #####: 1335:  JERRY_ASSERT (object_type == ECMA_OBJECT_TYPE_BUILT_IN_GENERAL
        -: 1336:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_CLASS
        -: 1337:                || object_type == ECMA_OBJECT_TYPE_BUILT_IN_ARRAY
        -: 1338:                || (object_type == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
        -: 1339:                    && !ecma_builtin_function_is_routine (object_p)));
        -: 1340:
    #####: 1341:  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))
        -: 1342:  {
    #####: 1343:    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;
        -: 1344:  }
        -: 1345:  else
        -: 1346:  {
    #####: 1347:    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;
        -: 1348:  }
        -: 1349:
    #####: 1350:  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;
        -: 1351:
    #####: 1352:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
        -: 1353:
    #####: 1354:  const ecma_builtin_property_descriptor_t *property_list_p = ecma_builtin_property_list_references[builtin_id];
    #####: 1355:  const ecma_builtin_property_descriptor_t *curr_property_p = property_list_p;
        -: 1356:
    #####: 1357:  while (curr_property_p->magic_string_id != magic_string_id)
        -: 1358:  {
    #####: 1359:    JERRY_ASSERT (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT);
    #####: 1360:    curr_property_p++;
        -: 1361:  }
        -: 1362:
    #####: 1363:  uint32_t index = (uint32_t) (curr_property_p - property_list_p);
    #####: 1364:  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + (index >> 3);
        -: 1365:
        -: 1366:#if JERRY_BUILTIN_REALMS
    #####: 1367:  if (index >= 8 * sizeof (uint8_t))
        -: 1368:  {
    #####: 1369:    bitset_p += sizeof (ecma_value_t);
        -: 1370:  }
        -: 1371:#endif /* JERRY_BUILTIN_REALMS */
        -: 1372:
    #####: 1373:  uint8_t bit_for_index = (uint8_t) (1u << (index & 0x7));
    #####: 1374:  JERRY_ASSERT (!(*bitset_p & bit_for_index));
        -: 1375:
    #####: 1376:  *bitset_p |= bit_for_index;
    #####: 1377:} /* ecma_builtin_delete_built_in_property */
        -: 1378:
        -: 1379:#if JERRY_ESNEXT
        -: 1380:
        -: 1381:/**
        -: 1382: * List names of an Built-in native handler object's lazy instantiated properties,
        -: 1383: * adding them to corresponding string collections
        -: 1384: */
        -: 1385:static void
    #####: 1386:ecma_builtin_native_handler_list_lazy_property_names (ecma_object_t *object_p, /**< function object */
        -: 1387:                                                      ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 1388:                                                      ecma_property_counter_t *prop_counter_p)  /**< prop counter */
        -: 1389:{
    #####: 1390:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
    #####: 1391:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -: 1392:
    #####: 1393:  if ((ext_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_NAME_INITIALIZED) == 0)
        -: 1394:  {
    #####: 1395:    ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_NAME));
    #####: 1396:    prop_counter_p->string_named_props++;
        -: 1397:  }
        -: 1398:
    #####: 1399:  if ((ext_obj_p->u.built_in.u2.routine_flags & ECMA_NATIVE_HANDLER_FLAGS_LENGTH_INITIALIZED) == 0)
        -: 1400:  {
    #####: 1401:    ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####: 1402:    prop_counter_p->string_named_props++;
        -: 1403:  }
    #####: 1404:} /* ecma_builtin_native_handler_list_lazy_property_names */
        -: 1405:
        -: 1406:#endif /* JERRY_ESNEXT */
        -: 1407:
        -: 1408:/**
        -: 1409: * List names of a built-in function's lazy instantiated properties
        -: 1410: *
        -: 1411: * See also:
        -: 1412: *          ecma_builtin_routine_try_to_instantiate_property
        -: 1413: */
        -: 1414:void
    #####: 1415:ecma_builtin_routine_list_lazy_property_names (ecma_object_t *object_p, /**< a built-in object */
        -: 1416:                                               ecma_collection_t *prop_names_p,  /**< prop name collection */
        -: 1417:                                               ecma_property_counter_t *prop_counter_p, /**< property counters */
        -: 1418:                                               jerry_property_filter_t filter) /**< name filters */
        -: 1419:{
    #####: 1420:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
    #####: 1421:  JERRY_ASSERT (ecma_builtin_function_is_routine (object_p));
        -: 1422:
    #####: 1423:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 1424:  {
    #####: 1425:    return;
        -: 1426:  }
        -: 1427:
        -: 1428:#if JERRY_ESNEXT
    #####: 1429:  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
        -: 1430:
    #####: 1431:  if (JERRY_UNLIKELY (ext_func_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER))
        -: 1432:  {
    #####: 1433:    ecma_builtin_native_handler_list_lazy_property_names (object_p, prop_names_p, prop_counter_p);
    #####: 1434:    return;
        -: 1435:  }
        -: 1436:
    #####: 1437:  if (!(ext_func_p->u.built_in.u2.routine_flags & ECMA_BUILTIN_ROUTINE_LENGTH_INITIALIZED))
        -: 1438:  {
        -: 1439:    /* Unintialized 'length' property is non-enumerable (ECMA-262 v6, 19.2.4.1) */
    #####: 1440:    ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####: 1441:    prop_counter_p->string_named_props++;
        -: 1442:  }
    #####: 1443:  if (!(ext_func_p->u.built_in.u2.routine_flags & ECMA_BUILTIN_ROUTINE_NAME_INITIALIZED))
        -: 1444:  {
        -: 1445:    /* Unintialized 'name' property is non-enumerable (ECMA-262 v6, 19.2.4.2) */
    #####: 1446:    ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_NAME));
    #####: 1447:    prop_counter_p->string_named_props++;
        -: 1448:  }
        -: 1449:#else /* !JERRY_ESNEXT */
        -: 1450:  /* 'length' property is non-enumerable (ECMA-262 v5, 15) */
    #####: 1451:  ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####: 1452:  prop_counter_p->string_named_props++;
        -: 1453:#endif /* JERRY_ESNEXT */
        -: 1454:} /* ecma_builtin_routine_list_lazy_property_names */
        -: 1455:
        -: 1456:/**
        -: 1457: * List names of a built-in object's lazy instantiated properties
        -: 1458: *
        -: 1459: * See also:
        -: 1460: *          ecma_builtin_try_to_instantiate_property
        -: 1461: */
        -: 1462:void
        4: 1463:ecma_builtin_list_lazy_property_names (ecma_object_t *object_p, /**< a built-in object */
        -: 1464:                                       ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 1465:                                       ecma_property_counter_t *prop_counter_p, /**< property counters */
        -: 1466:                                       jerry_property_filter_t filter) /**< name filters */
        -: 1467:{
        4: 1468:  JERRY_ASSERT (ecma_get_object_type (object_p) != ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
        -: 1469:                || !ecma_builtin_function_is_routine (object_p));
        -: 1470:
        -: 1471:  ecma_built_in_props_t *built_in_props_p;
        4: 1472:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 1473:
        4: 1474:  if (ECMA_BUILTIN_IS_EXTENDED_BUILT_IN (object_type))
        -: 1475:  {
    #####: 1476:    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;
        -: 1477:  }
        -: 1478:  else
        -: 1479:  {
        4: 1480:    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;
        -: 1481:  }
        -: 1482:
        4: 1483:  ecma_builtin_id_t builtin_id = (ecma_builtin_id_t) built_in_props_p->id;
        -: 1484:
        4: 1485:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
        -: 1486:
        -: 1487:#if JERRY_BUILTIN_REALMS
        4: 1488:  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + 1 + sizeof (ecma_value_t);
        -: 1489:#else /* !JERRY_BUILTIN_REALMS */
    #####: 1490:  uint8_t *bitset_p = built_in_props_p->u2.instantiated_bitset + 1;
        -: 1491:#endif /* JERRY_BUILTIN_REALMS */
        -: 1492:
        -: 1493:#if JERRY_ESNEXT
        4: 1494:  uint8_t *symbol_bitset_p = bitset_p;
        4: 1495:  bool has_symbol = true;
        -: 1496:#endif /* JERRY_BUILTIN_REALMS */
        -: 1497:
        4: 1498:  if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -: 1499:  {
        4: 1500:    const ecma_builtin_property_descriptor_t *curr_property_p = ecma_builtin_property_list_references[builtin_id];
        4: 1501:    uint8_t bitset = built_in_props_p->u2.instantiated_bitset[0];
        4: 1502:    uint32_t index = 0;
        -: 1503:
        -: 1504:#if JERRY_ESNEXT
        4: 1505:    has_symbol = false;
        -: 1506:#endif /* JERRY_BUILTIN_REALMS */
        -: 1507:
      148: 1508:    while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)
        -: 1509:    {
      140: 1510:      if (index == 8)
        -: 1511:      {
       16: 1512:        bitset = *bitset_p++;
       16: 1513:        index = 0;
        -: 1514:      }
        -: 1515:
      140: 1516:      uint32_t bit_for_index = (uint32_t) 1u << index;
        -: 1517:
      140: 1518:      if (!(bitset & bit_for_index))
        -: 1519:      {
        -: 1520:#if JERRY_ESNEXT
      140: 1521:        if (JERRY_LIKELY (curr_property_p->magic_string_id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT))
        -: 1522:        {
        -: 1523:#endif /* JERRY_ESNEXT */
      140: 1524:          ecma_value_t name = ecma_make_magic_string_value ((lit_magic_string_id_t) curr_property_p->magic_string_id);
      140: 1525:          ecma_collection_push_back (prop_names_p, name);
      140: 1526:          prop_counter_p->string_named_props++;
        -: 1527:#if JERRY_ESNEXT
        -: 1528:        }
        -: 1529:        else
        -: 1530:        {
    #####: 1531:          JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (curr_property_p->magic_string_id));
    #####: 1532:          has_symbol = true;
        -: 1533:        }
        -: 1534:#endif /* JERRY_ESNEXT */
        -: 1535:      }
        -: 1536:
      140: 1537:      curr_property_p++;
      140: 1538:      index++;
        -: 1539:    }
        -: 1540:  }
        -: 1541:
        -: 1542:#if JERRY_ESNEXT
        4: 1543:  if (has_symbol && !(filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS))
        -: 1544:  {
    #####: 1545:    const ecma_builtin_property_descriptor_t *curr_property_p = ecma_builtin_property_list_references[builtin_id];
    #####: 1546:    uint8_t bitset = built_in_props_p->u2.instantiated_bitset[0];
    #####: 1547:    uint32_t index = 0;
        -: 1548:
    #####: 1549:    while (curr_property_p->magic_string_id != LIT_MAGIC_STRING__COUNT)
        -: 1550:    {
    #####: 1551:      if (index == 8)
        -: 1552:      {
    #####: 1553:        bitset = *symbol_bitset_p++;
    #####: 1554:        index = 0;
        -: 1555:      }
        -: 1556:
    #####: 1557:      uint32_t bit_for_index = (uint32_t) 1u << index;
        -: 1558:
    #####: 1559:      if (curr_property_p->magic_string_id > LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 1560:          && !(bitset & bit_for_index))
        -: 1561:      {
    #####: 1562:        ecma_string_t *name_p = ecma_op_get_global_symbol (curr_property_p->magic_string_id);
    #####: 1563:        ecma_collection_push_back (prop_names_p, ecma_make_symbol_value (name_p));
    #####: 1564:        prop_counter_p->symbol_named_props++;
        -: 1565:      }
        -: 1566:
    #####: 1567:      curr_property_p++;
    #####: 1568:      index++;
        -: 1569:    }
        -: 1570:  }
        -: 1571:#endif /* JERRY_ESNEXT */
        4: 1572:} /* ecma_builtin_list_lazy_property_names */
        -: 1573:
        -: 1574:/**
        -: 1575: * Dispatcher of built-in routines
        -: 1576: *
        -: 1577: * @return ecma value
        -: 1578: *         Returned value must be freed with ecma_free_value.
        -: 1579: */
        -: 1580:static ecma_value_t
       12: 1581:ecma_builtin_dispatch_routine (ecma_extended_object_t *func_obj_p, /**< builtin object */
        -: 1582:                               ecma_value_t this_arg_value, /**< 'this' argument value */
        -: 1583:                               const ecma_value_t *arguments_list_p, /**< list of arguments passed to routine */
        -: 1584:                               uint32_t arguments_list_len) /**< length of arguments' list */
        -: 1585:{
       12: 1586:  JERRY_ASSERT (ecma_builtin_function_is_routine ((ecma_object_t *) func_obj_p));
        -: 1587:
       12: 1588:  ecma_value_t padded_arguments_list_p[3] = { ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED, ECMA_VALUE_UNDEFINED };
        -: 1589:
       12: 1590:  if (arguments_list_len <= 2)
        -: 1591:  {
       12: 1592:    switch (arguments_list_len)
        -: 1593:    {
    #####: 1594:      case 2:
        -: 1595:      {
    #####: 1596:        padded_arguments_list_p[1] = arguments_list_p[1];
        -: 1597:        /* FALLTHRU */
        -: 1598:      }
        2: 1599:      case 1:
        -: 1600:      {
        2: 1601:        padded_arguments_list_p[0] = arguments_list_p[0];
        2: 1602:        break;
        -: 1603:      }
       10: 1604:      default:
        -: 1605:      {
       10: 1606:        JERRY_ASSERT (arguments_list_len == 0);
        -: 1607:      }
        -: 1608:    }
        -: 1609:
       12: 1610:    arguments_list_p = padded_arguments_list_p;
        -: 1611:  }
        -: 1612:
       12: 1613:  return ecma_builtin_routines[func_obj_p->u.built_in.id] (func_obj_p->u.built_in.routine_id,
        -: 1614:                                                           this_arg_value,
        -: 1615:                                                           arguments_list_p,
        -: 1616:                                                           arguments_list_len);
        -: 1617:} /* ecma_builtin_dispatch_routine */
        -: 1618:
        -: 1619:/**
        -: 1620: * Handle calling [[Call]] of built-in object
        -: 1621: *
        -: 1622: * @return ecma value
        -: 1623: */
        -: 1624:ecma_value_t
       12: 1625:ecma_builtin_dispatch_call (ecma_object_t *obj_p, /**< built-in object */
        -: 1626:                            ecma_value_t this_arg_value, /**< 'this' argument value */
        -: 1627:                            const ecma_value_t *arguments_list_p, /**< arguments list */
        -: 1628:                            uint32_t arguments_list_len) /**< arguments list length */
        -: 1629:{
       12: 1630:  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -: 1631:
       12: 1632:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1633:
       12: 1634:  if (ecma_builtin_function_is_routine (obj_p))
        -: 1635:  {
        -: 1636:#if JERRY_ESNEXT
       12: 1637:    if (JERRY_UNLIKELY (ext_obj_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER))
        -: 1638:    {
    #####: 1639:      ecma_builtin_handler_t handler = ecma_builtin_handler_get (ext_obj_p->u.built_in.routine_id);
    #####: 1640:      return handler (obj_p, arguments_list_p, arguments_list_len);
        -: 1641:    }
        -: 1642:#endif /* !JERRY_ESNEXT */
        -: 1643:
       12: 1644:    return ecma_builtin_dispatch_routine (ext_obj_p,
        -: 1645:                                          this_arg_value,
        -: 1646:                                          arguments_list_p,
        -: 1647:                                          arguments_list_len);
        -: 1648:  }
        -: 1649:
    #####: 1650:  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;
    #####: 1651:  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_call_functions) / sizeof (ecma_builtin_dispatch_call_t));
    #####: 1652:  return ecma_builtin_call_functions[builtin_object_id] (arguments_list_p, arguments_list_len);
        -: 1653:} /* ecma_builtin_dispatch_call */
        -: 1654:
        -: 1655:/**
        -: 1656: * Handle calling [[Construct]] of built-in object
        -: 1657: *
        -: 1658: * @return ecma value
        -: 1659: */
        -: 1660:ecma_value_t
        4: 1661:ecma_builtin_dispatch_construct (ecma_object_t *obj_p, /**< built-in object */
        -: 1662:                                 const ecma_value_t *arguments_list_p, /**< arguments list */
        -: 1663:                                 uint32_t arguments_list_len) /**< arguments list length */
        -: 1664:{
        4: 1665:  JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);
        -: 1666:
        4: 1667:  if (ecma_builtin_function_is_routine (obj_p))
        -: 1668:  {
    #####: 1669:    return ecma_raise_type_error (ECMA_ERR_MSG ("Built-in routines have no constructor"));
        -: 1670:  }
        -: 1671:
        4: 1672:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        4: 1673:  ecma_builtin_id_t builtin_object_id = ext_obj_p->u.built_in.id;
        4: 1674:  JERRY_ASSERT (builtin_object_id < sizeof (ecma_builtin_construct_functions) / sizeof (ecma_builtin_dispatch_call_t));
        -: 1675:
        4: 1676:  return ecma_builtin_construct_functions[builtin_object_id] (arguments_list_p, arguments_list_len);
        -: 1677:} /* ecma_builtin_dispatch_construct */
        -: 1678:
        -: 1679:/**
        -: 1680: * @}
        -: 1681: * @}
        -: 1682: */
