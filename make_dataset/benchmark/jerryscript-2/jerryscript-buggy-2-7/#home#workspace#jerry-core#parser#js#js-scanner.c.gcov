        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jcontext.h"
        -:   17:#include "js-parser-internal.h"
        -:   18:#include "js-scanner-internal.h"
        -:   19:#include "lit-char-helpers.h"
        -:   20:
        -:   21:#if JERRY_PARSER
        -:   22:
        -:   23:/** \addtogroup parser Parser
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup jsparser JavaScript
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser_scanner Scanner
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/**
        -:   34: * Scan return types.
        -:   35: */
        -:   36:typedef enum
        -:   37:{
        -:   38:  SCAN_NEXT_TOKEN, /**< get next token after return */
        -:   39:  SCAN_KEEP_TOKEN, /**< keep the current token after return */
        -:   40:} scan_return_types_t;
        -:   41:
        -:   42:/**
        -:   43: * Checks whether token type is "of".
        -:   44: */
        -:   45:#if JERRY_ESNEXT
        -:   46:#define SCANNER_IDENTIFIER_IS_OF() (lexer_token_is_identifier (context_p, "of", 2))
        -:   47:#else
        -:   48:#define SCANNER_IDENTIFIER_IS_OF() (false)
        -:   49:#endif /* JERRY_ESNEXT */
        -:   50:
        -:   51:#if JERRY_ESNEXT
        -:   52:
        -:   53:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_GENERATOR)
        -:   54:                     == SCAN_STACK_COMPUTED_GENERATOR,
        -:   55:                     scanner_invalid_conversion_from_literal_pool_generator_to_computed_generator);
        -:   56:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_ASYNC)
        -:   57:                     == SCAN_STACK_COMPUTED_ASYNC,
        -:   58:                     scanner_invalid_conversion_from_literal_pool_async_to_computed_async);
        -:   59:
        -:   60:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_GENERATOR)
        -:   61:                     == SCANNER_LITERAL_POOL_GENERATOR,
        -:   62:                     scanner_invalid_conversion_from_computed_generator_to_literal_pool_generator);
        -:   63:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_ASYNC)
        -:   64:                     == SCANNER_LITERAL_POOL_ASYNC,
        -:   65:                     scanner_invalid_conversion_from_computed_async_to_literal_pool_async);
        -:   66:
        -:   67:#endif /* JERRY_ESNEXT */
        -:   68:
        -:   69:/**
        -:   70: * Scan primary expression.
        -:   71: *
        -:   72: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:   73: */
        -:   74:static scan_return_types_t
       19:   75:scanner_scan_primary_expression (parser_context_t *context_p, /**< context */
        -:   76:                                 scanner_context_t *scanner_context_p, /* scanner context */
        -:   77:                                 lexer_token_type_t type, /**< current token type */
        -:   78:                                 scan_stack_modes_t stack_top) /**< current stack top */
        -:   79:{
       19:   80:  switch (type)
        -:   81:  {
        2:   82:    case LEXER_KEYW_NEW:
        -:   83:    {
        2:   84:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;
        -:   85:
        -:   86:#if JERRY_ESNEXT
        2:   87:      if (scanner_try_scan_new_target (context_p))
        -:   88:      {
    #####:   89:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:   90:      }
        -:   91:#endif /* JERRY_ESNEXT */
        2:   92:      break;
        -:   93:    }
    #####:   94:    case LEXER_DIVIDE:
        -:   95:    case LEXER_ASSIGN_DIVIDE:
        -:   96:    {
    #####:   97:      lexer_construct_regexp_object (context_p, true);
    #####:   98:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:   99:      break;
        -:  100:    }
        2:  101:    case LEXER_KEYW_FUNCTION:
        -:  102:    {
        2:  103:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  104:#if JERRY_MODULE_SYSTEM
        2:  105:      bool is_export_default = stack_top == SCAN_STACK_EXPORT_DEFAULT;
        -:  106:#endif /* JERRY_MODULE_SYSTEM */
        -:  107:
        -:  108:#if JERRY_ESNEXT
        2:  109:      if (scanner_context_p->async_source_p != NULL)
        -:  110:      {
    #####:  111:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -:  112:      }
        -:  113:
        2:  114:      if (lexer_consume_generator (context_p))
        -:  115:      {
    #####:  116:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -:  117:      }
        -:  118:#endif /* JERRY_ESNEXT */
        -:  119:
        2:  120:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -:  121:
        2:  122:      lexer_next_token (context_p);
        -:  123:
        2:  124:      if (context_p->token.type == LEXER_LITERAL
    #####:  125:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  126:      {
        -:  127:#if JERRY_MODULE_SYSTEM
    #####:  128:        if (is_export_default)
        -:  129:        {
        -:  130:          lexer_lit_location_t *location_p;
    #####:  131:          location_p = scanner_add_custom_literal (context_p,
    #####:  132:                                                   scanner_context_p->active_literal_pool_p->prev_p,
    #####:  133:                                                   &context_p->token.lit_location);
        -:  134:
    #####:  135:          scanner_detect_invalid_let (context_p, location_p);
    #####:  136:          location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -:  137:        }
        -:  138:#endif /* JERRY_MODULE_SYSTEM */
    #####:  139:        lexer_next_token (context_p);
        -:  140:      }
        -:  141:#if JERRY_MODULE_SYSTEM
        2:  142:      else if (is_export_default)
        -:  143:      {
        -:  144:        lexer_lit_location_t *location_p;
    #####:  145:        location_p = scanner_add_custom_literal (context_p,
    #####:  146:                                                 scanner_context_p->active_literal_pool_p->prev_p,
        -:  147:                                                 &lexer_default_literal);
    #####:  148:        location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -:  149:      }
        -:  150:#endif /* JERRY_MODULE_SYSTEM */
        -:  151:
        2:  152:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);
        2:  153:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        2:  154:      return SCAN_KEEP_TOKEN;
        -:  155:    }
    #####:  156:    case LEXER_LEFT_PAREN:
        -:  157:    {
    #####:  158:      scanner_scan_bracket (context_p, scanner_context_p);
    #####:  159:      return SCAN_KEEP_TOKEN;
        -:  160:    }
    #####:  161:    case LEXER_LEFT_SQUARE:
        -:  162:    {
        -:  163:#if JERRY_ESNEXT
    #####:  164:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
        -:  165:#endif /* JERRY_ESNEXT */
        -:  166:
    #####:  167:      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####:  168:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  169:      break;
        -:  170:    }
        1:  171:    case LEXER_LEFT_BRACE:
        -:  172:    {
        -:  173:#if JERRY_ESNEXT
        1:  174:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
        1:  175:      parser_stack_push_uint8 (context_p, 0);
        -:  176:#endif /* JERRY_ESNEXT */
        -:  177:
        1:  178:      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
        1:  179:      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
        1:  180:      return SCAN_KEEP_TOKEN;
        -:  181:    }
        -:  182:#if JERRY_ESNEXT
    #####:  183:    case LEXER_TEMPLATE_LITERAL:
        -:  184:    {
    #####:  185:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -:  186:      {
    #####:  187:        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);
    #####:  188:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  189:        break;
        -:  190:      }
        -:  191:
        -:  192:      /* The string is a normal string literal. */
        -:  193:      /* FALLTHRU */
        -:  194:    }
        -:  195:#endif /* JERRY_ESNEXT */
    #####:  196:    case LEXER_LITERAL:
        -:  197:    {
        -:  198:#if JERRY_ESNEXT
       11:  199:      const uint8_t *source_p = context_p->source_p;
        -:  200:
       11:  201:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
        8:  202:          && lexer_check_arrow (context_p))
        -:  203:      {
    #####:  204:        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
    #####:  205:        return SCAN_KEEP_TOKEN;
        -:  206:      }
        -:  207:
       11:  208:      if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  209:      {
    #####:  210:        scanner_context_p->async_source_p = source_p;
    #####:  211:        scanner_check_async_function (context_p, scanner_context_p);
    #####:  212:        return SCAN_KEEP_TOKEN;
        -:  213:      }
        -:  214:#endif /* JERRY_ESNEXT */
        -:  215:
       11:  216:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  217:      {
        -:  218:#if JERRY_MODULE_SYSTEM
        8:  219:        if (stack_top == SCAN_STACK_EXPORT_DEFAULT)
        -:  220:        {
    #####:  221:          lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
    #####:  222:          location_p->type |= (SCANNER_LITERAL_IS_USED | SCANNER_LITERAL_IS_VAR);
    #####:  223:          scanner_detect_eval_call (context_p, scanner_context_p);
    #####:  224:          scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  225:          break;
        -:  226:        }
        -:  227:#endif /* JERRY_MODULE_SYSTEM */
        -:  228:
        8:  229:        scanner_add_reference (context_p, scanner_context_p);
        -:  230:      }
        -:  231:      /* FALLTHRU */
        -:  232:    }
        -:  233:    case LEXER_KEYW_THIS:
        -:  234:    case LEXER_LIT_TRUE:
        -:  235:    case LEXER_LIT_FALSE:
        -:  236:    case LEXER_LIT_NULL:
        -:  237:    {
       14:  238:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
       14:  239:      break;
        -:  240:    }
        -:  241:#if JERRY_ESNEXT
    #####:  242:    case LEXER_KEYW_SUPER:
        -:  243:    {
    #####:  244:      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;
    #####:  245:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  246:      break;
        -:  247:    }
    #####:  248:    case LEXER_KEYW_CLASS:
        -:  249:    {
    #####:  250:      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);
        -:  251:
    #####:  252:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  253:      {
    #####:  254:        return SCAN_KEEP_TOKEN;
        -:  255:      }
    #####:  256:      break;
        -:  257:    }
        -:  258:#endif /* JERRY_ESNEXT */
    #####:  259:    case LEXER_RIGHT_SQUARE:
        -:  260:    {
    #####:  261:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  262:      {
    #####:  263:        scanner_raise_error (context_p);
        -:  264:      }
        -:  265:
    #####:  266:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  267:      return SCAN_KEEP_TOKEN;
        -:  268:    }
        -:  269:#if JERRY_ESNEXT
    #####:  270:    case LEXER_THREE_DOTS:
        -:  271:    {
        -:  272:      /* Elision or spread arguments */
    #####:  273:      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  274:      {
    #####:  275:        scanner_raise_error (context_p);
        -:  276:      }
    #####:  277:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  278:      break;
        -:  279:    }
        -:  280:#endif /* JERRY_ESNEXT */
    #####:  281:    case LEXER_COMMA:
        -:  282:    {
    #####:  283:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  284:      {
    #####:  285:        scanner_raise_error (context_p);
        -:  286:      }
    #####:  287:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  288:
        -:  289:#if JERRY_ESNEXT
    #####:  290:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  291:      {
    #####:  292:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  293:      }
        -:  294:#endif /* JERRY_ESNEXT */
    #####:  295:      break;
        -:  296:    }
        -:  297:#if JERRY_ESNEXT
    #####:  298:    case LEXER_KEYW_YIELD:
        -:  299:    {
    #####:  300:      lexer_next_token (context_p);
        -:  301:
    #####:  302:      if (lexer_check_yield_no_arg (context_p))
        -:  303:      {
    #####:  304:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  305:      }
        -:  306:
    #####:  307:      if (context_p->token.type == LEXER_MULTIPLY)
        -:  308:      {
    #####:  309:        return SCAN_NEXT_TOKEN;
        -:  310:      }
    #####:  311:      return SCAN_KEEP_TOKEN;
        -:  312:    }
        -:  313:#endif /* JERRY_ESNEXT */
        -:  314:#if JERRY_MODULE_SYSTEM
    #####:  315:    case LEXER_KEYW_IMPORT:
        -:  316:    {
    #####:  317:      lexer_next_token (context_p);
        -:  318:
    #####:  319:      if (context_p->token.type == LEXER_DOT)
        -:  320:      {
    #####:  321:        scanner_check_import_meta (context_p);
        -:  322:      }
    #####:  323:      else if (context_p->token.type != LEXER_LEFT_PAREN)
        -:  324:      {
    #####:  325:        scanner_raise_error (context_p);
        -:  326:      }
        -:  327:
    #####:  328:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  329:      return SCAN_KEEP_TOKEN;
        -:  330:    }
        -:  331:#endif /* JERRY_MODULE_SYSTEM */
    #####:  332:    case LEXER_RIGHT_PAREN:
        -:  333:    {
    #####:  334:      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)
        -:  335:      {
    #####:  336:        parser_stack_pop_uint8 (context_p);
        -:  337:
        -:  338:#if JERRY_ESNEXT
    #####:  339:        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  340:        {
    #####:  341:          scanner_add_async_literal (context_p, scanner_context_p);
        -:  342:        }
        -:  343:#endif /* JERRY_ESNEXT */
        -:  344:
    #####:  345:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  346:        break;
        -:  347:      }
        -:  348:      /* FALLTHRU */
        -:  349:    }
        -:  350:    default:
        -:  351:    {
    #####:  352:      scanner_raise_error (context_p);
        -:  353:    }
        -:  354:  }
       16:  355:  return SCAN_NEXT_TOKEN;
        -:  356:} /* scanner_scan_primary_expression */
        -:  357:
        -:  358:/**
        -:  359: * Scan the tokens after the primary expression.
        -:  360: *
        -:  361: * @return true for break, false for fall through
        -:  362: */
        -:  363:static bool
       32:  364:scanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */
        -:  365:                                      scanner_context_t *scanner_context_p, /**< scanner context */
        -:  366:                                      lexer_token_type_t type, /**< current token type */
        -:  367:                                      scan_stack_modes_t stack_top) /**< current stack top */
        -:  368:{
       32:  369:  switch (type)
        -:  370:  {
        1:  371:    case LEXER_DOT:
        -:  372:    {
        1:  373:      lexer_scan_identifier (context_p);
        -:  374:
        1:  375:      if (context_p->token.type != LEXER_LITERAL
        1:  376:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  377:      {
    #####:  378:        scanner_raise_error (context_p);
        -:  379:      }
        -:  380:
        1:  381:      return true;
        -:  382:    }
        5:  383:    case LEXER_LEFT_PAREN:
        -:  384:    {
        5:  385:      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
        5:  386:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        5:  387:      return true;
        -:  388:    }
        -:  389:#if JERRY_ESNEXT
    #####:  390:    case LEXER_TEMPLATE_LITERAL:
        -:  391:    {
    #####:  392:      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))
        -:  393:      {
    #####:  394:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  395:        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);
        -:  396:      }
    #####:  397:      return true;
        -:  398:    }
        -:  399:#endif /* JERRY_ESNEXT */
        1:  400:    case LEXER_LEFT_SQUARE:
        -:  401:    {
        1:  402:      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);
        1:  403:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  404:      return true;
        -:  405:    }
    #####:  406:    case LEXER_INCREASE:
        -:  407:    case LEXER_DECREASE:
        -:  408:    {
    #####:  409:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  410:
    #####:  411:      if (context_p->token.flags & LEXER_WAS_NEWLINE)
        -:  412:      {
    #####:  413:        return false;
        -:  414:      }
        -:  415:
    #####:  416:      lexer_next_token (context_p);
    #####:  417:      type = (lexer_token_type_t) context_p->token.type;
        -:  418:
    #####:  419:      if (type != LEXER_QUESTION_MARK)
        -:  420:      {
    #####:  421:        break;
        -:  422:      }
        -:  423:      /* FALLTHRU */
        -:  424:    }
        -:  425:    case LEXER_QUESTION_MARK:
        -:  426:    {
    #####:  427:      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);
    #####:  428:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  429:      return true;
        -:  430:    }
       25:  431:    default:
        -:  432:    {
       25:  433:      break;
        -:  434:    }
        -:  435:  }
        -:  436:
       25:  437:  if (LEXER_IS_BINARY_OP_TOKEN (type)
        3:  438:      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))
        -:  439:  {
        3:  440:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        3:  441:    return true;
        -:  442:  }
        -:  443:
       22:  444:  return false;
        -:  445:} /* scanner_scan_post_primary_expression */
        -:  446:
        -:  447:/**
        -:  448: * Scan the tokens after the primary expression.
        -:  449: *
        -:  450: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:  451: */
        -:  452:static scan_return_types_t
       23:  453:scanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */
        -:  454:                                     scanner_context_t *scanner_context_p, /**< scanner context */
        -:  455:                                     lexer_token_type_t type, /**< current token type */
        -:  456:                                     scan_stack_modes_t stack_top) /**< current stack top */
        -:  457:{
       23:  458:  if (type == LEXER_COMMA)
        -:  459:  {
        2:  460:    switch (stack_top)
        -:  461:    {
    #####:  462:      case SCAN_STACK_VAR:
        -:  463:#if JERRY_ESNEXT
        -:  464:      case SCAN_STACK_LET:
        -:  465:      case SCAN_STACK_CONST:
        -:  466:#endif /* JERRY_ESNEXT */
        -:  467:      case SCAN_STACK_FOR_VAR_START:
        -:  468:#if JERRY_ESNEXT
        -:  469:      case SCAN_STACK_FOR_LET_START:
        -:  470:      case SCAN_STACK_FOR_CONST_START:
        -:  471:#endif /* JERRY_ESNEXT */
        -:  472:      {
    #####:  473:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####:  474:        return SCAN_NEXT_TOKEN;
        -:  475:      }
    #####:  476:      case SCAN_STACK_COLON_EXPRESSION:
        -:  477:      {
    #####:  478:        scanner_raise_error (context_p);
    #####:  479:        break;
        -:  480:      }
        -:  481:#if JERRY_ESNEXT
    #####:  482:      case SCAN_STACK_BINDING_INIT:
        -:  483:      case SCAN_STACK_BINDING_LIST_INIT:
        -:  484:      {
    #####:  485:        break;
        -:  486:      }
    #####:  487:      case SCAN_STACK_ARROW_ARGUMENTS:
        -:  488:      {
    #####:  489:        lexer_next_token (context_p);
    #####:  490:        scanner_check_arrow_arg (context_p, scanner_context_p);
    #####:  491:        return SCAN_KEEP_TOKEN;
        -:  492:      }
    #####:  493:      case SCAN_STACK_ARROW_EXPRESSION:
        -:  494:      {
    #####:  495:        break;
        -:  496:      }
    #####:  497:      case SCAN_STACK_CLASS_FIELD_INITIALIZER:
        -:  498:      {
    #####:  499:        scanner_raise_error (context_p);
    #####:  500:        break;
        -:  501:      }
    #####:  502:      case SCAN_STACK_FUNCTION_PARAMETERS:
        -:  503:      {
    #####:  504:        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
    #####:  505:        parser_stack_pop_uint8 (context_p);
    #####:  506:        return SCAN_NEXT_TOKEN;
        -:  507:      }
    #####:  508:      case SCAN_STACK_ARRAY_LITERAL:
        -:  509:      {
    #####:  510:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  511:
    #####:  512:        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  513:        {
    #####:  514:          scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  515:        }
        -:  516:
    #####:  517:        return SCAN_NEXT_TOKEN;
        -:  518:      }
        -:  519:#endif /* JERRY_ESNEXT */
        1:  520:      case SCAN_STACK_OBJECT_LITERAL:
        -:  521:      {
        1:  522:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
        1:  523:        return SCAN_KEEP_TOKEN;
        -:  524:      }
        1:  525:      default:
        -:  526:      {
        1:  527:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  528:        return SCAN_NEXT_TOKEN;
        -:  529:      }
        -:  530:    }
       21:  531:  }
        -:  532:
       21:  533:  switch (stack_top)
        -:  534:  {
    #####:  535:    case SCAN_STACK_WITH_EXPRESSION:
        -:  536:    {
    #####:  537:      if (type != LEXER_RIGHT_PAREN)
        -:  538:      {
    #####:  539:        break;
        -:  540:      }
        -:  541:
    #####:  542:      parser_stack_pop_uint8 (context_p);
        -:  543:
    #####:  544:      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;
    #####:  545:      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);
    #####:  546:      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);
    #####:  547:      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;
    #####:  548:      scanner_context_p->active_literal_pool_p->status_flags = status_flags;
        -:  549:
    #####:  550:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  551:      return SCAN_NEXT_TOKEN;
        -:  552:    }
    #####:  553:    case SCAN_STACK_DO_EXPRESSION:
        -:  554:    {
    #####:  555:      if (type != LEXER_RIGHT_PAREN)
        -:  556:      {
    #####:  557:        break;
        -:  558:      }
        -:  559:
    #####:  560:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####:  561:      return SCAN_NEXT_TOKEN;
        -:  562:    }
    #####:  563:    case SCAN_STACK_WHILE_EXPRESSION:
        -:  564:    {
    #####:  565:      if (type != LEXER_RIGHT_PAREN)
        -:  566:      {
    #####:  567:        break;
        -:  568:      }
        -:  569:
    #####:  570:      scanner_source_start_t source_start;
        -:  571:
    #####:  572:      parser_stack_pop_uint8 (context_p);
    #####:  573:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  574:
        -:  575:      scanner_location_info_t *location_info_p;
    #####:  576:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  577:                                                                         source_start.source_p,
        -:  578:                                                                         sizeof (scanner_location_info_t));
    #####:  579:      location_info_p->info.type = SCANNER_TYPE_WHILE;
        -:  580:
    #####:  581:      scanner_get_location (&location_info_p->location, context_p);
        -:  582:
    #####:  583:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  584:      return SCAN_NEXT_TOKEN;
        -:  585:    }
        5:  586:    case SCAN_STACK_PAREN_EXPRESSION:
        -:  587:    {
        5:  588:      if (type != LEXER_RIGHT_PAREN)
        -:  589:      {
    #####:  590:        break;
        -:  591:      }
        -:  592:
        5:  593:      parser_stack_pop_uint8 (context_p);
        -:  594:
        -:  595:#if JERRY_ESNEXT
        5:  596:      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  597:      {
    #####:  598:        scanner_add_async_literal (context_p, scanner_context_p);
        -:  599:      }
        -:  600:#endif /* JERRY_ESNEXT */
        -:  601:
        5:  602:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        5:  603:      return SCAN_NEXT_TOKEN;
        -:  604:    }
        1:  605:    case SCAN_STACK_STATEMENT_WITH_EXPR:
        -:  606:    {
        1:  607:      if (type != LEXER_RIGHT_PAREN)
        -:  608:      {
    #####:  609:        break;
        -:  610:      }
        -:  611:
        1:  612:      parser_stack_pop_uint8 (context_p);
        -:  613:
        -:  614:#if JERRY_ESNEXT
        1:  615:      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)
        -:  616:      {
    #####:  617:        scanner_check_function_after_if (context_p, scanner_context_p);
    #####:  618:        return SCAN_KEEP_TOKEN;
        -:  619:      }
        -:  620:#endif /* JERRY_ESNEXT */
        -:  621:
        1:  622:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
        1:  623:      return SCAN_NEXT_TOKEN;
        -:  624:    }
        -:  625:#if JERRY_ESNEXT
    #####:  626:    case SCAN_STACK_BINDING_LIST_INIT:
        -:  627:    {
    #####:  628:      parser_stack_pop_uint8 (context_p);
        -:  629:
    #####:  630:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  631:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  632:                    || context_p->stack_top_uint8 == SCAN_STACK_LET
        -:  633:                    || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  634:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  635:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  636:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  637:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  638:
    #####:  639:      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -:  640:
    #####:  641:      while (item_p != NULL)
        -:  642:      {
    #####:  643:        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  644:        {
    #####:  645:          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  646:        }
    #####:  647:        item_p = item_p->next_p;
        -:  648:      }
        -:  649:
    #####:  650:      scanner_pop_binding_list (scanner_context_p);
    #####:  651:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  652:      return SCAN_KEEP_TOKEN;
        -:  653:    }
    #####:  654:    case SCAN_STACK_BINDING_INIT:
        -:  655:    {
    #####:  656:      scanner_binding_literal_t binding_literal;
        -:  657:
    #####:  658:      parser_stack_pop_uint8 (context_p);
    #####:  659:      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
        -:  660:
    #####:  661:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  662:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  663:                    || context_p->stack_top_uint8 == SCAN_STACK_LET
        -:  664:                    || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  665:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  666:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  667:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  668:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  669:
    #####:  670:      JERRY_ASSERT (SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type)
        -:  671:                    || (stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL));
        -:  672:
    #####:  673:      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  674:      {
    #####:  675:        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  676:      }
        -:  677:
    #####:  678:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  679:      return SCAN_KEEP_TOKEN;
        -:  680:    }
        -:  681:#endif /* JERRY_ESNEXT */
        3:  682:    case SCAN_STACK_VAR:
        -:  683:#if JERRY_ESNEXT
        -:  684:    case SCAN_STACK_LET:
        -:  685:    case SCAN_STACK_CONST:
        -:  686:#endif /* JERRY_ESNEXT */
        -:  687:    {
        -:  688:#if JERRY_MODULE_SYSTEM
        3:  689:      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -:  690:#endif /* JERRY_MODULE_SYSTEM */
        -:  691:
        3:  692:      parser_stack_pop_uint8 (context_p);
        3:  693:      return SCAN_KEEP_TOKEN;
        -:  694:    }
        1:  695:    case SCAN_STACK_FOR_VAR_START:
        -:  696:#if JERRY_ESNEXT
        -:  697:    case SCAN_STACK_FOR_LET_START:
        -:  698:    case SCAN_STACK_FOR_CONST_START:
        -:  699:#endif /* JERRY_ESNEXT */
        -:  700:    case SCAN_STACK_FOR_START:
        -:  701:    {
        1:  702:      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())
        -:  703:      {
        1:  704:        scanner_for_statement_t for_statement;
        -:  705:
        1:  706:        parser_stack_pop_uint8 (context_p);
        1:  707:        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  708:
        -:  709:        scanner_location_info_t *location_info;
        1:  710:        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  711:                                                                         for_statement.u.source_p,
        -:  712:                                                                         sizeof (scanner_location_info_t));
        -:  713:#if JERRY_ESNEXT
        1:  714:        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;
        -:  715:
        1:  716:        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  717:        {
    #####:  718:          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);
        -:  719:        }
        -:  720:#else /* !JERRY_ESNEXT */
    #####:  721:        location_info->info.type = SCANNER_TYPE_FOR_IN;
        -:  722:#endif /* JERRY_ESNEXT */
        -:  723:
        1:  724:        scanner_get_location (&location_info->location, context_p);
        -:  725:
        1:  726:        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);
        1:  727:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  728:        return SCAN_NEXT_TOKEN;
        -:  729:      }
        -:  730:
    #####:  731:      if (type != LEXER_SEMICOLON)
        -:  732:      {
    #####:  733:        break;
        -:  734:      }
        -:  735:
    #####:  736:      scanner_for_statement_t for_statement;
        -:  737:
    #####:  738:      parser_stack_pop_uint8 (context_p);
    #####:  739:      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));
        -:  740:
        -:  741:#if JERRY_ESNEXT
    #####:  742:      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  743:      {
    #####:  744:        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  745:      }
        -:  746:#endif /* JERRY_ESNEXT */
        -:  747:
    #####:  748:      for_statement.u.source_p = context_p->source_p;
    #####:  749:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
    #####:  750:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);
        -:  751:
    #####:  752:      lexer_next_token (context_p);
        -:  753:
    #####:  754:      if (context_p->token.type != LEXER_SEMICOLON)
        -:  755:      {
    #####:  756:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  757:        return SCAN_KEEP_TOKEN;
        -:  758:      }
        -:  759:
    #####:  760:      type = LEXER_SEMICOLON;
        -:  761:      /* FALLTHRU */
        -:  762:    }
        -:  763:    case SCAN_STACK_FOR_CONDITION:
        -:  764:    {
    #####:  765:      if (type != LEXER_SEMICOLON)
        -:  766:      {
    #####:  767:        break;
        -:  768:      }
        -:  769:
    #####:  770:      scanner_for_statement_t for_statement;
        -:  771:
    #####:  772:      parser_stack_pop_uint8 (context_p);
    #####:  773:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  774:
        -:  775:      scanner_for_info_t *for_info_p;
    #####:  776:      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,
        -:  777:                                                               for_statement.u.source_p,
        -:  778:                                                               sizeof (scanner_for_info_t));
    #####:  779:      for_info_p->info.type = SCANNER_TYPE_FOR;
        -:  780:
    #####:  781:      scanner_get_location (&for_info_p->expression_location, context_p);
    #####:  782:      for_info_p->end_location.source_p = NULL;
        -:  783:
    #####:  784:      for_statement.u.for_info_p = for_info_p;
        -:  785:
    #####:  786:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
    #####:  787:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);
        -:  788:
    #####:  789:      lexer_next_token (context_p);
        -:  790:
    #####:  791:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  792:      {
    #####:  793:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  794:        return SCAN_KEEP_TOKEN;
        -:  795:      }
        -:  796:
    #####:  797:      type = LEXER_RIGHT_PAREN;
        -:  798:      /* FALLTHRU */
        -:  799:    }
        -:  800:    case SCAN_STACK_FOR_EXPRESSION:
        -:  801:    {
    #####:  802:      if (type != LEXER_RIGHT_PAREN)
        -:  803:      {
    #####:  804:        break;
        -:  805:      }
        -:  806:
    #####:  807:      scanner_for_statement_t for_statement;
        -:  808:
    #####:  809:      parser_stack_pop_uint8 (context_p);
    #####:  810:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  811:
    #####:  812:      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);
        -:  813:
    #####:  814:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  815:      return SCAN_NEXT_TOKEN;
        -:  816:    }
    #####:  817:    case SCAN_STACK_SWITCH_EXPRESSION:
        -:  818:    {
    #####:  819:      if (type != LEXER_RIGHT_PAREN)
        -:  820:      {
    #####:  821:        break;
        -:  822:      }
        -:  823:
    #####:  824:      lexer_next_token (context_p);
        -:  825:
    #####:  826:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  827:      {
    #####:  828:        break;
        -:  829:      }
        -:  830:
        -:  831:#if JERRY_ESNEXT
        -:  832:      scanner_literal_pool_t *literal_pool_p;
    #####:  833:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####:  834:      literal_pool_p->source_p = context_p->source_p - 1;
        -:  835:#endif /* JERRY_ESNEXT */
        -:  836:
    #####:  837:      parser_stack_pop_uint8 (context_p);
        -:  838:
    #####:  839:      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;
    #####:  840:      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
    #####:  841:      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);
        -:  842:
        -:  843:      scanner_switch_info_t *switch_info_p;
    #####:  844:      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,
        -:  845:                                                                     context_p->source_p,
        -:  846:                                                                     sizeof (scanner_switch_info_t));
    #####:  847:      switch_info_p->info.type = SCANNER_TYPE_SWITCH;
    #####:  848:      switch_info_p->case_p = NULL;
    #####:  849:      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;
        -:  850:
    #####:  851:      lexer_next_token (context_p);
        -:  852:
    #####:  853:      if (context_p->token.type != LEXER_RIGHT_BRACE
    #####:  854:          && context_p->token.type != LEXER_KEYW_CASE
    #####:  855:          && context_p->token.type != LEXER_KEYW_DEFAULT)
        -:  856:      {
    #####:  857:        break;
        -:  858:      }
        -:  859:
    #####:  860:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  861:      return SCAN_KEEP_TOKEN;
        -:  862:    }
    #####:  863:    case SCAN_STACK_CASE_STATEMENT:
        -:  864:    {
    #####:  865:      if (type != LEXER_COLON)
        -:  866:      {
    #####:  867:        break;
        -:  868:      }
        -:  869:
    #####:  870:      scanner_source_start_t source_start;
        -:  871:
    #####:  872:      parser_stack_pop_uint8 (context_p);
    #####:  873:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  874:
        -:  875:      scanner_location_info_t *location_info_p;
    #####:  876:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  877:                                                                         source_start.source_p,
        -:  878:                                                                         sizeof (scanner_location_info_t));
    #####:  879:      location_info_p->info.type = SCANNER_TYPE_CASE;
        -:  880:
    #####:  881:      scanner_get_location (&location_info_p->location, context_p);
        -:  882:
    #####:  883:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  884:      return SCAN_NEXT_TOKEN;
        -:  885:    }
    #####:  886:    case SCAN_STACK_COLON_EXPRESSION:
        -:  887:    {
    #####:  888:      if (type != LEXER_COLON)
        -:  889:      {
    #####:  890:        break;
        -:  891:      }
        -:  892:
    #####:  893:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  894:      parser_stack_pop_uint8 (context_p);
    #####:  895:      return SCAN_NEXT_TOKEN;
        -:  896:    }
        -:  897:#if JERRY_ESNEXT
        1:  898:    case SCAN_STACK_ARRAY_LITERAL:
        -:  899:    case SCAN_STACK_OBJECT_LITERAL:
        -:  900:    {
        1:  901:      if ((stack_top == SCAN_STACK_ARRAY_LITERAL && type != LEXER_RIGHT_SQUARE)
        1:  902:          || (stack_top == SCAN_STACK_OBJECT_LITERAL && type != LEXER_RIGHT_BRACE))
        -:  903:      {
        -:  904:        break;
        -:  905:      }
        -:  906:
        1:  907:      scanner_source_start_t source_start;
        1:  908:      uint8_t binding_type = scanner_context_p->binding_type;
        1:  909:      uint8_t object_literal_flags = 0;
        -:  910:
        1:  911:      parser_stack_pop_uint8 (context_p);
        -:  912:
        1:  913:      if (stack_top == SCAN_STACK_OBJECT_LITERAL)
        -:  914:      {
        1:  915:        object_literal_flags = context_p->stack_top_uint8;
        1:  916:        parser_stack_pop_uint8 (context_p);
        -:  917:      }
        -:  918:
        1:  919:      scanner_context_p->binding_type = context_p->stack_top_uint8;
        1:  920:      parser_stack_pop_uint8 (context_p);
        1:  921:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  922:
        1:  923:      lexer_next_token (context_p);
        -:  924:
        1:  925:      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -:  926:
        1:  927:      if (binding_type == SCANNER_BINDING_CATCH && stack_top == SCAN_STACK_CATCH_STATEMENT)
        -:  928:      {
    #####:  929:        scanner_pop_binding_list (scanner_context_p);
        -:  930:
        -:  931:#if JERRY_ESNEXT
    #####:  932:        if (object_literal_flags != 0)
        -:  933:        {
    #####:  934:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####:  935:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####:  936:          info_p->u8_arg = object_literal_flags;
        -:  937:        }
        -:  938:#endif /* JERRY_ESNEXT */
        -:  939:
    #####:  940:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  941:        {
    #####:  942:          scanner_raise_error (context_p);
        -:  943:        }
        -:  944:
    #####:  945:        lexer_next_token (context_p);
        -:  946:
    #####:  947:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  948:        {
    #####:  949:          scanner_raise_error (context_p);
        -:  950:        }
        -:  951:
    #####:  952:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  953:        return SCAN_NEXT_TOKEN;
        -:  954:      }
        -:  955:
        1:  956:      if (stack_top == SCAN_STACK_FOR_START_PATTERN)
        -:  957:      {
    #####:  958:        JERRY_ASSERT (binding_type == SCANNER_BINDING_NONE);
        -:  959:
    #####:  960:        parser_stack_change_last_uint8 (context_p, SCAN_STACK_FOR_START);
        -:  961:
    #####:  962:        if (context_p->token.type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())
        -:  963:        {
    #####:  964:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####:  965:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####:  966:          info_p->u8_arg = object_literal_flags | SCANNER_LITERAL_DESTRUCTURING_FOR;
    #####:  967:          return SCAN_KEEP_TOKEN;
        -:  968:        }
        -:  969:      }
        -:  970:
        1:  971:      if (context_p->token.type != LEXER_ASSIGN)
        -:  972:      {
        1:  973:        if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -:  974:        {
    #####:  975:          scanner_pop_binding_list (scanner_context_p);
        -:  976:        }
        -:  977:
        -:  978:#if JERRY_ESNEXT
        1:  979:        if ((stack_top == SCAN_STACK_ARRAY_LITERAL || stack_top == SCAN_STACK_OBJECT_LITERAL)
    #####:  980:            && (binding_type == SCANNER_BINDING_NONE || binding_type == SCANNER_BINDING_ARROW_ARG)
    #####:  981:            && context_p->token.type != LEXER_EOS
    #####:  982:            && context_p->token.type != LEXER_COMMA
    #####:  983:            && context_p->token.type != LEXER_RIGHT_BRACE
    #####:  984:            && context_p->token.type != LEXER_RIGHT_SQUARE)
        -:  985:        {
    #####:  986:          object_literal_flags |= SCANNER_LITERAL_NO_DESTRUCTURING;
        -:  987:        }
        -:  988:
        1:  989:        if (object_literal_flags != 0)
        -:  990:        {
    #####:  991:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####:  992:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####:  993:          info_p->u8_arg = object_literal_flags;
        -:  994:        }
        -:  995:#endif /* JERRY_ESNEXT */
        -:  996:
        1:  997:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        1:  998:        return SCAN_KEEP_TOKEN;
        -:  999:      }
        -: 1000:
        -: 1001:      scanner_location_info_t *location_info_p;
    #####: 1002:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -: 1003:                                                                         source_start.source_p,
        -: 1004:                                                                         sizeof (scanner_location_info_t));
    #####: 1005:      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;
    #####: 1006:      location_info_p->info.u8_arg = object_literal_flags;
    #####: 1007:      scanner_get_location (&location_info_p->location, context_p);
    #####: 1008:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1009:
    #####: 1010:      if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1011:      {
    #####: 1012:        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -: 1013:
    #####: 1014:        while (item_p != NULL)
        -: 1015:        {
    #####: 1016:          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;
    #####: 1017:          item_p = item_p->next_p;
        -: 1018:        }
        -: 1019:
    #####: 1020:        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);
        -: 1021:      }
    #####: 1022:      return SCAN_NEXT_TOKEN;
        -: 1023:    }
        -: 1024:#else /* !JERRY_ESNEXT */
    #####: 1025:    case SCAN_STACK_OBJECT_LITERAL:
        -: 1026:    {
    #####: 1027:      if (type != LEXER_RIGHT_BRACE)
        -: 1028:      {
        -: 1029:        break;
        -: 1030:      }
        -: 1031:
    #####: 1032:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1033:      parser_stack_pop_uint8 (context_p);
    #####: 1034:      return SCAN_NEXT_TOKEN;
        -: 1035:    }
    #####: 1036:    case SCAN_STACK_ARRAY_LITERAL:
        -: 1037:#endif /* JERRY_ESNEXT */
        1: 1038:    case SCAN_STACK_PROPERTY_ACCESSOR:
        -: 1039:    {
        1: 1040:      if (type != LEXER_RIGHT_SQUARE)
        -: 1041:      {
    #####: 1042:        break;
        -: 1043:      }
        -: 1044:
        1: 1045:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        1: 1046:      parser_stack_pop_uint8 (context_p);
        1: 1047:      return SCAN_NEXT_TOKEN;
        -: 1048:    }
        -: 1049:#if JERRY_ESNEXT
    #####: 1050:    case SCAN_STACK_COMPUTED_PROPERTY:
        -: 1051:    {
    #####: 1052:      if (type != LEXER_RIGHT_SQUARE)
        -: 1053:      {
    #####: 1054:        break;
        -: 1055:      }
        -: 1056:
    #####: 1057:      lexer_scan_identifier (context_p);
        -: 1058:
    #####: 1059:      parser_stack_pop_uint8 (context_p);
    #####: 1060:      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -: 1061:
    #####: 1062:      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)
        -: 1063:      {
    #####: 1064:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 1065:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1066:        return SCAN_KEEP_TOKEN;
        -: 1067:      }
        -: 1068:
    #####: 1069:      if (stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR
    #####: 1070:          || stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 1071:      {
    #####: 1072:        JERRY_ASSERT (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);
        -: 1073:
    #####: 1074:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1075:        {
    #####: 1076:          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -: 1077:
    #####: 1078:          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 1079:          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1080:          return SCAN_KEEP_TOKEN;
        -: 1081:        }
        -: 1082:
    #####: 1083:        if (context_p->token.type == LEXER_ASSIGN)
        -: 1084:        {
    #####: 1085:          scanner_push_class_field_initializer (context_p, scanner_context_p);
    #####: 1086:          return SCAN_NEXT_TOKEN;
        -: 1087:        }
        -: 1088:
    #####: 1089:        scanner_context_p->mode = (context_p->token.type != LEXER_SEMICOLON ? SCAN_MODE_CLASS_BODY_NO_SCAN
        -: 1090:                                                                            : SCAN_MODE_CLASS_BODY);
    #####: 1091:        return SCAN_KEEP_TOKEN;
        -: 1092:      }
        -: 1093:
    #####: 1094:      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -: 1095:
    #####: 1096:      if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1097:      {
    #####: 1098:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -: 1099:
    #####: 1100:        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 1101:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1102:        return SCAN_KEEP_TOKEN;
        -: 1103:      }
        -: 1104:
    #####: 1105:      if (context_p->token.type != LEXER_COLON)
        -: 1106:      {
    #####: 1107:        scanner_raise_error (context_p);
        -: 1108:      }
        -: 1109:
    #####: 1110:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1111:
    #####: 1112:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -: 1113:      {
    #####: 1114:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -: 1115:      }
    #####: 1116:      return SCAN_NEXT_TOKEN;
        -: 1117:    }
    #####: 1118:    case SCAN_STACK_COMPUTED_GENERATOR:
        -: 1119:    case SCAN_STACK_COMPUTED_ASYNC:
        -: 1120:    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:
        -: 1121:    {
    #####: 1122:      if (type != LEXER_RIGHT_SQUARE)
        -: 1123:      {
    #####: 1124:        break;
        -: 1125:      }
        -: 1126:
    #####: 1127:      lexer_next_token (context_p);
    #####: 1128:      parser_stack_pop_uint8 (context_p);
        -: 1129:
    #####: 1130:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -: 1131:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);
        -: 1132:
    #####: 1133:      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION
        -: 1134:                                          | SCANNER_LITERAL_POOL_GENERATOR
    #####: 1135:                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));
        -: 1136:
    #####: 1137:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -: 1138:
    #####: 1139:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1140:      return SCAN_KEEP_TOKEN;
        -: 1141:    }
    #####: 1142:    case SCAN_STACK_TEMPLATE_STRING:
        -: 1143:    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:
        -: 1144:    {
    #####: 1145:      if (type != LEXER_RIGHT_BRACE)
        -: 1146:      {
    #####: 1147:        break;
        -: 1148:      }
        -: 1149:
    #####: 1150:      context_p->source_p--;
    #####: 1151:      context_p->column--;
    #####: 1152:      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1153:
    #####: 1154:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1155:      {
    #####: 1156:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1157:      }
        -: 1158:      else
        -: 1159:      {
    #####: 1160:        parser_stack_pop_uint8 (context_p);
    #####: 1161:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 1162:      }
    #####: 1163:      return SCAN_NEXT_TOKEN;
        -: 1164:    }
    #####: 1165:    case SCAN_STACK_ARROW_ARGUMENTS:
        -: 1166:    {
    #####: 1167:      if (type != LEXER_RIGHT_PAREN)
        -: 1168:      {
    #####: 1169:        break;
        -: 1170:      }
        -: 1171:
    #####: 1172:      scanner_check_arrow (context_p, scanner_context_p);
    #####: 1173:      return SCAN_KEEP_TOKEN;
        -: 1174:    }
    #####: 1175:    case SCAN_STACK_ARROW_EXPRESSION:
        -: 1176:    {
    #####: 1177:      scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1178:      parser_stack_pop_uint8 (context_p);
    #####: 1179:      lexer_update_await_yield (context_p, context_p->status_flags);
    #####: 1180:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 1181:      return SCAN_KEEP_TOKEN;
        -: 1182:    }
    #####: 1183:    case SCAN_STACK_CLASS_EXTENDS:
        -: 1184:    {
    #####: 1185:      if (type != LEXER_LEFT_BRACE)
        -: 1186:      {
    #####: 1187:        break;
        -: 1188:      }
        -: 1189:
    #####: 1190:      scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
    #####: 1191:      parser_stack_pop_uint8 (context_p);
        -: 1192:
    #####: 1193:      return SCAN_KEEP_TOKEN;
        -: 1194:    }
    #####: 1195:    case SCAN_STACK_CLASS_FIELD_INITIALIZER:
        -: 1196:    {
    #####: 1197:      scanner_source_start_t source_start;
    #####: 1198:      const uint8_t *source_p = NULL;
        -: 1199:
    #####: 1200:      parser_stack_pop_uint8 (context_p);
    #####: 1201:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1202:      scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1203:      scanner_context_p->mode = SCAN_MODE_CLASS_BODY_NO_SCAN;
        -: 1204:
    #####: 1205:      switch (type)
        -: 1206:      {
    #####: 1207:        case LEXER_SEMICOLON:
        -: 1208:        {
    #####: 1209:          source_p = context_p->source_p - 1;
    #####: 1210:          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
    #####: 1211:          break;
        -: 1212:        }
    #####: 1213:        case LEXER_RIGHT_BRACE:
        -: 1214:        {
    #####: 1215:          source_p = context_p->source_p - 1;
    #####: 1216:          break;
        -: 1217:        }
    #####: 1218:        default:
        -: 1219:        {
    #####: 1220:          if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 1221:          {
    #####: 1222:            break;
        -: 1223:          }
        -: 1224:
    #####: 1225:          if (type == LEXER_LEFT_SQUARE)
        -: 1226:          {
    #####: 1227:            source_p = context_p->source_p - 1;
    #####: 1228:            break;
        -: 1229:          }
        -: 1230:
    #####: 1231:          if (type == LEXER_LITERAL)
        -: 1232:          {
    #####: 1233:            if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1234:                || context_p->token.lit_location.type == LEXER_NUMBER_LITERAL)
        -: 1235:            {
    #####: 1236:              source_p = context_p->token.lit_location.char_p;
        -: 1237:            }
    #####: 1238:            else if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1239:            {
    #####: 1240:              source_p = context_p->token.lit_location.char_p - 1;
        -: 1241:            }
    #####: 1242:            break;
        -: 1243:          }
        -: 1244:
    #####: 1245:          if (type == context_p->token.keyword_type && type != LEXER_EOS)
        -: 1246:          {
        -: 1247:            /* Convert keyword to literal. */
    #####: 1248:            source_p = context_p->token.lit_location.char_p;
    #####: 1249:            context_p->token.type = LEXER_LITERAL;
        -: 1250:          }
    #####: 1251:          break;
        -: 1252:        }
        -: 1253:      }
        -: 1254:
    #####: 1255:      if (JERRY_UNLIKELY (source_p == NULL))
        -: 1256:      {
    #####: 1257:        scanner_raise_error (context_p);
        -: 1258:      }
        -: 1259:
        -: 1260:      scanner_location_info_t *location_info_p;
    #####: 1261:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -: 1262:                                                                         source_start.source_p,
        -: 1263:                                                                         sizeof (scanner_location_info_t));
    #####: 1264:      location_info_p->info.type = SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END;
    #####: 1265:      location_info_p->location.source_p = source_p;
    #####: 1266:      location_info_p->location.line = context_p->token.line;
    #####: 1267:      location_info_p->location.column = context_p->token.column;
    #####: 1268:      return SCAN_KEEP_TOKEN;
        -: 1269:    }
    #####: 1270:    case SCAN_STACK_FUNCTION_PARAMETERS:
        -: 1271:    {
    #####: 1272:      parser_stack_pop_uint8 (context_p);
        -: 1273:
    #####: 1274:      if (type != LEXER_RIGHT_PAREN
    #####: 1275:          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))
        -: 1276:      {
        -: 1277:        break;
        -: 1278:      }
        -: 1279:
    #####: 1280:      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
    #####: 1281:      return SCAN_KEEP_TOKEN;
        -: 1282:    }
        -: 1283:#endif /* JERRY_ESNEXT */
        9: 1284:    default:
        -: 1285:    {
        9: 1286:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        9: 1287:      return SCAN_KEEP_TOKEN;
        -: 1288:    }
        -: 1289:  }
        -: 1290:
    #####: 1291:  scanner_raise_error (context_p);
    #####: 1292:  return SCAN_NEXT_TOKEN;
        -: 1293:} /* scanner_scan_primary_expression_end */
        -: 1294:
        -: 1295:/**
        -: 1296: * Scan statements.
        -: 1297: *
        -: 1298: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 1299: */
        -: 1300:static scan_return_types_t
       11: 1301:scanner_scan_statement (parser_context_t *context_p, /**< context */
        -: 1302:                        scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1303:                        lexer_token_type_t type, /**< current token type */
        -: 1304:                        scan_stack_modes_t stack_top) /**< current stack top */
        -: 1305:{
       11: 1306:  switch (type)
        -: 1307:  {
    #####: 1308:    case LEXER_SEMICOLON:
        -: 1309:    {
    #####: 1310:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1311:      return SCAN_KEEP_TOKEN;
        -: 1312:    }
    #####: 1313:    case LEXER_LEFT_BRACE:
        -: 1314:    {
        -: 1315:#if JERRY_ESNEXT
        -: 1316:      scanner_literal_pool_t *literal_pool_p;
    #####: 1317:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####: 1318:      literal_pool_p->source_p = context_p->source_p;
        -: 1319:#endif /* JERRY_ESNEXT */
        -: 1320:
    #####: 1321:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 1322:      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
    #####: 1323:      return SCAN_NEXT_TOKEN;
        -: 1324:    }
    #####: 1325:    case LEXER_KEYW_DO:
        -: 1326:    {
    #####: 1327:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 1328:      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);
    #####: 1329:      return SCAN_NEXT_TOKEN;
        -: 1330:    }
        1: 1331:    case LEXER_KEYW_TRY:
        -: 1332:    {
        1: 1333:      lexer_next_token (context_p);
        -: 1334:
        1: 1335:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1336:      {
    #####: 1337:        scanner_raise_error (context_p);
        -: 1338:      }
        -: 1339:
        -: 1340:#if JERRY_ESNEXT
        -: 1341:      scanner_literal_pool_t *literal_pool_p;
        1: 1342:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 1343:      literal_pool_p->source_p = context_p->source_p;
        -: 1344:#endif /* JERRY_ESNEXT */
        -: 1345:
        1: 1346:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 1347:      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);
        1: 1348:      return SCAN_NEXT_TOKEN;
        -: 1349:    }
    #####: 1350:    case LEXER_KEYW_DEBUGGER:
        -: 1351:    {
    #####: 1352:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1353:      return SCAN_NEXT_TOKEN;
        -: 1354:    }
    #####: 1355:    case LEXER_KEYW_IF:
        -: 1356:    case LEXER_KEYW_WITH:
        -: 1357:    case LEXER_KEYW_SWITCH:
        -: 1358:    {
    #####: 1359:      lexer_next_token (context_p);
    #####: 1360:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1361:      {
    #####: 1362:        scanner_raise_error (context_p);
        -: 1363:      }
        -: 1364:
    #####: 1365:      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;
        -: 1366:
    #####: 1367:      if (type == LEXER_KEYW_IF)
        -: 1368:      {
    #####: 1369:        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);
        -: 1370:      }
    #####: 1371:      else if (type == LEXER_KEYW_WITH)
        -: 1372:      {
    #####: 1373:        mode = SCAN_STACK_WITH_EXPRESSION;
        -: 1374:      }
    #####: 1375:      else if (type == LEXER_KEYW_SWITCH)
        -: 1376:      {
    #####: 1377:        mode = SCAN_STACK_SWITCH_EXPRESSION;
        -: 1378:      }
        -: 1379:
    #####: 1380:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1381:      parser_stack_push_uint8 (context_p, mode);
    #####: 1382:      return SCAN_NEXT_TOKEN;
        -: 1383:    }
    #####: 1384:    case LEXER_KEYW_WHILE:
        -: 1385:    {
    #####: 1386:      lexer_next_token (context_p);
        -: 1387:
    #####: 1388:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1389:      {
    #####: 1390:        scanner_raise_error (context_p);
        -: 1391:      }
        -: 1392:
    #####: 1393:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1394:
    #####: 1395:      scanner_source_start_t source_start;
    #####: 1396:      source_start.source_p = context_p->source_p;
        -: 1397:
    #####: 1398:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1399:      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);
    #####: 1400:      return SCAN_NEXT_TOKEN;
        -: 1401:    }
        1: 1402:    case LEXER_KEYW_FOR:
        -: 1403:    {
        1: 1404:      lexer_next_token (context_p);
        -: 1405:
        -: 1406:#if JERRY_ESNEXT
        1: 1407:      if (context_p->token.type == LEXER_KEYW_AWAIT)
        -: 1408:      {
    #####: 1409:        lexer_next_token (context_p);
        -: 1410:      }
        -: 1411:#endif /* JERRY_ESNEXT */
        -: 1412:
        1: 1413:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1414:      {
    #####: 1415:        scanner_raise_error (context_p);
        -: 1416:      }
        -: 1417:
        1: 1418:      scanner_for_statement_t for_statement;
        1: 1419:      for_statement.u.source_p = context_p->source_p;
        1: 1420:      uint8_t stack_mode = SCAN_STACK_FOR_START;
        1: 1421:      scan_return_types_t return_type = SCAN_KEEP_TOKEN;
        -: 1422:
        1: 1423:      lexer_next_token (context_p);
        1: 1424:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1425:
        -: 1426:#if JERRY_ESNEXT
        1: 1427:      const uint8_t *source_p = context_p->source_p;
        -: 1428:#endif /* JERRY_ESNEXT */
        -: 1429:
        1: 1430:      switch (context_p->token.type)
        -: 1431:      {
    #####: 1432:        case LEXER_SEMICOLON:
        -: 1433:        {
    #####: 1434:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 1435:          break;
        -: 1436:        }
        1: 1437:        case LEXER_KEYW_VAR:
        -: 1438:        {
        1: 1439:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        1: 1440:          stack_mode = SCAN_STACK_FOR_VAR_START;
        1: 1441:          return_type = SCAN_NEXT_TOKEN;
        1: 1442:          break;
        -: 1443:        }
        -: 1444:#if JERRY_ESNEXT
    #####: 1445:        case LEXER_LEFT_BRACE:
        -: 1446:        case LEXER_LEFT_SQUARE:
        -: 1447:        {
    #####: 1448:          stack_mode = SCAN_STACK_FOR_START_PATTERN;
    #####: 1449:          break;
        -: 1450:        }
    #####: 1451:        case LEXER_LITERAL:
        -: 1452:        {
    #####: 1453:          if (!lexer_token_is_let (context_p))
        -: 1454:          {
    #####: 1455:            break;
        -: 1456:          }
        -: 1457:
    #####: 1458:          parser_line_counter_t line = context_p->line;
    #####: 1459:          parser_line_counter_t column = context_p->column;
        -: 1460:
    #####: 1461:          if (lexer_check_arrow (context_p))
        -: 1462:          {
    #####: 1463:            context_p->source_p = source_p;
    #####: 1464:            context_p->line = line;
    #####: 1465:            context_p->column = column;
    #####: 1466:            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;
    #####: 1467:            break;
        -: 1468:          }
        -: 1469:
    #####: 1470:          lexer_next_token (context_p);
        -: 1471:
    #####: 1472:          type = (lexer_token_type_t) context_p->token.type;
        -: 1473:
    #####: 1474:          if (type != LEXER_LEFT_SQUARE
    #####: 1475:              && type != LEXER_LEFT_BRACE
    #####: 1476:              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))
        -: 1477:          {
    #####: 1478:            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 1479:            info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 1480:
    #####: 1481:            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1482:            break;
        -: 1483:          }
        -: 1484:
    #####: 1485:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        -: 1486:          /* FALLTHRU */
        -: 1487:        }
    #####: 1488:        case LEXER_KEYW_LET:
        -: 1489:        case LEXER_KEYW_CONST:
        -: 1490:        {
        -: 1491:          scanner_literal_pool_t *literal_pool_p;
    #####: 1492:          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####: 1493:          literal_pool_p->source_p = source_p;
        -: 1494:
    #####: 1495:          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)
        -: 1496:          {
    #####: 1497:            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1498:            return_type = SCAN_NEXT_TOKEN;
        -: 1499:          }
        -: 1500:
    #####: 1501:          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START
        -: 1502:                                                                    : SCAN_STACK_FOR_LET_START);
    #####: 1503:          break;
        -: 1504:        }
        -: 1505:#endif /* JERRY_ESNEXT */
        -: 1506:      }
        -: 1507:
        1: 1508:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
        1: 1509:      parser_stack_push_uint8 (context_p, stack_mode);
        1: 1510:      return return_type;
        -: 1511:    }
        3: 1512:    case LEXER_KEYW_VAR:
        -: 1513:    {
        3: 1514:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        3: 1515:      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);
        3: 1516:      return SCAN_NEXT_TOKEN;
        -: 1517:    }
        -: 1518:#if JERRY_ESNEXT
    #####: 1519:    case LEXER_KEYW_LET:
        -: 1520:    {
    #####: 1521:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1522:      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
    #####: 1523:      return SCAN_NEXT_TOKEN;
        -: 1524:    }
    #####: 1525:    case LEXER_KEYW_CONST:
        -: 1526:    {
    #####: 1527:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1528:      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);
    #####: 1529:      return SCAN_NEXT_TOKEN;
        -: 1530:    }
        -: 1531:#endif /* JERRY_ESNEXT */
    #####: 1532:    case LEXER_KEYW_THROW:
        -: 1533:    {
    #####: 1534:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1535:      return SCAN_NEXT_TOKEN;
        -: 1536:    }
        1: 1537:    case LEXER_KEYW_RETURN:
        -: 1538:    {
        1: 1539:      lexer_next_token (context_p);
        -: 1540:
        1: 1541:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
        1: 1542:          && context_p->token.type != LEXER_SEMICOLON
        1: 1543:          && context_p->token.type != LEXER_EOS
        1: 1544:          && context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1545:      {
        1: 1546:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1: 1547:        return SCAN_KEEP_TOKEN;
        -: 1548:      }
        -: 1549:
    #####: 1550:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1551:      return SCAN_KEEP_TOKEN;
        -: 1552:    }
    #####: 1553:    case LEXER_KEYW_BREAK:
        -: 1554:    case LEXER_KEYW_CONTINUE:
        -: 1555:    {
    #####: 1556:      lexer_next_token (context_p);
    #####: 1557:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1558:
    #####: 1559:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 1560:          && context_p->token.type == LEXER_LITERAL
    #####: 1561:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1562:      {
    #####: 1563:        return SCAN_NEXT_TOKEN;
        -: 1564:      }
    #####: 1565:      return SCAN_KEEP_TOKEN;
        -: 1566:    }
    #####: 1567:    case LEXER_KEYW_CASE:
        -: 1568:    case LEXER_KEYW_DEFAULT:
        -: 1569:    {
    #####: 1570:      if (stack_top != SCAN_STACK_SWITCH_BLOCK)
        -: 1571:      {
    #####: 1572:        scanner_raise_error (context_p);
        -: 1573:      }
        -: 1574:
        -: 1575:      scanner_case_info_t *case_info_p;
    #####: 1576:      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));
        -: 1577:
    #####: 1578:      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;
    #####: 1579:      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;
        -: 1580:
    #####: 1581:      case_info_p->next_p = NULL;
    #####: 1582:      scanner_get_location (&case_info_p->location, context_p);
        -: 1583:
    #####: 1584:      if (type == LEXER_KEYW_DEFAULT)
        -: 1585:      {
    #####: 1586:        lexer_next_token (context_p);
        -: 1587:
    #####: 1588:        if (context_p->token.type != LEXER_COLON)
        -: 1589:        {
    #####: 1590:          scanner_raise_error (context_p);
        -: 1591:        }
        -: 1592:
    #####: 1593:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 1594:        return SCAN_NEXT_TOKEN;
        -: 1595:      }
        -: 1596:
    #####: 1597:      scanner_source_start_t source_start;
    #####: 1598:      source_start.source_p = context_p->source_p;
        -: 1599:
    #####: 1600:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1601:      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);
        -: 1602:
    #####: 1603:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1604:      return SCAN_NEXT_TOKEN;
        -: 1605:    }
    #####: 1606:    case LEXER_KEYW_FUNCTION:
        -: 1607:    {
        -: 1608:#if JERRY_ESNEXT
    #####: 1609:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;
        -: 1610:
    #####: 1611:      if (scanner_context_p->async_source_p != NULL)
        -: 1612:      {
    #####: 1613:        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
    #####: 1614:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 1615:      }
        -: 1616:#endif /* JERRY_ESNEXT */
        -: 1617:
    #####: 1618:      lexer_next_token (context_p);
        -: 1619:
        -: 1620:#if JERRY_ESNEXT
    #####: 1621:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1622:      {
    #####: 1623:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
    #####: 1624:        lexer_next_token (context_p);
        -: 1625:      }
        -: 1626:#endif /* JERRY_ESNEXT */
        -: 1627:
    #####: 1628:      if (context_p->token.type != LEXER_LITERAL
    #####: 1629:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1630:      {
    #####: 1631:        scanner_raise_error (context_p);
        -: 1632:      }
        -: 1633:
    #####: 1634:      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1635:
        -: 1636:#if JERRY_ESNEXT
    #####: 1637:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);
        -: 1638:
    #####: 1639:      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)
    #####: 1640:          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
    #####: 1641:          && (literal_p->type & mask) != SCANNER_LITERAL_IS_LOCAL_FUNC)
        -: 1642:      {
    #####: 1643:        scanner_raise_redeclaration_error (context_p);
        -: 1644:      }
        -: 1645:
    #####: 1646:      scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1647:
    #####: 1648:      if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1649:          && (literal_p->type & (SCANNER_LITERAL_IS_VAR)))
        -: 1650:      {
    #####: 1651:        scanner_raise_redeclaration_error (context_p);
        -: 1652:      }
        -: 1653:
    #####: 1654:      literal_p->type |= SCANNER_LITERAL_IS_LOCAL_FUNC;
        -: 1655:
    #####: 1656:      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
        -: 1657:#else
    #####: 1658:      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;
        -: 1659:
    #####: 1660:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 1661:#endif /* JERRY_ESNEXT */
        -: 1662:
    #####: 1663:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -: 1664:
    #####: 1665:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1666:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);
    #####: 1667:      return SCAN_NEXT_TOKEN;
        -: 1668:    }
        -: 1669:#if JERRY_ESNEXT
    #####: 1670:    case LEXER_KEYW_CLASS:
        -: 1671:    {
        -: 1672:      lexer_lit_location_t *literal_p;
    #####: 1673:      literal_p = scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);
        -: 1674:
    #####: 1675:      if (literal_p == NULL)
        -: 1676:      {
    #####: 1677:        scanner_raise_error (context_p);
        -: 1678:      }
        -: 1679:
    #####: 1680:      scanner_detect_invalid_let (context_p, literal_p);
    #####: 1681:      literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 1682:
    #####: 1683:      if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1684:      {
    #####: 1685:        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1686:      }
        -: 1687:
        -: 1688:#if JERRY_MODULE_SYSTEM
    #####: 1689:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 1690:      {
    #####: 1691:        literal_p->type |= SCANNER_LITERAL_NO_REG;
    #####: 1692:        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 1693:      }
        -: 1694:#endif /* JERRY_MODULE_SYSTEM */
        -: 1695:
    #####: 1696:      return SCAN_NEXT_TOKEN;
        -: 1697:    }
        -: 1698:#endif /* JERRY_ESNEXT */
        -: 1699:#if JERRY_MODULE_SYSTEM
    #####: 1700:    case LEXER_KEYW_IMPORT:
        -: 1701:    {
    #####: 1702:      lexer_next_token (context_p);
        -: 1703:
    #####: 1704:      if (context_p->token.type == LEXER_DOT)
        -: 1705:      {
    #####: 1706:        scanner_check_import_meta (context_p);
    #####: 1707:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1708:        return SCAN_KEEP_TOKEN;
        -: 1709:      }
        -: 1710:
    #####: 1711:      if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1712:      {
    #####: 1713:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1714:        return SCAN_KEEP_TOKEN;
        -: 1715:      }
        -: 1716:
    #####: 1717:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1718:      {
    #####: 1719:        scanner_raise_error (context_p);
        -: 1720:      }
        -: 1721:
    #####: 1722:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1723:
    #####: 1724:      if (context_p->token.type == LEXER_LITERAL
    #####: 1725:          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1726:      {
    #####: 1727:        return SCAN_NEXT_TOKEN;
        -: 1728:      }
        -: 1729:
    #####: 1730:      bool parse_imports = true;
        -: 1731:
    #####: 1732:      if (context_p->token.type == LEXER_LITERAL
    #####: 1733:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1734:      {
    #####: 1735:        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1736:
    #####: 1737:        scanner_detect_invalid_let (context_p, literal_p);
    #####: 1738:        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1739:
    #####: 1740:        lexer_next_token (context_p);
        -: 1741:
    #####: 1742:        if (context_p->token.type == LEXER_COMMA)
        -: 1743:        {
    #####: 1744:          lexer_next_token (context_p);
        -: 1745:        }
        -: 1746:        else
        -: 1747:        {
    #####: 1748:          parse_imports = false;
        -: 1749:        }
        -: 1750:      }
        -: 1751:
    #####: 1752:      if (parse_imports)
        -: 1753:      {
    #####: 1754:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1755:        {
    #####: 1756:          lexer_next_token (context_p);
    #####: 1757:          if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1758:          {
    #####: 1759:            scanner_raise_error (context_p);
        -: 1760:          }
        -: 1761:
    #####: 1762:          lexer_next_token (context_p);
        -: 1763:
    #####: 1764:          if (context_p->token.type != LEXER_LITERAL
    #####: 1765:              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1766:          {
    #####: 1767:            scanner_raise_error (context_p);
        -: 1768:          }
        -: 1769:
    #####: 1770:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1771:
    #####: 1772:          scanner_detect_invalid_let (context_p, literal_p);
    #####: 1773:          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1774:
    #####: 1775:          lexer_next_token (context_p);
        -: 1776:        }
    #####: 1777:        else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1778:        {
    #####: 1779:          lexer_next_token (context_p);
        -: 1780:
    #####: 1781:          while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1782:          {
    #####: 1783:            if (context_p->token.type != LEXER_LITERAL
    #####: 1784:                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1785:            {
    #####: 1786:              scanner_raise_error (context_p);
        -: 1787:            }
        -: 1788:
    #####: 1789:            const uint8_t *source_p = context_p->source_p;
        -: 1790:
    #####: 1791:            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))
        -: 1792:            {
    #####: 1793:              lexer_next_token (context_p);
        -: 1794:
    #####: 1795:              if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1796:              {
    #####: 1797:                scanner_raise_error (context_p);
        -: 1798:              }
        -: 1799:
    #####: 1800:              lexer_next_token (context_p);
        -: 1801:
    #####: 1802:              if (context_p->token.type != LEXER_LITERAL
    #####: 1803:                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1804:              {
    #####: 1805:                scanner_raise_error (context_p);
        -: 1806:              }
        -: 1807:
    #####: 1808:              source_p = context_p->source_p;
        -: 1809:            }
        -: 1810:
    #####: 1811:            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1812:
    #####: 1813:            if (literal_p->type & (SCANNER_LITERAL_IS_ARG
        -: 1814:                                   | SCANNER_LITERAL_IS_VAR
        -: 1815:                                   | SCANNER_LITERAL_IS_LOCAL))
        -: 1816:            {
    #####: 1817:              context_p->source_p = source_p;
    #####: 1818:              scanner_raise_redeclaration_error (context_p);
        -: 1819:            }
        -: 1820:
    #####: 1821:            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1822:            {
    #####: 1823:              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1824:            }
        -: 1825:
    #####: 1826:            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1827:
    #####: 1828:            lexer_next_token (context_p);
        -: 1829:
    #####: 1830:            if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1831:            {
    #####: 1832:              if (context_p->token.type != LEXER_COMMA)
        -: 1833:              {
    #####: 1834:                scanner_raise_error (context_p);
        -: 1835:              }
        -: 1836:
    #####: 1837:              lexer_next_token (context_p);
        -: 1838:            }
        -: 1839:          }
        -: 1840:
    #####: 1841:          lexer_next_token (context_p);
        -: 1842:        }
        -: 1843:        else
        -: 1844:        {
    #####: 1845:          scanner_raise_error (context_p);
        -: 1846:        }
        -: 1847:      }
        -: 1848:
    #####: 1849:      if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1850:      {
    #####: 1851:        scanner_raise_error (context_p);
        -: 1852:      }
        -: 1853:
    #####: 1854:      lexer_next_token (context_p);
        -: 1855:
    #####: 1856:      if (context_p->token.type != LEXER_LITERAL
    #####: 1857:          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)
        -: 1858:      {
    #####: 1859:        scanner_raise_error (context_p);
        -: 1860:      }
        -: 1861:
    #####: 1862:      return SCAN_NEXT_TOKEN;
        -: 1863:    }
    #####: 1864:    case LEXER_KEYW_EXPORT:
        -: 1865:    {
    #####: 1866:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1867:      {
    #####: 1868:        scanner_raise_error (context_p);
        -: 1869:      }
        -: 1870:
    #####: 1871:      lexer_next_token (context_p);
        -: 1872:
    #####: 1873:      if (context_p->token.type == LEXER_KEYW_DEFAULT)
        -: 1874:      {
    #####: 1875:        lexer_next_token (context_p);
    #####: 1876:        parser_stack_push_uint8 (context_p, SCAN_STACK_EXPORT_DEFAULT);
    #####: 1877:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1878:        return SCAN_KEEP_TOKEN;
        -: 1879:      }
        -: 1880:
    #####: 1881:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1882:
    #####: 1883:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1884:      {
    #####: 1885:        lexer_next_token (context_p);
        -: 1886:
    #####: 1887:        if (lexer_token_is_identifier (context_p, "as", 2))
        -: 1888:        {
    #####: 1889:          lexer_next_token (context_p);
        -: 1890:
    #####: 1891:          if (context_p->token.type != LEXER_LITERAL
    #####: 1892:              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1893:          {
    #####: 1894:            scanner_raise_error (context_p);
        -: 1895:          }
        -: 1896:
    #####: 1897:          lexer_next_token (context_p);
        -: 1898:        }
        -: 1899:
    #####: 1900:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1901:        {
    #####: 1902:          scanner_raise_error (context_p);
        -: 1903:        }
        -: 1904:
    #####: 1905:        lexer_next_token (context_p);
        -: 1906:
    #####: 1907:        if (context_p->token.type != LEXER_LITERAL
    #####: 1908:            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1909:        {
    #####: 1910:          scanner_raise_error (context_p);
        -: 1911:        }
        -: 1912:
    #####: 1913:        return SCAN_NEXT_TOKEN;
        -: 1914:      }
        -: 1915:
        -: 1916:      scanner_source_start_t source_start;
    #####: 1917:      source_start.source_p = context_p->source_p;
        -: 1918:
    #####: 1919:      if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1920:      {
    #####: 1921:        lexer_next_token (context_p);
        -: 1922:
    #####: 1923:        while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1924:        {
    #####: 1925:          if (context_p->token.type != LEXER_LITERAL
    #####: 1926:              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1927:          {
    #####: 1928:            scanner_raise_error (context_p);
        -: 1929:          }
        -: 1930:
    #####: 1931:          lexer_next_token (context_p);
        -: 1932:
    #####: 1933:          if (lexer_token_is_identifier (context_p, "as", 2))
        -: 1934:          {
    #####: 1935:            lexer_next_token (context_p);
        -: 1936:
    #####: 1937:            if (context_p->token.type != LEXER_LITERAL
    #####: 1938:                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1939:            {
    #####: 1940:              scanner_raise_error (context_p);
        -: 1941:            }
        -: 1942:
    #####: 1943:            lexer_next_token (context_p);
        -: 1944:          }
        -: 1945:
    #####: 1946:          if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1947:          {
    #####: 1948:            if (context_p->token.type != LEXER_COMMA)
        -: 1949:            {
    #####: 1950:              scanner_raise_error (context_p);
        -: 1951:            }
        -: 1952:
    #####: 1953:            lexer_next_token (context_p);
        -: 1954:          }
        -: 1955:        }
        -: 1956:
    #####: 1957:        lexer_next_token (context_p);
        -: 1958:
    #####: 1959:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1960:        {
    #####: 1961:          return SCAN_KEEP_TOKEN;
        -: 1962:        }
        -: 1963:
    #####: 1964:        scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####: 1965:        info_p->type = SCANNER_TYPE_EXPORT_MODULE_SPECIFIER;
        -: 1966:
    #####: 1967:        lexer_next_token (context_p);
        -: 1968:
    #####: 1969:        if (context_p->token.type != LEXER_LITERAL
    #####: 1970:            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1971:        {
    #####: 1972:          scanner_raise_error (context_p);
        -: 1973:        }
        -: 1974:
    #####: 1975:        return SCAN_NEXT_TOKEN;
        -: 1976:      }
        -: 1977:
    #####: 1978:      switch (context_p->token.type)
        -: 1979:      {
    #####: 1980:        case LEXER_KEYW_CLASS:
        -: 1981:        case LEXER_KEYW_LET:
        -: 1982:        case LEXER_KEYW_CONST:
        -: 1983:        case LEXER_KEYW_VAR:
        -: 1984:        {
    #####: 1985:          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;
    #####: 1986:          break;
        -: 1987:        }
        -: 1988:      }
        -: 1989:
    #####: 1990:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 1991:      return SCAN_KEEP_TOKEN;
        -: 1992:    }
        -: 1993:#endif /* JERRY_MODULE_SYSTEM */
        5: 1994:    default:
        -: 1995:    {
        5: 1996:      break;
        -: 1997:    }
        -: 1998:  }
        -: 1999:
        5: 2000:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2001:
        5: 2002:  if (type == LEXER_LITERAL
        5: 2003:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2004:  {
        5: 2005:    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))
        -: 2006:    {
    #####: 2007:      lexer_consume_next_character (context_p);
    #####: 2008:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2009:      return SCAN_NEXT_TOKEN;
        -: 2010:    }
        -: 2011:
        5: 2012:    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);
        -: 2013:
        -: 2014:#if JERRY_ESNEXT
        -: 2015:    /* The colon needs to be checked first because the parser also checks
        -: 2016:     * it first, and this check skips the spaces which affects source_p. */
        5: 2017:    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))
        -: 2018:    {
    #####: 2019:      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);
    #####: 2020:      return SCAN_KEEP_TOKEN;
        -: 2021:    }
        -: 2022:
        5: 2023:    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))
        -: 2024:    {
    #####: 2025:      lexer_lit_location_t let_literal = context_p->token.lit_location;
    #####: 2026:      const uint8_t *source_p = context_p->source_p;
        -: 2027:
    #####: 2028:      lexer_next_token (context_p);
        -: 2029:
    #####: 2030:      type = (lexer_token_type_t) context_p->token.type;
        -: 2031:
    #####: 2032:      if (type == LEXER_LEFT_SQUARE
    #####: 2033:          || type == LEXER_LEFT_BRACE
    #####: 2034:          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))
        -: 2035:      {
    #####: 2036:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 2037:        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
    #####: 2038:        return SCAN_KEEP_TOKEN;
        -: 2039:      }
        -: 2040:
    #####: 2041:      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 2042:      info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 2043:
    #####: 2044:      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -: 2045:                                                                         scanner_context_p->active_literal_pool_p,
        -: 2046:                                                                         &let_literal);
    #####: 2047:      lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 2048:
    #####: 2049:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2050:      {
    #####: 2051:        lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2052:      }
        -: 2053:
    #####: 2054:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 2055:      return SCAN_KEEP_TOKEN;
        -: 2056:    }
        -: 2057:
        5: 2058:    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -: 2059:    {
    #####: 2060:      scanner_context_p->async_source_p = context_p->source_p;
        -: 2061:
    #####: 2062:      if (scanner_check_async_function (context_p, scanner_context_p))
        -: 2063:      {
    #####: 2064:        scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -: 2065:      }
    #####: 2066:      return SCAN_KEEP_TOKEN;
        -: 2067:    }
        -: 2068:#endif /* JERRY_ESNEXT */
        -: 2069:
        5: 2070:    scanner_add_reference (context_p, scanner_context_p);
        -: 2071:
        5: 2072:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        5: 2073:    return SCAN_NEXT_TOKEN;
        -: 2074:  }
        -: 2075:
    #####: 2076:  return SCAN_KEEP_TOKEN;
        -: 2077:} /* scanner_scan_statement */
        -: 2078:
        -: 2079:/**
        -: 2080: * Scan statement terminator.
        -: 2081: *
        -: 2082: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 2083: */
        -: 2084:static scan_return_types_t
        9: 2085:scanner_scan_statement_end (parser_context_t *context_p, /**< context */
        -: 2086:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 2087:                            lexer_token_type_t type) /**< current token type */
        -: 2088:{
        9: 2089:  bool terminator_found = false;
        -: 2090:
        9: 2091:  if (type == LEXER_SEMICOLON)
        -: 2092:  {
        9: 2093:    lexer_next_token (context_p);
        9: 2094:    terminator_found = true;
        -: 2095:  }
        -: 2096:
        -: 2097:  while (true)
        -: 2098:  {
       11: 2099:    type = (lexer_token_type_t) context_p->token.type;
        -: 2100:
       10: 2101:    switch (context_p->stack_top_uint8)
        -: 2102:    {
        2: 2103:      case SCAN_STACK_SCRIPT:
        -: 2104:      case SCAN_STACK_SCRIPT_FUNCTION:
        -: 2105:      {
        2: 2106:        if (type == LEXER_EOS)
        -: 2107:        {
        1: 2108:          return SCAN_NEXT_TOKEN;
        -: 2109:        }
        1: 2110:        break;
        -: 2111:      }
    #####: 2112:      case SCAN_STACK_BLOCK_STATEMENT:
        -: 2113:#if JERRY_ESNEXT
        -: 2114:      case SCAN_STACK_CLASS_STATEMENT:
        -: 2115:#endif /* JERRY_ESNEXT */
        -: 2116:      case SCAN_STACK_FUNCTION_STATEMENT:
        -: 2117:      {
    #####: 2118:        if (type != LEXER_RIGHT_BRACE)
        -: 2119:        {
    #####: 2120:          break;
        -: 2121:        }
        -: 2122:
        -: 2123:#if JERRY_ESNEXT
    #####: 2124:        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)
        -: 2125:        {
    #####: 2126:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2127:        }
        -: 2128:#else /* !JERRY_ESNEXT */
    #####: 2129:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)
        -: 2130:        {
    #####: 2131:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2132:        }
        -: 2133:#endif /* JERRY_ESNEXT */
        -: 2134:
    #####: 2135:        terminator_found = true;
    #####: 2136:        parser_stack_pop_uint8 (context_p);
        -: 2137:#if JERRY_MODULE_SYSTEM
    #####: 2138:        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 2139:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2140:        lexer_next_token (context_p);
    #####: 2141:        continue;
        -: 2142:      }
        5: 2143:      case SCAN_STACK_FUNCTION_EXPRESSION:
        -: 2144:#if JERRY_ESNEXT
        -: 2145:      case SCAN_STACK_FUNCTION_ARROW:
        -: 2146:#endif /* JERRY_ESNEXT */
        -: 2147:      {
        5: 2148:        if (type != LEXER_RIGHT_BRACE)
        -: 2149:        {
        3: 2150:          break;
        -: 2151:        }
        -: 2152:
        2: 2153:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 2154:#if JERRY_ESNEXT
        2: 2155:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)
        -: 2156:        {
    #####: 2157:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -: 2158:        }
        -: 2159:#endif /* JERRY_ESNEXT */
        -: 2160:
        2: 2161:        scanner_pop_literal_pool (context_p, scanner_context_p);
        2: 2162:        parser_stack_pop_uint8 (context_p);
        -: 2163:
        -: 2164:#if JERRY_MODULE_SYSTEM
        2: 2165:        if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)
        -: 2166:        {
    #####: 2167:          terminator_found = true;
    #####: 2168:          parser_stack_pop_uint8 (context_p);
    #####: 2169:          lexer_next_token (context_p);
    #####: 2170:          continue;
        -: 2171:        }
        -: 2172:#endif /* JERRY_MODULE_SYSTEM */
        2: 2173:        return SCAN_NEXT_TOKEN;
        -: 2174:      }
    #####: 2175:      case SCAN_STACK_FUNCTION_PROPERTY:
        -: 2176:      {
    #####: 2177:        if (type != LEXER_RIGHT_BRACE)
        -: 2178:        {
    #####: 2179:          break;
        -: 2180:        }
        -: 2181:
        -: 2182:#if JERRY_ESNEXT
    #####: 2183:        bool has_super_reference = (scanner_context_p->active_literal_pool_p->status_flags
    #####: 2184:                                    & SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE) != 0;
        -: 2185:#endif /* JERRY_ESNEXT */
    #####: 2186:        scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 2187:        parser_stack_pop_uint8 (context_p);
        -: 2188:
        -: 2189:#if JERRY_ESNEXT
    #####: 2190:        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR
    #####: 2191:            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 2192:        {
    #####: 2193:          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
    #####: 2194:          return SCAN_KEEP_TOKEN;
        -: 2195:        }
        -: 2196:
    #####: 2197:        if (has_super_reference && context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL)
        -: 2198:        {
    #####: 2199:          *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_SUPER;
        -: 2200:        }
        -: 2201:#else /* JERRY_ESNEXT */
        -: 2202:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);
        -: 2203:#endif /* JERRY_ESNEXT */
        -: 2204:
    #####: 2205:        lexer_next_token (context_p);
        -: 2206:
    #####: 2207:        if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2208:        {
    #####: 2209:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2210:          return SCAN_KEEP_TOKEN;
        -: 2211:        }
        -: 2212:
    #####: 2213:        if (context_p->token.type != LEXER_COMMA)
        -: 2214:        {
    #####: 2215:          scanner_raise_error (context_p);
        -: 2216:        }
        -: 2217:
    #####: 2218:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2219:        return SCAN_KEEP_TOKEN;
        -: 2220:      }
    #####: 2221:      case SCAN_STACK_SWITCH_BLOCK:
        -: 2222:      {
    #####: 2223:        if (type != LEXER_RIGHT_BRACE)
        -: 2224:        {
    #####: 2225:          break;
        -: 2226:        }
        -: 2227:
    #####: 2228:        scanner_switch_statement_t switch_statement;
        -: 2229:
    #####: 2230:        parser_stack_pop_uint8 (context_p);
    #####: 2231:        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
        -: 2232:
    #####: 2233:        scanner_context_p->active_switch_statement = switch_statement;
        -: 2234:
        -: 2235:#if JERRY_ESNEXT
    #####: 2236:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2237:#endif /* JERRY_ESNEXT */
        -: 2238:
    #####: 2239:        terminator_found = true;
    #####: 2240:        lexer_next_token (context_p);
    #####: 2241:        continue;
        -: 2242:      }
    #####: 2243:      case SCAN_STACK_IF_STATEMENT:
        -: 2244:      {
    #####: 2245:        parser_stack_pop_uint8 (context_p);
        -: 2246:
    #####: 2247:        if (type == LEXER_KEYW_ELSE
    #####: 2248:            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2249:        {
        -: 2250:#if JERRY_ESNEXT
    #####: 2251:          scanner_check_function_after_if (context_p, scanner_context_p);
    #####: 2252:          return SCAN_KEEP_TOKEN;
        -: 2253:#else /* !JERRY_ESNEXT */
    #####: 2254:          scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2255:          return SCAN_NEXT_TOKEN;
        -: 2256:#endif /* JERRY_ESNEXT */
        -: 2257:        }
    #####: 2258:        continue;
        -: 2259:      }
    #####: 2260:      case SCAN_STACK_WITH_STATEMENT:
        -: 2261:      {
    #####: 2262:        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 2263:
    #####: 2264:        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);
        -: 2265:
    #####: 2266:        parser_stack_pop_uint8 (context_p);
        -: 2267:
    #####: 2268:        if (context_p->stack_top_uint8 == 0)
        -: 2269:        {
    #####: 2270:          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;
        -: 2271:        }
        -: 2272:
    #####: 2273:        parser_stack_pop_uint8 (context_p);
    #####: 2274:        continue;
        -: 2275:      }
    #####: 2276:      case SCAN_STACK_DO_STATEMENT:
        -: 2277:      {
    #####: 2278:        parser_stack_pop_uint8 (context_p);
        -: 2279:
    #####: 2280:        if (type != LEXER_KEYW_WHILE
    #####: 2281:            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2282:        {
    #####: 2283:          scanner_raise_error (context_p);
        -: 2284:        }
        -: 2285:
    #####: 2286:        lexer_next_token (context_p);
    #####: 2287:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2288:        {
    #####: 2289:          scanner_raise_error (context_p);
        -: 2290:        }
        -: 2291:
    #####: 2292:        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);
    #####: 2293:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2294:        return SCAN_NEXT_TOKEN;
        -: 2295:      }
    #####: 2296:      case SCAN_STACK_DO_EXPRESSION:
        -: 2297:      {
    #####: 2298:        parser_stack_pop_uint8 (context_p);
    #####: 2299:        terminator_found = true;
    #####: 2300:        continue;
        -: 2301:      }
        -: 2302:#if JERRY_ESNEXT
    #####: 2303:      case SCAN_STACK_PRIVATE_BLOCK_EARLY:
        -: 2304:      {
    #####: 2305:        parser_list_iterator_t literal_iterator;
        -: 2306:        lexer_lit_location_t *literal_p;
        -: 2307:
    #####: 2308:        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);
        -: 2309:
    #####: 2310:        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 2311:        {
    #####: 2312:          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))
    #####: 2313:              && (literal_p->type & SCANNER_LITERAL_IS_USED))
        -: 2314:          {
    #####: 2315:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2316:          }
        -: 2317:        }
        -: 2318:        /* FALLTHRU */
        -: 2319:      }
    #####: 2320:      case SCAN_STACK_PRIVATE_BLOCK:
        -: 2321:      {
    #####: 2322:        parser_stack_pop_uint8 (context_p);
    #####: 2323:        scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 2324:        continue;
        -: 2325:      }
        -: 2326:#endif /* JERRY_ESNEXT */
        -: 2327:#if JERRY_MODULE_SYSTEM
    #####: 2328:      case SCAN_STACK_EXPORT_DEFAULT:
        -: 2329:      {
    #####: 2330:        parser_stack_pop_uint8 (context_p);
    #####: 2331:        lexer_lit_location_t *location_p = scanner_add_custom_literal (context_p,
        -: 2332:                                                                       scanner_context_p->active_literal_pool_p,
        -: 2333:                                                                       &lexer_default_literal);
    #####: 2334:        location_p->type |= SCANNER_LITERAL_IS_VAR;
    #####: 2335:        continue;
        -: 2336:      }
        -: 2337:#endif /* JERRY_MODULE_SYSTEM */
        3: 2338:      default:
        -: 2339:      {
        3: 2340:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT
        -: 2341:                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);
        -: 2342:
        3: 2343:        if (type != LEXER_RIGHT_BRACE)
        -: 2344:        {
        1: 2345:          break;
        -: 2346:        }
        -: 2347:
        2: 2348:        uint8_t stack_top = context_p->stack_top_uint8;
        2: 2349:        parser_stack_pop_uint8 (context_p);
        2: 2350:        lexer_next_token (context_p);
        -: 2351:
        -: 2352:#if JERRY_ESNEXT
        2: 2353:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2354:#else /* !JERRY_ESNEXT */
    #####: 2355:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2356:        {
    #####: 2357:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2358:        }
        -: 2359:#endif /* JERRY_ESNEXT */
        -: 2360:
        -: 2361:        /* A finally statement is optional after a try or catch statement. */
        2: 2362:        if (context_p->token.type == LEXER_KEYW_FINALLY)
        -: 2363:        {
    #####: 2364:          lexer_next_token (context_p);
        -: 2365:
    #####: 2366:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2367:          {
    #####: 2368:            scanner_raise_error (context_p);
        -: 2369:          }
        -: 2370:
        -: 2371:#if JERRY_ESNEXT
        -: 2372:          scanner_literal_pool_t *literal_pool_p;
    #####: 2373:          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####: 2374:          literal_pool_p->source_p = context_p->source_p;
        -: 2375:#endif /* JERRY_ESNEXT */
        -: 2376:
    #####: 2377:          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
    #####: 2378:          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2379:          return SCAN_NEXT_TOKEN;
        -: 2380:        }
        -: 2381:
        2: 2382:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2383:        {
        1: 2384:          terminator_found = true;
        1: 2385:          continue;
        -: 2386:        }
        -: 2387:
        -: 2388:        /* A catch statement must be present after a try statement unless a finally is provided. */
        1: 2389:        if (context_p->token.type != LEXER_KEYW_CATCH)
        -: 2390:        {
    #####: 2391:          scanner_raise_error (context_p);
        -: 2392:        }
        -: 2393:
        1: 2394:        lexer_next_token (context_p);
        -: 2395:
        -: 2396:        scanner_literal_pool_t *literal_pool_p;
        1: 2397:        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 2398:        literal_pool_p->source_p = context_p->source_p;
        1: 2399:        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);
        -: 2400:
        -: 2401:#if JERRY_ESNEXT
        1: 2402:        if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2403:        {
    #####: 2404:          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2405:          return SCAN_NEXT_TOKEN;
        -: 2406:        }
        -: 2407:#endif /* JERRY_ESNEXT */
        -: 2408:
        1: 2409:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2410:        {
    #####: 2411:          scanner_raise_error (context_p);
        -: 2412:        }
        -: 2413:
        1: 2414:        lexer_next_token (context_p);
        -: 2415:
        -: 2416:#if JERRY_ESNEXT
        1: 2417:        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 2418:        {
    #####: 2419:          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);
        -: 2420:
    #####: 2421:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2422:          {
    #####: 2423:            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2424:            scanner_context_p->mode = SCAN_MODE_BINDING;
    #####: 2425:            return SCAN_NEXT_TOKEN;
        -: 2426:          }
        -: 2427:
    #####: 2428:          parser_stack_push_uint8 (context_p, 0);
    #####: 2429:          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2430:          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2431:          return SCAN_KEEP_TOKEN;
        -: 2432:        }
        -: 2433:#endif /* JERRY_ESNEXT */
        -: 2434:
        1: 2435:        if (context_p->token.type != LEXER_LITERAL
        1: 2436:            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2437:        {
    #####: 2438:          scanner_raise_error (context_p);
        -: 2439:        }
        -: 2440:
        1: 2441:        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);
        1: 2442:        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;
        -: 2443:
        1: 2444:        lexer_next_token (context_p);
        -: 2445:
        1: 2446:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2447:        {
    #####: 2448:          scanner_raise_error (context_p);
        -: 2449:        }
        -: 2450:
        1: 2451:        lexer_next_token (context_p);
        -: 2452:
        1: 2453:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2454:        {
    #####: 2455:          scanner_raise_error (context_p);
        -: 2456:        }
        -: 2457:
        1: 2458:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 2459:        return SCAN_NEXT_TOKEN;
        -: 2460:      }
        -: 2461:    }
        -: 2462:
        5: 2463:    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2464:    {
    #####: 2465:      scanner_raise_error (context_p);
        -: 2466:    }
        -: 2467:
        5: 2468:    scanner_context_p->mode = SCAN_MODE_STATEMENT;
        5: 2469:    return SCAN_KEEP_TOKEN;
        -: 2470:  }
        -: 2471:} /* scanner_scan_statement_end */
        -: 2472:
        -: 2473:/**
        -: 2474: * Scan the whole source code.
        -: 2475: */
        -: 2476:void JERRY_ATTR_NOINLINE
        1: 2477:scanner_scan_all (parser_context_t *context_p) /**< context */
        -: 2478:{
        1: 2479:  scanner_context_t scanner_context;
        -: 2480:
        -: 2481:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2482:  if (context_p->is_show_opcodes)
        -: 2483:  {
        -: 2484:    JERRY_DEBUG_MSG ("\n--- Scanning start ---\n\n");
        -: 2485:  }
        -: 2486:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2487:
        1: 2488:  scanner_context.context_status_flags = context_p->status_flags;
        1: 2489:  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;
        -: 2490:#if JERRY_DEBUGGER
        -: 2491:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2492:  {
        -: 2493:    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;
        -: 2494:  }
        -: 2495:#endif /* JERRY_DEBUGGER */
        -: 2496:#if JERRY_ESNEXT
        1: 2497:  scanner_context.binding_type = SCANNER_BINDING_NONE;
        1: 2498:  scanner_context.active_binding_list_p = NULL;
        -: 2499:#endif /* JERRY_ESNEXT */
        1: 2500:  scanner_context.active_literal_pool_p = NULL;
        1: 2501:  scanner_context.active_switch_statement.last_case_p = NULL;
        1: 2502:  scanner_context.end_arguments_p = NULL;
        -: 2503:#if JERRY_ESNEXT
        1: 2504:  scanner_context.async_source_p = NULL;
        -: 2505:#endif /* JERRY_ESNEXT */
        -: 2506:
        -: 2507:  /* This assignment must be here because of Apple compilers. */
        1: 2508:  context_p->u.scanner_context_p = &scanner_context;
        -: 2509:#if JERRY_ESNEXT
        1: 2510:  context_p->global_status_flags |= ECMA_PARSE_INTERNAL_PRE_SCANNING;
        -: 2511:#endif /* JERRY_ESNEXT */
        -: 2512:
        1: 2513:  parser_stack_init (context_p);
        -: 2514:
        1: 2515:  PARSER_TRY (context_p->try_buffer)
        -: 2516:  {
        1: 2517:    if (context_p->arguments_start_p == NULL)
        -: 2518:    {
        1: 2519:      context_p->source_p = context_p->source_start_p;
        1: 2520:      context_p->source_end_p = context_p->source_start_p + context_p->source_size;
        -: 2521:
        1: 2522:      uint16_t status_flags = (SCANNER_LITERAL_POOL_FUNCTION
        -: 2523:                               | SCANNER_LITERAL_POOL_NO_ARGUMENTS
        -: 2524:                               | SCANNER_LITERAL_POOL_CAN_EVAL);
        -: 2525:
        1: 2526:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2527:      {
    #####: 2528:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2529:      }
        -: 2530:
        1: 2531:      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);
        1: 2532:      literal_pool_p->source_p = context_p->source_start_p;
        -: 2533:
        1: 2534:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);
        -: 2535:
        1: 2536:      lexer_next_token (context_p);
        1: 2537:      scanner_check_directives (context_p, &scanner_context);
        -: 2538:    }
        -: 2539:    else
        -: 2540:    {
    #####: 2541:      context_p->source_p = context_p->arguments_start_p;
    #####: 2542:      context_p->source_end_p = context_p->arguments_start_p + context_p->arguments_size;
        -: 2543:
    #####: 2544:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2545:
    #####: 2546:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2547:      {
    #####: 2548:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2549:      }
        -: 2550:
        -: 2551:#if JERRY_ESNEXT
    #####: 2552:      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2553:      {
    #####: 2554:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2555:      }
    #####: 2556:      if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 2557:      {
    #####: 2558:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2559:      }
        -: 2560:#endif /* JERRY_ESNEXT */
        -: 2561:
    #####: 2562:      scanner_push_literal_pool (context_p, &scanner_context, status_flags);
    #####: 2563:      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 2564:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);
        -: 2565:
        -: 2566:      /* Faking the first token. */
    #####: 2567:      context_p->token.type = LEXER_LEFT_PAREN;
        -: 2568:    }
        -: 2569:
        -: 2570:    while (true)
       79: 2571:    {
       80: 2572:      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;
       80: 2573:      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -: 2574:
       80: 2575:      switch (scanner_context.mode)
        -: 2576:      {
       17: 2577:        case SCAN_MODE_PRIMARY_EXPRESSION:
        -: 2578:        {
       17: 2579:          if (type == LEXER_ADD
       17: 2580:              || type == LEXER_SUBTRACT
       17: 2581:              || LEXER_IS_UNARY_OP_TOKEN (type))
        -: 2582:          {
        -: 2583:            break;
        -: 2584:          }
        -: 2585:          /* FALLTHRU */
        -: 2586:        }
        -: 2587:        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:
        -: 2588:        {
       19: 2589:          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2590:          {
        3: 2591:            continue;
        -: 2592:          }
       16: 2593:          break;
        -: 2594:        }
        -: 2595:#if JERRY_ESNEXT
    #####: 2596:        case SCAN_MODE_CLASS_DECLARATION:
        -: 2597:        {
    #####: 2598:          if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 2599:          {
    #####: 2600:            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);
    #####: 2601:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2602:            break;
        -: 2603:          }
    #####: 2604:          else if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2605:          {
    #####: 2606:            scanner_raise_error (context_p);
        -: 2607:          }
        -: 2608:
    #####: 2609:          scanner_context.mode = SCAN_MODE_CLASS_BODY;
        -: 2610:          /* FALLTHRU */
        -: 2611:        }
    #####: 2612:        case SCAN_MODE_CLASS_BODY:
        -: 2613:        {
    #####: 2614:          lexer_skip_empty_statements (context_p);
    #####: 2615:          lexer_scan_identifier (context_p);
        -: 2616:          /* FALLTHRU */
        -: 2617:        }
    #####: 2618:        case SCAN_MODE_CLASS_BODY_NO_SCAN:
        -: 2619:        {
    #####: 2620:          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR
        -: 2621:                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
    #####: 2622:          JERRY_ASSERT (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);
        -: 2623:
    #####: 2624:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2625:          {
    #####: 2626:            parser_stack_pop_uint8 (context_p);
    #####: 2627:            stack_top = context_p->stack_top_uint8;
        -: 2628:
    #####: 2629:            scanner_pop_literal_pool (context_p, &scanner_context);
        -: 2630:
    #####: 2631:            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);
        -: 2632:
    #####: 2633:            if (stack_top == SCAN_STACK_CLASS_STATEMENT)
        -: 2634:            {
        -: 2635:              /* The token is kept to disallow consuming a semicolon after it. */
    #####: 2636:              scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2637:              continue;
        -: 2638:            }
        -: 2639:
    #####: 2640:            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 2641:            parser_stack_pop_uint8 (context_p);
        -: 2642:
        -: 2643:#if JERRY_MODULE_SYSTEM
    #####: 2644:            if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)
        -: 2645:            {
        -: 2646:              /* The token is kept to disallow consuming a semicolon after it. */
    #####: 2647:              parser_stack_change_last_uint8 (context_p, SCAN_STACK_CLASS_STATEMENT);
    #####: 2648:              scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2649:              continue;
        -: 2650:            }
        -: 2651:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2652:            break;
        -: 2653:          }
        -: 2654:
    #####: 2655:          bool identifier_found = false;
        -: 2656:
    #####: 2657:          if (context_p->token.type == LEXER_LITERAL
    #####: 2658:              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####: 2659:              && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -: 2660:          {
    #####: 2661:            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 2662:            {
    #####: 2663:              const uint8_t *class_source_p = scanner_context.active_literal_pool_p->source_p;
    #####: 2664:              scanner_info_t *info_p = scanner_insert_info (context_p, class_source_p, sizeof (scanner_info_t));
        -: 2665:
    #####: 2666:              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;
    #####: 2667:              parser_stack_change_last_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
        -: 2668:            }
        -: 2669:          }
    #####: 2670:          else if (lexer_token_is_identifier (context_p, "static", 6))
        -: 2671:          {
    #####: 2672:            lexer_scan_identifier (context_p);
    #####: 2673:            identifier_found = true;
        -: 2674:          }
        -: 2675:
    #####: 2676:          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        -: 2677:
    #####: 2678:          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2679:
    #####: 2680:          if (lexer_token_is_identifier (context_p, "get", 3)
    #####: 2681:              || lexer_token_is_identifier (context_p, "set", 3))
        -: 2682:          {
    #####: 2683:            lexer_scan_identifier (context_p);
    #####: 2684:            identifier_found = true;
        -: 2685:
    #####: 2686:            if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2687:            {
    #####: 2688:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2689:              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2690:              continue;
        -: 2691:            }
        -: 2692:          }
    #####: 2693:          else if (lexer_token_is_identifier (context_p, "async", 5))
        -: 2694:          {
    #####: 2695:            lexer_scan_identifier (context_p);
    #####: 2696:            identifier_found = true;
        -: 2697:
    #####: 2698:            if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2699:            {
    #####: 2700:              if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2701:              {
    #####: 2702:                parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2703:                scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2704:                continue;
        -: 2705:              }
        -: 2706:
    #####: 2707:              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2708:
    #####: 2709:              if (context_p->token.type == LEXER_MULTIPLY)
        -: 2710:              {
    #####: 2711:                lexer_scan_identifier (context_p);
    #####: 2712:                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2713:              }
        -: 2714:            }
        -: 2715:          }
    #####: 2716:          else if (context_p->token.type == LEXER_MULTIPLY)
        -: 2717:          {
    #####: 2718:            lexer_scan_identifier (context_p);
    #####: 2719:            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2720:          }
        -: 2721:
    #####: 2722:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2723:          {
    #####: 2724:            if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)
        -: 2725:            {
    #####: 2726:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
        -: 2727:            }
        -: 2728:
    #####: 2729:            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 2730:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2731:            break;
        -: 2732:          }
        -: 2733:
    #####: 2734:          if (context_p->token.type == LEXER_LITERAL)
        -: 2735:          {
    #####: 2736:            lexer_scan_identifier (context_p);
    #####: 2737:            identifier_found = true;
        -: 2738:          }
        -: 2739:
    #####: 2740:          if (!identifier_found)
        -: 2741:          {
    #####: 2742:            scanner_raise_error (context_p);
        -: 2743:          }
        -: 2744:
    #####: 2745:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2746:          {
    #####: 2747:            if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 2748:            {
    #####: 2749:              context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2750:            }
        -: 2751:
    #####: 2752:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2753:            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
    #####: 2754:            continue;
        -: 2755:          }
        -: 2756:
    #####: 2757:          if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)
        -: 2758:          {
    #####: 2759:            scanner_raise_error (context_p);
        -: 2760:          }
        -: 2761:
    #####: 2762:          if (context_p->token.type == LEXER_ASSIGN)
        -: 2763:          {
    #####: 2764:            scanner_push_class_field_initializer (context_p, &scanner_context);
    #####: 2765:            break;
        -: 2766:          }
        -: 2767:
    #####: 2768:          if (context_p->token.type == LEXER_SEMICOLON)
        -: 2769:          {
    #####: 2770:            scanner_context.mode = SCAN_MODE_CLASS_BODY;
    #####: 2771:            continue;
        -: 2772:          }
        -: 2773:
    #####: 2774:          if (context_p->token.type != LEXER_RIGHT_BRACE
    #####: 2775:              && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2776:          {
    #####: 2777:            scanner_raise_error (context_p);
        -: 2778:          }
        -: 2779:
    #####: 2780:          scanner_context.mode = SCAN_MODE_CLASS_BODY_NO_SCAN;
    #####: 2781:          continue;
        -: 2782:        }
        -: 2783:#endif /* JERRY_ESNEXT */
       32: 2784:        case SCAN_MODE_POST_PRIMARY_EXPRESSION:
        -: 2785:        {
       32: 2786:          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))
        -: 2787:          {
       10: 2788:            break;
        -: 2789:          }
       22: 2790:          type = (lexer_token_type_t) context_p->token.type;
        -: 2791:          /* FALLTHRU */
        -: 2792:        }
       23: 2793:        case SCAN_MODE_PRIMARY_EXPRESSION_END:
        -: 2794:        {
       23: 2795:          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2796:          {
       14: 2797:            continue;
        -: 2798:          }
        9: 2799:          break;
        -: 2800:        }
        5: 2801:        case SCAN_MODE_STATEMENT_OR_TERMINATOR:
        -: 2802:        {
        5: 2803:          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)
        -: 2804:          {
    #####: 2805:            scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2806:            continue;
        -: 2807:          }
        -: 2808:          /* FALLTHRU */
        -: 2809:        }
        -: 2810:        case SCAN_MODE_STATEMENT:
        -: 2811:        {
       11: 2812:          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2813:          {
        1: 2814:            continue;
        -: 2815:          }
       10: 2816:          break;
        -: 2817:        }
        9: 2818:        case SCAN_MODE_STATEMENT_END:
        -: 2819:        {
        9: 2820:          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)
        -: 2821:          {
        5: 2822:            continue;
        -: 2823:          }
        -: 2824:
        4: 2825:          if (context_p->token.type == LEXER_EOS)
        -: 2826:          {
        1: 2827:            goto scan_completed;
        -: 2828:          }
        -: 2829:
        3: 2830:          break;
        -: 2831:        }
        4: 2832:        case SCAN_MODE_VAR_STATEMENT:
        -: 2833:        {
        -: 2834:#if JERRY_ESNEXT
        4: 2835:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 2836:          {
    #####: 2837:            uint8_t binding_type = SCANNER_BINDING_VAR;
        -: 2838:
    #####: 2839:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2840:            {
    #####: 2841:              binding_type = SCANNER_BINDING_LET;
        -: 2842:            }
    #####: 2843:            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)
        -: 2844:            {
    #####: 2845:              binding_type = SCANNER_BINDING_CONST;
        -: 2846:            }
        -: 2847:
    #####: 2848:            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);
        -: 2849:
    #####: 2850:            if (type == LEXER_LEFT_SQUARE)
        -: 2851:            {
    #####: 2852:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2853:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 2854:              break;
        -: 2855:            }
        -: 2856:
    #####: 2857:            parser_stack_push_uint8 (context_p, 0);
    #####: 2858:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2859:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2860:            continue;
        -: 2861:          }
        -: 2862:#endif /* JERRY_ESNEXT */
        -: 2863:
        4: 2864:          if (type != LEXER_LITERAL
        4: 2865:              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2866:          {
    #####: 2867:            scanner_raise_error (context_p);
        -: 2868:          }
        -: 2869:
        4: 2870:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 2871:
        -: 2872:#if JERRY_ESNEXT
        4: 2873:          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)
        -: 2874:          {
    #####: 2875:            scanner_detect_invalid_let (context_p, literal_p);
        -: 2876:
    #####: 2877:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2878:            {
    #####: 2879:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 2880:            }
        -: 2881:            else
        -: 2882:            {
    #####: 2883:              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);
    #####: 2884:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 2885:            }
        -: 2886:
    #####: 2887:            lexer_next_token (context_p);
        -: 2888:
    #####: 2889:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 2890:            {
    #####: 2891:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2892:            }
    #####: 2893:            else if (context_p->token.type == LEXER_ASSIGN)
        -: 2894:            {
    #####: 2895:              scanner_binding_literal_t binding_literal;
    #####: 2896:              binding_literal.literal_p = literal_p;
        -: 2897:
    #####: 2898:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 2899:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 2900:            }
        -: 2901:          }
        -: 2902:          else
        -: 2903:          {
        4: 2904:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 2905:            {
        4: 2906:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
        4: 2907:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2908:
        4: 2909:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2910:              {
    #####: 2911:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2912:              }
        -: 2913:            }
        -: 2914:
        4: 2915:            lexer_next_token (context_p);
        -: 2916:          }
        -: 2917:#else /* !JERRY_ESNEXT */
    #####: 2918:          literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2919:
    #####: 2920:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2921:          {
    #####: 2922:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2923:          }
        -: 2924:
    #####: 2925:          lexer_next_token (context_p);
        -: 2926:#endif /* JERRY_ESNEXT */
        -: 2927:
        -: 2928:#if JERRY_MODULE_SYSTEM
        4: 2929:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 2930:          {
    #####: 2931:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2932:          }
        -: 2933:#endif /* JERRY_MODULE_SYSTEM */
        -: 2934:
        4: 2935:          switch (context_p->token.type)
        -: 2936:          {
        3: 2937:            case LEXER_ASSIGN:
        -: 2938:            {
        3: 2939:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2940:              /* FALLTHRU */
        -: 2941:            }
        3: 2942:            case LEXER_COMMA:
        -: 2943:            {
        3: 2944:              lexer_next_token (context_p);
        3: 2945:              continue;
        -: 2946:            }
        -: 2947:          }
        -: 2948:
        1: 2949:          if (SCANNER_IS_FOR_START (stack_top))
        -: 2950:          {
        -: 2951:#if JERRY_MODULE_SYSTEM
        1: 2952:            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));
        -: 2953:#endif /* JERRY_MODULE_SYSTEM */
        -: 2954:
        1: 2955:            if (context_p->token.type != LEXER_SEMICOLON
        1: 2956:                && context_p->token.type != LEXER_KEYW_IN
    #####: 2957:                && !SCANNER_IDENTIFIER_IS_OF ())
        -: 2958:            {
    #####: 2959:              scanner_raise_error (context_p);
        -: 2960:            }
        -: 2961:
        1: 2962:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        1: 2963:            continue;
        -: 2964:          }
        -: 2965:
        -: 2966:#if JERRY_ESNEXT
    #####: 2967:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);
        -: 2968:#else /* !JERRY_ESNEXT */
        -: 2969:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);
        -: 2970:#endif /* JERRY_ESNEXT */
        -: 2971:
        -: 2972:#if JERRY_MODULE_SYSTEM
    #####: 2973:          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 2974:#endif /* JERRY_MODULE_SYSTEM */
        -: 2975:
    #####: 2976:          scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2977:          parser_stack_pop_uint8 (context_p);
    #####: 2978:          continue;
        -: 2979:        }
        2: 2980:        case SCAN_MODE_FUNCTION_ARGUMENTS:
        -: 2981:        {
        2: 2982:          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION
        -: 2983:                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT
        -: 2984:                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION
        -: 2985:                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);
        -: 2986:
        2: 2987:          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 2988:
        2: 2989:          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -: 2990:
        2: 2991:          literal_pool_p->source_p = context_p->source_p;
        -: 2992:
        -: 2993:#if JERRY_ESNEXT
        2: 2994:          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))
        -: 2995:          {
    #####: 2996:            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####: 2997:            literal_pool_p->source_p = scanner_context.async_source_p;
    #####: 2998:            scanner_context.async_source_p = NULL;
        -: 2999:          }
        -: 3000:#endif /* JERRY_ESNEXT */
        -: 3001:
        2: 3002:          if (type != LEXER_LEFT_PAREN)
        -: 3003:          {
    #####: 3004:            scanner_raise_error (context_p);
        -: 3005:          }
        2: 3006:          lexer_next_token (context_p);
        -: 3007:
        -: 3008:#if JERRY_ESNEXT
        -: 3009:          /* FALLTHRU */
        -: 3010:        }
        2: 3011:        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:
        -: 3012:        {
        2: 3013:          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)
        -: 3014:          {
        -: 3015:            lexer_lit_location_t *argument_literal_p;
        -: 3016:
        -: 3017:            do
        -: 3018:            {
    #####: 3019:              if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3020:              {
    #####: 3021:                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
    #####: 3022:                lexer_next_token (context_p);
        -: 3023:              }
        -: 3024:
    #####: 3025:              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 3026:              {
    #####: 3027:                argument_literal_p = NULL;
    #####: 3028:                break;
        -: 3029:              }
        -: 3030:
    #####: 3031:              if (context_p->token.type != LEXER_LITERAL
    #####: 3032:                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3033:              {
    #####: 3034:                scanner_raise_error (context_p);
        -: 3035:              }
        -: 3036:
    #####: 3037:              argument_literal_p = scanner_append_argument (context_p, &scanner_context);
    #####: 3038:              lexer_next_token (context_p);
        -: 3039:
    #####: 3040:              if (context_p->token.type != LEXER_COMMA)
        -: 3041:              {
    #####: 3042:                break;
        -: 3043:              }
        -: 3044:
    #####: 3045:              lexer_next_token (context_p);
        -: 3046:            }
    #####: 3047:            while (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS);
        -: 3048:
    #####: 3049:            if (argument_literal_p == NULL)
        -: 3050:            {
    #####: 3051:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -: 3052:
    #####: 3053:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
    #####: 3054:              scanner_append_hole (context_p, &scanner_context);
    #####: 3055:              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);
        -: 3056:
    #####: 3057:              if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3058:              {
    #####: 3059:                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 3060:                scanner_context.mode = SCAN_MODE_BINDING;
    #####: 3061:                break;
        -: 3062:              }
        -: 3063:
    #####: 3064:              parser_stack_push_uint8 (context_p, 0);
    #####: 3065:              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 3066:              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 3067:              continue;
        -: 3068:            }
        -: 3069:
    #####: 3070:            if (context_p->token.type == LEXER_ASSIGN)
        -: 3071:            {
    #####: 3072:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -: 3073:
    #####: 3074:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
    #####: 3075:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3076:
    #####: 3077:              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3078:              {
    #####: 3079:                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####: 3080:                break;
        -: 3081:              }
        -: 3082:
    #####: 3083:              scanner_binding_literal_t binding_literal;
    #####: 3084:              binding_literal.literal_p = argument_literal_p;
        -: 3085:
    #####: 3086:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 3087:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
    #####: 3088:              break;
        -: 3089:            }
        -: 3090:          }
        -: 3091:#else /* !JERRY_ESNEXT */
    #####: 3092:          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)
        -: 3093:          {
        -: 3094:            while (true)
        -: 3095:            {
    #####: 3096:              if (context_p->token.type != LEXER_LITERAL
    #####: 3097:                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3098:              {
    #####: 3099:                scanner_raise_error (context_p);
        -: 3100:              }
        -: 3101:
    #####: 3102:              scanner_append_argument (context_p, &scanner_context);
    #####: 3103:              lexer_next_token (context_p);
        -: 3104:
    #####: 3105:              if (context_p->token.type != LEXER_COMMA)
        -: 3106:              {
        -: 3107:                break;
        -: 3108:              }
        -: 3109:
    #####: 3110:              lexer_next_token (context_p);
        -: 3111:            }
        -: 3112:          }
        -: 3113:#endif /* JERRY_ESNEXT */
        -: 3114:
        2: 3115:          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)
        -: 3116:          {
        -: 3117:            /* End of argument parsing. */
    #####: 3118:            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));
    #####: 3119:            scanner_info_p->next_p = context_p->next_scanner_info_p;
    #####: 3120:            scanner_info_p->source_p = NULL;
    #####: 3121:            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;
    #####: 3122:            scanner_context.end_arguments_p = scanner_info_p;
        -: 3123:
    #####: 3124:            context_p->next_scanner_info_p = scanner_info_p;
    #####: 3125:            context_p->source_p = context_p->source_start_p;
    #####: 3126:            context_p->source_end_p = context_p->source_start_p + context_p->source_size;
    #####: 3127:            lexer_init_line_info (context_p);
        -: 3128:
        -: 3129:#if JERRY_ESNEXT
    #####: 3130:            scanner_filter_arguments (context_p, &scanner_context);
        -: 3131:#endif /* JERRY_ESNEXT */
    #####: 3132:            lexer_next_token (context_p);
    #####: 3133:            scanner_check_directives (context_p, &scanner_context);
    #####: 3134:            continue;
        -: 3135:          }
        -: 3136:
        2: 3137:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 3138:          {
    #####: 3139:            scanner_raise_error (context_p);
        -: 3140:          }
        -: 3141:
        2: 3142:          lexer_next_token (context_p);
        -: 3143:
        2: 3144:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 3145:          {
    #####: 3146:            scanner_raise_error (context_p);
        -: 3147:          }
        -: 3148:
        -: 3149:#if JERRY_ESNEXT
        2: 3150:          scanner_filter_arguments (context_p, &scanner_context);
        -: 3151:#endif /* JERRY_ESNEXT */
        2: 3152:          lexer_next_token (context_p);
        2: 3153:          scanner_check_directives (context_p, &scanner_context);
        2: 3154:          continue;
        -: 3155:        }
        2: 3156:        case SCAN_MODE_PROPERTY_NAME:
        -: 3157:        {
        2: 3158:          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -: 3159:
        2: 3160:          if (lexer_scan_identifier (context_p))
        -: 3161:          {
        2: 3162:            lexer_check_property_modifier (context_p);
        -: 3163:          }
        -: 3164:
        -: 3165:#if JERRY_ESNEXT
        2: 3166:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3167:          {
    #####: 3168:            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);
    #####: 3169:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3170:            break;
        -: 3171:          }
        -: 3172:
        2: 3173:          if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3174:          {
    #####: 3175:            *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_REST;
    #####: 3176:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3177:
    #####: 3178:            if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3179:            {
    #####: 3180:              scanner_context.mode = SCAN_MODE_BINDING;
        -: 3181:            }
    #####: 3182:            break;
        -: 3183:          }
        -: 3184:#endif /* JERRY_ESNEXT */
        -: 3185:
        2: 3186:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3187:          {
    #####: 3188:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 3189:            continue;
        -: 3190:          }
        -: 3191:
        2: 3192:          if (context_p->token.type == LEXER_PROPERTY_GETTER
        -: 3193:#if JERRY_ESNEXT
        2: 3194:              || context_p->token.type == LEXER_KEYW_ASYNC
        2: 3195:              || context_p->token.type == LEXER_MULTIPLY
        -: 3196:#endif /* JERRY_ESNEXT */
        2: 3197:              || context_p->token.type == LEXER_PROPERTY_SETTER)
        -: 3198:          {
    #####: 3199:            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 3200:
        -: 3201:#if JERRY_ESNEXT
    #####: 3202:            if (context_p->token.type == LEXER_MULTIPLY)
        -: 3203:            {
    #####: 3204:              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 3205:            }
    #####: 3206:            else if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 3207:            {
    #####: 3208:              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 3209:
    #####: 3210:              if (lexer_consume_generator (context_p))
        -: 3211:              {
    #####: 3212:                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 3213:              }
        -: 3214:            }
        -: 3215:#endif /* JERRY_ESNEXT */
        -: 3216:
    #####: 3217:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 3218:            lexer_scan_identifier (context_p);
        -: 3219:
        -: 3220:#if JERRY_ESNEXT
    #####: 3221:            if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3222:            {
    #####: 3223:              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 3224:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3225:              break;
        -: 3226:            }
        -: 3227:#endif /* JERRY_ESNEXT */
        -: 3228:
    #####: 3229:            if (context_p->token.type != LEXER_LITERAL)
        -: 3230:            {
    #####: 3231:              scanner_raise_error (context_p);
        -: 3232:            }
        -: 3233:
    #####: 3234:            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
    #####: 3235:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 3236:            break;
        -: 3237:          }
        -: 3238:
        2: 3239:          if (context_p->token.type != LEXER_LITERAL)
        -: 3240:          {
    #####: 3241:            scanner_raise_error (context_p);
        -: 3242:          }
        -: 3243:
        -: 3244:#if JERRY_ESNEXT
        2: 3245:          parser_line_counter_t start_line = context_p->token.line;
        2: 3246:          parser_line_counter_t start_column = context_p->token.column;
        2: 3247:          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 3248:#endif /* JERRY_ESNEXT */
        -: 3249:
        2: 3250:          lexer_next_token (context_p);
        -: 3251:
        -: 3252:#if JERRY_ESNEXT
        2: 3253:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 3254:          {
    #####: 3255:            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
        -: 3256:
    #####: 3257:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 3258:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 3259:            continue;
        -: 3260:          }
        -: 3261:
        2: 3262:          if (is_ident
        2: 3263:              && (context_p->token.type == LEXER_COMMA
        2: 3264:                  || context_p->token.type == LEXER_RIGHT_BRACE
        2: 3265:                  || context_p->token.type == LEXER_ASSIGN))
        -: 3266:          {
    #####: 3267:            context_p->source_p = context_p->token.lit_location.char_p;
    #####: 3268:            context_p->line = start_line;
    #####: 3269:            context_p->column = start_column;
        -: 3270:
    #####: 3271:            lexer_next_token (context_p);
        -: 3272:
    #####: 3273:            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL
        -: 3274:                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 3275:
    #####: 3276:            if (context_p->token.type != LEXER_LITERAL)
        -: 3277:            {
    #####: 3278:              scanner_raise_error (context_p);
        -: 3279:            }
        -: 3280:
    #####: 3281:            if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3282:            {
    #####: 3283:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 3284:              continue;
        -: 3285:            }
        -: 3286:
    #####: 3287:            scanner_add_reference (context_p, &scanner_context);
        -: 3288:
    #####: 3289:            lexer_next_token (context_p);
        -: 3290:
    #####: 3291:            if (context_p->token.type == LEXER_ASSIGN)
        -: 3292:            {
    #####: 3293:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3294:              break;
        -: 3295:            }
        -: 3296:
    #####: 3297:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 3298:            continue;
        -: 3299:          }
        -: 3300:#endif /* JERRY_ESNEXT */
        -: 3301:
        2: 3302:          if (context_p->token.type != LEXER_COLON)
        -: 3303:          {
    #####: 3304:            scanner_raise_error (context_p);
        -: 3305:          }
        -: 3306:
        2: 3307:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3308:
        -: 3309:#if JERRY_ESNEXT
        2: 3310:          if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3311:          {
    #####: 3312:            scanner_context.mode = SCAN_MODE_BINDING;
        -: 3313:          }
        -: 3314:#endif /* JERRY_ESNEXT */
        2: 3315:          break;
        -: 3316:        }
        -: 3317:#if JERRY_ESNEXT
    #####: 3318:        case SCAN_MODE_BINDING:
        -: 3319:        {
    #####: 3320:          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR
        -: 3321:                        || scanner_context.binding_type == SCANNER_BINDING_LET
        -: 3322:                        || scanner_context.binding_type == SCANNER_BINDING_CATCH
        -: 3323:                        || scanner_context.binding_type == SCANNER_BINDING_CONST
        -: 3324:                        || scanner_context.binding_type == SCANNER_BINDING_ARG
        -: 3325:                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);
        -: 3326:
    #####: 3327:          if (type == LEXER_THREE_DOTS)
        -: 3328:          {
    #####: 3329:            lexer_next_token (context_p);
    #####: 3330:            type = (lexer_token_type_t) context_p->token.type;
        -: 3331:          }
        -: 3332:
    #####: 3333:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 3334:          {
    #####: 3335:            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);
        -: 3336:
    #####: 3337:            if (type == LEXER_LEFT_SQUARE)
        -: 3338:            {
    #####: 3339:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 3340:              break;
        -: 3341:            }
        -: 3342:
    #####: 3343:            parser_stack_push_uint8 (context_p, 0);
    #####: 3344:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 3345:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 3346:            continue;
        -: 3347:          }
        -: 3348:
    #####: 3349:          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3350:          {
    #####: 3351:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3352:            continue;
        -: 3353:          }
        -: 3354:
    #####: 3355:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 3356:
    #####: 3357:          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 3358:
    #####: 3359:          if (scanner_context.binding_type == SCANNER_BINDING_VAR)
        -: 3360:          {
    #####: 3361:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 3362:            {
    #####: 3363:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
    #####: 3364:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 3365:
    #####: 3366:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 3367:              {
    #####: 3368:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 3369:              }
        -: 3370:            }
    #####: 3371:            break;
        -: 3372:          }
        -: 3373:
    #####: 3374:          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)
        -: 3375:          {
    #####: 3376:            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
        -: 3377:
    #####: 3378:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3379:            {
    #####: 3380:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3381:              break;
        -: 3382:            }
        -: 3383:          }
        -: 3384:          else
        -: 3385:          {
    #####: 3386:            scanner_detect_invalid_let (context_p, literal_p);
        -: 3387:
    #####: 3388:            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)
        -: 3389:            {
    #####: 3390:              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)
        -: 3391:                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));
        -: 3392:
    #####: 3393:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 3394:            }
        -: 3395:            else
        -: 3396:            {
    #####: 3397:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 3398:
    #####: 3399:              if (scanner_context.binding_type == SCANNER_BINDING_ARG)
        -: 3400:              {
    #####: 3401:                literal_p->type |= SCANNER_LITERAL_IS_ARG;
        -: 3402:
    #####: 3403:                if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3404:                {
    #####: 3405:                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3406:                  break;
        -: 3407:                }
        -: 3408:              }
        -: 3409:            }
        -: 3410:
    #####: 3411:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3412:            {
    #####: 3413:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3414:              break;
        -: 3415:            }
        -: 3416:          }
        -: 3417:
        -: 3418:          scanner_binding_item_t *binding_item_p;
    #####: 3419:          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));
        -: 3420:
    #####: 3421:          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;
    #####: 3422:          binding_item_p->literal_p = literal_p;
        -: 3423:
    #####: 3424:          scanner_context.active_binding_list_p->items_p = binding_item_p;
        -: 3425:
    #####: 3426:          lexer_next_token (context_p);
    #####: 3427:          if (context_p->token.type != LEXER_ASSIGN)
        -: 3428:          {
    #####: 3429:            continue;
        -: 3430:          }
        -: 3431:
    #####: 3432:          scanner_binding_literal_t binding_literal;
    #####: 3433:          binding_literal.literal_p = literal_p;
        -: 3434:
    #####: 3435:          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 3436:          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 3437:
    #####: 3438:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3439:          break;
        -: 3440:        }
        -: 3441:#endif /* JERRY_ESNEXT */
        -: 3442:      }
        -: 3443:
       50: 3444:      lexer_next_token (context_p);
        -: 3445:    }
        -: 3446:
        1: 3447:scan_completed:
        1: 3448:    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT
    #####: 3449:        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)
        -: 3450:    {
    #####: 3451:      scanner_raise_error (context_p);
        -: 3452:    }
        -: 3453:
        1: 3454:    scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3455:
        -: 3456:#if JERRY_ESNEXT
        1: 3457:    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);
        -: 3458:#endif /* JERRY_ESNEXT */
        1: 3459:    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);
        -: 3460:
        -: 3461:#ifndef JERRY_NDEBUG
        1: 3462:    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;
        -: 3463:#endif /* !JERRY_NDEBUG */
        -: 3464:  }
        -: 3465:  PARSER_CATCH
        -: 3466:  {
        -: 3467:#if JERRY_ESNEXT
    #####: 3468:    while (scanner_context.active_binding_list_p != NULL)
        -: 3469:    {
    #####: 3470:      scanner_pop_binding_list (&scanner_context);
        -: 3471:    }
        -: 3472:#endif /* JERRY_ESNEXT */
        -: 3473:
    #####: 3474:    if (JERRY_UNLIKELY (context_p->error != PARSER_ERR_OUT_OF_MEMORY))
        -: 3475:    {
        -: 3476:      /* Ignore the errors thrown by the lexer. */
    #####: 3477:      context_p->error = PARSER_ERR_NO_ERROR;
        -: 3478:
        -: 3479:      /* The following code may allocate memory, so it is enclosed in a try/catch. */
    #####: 3480:      PARSER_TRY (context_p->try_buffer)
        -: 3481:      {
        -: 3482:#if JERRY_ESNEXT
    #####: 3483:        if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)
        -: 3484:        {
    #####: 3485:          JERRY_ASSERT (scanner_context.async_source_p != NULL);
        -: 3486:
        -: 3487:          scanner_info_t *info_p;
    #####: 3488:          info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));
    #####: 3489:          info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;
        -: 3490:        }
        -: 3491:#endif /* JERRY_ESNEXT */
        -: 3492:
    #####: 3493:        while (scanner_context.active_literal_pool_p != NULL)
        -: 3494:        {
    #####: 3495:          scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3496:        }
        -: 3497:      }
        -: 3498:      PARSER_CATCH
        -: 3499:      {
    #####: 3500:        JERRY_ASSERT (context_p->error == PARSER_ERR_OUT_OF_MEMORY);
        -: 3501:      }
        -: 3502:      PARSER_TRY_END
        -: 3503:    }
        -: 3504:
    #####: 3505:    JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR || context_p->error == PARSER_ERR_OUT_OF_MEMORY);
        -: 3506:
    #####: 3507:    if (context_p->error == PARSER_ERR_OUT_OF_MEMORY)
        -: 3508:    {
    #####: 3509:      while (scanner_context.active_literal_pool_p != NULL)
        -: 3510:      {
    #####: 3511:        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 3512:
    #####: 3513:        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;
        -: 3514:
    #####: 3515:        parser_list_free (&literal_pool_p->literal_pool);
    #####: 3516:        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 3517:      }
        -: 3518:
    #####: 3519:      parser_stack_free (context_p);
    #####: 3520:      return;
        -: 3521:    }
        -: 3522:  }
        -: 3523:  PARSER_TRY_END
        -: 3524:
        1: 3525:  context_p->status_flags = scanner_context.context_status_flags;
        -: 3526:#if JERRY_ESNEXT
        1: 3527:  context_p->global_status_flags &= (uint32_t) ~ECMA_PARSE_INTERNAL_PRE_SCANNING;
        -: 3528:#endif /* JERRY_ESNEXT */
        1: 3529:  scanner_reverse_info_list (context_p);
        -: 3530:
        -: 3531:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 3532:  if (context_p->is_show_opcodes)
        -: 3533:  {
        -: 3534:    scanner_info_t *info_p = context_p->next_scanner_info_p;
        -: 3535:    const uint8_t *source_start_p = (context_p->arguments_start_p == NULL ? context_p->source_start_p
        -: 3536:                                                                          : context_p->arguments_start_p);
        -: 3537:
        -: 3538:    while (info_p->type != SCANNER_TYPE_END)
        -: 3539:    {
        -: 3540:      const char *name_p = NULL;
        -: 3541:      bool print_location = false;
        -: 3542:
        -: 3543:      switch (info_p->type)
        -: 3544:      {
        -: 3545:        case SCANNER_TYPE_END_ARGUMENTS:
        -: 3546:        {
        -: 3547:          JERRY_DEBUG_MSG ("  END_ARGUMENTS\n");
        -: 3548:          source_start_p = context_p->source_start_p;
        -: 3549:          break;
        -: 3550:        }
        -: 3551:        case SCANNER_TYPE_FUNCTION:
        -: 3552:        case SCANNER_TYPE_BLOCK:
        -: 3553:        {
        -: 3554:          const uint8_t *prev_source_p = info_p->source_p - 1;
        -: 3555:          const uint8_t *data_p;
        -: 3556:
        -: 3557:          if (info_p->type == SCANNER_TYPE_FUNCTION)
        -: 3558:          {
        -: 3559:            data_p = (const uint8_t *) (info_p + 1);
        -: 3560:
        -: 3561:            JERRY_DEBUG_MSG ("  FUNCTION: flags: 0x%x declarations: %d",
        -: 3562:                             (int) info_p->u8_arg,
        -: 3563:                             (int) info_p->u16_arg);
        -: 3564:          }
        -: 3565:          else
        -: 3566:          {
        -: 3567:            data_p = (const uint8_t *) (info_p + 1);
        -: 3568:
        -: 3569:            JERRY_DEBUG_MSG ("  BLOCK:");
        -: 3570:          }
        -: 3571:
        -: 3572:          JERRY_DEBUG_MSG (" source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3573:
        -: 3574:          while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 3575:          {
        -: 3576:            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -: 3577:            {
        -: 3578:              case SCANNER_STREAM_TYPE_HOLE:
        -: 3579:              {
        -: 3580:                JERRY_DEBUG_MSG ("    HOLE\n");
        -: 3581:                data_p++;
        -: 3582:                continue;
        -: 3583:              }
        -: 3584:#if JERRY_ESNEXT
        -: 3585:              case SCANNER_STREAM_TYPE_ARGUMENTS:
        -: 3586:              {
        -: 3587:                JERRY_DEBUG_MSG ("    ARGUMENTS%s%s\n",
        -: 3588:                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "",
        -: 3589:                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? " L" : "");
        -: 3590:                data_p++;
        -: 3591:                continue;
        -: 3592:              }
        -: 3593:              case SCANNER_STREAM_TYPE_ARGUMENTS_FUNC:
        -: 3594:              {
        -: 3595:                JERRY_DEBUG_MSG ("    ARGUMENTS_FUNC%s%s\n",
        -: 3596:                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "",
        -: 3597:                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? " L" : "");
        -: 3598:                data_p++;
        -: 3599:                continue;
        -: 3600:              }
        -: 3601:#else /* !JERRY_ESNEXT */
        -: 3602:              case SCANNER_STREAM_TYPE_ARGUMENTS:
        -: 3603:              {
        -: 3604:                JERRY_DEBUG_MSG ("    ARGUMENTS%s\n",
        -: 3605:                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "");
        -: 3606:                data_p++;
        -: 3607:                continue;
        -: 3608:              }
        -: 3609:#endif /* JERRY_ESNEXT */
        -: 3610:              case SCANNER_STREAM_TYPE_VAR:
        -: 3611:              {
        -: 3612:                JERRY_DEBUG_MSG ("    VAR ");
        -: 3613:                break;
        -: 3614:              }
        -: 3615:#if JERRY_ESNEXT
        -: 3616:              case SCANNER_STREAM_TYPE_LET:
        -: 3617:              {
        -: 3618:                JERRY_DEBUG_MSG ("    LET ");
        -: 3619:                break;
        -: 3620:              }
        -: 3621:              case SCANNER_STREAM_TYPE_CONST:
        -: 3622:              {
        -: 3623:                JERRY_DEBUG_MSG ("    CONST ");
        -: 3624:                break;
        -: 3625:              }
        -: 3626:              case SCANNER_STREAM_TYPE_LOCAL:
        -: 3627:              {
        -: 3628:                JERRY_DEBUG_MSG ("    LOCAL ");
        -: 3629:                break;
        -: 3630:              }
        -: 3631:#endif /* JERRY_ESNEXT */
        -: 3632:#if JERRY_MODULE_SYSTEM
        -: 3633:              case SCANNER_STREAM_TYPE_IMPORT:
        -: 3634:              {
        -: 3635:                JERRY_DEBUG_MSG ("    IMPORT ");
        -: 3636:                break;
        -: 3637:              }
        -: 3638:#endif /* JERRY_MODULE_SYSTEM */
        -: 3639:              case SCANNER_STREAM_TYPE_ARG:
        -: 3640:              {
        -: 3641:                JERRY_DEBUG_MSG ("    ARG ");
        -: 3642:                break;
        -: 3643:              }
        -: 3644:#if JERRY_ESNEXT
        -: 3645:              case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 3646:              {
        -: 3647:                JERRY_DEBUG_MSG ("    ARG_VAR ");
        -: 3648:                break;
        -: 3649:              }
        -: 3650:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 3651:              {
        -: 3652:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG ");
        -: 3653:                break;
        -: 3654:              }
        -: 3655:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 3656:              {
        -: 3657:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG_VAR ");
        -: 3658:                break;
        -: 3659:              }
        -: 3660:#endif /* JERRY_ESNEXT */
        -: 3661:              case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 3662:              {
        -: 3663:                JERRY_DEBUG_MSG ("    ARG_FUNC ");
        -: 3664:                break;
        -: 3665:              }
        -: 3666:#if JERRY_ESNEXT
        -: 3667:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 3668:              {
        -: 3669:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG_FUNC ");
        -: 3670:                break;
        -: 3671:              }
        -: 3672:#endif /* JERRY_ESNEXT */
        -: 3673:              case SCANNER_STREAM_TYPE_FUNC:
        -: 3674:              {
        -: 3675:                JERRY_DEBUG_MSG ("    FUNC ");
        -: 3676:                break;
        -: 3677:              }
        -: 3678:              default:
        -: 3679:              {
        -: 3680:                JERRY_UNREACHABLE ();
        -: 3681:                data_p++;
        -: 3682:                continue;
        -: 3683:              }
        -: 3684:            }
        -: 3685:
        -: 3686:            size_t length;
        -: 3687:
        -: 3688:            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 3689:            {
        -: 3690:              if (data_p[2] != 0)
        -: 3691:              {
        -: 3692:                prev_source_p += data_p[2];
        -: 3693:                length = 2 + 1;
        -: 3694:              }
        -: 3695:              else
        -: 3696:              {
        -: 3697:                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (uintptr_t));
        -: 3698:                length = 2 + 1 + sizeof (uintptr_t);
        -: 3699:              }
        -: 3700:            }
        -: 3701:            else
        -: 3702:            {
        -: 3703:              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 3704:
        -: 3705:              if (diff <= UINT8_MAX)
        -: 3706:              {
        -: 3707:                diff = -diff;
        -: 3708:              }
        -: 3709:
        -: 3710:              prev_source_p += diff;
        -: 3711:              length = 2 + 2;
        -: 3712:            }
        -: 3713:
        -: 3714:#if JERRY_ESNEXT
        -: 3715:            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 3716:            {
        -: 3717:              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 3718:              JERRY_DEBUG_MSG ("*");
        -: 3719:            }
        -: 3720:#endif /* JERRY_ESNEXT */
        -: 3721:
        -: 3722:            if (data_p[0] & SCANNER_STREAM_NO_REG)
        -: 3723:            {
        -: 3724:              JERRY_DEBUG_MSG ("* ");
        -: 3725:            }
        -: 3726:
        -: 3727:            JERRY_DEBUG_MSG ("'%.*s'\n", data_p[1], (char *) prev_source_p);
        -: 3728:            prev_source_p += data_p[1];
        -: 3729:            data_p += length;
        -: 3730:          }
        -: 3731:          break;
        -: 3732:        }
        -: 3733:        case SCANNER_TYPE_WHILE:
        -: 3734:        {
        -: 3735:          name_p = "WHILE";
        -: 3736:          print_location = true;
        -: 3737:          break;
        -: 3738:        }
        -: 3739:        case SCANNER_TYPE_FOR:
        -: 3740:        {
        -: 3741:          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;
        -: 3742:          JERRY_DEBUG_MSG ("  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\n",
        -: 3743:                           (int) (for_info_p->info.source_p - source_start_p),
        -: 3744:                           (int) (for_info_p->expression_location.source_p - source_start_p),
        -: 3745:                           (int) for_info_p->expression_location.line,
        -: 3746:                           (int) for_info_p->expression_location.column,
        -: 3747:                           (int) (for_info_p->end_location.source_p - source_start_p),
        -: 3748:                           (int) for_info_p->end_location.line,
        -: 3749:                           (int) for_info_p->end_location.column);
        -: 3750:          break;
        -: 3751:        }
        -: 3752:        case SCANNER_TYPE_FOR_IN:
        -: 3753:        {
        -: 3754:          name_p = "FOR-IN";
        -: 3755:          print_location = true;
        -: 3756:          break;
        -: 3757:        }
        -: 3758:#if JERRY_ESNEXT
        -: 3759:        case SCANNER_TYPE_FOR_OF:
        -: 3760:        {
        -: 3761:          name_p = "FOR-OF";
        -: 3762:          print_location = true;
        -: 3763:          break;
        -: 3764:        }
        -: 3765:#endif /* JERRY_ESNEXT */
        -: 3766:        case SCANNER_TYPE_SWITCH:
        -: 3767:        {
        -: 3768:          JERRY_DEBUG_MSG ("  SWITCH: source:%d\n",
        -: 3769:                           (int) (info_p->source_p - source_start_p));
        -: 3770:
        -: 3771:          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;
        -: 3772:
        -: 3773:          while (current_case_p != NULL)
        -: 3774:          {
        -: 3775:            JERRY_DEBUG_MSG ("    CASE: location:%d[%d:%d]\n",
        -: 3776:                             (int) (current_case_p->location.source_p - source_start_p),
        -: 3777:                             (int) current_case_p->location.line,
        -: 3778:                             (int) current_case_p->location.column);
        -: 3779:
        -: 3780:            current_case_p = current_case_p->next_p;
        -: 3781:          }
        -: 3782:          break;
        -: 3783:        }
        -: 3784:        case SCANNER_TYPE_CASE:
        -: 3785:        {
        -: 3786:          name_p = "CASE";
        -: 3787:          print_location = true;
        -: 3788:          break;
        -: 3789:        }
        -: 3790:#if JERRY_ESNEXT
        -: 3791:        case SCANNER_TYPE_INITIALIZER:
        -: 3792:        {
        -: 3793:          scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;
        -: 3794:          JERRY_DEBUG_MSG ("  INITIALIZER: flags: 0x%x source:%d location:%d[%d:%d]\n",
        -: 3795:                           (int) info_p->u8_arg,
        -: 3796:                           (int) (location_info_p->info.source_p - source_start_p),
        -: 3797:                           (int) (location_info_p->location.source_p - source_start_p),
        -: 3798:                           (int) location_info_p->location.line,
        -: 3799:                           (int) location_info_p->location.column);
        -: 3800:          break;
        -: 3801:        }
        -: 3802:        case SCANNER_TYPE_CLASS_CONSTRUCTOR:
        -: 3803:        {
        -: 3804:          JERRY_DEBUG_MSG ("  CLASS_CONSTRUCTOR: source:%d\n",
        -: 3805:                           (int) (info_p->source_p - source_start_p));
        -: 3806:          print_location = false;
        -: 3807:          break;
        -: 3808:        }
        -: 3809:        case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:
        -: 3810:        {
        -: 3811:          name_p = "SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END";
        -: 3812:          print_location = true;
        -: 3813:          break;
        -: 3814:        }
        -: 3815:        case SCANNER_TYPE_LET_EXPRESSION:
        -: 3816:        {
        -: 3817:          JERRY_DEBUG_MSG ("  LET_EXPRESSION: source:%d\n",
        -: 3818:                           (int) (info_p->source_p - source_start_p));
        -: 3819:          break;
        -: 3820:        }
        -: 3821:        case SCANNER_TYPE_ERR_REDECLARED:
        -: 3822:        {
        -: 3823:          JERRY_DEBUG_MSG ("  ERR_REDECLARED: source:%d\n",
        -: 3824:                           (int) (info_p->source_p - source_start_p));
        -: 3825:          break;
        -: 3826:        }
        -: 3827:        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:
        -: 3828:        {
        -: 3829:          JERRY_DEBUG_MSG ("  ERR_ASYNC_FUNCTION: source:%d\n",
        -: 3830:                           (int) (info_p->source_p - source_start_p));
        -: 3831:          break;
        -: 3832:        }
        -: 3833:        case SCANNER_TYPE_LITERAL_FLAGS:
        -: 3834:        {
        -: 3835:          JERRY_DEBUG_MSG ("  SCANNER_TYPE_LITERAL_FLAGS: flags: 0x%x source:%d\n",
        -: 3836:                           (int) info_p->u8_arg,
        -: 3837:                           (int) (info_p->source_p - source_start_p));
        -: 3838:          print_location = false;
        -: 3839:          break;
        -: 3840:        }
        -: 3841:        case SCANNER_TYPE_EXPORT_MODULE_SPECIFIER:
        -: 3842:        {
        -: 3843:          JERRY_DEBUG_MSG ("  EXPORT_WITH_MODULE_SPECIFIER: source:%d\n",
        -: 3844:                           (int) (info_p->source_p - source_start_p));
        -: 3845:          print_location = false;
        -: 3846:          break;
        -: 3847:        }
        -: 3848:#endif /* JERRY_ESNEXT */
        -: 3849:      }
        -: 3850:
        -: 3851:      if (print_location)
        -: 3852:      {
        -: 3853:        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;
        -: 3854:        JERRY_DEBUG_MSG ("  %s: source:%d location:%d[%d:%d]\n",
        -: 3855:                         name_p,
        -: 3856:                         (int) (location_info_p->info.source_p - source_start_p),
        -: 3857:                         (int) (location_info_p->location.source_p - source_start_p),
        -: 3858:                         (int) location_info_p->location.line,
        -: 3859:                         (int) location_info_p->location.column);
        -: 3860:      }
        -: 3861:
        -: 3862:      info_p = info_p->next_p;
        -: 3863:    }
        -: 3864:
        -: 3865:    JERRY_DEBUG_MSG ("\n--- Scanning end ---\n\n");
        -: 3866:  }
        -: 3867:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 3868:
        1: 3869:  parser_stack_free (context_p);
        -: 3870:} /* scanner_scan_all */
        -: 3871:
        -: 3872:/**
        -: 3873: * @}
        -: 3874: * @}
        -: 3875: * @}
        -: 3876: */
        -: 3877:
        -: 3878:#endif /* JERRY_PARSER */
