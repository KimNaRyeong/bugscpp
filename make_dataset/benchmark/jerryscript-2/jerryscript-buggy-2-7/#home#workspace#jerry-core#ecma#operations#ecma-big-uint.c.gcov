        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-big-uint.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-big-uint.h"
        -:   17:#include "ecma-helpers.h"
        -:   18:#include "jmem.h"
        -:   19:#include "lit-char-helpers.h"
        -:   20:
        -:   21:#if JERRY_BUILTIN_BIGINT
        -:   22:
        -:   23:JERRY_STATIC_ASSERT (sizeof (ecma_bigint_two_digits_t) == 2 * sizeof (ecma_bigint_digit_t),
        -:   24:                     ecma_big_int_two_digits_must_be_twice_as_long_as_ecma_big_int_digit);
        -:   25:
        -:   26:JERRY_STATIC_ASSERT ((1 << ECMA_BIGINT_DIGIT_SHIFT) == (8 * sizeof (ecma_bigint_digit_t)),
        -:   27:                     ecma_bigint_digit_shift_is_incorrect);
        -:   28:
        -:   29:JERRY_STATIC_ASSERT ((ECMA_BIG_UINT_BITWISE_DECREASE_LEFT << 1) == ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT,
        -:   30:                     ecma_big_uint_bitwise_left_and_right_sub_option_bits_must_follow_each_other);
        -:   31:
        -:   32:/**
        -:   33: * Create a new BigInt value
        -:   34: *
        -:   35: * @return new BigInt value, NULL on error
        -:   36: */
        -:   37:ecma_extended_primitive_t *
    #####:   38:ecma_bigint_create (uint32_t size) /**< size of the new BigInt value */
        -:   39:{
    #####:   40:  JERRY_ASSERT (size > 0);
    #####:   41:  JERRY_ASSERT ((size % sizeof (ecma_bigint_digit_t)) == 0);
        -:   42:
    #####:   43:  if (JERRY_UNLIKELY (size > ECMA_BIGINT_MAX_SIZE))
        -:   44:  {
    #####:   45:    return NULL;
        -:   46:  }
        -:   47:
        -:   48:  ecma_extended_primitive_t *value_p;
        -:   49:
    #####:   50:  size_t mem_size = ECMA_BIGINT_GET_BYTE_SIZE (size) + sizeof (ecma_extended_primitive_t);
    #####:   51:  value_p = (ecma_extended_primitive_t *) jmem_heap_alloc_block_null_on_error (mem_size);
        -:   52:
    #####:   53:  if (JERRY_UNLIKELY (value_p == NULL))
        -:   54:  {
    #####:   55:    return NULL;
        -:   56:  }
        -:   57:
    #####:   58:  value_p->refs_and_type = ECMA_EXTENDED_PRIMITIVE_REF_ONE | ECMA_TYPE_BIGINT;
    #####:   59:  value_p->u.bigint_sign_and_size = size;
    #####:   60:  return value_p;
        -:   61:} /* ecma_bigint_create */
        -:   62:
        -:   63:/**
        -:   64: * Extend a BigUInt value with a new data prefix value
        -:   65: *
        -:   66: * @return new BigUInt value, NULL on error
        -:   67: */
        -:   68:ecma_extended_primitive_t *
    #####:   69:ecma_big_uint_extend (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:   70:                      ecma_bigint_digit_t digit) /**< new digit */
        -:   71:{
    #####:   72:  uint32_t old_size = ECMA_BIGINT_GET_SIZE (value_p);
        -:   73:
    #####:   74:  if (ECMA_BIGINT_SIZE_IS_ODD (old_size))
        -:   75:  {
    #####:   76:    value_p->u.bigint_sign_and_size += (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:   77:    *ECMA_BIGINT_GET_DIGITS (value_p, old_size) = digit;
    #####:   78:    return value_p;
        -:   79:  }
        -:   80:
    #####:   81:  ecma_extended_primitive_t *result_p = ecma_bigint_create (old_size + (uint32_t) sizeof (ecma_bigint_digit_t));
        -:   82:
    #####:   83:  if (JERRY_UNLIKELY (result_p == NULL))
        -:   84:  {
    #####:   85:    ecma_deref_bigint (value_p);
    #####:   86:    return NULL;
        -:   87:  }
        -:   88:
    #####:   89:  memcpy (result_p + 1, value_p + 1, old_size);
    #####:   90:  ecma_deref_bigint (value_p);
        -:   91:
    #####:   92:  *ECMA_BIGINT_GET_DIGITS (result_p, old_size) = digit;
    #####:   93:  return result_p;
        -:   94:} /* ecma_big_uint_extend */
        -:   95:
        -:   96:/**
        -:   97: * Count the number of leading zero bits of a digit
        -:   98: *
        -:   99: * return number of leading zero bits
        -:  100: */
        -:  101:ecma_bigint_digit_t
    #####:  102:ecma_big_uint_count_leading_zero (ecma_bigint_digit_t digit) /**< digit value */
        -:  103:{
    #####:  104:  ecma_bigint_digit_t shift = 4 * sizeof (ecma_bigint_digit_t);
    #####:  105:  ecma_bigint_digit_t result = 8 * sizeof (ecma_bigint_digit_t);
        -:  106:
        -:  107:  do
        -:  108:  {
    #####:  109:    ecma_bigint_digit_t value = digit >> shift;
    #####:  110:    if (value > 0)
        -:  111:    {
    #####:  112:      digit = value;
    #####:  113:      result -= shift;
        -:  114:    }
    #####:  115:    shift >>= 1;
        -:  116:  }
    #####:  117:  while (shift > 0);
        -:  118:
    #####:  119:  return result - digit;
        -:  120:} /* ecma_big_uint_count_leading_zero */
        -:  121:
        -:  122:/**
        -:  123: * Helper function which discards the leading zero digits of a BigUInt value
        -:  124: *
        -:  125: * @return new BigUInt value, NULL on error
        -:  126: */
        -:  127:static ecma_extended_primitive_t *
    #####:  128:ecma_big_uint_normalize_result (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  129:                                ecma_bigint_digit_t *last_digit_p) /**< points to the end of BigUInt */
        -:  130:{
    #####:  131:  JERRY_ASSERT (last_digit_p[-1] == 0);
        -:  132:
    #####:  133:  ecma_bigint_digit_t *first_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  134:
        -:  135:  /* The following code is tricky. The value stored in first_digit_p[-1] is the size
        -:  136:   * of the BigUInt value, and it cannot be zero. Hence the loop below will terminate. */
    #####:  137:  JERRY_ASSERT (first_digit_p[-1] != 0);
        -:  138:
        -:  139:  do
        -:  140:  {
    #####:  141:    --last_digit_p;
        -:  142:  }
    #####:  143:  while (last_digit_p[-1] == 0);
        -:  144:
    #####:  145:  JERRY_ASSERT (last_digit_p >= first_digit_p);
        -:  146:
    #####:  147:  if (first_digit_p == last_digit_p)
        -:  148:  {
    #####:  149:    ecma_deref_bigint (value_p);
    #####:  150:    return ECMA_BIGINT_POINTER_TO_ZERO;
        -:  151:  }
        -:  152:
    #####:  153:  uint32_t new_size = (uint32_t) ((uint8_t *) last_digit_p - (uint8_t *) first_digit_p);
        -:  154:
    #####:  155:  if (ECMA_BIGINT_SIZE_IS_ODD (new_size)
    #####:  156:      && ((new_size + sizeof (ecma_bigint_digit_t)) == ECMA_BIGINT_GET_SIZE (value_p)))
        -:  157:  {
    #####:  158:    value_p->u.bigint_sign_and_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:  159:    return value_p;
        -:  160:  }
        -:  161:
    #####:  162:  ecma_extended_primitive_t *result_p = ecma_bigint_create (new_size);
        -:  163:
    #####:  164:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  165:  {
    #####:  166:    ecma_deref_bigint (value_p);
    #####:  167:    return NULL;
        -:  168:  }
        -:  169:
    #####:  170:  memcpy (ECMA_BIGINT_GET_DIGITS (result_p, 0), ECMA_BIGINT_GET_DIGITS (value_p, 0), new_size);
    #####:  171:  ecma_deref_bigint (value_p);
        -:  172:
    #####:  173:  return result_p;
        -:  174:} /* ecma_big_uint_normalize_result */
        -:  175:
        -:  176:/**
        -:  177: * Helper function which increases the result by 1 and extends or shrinks the BigUInt when necessary
        -:  178: *
        -:  179: * @return new BigUInt value, NULL on error
        -:  180: */
        -:  181:static ecma_extended_primitive_t *
    #####:  182:ecma_big_uint_increase_result (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  183:{
    #####:  184:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  185:
    #####:  186:  JERRY_ASSERT (size > 0);
        -:  187:
    #####:  188:  ecma_bigint_digit_t *first_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  189:  ecma_bigint_digit_t *last_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  190:
    #####:  191:  while (*first_digit_p == ~((ecma_bigint_digit_t) 0))
        -:  192:  {
    #####:  193:    *first_digit_p++ = 0;
        -:  194:
    #####:  195:    if (first_digit_p == last_digit_p)
        -:  196:    {
    #####:  197:      return ecma_big_uint_extend (value_p, 1);
        -:  198:    }
        -:  199:  }
        -:  200:
    #####:  201:  (*first_digit_p)++;
        -:  202:
    #####:  203:  if (last_digit_p[-1] != 0)
        -:  204:  {
    #####:  205:    return value_p;
        -:  206:  }
        -:  207:
    #####:  208:  return ecma_big_uint_normalize_result (value_p, last_digit_p);
        -:  209:} /* ecma_big_uint_increase_result */
        -:  210:
        -:  211:/**
        -:  212: * Compare two BigUInt numbers
        -:  213: *
        -:  214: * return -1, if left value < right value, 0 if they are equal, and 1 otherwise
        -:  215: */
        -:  216:int
    #####:  217:ecma_big_uint_compare (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  218:                       ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  219:{
    #####:  220:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  221:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  222:
    #####:  223:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  224:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  225:
    #####:  226:  if (left_size > right_size)
        -:  227:  {
    #####:  228:    return 1;
        -:  229:  }
        -:  230:
    #####:  231:  if (left_size < right_size)
        -:  232:  {
    #####:  233:    return -1;
        -:  234:  }
        -:  235:
    #####:  236:  ecma_bigint_digit_t *start_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  237:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####:  238:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, left_size);
        -:  239:
        -:  240:  do
        -:  241:  {
    #####:  242:    ecma_bigint_digit_t left_value = *(--left_p);
    #####:  243:    ecma_bigint_digit_t right_value = *(--right_p);
        -:  244:
    #####:  245:    if (left_value < right_value)
        -:  246:    {
    #####:  247:      return -1;
        -:  248:    }
        -:  249:
    #####:  250:    if (left_value > right_value)
        -:  251:    {
    #####:  252:      return 1;
        -:  253:    }
        -:  254:  }
    #####:  255:  while (left_p > start_p);
        -:  256:
    #####:  257:  return 0;
        -:  258:} /* ecma_big_uint_compare */
        -:  259:
        -:  260:/**
        -:  261: * In-place multiply and addition operation with digit
        -:  262: *
        -:  263: * return updated value on success, NULL if no memory is available
        -:  264: */
        -:  265:ecma_extended_primitive_t *
    #####:  266:ecma_big_uint_mul_digit (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  267:                         ecma_bigint_digit_t mul, /**< multiply value */
        -:  268:                         ecma_bigint_digit_t add) /**< addition value */
        -:  269:{
    #####:  270:  JERRY_ASSERT (mul > 1);
    #####:  271:  JERRY_ASSERT (add < mul);
        -:  272:
    #####:  273:  if (JERRY_UNLIKELY (value_p == NULL))
        -:  274:  {
    #####:  275:    JERRY_ASSERT (add > 0);
        -:  276:
    #####:  277:    value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:  278:
    #####:  279:    if (JERRY_UNLIKELY (value_p == NULL))
        -:  280:    {
    #####:  281:      return NULL;
        -:  282:    }
        -:  283:
    #####:  284:    *ECMA_BIGINT_GET_DIGITS (value_p, 0) = add;
    #####:  285:    return value_p;
        -:  286:  }
        -:  287:
    #####:  288:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  289:
    #####:  290:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  291:
    #####:  292:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  293:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
    #####:  294:  ecma_bigint_digit_t carry = add;
        -:  295:
        -:  296:  do
        -:  297:  {
    #####:  298:    ecma_bigint_two_digits_t multiply_result = ((ecma_bigint_two_digits_t) *current_p) * mul;
        -:  299:    ecma_bigint_digit_t multiply_result_low, new_carry;
        -:  300:
    #####:  301:    multiply_result_low = (ecma_bigint_digit_t) multiply_result;
    #####:  302:    new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  303:
    #####:  304:    multiply_result_low += carry;
    #####:  305:    if (multiply_result_low < carry)
        -:  306:    {
    #####:  307:      new_carry++;
        -:  308:    }
        -:  309:
    #####:  310:    *current_p++ = multiply_result_low;
    #####:  311:    carry = new_carry;
        -:  312:  }
    #####:  313:  while (current_p < end_p);
        -:  314:
    #####:  315:  if (carry == 0)
        -:  316:  {
    #####:  317:    return value_p;
        -:  318:  }
        -:  319:
    #####:  320:  return ecma_big_uint_extend (value_p, carry);
        -:  321:} /* ecma_big_uint_mul_digit */
        -:  322:
        -:  323:/**
        -:  324: * Convert a BigUInt to a human readable number
        -:  325: *
        -:  326: * return char sequence on success, NULL otherwise
        -:  327: */
        -:  328:lit_utf8_byte_t *
    #####:  329:ecma_big_uint_to_string (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  330:                         uint32_t radix, /**< radix number between 2 and 36 */
        -:  331:                         uint32_t *char_start_p, /**< [out] start offset of numbers */
        -:  332:                         uint32_t *char_size_p) /**< [out] size of the output buffer */
        -:  333:{
    #####:  334:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  335:
    #####:  336:  JERRY_ASSERT (radix >= 2 && radix <= 36);
    #####:  337:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  338:
    #####:  339:  uint32_t max_size = size * 8;
        -:  340:
    #####:  341:  if (radix < 16)
        -:  342:  {
    #####:  343:    if (radix >= 8)
        -:  344:    {
        -:  345:      /* Most frequent case. */
    #####:  346:      max_size = (max_size + 2) / 3;
        -:  347:    }
    #####:  348:    else if (radix >= 4)
        -:  349:    {
    #####:  350:      max_size = (max_size + 1) >> 1;
        -:  351:    }
        -:  352:  }
    #####:  353:  else if (radix < 32)
        -:  354:  {
    #####:  355:    max_size = (max_size + 3) >> 2;
        -:  356:  }
        -:  357:  else
        -:  358:  {
    #####:  359:    max_size = (max_size + 4) / 5;
        -:  360:  }
        -:  361:
        -:  362:  /* This space can be used to store a sign. */
    #####:  363:  max_size += (uint32_t) (2 * sizeof (ecma_bigint_digit_t) - 1);
    #####:  364:  max_size &= ~(uint32_t) (sizeof (ecma_bigint_digit_t) - 1);
    #####:  365:  *char_size_p = max_size;
        -:  366:
    #####:  367:  lit_utf8_byte_t *result_p = (lit_utf8_byte_t *) jmem_heap_alloc_block_null_on_error (max_size);
        -:  368:
    #####:  369:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  370:  {
    #####:  371:    return NULL;
        -:  372:  }
        -:  373:
    #####:  374:  memcpy (result_p, value_p + 1, size);
        -:  375:
    #####:  376:  ecma_bigint_digit_t *start_p = (ecma_bigint_digit_t *) (result_p + size);
    #####:  377:  ecma_bigint_digit_t *end_p = (ecma_bigint_digit_t *) result_p;
    #####:  378:  lit_utf8_byte_t *string_p = result_p + max_size;
        -:  379:
        -:  380:  do
        -:  381:  {
    #####:  382:    ecma_bigint_digit_t *current_p = (ecma_bigint_digit_t *) start_p;
    #####:  383:    ecma_bigint_digit_t remainder = 0;
        -:  384:
        -:  385:    if (sizeof (uintptr_t) == sizeof (ecma_bigint_two_digits_t))
        -:  386:    {
        -:  387:      do
        -:  388:      {
    #####:  389:        ecma_bigint_two_digits_t result = *(--current_p) | ECMA_BIGINT_HIGH_DIGIT (remainder);
        -:  390:
    #####:  391:        *current_p = (ecma_bigint_digit_t) (result / radix);
    #####:  392:        remainder = (ecma_bigint_digit_t) (result % radix);
        -:  393:      }
    #####:  394:      while (current_p > end_p);
        -:  395:    }
        -:  396:    else
        -:  397:    {
    #####:  398:      if (ECMA_BIGINT_SIZE_IS_ODD ((uintptr_t) current_p - (uintptr_t) end_p))
        -:  399:      {
    #####:  400:        ecma_bigint_digit_t result = *(--current_p);
    #####:  401:        *current_p = result / radix;
    #####:  402:        remainder = result % radix;
        -:  403:      }
        -:  404:
    #####:  405:      while (current_p > end_p)
        -:  406:      {
        -:  407:        /* The following algorithm splits the 64 bit input into three numbers, extend
        -:  408:         * them with remainder, divide them by radix, and updates the three bit ranges
        -:  409:         * corresponding to the three numbers. */
        -:  410:
    #####:  411:        const uint32_t extract_bits_low = 10;
    #####:  412:        const uint32_t extract_bits_low_mask = (uint32_t) ((1 << extract_bits_low) - 1);
    #####:  413:        const uint32_t extract_bits_high = (uint32_t) ((sizeof (ecma_bigint_digit_t) * 8) - extract_bits_low);
    #####:  414:        const uint32_t extract_bits_high_mask = (uint32_t) ((1 << extract_bits_high) - 1);
        -:  415:
    #####:  416:        ecma_bigint_digit_t result_high = current_p[-1];
    #####:  417:        ecma_bigint_digit_t result_mid = (result_high & extract_bits_low_mask) << extract_bits_low;
        -:  418:
    #####:  419:        result_high = (result_high >> extract_bits_low) | (remainder << extract_bits_high);
    #####:  420:        result_mid |= (result_high % radix) << (extract_bits_low * 2);
    #####:  421:        result_high = (result_high / radix) << extract_bits_low;
        -:  422:
    #####:  423:        ecma_bigint_digit_t result_low = current_p[-2];
    #####:  424:        result_mid |= result_low >> extract_bits_high;
    #####:  425:        result_low = (result_low & extract_bits_high_mask) | ((result_mid % radix) << extract_bits_high);
        -:  426:
    #####:  427:        result_mid = result_mid / radix;
        -:  428:
    #####:  429:        current_p[-1] = result_high | (result_mid >> extract_bits_low);
    #####:  430:        current_p[-2] = (result_low / radix) | (result_mid << extract_bits_high);
        -:  431:
    #####:  432:        remainder = result_low % radix;
    #####:  433:        current_p -= 2;
        -:  434:      }
        -:  435:    }
        -:  436:
    #####:  437:    *(--string_p) = (lit_utf8_byte_t) ((remainder < 10) ? (remainder + LIT_CHAR_0)
    #####:  438:                                                        : (remainder + (LIT_CHAR_LOWERCASE_A - 10)));
    #####:  439:    JERRY_ASSERT (string_p >= (lit_utf8_byte_t *) start_p);
        -:  440:
    #####:  441:    if (start_p[-1] == 0)
        -:  442:    {
    #####:  443:      start_p--;
        -:  444:    }
        -:  445:  }
    #####:  446:  while (start_p > end_p);
        -:  447:
    #####:  448:  *char_start_p = (uint32_t) (string_p - result_p);
    #####:  449:  return result_p;
        -:  450:} /* ecma_big_uint_to_string */
        -:  451:
        -:  452:/**
        -:  453: * Increase the value of a BigUInt value by 1
        -:  454: *
        -:  455: * return new BigUInt value, NULL on error
        -:  456: */
        -:  457:ecma_extended_primitive_t *
    #####:  458:ecma_big_uint_increase (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  459:{
    #####:  460:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  461:
    #####:  462:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  463:
    #####:  464:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  465:  ecma_bigint_digit_t *digits_end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  466:
    #####:  467:  if (JERRY_UNLIKELY (digits_p[0] == ~((ecma_bigint_digit_t) 0) && digits_end_p[-1] == ~((ecma_bigint_digit_t) 0)))
        -:  468:  {
        -:  469:    do
        -:  470:    {
    #####:  471:      digits_p++;
        -:  472:    }
    #####:  473:    while (digits_p < digits_end_p && digits_p[0] == ~((ecma_bigint_digit_t) 0));
        -:  474:
    #####:  475:    if (digits_p == digits_end_p)
        -:  476:    {
        -:  477:      ecma_extended_primitive_t *result_value_p;
    #####:  478:      result_value_p = ecma_bigint_create ((uint32_t) (size + sizeof (ecma_bigint_digit_t)));
        -:  479:
    #####:  480:      if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  481:      {
    #####:  482:        return NULL;
        -:  483:      }
        -:  484:
    #####:  485:      memset (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), 0, size);
    #####:  486:      *ECMA_BIGINT_GET_DIGITS (result_value_p, size) = 1;
    #####:  487:      return result_value_p;
        -:  488:    }
        -:  489:
    #####:  490:    digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  491:  }
        -:  492:
    #####:  493:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  494:
    #####:  495:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  496:  {
    #####:  497:    return NULL;
        -:  498:  }
        -:  499:
    #####:  500:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  501:
    #####:  502:  while (digits_p[0] == ~((ecma_bigint_digit_t) 0))
        -:  503:  {
    #####:  504:    digits_p++;
    #####:  505:    *result_p++ = 0;
        -:  506:  }
        -:  507:
    #####:  508:  *result_p++ = (*digits_p++) + 1;
        -:  509:
    #####:  510:  if (digits_p < digits_end_p)
        -:  511:  {
    #####:  512:    memcpy (result_p, digits_p, (size_t) ((uint8_t *) digits_end_p - (uint8_t *) digits_p));
        -:  513:  }
    #####:  514:  return result_value_p;
        -:  515:} /* ecma_big_uint_increase */
        -:  516:
        -:  517:/**
        -:  518: * Decrease the value of a BigUInt value by 1
        -:  519: *
        -:  520: * return new BigUInt value, NULL on error
        -:  521: */
        -:  522:ecma_extended_primitive_t *
    #####:  523:ecma_big_uint_decrease (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  524:{
    #####:  525:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  526:
    #####:  527:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  528:
    #####:  529:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  530:  ecma_bigint_digit_t *digits_end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  531:
    #####:  532:  JERRY_ASSERT (size > sizeof (ecma_bigint_digit_t) || *digits_p > 1);
        -:  533:
    #####:  534:  if (JERRY_UNLIKELY (digits_p[0] == 0 && digits_end_p[-1] == 1))
        -:  535:  {
        -:  536:    do
        -:  537:    {
    #####:  538:      digits_p++;
    #####:  539:      JERRY_ASSERT (digits_p < digits_end_p);
        -:  540:    }
    #####:  541:    while (digits_p[0] == 0);
        -:  542:
    #####:  543:    if (digits_p + 1 == digits_end_p)
        -:  544:    {
    #####:  545:      size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:  546:      ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  547:
    #####:  548:      if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  549:      {
    #####:  550:        return NULL;
        -:  551:      }
        -:  552:
    #####:  553:      memset (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), 0xff, size);
    #####:  554:      return result_value_p;
        -:  555:    }
        -:  556:
    #####:  557:    digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  558:  }
        -:  559:
    #####:  560:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  561:
    #####:  562:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  563:  {
    #####:  564:    return NULL;
        -:  565:  }
        -:  566:
    #####:  567:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  568:
    #####:  569:  while (digits_p[0] == 0)
        -:  570:  {
    #####:  571:    digits_p++;
    #####:  572:    *result_p++ = ~((ecma_bigint_digit_t) 0);
        -:  573:  }
        -:  574:
    #####:  575:  *result_p++ = (*digits_p++) - 1;
        -:  576:
    #####:  577:  if (digits_p < digits_end_p)
        -:  578:  {
    #####:  579:    memcpy (result_p, digits_p, (size_t) ((uint8_t *) digits_end_p - (uint8_t *) digits_p));
        -:  580:  }
    #####:  581:  return result_value_p;
        -:  582:} /* ecma_big_uint_decrease */
        -:  583:
        -:  584:/**
        -:  585: * Add right BigUInt value to the left BigUInt value
        -:  586: *
        -:  587: * return new BigUInt value, NULL on error
        -:  588: */
        -:  589:ecma_extended_primitive_t *
    #####:  590:ecma_big_uint_add (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  591:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  592:{
    #####:  593:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  594:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  595:
    #####:  596:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  597:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  598:
    #####:  599:  if (left_size < right_size)
        -:  600:  {
        -:  601:    /* Swap values. */
    #####:  602:    ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####:  603:    left_value_p = right_value_p;
    #####:  604:    right_value_p = tmp_value_p;
        -:  605:
    #####:  606:    uint32_t tmp_size = left_size;
    #####:  607:    left_size = right_size;
    #####:  608:    right_size = tmp_size;
        -:  609:  }
        -:  610:
    #####:  611:  ecma_extended_primitive_t *result_p = ecma_bigint_create (left_size);
        -:  612:
    #####:  613:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  614:  {
    #####:  615:    return NULL;
        -:  616:  }
        -:  617:
    #####:  618:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  619:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_p, right_size);
    #####:  620:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  621:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  622:  ecma_bigint_digit_t carry = 0;
        -:  623:
    #####:  624:  left_size -= right_size;
        -:  625:
        -:  626:  do
        -:  627:  {
    #####:  628:    ecma_bigint_digit_t left = *left_p++;
        -:  629:
    #####:  630:    if (carry == 0 || left != ~(ecma_bigint_digit_t) 0)
        -:  631:    {
    #####:  632:      left += carry;
    #####:  633:      carry = 0;
        -:  634:    }
        -:  635:    else
        -:  636:    {
    #####:  637:      left = 0;
    #####:  638:      carry = 1;
        -:  639:    }
        -:  640:
    #####:  641:    ecma_bigint_digit_t right = *right_p++;
    #####:  642:    left += right;
        -:  643:
    #####:  644:    if (left < right)
        -:  645:    {
    #####:  646:      JERRY_ASSERT (carry == 0);
    #####:  647:      carry = 1;
        -:  648:    }
        -:  649:
    #####:  650:    *current_p++ = left;
        -:  651:  }
    #####:  652:  while (current_p < end_p);
        -:  653:
    #####:  654:  end_p = (ecma_bigint_digit_t *) (((uint8_t *) end_p) + left_size);
        -:  655:
    #####:  656:  if (carry != 0)
        -:  657:  {
        -:  658:    while (true)
    #####:  659:    {
    #####:  660:      if (JERRY_UNLIKELY (current_p == end_p))
        -:  661:      {
    #####:  662:        return ecma_big_uint_extend (result_p, 1);
        -:  663:      }
        -:  664:
    #####:  665:      ecma_bigint_digit_t value = *left_p++;
        -:  666:
    #####:  667:      if (value != ~(ecma_bigint_digit_t) 0)
        -:  668:      {
    #####:  669:        *current_p++ = value + 1;
    #####:  670:        break;
        -:  671:      }
        -:  672:
    #####:  673:      *current_p++ = 0;
        -:  674:    }
        -:  675:  }
        -:  676:
    #####:  677:  if (current_p < end_p)
        -:  678:  {
    #####:  679:    memcpy (current_p, left_p, (size_t) ((uint8_t *) end_p - (uint8_t *) current_p));
        -:  680:  }
        -:  681:
    #####:  682:  return result_p;
        -:  683:} /* ecma_big_uint_add */
        -:  684:
        -:  685:/**
        -:  686: * Substract right BigUInt value from the left BigUInt value
        -:  687: *
        -:  688: * return new BigUInt value, NULL on error
        -:  689: */
        -:  690:ecma_extended_primitive_t *
    #####:  691:ecma_big_uint_sub (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  692:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  693:{
    #####:  694:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  695:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  696:
    #####:  697:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  698:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
    #####:  699:  JERRY_ASSERT (left_size >= right_size);
        -:  700:
    #####:  701:  ecma_extended_primitive_t *result_p = ecma_bigint_create (left_size);
        -:  702:
    #####:  703:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  704:  {
    #####:  705:    return NULL;
        -:  706:  }
        -:  707:
    #####:  708:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  709:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_p, right_size);
    #####:  710:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  711:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  712:  ecma_bigint_digit_t carry = 0;
        -:  713:
    #####:  714:  left_size -= right_size;
        -:  715:
        -:  716:  do
        -:  717:  {
    #####:  718:    ecma_bigint_digit_t left = *left_p++;
    #####:  719:    ecma_bigint_digit_t right = *right_p++;
        -:  720:
    #####:  721:    if (carry == 0 || left != 0)
        -:  722:    {
    #####:  723:      left -= carry;
    #####:  724:      carry = left < right;
        -:  725:    }
        -:  726:    else
        -:  727:    {
    #####:  728:      left = ~(ecma_bigint_digit_t) 0;
    #####:  729:      carry = 1;
        -:  730:    }
        -:  731:
    #####:  732:    *current_p++ = left - right;
        -:  733:  }
    #####:  734:  while (current_p < end_p);
        -:  735:
    #####:  736:  end_p = (ecma_bigint_digit_t *) (((uint8_t *) end_p) + left_size);
        -:  737:
    #####:  738:  if (carry != 0)
        -:  739:  {
        -:  740:    while (true)
    #####:  741:    {
    #####:  742:      JERRY_ASSERT (current_p < end_p);
        -:  743:
    #####:  744:      ecma_bigint_digit_t value = *left_p++;
        -:  745:
    #####:  746:      if (value != 0)
        -:  747:      {
    #####:  748:        *current_p++ = value - 1;
    #####:  749:        break;
        -:  750:      }
        -:  751:
    #####:  752:      *current_p++ = ~(ecma_bigint_digit_t) 0;
        -:  753:    }
        -:  754:  }
        -:  755:
    #####:  756:  if (current_p < end_p)
        -:  757:  {
    #####:  758:    memcpy (current_p, left_p, (size_t) ((uint8_t *) end_p - (uint8_t *) current_p));
    #####:  759:    return result_p;
        -:  760:  }
        -:  761:
    #####:  762:  if (current_p[-1] != 0)
        -:  763:  {
    #####:  764:    return result_p;
        -:  765:  }
        -:  766:
    #####:  767:  return ecma_big_uint_normalize_result (result_p, current_p);
        -:  768:} /* ecma_big_uint_sub */
        -:  769:
        -:  770:/**
        -:  771: * Multiply two BigUInt values
        -:  772: *
        -:  773: * return new BigUInt value, NULL on error
        -:  774: */
        -:  775:ecma_extended_primitive_t *
    #####:  776:ecma_big_uint_mul (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  777:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  778:{
    #####:  779:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  780:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  781:
    #####:  782:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  783:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  784:
    #####:  785:  if (left_size < right_size)
        -:  786:  {
        -:  787:    /* Swap values. */
    #####:  788:    ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####:  789:    left_value_p = right_value_p;
    #####:  790:    right_value_p = tmp_value_p;
        -:  791:
    #####:  792:    uint32_t tmp_size = left_size;
    #####:  793:    left_size = right_size;
    #####:  794:    right_size = tmp_size;
        -:  795:  }
        -:  796:
    #####:  797:  uint32_t result_size = left_size + right_size - (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  798:
    #####:  799:  ecma_extended_primitive_t *result_p = ecma_bigint_create (result_size);
        -:  800:
    #####:  801:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  802:  {
    #####:  803:    return NULL;
        -:  804:  }
        -:  805:
    #####:  806:  memset (ECMA_BIGINT_GET_DIGITS (result_p, 0), 0, result_size);
        -:  807:
        -:  808:  /* Lower amount of space is allocated by default. This value provides extra space if needed. */
    #####:  809:  ecma_bigint_digit_t extra_space[1] = { 0 };
        -:  810:
    #####:  811:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  812:  ecma_bigint_digit_t *right_end_p = ECMA_BIGINT_GET_DIGITS (right_value_p, right_size);
    #####:  813:  ecma_bigint_digit_t *left_start_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  814:  ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
        -:  815:
    #####:  816:  ecma_bigint_digit_t *result_start_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  817:  ecma_bigint_digit_t *result_end_p = ECMA_BIGINT_GET_DIGITS (result_p, result_size);
        -:  818:
        -:  819:  do
        -:  820:  {
    #####:  821:    ecma_bigint_two_digits_t right = *right_p++;
        -:  822:
    #####:  823:    if (right == 0)
        -:  824:    {
    #####:  825:      result_start_p++;
    #####:  826:      continue;
        -:  827:    }
        -:  828:
    #####:  829:    ecma_bigint_digit_t *left_p = left_start_p;
    #####:  830:    ecma_bigint_digit_t *destination_p = result_start_p;
    #####:  831:    ecma_bigint_digit_t carry = 0;
        -:  832:
        -:  833:    do
        -:  834:    {
    #####:  835:      JERRY_ASSERT (destination_p != (ecma_bigint_digit_t *) (extra_space + 1));
        -:  836:
        -:  837:      ecma_bigint_two_digits_t multiply_result;
        -:  838:      ecma_bigint_digit_t multiply_result_low, new_carry;
    #####:  839:      ecma_bigint_digit_t value = *destination_p;
        -:  840:
    #####:  841:      multiply_result = ((ecma_bigint_two_digits_t) (*left_p++)) * ((ecma_bigint_two_digits_t) right);
    #####:  842:      multiply_result_low = (ecma_bigint_digit_t) multiply_result;
    #####:  843:      value += multiply_result_low;
    #####:  844:      new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  845:
        -:  846:      /* The new_carry can never overflow because:
        -:  847:       *   a) If left or right is less than 0xff..ff, new_carry will be less than or equal to
        -:  848:       *      0xff...fd, and increasing it by maximum of two (carries) cannot overflow.
        -:  849:       *   b) If left and right are both equal to 0xff..ff, multiply_result_low will be 1,
        -:  850:       *      and computing value + carry + 1 can only increase new_carry at most once. */
        -:  851:
    #####:  852:      if (value < multiply_result_low)
        -:  853:      {
    #####:  854:        JERRY_ASSERT (new_carry < ~(ecma_bigint_digit_t) 0);
    #####:  855:        new_carry++;
        -:  856:      }
        -:  857:
    #####:  858:      value += carry;
        -:  859:
    #####:  860:      if (value < carry)
        -:  861:      {
    #####:  862:        JERRY_ASSERT (new_carry < ~(ecma_bigint_digit_t) 0);
    #####:  863:        new_carry++;
        -:  864:      }
        -:  865:
    #####:  866:      carry = new_carry;
    #####:  867:      *destination_p++ = value;
        -:  868:
    #####:  869:      if (destination_p == result_end_p)
        -:  870:      {
    #####:  871:        destination_p = (ecma_bigint_digit_t *) extra_space;
        -:  872:      }
        -:  873:    }
    #####:  874:    while (left_p < left_end_p);
        -:  875:
    #####:  876:    while (carry > 0)
        -:  877:    {
    #####:  878:      JERRY_ASSERT (destination_p != (ecma_bigint_digit_t *) (extra_space + 1));
        -:  879:
    #####:  880:      ecma_bigint_digit_t value = *destination_p;
        -:  881:
    #####:  882:      value += carry;
    #####:  883:      carry = (value < carry);
        -:  884:
    #####:  885:      *destination_p++ = value;
        -:  886:
    #####:  887:      if (destination_p == result_end_p)
        -:  888:      {
    #####:  889:        destination_p = (ecma_bigint_digit_t *) extra_space;
        -:  890:      }
        -:  891:    }
        -:  892:
    #####:  893:    result_start_p++;
        -:  894:  }
    #####:  895:  while (right_p < right_end_p);
        -:  896:
    #####:  897:  if (extra_space[0] == 0)
        -:  898:  {
    #####:  899:    return result_p;
        -:  900:  }
        -:  901:
    #####:  902:  return ecma_big_uint_extend (result_p, extra_space[0]);
        -:  903:} /* ecma_big_uint_mul */
        -:  904:
        -:  905:/**
        -:  906: * Divide left BigUInt value with right digit value
        -:  907: *
        -:  908: * return new BigUInt value, NULL on error
        -:  909: */
        -:  910:static ecma_extended_primitive_t *
    #####:  911:ecma_big_uint_div_digit (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  912:                         ecma_bigint_digit_t divisor_digit, /**< divisor value */
        -:  913:                         bool is_mod) /**< true if return with remainder */
        -:  914:{
    #####:  915:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
        -:  916:
    #####:  917:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  918:  JERRY_ASSERT (divisor_digit > 0);
        -:  919:
    #####:  920:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size - sizeof (ecma_bigint_digit_t));
    #####:  921:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
        -:  922:
    #####:  923:  ecma_bigint_digit_t last_digit = *left_p;
    #####:  924:  ecma_bigint_digit_t remainder = last_digit % divisor_digit;
        -:  925:
    #####:  926:  last_digit = last_digit / divisor_digit;
        -:  927:
    #####:  928:  ecma_extended_primitive_t *result_p = NULL;
    #####:  929:  ecma_bigint_digit_t *current_p = NULL;
        -:  930:
    #####:  931:  if (!is_mod)
        -:  932:  {
    #####:  933:    ecma_bigint_digit_t result_size = left_size;
        -:  934:
    #####:  935:    if (last_digit == 0)
        -:  936:    {
    #####:  937:      result_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  938:    }
        -:  939:
    #####:  940:    result_p = ecma_bigint_create (result_size);
        -:  941:
    #####:  942:    if (JERRY_UNLIKELY (result_p == NULL))
        -:  943:    {
    #####:  944:      return NULL;
        -:  945:    }
        -:  946:
    #####:  947:    current_p = ECMA_BIGINT_GET_DIGITS (result_p, result_size);
        -:  948:
    #####:  949:    if (last_digit != 0)
        -:  950:    {
    #####:  951:      *(--current_p) = last_digit;
        -:  952:    }
        -:  953:  }
        -:  954:
    #####:  955:  while (left_p > end_p)
        -:  956:  {
    #####:  957:    const uint32_t shift = 1 << ECMA_BIGINT_DIGIT_SHIFT;
        -:  958:
    #####:  959:    ecma_bigint_two_digits_t result = *(--left_p) | (((ecma_bigint_two_digits_t) remainder) << shift);
        -:  960:
    #####:  961:    if (!is_mod)
        -:  962:    {
    #####:  963:      *(--current_p) = (ecma_bigint_digit_t) (result / divisor_digit);
        -:  964:    }
        -:  965:
    #####:  966:    remainder = (ecma_bigint_digit_t) (result % divisor_digit);
        -:  967:  }
        -:  968:
    #####:  969:  if (!is_mod)
        -:  970:  {
    #####:  971:    JERRY_ASSERT (current_p == ECMA_BIGINT_GET_DIGITS (result_p, 0));
    #####:  972:    return result_p;
        -:  973:  }
        -:  974:
    #####:  975:  if (remainder == 0)
        -:  976:  {
    #####:  977:    return ECMA_BIGINT_POINTER_TO_ZERO;
        -:  978:  }
        -:  979:
    #####:  980:  result_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:  981:
    #####:  982:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  983:  {
    #####:  984:    return NULL;
        -:  985:  }
        -:  986:
    #####:  987:  *ECMA_BIGINT_GET_DIGITS (result_p, 0) = remainder;
    #####:  988:  return result_p;
        -:  989:} /* ecma_big_uint_div_digit */
        -:  990:
        -:  991:/**
        -:  992: * Shift left a BigUInt value by a digit value
        -:  993: *
        -:  994: * return newly allocated buffer, NULL on error
        -:  995: */
        -:  996:static ecma_bigint_digit_t *
    #####:  997:ecma_big_uint_div_shift_left (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  998:                              ecma_bigint_digit_t shift_left, /**< left shift */
        -:  999:                              bool extend) /**< extend the result with an extra digit */
        -: 1000:{
    #####: 1001:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -: 1002:
    #####: 1003:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -: 1004:
    #####: 1005:  ecma_bigint_digit_t *source_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####: 1006:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -: 1007:
    #####: 1008:  if (extend)
        -: 1009:  {
    #####: 1010:    size += (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1011:  }
        -: 1012:
    #####: 1013:  ecma_bigint_digit_t *result_p = (ecma_bigint_digit_t *) jmem_heap_alloc_block_null_on_error (size);
        -: 1014:
    #####: 1015:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1016:  {
    #####: 1017:    return result_p;
        -: 1018:  }
        -: 1019:
    #####: 1020:  if (shift_left == 0)
        -: 1021:  {
    #####: 1022:    JERRY_ASSERT (extend);
        -: 1023:
    #####: 1024:    size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####: 1025:    *(ecma_bigint_digit_t *) (((uint8_t *) result_p) + size) = 0;
        -: 1026:
    #####: 1027:    memcpy (result_p, source_p, size);
    #####: 1028:    return result_p;
        -: 1029:  }
        -: 1030:
    #####: 1031:  ecma_bigint_digit_t *destination_p = result_p;
    #####: 1032:  ecma_bigint_digit_t carry = 0;
    #####: 1033:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -: 1034:
        -: 1035:  do
        -: 1036:  {
    #####: 1037:    ecma_bigint_digit_t value = *source_p++;
        -: 1038:
    #####: 1039:    *destination_p++ = (value << shift_left) | carry;
    #####: 1040:    carry = value >> shift_right;
        -: 1041:  }
    #####: 1042:  while (source_p < end_p);
        -: 1043:
    #####: 1044:  if (extend)
        -: 1045:  {
    #####: 1046:    *destination_p++ = carry;
        -: 1047:  }
        -: 1048:
    #####: 1049:  return result_p;
        -: 1050:} /* ecma_big_uint_div_shift_left */
        -: 1051:
        -: 1052:/**
        -: 1053: * Divide left BigUInt value with right BigUInt value
        -: 1054: *
        -: 1055: * return new BigUInt value, NULL on error
        -: 1056: */
        -: 1057:ecma_extended_primitive_t *
    #####: 1058:ecma_big_uint_div_mod (ecma_extended_primitive_t *dividend_value_p, /**< divider BigUInt value */
        -: 1059:                       ecma_extended_primitive_t *divisor_value_p, /**< divisor BigUInt value */
        -: 1060:                       bool is_mod) /**< true if return with remainder instead of quotient */
        -: 1061:{
        -: 1062:  /* This algorithm is based on Donald Knuth’s "Algorithm D" */
    #####: 1063:  uint32_t divisor_size = ECMA_BIGINT_GET_SIZE (divisor_value_p);
        -: 1064:
    #####: 1065:  JERRY_ASSERT (divisor_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (divisor_value_p, divisor_size) != 0);
        -: 1066:
        -: 1067:  /* The divisor must have at least two digits, so the single digit case is handled separately. */
    #####: 1068:  if (divisor_size == sizeof (ecma_bigint_digit_t))
        -: 1069:  {
    #####: 1070:    return ecma_big_uint_div_digit (dividend_value_p, *ECMA_BIGINT_GET_DIGITS (divisor_value_p, 0), is_mod);
        -: 1071:  }
        -: 1072:
        -: 1073:  /* D1. [Normalize] */
    #####: 1074:  ecma_bigint_digit_t divisor_high = ECMA_BIGINT_GET_LAST_DIGIT (divisor_value_p, divisor_size);
    #####: 1075:  ecma_bigint_digit_t shift_left = ecma_big_uint_count_leading_zero (divisor_high);
    #####: 1076:  ecma_bigint_digit_t *buffer_p = ecma_big_uint_div_shift_left (dividend_value_p, shift_left, true);
        -: 1077:
    #####: 1078:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1079:  {
    #####: 1080:    return NULL;
        -: 1081:  }
        -: 1082:
    #####: 1083:  uint32_t dividend_size = ECMA_BIGINT_GET_SIZE (dividend_value_p);
    #####: 1084:  ecma_extended_primitive_t *result_p = NULL;
        -: 1085:  ecma_bigint_digit_t *divisor_p;
        -: 1086:
    #####: 1087:  JERRY_ASSERT (dividend_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (dividend_value_p, dividend_size) != 0);
    #####: 1088:  JERRY_ASSERT (dividend_size >= divisor_size);
        -: 1089:
    #####: 1090:  if (shift_left > 0)
        -: 1091:  {
    #####: 1092:    divisor_p = ecma_big_uint_div_shift_left (divisor_value_p, shift_left, false);
        -: 1093:
    #####: 1094:    if (JERRY_UNLIKELY (divisor_p == NULL))
        -: 1095:    {
    #####: 1096:      goto error;
        -: 1097:    }
        -: 1098:  }
        -: 1099:  else
        -: 1100:  {
    #####: 1101:    divisor_p = ECMA_BIGINT_GET_DIGITS (divisor_value_p, 0);
        -: 1102:  }
        -: 1103:
    #####: 1104:  ecma_bigint_digit_t *dividend_end_p = (ecma_bigint_digit_t *) (((uint8_t *) buffer_p) + dividend_size);
    #####: 1105:  ecma_bigint_digit_t *dividend_p = (ecma_bigint_digit_t *) (((uint8_t *) dividend_end_p) - divisor_size);
    #####: 1106:  ecma_bigint_digit_t *divisor_end_p = (ecma_bigint_digit_t *) (((uint8_t *) divisor_p) + divisor_size);
    #####: 1107:  ecma_bigint_digit_t divisor_low = divisor_end_p[-2];
        -: 1108:
    #####: 1109:  divisor_high = divisor_end_p[-1];
    #####: 1110:  JERRY_ASSERT ((divisor_high & (((ecma_bigint_digit_t) 1) << (8 * sizeof (ecma_bigint_digit_t) - 1))) != 0);
        -: 1111:
        -: 1112:  do
        -: 1113:  {
        -: 1114:    /* D3. [Calculate Q′] */
        -: 1115:    ecma_bigint_digit_t result_div;
        -: 1116:
        -: 1117:    /* This do-while(false) statement allows local declarations and early exit. */
        -: 1118:    do
        -: 1119:    {
        -: 1120:      ecma_bigint_digit_t result_mod;
        -: 1121:
    #####: 1122:      if (dividend_end_p[0] < divisor_high)
        -: 1123:      {
    #####: 1124:        ecma_bigint_two_digits_t dividend = dividend_end_p[-1] | ECMA_BIGINT_HIGH_DIGIT (dividend_end_p[0]);
    #####: 1125:        result_div = (ecma_bigint_digit_t) (dividend / divisor_high);
    #####: 1126:        result_mod = (ecma_bigint_digit_t) (dividend % divisor_high);
        -: 1127:      }
        -: 1128:      else
        -: 1129:      {
    #####: 1130:        JERRY_ASSERT (dividend_end_p[0] == divisor_high && dividend_end_p[-1] < divisor_high);
        -: 1131:
    #####: 1132:        result_div = ~((ecma_bigint_digit_t) 0);
    #####: 1133:        result_mod = dividend_end_p[-1] + divisor_high;
        -: 1134:
    #####: 1135:        if (result_mod < divisor_high)
        -: 1136:        {
    #####: 1137:          break;
        -: 1138:        }
        -: 1139:      }
        -: 1140:
    #####: 1141:      ecma_bigint_two_digits_t low_digits = ((ecma_bigint_two_digits_t) result_div) * divisor_low;
        -: 1142:
    #####: 1143:      while (low_digits > (ECMA_BIGINT_HIGH_DIGIT (result_mod) | divisor_low))
        -: 1144:      {
    #####: 1145:        result_div--;
    #####: 1146:        result_mod += divisor_high;
        -: 1147:
        -: 1148:        /* If result_mod becomes a two digit long number, the condition of the loop must be true,
        -: 1149:         * so the loop can be aborted. This loop stops after maximum of two iterations, since
        -: 1150:         * the highest bit of divisor_high is set. */
    #####: 1151:        if (result_mod < divisor_high)
        -: 1152:        {
    #####: 1153:          break;
        -: 1154:        }
        -: 1155:
        -: 1156:        /* Subtraction is faster than recomputing result_div * divisor_low. */
    #####: 1157:        low_digits -= divisor_low;
        -: 1158:      }
        -: 1159:    }
        -: 1160:    while (false);
        -: 1161:
        -: 1162:    /* D4. [Multiply and subtract] */
    #####: 1163:    ecma_bigint_digit_t *destination_p = dividend_p;
    #####: 1164:    ecma_bigint_digit_t *source_p = divisor_p;
    #####: 1165:    ecma_bigint_digit_t carry = 0;
        -: 1166:
        -: 1167:    do
        -: 1168:    {
    #####: 1169:      ecma_bigint_two_digits_t multiply_result = ((ecma_bigint_two_digits_t) (*source_p++)) * result_div;
        -: 1170:      ecma_bigint_digit_t multiply_result_low, new_carry;
    #####: 1171:      ecma_bigint_digit_t value = *destination_p;
        -: 1172:
        -: 1173:      /* The new carry never overflows. See the comment in ecma_big_uint_mul. */
    #####: 1174:      new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
    #####: 1175:      multiply_result_low = (ecma_bigint_digit_t) multiply_result;
        -: 1176:
    #####: 1177:      if (value < multiply_result_low)
        -: 1178:      {
    #####: 1179:        new_carry++;
        -: 1180:      }
        -: 1181:
    #####: 1182:      value -= multiply_result_low;
        -: 1183:
    #####: 1184:      if (value < carry)
        -: 1185:      {
    #####: 1186:        new_carry++;
        -: 1187:      }
        -: 1188:
    #####: 1189:      *destination_p++ = value - carry;
    #####: 1190:      carry = new_carry;
        -: 1191:    }
    #####: 1192:    while (source_p < divisor_end_p);
        -: 1193:
    #####: 1194:    bool negative_result = *destination_p < carry;
    #####: 1195:    *destination_p -= carry;
        -: 1196:
    #####: 1197:    if (negative_result)
        -: 1198:    {
        -: 1199:      /* D6. [Add back] */
    #####: 1200:      result_div--;
        -: 1201:
    #####: 1202:      destination_p = dividend_p;
    #####: 1203:      source_p = divisor_p;
    #####: 1204:      carry = 0;
        -: 1205:
        -: 1206:      do
        -: 1207:      {
    #####: 1208:        ecma_bigint_digit_t left = *destination_p;
        -: 1209:
    #####: 1210:        if (carry == 0 || left != ~(ecma_bigint_digit_t) 0)
        -: 1211:        {
    #####: 1212:          left += carry;
    #####: 1213:          carry = 0;
        -: 1214:        }
        -: 1215:        else
        -: 1216:        {
    #####: 1217:          left = 0;
    #####: 1218:          carry = 1;
        -: 1219:        }
        -: 1220:
    #####: 1221:        ecma_bigint_digit_t right = *source_p++;
    #####: 1222:        left += right;
        -: 1223:
    #####: 1224:        if (left < right)
        -: 1225:        {
    #####: 1226:          JERRY_ASSERT (carry == 0);
    #####: 1227:          carry = 1;
        -: 1228:        }
        -: 1229:
    #####: 1230:        *destination_p++ = left;
        -: 1231:      }
    #####: 1232:      while (source_p < divisor_end_p);
        -: 1233:    }
        -: 1234:
    #####: 1235:    *dividend_end_p = result_div;
        -: 1236:
    #####: 1237:    dividend_p--;
    #####: 1238:    dividend_end_p--;
        -: 1239:  }
    #####: 1240:  while (dividend_p >= buffer_p);
        -: 1241:
        -: 1242:  ecma_bigint_digit_t *source_p;
        -: 1243:  ecma_bigint_digit_t *source_end_p;
        -: 1244:
    #####: 1245:  if (is_mod)
        -: 1246:  {
    #####: 1247:    source_p = buffer_p;
    #####: 1248:    source_end_p = dividend_end_p;
        -: 1249:
    #####: 1250:    while (source_end_p > source_p && *source_end_p == 0)
        -: 1251:    {
    #####: 1252:      source_end_p--;
        -: 1253:    }
        -: 1254:
    #####: 1255:    if ((*source_end_p >> shift_left) != 0)
        -: 1256:    {
    #####: 1257:      source_end_p++;
        -: 1258:      /* This is required to reset carry below. */
    #####: 1259:      *source_end_p = 0;
        -: 1260:    }
        -: 1261:  }
        -: 1262:  else
        -: 1263:  {
    #####: 1264:    source_p = dividend_end_p + 1;
    #####: 1265:    source_end_p = (ecma_bigint_digit_t *) (((uint8_t *) buffer_p) + dividend_size);
        -: 1266:
    #####: 1267:    if (*source_end_p != 0)
        -: 1268:    {
    #####: 1269:      source_end_p++;
        -: 1270:    }
        -: 1271:  }
        -: 1272:
    #####: 1273:  result_p = ECMA_BIGINT_POINTER_TO_ZERO;
        -: 1274:
    #####: 1275:  if (source_p < source_end_p)
        -: 1276:  {
    #####: 1277:    result_p = ecma_bigint_create ((uint32_t) ((uint8_t *) source_end_p - (uint8_t *) source_p));
        -: 1278:
    #####: 1279:    if (result_p != NULL)
        -: 1280:    {
    #####: 1281:      ecma_bigint_digit_t *destination_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
        -: 1282:
    #####: 1283:      if (is_mod && shift_left > 0)
    #####: 1284:      {
    #####: 1285:        ecma_bigint_digit_t shift_right = shift_left;
        -: 1286:
    #####: 1287:        shift_left = (ecma_bigint_digit_t) (8 * (sizeof (ecma_bigint_digit_t)) - shift_left);
    #####: 1288:        destination_p += source_end_p - source_p;
        -: 1289:
    #####: 1290:        ecma_bigint_digit_t carry = *source_end_p << shift_left;
        -: 1291:
        -: 1292:        do
        -: 1293:        {
    #####: 1294:          ecma_bigint_digit_t value = *(--source_end_p);
        -: 1295:
    #####: 1296:          *(--destination_p) = (value >> shift_right) | carry;
    #####: 1297:          carry = value << shift_left;
        -: 1298:        }
    #####: 1299:        while (source_end_p > source_p);
        -: 1300:      }
        -: 1301:      else
        -: 1302:      {
    #####: 1303:        memcpy (destination_p, source_p, (size_t) ((uint8_t *) source_end_p - (uint8_t *) source_p));
        -: 1304:      }
        -: 1305:    }
        -: 1306:  }
        -: 1307:
    #####: 1308:error:
    #####: 1309:  jmem_heap_free_block (buffer_p, dividend_size + sizeof (ecma_bigint_digit_t));
        -: 1310:
    #####: 1311:  if (shift_left > 0 && divisor_p != NULL)
        -: 1312:  {
    #####: 1313:    jmem_heap_free_block (divisor_p, divisor_size);
        -: 1314:  }
        -: 1315:
    #####: 1316:  return result_p;
        -: 1317:} /* ecma_big_uint_div_mod */
        -: 1318:
        -: 1319:/**
        -: 1320: * Shift left BigUInt values by an uint32 value
        -: 1321: *
        -: 1322: * return new BigUInt value, NULL on error
        -: 1323: */
        -: 1324:ecma_extended_primitive_t *
    #####: 1325:ecma_big_uint_shift_left (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1326:                          uint32_t right_value) /**< shift value */
        -: 1327:{
    #####: 1328:  JERRY_ASSERT (right_value > 0);
        -: 1329:
    #####: 1330:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1331:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
        -: 1332:
    #####: 1333:  uint32_t zero_size = (right_value >> ECMA_BIGINT_DIGIT_SHIFT) * (uint32_t) sizeof (ecma_bigint_digit_t);
    #####: 1334:  uint32_t result_size = left_size + zero_size;
        -: 1335:
    #####: 1336:  uint32_t shift_left = right_value & ((1 << ECMA_BIGINT_DIGIT_SHIFT) - 1);
    #####: 1337:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -: 1338:
    #####: 1339:  if (shift_left > 0 && (ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) >> shift_right) != 0)
        -: 1340:  {
    #####: 1341:    result_size += (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1342:  }
        -: 1343:
    #####: 1344:  if (result_size > ECMA_BIGINT_MAX_SIZE)
        -: 1345:  {
    #####: 1346:    return NULL;
        -: 1347:  }
        -: 1348:
    #####: 1349:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (result_size);
        -: 1350:
    #####: 1351:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1352:  {
    #####: 1353:    return NULL;
        -: 1354:  }
        -: 1355:
    #####: 1356:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1357:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -: 1358:
    #####: 1359:  if (zero_size > 0)
        -: 1360:  {
    #####: 1361:    memset (result_p, 0, zero_size);
    #####: 1362:    result_p = (ecma_bigint_digit_t *) (((uint8_t *) result_p) + zero_size);
        -: 1363:  }
        -: 1364:
    #####: 1365:  if (shift_left == 0)
        -: 1366:  {
        -: 1367:    /* Shift by full digits. */
    #####: 1368:    memcpy (result_p, left_p, left_size);
    #####: 1369:    return result_value_p;
        -: 1370:  }
        -: 1371:
    #####: 1372:  ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####: 1373:  ecma_bigint_digit_t carry = 0;
        -: 1374:
        -: 1375:  do
        -: 1376:  {
    #####: 1377:    ecma_bigint_digit_t value = *left_p++;
        -: 1378:
    #####: 1379:    *result_p++ = (value << shift_left) | carry;
    #####: 1380:    carry = value >> shift_right;
        -: 1381:  }
    #####: 1382:  while (left_p < left_end_p);
        -: 1383:
    #####: 1384:  if (carry > 0)
        -: 1385:  {
    #####: 1386:    *result_p = carry;
        -: 1387:  }
        -: 1388:
    #####: 1389:  return result_value_p;
        -: 1390:} /* ecma_big_uint_shift_left */
        -: 1391:
        -: 1392:/**
        -: 1393: * Shift right BigUInt values by an uint32 value
        -: 1394: *
        -: 1395: * @return new BigUInt value, NULL on error
        -: 1396: */
        -: 1397:ecma_extended_primitive_t *
    #####: 1398:ecma_big_uint_shift_right (ecma_extended_primitive_t *left_value_p,  /**< left BigUInt value */
        -: 1399:                           uint32_t right_value, /**< shift value */
        -: 1400:                           bool increase_result) /**< increase result */
        -: 1401:{
    #####: 1402:  JERRY_ASSERT (right_value > 0);
        -: 1403:
    #####: 1404:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1405:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
        -: 1406:
    #####: 1407:  uint32_t crop_size = (right_value >> ECMA_BIGINT_DIGIT_SHIFT) * (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1408:
    #####: 1409:  uint32_t shift_right = right_value & ((1 << ECMA_BIGINT_DIGIT_SHIFT) - 1);
    #####: 1410:  uint32_t shift_left = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_right;
    #####: 1411:  ecma_bigint_digit_t carry = 0;
        -: 1412:
    #####: 1413:  if (shift_right > 0
    #####: 1414:      && (ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) >> shift_right) == 0)
        -: 1415:  {
    #####: 1416:    carry = ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) << shift_left;
    #####: 1417:    left_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1418:  }
        -: 1419:
    #####: 1420:  if (left_size <= crop_size)
        -: 1421:  {
    #####: 1422:    if (JERRY_LIKELY (!increase_result))
        -: 1423:    {
    #####: 1424:      return ECMA_BIGINT_POINTER_TO_ZERO;
        -: 1425:    }
        -: 1426:
    #####: 1427:    ecma_extended_primitive_t *result_value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
    #####: 1428:    if (result_value_p != NULL)
        -: 1429:    {
    #####: 1430:      *ECMA_BIGINT_GET_DIGITS (result_value_p, 0) = 1;
        -: 1431:    }
    #####: 1432:    return result_value_p;
        -: 1433:  }
        -: 1434:
    #####: 1435:  if (JERRY_UNLIKELY (increase_result)
    #####: 1436:      && (shift_right == 0
    #####: 1437:          || (*ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size) << shift_left) == 0))
        -: 1438:  {
    #####: 1439:    ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1440:    ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size);
        -: 1441:
    #####: 1442:    while (left_p < left_end_p)
        -: 1443:    {
    #####: 1444:      if (*left_p != 0)
        -: 1445:      {
    #####: 1446:        break;
        -: 1447:      }
    #####: 1448:      left_p++;
        -: 1449:    }
        -: 1450:
    #####: 1451:    if (left_p == left_end_p)
        -: 1452:    {
    #####: 1453:      increase_result = false;
        -: 1454:    }
        -: 1455:  }
        -: 1456:
    #####: 1457:  uint32_t size = left_size - crop_size;
    #####: 1458:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -: 1459:
    #####: 1460:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1461:  {
    #####: 1462:    return NULL;
        -: 1463:  }
        -: 1464:
    #####: 1465:  if (shift_right == 0)
        -: 1466:  {
    #####: 1467:    memcpy (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size), size);
        -: 1468:
    #####: 1469:    if (JERRY_LIKELY (!increase_result))
        -: 1470:    {
    #####: 1471:      return result_value_p;
        -: 1472:    }
    #####: 1473:    return ecma_big_uint_increase_result (result_value_p);
        -: 1474:  }
        -: 1475:
    #####: 1476:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####: 1477:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, size);
    #####: 1478:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -: 1479:
        -: 1480:  do
        -: 1481:  {
    #####: 1482:    ecma_bigint_digit_t value = *(--left_p);
        -: 1483:
    #####: 1484:    *(--result_p) = (value >> shift_right) | carry;
    #####: 1485:    carry = value << shift_left;
        -: 1486:  }
    #####: 1487:  while (result_p > end_p);
        -: 1488:
    #####: 1489:  if (JERRY_LIKELY (!increase_result))
        -: 1490:  {
    #####: 1491:    return result_value_p;
        -: 1492:  }
    #####: 1493:  return ecma_big_uint_increase_result (result_value_p);
        -: 1494:} /* ecma_big_uint_shift_right */
        -: 1495:
        -: 1496:#if JERRY_ESNEXT
        -: 1497:
        -: 1498:/**
        -: 1499: * Compute the left value raised to the power of right value
        -: 1500: *
        -: 1501: * return new BigUInt value, NULL on error
        -: 1502: */
        -: 1503:ecma_extended_primitive_t *
    #####: 1504:ecma_big_uint_pow (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1505:                   uint32_t right_value) /**< power value */
        -: 1506:{
    #####: 1507:  ecma_extended_primitive_t *result_p = ECMA_BIGINT_NUMBER_IS_ODD (right_value) ? left_value_p : NULL;
    #####: 1508:  ecma_extended_primitive_t *square_p = left_value_p;
        -: 1509:
    #####: 1510:  JERRY_ASSERT (right_value >= 2);
        -: 1511:
        -: 1512:  while (true)
    #####: 1513:  {
    #####: 1514:    ecma_extended_primitive_t *new_square_p = ecma_big_uint_mul (square_p, square_p);
        -: 1515:
    #####: 1516:    if (JERRY_UNLIKELY (new_square_p == NULL))
        -: 1517:    {
    #####: 1518:      if (result_p != NULL && result_p != left_value_p)
        -: 1519:      {
    #####: 1520:        ecma_deref_bigint (result_p);
        -: 1521:      }
    #####: 1522:      result_p = NULL;
    #####: 1523:      break;
        -: 1524:    }
        -: 1525:
    #####: 1526:    if (square_p != left_value_p)
        -: 1527:    {
    #####: 1528:      ecma_deref_bigint (square_p);
        -: 1529:    }
        -: 1530:
    #####: 1531:    square_p = new_square_p;
    #####: 1532:    right_value >>= 1;
        -: 1533:
    #####: 1534:    if (ECMA_BIGINT_NUMBER_IS_ODD (right_value))
        -: 1535:    {
    #####: 1536:      if (result_p != NULL)
        -: 1537:      {
    #####: 1538:        ecma_extended_primitive_t *new_result_p = ecma_big_uint_mul (square_p, result_p);
        -: 1539:
    #####: 1540:        if (result_p != left_value_p)
        -: 1541:        {
    #####: 1542:          ecma_deref_bigint (result_p);
        -: 1543:        }
        -: 1544:
    #####: 1545:        result_p = new_result_p;
        -: 1546:      }
        -: 1547:      else
        -: 1548:      {
    #####: 1549:        ecma_ref_extended_primitive (square_p);
    #####: 1550:        result_p = square_p;
        -: 1551:      }
        -: 1552:
    #####: 1553:      if (JERRY_UNLIKELY (result_p == NULL) || right_value == 1)
        -: 1554:      {
        -: 1555:        break;
        -: 1556:      }
        -: 1557:    }
        -: 1558:  }
        -: 1559:
    #####: 1560:  if (square_p != left_value_p)
        -: 1561:  {
    #####: 1562:    ecma_deref_bigint (square_p);
        -: 1563:  }
        -: 1564:
    #####: 1565:  return result_p;
        -: 1566:} /* ecma_big_uint_pow */
        -: 1567:
        -: 1568:#endif /* JERRY_ESNEXT */
        -: 1569:
        -: 1570:/**
        -: 1571: * Perform bitwise operations on two BigUInt numbers
        -: 1572: *
        -: 1573: * return new BigUInt value, NULL on error
        -: 1574: */
        -: 1575:ecma_extended_primitive_t *
    #####: 1576:ecma_big_uint_bitwise_op (uint32_t operation_and_options, /**< bitwise operation type and options */
        -: 1577:                          ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1578:                          ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -: 1579:{
    #####: 1580:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1581:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -: 1582:
    #####: 1583:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####: 1584:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -: 1585:
    #####: 1586:  uint32_t operation_type = ECMA_BIGINT_BITWISE_GET_OPERATION_TYPE (operation_and_options);
        -: 1587:
    #####: 1588:  switch (operation_type)
        -: 1589:  {
    #####: 1590:    case ECMA_BIG_UINT_BITWISE_AND:
        -: 1591:    {
    #####: 1592:      if (left_size > right_size)
        -: 1593:      {
    #####: 1594:        left_size = right_size;
    #####: 1595:        break;
        -: 1596:      }
        -: 1597:      /* FALLTHRU */
        -: 1598:    }
        -: 1599:    case ECMA_BIG_UINT_BITWISE_AND_NOT:
        -: 1600:    {
    #####: 1601:      if (right_size > left_size)
        -: 1602:      {
    #####: 1603:        right_size = left_size;
        -: 1604:      }
    #####: 1605:      break;
        -: 1606:    }
    #####: 1607:    default:
        -: 1608:    {
    #####: 1609:      JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_OR
        -: 1610:                    || operation_type == ECMA_BIG_UINT_BITWISE_XOR);
        -: 1611:
    #####: 1612:      if (right_size <= left_size)
        -: 1613:      {
    #####: 1614:        break;
        -: 1615:      }
        -: 1616:
        -: 1617:      /* Swap values. */
    #####: 1618:      ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####: 1619:      left_value_p = right_value_p;
    #####: 1620:      right_value_p = tmp_value_p;
        -: 1621:
    #####: 1622:      uint32_t tmp_size = left_size;
    #####: 1623:      left_size = right_size;
    #####: 1624:      right_size = tmp_size;
        -: 1625:
    #####: 1626:      uint32_t decrease_opts = (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_BOTH);
        -: 1627:
        -: 1628:      /* When exactly one bit is set, invert both bits. */
    #####: 1629:      if (decrease_opts >= ECMA_BIG_UINT_BITWISE_DECREASE_LEFT
    #####: 1630:          && decrease_opts <= ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT)
        -: 1631:      {
    #####: 1632:        operation_and_options ^= ECMA_BIG_UINT_BITWISE_DECREASE_BOTH;
        -: 1633:      }
    #####: 1634:      break;
        -: 1635:    }
        -: 1636:  }
        -: 1637:
    #####: 1638:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (left_size);
        -: 1639:
    #####: 1640:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1641:  {
    #####: 1642:    return NULL;
        -: 1643:  }
        -: 1644:
    #####: 1645:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1646:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####: 1647:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
    #####: 1648:  ecma_bigint_digit_t *result_end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, right_size);
        -: 1649:
    #####: 1650:  if (!(operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_BOTH))
        -: 1651:  {
    #####: 1652:    JERRY_ASSERT (!(operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT));
        -: 1653:
    #####: 1654:    if (operation_type == ECMA_BIG_UINT_BITWISE_AND)
        -: 1655:    {
        -: 1656:      do
        -: 1657:      {
    #####: 1658:        *result_p++ = *left_p++ & *right_p++;
        -: 1659:      }
    #####: 1660:      while (result_p < result_end_p);
        -: 1661:
    #####: 1662:      if (result_p[-1] == 0)
        -: 1663:      {
    #####: 1664:        return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1665:      }
    #####: 1666:      return result_value_p;
        -: 1667:    }
        -: 1668:
    #####: 1669:    if (operation_type == ECMA_BIG_UINT_BITWISE_OR)
        -: 1670:    {
        -: 1671:      do
        -: 1672:      {
    #####: 1673:        *result_p++ = *left_p++ | *right_p++;
        -: 1674:      }
    #####: 1675:      while (result_p < result_end_p);
        -: 1676:
    #####: 1677:      if (left_size > right_size)
        -: 1678:      {
    #####: 1679:        memcpy (result_p, left_p, left_size - right_size);
        -: 1680:      }
    #####: 1681:      return result_value_p;
        -: 1682:    }
        -: 1683:
    #####: 1684:    JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_XOR);
        -: 1685:
        -: 1686:    do
        -: 1687:    {
    #####: 1688:      *result_p++ = *left_p++ ^ *right_p++;
        -: 1689:    }
    #####: 1690:    while (result_p < result_end_p);
        -: 1691:
    #####: 1692:    if (left_size > right_size)
        -: 1693:    {
    #####: 1694:      memcpy (result_p, left_p, left_size - right_size);
    #####: 1695:      return result_value_p;
        -: 1696:    }
        -: 1697:
    #####: 1698:    if (result_p[-1] == 0)
        -: 1699:    {
    #####: 1700:      return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1701:    }
    #####: 1702:    return result_value_p;
        -: 1703:  }
        -: 1704:
    #####: 1705:  uint32_t left_carry = 0, right_carry = 0;
        -: 1706:
    #####: 1707:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_LEFT)
        -: 1708:  {
    #####: 1709:    left_carry = 1;
        -: 1710:  }
        -: 1711:
    #####: 1712:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT)
        -: 1713:  {
    #####: 1714:    right_carry = 1;
        -: 1715:  }
        -: 1716:
        -: 1717:  do
        -: 1718:  {
    #####: 1719:    ecma_bigint_digit_t left = (*left_p++) - left_carry;
        -: 1720:
    #####: 1721:    if (left != ~((ecma_bigint_digit_t) 0))
        -: 1722:    {
    #####: 1723:      left_carry = 0;
        -: 1724:    }
        -: 1725:
    #####: 1726:    ecma_bigint_digit_t right = (*right_p++) - right_carry;
        -: 1727:
    #####: 1728:    if (right != ~((ecma_bigint_digit_t) 0))
        -: 1729:    {
    #####: 1730:      right_carry = 0;
        -: 1731:    }
        -: 1732:
    #####: 1733:    switch (operation_type)
        -: 1734:    {
    #####: 1735:      case ECMA_BIG_UINT_BITWISE_AND:
        -: 1736:      {
    #####: 1737:        *result_p++ = left & right;
    #####: 1738:        break;
        -: 1739:      }
    #####: 1740:      case ECMA_BIG_UINT_BITWISE_OR:
        -: 1741:      {
    #####: 1742:        *result_p++ = left | right;
    #####: 1743:        break;
        -: 1744:      }
    #####: 1745:      case ECMA_BIG_UINT_BITWISE_XOR:
        -: 1746:      {
    #####: 1747:        *result_p++ = left ^ right;
    #####: 1748:        break;
        -: 1749:      }
    #####: 1750:      default:
        -: 1751:      {
    #####: 1752:        JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_AND_NOT);
    #####: 1753:        *result_p++ = left & ~right;
    #####: 1754:        break;
        -: 1755:      }
        -: 1756:    }
        -: 1757:  }
    #####: 1758:  while (result_p < result_end_p);
        -: 1759:
    #####: 1760:  if (operation_type != ECMA_BIG_UINT_BITWISE_AND)
        -: 1761:  {
    #####: 1762:    result_end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, left_size);
        -: 1763:
    #####: 1764:    if (left_carry > 0)
        -: 1765:    {
    #####: 1766:      while (*left_p == 0)
        -: 1767:      {
    #####: 1768:        *result_p++ = ~((ecma_bigint_digit_t) 0);
    #####: 1769:        left_p++;
        -: 1770:
    #####: 1771:        JERRY_ASSERT (result_p < result_end_p);
        -: 1772:      }
        -: 1773:
    #####: 1774:      *result_p++ = *left_p++ - 1;
        -: 1775:    }
        -: 1776:
    #####: 1777:    if (result_p < result_end_p)
        -: 1778:    {
    #####: 1779:      memcpy (result_p, left_p, (size_t) ((uint8_t *) result_end_p - (uint8_t *) result_p));
        -: 1780:
    #####: 1781:      if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1782:      {
    #####: 1783:        return ecma_big_uint_increase_result (result_value_p);
        -: 1784:      }
    #####: 1785:      return result_value_p;
        -: 1786:    }
        -: 1787:  }
        -: 1788:
    #####: 1789:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1790:  {
    #####: 1791:    return ecma_big_uint_increase_result (result_value_p);
        -: 1792:  }
        -: 1793:
    #####: 1794:  if (result_p[-1] == 0)
        -: 1795:  {
    #####: 1796:    return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1797:  }
    #####: 1798:  return result_value_p;
        -: 1799:} /* ecma_big_uint_bitwise_op */
        -: 1800:
        -: 1801:#endif /* JERRY_BUILTIN_BIGINT */
