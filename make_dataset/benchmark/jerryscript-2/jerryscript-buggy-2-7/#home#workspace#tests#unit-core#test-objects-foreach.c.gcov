        -:    0:Source:/home/workspace/tests/unit-core/test-objects-foreach.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:#include "test-common.h"
        -:   18:
        -:   19:static bool
    #####:   20:count_objects (jerry_value_t object, void *user_arg)
        -:   21:{
        -:   22:  (void) object;
    #####:   23:  TEST_ASSERT (user_arg != NULL);
        -:   24:
    #####:   25:  int *counter = (int *) user_arg;
        -:   26:
    #####:   27:  (*counter)++;
    #####:   28:  return true;
        -:   29:} /* count_objects */
        -:   30:
        -:   31:static void
    #####:   32:test_container (void)
        -:   33:{
    #####:   34:  jerry_value_t global = jerry_get_global_object ();
    #####:   35:  jerry_value_t map_str = jerry_create_string ((const jerry_char_t *) "Map");
    #####:   36:  jerry_value_t map_result = jerry_get_property (global, map_str);
    #####:   37:  jerry_type_t type = jerry_value_get_type (map_result);
        -:   38:
    #####:   39:  jerry_release_value (map_result);
    #####:   40:  jerry_release_value (map_str);
    #####:   41:  jerry_release_value (global);
        -:   42:
        -:   43:  /* If there is no Map function this is not an es.next profile build, skip this test case. */
    #####:   44:  if (type != JERRY_TYPE_FUNCTION)
        -:   45:  {
    #####:   46:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Container based test is disabled!\n");
    #####:   47:    return;
        -:   48:  }
        -:   49:
        -:   50:  {
        -:   51:    /* Create a "DEMO" array which will be used for the Map below. */
    #####:   52:    const char array_str[] = "var DEMO = [[1, 2], [3, 4]]; DEMO";
    #####:   53:    jerry_value_t array = jerry_eval ((const jerry_char_t *) array_str, sizeof (array_str) - 1, 0);
    #####:   54:    TEST_ASSERT (jerry_value_is_object (array));
    #####:   55:    TEST_ASSERT (!jerry_value_is_error (array));
    #####:   56:    jerry_release_value (array);
        -:   57:  }
        -:   58:
    #####:   59:  const char eval_str[] = "new Map (DEMO)";
        -:   60:  {
        -:   61:    /* Make sure that the Map and it's prototype object/function is initialized. */
    #####:   62:    jerry_value_t result = jerry_eval ((const jerry_char_t *) eval_str, sizeof (eval_str) - 1, 0);
    #####:   63:    TEST_ASSERT (jerry_value_is_object (result));
    #####:   64:    TEST_ASSERT (!jerry_value_is_error (result));
    #####:   65:    jerry_release_value (result);
        -:   66:  }
        -:   67:
        -:   68:  /* Do a bit of cleaning to clear up old objects. */
    #####:   69:  jerry_gc (JERRY_GC_PRESSURE_LOW);
        -:   70:
        -:   71:  /* Get the number of iterable objects. */
    #####:   72:  int start_count = 0;
    #####:   73:  jerry_objects_foreach (count_objects, &start_count);
        -:   74:
        -:   75:  /* Create another map. */
    #####:   76:  jerry_value_t result = jerry_eval ((const jerry_char_t *) eval_str, sizeof (eval_str) - 1, 0);
        -:   77:
        -:   78:  /* Remove any old/unused objects. */
    #####:   79:  jerry_gc (JERRY_GC_PRESSURE_LOW);
        -:   80:
        -:   81:  /* Get the current number of objects. */
    #####:   82:  int end_count = 0;
    #####:   83:  jerry_objects_foreach (count_objects, &end_count);
        -:   84:
        -:   85:  /* As only one Map was created the number of available iterable objects should be incremented only by one. */
    #####:   86:  TEST_ASSERT (end_count > start_count);
    #####:   87:  TEST_ASSERT ((end_count - start_count) == 1);
        -:   88:
    #####:   89:  jerry_release_value (result);
        -:   90:} /* test_container */
        -:   91:
        -:   92:static void
    #####:   93:test_internal_prop (void)
        -:   94:{
        -:   95:  /* Make sure that the object is initialized in the engine. */
    #####:   96:  jerry_value_t object_dummy = jerry_create_object ();
        -:   97:
        -:   98:  /* Get the number of iterable objects. */
    #####:   99:  int before_object_count = 0;
    #####:  100:  jerry_objects_foreach (count_objects, &before_object_count);
        -:  101:
    #####:  102:  jerry_value_t object = jerry_create_object ();
        -:  103:
        -:  104:  /* After creating the object, the number of objects is incremented by one. */
    #####:  105:  int after_object_count = 0;
        -:  106:  {
    #####:  107:    jerry_objects_foreach (count_objects, &after_object_count);
        -:  108:
    #####:  109:    TEST_ASSERT (after_object_count > before_object_count);
    #####:  110:    TEST_ASSERT ((after_object_count - before_object_count) == 1);
        -:  111:  }
        -:  112:
    #####:  113:  jerry_value_t internal_prop_name = jerry_create_string ((const jerry_char_t *) "hidden_foo");
    #####:  114:  jerry_value_t internal_prop_object = jerry_create_object ();
    #####:  115:  bool internal_result = jerry_set_internal_property (object, internal_prop_name, internal_prop_object);
    #####:  116:  TEST_ASSERT (internal_result == true);
    #####:  117:  jerry_release_value (internal_prop_name);
    #####:  118:  jerry_release_value (internal_prop_object);
        -:  119:
        -:  120:  /* After adding an internal property object, the number of object is incremented by one. */
        -:  121:  {
    #####:  122:    int after_internal_count = 0;
    #####:  123:    jerry_objects_foreach (count_objects, &after_internal_count);
        -:  124:
    #####:  125:    TEST_ASSERT (after_internal_count > after_object_count);
    #####:  126:    TEST_ASSERT ((after_internal_count - after_object_count) == 1);
        -:  127:  }
        -:  128:
    #####:  129:  jerry_release_value (object);
    #####:  130:  jerry_release_value (object_dummy);
    #####:  131:} /* test_internal_prop */
        -:  132:
        -:  133:static int test_data = 1;
        -:  134:
    #####:  135:static void free_test_data (void *native_p, /**< native pointer */
        -:  136:                            jerry_object_native_info_t *info_p) /**< native info */
        -:  137:{
    #####:  138:  TEST_ASSERT ((int *) native_p == &test_data);
    #####:  139:  TEST_ASSERT (info_p->free_cb == free_test_data);
    #####:  140:} /* free_test_data */
        -:  141:
        -:  142:static const jerry_object_native_info_t test_info =
        -:  143:{
        -:  144:  .free_cb = free_test_data,
        -:  145:  .number_of_references = 0,
        -:  146:  .offset_of_references = 0,
        -:  147:};
        -:  148:
        -:  149:static const jerry_char_t strict_equal_source[] = "var x = function(a, b) {return a === b;}; x";
        -:  150:
        -:  151:static bool
    #####:  152:find_test_object_by_data (const jerry_value_t candidate,
        -:  153:                          void *object_data_p,
        -:  154:                          void *context_p)
        -:  155:{
    #####:  156:  if (object_data_p == &test_data)
        -:  157:  {
    #####:  158:    *((jerry_value_t *) context_p) = jerry_acquire_value (candidate);
    #####:  159:    return false;
        -:  160:  }
        -:  161:  return true;
        -:  162:} /* find_test_object_by_data */
        -:  163:
        -:  164:static bool
    #####:  165:find_test_object_by_property (const jerry_value_t candidate,
        -:  166:                              void *context_p)
        -:  167:{
    #####:  168:  jerry_value_t *args_p = (jerry_value_t *) context_p;
    #####:  169:  jerry_value_t result = jerry_has_property (candidate, args_p[0]);
        -:  170:
    #####:  171:  bool has_property = (!jerry_value_is_error (result) && jerry_value_is_true (result));
        -:  172:
        -:  173:  /* If the object has the desired property, store a new reference to it in args_p[1]. */
    #####:  174:  if (has_property)
        -:  175:  {
    #####:  176:    args_p[1] = jerry_acquire_value (candidate);
        -:  177:  }
        -:  178:
    #####:  179:  jerry_release_value (result);
        -:  180:
        -:  181:  /* Stop iterating if we've found our object. */
    #####:  182:  return !has_property;
        -:  183:} /* find_test_object_by_property */
        -:  184:
        -:  185:int
    #####:  186:main (void)
        -:  187:{
    #####:  188:  jerry_init (JERRY_INIT_EMPTY);
        -:  189:
        -:  190:  jerry_parse_options_t parse_options;
    #####:  191:  parse_options.options = JERRY_PARSE_STRICT_MODE;
        -:  192:
        -:  193:  /* Render strict-equal as a function. */
    #####:  194:  jerry_value_t parse_result = jerry_parse (strict_equal_source,
        -:  195:                                            sizeof (strict_equal_source) - 1,
        -:  196:                                            &parse_options);
    #####:  197:  TEST_ASSERT (!jerry_value_is_error (parse_result));
    #####:  198:  jerry_value_t strict_equal = jerry_run (parse_result);
    #####:  199:  TEST_ASSERT (!jerry_value_is_error (strict_equal));
    #####:  200:  jerry_release_value (parse_result);
        -:  201:
        -:  202:  /* Create an object and associate some native data with it. */
    #####:  203:  jerry_value_t object = jerry_create_object ();
    #####:  204:  jerry_set_object_native_pointer (object, &test_data, &test_info);
        -:  205:
        -:  206:  /* Retrieve the object by its native pointer. */
        -:  207:
        -:  208:  jerry_value_t found_object;
    #####:  209:  TEST_ASSERT (jerry_objects_foreach_by_native_info (&test_info, find_test_object_by_data, &found_object));
    #####:  210:  jerry_value_t args[2] = {object, found_object};
        -:  211:
        -:  212:  /* Assert that the correct object was retrieved. */
    #####:  213:  jerry_value_t undefined = jerry_create_undefined ();
    #####:  214:  jerry_value_t strict_equal_result = jerry_call_function (strict_equal, undefined, args, 2);
    #####:  215:  TEST_ASSERT (jerry_value_is_boolean (strict_equal_result) && jerry_value_is_true (strict_equal_result));
    #####:  216:  jerry_release_value (strict_equal_result);
    #####:  217:  jerry_release_value (found_object);
    #####:  218:  jerry_release_value (object);
        -:  219:
        -:  220:  /* Collect garbage. */
    #####:  221:  jerry_gc (JERRY_GC_PRESSURE_LOW);
        -:  222:
        -:  223:  /* Attempt to retrieve the object by its native pointer again. */
    #####:  224:  TEST_ASSERT (!jerry_objects_foreach_by_native_info (&test_info, find_test_object_by_data, &found_object));
        -:  225:
        -:  226:  /* Create an object and set a property on it. */
    #####:  227:  object = jerry_create_object ();
    #####:  228:  jerry_value_t property_name = jerry_create_string ((jerry_char_t *) "xyzzy");
    #####:  229:  jerry_value_t property_value = jerry_create_number (42);
    #####:  230:  jerry_release_value (jerry_set_property (object, property_name, property_value));
    #####:  231:  jerry_release_value (property_value);
        -:  232:
        -:  233:  /* Retrieve the object by the presence of its property, placing it at args[1]. */
    #####:  234:  args[0] = property_name;
    #####:  235:  TEST_ASSERT (jerry_objects_foreach (find_test_object_by_property, args));
        -:  236:
        -:  237:  /* Assert that the right object was retrieved and release both the original reference to it and the retrieved one. */
    #####:  238:  args[0] = object;
    #####:  239:  strict_equal_result = jerry_call_function (strict_equal, undefined, args, 2);
    #####:  240:  TEST_ASSERT (jerry_value_is_boolean (strict_equal_result) && jerry_value_is_true (strict_equal_result));
    #####:  241:  jerry_release_value (strict_equal_result);
    #####:  242:  jerry_release_value (args[0]);
    #####:  243:  jerry_release_value (args[1]);
        -:  244:
        -:  245:  /* Collect garbage. */
    #####:  246:  jerry_gc (JERRY_GC_PRESSURE_LOW);
        -:  247:
        -:  248:  /* Attempt to retrieve the object by the presence of its property again. */
    #####:  249:  args[0] = property_name;
    #####:  250:  TEST_ASSERT (!jerry_objects_foreach (find_test_object_by_property, args));
        -:  251:
    #####:  252:  jerry_release_value (property_name);
    #####:  253:  jerry_release_value (undefined);
    #####:  254:  jerry_release_value (strict_equal);
        -:  255:
    #####:  256:  test_container ();
    #####:  257:  test_internal_prop ();
        -:  258:
    #####:  259:  jerry_cleanup ();
        -:  260:
        -:  261:  return 0;
        -:  262:} /* main */
