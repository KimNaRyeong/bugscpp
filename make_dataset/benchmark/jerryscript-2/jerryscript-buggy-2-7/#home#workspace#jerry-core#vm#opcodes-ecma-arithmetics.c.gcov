        -:    0:Source:/home/workspace/jerry-core/vm/opcodes-ecma-arithmetics.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-bigint.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "ecma-number-arithmetic.h"
        -:   22:#include "ecma-objects.h"
        -:   23:#include "opcodes.h"
        -:   24:#include "jrt-libc-includes.h"
        -:   25:
        -:   26:/** \addtogroup vm Virtual machine
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup vm_opcodes Opcodes
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/**
        -:   34: * Perform ECMA number arithmetic operation.
        -:   35: *
        -:   36: * The algorithm of the operation is following:
        -:   37: *   leftNum = ToNumber (leftValue);
        -:   38: *   rightNum = ToNumber (rightValue);
        -:   39: *   result = leftNum ArithmeticOp rightNum;
        -:   40: *
        -:   41: * @return ecma value
        -:   42: *         Returned value must be freed with ecma_free_value
        -:   43: */
        -:   44:ecma_value_t
    #####:   45:do_number_arithmetic (number_arithmetic_op op, /**< number arithmetic operation */
        -:   46:                      ecma_value_t left_value, /**< left value */
        -:   47:                      ecma_value_t right_value) /**< right value */
        -:   48:{
    #####:   49:  ecma_number_t left_number;
    #####:   50:  left_value = ecma_op_to_numeric (left_value, &left_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:   51:
    #####:   52:  if (ECMA_IS_VALUE_ERROR (left_value))
        -:   53:  {
    #####:   54:    return left_value;
        -:   55:  }
        -:   56:
    #####:   57:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:   58:
        -:   59:#if JERRY_BUILTIN_BIGINT
    #####:   60:  if (JERRY_LIKELY (!ecma_is_value_bigint (left_value)))
        -:   61:  {
        -:   62:#endif /* JERRY_BUILTIN_BIGINT */
        -:   63:
    #####:   64:    ecma_number_t right_number;
    #####:   65:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (right_value, &right_number)))
        -:   66:    {
    #####:   67:      return ECMA_VALUE_ERROR;
        -:   68:    }
        -:   69:
    #####:   70:    ecma_number_t result = ECMA_NUMBER_ZERO;
        -:   71:
    #####:   72:    switch (op)
        -:   73:    {
    #####:   74:      case NUMBER_ARITHMETIC_SUBTRACTION:
        -:   75:      {
    #####:   76:        result = left_number - right_number;
    #####:   77:        break;
        -:   78:      }
    #####:   79:      case NUMBER_ARITHMETIC_MULTIPLICATION:
        -:   80:      {
    #####:   81:        result = left_number * right_number;
    #####:   82:        break;
        -:   83:      }
    #####:   84:      case NUMBER_ARITHMETIC_DIVISION:
        -:   85:      {
    #####:   86:        result = left_number / right_number;
    #####:   87:        break;
        -:   88:      }
    #####:   89:      case NUMBER_ARITHMETIC_REMAINDER:
        -:   90:      {
    #####:   91:        result = ecma_op_number_remainder (left_number, right_number);
    #####:   92:        break;
        -:   93:      }
        -:   94:#if JERRY_ESNEXT
    #####:   95:      case NUMBER_ARITHMETIC_EXPONENTIATION:
        -:   96:      {
    #####:   97:        result = ecma_number_pow (left_number, right_number);
    #####:   98:        break;
        -:   99:      }
        -:  100:#endif /* JERRY_ESNEXT */
        -:  101:    }
        -:  102:
    #####:  103:    ret_value = ecma_make_number_value (result);
        -:  104:#if JERRY_BUILTIN_BIGINT
        -:  105:  }
        -:  106:  else
        -:  107:  {
    #####:  108:    bool free_right_value;
    #####:  109:    right_value = ecma_bigint_get_bigint (right_value, &free_right_value);
        -:  110:
    #####:  111:    if (ECMA_IS_VALUE_ERROR (right_value))
        -:  112:    {
    #####:  113:      ecma_free_value (left_value);
    #####:  114:      return right_value;
        -:  115:    }
        -:  116:
    #####:  117:    switch (op)
        -:  118:    {
    #####:  119:      case NUMBER_ARITHMETIC_SUBTRACTION:
        -:  120:      {
    #####:  121:        ret_value = ecma_bigint_add_sub (left_value, right_value, false);
    #####:  122:        break;
        -:  123:      }
    #####:  124:      case NUMBER_ARITHMETIC_MULTIPLICATION:
        -:  125:      {
    #####:  126:        ret_value = ecma_bigint_mul (left_value, right_value);
    #####:  127:        break;
        -:  128:      }
    #####:  129:      case NUMBER_ARITHMETIC_DIVISION:
        -:  130:      {
    #####:  131:        ret_value = ecma_bigint_div_mod (left_value, right_value, false);
    #####:  132:        break;
        -:  133:      }
    #####:  134:      case NUMBER_ARITHMETIC_REMAINDER:
        -:  135:      {
    #####:  136:        ret_value = ecma_bigint_div_mod (left_value, right_value, true);
    #####:  137:        break;
        -:  138:      }
        -:  139:#if JERRY_ESNEXT
    #####:  140:      case NUMBER_ARITHMETIC_EXPONENTIATION:
        -:  141:      {
    #####:  142:        ret_value = ecma_bigint_pow (left_value, right_value);
    #####:  143:        break;
        -:  144:      }
        -:  145:#endif /* JERRY_ESNEXT */
        -:  146:    }
        -:  147:
    #####:  148:    ecma_free_value (left_value);
    #####:  149:    if (free_right_value)
        -:  150:    {
    #####:  151:      ecma_free_value (right_value);
        -:  152:    }
        -:  153:  }
        -:  154:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  155:  return ret_value;
        -:  156:} /* do_number_arithmetic */
        -:  157:
        -:  158:/**
        -:  159: * 'Addition' opcode handler.
        -:  160: *
        -:  161: * See also: ECMA-262 v5, 11.6.1
        -:  162: *
        -:  163: * @return ecma value
        -:  164: *         Returned value must be freed with ecma_free_value
        -:  165: */
        -:  166:ecma_value_t
        1:  167:opfunc_addition (ecma_value_t left_value, /**< left value */
        -:  168:                 ecma_value_t right_value) /**< right value */
        -:  169:{
        1:  170:  bool free_left_value = false;
        1:  171:  bool free_right_value = false;
        -:  172:
        1:  173:  if (ecma_is_value_object (left_value))
        -:  174:  {
    #####:  175:    ecma_object_t *obj_p = ecma_get_object_from_value (left_value);
    #####:  176:    left_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_NO);
    #####:  177:    free_left_value = true;
        -:  178:
    #####:  179:    if (ECMA_IS_VALUE_ERROR (left_value))
        -:  180:    {
    #####:  181:      return left_value;
        -:  182:    }
        -:  183:  }
        -:  184:
        1:  185:  if (ecma_is_value_object (right_value))
        -:  186:  {
    #####:  187:    ecma_object_t *obj_p = ecma_get_object_from_value (right_value);
    #####:  188:    right_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_NO);
    #####:  189:    free_right_value = true;
        -:  190:
    #####:  191:    if (ECMA_IS_VALUE_ERROR (right_value))
        -:  192:    {
    #####:  193:      if (free_left_value)
        -:  194:      {
    #####:  195:        ecma_free_value (left_value);
        -:  196:      }
    #####:  197:      return right_value;
        -:  198:    }
        -:  199:  }
        -:  200:
        1:  201:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  202:
        1:  203:  if (ecma_is_value_string (left_value)
    #####:  204:      || ecma_is_value_string (right_value))
        1:  205:  {
        1:  206:    ecma_string_t *string1_p = ecma_op_to_string (left_value);
        -:  207:
        1:  208:    if (JERRY_UNLIKELY (string1_p == NULL))
        -:  209:    {
    #####:  210:      if (free_left_value)
        -:  211:      {
    #####:  212:        ecma_free_value (left_value);
        -:  213:      }
    #####:  214:      if (free_right_value)
        -:  215:      {
    #####:  216:        ecma_free_value (right_value);
        -:  217:      }
    #####:  218:      return ECMA_VALUE_ERROR;
        -:  219:    }
        -:  220:
        1:  221:    ecma_string_t *string2_p = ecma_op_to_string (right_value);
        -:  222:
        1:  223:    if (JERRY_UNLIKELY (string2_p == NULL))
        -:  224:    {
    #####:  225:      if (free_right_value)
        -:  226:      {
    #####:  227:        ecma_free_value (right_value);
        -:  228:      }
    #####:  229:      if (free_left_value)
        -:  230:      {
    #####:  231:        ecma_free_value (left_value);
        -:  232:      }
    #####:  233:      ecma_deref_ecma_string (string1_p);
    #####:  234:      return ECMA_VALUE_ERROR;
        -:  235:    }
        -:  236:
        1:  237:    string1_p = ecma_concat_ecma_strings (string1_p, string2_p);
        1:  238:    ret_value = ecma_make_string_value (string1_p);
        -:  239:
        1:  240:    ecma_deref_ecma_string (string2_p);
        -:  241:  }
        -:  242:#if JERRY_BUILTIN_BIGINT
    #####:  243:  else if (JERRY_UNLIKELY (ecma_is_value_bigint (left_value))
    #####:  244:           && JERRY_UNLIKELY (ecma_is_value_bigint (right_value)))
        -:  245:  {
    #####:  246:    ret_value = ecma_bigint_add_sub (left_value, right_value, true);
        -:  247:  }
        -:  248:#endif /* JERRY_BUILTIN_BIGINT */
        -:  249:  else
        -:  250:  {
    #####:  251:    ecma_number_t num_left;
    #####:  252:    ecma_number_t num_right;
    #####:  253:    if (!ECMA_IS_VALUE_ERROR (ecma_op_to_number (left_value, &num_left))
    #####:  254:        && !ECMA_IS_VALUE_ERROR (ecma_op_to_number (right_value, &num_right)))
        -:  255:    {
    #####:  256:      ret_value = ecma_make_number_value (num_left + num_right);
        -:  257:    }
        -:  258:    else
        -:  259:    {
    #####:  260:      ret_value = ECMA_VALUE_ERROR;
        -:  261:    }
        -:  262:  }
        -:  263:
        1:  264:  if (free_left_value)
        -:  265:  {
    #####:  266:    ecma_free_value (left_value);
        -:  267:  }
        -:  268:
        1:  269:  if (free_right_value)
        -:  270:  {
    #####:  271:    ecma_free_value (right_value);
        -:  272:  }
        -:  273:
        1:  274:  return ret_value;
        -:  275:} /* opfunc_addition */
        -:  276:
        -:  277:/**
        -:  278: * Unary operation opcode handler.
        -:  279: *
        -:  280: * See also: ECMA-262 v5, 11.4, 11.4.6, 11.4.7
        -:  281: *
        -:  282: * @return ecma value
        -:  283: *         Returned value must be freed with ecma_free_value
        -:  284: */
        -:  285:ecma_value_t
    #####:  286:opfunc_unary_operation (ecma_value_t left_value, /**< left value */
        -:  287:                        bool is_plus) /**< unary plus flag */
        -:  288:{
    #####:  289:  ecma_number_t left_number;
    #####:  290:  left_value = ecma_op_to_numeric (left_value, &left_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:  291:
    #####:  292:  if (ECMA_IS_VALUE_ERROR (left_value))
        -:  293:  {
    #####:  294:    return left_value;
        -:  295:  }
        -:  296:
        -:  297:#if JERRY_BUILTIN_BIGINT
    #####:  298:  if (JERRY_LIKELY (!ecma_is_value_bigint (left_value)))
        -:  299:  {
    #####:  300:    return ecma_make_number_value (is_plus ? left_number : -left_number);
        -:  301:  }
        -:  302:
        -:  303:  ecma_value_t ret_value;
        -:  304:
    #####:  305:  if (is_plus)
        -:  306:  {
    #####:  307:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Unary plus is not allowed for BigInts"));
        -:  308:  }
        -:  309:  else
        -:  310:  {
    #####:  311:    ret_value = left_value;
        -:  312:
    #####:  313:    if (left_value != ECMA_BIGINT_ZERO)
        -:  314:    {
    #####:  315:      ret_value = ecma_bigint_negate (ecma_get_extended_primitive_from_value (left_value));
        -:  316:    }
        -:  317:  }
        -:  318:
    #####:  319:  ecma_free_value (left_value);
    #####:  320:  return ret_value;
        -:  321:#else /* !JERRY_BUILTIN_BIGINT */
    #####:  322:  return ecma_make_number_value (is_plus ? left_number : -left_number);
        -:  323:#endif /* JERRY_BUILTIN_BIGINT */
        -:  324:} /* opfunc_unary_operation */
        -:  325:
        -:  326:/**
        -:  327: * @}
        -:  328: * @}
        -:  329: */
