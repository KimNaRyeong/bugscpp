        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-comparison.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-string-object.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_ARRAY
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_ARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   48:  /* Note: these 2 routine ids must be in this order */
        -:   49:#if !JERRY_ESNEXT
        -:   50:  ECMA_ARRAY_PROTOTYPE_TO_STRING,
        -:   51:#endif /* !JERRY_ESNEXT */
        -:   52:  ECMA_ARRAY_PROTOTYPE_SORT,
        -:   53:  ECMA_ARRAY_PROTOTYPE_CONCAT,
        -:   54:  ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING,
        -:   55:  ECMA_ARRAY_PROTOTYPE_JOIN,
        -:   56:  ECMA_ARRAY_PROTOTYPE_POP,
        -:   57:  ECMA_ARRAY_PROTOTYPE_PUSH,
        -:   58:  ECMA_ARRAY_PROTOTYPE_REVERSE,
        -:   59:  ECMA_ARRAY_PROTOTYPE_SHIFT,
        -:   60:  ECMA_ARRAY_PROTOTYPE_SLICE,
        -:   61:  ECMA_ARRAY_PROTOTYPE_SPLICE,
        -:   62:  ECMA_ARRAY_PROTOTYPE_UNSHIFT,
        -:   63:  ECMA_ARRAY_PROTOTYPE_AT,
        -:   64:  ECMA_ARRAY_PROTOTYPE_INDEX_OF,
        -:   65:  ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF,
        -:   66:  /* Note these 3 routines must be in this order */
        -:   67:  ECMA_ARRAY_PROTOTYPE_EVERY,
        -:   68:  ECMA_ARRAY_PROTOTYPE_SOME,
        -:   69:  ECMA_ARRAY_PROTOTYPE_FOR_EACH,
        -:   70:  ECMA_ARRAY_PROTOTYPE_MAP,
        -:   71:  ECMA_ARRAY_PROTOTYPE_FILTER,
        -:   72:  /* Note these 2 routines must be in this order */
        -:   73:  ECMA_ARRAY_PROTOTYPE_REDUCE,
        -:   74:  ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT,
        -:   75:  ECMA_ARRAY_PROTOTYPE_FIND,
        -:   76:  ECMA_ARRAY_PROTOTYPE_FIND_INDEX,
        -:   77:  ECMA_ARRAY_PROTOTYPE_ENTRIES,
        -:   78:  ECMA_ARRAY_PROTOTYPE_KEYS,
        -:   79:  ECMA_ARRAY_PROTOTYPE_SYMBOL_ITERATOR,
        -:   80:  ECMA_ARRAY_PROTOTYPE_FILL,
        -:   81:  ECMA_ARRAY_PROTOTYPE_COPY_WITHIN,
        -:   82:  ECMA_ARRAY_PROTOTYPE_INCLUDES,
        -:   83:  ECMA_ARRAY_PROTOTYPE_FLAT,
        -:   84:  ECMA_ARRAY_PROTOTYPE_FLATMAP,
        -:   85:};
        -:   86:
        -:   87:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array-prototype.inc.h"
        -:   88:#define BUILTIN_UNDERSCORED_ID array_prototype
        -:   89:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   90:
        -:   91:/** \addtogroup ecma ECMA
        -:   92: * @{
        -:   93: *
        -:   94: * \addtogroup ecmabuiltins
        -:   95: * @{
        -:   96: *
        -:   97: * \addtogroup arrayprototype ECMA Array.prototype object built-in
        -:   98: * @{
        -:   99: */
        -:  100:
        -:  101:/**
        -:  102: * Helper function to set an object's length property
        -:  103: *
        -:  104: * @return ecma value (return value of the [[Put]] method)
        -:  105: *         Calling ecma_free_value on the returned value is optional if it is not abrupt completion.
        -:  106: */
        -:  107:static ecma_value_t
    #####:  108:ecma_builtin_array_prototype_helper_set_length (ecma_object_t *object, /**< object*/
        -:  109:                                                ecma_number_t length) /**< new length */
        -:  110:{
    #####:  111:  ecma_value_t length_value = ecma_make_number_value (length);
    #####:  112:  ecma_value_t ret_value = ecma_op_object_put (object,
        -:  113:                                               ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  114:                                               length_value,
        -:  115:                                               true);
        -:  116:
    #####:  117:  ecma_free_value (length_value);
        -:  118:
    #####:  119:  JERRY_ASSERT (ecma_is_value_boolean (ret_value)
        -:  120:                || ecma_is_value_empty (ret_value)
        -:  121:                || ECMA_IS_VALUE_ERROR (ret_value));
    #####:  122:  return ret_value;
        -:  123:} /* ecma_builtin_array_prototype_helper_set_length */
        -:  124:
        -:  125:/**
        -:  126: * The Array.prototype object's 'toLocaleString' routine
        -:  127: *
        -:  128: * See also:
        -:  129: *          ECMA-262 v5, 15.4.4.3
        -:  130: *
        -:  131: * @return ecma value
        -:  132: *         Returned value must be freed with ecma_free_value.
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_builtin_array_prototype_object_to_locale_string (ecma_object_t *obj_p, /**< object */
        -:  136:                                                      ecma_length_t length) /**< object's length */
        -:  137:{
        -:  138:  /* 5. */
    #####:  139:  if (length == 0)
        -:  140:  {
    #####:  141:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  142:  }
        -:  143:
        -:  144:  /* 7-8. */
    #####:  145:  ecma_string_t *first_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, 0);
        -:  146:
    #####:  147:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  148:  {
    #####:  149:    return ECMA_VALUE_ERROR;
        -:  150:  }
        -:  151:
    #####:  152:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  153:  ecma_deref_ecma_string (first_string_p);
        -:  154:
        -:  155:  /* 9-10. */
    #####:  156:  for (ecma_length_t k = 1; k < length; k++)
        -:  157:  {
        -:  158:    /* 4. Implementation-defined: set the separator to a single comma character. */
    #####:  159:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
        -:  160:
    #####:  161:    ecma_string_t *next_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, k);
        -:  162:
    #####:  163:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  164:    {
    #####:  165:      ecma_stringbuilder_destroy (&builder);
    #####:  166:      return ECMA_VALUE_ERROR;
        -:  167:    }
        -:  168:
    #####:  169:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  170:    ecma_deref_ecma_string (next_string_p);
        -:  171:  }
        -:  172:
    #####:  173:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  174:} /* ecma_builtin_array_prototype_object_to_locale_string */
        -:  175:
        -:  176:/**
        -:  177: * The Array.prototype object's 'concat' routine
        -:  178: *
        -:  179: * See also:
        -:  180: *          ECMA-262 v5, 15.4.4.4
        -:  181: *
        -:  182: * @return ecma value
        -:  183: *         Returned value must be freed with ecma_free_value.
        -:  184: */
        -:  185:static ecma_value_t
    #####:  186:ecma_builtin_array_prototype_object_concat (const ecma_value_t args[], /**< arguments list */
        -:  187:                                            uint32_t args_number, /**< number of arguments */
        -:  188:                                            ecma_object_t *obj_p) /**< array object */
        -:  189:{
        -:  190:  /* 2. */
        -:  191:#if JERRY_ESNEXT
    #####:  192:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -:  193:
    #####:  194:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:#else /* !JERRY_ESNEXT */
    #####:  199:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  200:#endif /* JERRY_ESNEXT */
        -:  201:
    #####:  202:  ecma_length_t new_length = 0;
        -:  203:
        -:  204:  /* 5.b - 5.c for this_arg */
    #####:  205:  ecma_value_t concat_this_value = ecma_builtin_helper_array_concat_value (new_array_p,
        -:  206:                                                                           &new_length,
        -:  207:                                                                           ecma_make_object_value (obj_p));
    #####:  208:  if (ECMA_IS_VALUE_ERROR (concat_this_value))
        -:  209:  {
    #####:  210:    ecma_deref_object (new_array_p);
    #####:  211:    return concat_this_value;
        -:  212:  }
        -:  213:
    #####:  214:  JERRY_ASSERT (ecma_is_value_empty (concat_this_value));
        -:  215:
        -:  216:  /* 5. */
    #####:  217:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:  218:  {
    #####:  219:    ecma_value_t concat_value = ecma_builtin_helper_array_concat_value (new_array_p, &new_length, args[arg_index]);
        -:  220:
    #####:  221:    if (ECMA_IS_VALUE_ERROR (concat_value))
        -:  222:    {
    #####:  223:      ecma_deref_object (new_array_p);
    #####:  224:      return concat_value;
        -:  225:    }
        -:  226:
    #####:  227:    JERRY_ASSERT (ecma_is_value_empty (concat_value));
        -:  228:  }
        -:  229:
    #####:  230:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -:  231:                                                                                  ((ecma_number_t) new_length));
    #####:  232:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  233:  {
    #####:  234:    ecma_deref_object (new_array_p);
    #####:  235:    return set_length_value;
        -:  236:  }
        -:  237:
    #####:  238:  return ecma_make_object_value (new_array_p);
        -:  239:} /* ecma_builtin_array_prototype_object_concat */
        -:  240:
        -:  241:/**
        -:  242: * The Array.prototype.toString's separator creation routine
        -:  243: *
        -:  244: * See also:
        -:  245: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  246: *
        -:  247: * @return NULL - if the conversion fails
        -:  248: *         ecma_string_t * - otherwise
        -:  249: */
        -:  250:
        -:  251:static ecma_string_t *
    #####:  252:ecma_op_array_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  253:{
    #####:  254:  if (ecma_is_value_undefined (separator))
        -:  255:  {
    #####:  256:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  257:  }
        -:  258:
    #####:  259:  return ecma_op_to_string (separator);
        -:  260:} /* ecma_op_array_get_separator_string */
        -:  261:
        -:  262:/**
        -:  263: * The Array.prototype's 'toString' single element operation routine
        -:  264: *
        -:  265: * See also:
        -:  266: *          ECMA-262 v5.1, 15.4.4.2
        -:  267: *
        -:  268: * @return NULL - if the conversion fails
        -:  269: *         ecma_string_t * - otherwise
        -:  270: */
        -:  271:static ecma_string_t *
    #####:  272:ecma_op_array_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  273:                                      ecma_length_t index) /**< array index */
        -:  274:{
    #####:  275:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  276:
    #####:  277:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  278:  {
    #####:  279:    return NULL;
        -:  280:  }
        -:  281:
    #####:  282:  if (ecma_is_value_undefined (index_value)
    #####:  283:      || ecma_is_value_null (index_value))
        -:  284:  {
    #####:  285:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  286:  }
        -:  287:
    #####:  288:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  289:
    #####:  290:  ecma_free_value (index_value);
        -:  291:
    #####:  292:  return ret_str_p;
        -:  293:} /* ecma_op_array_get_to_string_at_index */
        -:  294:
        -:  295:/**
        -:  296: * The Array.prototype object's 'join' routine
        -:  297: *
        -:  298: * See also:
        -:  299: *          ECMA-262 v5, 15.4.4.5
        -:  300: *
        -:  301: * @return ecma value
        -:  302: *         Returned value must be freed with ecma_free_value.
        -:  303: */
        -:  304:static ecma_value_t
    #####:  305:ecma_builtin_array_prototype_join (ecma_value_t separator_arg, /**< separator argument */
        -:  306:                                   ecma_object_t *obj_p, /**< object */
        -:  307:                                   ecma_length_t length) /**< object's length */
        -:  308:{
        -:  309:  /* 4-5. */
    #####:  310:  ecma_string_t *separator_string_p = ecma_op_array_get_separator_string (separator_arg);
        -:  311:
    #####:  312:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  313:  {
    #####:  314:    return ECMA_VALUE_ERROR;
        -:  315:  }
        -:  316:
    #####:  317:  if (length == 0)
        -:  318:  {
        -:  319:    /* 6. */
    #####:  320:    ecma_deref_ecma_string (separator_string_p);
    #####:  321:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  322:  }
        -:  323:
        -:  324:  /* 7-8. */
    #####:  325:  ecma_string_t *first_string_p = ecma_op_array_get_to_string_at_index (obj_p, 0);
        -:  326:
    #####:  327:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  328:  {
    #####:  329:    ecma_deref_ecma_string (separator_string_p);
    #####:  330:    return ECMA_VALUE_ERROR;
        -:  331:  }
        -:  332:
    #####:  333:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  334:  ecma_deref_ecma_string (first_string_p);
        -:  335:
        -:  336:  /* 9-10. */
    #####:  337:  for (ecma_length_t k = 1; k < length; k++)
        -:  338:  {
        -:  339:    /* 10.a */
    #####:  340:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  341:
        -:  342:    /* 10.d */
    #####:  343:    ecma_string_t *next_string_p = ecma_op_array_get_to_string_at_index (obj_p, k);
        -:  344:
    #####:  345:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  346:    {
    #####:  347:      ecma_deref_ecma_string (separator_string_p);
    #####:  348:      ecma_stringbuilder_destroy (&builder);
    #####:  349:      return ECMA_VALUE_ERROR;
        -:  350:    }
        -:  351:
    #####:  352:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  353:    ecma_deref_ecma_string (next_string_p);
        -:  354:  }
        -:  355:
    #####:  356:  ecma_deref_ecma_string (separator_string_p);
    #####:  357:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  358:} /* ecma_builtin_array_prototype_join */
        -:  359:
        -:  360:/**
        -:  361: * The Array.prototype object's 'pop' routine
        -:  362: *
        -:  363: * See also:
        -:  364: *          ECMA-262 v5, 15.4.4.6
        -:  365: *
        -:  366: * @return ecma value
        -:  367: *         Returned value must be freed with ecma_free_value.
        -:  368: */
        -:  369:static ecma_value_t
    #####:  370:ecma_builtin_array_prototype_object_pop (ecma_object_t *obj_p, /**< object */
        -:  371:                                         ecma_length_t len) /**< object's length */
        -:  372:{
        -:  373:   /* 4. */
    #####:  374:  if (len == 0)
        -:  375:  {
        -:  376:    /* 4.a */
    #####:  377:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  378:
        -:  379:    /* 4.b */
    #####:  380:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  381:  }
        -:  382:
        -:  383:  /* 5.b */
    #####:  384:  len--;
    #####:  385:  ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, len);
        -:  386:
    #####:  387:  if (ECMA_IS_VALUE_ERROR (get_value))
        -:  388:  {
    #####:  389:    return get_value;
        -:  390:  }
        -:  391:
    #####:  392:  if (ecma_op_object_is_fast_array (obj_p))
        -:  393:  {
    #####:  394:    ecma_delete_fast_array_properties (obj_p, (uint32_t) len);
        -:  395:
    #####:  396:    return get_value;
        -:  397:  }
        -:  398:
        -:  399:  /* 5.c */
    #####:  400:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, len, true);
        -:  401:
    #####:  402:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  403:  {
    #####:  404:    ecma_free_value (get_value);
    #####:  405:    return del_value;
        -:  406:  }
        -:  407:
    #####:  408:  ecma_free_value (del_value);
        -:  409:
        -:  410:  /* 5.d */
    #####:  411:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  412:
    #####:  413:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  414:  {
    #####:  415:    ecma_free_value (get_value);
    #####:  416:    return set_length_value;
        -:  417:  }
        -:  418:
    #####:  419:  return get_value;
        -:  420:} /* ecma_builtin_array_prototype_object_pop */
        -:  421:
        -:  422:/**
        -:  423: * The Array.prototype object's 'push' routine
        -:  424: *
        -:  425: * See also:
        -:  426: *          ECMA-262 v5, 15.4.4.7
        -:  427: *
        -:  428: * @return ecma value
        -:  429: *         Returned value must be freed with ecma_free_value.
        -:  430: */
        -:  431:static ecma_value_t
    #####:  432:ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */
        -:  433:                                          uint32_t arguments_number, /**< number of arguments */
        -:  434:                                          ecma_object_t *obj_p, /**< object */
        -:  435:                                          ecma_length_t length) /**< object's length */
        -:  436:{
    #####:  437:  if (ecma_op_object_is_fast_array (obj_p))
        -:  438:  {
    #####:  439:    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)
        -:  440:    {
    #####:  441:      return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -:  442:    }
        -:  443:
    #####:  444:    if (arguments_number == 0)
        -:  445:    {
    #####:  446:      return ecma_make_uint32_value ((uint32_t) length);
        -:  447:    }
        -:  448:
    #####:  449:    uint32_t new_length = ((uint32_t) length) + arguments_number;
    #####:  450:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  451:    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;
        -:  452:
    #####:  453:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  454:    {
    #####:  455:      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);
        -:  456:    }
        -:  457:
    #####:  458:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;
        -:  459:
    #####:  460:    return ecma_make_uint32_value (new_length);
        -:  461:  }
        -:  462:
        -:  463:#if JERRY_ESNEXT
        -:  464:  /* 5. */
    #####:  465:  if ((ecma_number_t) (length + arguments_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  466:  {
    #####:  467:    return ecma_raise_type_error (ECMA_ERR_MSG ("Pushing element over 2**53-1 length is disallowed"));
        -:  468:  }
        -:  469:
        -:  470:  /* 6. */
    #####:  471:  for (ecma_length_t index = 0; index < arguments_number; index++, length++)
        -:  472:  {
        -:  473:    /* 6.b */
    #####:  474:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, length, argument_list_p[index], true);
        -:  475:
    #####:  476:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  477:    {
    #####:  478:      return put_value;
        -:  479:    }
        -:  480:  }
        -:  481:
    #####:  482:  ecma_number_t n = (ecma_number_t) length;
        -:  483:#else /* JERRY_ESNEXT */
    #####:  484:  ecma_number_t n = (ecma_number_t) length;
        -:  485:
        -:  486:  /* 5. */
    #####:  487:  for (ecma_length_t index = 0; index < arguments_number; index++, n++)
        -:  488:  {
        -:  489:    /* 5.b */
    #####:  490:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (n);
    #####:  491:    ecma_value_t put_value = ecma_op_object_put (obj_p, index_str_p, argument_list_p[index], true);
    #####:  492:    ecma_deref_ecma_string (index_str_p);
        -:  493:
    #####:  494:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  495:    {
        -:  496:      return put_value;
        -:  497:    }
        -:  498:  }
        -:  499:
        -:  500:#endif /* JERRY_ESNEXT */
        -:  501:  /* 6 - 7. */
    #####:  502:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);
        -:  503:
    #####:  504:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  505:  {
    #####:  506:    return set_length_value;
        -:  507:  }
        -:  508:
    #####:  509:  return ecma_make_number_value (n);
        -:  510:} /* ecma_builtin_array_prototype_object_push */
        -:  511:
        -:  512:/**
        -:  513: * The Array.prototype object's 'reverse' routine
        -:  514: *
        -:  515: * See also:
        -:  516: *          ECMA-262 v5, 15.4.4.8
        -:  517: *
        -:  518: * @return ecma value
        -:  519: *         Returned value must be freed with ecma_free_value.
        -:  520: */
        -:  521:static ecma_value_t
    #####:  522:ecma_builtin_array_prototype_object_reverse (ecma_value_t this_arg, /**< this argument */
        -:  523:                                             ecma_object_t *obj_p, /**< object */
        -:  524:                                             ecma_length_t len) /**< object's length */
        -:  525:{
        -:  526:
    #####:  527:  if (ecma_op_object_is_fast_array (obj_p))
        -:  528:  {
    #####:  529:    uint32_t middle = (uint32_t) len / 2;
    #####:  530:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  531:
    #####:  532:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  533:        && len != 0)
        -:  534:    {
    #####:  535:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  536:
    #####:  537:      for (uint32_t i = 0; i < middle; i++)
        -:  538:      {
    #####:  539:        ecma_value_t tmp = buffer_p[i];
    #####:  540:        buffer_p[i] = buffer_p[len - 1 - i];
    #####:  541:        buffer_p[len - 1 - i] = tmp;
        -:  542:      }
        -:  543:
    #####:  544:      return ecma_copy_value (this_arg);
        -:  545:    }
        -:  546:  }
        -:  547:
    #####:  548:  ecma_length_t middle = len / 2;
    #####:  549:  for (ecma_length_t lower = 0; lower < middle; lower++)
        -:  550:  {
    #####:  551:    ecma_length_t upper = len - lower - 1;
    #####:  552:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  553:
    #####:  554:    ecma_string_t *lower_str_p = ecma_new_ecma_string_from_length (lower);
    #####:  555:    ecma_string_t *upper_str_p = ecma_new_ecma_string_from_length (upper);
        -:  556:
        -:  557:#if JERRY_ESNEXT
    #####:  558:    ecma_value_t lower_value = ECMA_VALUE_EMPTY;
    #####:  559:    ecma_value_t upper_value = ECMA_VALUE_EMPTY;
        -:  560:
    #####:  561:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
        -:  562:
        -:  563:#if JERRY_BUILTIN_PROXY
    #####:  564:    if (ECMA_IS_VALUE_ERROR (has_lower))
        -:  565:    {
    #####:  566:      goto clean_up;
        -:  567:    }
        -:  568:#endif /* JERRY_BUILTIN_PROXY */
        -:  569:
    #####:  570:    bool lower_exist = ecma_is_value_true (has_lower);
        -:  571:
    #####:  572:    if (lower_exist)
        -:  573:    {
    #####:  574:      lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  575:
    #####:  576:      if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  577:      {
    #####:  578:        goto clean_up;
        -:  579:      }
        -:  580:    }
        -:  581:
    #####:  582:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  583:
        -:  584:#if JERRY_BUILTIN_PROXY
    #####:  585:    if (ECMA_IS_VALUE_ERROR (has_upper))
        -:  586:    {
    #####:  587:      goto clean_up;
        -:  588:    }
        -:  589:#endif /* JERRY_BUILTIN_PROXY */
        -:  590:
    #####:  591:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  592:
    #####:  593:    if (upper_exist)
        -:  594:    {
    #####:  595:      upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  596:
    #####:  597:      if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  598:      {
    #####:  599:        goto clean_up;
        -:  600:      }
        -:  601:    }
        -:  602:#else /* !JERRY_ESNEXT */
    #####:  603:    ecma_value_t lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  604:
    #####:  605:    if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  606:    {
    #####:  607:      ecma_deref_ecma_string (lower_str_p);
    #####:  608:      ecma_deref_ecma_string (upper_str_p);
    #####:  609:      return ret_value;
        -:  610:    }
        -:  611:
    #####:  612:    ecma_value_t upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  613:
    #####:  614:    if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  615:    {
        -:  616:      goto clean_up;
        -:  617:    }
        -:  618:
    #####:  619:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
    #####:  620:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  621:
    #####:  622:    bool lower_exist = ecma_is_value_true (has_lower);
    #####:  623:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  624:#endif /* JERRY_ESNEXT */
        -:  625:
    #####:  626:    if (lower_exist && upper_exist)
    #####:  627:    {
    #####:  628:      ecma_value_t outer_put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  629:
    #####:  630:      if (ECMA_IS_VALUE_ERROR (outer_put_value))
        -:  631:      {
    #####:  632:        goto clean_up;
        -:  633:      }
        -:  634:
    #####:  635:      ecma_value_t inner_put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  636:
    #####:  637:      if (ECMA_IS_VALUE_ERROR (inner_put_value))
        -:  638:      {
    #####:  639:        goto clean_up;
        -:  640:      }
        -:  641:    }
    #####:  642:    else if (!lower_exist && upper_exist)
    #####:  643:    {
    #####:  644:      ecma_value_t put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  645:
    #####:  646:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  647:      {
    #####:  648:        goto clean_up;
        -:  649:      }
        -:  650:
    #####:  651:      ecma_value_t del_value = ecma_op_object_delete (obj_p, upper_str_p, true);
        -:  652:
    #####:  653:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  654:      {
    #####:  655:        goto clean_up;
        -:  656:      }
        -:  657:    }
    #####:  658:    else if (lower_exist)
        -:  659:    {
    #####:  660:      ecma_value_t del_value = ecma_op_object_delete (obj_p, lower_str_p, true);
        -:  661:
    #####:  662:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  663:      {
    #####:  664:        goto clean_up;
        -:  665:      }
        -:  666:
    #####:  667:      ecma_value_t put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  668:
    #####:  669:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  670:      {
    #####:  671:        goto clean_up;
        -:  672:      }
        -:  673:    }
        -:  674:
    #####:  675:    ret_value = ECMA_VALUE_EMPTY;
        -:  676:
    #####:  677:clean_up:
    #####:  678:    ecma_free_value (upper_value);
    #####:  679:    ecma_free_value (lower_value);
    #####:  680:    ecma_deref_ecma_string (lower_str_p);
    #####:  681:    ecma_deref_ecma_string (upper_str_p);
        -:  682:
    #####:  683:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  684:    {
    #####:  685:      return ret_value;
        -:  686:    }
        -:  687:  }
        -:  688:
    #####:  689:  return ecma_copy_value (this_arg);
        -:  690:} /* ecma_builtin_array_prototype_object_reverse */
        -:  691:
        -:  692:/**
        -:  693: * The Array.prototype object's 'shift' routine
        -:  694: *
        -:  695: * See also:
        -:  696: *          ECMA-262 v5, 15.4.4.9
        -:  697: *
        -:  698: * @return ecma value
        -:  699: *         Returned value must be freed with ecma_free_value.
        -:  700: */
        -:  701:static ecma_value_t
    #####:  702:ecma_builtin_array_prototype_object_shift (ecma_object_t *obj_p, /**< object */
        -:  703:                                           ecma_length_t len) /**< object's length */
        -:  704:{
        -:  705:  /* 4. */
    #####:  706:  if (len == 0)
        -:  707:  {
    #####:  708:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  709:
    #####:  710:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  711:  }
        -:  712:
    #####:  713:  if (ecma_op_object_is_fast_array (obj_p))
        -:  714:  {
    #####:  715:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  716:
    #####:  717:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  718:        && len != 0)
        -:  719:    {
    #####:  720:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
    #####:  721:      ecma_value_t ret_value = buffer_p[0];
        -:  722:
    #####:  723:      if (ecma_is_value_object (ret_value))
        -:  724:      {
    #####:  725:        ecma_ref_object (ecma_get_object_from_value (ret_value));
        -:  726:      }
        -:  727:
    #####:  728:      memmove (buffer_p, buffer_p + 1, (size_t) (sizeof (ecma_value_t) * (len - 1)));
        -:  729:
    #####:  730:      buffer_p[len - 1] = ECMA_VALUE_UNDEFINED;
    #####:  731:      ecma_delete_fast_array_properties (obj_p, (uint32_t) (len - 1));
        -:  732:
    #####:  733:      return ret_value;
        -:  734:    }
        -:  735:  }
        -:  736:
        -:  737:  /* 5. */
    #####:  738:  ecma_value_t first_value = ecma_op_object_get_by_index (obj_p, 0);
        -:  739:
    #####:  740:  if (ECMA_IS_VALUE_ERROR (first_value))
        -:  741:  {
    #####:  742:    return first_value;
        -:  743:  }
        -:  744:
        -:  745:  /* 6. and 7. */
    #####:  746:  for (ecma_length_t k = 1; k < len; k++)
        -:  747:  {
        -:  748:    /* 7.a - 7.c */
    #####:  749:    ecma_value_t curr_value = ecma_op_object_find_by_index (obj_p, k);
        -:  750:
    #####:  751:    if (ECMA_IS_VALUE_ERROR (curr_value))
        -:  752:    {
    #####:  753:      ecma_free_value (first_value);
    #####:  754:      return curr_value;
        -:  755:    }
        -:  756:
        -:  757:    /* 7.b */
    #####:  758:    ecma_length_t to = k - 1;
        -:  759:    ecma_value_t operation_value;
        -:  760:
    #####:  761:    if (ecma_is_value_found (curr_value))
        -:  762:    {
        -:  763:      /* 7.d.i, 7.d.ii */
    #####:  764:      operation_value = ecma_op_object_put_by_index (obj_p, to, curr_value, true);
    #####:  765:      ecma_free_value (curr_value);
        -:  766:    }
        -:  767:    else
        -:  768:    {
        -:  769:      /* 7.e.i */
    #####:  770:      operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -:  771:    }
        -:  772:
    #####:  773:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -:  774:    {
    #####:  775:      ecma_free_value (first_value);
    #####:  776:      return operation_value;
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  /* 8. */
    #####:  781:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, --len, true);
        -:  782:
    #####:  783:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  784:  {
    #####:  785:    ecma_free_value (first_value);
    #####:  786:    return del_value;
        -:  787:  }
        -:  788:
        -:  789:  /* 9. */
    #####:  790:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  791:
    #####:  792:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  793:  {
    #####:  794:    ecma_free_value (first_value);
    #####:  795:    return set_length_value;
        -:  796:  }
        -:  797:
        -:  798:  /* 10. */
    #####:  799:  return first_value;
        -:  800:} /* ecma_builtin_array_prototype_object_shift */
        -:  801:
        -:  802:/**
        -:  803: * The Array.prototype object's 'slice' routine
        -:  804: *
        -:  805: * See also:
        -:  806: *          ECMA-262 v5, 15.4.4.10
        -:  807: *
        -:  808: * @return ecma value
        -:  809: *         Returned value must be freed with ecma_free_value.
        -:  810: */
        -:  811:static ecma_value_t
    #####:  812:ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */
        -:  813:                                           ecma_value_t arg2, /**< end */
        -:  814:                                           ecma_object_t *obj_p, /**< object */
        -:  815:                                           ecma_length_t len) /**< object's length */
        -:  816:{
    #####:  817:  ecma_length_t start = 0, end = len;
        -:  818:
        -:  819:  /* 5. 6.*/
    #####:  820:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,
        -:  821:                                                                      len,
        -:  822:                                                                      &start)))
        -:  823:  {
    #####:  824:    return ECMA_VALUE_ERROR;
        -:  825:  }
        -:  826:
        -:  827:  /* 7. */
    #####:  828:  if (ecma_is_value_undefined (arg2))
        -:  829:  {
    #####:  830:    end = len;
        -:  831:  }
        -:  832:  else
        -:  833:  {
        -:  834:    /* 7. part 2, 8.*/
    #####:  835:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,
        -:  836:                                                                        len,
        -:  837:                                                                        &end)))
        -:  838:    {
    #####:  839:      return ECMA_VALUE_ERROR;
        -:  840:    }
        -:  841:  }
        -:  842:
    #####:  843:  JERRY_ASSERT (start <= len && end <= len);
        -:  844:
    #####:  845:  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);
    #####:  846:  ecma_length_t copied_length = (end > start) ? end - start : 0;
        -:  847:#if JERRY_ESNEXT
    #####:  848:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);
        -:  849:
    #####:  850:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  851:  {
    #####:  852:    return ECMA_VALUE_ERROR;
        -:  853:  }
        -:  854:
    #####:  855:  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);
        -:  856:#else /* !JERRY_ESNEXT */
    #####:  857:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  858:#endif /* JERRY_ESNEXT */
        -:  859:
    #####:  860:  if (use_fast_path && copied_length > 0)
        -:  861:  {
    #####:  862:    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;
        -:  863:
    #####:  864:    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -:  865:    {
    #####:  866:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -:  867:      {
        -:  868:        /**
        -:  869:         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.
        -:  870:         * There is no need to do any copy.
        -:  871:         */
    #####:  872:        return ecma_make_object_value (new_array_p);
        -:  873:      }
        -:  874:
        -:  875:      /* Source array's length could be changed during the start/end normalization.
        -:  876:       * If the "end" value is greater than the current length, clamp the value to avoid buffer-overflow. */
    #####:  877:      if (ext_from_obj_p->u.array.length < end)
        -:  878:      {
    #####:  879:        end = ext_from_obj_p->u.array.length;
        -:  880:      }
        -:  881:
    #####:  882:      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;
        -:  883:
        -:  884:#if JERRY_ESNEXT
    #####:  885:      uint32_t target_length = ext_to_obj_p->u.array.length;
        -:  886:      ecma_value_t *to_buffer_p;
    #####:  887:      JERRY_ASSERT (copied_length <= UINT32_MAX);
        -:  888:
    #####:  889:      if (copied_length == target_length)
        -:  890:      {
    #####:  891:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  892:      }
    #####:  893:      else if (copied_length > target_length)
        -:  894:      {
    #####:  895:        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);
        -:  896:      }
        -:  897:      else
        -:  898:      {
    #####:  899:        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);
    #####:  900:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  901:      }
        -:  902:#else /* !JERRY_ESNEXT */
    #####:  903:      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  904:#endif /* JERRY_ESNEXT */
        -:  905:
    #####:  906:      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  907:
        -:  908:      /* 9. */
    #####:  909:      uint32_t n = 0;
        -:  910:
    #####:  911:      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)
        -:  912:      {
        -:  913:#if JERRY_ESNEXT
    #####:  914:        ecma_free_value_if_not_object (to_buffer_p[n]);
        -:  915:#endif /* JERRY_ESNEXT */
    #####:  916:        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);
        -:  917:      }
        -:  918:
    #####:  919:      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;
        -:  920:
    #####:  921:      return ecma_make_object_value (new_array_p);
        -:  922:    }
        -:  923:  }
        -:  924:
        -:  925:  /* 9. */
    #####:  926:  ecma_length_t n = 0;
        -:  927:
        -:  928:  /* 10. */
    #####:  929:  for (ecma_length_t k = start; k < end; k++, n++)
        -:  930:  {
        -:  931:    /* 10.c */
    #####:  932:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);
        -:  933:
    #####:  934:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  935:    {
    #####:  936:      ecma_deref_object (new_array_p);
    #####:  937:      return get_value;
        -:  938:    }
        -:  939:
    #####:  940:    if (ecma_is_value_found (get_value))
        -:  941:    {
        -:  942:      /* 10.c.ii */
        -:  943:      ecma_value_t put_comp;
        -:  944:#if JERRY_ESNEXT
    #####:  945:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  946:#else /* !JERRY_ESNEXT */
    #####:  947:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -:  948:#endif /* JERRY_ESNEXT */
    #####:  949:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -:  950:                                                        n,
        -:  951:                                                        get_value,
        -:  952:                                                        prop_flags);
    #####:  953:      ecma_free_value (get_value);
        -:  954:
        -:  955:#if JERRY_ESNEXT
    #####:  956:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  957:      {
    #####:  958:        ecma_deref_object (new_array_p);
    #####:  959:        return put_comp;
        -:  960:      }
        -:  961:#else /* !JERRY_ESNEXT */
        -:  962:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  963:#endif /* JERRY_ESNEXT */
        -:  964:    }
        -:  965:  }
        -:  966:
        -:  967:#if JERRY_ESNEXT
    #####:  968:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));
        -:  969:
    #####:  970:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  971:  {
    #####:  972:    ecma_deref_object (new_array_p);
    #####:  973:    return set_length_value;
        -:  974:  }
        -:  975:#endif /* JERRY_ESNEXT */
        -:  976:
    #####:  977:  return ecma_make_object_value (new_array_p);
        -:  978:} /* ecma_builtin_array_prototype_object_slice */
        -:  979:
        -:  980:/**
        -:  981: * SortCompare abstract method
        -:  982: *
        -:  983: * See also:
        -:  984: *          ECMA-262 v5, 15.4.4.11
        -:  985: *
        -:  986: * @return ecma value
        -:  987: *         Returned value must be freed with ecma_free_value.
        -:  988: */
        -:  989:static ecma_value_t
    #####:  990:ecma_builtin_array_prototype_object_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -:  991:                                                         ecma_value_t rhs, /**< right value */
        -:  992:                                                         ecma_value_t compare_func, /**< compare function */
        -:  993:                                                         ecma_object_t *array_buffer_p) /**< arrayBuffer */
        -:  994:{
        -:  995:  JERRY_UNUSED (array_buffer_p);
        -:  996:  /*
        -:  997:   * ECMA-262 v5, 15.4.4.11 NOTE1: Because non-existent property values always
        -:  998:   * compare greater than undefined property values, and undefined always
        -:  999:   * compares greater than any other value, undefined property values always
        -: 1000:   * sort to the end of the result, followed by non-existent property values.
        -: 1001:   */
    #####: 1002:  bool lhs_is_undef = ecma_is_value_undefined (lhs);
    #####: 1003:  bool rhs_is_undef = ecma_is_value_undefined (rhs);
        -: 1004:
    #####: 1005:  if (lhs_is_undef)
        -: 1006:  {
    #####: 1007:    return ecma_make_integer_value (rhs_is_undef ? 0 : 1);
        -: 1008:  }
        -: 1009:
    #####: 1010:  if (rhs_is_undef)
        -: 1011:  {
    #####: 1012:    return ecma_make_integer_value (-1);
        -: 1013:  }
        -: 1014:
    #####: 1015:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1016:
    #####: 1017:  if (ecma_is_value_undefined (compare_func))
        -: 1018:  {
        -: 1019:    /* Default comparison when no compare_func is passed. */
    #####: 1020:    ecma_string_t *lhs_str_p = ecma_op_to_string (lhs);
    #####: 1021:    if (JERRY_UNLIKELY (lhs_str_p == NULL))
        -: 1022:    {
    #####: 1023:      return ECMA_VALUE_ERROR;
        -: 1024:    }
        -: 1025:
    #####: 1026:    ecma_string_t *rhs_str_p = ecma_op_to_string (rhs);
    #####: 1027:    if (JERRY_UNLIKELY (rhs_str_p == NULL))
        -: 1028:    {
    #####: 1029:      ecma_deref_ecma_string (lhs_str_p);
    #####: 1030:      return ECMA_VALUE_ERROR;
        -: 1031:    }
        -: 1032:
    #####: 1033:    if (ecma_compare_ecma_strings_relational (lhs_str_p, rhs_str_p))
        -: 1034:    {
    #####: 1035:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1036:    }
    #####: 1037:    else if (!ecma_compare_ecma_strings (lhs_str_p, rhs_str_p))
        -: 1038:    {
    #####: 1039:      result = ECMA_NUMBER_ONE;
        -: 1040:    }
        -: 1041:    else
        -: 1042:    {
    #####: 1043:      result = ECMA_NUMBER_ZERO;
        -: 1044:    }
        -: 1045:
    #####: 1046:    ecma_deref_ecma_string (rhs_str_p);
    #####: 1047:    ecma_deref_ecma_string (lhs_str_p);
        -: 1048:  }
        -: 1049:  else
        -: 1050:  {
        -: 1051:    /*
        -: 1052:     * compare_func, if not undefined, will always contain a callable function object.
        -: 1053:     * We checked this previously, before this function was called.
        -: 1054:     */
    #####: 1055:    JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1056:    ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1057:
    #####: 1058:    ecma_value_t compare_args[] = { lhs, rhs };
        -: 1059:
    #####: 1060:    ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1061:                                                     ECMA_VALUE_UNDEFINED,
        -: 1062:                                                     compare_args,
        -: 1063:                                                     2);
    #####: 1064:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1065:    {
    #####: 1066:      return call_value;
        -: 1067:    }
        -: 1068:
    #####: 1069:    if (!ecma_is_value_number (call_value))
        -: 1070:    {
    #####: 1071:      ecma_number_t ret_num;
        -: 1072:
    #####: 1073:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (call_value, &ret_num)))
        -: 1074:      {
    #####: 1075:        ecma_free_value (call_value);
    #####: 1076:        return ECMA_VALUE_ERROR;
        -: 1077:      }
        -: 1078:
    #####: 1079:      result = ret_num;
        -: 1080:    }
        -: 1081:    else
        -: 1082:    {
    #####: 1083:      result = ecma_get_number_from_value (call_value);
        -: 1084:    }
        -: 1085:
    #####: 1086:    ecma_free_value (call_value);
        -: 1087:  }
        -: 1088:
    #####: 1089:  return ecma_make_number_value (result);
        -: 1090:} /* ecma_builtin_array_prototype_object_sort_compare_helper */
        -: 1091:
        -: 1092:/**
        -: 1093: * The Array.prototype object's 'sort' routine
        -: 1094: *
        -: 1095: * See also:
        -: 1096: *          ECMA-262 v5, 15.4.4.11
        -: 1097: *
        -: 1098: * @return ecma value
        -: 1099: *         Returned value must be freed with ecma_free_value.
        -: 1100: */
        -: 1101:static ecma_value_t
    #####: 1102:ecma_builtin_array_prototype_object_sort (ecma_value_t this_arg, /**< this argument */
        -: 1103:                                          ecma_value_t arg1, /**< comparefn */
        -: 1104:                                          ecma_object_t *obj_p) /**< object */
        -: 1105:{
        -: 1106:  /* Check if the provided compare function is callable. */
    #####: 1107:  if (!ecma_is_value_undefined (arg1) && !ecma_op_is_callable (arg1))
        -: 1108:  {
    #####: 1109:    return ecma_raise_type_error (ECMA_ERR_MSG ("Compare function is not callable"));
        -: 1110:  }
        -: 1111:
    #####: 1112:  ecma_length_t len;
    #####: 1113:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &len);
        -: 1114:
    #####: 1115:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1116:  {
    #####: 1117:    return len_value;
        -: 1118:  }
    #####: 1119:  ecma_collection_t *array_index_props_p = ecma_new_collection ();
        -: 1120:
    #####: 1121:  for (uint32_t i = 0; i < len; i++)
        -: 1122:  {
    #####: 1123:    ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -: 1124:
    #####: 1125:    ecma_property_descriptor_t prop_desc;
    #####: 1126:    ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 1127:
    #####: 1128:    if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 1129:    {
    #####: 1130:      ecma_collection_free (array_index_props_p);
    #####: 1131:      ecma_deref_ecma_string (prop_name_p);
    #####: 1132:      return get_desc;
        -: 1133:    }
        -: 1134:
    #####: 1135:    if (ecma_is_value_true (get_desc))
        -: 1136:    {
    #####: 1137:      ecma_ref_ecma_string (prop_name_p);
    #####: 1138:      ecma_collection_push_back (array_index_props_p, ecma_make_string_value (prop_name_p));
    #####: 1139:      ecma_free_property_descriptor (&prop_desc);
    #####: 1140:      continue;
        -: 1141:    }
        -: 1142:  }
        -: 1143:
    #####: 1144:  uint32_t defined_prop_count = array_index_props_p->item_count;
        -: 1145:
    #####: 1146:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 1147:  uint32_t copied_num = 0;
    #####: 1148:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, defined_prop_count, ecma_value_t);
        -: 1149:
    #####: 1150:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1151:
        -: 1152:  /* Copy unsorted array into a native c array. */
    #####: 1153:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1154:  {
    #####: 1155:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1156:
    #####: 1157:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1158:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1159:
    #####: 1160:    if (index >= len)
        -: 1161:    {
    #####: 1162:      break;
        -: 1163:    }
        -: 1164:
    #####: 1165:    ecma_value_t index_value = ecma_op_object_get (obj_p, property_name_p);
        -: 1166:
    #####: 1167:    if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1168:    {
    #####: 1169:      goto clean_up;
        -: 1170:    }
        -: 1171:
    #####: 1172:    values_buffer[copied_num++] = index_value;
        -: 1173:  }
        -: 1174:
    #####: 1175:  JERRY_ASSERT (copied_num == defined_prop_count);
        -: 1176:
        -: 1177:  /* Sorting. */
    #####: 1178:  if (copied_num > 1)
        -: 1179:  {
    #####: 1180:    const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_array_prototype_object_sort_compare_helper;
    #####: 1181:    ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
        -: 1182:                                                                           (uint32_t) (copied_num),
        -: 1183:                                                                           arg1,
        -: 1184:                                                                           sort_cb,
        -: 1185:                                                                           NULL);
    #####: 1186:    if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1187:    {
    #####: 1188:      goto clean_up;
        -: 1189:    }
        -: 1190:
    #####: 1191:    ecma_free_value (sort_value);
        -: 1192:  }
        -: 1193:
        -: 1194:  /* Put sorted values to the front of the array. */
    #####: 1195:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1196:  {
    #####: 1197:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, index, values_buffer[index], true);
        -: 1198:
    #####: 1199:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1200:    {
    #####: 1201:      goto clean_up;
        -: 1202:    }
        -: 1203:  }
        -: 1204:
    #####: 1205:  ret_value = ECMA_VALUE_EMPTY;
        -: 1206:
    #####: 1207:clean_up:
        -: 1208:  /* Free values that were copied to the local array. */
    #####: 1209:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1210:  {
    #####: 1211:    ecma_free_value (values_buffer[index]);
        -: 1212:  }
        -: 1213:
    #####: 1214:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1215:
    #####: 1216:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1217:  {
    #####: 1218:    ecma_collection_free (array_index_props_p);
    #####: 1219:    return ret_value;
        -: 1220:  }
        -: 1221:
    #####: 1222:  JERRY_ASSERT (ecma_is_value_empty (ret_value));
        -: 1223:
        -: 1224:  /* Undefined properties should be in the back of the array. */
    #####: 1225:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1226:
    #####: 1227:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1228:  {
    #####: 1229:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1230:
    #####: 1231:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1232:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1233:
    #####: 1234:    if (index >= copied_num && index < len)
        -: 1235:    {
    #####: 1236:      ecma_value_t del_value = ecma_op_object_delete (obj_p, property_name_p, true);
        -: 1237:
    #####: 1238:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1239:      {
    #####: 1240:        ecma_collection_free (array_index_props_p);
    #####: 1241:        return del_value;
        -: 1242:      }
        -: 1243:    }
        -: 1244:  }
        -: 1245:
    #####: 1246:  ecma_collection_free (array_index_props_p);
        -: 1247:
    #####: 1248:  return ecma_copy_value (this_arg);
        -: 1249:} /* ecma_builtin_array_prototype_object_sort */
        -: 1250:
        -: 1251:/**
        -: 1252: * The Array.prototype object's 'splice' routine
        -: 1253: *
        -: 1254: * See also:
        -: 1255: *          ECMA-262 v11, 22.1.3.28
        -: 1256: *          ECMA-262 v5, 15.4.4.12
        -: 1257: *
        -: 1258: * @return ecma value
        -: 1259: *         Returned value must be freed with ecma_free_value.
        -: 1260: */
        -: 1261:static ecma_value_t
    #####: 1262:ecma_builtin_array_prototype_object_splice (const ecma_value_t args[], /**< arguments list */
        -: 1263:                                            uint32_t args_number, /**< number of arguments */
        -: 1264:                                            ecma_object_t *obj_p, /**< object */
        -: 1265:                                            ecma_length_t len) /**< object's length */
        -: 1266:{
    #####: 1267:  ecma_length_t actual_start = 0;
    #####: 1268:  ecma_length_t actual_delete_count = 0;
    #####: 1269:  ecma_length_t insert_count = 0;
        -: 1270:
    #####: 1271:  if (args_number > 0)
        -: 1272:  {
        -: 1273:    /* ES5.1: 6, ES11: 4. */
    #####: 1274:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1275:                                                                        len,
        -: 1276:                                                                        &actual_start)))
        -: 1277:    {
    #####: 1278:      return ECMA_VALUE_ERROR;
        -: 1279:    }
        -: 1280:
        -: 1281:    /* ES11: 6. */
    #####: 1282:    if (args_number == 1)
        -: 1283:    {
    #####: 1284:      actual_delete_count = len - actual_start;
        -: 1285:    }
        -: 1286:    /* ES11: 7. */
        -: 1287:    else
        -: 1288:    {
    #####: 1289:      insert_count = args_number - 2;
        -: 1290:
    #####: 1291:      ecma_number_t delete_num;
    #####: 1292:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &delete_num)))
        -: 1293:      {
    #####: 1294:        return ECMA_VALUE_ERROR;
        -: 1295:      }
        -: 1296:
        -: 1297:      /* ES5.1: 7 */
    #####: 1298:      actual_delete_count = (ecma_length_t) (JERRY_MIN (JERRY_MAX (delete_num, 0),
        -: 1299:                                                        (ecma_number_t) (len - actual_start)));
        -: 1300:    }
        -: 1301:  }
        -: 1302:
    #####: 1303:  ecma_length_t new_length = len + insert_count - actual_delete_count;
        -: 1304:
        -: 1305:#if JERRY_ESNEXT
        -: 1306:  /* ES11: 8. */
    #####: 1307:  if ((ecma_number_t) new_length > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1308:  {
    #####: 1309:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid new Array length"));
        -: 1310:  }
        -: 1311:
        -: 1312:  /* ES11: 9. */
    #####: 1313:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, actual_delete_count);
        -: 1314:
    #####: 1315:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1316:  {
    #####: 1317:    return ECMA_VALUE_ERROR;
        -: 1318:  }
        -: 1319:#else /* !JERRY_ESNEXT */
        -: 1320:  /* ES5.1: 2. */
    #####: 1321:  ecma_object_t *new_array_p = ecma_op_new_array_object (actual_delete_count);
        -: 1322:#endif /* JERRY_ESNEXT */
        -: 1323:
        -: 1324:  /* ES5.1: 8, ES11: 10. */
    #####: 1325:  ecma_length_t k = 0;
        -: 1326:
        -: 1327:  /* ES5.1: 9, ES11: 11. */
    #####: 1328:  for (; k < actual_delete_count; k++)
        -: 1329:  {
    #####: 1330:    ecma_length_t from = actual_start + k;
    #####: 1331:    ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1332:
    #####: 1333:    if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1334:    {
    #####: 1335:      ecma_deref_object (new_array_p);
    #####: 1336:      return from_present;
        -: 1337:    }
        -: 1338:
    #####: 1339:    if (ecma_is_value_found (from_present))
        -: 1340:    {
        -: 1341:#if JERRY_ESNEXT
    #####: 1342:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 1343:#else /* !JERRY_ESNEXT */
    #####: 1344:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 1345:#endif /* JERRY_ESNEXT */
        -: 1346:
    #####: 1347:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 1348:                                                                     k,
        -: 1349:                                                                     from_present,
        -: 1350:                                                                     prop_flags);
    #####: 1351:      ecma_free_value (from_present);
        -: 1352:
        -: 1353:#if JERRY_ESNEXT
    #####: 1354:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 1355:      {
    #####: 1356:        ecma_deref_object (new_array_p);
    #####: 1357:        return put_comp;
        -: 1358:      }
        -: 1359:#else /* !JERRY_ESNEXT */
        -: 1360:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 1361:#endif /* JERRY_ESNEXT */
        -: 1362:    }
        -: 1363:  }
        -: 1364:
        -: 1365:#if JERRY_ESNEXT
        -: 1366:  /* ES11: 12. */
    #####: 1367:  ecma_value_t set_length = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -: 1368:                                                                            ((ecma_number_t) actual_delete_count));
        -: 1369:
    #####: 1370:  if (ECMA_IS_VALUE_ERROR (set_length))
        -: 1371:  {
    #####: 1372:    ecma_deref_object (new_array_p);
    #####: 1373:    return set_length;
        -: 1374:  }
        -: 1375:#endif /* JERRY_ESNEXT */
        -: 1376:
        -: 1377:  /* ES5.1: 12, ES11: 15. */
    #####: 1378:  if (insert_count < actual_delete_count)
        -: 1379:  {
    #####: 1380:    for (k = actual_start; k < len - actual_delete_count; k++)
        -: 1381:    {
    #####: 1382:      ecma_length_t from = k + actual_delete_count;
    #####: 1383:      ecma_length_t to = k + insert_count;
        -: 1384:
    #####: 1385:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1386:
    #####: 1387:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1388:      {
    #####: 1389:        ecma_deref_object (new_array_p);
    #####: 1390:        return from_present;
        -: 1391:      }
        -: 1392:
        -: 1393:      ecma_value_t operation_value;
        -: 1394:
    #####: 1395:      if (ecma_is_value_found (from_present))
        -: 1396:      {
    #####: 1397:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1398:        ecma_free_value (from_present);
        -: 1399:      }
        -: 1400:      else
        -: 1401:      {
    #####: 1402:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1403:      }
        -: 1404:
    #####: 1405:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1406:      {
    #####: 1407:        ecma_deref_object (new_array_p);
    #####: 1408:        return operation_value;
        -: 1409:      }
        -: 1410:    }
        -: 1411:
    #####: 1412:    k = len;
        -: 1413:
    #####: 1414:    for (k = len; k > new_length; k--)
        -: 1415:    {
    #####: 1416:      ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, k - 1, true);
        -: 1417:
    #####: 1418:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1419:      {
    #####: 1420:        ecma_deref_object (new_array_p);
    #####: 1421:        return del_value;
        -: 1422:      }
        -: 1423:    }
        -: 1424:  }
        -: 1425:  /* ES5.1: 13, ES11: 16. */
    #####: 1426:  else if (insert_count > actual_delete_count)
        -: 1427:  {
    #####: 1428:    for (k = len - actual_delete_count; k > actual_start; k--)
        -: 1429:    {
    #####: 1430:      ecma_length_t from = k + actual_delete_count - 1;
    #####: 1431:      ecma_length_t to = k + insert_count - 1;
        -: 1432:
    #####: 1433:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1434:
    #####: 1435:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1436:      {
    #####: 1437:        ecma_deref_object (new_array_p);
    #####: 1438:        return from_present;
        -: 1439:      }
        -: 1440:
        -: 1441:      ecma_value_t operation_value;
        -: 1442:
    #####: 1443:      if (ecma_is_value_found (from_present))
        -: 1444:      {
    #####: 1445:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1446:        ecma_free_value (from_present);
        -: 1447:      }
        -: 1448:      else
        -: 1449:      {
    #####: 1450:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1451:      }
        -: 1452:
    #####: 1453:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1454:      {
    #####: 1455:        ecma_deref_object (new_array_p);
    #####: 1456:        return operation_value;
        -: 1457:      }
        -: 1458:    }
        -: 1459:  }
        -: 1460:
        -: 1461:  /* ES5.1: 14, ES11: 17. */
    #####: 1462:  k = actual_start;
        -: 1463:
        -: 1464:  /* ES5.1: 15, ES11: 18. */
    #####: 1465:  uint32_t idx = 0;
    #####: 1466:  for (uint32_t arg_index = 2; arg_index < args_number; arg_index++, idx++)
        -: 1467:  {
    #####: 1468:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p,
        -: 1469:                                                          actual_start + idx,
    #####: 1470:                                                          args[arg_index],
        -: 1471:                                                          true);
        -: 1472:
    #####: 1473:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1474:    {
    #####: 1475:      ecma_deref_object (new_array_p);
    #####: 1476:      return put_value;
        -: 1477:    }
        -: 1478:  }
        -: 1479:
        -: 1480:  /* ES5.1: 16, ES11: 19. */
    #####: 1481:  ecma_value_t set_new_length = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) new_length));
        -: 1482:
    #####: 1483:  if (ECMA_IS_VALUE_ERROR (set_new_length))
        -: 1484:  {
    #####: 1485:    ecma_deref_object (new_array_p);
    #####: 1486:    return set_new_length;
        -: 1487:  }
        -: 1488:
        -: 1489:  /* ES5.1: 17, ES11: 20. */
    #####: 1490:  return ecma_make_object_value (new_array_p);
        -: 1491:} /* ecma_builtin_array_prototype_object_splice */
        -: 1492:
        -: 1493:/**
        -: 1494: * The Array.prototype object's 'unshift' routine
        -: 1495: *
        -: 1496: * See also:
        -: 1497: *          ECMA-262  v5, 15.4.4.13
        -: 1498: *          ECMA-262 v11, 22.1.3.31
        -: 1499: *
        -: 1500: * @return ecma value
        -: 1501: *         Returned value must be freed with ecma_free_value.
        -: 1502: */
        -: 1503:static ecma_value_t
    #####: 1504:ecma_builtin_array_prototype_object_unshift (const ecma_value_t args[], /**< arguments list */
        -: 1505:                                             uint32_t args_number, /**< number of arguments */
        -: 1506:                                             ecma_object_t *obj_p, /**< object */
        -: 1507:                                             ecma_length_t len) /**< object's length */
        -: 1508:{
        -: 1509:
    #####: 1510:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1511:  {
    #####: 1512:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1513:
    #####: 1514:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1515:        && len != 0)
        -: 1516:    {
    #####: 1517:      if (args_number > UINT32_MAX - len)
        -: 1518:      {
    #####: 1519:        return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -: 1520:      }
        -: 1521:
    #####: 1522:      if (args_number == 0)
        -: 1523:      {
    #####: 1524:        return ecma_make_uint32_value ((uint32_t) len);
        -: 1525:      }
        -: 1526:
    #####: 1527:      uint32_t new_length = ((uint32_t) len) + args_number;
    #####: 1528:      ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length);
    #####: 1529:      memmove (buffer_p + args_number, buffer_p, (size_t) (sizeof (ecma_value_t) * len));
        -: 1530:
    #####: 1531:      uint32_t index = 0;
        -: 1532:
    #####: 1533:      while (index < args_number)
        -: 1534:      {
    #####: 1535:        buffer_p[index] = ecma_copy_value_if_not_object (args[index]);
    #####: 1536:        index++;
        -: 1537:      }
        -: 1538:
    #####: 1539:      ext_obj_p->u.array.length_prop_and_hole_count -= args_number * ECMA_FAST_ARRAY_HOLE_ONE;
        -: 1540:
    #####: 1541:      return ecma_make_uint32_value (new_length);
        -: 1542:    }
        -: 1543:  }
        -: 1544:
        -: 1545:#if JERRY_ESNEXT
    #####: 1546:  const bool should_iterate = args_number > 0;
        -: 1547:#else /* !JERRY_ESNEXT */
        -: 1548:  const bool should_iterate = true;
        -: 1549:#endif /* JERRY_ESNEXT */
    #####: 1550:  if (should_iterate)
        -: 1551:  {
        -: 1552:#if JERRY_ESNEXT
        -: 1553:    /* ES11:4.a. */
    #####: 1554:    if ((ecma_number_t) (len + args_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1555:    {
    #####: 1556:      return ecma_raise_type_error (ECMA_ERR_MSG ("Unshift elements over 2**53-1 length is disallowed"));
        -: 1557:    }
        -: 1558:#endif /* JERRY_ESNEXT */
        -: 1559:
        -: 1560:    /* ES5.1:5.,6. ES11: 4.b, 4.c */
    #####: 1561:    for (ecma_length_t k = len; k > 0; k--)
        -: 1562:    {
        -: 1563:      /* ES5.1:6.a, 6.c, ES11:4.c.i., 4.c.iii.  */
    #####: 1564:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k - 1);
        -: 1565:
    #####: 1566:      if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1567:      {
    #####: 1568:        return get_value;
        -: 1569:      }
        -: 1570:
        -: 1571:      /* ES5.1:6.b, ES11:4.c.ii. */
    #####: 1572:      ecma_number_t new_idx = ((ecma_number_t) k) + ((ecma_number_t) args_number) - 1;
    #####: 1573:      ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (new_idx);
        -: 1574:      ecma_value_t operation_value;
        -: 1575:
    #####: 1576:      if (ecma_is_value_found (get_value))
        -: 1577:      {
        -: 1578:        /* ES5.1:6.d.i, 6.d.ii, ES11:4.c.iv. */
    #####: 1579:        operation_value = ecma_op_object_put (obj_p, index_str_p, get_value, true);
    #####: 1580:        ecma_free_value (get_value);
        -: 1581:      }
        -: 1582:      else
        -: 1583:      {
        -: 1584:        /* ES5.1:6.e.i, ES11:4.c.v. */
    #####: 1585:        operation_value = ecma_op_object_delete (obj_p, index_str_p, true);
        -: 1586:      }
        -: 1587:
    #####: 1588:      ecma_deref_ecma_string (index_str_p);
        -: 1589:
    #####: 1590:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1591:      {
    #####: 1592:        return operation_value;
        -: 1593:      }
        -: 1594:    }
        -: 1595:
    #####: 1596:    for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -: 1597:    {
        -: 1598:      /* ES5.1:9.b, ES11:4.f.ii.  */
    #####: 1599:      ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, arg_index, args[arg_index], true);
        -: 1600:
    #####: 1601:      if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1602:      {
    #####: 1603:        return put_value;
        -: 1604:      }
        -: 1605:    }
        -: 1606:  }
        -: 1607:
        -: 1608:  /* ES5.1:10., ES11:5. */
    #####: 1609:  ecma_number_t new_len = ((ecma_number_t) len) + ((ecma_number_t) args_number);
    #####: 1610:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, new_len);
        -: 1611:
    #####: 1612:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1613:  {
    #####: 1614:    return set_length_value;
        -: 1615:  }
        -: 1616:
    #####: 1617:  return ecma_make_number_value (new_len);
        -: 1618:} /* ecma_builtin_array_prototype_object_unshift */
        -: 1619:
        -: 1620:/**
        -: 1621: * The Array.prototype object's 'at' routine
        -: 1622: *
        -: 1623: * See also:
        -: 1624: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1625: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1626: *
        -: 1627: * @return ecma value
        -: 1628: *         Returned value must be freed with ecma_free_value.
        -: 1629: */
        -: 1630:static ecma_value_t
    #####: 1631:ecma_builtin_array_prototype_object_at (const ecma_value_t index, /**< index argument */
        -: 1632:                                        ecma_object_t *obj_p, /**< object */
        -: 1633:                                        ecma_length_t len) /**< object's length */
        -: 1634:{
    #####: 1635:  ecma_length_t res_index;
    #####: 1636:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1637:
    #####: 1638:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1639:  {
    #####: 1640:    return return_value;
        -: 1641:  }
        -: 1642:
    #####: 1643:  return ecma_op_object_get_by_index (obj_p, res_index);
        -: 1644:} /* ecma_builtin_array_prototype_object_at */
        -: 1645:
        -: 1646:/**
        -: 1647: * The Array.prototype object's 'indexOf' routine
        -: 1648: *
        -: 1649: * See also:
        -: 1650: *          ECMA-262 v5, 15.4.4.14
        -: 1651: *
        -: 1652: * @return ecma value
        -: 1653: *         Returned value must be freed with ecma_free_value.
        -: 1654: */
        -: 1655:static ecma_value_t
    #####: 1656:ecma_builtin_array_prototype_object_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1657:                                              uint32_t args_number, /**< number of arguments */
        -: 1658:                                              ecma_object_t *obj_p, /**< object */
        -: 1659:                                              ecma_length_t len) /**< object's length */
        -: 1660:{
        -: 1661:  /* 4. */
    #####: 1662:  if (len == 0)
        -: 1663:  {
    #####: 1664:    return ecma_make_integer_value (-1);
        -: 1665:  }
        -: 1666:
        -: 1667:  /* 5. */
    #####: 1668:  ecma_number_t idx = 0;
    #####: 1669:  if (args_number > 1)
        -: 1670:  {
    #####: 1671:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1672:    {
    #####: 1673:      return ECMA_VALUE_ERROR;
        -: 1674:    }
        -: 1675:  }
        -: 1676:
        -: 1677:  /* 6. */
    #####: 1678:  if (idx >= (ecma_number_t) len)
        -: 1679:  {
    #####: 1680:    return ecma_make_number_value (-1);
        -: 1681:  }
        -: 1682:
        -: 1683:  /* 7. */
    #####: 1684:  ecma_length_t from_idx = (ecma_length_t) idx;
        -: 1685:
        -: 1686:  /* 8. */
    #####: 1687:  if (idx < 0)
        -: 1688:  {
    #####: 1689:    from_idx = (ecma_length_t) JERRY_MAX ((ecma_number_t) len + idx, 0);
        -: 1690:  }
        -: 1691:
    #####: 1692:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1693:  {
    #####: 1694:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1695:
    #####: 1696:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1697:    {
    #####: 1698:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1699:      {
    #####: 1700:        return ecma_make_integer_value (-1);
        -: 1701:      }
        -: 1702:
    #####: 1703:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1704:
    #####: 1705:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1706:
    #####: 1707:      while (from_idx < len)
        -: 1708:      {
    #####: 1709:        if (ecma_op_strict_equality_compare (args[0], buffer_p[from_idx]))
        -: 1710:        {
    #####: 1711:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1712:        }
        -: 1713:
    #####: 1714:        from_idx++;
        -: 1715:      }
        -: 1716:
    #####: 1717:      return ecma_make_integer_value (-1);
        -: 1718:    }
        -: 1719:  }
        -: 1720:
        -: 1721:  /* 6. */
    #####: 1722:  while (from_idx < len)
        -: 1723:  {
        -: 1724:    /* 9.a */
    #####: 1725:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1726:
    #####: 1727:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1728:    {
    #####: 1729:      return get_value;
        -: 1730:    }
        -: 1731:
        -: 1732:    /* 9.b.i, 9.b.ii */
    #####: 1733:    if (ecma_is_value_found (get_value)
    #####: 1734:        && ecma_op_strict_equality_compare (args[0], get_value))
        -: 1735:    {
    #####: 1736:      ecma_free_value (get_value);
    #####: 1737:      return ecma_make_length_value (from_idx);
        -: 1738:    }
        -: 1739:
    #####: 1740:    from_idx++;
        -: 1741:
    #####: 1742:    ecma_free_value (get_value);
        -: 1743:  }
        -: 1744:
    #####: 1745:  return ecma_make_integer_value (-1);
        -: 1746:} /* ecma_builtin_array_prototype_object_index_of */
        -: 1747:
        -: 1748:/**
        -: 1749: * The Array.prototype object's 'lastIndexOf' routine
        -: 1750: *
        -: 1751: * See also:
        -: 1752: *          ECMA-262 v5, 15.4.4.15
        -: 1753: *
        -: 1754: * @return ecma value
        -: 1755: *         Returned value must be freed with ecma_free_value.
        -: 1756: */
        -: 1757:static ecma_value_t
    #####: 1758:ecma_builtin_array_prototype_object_last_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1759:                                                   uint32_t args_number, /**< number of arguments */
        -: 1760:                                                   ecma_object_t *obj_p, /**< object */
        -: 1761:                                                   ecma_length_t len) /**< object's length */
        -: 1762:{
        -: 1763:  /* 4. */
    #####: 1764:  if (len == 0)
        -: 1765:  {
    #####: 1766:    return ecma_make_integer_value (-1);
        -: 1767:  }
        -: 1768:
        -: 1769:  /* 5. */
    #####: 1770:  ecma_number_t idx = (ecma_number_t) len - 1;
    #####: 1771:  if (args_number > 1)
        -: 1772:  {
    #####: 1773:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1774:    {
    #####: 1775:      return ECMA_VALUE_ERROR;
        -: 1776:    }
        -: 1777:  }
        -: 1778:
        -: 1779:  ecma_length_t from_idx;
        -: 1780:
        -: 1781:  /* 6 */
    #####: 1782:  if (idx >= 0)
        -: 1783:  {
    #####: 1784:    from_idx = (ecma_length_t) (JERRY_MIN (idx, (ecma_number_t) (len - 1)));
        -: 1785:  }
        -: 1786:  else
        -: 1787:  {
    #####: 1788:    ecma_number_t k = (ecma_number_t) len + idx;
    #####: 1789:    if (k < 0)
        -: 1790:    {
    #####: 1791:      return ecma_make_integer_value (-1);
        -: 1792:    }
    #####: 1793:    from_idx = (ecma_length_t) k;
        -: 1794:  }
        -: 1795:
    #####: 1796:  ecma_value_t search_element = (args_number > 0) ? args[0] : ECMA_VALUE_UNDEFINED;
        -: 1797:
    #####: 1798:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1799:  {
    #####: 1800:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1801:
    #####: 1802:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1803:    {
    #####: 1804:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1805:      {
    #####: 1806:        return ecma_make_integer_value (-1);
        -: 1807:      }
        -: 1808:
    #####: 1809:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1810:
    #####: 1811:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1812:
    #####: 1813:      while (from_idx < len)
        -: 1814:      {
    #####: 1815:        if (ecma_op_strict_equality_compare (search_element, buffer_p[from_idx]))
        -: 1816:        {
    #####: 1817:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1818:        }
    #####: 1819:        from_idx--;
        -: 1820:      }
    #####: 1821:      return ecma_make_integer_value (-1);
        -: 1822:    }
        -: 1823:  }
        -: 1824:
        -: 1825:    /* 8. */
    #####: 1826:  while (from_idx < len)
        -: 1827:  {
        -: 1828:    /* 8.a */
    #####: 1829:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1830:
    #####: 1831:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1832:    {
    #####: 1833:      return get_value;
        -: 1834:    }
        -: 1835:
        -: 1836:    /* 8.b.i, 8.b.ii */
    #####: 1837:    if (ecma_is_value_found (get_value)
    #####: 1838:        && ecma_op_strict_equality_compare (search_element, get_value))
        -: 1839:    {
    #####: 1840:      ecma_free_value (get_value);
    #####: 1841:      return ecma_make_length_value (from_idx);
        -: 1842:    }
        -: 1843:
    #####: 1844:    from_idx--;
        -: 1845:
    #####: 1846:    ecma_free_value (get_value);
        -: 1847:  }
        -: 1848:
    #####: 1849:  return ecma_make_integer_value (-1);
        -: 1850:} /* ecma_builtin_array_prototype_object_last_index_of */
        -: 1851:
        -: 1852:/**
        -: 1853: * Type of array routine.
        -: 1854: */
        -: 1855:typedef enum
        -: 1856:{
        -: 1857:  ARRAY_ROUTINE_EVERY, /**< Array.every: ECMA-262 v5, 15.4.4.16 */
        -: 1858:  ARRAY_ROUTINE_SOME, /**< Array.some: ECMA-262 v5, 15.4.4.17 */
        -: 1859:  ARRAY_ROUTINE_FOREACH, /**< Array.forEach: ECMA-262 v5, 15.4.4.18 */
        -: 1860:  ARRAY_ROUTINE__COUNT /**< count of the modes */
        -: 1861:} array_routine_mode;
        -: 1862:
        -: 1863:/**
        -: 1864: * Applies the provided function to each element of the array as long as
        -: 1865: * the return value stays empty. The common function for 'every', 'some'
        -: 1866: * and 'forEach' of the Array prototype.
        -: 1867: *
        -: 1868: * See also:
        -: 1869: *          ECMA-262 v5, 15.4.4.16
        -: 1870: *          ECMA-262 v5, 15.4.4.17
        -: 1871: *          ECMA-262 v5, 15.4.4.18
        -: 1872: *
        -: 1873: * @return ecma value
        -: 1874: *         Returned value must be freed with ecma_free_value.
        -: 1875: */
        -: 1876:static ecma_value_t
    #####: 1877:ecma_builtin_array_apply (ecma_value_t arg1, /**< callbackfn */
        -: 1878:                          ecma_value_t arg2, /**< thisArg */
        -: 1879:                          array_routine_mode mode, /**< array routine mode */
        -: 1880:                          ecma_object_t *obj_p, /**< object */
        -: 1881:                          ecma_length_t len) /**< object's length */
        -: 1882:
        -: 1883:{
    #####: 1884:  JERRY_ASSERT (mode < ARRAY_ROUTINE__COUNT);
        -: 1885:
        -: 1886:  /* 4. */
    #####: 1887:  if (!ecma_op_is_callable (arg1))
        -: 1888:  {
    #####: 1889:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1890:  }
        -: 1891:
        -: 1892:  /* We already checked that arg1 is callable */
    #####: 1893:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1894:  ecma_value_t current_index;
        -: 1895:
        -: 1896:  /* 7. */
    #####: 1897:  for (ecma_length_t index = 0; index < len; index++)
        -: 1898:  {
        -: 1899:    /* 7.a - 7.c */
    #####: 1900:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1901:
    #####: 1902:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1903:    {
    #####: 1904:      return get_value;
        -: 1905:    }
        -: 1906:
    #####: 1907:    if (ecma_is_value_found (get_value))
        -: 1908:    {
        -: 1909:      /* 7.c.i */
    #####: 1910:      current_index = ecma_make_length_value (index);
        -: 1911:
    #####: 1912:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 1913:      /* 7.c.ii */
    #####: 1914:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1915:
    #####: 1916:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1917:      {
    #####: 1918:        ecma_free_value (get_value);
    #####: 1919:        return call_value;
        -: 1920:      }
        -: 1921:
    #####: 1922:      bool to_boolean = ecma_op_to_boolean (call_value);
        -: 1923:
    #####: 1924:      ecma_free_value (call_value);
    #####: 1925:      ecma_free_value (get_value);
        -: 1926:
        -: 1927:      /* 7.c.iii */
    #####: 1928:      if (mode == ARRAY_ROUTINE_EVERY && !to_boolean)
        -: 1929:      {
    #####: 1930:        return ECMA_VALUE_FALSE;
        -: 1931:      }
    #####: 1932:      else if (mode == ARRAY_ROUTINE_SOME && to_boolean)
        -: 1933:      {
    #####: 1934:        return ECMA_VALUE_TRUE;
        -: 1935:      }
        -: 1936:    }
        -: 1937:  }
        -: 1938:
        -: 1939:  /* 8. */
        -: 1940:
    #####: 1941:  if (mode == ARRAY_ROUTINE_EVERY)
        -: 1942:  {
    #####: 1943:    return ECMA_VALUE_TRUE;
        -: 1944:  }
    #####: 1945:  else if (mode == ARRAY_ROUTINE_SOME)
        -: 1946:  {
    #####: 1947:    return ECMA_VALUE_FALSE;
        -: 1948:  }
        -: 1949:
    #####: 1950:  JERRY_ASSERT (mode == ARRAY_ROUTINE_FOREACH);
    #####: 1951:  return ECMA_VALUE_UNDEFINED;
        -: 1952:} /* ecma_builtin_array_apply */
        -: 1953:
        -: 1954:/**
        -: 1955: * The Array.prototype object's 'map' routine
        -: 1956: *
        -: 1957: * See also:
        -: 1958: *          ECMA-262 v5, 15.4.4.19
        -: 1959: *
        -: 1960: * @return ecma value
        -: 1961: *         Returned value must be freed with ecma_free_value.
        -: 1962: */
        -: 1963:static ecma_value_t
    #####: 1964:ecma_builtin_array_prototype_object_map (ecma_value_t arg1, /**< callbackfn */
        -: 1965:                                         ecma_value_t arg2, /**< thisArg */
        -: 1966:                                         ecma_object_t *obj_p, /**< object */
        -: 1967:                                         ecma_length_t len) /**< object's length */
        -: 1968:{
        -: 1969:  /* 4. */
    #####: 1970:  if (!ecma_op_is_callable (arg1))
        -: 1971:  {
    #####: 1972:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1973:  }
        -: 1974:
        -: 1975:  /* 6. */
        -: 1976:#if JERRY_ESNEXT
    #####: 1977:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, len);
        -: 1978:
    #####: 1979:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1980:  {
    #####: 1981:    return ECMA_VALUE_ERROR;
        -: 1982:  }
        -: 1983:#else /* !JERRY_ESNEXT */
    #####: 1984:  ecma_object_t *new_array_p = ecma_op_new_array_object (len);
        -: 1985:#endif /* JERRY_ESNEXT */
        -: 1986:
    #####: 1987:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 1988:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1989:
        -: 1990:  /* 7-8. */
        -: 1991:  ecma_value_t current_index;
        -: 1992:
    #####: 1993:  for (ecma_length_t index = 0; index < len; index++)
        -: 1994:  {
        -: 1995:    /* 8.a - 8.b */
    #####: 1996:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1997:
    #####: 1998:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1999:    {
    #####: 2000:      ecma_deref_object (new_array_p);
    #####: 2001:      return current_value;
        -: 2002:    }
        -: 2003:
    #####: 2004:    if (ecma_is_value_found (current_value))
        -: 2005:    {
        -: 2006:      /* 8.c.i, 8.c.ii */
    #####: 2007:      current_index = ecma_make_length_value (index);
    #####: 2008:      ecma_value_t call_args[] = { current_value, current_index, ecma_make_object_value (obj_p) };
        -: 2009:
    #####: 2010:      ecma_value_t mapped_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2011:
    #####: 2012:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -: 2013:      {
    #####: 2014:        ecma_free_value (current_value);
    #####: 2015:        ecma_deref_object (new_array_p);
    #####: 2016:        return mapped_value;
        -: 2017:      }
        -: 2018:
        -: 2019:      /* 8.c.iii */
        -: 2020:      ecma_value_t put_comp;
        -: 2021:#if JERRY_ESNEXT
    #####: 2022:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2023:#else /* !JERRY_ESNEXT */
    #####: 2024:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2025:#endif /* JERRY_ESNEXT */
    #####: 2026:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2027:                                                        index,
        -: 2028:                                                        mapped_value,
        -: 2029:                                                        prop_flags);
        -: 2030:
    #####: 2031:      ecma_free_value (mapped_value);
    #####: 2032:      ecma_free_value (current_value);
        -: 2033:#if JERRY_ESNEXT
    #####: 2034:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2035:      {
    #####: 2036:        ecma_deref_object (new_array_p);
    #####: 2037:        return put_comp;
        -: 2038:      }
        -: 2039:#else /* !JERRY_ESNEXT */
        -: 2040:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2041:#endif /* JERRY_ESNEXT */
        -: 2042:    }
        -: 2043:  }
        -: 2044:
    #####: 2045:  return ecma_make_object_value (new_array_p);
        -: 2046:} /* ecma_builtin_array_prototype_object_map */
        -: 2047:
        -: 2048:/**
        -: 2049: * The Array.prototype object's 'filter' routine
        -: 2050: *
        -: 2051: * See also:
        -: 2052: *          ECMA-262 v5, 15.4.4.20
        -: 2053: *
        -: 2054: * @return ecma value
        -: 2055: *         Returned value must be freed with ecma_free_value.
        -: 2056: */
        -: 2057:static ecma_value_t
    #####: 2058:ecma_builtin_array_prototype_object_filter (ecma_value_t arg1, /**< callbackfn */
        -: 2059:                                            ecma_value_t arg2, /**< thisArg */
        -: 2060:                                            ecma_object_t *obj_p, /**< object */
        -: 2061:                                            ecma_length_t len) /**< object's length */
        -: 2062:{
        -: 2063:  /* 4. */
    #####: 2064:  if (!ecma_op_is_callable (arg1))
        -: 2065:  {
    #####: 2066:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2067:  }
        -: 2068:
        -: 2069:  /* 6. */
        -: 2070:#if JERRY_ESNEXT
    #####: 2071:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2072:
    #####: 2073:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2074:  {
    #####: 2075:    return ECMA_VALUE_ERROR;
        -: 2076:  }
        -: 2077:
        -: 2078:  /* ES11: 22.1.3.7. 7.c.iii.1 */
    #####: 2079:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2080:#else /* !JERRY_ESNEXT */
    #####: 2081:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -: 2082:
        -: 2083:  /* ES5.1: 15.4.4.20. 9.c.iii.1 */
    #####: 2084:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2085:#endif /* JERRY_ESNEXT */
        -: 2086:
        -: 2087:  /* We already checked that arg1 is callable, so it will always be an object. */
    #####: 2088:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 2089:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 2090:
        -: 2091:  /* 8. */
    #####: 2092:  ecma_length_t new_array_index = 0;
        -: 2093:  ecma_value_t current_index;
        -: 2094:
        -: 2095:  /* 9. */
    #####: 2096:  for (ecma_length_t index = 0; index < len; index++)
        -: 2097:  {
        -: 2098:    /* 9.a - 9.c */
    #####: 2099:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 2100:
    #####: 2101:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2102:    {
    #####: 2103:      ecma_deref_object (new_array_p);
    #####: 2104:      return get_value;
        -: 2105:    }
        -: 2106:
    #####: 2107:    if (ecma_is_value_found (get_value))
        -: 2108:    {
        -: 2109:      /* 9.c.i */
    #####: 2110:      current_index = ecma_make_length_value (index);
        -: 2111:
    #####: 2112:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2113:      /* 9.c.ii */
    #####: 2114:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2115:
    #####: 2116:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2117:      {
    #####: 2118:        ecma_free_value (get_value);
    #####: 2119:        ecma_deref_object (new_array_p);
    #####: 2120:        return call_value;
        -: 2121:      }
        -: 2122:
        -: 2123:      /* 9.c.iii */
    #####: 2124:      if (ecma_op_to_boolean (call_value))
        -: 2125:      {
        -: 2126:        ecma_value_t put_comp;
    #####: 2127:        put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2128:                                                          new_array_index,
        -: 2129:                                                          get_value,
        -: 2130:                                                          prop_flags);
        -: 2131:#if JERRY_ESNEXT
    #####: 2132:        if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2133:        {
    #####: 2134:          ecma_free_value (call_value);
    #####: 2135:          ecma_free_value (get_value);
    #####: 2136:          ecma_deref_object (new_array_p);
        -: 2137:
    #####: 2138:          return put_comp;
        -: 2139:        }
        -: 2140:#else /* !JERRY_ESNEXT */
        -: 2141:        JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2142:#endif /* JERRY_ESNEXT */
    #####: 2143:        new_array_index++;
        -: 2144:      }
        -: 2145:
    #####: 2146:      ecma_free_value (call_value);
    #####: 2147:      ecma_free_value (get_value);
        -: 2148:    }
        -: 2149:  }
        -: 2150:
    #####: 2151:  return ecma_make_object_value (new_array_p);
        -: 2152:} /* ecma_builtin_array_prototype_object_filter */
        -: 2153:
        -: 2154:/**
        -: 2155: * The Array.prototype object's 'reduce' and 'reduceRight' routine
        -: 2156: *
        -: 2157: * See also:
        -: 2158: *         ECMA-262 v5, 15.4.4.21
        -: 2159: *         ECMA-262 v5, 15.4.4.22
        -: 2160: *
        -: 2161: * @return ecma value
        -: 2162: *         Returned value must be freed with ecma_free_value.
        -: 2163: */
        -: 2164:static ecma_value_t
    #####: 2165:ecma_builtin_array_reduce_from (const ecma_value_t args_p[], /**< routine's arguments */
        -: 2166:                                uint32_t args_number, /**< arguments list length */
        -: 2167:                                bool start_from_left, /**< whether the reduce starts from left or right */
        -: 2168:                                ecma_object_t *obj_p, /**< object */
        -: 2169:                                ecma_length_t len) /**< object's length */
        -: 2170:{
        -: 2171:  /* 4. */
    #####: 2172:  if (!ecma_op_is_callable (args_p[0]))
        -: 2173:  {
    #####: 2174:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2175:  }
        -: 2176:
        -: 2177:  /* 5. */
    #####: 2178:  if (len == 0 && args_number == 1)
        -: 2179:  {
    #####: 2180:    return ecma_raise_type_error (ECMA_ERR_MSG ("Reduce of empty Array with no initial value"));
        -: 2181:  }
        -: 2182:
    #####: 2183:  JERRY_ASSERT (ecma_is_value_object (args_p[0]));
    #####: 2184:  ecma_object_t *func_object_p = ecma_get_object_from_value (args_p[0]);
        -: 2185:
    #####: 2186:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
        -: 2187:
        -: 2188:  /* 6. */
    #####: 2189:  ecma_length_t index = 0;
    #####: 2190:  const ecma_length_t last_index = len - 1;
        -: 2191:
        -: 2192:  /* 7.a */
    #####: 2193:  if (args_number > 1)
        -: 2194:  {
    #####: 2195:    accumulator = ecma_copy_value (args_p[1]);
        -: 2196:  }
        -: 2197:  else
        -: 2198:  {
        -: 2199:    /* 8.a */
    #####: 2200:    bool k_present = false;
        -: 2201:
        -: 2202:    /* 8.b */
    #####: 2203:    while (!k_present && index < len)
        -: 2204:    {
        -: 2205:      /* 8.b.i */
    #####: 2206:      k_present = true;
        -: 2207:
        -: 2208:      /* 8.b.ii-iii */
    #####: 2209:      ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, start_from_left ? index
        -: 2210:                                                                                                  : last_index - index);
        -: 2211:
    #####: 2212:      if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2213:      {
    #####: 2214:        return current_value;
        -: 2215:      }
        -: 2216:
    #####: 2217:      if (ecma_is_value_found (current_value))
        -: 2218:      {
    #####: 2219:        accumulator = current_value;
        -: 2220:      }
        -: 2221:      else
        -: 2222:      {
    #####: 2223:        k_present = false;
        -: 2224:      }
        -: 2225:
        -: 2226:      /* 8.b.iv */
    #####: 2227:      index++;
        -: 2228:    }
        -: 2229:
        -: 2230:    /* 8.c */
    #####: 2231:    if (!k_present)
        -: 2232:    {
    #####: 2233:      return ecma_raise_type_error (ECMA_ERR_MSG ("Missing Array element"));
        -: 2234:    }
        -: 2235:  }
        -: 2236:  /* 9. */
        -: 2237:  ecma_value_t current_index;
        -: 2238:
    #####: 2239:  for (; index < len; index++)
        -: 2240:  {
    #####: 2241:    const ecma_length_t corrected_index = start_from_left ? index : last_index - index;
        -: 2242:
        -: 2243:    /* 9.a - 9.b */
    #####: 2244:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, corrected_index);
        -: 2245:
    #####: 2246:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2247:    {
    #####: 2248:      ecma_free_value (accumulator);
    #####: 2249:      return current_value;
        -: 2250:    }
        -: 2251:
    #####: 2252:    if (ecma_is_value_found (current_value))
        -: 2253:    {
        -: 2254:      /* 9.c.i, 9.c.ii */
    #####: 2255:      current_index = ecma_make_length_value (corrected_index);
    #####: 2256:      ecma_value_t call_args[] = {accumulator, current_value, current_index, ecma_make_object_value (obj_p)};
        -: 2257:
    #####: 2258:      ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -: 2259:                                                       ECMA_VALUE_UNDEFINED,
        -: 2260:                                                       call_args,
        -: 2261:                                                       4);
    #####: 2262:      ecma_free_value (current_index);
    #####: 2263:      ecma_free_value (accumulator);
    #####: 2264:      ecma_free_value (current_value);
        -: 2265:
    #####: 2266:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2267:      {
    #####: 2268:        return call_value;
        -: 2269:      }
        -: 2270:
    #####: 2271:      accumulator = call_value;
        -: 2272:    }
        -: 2273:  }
        -: 2274:
    #####: 2275:  return accumulator;
        -: 2276:} /* ecma_builtin_array_reduce_from */
        -: 2277:
        -: 2278:#if JERRY_ESNEXT
        -: 2279:
        -: 2280:/**
        -: 2281: * The Array.prototype object's 'fill' routine
        -: 2282: *
        -: 2283: * Note: this method only supports length up to uint32, instead of max_safe_integer
        -: 2284: *
        -: 2285: * See also:
        -: 2286: *          ECMA-262 v6, 22.1.3.6
        -: 2287: *
        -: 2288: * @return ecma value
        -: 2289: *         Returned value must be freed with ecma_free_value.
        -: 2290: */
        -: 2291:static ecma_value_t
    #####: 2292:ecma_builtin_array_prototype_fill (ecma_value_t value, /**< value */
        -: 2293:                                   ecma_value_t start_val, /**< start value */
        -: 2294:                                   ecma_value_t end_val, /**< end value */
        -: 2295:                                   ecma_object_t *obj_p, /**< object */
        -: 2296:                                   ecma_length_t len) /**< object's length */
        -: 2297:{
    #####: 2298:  ecma_length_t k, final;
        -: 2299:
        -: 2300:  /* 5. 6. 7. */
    #####: 2301:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (start_val,
        -: 2302:                                                                      len,
        -: 2303:                                                                      &k)))
        -: 2304:  {
    #####: 2305:    return ECMA_VALUE_ERROR;
        -: 2306:  }
        -: 2307:
        -: 2308:  /* 8. */
    #####: 2309:  if (ecma_is_value_undefined (end_val))
        -: 2310:  {
    #####: 2311:    final = len;
        -: 2312:  }
        -: 2313:  else
        -: 2314:  {
        -: 2315:    /* 8 part 2, 9, 10 */
    #####: 2316:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end_val,
        -: 2317:                                                                        len,
        -: 2318:                                                                        &final)))
        -: 2319:    {
    #####: 2320:      return ECMA_VALUE_ERROR;
        -: 2321:    }
        -: 2322:  }
        -: 2323:
    #####: 2324:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2325:  {
    #####: 2326:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2327:
    #####: 2328:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2329:    {
    #####: 2330:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 2331:      {
    #####: 2332:        ecma_ref_object (obj_p);
    #####: 2333:        return ecma_make_object_value (obj_p);
        -: 2334:      }
        -: 2335:
    #####: 2336:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2337:
    #####: 2338:      while (k < final)
        -: 2339:      {
    #####: 2340:        ecma_free_value_if_not_object (buffer_p[k]);
    #####: 2341:        buffer_p[k] = ecma_copy_value_if_not_object (value);
    #####: 2342:        k++;
        -: 2343:      }
        -: 2344:
    #####: 2345:      ecma_ref_object (obj_p);
    #####: 2346:      return ecma_make_object_value (obj_p);
        -: 2347:    }
        -: 2348:  }
        -: 2349:
        -: 2350:  /* 11. */
    #####: 2351:  while (k < final)
        -: 2352:  {
        -: 2353:    /* 11.a - 11.b */
    #####: 2354:    ecma_value_t put_val = ecma_op_object_put_by_index (obj_p, k, value, true);
        -: 2355:
        -: 2356:    /* 11. c */
    #####: 2357:    if (ECMA_IS_VALUE_ERROR (put_val))
        -: 2358:    {
    #####: 2359:      return put_val;
        -: 2360:    }
        -: 2361:
        -: 2362:    /* 11.d */
    #####: 2363:    k++;
        -: 2364:  }
        -: 2365:
    #####: 2366:  ecma_ref_object (obj_p);
    #####: 2367:  return ecma_make_object_value (obj_p);
        -: 2368:} /* ecma_builtin_array_prototype_fill */
        -: 2369:
        -: 2370:/**
        -: 2371: * The Array.prototype object's 'find' and 'findIndex' routine
        -: 2372: *
        -: 2373: * See also:
        -: 2374: *          ECMA-262 v6, 22.1.3.8
        -: 2375: *          ECMA-262 v6, 22.1.3.9
        -: 2376: *
        -: 2377: * @return ecma value
        -: 2378: *         Returned value must be freed with ecma_free_value.
        -: 2379: */
        -: 2380:static ecma_value_t
    #####: 2381:ecma_builtin_array_prototype_object_find (ecma_value_t predicate, /**< callback function */
        -: 2382:                                          ecma_value_t predicate_this_arg, /**< this argument for
        -: 2383:                                                                            *   invoke predicate */
        -: 2384:                                          bool is_find, /**< true - find routine
        -: 2385:                                                         *   false - findIndex routine */
        -: 2386:                                          ecma_object_t *obj_p, /**< object */
        -: 2387:                                          ecma_length_t len) /**< object's length */
        -: 2388:{
        -: 2389:  /* 5. */
    #####: 2390:  if (!ecma_op_is_callable (predicate))
        -: 2391:  {
    #####: 2392:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2393:  }
        -: 2394:
        -: 2395:  /* We already checked that predicate is callable, so it will always be an object. */
    #####: 2396:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 2397:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 2398:
        -: 2399:  /* 7 - 8. */
    #####: 2400:  for (ecma_length_t index = 0; index < len; index++)
        -: 2401:  {
        -: 2402:    /* 8.a - 8.c */
    #####: 2403:    ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, index);
        -: 2404:
    #####: 2405:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2406:    {
    #####: 2407:      return get_value;
        -: 2408:    }
        -: 2409:
        -: 2410:    /* 8.d - 8.e */
    #####: 2411:    ecma_value_t current_index = ecma_make_length_value (index);
        -: 2412:
    #####: 2413:    ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2414:
    #####: 2415:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 2416:
    #####: 2417:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2418:    {
    #####: 2419:      ecma_free_value (get_value);
    #####: 2420:      return call_value;
        -: 2421:    }
        -: 2422:
    #####: 2423:    bool call_value_to_bool = ecma_op_to_boolean (call_value);
        -: 2424:
    #####: 2425:    ecma_free_value (call_value);
        -: 2426:
    #####: 2427:    if (call_value_to_bool)
        -: 2428:    {
        -: 2429:      /* 8.f */
    #####: 2430:      if (is_find)
        -: 2431:      {
    #####: 2432:        ecma_free_value (current_index);
    #####: 2433:        return get_value;
        -: 2434:      }
        -: 2435:
    #####: 2436:      ecma_free_value (get_value);
    #####: 2437:      return current_index;
        -: 2438:    }
        -: 2439:
    #####: 2440:    ecma_free_value (get_value);
    #####: 2441:    ecma_free_value (current_index);
        -: 2442:  }
        -: 2443:
        -: 2444:  /* 9. */
    #####: 2445:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 2446:} /* ecma_builtin_array_prototype_object_find */
        -: 2447:
        -: 2448:/**
        -: 2449: * The Array.prototype object's 'copyWithin' routine
        -: 2450: *
        -: 2451: * See also:
        -: 2452: *          ECMA-262 v6, 22.1.3.3
        -: 2453: *
        -: 2454: * @return ecma value
        -: 2455: *         Returned value must be freed with ecma_free_value.
        -: 2456: */
        -: 2457:static ecma_value_t
    #####: 2458:ecma_builtin_array_prototype_object_copy_within (const ecma_value_t args[], /**< arguments list */
        -: 2459:                                                 uint32_t args_number, /**< number of arguments */
        -: 2460:                                                 ecma_object_t *obj_p, /**< object */
        -: 2461:                                                 ecma_length_t len) /**< object's length */
        -: 2462:{
    #####: 2463:  if (args_number == 0)
        -: 2464:  {
    #####: 2465:    return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2466:  }
        -: 2467:
        -: 2468:  /* 5 - 7 */
    #####: 2469:  ecma_length_t target;
        -: 2470:
    #####: 2471:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &target)))
        -: 2472:  {
    #####: 2473:    return ECMA_VALUE_ERROR;
        -: 2474:  }
        -: 2475:
    #####: 2476:  ecma_length_t start = 0;
    #####: 2477:  ecma_length_t end = len;
        -: 2478:
    #####: 2479:  if (args_number > 1)
        -: 2480:  {
        -: 2481:    /* 8 - 10 */
    #####: 2482:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &start)))
        -: 2483:    {
    #####: 2484:      return ECMA_VALUE_ERROR;
        -: 2485:    }
        -: 2486:
    #####: 2487:    if (args_number > 2)
        -: 2488:    {
        -: 2489:      /* 11 */
    #####: 2490:      if (ecma_is_value_undefined (args[2]))
        -: 2491:      {
    #####: 2492:        end = len;
        -: 2493:      }
        -: 2494:      else
        -: 2495:      {
        -: 2496:        /* 11 part 2, 12, 13 */
    #####: 2497:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2], len, &end)))
        -: 2498:        {
    #####: 2499:          return ECMA_VALUE_ERROR;
        -: 2500:        }
        -: 2501:      }
        -: 2502:    }
        -: 2503:  }
        -: 2504:
    #####: 2505:  ecma_length_t count = JERRY_MIN (end - start, len - target);
    #####: 2506:  if (end <= start || len <= target) /* count <= 0 check, but variables are unsigned */
        -: 2507:  {
    #####: 2508:    ecma_ref_object (obj_p);
    #####: 2509:    return ecma_make_object_value (obj_p);
        -: 2510:  }
        -: 2511:
    #####: 2512:  bool forward = true;
        -: 2513:
    #####: 2514:  if (start < target && target < start + count)
        -: 2515:  {
    #####: 2516:    start = start + count - 1;
    #####: 2517:    target = target + count - 1;
    #####: 2518:    forward = false;
        -: 2519:  }
        -: 2520:
    #####: 2521:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2522:  {
    #####: 2523:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####: 2524:    const uint32_t actual_length = ext_obj_p->u.array.length;
        -: 2525:
    #####: 2526:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 2527:        && ((forward && (target + count - 1 < actual_length)) || (!forward && (target < actual_length))))
        -: 2528:    {
    #####: 2529:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2530:      {
    #####: 2531:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2532:
    #####: 2533:        for (; count > 0; count--)
        -: 2534:        {
    #####: 2535:          ecma_value_t copy_value = ecma_copy_value_if_not_object (buffer_p[start]);
        -: 2536:
    #####: 2537:          ecma_free_value_if_not_object (buffer_p[target]);
        -: 2538:
    #####: 2539:          buffer_p[target] = copy_value;
        -: 2540:
    #####: 2541:          if (forward)
        -: 2542:          {
    #####: 2543:            start++;
    #####: 2544:            target++;
        -: 2545:          }
        -: 2546:          else
        -: 2547:          {
    #####: 2548:            start--;
    #####: 2549:            target--;
        -: 2550:          }
        -: 2551:        }
        -: 2552:      }
        -: 2553:
    #####: 2554:      ecma_ref_object (obj_p);
    #####: 2555:      return ecma_make_object_value (obj_p);
        -: 2556:    }
        -: 2557:  }
        -: 2558:
    #####: 2559:  while (count > 0)
        -: 2560:  {
    #####: 2561:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, start);
        -: 2562:
    #####: 2563:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2564:    {
    #####: 2565:      return get_value;
        -: 2566:    }
        -: 2567:
        -: 2568:    ecma_value_t op_value;
        -: 2569:
    #####: 2570:    if (ecma_is_value_found (get_value))
        -: 2571:    {
    #####: 2572:      op_value = ecma_op_object_put_by_index (obj_p, target, get_value, true);
        -: 2573:    }
        -: 2574:    else
        -: 2575:    {
    #####: 2576:      op_value = ecma_op_object_delete_by_index (obj_p, target, true);
        -: 2577:    }
        -: 2578:
    #####: 2579:    ecma_free_value (get_value);
        -: 2580:
    #####: 2581:    if (ECMA_IS_VALUE_ERROR (op_value))
        -: 2582:    {
    #####: 2583:      return op_value;
        -: 2584:    }
        -: 2585:
    #####: 2586:    ecma_free_value (op_value);
        -: 2587:
    #####: 2588:    if (forward)
        -: 2589:    {
    #####: 2590:      start++;
    #####: 2591:      target++;
        -: 2592:    }
        -: 2593:    else
        -: 2594:    {
    #####: 2595:      start--;
    #####: 2596:      target--;
        -: 2597:    }
        -: 2598:
    #####: 2599:    count--;
        -: 2600:  }
        -: 2601:
    #####: 2602:  return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2603:} /* ecma_builtin_array_prototype_object_copy_within */
        -: 2604:
        -: 2605:/**
        -: 2606: * The Array.prototype object's 'includes' routine
        -: 2607: *
        -: 2608: * See also:
        -: 2609: *          ECMA-262 v11, 22.1.3.13
        -: 2610: *
        -: 2611: * @return ECMA_VALUE_ERROR -if the operation fails
        -: 2612: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the search element is in the array or not
        -: 2613: */
        -: 2614:static ecma_value_t
    #####: 2615:ecma_builtin_array_prototype_includes (const ecma_value_t args[], /**< arguments list */
        -: 2616:                                       uint32_t args_number, /**< number of arguments */
        -: 2617:                                       ecma_object_t *obj_p, /**< object */
        -: 2618:                                       ecma_length_t len) /**< object's length */
        -: 2619:{
        -: 2620:  /* 3. */
    #####: 2621:  if (len == 0)
        -: 2622:  {
    #####: 2623:    return ECMA_VALUE_FALSE;
        -: 2624:  }
        -: 2625:
    #####: 2626:  ecma_length_t from_index = 0;
        -: 2627:
        -: 2628:  /* 4-7. */
    #####: 2629:  if (args_number > 1)
        -: 2630:  {
    #####: 2631:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &from_index)))
        -: 2632:    {
    #####: 2633:      return ECMA_VALUE_ERROR;
        -: 2634:    }
        -: 2635:  }
        -: 2636:
        -: 2637:  /* Fast array path */
    #####: 2638:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2639:  {
    #####: 2640:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2641:
    #####: 2642:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2643:    {
    #####: 2644:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2645:      {
    #####: 2646:        len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 2647:
    #####: 2648:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2649:
    #####: 2650:        while (from_index < len)
        -: 2651:        {
    #####: 2652:          if (ecma_op_same_value_zero (buffer_p[from_index], args[0], false))
        -: 2653:          {
    #####: 2654:            return ECMA_VALUE_TRUE;
        -: 2655:          }
        -: 2656:
    #####: 2657:          from_index++;
        -: 2658:        }
        -: 2659:      }
        -: 2660:
    #####: 2661:      return ECMA_VALUE_FALSE;
        -: 2662:    }
        -: 2663:  }
        -: 2664:
        -: 2665:  /* 8. */
    #####: 2666:  while (from_index < len)
        -: 2667:  {
    #####: 2668:    ecma_value_t element = ecma_op_object_get_by_index (obj_p, from_index);
        -: 2669:
    #####: 2670:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2671:    {
    #####: 2672:      return element;
        -: 2673:    }
        -: 2674:
    #####: 2675:    if (ecma_op_same_value_zero (element, args[0], false))
        -: 2676:    {
    #####: 2677:      ecma_free_value (element);
    #####: 2678:      return ECMA_VALUE_TRUE;
        -: 2679:    }
        -: 2680:
    #####: 2681:    ecma_free_value (element);
    #####: 2682:    from_index++;
        -: 2683:  }
        -: 2684:
        -: 2685:  /* 9. */
    #####: 2686:  return ECMA_VALUE_FALSE;
        -: 2687:} /* ecma_builtin_array_prototype_includes */
        -: 2688:
        -: 2689:/**
        -: 2690: * Abstract operation: FlattenIntoArray
        -: 2691: *
        -: 2692: * See also:
        -: 2693: *          ECMA-262 v10, 22.1.3.10.1
        -: 2694: *
        -: 2695: * @return  ECMA_VALUE_ERROR -if the operation fails
        -: 2696: *          ecma value which contains target_index
        -: 2697: */
        -: 2698:static ecma_value_t
    #####: 2699:ecma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */
        -: 2700:                                       ecma_object_t *source, /**< source object */
        -: 2701:                                       ecma_length_t source_len, /**< source object length */
        -: 2702:                                       ecma_length_t start, /**< remaining recursion depth */
        -: 2703:                                       ecma_number_t depth, /**< start index offset */
        -: 2704:                                       ecma_value_t mapped_value, /**< mapped value  */
        -: 2705:                                       ecma_value_t thisArg) /**< this arg */
        -: 2706:{
        -: 2707:  /* 7. */
    #####: 2708:  ecma_length_t target_index = start;
        -: 2709:
        -: 2710:  /* 9. */
    #####: 2711:  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)
        -: 2712:  {
        -: 2713:    /* a. */
    #####: 2714:    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);
        -: 2715:
    #####: 2716:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2717:    {
    #####: 2718:      return element;
        -: 2719:    }
        -: 2720:
    #####: 2721:    if (!ecma_is_value_found (element))
        -: 2722:    {
    #####: 2723:      continue;
        -: 2724:    }
        -: 2725:
        -: 2726:    /* b-c. */
    #####: 2727:    if (!ecma_is_value_undefined (mapped_value))
        -: 2728:    {
        -: 2729:      /* i-ii. */
    #####: 2730:      ecma_value_t source_val = ecma_make_length_value (source_index);
    #####: 2731:      ecma_value_t args[] = {element, source_val, ecma_make_object_value (source)};
    #####: 2732:      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);
        -: 2733:
    #####: 2734:      ecma_free_value (element);
    #####: 2735:      ecma_free_value (source_val);
        -: 2736:
    #####: 2737:      if (ECMA_IS_VALUE_ERROR (temp_element))
        -: 2738:      {
    #####: 2739:        return temp_element;
        -: 2740:      }
        -: 2741:
    #####: 2742:      element = temp_element;
        -: 2743:    }
        -: 2744:
        -: 2745:    /* iv-v. */
    #####: 2746:    if (depth > 0)
        -: 2747:    {
    #####: 2748:      ecma_value_t is_array = ecma_is_value_array (element);
        -: 2749:
    #####: 2750:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 2751:      {
    #####: 2752:        ecma_free_value (element);
    #####: 2753:        return is_array;
        -: 2754:      }
        -: 2755:
    #####: 2756:      if (ecma_is_value_true (is_array))
        -: 2757:      {
    #####: 2758:        ecma_object_t *element_obj = ecma_get_object_from_value (element);
    #####: 2759:        ecma_length_t element_len;
    #####: 2760:        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);
        -: 2761:
    #####: 2762:        if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2763:        {
    #####: 2764:          ecma_deref_object (element_obj);
    #####: 2765:          return len_value;
        -: 2766:        }
        -: 2767:
    #####: 2768:        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,
        -: 2769:                                                                               element_obj,
        -: 2770:                                                                               element_len,
        -: 2771:                                                                               target_index,
    #####: 2772:                                                                               depth - 1,
        -: 2773:                                                                               ECMA_VALUE_UNDEFINED,
        -: 2774:                                                                               ECMA_VALUE_UNDEFINED);
        -: 2775:
    #####: 2776:        ecma_deref_object (element_obj);
        -: 2777:
    #####: 2778:        if (ECMA_IS_VALUE_ERROR (target_index_val))
        -: 2779:        {
    #####: 2780:          return target_index_val;
        -: 2781:        }
        -: 2782:
    #####: 2783:        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);
    #####: 2784:        continue;
        -: 2785:      }
        -: 2786:    }
        -: 2787:
        -: 2788:    /* vi. */
    #####: 2789:    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 2790:    ecma_value_t element_temp = ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target),
        -: 2791:                                                                       target_index,
        -: 2792:                                                                       element,
        -: 2793:                                                                       flags);
        -: 2794:
    #####: 2795:    ecma_free_value (element);
        -: 2796:
    #####: 2797:    if (ECMA_IS_VALUE_ERROR (element_temp))
        -: 2798:    {
    #####: 2799:      return element_temp;
        -: 2800:    }
        -: 2801:
    #####: 2802:    target_index++;
        -: 2803:  }
        -: 2804:  /* 10. */
    #####: 2805:  return ecma_make_length_value (target_index);
        -: 2806:} /* ecma_builtin_array_flatten_into_array */
        -: 2807:
        -: 2808:/**
        -: 2809: * The Array.prototype object's 'flat' routine
        -: 2810: *
        -: 2811: * See also:
        -: 2812: *          ECMA-262 v10, 22.1.3.10
        -: 2813: *
        -: 2814: * @return ecma value
        -: 2815: *         Returned value must be freed with ecma_free_value.
        -: 2816: */
        -: 2817:static ecma_value_t
    #####: 2818:ecma_builtin_array_prototype_object_flat (const ecma_value_t args[], /**< arguments list */
        -: 2819:                                          uint32_t args_number, /**< number of arguments */
        -: 2820:                                          ecma_object_t *obj_p, /**< array object */
        -: 2821:                                          ecma_length_t len) /**< array object's length */
        -: 2822:{
        -: 2823:  /* 3. */
    #####: 2824:  ecma_number_t depth_num = 1;
        -: 2825:
        -: 2826:  /* 4. */
    #####: 2827:  if (args_number > 0 && ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[0], &depth_num)))
        -: 2828:  {
    #####: 2829:    return ECMA_VALUE_ERROR;
        -: 2830:  }
        -: 2831:
        -: 2832:  /* 5. */
    #####: 2833:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2834:
    #####: 2835:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2836:  {
    #####: 2837:    return ECMA_VALUE_ERROR;
        -: 2838:  }
        -: 2839:
        -: 2840:  /* 6. */
    #####: 2841:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2842:                                                                    obj_p,
        -: 2843:                                                                    len,
        -: 2844:                                                                    0,
        -: 2845:                                                                    depth_num,
        -: 2846:                                                                    ECMA_VALUE_UNDEFINED,
        -: 2847:                                                                    ECMA_VALUE_UNDEFINED);
        -: 2848:
    #####: 2849:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2850:  {
    #####: 2851:    ecma_deref_object (new_array_p);
    #####: 2852:    return flatten_val;
        -: 2853:  }
        -: 2854:
        -: 2855:  /* 7. */
    #####: 2856:  return ecma_make_object_value (new_array_p);
        -: 2857:} /* ecma_builtin_array_prototype_object_flat */
        -: 2858:
        -: 2859:/**
        -: 2860: * The Array.prototype object's 'flatMap' routine
        -: 2861: *
        -: 2862: * See also:
        -: 2863: *          ECMA-262 v10, 22.1.3.11
        -: 2864: *
        -: 2865: * @return ecma value
        -: 2866: *         Returned value must be freed with ecma_free_value.
        -: 2867: */
        -: 2868:static ecma_value_t
    #####: 2869:ecma_builtin_array_prototype_object_flat_map (ecma_value_t callback, /**< callbackFn */
        -: 2870:                                              ecma_value_t this_arg, /**< thisArg */
        -: 2871:                                              ecma_object_t *obj_p, /**< array object */
        -: 2872:                                              ecma_length_t len) /**< array object's length */
        -: 2873:{
    #####: 2874:  if (!ecma_op_is_callable (callback))
        -: 2875:  {
    #####: 2876:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2877:  }
        -: 2878:
        -: 2879:  /* 4. */
    #####: 2880:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2881:
    #####: 2882:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2883:  {
    #####: 2884:    return ECMA_VALUE_ERROR;
        -: 2885:  }
        -: 2886:
        -: 2887:  /* 5. */
    #####: 2888:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2889:                                                                    obj_p,
        -: 2890:                                                                    len,
        -: 2891:                                                                    0,
        -: 2892:                                                                    1,
        -: 2893:                                                                    callback,
        -: 2894:                                                                    this_arg);
    #####: 2895:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2896:  {
    #####: 2897:    ecma_deref_object (new_array_p);
    #####: 2898:    return flatten_val;
        -: 2899:  }
        -: 2900:
        -: 2901:  /* 6. */
    #####: 2902:  return ecma_make_object_value (new_array_p);
        -: 2903:} /* ecma_builtin_array_prototype_object_flat_map */
        -: 2904:#endif /* JERRY_ESNEXT */
        -: 2905:
        -: 2906:/**
        -: 2907: * Dispatcher of the built-in's routines
        -: 2908: *
        -: 2909: * @return ecma value
        -: 2910: *         Returned value must be freed with ecma_free_value.
        -: 2911: */
        -: 2912:ecma_value_t
    #####: 2913:ecma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 2914:                                               ecma_value_t this_arg, /**< 'this' argument value */
        -: 2915:                                               const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 2916:                                                                                       *   passed to routine */
        -: 2917:                                               uint32_t arguments_number) /**< length of arguments' list */
        -: 2918:{
    #####: 2919:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -: 2920:
    #####: 2921:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -: 2922:  {
    #####: 2923:    return obj_this;
        -: 2924:  }
        -: 2925:
    #####: 2926:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -: 2927:
    #####: 2928:  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))
        -: 2929:  {
    #####: 2930:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 2931:
        -: 2932:#if !JERRY_ESNEXT
    #####: 2933:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)
        -: 2934:    {
    #####: 2935:      ret_value = ecma_array_object_to_string (obj_this);
        -: 2936:    }
        -: 2937:#endif /* !JERRY_ESNEXT */
    #####: 2938:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_SORT)
        -: 2939:    {
    #####: 2940:      ret_value = ecma_builtin_array_prototype_object_sort (this_arg,
        -: 2941:                                                            arguments_list_p[0],
        -: 2942:                                                            obj_p);
        -: 2943:
        -: 2944:    }
    #####: 2945:    else if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT)
        -: 2946:    {
    #####: 2947:      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p,
        -: 2948:                                                              arguments_number,
        -: 2949:                                                              obj_p);
        -: 2950:    }
        -: 2951:
    #####: 2952:    ecma_deref_object (obj_p);
    #####: 2953:    return ret_value;
        -: 2954:  }
        -: 2955:
        -: 2956:#if JERRY_ESNEXT
    #####: 2957:  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES
        -: 2958:                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))
        -: 2959:  {
        -: 2960:    ecma_value_t ret_value;
        -: 2961:
    #####: 2962:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)
        -: 2963:    {
    #####: 2964:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_ENTRIES);
        -: 2965:    }
        -: 2966:    else
        -: 2967:    {
    #####: 2968:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);
    #####: 2969:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);
        -: 2970:    }
        -: 2971:
    #####: 2972:    ecma_deref_object (obj_p);
    #####: 2973:    return ret_value;
        -: 2974:  }
        -: 2975:#endif /* JERRY_ESNEXT */
        -: 2976:
    #####: 2977:  ecma_length_t length;
    #####: 2978:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -: 2979:
    #####: 2980:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2981:  {
    #####: 2982:    ecma_deref_object (obj_p);
    #####: 2983:    return len_value;
        -: 2984:  }
        -: 2985:
        -: 2986:  ecma_value_t ret_value;
        -: 2987:
    #####: 2988:  switch (builtin_routine_id)
        -: 2989:  {
    #####: 2990:    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:
        -: 2991:    {
    #####: 2992:      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);
    #####: 2993:      break;
        -: 2994:    }
    #####: 2995:    case ECMA_ARRAY_PROTOTYPE_JOIN:
        -: 2996:    {
    #####: 2997:      ret_value = ecma_builtin_array_prototype_join (arguments_list_p[0], obj_p, length);
    #####: 2998:      break;
        -: 2999:    }
    #####: 3000:    case ECMA_ARRAY_PROTOTYPE_POP:
        -: 3001:    {
    #####: 3002:      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);
    #####: 3003:      break;
        -: 3004:    }
    #####: 3005:    case ECMA_ARRAY_PROTOTYPE_PUSH:
        -: 3006:    {
    #####: 3007:      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p,
        -: 3008:                                                            arguments_number,
        -: 3009:                                                            obj_p,
        -: 3010:                                                            length);
    #####: 3011:      break;
        -: 3012:    }
    #####: 3013:    case ECMA_ARRAY_PROTOTYPE_REVERSE:
        -: 3014:    {
    #####: 3015:      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);
    #####: 3016:      break;
        -: 3017:    }
    #####: 3018:    case ECMA_ARRAY_PROTOTYPE_SHIFT:
        -: 3019:    {
    #####: 3020:      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);
    #####: 3021:      break;
        -: 3022:    }
    #####: 3023:    case ECMA_ARRAY_PROTOTYPE_SLICE:
        -: 3024:    {
    #####: 3025:      ret_value = ecma_builtin_array_prototype_object_slice (arguments_list_p[0],
    #####: 3026:                                                             arguments_list_p[1],
        -: 3027:                                                             obj_p,
        -: 3028:                                                             length);
    #####: 3029:      break;
        -: 3030:    }
    #####: 3031:    case ECMA_ARRAY_PROTOTYPE_SPLICE:
        -: 3032:    {
    #####: 3033:      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p,
        -: 3034:                                                              arguments_number,
        -: 3035:                                                              obj_p,
        -: 3036:                                                              length);
    #####: 3037:      break;
        -: 3038:    }
    #####: 3039:    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:
        -: 3040:    {
    #####: 3041:      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p,
        -: 3042:                                                               arguments_number,
        -: 3043:                                                               obj_p,
        -: 3044:                                                               length);
    #####: 3045:      break;
        -: 3046:    }
    #####: 3047:    case ECMA_ARRAY_PROTOTYPE_AT:
        -: 3048:    {
    #####: 3049:      ret_value = ecma_builtin_array_prototype_object_at (arguments_list_p[0],
        -: 3050:                                                          obj_p,
        -: 3051:                                                          length);
    #####: 3052:      break;
        -: 3053:    }
    #####: 3054:    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:
        -: 3055:    {
    #####: 3056:      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p,
        -: 3057:                                                                arguments_number,
        -: 3058:                                                                obj_p,
        -: 3059:                                                                length);
    #####: 3060:      break;
        -: 3061:    }
    #####: 3062:    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:
        -: 3063:    {
    #####: 3064:      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p,
        -: 3065:                                                                     arguments_number,
        -: 3066:                                                                     obj_p,
        -: 3067:                                                                     length);
    #####: 3068:      break;
        -: 3069:    }
    #####: 3070:    case ECMA_ARRAY_PROTOTYPE_EVERY:
        -: 3071:    case ECMA_ARRAY_PROTOTYPE_SOME:
        -: 3072:    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:
        -: 3073:    {
    #####: 3074:      ret_value = ecma_builtin_array_apply (arguments_list_p[0],
    #####: 3075:                                            arguments_list_p[1],
    #####: 3076:                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,
        -: 3077:                                            obj_p,
        -: 3078:                                            length);
    #####: 3079:      break;
        -: 3080:    }
    #####: 3081:    case ECMA_ARRAY_PROTOTYPE_MAP:
        -: 3082:    {
    #####: 3083:      ret_value = ecma_builtin_array_prototype_object_map (arguments_list_p[0],
    #####: 3084:                                                           arguments_list_p[1],
        -: 3085:                                                           obj_p,
        -: 3086:                                                           length);
    #####: 3087:      break;
        -: 3088:    }
    #####: 3089:    case ECMA_ARRAY_PROTOTYPE_REDUCE:
        -: 3090:    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:
        -: 3091:    {
    #####: 3092:      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,
        -: 3093:                                                  arguments_number,
        -: 3094:                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,
        -: 3095:                                                  obj_p,
        -: 3096:                                                  length);
    #####: 3097:      break;
        -: 3098:    }
        -: 3099:#if JERRY_ESNEXT
    #####: 3100:    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:
        -: 3101:    {
    #####: 3102:      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p,
        -: 3103:                                                                   arguments_number,
        -: 3104:                                                                   obj_p,
        -: 3105:                                                                   length);
    #####: 3106:      break;
        -: 3107:    }
    #####: 3108:    case ECMA_ARRAY_PROTOTYPE_FIND:
        -: 3109:    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:
        -: 3110:    {
    #####: 3111:      ret_value = ecma_builtin_array_prototype_object_find (arguments_list_p[0],
    #####: 3112:                                                            arguments_list_p[1],
        -: 3113:                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,
        -: 3114:                                                            obj_p,
        -: 3115:                                                            length);
    #####: 3116:      break;
        -: 3117:    }
    #####: 3118:    case ECMA_ARRAY_PROTOTYPE_FILL:
        -: 3119:    {
    #####: 3120:      ret_value = ecma_builtin_array_prototype_fill (arguments_list_p[0],
    #####: 3121:                                                     arguments_list_p[1],
    #####: 3122:                                                     arguments_list_p[2],
        -: 3123:                                                     obj_p,
        -: 3124:                                                     length);
    #####: 3125:      break;
        -: 3126:    }
    #####: 3127:    case ECMA_ARRAY_PROTOTYPE_INCLUDES:
        -: 3128:    {
    #####: 3129:      ret_value = ecma_builtin_array_prototype_includes (arguments_list_p,
        -: 3130:                                                         arguments_number,
        -: 3131:                                                         obj_p,
        -: 3132:                                                         length);
    #####: 3133:      break;
        -: 3134:    }
    #####: 3135:    case ECMA_ARRAY_PROTOTYPE_FLAT:
        -: 3136:    {
    #####: 3137:      ret_value = ecma_builtin_array_prototype_object_flat (arguments_list_p,
        -: 3138:                                                            arguments_number,
        -: 3139:                                                            obj_p,
        -: 3140:                                                            length);
    #####: 3141:      break;
        -: 3142:    }
    #####: 3143:    case ECMA_ARRAY_PROTOTYPE_FLATMAP:
        -: 3144:    {
    #####: 3145:      ret_value = ecma_builtin_array_prototype_object_flat_map (arguments_list_p[0],
    #####: 3146:                                                                arguments_list_p[1],
        -: 3147:                                                                obj_p,
        -: 3148:                                                                length);
    #####: 3149:      break;
        -: 3150:    }
        -: 3151:#endif /* JERRY_ESNEXT */
    #####: 3152:    default:
        -: 3153:    {
    #####: 3154:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);
        -: 3155:
    #####: 3156:      ret_value = ecma_builtin_array_prototype_object_filter (arguments_list_p[0],
    #####: 3157:                                                              arguments_list_p[1],
        -: 3158:                                                              obj_p,
        -: 3159:                                                              length);
    #####: 3160:      break;
        -: 3161:    }
        -: 3162:  }
        -: 3163:
    #####: 3164:  ecma_free_value (len_value);
    #####: 3165:  ecma_deref_object (obj_p);
        -: 3166:
    #####: 3167:  return ret_value;
        -: 3168:} /* ecma_builtin_array_prototype_dispatch_routine */
        -: 3169:
        -: 3170:/**
        -: 3171: * @}
        -: 3172: * @}
        -: 3173: * @}
        -: 3174: */
        -: 3175:
        -: 3176:#endif /* JERRY_BUILTIN_ARRAY */
