        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-get-put-value.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Implementation of ECMA GetValue and PutValue
        -:   18: */
        -:   19:
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "ecma-lex-env.h"
        -:   25:#include "ecma-objects.h"
        -:   26:#include "ecma-function-object.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:
        -:   29:#include "ecma-reference.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup lexicalenvironment Lexical environment
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * GetValue operation part
        -:   40: *
        -:   41: * See also: ECMA-262 v5, 8.7.1, sections 3 and 5
        -:   42: *
        -:   43: * @return ecma value
        -:   44: *         Returned value must be freed with ecma_free_value.
        -:   45: */
        -:   46:ecma_value_t
    #####:   47:ecma_op_get_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */
        -:   48:                                ecma_object_t **ref_base_lex_env_p, /**< [out] reference's base (lexical environment) */
        -:   49:                                ecma_string_t *name_p) /**< variable name */
        -:   50:{
    #####:   51:  JERRY_ASSERT (lex_env_p != NULL
        -:   52:                && ecma_is_lexical_environment (lex_env_p));
        -:   53:
        -:   54:  while (true)
        -:   55:  {
    #####:   56:    switch (ecma_get_lex_env_type (lex_env_p))
        -:   57:    {
    #####:   58:      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:   59:      {
    #####:   60:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:   61:
    #####:   62:        if (property_p != NULL)
        -:   63:        {
    #####:   64:          *ref_base_lex_env_p = lex_env_p;
    #####:   65:          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   66:
        -:   67:#if JERRY_ESNEXT
    #####:   68:          if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:   69:          {
    #####:   70:            return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:   71:          }
        -:   72:#endif /* JERRY_ESNEXT */
        -:   73:
    #####:   74:          return ecma_fast_copy_value (property_value_p->value);
        -:   75:        }
    #####:   76:        break;
        -:   77:      }
        -:   78:#if JERRY_ESNEXT
    #####:   79:      case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:   80:      {
        -:   81:#if JERRY_MODULE_SYSTEM
    #####:   82:        if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)
        -:   83:        {
    #####:   84:          ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:   85:
    #####:   86:          if (property_p != NULL)
        -:   87:          {
    #####:   88:            *ref_base_lex_env_p = lex_env_p;
    #####:   89:            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   90:
    #####:   91:            if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:   92:            {
    #####:   93:              property_value_p = ecma_get_property_value_from_named_reference (property_value_p);
        -:   94:            }
        -:   95:
    #####:   96:            if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:   97:            {
    #####:   98:              return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:   99:            }
        -:  100:
    #####:  101:            return ecma_fast_copy_value (property_value_p->value);
        -:  102:          }
        -:  103:        }
        -:  104:#endif /* JERRY_MODULE_SYSTEM */
    #####:  105:        break;
        -:  106:      }
        -:  107:#endif /* JERRY_ESNEXT */
    #####:  108:      default:
        -:  109:      {
    #####:  110:        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  111:
    #####:  112:        ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);
        -:  113:
    #####:  114:        if (ecma_is_value_found (result))
        -:  115:        {
        -:  116:          /* Note: the result may contains ECMA_VALUE_ERROR */
    #####:  117:          *ref_base_lex_env_p = lex_env_p;
    #####:  118:          return result;
        -:  119:        }
        -:  120:
    #####:  121:        break;
        -:  122:      }
        -:  123:    }
        -:  124:
    #####:  125:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:  126:    {
    #####:  127:      break;
        -:  128:    }
        -:  129:
    #####:  130:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  131:  }
        -:  132:
    #####:  133:  *ref_base_lex_env_p = NULL;
        -:  134:#if JERRY_ERROR_MESSAGES
    #####:  135:  return ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,
        -:  136:                                                "% is not defined",
        -:  137:                                                ecma_make_string_value (name_p));
        -:  138:#else /* JERRY_ERROR_MESSAGES */
        -:  139:  return ecma_raise_reference_error (NULL);
        -:  140:#endif /* JERRY_ERROR_MESSAGES */
        -:  141:
        -:  142:} /* ecma_op_get_value_lex_env_base */
        -:  143:
        -:  144:/**
        -:  145: * GetValue operation part (object base).
        -:  146: *
        -:  147: * See also: ECMA-262 v5, 8.7.1, section 4
        -:  148: *
        -:  149: * @return ecma value
        -:  150: *         Returned value must be freed with ecma_free_value.
        -:  151: */
        -:  152:ecma_value_t
    #####:  153:ecma_op_get_value_object_base (ecma_value_t base_value, /**< base value */
        -:  154:                               ecma_string_t *property_name_p) /**< property name */
        -:  155:{
        -:  156:  ecma_object_t *obj_p;
        -:  157:
    #####:  158:  if (JERRY_UNLIKELY (ecma_is_value_object (base_value)))
        -:  159:  {
    #####:  160:    obj_p = ecma_get_object_from_value (base_value);
        -:  161:  }
        -:  162:  else
        -:  163:  {
    #####:  164:    ecma_builtin_id_t id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;
        -:  165:
    #####:  166:    if (JERRY_LIKELY (ecma_is_value_string (base_value)))
        -:  167:    {
    #####:  168:      ecma_string_t *string_p = ecma_get_string_from_value (base_value);
        -:  169:
    #####:  170:      if (ecma_string_is_length (property_name_p))
        -:  171:      {
    #####:  172:        return ecma_make_uint32_value (ecma_string_get_length (string_p));
        -:  173:      }
        -:  174:
    #####:  175:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  176:
    #####:  177:      if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####:  178:          && index < ecma_string_get_length (string_p))
        -:  179:      {
    #####:  180:        ecma_char_t char_at_idx = ecma_string_get_char_at_pos (string_p, index);
    #####:  181:        return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));
        -:  182:      }
        -:  183:
        -:  184:#if JERRY_BUILTIN_STRING
    #####:  185:      id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;
        -:  186:#endif /* JERRY_BUILTIN_STRING */
        -:  187:    }
    #####:  188:    else if (ecma_is_value_number (base_value))
        -:  189:    {
        -:  190:#if JERRY_BUILTIN_NUMBER
    #####:  191:      id = ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;
        -:  192:#endif /* JERRY_BUILTIN_NUMBER */
        -:  193:    }
        -:  194:#if JERRY_ESNEXT
    #####:  195:    else if (ecma_is_value_symbol (base_value))
        -:  196:    {
    #####:  197:      id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;
        -:  198:    }
        -:  199:#endif /* JERRY_ESNEXT */
        -:  200:#if JERRY_BUILTIN_BIGINT
    #####:  201:    else if (ecma_is_value_bigint (base_value))
        -:  202:    {
    #####:  203:      id = ECMA_BUILTIN_ID_BIGINT_PROTOTYPE;
        -:  204:    }
        -:  205:#endif /* JERRY_BUILTIN_BIGINT */
        -:  206:    else
        -:  207:    {
    #####:  208:      JERRY_ASSERT (ecma_is_value_boolean (base_value));
        -:  209:#if JERRY_BUILTIN_BOOLEAN
    #####:  210:      id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;
        -:  211:#endif /* JERRY_BUILTIN_BOOLEAN */
        -:  212:    }
        -:  213:
    #####:  214:    obj_p = ecma_builtin_get (id);
        -:  215:  }
        -:  216:
    #####:  217:  return ecma_op_object_get_with_receiver (obj_p, property_name_p, base_value);
        -:  218:} /* ecma_op_get_value_object_base */
        -:  219:
        -:  220:/**
        -:  221: * PutValue operation part
        -:  222: *
        -:  223: * See also: ECMA-262 v5, 8.7.2, sections 3 and 5
        -:  224: *
        -:  225: * @return ecma value
        -:  226: *         Returned value must be freed with ecma_free_value.
        -:  227: */
        -:  228:ecma_value_t
        2:  229:ecma_op_put_value_lex_env_base (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  230:                                ecma_string_t *name_p, /**< variable name */
        -:  231:                                bool is_strict, /**< flag indicating strict mode */
        -:  232:                                ecma_value_t value) /**< ECMA-value */
        -:  233:{
        2:  234:  JERRY_ASSERT (lex_env_p != NULL
        -:  235:                && ecma_is_lexical_environment (lex_env_p));
        -:  236:
        -:  237:  while (true)
        -:  238:  {
        2:  239:    switch (ecma_get_lex_env_type (lex_env_p))
        -:  240:    {
        -:  241:#if JERRY_ESNEXT
    #####:  242:      case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  243:      {
    #####:  244:        if ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)
        -:  245:        {
    #####:  246:          break;
        -:  247:        }
        -:  248:        /* FALLTHRU */
        -:  249:      }
        -:  250:#endif /* JERRY_ESNEXT */
    #####:  251:      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  252:      {
    #####:  253:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  254:
    #####:  255:        if (property_p != NULL)
        -:  256:        {
        -:  257:#if JERRY_ESNEXT
    #####:  258:          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  259:
    #####:  260:          JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_WRITABLE)
        -:  261:                        || (*property_p & ECMA_PROPERTY_FLAG_DATA));
        -:  262:
    #####:  263:          if ((*property_p & ECMA_PROPERTY_FLAG_WRITABLE)
    #####:  264:              && property_value_p->value != ECMA_VALUE_UNINITIALIZED)
        -:  265:          {
    #####:  266:            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);
    #####:  267:            return ECMA_VALUE_EMPTY;
        -:  268:          }
        -:  269:#else /* JERRY_ESNEXT */
    #####:  270:          if (ecma_is_property_writable (*property_p))
        -:  271:          {
    #####:  272:            ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  273:            ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);
    #####:  274:            return ECMA_VALUE_EMPTY;
        -:  275:          }
        -:  276:#endif /* JERRY_ESNEXT */
        -:  277:
    #####:  278:          return ecma_op_raise_set_binding_error (property_p, is_strict);
        -:  279:        }
    #####:  280:        break;
        -:  281:      }
        2:  282:      default:
        -:  283:      {
        2:  284:        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  285:
        2:  286:        ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  287:
        2:  288:        ecma_value_t has_property = ecma_op_object_has_property (binding_obj_p, name_p);
        -:  289:
        -:  290:#if JERRY_BUILTIN_PROXY
        2:  291:        if (ECMA_IS_VALUE_ERROR (has_property))
        -:  292:        {
    #####:  293:          return has_property;
        -:  294:        }
        -:  295:#endif /* JERRY_BUILTIN_PROXY */
        -:  296:
        2:  297:        if (ecma_is_value_true (has_property))
        -:  298:        {
        2:  299:          ecma_value_t completion = ecma_op_object_put (binding_obj_p,
        -:  300:                                                        name_p,
        -:  301:                                                        value,
        -:  302:                                                        is_strict);
        -:  303:
        2:  304:          if (ECMA_IS_VALUE_ERROR (completion))
        -:  305:          {
    #####:  306:            return completion;
        -:  307:          }
        -:  308:
        2:  309:          JERRY_ASSERT (ecma_is_value_boolean (completion));
        2:  310:          return ECMA_VALUE_EMPTY;
        -:  311:        }
        -:  312:
    #####:  313:        break;
        -:  314:      }
        -:  315:    }
        -:  316:
    #####:  317:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:  318:    {
    #####:  319:      break;
        -:  320:    }
        -:  321:
    #####:  322:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  323:  }
        -:  324:
    #####:  325:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  326:
    #####:  327:  if (is_strict)
        -:  328:  {
        -:  329:#if JERRY_ERROR_MESSAGES
    #####:  330:    return ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,
        -:  331:                                                  "% is not defined",
        -:  332:                                                  ecma_make_string_value (name_p));
        -:  333:#else /* !JERRY_ERROR_MESSAGES */
        -:  334:    return ecma_raise_reference_error (NULL);
        -:  335:#endif /* JERRY_ERROR_MESSAGES */
        -:  336:  }
        -:  337:
    #####:  338:  ecma_value_t completion = ecma_op_object_put (ecma_get_lex_env_binding_object (lex_env_p),
        -:  339:                                                name_p,
        -:  340:                                                value,
        -:  341:                                                false);
        -:  342:
    #####:  343:  JERRY_ASSERT (ecma_is_value_boolean (completion));
        -:  344:
    #####:  345:  return ECMA_VALUE_EMPTY;
        -:  346:} /* ecma_op_put_value_lex_env_base */
        -:  347:
        -:  348:/**
        -:  349: * @}
        -:  350: * @}
        -:  351: */
