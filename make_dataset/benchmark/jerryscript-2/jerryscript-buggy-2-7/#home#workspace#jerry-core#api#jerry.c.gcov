        -:    0:Source:/home/workspace/jerry-core/api/jerry.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:#include <math.h>
        -:   18:
        -:   19:#include "debugger.h"
        -:   20:#include "ecma-alloc.h"
        -:   21:#include "ecma-array-object.h"
        -:   22:#include "ecma-arraybuffer-object.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-builtin-helpers.h"
        -:   25:#include "ecma-builtins.h"
        -:   26:#include "ecma-comparison.h"
        -:   27:#include "ecma-container-object.h"
        -:   28:#include "ecma-dataview-object.h"
        -:   29:#include "ecma-eval.h"
        -:   30:#include "ecma-exceptions.h"
        -:   31:#include "ecma-extended-info.h"
        -:   32:#include "ecma-function-object.h"
        -:   33:#include "ecma-gc.h"
        -:   34:#include "ecma-helpers.h"
        -:   35:#include "ecma-init-finalize.h"
        -:   36:#include "ecma-iterator-object.h"
        -:   37:#include "ecma-lex-env.h"
        -:   38:#include "ecma-line-info.h"
        -:   39:#include "ecma-literal-storage.h"
        -:   40:#include "ecma-objects.h"
        -:   41:#include "ecma-objects-general.h"
        -:   42:#include "ecma-regexp-object.h"
        -:   43:#include "ecma-promise-object.h"
        -:   44:#include "ecma-proxy-object.h"
        -:   45:#include "ecma-shared-arraybuffer-object.h"
        -:   46:#include "ecma-symbol-object.h"
        -:   47:#include "ecma-typedarray-object.h"
        -:   48:#include "jcontext.h"
        -:   49:#include "jerryscript.h"
        -:   50:#include "jerryscript-debugger-transport.h"
        -:   51:#include "jmem.h"
        -:   52:#include "js-parser.h"
        -:   53:#include "lit-char-helpers.h"
        -:   54:#include "opcodes.h"
        -:   55:#include "re-compiler.h"
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   58:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   59:
        -:   60:#if JERRY_BUILTIN_REGEXP
        -:   61:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   62:                     && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   63:                     && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE
        -:   64:                     && (int) RE_FLAG_STICKY== (int) JERRY_REGEXP_FLAG_STICKY
        -:   65:                     && (int) RE_FLAG_UNICODE == (int) JERRY_REGEXP_FLAG_UNICODE
        -:   66:                     && (int) RE_FLAG_DOTALL == (int) JERRY_REGEXP_FLAG_DOTALL,
        -:   67:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   68:#endif /* JERRY_BUILTIN_REGEXP */
        -:   69:
        -:   70:#if JERRY_ESNEXT
        -:   71:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   72:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   73:                     && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   74:                     promise_internal_state_matches_external);
        -:   75:#endif /* JERRY_ESNEXT */
        -:   76:
        -:   77:/**
        -:   78: * Offset between internal and external arithmetic operator types
        -:   79: */
        -:   80:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   81:
        -:   82:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   83:                     && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_MUL)
        -:   84:                     && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   85:                     && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   86:                     number_arithmetics_operation_type_matches_external);
        -:   87:
        -:   88:#if !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC
        -:   89:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   90:#endif /* !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC */
        -:   91:
        -:   92:/** \addtogroup jerry Jerry engine interface
        -:   93: * @{
        -:   94: */
        -:   95:
        -:   96:/**
        -:   97: * Assert that it is correct to call API in current state.
        -:   98: *
        -:   99: * Note:
        -:  100: *         By convention, there are some states when API could not be invoked.
        -:  101: *
        -:  102: *         The API can be and only be invoked when the ECMA_STATUS_API_AVAILABLE
        -:  103: *         flag is set.
        -:  104: *
        -:  105: *         This procedure checks whether the API is available, and terminates
        -:  106: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  107: *
        -:  108: * Note:
        -:  109: *         The API could not be invoked in the following cases:
        -:  110: *           - before jerry_init and after jerry_cleanup
        -:  111: *           - between enter to and return from a native free callback
        -:  112: */
        -:  113:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  114:jerry_assert_api_available (void)
        -:  115:{
      121:  116:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);
        -:  117:} /* jerry_assert_api_available */
        -:  118:
        -:  119:/**
        -:  120: * Turn on API availability
        -:  121: */
        -:  122:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  123:jerry_make_api_available (void)
        -:  124:{
        1:  125:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;
        -:  126:} /* jerry_make_api_available */
        -:  127:
        -:  128:/**
        -:  129: * Turn off API availability
        -:  130: */
        -:  131:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  132:jerry_make_api_unavailable (void)
        -:  133:{
    #####:  134:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_AVAILABLE;
        -:  135:} /* jerry_make_api_unavailable */
        -:  136:
        -:  137:/**
        -:  138: * Create an API compatible return value.
        -:  139: *
        -:  140: * @return return value for Jerry API functions
        -:  141: */
        -:  142:static jerry_value_t
        5:  143:jerry_return (jerry_value_t value) /**< return value */
        -:  144:{
        5:  145:  if (ECMA_IS_VALUE_ERROR (value))
        -:  146:  {
    #####:  147:    value = ecma_create_error_reference_from_context ();
        -:  148:  }
        -:  149:
        5:  150:  return value;
        -:  151:} /* jerry_return */
        -:  152:
        -:  153:/**
        -:  154: * Throw an API compatible return value.
        -:  155: *
        -:  156: * @return return value for Jerry API functions
        -:  157: */
        -:  158:static inline jerry_value_t JERRY_ATTR_ALWAYS_INLINE
        -:  159:jerry_throw (jerry_value_t value) /**< return value */
        -:  160:{
    #####:  161:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (value));
    #####:  162:  return ecma_create_error_reference_from_context ();
        -:  163:} /* jerry_throw */
        -:  164:
        -:  165:/**
        -:  166: * Jerry engine initialization
        -:  167: */
        -:  168:void
        1:  169:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  170:{
        -:  171:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  172:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));
        -:  173:
        -:  174:  /* Zero out all non-external members. */
        1:  175:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,
        -:  176:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  177:
        1:  178:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  179:
        -:  180:  jerry_make_api_available ();
        -:  181:
        1:  182:  jmem_init ();
        1:  183:  ecma_init ();
        1:  184:} /* jerry_init */
        -:  185:
        -:  186:/**
        -:  187: * Terminate Jerry engine
        -:  188: */
        -:  189:void
    #####:  190:jerry_cleanup (void)
        -:  191:{
        -:  192:  jerry_assert_api_available ();
        -:  193:
        -:  194:#if JERRY_DEBUGGER
        -:  195:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  196:  {
        -:  197:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  198:
        -:  199:    jerry_debugger_transport_close ();
        -:  200:  }
        -:  201:#endif /* JERRY_DEBUGGER */
        -:  202:
    #####:  203:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p);
        -:  204:       this_p != NULL;
    #####:  205:       this_p = this_p->next_p)
        -:  206:  {
    #####:  207:    if (this_p->manager_p->deinit_cb)
        -:  208:    {
    #####:  209:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  210:      this_p->manager_p->deinit_cb (data);
        -:  211:    }
        -:  212:  }
        -:  213:
        -:  214:#if JERRY_ESNEXT
    #####:  215:  ecma_free_all_enqueued_jobs ();
        -:  216:#endif /* JERRY_ESNEXT */
    #####:  217:  ecma_finalize ();
        -:  218:  jerry_make_api_unavailable ();
        -:  219:
    #####:  220:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL;
        -:  221:       this_p != NULL;
    #####:  222:       this_p = next_p)
        -:  223:  {
    #####:  224:    next_p = this_p->next_p;
    #####:  225:    if (this_p->manager_p->finalize_cb)
        -:  226:    {
    #####:  227:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  228:      this_p->manager_p->finalize_cb (data);
        -:  229:    }
    #####:  230:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  231:  }
        -:  232:
    #####:  233:  jmem_finalize ();
    #####:  234:} /* jerry_cleanup */
        -:  235:
        -:  236:/**
        -:  237: * Retrieve a context data item, or create a new one.
        -:  238: *
        -:  239: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  240: *
        -:  241: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  242: * none was found.
        -:  243: */
        -:  244:void *
    #####:  245:jerry_get_context_data (const jerry_context_data_manager_t *manager_p)
        -:  246:{
    #####:  247:  void *ret = NULL;
        -:  248:  jerry_context_data_header_t *item_p;
        -:  249:
    #####:  250:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  251:  {
    #####:  252:    if (item_p->manager_p == manager_p)
        -:  253:    {
    #####:  254:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  255:    }
        -:  256:  }
        -:  257:
    #####:  258:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  259:  item_p->manager_p = manager_p;
    #####:  260:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  261:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  262:
    #####:  263:  if (manager_p->bytes_needed > 0)
        -:  264:  {
    #####:  265:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  266:    memset (ret, 0, manager_p->bytes_needed);
        -:  267:  }
        -:  268:
    #####:  269:  if (manager_p->init_cb)
        -:  270:  {
    #####:  271:    manager_p->init_cb (ret);
        -:  272:  }
        -:  273:
    #####:  274:  return ret;
        -:  275:} /* jerry_get_context_data */
        -:  276:
        -:  277:/**
        -:  278: * Register external magic string array
        -:  279: */
        -:  280:void
    #####:  281:jerry_register_magic_strings (const jerry_char_t * const *ex_str_items_p, /**< character arrays, representing
        -:  282:                                                                           *   external magic strings' contents */
        -:  283:                              uint32_t count, /**< number of the strings */
        -:  284:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  285:{
        -:  286:  jerry_assert_api_available ();
        -:  287:
    #####:  288:  lit_magic_strings_ex_set ((const lit_utf8_byte_t * const *) ex_str_items_p,
        -:  289:                            count,
        -:  290:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  291:} /* jerry_register_magic_strings */
        -:  292:
        -:  293:/**
        -:  294: * Run garbage collection
        -:  295: */
        -:  296:void
    #####:  297:jerry_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  298:{
        -:  299:  jerry_assert_api_available ();
        -:  300:
    #####:  301:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  302:  {
        -:  303:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  304:    ecma_gc_run ();
    #####:  305:    return;
        -:  306:  }
        -:  307:
    #####:  308:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  309:} /* jerry_gc */
        -:  310:
        -:  311:/**
        -:  312: * Get heap memory stats.
        -:  313: *
        -:  314: * @return true - get the heap stats successful
        -:  315: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  316: */
        -:  317:bool
    #####:  318:jerry_get_memory_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  319:{
        -:  320:#if JERRY_MEM_STATS
    #####:  321:  if (out_stats_p == NULL)
        -:  322:  {
        -:  323:    return false;
        -:  324:  }
        -:  325:
        -:  326:  jmem_heap_stats_t jmem_heap_stats;
    #####:  327:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  328:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  329:
    #####:  330:  *out_stats_p = (jerry_heap_stats_t)
        -:  331:  {
        -:  332:    .version = 1,
    #####:  333:    .size = jmem_heap_stats.size,
    #####:  334:    .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  335:    .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes
        -:  336:  };
        -:  337:
    #####:  338:  return true;
        -:  339:#else /* !JERRY_MEM_STATS */
        -:  340:  JERRY_UNUSED (out_stats_p);
    #####:  341:  return false;
        -:  342:#endif /* JERRY_MEM_STATS */
        -:  343:} /* jerry_get_memory_stats */
        -:  344:
        -:  345:/**
        -:  346: * Simple Jerry runner
        -:  347: *
        -:  348: * @return true  - if run was successful
        -:  349: *         false - otherwise
        -:  350: */
        -:  351:bool
    #####:  352:jerry_run_simple (const jerry_char_t *script_source_p, /**< script source */
        -:  353:                  size_t script_source_size, /**< script source size */
        -:  354:                  jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  355:{
    #####:  356:  bool result = false;
        -:  357:
    #####:  358:  jerry_init (flags);
        -:  359:
    #####:  360:  jerry_value_t parse_ret_val = jerry_parse (script_source_p, script_source_size, NULL);
        -:  361:
    #####:  362:  if (!ecma_is_value_error_reference (parse_ret_val))
        -:  363:  {
    #####:  364:    jerry_value_t run_ret_val = jerry_run (parse_ret_val);
        -:  365:
    #####:  366:    if (!ecma_is_value_error_reference (run_ret_val))
        -:  367:    {
    #####:  368:      result = true;
        -:  369:    }
        -:  370:
    #####:  371:    jerry_release_value (run_ret_val);
        -:  372:  }
        -:  373:
    #####:  374:  jerry_release_value (parse_ret_val);
    #####:  375:  jerry_cleanup ();
        -:  376:
    #####:  377:  return result;
        -:  378:} /* jerry_run_simple */
        -:  379:
        -:  380:#if JERRY_PARSER
        -:  381:
        -:  382:/**
        -:  383: * Common code for parsing a script, module, or function.
        -:  384: *
        -:  385: * @return function object value - if script was parsed successfully,
        -:  386: *         thrown error - otherwise
        -:  387: */
        -:  388:static jerry_value_t
        1:  389:jerry_parse_common (void *source_p, /**< script source */
        -:  390:                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */
        -:  391:                    uint32_t parse_opts) /**< internal parsing options */
        -:  392:{
        -:  393:  jerry_assert_api_available ();
        -:  394:
        1:  395:  if (options_p != NULL)
        -:  396:  {
        1:  397:    const uint32_t allowed_options = (JERRY_PARSE_STRICT_MODE
        -:  398:                                      | JERRY_PARSE_MODULE
        -:  399:                                      | JERRY_PARSE_HAS_ARGUMENT_LIST
        -:  400:                                      | JERRY_PARSE_HAS_RESOURCE
        -:  401:                                      | JERRY_PARSE_HAS_START
        -:  402:                                      | JERRY_PARSE_HAS_USER_VALUE);
        1:  403:    uint32_t options = options_p->options;
        -:  404:
        1:  405:    if ((options & ~allowed_options) != 0
        1:  406:        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)
    #####:  407:            && ((options_p->options & JERRY_PARSE_MODULE)
    #####:  408:                || !ecma_is_value_string (options_p->argument_list)))
        1:  409:        || ((options_p->options & JERRY_PARSE_HAS_RESOURCE)
        1:  410:            && !ecma_is_value_string (options_p->resource_name)))
        -:  411:    {
    #####:  412:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  413:    }
        -:  414:  }
        -:  415:
        -:  416:#if JERRY_DEBUGGER
        -:  417:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  418:      && options_p != NULL
        -:  419:      && (options_p->options & JERRY_PARSE_HAS_RESOURCE)
        -:  420:      && ecma_is_value_string (options_p->resource_name))
        -:  421:  {
        -:  422:    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->resource_name),
        -:  423:                                resource_name_start_p,
        -:  424:                                resource_name_size);
        -:  425:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  426:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  427:                                resource_name_start_p,
        -:  428:                                resource_name_size);
        -:  429:    ECMA_FINALIZE_UTF8_STRING (resource_name_start_p, resource_name_size);
        -:  430:  }
        -:  431:#endif /* JERRY_DEBUGGER */
        -:  432:
        1:  433:  if (options_p != NULL)
        -:  434:  {
        1:  435:    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);
        -:  436:  }
        -:  437:
        1:  438:  if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  439:  {
        -:  440:#if JERRY_MODULE_SYSTEM
    #####:  441:    JERRY_CONTEXT (module_current_p) = ecma_module_create ();
        -:  442:#else /* !JERRY_MODULE_SYSTEM */
    #####:  443:    return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  444:#endif /* JERRY_MODULE_SYSTEM */
        -:  445:  }
        -:  446:
        -:  447:  ecma_compiled_code_t *bytecode_data_p;
        1:  448:  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);
        -:  449:
        1:  450:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  451:  {
        -:  452:#if JERRY_MODULE_SYSTEM
    #####:  453:    if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  454:    {
    #####:  455:      ecma_module_cleanup_context ();
        -:  456:    }
        -:  457:#endif /* JERRY_MODULE_SYSTEM */
        -:  458:
    #####:  459:    return ecma_create_error_reference_from_context ();
        -:  460:  }
        -:  461:
        -:  462:#if JERRY_MODULE_SYSTEM
        1:  463:  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))
        -:  464:  {
    #####:  465:    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);
    #####:  466:    module_p->u.compiled_code_p = bytecode_data_p;
        -:  467:
    #####:  468:    JERRY_CONTEXT (module_current_p) = NULL;
        -:  469:
    #####:  470:    return ecma_make_object_value ((ecma_object_t *) module_p);
        -:  471:  }
        -:  472:#endif /* JERRY_MODULE_SYSTEM */
        -:  473:
        1:  474:  if (JERRY_UNLIKELY (options_p != NULL
        -:  475:                      && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))
        -:  476:  {
    #####:  477:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -:  478:
        -:  479:#if JERRY_BUILTIN_REALMS
    #####:  480:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));
        -:  481:#endif /* JERRY_BUILTIN_REALMS */
        -:  482:
    #####:  483:    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);
    #####:  484:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  485:    ecma_bytecode_deref (bytecode_data_p);
        -:  486:
    #####:  487:    return ecma_make_object_value (func_obj_p);
        -:  488:  }
        -:  489:
        1:  490:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  491:
        1:  492:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  493:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;
        1:  494:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);
        -:  495:
        1:  496:  return ecma_make_object_value (object_p);
        -:  497:} /* jerry_parse_common */
        -:  498:
        -:  499:#endif /* JERRY_PARSER */
        -:  500:
        -:  501:/**
        -:  502: * Parse a script, module, or function and create a compiled code using a character string
        -:  503: *
        -:  504: * @return function object value - if script was parsed successfully,
        -:  505: *         thrown error - otherwise
        -:  506: */
        -:  507:jerry_value_t
        1:  508:jerry_parse (const jerry_char_t *source_p, /**< script source */
        -:  509:             size_t source_size, /**< script source size */
        -:  510:             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  511:{
        -:  512:#if JERRY_PARSER
        1:  513:  parser_source_char_t source_char;
        1:  514:  source_char.source_p = source_p;
        1:  515:  source_char.source_size = source_size;
        -:  516:
        1:  517:  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);
        -:  518:#else /* !JERRY_PARSER */
        -:  519:  JERRY_UNUSED (source_p);
        -:  520:  JERRY_UNUSED (source_size);
        -:  521:  JERRY_UNUSED (options_p);
        -:  522:
        -:  523:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  524:#endif /* JERRY_PARSER */
        -:  525:} /* jerry_parse */
        -:  526:
        -:  527:/**
        -:  528: * Parse a script, module, or function and create a compiled code using a string value
        -:  529: *
        -:  530: * @return function object value - if script was parsed successfully,
        -:  531: *         thrown error - otherwise
        -:  532: */
        -:  533:jerry_value_t
    #####:  534:jerry_parse_value (const jerry_value_t source_value, /**< script source */
        -:  535:                   const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  536:{
        -:  537:#if JERRY_PARSER
    #####:  538:  if (!ecma_is_value_string (source_value))
        -:  539:  {
    #####:  540:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  541:  }
        -:  542:
    #####:  543:  ecma_value_t source[1];
    #####:  544:  source[0] = source_value;
        -:  545:
    #####:  546:  return jerry_parse_common ((void *) source, options_p, ECMA_PARSE_HAS_SOURCE_VALUE);
        -:  547:#else /* !JERRY_PARSER */
        -:  548:  JERRY_UNUSED (source_value);
        -:  549:  JERRY_UNUSED (options_p);
        -:  550:
        -:  551:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  552:#endif /* JERRY_PARSER */
        -:  553:} /* jerry_parse_value */
        -:  554:
        -:  555:/**
        -:  556: * Run a Script or Module created by jerry_parse.
        -:  557: *
        -:  558: * Note:
        -:  559: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  560: *
        -:  561: * @return result of bytecode - if run was successful
        -:  562: *         thrown error - otherwise
        -:  563: */
        -:  564:jerry_value_t
        1:  565:jerry_run (const jerry_value_t func_val) /**< function to run */
        -:  566:{
        -:  567:  jerry_assert_api_available ();
        -:  568:
        1:  569:  if (!ecma_is_value_object (func_val))
        -:  570:  {
    #####:  571:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  572:  }
        -:  573:
        1:  574:  ecma_object_t *object_p = ecma_get_object_from_value (func_val);
        -:  575:
        1:  576:  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))
        -:  577:  {
    #####:  578:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  579:  }
        -:  580:
        1:  581:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  582:
        -:  583:  const ecma_compiled_code_t *bytecode_data_p;
        1:  584:  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  585:
        1:  586:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);
        -:  587:
        1:  588:  return jerry_return (vm_run_global (bytecode_data_p, object_p));
        -:  589:} /* jerry_run */
        -:  590:
        -:  591:/**
        -:  592: * Perform eval
        -:  593: *
        -:  594: * Note:
        -:  595: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  596: *
        -:  597: * @return result of eval, may be error value.
        -:  598: */
        -:  599:jerry_value_t
    #####:  600:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  601:            size_t source_size, /**< length of source code */
        -:  602:            uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  603:{
        -:  604:  jerry_assert_api_available ();
        -:  605:
    #####:  606:  uint32_t allowed_parse_options = JERRY_PARSE_STRICT_MODE;
        -:  607:
    #####:  608:  if ((parse_opts & ~allowed_parse_options) != 0)
        -:  609:  {
    #####:  610:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  611:  }
        -:  612:
    #####:  613:  parser_source_char_t source_char;
    #####:  614:  source_char.source_p = source_p;
    #####:  615:  source_char.source_size = source_size;
        -:  616:
    #####:  617:  return jerry_return (ecma_op_eval_chars_buffer ((void *) &source_char, parse_opts));
        -:  618:} /* jerry_eval */
        -:  619:
        -:  620:/**
        -:  621: * Link modules to their dependencies. The dependencies are resolved by a user callback.
        -:  622: *
        -:  623: * Note:
        -:  624: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  625: *
        -:  626: * @return true - if linking is successful, error - otherwise
        -:  627: */
        -:  628:jerry_value_t
    #####:  629:jerry_module_link (const jerry_value_t module_val, /**< root module */
        -:  630:                   jerry_module_resolve_callback_t callback, /**< resolve module callback, uses
        -:  631:                                                              *   jerry_port_module_resolve when NULL is passed */
        -:  632:                   void *user_p) /**< pointer passed to the resolve callback */
        -:  633:{
        -:  634:  jerry_assert_api_available ();
        -:  635:
        -:  636:#if JERRY_MODULE_SYSTEM
    #####:  637:  if (callback == NULL)
        -:  638:  {
    #####:  639:    callback = jerry_port_module_resolve;
        -:  640:  }
        -:  641:
    #####:  642:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  643:
    #####:  644:  if (module_p == NULL)
        -:  645:  {
    #####:  646:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  647:  }
        -:  648:
    #####:  649:  return jerry_return (ecma_module_link (module_p, callback, user_p));
        -:  650:#else /* !JERRY_MODULE_SYSTEM */
        -:  651:  JERRY_UNUSED (module_val);
        -:  652:  JERRY_UNUSED (callback);
        -:  653:  JERRY_UNUSED (user_p);
        -:  654:
    #####:  655:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  656:#endif /* JERRY_MODULE_SYSTEM */
        -:  657:} /* jerry_module_link */
        -:  658:
        -:  659:/**
        -:  660: * Evaluate a module and its dependencies. The module must be in linked state.
        -:  661: *
        -:  662: * Note:
        -:  663: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  664: *
        -:  665: * @return result of module bytecode execution - if evaluation was successful
        -:  666: *         error - otherwise
        -:  667: */
        -:  668:jerry_value_t
    #####:  669:jerry_module_evaluate (const jerry_value_t module_val) /**< root module */
        -:  670:{
        -:  671:  jerry_assert_api_available ();
        -:  672:
        -:  673:#if JERRY_MODULE_SYSTEM
    #####:  674:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  675:
    #####:  676:  if (module_p == NULL)
        -:  677:  {
    #####:  678:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  679:  }
        -:  680:
    #####:  681:  if (module_p->header.u.cls.u1.module_state != JERRY_MODULE_STATE_LINKED)
        -:  682:  {
    #####:  683:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module must be in linked state")));
        -:  684:  }
        -:  685:
    #####:  686:  return jerry_return (ecma_module_evaluate (module_p));
        -:  687:#else /* !JERRY_MODULE_SYSTEM */
        -:  688:  JERRY_UNUSED (module_val);
        -:  689:
    #####:  690:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  691:#endif /* JERRY_MODULE_SYSTEM */
        -:  692:} /* jerry_module_evaluate */
        -:  693:
        -:  694:/**
        -:  695: * Returns the current status of a module
        -:  696: *
        -:  697: * @return current status - if module_val is a module,
        -:  698: *         JERRY_MODULE_STATE_INVALID - otherwise
        -:  699: */
        -:  700:jerry_module_state_t
    #####:  701:jerry_module_get_state (const jerry_value_t module_val) /**< module object */
        -:  702:{
        -:  703:  jerry_assert_api_available ();
        -:  704:
        -:  705:#if JERRY_MODULE_SYSTEM
    #####:  706:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  707:
    #####:  708:  if (module_p == NULL)
        -:  709:  {
    #####:  710:    return JERRY_MODULE_STATE_INVALID;
        -:  711:  }
        -:  712:
    #####:  713:  return (jerry_module_state_t) module_p->header.u.cls.u1.module_state;
        -:  714:#else /* !JERRY_MODULE_SYSTEM */
        -:  715:  JERRY_UNUSED (module_val);
        -:  716:
    #####:  717:  return JERRY_MODULE_STATE_INVALID;
        -:  718:#endif /* JERRY_MODULE_SYSTEM */
        -:  719:} /* jerry_module_get_state */
        -:  720:
        -:  721:/**
        -:  722: * Sets a callback which is called after a module state is changed to linked, evaluated, or error.
        -:  723: */
        -:  724:void
    #####:  725:jerry_module_set_state_changed_callback (jerry_module_state_changed_callback_t callback, /**< callback */
        -:  726:                                         void *user_p) /**< pointer passed to the callback */
        -:  727:{
        -:  728:  jerry_assert_api_available ();
        -:  729:
        -:  730:#if JERRY_MODULE_SYSTEM
    #####:  731:  JERRY_CONTEXT (module_state_changed_callback_p) = callback;
    #####:  732:  JERRY_CONTEXT (module_state_changed_callback_user_p) = user_p;
        -:  733:#else /* !JERRY_MODULE_SYSTEM */
        -:  734:  JERRY_UNUSED (callback);
        -:  735:  JERRY_UNUSED (user_p);
        -:  736:#endif /* JERRY_MODULE_SYSTEM */
    #####:  737:} /* jerry_module_set_state_changed_callback */
        -:  738:
        -:  739:/**
        -:  740: * Sets a callback which is called when an import.meta expression of a module is evaluated the first time.
        -:  741: */
        -:  742:void
    #####:  743:jerry_module_set_import_meta_callback (jerry_module_import_meta_callback_t callback, /**< callback */
        -:  744:                                       void *user_p) /**< pointer passed to the callback */
        -:  745:{
        -:  746:  jerry_assert_api_available ();
        -:  747:
        -:  748:#if JERRY_MODULE_SYSTEM
    #####:  749:  JERRY_CONTEXT (module_import_meta_callback_p) = callback;
    #####:  750:  JERRY_CONTEXT (module_import_meta_callback_user_p) = user_p;
        -:  751:#else /* !JERRY_MODULE_SYSTEM */
        -:  752:  JERRY_UNUSED (callback);
        -:  753:  JERRY_UNUSED (user_p);
        -:  754:#endif /* JERRY_MODULE_SYSTEM */
    #####:  755:} /* jerry_module_set_import_meta_callback */
        -:  756:
        -:  757:/**
        -:  758: * Returns the number of import/export requests of a module
        -:  759: *
        -:  760: * @return number of import/export requests of a module
        -:  761: */
        -:  762:size_t
    #####:  763:jerry_module_get_number_of_requests (const jerry_value_t module_val) /**< module */
        -:  764:{
        -:  765:  jerry_assert_api_available ();
        -:  766:
        -:  767:#if JERRY_MODULE_SYSTEM
    #####:  768:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  769:
    #####:  770:  if (module_p == NULL)
        -:  771:  {
    #####:  772:    return 0;
        -:  773:  }
        -:  774:
    #####:  775:  size_t number_of_requests = 0;
        -:  776:
    #####:  777:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  778:
    #####:  779:  while (node_p != NULL)
        -:  780:  {
    #####:  781:    number_of_requests++;
    #####:  782:    node_p = node_p->next_p;
        -:  783:  }
        -:  784:
    #####:  785:  return number_of_requests;
        -:  786:#else /* !JERRY_MODULE_SYSTEM */
        -:  787:  JERRY_UNUSED (module_val);
        -:  788:
    #####:  789:  return 0;
        -:  790:#endif /* JERRY_MODULE_SYSTEM */
        -:  791:} /* jerry_module_get_number_of_requests */
        -:  792:
        -:  793:/**
        -:  794: * Returns the module request specified by the request_index argument
        -:  795: *
        -:  796: * Note:
        -:  797: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  798: *
        -:  799: * @return string - if the request has not been resolved yet,
        -:  800: *         module object - if the request has been resolved successfully,
        -:  801: *         error - otherwise
        -:  802: */
        -:  803:jerry_value_t
    #####:  804:jerry_module_get_request (const jerry_value_t module_val, /**< module */
        -:  805:                          size_t request_index) /**< request index */
        -:  806:{
        -:  807:  jerry_assert_api_available ();
        -:  808:
        -:  809:#if JERRY_MODULE_SYSTEM
    #####:  810:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  811:
    #####:  812:  if (module_p == NULL)
        -:  813:  {
    #####:  814:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  815:  }
        -:  816:
    #####:  817:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  818:
    #####:  819:  while (node_p != NULL)
        -:  820:  {
    #####:  821:    if (request_index == 0)
        -:  822:    {
    #####:  823:      return ecma_copy_value (node_p->u.path_or_module);
        -:  824:    }
        -:  825:
    #####:  826:    --request_index;
    #####:  827:    node_p = node_p->next_p;
        -:  828:  }
        -:  829:
    #####:  830:  return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Request is not available")));
        -:  831:#else /* !JERRY_MODULE_SYSTEM */
        -:  832:  JERRY_UNUSED (module_val);
        -:  833:  JERRY_UNUSED (request_index);
        -:  834:
    #####:  835:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  836:#endif /* JERRY_MODULE_SYSTEM */
        -:  837:} /* jerry_module_get_request */
        -:  838:
        -:  839:/**
        -:  840: * Returns the namespace object of a module
        -:  841: *
        -:  842: * Note:
        -:  843: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  844: *
        -:  845: * @return object - if namespace object is available,
        -:  846: *         error - otherwise
        -:  847: */
        -:  848:jerry_value_t
    #####:  849:jerry_module_get_namespace (const jerry_value_t module_val) /**< module */
        -:  850:{
        -:  851:  jerry_assert_api_available ();
        -:  852:
        -:  853:#if JERRY_MODULE_SYSTEM
    #####:  854:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  855:
    #####:  856:  if (module_p == NULL)
        -:  857:  {
    #####:  858:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  859:  }
        -:  860:
    #####:  861:  if (module_p->header.u.cls.u1.module_state < JERRY_MODULE_STATE_LINKED
    #####:  862:      || module_p->header.u.cls.u1.module_state > JERRY_MODULE_STATE_EVALUATED)
        -:  863:  {
    #####:  864:    return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Namespace object is not available")));
        -:  865:  }
        -:  866:
    #####:  867:  JERRY_ASSERT (module_p->namespace_object_p != NULL);
        -:  868:
    #####:  869:  ecma_ref_object (module_p->namespace_object_p);
    #####:  870:  return ecma_make_object_value (module_p->namespace_object_p);
        -:  871:#else /* !JERRY_MODULE_SYSTEM */
        -:  872:  JERRY_UNUSED (module_val);
        -:  873:
    #####:  874:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  875:#endif /* JERRY_MODULE_SYSTEM */
        -:  876:} /* jerry_module_get_namespace */
        -:  877:
        -:  878:/**
        -:  879: * Sets the callback which is called when dynamic imports are resolved
        -:  880: */
        -:  881:void
    #####:  882:jerry_module_set_import_callback (jerry_module_import_callback_t callback_p, /**< callback which handles
        -:  883:                                                                              *   dynamic import calls */
        -:  884:                                  void *user_p) /**< user pointer passed to the callback */
        -:  885:{
        -:  886:  jerry_assert_api_available ();
        -:  887:
        -:  888:#if JERRY_MODULE_SYSTEM
    #####:  889:  JERRY_CONTEXT (module_import_callback_p) = callback_p;
    #####:  890:  JERRY_CONTEXT (module_import_callback_user_p) = user_p;
        -:  891:#else /* !JERRY_MODULE_SYSTEM */
        -:  892:  JERRY_UNUSED (callback_p);
        -:  893:  JERRY_UNUSED (user_p);
        -:  894:#endif /* JERRY_MODULE_SYSTEM */
    #####:  895:} /* jerry_module_set_import_callback */
        -:  896:
        -:  897:/**
        -:  898: * Creates a native module with a list of exports. The initial state of the module is linked.
        -:  899: *
        -:  900: * Note:
        -:  901: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  902: *
        -:  903: * @return native module - if the module is successfully created,
        -:  904: *         error - otherwise
        -:  905: */
        -:  906:jerry_value_t
    #####:  907:jerry_native_module_create (jerry_native_module_evaluate_callback_t callback, /**< evaluation callback for
        -:  908:                                                                               *   native modules */
        -:  909:                            const jerry_value_t * const exports_p, /**< list of the exported bindings of the module,
        -:  910:                                                                    *   must be valid string identifiers */
        -:  911:                            size_t number_of_exports) /**< number of exports in the exports_p list */
        -:  912:{
        -:  913:  jerry_assert_api_available ();
        -:  914:
        -:  915:#if JERRY_MODULE_SYSTEM
    #####:  916:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
    #####:  917:  ecma_object_t *scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:  918:  ecma_module_names_t *local_exports_p = NULL;
        -:  919:
    #####:  920:  for (size_t i = 0; i < number_of_exports; i++)
        -:  921:  {
    #####:  922:    if (!ecma_is_value_string (exports_p[i]))
        -:  923:    {
    #####:  924:      ecma_deref_object (scope_p);
    #####:  925:      ecma_module_release_module_names (local_exports_p);
    #####:  926:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be string values")));
        -:  927:    }
        -:  928:
    #####:  929:    ecma_string_t *name_str_p = ecma_get_string_from_value (exports_p[i]);
        -:  930:
    #####:  931:    bool valid_identifier = false;
        -:  932:
    #####:  933:    ECMA_STRING_TO_UTF8_STRING (name_str_p, name_start_p, name_size);
        -:  934:
    #####:  935:    if (name_size > 0)
        -:  936:    {
    #####:  937:      const lit_utf8_byte_t *name_p = name_start_p;
    #####:  938:      const lit_utf8_byte_t *name_end_p = name_start_p + name_size;
    #####:  939:      lit_code_point_t code_point;
        -:  940:
    #####:  941:      lit_utf8_size_t size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  942:
    #####:  943:      if (lit_code_point_is_identifier_start (code_point))
        -:  944:      {
    #####:  945:        name_p += size;
        -:  946:
    #####:  947:        valid_identifier = true;
        -:  948:
    #####:  949:        while (name_p < name_end_p)
        -:  950:        {
    #####:  951:          size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  952:
    #####:  953:          if (!lit_code_point_is_identifier_part (code_point))
        -:  954:          {
    #####:  955:            valid_identifier = false;
    #####:  956:            break;
        -:  957:          }
        -:  958:
    #####:  959:          name_p += size;
        -:  960:        }
        -:  961:      }
        -:  962:    }
        -:  963:
    #####:  964:    ECMA_FINALIZE_UTF8_STRING (name_start_p, name_size);
        -:  965:
    #####:  966:    if (!valid_identifier)
        -:  967:    {
    #####:  968:      ecma_deref_object (scope_p);
    #####:  969:      ecma_module_release_module_names (local_exports_p);
    #####:  970:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be valid identifiers")));
        -:  971:    }
        -:  972:
    #####:  973:    if (ecma_find_named_property (scope_p, name_str_p) != NULL)
        -:  974:    {
    #####:  975:      continue;
        -:  976:    }
        -:  977:
    #####:  978:    ecma_create_named_data_property (scope_p, name_str_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -:  979:
        -:  980:    ecma_module_names_t *new_export_p;
    #####:  981:    new_export_p = (ecma_module_names_t *) jmem_heap_alloc_block (sizeof (ecma_module_names_t));
        -:  982:
    #####:  983:    new_export_p->next_p = local_exports_p;
    #####:  984:    local_exports_p = new_export_p;
        -:  985:
    #####:  986:    ecma_ref_ecma_string (name_str_p);
    #####:  987:    new_export_p->imex_name_p = name_str_p;
        -:  988:
    #####:  989:    ecma_ref_ecma_string (name_str_p);
    #####:  990:    new_export_p->local_name_p = name_str_p;
        -:  991:  }
        -:  992:
    #####:  993:  ecma_module_t *module_p = ecma_module_create ();
        -:  994:
    #####:  995:  module_p->header.u.cls.u2.module_flags |= ECMA_MODULE_IS_NATIVE;
    #####:  996:  module_p->scope_p = scope_p;
    #####:  997:  module_p->local_exports_p = local_exports_p;
    #####:  998:  module_p->u.callback = callback;
        -:  999:
    #####: 1000:  ecma_deref_object (scope_p);
        -: 1001:
    #####: 1002:  return ecma_make_object_value (&module_p->header.object);
        -: 1003:
        -: 1004:#else /* !JERRY_MODULE_SYSTEM */
        -: 1005:  JERRY_UNUSED (callback);
        -: 1006:  JERRY_UNUSED (exports_p);
        -: 1007:  JERRY_UNUSED (number_of_exports);
        -: 1008:
    #####: 1009:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1010:#endif /* JERRY_MODULE_SYSTEM */
        -: 1011:} /* jerry_native_module_create */
        -: 1012:
        -: 1013:/**
        -: 1014: * Gets the value of an export which belongs to a native module.
        -: 1015: *
        -: 1016: * Note:
        -: 1017: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1018: *
        -: 1019: * @return value of the export - if success
        -: 1020: *         error - otherwise
        -: 1021: */
        -: 1022:jerry_value_t
    #####: 1023:jerry_native_module_get_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1024:                                const jerry_value_t export_name_val) /**< string identifier of the export */
        -: 1025:{
        -: 1026:  jerry_assert_api_available ();
        -: 1027:
        -: 1028:#if JERRY_MODULE_SYSTEM
    #####: 1029:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1030:
    #####: 1031:  if (module_p == NULL)
        -: 1032:  {
    #####: 1033:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1034:  }
        -: 1035:
    #####: 1036:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1037:      || !ecma_is_value_string (export_name_val))
        -: 1038:  {
    #####: 1039:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1040:  }
        -: 1041:
    #####: 1042:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1043:                                                          ecma_get_string_from_value (export_name_val));
        -: 1044:
    #####: 1045:  if (property_p == NULL)
        -: 1046:  {
    #####: 1047:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1048:  }
        -: 1049:
    #####: 1050:  return ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 1051:#else /* !JERRY_MODULE_SYSTEM */
        -: 1052:  JERRY_UNUSED (native_module_val);
        -: 1053:  JERRY_UNUSED (export_name_val);
        -: 1054:
    #####: 1055:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1056:#endif /* JERRY_MODULE_SYSTEM */
        -: 1057:} /* jerry_native_module_get_export */
        -: 1058:
        -: 1059:/**
        -: 1060: * Sets the value of an export which belongs to a native module.
        -: 1061: *
        -: 1062: * Note:
        -: 1063: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1064: *
        -: 1065: * @return true value - if the operation was successful
        -: 1066: *         error - otherwise
        -: 1067: */
        -: 1068:jerry_value_t
    #####: 1069:jerry_native_module_set_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1070:                                const jerry_value_t export_name_val, /**< string identifier of the export */
        -: 1071:                                const jerry_value_t value_to_set) /**< new value of the export */
        -: 1072:{
        -: 1073:  jerry_assert_api_available ();
        -: 1074:
        -: 1075:#if JERRY_MODULE_SYSTEM
    #####: 1076:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1077:
    #####: 1078:  if (module_p == NULL)
        -: 1079:  {
    #####: 1080:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1081:  }
        -: 1082:
    #####: 1083:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1084:      || !ecma_is_value_string (export_name_val)
    #####: 1085:      || ecma_is_value_error_reference (value_to_set))
        -: 1086:  {
    #####: 1087:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1088:  }
        -: 1089:
    #####: 1090:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1091:                                                          ecma_get_string_from_value (export_name_val));
        -: 1092:
    #####: 1093:  if (property_p == NULL)
        -: 1094:  {
    #####: 1095:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1096:  }
        -: 1097:
    #####: 1098:  ecma_named_data_property_assign_value (module_p->scope_p,
    #####: 1099:                                         ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1100:                                         value_to_set);
    #####: 1101:  return ECMA_VALUE_TRUE;
        -: 1102:#else /* !JERRY_MODULE_SYSTEM */
        -: 1103:  JERRY_UNUSED (native_module_val);
        -: 1104:  JERRY_UNUSED (export_name_val);
        -: 1105:  JERRY_UNUSED (value_to_set);
        -: 1106:
    #####: 1107:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1108:#endif /* JERRY_MODULE_SYSTEM */
        -: 1109:} /* jerry_native_module_set_export */
        -: 1110:
        -: 1111:/**
        -: 1112: * Run enqueued Promise jobs until the first thrown error or until all get executed.
        -: 1113: *
        -: 1114: * Note:
        -: 1115: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1116: *
        -: 1117: * @return result of last executed job, may be error value.
        -: 1118: */
        -: 1119:jerry_value_t
    #####: 1120:jerry_run_all_enqueued_jobs (void)
        -: 1121:{
        -: 1122:  jerry_assert_api_available ();
        -: 1123:
        -: 1124:#if JERRY_ESNEXT
    #####: 1125:  return ecma_process_all_enqueued_jobs ();
        -: 1126:#else /* !JERRY_ESNEXT */
    #####: 1127:  return ECMA_VALUE_UNDEFINED;
        -: 1128:#endif /* JERRY_ESNEXT */
        -: 1129:} /* jerry_run_all_enqueued_jobs */
        -: 1130:
        -: 1131:/**
        -: 1132: * Get global object
        -: 1133: *
        -: 1134: * Note:
        -: 1135: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1136: *
        -: 1137: * @return api value of global object
        -: 1138: */
        -: 1139:jerry_value_t
        5: 1140:jerry_get_global_object (void)
        -: 1141:{
        -: 1142:  jerry_assert_api_available ();
        5: 1143:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        5: 1144:  ecma_ref_object (global_obj_p);
        5: 1145:  return ecma_make_object_value (global_obj_p);
        -: 1146:} /* jerry_get_global_object */
        -: 1147:
        -: 1148:/**
        -: 1149: * Check if the specified value is an abort value.
        -: 1150: *
        -: 1151: * @return true  - if both the error and abort values are set,
        -: 1152: *         false - otherwise
        -: 1153: */
        -: 1154:bool
    #####: 1155:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -: 1156:{
        -: 1157:  jerry_assert_api_available ();
        -: 1158:
    #####: 1159:  if (!ecma_is_value_error_reference (value))
        -: 1160:  {
    #####: 1161:    return false;
        -: 1162:  }
        -: 1163:
    #####: 1164:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1165:
    #####: 1166:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_ABORT) != 0;
        -: 1167:} /* jerry_value_is_abort */
        -: 1168:
        -: 1169:/**
        -: 1170: * Check if the specified value is an array object value.
        -: 1171: *
        -: 1172: * @return true  - if the specified value is an array object,
        -: 1173: *         false - otherwise
        -: 1174: */
        -: 1175:bool
    #####: 1176:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -: 1177:{
        -: 1178:  jerry_assert_api_available ();
        -: 1179:
    #####: 1180:  return (ecma_is_value_object (value)
    #####: 1181:          && ecma_get_object_base_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1182:} /* jerry_value_is_array */
        -: 1183:
        -: 1184:/**
        -: 1185: * Check if the specified value is boolean.
        -: 1186: *
        -: 1187: * @return true  - if the specified value is boolean,
        -: 1188: *         false - otherwise
        -: 1189: */
        -: 1190:bool
    #####: 1191:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -: 1192:{
        -: 1193:  jerry_assert_api_available ();
        -: 1194:
    #####: 1195:  return ecma_is_value_boolean (value);
        -: 1196:} /* jerry_value_is_boolean */
        -: 1197:
        -: 1198:/**
        -: 1199: * Check if the specified value is true.
        -: 1200: *
        -: 1201: * @return true  - if the specified value is true
        -: 1202: *         false - otherwise
        -: 1203: */
        -: 1204:bool
    #####: 1205:jerry_value_is_true (const jerry_value_t value) /**< api value */
        -: 1206:{
        -: 1207:  jerry_assert_api_available ();
        -: 1208:
    #####: 1209:  return ecma_is_value_true (value);
        -: 1210:} /* jerry_value_is_true */
        -: 1211:
        -: 1212:/**
        -: 1213: * Check if the specified value is false.
        -: 1214: *
        -: 1215: * @return true  - if the specified value is false
        -: 1216: *         false - otherwise
        -: 1217: */
        -: 1218:bool
    #####: 1219:jerry_value_is_false (const jerry_value_t value) /**< api value */
        -: 1220:{
        -: 1221:  jerry_assert_api_available ();
        -: 1222:
    #####: 1223:  return ecma_is_value_false (value);
        -: 1224:} /* jerry_value_is_false */
        -: 1225:
        -: 1226:/**
        -: 1227: * Check if the specified value is a constructor function object value.
        -: 1228: *
        -: 1229: * @return true - if the specified value is a function value that implements [[Construct]],
        -: 1230: *         false - otherwise
        -: 1231: */
        -: 1232:bool
    #####: 1233:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -: 1234:{
        -: 1235:  jerry_assert_api_available ();
        -: 1236:
    #####: 1237:  return ecma_is_constructor (value);
        -: 1238:} /* jerry_value_is_constructor */
        -: 1239:
        -: 1240:/**
        -: 1241: * Check if the specified value is an error or abort value.
        -: 1242: *
        -: 1243: * @return true  - if the specified value is an error value,
        -: 1244: *         false - otherwise
        -: 1245: */
        -: 1246:bool
       21: 1247:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -: 1248:{
        -: 1249:  jerry_assert_api_available ();
        -: 1250:
       21: 1251:  return ecma_is_value_error_reference (value);
        -: 1252:} /* jerry_value_is_error */
        -: 1253:
        -: 1254:/**
        -: 1255: * Check if the specified value is a function object value.
        -: 1256: *
        -: 1257: * @return true - if the specified value is callable,
        -: 1258: *         false - otherwise
        -: 1259: */
        -: 1260:bool
    #####: 1261:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -: 1262:{
        -: 1263:  jerry_assert_api_available ();
        -: 1264:
    #####: 1265:  return ecma_op_is_callable (value);
        -: 1266:} /* jerry_value_is_function */
        -: 1267:
        -: 1268:/**
        -: 1269: * Check if the specified value is an async function object value.
        -: 1270: *
        -: 1271: * @return true - if the specified value is an async function,
        -: 1272: *         false - otherwise
        -: 1273: */
        -: 1274:bool
    #####: 1275:jerry_value_is_async_function (const jerry_value_t value) /**< api value */
        -: 1276:{
        -: 1277:  jerry_assert_api_available ();
        -: 1278:
        -: 1279:#if JERRY_ESNEXT
    #####: 1280:  if (ecma_is_value_object (value))
        -: 1281:  {
    #####: 1282:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1283:
    #####: 1284:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1285:    {
        -: 1286:      const ecma_compiled_code_t *bytecode_data_p;
    #####: 1287:      bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);
    #####: 1288:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -: 1289:
    #####: 1290:      return (type == CBC_FUNCTION_ASYNC
    #####: 1291:              || type == CBC_FUNCTION_ASYNC_ARROW
    #####: 1292:              || type == CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1293:    }
        -: 1294:  }
        -: 1295:#else /* !JERRY_ESNEXT */
        -: 1296:  JERRY_UNUSED (value);
        -: 1297:#endif /* JERRY_ESNEXT */
        -: 1298:
    #####: 1299:  return false;
        -: 1300:} /* jerry_value_is_async_function */
        -: 1301:
        -: 1302:/**
        -: 1303: * Check if the specified value is number.
        -: 1304: *
        -: 1305: * @return true  - if the specified value is number,
        -: 1306: *         false - otherwise
        -: 1307: */
        -: 1308:bool
    #####: 1309:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -: 1310:{
        -: 1311:  jerry_assert_api_available ();
        -: 1312:
    #####: 1313:  return ecma_is_value_number (value);
        -: 1314:} /* jerry_value_is_number */
        -: 1315:
        -: 1316:/**
        -: 1317: * Check if the specified value is null.
        -: 1318: *
        -: 1319: * @return true  - if the specified value is null,
        -: 1320: *         false - otherwise
        -: 1321: */
        -: 1322:bool
    #####: 1323:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -: 1324:{
        -: 1325:  jerry_assert_api_available ();
        -: 1326:
    #####: 1327:  return ecma_is_value_null (value);
        -: 1328:} /* jerry_value_is_null */
        -: 1329:
        -: 1330:/**
        -: 1331: * Check if the specified value is object.
        -: 1332: *
        -: 1333: * @return true  - if the specified value is object,
        -: 1334: *         false - otherwise
        -: 1335: */
        -: 1336:bool
    #####: 1337:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -: 1338:{
        -: 1339:  jerry_assert_api_available ();
        -: 1340:
    #####: 1341:  return ecma_is_value_object (value);
        -: 1342:} /* jerry_value_is_object */
        -: 1343:
        -: 1344:/**
        -: 1345: * Check if the specified value is promise.
        -: 1346: *
        -: 1347: * @return true  - if the specified value is promise,
        -: 1348: *         false - otherwise
        -: 1349: */
        -: 1350:bool
    #####: 1351:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -: 1352:{
        -: 1353:  jerry_assert_api_available ();
        -: 1354:#if JERRY_ESNEXT
    #####: 1355:  return (ecma_is_value_object (value)
    #####: 1356:          && ecma_is_promise (ecma_get_object_from_value (value)));
        -: 1357:#else /* !JERRY_ESNEXT */
        -: 1358:  JERRY_UNUSED (value);
    #####: 1359:  return false;
        -: 1360:#endif /* JERRY_ESNEXT */
        -: 1361:} /* jerry_value_is_promise */
        -: 1362:
        -: 1363:/**
        -: 1364: * Check if the specified value is a proxy object.
        -: 1365: *
        -: 1366: * @return true  - if the specified value is a proxy object,
        -: 1367: *         false - otherwise
        -: 1368: */
        -: 1369:bool
    #####: 1370:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -: 1371:{
        -: 1372:  jerry_assert_api_available ();
        -: 1373:#if JERRY_BUILTIN_PROXY
    #####: 1374:  return (ecma_is_value_object (value)
    #####: 1375:          && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -: 1376:#else /* !JERRY_BUILTIN_PROXY */
        -: 1377:  JERRY_UNUSED (value);
    #####: 1378:  return false;
        -: 1379:#endif /* JERRY_BUILTIN_PROXY */
        -: 1380:} /* jerry_value_is_proxy */
        -: 1381:
        -: 1382:/**
        -: 1383: * Check if the specified value is string.
        -: 1384: *
        -: 1385: * @return true  - if the specified value is string,
        -: 1386: *         false - otherwise
        -: 1387: */
        -: 1388:bool
    #####: 1389:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -: 1390:{
        -: 1391:  jerry_assert_api_available ();
        -: 1392:
    #####: 1393:  return ecma_is_value_string (value);
        -: 1394:} /* jerry_value_is_string */
        -: 1395:
        -: 1396:/**
        -: 1397: * Check if the specified value is symbol.
        -: 1398: *
        -: 1399: * @return true  - if the specified value is symbol,
        -: 1400: *         false - otherwise
        -: 1401: */
        -: 1402:bool
       10: 1403:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -: 1404:{
        -: 1405:  jerry_assert_api_available ();
        -: 1406:
        -: 1407:#if JERRY_ESNEXT
       10: 1408:  return ecma_is_value_symbol (value);
        -: 1409:#else /* !JERRY_ESNEXT */
        -: 1410:  JERRY_UNUSED (value);
    #####: 1411:  return false;
        -: 1412:#endif /* JERRY_ESNEXT */
        -: 1413:} /* jerry_value_is_symbol */
        -: 1414:
        -: 1415:/**
        -: 1416: * Check if the specified value is BigInt.
        -: 1417: *
        -: 1418: * @return true  - if the specified value is BigInt,
        -: 1419: *         false - otherwise
        -: 1420: */
        -: 1421:bool
    #####: 1422:jerry_value_is_bigint (const jerry_value_t value) /**< api value */
        -: 1423:{
        -: 1424:  jerry_assert_api_available ();
        -: 1425:
        -: 1426:#if JERRY_BUILTIN_BIGINT
    #####: 1427:  return ecma_is_value_bigint (value);
        -: 1428:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1429:  JERRY_UNUSED (value);
    #####: 1430:  return false;
        -: 1431:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1432:} /* jerry_value_is_bigint */
        -: 1433:
        -: 1434:/**
        -: 1435: * Check if the specified value is undefined.
        -: 1436: *
        -: 1437: * @return true  - if the specified value is undefined,
        -: 1438: *         false - otherwise
        -: 1439: */
        -: 1440:bool
    #####: 1441:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -: 1442:{
        -: 1443:  jerry_assert_api_available ();
        -: 1444:
    #####: 1445:  return ecma_is_value_undefined (value);
        -: 1446:} /* jerry_value_is_undefined */
        -: 1447:
        -: 1448:/**
        -: 1449: * Perform the base type of the JavaScript value.
        -: 1450: *
        -: 1451: * @return jerry_type_t value
        -: 1452: */
        -: 1453:jerry_type_t
    #####: 1454:jerry_value_get_type (const jerry_value_t value) /**< input value to check */
        -: 1455:{
        -: 1456:  jerry_assert_api_available ();
        -: 1457:
    #####: 1458:  if (ecma_is_value_error_reference (value))
        -: 1459:  {
    #####: 1460:    return JERRY_TYPE_ERROR;
        -: 1461:  }
        -: 1462:
    #####: 1463:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -: 1464:
    #####: 1465:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -: 1466:
    #####: 1467:  switch (lit_id)
        -: 1468:  {
    #####: 1469:    case LIT_MAGIC_STRING_UNDEFINED:
        -: 1470:    {
    #####: 1471:      return JERRY_TYPE_UNDEFINED;
        -: 1472:    }
    #####: 1473:    case LIT_MAGIC_STRING_BOOLEAN:
        -: 1474:    {
    #####: 1475:      return JERRY_TYPE_BOOLEAN;
        -: 1476:    }
    #####: 1477:    case LIT_MAGIC_STRING_NUMBER:
        -: 1478:    {
    #####: 1479:      return JERRY_TYPE_NUMBER;
        -: 1480:    }
    #####: 1481:    case LIT_MAGIC_STRING_STRING:
        -: 1482:    {
    #####: 1483:      return JERRY_TYPE_STRING;
        -: 1484:    }
        -: 1485:#if JERRY_ESNEXT
    #####: 1486:    case LIT_MAGIC_STRING_SYMBOL:
        -: 1487:    {
    #####: 1488:      return JERRY_TYPE_SYMBOL;
        -: 1489:    }
        -: 1490:#endif /* JERRY_ESNEXT */
    #####: 1491:    case LIT_MAGIC_STRING_FUNCTION:
        -: 1492:    {
    #####: 1493:      return JERRY_TYPE_FUNCTION;
        -: 1494:    }
        -: 1495:#if JERRY_BUILTIN_BIGINT
    #####: 1496:    case LIT_MAGIC_STRING_BIGINT:
        -: 1497:    {
    #####: 1498:      return JERRY_TYPE_BIGINT;
        -: 1499:    }
        -: 1500:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 1501:    default:
        -: 1502:    {
    #####: 1503:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -: 1504:
        -: 1505:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -: 1506:       * Thus we'll do an extra check for 'null' here.
        -: 1507:       */
    #####: 1508:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -: 1509:    }
        -: 1510:  }
        -: 1511:} /* jerry_value_get_type */
        -: 1512:
        -: 1513:/**
        -: 1514: * Used by jerry_object_get_type to get the type of class objects
        -: 1515: */
        -: 1516:static const uint8_t jerry_class_object_type[] =
        -: 1517:{
        -: 1518:  /* These objects require custom property resolving. */
        -: 1519:  JERRY_OBJECT_TYPE_STRING, /**< type of ECMA_OBJECT_CLASS_STRING */
        -: 1520:  JERRY_OBJECT_TYPE_ARGUMENTS, /**< type of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 1521:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1522:  JERRY_OBJECT_TYPE_TYPEDARRAY, /**< type of ECMA_OBJECT_CLASS_TYPEDARRAY */
        -: 1523:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1524:#if JERRY_MODULE_SYSTEM
        -: 1525:  JERRY_OBJECT_TYPE_MODULE_NAMESPACE, /**< type of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 1526:#endif
        -: 1527:
        -: 1528:  /* These objects are marked by Garbage Collector. */
        -: 1529:#if JERRY_ESNEXT
        -: 1530:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_GENERATOR */
        -: 1531:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 1532:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 1533:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 1534:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 1535:#if JERRY_BUILTIN_REGEXP
        -: 1536:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 1537:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1538:#endif /* JERRY_ESNEXT */
        -: 1539:#if JERRY_MODULE_SYSTEM
        -: 1540:  JERRY_OBJECT_TYPE_MODULE, /**< type of ECMA_OBJECT_CLASS_MODULE */
        -: 1541:#endif
        -: 1542:#if JERRY_ESNEXT
        -: 1543:  JERRY_OBJECT_TYPE_PROMISE, /**< type of ECMA_OBJECT_CLASS_PROMISE */
        -: 1544:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 1545:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_ASYNC_FROM_SYNC_ITERATOR */
        -: 1546:#endif /* JERRY_ESNEXT */
        -: 1547:#if JERRY_BUILTIN_DATAVIEW
        -: 1548:  JERRY_OBJECT_TYPE_DATAVIEW, /**< type of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 1549:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1550:#if JERRY_BUILTIN_CONTAINER
        -: 1551:  JERRY_OBJECT_TYPE_CONTAINER, /**< type of ECMA_OBJECT_CLASS_CONTAINER */
        -: 1552:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1553:
        -: 1554:  /* Normal objects. */
        -: 1555:  JERRY_OBJECT_TYPE_BOOLEAN, /**< type of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 1556:  JERRY_OBJECT_TYPE_NUMBER, /**< type of ECMA_OBJECT_CLASS_NUMBER */
        -: 1557:  JERRY_OBJECT_TYPE_ERROR, /**< type of ECMA_OBJECT_CLASS_ERROR */
        -: 1558:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 1559:#if JERRY_PARSER
        -: 1560:  JERRY_OBJECT_TYPE_SCRIPT, /**< type of ECMA_OBJECT_CLASS_SCRIPT */
        -: 1561:#endif /* JERRY_PARSER */
        -: 1562:#if JERRY_BUILTIN_DATE
        -: 1563:  JERRY_OBJECT_TYPE_DATE, /**< type of ECMA_OBJECT_CLASS_DATE */
        -: 1564:#endif /* JERRY_BUILTIN_DATE */
        -: 1565:#if JERRY_BUILTIN_REGEXP
        -: 1566:  JERRY_OBJECT_TYPE_REGEXP, /**< type of ECMA_OBJECT_CLASS_REGEXP */
        -: 1567:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1568:#if JERRY_ESNEXT
        -: 1569:  JERRY_OBJECT_TYPE_SYMBOL, /**< type of ECMA_OBJECT_CLASS_SYMBOL */
        -: 1570:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 1571:#endif /* JERRY_ESNEXT */
        -: 1572:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1573:  JERRY_OBJECT_TYPE_ARRAYBUFFER, /**< type of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 1574:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1575:  JERRY_OBJECT_TYPE_SHARED_ARRAY_BUFFER, /**< type of ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER */
        -: 1576:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1577:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1578:#if JERRY_BUILTIN_BIGINT
        -: 1579:  JERRY_OBJECT_TYPE_BIGINT, /**< type of ECMA_OBJECT_CLASS_BIGINT */
        -: 1580:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1581:#if JERRY_BUILTIN_WEAKREF
        -: 1582:  JERRY_OBJECT_TYPE_WEAKREF, /**< type of ECMA_OBJECT_CLASS_WEAKREF */
        -: 1583:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1584:};
        -: 1585:
        -: 1586:JERRY_STATIC_ASSERT (sizeof (jerry_class_object_type) == ECMA_OBJECT_CLASS__MAX,
        -: 1587:                     jerry_class_object_type_must_have_object_class_max_elements);
        -: 1588:
        -: 1589:/**
        -: 1590: * Get the object type of the given value
        -: 1591: *
        -: 1592: * @return JERRY_OBJECT_TYPE_NONE - if the given value is not an object
        -: 1593: *         jerry_object_type_t value - otherwise
        -: 1594: */
        -: 1595:jerry_object_type_t
    #####: 1596:jerry_object_get_type (const jerry_value_t value) /**< input value to check */
        -: 1597:{
        -: 1598:  jerry_assert_api_available ();
        -: 1599:
    #####: 1600:  if (!ecma_is_value_object (value))
        -: 1601:  {
    #####: 1602:    return JERRY_OBJECT_TYPE_NONE;
        -: 1603:  }
        -: 1604:
    #####: 1605:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1606:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1607:
    #####: 1608:  switch (ecma_get_object_type (obj_p))
        -: 1609:  {
    #####: 1610:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1611:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1612:    {
    #####: 1613:      JERRY_ASSERT (ext_obj_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 1614:      return jerry_class_object_type[ext_obj_p->u.cls.type];
        -: 1615:    }
    #####: 1616:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1617:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1618:    {
    #####: 1619:      return JERRY_OBJECT_TYPE_ARRAY;
        -: 1620:    }
        -: 1621:#if JERRY_ESNEXT
    #####: 1622:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1623:    {
    #####: 1624:      return JERRY_OBJECT_TYPE_PROXY;
        -: 1625:    }
        -: 1626:#endif /* JERRY_ESNEXT */
    #####: 1627:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1628:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1629:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1630:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1631:    {
    #####: 1632:      return JERRY_OBJECT_TYPE_FUNCTION;
        -: 1633:    }
    #####: 1634:    default:
        -: 1635:    {
    #####: 1636:      break;
        -: 1637:    }
        -: 1638:  }
        -: 1639:
    #####: 1640:  return JERRY_OBJECT_TYPE_GENERIC;
        -: 1641:} /* jerry_object_get_type */
        -: 1642:
        -: 1643:/**
        -: 1644: * Get the function type of the given value
        -: 1645: *
        -: 1646: * @return JERRY_FUNCTION_TYPE_NONE - if the given value is not a function object
        -: 1647: *         jerry_function_type_t value - otherwise
        -: 1648: */
        -: 1649:jerry_function_type_t
    #####: 1650:jerry_function_get_type (const jerry_value_t value) /**< input value to check */
        -: 1651:{
        -: 1652:  jerry_assert_api_available ();
        -: 1653:
    #####: 1654:  if (ecma_is_value_object (value))
        -: 1655:  {
    #####: 1656:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1657:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1658:
    #####: 1659:    switch (ecma_get_object_type (obj_p))
        -: 1660:    {
    #####: 1661:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1662:      {
    #####: 1663:        return JERRY_FUNCTION_TYPE_BOUND;
        -: 1664:      }
    #####: 1665:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1666:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1667:      {
    #####: 1668:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1669:      }
    #####: 1670:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1671:      {
    #####: 1672:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_obj_p);
        -: 1673:
    #####: 1674:        switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))
        -: 1675:        {
        -: 1676:#if JERRY_ESNEXT
    #####: 1677:          case CBC_FUNCTION_ARROW:
        -: 1678:          case CBC_FUNCTION_ASYNC_ARROW:
        -: 1679:          {
    #####: 1680:            return JERRY_FUNCTION_TYPE_ARROW;
        -: 1681:          }
    #####: 1682:          case CBC_FUNCTION_GENERATOR:
        -: 1683:          case CBC_FUNCTION_ASYNC_GENERATOR:
        -: 1684:          {
    #####: 1685:            return JERRY_FUNCTION_TYPE_GENERATOR;
        -: 1686:          }
        -: 1687:#endif /* JERRY_ESNEXT */
    #####: 1688:          case CBC_FUNCTION_ACCESSOR:
        -: 1689:          {
    #####: 1690:            return JERRY_FUNCTION_TYPE_ACCESSOR;
        -: 1691:          }
    #####: 1692:          default:
        -: 1693:          {
    #####: 1694:            break;
        -: 1695:          }
        -: 1696:        }
    #####: 1697:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1698:      }
    #####: 1699:      default:
        -: 1700:      {
    #####: 1701:        break;
        -: 1702:      }
        -: 1703:    }
    #####: 1704:  }
        -: 1705:
    #####: 1706:  return JERRY_FUNCTION_TYPE_NONE;
        -: 1707:} /* jerry_function_get_type */
        -: 1708:
        -: 1709:/**
        -: 1710: * Get the itearator type of the given value
        -: 1711: *
        -: 1712: * @return JERRY_ITERATOR_TYPE_NONE - if the given value is not an iterator object
        -: 1713: *         jerry_iterator_type_t value - otherwise
        -: 1714: */
        -: 1715:jerry_iterator_type_t
    #####: 1716:jerry_iterator_get_type (const jerry_value_t value) /**< input value to check */
        -: 1717:{
        -: 1718:  jerry_assert_api_available ();
        -: 1719:
        -: 1720:#if JERRY_ESNEXT
    #####: 1721:  if (ecma_is_value_object (value))
        -: 1722:  {
    #####: 1723:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1724:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1725:
    #####: 1726:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 1727:    {
    #####: 1728:      switch (ext_obj_p->u.cls.type)
        -: 1729:      {
    #####: 1730:        case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1731:        {
    #####: 1732:          return JERRY_ITERATOR_TYPE_ARRAY;
        -: 1733:        }
        -: 1734:#if JERRY_BUILTIN_CONTAINER
    #####: 1735:        case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1736:        {
    #####: 1737:          return JERRY_ITERATOR_TYPE_SET;
        -: 1738:        }
    #####: 1739:        case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1740:        {
    #####: 1741:          return JERRY_ITERATOR_TYPE_MAP;
        -: 1742:        }
        -: 1743:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1744:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1745:        {
    #####: 1746:          return JERRY_ITERATOR_TYPE_STRING;
        -: 1747:        }
    #####: 1748:        default:
        -: 1749:        {
    #####: 1750:          break;
        -: 1751:        }
        -: 1752:      }
    #####: 1753:    }
        -: 1754:  }
        -: 1755:#else /* !JERRY_ESNEXT */
        -: 1756:  JERRY_UNUSED (value);
        -: 1757:#endif /* JERRY_ESNEXT */
        -: 1758:
    #####: 1759:  return JERRY_ITERATOR_TYPE_NONE;
        -: 1760:} /* jerry_iterator_get_type */
        -: 1761:
        -: 1762:/**
        -: 1763: * Check if the specified feature is enabled.
        -: 1764: *
        -: 1765: * @return true  - if the specified feature is enabled,
        -: 1766: *         false - otherwise
        -: 1767: */
        -: 1768:bool
    #####: 1769:jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -: 1770:{
    #####: 1771:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -: 1772:
        -: 1773:  return (false
        -: 1774:#if JERRY_CPOINTER_32_BIT
        -: 1775:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -: 1776:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1777:#if JERRY_ERROR_MESSAGES
    #####: 1778:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -: 1779:#endif /* JERRY_ERROR_MESSAGES */
        -: 1780:#if JERRY_PARSER
    #####: 1781:          || feature == JERRY_FEATURE_JS_PARSER
        -: 1782:#endif /* JERRY_PARSER */
        -: 1783:#if JERRY_MEM_STATS
    #####: 1784:          || feature == JERRY_FEATURE_MEM_STATS
        -: 1785:#endif /* JERRY_MEM_STATS */
        -: 1786:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1787:          || feature == JERRY_FEATURE_PARSER_DUMP
        -: 1788:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1789:#if JERRY_REGEXP_DUMP_BYTE_CODE
        -: 1790:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -: 1791:#endif /* JERRY_REGEXP_DUMP_BYTE_CODE */
        -: 1792:#if JERRY_SNAPSHOT_SAVE
    #####: 1793:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -: 1794:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1795:#if JERRY_SNAPSHOT_EXEC
    #####: 1796:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -: 1797:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1798:#if JERRY_DEBUGGER
        -: 1799:          || feature == JERRY_FEATURE_DEBUGGER
        -: 1800:#endif /* JERRY_DEBUGGER */
        -: 1801:#if JERRY_VM_EXEC_STOP
    #####: 1802:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -: 1803:#endif /* JERRY_VM_EXEC_STOP */
        -: 1804:#if JERRY_VM_THROW
        -: 1805:          || feature == JERRY_FEATURE_VM_THROW
        -: 1806:#endif /* JERRY_VM_THROW */
        -: 1807:#if JERRY_BUILTIN_JSON
    #####: 1808:          || feature == JERRY_FEATURE_JSON
        -: 1809:#endif /* JERRY_BUILTIN_JSON */
        -: 1810:#if JERRY_ESNEXT
    #####: 1811:          || feature == JERRY_FEATURE_PROMISE
    #####: 1812:          || feature == JERRY_FEATURE_SYMBOL
        -: 1813:#endif /* JERRY_ESNEXT */
        -: 1814:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1815:          || feature == JERRY_FEATURE_TYPEDARRAY
        -: 1816:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1817:#if JERRY_BUILTIN_DATAVIEW
    #####: 1818:          || feature == JERRY_FEATURE_DATAVIEW
        -: 1819:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1820:#if JERRY_BUILTIN_PROXY
    #####: 1821:          || feature == JERRY_FEATURE_PROXY
        -: 1822:#endif /* JERRY_BUILTIN_PROXY */
        -: 1823:#if JERRY_BUILTIN_DATE
    #####: 1824:          || feature == JERRY_FEATURE_DATE
        -: 1825:#endif /* JERRY_BUILTIN_DATE */
        -: 1826:#if JERRY_BUILTIN_REGEXP
    #####: 1827:          || feature == JERRY_FEATURE_REGEXP
        -: 1828:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1829:#if JERRY_LINE_INFO
    #####: 1830:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1831:#endif /* JERRY_LINE_INFO */
        -: 1832:#if JERRY_LOGGING
    #####: 1833:          || feature == JERRY_FEATURE_LOGGING
        -: 1834:#endif /* JERRY_LOGGING */
        -: 1835:#if JERRY_BUILTIN_GLOBAL_THIS
    #####: 1836:          || feature == JERRY_FEATURE_GLOBAL_THIS
        -: 1837:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        -: 1838:#if JERRY_BUILTIN_CONTAINER
    #####: 1839:          || feature == JERRY_FEATURE_MAP
    #####: 1840:          || feature == JERRY_FEATURE_SET
    #####: 1841:          || feature == JERRY_FEATURE_WEAKMAP
    #####: 1842:          || feature == JERRY_FEATURE_WEAKSET
        -: 1843:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1844:#if JERRY_BUILTIN_WEAKREF
    #####: 1845:          || feature == JERRY_FEATURE_WEAKREF
        -: 1846:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1847:#if JERRY_BUILTIN_BIGINT
    #####: 1848:          || feature == JERRY_FEATURE_BIGINT
        -: 1849:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1850:#if JERRY_BUILTIN_REALMS
    #####: 1851:          || feature == JERRY_FEATURE_REALM
        -: 1852:#endif /* JERRY_BUILTIN_REALMS */
        -: 1853:#if JERRY_PROMISE_CALLBACK
    #####: 1854:          || feature == JERRY_FEATURE_PROMISE_CALLBACK
        -: 1855:#endif /* JERRY_PROMISE_CALLBACK */
        -: 1856:#if JERRY_MODULE_SYSTEM
    #####: 1857:          || feature == JERRY_FEATURE_MODULE
        -: 1858:#endif /* JERRY_MODULE_SYSTEM */
        -: 1859:#if JERRY_FUNCTION_TO_STRING
    #####: 1860:          || feature == JERRY_FEATURE_FUNCTION_TO_STRING
        -: 1861:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1862:          );
        -: 1863:} /* jerry_is_feature_enabled */
        -: 1864:
        -: 1865:/**
        -: 1866: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1867: *
        -: 1868: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1869: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1870: */
        -: 1871:jerry_value_t
    #####: 1872:jerry_binary_operation (jerry_binary_operation_t op, /**< operation */
        -: 1873:                        const jerry_value_t lhs, /**< first operand */
        -: 1874:                        const jerry_value_t rhs) /**< second operand */
        -: 1875:{
        -: 1876:  jerry_assert_api_available ();
        -: 1877:
    #####: 1878:  if (ecma_is_value_error_reference (lhs) || ecma_is_value_error_reference (rhs))
        -: 1879:  {
    #####: 1880:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 1881:  }
        -: 1882:
    #####: 1883:  switch (op)
        -: 1884:  {
    #####: 1885:    case JERRY_BIN_OP_EQUAL:
        -: 1886:    {
    #####: 1887:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1888:    }
    #####: 1889:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1890:    {
    #####: 1891:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1892:    }
    #####: 1893:    case JERRY_BIN_OP_LESS:
        -: 1894:    {
    #####: 1895:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1896:    }
    #####: 1897:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1898:    {
    #####: 1899:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1900:    }
    #####: 1901:    case JERRY_BIN_OP_GREATER:
        -: 1902:    {
    #####: 1903:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1904:    }
    #####: 1905:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1906:    {
    #####: 1907:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1908:    }
    #####: 1909:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1910:    {
    #####: 1911:      if (!ecma_is_value_object (lhs)
    #####: 1912:          || !ecma_op_is_callable (rhs))
        -: 1913:      {
    #####: 1914:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1915:      }
        -: 1916:
    #####: 1917:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1918:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1919:    }
    #####: 1920:    case JERRY_BIN_OP_ADD:
        -: 1921:    {
    #####: 1922:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1923:    }
    #####: 1924:    case JERRY_BIN_OP_SUB:
        -: 1925:    case JERRY_BIN_OP_MUL:
        -: 1926:    case JERRY_BIN_OP_DIV:
        -: 1927:    case JERRY_BIN_OP_REM:
        -: 1928:    {
    #####: 1929:      return jerry_return (do_number_arithmetic (op - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1930:    }
    #####: 1931:    default:
        -: 1932:    {
    #####: 1933:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported binary operation")));
        -: 1934:    }
        -: 1935:  }
        -: 1936:} /* jerry_binary_operation */
        -: 1937:
        -: 1938:/**
        -: 1939: * Create abort from an api value.
        -: 1940: *
        -: 1941: * Create abort value from an api value. If the second argument is true
        -: 1942: * it will release the input api value.
        -: 1943: *
        -: 1944: * @return api abort value
        -: 1945: */
        -: 1946:jerry_value_t
    #####: 1947:jerry_create_abort_from_value (jerry_value_t value, /**< api value */
        -: 1948:                               bool release) /**< release api value */
        -: 1949:{
        -: 1950:  jerry_assert_api_available ();
        -: 1951:
    #####: 1952:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1953:  {
        -: 1954:    /* This is a rare case so it is optimized for
        -: 1955:     * binary size rather than performance. */
    #####: 1956:    if (jerry_value_is_abort (value))
        -: 1957:    {
    #####: 1958:      return release ? value : jerry_acquire_value (value);
        -: 1959:    }
        -: 1960:
    #####: 1961:    value = jerry_get_value_from_error (value, release);
    #####: 1962:    release = true;
        -: 1963:  }
        -: 1964:
    #####: 1965:  if (!release)
        -: 1966:  {
    #####: 1967:    value = ecma_copy_value (value);
        -: 1968:  }
        -: 1969:
    #####: 1970:  return ecma_create_error_reference (value, ECMA_ERROR_API_ABORT);
        -: 1971:} /* jerry_create_abort_from_value */
        -: 1972:
        -: 1973:/**
        -: 1974: * Create error from an api value.
        -: 1975: *
        -: 1976: * Create error value from an api value. If the second argument is true
        -: 1977: * it will release the input api value.
        -: 1978: *
        -: 1979: * @return api error value
        -: 1980: */
        -: 1981:jerry_value_t
    #####: 1982:jerry_create_error_from_value (jerry_value_t value, /**< api value */
        -: 1983:                               bool release) /**< release api value */
        -: 1984:{
        -: 1985:  jerry_assert_api_available ();
        -: 1986:
    #####: 1987:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1988:  {
        -: 1989:    /* This is a rare case so it is optimized for
        -: 1990:     * binary size rather than performance. */
    #####: 1991:    if (!jerry_value_is_abort (value))
        -: 1992:    {
    #####: 1993:      return release ? value : jerry_acquire_value (value);
        -: 1994:    }
        -: 1995:
    #####: 1996:    value = jerry_get_value_from_error (value, release);
    #####: 1997:    release = true;
        -: 1998:  }
        -: 1999:
    #####: 2000:  if (!release)
        -: 2001:  {
    #####: 2002:    value = ecma_copy_value (value);
        -: 2003:  }
        -: 2004:
    #####: 2005:  return ecma_create_error_reference (value, 0);
        -: 2006:} /* jerry_create_error_from_value */
        -: 2007:
        -: 2008:/**
        -: 2009: * Get the value from an error value.
        -: 2010: *
        -: 2011: * Extract the api value from an error. If the second argument is true
        -: 2012: * it will release the input error value.
        -: 2013: *
        -: 2014: * Note:
        -: 2015: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2016: *
        -: 2017: * @return jerry_value_t value
        -: 2018: */
        -: 2019:jerry_value_t
    #####: 2020:jerry_get_value_from_error (jerry_value_t value, /**< api value */
        -: 2021:                            bool release) /**< release api value */
        -: 2022:{
        -: 2023:  jerry_assert_api_available ();
        -: 2024:
    #####: 2025:  if (!ecma_is_value_error_reference (value))
        -: 2026:  {
    #####: 2027:    return release ? value : ecma_copy_value (value);
        -: 2028:  }
        -: 2029:
    #####: 2030:  jerry_value_t ret_val = jerry_acquire_value (ecma_get_extended_primitive_from_value (value)->u.value);
        -: 2031:
    #####: 2032:  if (release)
        -: 2033:  {
    #####: 2034:    jerry_release_value (value);
        -: 2035:  }
    #####: 2036:  return ret_val;
        -: 2037:} /* jerry_get_value_from_error */
        -: 2038:
        -: 2039:/**
        -: 2040: * Set new decorator callback for Error objects. The decorator can
        -: 2041: * create or update any properties of the newly created Error object.
        -: 2042: */
        -: 2043:void
    #####: 2044:jerry_set_error_object_created_callback (jerry_error_object_created_callback_t callback, /**< new callback */
        -: 2045:                                         void *user_p) /**< user pointer passed to the callback */
        -: 2046:{
        -: 2047:  jerry_assert_api_available ();
        -: 2048:
    #####: 2049:  JERRY_CONTEXT (error_object_created_callback_p) = callback;
    #####: 2050:  JERRY_CONTEXT (error_object_created_callback_user_p) = user_p;
    #####: 2051:} /* jerry_set_error_object_created_callback */
        -: 2052:
        -: 2053:/**
        -: 2054: * When JERRY_VM_THROW is enabled, the callback passed to this
        -: 2055: * function is called when an error is thrown in ECMAScript code.
        -: 2056: */
    #####: 2057:void jerry_set_vm_throw_callback (jerry_vm_throw_callback_t throw_cb, /**< callback which is called on throws */
        -: 2058:                                  void *user_p) /**< pointer passed to the function */
        -: 2059:{
        -: 2060:#if JERRY_VM_THROW
    #####: 2061:  JERRY_CONTEXT (vm_throw_callback_p) = throw_cb;
    #####: 2062:  JERRY_CONTEXT (vm_throw_callback_user_p) = user_p;
        -: 2063:#else /* !JERRY_VM_THROW */
        -: 2064:  JERRY_UNUSED (throw_cb);
        -: 2065:  JERRY_UNUSED (user_p);
        -: 2066:#endif /* JERRY_VM_THROW */
    #####: 2067:} /* jerry_set_vm_throw_callback */
        -: 2068:
        -: 2069:/**
        -: 2070: * Checks whether the callback set by jerry_set_vm_throw_callback captured the error
        -: 2071: *
        -: 2072: * @return true, if the vm throw callback captured the error
        -: 2073: *         false, otherwise
        -: 2074: */
        -: 2075:bool
    #####: 2076:jerry_error_is_throw_captured (jerry_value_t value) /**< api value */
        -: 2077:{
        -: 2078:  jerry_assert_api_available ();
        -: 2079:
        -: 2080:#if JERRY_VM_THROW
    #####: 2081:  if (!ecma_is_value_error_reference (value))
        -: 2082:  {
        -: 2083:    return false;
        -: 2084:  }
        -: 2085:
    #####: 2086:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2087:
    #####: 2088:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_THROW_CAPTURED) != 0;
        -: 2089:#else /* !JERRY_VM_THROW */
        -: 2090:  JERRY_UNUSED (value);
    #####: 2091:  return false;
        -: 2092:#endif /* JERRY_VM_THROW */
        -: 2093:} /* jerry_error_is_throw_captured */
        -: 2094:
        -: 2095:/**
        -: 2096: * Sets whether the callback set by jerry_set_vm_throw_callback should capture the error or not
        -: 2097: */
        -: 2098:void
    #####: 2099:jerry_error_set_throw_capture (jerry_value_t value, /**< api value */
        -: 2100:                               bool should_capture) /**< callback should capture this error */
        -: 2101:{
        -: 2102:  jerry_assert_api_available ();
        -: 2103:
        -: 2104:#if JERRY_VM_THROW
    #####: 2105:  if (!ecma_is_value_error_reference (value))
        -: 2106:  {
        -: 2107:    return;
        -: 2108:  }
        -: 2109:
    #####: 2110:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2111:
    #####: 2112:  if (should_capture)
        -: 2113:  {
    #####: 2114:    error_ref_p->refs_and_type &= ~(uint32_t) ECMA_ERROR_API_THROW_CAPTURED;
    #####: 2115:    return;
        -: 2116:  }
        -: 2117:
    #####: 2118:  error_ref_p->refs_and_type |= ECMA_ERROR_API_THROW_CAPTURED;
        -: 2119:#else /* !JERRY_VM_THROW */
        -: 2120:  JERRY_UNUSED (value);
        -: 2121:  JERRY_UNUSED (should_capture);
        -: 2122:#endif /* JERRY_VM_THROW */
    #####: 2123:} /* jerry_error_set_throw_capture */
        -: 2124:
        -: 2125:/**
        -: 2126: * Return the type of the Error object if possible.
        -: 2127: *
        -: 2128: * @return one of the jerry_error_t value as the type of the Error object
        -: 2129: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 2130: */
        -: 2131:jerry_error_t
    #####: 2132:jerry_get_error_type (jerry_value_t value) /**< api value */
        -: 2133:{
    #####: 2134:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2135:  {
    #####: 2136:    value = ecma_get_extended_primitive_from_value (value)->u.value;
        -: 2137:  }
        -: 2138:
    #####: 2139:  if (!ecma_is_value_object (value))
        -: 2140:  {
    #####: 2141:    return JERRY_ERROR_NONE;
        -: 2142:  }
        -: 2143:
    #####: 2144:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 2145:  jerry_error_t error_type = ecma_get_error_type (object_p);
        -: 2146:
    #####: 2147:  return (jerry_error_t) error_type;
        -: 2148:} /* jerry_get_error_type */
        -: 2149:
        -: 2150:/**
        -: 2151: * Get number from the specified value as a double.
        -: 2152: *
        -: 2153: * @return stored number as double
        -: 2154: */
        -: 2155:double
    #####: 2156:jerry_get_number_value (const jerry_value_t value) /**< api value */
        -: 2157:{
        -: 2158:  jerry_assert_api_available ();
        -: 2159:
    #####: 2160:  if (!ecma_is_value_number (value))
        -: 2161:  {
    #####: 2162:    return 0;
        -: 2163:  }
        -: 2164:
    #####: 2165:  return (double) ecma_get_number_from_value (value);
        -: 2166:} /* jerry_get_number_value */
        -: 2167:
        -: 2168:/**
        -: 2169: * Call ToBoolean operation on the api value.
        -: 2170: *
        -: 2171: * @return true  - if the logical value is true
        -: 2172: *         false - otherwise
        -: 2173: */
        -: 2174:bool
    #####: 2175:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 2176:{
        -: 2177:  jerry_assert_api_available ();
        -: 2178:
    #####: 2179:  if (ecma_is_value_error_reference (value))
        -: 2180:  {
    #####: 2181:    return false;
        -: 2182:  }
        -: 2183:
    #####: 2184:  return ecma_op_to_boolean (value);
        -: 2185:} /* jerry_value_to_boolean */
        -: 2186:
        -: 2187:/**
        -: 2188: * Call ToNumber operation on the api value.
        -: 2189: *
        -: 2190: * Note:
        -: 2191: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2192: *
        -: 2193: * @return converted number value - if success
        -: 2194: *         thrown error - otherwise
        -: 2195: */
        -: 2196:jerry_value_t
    #####: 2197:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 2198:{
        -: 2199:  jerry_assert_api_available ();
        -: 2200:
    #####: 2201:  if (ecma_is_value_error_reference (value))
        -: 2202:  {
    #####: 2203:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2204:  }
        -: 2205:
    #####: 2206:  ecma_number_t num;
    #####: 2207:  ecma_value_t ret_value = ecma_op_to_number (value, &num);
        -: 2208:
    #####: 2209:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2210:  {
    #####: 2211:    return ecma_create_error_reference_from_context ();
        -: 2212:  }
        -: 2213:
    #####: 2214:  return ecma_make_number_value (num);
        -: 2215:} /* jerry_value_to_number */
        -: 2216:
        -: 2217:/**
        -: 2218: * Call ToObject operation on the api value.
        -: 2219: *
        -: 2220: * Note:
        -: 2221: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2222: *
        -: 2223: * @return converted object value - if success
        -: 2224: *         thrown error - otherwise
        -: 2225: */
        -: 2226:jerry_value_t
    #####: 2227:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 2228:{
        -: 2229:  jerry_assert_api_available ();
        -: 2230:
    #####: 2231:  if (ecma_is_value_error_reference (value))
        -: 2232:  {
    #####: 2233:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2234:  }
        -: 2235:
    #####: 2236:  return jerry_return (ecma_op_to_object (value));
        -: 2237:} /* jerry_value_to_object */
        -: 2238:
        -: 2239:/**
        -: 2240: * Call ToPrimitive operation on the api value.
        -: 2241: *
        -: 2242: * Note:
        -: 2243: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2244: *
        -: 2245: * @return converted primitive value - if success
        -: 2246: *         thrown error - otherwise
        -: 2247: */
        -: 2248:jerry_value_t
    #####: 2249:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 2250:{
        -: 2251:  jerry_assert_api_available ();
        -: 2252:
    #####: 2253:  if (ecma_is_value_error_reference (value))
        -: 2254:  {
    #####: 2255:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2256:  }
        -: 2257:
    #####: 2258:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 2259:} /* jerry_value_to_primitive */
        -: 2260:
        -: 2261:/**
        -: 2262: * Call the ToString ecma builtin operation on the api value.
        -: 2263: *
        -: 2264: * Note:
        -: 2265: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2266: *
        -: 2267: * @return converted string value - if success
        -: 2268: *         thrown error - otherwise
        -: 2269: */
        -: 2270:jerry_value_t
       10: 2271:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 2272:{
        -: 2273:
        -: 2274:  jerry_assert_api_available ();
        -: 2275:
       10: 2276:  if (ecma_is_value_error_reference (value))
        -: 2277:  {
    #####: 2278:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2279:  }
        -: 2280:
       10: 2281:  ecma_string_t *str_p = ecma_op_to_string (value);
       10: 2282:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 2283:  {
    #####: 2284:    return ecma_create_error_reference_from_context ();
        -: 2285:  }
        -: 2286:
       10: 2287:  return ecma_make_string_value (str_p);
        -: 2288:} /* jerry_value_to_string */
        -: 2289:
        -: 2290:/**
        -: 2291: * Call the BigInt constructor ecma builtin operation on the api value.
        -: 2292: *
        -: 2293: * Note:
        -: 2294: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2295: *
        -: 2296: * @return BigInt value - if success
        -: 2297: *         thrown error - otherwise
        -: 2298: */
        -: 2299:jerry_value_t
    #####: 2300:jerry_value_to_bigint (const jerry_value_t value) /**< input value */
        -: 2301:{
        -: 2302:  jerry_assert_api_available ();
        -: 2303:
        -: 2304:#if JERRY_BUILTIN_BIGINT
    #####: 2305:  if (ecma_is_value_error_reference (value))
        -: 2306:  {
    #####: 2307:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2308:  }
        -: 2309:
    #####: 2310:  return jerry_return (ecma_bigint_to_bigint (value, true));
        -: 2311:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2312:  JERRY_UNUSED (value);
    #####: 2313:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2314:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2315:} /* jerry_value_to_bigint */
        -: 2316:
        -: 2317:/**
        -: 2318: * Convert any number to integer number.
        -: 2319: *
        -: 2320: * Note:
        -: 2321: *      For non-number values 0 is returned.
        -: 2322: *
        -: 2323: * @return integer representation of the number.
        -: 2324: */
        -: 2325:double
    #####: 2326:jerry_value_as_integer (const jerry_value_t value) /**< input value */
        -: 2327:{
        -: 2328:  jerry_assert_api_available ();
        -: 2329:
    #####: 2330:  if (!ecma_is_value_number (value))
        -: 2331:  {
    #####: 2332:    return 0;
        -: 2333:  }
        -: 2334:
    #####: 2335:  double number = ecma_get_number_from_value (value);
        -: 2336:
    #####: 2337:  if (ecma_number_is_nan (number))
        -: 2338:  {
    #####: 2339:    return ECMA_NUMBER_ZERO;
        -: 2340:  }
        -: 2341:
    #####: 2342:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -: 2343:  {
    #####: 2344:    return number;
        -: 2345:  }
        -: 2346:
    #####: 2347:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -: 2348:
    #####: 2349:  return ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        -: 2350:} /* jerry_value_as_integer */
        -: 2351:
        -: 2352:/**
        -: 2353: * Convert any number to int32 number.
        -: 2354: *
        -: 2355: * Note:
        -: 2356: *      For non-number values 0 is returned.
        -: 2357: *
        -: 2358: * @return int32 representation of the number.
        -: 2359: */
        -: 2360:int32_t
    #####: 2361:jerry_value_as_int32 (const jerry_value_t value) /**< input value */
        -: 2362:{
        -: 2363:  jerry_assert_api_available ();
        -: 2364:
    #####: 2365:  if (!ecma_is_value_number (value))
        -: 2366:  {
    #####: 2367:    return 0;
        -: 2368:  }
        -: 2369:
    #####: 2370:  return ecma_number_to_int32 (ecma_get_number_from_value (value));
        -: 2371:} /* jerry_value_as_int32 */
        -: 2372:
        -: 2373:/**
        -: 2374: * Convert any number to uint32 number.
        -: 2375: *
        -: 2376: * Note:
        -: 2377: *      For non-number values 0 is returned.
        -: 2378: *
        -: 2379: * @return uint32 representation of the number.
        -: 2380: */
        -: 2381:uint32_t
    #####: 2382:jerry_value_as_uint32 (const jerry_value_t value) /**< input value */
        -: 2383:{
        -: 2384:  jerry_assert_api_available ();
        -: 2385:
    #####: 2386:  if (!ecma_is_value_number (value))
        -: 2387:  {
    #####: 2388:    return 0;
        -: 2389:  }
        -: 2390:
    #####: 2391:  return ecma_number_to_uint32 (ecma_get_number_from_value (value));
        -: 2392:} /* jerry_value_as_uint32 */
        -: 2393:
        -: 2394:/**
        -: 2395: * Acquire specified Jerry API value.
        -: 2396: *
        -: 2397: * Note:
        -: 2398: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2399: *
        -: 2400: * @return acquired api value
        -: 2401: */
        -: 2402:jerry_value_t
    #####: 2403:jerry_acquire_value (jerry_value_t value) /**< API value */
        -: 2404:{
        -: 2405:  jerry_assert_api_available ();
        -: 2406:
    #####: 2407:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2408:  {
    #####: 2409:    ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
    #####: 2410:    return value;
        -: 2411:  }
        -: 2412:
    #####: 2413:  return ecma_copy_value (value);
        -: 2414:} /* jerry_acquire_value */
        -: 2415:
        -: 2416:/**
        -: 2417: * Release specified Jerry API value
        -: 2418: */
        -: 2419:void
       31: 2420:jerry_release_value (jerry_value_t value) /**< API value */
        -: 2421:{
        -: 2422:  jerry_assert_api_available ();
        -: 2423:
       31: 2424:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2425:  {
    #####: 2426:    ecma_deref_error_reference (ecma_get_extended_primitive_from_value (value));
    #####: 2427:    return;
        -: 2428:  }
        -: 2429:
       31: 2430:  ecma_free_value (value);
        -: 2431:} /* jerry_release_value */
        -: 2432:
        -: 2433:/**
        -: 2434: * Create an array object value
        -: 2435: *
        -: 2436: * Note:
        -: 2437: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2438: *
        -: 2439: * @return value of the constructed array object
        -: 2440: */
        -: 2441:jerry_value_t
    #####: 2442:jerry_create_array (uint32_t size) /**< size of array */
        -: 2443:{
        -: 2444:  jerry_assert_api_available ();
        -: 2445:
    #####: 2446:  ecma_object_t *array_p = ecma_op_new_array_object (size);
    #####: 2447:  return ecma_make_object_value (array_p);
        -: 2448:} /* jerry_create_array */
        -: 2449:
        -: 2450:/**
        -: 2451: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 2452: *
        -: 2453: * @return value of the created boolean
        -: 2454: */
        -: 2455:jerry_value_t
    #####: 2456:jerry_create_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 2457:{
        -: 2458:  jerry_assert_api_available ();
        -: 2459:
    #####: 2460:  return jerry_return (ecma_make_boolean_value (value));
        -: 2461:} /* jerry_create_boolean */
        -: 2462:
        -: 2463:/**
        -: 2464: * Create an error object
        -: 2465: *
        -: 2466: * Note:
        -: 2467: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2468: *      - the error flag is set for the returned value
        -: 2469: *
        -: 2470: * @return value of the constructed error object
        -: 2471: */
        -: 2472:jerry_value_t
    #####: 2473:jerry_create_error (jerry_error_t error_type, /**< type of error */
        -: 2474:                    const jerry_char_t *message_p) /**< value of 'message' property
        -: 2475:                                                    *   of constructed error object */
        -: 2476:{
    #####: 2477:  return jerry_create_error_sz (error_type,
        -: 2478:                                (lit_utf8_byte_t *) message_p,
        -: 2479:                                lit_zt_utf8_string_size (message_p));
        -: 2480:} /* jerry_create_error */
        -: 2481:
        -: 2482:/**
        -: 2483: * Create an error object
        -: 2484: *
        -: 2485: * Note:
        -: 2486: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2487: *      - the error flag is set for the returned value
        -: 2488: *
        -: 2489: * @return value of the constructed error object
        -: 2490: */
        -: 2491:jerry_value_t
    #####: 2492:jerry_create_error_sz (jerry_error_t error_type, /**< type of error */
        -: 2493:                       const jerry_char_t *message_p, /**< value of 'message' property
        -: 2494:                                                       *   of constructed error object */
        -: 2495:                       jerry_size_t message_size) /**< size of the message in bytes */
        -: 2496:{
        -: 2497:  jerry_assert_api_available ();
        -: 2498:
    #####: 2499:  if (message_p == NULL || message_size == 0)
        -: 2500:  {
    #####: 2501:    return ecma_create_error_object_reference (ecma_new_standard_error ((jerry_error_t) error_type, NULL));
        -: 2502:  }
        -: 2503:  else
        -: 2504:  {
    #####: 2505:    ecma_string_t *message_string_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) message_p,
        -: 2506:                                                                      (lit_utf8_size_t) message_size);
        -: 2507:
    #####: 2508:    ecma_object_t *error_object_p = ecma_new_standard_error ((jerry_error_t) error_type,
        -: 2509:                                                             message_string_p);
        -: 2510:
    #####: 2511:    ecma_deref_ecma_string (message_string_p);
        -: 2512:
    #####: 2513:    return ecma_create_error_object_reference (error_object_p);
        -: 2514:  }
        -: 2515:} /* jerry_create_error_sz */
        -: 2516:
        -: 2517:/**
        -: 2518: * Create an external function object
        -: 2519: *
        -: 2520: * Note:
        -: 2521: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2522: *
        -: 2523: * @return value of the constructed function object
        -: 2524: */
        -: 2525:jerry_value_t
        5: 2526:jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler
        -: 2527:                                                                     *   for the function */
        -: 2528:{
        -: 2529:  jerry_assert_api_available ();
        -: 2530:
        5: 2531:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);
        5: 2532:  return ecma_make_object_value (func_obj_p);
        -: 2533:} /* jerry_create_external_function */
        -: 2534:
        -: 2535:/**
        -: 2536: * Creates a jerry_value_t representing a number value.
        -: 2537: *
        -: 2538: * Note:
        -: 2539: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2540: *
        -: 2541: * @return jerry_value_t created from the given double argument.
        -: 2542: */
        -: 2543:jerry_value_t
    #####: 2544:jerry_create_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 2545:{
        -: 2546:  jerry_assert_api_available ();
        -: 2547:
    #####: 2548:  return ecma_make_number_value ((ecma_number_t) value);
        -: 2549:} /* jerry_create_number */
        -: 2550:
        -: 2551:/**
        -: 2552: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 2553: *
        -: 2554: * Note:
        -: 2555: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2556: *
        -: 2557: * @return jerry_value_t representing an infinity value.
        -: 2558: */
        -: 2559:jerry_value_t
    #####: 2560:jerry_create_number_infinity (bool sign) /**< true for negative Infinity
        -: 2561:                                          *   false for positive Infinity */
        -: 2562:{
        -: 2563:  jerry_assert_api_available ();
        -: 2564:
    #####: 2565:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 2566:} /* jerry_create_number_infinity */
        -: 2567:
        -: 2568:/**
        -: 2569: * Creates a jerry_value_t representing a not-a-number value.
        -: 2570: *
        -: 2571: * Note:
        -: 2572: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2573: *
        -: 2574: * @return jerry_value_t representing a not-a-number value.
        -: 2575: */
        -: 2576:jerry_value_t
    #####: 2577:jerry_create_number_nan (void)
        -: 2578:{
        -: 2579:  jerry_assert_api_available ();
        -: 2580:
    #####: 2581:  return ecma_make_nan_value ();
        -: 2582:} /* jerry_create_number_nan */
        -: 2583:
        -: 2584:/**
        -: 2585: * Creates a jerry_value_t representing an undefined value.
        -: 2586: *
        -: 2587: * @return value of undefined
        -: 2588: */
        -: 2589:jerry_value_t
        5: 2590:jerry_create_undefined (void)
        -: 2591:{
        -: 2592:  jerry_assert_api_available ();
        -: 2593:
        5: 2594:  return ECMA_VALUE_UNDEFINED;
        -: 2595:} /* jerry_create_undefined */
        -: 2596:
        -: 2597:/**
        -: 2598: * Creates and returns a jerry_value_t with type null object.
        -: 2599: *
        -: 2600: * @return jerry_value_t representing null
        -: 2601: */
        -: 2602:jerry_value_t
    #####: 2603:jerry_create_null (void)
        -: 2604:{
        -: 2605:  jerry_assert_api_available ();
        -: 2606:
    #####: 2607:  return ECMA_VALUE_NULL;
        -: 2608:} /* jerry_create_null */
        -: 2609:
        -: 2610:/**
        -: 2611: * Create new JavaScript object, like with new Object().
        -: 2612: *
        -: 2613: * Note:
        -: 2614: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2615: *
        -: 2616: * @return value of the created object
        -: 2617: */
        -: 2618:jerry_value_t
    #####: 2619:jerry_create_object (void)
        -: 2620:{
        -: 2621:  jerry_assert_api_available ();
        -: 2622:
    #####: 2623:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 2624:} /* jerry_create_object */
        -: 2625:
        -: 2626:/**
        -: 2627: * Create an empty Promise object which can be resolve/reject later
        -: 2628: * by calling jerry_resolve_or_reject_promise.
        -: 2629: *
        -: 2630: * Note:
        -: 2631: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2632: *
        -: 2633: * @return value of the created object
        -: 2634: */
        -: 2635:jerry_value_t
    #####: 2636:jerry_create_promise (void)
        -: 2637:{
        -: 2638:  jerry_assert_api_available ();
        -: 2639:
        -: 2640:#if JERRY_ESNEXT
    #####: 2641:  ecma_value_t promise_value = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2642:
    #####: 2643:  return promise_value;
        -: 2644:#else /* !JERRY_ESNEXT */
    #####: 2645:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 2646:#endif /* JERRY_ESNEXT */
        -: 2647:} /* jerry_create_promise */
        -: 2648:
        -: 2649:/**
        -: 2650: * Create a new Proxy object with the given target and handler
        -: 2651: *
        -: 2652: * Note:
        -: 2653: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2654: *
        -: 2655: * @return value of the created Proxy object
        -: 2656: */
        -: 2657:jerry_value_t
    #####: 2658:jerry_create_proxy (const jerry_value_t target, /**< target argument */
        -: 2659:                    const jerry_value_t handler) /**< handler argument */
        -: 2660:{
        -: 2661:  jerry_assert_api_available ();
        -: 2662:
    #####: 2663:  if (ecma_is_value_error_reference (target)
    #####: 2664:      || ecma_is_value_error_reference (handler))
        -: 2665:  {
    #####: 2666:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2667:  }
        -: 2668:
        -: 2669:#if JERRY_BUILTIN_PROXY
    #####: 2670:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, 0);
    #####: 2671:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2672:#else /* !JERRY_BUILTIN_PROXY */
    #####: 2673:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2674:#endif /* JERRY_BUILTIN_PROXY */
        -: 2675:} /* jerry_create_proxy */
        -: 2676:
        -: 2677:#if JERRY_BUILTIN_PROXY
        -: 2678:
        -: 2679:JERRY_STATIC_ASSERT ((int) JERRY_PROXY_SKIP_RESULT_VALIDATION == (int) ECMA_PROXY_SKIP_RESULT_VALIDATION,
        -: 2680:                     jerry_and_ecma_proxy_skip_result_validation_must_be_equal);
        -: 2681:
        -: 2682:#endif /* JERRY_BUILTIN_PROXY */
        -: 2683:
        -: 2684:/**
        -: 2685: * Create a new Proxy object with the given target, handler, and special options
        -: 2686: *
        -: 2687: * Note:
        -: 2688: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2689: *
        -: 2690: * @return value of the created Proxy object
        -: 2691: */
        -: 2692:jerry_value_t
    #####: 2693:jerry_create_special_proxy (const jerry_value_t target, /**< target argument */
        -: 2694:                            const jerry_value_t handler, /**< handler argument */
        -: 2695:                            uint32_t options) /**< jerry_proxy_object_options_t option bits */
        -: 2696:{
        -: 2697:  jerry_assert_api_available ();
        -: 2698:
    #####: 2699:  if (ecma_is_value_error_reference (target)
    #####: 2700:      || ecma_is_value_error_reference (handler))
        -: 2701:  {
    #####: 2702:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2703:  }
        -: 2704:
        -: 2705:#if JERRY_BUILTIN_PROXY
    #####: 2706:  options &= JERRY_PROXY_SKIP_RESULT_VALIDATION;
        -: 2707:
    #####: 2708:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, options);
    #####: 2709:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2710:#else /* !JERRY_BUILTIN_PROXY */
        -: 2711:  JERRY_UNUSED (options);
    #####: 2712:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2713:#endif /* JERRY_BUILTIN_PROXY */
        -: 2714:} /* jerry_create_special_proxy */
        -: 2715:
        -: 2716:/**
        -: 2717: * Create string from a valid UTF-8 string
        -: 2718: *
        -: 2719: * Note:
        -: 2720: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2721: *
        -: 2722: * @return value of the created string
        -: 2723: */
        -: 2724:jerry_value_t
    #####: 2725:jerry_create_string_from_utf8 (const jerry_char_t *str_p) /**< pointer to string */
        -: 2726:{
    #####: 2727:  return jerry_create_string_sz_from_utf8 (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2728:} /* jerry_create_string_from_utf8 */
        -: 2729:
        -: 2730:/**
        -: 2731: * Create string from a valid UTF-8 string
        -: 2732: *
        -: 2733: * Note:
        -: 2734: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2735: *
        -: 2736: * @return value of the created string
        -: 2737: */
        -: 2738:jerry_value_t
    #####: 2739:jerry_create_string_sz_from_utf8 (const jerry_char_t *str_p, /**< pointer to string */
        -: 2740:                                  jerry_size_t str_size) /**< string size */
        -: 2741:{
        -: 2742:  jerry_assert_api_available ();
        -: 2743:
    #####: 2744:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2745:                                                                                 (lit_utf8_size_t) str_size);
        -: 2746:
    #####: 2747:  return ecma_make_string_value (ecma_str_p);
        -: 2748:} /* jerry_create_string_sz_from_utf8 */
        -: 2749:
        -: 2750:/**
        -: 2751: * Create string from a valid CESU-8 string
        -: 2752: *
        -: 2753: * Note:
        -: 2754: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2755: *
        -: 2756: * @return value of the created string
        -: 2757: */
        -: 2758:jerry_value_t
        5: 2759:jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */
        -: 2760:{
        5: 2761:  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2762:} /* jerry_create_string */
        -: 2763:
        -: 2764:/**
        -: 2765: * Create string from a valid CESU-8 string
        -: 2766: *
        -: 2767: * Note:
        -: 2768: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2769: *
        -: 2770: * @return value of the created string
        -: 2771: */
        -: 2772:jerry_value_t
        6: 2773:jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2774:                        jerry_size_t str_size) /**< string size */
        -: 2775:{
        -: 2776:  jerry_assert_api_available ();
        -: 2777:
        6: 2778:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,
        -: 2779:                                                              (lit_utf8_size_t) str_size);
        6: 2780:  return ecma_make_string_value (ecma_str_p);
        -: 2781:} /* jerry_create_string_sz */
        -: 2782:
        -: 2783:/**
        -: 2784: * Create external string from a valid CESU-8 string
        -: 2785: *
        -: 2786: * Note:
        -: 2787: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2788: *
        -: 2789: * @return value of the created external string
        -: 2790: */
        -: 2791:jerry_value_t
    #####: 2792:jerry_create_external_string (const jerry_char_t *str_p, /**< pointer to string */
        -: 2793:                              void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2794:{
    #####: 2795:  return jerry_create_external_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p), user_p);
        -: 2796:} /* jerry_create_external_string */
        -: 2797:
        -: 2798:/**
        -: 2799: * Create external string from a valid CESU-8 string
        -: 2800: *
        -: 2801: * Note:
        -: 2802: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2803: *
        -: 2804: * @return value of the created external string
        -: 2805: */
        -: 2806:jerry_value_t
    #####: 2807:jerry_create_external_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2808:                                 jerry_size_t str_size, /**< string size */
        -: 2809:                                 void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2810:{
        -: 2811:  jerry_assert_api_available ();
        -: 2812:
    #####: 2813:  ecma_string_t *ecma_str_p = ecma_new_ecma_external_string_from_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2814:                                                                        (lit_utf8_size_t) str_size,
        -: 2815:                                                                        user_p);
    #####: 2816:  return ecma_make_string_value (ecma_str_p);
        -: 2817:} /* jerry_create_external_string_sz */
        -: 2818:
        -: 2819:/**
        -: 2820: * Create symbol from an api value
        -: 2821: *
        -: 2822: * Note:
        -: 2823: *      The given argument is converted to string. This operation can throw an error.
        -: 2824: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2825: *
        -: 2826: * @return value of the created symbol, if success
        -: 2827: *         thrown error, otherwise
        -: 2828: */
        -: 2829:jerry_value_t
    #####: 2830:jerry_create_symbol (const jerry_value_t value) /**< api value */
        -: 2831:{
        -: 2832:  jerry_assert_api_available ();
        -: 2833:
    #####: 2834:  if (ecma_is_value_error_reference (value))
        -: 2835:  {
    #####: 2836:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2837:  }
        -: 2838:
        -: 2839:#if JERRY_ESNEXT
    #####: 2840:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 2841:#else /* !JERRY_ESNEXT */
    #####: 2842:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 2843:#endif /* JERRY_ESNEXT */
        -: 2844:} /* jerry_create_symbol */
        -: 2845:
        -: 2846:/**
        -: 2847: * Create BigInt from a sequence of uint64 digits
        -: 2848: *
        -: 2849: * @return value of the created bigint, if success
        -: 2850: *         thrown error, otherwise
        -: 2851: */
        -: 2852:jerry_value_t
    #####: 2853:jerry_create_bigint (const uint64_t *digits_p, /**< BigInt digits (lowest digit first) */
        -: 2854:                     uint32_t size, /**< number of BigInt digits */
        -: 2855:                     bool sign) /**< sign bit, true if the result should be negative */
        -: 2856:{
        -: 2857:  jerry_assert_api_available ();
        -: 2858:
        -: 2859:#if JERRY_BUILTIN_BIGINT
    #####: 2860:  return jerry_return (ecma_bigint_create_from_digits (digits_p, size, sign));
        -: 2861:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2862:  JERRY_UNUSED (digits_p);
        -: 2863:  JERRY_UNUSED (size);
        -: 2864:  JERRY_UNUSED (sign);
    #####: 2865:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2866:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2867:} /* jerry_create_bigint */
        -: 2868:
        -: 2869:/**
        -: 2870: * Calculates the size of the given pattern and creates a RegExp object.
        -: 2871: *
        -: 2872: * @return value of the constructed RegExp object.
        -: 2873: */
        -: 2874:jerry_value_t
    #####: 2875:jerry_create_regexp (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2876:                     uint16_t flags) /**< optional RegExp flags */
        -: 2877:{
    #####: 2878:  return jerry_create_regexp_sz (pattern_p, lit_zt_utf8_string_size (pattern_p), flags);
        -: 2879:} /* jerry_create_regexp */
        -: 2880:
        -: 2881:/**
        -: 2882: * Creates a RegExp object with the given pattern and flags.
        -: 2883: *
        -: 2884: * @return value of the constructed RegExp object.
        -: 2885: */
        -: 2886:jerry_value_t
    #####: 2887:jerry_create_regexp_sz (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2888:                        jerry_size_t pattern_size, /**< length of the pattern */
        -: 2889:                        uint16_t flags) /**< optional RegExp flags */
        -: 2890:{
        -: 2891:  jerry_assert_api_available ();
        -: 2892:
        -: 2893:#if JERRY_BUILTIN_REGEXP
    #####: 2894:  if (!lit_is_valid_utf8_string (pattern_p, pattern_size, true))
        -: 2895:  {
    #####: 2896:    return jerry_throw (ecma_raise_common_error (ECMA_ERR_MSG ("Input must be a valid utf8 string")));
        -: 2897:  }
        -: 2898:
    #####: 2899:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 2900:
    #####: 2901:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 2902:  {
    #####: 2903:    return ECMA_VALUE_ERROR;
        -: 2904:  }
        -: 2905:
    #####: 2906:  ecma_string_t *ecma_pattern = ecma_new_ecma_string_from_utf8 (pattern_p, pattern_size);
        -: 2907:
    #####: 2908:  jerry_value_t ret_val = ecma_op_create_regexp_with_flags (regexp_obj_p,
        -: 2909:                                                            ecma_make_string_value (ecma_pattern),
        -: 2910:                                                            flags);
    #####: 2911:  ecma_deref_ecma_string (ecma_pattern);
        -: 2912:
    #####: 2913:  return ret_val;
        -: 2914:
        -: 2915:#else /* !JERRY_BUILTIN_REGEXP */
        -: 2916:  JERRY_UNUSED (pattern_p);
        -: 2917:  JERRY_UNUSED (pattern_size);
        -: 2918:  JERRY_UNUSED (flags);
        -: 2919:
        -: 2920:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("RegExp is not supported")));
        -: 2921:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2922:} /* jerry_create_regexp_sz */
        -: 2923:
        -: 2924:/**
        -: 2925: * Creates a new realm (global object).
        -: 2926: *
        -: 2927: * @return new realm object
        -: 2928: */
        -: 2929:jerry_value_t
    #####: 2930:jerry_create_realm (void)
        -: 2931:{
        -: 2932:  jerry_assert_api_available ();
        -: 2933:
        -: 2934:#if JERRY_BUILTIN_REALMS
    #####: 2935:  ecma_global_object_t *global_object_p = ecma_builtin_create_global_object ();
    #####: 2936:  return ecma_make_object_value ((ecma_object_t *) global_object_p);
        -: 2937:#else /* !JERRY_BUILTIN_REALMS */
    #####: 2938:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Realms are disabled")));
        -: 2939:#endif /* JERRY_BUILTIN_REALMS */
        -: 2940:} /* jerry_create_realm */
        -: 2941:
        -: 2942:/**
        -: 2943: * Get length of an array object
        -: 2944: *
        -: 2945: * Note:
        -: 2946: *      Returns 0, if the value parameter is not an array object.
        -: 2947: *
        -: 2948: * @return length of the given array
        -: 2949: */
        -: 2950:uint32_t
    #####: 2951:jerry_get_array_length (const jerry_value_t value) /**< api value */
        -: 2952:{
        -: 2953:  jerry_assert_api_available ();
        -: 2954:
    #####: 2955:  if (!jerry_value_is_object (value))
        -: 2956:  {
    #####: 2957:    return 0;
        -: 2958:  }
        -: 2959:
    #####: 2960:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2961:
    #####: 2962:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -: 2963:  {
    #####: 2964:    return ecma_array_get_length (object_p);
        -: 2965:  }
        -: 2966:
    #####: 2967:  return 0;
        -: 2968:} /* jerry_get_array_length */
        -: 2969:
        -: 2970:/**
        -: 2971: * Get size of Jerry string
        -: 2972: *
        -: 2973: * Note:
        -: 2974: *      Returns 0, if the value parameter is not a string.
        -: 2975: *
        -: 2976: * @return number of bytes in the buffer needed to represent the string
        -: 2977: */
        -: 2978:jerry_size_t
    #####: 2979:jerry_get_string_size (const jerry_value_t value) /**< input string */
        -: 2980:{
        -: 2981:  jerry_assert_api_available ();
        -: 2982:
    #####: 2983:  if (!ecma_is_value_string (value))
        -: 2984:  {
    #####: 2985:    return 0;
        -: 2986:  }
        -: 2987:
    #####: 2988:  return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 2989:} /* jerry_get_string_size */
        -: 2990:
        -: 2991:/**
        -: 2992: * Get UTF-8 encoded string size from Jerry string
        -: 2993: *
        -: 2994: * Note:
        -: 2995: *      Returns 0, if the value parameter is not a string.
        -: 2996: *
        -: 2997: * @return number of bytes in the buffer needed to represent the UTF-8 encoded string
        -: 2998: */
        -: 2999:jerry_size_t
    #####: 3000:jerry_get_utf8_string_size (const jerry_value_t value) /**< input string */
        -: 3001:{
        -: 3002:  jerry_assert_api_available ();
        -: 3003:
    #####: 3004:  if (!ecma_is_value_string (value))
        -: 3005:  {
    #####: 3006:    return 0;
        -: 3007:  }
        -: 3008:
    #####: 3009:  return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 3010:} /* jerry_get_utf8_string_size */
        -: 3011:
        -: 3012:/**
        -: 3013: * Get length of Jerry string
        -: 3014: *
        -: 3015: * Note:
        -: 3016: *      Returns 0, if the value parameter is not a string.
        -: 3017: *
        -: 3018: * @return number of characters in the string
        -: 3019: */
        -: 3020:jerry_length_t
    #####: 3021:jerry_get_string_length (const jerry_value_t value) /**< input string */
        -: 3022:{
        -: 3023:  jerry_assert_api_available ();
        -: 3024:
    #####: 3025:  if (!ecma_is_value_string (value))
        -: 3026:  {
    #####: 3027:    return 0;
        -: 3028:  }
        -: 3029:
    #####: 3030:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 3031:} /* jerry_get_string_length */
        -: 3032:
        -: 3033:/**
        -: 3034: * Get UTF-8 string length from Jerry string
        -: 3035: *
        -: 3036: * Note:
        -: 3037: *      Returns 0, if the value parameter is not a string.
        -: 3038: *
        -: 3039: * @return number of characters in the string
        -: 3040: */
        -: 3041:jerry_length_t
       10: 3042:jerry_get_utf8_string_length (const jerry_value_t value) /**< input string */
        -: 3043:{
        -: 3044:  jerry_assert_api_available ();
        -: 3045:
       10: 3046:  if (!ecma_is_value_string (value))
        -: 3047:  {
    #####: 3048:    return 0;
        -: 3049:  }
        -: 3050:
       10: 3051:  return ecma_string_get_utf8_length (ecma_get_string_from_value (value));
        -: 3052:} /* jerry_get_utf8_string_length */
        -: 3053:
        -: 3054:/**
        -: 3055: * Copy the characters of a string into a specified buffer.
        -: 3056: *
        -: 3057: * Note:
        -: 3058: *      The '\0' character could occur in character buffer.
        -: 3059: *      Returns 0, if the value parameter is not a string or
        -: 3060: *      the buffer is not large enough for the whole string.
        -: 3061: *
        -: 3062: * Note:
        -: 3063: *      If the size of the string in jerry value is larger than the size of the
        -: 3064: *      target buffer, the copy will fail.
        -: 3065: *      To copy substring use jerry_substring_to_char_buffer() instead.
        -: 3066: *
        -: 3067: * @return number of bytes, actually copied to the buffer.
        -: 3068: */
        -: 3069:jerry_size_t
    #####: 3070:jerry_string_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3071:                             jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3072:                             jerry_size_t buffer_size) /**< size of output buffer */
        -: 3073:{
        -: 3074:  jerry_assert_api_available ();
        -: 3075:
    #####: 3076:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3077:  {
    #####: 3078:    return 0;
        -: 3079:  }
        -: 3080:
    #####: 3081:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3082:
    #####: 3083:  if (ecma_string_get_size (str_p) > buffer_size)
        -: 3084:  {
    #####: 3085:    return 0;
        -: 3086:  }
        -: 3087:
    #####: 3088:  return ecma_string_copy_to_cesu8_buffer (str_p,
        -: 3089:                                           (lit_utf8_byte_t *) buffer_p,
        -: 3090:                                           buffer_size);
        -: 3091:} /* jerry_string_to_char_buffer */
        -: 3092:
        -: 3093:/**
        -: 3094: * Copy the characters of an utf-8 encoded string into a specified buffer.
        -: 3095: *
        -: 3096: * Note:
        -: 3097: *      The '\0' character could occur anywhere in the returned string
        -: 3098: *      Returns 0, if the value parameter is not a string or the buffer
        -: 3099: *      is not large enough for the whole string.
        -: 3100: *
        -: 3101: * Note:
        -: 3102: *      If the size of the string in jerry value is larger than the size of the
        -: 3103: *      target buffer, the copy will fail.
        -: 3104: *      To copy a substring use jerry_substring_to_utf8_char_buffer() instead.
        -: 3105: *
        -: 3106: * @return number of bytes copied to the buffer.
        -: 3107: */
        -: 3108:jerry_size_t
    #####: 3109:jerry_string_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3110:                                  jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3111:                                  jerry_size_t buffer_size) /**< size of output buffer */
        -: 3112:{
        -: 3113:  jerry_assert_api_available ();
        -: 3114:
    #####: 3115:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3116:  {
    #####: 3117:    return 0;
        -: 3118:  }
        -: 3119:
    #####: 3120:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3121:
    #####: 3122:  if (ecma_string_get_utf8_size (str_p) > buffer_size)
        -: 3123:  {
    #####: 3124:    return 0;
        -: 3125:  }
        -: 3126:
    #####: 3127:  return ecma_string_copy_to_utf8_buffer (str_p,
        -: 3128:                                          (lit_utf8_byte_t *) buffer_p,
        -: 3129:                                          buffer_size);
        -: 3130:} /* jerry_string_to_utf8_char_buffer */
        -: 3131:
        -: 3132:/**
        -: 3133: * Copy the characters of an cesu-8 encoded substring into a specified buffer.
        -: 3134: *
        -: 3135: * Note:
        -: 3136: *      The '\0' character could occur anywhere in the returned string
        -: 3137: *      Returns 0, if the value parameter is not a string.
        -: 3138: *      It will extract the substring beetween the specified start position
        -: 3139: *      and the end position (or the end of the string, whichever comes first).
        -: 3140: *
        -: 3141: * @return number of bytes copied to the buffer.
        -: 3142: */
        -: 3143:jerry_size_t
    #####: 3144:jerry_substring_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3145:                                jerry_length_t start_pos, /**< position of the first character */
        -: 3146:                                jerry_length_t end_pos, /**< position of the last character */
        -: 3147:                                jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3148:                                jerry_size_t buffer_size) /**< size of output buffer */
        -: 3149:{
        -: 3150:  jerry_assert_api_available ();
        -: 3151:
    #####: 3152:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3153:  {
    #####: 3154:    return 0;
        -: 3155:  }
        -: 3156:
    #####: 3157:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3158:
    #####: 3159:  return ecma_substring_copy_to_cesu8_buffer (str_p,
        -: 3160:                                              start_pos,
        -: 3161:                                              end_pos,
        -: 3162:                                              (lit_utf8_byte_t *) buffer_p,
        -: 3163:                                              buffer_size);
        -: 3164:} /* jerry_substring_to_char_buffer */
        -: 3165:
        -: 3166:/**
        -: 3167: * Copy the characters of an utf-8 encoded substring into a specified buffer.
        -: 3168: *
        -: 3169: * Note:
        -: 3170: *      The '\0' character could occur anywhere in the returned string
        -: 3171: *      Returns 0, if the value parameter is not a string.
        -: 3172: *      It will extract the substring beetween the specified start position
        -: 3173: *      and the end position (or the end of the string, whichever comes first).
        -: 3174: *
        -: 3175: * @return number of bytes copied to the buffer.
        -: 3176: */
        -: 3177:jerry_size_t
       10: 3178:jerry_substring_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3179:                                     jerry_length_t start_pos, /**< position of the first character */
        -: 3180:                                     jerry_length_t end_pos, /**< position of the last character */
        -: 3181:                                     jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3182:                                     jerry_size_t buffer_size) /**< size of output buffer */
        -: 3183:{
        -: 3184:  jerry_assert_api_available ();
        -: 3185:
       10: 3186:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3187:  {
    #####: 3188:    return 0;
        -: 3189:  }
        -: 3190:
       10: 3191:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3192:
       10: 3193:  return ecma_substring_copy_to_utf8_buffer (str_p,
        -: 3194:                                             start_pos,
        -: 3195:                                             end_pos,
        -: 3196:                                             (lit_utf8_byte_t *) buffer_p,
        -: 3197:                                             buffer_size);
        -: 3198:} /* jerry_substring_to_utf8_char_buffer */
        -: 3199:
        -: 3200:/**
        -: 3201: * Sets the global callback which is called when an external string is freed.
        -: 3202: */
        -: 3203:void
    #####: 3204:jerry_string_set_external_free_callback (jerry_external_string_free_callback_t callback_p) /**< free callback */
        -: 3205:{
    #####: 3206:  JERRY_CONTEXT (external_string_free_callback_p) = callback_p;
    #####: 3207:} /* jerry_string_set_external_free_callback */
        -: 3208:
        -: 3209:/**
        -: 3210: * Returns the user pointer assigned to an external string.
        -: 3211: *
        -: 3212: * @return user pointer, if value is an external string
        -: 3213: *         NULL, otherwise
        -: 3214: */
        -: 3215:void *
    #####: 3216:jerry_string_get_external_user_pointer (const jerry_value_t value, /**< string value */
        -: 3217:                                        bool *is_external) /**< [out] true - if value is an external string,
        -: 3218:                                                            *         false - otherwise */
        -: 3219:{
    #####: 3220:  if (is_external != NULL)
        -: 3221:  {
    #####: 3222:    *is_external = false;
        -: 3223:  }
        -: 3224:
    #####: 3225:  if (!ecma_is_value_string (value))
        -: 3226:  {
    #####: 3227:    return NULL;
        -: 3228:  }
        -: 3229:
    #####: 3230:  ecma_string_t *string_p = ecma_get_string_from_value (value);
        -: 3231:
    #####: 3232:  if (ECMA_IS_DIRECT_STRING (string_p)
    #####: 3233:      || ECMA_STRING_GET_CONTAINER (string_p) != ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 3234:  {
    #####: 3235:    return NULL;
        -: 3236:  }
        -: 3237:
    #####: 3238:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 3239:
    #####: 3240:  if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -: 3241:  {
    #####: 3242:    return NULL;
        -: 3243:  }
        -: 3244:
    #####: 3245:  if (is_external != NULL)
        -: 3246:  {
    #####: 3247:    *is_external = true;
        -: 3248:  }
        -: 3249:
    #####: 3250:  return ((ecma_external_string_t *) string_p)->user_p;
        -: 3251:} /* jerry_string_get_external_user_pointer */
        -: 3252:
        -: 3253:/**
        -: 3254: * Checks whether the object or it's prototype objects have the given property.
        -: 3255: *
        -: 3256: * @return raised error - if the operation fail
        -: 3257: *         true/false API value  - depend on whether the property exists
        -: 3258: */
        -: 3259:jerry_value_t
    #####: 3260:jerry_has_property (const jerry_value_t obj_val, /**< object value */
        -: 3261:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3262:{
        -: 3263:  jerry_assert_api_available ();
        -: 3264:
    #####: 3265:  if (!ecma_is_value_object (obj_val)
    #####: 3266:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3267:  {
    #####: 3268:    return ECMA_VALUE_FALSE;
        -: 3269:  }
        -: 3270:
    #####: 3271:  return jerry_return (ecma_op_object_has_property (ecma_get_object_from_value (obj_val),
        -: 3272:                                                    ecma_get_prop_name_from_value (prop_name_val)));
        -: 3273:} /* jerry_has_property */
        -: 3274:
        -: 3275:/**
        -: 3276: * Checks whether the object has the given property.
        -: 3277: *
        -: 3278: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 3279: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 3280: */
        -: 3281:jerry_value_t
    #####: 3282:jerry_has_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3283:                        const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3284:{
        -: 3285:  jerry_assert_api_available ();
        -: 3286:
    #####: 3287:  if (!ecma_is_value_object (obj_val)
    #####: 3288:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3289:  {
    #####: 3290:    return ECMA_VALUE_FALSE;
        -: 3291:  }
        -: 3292:
    #####: 3293:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 3294:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3295:
        -: 3296:#if JERRY_BUILTIN_PROXY
    #####: 3297:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 3298:  {
    #####: 3299:    ecma_property_descriptor_t prop_desc;
        -: 3300:
    #####: 3301:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 3302:
    #####: 3303:    if (ecma_is_value_true (status))
        -: 3304:    {
    #####: 3305:      ecma_free_property_descriptor (&prop_desc);
        -: 3306:    }
        -: 3307:
    #####: 3308:    return jerry_return (status);
        -: 3309:  }
        -: 3310:#endif /* JERRY_BUILTIN_PROXY */
        -: 3311:
    #####: 3312:  return ecma_make_boolean_value (ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p));
        -: 3313:} /* jerry_has_own_property */
        -: 3314:
        -: 3315:/**
        -: 3316: * Checks whether the object has the given internal property.
        -: 3317: *
        -: 3318: * @return true  - if the internal property exists
        -: 3319: *         false - otherwise
        -: 3320: */
        -: 3321:bool
    #####: 3322:jerry_has_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3323:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3324:{
        -: 3325:  jerry_assert_api_available ();
        -: 3326:
    #####: 3327:  if (!ecma_is_value_object (obj_val)
    #####: 3328:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3329:  {
    #####: 3330:    return false;
        -: 3331:  }
        -: 3332:
    #####: 3333:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3334:
    #####: 3335:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3336:
    #####: 3337:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3338:  {
    #####: 3339:    return false;
        -: 3340:  }
        -: 3341:
    #####: 3342:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3343:
    #####: 3344:  if (property_p == NULL)
        -: 3345:  {
    #####: 3346:    return false;
        -: 3347:  }
        -: 3348:
    #####: 3349:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3350:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3351:
    #####: 3352:  return property_p != NULL;
        -: 3353:} /* jerry_has_internal_property */
        -: 3354:
        -: 3355:/**
        -: 3356: * Delete a property from an object.
        -: 3357: *
        -: 3358: * @return true  - if property was deleted successfully
        -: 3359: *         false - otherwise
        -: 3360: */
        -: 3361:bool
    #####: 3362:jerry_delete_property (const jerry_value_t obj_val, /**< object value */
        -: 3363:                       const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3364:{
        -: 3365:  jerry_assert_api_available ();
        -: 3366:
    #####: 3367:  if (!ecma_is_value_object (obj_val)
    #####: 3368:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3369:  {
    #####: 3370:    return false;
        -: 3371:  }
        -: 3372:
    #####: 3373:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3374:                                                  ecma_get_prop_name_from_value (prop_name_val),
        -: 3375:                                                  false);
        -: 3376:
        -: 3377:#if JERRY_BUILTIN_PROXY
    #####: 3378:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3379:  {
        -: 3380:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3381:    jcontext_release_exception ();
        -: 3382:  }
        -: 3383:#endif /* JERRY_BUILTIN_PROXY */
        -: 3384:
    #####: 3385:  return ecma_is_value_true (ret_value);
        -: 3386:} /* jerry_delete_property */
        -: 3387:
        -: 3388:/**
        -: 3389: * Delete indexed property from the specified object.
        -: 3390: *
        -: 3391: * @return true  - if property was deleted successfully
        -: 3392: *         false - otherwise
        -: 3393: */
        -: 3394:bool
    #####: 3395:jerry_delete_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3396:                                uint32_t index) /**< index to be written */
        -: 3397:{
        -: 3398:  jerry_assert_api_available ();
        -: 3399:
    #####: 3400:  if (!ecma_is_value_object (obj_val))
        -: 3401:  {
    #####: 3402:    return false;
        -: 3403:  }
        -: 3404:
    #####: 3405:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 3406:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3407:                                                  str_idx_p,
        -: 3408:                                                  false);
    #####: 3409:  ecma_deref_ecma_string (str_idx_p);
        -: 3410:
        -: 3411:#if JERRY_BUILTIN_PROXY
    #####: 3412:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3413:  {
        -: 3414:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3415:    jcontext_release_exception ();
        -: 3416:  }
        -: 3417:#endif /* JERRY_BUILTIN_PROXY */
        -: 3418:
    #####: 3419:  return ecma_is_value_true (ret_value);
        -: 3420:} /* jerry_delete_property_by_index */
        -: 3421:
        -: 3422:/**
        -: 3423: * Delete an internal property from an object.
        -: 3424: *
        -: 3425: * @return true  - if property was deleted successfully
        -: 3426: *         false - otherwise
        -: 3427: */
        -: 3428:bool
    #####: 3429:jerry_delete_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3430:                                const jerry_value_t prop_name_val) /**< property name value */
        -: 3431:{
        -: 3432:  jerry_assert_api_available ();
        -: 3433:
    #####: 3434:  if (!ecma_is_value_object (obj_val)
    #####: 3435:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3436:  {
    #####: 3437:    return false;
        -: 3438:  }
        -: 3439:
    #####: 3440:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3441:
    #####: 3442:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3443:
    #####: 3444:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3445:  {
    #####: 3446:    return true;
        -: 3447:  }
        -: 3448:
    #####: 3449:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3450:
    #####: 3451:  if (property_p == NULL)
        -: 3452:  {
    #####: 3453:    return true;
        -: 3454:  }
        -: 3455:
    #####: 3456:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3457:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3458:
    #####: 3459:  if (property_p == NULL)
        -: 3460:  {
    #####: 3461:    return true;
        -: 3462:  }
        -: 3463:
    #####: 3464:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 3465:
    #####: 3466:  return true;
        -: 3467:} /* jerry_delete_internal_property */
        -: 3468:
        -: 3469:/**
        -: 3470: * Get value of a property to the specified object with the given name.
        -: 3471: *
        -: 3472: * Note:
        -: 3473: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3474: *
        -: 3475: * @return value of the property - if success
        -: 3476: *         value marked with error flag - otherwise
        -: 3477: */
        -: 3478:jerry_value_t
    #####: 3479:jerry_get_property (const jerry_value_t obj_val, /**< object value */
        -: 3480:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3481:{
        -: 3482:  jerry_assert_api_available ();
        -: 3483:
    #####: 3484:  if (!ecma_is_value_object (obj_val)
    #####: 3485:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3486:  {
    #####: 3487:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3488:  }
        -: 3489:
    #####: 3490:  jerry_value_t ret_value = ecma_op_object_get (ecma_get_object_from_value (obj_val),
        -: 3491:                                                ecma_get_prop_name_from_value (prop_name_val));
    #####: 3492:  return jerry_return (ret_value);
        -: 3493:} /* jerry_get_property */
        -: 3494:
        -: 3495:/**
        -: 3496: * Get value by an index from the specified object.
        -: 3497: *
        -: 3498: * Note:
        -: 3499: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3500: *
        -: 3501: * @return value of the property specified by the index - if success
        -: 3502: *         value marked with error flag - otherwise
        -: 3503: */
        -: 3504:jerry_value_t
    #####: 3505:jerry_get_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3506:                             uint32_t index) /**< index to be written */
        -: 3507:{
        -: 3508:  jerry_assert_api_available ();
        -: 3509:
    #####: 3510:  if (!ecma_is_value_object (obj_val))
        -: 3511:  {
    #####: 3512:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3513:  }
        -: 3514:
    #####: 3515:  ecma_value_t ret_value = ecma_op_object_get_by_index (ecma_get_object_from_value (obj_val), index);
        -: 3516:
    #####: 3517:  return jerry_return (ret_value);
        -: 3518:} /* jerry_get_property_by_index */
        -: 3519:
        -: 3520:/**
        -: 3521: * Get the own property value of an object with the given name.
        -: 3522: *
        -: 3523: * Note:
        -: 3524: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3525: *
        -: 3526: * @return value of the property - if success
        -: 3527: *         value marked with error flag - otherwise
        -: 3528: */
        -: 3529:jerry_value_t
    #####: 3530:jerry_get_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3531:                        const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3532:                        const jerry_value_t receiver_val, /**< receiver object value */
        -: 3533:                        bool *found_p) /**< [out] true, if the property is found
        -: 3534:                                        *   or obj_val is a Proxy object, false otherwise */
        -: 3535:{
        -: 3536:  jerry_assert_api_available ();
        -: 3537:
    #####: 3538:  if (found_p != NULL)
        -: 3539:  {
    #####: 3540:    *found_p = false;
        -: 3541:  }
        -: 3542:
    #####: 3543:  if (!ecma_is_value_object (obj_val)
    #####: 3544:      || !ecma_is_value_prop_name (prop_name_val)
    #####: 3545:      || !ecma_is_value_object (receiver_val))
        -: 3546:  {
    #####: 3547:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3548:  }
        -: 3549:
    #####: 3550:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 3551:  ecma_string_t *property_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3552:
        -: 3553:#if JERRY_BUILTIN_PROXY
    #####: 3554:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 3555:  {
    #####: 3556:    if (found_p != NULL)
        -: 3557:    {
    #####: 3558:      *found_p = true;
        -: 3559:    }
        -: 3560:
    #####: 3561:    return jerry_return (ecma_proxy_object_get (object_p, property_name_p, receiver_val));
        -: 3562:  }
        -: 3563:#endif /* JERRY_BUILTIN_PROXY */
        -: 3564:
    #####: 3565:  ecma_value_t ret_value = ecma_op_object_find_own (receiver_val, object_p, property_name_p);
        -: 3566:
    #####: 3567:  if (ecma_is_value_found (ret_value))
        -: 3568:  {
    #####: 3569:    if (found_p != NULL)
        -: 3570:    {
    #####: 3571:      *found_p = true;
        -: 3572:    }
        -: 3573:
    #####: 3574:    return jerry_return (ret_value);
        -: 3575:  }
        -: 3576:
    #####: 3577:  return ECMA_VALUE_UNDEFINED;
        -: 3578:} /* jerry_get_own_property */
        -: 3579:
        -: 3580:/**
        -: 3581: * Get value of an internal property to the specified object with the given name.
        -: 3582: *
        -: 3583: * Note:
        -: 3584: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3585: *
        -: 3586: * @return value of the internal property - if the internal property exists
        -: 3587: *         undefined value - if the internal does not property exists
        -: 3588: *         value marked with error flag - otherwise
        -: 3589: */
        -: 3590:jerry_value_t
    #####: 3591:jerry_get_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3592:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3593:{
        -: 3594:  jerry_assert_api_available ();
        -: 3595:
    #####: 3596:  if (!ecma_is_value_object (obj_val)
    #####: 3597:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3598:  {
    #####: 3599:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3600:  }
        -: 3601:
    #####: 3602:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3603:
    #####: 3604:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3605:
    #####: 3606:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3607:  {
    #####: 3608:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3609:  }
        -: 3610:
    #####: 3611:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3612:
    #####: 3613:  if (property_p == NULL)
        -: 3614:  {
    #####: 3615:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3616:  }
        -: 3617:
    #####: 3618:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3619:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3620:
    #####: 3621:  if (property_p == NULL)
        -: 3622:  {
    #####: 3623:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3624:  }
        -: 3625:
    #####: 3626:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3627:} /* jerry_get_internal_property */
        -: 3628:
        -: 3629:/**
        -: 3630: * Set a property to the specified object with the given name.
        -: 3631: *
        -: 3632: * Note:
        -: 3633: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3634: *
        -: 3635: * @return true value - if the operation was successful
        -: 3636: *         value marked with error flag - otherwise
        -: 3637: */
        -: 3638:jerry_value_t
        5: 3639:jerry_set_property (const jerry_value_t obj_val, /**< object value */
        -: 3640:                    const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3641:                    const jerry_value_t value_to_set) /**< value to set */
        -: 3642:{
        -: 3643:  jerry_assert_api_available ();
        -: 3644:
        5: 3645:  if (ecma_is_value_error_reference (value_to_set)
        5: 3646:      || !ecma_is_value_object (obj_val)
        5: 3647:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3648:  {
    #####: 3649:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3650:  }
        -: 3651:
        5: 3652:  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),
        -: 3653:                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3654:                                           value_to_set,
        -: 3655:                                           true));
        -: 3656:} /* jerry_set_property */
        -: 3657:
        -: 3658:/**
        -: 3659: * Set indexed value in the specified object
        -: 3660: *
        -: 3661: * Note:
        -: 3662: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3663: *
        -: 3664: * @return true value - if the operation was successful
        -: 3665: *         value marked with error flag - otherwise
        -: 3666: */
        -: 3667:jerry_value_t
    #####: 3668:jerry_set_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3669:                             uint32_t index, /**< index to be written */
        -: 3670:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3671:{
        -: 3672:  jerry_assert_api_available ();
        -: 3673:
    #####: 3674:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3675:      || !ecma_is_value_object (obj_val))
        -: 3676:  {
    #####: 3677:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3678:  }
        -: 3679:
    #####: 3680:  ecma_value_t ret_value = ecma_op_object_put_by_index (ecma_get_object_from_value (obj_val),
        -: 3681:                                                        index,
        -: 3682:                                                        value_to_set,
        -: 3683:                                                        true);
        -: 3684:
    #####: 3685:  return jerry_return (ret_value);
        -: 3686:} /* jerry_set_property_by_index */
        -: 3687:
        -: 3688:/**
        -: 3689: * Set an internal property to the specified object with the given name.
        -: 3690: *
        -: 3691: * Note:
        -: 3692: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 3693: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3694: *
        -: 3695: * @return true value - if the operation was successful
        -: 3696: *         value marked with error flag - otherwise
        -: 3697: */
        -: 3698:bool
    #####: 3699:jerry_set_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3700:                             const jerry_value_t prop_name_val, /**< property name value */
        -: 3701:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3702:{
        -: 3703:  jerry_assert_api_available ();
        -: 3704:
    #####: 3705:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3706:      || !ecma_is_value_object (obj_val)
    #####: 3707:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3708:  {
    #####: 3709:    return false;
        -: 3710:  }
        -: 3711:
    #####: 3712:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3713:
    #####: 3714:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3715:
    #####: 3716:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3717:  {
    #####: 3718:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3719:  }
        -: 3720:
    #####: 3721:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3722:  ecma_object_t *internal_object_p;
        -: 3723:
    #####: 3724:  if (property_p == NULL)
        -: 3725:  {
    #####: 3726:    ecma_property_value_t *value_p = ecma_create_named_data_property (obj_p,
        -: 3727:                                                                      internal_string_p,
        -: 3728:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3729:                                                                      NULL);
        -: 3730:
    #####: 3731:    internal_object_p = ecma_create_object (NULL,
        -: 3732:                                            sizeof (ecma_extended_object_t),
        -: 3733:                                            ECMA_OBJECT_TYPE_CLASS);
        -: 3734:    {
    #####: 3735:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 3736:      container_p->u.cls.type = ECMA_OBJECT_CLASS_INTERNAL_OBJECT;
        -: 3737:    }
        -: 3738:
    #####: 3739:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 3740:    ecma_deref_object (internal_object_p);
        -: 3741:  }
        -: 3742:  else
        -: 3743:  {
    #####: 3744:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 3745:  }
        -: 3746:
    #####: 3747:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
    #####: 3748:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 3749:
    #####: 3750:  if (property_p == NULL)
        -: 3751:  {
    #####: 3752:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 3753:                                                                      prop_name_p,
        -: 3754:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3755:                                                                      NULL);
        -: 3756:
    #####: 3757:    value_p->value = ecma_copy_value_if_not_object (value_to_set);
        -: 3758:  }
        -: 3759:  else
        -: 3760:  {
    #####: 3761:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value_to_set);
        -: 3762:  }
        -: 3763:
    #####: 3764:  return true;
        -: 3765:} /* jerry_set_internal_property */
        -: 3766:
        -: 3767:/**
        -: 3768: * Construct empty property descriptor, i.e.:
        -: 3769: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 3770: *
        -: 3771: * @return empty property descriptor
        -: 3772: */
        -: 3773:jerry_property_descriptor_t
    #####: 3774:jerry_property_descriptor_create (void)
        -: 3775:{
        -: 3776:  jerry_property_descriptor_t prop_desc;
        -: 3777:
    #####: 3778:  prop_desc.flags = JERRY_PROP_NO_OPTS;
    #####: 3779:  prop_desc.value = ECMA_VALUE_UNDEFINED;
    #####: 3780:  prop_desc.getter = ECMA_VALUE_UNDEFINED;
    #####: 3781:  prop_desc.setter = ECMA_VALUE_UNDEFINED;
        -: 3782:
    #####: 3783:  return prop_desc;
        -: 3784:} /* jerry_property_descriptor_create */
        -: 3785:
        -: 3786:/**
        -: 3787: * Convert a ecma_property_descriptor_t to a jerry_property_descriptor_t
        -: 3788: *
        -: 3789: * if error occurs the property descriptor's value field is filled with ECMA_VALUE_ERROR
        -: 3790: *
        -: 3791: * @return jerry_property_descriptor_t
        -: 3792: */
        -: 3793:static jerry_property_descriptor_t
    #####: 3794:jerry_property_descriptor_from_ecma (const ecma_property_descriptor_t *prop_desc_p) /**<[out] property_descriptor */
        -: 3795:{
    #####: 3796:  jerry_property_descriptor_t prop_desc = jerry_property_descriptor_create ();
        -: 3797:
    #####: 3798:  prop_desc.flags = prop_desc_p->flags;
        -: 3799:
    #####: 3800:  if (prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED))
        -: 3801:  {
    #####: 3802:    prop_desc.value = prop_desc_p->value;
        -: 3803:  }
        -: 3804:
    #####: 3805:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3806:  {
    #####: 3807:    prop_desc.getter = ECMA_VALUE_NULL;
        -: 3808:
    #####: 3809:    if (prop_desc_p->get_p != NULL)
        -: 3810:    {
    #####: 3811:      prop_desc.getter = ecma_make_object_value (prop_desc_p->get_p);
    #####: 3812:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.getter));
        -: 3813:    }
        -: 3814:  }
        -: 3815:
    #####: 3816:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3817:  {
    #####: 3818:    prop_desc.setter = ECMA_VALUE_NULL;
        -: 3819:
    #####: 3820:    if (prop_desc_p->set_p != NULL)
        -: 3821:    {
    #####: 3822:      prop_desc.setter = ecma_make_object_value (prop_desc_p->set_p);
    #####: 3823:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.setter));
        -: 3824:    }
        -: 3825:  }
        -: 3826:
    #####: 3827:  return prop_desc;
        -: 3828:} /* jerry_property_descriptor_from_ecma */
        -: 3829:
        -: 3830:/**
        -: 3831: * Convert a jerry_property_descriptor_t to a ecma_property_descriptor_t
        -: 3832: *
        -: 3833: * Note:
        -: 3834: *     if error occurs the property descriptor's value field
        -: 3835: *     is set to ECMA_VALUE_ERROR, but no error is thrown
        -: 3836: *
        -: 3837: * @return ecma_property_descriptor_t
        -: 3838: */
        -: 3839:static ecma_property_descriptor_t
    #####: 3840:jerry_property_descriptor_to_ecma (const jerry_property_descriptor_t *prop_desc_p) /**< input property_descriptor */
        -: 3841:{
    #####: 3842:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 3843:
    #####: 3844:  prop_desc.flags = prop_desc_p->flags;
        -: 3845:
        -: 3846:  /* Copy data property info. */
    #####: 3847:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3848:  {
    #####: 3849:    if (ecma_is_value_error_reference (prop_desc_p->value)
    #####: 3850:        || (prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -: 3851:    {
    #####: 3852:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3853:      return prop_desc;
        -: 3854:    }
        -: 3855:
    #####: 3856:    prop_desc.value = prop_desc_p->value;
        -: 3857:  }
        -: 3858:
        -: 3859:  /* Copy accessor property info. */
    #####: 3860:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3861:  {
    #####: 3862:    ecma_value_t getter = prop_desc_p->getter;
        -: 3863:
    #####: 3864:    if (ecma_is_value_error_reference (getter))
        -: 3865:    {
    #####: 3866:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3867:      return prop_desc;
        -: 3868:    }
        -: 3869:
    #####: 3870:    if (ecma_op_is_callable (getter))
        -: 3871:    {
    #####: 3872:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 3873:    }
    #####: 3874:    else if (!ecma_is_value_null (getter))
        -: 3875:    {
    #####: 3876:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3877:      return prop_desc;
        -: 3878:    }
        -: 3879:  }
        -: 3880:
    #####: 3881:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3882:  {
    #####: 3883:    ecma_value_t setter = prop_desc_p->setter;
        -: 3884:
    #####: 3885:    if (ecma_is_value_error_reference (setter))
        -: 3886:    {
    #####: 3887:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3888:      return prop_desc;
        -: 3889:    }
        -: 3890:
    #####: 3891:    if (ecma_op_is_callable (setter))
        -: 3892:    {
    #####: 3893:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 3894:    }
    #####: 3895:    else if (!ecma_is_value_null (setter))
        -: 3896:    {
    #####: 3897:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3898:      return prop_desc;
        -: 3899:    }
        -: 3900:  }
        -: 3901:
    #####: 3902:  const uint16_t configurable_mask = JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED;
    #####: 3903:  const uint16_t enumerable_mask = JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_ENUMERABLE_DEFINED;
    #####: 3904:  const uint16_t writable_mask = JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED;
        -: 3905:
    #####: 3906:  if ((prop_desc_p->flags & configurable_mask) == JERRY_PROP_IS_CONFIGURABLE
    #####: 3907:      || (prop_desc_p->flags & enumerable_mask) == JERRY_PROP_IS_ENUMERABLE
    #####: 3908:      || (prop_desc_p->flags & writable_mask) == JERRY_PROP_IS_WRITABLE)
        -: 3909:  {
    #####: 3910:    prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3911:    return prop_desc;
        -: 3912:  }
        -: 3913:
    #####: 3914:  prop_desc.flags |= (uint16_t) (prop_desc_p->flags | JERRY_PROP_SHOULD_THROW);
        -: 3915:
    #####: 3916:  return prop_desc;
        -: 3917:} /* jerry_property_descriptor_to_ecma */
        -: 3918:
        -: 3919:/** Helper function to return false value or error depending on the given flag.
        -: 3920: *
        -: 3921: * @return value marked with error flag - if is_throw is true
        -: 3922: *         false value - otherwise
        -: 3923: */
        -: 3924:static jerry_value_t
    #####: 3925:jerry_type_error_or_false (const char *msg_p, /**< message */
        -: 3926:                           uint16_t flags) /**< property descriptor flags */
        -: 3927:{
    #####: 3928:  if (!(flags & JERRY_PROP_SHOULD_THROW))
        -: 3929:  {
    #####: 3930:    return ECMA_VALUE_FALSE;
        -: 3931:  }
        -: 3932:
    #####: 3933:  return jerry_throw (ecma_raise_type_error (msg_p));
        -: 3934:} /* jerry_type_error_or_false */
        -: 3935:
        -: 3936:/**
        -: 3937: * Define a property to the specified object with the given name.
        -: 3938: *
        -: 3939: * Note:
        -: 3940: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3941: *
        -: 3942: * @return true value - if the operation was successful
        -: 3943: *         false value - if the property cannot be defined and JERRY_PROP_SHOULD_THROW is not set
        -: 3944: *         value marked with error flag - otherwise
        -: 3945: */
        -: 3946:jerry_value_t
    #####: 3947:jerry_define_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3948:                           const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3949:                           const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3950:{
        -: 3951:  jerry_assert_api_available ();
        -: 3952:
    #####: 3953:  if (!ecma_is_value_object (obj_val)
    #####: 3954:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3955:  {
    #####: 3956:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3957:  }
        -: 3958:
    #####: 3959:  if (prop_desc_p->flags & (JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_VALUE_DEFINED)
    #####: 3960:      && prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 3961:  {
    #####: 3962:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3963:  }
        -: 3964:
    #####: 3965:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (prop_desc_p);
        -: 3966:
    #####: 3967:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 3968:  {
    #####: 3969:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3970:  }
        -: 3971:
    #####: 3972:  return jerry_return (ecma_op_object_define_own_property (ecma_get_object_from_value (obj_val),
        -: 3973:                                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3974:                                                           &prop_desc));
        -: 3975:} /* jerry_define_own_property */
        -: 3976:
        -: 3977:/**
        -: 3978: * Construct property descriptor from specified property.
        -: 3979: *
        -: 3980: * @return true - if success, the prop_desc_p fields contains the property info
        -: 3981: *         false - otherwise, the prop_desc_p is unchanged
        -: 3982: */
        -: 3983:jerry_value_t
    #####: 3984:jerry_get_own_property_descriptor (const jerry_value_t  obj_val, /**< object value */
        -: 3985:                                   const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3986:                                   jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3987:{
        -: 3988:  jerry_assert_api_available ();
        -: 3989:
    #####: 3990:  if (!ecma_is_value_object (obj_val)
    #####: 3991:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3992:  {
    #####: 3993:    return ECMA_VALUE_FALSE;
        -: 3994:  }
        -: 3995:
    #####: 3996:  ecma_property_descriptor_t prop_desc;
        -: 3997:
    #####: 3998:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (obj_val),
        -: 3999:                                                                    ecma_get_prop_name_from_value (prop_name_val),
        -: 4000:                                                                    &prop_desc);
        -: 4001:
        -: 4002:#if JERRY_BUILTIN_PROXY
    #####: 4003:  if (ECMA_IS_VALUE_ERROR (status))
        -: 4004:  {
    #####: 4005:    return jerry_throw (status);
        -: 4006:  }
        -: 4007:#endif /* JERRY_BUILTIN_PROXY */
        -: 4008:
    #####: 4009:  if (!ecma_is_value_true (status))
        -: 4010:  {
    #####: 4011:    return ECMA_VALUE_FALSE;
        -: 4012:  }
        -: 4013:
        -: 4014:  /* The flags are always filled in the returned descriptor. */
    #####: 4015:  JERRY_ASSERT ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 4016:                && (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 4017:                && ((prop_desc.flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 4018:                    || !(prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED)));
        -: 4019:
    #####: 4020:  prop_desc_p->flags = prop_desc.flags;
    #####: 4021:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 4022:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 4023:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 4024:
    #####: 4025:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 4026:  {
    #####: 4027:    prop_desc_p->value = prop_desc.value;
        -: 4028:  }
        -: 4029:
    #####: 4030:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 4031:  {
    #####: 4032:    if (prop_desc.get_p != NULL)
        -: 4033:    {
    #####: 4034:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 4035:    }
        -: 4036:    else
        -: 4037:    {
    #####: 4038:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 4039:    }
        -: 4040:  }
        -: 4041:
    #####: 4042:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 4043:  {
    #####: 4044:    if (prop_desc.set_p != NULL)
        -: 4045:    {
    #####: 4046:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 4047:    }
        -: 4048:    else
        -: 4049:    {
    #####: 4050:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 4051:    }
        -: 4052:  }
        -: 4053:
    #####: 4054:  return ECMA_VALUE_TRUE;
        -: 4055:} /* jerry_get_own_property_descriptor */
        -: 4056:
        -: 4057:/**
        -: 4058: * Free fields of property descriptor (setter, getter and value).
        -: 4059: */
        -: 4060:void
    #####: 4061:jerry_property_descriptor_free (const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 4062:{
    #####: 4063:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 4064:  {
    #####: 4065:    jerry_release_value (prop_desc_p->value);
        -: 4066:  }
        -: 4067:
    #####: 4068:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 4069:  {
    #####: 4070:    jerry_release_value (prop_desc_p->getter);
        -: 4071:  }
        -: 4072:
    #####: 4073:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 4074:  {
    #####: 4075:    jerry_release_value (prop_desc_p->setter);
        -: 4076:  }
    #####: 4077:} /* jerry_property_descriptor_free */
        -: 4078:
        -: 4079:/**
        -: 4080: * Invoke function specified by a function value
        -: 4081: *
        -: 4082: * Note:
        -: 4083: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4084: *      - If function is invoked as constructor, it should support [[Construct]] method,
        -: 4085: *        otherwise, if function is simply called - it should support [[Call]] method.
        -: 4086: *
        -: 4087: * @return returned jerry value of the invoked function
        -: 4088: */
        -: 4089:static jerry_value_t
    #####: 4090:jerry_invoke_function (bool is_invoke_as_constructor, /**< true - invoke function as constructor
        -: 4091:                                                       *          (this_arg_p should be NULL, as it is ignored),
        -: 4092:                                                       *   false - perform function call */
        -: 4093:                       const jerry_value_t func_obj_val, /**< function object to call */
        -: 4094:                       const jerry_value_t this_val, /**< object value of 'this' binding */
        -: 4095:                       const jerry_value_t args_p[], /**< function's call arguments */
        -: 4096:                       const jerry_size_t args_count) /**< number of the arguments */
        -: 4097:{
    #####: 4098:  JERRY_ASSERT (args_count == 0 || args_p != NULL);
        -: 4099:
    #####: 4100:  if (ecma_is_value_error_reference (func_obj_val)
    #####: 4101:      || ecma_is_value_error_reference (this_val))
        -: 4102:  {
    #####: 4103:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4104:  }
        -: 4105:
    #####: 4106:  for (uint32_t i = 0; i < args_count; i++)
        -: 4107:  {
    #####: 4108:    if (ecma_is_value_error_reference (args_p[i]))
        -: 4109:    {
    #####: 4110:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4111:    }
        -: 4112:  }
        -: 4113:
    #####: 4114:  if (is_invoke_as_constructor)
        -: 4115:  {
    #####: 4116:    JERRY_ASSERT (jerry_value_is_constructor (func_obj_val));
        -: 4117:
    #####: 4118:    return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_obj_val),
        -: 4119:                                                     ecma_get_object_from_value (func_obj_val),
        -: 4120:                                                     args_p,
        -: 4121:                                                     args_count));
        -: 4122:  }
        -: 4123:  else
        -: 4124:  {
    #####: 4125:    JERRY_ASSERT (jerry_value_is_function (func_obj_val));
        -: 4126:
    #####: 4127:    return jerry_return (ecma_op_function_call (ecma_get_object_from_value (func_obj_val),
        -: 4128:                                                this_val,
        -: 4129:                                                args_p,
        -: 4130:                                                args_count));
        -: 4131:  }
        -: 4132:} /* jerry_invoke_function */
        -: 4133:
        -: 4134:/**
        -: 4135: * Call function specified by a function value
        -: 4136: *
        -: 4137: * Note:
        -: 4138: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4139: *      error flag must not be set for any arguments of this function.
        -: 4140: *
        -: 4141: * @return returned jerry value of the called function
        -: 4142: */
        -: 4143:jerry_value_t
    #####: 4144:jerry_call_function (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4145:                     const jerry_value_t this_val, /**< object for 'this' binding */
        -: 4146:                     const jerry_value_t args_p[], /**< function's call arguments */
        -: 4147:                     jerry_size_t args_count) /**< number of the arguments */
        -: 4148:{
        -: 4149:  jerry_assert_api_available ();
        -: 4150:
    #####: 4151:  if (jerry_value_is_function (func_obj_val) && !ecma_is_value_error_reference (this_val))
        -: 4152:  {
    #####: 4153:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4154:    {
    #####: 4155:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4156:      {
    #####: 4157:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4158:      }
        -: 4159:    }
        -: 4160:
    #####: 4161:    return jerry_invoke_function (false, func_obj_val, this_val, args_p, args_count);
        -: 4162:  }
        -: 4163:
    #####: 4164:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4165:} /* jerry_call_function */
        -: 4166:
        -: 4167:/**
        -: 4168: * Construct object value invoking specified function value as a constructor
        -: 4169: *
        -: 4170: * Note:
        -: 4171: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4172: *      error flag must not be set for any arguments of this function.
        -: 4173: *
        -: 4174: * @return returned jerry value of the invoked constructor
        -: 4175: */
        -: 4176:jerry_value_t
    #####: 4177:jerry_construct_object (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4178:                        const jerry_value_t args_p[], /**< function's call arguments
        -: 4179:                                                       *   (NULL if arguments number is zero) */
        -: 4180:                        jerry_size_t args_count) /**< number of the arguments */
        -: 4181:{
        -: 4182:  jerry_assert_api_available ();
        -: 4183:
    #####: 4184:  if (jerry_value_is_constructor (func_obj_val))
        -: 4185:  {
    #####: 4186:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4187:    {
    #####: 4188:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4189:      {
    #####: 4190:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4191:      }
        -: 4192:    }
        -: 4193:
    #####: 4194:    ecma_value_t this_val = ECMA_VALUE_UNDEFINED;
    #####: 4195:    return jerry_invoke_function (true, func_obj_val, this_val, args_p, args_count);
        -: 4196:  }
        -: 4197:
    #####: 4198:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4199:} /* jerry_construct_object */
        -: 4200:
        -: 4201:/**
        -: 4202: * Get keys of the specified object value
        -: 4203: *
        -: 4204: * Note:
        -: 4205: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4206: *
        -: 4207: * @return array object value - if success
        -: 4208: *         value marked with error flag - otherwise
        -: 4209: */
        -: 4210:jerry_value_t
    #####: 4211:jerry_get_object_keys (const jerry_value_t obj_val) /**< object value */
        -: 4212:{
        -: 4213:  jerry_assert_api_available ();
        -: 4214:
    #####: 4215:  if (!ecma_is_value_object (obj_val))
        -: 4216:  {
    #####: 4217:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4218:  }
        -: 4219:
    #####: 4220:  ecma_collection_t *prop_names = ecma_op_object_get_enumerable_property_names (ecma_get_object_from_value (obj_val),
        -: 4221:                                                                                ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 4222:
        -: 4223:#if JERRY_BUILTIN_PROXY
    #####: 4224:  if (JERRY_UNLIKELY (prop_names == NULL))
        -: 4225:  {
    #####: 4226:    return ECMA_VALUE_ERROR;
        -: 4227:  }
        -: 4228:#endif /* JERRY_BUILTIN_PROXY */
        -: 4229:
    #####: 4230:  return ecma_op_new_array_object_from_collection (prop_names, false);
        -: 4231:} /* jerry_get_object_keys */
        -: 4232:
        -: 4233:/**
        -: 4234: * Get the prototype of the specified object
        -: 4235: *
        -: 4236: * Note:
        -: 4237: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4238: *
        -: 4239: * @return prototype object or null value - if success
        -: 4240: *         value marked with error flag - otherwise
        -: 4241: */
        -: 4242:jerry_value_t
    #####: 4243:jerry_get_prototype (const jerry_value_t obj_val) /**< object value */
        -: 4244:{
        -: 4245:  jerry_assert_api_available ();
        -: 4246:
    #####: 4247:  if (!ecma_is_value_object (obj_val))
        -: 4248:  {
    #####: 4249:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4250:  }
        -: 4251:
    #####: 4252:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4253:
        -: 4254:#if JERRY_BUILTIN_PROXY
    #####: 4255:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4256:  {
    #####: 4257:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 4258:  }
        -: 4259:#endif /* JERRY_BUILTIN_PROXY */
        -: 4260:
    #####: 4261:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 4262:  {
    #####: 4263:    return ECMA_VALUE_NULL;
        -: 4264:  }
        -: 4265:
    #####: 4266:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 4267:  ecma_ref_object (proto_obj_p);
        -: 4268:
    #####: 4269:  return ecma_make_object_value (proto_obj_p);
        -: 4270:} /* jerry_get_prototype */
        -: 4271:
        -: 4272:/**
        -: 4273: * Set the prototype of the specified object
        -: 4274: *
        -: 4275: * @return true value - if success
        -: 4276: *         value marked with error flag - otherwise
        -: 4277: */
        -: 4278:jerry_value_t
    #####: 4279:jerry_set_prototype (const jerry_value_t obj_val, /**< object value */
        -: 4280:                     const jerry_value_t proto_obj_val) /**< prototype object value */
        -: 4281:{
        -: 4282:  jerry_assert_api_available ();
        -: 4283:
    #####: 4284:  if (!ecma_is_value_object (obj_val)
    #####: 4285:      || ecma_is_value_error_reference (proto_obj_val)
    #####: 4286:      || (!ecma_is_value_object (proto_obj_val) && !ecma_is_value_null (proto_obj_val)))
        -: 4287:  {
    #####: 4288:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4289:  }
    #####: 4290:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4291:
        -: 4292:#if JERRY_BUILTIN_PROXY
    #####: 4293:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4294:  {
    #####: 4295:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto_obj_val));
        -: 4296:  }
        -: 4297:#endif /* JERRY_BUILTIN_PROXY */
        -: 4298:
    #####: 4299:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto_obj_val);
        -: 4300:} /* jerry_set_prototype */
        -: 4301:
        -: 4302:/**
        -: 4303: * Utility to check if a given object can be used for the foreach api calls.
        -: 4304: *
        -: 4305: * Some objects/classes uses extra internal objects to correctly store data.
        -: 4306: * These extre object should never be exposed externally to the API user.
        -: 4307: *
        -: 4308: * @returns true - if the user can access the object in the callback.
        -: 4309: *          false - if the object is an internal object which should no be accessed by the user.
        -: 4310: */
        -: 4311:static
    #####: 4312:bool jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 4313:{
    #####: 4314:  if (ecma_is_lexical_environment (object_p))
        -: 4315:  {
    #####: 4316:    return false;
        -: 4317:  }
        -: 4318:
    #####: 4319:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 4320:
    #####: 4321:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 4322:  {
    #####: 4323:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 4324:    switch (ext_object_p->u.cls.type)
        -: 4325:    {
        -: 4326:      /* An object's internal property object should not be iterable by foreach. */
    #####: 4327:      case ECMA_OBJECT_CLASS_INTERNAL_OBJECT:
        -: 4328:      {
    #####: 4329:        return false;
        -: 4330:      }
        -: 4331:    }
        -: 4332:  }
        -: 4333:
    #####: 4334:  return true;
        -: 4335:} /* jerry_object_is_valid_foreach */
        -: 4336:
        -: 4337:/**
        -: 4338: * Traverse objects.
        -: 4339: *
        -: 4340: * @return true - traversal was interrupted by the callback.
        -: 4341: *         false - otherwise - traversal visited all objects.
        -: 4342: */
        -: 4343:bool
    #####: 4344:jerry_objects_foreach (jerry_objects_foreach_t foreach_p, /**< function pointer of the iterator function */
        -: 4345:                       void *user_data_p) /**< pointer to user data */
        -: 4346:{
        -: 4347:  jerry_assert_api_available ();
        -: 4348:
    #####: 4349:  JERRY_ASSERT (foreach_p != NULL);
        -: 4350:
    #####: 4351:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4352:
    #####: 4353:  while (iter_cp != JMEM_CP_NULL)
        -: 4354:  {
    #####: 4355:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4356:
    #####: 4357:    if (jerry_object_is_valid_foreach (iter_p)
    #####: 4358:        && !foreach_p (ecma_make_object_value (iter_p), user_data_p))
        -: 4359:    {
    #####: 4360:      return true;
        -: 4361:    }
        -: 4362:
    #####: 4363:    iter_cp = iter_p->gc_next_cp;
        -: 4364:  }
        -: 4365:
    #####: 4366:  return false;
        -: 4367:} /* jerry_objects_foreach */
        -: 4368:
        -: 4369:/**
        -: 4370: * Traverse objects having a given native type info.
        -: 4371: *
        -: 4372: * @return true - traversal was interrupted by the callback.
        -: 4373: *         false - otherwise - traversal visited all objects.
        -: 4374: */
        -: 4375:bool
    #####: 4376:jerry_objects_foreach_by_native_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 4377:                                                                                        *   of the native pointer */
        -: 4378:                                      jerry_objects_foreach_by_native_info_t foreach_p, /**< function to apply for
        -: 4379:                                                                                         *   each matching object */
        -: 4380:                                      void *user_data_p) /**< pointer to user data */
        -: 4381:{
        -: 4382:  jerry_assert_api_available ();
        -: 4383:
    #####: 4384:  JERRY_ASSERT (native_info_p != NULL);
    #####: 4385:  JERRY_ASSERT (foreach_p != NULL);
        -: 4386:
        -: 4387:  ecma_native_pointer_t *native_pointer_p;
        -: 4388:
    #####: 4389:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4390:
    #####: 4391:  while (iter_cp != JMEM_CP_NULL)
        -: 4392:  {
    #####: 4393:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4394:
    #####: 4395:    if (jerry_object_is_valid_foreach (iter_p))
        -: 4396:    {
    #####: 4397:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 4398:      if (native_pointer_p
    #####: 4399:          && !foreach_p (ecma_make_object_value (iter_p), native_pointer_p->native_p, user_data_p))
        -: 4400:      {
    #####: 4401:        return true;
        -: 4402:      }
        -: 4403:    }
        -: 4404:
    #####: 4405:    iter_cp = iter_p->gc_next_cp;
        -: 4406:  }
        -: 4407:
    #####: 4408:  return false;
        -: 4409:} /* jerry_objects_foreach_by_native_info */
        -: 4410:
        -: 4411:/**
        -: 4412: * Get native pointer and its type information, associated with the given native type info.
        -: 4413: *
        -: 4414: * Note:
        -: 4415: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 4416: *
        -: 4417: * @return true - if there is an associated pointer,
        -: 4418: *         false - otherwise
        -: 4419: */
        -: 4420:bool
    #####: 4421:jerry_get_object_native_pointer (const jerry_value_t obj_val, /**< object to get native pointer from */
        -: 4422:                                 void **out_native_pointer_p, /**< [out] native pointer */
        -: 4423:                                 const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 4424:                                                                                   *   of the native pointer */
        -: 4425:{
        -: 4426:  jerry_assert_api_available ();
        -: 4427:
    #####: 4428:  if (!ecma_is_value_object (obj_val))
        -: 4429:  {
    #####: 4430:    return false;
        -: 4431:  }
        -: 4432:
        -: 4433:  ecma_native_pointer_t *native_pointer_p;
    #####: 4434:  native_pointer_p = ecma_get_native_pointer_value (ecma_get_object_from_value (obj_val), (void *) native_info_p);
        -: 4435:
    #####: 4436:  if (native_pointer_p == NULL)
        -: 4437:  {
    #####: 4438:    return false;
        -: 4439:  }
        -: 4440:
    #####: 4441:  if (out_native_pointer_p != NULL)
        -: 4442:  {
    #####: 4443:    *out_native_pointer_p = native_pointer_p->native_p;
        -: 4444:  }
        -: 4445:
    #####: 4446:  return true;
        -: 4447:} /* jerry_get_object_native_pointer */
        -: 4448:
        -: 4449:/**
        -: 4450: * Set native pointer and an optional type info for the specified object.
        -: 4451: *
        -: 4452: *
        -: 4453: * Note:
        -: 4454: *      If native pointer was already set for the object, its value is updated.
        -: 4455: *
        -: 4456: * Note:
        -: 4457: *      If a non-NULL free callback is specified in the native type info,
        -: 4458: *      it will be called by the garbage collector when the object is freed.
        -: 4459: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 4460: *      The type info always overwrites the previous value, so passing
        -: 4461: *      a NULL value deletes the current type info.
        -: 4462: */
        -: 4463:void
    #####: 4464:jerry_set_object_native_pointer (const jerry_value_t obj_val, /**< object to set native pointer in */
        -: 4465:                                 void *native_pointer_p, /**< native pointer */
        -: 4466:                                 const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4467:{
        -: 4468:  jerry_assert_api_available ();
        -: 4469:
    #####: 4470:  if (ecma_is_value_object (obj_val))
        -: 4471:  {
    #####: 4472:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4473:
    #####: 4474:    ecma_create_native_pointer_property (object_p, native_pointer_p, native_info_p);
        -: 4475:  }
    #####: 4476:} /* jerry_set_object_native_pointer */
        -: 4477:
        -: 4478:/**
        -: 4479: * Delete the previously set native pointer by the native type info from the specified object.
        -: 4480: *
        -: 4481: * Note:
        -: 4482: *      If the specified object has no matching native pointer for the given native type info
        -: 4483: *      the function has no effect.
        -: 4484: *
        -: 4485: * Note:
        -: 4486: *      This operation cannot throw an exception.
        -: 4487: *
        -: 4488: * @return true - if the native pointer has been deleted succesfully
        -: 4489: *         false - otherwise
        -: 4490: */
        -: 4491:bool
    #####: 4492:jerry_delete_object_native_pointer (const jerry_value_t obj_val, /**< object to delete native pointer from */
        -: 4493:                                    const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4494:{
        -: 4495:  jerry_assert_api_available ();
        -: 4496:
    #####: 4497:  if (ecma_is_value_object (obj_val))
        -: 4498:  {
    #####: 4499:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4500:
    #####: 4501:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 4502:  }
        -: 4503:
    #####: 4504:  return false;
        -: 4505:} /* jerry_delete_object_native_pointer */
        -: 4506:
        -: 4507:/**
        -: 4508: * Initialize the references stored in a buffer pointed by a native pointer.
        -: 4509: * The references are initialized to undefined.
        -: 4510: */
        -: 4511:void
    #####: 4512:jerry_native_pointer_init_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4513:                                      const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4514:                                                                                        *   the native pointer */
        -: 4515:{
        -: 4516:  jerry_assert_api_available ();
        -: 4517:
    #####: 4518:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4519:  {
    #####: 4520:    return;
        -: 4521:  }
        -: 4522:
    #####: 4523:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4524:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4525:
    #####: 4526:  while (value_p < end_p)
        -: 4527:  {
    #####: 4528:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4529:  }
        -: 4530:} /* jerry_native_pointer_init_references */
        -: 4531:
        -: 4532:/**
        -: 4533: * Release the value references after a buffer pointed by a native pointer
        -: 4534: * is not attached to an object anymore. All references are set to undefined
        -: 4535: * similar to jerry_native_pointer_init_references.
        -: 4536: */
        -: 4537:void
    #####: 4538:jerry_native_pointer_release_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4539:                                         const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4540:                                                                                           *   the native pointer */
        -: 4541:{
        -: 4542:  jerry_assert_api_available ();
        -: 4543:
    #####: 4544:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4545:  {
    #####: 4546:    return;
        -: 4547:  }
        -: 4548:
    #####: 4549:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4550:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4551:
    #####: 4552:  while (value_p < end_p)
        -: 4553:  {
    #####: 4554:    ecma_free_value_if_not_object (*value_p);
    #####: 4555:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4556:  }
        -: 4557:} /* jerry_native_pointer_release_references */
        -: 4558:
        -: 4559:/**
        -: 4560: * Updates a value reference inside the area specified by the number_of_references and
        -: 4561: * offset_of_references fields in its corresponding jerry_object_native_info_t data.
        -: 4562: * The area must be part of a buffer which is currently assigned to an object.
        -: 4563: *
        -: 4564: * Note:
        -: 4565: *      Error references are not supported, they are replaced by undefined values.
        -: 4566: */
        -: 4567:void
    #####: 4568:jerry_native_pointer_set_reference (jerry_value_t *reference_p, /**< a valid non-NULL pointer to
        -: 4569:                                                                 *   a reference in a native buffer. */
        -: 4570:                                    jerry_value_t value) /**< new value of the reference */
        -: 4571:{
        -: 4572:  jerry_assert_api_available ();
        -: 4573:
    #####: 4574:  if (reference_p == NULL)
        -: 4575:  {
    #####: 4576:    return;
        -: 4577:  }
        -: 4578:
    #####: 4579:  if (ecma_is_value_error_reference (value))
        -: 4580:  {
    #####: 4581:    value = ECMA_VALUE_UNDEFINED;
        -: 4582:  }
        -: 4583:
    #####: 4584:  ecma_free_value_if_not_object (*reference_p);
    #####: 4585:  *reference_p = ecma_copy_value_if_not_object (value);
        -: 4586:} /* jerry_native_pointer_set_reference */
        -: 4587:
        -: 4588:/**
        -: 4589: * Applies the given function to the every property in the object.
        -: 4590: *
        -: 4591: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 4592: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 4593: *                - object fields traversal was stopped on callback that returned false;
        -: 4594: *         false - otherwise,
        -: 4595: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 4596: */
        -: 4597:bool
    #####: 4598:jerry_foreach_object_property (const jerry_value_t obj_val, /**< object value */
        -: 4599:                               jerry_object_property_foreach_t foreach_p, /**< foreach function */
        -: 4600:                               void *user_data_p) /**< user data for foreach function */
        -: 4601:{
        -: 4602:  jerry_assert_api_available ();
        -: 4603:
    #####: 4604:  if (!ecma_is_value_object (obj_val))
        -: 4605:  {
    #####: 4606:    return false;
        -: 4607:  }
        -: 4608:
    #####: 4609:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 4610:  ecma_collection_t *names_p = ecma_op_object_enumerate (object_p);
        -: 4611:
        -: 4612:#if JERRY_BUILTIN_PROXY
    #####: 4613:  if (names_p == NULL)
        -: 4614:  {
        -: 4615:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 4616:    jcontext_release_exception ();
    #####: 4617:    return false;
        -: 4618:  }
        -: 4619:#endif /* JERRY_BUILTIN_PROXY */
        -: 4620:
    #####: 4621:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 4622:
    #####: 4623:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 4624:
    #####: 4625:  bool continuous = true;
        -: 4626:
    #####: 4627:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 4628:  {
    #####: 4629:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 4630:
    #####: 4631:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 4632:
    #####: 4633:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 4634:    {
    #####: 4635:      break;
        -: 4636:    }
        -: 4637:
    #####: 4638:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 4639:    ecma_free_value (property_value);
        -: 4640:  }
        -: 4641:
    #####: 4642:  ecma_collection_free (names_p);
        -: 4643:
    #####: 4644:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 4645:  {
    #####: 4646:    return true;
        -: 4647:  }
        -: 4648:
    #####: 4649:  jcontext_release_exception ();
    #####: 4650:  return false;
        -: 4651:} /* jerry_foreach_object_property */
        -: 4652:
        -: 4653:/**
        -: 4654: * Gets the property keys for the given object using the selected filters.
        -: 4655: *
        -: 4656: * @return array containing the filtered property keys in successful operation
        -: 4657: *         value marked with error flag - otherwise
        -: 4658: */
        -: 4659:jerry_value_t
    #####: 4660:jerry_object_get_property_names (const jerry_value_t obj_val, /**< object */
        -: 4661:                                 jerry_property_filter_t filter) /**< property filter options */
        -: 4662:{
        -: 4663:  jerry_assert_api_available ();
        -: 4664:
    #####: 4665:  if (!ecma_is_value_object (obj_val))
        -: 4666:  {
    #####: 4667:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4668:  }
        -: 4669:
    #####: 4670:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 4671:  ecma_object_t *obj_iter_p = obj_p;
    #####: 4672:  ecma_collection_t *result_p = ecma_new_collection ();
        -: 4673:
    #####: 4674:  ecma_ref_object (obj_iter_p);
        -: 4675:
        -: 4676:  while (true)
    #####: 4677:  {
        -: 4678:    /* Step 1. Get Object.[[OwnKeys]] */
    #####: 4679:    ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_iter_p, filter);
        -: 4680:
        -: 4681:#if JERRY_BUILTIN_PROXY
    #####: 4682:    if (prop_names_p == NULL)
        -: 4683:    {
    #####: 4684:      ecma_deref_object (obj_iter_p);
    #####: 4685:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4686:    }
        -: 4687:#endif /* JERRY_BUILTIN_PROXY */
        -: 4688:
    #####: 4689:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 4690:    {
    #####: 4691:      ecma_value_t key = prop_names_p->buffer_p[i];
    #####: 4692:      ecma_string_t *key_p = ecma_get_prop_name_from_value (key);
    #####: 4693:      uint32_t index = ecma_string_get_array_index (key_p);
        -: 4694:
        -: 4695:      /* Step 2. Filter by key type */
    #####: 4696:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS
        -: 4697:                    | JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS
        -: 4698:                    | JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -: 4699:      {
    #####: 4700:        if (ecma_is_value_symbol (key))
        -: 4701:        {
    #####: 4702:          if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
        -: 4703:          {
    #####: 4704:            continue;
        -: 4705:          }
        -: 4706:        }
    #####: 4707:        else if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 4708:        {
    #####: 4709:          if ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
    #####: 4710:              || ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
    #####: 4711:                  && !(filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER)))
        -: 4712:          {
    #####: 4713:            continue;
        -: 4714:          }
        -: 4715:        }
    #####: 4716:        else if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 4717:        {
    #####: 4718:          continue;
        -: 4719:        }
        -: 4720:      }
        -: 4721:
        -: 4722:      /* Step 3. Filter property attributes */
    #####: 4723:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE
        -: 4724:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE
        -: 4725:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE))
        -: 4726:      {
    #####: 4727:        ecma_property_descriptor_t prop_desc;
    #####: 4728:        ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_iter_p, key_p, &prop_desc);
        -: 4729:
        -: 4730:#if JERRY_BUILTIN_PROXY
    #####: 4731:        if (ECMA_IS_VALUE_ERROR (status))
        -: 4732:        {
    #####: 4733:          ecma_collection_free (prop_names_p);
    #####: 4734:          ecma_collection_free (result_p);
    #####: 4735:          ecma_deref_object (obj_iter_p);
    #####: 4736:          return jerry_throw (ECMA_VALUE_ERROR);
        -: 4737:        }
        -: 4738:#endif /* JERRY_BUILTIN_PROXY */
        -: 4739:
    #####: 4740:        JERRY_ASSERT (ecma_is_value_true (status));
    #####: 4741:        uint16_t flags = prop_desc.flags;
    #####: 4742:        ecma_free_property_descriptor (&prop_desc);
        -: 4743:
    #####: 4744:        if ((!(flags & JERRY_PROP_IS_CONFIGURABLE)
    #####: 4745:             && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE))
    #####: 4746:            || (!(flags & JERRY_PROP_IS_ENUMERABLE)
    #####: 4747:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE))
    #####: 4748:            || (!(flags & JERRY_PROP_IS_WRITABLE)
    #####: 4749:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE)))
        -: 4750:        {
    #####: 4751:          continue;
        -: 4752:        }
        -: 4753:      }
        -: 4754:
    #####: 4755:      if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####: 4756:          && (filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER))
        -: 4757:      {
    #####: 4758:        ecma_deref_ecma_string (key_p);
    #####: 4759:        key = ecma_make_uint32_value (index);
        -: 4760:      }
        -: 4761:      else
        -: 4762:      {
    #####: 4763:        ecma_ref_ecma_string (key_p);
        -: 4764:      }
        -: 4765:
    #####: 4766:      if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) && obj_iter_p != obj_p)
    #####: 4767:      {
    #####: 4768:        uint32_t duplicate_idx = 0;
    #####: 4769:        while (duplicate_idx < result_p->item_count)
        -: 4770:        {
    #####: 4771:          ecma_value_t value = result_p->buffer_p[duplicate_idx];
    #####: 4772:          JERRY_ASSERT (ecma_is_value_prop_name (value) || ecma_is_value_number (value));
    #####: 4773:          if (JERRY_UNLIKELY (ecma_is_value_number (value)))
        -: 4774:          {
    #####: 4775:            if (ecma_get_number_from_value (value) == ecma_get_number_from_value (key))
        -: 4776:            {
    #####: 4777:              break;
        -: 4778:            }
        -: 4779:          }
    #####: 4780:          else if (ecma_compare_ecma_strings (ecma_get_prop_name_from_value (value), key_p))
        -: 4781:          {
    #####: 4782:            break;
        -: 4783:          }
        -: 4784:
    #####: 4785:          duplicate_idx++;
        -: 4786:        }
        -: 4787:
    #####: 4788:        if (duplicate_idx == result_p->item_count)
        -: 4789:        {
    #####: 4790:          ecma_collection_push_back (result_p, key);
        -: 4791:        }
        -: 4792:      }
        -: 4793:      else
        -: 4794:      {
    #####: 4795:        ecma_collection_push_back (result_p, key);
        -: 4796:      }
        -: 4797:    }
        -: 4798:
    #####: 4799:    ecma_collection_free (prop_names_p);
        -: 4800:
        -: 4801:    /* Step 4: Traverse prototype chain */
        -: 4802:
    #####: 4803:    if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) != JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN)
        -: 4804:    {
    #####: 4805:      break;
        -: 4806:    }
        -: 4807:
    #####: 4808:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_iter_p);
        -: 4809:
    #####: 4810:    if (proto_p == NULL)
        -: 4811:    {
    #####: 4812:      break;
        -: 4813:    }
        -: 4814:
    #####: 4815:    ecma_deref_object (obj_iter_p);
        -: 4816:
    #####: 4817:    if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 4818:    {
    #####: 4819:      ecma_collection_free (result_p);
    #####: 4820:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4821:    }
        -: 4822:
    #####: 4823:    obj_iter_p = proto_p;
        -: 4824:  }
        -: 4825:
    #####: 4826:  ecma_deref_object (obj_iter_p);
        -: 4827:
    #####: 4828:  return ecma_op_new_array_object_from_collection (result_p, false);
        -: 4829:} /* jerry_object_get_property_names */
        -: 4830:
        -: 4831:/**
        -: 4832: * FromPropertyDescriptor abstract operation.
        -: 4833: *
        -: 4834: * @return new jerry_value_t - if success
        -: 4835: *         value marked with error flag - otherwise
        -: 4836: */
        -: 4837:jerry_value_t
    #####: 4838:jerry_from_property_descriptor (const jerry_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -: 4839:{
        -: 4840:  jerry_assert_api_available ();
        -: 4841:
    #####: 4842:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (src_prop_desc_p);
        -: 4843:
    #####: 4844:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 4845:  {
    #####: 4846:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4847:  }
        -: 4848:
    #####: 4849:  ecma_object_t *desc_obj_p = ecma_op_from_property_descriptor (&prop_desc);
        -: 4850:
    #####: 4851:  return ecma_make_object_value (desc_obj_p);
        -: 4852:} /* jerry_from_property_descriptor */
        -: 4853:
        -: 4854:/**
        -: 4855: * ToPropertyDescriptor abstract operation.
        -: 4856: *
        -: 4857: * @return true - if the conversion is successful
        -: 4858: *         thrown error - otherwise
        -: 4859: */
        -: 4860:jerry_value_t
    #####: 4861:jerry_to_property_descriptor (jerry_value_t obj_value, /**< object value */
        -: 4862:                              jerry_property_descriptor_t *out_prop_desc_p) /**< [out] filled property descriptor
        -: 4863:                                                                             *   if return value is true,
        -: 4864:                                                                             *   unmodified otherwise */
        -: 4865:{
        -: 4866:  jerry_assert_api_available ();
        -: 4867:
    #####: 4868:  ecma_property_descriptor_t prop_desc;
    #####: 4869:  jerry_value_t result = ecma_op_to_property_descriptor (obj_value, &prop_desc);
        -: 4870:
    #####: 4871:  if (ECMA_IS_VALUE_ERROR (result))
        -: 4872:  {
    #####: 4873:    return jerry_throw (result);
        -: 4874:  }
        -: 4875:
    #####: 4876:  JERRY_ASSERT (result == ECMA_VALUE_EMPTY);
        -: 4877:
    #####: 4878:  *out_prop_desc_p = jerry_property_descriptor_from_ecma (&prop_desc);
    #####: 4879:  return ECMA_VALUE_TRUE;
        -: 4880:} /* jerry_to_property_descriptor */
        -: 4881:
        -: 4882:/**
        -: 4883: * Resolve or reject the promise with an argument.
        -: 4884: *
        -: 4885: * @return undefined value - if success
        -: 4886: *         value marked with error flag - otherwise
        -: 4887: */
        -: 4888:jerry_value_t
    #####: 4889:jerry_resolve_or_reject_promise (jerry_value_t promise, /**< the promise value */
        -: 4890:                                 jerry_value_t argument, /**< the argument */
        -: 4891:                                 bool is_resolve) /**< whether the promise should be resolved or rejected */
        -: 4892:{
        -: 4893:  jerry_assert_api_available ();
        -: 4894:
        -: 4895:#if JERRY_ESNEXT
    #####: 4896:  if (!ecma_is_value_object (promise) || !ecma_is_promise (ecma_get_object_from_value (promise)))
        -: 4897:  {
    #####: 4898:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4899:  }
        -: 4900:
    #####: 4901:  if (ecma_is_value_error_reference (argument))
        -: 4902:  {
    #####: 4903:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4904:  }
        -: 4905:
    #####: 4906:  if (is_resolve)
        -: 4907:  {
    #####: 4908:    return ecma_fulfill_promise_with_checks (promise, argument);
        -: 4909:  }
        -: 4910:
    #####: 4911:  return ecma_reject_promise_with_checks (promise, argument);
        -: 4912:#else /* !JERRY_ESNEXT */
        -: 4913:  JERRY_UNUSED (promise);
        -: 4914:  JERRY_UNUSED (argument);
        -: 4915:  JERRY_UNUSED (is_resolve);
        -: 4916:
    #####: 4917:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4918:#endif /* JERRY_ESNEXT */
        -: 4919:} /* jerry_resolve_or_reject_promise */
        -: 4920:
        -: 4921:/**
        -: 4922: * Get the result of a promise.
        -: 4923: *
        -: 4924: * @return - Promise result
        -: 4925: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 4926: */
        -: 4927:jerry_value_t
    #####: 4928:jerry_get_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 4929:{
        -: 4930:  jerry_assert_api_available ();
        -: 4931:
        -: 4932:#if JERRY_ESNEXT
    #####: 4933:  if (!jerry_value_is_promise (promise))
        -: 4934:  {
    #####: 4935:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4936:  }
        -: 4937:
    #####: 4938:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 4939:#else /* !JERRY_ESNEXT */
        -: 4940:  JERRY_UNUSED (promise);
    #####: 4941:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4942:#endif /* JERRY_ESNEXT */
        -: 4943:} /* jerry_get_promise_result */
        -: 4944:
        -: 4945:/**
        -: 4946: * Get the state of a promise object.
        -: 4947: *
        -: 4948: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 4949: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 4950: *           or the promise support was not enabled.
        -: 4951: */
        -: 4952:jerry_promise_state_t
    #####: 4953:jerry_get_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 4954:{
        -: 4955:  jerry_assert_api_available ();
        -: 4956:
        -: 4957:#if JERRY_ESNEXT
    #####: 4958:  if (!jerry_value_is_promise (promise))
        -: 4959:  {
    #####: 4960:    return JERRY_PROMISE_STATE_NONE;
        -: 4961:  }
        -: 4962:
    #####: 4963:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 4964:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 4965:
    #####: 4966:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 4967:#else /* !JERRY_ESNEXT */
        -: 4968:  JERRY_UNUSED (promise);
    #####: 4969:  return JERRY_PROMISE_STATE_NONE;
        -: 4970:#endif /* JERRY_ESNEXT */
        -: 4971:} /* jerry_get_promise_state */
        -: 4972:
        -: 4973:/**
        -: 4974: * Sets a callback for tracking Promise and async operations.
        -: 4975: *
        -: 4976: * Note:
        -: 4977: *     the previous callback is overwritten
        -: 4978: */
        1: 4979:void jerry_promise_set_callback (jerry_promise_event_filter_t filters, /**< combination of event filters */
        -: 4980:                                 jerry_promise_callback_t callback, /**< notification callback */
        -: 4981:                                 void *user_p) /**< user pointer passed to the callback */
        -: 4982:{
        -: 4983:  jerry_assert_api_available ();
        -: 4984:
        -: 4985:#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK
    #####: 4986:  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)
        -: 4987:  {
    #####: 4988:    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;
    #####: 4989:    return;
        -: 4990:  }
        -: 4991:
    #####: 4992:  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;
    #####: 4993:  JERRY_CONTEXT (promise_callback) = callback;
    #####: 4994:  JERRY_CONTEXT (promise_callback_user_p) = user_p;
        -: 4995:#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */
        -: 4996:  JERRY_UNUSED (filters);
        -: 4997:  JERRY_UNUSED (callback);
        -: 4998:  JERRY_UNUSED (user_p);
        -: 4999:#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */
        1: 5000:} /* jerry_promise_set_callback */
        -: 5001:
        -: 5002:/**
        -: 5003: * Get the well-knwon symbol represented by the given `symbol` enum value.
        -: 5004: *
        -: 5005: * Note:
        -: 5006: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5007: *
        -: 5008: * @return undefined value - if invalid well-known symbol was requested
        -: 5009: *         well-known symbol value - otherwise
        -: 5010: */
        -: 5011:jerry_value_t
    #####: 5012:jerry_get_well_known_symbol (jerry_well_known_symbol_t symbol) /**< jerry_well_known_symbol_t enum value */
        -: 5013:{
        -: 5014:  jerry_assert_api_available ();
        -: 5015:
        -: 5016:#if JERRY_ESNEXT
    #####: 5017:  lit_magic_string_id_t id = (lit_magic_string_id_t) (LIT_GLOBAL_SYMBOL__FIRST + symbol);
        -: 5018:
    #####: 5019:  if (!LIT_IS_GLOBAL_SYMBOL (id))
        -: 5020:  {
    #####: 5021:    return ECMA_VALUE_UNDEFINED;
        -: 5022:  }
        -: 5023:
    #####: 5024:  return ecma_make_symbol_value (ecma_op_get_global_symbol (id));
        -: 5025:#else /* !JERRY_ESNEXT */
        -: 5026:  JERRY_UNUSED (symbol);
        -: 5027:
    #####: 5028:  return ECMA_VALUE_UNDEFINED;
        -: 5029:#endif /* JERRY_ESNEXT */
        -: 5030:} /** jerry_get_well_known_symbol */
        -: 5031:
        -: 5032:/**
        -: 5033: * Returns the description internal property of a symbol.
        -: 5034: *
        -: 5035: * Note:
        -: 5036: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5037: *
        -: 5038: * @return string or undefined value containing the symbol's description - if success
        -: 5039: *         thrown error - otherwise
        -: 5040: */
        -: 5041:jerry_value_t
    #####: 5042:jerry_get_symbol_description (const jerry_value_t symbol) /**< symbol value */
        -: 5043:{
        -: 5044:  jerry_assert_api_available ();
        -: 5045:
        -: 5046:#if JERRY_ESNEXT
    #####: 5047:  if (!ecma_is_value_symbol (symbol))
        -: 5048:  {
    #####: 5049:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 5050:  }
        -: 5051:
        -: 5052:  /* Note: This operation cannot throw an error */
    #####: 5053:  return ecma_copy_value (ecma_get_symbol_description (ecma_get_symbol_from_value (symbol)));
        -: 5054:#else /* !JERRY_ESNEXT */
        -: 5055:  JERRY_UNUSED (symbol);
        -: 5056:
    #####: 5057:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 5058:#endif /* JERRY_ESNEXT */
        -: 5059:} /* jerry_get_symbol_description */
        -: 5060:
        -: 5061:/**
        -: 5062: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 5063: *
        -: 5064: * Note:
        -: 5065: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5066: *
        -: 5067: * @return string value containing the symbol's descriptive string - if success
        -: 5068: *         thrown error - otherwise
        -: 5069: */
        -: 5070:jerry_value_t
    #####: 5071:jerry_get_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 5072:{
        -: 5073:  jerry_assert_api_available ();
        -: 5074:
        -: 5075:#if JERRY_ESNEXT
    #####: 5076:  if (!ecma_is_value_symbol (symbol))
        -: 5077:  {
    #####: 5078:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 5079:  }
        -: 5080:
        -: 5081:  /* Note: This operation cannot throw an error */
    #####: 5082:  return ecma_get_symbol_descriptive_string (symbol);
        -: 5083:#else /* !JERRY_ESNEXT */
        -: 5084:  JERRY_UNUSED (symbol);
        -: 5085:
    #####: 5086:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 5087:#endif /* JERRY_ESNEXT */
        -: 5088:} /** jerry_get_symbol_descriptive_string */
        -: 5089:
        -: 5090:/**
        -: 5091: * Get the number of uint64 digits of a BigInt value
        -: 5092: *
        -: 5093: * @return number of uint64 digits
        -: 5094: */
        -: 5095:uint32_t
    #####: 5096:jerry_get_bigint_size_in_digits (jerry_value_t value) /**< BigInt value */
        -: 5097:{
        -: 5098:  jerry_assert_api_available ();
        -: 5099:
        -: 5100:#if JERRY_BUILTIN_BIGINT
    #####: 5101:  if (!ecma_is_value_bigint (value))
        -: 5102:  {
    #####: 5103:    return 0;
        -: 5104:  }
        -: 5105:
    #####: 5106:  return ecma_bigint_get_size_in_digits (value);
        -: 5107:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5108:  JERRY_UNUSED (value);
    #####: 5109:  return 0;
        -: 5110:#endif /* JERRY_BUILTIN_BIGINT */
        -: 5111:} /* jerry_get_bigint_size_in_digits */
        -: 5112:
        -: 5113:/**
        -: 5114: * Get the uint64 digits of a BigInt value (lowest digit first)
        -: 5115: */
        -: 5116:void
    #####: 5117:jerry_get_bigint_digits (jerry_value_t value, /**< BigInt value */
        -: 5118:                         uint64_t *digits_p, /**< [out] buffer for digits */
        -: 5119:                         uint32_t size, /**< buffer size in digits */
        -: 5120:                         bool *sign_p) /**< [out] sign of BigInt */
        -: 5121:{
        -: 5122:#if JERRY_BUILTIN_BIGINT
    #####: 5123:  if (!ecma_is_value_bigint (value))
        -: 5124:  {
    #####: 5125:    if (sign_p != NULL)
        -: 5126:    {
    #####: 5127:      *sign_p = false;
        -: 5128:    }
    #####: 5129:    memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5130:  }
        -: 5131:
    #####: 5132:  ecma_bigint_get_digits_and_sign (value, digits_p, size, sign_p);
        -: 5133:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5134:  JERRY_UNUSED (value);
        -: 5135:
    #####: 5136:  if (sign_p != NULL)
        -: 5137:  {
    #####: 5138:    *sign_p = false;
        -: 5139:  }
    #####: 5140:  memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5141:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 5142:} /* jerry_get_bigint_digits */
        -: 5143:
        -: 5144:/**
        -: 5145: * Get the target object of a Proxy object
        -: 5146: *
        -: 5147: * @return type error - if proxy_value is not a Proxy object
        -: 5148: *         target object - otherwise
        -: 5149: */
        -: 5150:jerry_value_t
    #####: 5151:jerry_get_proxy_target (jerry_value_t proxy_value) /**< proxy value */
        -: 5152:{
        -: 5153:  jerry_assert_api_available ();
        -: 5154:
        -: 5155:#if JERRY_BUILTIN_PROXY
    #####: 5156:  if (ecma_is_value_object (proxy_value))
        -: 5157:  {
    #####: 5158:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5159:
    #####: 5160:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5161:    {
    #####: 5162:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5163:
    #####: 5164:      if (!ecma_is_value_null (proxy_object_p->target))
        -: 5165:      {
    #####: 5166:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->target));
        -: 5167:      }
    #####: 5168:      return proxy_object_p->target;
        -: 5169:    }
        -: 5170:  }
        -: 5171:#else /* !JERRY_BUILTIN_PROXY */
        -: 5172:  JERRY_UNUSED (proxy_value);
        -: 5173:#endif /* JERRY_BUILTIN_PROXY */
        -: 5174:
    #####: 5175:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5176:} /* jerry_get_proxy_target */
        -: 5177:
        -: 5178:/**
        -: 5179: * Get the handler object of a Proxy object
        -: 5180: *
        -: 5181: * @return type error - if proxy_value is not a Proxy object
        -: 5182: *         handler object - otherwise
        -: 5183: */
        -: 5184:jerry_value_t
    #####: 5185:jerry_get_proxy_handler (jerry_value_t proxy_value) /**< proxy value */
        -: 5186:{
        -: 5187:  jerry_assert_api_available ();
        -: 5188:
        -: 5189:#if JERRY_BUILTIN_PROXY
    #####: 5190:  if (ecma_is_value_object (proxy_value))
        -: 5191:  {
    #####: 5192:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5193:
    #####: 5194:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5195:    {
    #####: 5196:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5197:
    #####: 5198:      if (!ecma_is_value_null (proxy_object_p->handler))
        -: 5199:      {
    #####: 5200:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->handler));
        -: 5201:      }
    #####: 5202:      return proxy_object_p->handler;
        -: 5203:    }
        -: 5204:  }
        -: 5205:#else /* !JERRY_BUILTIN_PROXY */
        -: 5206:  JERRY_UNUSED (proxy_value);
        -: 5207:#endif /* JERRY_BUILTIN_PROXY */
        -: 5208:
    #####: 5209:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5210:} /* jerry_get_proxy_handler */
        -: 5211:
        -: 5212:/**
        -: 5213: * Validate UTF-8 string
        -: 5214: *
        -: 5215: * @return true - if UTF-8 string is well-formed
        -: 5216: *         false - otherwise
        -: 5217: */
        -: 5218:bool
        1: 5219:jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */
        -: 5220:                            jerry_size_t buf_size) /**< string size */
        -: 5221:{
        1: 5222:  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,
        -: 5223:                                   (lit_utf8_size_t) buf_size,
        -: 5224:                                   true);
        -: 5225:} /* jerry_is_valid_utf8_string */
        -: 5226:
        -: 5227:/**
        -: 5228: * Validate CESU-8 string
        -: 5229: *
        -: 5230: * @return true - if CESU-8 string is well-formed
        -: 5231: *         false - otherwise
        -: 5232: */
        -: 5233:bool
    #####: 5234:jerry_is_valid_cesu8_string (const jerry_char_t *cesu8_buf_p, /**< CESU-8 string */
        -: 5235:                             jerry_size_t buf_size) /**< string size */
        -: 5236:{
    #####: 5237:  return lit_is_valid_cesu8_string ((lit_utf8_byte_t *) cesu8_buf_p,
        -: 5238:                                    (lit_utf8_size_t) buf_size);
        -: 5239:} /* jerry_is_valid_cesu8_string */
        -: 5240:
        -: 5241:/**
        -: 5242: * Allocate memory on the engine's heap.
        -: 5243: *
        -: 5244: * Note:
        -: 5245: *      This function may take away memory from the executed JavaScript code.
        -: 5246: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 5247: *      malloc), it should be used instead.
        -: 5248: *
        -: 5249: * @return allocated memory on success
        -: 5250: *         NULL otherwise
        -: 5251: */
        -: 5252:void *
    #####: 5253:jerry_heap_alloc (size_t size) /**< size of the memory block */
        -: 5254:{
        -: 5255:  jerry_assert_api_available ();
        -: 5256:
    #####: 5257:  return jmem_heap_alloc_block_null_on_error (size);
        -: 5258:} /* jerry_heap_alloc */
        -: 5259:
        -: 5260:/**
        -: 5261: * Free memory allocated on the engine's heap.
        -: 5262: */
        -: 5263:void
    #####: 5264:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 5265:                 size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 5266:{
        -: 5267:  jerry_assert_api_available ();
        -: 5268:
    #####: 5269:  jmem_heap_free_block (mem_p, size);
    #####: 5270:} /* jerry_heap_free */
        -: 5271:
        -: 5272:/**
        -: 5273: * Create an external engine context.
        -: 5274: *
        -: 5275: * @return the pointer to the context.
        -: 5276: */
        -: 5277:jerry_context_t *
    #####: 5278:jerry_create_context (uint32_t heap_size, /**< the size of heap */
        -: 5279:                      jerry_context_alloc_t alloc, /**< the alloc function */
        -: 5280:                      void *cb_data_p) /**< the cb_data for alloc function */
        -: 5281:{
        -: 5282:  JERRY_UNUSED (heap_size);
        -: 5283:
        -: 5284:#if JERRY_EXTERNAL_CONTEXT
        -: 5285:
        -: 5286:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 5287:
        -: 5288:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5289:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 5290:
        -: 5291:  /* Minimum heap size is 1Kbyte. */
        -: 5292:  if (heap_size < 1024)
        -: 5293:  {
        -: 5294:    return NULL;
        -: 5295:  }
        -: 5296:
        -: 5297:  total_size += heap_size;
        -: 5298:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5299:
        -: 5300:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 5301:
        -: 5302:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 5303:
        -: 5304:  if (context_p == NULL)
        -: 5305:  {
        -: 5306:    return NULL;
        -: 5307:  }
        -: 5308:
        -: 5309:  memset (context_p, 0, total_size);
        -: 5310:
        -: 5311:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 5312:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 5313:
        -: 5314:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 5315:
        -: 5316:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5317:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 5318:  context_p->heap_size = heap_size;
        -: 5319:  byte_p += heap_size;
        -: 5320:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5321:
        -: 5322:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 5323:
        -: 5324:  JERRY_UNUSED (byte_p);
        -: 5325:  return context_p;
        -: 5326:
        -: 5327:#else /* !JERRY_EXTERNAL_CONTEXT */
        -: 5328:
        -: 5329:  JERRY_UNUSED (alloc);
        -: 5330:  JERRY_UNUSED (cb_data_p);
        -: 5331:
    #####: 5332:  return NULL;
        -: 5333:
        -: 5334:#endif /* JERRY_EXTERNAL_CONTEXT */
        -: 5335:} /* jerry_create_context */
        -: 5336:
        -: 5337:/**
        -: 5338: * When JERRY_VM_EXEC_STOP is enabled, the callback passed to this function
        -: 5339: * is periodically called with the user_p argument. If frequency is greater
        -: 5340: * than 1, the callback is only called at every frequency ticks.
        -: 5341: */
        -: 5342:void
    #####: 5343:jerry_set_vm_exec_stop_callback (jerry_vm_exec_stop_callback_t stop_cb, /**< periodically called user function */
        -: 5344:                                 void *user_p, /**< pointer passed to the function */
        -: 5345:                                 uint32_t frequency) /**< frequency of the function call */
        -: 5346:{
        -: 5347:#if JERRY_VM_EXEC_STOP
    #####: 5348:  if (frequency == 0)
        -: 5349:  {
    #####: 5350:    frequency = 1;
        -: 5351:  }
        -: 5352:
    #####: 5353:  JERRY_CONTEXT (vm_exec_stop_frequency) = frequency;
    #####: 5354:  JERRY_CONTEXT (vm_exec_stop_counter) = frequency;
    #####: 5355:  JERRY_CONTEXT (vm_exec_stop_cb) = stop_cb;
    #####: 5356:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
        -: 5357:#else /* !JERRY_VM_EXEC_STOP */
        -: 5358:  JERRY_UNUSED (stop_cb);
        -: 5359:  JERRY_UNUSED (user_p);
        -: 5360:  JERRY_UNUSED (frequency);
        -: 5361:#endif /* JERRY_VM_EXEC_STOP */
    #####: 5362:} /* jerry_set_vm_exec_stop_callback */
        -: 5363:
        -: 5364:/**
        -: 5365: * Get backtrace. The backtrace is an array of strings where
        -: 5366: * each string contains the position of the corresponding frame.
        -: 5367: * The array length is zero if the backtrace is not available.
        -: 5368: *
        -: 5369: * @return array value
        -: 5370: */
        -: 5371:jerry_value_t
    #####: 5372:jerry_get_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 5373:{
    #####: 5374:  return vm_get_backtrace (max_depth);
        -: 5375:} /* jerry_get_backtrace */
        -: 5376:
        -: 5377:/**
        -: 5378: * Low-level function to capture each backtrace frame.
        -: 5379: * The captured frame data is passed to a callback function.
        -: 5380: */
        -: 5381:void
    #####: 5382:jerry_backtrace_capture (jerry_backtrace_callback_t callback, /**< callback function */
        -: 5383:                         void *user_p) /**< user pointer passed to the callback function */
        -: 5384:{
    #####: 5385:  jerry_backtrace_frame_t frame;
    #####: 5386:  vm_frame_ctx_t *context_p = JERRY_CONTEXT (vm_top_context_p);
        -: 5387:
    #####: 5388:  while (context_p != NULL)
        -: 5389:  {
    #####: 5390:    frame.context_p = context_p;
    #####: 5391:    frame.frame_type = JERRY_BACKTRACE_FRAME_JS;
        -: 5392:
    #####: 5393:    if (!callback (&frame, user_p))
        -: 5394:    {
    #####: 5395:      return;
        -: 5396:    }
        -: 5397:
    #####: 5398:    context_p = context_p->prev_context_p;
        -: 5399:  }
        -: 5400:} /* jerry_backtrace_capture */
        -: 5401:
        -: 5402:/**
        -: 5403: * Returns with the type of the backtrace frame.
        -: 5404: *
        -: 5405: * @return frame type listed in jerry_backtrace_frame_types_t
        -: 5406: */
        -: 5407:jerry_backtrace_frame_types_t
    #####: 5408:jerry_backtrace_get_frame_type (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5409:{
    #####: 5410:  return (jerry_backtrace_frame_types_t) frame_p->frame_type;
        -: 5411:} /* jerry_backtrace_get_frame_type */
        -: 5412:
        -: 5413:/**
        -: 5414: * Initialize and return with the location private field of a backtrace frame.
        -: 5415: *
        -: 5416: * @return pointer to the location private field - if the location is available,
        -: 5417: *         NULL - otherwise
        -: 5418: */
        -: 5419:const jerry_backtrace_location_t *
    #####: 5420:jerry_backtrace_get_location (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5421:{
        -: 5422:  JERRY_UNUSED (frame_p);
        -: 5423:
        -: 5424:#if JERRY_LINE_INFO
    #####: 5425:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5426:  {
    #####: 5427:    vm_frame_ctx_t *context_p = frame_p->context_p;
    #####: 5428:    const ecma_compiled_code_t *bytecode_header_p = context_p->shared_p->bytecode_header_p;
        -: 5429:
    #####: 5430:    if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO))
        -: 5431:    {
        -: 5432:      return NULL;
        -: 5433:    }
        -: 5434:
    #####: 5435:    frame_p->location.resource_name = ecma_get_resource_name (bytecode_header_p);
        -: 5436:
    #####: 5437:    ecma_line_info_get (ecma_compiled_code_get_line_info (bytecode_header_p),
    #####: 5438:                        (uint32_t) (context_p->byte_code_p - context_p->byte_code_start_p),
        -: 5439:                        &frame_p->location);
        -: 5440:
    #####: 5441:    return &frame_p->location;
        -: 5442:  }
        -: 5443:#endif /* JERRY_LINE_INFO */
        -: 5444:
    #####: 5445:  return NULL;
        -: 5446:} /* jerry_backtrace_get_location */
        -: 5447:
        -: 5448:/**
        -: 5449: * Initialize and return with the called function private field of a backtrace frame.
        -: 5450: * The backtrace frame is created for running the code bound to this function.
        -: 5451: *
        -: 5452: * @return pointer to the called function - if the function is available,
        -: 5453: *         NULL - otherwise
        -: 5454: */
        -: 5455:const jerry_value_t *
    #####: 5456:jerry_backtrace_get_function (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5457:{
    #####: 5458:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5459:  {
    #####: 5460:    vm_frame_ctx_t *context_p = frame_p->context_p;
        -: 5461:
    #####: 5462:    if (context_p->shared_p->function_object_p != NULL)
        -: 5463:    {
    #####: 5464:      frame_p->function = ecma_make_object_value (context_p->shared_p->function_object_p);
    #####: 5465:      return &frame_p->function;
        -: 5466:    }
        -: 5467:  }
        -: 5468:
    #####: 5469:  return NULL;
        -: 5470:} /* jerry_backtrace_get_function */
        -: 5471:
        -: 5472:/**
        -: 5473: * Initialize and return with the 'this' binding private field of a backtrace frame.
        -: 5474: * The 'this' binding is a hidden value passed to the called function. As for arrow
        -: 5475: * functions, the 'this' binding is assigned at function creation.
        -: 5476: *
        -: 5477: * @return pointer to the 'this' binding - if the binding is available,
        -: 5478: *         NULL - otherwise
        -: 5479: */
        -: 5480:const jerry_value_t *
    #####: 5481:jerry_backtrace_get_this (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5482:{
    #####: 5483:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5484:  {
    #####: 5485:    frame_p->this_binding = frame_p->context_p->this_binding;
    #####: 5486:    return &frame_p->this_binding;
        -: 5487:  }
        -: 5488:
    #####: 5489:  return NULL;
        -: 5490:} /* jerry_backtrace_get_this */
        -: 5491:
        -: 5492:/**
        -: 5493: * Returns true, if the code bound to the backtrace frame is strict mode code.
        -: 5494: *
        -: 5495: * @return true - if strict mode code is bound to the frame,
        -: 5496: *         false - otherwise
        -: 5497: */
        -: 5498:bool
    #####: 5499:jerry_backtrace_is_strict (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5500:{
    #####: 5501:  return (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS
    #####: 5502:          && (frame_p->context_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0);
        -: 5503:} /* jerry_backtrace_is_strict */
        -: 5504:
        -: 5505:/**
        -: 5506: * Get the resource name (usually a file name) of the currently executed script or the given function object
        -: 5507: *
        -: 5508: * Note: returned value must be freed with jerry_release_value, when it is no longer needed
        -: 5509: *
        -: 5510: * @return JS string constructed from
        -: 5511: *         - the currently executed function object's resource name, if the given value is undefined
        -: 5512: *         - resource name of the function object, if the given value is a function object
        -: 5513: *         - "<anonymous>", otherwise
        -: 5514: */
        -: 5515:jerry_value_t
    #####: 5516:jerry_get_resource_name (const jerry_value_t value) /**< jerry api value */
        -: 5517:{
        -: 5518:#if JERRY_RESOURCE_NAME
    #####: 5519:  if (ecma_is_value_undefined (value) && JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 5520:  {
    #####: 5521:    return ecma_copy_value (ecma_get_resource_name (JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p));
        -: 5522:  }
        -: 5523:
    #####: 5524:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5525:
    #####: 5526:  if (script_value == JMEM_CP_NULL)
        -: 5527:  {
    #####: 5528:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5529:  }
        -: 5530:
    #####: 5531:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5532:
    #####: 5533:  return ecma_copy_value (script_p->resource_name);
        -: 5534:#else /* !JERRY_RESOURCE_NAME */
        -: 5535:  JERRY_UNUSED (value);
        -: 5536:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5537:#endif /* JERRY_RESOURCE_NAME */
        -: 5538:} /* jerry_get_resource_name */
        -: 5539:
        -: 5540:/**
        -: 5541: * Returns the user value assigned to a script / module / function.
        -: 5542: *
        -: 5543: * Note:
        -: 5544: *    This value is usually set by the parser when
        -: 5545: *    the JERRY_PARSE_HAS_USER_VALUE flag is passed.
        -: 5546: *
        -: 5547: * @return user value
        -: 5548: */
        -: 5549:jerry_value_t
    #####: 5550:jerry_get_user_value (const jerry_value_t value) /**< jerry api value */
        -: 5551:{
    #####: 5552:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5553:
    #####: 5554:  if (script_value == JMEM_CP_NULL)
        -: 5555:  {
    #####: 5556:    return ECMA_VALUE_UNDEFINED;
        -: 5557:  }
        -: 5558:
    #####: 5559:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5560:
    #####: 5561:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE))
        -: 5562:  {
    #####: 5563:    return ECMA_VALUE_UNDEFINED;
        -: 5564:  }
        -: 5565:
    #####: 5566:  return ecma_copy_value (CBC_SCRIPT_GET_USER_VALUE (script_p));
        -: 5567:} /* jerry_get_user_value */
        -: 5568:
        -: 5569:/**
        -: 5570: * Checks whether an ECMAScript code is compiled by eval
        -: 5571: * like (eval, new Function, jerry_eval, etc.) command.
        -: 5572: *
        -: 5573: * @return true, if code is compiled by eval like command
        -: 5574: *         false, otherwise
        -: 5575: */
        -: 5576:bool
    #####: 5577:jerry_is_eval_code (const jerry_value_t value) /**< jerry api value */
        -: 5578:{
    #####: 5579:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5580:
    #####: 5581:  if (script_value == JMEM_CP_NULL)
        -: 5582:  {
    #####: 5583:    return false;
        -: 5584:  }
        -: 5585:
    #####: 5586:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5587:
    #####: 5588:  return (script_p->refs_and_type & CBC_SCRIPT_IS_EVAL_CODE) != 0;
        -: 5589:} /* jerry_is_eval_code */
        -: 5590:
        -: 5591:/**
        -: 5592: * Returns a newly created source info structure corresponding to the passed script/module/function.
        -: 5593: *
        -: 5594: * @return a newly created source info, if at least one field is available, NULL otherwise
        -: 5595: */
        -: 5596:jerry_source_info_t *
    #####: 5597:jerry_get_source_info (const jerry_value_t value) /**< jerry api value */
        -: 5598:{
        -: 5599:  jerry_assert_api_available ();
        -: 5600:
        -: 5601:#if JERRY_FUNCTION_TO_STRING
    #####: 5602:  if (!ecma_is_value_object (value))
        -: 5603:  {
        -: 5604:    return NULL;
        -: 5605:  }
        -: 5606:
        -: 5607:  jerry_source_info_t source_info;
        -: 5608:
    #####: 5609:  source_info.enabled_fields = 0;
    #####: 5610:  source_info.source_code = ECMA_VALUE_UNDEFINED;
    #####: 5611:  source_info.function_arguments = ECMA_VALUE_UNDEFINED;
    #####: 5612:  source_info.source_range_start = 0;
    #####: 5613:  source_info.source_range_length = 0;
        -: 5614:
    #####: 5615:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 5616:  cbc_script_t *script_p = NULL;
        -: 5617:
        -: 5618:  while (true)
        -: 5619:  {
    #####: 5620:    switch (ecma_get_object_type (object_p))
        -: 5621:    {
    #####: 5622:      case ECMA_OBJECT_TYPE_CLASS:
        -: 5623:      {
    #####: 5624:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 5625:        const ecma_compiled_code_t *bytecode_p = NULL;
        -: 5626:
    #####: 5627:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 5628:        {
    #####: 5629:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5630:                                                        ext_object_p->u.cls.u3.value);
        -: 5631:        }
        -: 5632:#if JERRY_MODULE_SYSTEM
    #####: 5633:        else if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 5634:        {
    #####: 5635:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 5636:
    #####: 5637:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 5638:          {
    #####: 5639:            bytecode_p = module_p->u.compiled_code_p;
        -: 5640:          }
        -: 5641:        }
        -: 5642:#endif /* JERRY_MODULE_SYSTEM */
        -: 5643:
    #####: 5644:        if (bytecode_p == NULL)
        -: 5645:        {
        -: 5646:          return NULL;
        -: 5647:        }
        -: 5648:
    #####: 5649:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5650:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5651:        break;
        -: 5652:      }
    #####: 5653:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 5654:      {
        -: 5655:        const ecma_compiled_code_t *bytecode_p;
    #####: 5656:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
        -: 5657:
    #####: 5658:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5659:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5660:
    #####: 5661:        if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -: 5662:        {
    #####: 5663:          uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####: 5664:          uint8_t extended_info = *extended_info_p;
        -: 5665:
        -: 5666:#if JERRY_ESNEXT
    #####: 5667:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -: 5668:          {
    #####: 5669:            ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5670:          }
        -: 5671:#endif /* JERRY_ESNEXT */
        -: 5672:
    #####: 5673:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 5674:          {
    #####: 5675:            ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5676:
    #####: 5677:            ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5678:
    #####: 5679:            source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5680:            source_info.source_code = function_arguments;
    #####: 5681:            script_p = NULL;
        -: 5682:          }
        -: 5683:
    #####: 5684:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_RANGE;
    #####: 5685:          source_info.source_range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####: 5686:          source_info.source_range_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5687:        }
        -: 5688:
        -: 5689:        JERRY_ASSERT (script_p != NULL || (source_info.enabled_fields & JERRY_SOURCE_INFO_HAS_SOURCE_CODE));
        -: 5690:
    #####: 5691:        if (source_info.enabled_fields == 0 && (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -: 5692:        {
    #####: 5693:          ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5694:
    #####: 5695:          ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5696:
    #####: 5697:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_FUNCTION_ARGUMENTS;
    #####: 5698:          source_info.function_arguments = function_arguments;
        -: 5699:        }
        -: 5700:        break;
        -: 5701:      }
    #####: 5702:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 5703:      {
    #####: 5704:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 5705:
    #####: 5706:        object_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -: 5707:                                                               ext_object_p->u.bound_function.target_function);
    #####: 5708:        continue;
        -: 5709:      }
        -: 5710:#if JERRY_ESNEXT
    #####: 5711:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 5712:      {
    #####: 5713:        ecma_value_t script_value = ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
    #####: 5714:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5715:        break;
        -: 5716:      }
        -: 5717:#endif /* JERRY_ESNEXT */
        -: 5718:      default:
        -: 5719:      {
        -: 5720:        return NULL;
        -: 5721:      }
        -: 5722:    }
        -: 5723:
        -: 5724:    break;
        -: 5725:  }
        -: 5726:
    #####: 5727:  jerry_source_info_t *source_info_p = jmem_heap_alloc_block_null_on_error (sizeof (jerry_source_info_t));
        -: 5728:
    #####: 5729:  if (source_info_p == NULL)
        -: 5730:  {
        -: 5731:    return NULL;
        -: 5732:  }
        -: 5733:
    #####: 5734:  if (script_p != NULL)
        -: 5735:  {
    #####: 5736:    ecma_ref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 5737:
    #####: 5738:    source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5739:    source_info.source_code = script_p->source_code;
        -: 5740:  }
        -: 5741:
        -: 5742:  JERRY_ASSERT (source_info.enabled_fields != 0);
        -: 5743:
    #####: 5744:  *source_info_p = source_info;
    #####: 5745:  return source_info_p;
        -: 5746:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5747:  JERRY_UNUSED (value);
    #####: 5748:  return NULL;
        -: 5749:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 5750:} /* jerry_get_source_info */
        -: 5751:
        -: 5752:/**
        -: 5753: * Frees the the source info structure returned by jerry_get_source_info.
        -: 5754: */
        -: 5755:void
    #####: 5756:jerry_free_source_info (jerry_source_info_t *source_info_p) /**< source info block */
        -: 5757:{
        -: 5758:  jerry_assert_api_available ();
        -: 5759:
        -: 5760:#if JERRY_FUNCTION_TO_STRING
    #####: 5761:  if (source_info_p != NULL)
        -: 5762:  {
    #####: 5763:    ecma_free_value (source_info_p->source_code);
    #####: 5764:    ecma_free_value (source_info_p->function_arguments);
    #####: 5765:    jmem_heap_free_block (source_info_p, sizeof (jerry_source_info_t));
        -: 5766:  }
        -: 5767:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5768:  JERRY_UNUSED (source_info_p);
        -: 5769:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 5770:} /* jerry_free_source_info */
        -: 5771:
        -: 5772:/**
        -: 5773: * Replaces the currently active realm with another realm.
        -: 5774: *
        -: 5775: * The replacement should be temporary, and the original realm must be
        -: 5776: * restored after the tasks are completed. During the replacement, the
        -: 5777: * realm must be referenced by the application (i.e. the gc must not
        -: 5778: * reclaim it). This is also true to the returned previously active
        -: 5779: * realm, so there is no need to free the value after the restoration.
        -: 5780: *
        -: 5781: * @return previous realm value - if the passed value is a realm
        -: 5782: *         exception - otherwise
        -: 5783: */
        -: 5784:jerry_value_t
    #####: 5785:jerry_set_realm (jerry_value_t realm_value) /**< jerry api value */
        -: 5786:{
        -: 5787:  jerry_assert_api_available ();
        -: 5788:
        -: 5789:#if JERRY_BUILTIN_REALMS
    #####: 5790:  if (ecma_is_value_object (realm_value))
        -: 5791:  {
    #####: 5792:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5793:
    #####: 5794:    if (ecma_builtin_is_global (object_p))
        -: 5795:    {
    #####: 5796:      ecma_global_object_t *previous_global_object_p = JERRY_CONTEXT (global_object_p);
    #####: 5797:      JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) object_p;
    #####: 5798:      return ecma_make_object_value ((ecma_object_t *) previous_global_object_p);
        -: 5799:    }
        -: 5800:  }
        -: 5801:
    #####: 5802:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5803:#else /* !JERRY_BUILTIN_REALMS */
        -: 5804:  JERRY_UNUSED (realm_value);
    #####: 5805:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5806:#endif /* JERRY_BUILTIN_REALMS */
        -: 5807:} /* jerry_set_realm */
        -: 5808:
        -: 5809:/**
        -: 5810: * Gets the 'this' binding of a realm
        -: 5811: *
        -: 5812: * @return type error - if realm_value is not a realm
        -: 5813: *         this value - otherwise
        -: 5814: */
        -: 5815:jerry_value_t
    #####: 5816:jerry_realm_get_this (jerry_value_t realm_value) /**< realm value */
        -: 5817:{
        -: 5818:  jerry_assert_api_available ();
        -: 5819:
        -: 5820:#if JERRY_BUILTIN_REALMS
    #####: 5821:  if (ecma_is_value_object (realm_value))
        -: 5822:  {
    #####: 5823:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5824:
    #####: 5825:    if (ecma_builtin_is_global (object_p))
        -: 5826:    {
    #####: 5827:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -: 5828:
    #####: 5829:      ecma_ref_object (ecma_get_object_from_value (global_object_p->this_binding));
    #####: 5830:      return global_object_p->this_binding;
        -: 5831:    }
        -: 5832:  }
        -: 5833:
        -: 5834:#else /* !JERRY_BUILTIN_REALMS */
    #####: 5835:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 5836:
    #####: 5837:  if (realm_value == ecma_make_object_value (global_object_p))
        -: 5838:  {
    #####: 5839:    ecma_ref_object (global_object_p);
    #####: 5840:    return realm_value;
        -: 5841:  }
        -: 5842:#endif /* JERRY_BUILTIN_REALMS */
        -: 5843:
    #####: 5844:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5845:} /* jerry_realm_get_this */
        -: 5846:
        -: 5847:/**
        -: 5848: * Sets the 'this' binding of a realm
        -: 5849: *
        -: 5850: * This function must be called before executing any script on the realm.
        -: 5851: * Otherwise the operation is undefined.
        -: 5852: *
        -: 5853: * @return type error - if realm_value is not a realm or this_value is not object
        -: 5854: *         true - otherwise
        -: 5855: */
        -: 5856:jerry_value_t
    #####: 5857:jerry_realm_set_this (jerry_value_t realm_value, /**< realm value */
        -: 5858:                      jerry_value_t this_value) /**< this value */
        -: 5859:{
        -: 5860:  jerry_assert_api_available ();
        -: 5861:
        -: 5862:#if JERRY_BUILTIN_REALMS
    #####: 5863:  if (!ecma_is_value_object (this_value))
        -: 5864:  {
    #####: 5865:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Second argument must be an object")));
        -: 5866:  }
        -: 5867:
    #####: 5868:  if (ecma_is_value_object (realm_value))
        -: 5869:  {
    #####: 5870:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5871:
    #####: 5872:    if (ecma_builtin_is_global (object_p))
        -: 5873:    {
    #####: 5874:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
    #####: 5875:      global_object_p->this_binding = this_value;
        -: 5876:
    #####: 5877:      ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, ecma_get_object_from_value (this_value));
        -: 5878:
    #####: 5879:      ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -: 5880:#if JERRY_ESNEXT
    #####: 5881:      global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -: 5882:#endif /* JERRY_ESNEXT */
    #####: 5883:      ecma_deref_object (global_lex_env_p);
    #####: 5884:      return ECMA_VALUE_TRUE;
        -: 5885:    }
        -: 5886:  }
        -: 5887:
    #####: 5888:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("First argument is not a realm")));
        -: 5889:#else /* !JERRY_BUILTIN_REALMS */
        -: 5890:  JERRY_UNUSED (realm_value);
        -: 5891:  JERRY_UNUSED (this_value);
    #####: 5892:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5893:#endif /* JERRY_BUILTIN_REALMS */
        -: 5894:} /* jerry_realm_set_this */
        -: 5895:
        -: 5896:/**
        -: 5897: * Check if the given value is an ArrayBuffer object.
        -: 5898: *
        -: 5899: * @return true - if it is an ArrayBuffer object
        -: 5900: *         false - otherwise
        -: 5901: */
        -: 5902:bool
    #####: 5903:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 5904:{
        -: 5905:  jerry_assert_api_available ();
        -: 5906:
        -: 5907:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5908:  return ecma_is_arraybuffer (value);
        -: 5909:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5910:  JERRY_UNUSED (value);
    #####: 5911:  return false;
        -: 5912:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5913:} /* jerry_value_is_arraybuffer */
        -: 5914:
        -: 5915:/**
        -: 5916: * Creates an ArrayBuffer object with the given length (size).
        -: 5917: *
        -: 5918: * Notes:
        -: 5919: *      * the length is specified in bytes.
        -: 5920: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5921: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5922: *
        -: 5923: * @return value of the constructed ArrayBuffer object
        -: 5924: */
        -: 5925:jerry_value_t
    #####: 5926:jerry_create_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 5927:                                                      *   for the array buffer in bytes */
        -: 5928:{
        -: 5929:  jerry_assert_api_available ();
        -: 5930:
        -: 5931:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5932:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 5933:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5934:  JERRY_UNUSED (size);
    #####: 5935:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5936:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5937:} /* jerry_create_arraybuffer */
        -: 5938:
        -: 5939:/**
        -: 5940: * Creates an ArrayBuffer object with user specified buffer.
        -: 5941: *
        -: 5942: * Notes:
        -: 5943: *     * the size is specified in bytes.
        -: 5944: *     * the buffer passed should be at least the specified bytes big.
        -: 5945: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5946: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 5947: *
        -: 5948: * @return value of the newly construced array buffer object
        -: 5949: */
        -: 5950:jerry_value_t
    #####: 5951:jerry_create_arraybuffer_external (const jerry_length_t size, /**< size of the buffer in bytes */
        -: 5952:                                   uint8_t *buffer_p, /**< the backing store used by the array buffer object */
        -: 5953:                                   void *arraybuffer_user_p) /**< user pointer assigned to the array buffer object */
        -: 5954:{
        -: 5955:  jerry_assert_api_available ();
        -: 5956:
        -: 5957:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5958:  ecma_object_t *arraybuffer_p;
        -: 5959:
    #####: 5960:  if (JERRY_UNLIKELY (size == 0))
        -: 5961:  {
    #####: 5962:    arraybuffer_p = ecma_arraybuffer_new_object (0);
        -: 5963:  }
        -: 5964:  else
        -: 5965:  {
    #####: 5966:    arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_ARRAY_BUFFER, size);
        -: 5967:
    #####: 5968:    ecma_arraybuffer_pointer_t *arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) arraybuffer_p;
    #####: 5969:    arraybuffer_pointer_p->arraybuffer_user_p = arraybuffer_user_p;
        -: 5970:
    #####: 5971:    if (buffer_p != NULL)
        -: 5972:    {
    #####: 5973:      arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 5974:      arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 5975:    }
        -: 5976:  }
        -: 5977:
    #####: 5978:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 5979:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5980:  JERRY_UNUSED (size);
        -: 5981:  JERRY_UNUSED (buffer_p);
        -: 5982:  JERRY_UNUSED (arraybuffer_user_p);
    #####: 5983:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5984:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5985:} /* jerry_create_arraybuffer_external */
        -: 5986:
        -: 5987:/**
        -: 5988: * Check if the given value is a SharedArrayBuffer object.
        -: 5989: *
        -: 5990: * @return true - if it is a SharedArrayBuffer object
        -: 5991: *         false - otherwise
        -: 5992: */
        -: 5993:bool
    #####: 5994:jerry_value_is_shared_arraybuffer (const jerry_value_t value) /**< value to check if it is a SharedArrayBuffer */
        -: 5995:{
        -: 5996:  jerry_assert_api_available ();
        -: 5997:
    #####: 5998:  return ecma_is_shared_arraybuffer (value);
        -: 5999:} /* jerry_value_is_shared_arraybuffer */
        -: 6000:
        -: 6001:/**
        -: 6002: * Creates a SharedArrayBuffer object with the given length (size).
        -: 6003: *
        -: 6004: * Notes:
        -: 6005: *      * the length is specified in bytes.
        -: 6006: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 6007: *      * if the typed arrays are disabled this will return a TypeError.
        -: 6008: *
        -: 6009: * @return value of the constructed SharedArrayBuffer object
        -: 6010: */
        -: 6011:jerry_value_t
    #####: 6012:jerry_create_shared_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 6013:                                                             *   for the shared array buffer in bytes */
        -: 6014:{
        -: 6015:  jerry_assert_api_available ();
        -: 6016:
        -: 6017:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 6018:  return jerry_return (ecma_make_object_value (ecma_shared_arraybuffer_new_object (size)));
        -: 6019:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6020:  JERRY_UNUSED (size);
    #####: 6021:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 6022:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6023:} /* jerry_create_shared_arraybuffer */
        -: 6024:
        -: 6025:/**
        -: 6026: * Creates a SharedArrayBuffer object with user specified buffer.
        -: 6027: *
        -: 6028: * Notes:
        -: 6029: *     * the size is specified in bytes.
        -: 6030: *     * the buffer passed should be at least the specified bytes big.
        -: 6031: *     * if the typed arrays are disabled this will return a TypeError.
        -: 6032: *     * if the size is zero or buffer_p is a null pointer this will return an empty SharedArrayBuffer.
        -: 6033: *
        -: 6034: * @return value of the newly construced shared array buffer object
        -: 6035: */
        -: 6036:jerry_value_t
    #####: 6037:jerry_create_shared_arraybuffer_external (const jerry_length_t size, /**< size of the buffer in bytes */
        -: 6038:                                          uint8_t *buffer_p, /**< the backing store used by the
        -: 6039:                                                              *   shared array buffer object */
        -: 6040:                                          void *arraybuffer_user_p) /**< user pointer assigned to the
        -: 6041:                                                                     *   shared array buffer object */
        -: 6042:{
        -: 6043:  jerry_assert_api_available ();
        -: 6044:
        -: 6045:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 6046:  ecma_object_t *shared_arraybuffer_p;
        -: 6047:
    #####: 6048:  if (JERRY_UNLIKELY (size == 0))
        -: 6049:  {
    #####: 6050:    shared_arraybuffer_p = ecma_shared_arraybuffer_new_object (0);
        -: 6051:  }
        -: 6052:  else
        -: 6053:  {
    #####: 6054:    shared_arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER, size);
        -: 6055:
    #####: 6056:    ecma_arraybuffer_pointer_t *shared_arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) shared_arraybuffer_p;
    #####: 6057:    shared_arraybuffer_pointer_p->arraybuffer_user_p = arraybuffer_user_p;
        -: 6058:
    #####: 6059:    if (buffer_p != NULL)
        -: 6060:    {
    #####: 6061:      shared_arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 6062:      shared_arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 6063:    }
        -: 6064:  }
        -: 6065:
    #####: 6066:  return jerry_return (ecma_make_object_value (shared_arraybuffer_p));
        -: 6067:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6068:  JERRY_UNUSED (size);
        -: 6069:  JERRY_UNUSED (buffer_p);
        -: 6070:  JERRY_UNUSED (arraybuffer_user_p);
    #####: 6071:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 6072:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6073:} /* jerry_create_shared_arraybuffer_external */
        -: 6074:
        -: 6075:/**
        -: 6076: * Copy bytes into the ArrayBuffer or SharedArrayBuffer from a buffer.
        -: 6077: *
        -: 6078: * Note:
        -: 6079: *     * returns 0, if the passed object is not an ArrayBuffer or SharedArrayBuffer
        -: 6080: *
        -: 6081: * @return number of bytes copied into the ArrayBuffer or SharedArrayBuffer.
        -: 6082: */
        -: 6083:jerry_length_t
    #####: 6084:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer or SharedArrayBuffer */
        -: 6085:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 6086:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 6087:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 6088:{
        -: 6089:  jerry_assert_api_available ();
        -: 6090:
        -: 6091:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6092:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6093:  {
    #####: 6094:    return 0;
        -: 6095:  }
        -: 6096:
    #####: 6097:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
        -: 6098:
    #####: 6099:  if (ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (buffer_p))
        -: 6100:  {
    #####: 6101:    jerry_release_value (jcontext_take_exception ());
    #####: 6102:    return 0;
        -: 6103:  }
        -: 6104:
    #####: 6105:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6106:
    #####: 6107:  if (offset >= length)
        -: 6108:  {
    #####: 6109:    return 0;
        -: 6110:  }
        -: 6111:
    #####: 6112:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6113:
    #####: 6114:  if (copy_count > 0)
        -: 6115:  {
    #####: 6116:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6117:
    #####: 6118:    memcpy ((void *) (mem_buffer_p + offset), (void *) buf_p, copy_count);
        -: 6119:  }
        -: 6120:
    #####: 6121:  return copy_count;
        -: 6122:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6123:  JERRY_UNUSED (value);
        -: 6124:  JERRY_UNUSED (offset);
        -: 6125:  JERRY_UNUSED (buf_p);
        -: 6126:  JERRY_UNUSED (buf_size);
    #####: 6127:  return 0;
        -: 6128:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6129:} /* jerry_arraybuffer_write */
        -: 6130:
        -: 6131:/**
        -: 6132: * Copy bytes from a buffer into an ArrayBuffer or SharedArrayBuffer.
        -: 6133: *
        -: 6134: * Note:
        -: 6135: *     * if the object passed is not an ArrayBuffer or SharedArrayBuffer will return 0.
        -: 6136: *
        -: 6137: * @return number of bytes read from the ArrayBuffer.
        -: 6138: */
        -: 6139:jerry_length_t
    #####: 6140:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer or SharedArrayBuffer to read from */
        -: 6141:                        jerry_length_t offset, /**< start offset of the ArrayBuffer or SharedArrayBuffer */
        -: 6142:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 6143:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 6144:{
        -: 6145:  jerry_assert_api_available ();
        -: 6146:
        -: 6147:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6148:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6149:  {
    #####: 6150:    return 0;
        -: 6151:  }
        -: 6152:
    #####: 6153:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
        -: 6154:
    #####: 6155:  if (ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (buffer_p))
        -: 6156:  {
    #####: 6157:    jerry_release_value (jcontext_take_exception ());
    #####: 6158:    return 0;
        -: 6159:  }
        -: 6160:
    #####: 6161:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6162:
    #####: 6163:  if (offset >= length)
        -: 6164:  {
    #####: 6165:    return 0;
        -: 6166:  }
        -: 6167:
    #####: 6168:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6169:
    #####: 6170:  if (copy_count > 0)
        -: 6171:  {
    #####: 6172:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6173:
    #####: 6174:    memcpy ((void *) buf_p, (void *) (mem_buffer_p + offset), copy_count);
        -: 6175:  }
        -: 6176:
    #####: 6177:  return copy_count;
        -: 6178:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6179:  JERRY_UNUSED (value);
        -: 6180:  JERRY_UNUSED (offset);
        -: 6181:  JERRY_UNUSED (buf_p);
        -: 6182:  JERRY_UNUSED (buf_size);
    #####: 6183:  return 0;
        -: 6184:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6185:} /* jerry_arraybuffer_read */
        -: 6186:
        -: 6187:/**
        -: 6188: * Get the length (size) of the ArrayBuffer or SharedArrayBuffer in bytes.
        -: 6189: *
        -: 6190: * Note:
        -: 6191: *     This is the 'byteLength' property of an ArrayBuffer or SharedArrayBuffer.
        -: 6192: *
        -: 6193: * @return the length of the ArrayBuffer in bytes.
        -: 6194: */
        -: 6195:jerry_length_t
    #####: 6196:jerry_get_arraybuffer_byte_length (const jerry_value_t value) /**< ArrayBuffer or SharedArrayBuffer */
        -: 6197:{
        -: 6198:  jerry_assert_api_available ();
        -: 6199:
        -: 6200:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6201:  if (ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value))
        -: 6202:  {
    #####: 6203:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6204:    return ecma_arraybuffer_get_length (buffer_p);
        -: 6205:  }
        -: 6206:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6207:  JERRY_UNUSED (value);
        -: 6208:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6209:  return 0;
        -: 6210:} /* jerry_get_arraybuffer_byte_length */
        -: 6211:
        -: 6212:/**
        -: 6213: * Get a pointer for the start of the ArrayBuffer.
        -: 6214: *
        -: 6215: * Note:
        -: 6216: *    * This is a high-risk operation as the bounds are not checked
        -: 6217: *      when accessing the pointer elements.
        -: 6218: *
        -: 6219: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 6220: *         pointer is NULL if:
        -: 6221: *            - the parameter is not an ArrayBuffer
        -: 6222: *            - an external ArrayBuffer has been detached
        -: 6223: */
        -: 6224:uint8_t *
    #####: 6225:jerry_get_arraybuffer_pointer (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 6226:{
        -: 6227:  jerry_assert_api_available ();
        -: 6228:
        -: 6229:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6230:  if (!(ecma_is_arraybuffer (array_buffer) || ecma_is_shared_arraybuffer (array_buffer)))
        -: 6231:  {
    #####: 6232:    return NULL;
        -: 6233:  }
        -: 6234:
    #####: 6235:  ecma_object_t *buffer_p = ecma_get_object_from_value (array_buffer);
        -: 6236:
    #####: 6237:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (buffer_p) & ECMA_ARRAYBUFFER_ALLOCATED))
        -: 6238:  {
    #####: 6239:    return NULL;
        -: 6240:  }
        -: 6241:
    #####: 6242:  return (uint8_t *) ecma_arraybuffer_get_buffer (buffer_p);
        -: 6243:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6244:  JERRY_UNUSED (array_buffer);
        -: 6245:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6246:
    #####: 6247:  return NULL;
        -: 6248:} /* jerry_get_arraybuffer_pointer */
        -: 6249:
        -: 6250:/**
        -: 6251: * Get if the ArrayBuffer is detachable.
        -: 6252: *
        -: 6253: * @return boolean value - if success
        -: 6254: *         value marked with error flag - otherwise
        -: 6255: */
        -: 6256:jerry_value_t
    #####: 6257:jerry_is_arraybuffer_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 6258:{
        -: 6259:  jerry_assert_api_available ();
        -: 6260:
        -: 6261:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6262:  if (ecma_is_arraybuffer (value))
        -: 6263:  {
    #####: 6264:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6265:    return ecma_make_boolean_value (!ecma_arraybuffer_is_detached (buffer_p));
        -: 6266:  }
        -: 6267:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6268:  JERRY_UNUSED (value);
        -: 6269:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6270:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6271:} /* jerry_is_arraybuffer_detachable */
        -: 6272:
        -: 6273:/**
        -: 6274: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 6275: *
        -: 6276: * Note: if the ArrayBuffer has a separate data buffer, the free callback set by
        -: 6277: *       jerry_arraybuffer_set_allocation_callbacks is called for this buffer
        -: 6278: *
        -: 6279: * @return null value - if success
        -: 6280: *         value marked with error flag - otherwise
        -: 6281: */
        -: 6282:jerry_value_t
    #####: 6283:jerry_detach_arraybuffer (const jerry_value_t value) /**< ArrayBuffer */
        -: 6284:{
        -: 6285:  jerry_assert_api_available ();
        -: 6286:
        -: 6287:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6288:  if (ecma_is_arraybuffer (value))
        -: 6289:  {
    #####: 6290:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6291:    if (ecma_arraybuffer_detach (buffer_p))
        -: 6292:    {
    #####: 6293:      return ECMA_VALUE_NULL;
        -: 6294:    }
    #####: 6295:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has already been detached")));
        -: 6296:  }
        -: 6297:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6298:  JERRY_UNUSED (value);
        -: 6299:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6300:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6301:} /* jerry_detach_arraybuffer */
        -: 6302:
        -: 6303:/**
        -: 6304: * Checks whether a buffer is currently allocated for an array buffer or typed array.
        -: 6305: *
        -: 6306: * @return true, if a buffer is allocated for an array buffer or typed array
        -: 6307: *         false, otherwise
        -: 6308: */
        -: 6309:bool
    #####: 6310:jerry_arraybuffer_has_buffer (const jerry_value_t value) /**< array buffer or typed array value */
        -: 6311:{
        -: 6312:  jerry_assert_api_available ();
        -: 6313:
        -: 6314:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6315:  if (!ecma_is_value_object (value))
        -: 6316:  {
    #####: 6317:    return false;
        -: 6318:  }
        -: 6319:
    #####: 6320:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 6321:
    #####: 6322:  if (ecma_object_is_typedarray (object_p))
        -: 6323:  {
    #####: 6324:    object_p = ecma_typedarray_get_arraybuffer (object_p);
        -: 6325:  }
    #####: 6326:  else if (!(ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####: 6327:             || ecma_object_is_shared_arraybuffer (object_p)))
        -: 6328:  {
    #####: 6329:    return false;
        -: 6330:  }
        -: 6331:
    #####: 6332:  return (ECMA_ARRAYBUFFER_GET_FLAGS (object_p) & ECMA_ARRAYBUFFER_ALLOCATED) != 0;
        -: 6333:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6334:  JERRY_UNUSED (value);
    #####: 6335:  return false;
        -: 6336:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6337:} /* jerry_arraybuffer_has_buffer */
        -: 6338:
        -: 6339:/**
        -: 6340: * Array buffers which size is less or equal than the limit passed to this function are allocated in
        -: 6341: * a single memory block. The allocator callbacks set by jerry_arraybuffer_set_allocation_callbacks
        -: 6342: * are not called for these array buffers. The default limit is 256 bytes.
        -: 6343: */
        -: 6344:void
    #####: 6345:jerry_arraybuffer_set_compact_allocation_limit (const jerry_length_t allocation_limit) /**< maximum size of
        -: 6346:                                                                                        *   compact allocation */
        -: 6347:{
        -: 6348:  jerry_assert_api_available ();
        -: 6349:
        -: 6350:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6351:  JERRY_CONTEXT (arraybuffer_compact_allocation_limit) = allocation_limit;
        -: 6352:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6353:  JERRY_UNUSED (allocation_limit);
        -: 6354:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6355:} /* jerry_arraybuffer_set_compact_allocation_limit */
        -: 6356:
        -: 6357:/**
        -: 6358: * Set callbacks for allocating and freeing backing stores for array buffer objects.
        -: 6359: */
        -: 6360:void
    #####: 6361:jerry_arraybuffer_set_allocator_callbacks (jerry_arraybuffer_allocate_t allocate_callback, /**< callback for allocating
        -: 6362:                                                                                            *   array buffer memory */
        -: 6363:                                           jerry_arraybuffer_free_t free_callback, /**< callback for freeing
        -: 6364:                                                                                    *   array buffer memory */
        -: 6365:                                           void *user_p) /**< user pointer passed to the callbacks */
        -: 6366:{
        -: 6367:  jerry_assert_api_available ();
        -: 6368:
        -: 6369:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6370:  JERRY_CONTEXT (arraybuffer_allocate_callback) = allocate_callback;
    #####: 6371:  JERRY_CONTEXT (arraybuffer_free_callback) = free_callback;
    #####: 6372:  JERRY_CONTEXT (arraybuffer_allocate_callback_user_p) = user_p;
        -: 6373:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6374:  JERRY_UNUSED (allocate_callback);
        -: 6375:  JERRY_UNUSED (free_callback);
        -: 6376:  JERRY_UNUSED (user_p);
        -: 6377:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6378:} /* jerry_arraybuffer_set_allocator_callbacks */
        -: 6379:
        -: 6380:/**
        -: 6381: * DataView related functions
        -: 6382: */
        -: 6383:
        -: 6384:/**
        -: 6385: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 6386: *
        -: 6387: * Notes:
        -: 6388: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 6389: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 6390: *
        -: 6391: * @return value of the constructed DataView object - if success
        -: 6392: *         created error - otherwise
        -: 6393: */
        -: 6394:jerry_value_t
    #####: 6395:jerry_create_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 6396:                       const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 6397:                       const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 6398:{
        -: 6399:  jerry_assert_api_available ();
        -: 6400:
        -: 6401:#if JERRY_BUILTIN_DATAVIEW
    #####: 6402:  if (ecma_is_value_error_reference (array_buffer))
        -: 6403:  {
    #####: 6404:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6405:  }
        -: 6406:
    #####: 6407:  ecma_value_t arguments_p[3] =
        -: 6408:  {
        -: 6409:    array_buffer,
    #####: 6410:    ecma_make_uint32_value (byte_offset),
    #####: 6411:    ecma_make_uint32_value (byte_length)
        -: 6412:  };
    #####: 6413:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
    #####: 6414:  if (old_new_target_p == NULL)
        -: 6415:  {
    #####: 6416:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ECMA_BUILTIN_ID_DATAVIEW);
        -: 6417:  }
        -: 6418:
    #####: 6419:  ecma_value_t dataview_value = ecma_op_dataview_create (arguments_p, 3);
    #####: 6420:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6421:  return jerry_return (dataview_value);
        -: 6422:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6423:  JERRY_UNUSED (array_buffer);
        -: 6424:  JERRY_UNUSED (byte_offset);
        -: 6425:  JERRY_UNUSED (byte_length);
    #####: 6426:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6427:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6428:} /* jerry_create_dataview */
        -: 6429:
        -: 6430:/**
        -: 6431: * Check if the given value is a DataView object.
        -: 6432: *
        -: 6433: * @return true - if it is a DataView object
        -: 6434: *         false - otherwise
        -: 6435: */
        -: 6436:bool
    #####: 6437:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 6438:{
        -: 6439:  jerry_assert_api_available ();
        -: 6440:
        -: 6441:#if JERRY_BUILTIN_DATAVIEW
    #####: 6442:  return ecma_is_dataview (value);
        -: 6443:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6444:  JERRY_UNUSED (value);
    #####: 6445:  return false;
        -: 6446:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6447:} /* jerry_value_is_dataview */
        -: 6448:
        -: 6449:/**
        -: 6450: * Get the underlying ArrayBuffer from a DataView.
        -: 6451: *
        -: 6452: * Additionally the byteLength and byteOffset properties are also returned
        -: 6453: * which were specified when the DataView was created.
        -: 6454: *
        -: 6455: * Note:
        -: 6456: *     the returned value must be freed with a jerry_release_value call
        -: 6457: *
        -: 6458: * @return ArrayBuffer of a DataView
        -: 6459: *         TypeError if the object is not a DataView.
        -: 6460: */
        -: 6461:jerry_value_t
    #####: 6462:jerry_get_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 6463:                           jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6464:                           jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6465:{
        -: 6466:  jerry_assert_api_available ();
        -: 6467:
        -: 6468:#if JERRY_BUILTIN_DATAVIEW
    #####: 6469:  if (ecma_is_value_error_reference (value))
        -: 6470:  {
    #####: 6471:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6472:  }
        -: 6473:
    #####: 6474:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 6475:
    #####: 6476:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 6477:  {
    #####: 6478:    return ecma_create_error_reference_from_context ();
        -: 6479:  }
        -: 6480:
    #####: 6481:  if (byte_offset != NULL)
        -: 6482:  {
    #####: 6483:    *byte_offset = dataview_p->byte_offset;
        -: 6484:  }
        -: 6485:
    #####: 6486:  if (byte_length != NULL)
        -: 6487:  {
    #####: 6488:    *byte_length = dataview_p->header.u.cls.u3.length;
        -: 6489:  }
        -: 6490:
    #####: 6491:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 6492:  ecma_ref_object (arraybuffer_p);
        -: 6493:
    #####: 6494:  return ecma_make_object_value (arraybuffer_p);
        -: 6495:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6496:  JERRY_UNUSED (value);
        -: 6497:  JERRY_UNUSED (byte_offset);
        -: 6498:  JERRY_UNUSED (byte_length);
    #####: 6499:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6500:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6501:} /* jerry_get_dataview_buffer */
        -: 6502:
        -: 6503:/**
        -: 6504: * TypedArray related functions
        -: 6505: */
        -: 6506:
        -: 6507:/**
        -: 6508: * Check if the given value is a TypedArray object.
        -: 6509: *
        -: 6510: * @return true - if it is a TypedArray object
        -: 6511: *         false - otherwise
        -: 6512: */
        -: 6513:bool
    #####: 6514:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 6515:{
        -: 6516:  jerry_assert_api_available ();
        -: 6517:
        -: 6518:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6519:  return ecma_is_typedarray (value);
        -: 6520:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6521:  JERRY_UNUSED (value);
    #####: 6522:  return false;
        -: 6523:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6524:} /* jerry_value_is_typedarray */
        -: 6525:
        -: 6526:#if JERRY_BUILTIN_TYPEDARRAY
        -: 6527:/**
        -: 6528: * TypedArray mapping type
        -: 6529: */
        -: 6530:typedef struct
        -: 6531:{
        -: 6532:  jerry_typedarray_type_t api_type; /**< api type */
        -: 6533:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 6534:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 6535:  uint8_t element_size_shift; /**< element size shift */
        -: 6536:} jerry_typedarray_mapping_t;
        -: 6537:
        -: 6538:/**
        -: 6539: * List of TypedArray mappings
        -: 6540: */
        -: 6541:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] =
        -: 6542:{
        -: 6543:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT) \
        -: 6544:  { JERRY_TYPEDARRAY_ ## NAME, ECMA_BUILTIN_ID_ ## NAME ## ARRAY_PROTOTYPE, \
        -: 6545:    ECMA_ ## LIT_NAME ## _ARRAY, SIZE_SHIFT }
        -: 6546:
        -: 6547:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),
        -: 6548:  TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 6549:  TYPEDARRAY_ENTRY (INT8, INT8, 0),
        -: 6550:  TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 6551:  TYPEDARRAY_ENTRY (INT16, INT16, 1),
        -: 6552:  TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 6553:  TYPEDARRAY_ENTRY (INT32, INT32, 2),
        -: 6554:  TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 6555:#if JERRY_NUMBER_TYPE_FLOAT64
        -: 6556:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 6557:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 6558:#if JERRY_BUILTIN_BIGINT
        -: 6559:  TYPEDARRAY_ENTRY (BIGINT64, BIGINT64, 3),
        -: 6560:  TYPEDARRAY_ENTRY (BIGUINT64, BIGUINT64, 3),
        -: 6561:#endif /* JERRY_BUILTIN_BIGINT */
        -: 6562:#undef TYPEDARRAY_ENTRY
        -: 6563:};
        -: 6564:
        -: 6565:/**
        -: 6566: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 6567: * information.
        -: 6568: *
        -: 6569: * @return true - if the TypedArray information was found
        -: 6570: *         false - if there is no such TypedArray type
        -: 6571: */
        -: 6572:static bool
    #####: 6573:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 6574:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 6575:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 6576:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 6577:{
    #####: 6578:  JERRY_ASSERT (prototype_id != NULL);
    #####: 6579:  JERRY_ASSERT (id != NULL);
    #####: 6580:  JERRY_ASSERT (element_size_shift != NULL);
        -: 6581:
    #####: 6582:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6583:  {
    #####: 6584:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 6585:    {
    #####: 6586:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 6587:      *id = jerry_typedarray_mappings[i].id;
    #####: 6588:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 6589:      return true;
        -: 6590:    }
        -: 6591:  }
        -: 6592:
    #####: 6593:  return false;
        -: 6594:} /* jerry_typedarray_find_by_type */
        -: 6595:
        -: 6596:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6597:
        -: 6598:/**
        -: 6599: * Create a TypedArray object with a given type and length.
        -: 6600: *
        -: 6601: * Notes:
        -: 6602: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6603: *      * byteOffset property will be set to 0.
        -: 6604: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 6605: *
        -: 6606: * @return - new TypedArray object
        -: 6607: */
        -: 6608:jerry_value_t
    #####: 6609:jerry_create_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6610:                         jerry_length_t length) /**< element count of the new TypedArray */
        -: 6611:{
        -: 6612:  jerry_assert_api_available ();
        -: 6613:
        -: 6614:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6615:  ecma_builtin_id_t prototype_id = 0;
    #####: 6616:  ecma_typedarray_type_t id = 0;
    #####: 6617:  uint8_t element_size_shift = 0;
        -: 6618:
    #####: 6619:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6620:  {
    #####: 6621:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6622:  }
        -: 6623:
    #####: 6624:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 6625:
    #####: 6626:  ecma_value_t array_value = ecma_typedarray_create_object_with_length (length,
        -: 6627:                                                                        NULL,
        -: 6628:                                                                        prototype_obj_p,
        -: 6629:                                                                        element_size_shift,
        -: 6630:                                                                        id);
        -: 6631:
    #####: 6632:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 6633:
    #####: 6634:  return array_value;
        -: 6635:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6636:  JERRY_UNUSED (type_name);
        -: 6637:  JERRY_UNUSED (length);
    #####: 6638:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6639:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6640:} /* jerry_create_typedarray */
        -: 6641:
        -: 6642:/**
        -: 6643: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6644: *
        -: 6645: * Notes:
        -: 6646: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6647: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 6648: *
        -: 6649: * @return - new TypedArray object
        -: 6650: */
        -: 6651:jerry_value_t
    #####: 6652:jerry_create_typedarray_for_arraybuffer_sz (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6653:                                            const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 6654:                                            jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 6655:                                            jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 6656:{
        -: 6657:  jerry_assert_api_available ();
        -: 6658:
        -: 6659:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6660:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6661:  {
    #####: 6662:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6663:  }
        -: 6664:
    #####: 6665:  ecma_builtin_id_t prototype_id = 0;
    #####: 6666:  ecma_typedarray_type_t id = 0;
    #####: 6667:  uint8_t element_size_shift = 0;
        -: 6668:
    #####: 6669:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6670:  {
    #####: 6671:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6672:  }
        -: 6673:
    #####: 6674:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 6675:  {
    #####: 6676:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not an ArrayBuffer")));
        -: 6677:  }
        -: 6678:
    #####: 6679:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 6680:  ecma_value_t arguments_p[3] =
        -: 6681:  {
        -: 6682:    arraybuffer,
    #####: 6683:    ecma_make_uint32_value (byte_offset),
    #####: 6684:    ecma_make_uint32_value (length)
        -: 6685:  };
        -: 6686:
    #####: 6687:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 6688:  ecma_free_value (arguments_p[1]);
    #####: 6689:  ecma_free_value (arguments_p[2]);
        -: 6690:
    #####: 6691:  return jerry_return (array_value);
        -: 6692:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6693:  JERRY_UNUSED (type_name);
        -: 6694:  JERRY_UNUSED (arraybuffer);
        -: 6695:  JERRY_UNUSED (byte_offset);
        -: 6696:  JERRY_UNUSED (length);
    #####: 6697:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6698:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6699:} /* jerry_create_typedarray_for_arraybuffer_sz */
        -: 6700:
        -: 6701:/**
        -: 6702: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6703: *
        -: 6704: * Notes:
        -: 6705: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6706: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 6707: *
        -: 6708: * @return - new TypedArray object
        -: 6709: */
        -: 6710:jerry_value_t
    #####: 6711:jerry_create_typedarray_for_arraybuffer (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6712:                                         const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 6713:{
        -: 6714:  jerry_assert_api_available ();
        -: 6715:
        -: 6716:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6717:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6718:  {
    #####: 6719:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6720:  }
        -: 6721:
    #####: 6722:  jerry_length_t byteLength = jerry_get_arraybuffer_byte_length (arraybuffer);
    #####: 6723:  return jerry_create_typedarray_for_arraybuffer_sz (type_name, arraybuffer, 0, byteLength);
        -: 6724:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6725:  JERRY_UNUSED (type_name);
        -: 6726:  JERRY_UNUSED (arraybuffer);
    #####: 6727:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6728:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6729:} /* jerry_create_typedarray_for_arraybuffer */
        -: 6730:
        -: 6731:/**
        -: 6732: * Get the type of the TypedArray.
        -: 6733: *
        -: 6734: * @return - type of the TypedArray
        -: 6735: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 6736: */
        -: 6737:jerry_typedarray_type_t
    #####: 6738:jerry_get_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 6739:{
        -: 6740:  jerry_assert_api_available ();
        -: 6741:
        -: 6742:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6743:  if (!ecma_is_typedarray (value))
        -: 6744:  {
    #####: 6745:    return JERRY_TYPEDARRAY_INVALID;
        -: 6746:  }
        -: 6747:
    #####: 6748:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6749:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 6750:
    #####: 6751:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6752:  {
    #####: 6753:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 6754:    {
    #####: 6755:      return jerry_typedarray_mappings[i].api_type;
        -: 6756:    }
        -: 6757:  }
        -: 6758:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6759:  JERRY_UNUSED (value);
        -: 6760:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6761:
    #####: 6762:  return JERRY_TYPEDARRAY_INVALID;
        -: 6763:} /* jerry_get_typedarray_type */
        -: 6764:
        -: 6765:/**
        -: 6766: * Get the element count of the TypedArray.
        -: 6767: *
        -: 6768: * @return length of the TypedArray.
        -: 6769: */
        -: 6770:jerry_length_t
    #####: 6771:jerry_get_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 6772:{
        -: 6773:  jerry_assert_api_available ();
        -: 6774:
        -: 6775:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6776:  if (ecma_is_typedarray (value))
        -: 6777:  {
    #####: 6778:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6779:    return ecma_typedarray_get_length (array_p);
        -: 6780:  }
        -: 6781:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6782:  JERRY_UNUSED (value);
        -: 6783:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6784:
    #####: 6785:  return 0;
        -: 6786:} /* jerry_get_typedarray_length */
        -: 6787:
        -: 6788:/**
        -: 6789: * Get the underlying ArrayBuffer from a TypedArray.
        -: 6790: *
        -: 6791: * Additionally the byteLength and byteOffset properties are also returned
        -: 6792: * which were specified when the TypedArray was created.
        -: 6793: *
        -: 6794: * Note:
        -: 6795: *     the returned value must be freed with a jerry_release_value call
        -: 6796: *
        -: 6797: * @return ArrayBuffer of a TypedArray
        -: 6798: *         TypeError if the object is not a TypedArray.
        -: 6799: */
        -: 6800:jerry_value_t
    #####: 6801:jerry_get_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 6802:                             jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6803:                             jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6804:{
        -: 6805:  jerry_assert_api_available ();
        -: 6806:
        -: 6807:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6808:  if (!ecma_is_typedarray (value))
        -: 6809:  {
    #####: 6810:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Object is not a TypedArray")));
        -: 6811:  }
        -: 6812:
    #####: 6813:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6814:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 6815:
    #####: 6816:  if (byte_length != NULL)
        -: 6817:  {
    #####: 6818:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 6819:  }
        -: 6820:
    #####: 6821:  if (byte_offset != NULL)
        -: 6822:  {
    #####: 6823:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 6824:  }
        -: 6825:
    #####: 6826:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 6827:  ecma_ref_object (arraybuffer_p);
    #####: 6828:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 6829:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6830:  JERRY_UNUSED (value);
        -: 6831:  JERRY_UNUSED (byte_length);
        -: 6832:  JERRY_UNUSED (byte_offset);
    #####: 6833:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6834:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6835:} /* jerry_get_typedarray_buffer */
        -: 6836:
        -: 6837:/**
        -: 6838: * Parse the given JSON string to create a jerry_value_t.
        -: 6839: *
        -: 6840: * The behaviour is equivalent with the "JSON.parse(string)" JS call.
        -: 6841: *
        -: 6842: * Note:
        -: 6843: *      The returned value must be freed with jerry_release_value.
        -: 6844: *
        -: 6845: * @return - jerry_value_t containing a JavaScript value.
        -: 6846: *         - Error value if there was problems during the parse.
        -: 6847: */
        -: 6848:jerry_value_t
    #####: 6849:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 6850:                  jerry_size_t string_size) /**< json string size */
        -: 6851:{
        -: 6852:  jerry_assert_api_available ();
        -: 6853:
        -: 6854:#if JERRY_BUILTIN_JSON
    #####: 6855:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 6856:
    #####: 6857:  if (ecma_is_value_undefined (ret_value))
        -: 6858:  {
    #####: 6859:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON string parse error")));
        -: 6860:  }
        -: 6861:
    #####: 6862:  return jerry_return (ret_value);
        -: 6863:#else /* !JERRY_BUILTIN_JSON */
        -: 6864:  JERRY_UNUSED (string_p);
        -: 6865:  JERRY_UNUSED (string_size);
        -: 6866:
        -: 6867:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6868:#endif /* JERRY_BUILTIN_JSON */
        -: 6869:} /* jerry_json_parse */
        -: 6870:
        -: 6871:/**
        -: 6872: * Create a JSON string from a JavaScript value.
        -: 6873: *
        -: 6874: * The behaviour is equivalent with the "JSON.stringify(input_value)" JS call.
        -: 6875: *
        -: 6876: * Note:
        -: 6877: *      The returned value must be freed with jerry_release_value,
        -: 6878: *
        -: 6879: * @return - jerry_value_t containing a JSON string.
        -: 6880: *         - Error value if there was a problem during the stringification.
        -: 6881: */
        -: 6882:jerry_value_t
    #####: 6883:jerry_json_stringify (const jerry_value_t input_value) /**< a value to stringify */
        -: 6884:{
        -: 6885:  jerry_assert_api_available ();
        -: 6886:#if JERRY_BUILTIN_JSON
    #####: 6887:  if (ecma_is_value_error_reference (input_value))
        -: 6888:  {
    #####: 6889:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6890:  }
        -: 6891:
    #####: 6892:  ecma_value_t ret_value = ecma_builtin_json_stringify_no_opts (input_value);
        -: 6893:
    #####: 6894:  if (ecma_is_value_undefined (ret_value))
        -: 6895:  {
    #####: 6896:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON stringify error")));
        -: 6897:  }
        -: 6898:
    #####: 6899:  return jerry_return (ret_value);
        -: 6900:#else /* JERRY_BUILTIN_JSON */
        -: 6901:  JERRY_UNUSED (input_value);
        -: 6902:
        -: 6903:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6904:#endif /* JERRY_BUILTIN_JSON */
        -: 6905:} /* jerry_json_stringify */
        -: 6906:
        -: 6907:/**
        -: 6908: * Create a container type specified in jerry_container_type_t.
        -: 6909: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 6910: * inserted to the container.
        -: 6911: *
        -: 6912: * Note:
        -: 6913: *      The returned value must be freed with jerry_release_value
        -: 6914: * @return jerry_value_t representing a container with the given type.
        -: 6915: */
        -: 6916:jerry_value_t
    #####: 6917:jerry_create_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 6918:                        const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 6919:                        jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 6920:{
        -: 6921:  jerry_assert_api_available ();
        -: 6922:
        -: 6923:#if JERRY_BUILTIN_CONTAINER
    #####: 6924:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 6925:  {
    #####: 6926:    if (ecma_is_value_error_reference (arguments_list_p[i]))
        -: 6927:    {
    #####: 6928:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6929:    }
        -: 6930:  }
        -: 6931:
        -: 6932:  lit_magic_string_id_t lit_id;
        -: 6933:  ecma_builtin_id_t proto_id;
        -: 6934:  ecma_builtin_id_t ctor_id;
        -: 6935:
    #####: 6936:  switch (container_type)
        -: 6937:  {
    #####: 6938:    case JERRY_CONTAINER_TYPE_MAP:
        -: 6939:    {
    #####: 6940:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 6941:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 6942:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 6943:      break;
        -: 6944:    }
    #####: 6945:    case JERRY_CONTAINER_TYPE_SET:
        -: 6946:    {
    #####: 6947:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 6948:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 6949:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 6950:      break;
        -: 6951:    }
    #####: 6952:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 6953:    {
    #####: 6954:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 6955:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 6956:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 6957:      break;
        -: 6958:    }
    #####: 6959:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 6960:    {
    #####: 6961:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 6962:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 6963:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 6964:      break;
        -: 6965:    }
    #####: 6966:    default:
        -: 6967:    {
    #####: 6968:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Invalid container type")));
        -: 6969:    }
        -: 6970:  }
    #####: 6971:  ecma_object_t * old_new_target_p = JERRY_CONTEXT (current_new_target_p);
        -: 6972:
    #####: 6973:  if (old_new_target_p == NULL)
        -: 6974:  {
    #####: 6975:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ctor_id);
        -: 6976:  }
        -: 6977:
    #####: 6978:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p,
        -: 6979:                                                           arguments_list_len,
        -: 6980:                                                           lit_id,
        -: 6981:                                                           proto_id);
        -: 6982:
    #####: 6983:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6984:  return container_value;
        -: 6985:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6986:  JERRY_UNUSED (arguments_list_p);
        -: 6987:  JERRY_UNUSED (arguments_list_len);
        -: 6988:  JERRY_UNUSED (container_type);
    #####: 6989:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 6990:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6991:} /* jerry_create_container */
        -: 6992:
        -: 6993:/**
        -: 6994: * Get the type of the given container object.
        -: 6995: *
        -: 6996: * @return Corresponding type to the given container object.
        -: 6997: */
        -: 6998:jerry_container_type_t
    #####: 6999:jerry_get_container_type (const jerry_value_t value) /**< the container object */
        -: 7000:{
        -: 7001:  jerry_assert_api_available ();
        -: 7002:
        -: 7003:#if JERRY_BUILTIN_CONTAINER
    #####: 7004:  if (ecma_is_value_object (value))
        -: 7005:  {
    #####: 7006:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 7007:
    #####: 7008:    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_CONTAINER))
        -: 7009:    {
    #####: 7010:      switch (((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id)
        -: 7011:      {
    #####: 7012:        case LIT_MAGIC_STRING_MAP_UL:
        -: 7013:        {
    #####: 7014:          return JERRY_CONTAINER_TYPE_MAP;
        -: 7015:        }
    #####: 7016:        case LIT_MAGIC_STRING_SET_UL:
        -: 7017:        {
    #####: 7018:          return JERRY_CONTAINER_TYPE_SET;
        -: 7019:        }
    #####: 7020:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 7021:        {
    #####: 7022:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 7023:        }
    #####: 7024:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 7025:        {
    #####: 7026:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 7027:        }
    #####: 7028:        default:
        -: 7029:        {
    #####: 7030:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 7031:        }
        -: 7032:      }
        -: 7033:    }
        -: 7034:  }
        -: 7035:
        -: 7036:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 7037:  JERRY_UNUSED (value);
        -: 7038:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 7039:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 7040:} /* jerry_get_container_type */
        -: 7041:
        -: 7042:/**
        -: 7043: * Return a new array containing elements from a Container or a Container Iterator.
        -: 7044: * Sets the boolean input value to `true` if the container object has key/value pairs.
        -: 7045: *
        -: 7046: * Note:
        -: 7047: *     the returned value must be freed with a jerry_release_value call
        -: 7048: *
        -: 7049: * @return an array of items for maps/sets or their iterators, error otherwise
        -: 7050: */
        -: 7051:jerry_value_t
    #####: 7052:jerry_get_array_from_container (jerry_value_t value, /**< the container or iterator object */
        -: 7053:                                bool *is_key_value_p) /**< [out] is key-value structure */
        -: 7054:{
        -: 7055:  jerry_assert_api_available ();
        -: 7056:
        -: 7057:#if JERRY_BUILTIN_CONTAINER
    #####: 7058:  const char *container_needed = ECMA_ERR_MSG ("Value is not a Container or Iterator");
        -: 7059:
    #####: 7060:  if (!ecma_is_value_object (value))
        -: 7061:  {
    #####: 7062:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 7063:  }
        -: 7064:
    #####: 7065:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 7066:
    #####: 7067:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 7068:  {
    #####: 7069:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 7070:  }
        -: 7071:
    #####: 7072:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 7073:
        -: 7074:  uint32_t entry_count;
        -: 7075:  uint8_t entry_size;
        -: 7076:
    #####: 7077:  uint32_t index = 0;
    #####: 7078:  uint8_t iterator_kind = ECMA_ITERATOR__COUNT;
        -: 7079:  ecma_value_t *start_p;
        -: 7080:
    #####: 7081:  *is_key_value_p = false;
        -: 7082:
    #####: 7083:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_MAP_ITERATOR
    #####: 7084:      || ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_SET_ITERATOR)
    #####: 7085:  {
    #####: 7086:    ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 7087:
    #####: 7088:    if (ecma_is_value_empty (iterated_value))
        -: 7089:    {
    #####: 7090:      return ecma_op_new_array_object_from_collection (ecma_new_collection (), false);
        -: 7091:    }
        -: 7092:
    #####: 7093:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
        -: 7094:
    #####: 7095:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####: 7096:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 7097:    index = ext_obj_p->u.cls.u2.iterator_index;
        -: 7098:
    #####: 7099:    entry_size = ecma_op_container_entry_size (map_object_p->u.cls.u2.container_id);
    #####: 7100:    start_p = ECMA_CONTAINER_START (container_p);
        -: 7101:
    #####: 7102:    iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
        -: 7103:  }
    #####: 7104:  else if (jerry_get_container_type (value) != JERRY_CONTAINER_TYPE_INVALID)
        -: 7105:  {
    #####: 7106:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, ext_obj_p->u.cls.u3.value);
    #####: 7107:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 7108:    entry_size = ecma_op_container_entry_size (ext_obj_p->u.cls.u2.container_id);
        -: 7109:
    #####: 7110:    index = 0;
    #####: 7111:    iterator_kind = ECMA_ITERATOR_KEYS;
    #####: 7112:    start_p = ECMA_CONTAINER_START (container_p);
        -: 7113:
    #####: 7114:    if (ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL
    #####: 7115:        || ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7116:    {
    #####: 7117:      iterator_kind = ECMA_ITERATOR_ENTRIES;
        -: 7118:    }
        -: 7119:  }
        -: 7120:  else
        -: 7121:  {
    #####: 7122:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 7123:  }
        -: 7124:
    #####: 7125:  *is_key_value_p = (iterator_kind == ECMA_ITERATOR_ENTRIES);
    #####: 7126:  ecma_collection_t *collection_buffer = ecma_new_collection ();
        -: 7127:
    #####: 7128:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 7129:  {
    #####: 7130:    ecma_value_t *entry_p = start_p + i;
        -: 7131:
    #####: 7132:    if (ecma_is_value_empty (*entry_p))
        -: 7133:    {
    #####: 7134:      continue;
        -: 7135:    }
        -: 7136:
    #####: 7137:    if (iterator_kind != ECMA_ITERATOR_VALUES)
        -: 7138:    {
    #####: 7139:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[0]));
        -: 7140:    }
        -: 7141:
    #####: 7142:    if (iterator_kind != ECMA_ITERATOR_KEYS)
        -: 7143:    {
    #####: 7144:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[1]));
        -: 7145:    }
        -: 7146:  }
    #####: 7147:  return ecma_op_new_array_object_from_collection (collection_buffer, false);
        -: 7148:#else /* JERRY_BUILTIN_CONTAINER */
        -: 7149:  JERRY_UNUSED (value);
        -: 7150:  JERRY_UNUSED (is_key_value_p);
    #####: 7151:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 7152:#endif
        -: 7153:} /* jerry_get_array_from_container */
        -: 7154:
        -: 7155:/**
        -: 7156: * Perform container operation on the given operands (add, get, set, has, delete, size, clear).
        -: 7157: *
        -: 7158: * @return error - if argument is invalid or operation is unsuccessful or unsupported
        -: 7159: *                 result of the container operation - otherwise.
        -: 7160: */
        -: 7161:jerry_value_t
    #####: 7162:jerry_container_operation (jerry_container_operation_t operation, /**< container operation */
        -: 7163:                           jerry_value_t container, /**< container */
        -: 7164:                           jerry_value_t *arguments, /**< list of arguments */
        -: 7165:                           uint32_t arguments_number) /**< number of arguments */
        -: 7166:{
        -: 7167:  jerry_assert_api_available ();
        -: 7168:#if JERRY_BUILTIN_CONTAINER
    #####: 7169:  if (!ecma_is_value_object (container))
        -: 7170:  {
    #####: 7171:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not an object.")));
        -: 7172:  }
        -: 7173:
    #####: 7174:  ecma_object_t *obj_p = ecma_get_object_from_value (container);
        -: 7175:
    #####: 7176:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 7177:  {
    #####: 7178:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not a container object.")));
        -: 7179:  }
    #####: 7180:  uint16_t type = ((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id;
    #####: 7181:  ecma_extended_object_t *container_object_p = ecma_op_container_get_object (container, type);
        -: 7182:
    #####: 7183:  if (container_object_p == NULL)
        -: 7184:  {
    #####: 7185:    return ecma_create_error_reference_from_context ();
        -: 7186:  }
        -: 7187:
    #####: 7188:  switch (operation)
        -: 7189:  {
    #####: 7190:    case JERRY_CONTAINER_OP_ADD:
        -: 7191:    case JERRY_CONTAINER_OP_DELETE:
        -: 7192:    case JERRY_CONTAINER_OP_GET:
        -: 7193:    case JERRY_CONTAINER_OP_HAS:
        -: 7194:    {
    #####: 7195:      if (arguments_number != 1 || ecma_is_value_error_reference (arguments[0]))
        -: 7196:      {
    #####: 7197:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7198:      }
    #####: 7199:      break;
        -: 7200:    }
    #####: 7201:    case JERRY_CONTAINER_OP_SET:
        -: 7202:    {
    #####: 7203:      if (arguments_number != 2
    #####: 7204:          || ecma_is_value_error_reference (arguments[0])
    #####: 7205:          || ecma_is_value_error_reference (arguments[1]))
        -: 7206:      {
    #####: 7207:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7208:      }
    #####: 7209:      break;
        -: 7210:    }
    #####: 7211:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7212:    case JERRY_CONTAINER_OP_SIZE:
        -: 7213:    {
    #####: 7214:      if (arguments_number != 0)
        -: 7215:      {
    #####: 7216:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7217:      }
    #####: 7218:      break;
        -: 7219:    }
    #####: 7220:    default:
        -: 7221:    {
    #####: 7222:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7223:    }
        -: 7224:  }
        -: 7225:
        -: 7226:  jerry_value_t result;
    #####: 7227:  const char *incorrect_type_call = ECMA_ERR_MSG ("Operator called on incorrect container type");
        -: 7228:
    #####: 7229:  switch (operation)
        -: 7230:  {
    #####: 7231:    case JERRY_CONTAINER_OP_ADD:
        -: 7232:    {
    #####: 7233:      if (type == LIT_MAGIC_STRING_MAP_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7234:      {
    #####: 7235:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7236:      }
    #####: 7237:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[0], type);
    #####: 7238:      break;
        -: 7239:    }
    #####: 7240:    case JERRY_CONTAINER_OP_GET:
        -: 7241:    {
    #####: 7242:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7243:      {
    #####: 7244:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7245:      }
    #####: 7246:      result = ecma_op_container_get (container_object_p, arguments[0], type);
    #####: 7247:      break;
        -: 7248:    }
    #####: 7249:    case JERRY_CONTAINER_OP_SET:
        -: 7250:    {
    #####: 7251:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7252:      {
    #####: 7253:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7254:      }
    #####: 7255:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[1], type);
    #####: 7256:      break;
        -: 7257:    }
    #####: 7258:    case JERRY_CONTAINER_OP_HAS:
        -: 7259:    {
    #####: 7260:      result = ecma_op_container_has (container_object_p, arguments[0], type);
    #####: 7261:      break;
        -: 7262:    }
    #####: 7263:    case JERRY_CONTAINER_OP_DELETE:
        -: 7264:    {
    #####: 7265:      if (type == LIT_MAGIC_STRING_WEAKMAP_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7266:      {
    #####: 7267:        result = ecma_op_container_delete_weak (container_object_p, arguments[0], type);
    #####: 7268:        break;
        -: 7269:      }
    #####: 7270:      result = ecma_op_container_delete (container_object_p, arguments[0], type);
    #####: 7271:      break;
        -: 7272:    }
    #####: 7273:    case JERRY_CONTAINER_OP_SIZE:
        -: 7274:    {
    #####: 7275:      result = ecma_op_container_size (container_object_p);
    #####: 7276:      break;
        -: 7277:    }
    #####: 7278:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7279:    {
    #####: 7280:      if (type == LIT_MAGIC_STRING_WEAKSET_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7281:      {
    #####: 7282:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7283:      }
    #####: 7284:      result = ecma_op_container_clear (container_object_p);
    #####: 7285:      break;
        -: 7286:    }
    #####: 7287:    default:
        -: 7288:    {
    #####: 7289:      result = jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported container operation")));
    #####: 7290:      break;
        -: 7291:    }
        -: 7292:  }
    #####: 7293:  return jerry_return (result);
        -: 7294:#else /* JERRY_BUILTIN_CONTAINER */
        -: 7295:  JERRY_UNUSED (operation);
        -: 7296:  JERRY_UNUSED (container);
        -: 7297:  JERRY_UNUSED (arguments);
        -: 7298:  JERRY_UNUSED (arguments_number);
    #####: 7299:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 7300:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7301:} /* jerry_container_operation */
        -: 7302:
        -: 7303:/**
        -: 7304: * @}
        -: 7305: */
