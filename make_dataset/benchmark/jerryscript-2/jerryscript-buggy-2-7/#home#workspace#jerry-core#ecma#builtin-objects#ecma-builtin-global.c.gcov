        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-global.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-eval.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-gc.h"
        -:   22:#include "ecma-globals.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "jrt.h"
        -:   25:#include "lit-char-helpers.h"
        -:   26:#include "lit-magic-strings.h"
        -:   27:#include "lit-strings.h"
        -:   28:#include "vm.h"
        -:   29:#include "jcontext.h"
        -:   30:#include "jrt-libc-includes.h"
        -:   31:#include "jrt-bit-fields.h"
        -:   32:
        -:   33:#define ECMA_BUILTINS_INTERNAL
        -:   34:#include "ecma-builtins-internal.h"
        -:   35:
        -:   36:/**
        -:   37: * This object has a custom dispatch function.
        -:   38: */
        -:   39:#define BUILTIN_CUSTOM_DISPATCH
        -:   40:
        -:   41:/**
        -:   42: * List of built-in routine identifiers.
        -:   43: */
        -:   44:enum
        -:   45:{
        -:   46:  ECMA_GLOBAL_ROUTINE_START = 0,
        -:   47:  /* Note: these 5 routine ids must be in this order */
        -:   48:  ECMA_GLOBAL_IS_NAN,
        -:   49:  ECMA_GLOBAL_IS_FINITE,
        -:   50:  ECMA_GLOBAL_EVAL,
        -:   51:  ECMA_GLOBAL_PARSE_INT,
        -:   52:  ECMA_GLOBAL_PARSE_FLOAT,
        -:   53:  ECMA_GLOBAL_DECODE_URI,
        -:   54:  ECMA_GLOBAL_DECODE_URI_COMPONENT,
        -:   55:  ECMA_GLOBAL_ENCODE_URI,
        -:   56:  ECMA_GLOBAL_ENCODE_URI_COMPONENT,
        -:   57:  ECMA_GLOBAL_ESCAPE,
        -:   58:  ECMA_GLOBAL_UNESCAPE,
        -:   59:};
        -:   60:
        -:   61:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-global.inc.h"
        -:   62:#define BUILTIN_UNDERSCORED_ID global
        -:   63:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   64:
        -:   65:/** \addtogroup ecma ECMA
        -:   66: * @{
        -:   67: *
        -:   68: * \addtogroup ecmabuiltins
        -:   69: * @{
        -:   70: *
        -:   71: * \addtogroup global ECMA Global object built-in
        -:   72: * @{
        -:   73: */
        -:   74:
        -:   75:/**
        -:   76: * The Global object's 'eval' routine
        -:   77: *
        -:   78: * See also:
        -:   79: *          ECMA-262 v5, 15.1.2.1
        -:   80: *
        -:   81: * @return ecma value
        -:   82: *         Returned value must be freed with ecma_free_value.
        -:   83: */
        -:   84:static ecma_value_t
    #####:   85:ecma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */
        -:   86:{
    #####:   87:  if (JERRY_UNLIKELY (!ecma_is_value_string (x)))
        -:   88:  {
        -:   89:    /* step 1 */
    #####:   90:    return ecma_copy_value (x);
        -:   91:  }
        -:   92:
    #####:   93:  uint32_t parse_opts = vm_is_direct_eval_form_call () ? ECMA_PARSE_DIRECT_EVAL : ECMA_PARSE_NO_OPTS;
        -:   94:
        -:   95:  /* See also: ECMA-262 v5, 10.1.1 */
    #####:   96:  if (parse_opts && vm_is_strict_mode ())
        -:   97:  {
    #####:   98:    JERRY_ASSERT (parse_opts & ECMA_PARSE_DIRECT_EVAL);
    #####:   99:    parse_opts |= ECMA_PARSE_STRICT_MODE;
        -:  100:  }
        -:  101:
        -:  102:#if JERRY_ESNEXT
    #####:  103:  if (vm_is_direct_eval_form_call ())
        -:  104:  {
    #####:  105:    parse_opts |= ECMA_GET_LOCAL_PARSE_OPTS ();
        -:  106:  }
        -:  107:#endif /* JERRY_ESNEXT */
        -:  108:
        -:  109:  /* steps 2 to 8 */
    #####:  110:  return ecma_op_eval (x, parse_opts);
        -:  111:} /* ecma_builtin_global_object_eval */
        -:  112:
        -:  113:/**
        -:  114: * The Global object's 'isNaN' routine
        -:  115: *
        -:  116: * See also:
        -:  117: *          ECMA-262 v5, 15.1.2.4
        -:  118: *
        -:  119: * @return ecma value
        -:  120: *         Returned value must be freed with ecma_free_value.
        -:  121: */
        -:  122:static ecma_value_t
    #####:  123:ecma_builtin_global_object_is_nan (ecma_number_t arg_num) /**< routine's first argument */
        -:  124:{
    #####:  125:  return ecma_make_boolean_value (ecma_number_is_nan (arg_num));
        -:  126:} /* ecma_builtin_global_object_is_nan */
        -:  127:
        -:  128:/**
        -:  129: * The Global object's 'isFinite' routine
        -:  130: *
        -:  131: * See also:
        -:  132: *          ECMA-262 v5, 15.1.2.5
        -:  133: *
        -:  134: * @return ecma value
        -:  135: *         Returned value must be freed with ecma_free_value.
        -:  136: */
        -:  137:static ecma_value_t
    #####:  138:ecma_builtin_global_object_is_finite (ecma_number_t arg_num) /**< routine's first argument */
        -:  139:{
    #####:  140:  bool is_finite = !(ecma_number_is_nan (arg_num)
    #####:  141:                     || ecma_number_is_infinity (arg_num));
        -:  142:
    #####:  143:  return ecma_make_boolean_value (is_finite);
        -:  144:} /* ecma_builtin_global_object_is_finite */
        -:  145:
        -:  146:/**
        -:  147: * Helper function to check whether a character is in a character bitset.
        -:  148: *
        -:  149: * @return true if the character is in the character bitset.
        -:  150: */
        -:  151:static bool
    #####:  152:ecma_builtin_global_object_character_is_in (uint32_t character, /**< character */
        -:  153:                                            const uint8_t *bitset) /**< character set */
        -:  154:{
    #####:  155:  JERRY_ASSERT (character < 128);
    #####:  156:  return (bitset[character >> 3] & (1u << (character & 0x7))) != 0;
        -:  157:} /* ecma_builtin_global_object_character_is_in */
        -:  158:
        -:  159:/**
        -:  160: * Unescaped URI characters bitset:
        -:  161: *   One bit for each character between 0 - 127.
        -:  162: *   Bit is set if the character is in the unescaped URI set.
        -:  163: */
        -:  164:static const uint8_t unescaped_uri_set[16] =
        -:  165:{
        -:  166:  0x0, 0x0, 0x0, 0x0, 0xda, 0xff, 0xff, 0xaf,
        -:  167:  0xff, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x47
        -:  168:};
        -:  169:
        -:  170:/**
        -:  171: * Unescaped URI component characters bitset:
        -:  172: *   One bit for each character between 0 - 127.
        -:  173: *   Bit is set if the character is in the unescaped component URI set.
        -:  174: */
        -:  175:static const uint8_t unescaped_uri_component_set[16] =
        -:  176:{
        -:  177:  0x0, 0x0, 0x0, 0x0, 0x82, 0x67, 0xff, 0x3,
        -:  178:  0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x47
        -:  179:};
        -:  180:
        -:  181:/**
        -:  182: * Format is a percent sign followed by two hex digits.
        -:  183: */
        -:  184:#define URI_ENCODED_BYTE_SIZE (3)
        -:  185:
        -:  186:/**
        -:  187: * The Global object's 'decodeURI' and 'decodeURIComponent' routines
        -:  188: *
        -:  189: * See also:
        -:  190: *          ECMA-262 v5, 15.1.3.1
        -:  191: *          ECMA-262 v5, 15.1.3.2
        -:  192: *
        -:  193: * @return ecma value
        -:  194: *         Returned value must be freed with ecma_free_value.
        -:  195: */
        -:  196:static ecma_value_t
    #####:  197:ecma_builtin_global_object_decode_uri_helper (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  198:                                                                               *   string buffer */
        -:  199:                                              lit_utf8_size_t input_size, /**< routine's first argument's
        -:  200:                                                                           *   string buffer's size */
        -:  201:                                              const uint8_t *reserved_uri_bitset) /**< reserved characters bitset */
        -:  202:{
    #####:  203:  lit_utf8_byte_t *input_char_p = input_start_p;
    #####:  204:  lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  205:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  206:
    #####:  207:  while (input_char_p < input_end_p)
        -:  208:  {
    #####:  209:    if (*input_char_p != '%')
        -:  210:    {
    #####:  211:      ecma_stringbuilder_append_byte (&builder, *input_char_p++);
    #####:  212:      continue;
        -:  213:    }
        -:  214:
    #####:  215:    uint32_t hex_value = lit_char_hex_lookup (input_char_p + 1, input_end_p, 2);
    #####:  216:    if (hex_value == UINT32_MAX)
        -:  217:    {
    #####:  218:      ecma_stringbuilder_destroy (&builder);
    #####:  219:      return ecma_raise_uri_error (ECMA_ERR_MSG ("Invalid hexadecimal value"));
        -:  220:    }
        -:  221:
    #####:  222:    ecma_char_t decoded_byte = (ecma_char_t) hex_value;
    #####:  223:    input_char_p += URI_ENCODED_BYTE_SIZE;
        -:  224:
    #####:  225:    if (decoded_byte <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  226:    {
    #####:  227:      if (ecma_builtin_global_object_character_is_in (decoded_byte, reserved_uri_bitset)
    #####:  228:          && !ecma_builtin_global_object_character_is_in (decoded_byte, unescaped_uri_component_set))
        -:  229:      {
    #####:  230:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_PERCENT);
    #####:  231:        input_char_p -= 2;
        -:  232:      }
        -:  233:      else
        -:  234:      {
    #####:  235:        ecma_stringbuilder_append_byte (&builder, (lit_utf8_byte_t) decoded_byte);
        -:  236:      }
        -:  237:    }
        -:  238:    else
        -:  239:    {
        -:  240:      uint32_t bytes_count;
        -:  241:
    #####:  242:      if ((decoded_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  243:      {
    #####:  244:        bytes_count = 2;
        -:  245:      }
    #####:  246:      else if ((decoded_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  247:      {
    #####:  248:        bytes_count = 3;
        -:  249:      }
    #####:  250:      else if ((decoded_byte & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)
        -:  251:      {
    #####:  252:        bytes_count = 4;
        -:  253:      }
        -:  254:      else
        -:  255:      {
    #####:  256:        ecma_stringbuilder_destroy (&builder);
    #####:  257:        return ecma_raise_uri_error (ECMA_ERR_MSG ("Invalid UTF8 character"));
        -:  258:      }
        -:  259:
    #####:  260:      lit_utf8_byte_t octets[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####:  261:      octets[0] = (lit_utf8_byte_t) decoded_byte;
    #####:  262:      bool is_valid = true;
        -:  263:
    #####:  264:      for (uint32_t i = 1; i < bytes_count; i++)
        -:  265:      {
    #####:  266:        if (input_char_p >= input_end_p || *input_char_p != '%')
        -:  267:        {
    #####:  268:          is_valid = false;
    #####:  269:          break;
        -:  270:        }
        -:  271:        else
        -:  272:        {
    #####:  273:          hex_value = lit_char_hex_lookup (input_char_p + 1, input_end_p, 2);
        -:  274:
    #####:  275:          if (hex_value == UINT32_MAX || (hex_value & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  276:          {
    #####:  277:            is_valid = false;
    #####:  278:            break;
        -:  279:          }
        -:  280:
    #####:  281:          input_char_p += URI_ENCODED_BYTE_SIZE;
    #####:  282:          octets[i] = (lit_utf8_byte_t) hex_value;
        -:  283:        }
        -:  284:      }
        -:  285:
    #####:  286:      if (!is_valid
    #####:  287:          || !lit_is_valid_utf8_string (octets, bytes_count, true))
        -:  288:      {
    #####:  289:        ecma_stringbuilder_destroy (&builder);
    #####:  290:        return ecma_raise_uri_error (ECMA_ERR_MSG ("Invalid UTF8 string"));
        -:  291:      }
        -:  292:
    #####:  293:      lit_code_point_t cp;
    #####:  294:      lit_read_code_point_from_utf8 (octets, bytes_count, &cp);
        -:  295:
    #####:  296:      if (lit_is_code_point_utf16_high_surrogate (cp)
    #####:  297:          || lit_is_code_point_utf16_low_surrogate (cp))
        -:  298:      {
    #####:  299:        ecma_stringbuilder_destroy (&builder);
    #####:  300:        return ecma_raise_uri_error (ECMA_ERR_MSG ("Invalid UTF8 codepoint"));
        -:  301:      }
        -:  302:
    #####:  303:      lit_utf8_byte_t result_chars[LIT_CESU8_MAX_BYTES_IN_CODE_POINT];
    #####:  304:      lit_utf8_size_t cp_size = lit_code_point_to_cesu8 (cp, result_chars);
    #####:  305:      ecma_stringbuilder_append_raw (&builder, result_chars, cp_size);
        -:  306:    }
        -:  307:  }
        -:  308:
    #####:  309:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  310:} /* ecma_builtin_global_object_decode_uri_helper */
        -:  311:
        -:  312:/**
        -:  313: * Helper function to encode byte as hexadecimal values.
        -:  314: */
        -:  315:static void
    #####:  316:ecma_builtin_global_object_byte_to_hex (lit_utf8_byte_t *dest_p, /**< destination pointer */
        -:  317:                                        uint32_t byte) /**< value */
        -:  318:{
    #####:  319:  JERRY_ASSERT (byte < 256);
        -:  320:
    #####:  321:  dest_p[0] = LIT_CHAR_PERCENT;
    #####:  322:  ecma_char_t hex_digit = (ecma_char_t) (byte >> 4);
    #####:  323:  dest_p[1] = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
    #####:  324:  hex_digit = (lit_utf8_byte_t) (byte & 0xf);
    #####:  325:  dest_p[2] = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
    #####:  326:} /* ecma_builtin_global_object_byte_to_hex */
        -:  327:
        -:  328:/**
        -:  329: * The Global object's 'encodeURI' and 'encodeURIComponent' routines
        -:  330: *
        -:  331: * See also:
        -:  332: *          ECMA-262 v5, 15.1.3.3
        -:  333: *          ECMA-262 v5, 15.1.3.4
        -:  334: *
        -:  335: * @return ecma value
        -:  336: *         Returned value must be freed with ecma_free_value.
        -:  337: */
        -:  338:static ecma_value_t
    #####:  339:ecma_builtin_global_object_encode_uri_helper (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  340:                                                                               *   string buffer */
        -:  341:                                              lit_utf8_size_t input_size, /**< routine's first argument's
        -:  342:                                                                           *   string buffer's size */
        -:  343:                                              const uint8_t *unescaped_uri_bitset_p) /**< unescaped bitset */
        -:  344:{
    #####:  345:  lit_utf8_byte_t *input_char_p = input_start_p;
    #####:  346:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  347:  ecma_char_t ch;
    #####:  348:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  349:  lit_utf8_byte_t octets[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####:  350:  memset (octets, LIT_BYTE_NULL, LIT_UTF8_MAX_BYTES_IN_CODE_POINT);
        -:  351:
    #####:  352:  while (input_char_p < input_end_p)
        -:  353:  {
    #####:  354:    input_char_p += lit_read_code_unit_from_cesu8 (input_char_p, &ch);
        -:  355:
    #####:  356:    if (lit_is_code_point_utf16_low_surrogate (ch))
        -:  357:    {
    #####:  358:      ecma_stringbuilder_destroy (&builder);
    #####:  359:      return ecma_raise_uri_error (ECMA_ERR_MSG ("Unicode surrogate pair missing"));
        -:  360:    }
        -:  361:
    #####:  362:    lit_code_point_t cp = ch;
        -:  363:
    #####:  364:    if (lit_is_code_point_utf16_high_surrogate (ch))
        -:  365:    {
    #####:  366:      if (input_char_p == input_end_p)
        -:  367:      {
    #####:  368:        ecma_stringbuilder_destroy (&builder);
    #####:  369:        return ecma_raise_uri_error (ECMA_ERR_MSG ("Unicode surrogate pair missing"));
        -:  370:      }
        -:  371:
    #####:  372:      ecma_char_t next_ch;
    #####:  373:      lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (input_char_p, &next_ch);
        -:  374:
    #####:  375:      if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  376:      {
    #####:  377:        cp = lit_convert_surrogate_pair_to_code_point (ch, next_ch);
    #####:  378:        input_char_p += read_size;
        -:  379:      }
        -:  380:      else
        -:  381:      {
    #####:  382:        ecma_stringbuilder_destroy (&builder);
    #####:  383:        return ecma_raise_uri_error (ECMA_ERR_MSG ("Unicode surrogate pair missing"));
        -:  384:      }
        -:  385:    }
        -:  386:
    #####:  387:    lit_utf8_size_t utf_size = lit_code_point_to_utf8 (cp, octets);
    #####:  388:    lit_utf8_byte_t result_chars[URI_ENCODED_BYTE_SIZE];
        -:  389:
    #####:  390:    if (utf_size == 1)
        -:  391:    {
    #####:  392:      if (ecma_builtin_global_object_character_is_in (octets[0], unescaped_uri_bitset_p))
        -:  393:      {
    #####:  394:        ecma_stringbuilder_append_byte (&builder, octets[0]);
        -:  395:      }
        -:  396:      else
        -:  397:      {
    #####:  398:        ecma_builtin_global_object_byte_to_hex (result_chars, octets[0]);
    #####:  399:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  400:      }
        -:  401:    }
        -:  402:    else
        -:  403:    {
    #####:  404:      for (uint32_t i = 0; i < utf_size; i++)
        -:  405:      {
    #####:  406:        JERRY_ASSERT (utf_size <= LIT_UTF8_MAX_BYTES_IN_CODE_POINT);
    #####:  407:        ecma_builtin_global_object_byte_to_hex (result_chars, octets[i]);
    #####:  408:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  409:      }
        -:  410:    }
        -:  411:  }
        -:  412:
    #####:  413:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  414:} /* ecma_builtin_global_object_encode_uri_helper */
        -:  415:
        -:  416:#if JERRY_BUILTIN_ANNEXB
        -:  417:
        -:  418:/**
        -:  419: * Maximum value of a byte.
        -:  420: */
        -:  421:#define ECMA_ESCAPE_MAXIMUM_BYTE_VALUE (255)
        -:  422:
        -:  423:/**
        -:  424: * Format is a percent sign followed by lowercase u and four hex digits.
        -:  425: */
        -:  426:#define ECMA_ESCAPE_ENCODED_UNICODE_CHARACTER_SIZE (6)
        -:  427:
        -:  428:/**
        -:  429: * Escape characters bitset:
        -:  430: *   One bit for each character between 0 - 127.
        -:  431: *   Bit is set if the character does not need to be converted to %xx form.
        -:  432: *   These characters are: a-z A-Z 0-9 @ * _ + - . /
        -:  433: */
        -:  434:static const uint8_t ecma_escape_set[16] =
        -:  435:{
        -:  436:  0x0, 0x0, 0x0, 0x0, 0x0, 0xec, 0xff, 0x3,
        -:  437:  0xff, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x7
        -:  438:};
        -:  439:
        -:  440:/**
        -:  441: * The Global object's 'escape' routine
        -:  442: *
        -:  443: * See also:
        -:  444: *          ECMA-262 v5, B.2.1
        -:  445: *
        -:  446: * @return ecma value
        -:  447: *         Returned value must be freed with ecma_free_value.
        -:  448: */
        -:  449:static ecma_value_t
    #####:  450:ecma_builtin_global_object_escape (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  451:                                                                    *   string buffer */
        -:  452:                                   lit_utf8_size_t input_size) /**< routine's first argument's
        -:  453:                                                                *   string buffer's size */
        -:  454:{
    #####:  455:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####:  456:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  457:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  458:  lit_utf8_byte_t result_chars[URI_ENCODED_BYTE_SIZE];
        -:  459:
    #####:  460:  while (input_curr_p < input_end_p)
        -:  461:  {
    #####:  462:    ecma_char_t chr = lit_cesu8_read_next (&input_curr_p);
        -:  463:
    #####:  464:    if (chr <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  465:    {
    #####:  466:      if (ecma_builtin_global_object_character_is_in ((uint32_t) chr, ecma_escape_set))
        -:  467:      {
    #####:  468:        ecma_stringbuilder_append_char (&builder, chr);
        -:  469:      }
        -:  470:      else
        -:  471:      {
    #####:  472:        ecma_builtin_global_object_byte_to_hex (result_chars, chr);
    #####:  473:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  474:      }
        -:  475:    }
    #####:  476:    else if (chr > ECMA_ESCAPE_MAXIMUM_BYTE_VALUE)
        -:  477:    {
    #####:  478:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_PERCENT);
    #####:  479:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_LOWERCASE_U);
        -:  480:
    #####:  481:      ecma_builtin_global_object_byte_to_hex (result_chars, (chr >> JERRY_BITSINBYTE));
    #####:  482:      ecma_stringbuilder_append_raw (&builder, result_chars + 1, 2);
        -:  483:
    #####:  484:      ecma_builtin_global_object_byte_to_hex (result_chars, (chr & 0xff));
    #####:  485:      ecma_stringbuilder_append_raw (&builder, result_chars + 1, 2);
        -:  486:    }
        -:  487:    else
        -:  488:    {
    #####:  489:      ecma_builtin_global_object_byte_to_hex (result_chars, chr);
    #####:  490:      ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  491:    }
        -:  492:  }
        -:  493:
    #####:  494:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  495:} /* ecma_builtin_global_object_escape */
        -:  496:
        -:  497:/**
        -:  498: * Utility method to resolve character sequences for the 'unescape' method.
        -:  499: *
        -:  500: * Expected formats: %uxxxx or %yy
        -:  501: *
        -:  502: * @return number of characters processed during the escape resolve
        -:  503: */
        -:  504:static uint8_t
    #####:  505:ecma_builtin_global_object_unescape_resolve_escape (const lit_utf8_byte_t *buffer_p,  /**< character buffer */
        -:  506:                                                    bool unicode_sequence, /**< true if unescaping unicode sequence */
        -:  507:                                                    ecma_char_t *out_result_p) /**< [out] resolved character */
        -:  508:{
    #####:  509:  JERRY_ASSERT (buffer_p != NULL);
    #####:  510:  JERRY_ASSERT (out_result_p != NULL);
        -:  511:
    #####:  512:  ecma_char_t unescaped_chr = 0;
    #####:  513:  uint8_t sequence_length = unicode_sequence ? 5 : 2;
    #####:  514:  uint8_t start = unicode_sequence ? 1 : 0;
        -:  515:
    #####:  516:  for (uint8_t i = start; i < sequence_length; i++)
        -:  517:  {
    #####:  518:    const lit_utf8_byte_t current_char = buffer_p[i];
        -:  519:
    #####:  520:    if (!lit_char_is_hex_digit (current_char))
        -:  521:    {
        -:  522:      /* This was not an escape sequence, skip processing */
    #####:  523:      return 0;
        -:  524:    }
        -:  525:
    #####:  526:    unescaped_chr = (ecma_char_t) ((unescaped_chr << 4) + (ecma_char_t) lit_char_hex_to_int (current_char));
        -:  527:  }
        -:  528:
    #####:  529:  *out_result_p = unescaped_chr;
        -:  530:
    #####:  531:  return sequence_length;
        -:  532:} /* ecma_builtin_global_object_unescape_resolve_escape */
        -:  533:
        -:  534:/**
        -:  535: * The Global object's 'unescape' routine
        -:  536: *
        -:  537: * See also:
        -:  538: *          ECMA-262 v5, B.2.2
        -:  539: *          ECMA-262 v11, B.2.1.2
        -:  540: *
        -:  541: * @return ecma value
        -:  542: *         Returned value must be freed with ecma_free_value.
        -:  543: */
        -:  544:static ecma_value_t
    #####:  545:ecma_builtin_global_object_unescape (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  546:                                                                      *   string buffer */
        -:  547:                                     lit_utf8_size_t input_size) /**< routine's first argument's
        -:  548:                                                                  *   string buffer's size */
        -:  549:{
    #####:  550:  if (input_size == 0)
        -:  551:  {
    #####:  552:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  553:  }
        -:  554:
    #####:  555:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####:  556:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  557:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  558:
    #####:  559:  while (input_curr_p < input_end_p)
        -:  560:  {
    #####:  561:    ecma_char_t chr = lit_cesu8_read_next (&input_curr_p);
        -:  562:
        -:  563:    // potential pattern
    #####:  564:    if (chr == LIT_CHAR_PERCENT)
        -:  565:    {
    #####:  566:      const lit_utf8_size_t chars_leftover = (lit_utf8_size_t) (input_end_p - input_curr_p);
        -:  567:
        -:  568:      // potential unicode sequence
    #####:  569:      if (chars_leftover >= 5 && input_curr_p[0] == LIT_CHAR_LOWERCASE_U)
        -:  570:      {
    #####:  571:        input_curr_p += ecma_builtin_global_object_unescape_resolve_escape (input_curr_p, true, &chr);
        -:  572:      }
        -:  573:      // potential two hexa sequence
    #####:  574:      else if (chars_leftover >= 2)
        -:  575:      {
    #####:  576:        input_curr_p += ecma_builtin_global_object_unescape_resolve_escape (input_curr_p, false, &chr);
        -:  577:      }
        -:  578:    }
        -:  579:
    #####:  580:    ecma_stringbuilder_append_char (&builder, chr);
        -:  581:  }
        -:  582:
    #####:  583:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  584:} /* ecma_builtin_global_object_unescape */
        -:  585:
        -:  586:#endif /* JERRY_BUILTIN_ANNEXB */
        -:  587:
        -:  588:/**
        -:  589: * Dispatcher of the built-in's routines
        -:  590: *
        -:  591: * @return ecma value
        -:  592: *         Returned value must be freed with ecma_free_value.
        -:  593: */
        -:  594:ecma_value_t
    #####:  595:ecma_builtin_global_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  596:                                      ecma_value_t this_arg, /**< 'this' argument value */
        -:  597:                                      const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  598:                                                                              *   passed to routine */
        -:  599:                                      uint32_t arguments_number) /**< length of arguments' list */
        -:  600:{
        -:  601:  JERRY_UNUSED_2 (this_arg, arguments_number);
        -:  602:
    #####:  603:  ecma_value_t routine_arg_1 = arguments_list_p[0];
        -:  604:
    #####:  605:  if (builtin_routine_id == ECMA_GLOBAL_EVAL)
        -:  606:  {
    #####:  607:    return ecma_builtin_global_object_eval (routine_arg_1);
        -:  608:  }
        -:  609:
    #####:  610:  if (builtin_routine_id <= ECMA_GLOBAL_IS_FINITE)
        -:  611:  {
    #####:  612:    ecma_number_t arg_num;
        -:  613:
    #####:  614:    routine_arg_1 = ecma_op_to_number (routine_arg_1, &arg_num);
        -:  615:
    #####:  616:    if (!ecma_is_value_empty (routine_arg_1))
        -:  617:    {
    #####:  618:      return routine_arg_1;
        -:  619:    }
        -:  620:
    #####:  621:    if (builtin_routine_id == ECMA_GLOBAL_IS_NAN)
        -:  622:    {
    #####:  623:      return ecma_builtin_global_object_is_nan (arg_num);
        -:  624:    }
        -:  625:
    #####:  626:    JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_IS_FINITE);
        -:  627:
    #####:  628:    return ecma_builtin_global_object_is_finite (arg_num);
        -:  629:  }
        -:  630:
    #####:  631:  ecma_string_t *str_p = ecma_op_to_string (routine_arg_1);
        -:  632:
    #####:  633:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  634:  {
    #####:  635:    return ECMA_VALUE_ERROR;
        -:  636:  }
        -:  637:
        -:  638:  ecma_value_t ret_value;
        -:  639:
    #####:  640:  if (builtin_routine_id <= ECMA_GLOBAL_PARSE_FLOAT)
        -:  641:  {
    #####:  642:    ECMA_STRING_TO_UTF8_STRING (str_p, string_buff, string_buff_size);
        -:  643:
    #####:  644:    if (builtin_routine_id == ECMA_GLOBAL_PARSE_INT)
        -:  645:    {
    #####:  646:      ret_value = ecma_number_parse_int (string_buff,
        -:  647:                                         string_buff_size,
    #####:  648:                                         arguments_list_p[1]);
        -:  649:    }
        -:  650:    else
        -:  651:    {
    #####:  652:      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_PARSE_FLOAT);
    #####:  653:      ret_value = ecma_number_parse_float (string_buff,
        -:  654:                                           string_buff_size);
        -:  655:    }
        -:  656:
    #####:  657:    ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);
    #####:  658:    ecma_deref_ecma_string (str_p);
    #####:  659:    return ret_value;
        -:  660:  }
        -:  661:
    #####:  662:  lit_utf8_size_t input_size = ecma_string_get_size (str_p);
        -:  663:
    #####:  664:  JMEM_DEFINE_LOCAL_ARRAY (input_start_p,
        -:  665:                           input_size + 1,
        -:  666:                           lit_utf8_byte_t);
        -:  667:
    #####:  668:  ecma_string_to_utf8_bytes (str_p, input_start_p, input_size);
        -:  669:
    #####:  670:  input_start_p[input_size] = LIT_BYTE_NULL;
        -:  671:
    #####:  672:  switch (builtin_routine_id)
        -:  673:  {
        -:  674:#if JERRY_BUILTIN_ANNEXB
    #####:  675:    case ECMA_GLOBAL_ESCAPE:
        -:  676:    {
    #####:  677:      ret_value = ecma_builtin_global_object_escape (input_start_p, input_size);
    #####:  678:      break;
        -:  679:    }
    #####:  680:    case ECMA_GLOBAL_UNESCAPE:
        -:  681:    {
    #####:  682:      ret_value = ecma_builtin_global_object_unescape (input_start_p, input_size);
    #####:  683:      break;
        -:  684:    }
        -:  685:#endif /* JERRY_BUILTIN_ANNEXB */
    #####:  686:    case ECMA_GLOBAL_DECODE_URI:
        -:  687:    case ECMA_GLOBAL_DECODE_URI_COMPONENT:
        -:  688:    {
    #####:  689:      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_DECODE_URI ? unescaped_uri_set
    #####:  690:                                                                             : unescaped_uri_component_set);
        -:  691:
    #####:  692:      ret_value = ecma_builtin_global_object_decode_uri_helper (input_start_p, input_size, uri_set);
    #####:  693:      break;
        -:  694:    }
    #####:  695:    default:
        -:  696:    {
    #####:  697:      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI
        -:  698:                    || builtin_routine_id == ECMA_GLOBAL_ENCODE_URI_COMPONENT);
        -:  699:
    #####:  700:      const uint8_t *uri_set = (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI ? unescaped_uri_set
    #####:  701:                                                                             : unescaped_uri_component_set);
        -:  702:
    #####:  703:      ret_value = ecma_builtin_global_object_encode_uri_helper (input_start_p, input_size, uri_set);
    #####:  704:      break;
        -:  705:    }
        -:  706:  }
        -:  707:
    #####:  708:  JMEM_FINALIZE_LOCAL_ARRAY (input_start_p);
        -:  709:
    #####:  710:  ecma_deref_ecma_string (str_p);
    #####:  711:  return ret_value;
        -:  712:} /* ecma_builtin_global_dispatch_routine */
        -:  713:
        -:  714:/**
        -:  715: * @}
        -:  716: * @}
        -:  717: * @}
        -:  718: */
