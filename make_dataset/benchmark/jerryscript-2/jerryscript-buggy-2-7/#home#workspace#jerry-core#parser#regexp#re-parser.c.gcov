        -:    0:Source:/home/workspace/jerry-core/parser/regexp/re-parser.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-globals.h"
        -:   18:#include "jcontext.h"
        -:   19:#include "jrt-libc-includes.h"
        -:   20:#include "lit-char-helpers.h"
        -:   21:#include "re-compiler.h"
        -:   22:#include "re-parser.h"
        -:   23:
        -:   24:#if JERRY_BUILTIN_REGEXP
        -:   25:
        -:   26:/** \addtogroup parser Parser
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup regexparser Regular expression
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup regexparser_parser Parser
        -:   33: * @{
        -:   34: */
        -:   35:
        -:   36:/**
        -:   37: * Get the start opcode for the current group.
        -:   38: *
        -:   39: * @return RegExp opcode
        -:   40: */
        -:   41:static re_opcode_t
    #####:   42:re_get_group_start_opcode (bool is_capturing) /**< is capturing group */
        -:   43:{
    #####:   44:  return (is_capturing) ? RE_OP_CAPTURING_GROUP_START : RE_OP_NON_CAPTURING_GROUP_START;
        -:   45:} /* re_get_group_start_opcode*/
        -:   46:
        -:   47:/**
        -:   48: * Get the end opcode for the current group.
        -:   49: *
        -:   50: * @return RegExp opcode
        -:   51: */
        -:   52:static re_opcode_t
    #####:   53:re_get_group_end_opcode (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   54:                         bool is_capturing) /**< is capturing group */
        -:   55:{
    #####:   56:  if (is_capturing)
        -:   57:  {
    #####:   58:    if (re_ctx_p->token.greedy)
        -:   59:    {
    #####:   60:      return RE_OP_GREEDY_CAPTURING_GROUP_END;
        -:   61:    }
        -:   62:
    #####:   63:    return RE_OP_LAZY_CAPTURING_GROUP_END;
        -:   64:  }
        -:   65:
    #####:   66:  if (re_ctx_p->token.greedy)
        -:   67:  {
    #####:   68:    return RE_OP_GREEDY_NON_CAPTURING_GROUP_END;
        -:   69:  }
        -:   70:
    #####:   71:  return RE_OP_LAZY_NON_CAPTURING_GROUP_END;
        -:   72:} /* re_get_group_end_opcode */
        -:   73:
        -:   74:/**
        -:   75: * Enclose the given bytecode to a group.
        -:   76: */
        -:   77:static void
    #####:   78:re_insert_into_group (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   79:                      uint32_t group_start_offset, /**< offset of group start */
        -:   80:                      uint32_t idx, /**< index of group */
        -:   81:                      uint32_t capture_start, /**< index of first nested capture */
        -:   82:                      bool is_capturing) /**< is capturing group */
        -:   83:{
    #####:   84:  uint32_t qmin = re_ctx_p->token.qmin;
    #####:   85:  uint32_t qmax = re_ctx_p->token.qmax;
        -:   86:
    #####:   87:  if (JERRY_UNLIKELY (!is_capturing && re_bytecode_size (re_ctx_p) == group_start_offset))
        -:   88:  {
    #####:   89:    return;
        -:   90:  }
        -:   91:
    #####:   92:  if (qmin == 0)
        -:   93:  {
    #####:   94:    re_insert_value (re_ctx_p,
        -:   95:                     group_start_offset,
    #####:   96:                     re_bytecode_size (re_ctx_p) - group_start_offset);
        -:   97:  }
        -:   98:
    #####:   99:  re_insert_value (re_ctx_p, group_start_offset, qmin);
    #####:  100:  re_insert_value (re_ctx_p, group_start_offset, re_ctx_p->captures_count - capture_start);
        -:  101:
    #####:  102:  if (!is_capturing)
        -:  103:  {
    #####:  104:    re_insert_value (re_ctx_p, group_start_offset, capture_start);
        -:  105:  }
        -:  106:  else
        -:  107:  {
    #####:  108:    JERRY_ASSERT (idx == capture_start);
        -:  109:  }
        -:  110:
    #####:  111:  re_insert_value (re_ctx_p, group_start_offset, idx);
    #####:  112:  re_insert_opcode (re_ctx_p, group_start_offset, re_get_group_start_opcode (is_capturing));
        -:  113:
    #####:  114:  re_append_opcode (re_ctx_p, re_get_group_end_opcode (re_ctx_p, is_capturing));
    #####:  115:  re_append_value (re_ctx_p, idx);
    #####:  116:  re_append_value (re_ctx_p, qmin);
    #####:  117:  re_append_value (re_ctx_p, qmax + RE_QMAX_OFFSET);
        -:  118:} /* re_insert_into_group */
        -:  119:
        -:  120:/**
        -:  121: * Insert simple atom iterator.
        -:  122: */
        -:  123:static void
    #####:  124:re_insert_atom_iterator (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  125:                         uint32_t start_offset) /**< atom start offset */
        -:  126:{
    #####:  127:  const uint32_t qmin = re_ctx_p->token.qmin;
    #####:  128:  const uint32_t qmax = re_ctx_p->token.qmax;
        -:  129:
    #####:  130:  if (qmin == 1 && qmax == 1)
        -:  131:  {
    #####:  132:    return;
        -:  133:  }
        -:  134:
    #####:  135:  re_append_opcode (re_ctx_p, RE_OP_ITERATOR_END);
    #####:  136:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
    #####:  137:  re_insert_value (re_ctx_p, start_offset, qmax + RE_QMAX_OFFSET);
    #####:  138:  re_insert_value (re_ctx_p, start_offset, qmin);
    #####:  139:  re_insert_opcode (re_ctx_p, start_offset, re_ctx_p->token.greedy ? RE_OP_GREEDY_ITERATOR : RE_OP_LAZY_ITERATOR);
        -:  140:} /* re_insert_atom_iterator */
        -:  141:
        -:  142:/**
        -:  143: * Insert a lookahead assertion.
        -:  144: */
        -:  145:static void
    #####:  146:re_insert_assertion_lookahead (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  147:                               uint32_t start_offset, /**< atom start offset */
        -:  148:                               uint32_t capture_start, /**< index of first nested capture */
        -:  149:                               bool negative) /** lookahead type */
        -:  150:{
    #####:  151:  const uint32_t qmin = re_ctx_p->token.qmin;
        -:  152:
    #####:  153:  re_append_opcode (re_ctx_p, RE_OP_ASSERT_END);
    #####:  154:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
        -:  155:
        -:  156:  /* We need to clear nested capturing group results when a negative assertion or the tail after a positive assertion
        -:  157:   * does not match, so we store the begin and end index of nested capturing groups. */
    #####:  158:  re_insert_value (re_ctx_p, start_offset, re_ctx_p->captures_count - capture_start);
    #####:  159:  re_insert_value (re_ctx_p, start_offset, capture_start);
        -:  160:
        -:  161:  /* Lookaheads always result in zero length matches, which means iterations will always stop on the first match.
        -:  162:   * This allows us to not have to deal with iterations beyond one. Either qmin == 0 which will implicitly match,
        -:  163:   * or qmin > 0, in which case the first iteration will decide whether the assertion matches depending on whether
        -:  164:   * the iteration matched or not. This also allows us to ignore qmax entirely. */
    #####:  165:  re_insert_byte (re_ctx_p, start_offset, (uint8_t) JERRY_MIN (qmin, 1));
        -:  166:
    #####:  167:  const re_opcode_t opcode = (negative) ? RE_OP_ASSERT_LOOKAHEAD_NEG : RE_OP_ASSERT_LOOKAHEAD_POS;
    #####:  168:  re_insert_opcode (re_ctx_p, start_offset, opcode);
    #####:  169:} /* re_insert_assertion_lookahead */
        -:  170:
        -:  171:/**
        -:  172: * Consume non greedy (question mark) character if present.
        -:  173: */
        -:  174:static void
    #####:  175:re_parse_lazy_char (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  176:{
    #####:  177:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  178:      && *re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  179:  {
    #####:  180:    re_ctx_p->input_curr_p++;
    #####:  181:    re_ctx_p->token.greedy = false;
    #####:  182:    return;
        -:  183:  }
        -:  184:
    #####:  185:  re_ctx_p->token.greedy = true;
        -:  186:} /* re_parse_lazy_char */
        -:  187:
        -:  188:/**
        -:  189: * Parse a max 3 digit long octal number from the input string, with a decimal value less than 256.
        -:  190: *
        -:  191: * @return value of the octal number
        -:  192: */
        -:  193:static uint32_t
    #####:  194:re_parse_octal (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  195:{
    #####:  196:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  197:  JERRY_ASSERT (lit_char_is_octal_digit (*re_ctx_p->input_curr_p));
        -:  198:
    #####:  199:  uint32_t value = (uint32_t) (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  200:
    #####:  201:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  202:      && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  203:  {
    #####:  204:    value = value * 8 + (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  205:  }
        -:  206:
    #####:  207:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  208:      && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  209:  {
    #####:  210:    const uint32_t new_value = value * 8 + (*re_ctx_p->input_curr_p) - LIT_CHAR_0;
        -:  211:
    #####:  212:    if (new_value <= RE_MAX_OCTAL_VALUE)
        -:  213:    {
    #####:  214:      value = new_value;
    #####:  215:      re_ctx_p->input_curr_p++;
        -:  216:    }
        -:  217:  }
        -:  218:
    #####:  219:  return value;
        -:  220:} /* re_parse_octal */
        -:  221:
        -:  222:/**
        -:  223: * Check that the currently parsed quantifier is valid.
        -:  224: *
        -:  225: * @return ECMA_VALUE_ERROR, if quantifier is invalid
        -:  226: *         ECMA_VALUE_EMPTY, otherwise
        -:  227: */
        -:  228:static ecma_value_t
    #####:  229:re_check_quantifier (re_compiler_ctx_t *re_ctx_p)
        -:  230:{
    #####:  231:  if (re_ctx_p->token.qmin > re_ctx_p->token.qmax)
        -:  232:  {
        -:  233:    /* ECMA-262 v5.1 15.10.2.5 */
    #####:  234:    return ecma_raise_syntax_error (ECMA_ERR_MSG ("Quantifier error: min > max"));
        -:  235:  }
        -:  236:
    #####:  237:  return ECMA_VALUE_EMPTY;
        -:  238:} /* re_check_quantifier */
        -:  239:
        -:  240:/**
        -:  241: * Parse RegExp quantifier.
        -:  242: *
        -:  243: * @return ECMA_VALUE_TRUE - if parsed successfully
        -:  244: *         ECMA_VALUE_FALSE - otherwise
        -:  245: */
        -:  246:static ecma_value_t
    #####:  247:re_parse_quantifier (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  248:{
    #####:  249:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  250:  {
    #####:  251:    switch (*re_ctx_p->input_curr_p)
        -:  252:    {
    #####:  253:      case LIT_CHAR_QUESTION:
        -:  254:      {
    #####:  255:        re_ctx_p->input_curr_p++;
    #####:  256:        re_ctx_p->token.qmin = 0;
    #####:  257:        re_ctx_p->token.qmax = 1;
        -:  258:
    #####:  259:        re_parse_lazy_char (re_ctx_p);
    #####:  260:        return ECMA_VALUE_TRUE;
        -:  261:      }
    #####:  262:      case LIT_CHAR_ASTERISK:
        -:  263:      {
    #####:  264:        re_ctx_p->input_curr_p++;
    #####:  265:        re_ctx_p->token.qmin = 0;
    #####:  266:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  267:
    #####:  268:        re_parse_lazy_char (re_ctx_p);
    #####:  269:        return ECMA_VALUE_TRUE;
        -:  270:      }
    #####:  271:      case LIT_CHAR_PLUS:
        -:  272:      {
    #####:  273:        re_ctx_p->input_curr_p++;
    #####:  274:        re_ctx_p->token.qmin = 1;
    #####:  275:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  276:
    #####:  277:        re_parse_lazy_char (re_ctx_p);
    #####:  278:        return ECMA_VALUE_TRUE;
        -:  279:      }
    #####:  280:      case LIT_CHAR_LEFT_BRACE:
        -:  281:      {
    #####:  282:        const lit_utf8_byte_t *current_p = re_ctx_p->input_curr_p + 1;
    #####:  283:        uint32_t qmin = 0;
    #####:  284:        uint32_t qmax = RE_INFINITY;
        -:  285:
    #####:  286:        if (current_p >= re_ctx_p->input_end_p)
        -:  287:        {
    #####:  288:          break;
        -:  289:        }
        -:  290:
    #####:  291:        if (!lit_char_is_decimal_digit (*current_p))
        -:  292:        {
    #####:  293:          break;
        -:  294:        }
        -:  295:
    #####:  296:        qmin = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  297:
    #####:  298:        if (current_p >= re_ctx_p->input_end_p)
        -:  299:        {
    #####:  300:          break;
        -:  301:        }
        -:  302:
    #####:  303:        lit_utf8_byte_t ch = *current_p++;
    #####:  304:        if (ch == LIT_CHAR_RIGHT_BRACE)
        -:  305:        {
    #####:  306:          qmax = qmin;
        -:  307:        }
    #####:  308:        else if (ch == LIT_CHAR_COMMA)
        -:  309:        {
    #####:  310:          if (current_p >= re_ctx_p->input_end_p)
        -:  311:          {
    #####:  312:            break;
        -:  313:          }
        -:  314:
    #####:  315:          if (lit_char_is_decimal_digit (*current_p))
        -:  316:          {
    #####:  317:            qmax = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  318:          }
        -:  319:
    #####:  320:          if (current_p >= re_ctx_p->input_end_p || *current_p++ != LIT_CHAR_RIGHT_BRACE)
        -:  321:          {
        -:  322:            break;
        -:  323:          }
        -:  324:        }
        -:  325:        else
        -:  326:        {
    #####:  327:          break;
        -:  328:        }
        -:  329:
    #####:  330:        re_ctx_p->token.qmin = qmin;
    #####:  331:        re_ctx_p->token.qmax = qmax;
    #####:  332:        re_ctx_p->input_curr_p = current_p;
    #####:  333:        re_parse_lazy_char (re_ctx_p);
    #####:  334:        return ECMA_VALUE_TRUE;
        -:  335:      }
    #####:  336:      default:
        -:  337:      {
    #####:  338:        break;
        -:  339:      }
        -:  340:    }
    #####:  341:  }
        -:  342:
    #####:  343:  re_ctx_p->token.qmin = 1;
    #####:  344:  re_ctx_p->token.qmax = 1;
    #####:  345:  re_ctx_p->token.greedy = true;
        -:  346:
    #####:  347:  return ECMA_VALUE_FALSE;
        -:  348:} /* re_parse_quantifier */
        -:  349:
        -:  350:/**
        -:  351: * Count the number of groups in the current pattern.
        -:  352: */
        -:  353:static void
    #####:  354:re_count_groups (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  355:{
    #####:  356:  bool is_char_class = 0;
    #####:  357:  re_ctx_p->groups_count = 0;
    #####:  358:  const lit_utf8_byte_t *curr_p = re_ctx_p->input_start_p;
        -:  359:
    #####:  360:  while (curr_p < re_ctx_p->input_end_p)
        -:  361:  {
    #####:  362:    switch (*curr_p++)
        -:  363:    {
    #####:  364:      case LIT_CHAR_BACKSLASH:
        -:  365:      {
    #####:  366:        if (curr_p < re_ctx_p->input_end_p)
        -:  367:        {
    #####:  368:          lit_utf8_incr (&curr_p);
        -:  369:        }
    #####:  370:        break;
        -:  371:      }
    #####:  372:      case LIT_CHAR_LEFT_SQUARE:
        -:  373:      {
    #####:  374:        is_char_class = true;
    #####:  375:        break;
        -:  376:      }
    #####:  377:      case LIT_CHAR_RIGHT_SQUARE:
        -:  378:      {
    #####:  379:        is_char_class = false;
    #####:  380:        break;
        -:  381:      }
    #####:  382:      case LIT_CHAR_LEFT_PAREN:
        -:  383:      {
    #####:  384:        if (curr_p < re_ctx_p->input_end_p
    #####:  385:            && *curr_p != LIT_CHAR_QUESTION
    #####:  386:            && !is_char_class)
        -:  387:        {
    #####:  388:          re_ctx_p->groups_count++;
        -:  389:        }
    #####:  390:        break;
        -:  391:      }
        -:  392:    }
        -:  393:  }
    #####:  394:} /* re_count_groups */
        -:  395:
        -:  396:#if JERRY_ESNEXT
        -:  397:/**
        -:  398: * Check if a code point is a Syntax character
        -:  399: *
        -:  400: * @return true, if syntax character
        -:  401: *         false, otherwise
        -:  402: */
        -:  403:static bool
    #####:  404:re_is_syntax_char (lit_code_point_t cp) /**< code point */
        -:  405:{
    #####:  406:  return (cp == LIT_CHAR_CIRCUMFLEX
    #####:  407:          || cp == LIT_CHAR_DOLLAR_SIGN
    #####:  408:          || cp == LIT_CHAR_BACKSLASH
    #####:  409:          || cp == LIT_CHAR_DOT
    #####:  410:          || cp == LIT_CHAR_ASTERISK
    #####:  411:          || cp == LIT_CHAR_PLUS
    #####:  412:          || cp == LIT_CHAR_QUESTION
    #####:  413:          || cp == LIT_CHAR_LEFT_PAREN
    #####:  414:          || cp == LIT_CHAR_RIGHT_PAREN
    #####:  415:          || cp == LIT_CHAR_LEFT_SQUARE
    #####:  416:          || cp == LIT_CHAR_RIGHT_SQUARE
    #####:  417:          || cp == LIT_CHAR_LEFT_BRACE
    #####:  418:          || cp == LIT_CHAR_RIGHT_BRACE
    #####:  419:          || cp == LIT_CHAR_VLINE);
        -:  420:} /* re_is_syntax_char */
        -:  421:#endif /* JERRY_ESNEXT */
        -:  422:
        -:  423:/**
        -:  424: * Parse a Character Escape or a Character Class Escape.
        -:  425: *
        -:  426: * @return ECMA_VALUE_EMPTY, if parsed successfully
        -:  427: *         ECMA_VALUE_ERROR, otherwise
        -:  428: */
        -:  429:static ecma_value_t
    #####:  430:re_parse_char_escape (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  431:{
    #####:  432:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  433:  re_ctx_p->token.type = RE_TOK_CHAR;
        -:  434:
    #####:  435:  if (lit_char_is_decimal_digit (*re_ctx_p->input_curr_p))
        -:  436:  {
        -:  437:    /* NULL code point escape, only valid if there are no following digits. */
    #####:  438:    if (*re_ctx_p->input_curr_p == LIT_CHAR_0
    #####:  439:        && (re_ctx_p->input_curr_p + 1 >= re_ctx_p->input_end_p
    #####:  440:            || !lit_char_is_decimal_digit (re_ctx_p->input_curr_p[1])))
        -:  441:    {
    #####:  442:      re_ctx_p->input_curr_p++;
    #####:  443:      re_ctx_p->token.value = LIT_UNICODE_CODE_POINT_NULL;
    #####:  444:      return ECMA_VALUE_EMPTY;
        -:  445:    }
        -:  446:
        -:  447:#if JERRY_ESNEXT
    #####:  448:    if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  449:    {
    #####:  450:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape sequence"));
        -:  451:    }
        -:  452:#endif /* JERRY_ESNEXT */
        -:  453:
        -:  454:    /* Legacy octal escape sequence */
    #####:  455:    if (lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  456:    {
    #####:  457:      re_ctx_p->token.value = re_parse_octal (re_ctx_p);
    #####:  458:      return ECMA_VALUE_EMPTY;
        -:  459:    }
        -:  460:
        -:  461:    /* Identity escape */
    #####:  462:    re_ctx_p->token.value = *re_ctx_p->input_curr_p++;
    #####:  463:    return ECMA_VALUE_EMPTY;
        -:  464:  }
        -:  465:
    #####:  466:  lit_code_point_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
    #####:  467:  switch (ch)
        -:  468:  {
        -:  469:    /* Character Class escapes */
    #####:  470:    case LIT_CHAR_LOWERCASE_D:
        -:  471:    {
    #####:  472:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  473:      re_ctx_p->token.value = RE_ESCAPE_DIGIT;
    #####:  474:      break;
        -:  475:    }
    #####:  476:    case LIT_CHAR_UPPERCASE_D:
        -:  477:    {
    #####:  478:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  479:      re_ctx_p->token.value = RE_ESCAPE_NOT_DIGIT;
    #####:  480:      break;
        -:  481:    }
    #####:  482:    case LIT_CHAR_LOWERCASE_S:
        -:  483:    {
    #####:  484:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  485:      re_ctx_p->token.value = RE_ESCAPE_WHITESPACE;
    #####:  486:      break;
        -:  487:    }
    #####:  488:    case LIT_CHAR_UPPERCASE_S:
        -:  489:    {
    #####:  490:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  491:      re_ctx_p->token.value = RE_ESCAPE_NOT_WHITESPACE;
    #####:  492:      break;
        -:  493:    }
    #####:  494:    case LIT_CHAR_LOWERCASE_W:
        -:  495:    {
    #####:  496:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  497:      re_ctx_p->token.value = RE_ESCAPE_WORD_CHAR;
    #####:  498:      break;
        -:  499:    }
    #####:  500:    case LIT_CHAR_UPPERCASE_W:
        -:  501:    {
    #####:  502:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  503:      re_ctx_p->token.value = RE_ESCAPE_NOT_WORD_CHAR;
    #####:  504:      break;
        -:  505:    }
        -:  506:    /* Control escapes */
    #####:  507:    case LIT_CHAR_LOWERCASE_F:
        -:  508:    {
    #####:  509:      re_ctx_p->token.value = LIT_CHAR_FF;
    #####:  510:      break;
        -:  511:    }
    #####:  512:    case LIT_CHAR_LOWERCASE_N:
        -:  513:    {
    #####:  514:      re_ctx_p->token.value = LIT_CHAR_LF;
    #####:  515:      break;
        -:  516:    }
    #####:  517:    case LIT_CHAR_LOWERCASE_R:
        -:  518:    {
    #####:  519:      re_ctx_p->token.value = LIT_CHAR_CR;
    #####:  520:      break;
        -:  521:    }
    #####:  522:    case LIT_CHAR_LOWERCASE_T:
        -:  523:    {
    #####:  524:      re_ctx_p->token.value = LIT_CHAR_TAB;
    #####:  525:      break;
        -:  526:    }
    #####:  527:    case LIT_CHAR_LOWERCASE_V:
        -:  528:    {
    #####:  529:      re_ctx_p->token.value = LIT_CHAR_VTAB;
    #####:  530:      break;
        -:  531:    }
        -:  532:    /* Control letter */
    #####:  533:    case LIT_CHAR_LOWERCASE_C:
        -:  534:    {
    #####:  535:      if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  536:      {
    #####:  537:        ch = *re_ctx_p->input_curr_p;
        -:  538:
    #####:  539:        if ((ch >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)
    #####:  540:            || (ch >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END))
        -:  541:        {
    #####:  542:          re_ctx_p->token.value = (ch % 32);
    #####:  543:          re_ctx_p->input_curr_p++;
        -:  544:
    #####:  545:          break;
        -:  546:        }
        -:  547:      }
        -:  548:
        -:  549:#if JERRY_ESNEXT
    #####:  550:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  551:      {
    #####:  552:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid control escape sequence"));
        -:  553:      }
        -:  554:#endif /* JERRY_ESNEXT */
        -:  555:
    #####:  556:      re_ctx_p->token.value = LIT_CHAR_BACKSLASH;
    #####:  557:      re_ctx_p->input_curr_p--;
        -:  558:
    #####:  559:      break;
        -:  560:    }
        -:  561:    /* Hex escape */
    #####:  562:    case LIT_CHAR_LOWERCASE_X:
        -:  563:    {
    #####:  564:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 2);
    #####:  565:      if (hex_value != UINT32_MAX)
        -:  566:      {
    #####:  567:        re_ctx_p->token.value = hex_value;
    #####:  568:        re_ctx_p->input_curr_p += 2;
    #####:  569:        break;
        -:  570:      }
        -:  571:
        -:  572:#if JERRY_ESNEXT
    #####:  573:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  574:      {
    #####:  575:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid hex escape sequence"));
        -:  576:      }
        -:  577:#endif /* JERRY_ESNEXT */
        -:  578:
    #####:  579:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_X;
    #####:  580:      break;
        -:  581:    }
        -:  582:    /* Unicode escape */
    #####:  583:    case LIT_CHAR_LOWERCASE_U:
        -:  584:    {
    #####:  585:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 4);
    #####:  586:      if (hex_value != UINT32_MAX)
        -:  587:      {
    #####:  588:        re_ctx_p->token.value = hex_value;
    #####:  589:        re_ctx_p->input_curr_p += 4;
        -:  590:
        -:  591:#if JERRY_ESNEXT
    #####:  592:        if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  593:            && lit_is_code_point_utf16_high_surrogate (re_ctx_p->token.value)
    #####:  594:            && re_ctx_p->input_curr_p + 6 <= re_ctx_p->input_end_p
    #####:  595:            && re_ctx_p->input_curr_p[0] == '\\'
    #####:  596:            && re_ctx_p->input_curr_p[1] == 'u')
        -:  597:        {
    #####:  598:          hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p + 2, re_ctx_p->input_end_p, 4);
    #####:  599:          if (lit_is_code_point_utf16_low_surrogate (hex_value))
        -:  600:          {
    #####:  601:            re_ctx_p->token.value = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) re_ctx_p->token.value,
    #####:  602:                                                                              (ecma_char_t) hex_value);
    #####:  603:            re_ctx_p->input_curr_p += 6;
        -:  604:          }
        -:  605:        }
        -:  606:#endif /* JERRY_ESNEXT */
        -:  607:
    #####:  608:        break;
        -:  609:      }
        -:  610:
        -:  611:#if JERRY_ESNEXT
    #####:  612:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  613:      {
    #####:  614:        if (re_ctx_p->input_curr_p + 1 < re_ctx_p->input_end_p
    #####:  615:            && re_ctx_p->input_curr_p[0] == LIT_CHAR_LEFT_BRACE
    #####:  616:            && lit_char_is_hex_digit (re_ctx_p->input_curr_p[1]))
        -:  617:        {
    #####:  618:          lit_code_point_t cp = lit_char_hex_to_int (re_ctx_p->input_curr_p[1]);
    #####:  619:          re_ctx_p->input_curr_p += 2;
        -:  620:
    #####:  621:          while (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_hex_digit (*re_ctx_p->input_curr_p))
        -:  622:          {
    #####:  623:            cp = cp * 16 + lit_char_hex_to_int (*re_ctx_p->input_curr_p++);
        -:  624:
    #####:  625:            if (JERRY_UNLIKELY (cp > LIT_UNICODE_CODE_POINT_MAX))
        -:  626:            {
    #####:  627:              return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid unicode escape sequence"));
        -:  628:            }
        -:  629:          }
        -:  630:
    #####:  631:          if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && *re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_BRACE)
        -:  632:          {
    #####:  633:            re_ctx_p->input_curr_p++;
    #####:  634:            re_ctx_p->token.value = cp;
    #####:  635:            break;
        -:  636:          }
        -:  637:        }
        -:  638:
    #####:  639:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid unicode escape sequence"));
        -:  640:      }
        -:  641:#endif /* JERRY_ESNEXT */
        -:  642:
    #####:  643:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_U;
    #####:  644:      break;
        -:  645:    }
        -:  646:    /* Identity escape */
    #####:  647:    default:
        -:  648:    {
        -:  649:#if JERRY_ESNEXT
        -:  650:      /* Must be '/', or one of SyntaxCharacter */
    #####:  651:      if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  652:          && ch != LIT_CHAR_SLASH
    #####:  653:          && !re_is_syntax_char (ch))
        -:  654:      {
    #####:  655:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  656:      }
        -:  657:#endif /* JERRY_ESNEXT */
    #####:  658:      re_ctx_p->token.value = ch;
        -:  659:    }
        -:  660:  }
        -:  661:
    #####:  662:  return ECMA_VALUE_EMPTY;
        -:  663:} /* re_parse_char_escape */
        -:  664:
        -:  665:/**
        -:  666: * Read the input pattern and parse the next token for the RegExp compiler
        -:  667: *
        -:  668: * @return empty ecma value - if parsed successfully
        -:  669: *         error ecma value - otherwise
        -:  670: *
        -:  671: *         Returned value must be freed with ecma_free_value
        -:  672: */
        -:  673:static ecma_value_t
    #####:  674:re_parse_next_token (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  675:{
    #####:  676:  if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  677:  {
    #####:  678:    re_ctx_p->token.type = RE_TOK_EOF;
    #####:  679:    return ECMA_VALUE_EMPTY;
        -:  680:  }
        -:  681:
    #####:  682:  ecma_char_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -:  683:
    #####:  684:  switch (ch)
        -:  685:  {
    #####:  686:    case LIT_CHAR_CIRCUMFLEX:
        -:  687:    {
    #####:  688:      re_ctx_p->token.type = RE_TOK_ASSERT_START;
    #####:  689:      return ECMA_VALUE_EMPTY;
        -:  690:    }
    #####:  691:    case LIT_CHAR_DOLLAR_SIGN:
        -:  692:    {
    #####:  693:      re_ctx_p->token.type = RE_TOK_ASSERT_END;
    #####:  694:      return ECMA_VALUE_EMPTY;
        -:  695:    }
    #####:  696:    case LIT_CHAR_VLINE:
        -:  697:    {
    #####:  698:      re_ctx_p->token.type = RE_TOK_ALTERNATIVE;
    #####:  699:      return ECMA_VALUE_EMPTY;
        -:  700:    }
    #####:  701:    case LIT_CHAR_DOT:
        -:  702:    {
    #####:  703:      re_ctx_p->token.type = RE_TOK_PERIOD;
        -:  704:      /* Check quantifier */
    #####:  705:      break;
        -:  706:    }
    #####:  707:    case LIT_CHAR_BACKSLASH:
        -:  708:    {
    #####:  709:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  710:      {
    #####:  711:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  712:      }
        -:  713:
        -:  714:      /* DecimalEscape, Backreferences cannot start with a zero digit. */
    #####:  715:      if (*re_ctx_p->input_curr_p > LIT_CHAR_0 && *re_ctx_p->input_curr_p <= LIT_CHAR_9)
        -:  716:      {
    #####:  717:        const lit_utf8_byte_t *digits_p = re_ctx_p->input_curr_p;
    #####:  718:        const uint32_t value = lit_parse_decimal (&digits_p, re_ctx_p->input_end_p);
        -:  719:
    #####:  720:        if (re_ctx_p->groups_count < 0)
        -:  721:        {
    #####:  722:          re_count_groups (re_ctx_p);
        -:  723:        }
        -:  724:
    #####:  725:        if (value <= (uint32_t) re_ctx_p->groups_count)
        -:  726:        {
        -:  727:          /* Valid backreference */
    #####:  728:          re_ctx_p->input_curr_p = digits_p;
    #####:  729:          re_ctx_p->token.type = RE_TOK_BACKREFERENCE;
    #####:  730:          re_ctx_p->token.value = value;
        -:  731:
        -:  732:          /* Check quantifier */
    #####:  733:          break;
        -:  734:        }
        -:  735:      }
        -:  736:
    #####:  737:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  738:      {
    #####:  739:        re_ctx_p->input_curr_p++;
    #####:  740:        re_ctx_p->token.type = RE_TOK_ASSERT_WORD_BOUNDARY;
    #####:  741:        return ECMA_VALUE_EMPTY;
        -:  742:      }
    #####:  743:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_UPPERCASE_B)
        -:  744:      {
    #####:  745:        re_ctx_p->input_curr_p++;
    #####:  746:        re_ctx_p->token.type = RE_TOK_ASSERT_NOT_WORD_BOUNDARY;
    #####:  747:        return ECMA_VALUE_EMPTY;
        -:  748:      }
        -:  749:
    #####:  750:      const ecma_value_t parse_result = re_parse_char_escape (re_ctx_p);
        -:  751:
    #####:  752:      if (ECMA_IS_VALUE_ERROR (parse_result))
        -:  753:      {
    #####:  754:        return parse_result;
        -:  755:      }
        -:  756:
        -:  757:      /* Check quantifier */
    #####:  758:      break;
        -:  759:    }
    #####:  760:    case LIT_CHAR_LEFT_PAREN:
        -:  761:    {
    #####:  762:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  763:      {
    #####:  764:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated group"));
        -:  765:      }
        -:  766:
    #####:  767:      if (*re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  768:      {
    #####:  769:        re_ctx_p->input_curr_p++;
    #####:  770:        if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  771:        {
    #####:  772:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid group"));
        -:  773:        }
        -:  774:
    #####:  775:        ch = *re_ctx_p->input_curr_p++;
        -:  776:
    #####:  777:        if (ch == LIT_CHAR_EQUALS)
        -:  778:        {
    #####:  779:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  780:          re_ctx_p->token.value = false;
        -:  781:        }
    #####:  782:        else if (ch == LIT_CHAR_EXCLAMATION)
        -:  783:        {
    #####:  784:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  785:          re_ctx_p->token.value = true;
        -:  786:        }
    #####:  787:        else if (ch == LIT_CHAR_COLON)
        -:  788:        {
    #####:  789:          re_ctx_p->token.type = RE_TOK_START_NON_CAPTURE_GROUP;
        -:  790:        }
        -:  791:        else
        -:  792:        {
    #####:  793:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid group"));
        -:  794:        }
        -:  795:      }
        -:  796:      else
        -:  797:      {
    #####:  798:        re_ctx_p->token.type = RE_TOK_START_CAPTURE_GROUP;
        -:  799:      }
        -:  800:
    #####:  801:      return ECMA_VALUE_EMPTY;
        -:  802:    }
    #####:  803:    case LIT_CHAR_RIGHT_PAREN:
        -:  804:    {
    #####:  805:      re_ctx_p->token.type = RE_TOK_END_GROUP;
        -:  806:
    #####:  807:      return ECMA_VALUE_EMPTY;
        -:  808:    }
    #####:  809:    case LIT_CHAR_LEFT_SQUARE:
        -:  810:    {
    #####:  811:      re_ctx_p->token.type = RE_TOK_CHAR_CLASS;
        -:  812:
    #####:  813:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  814:      {
    #####:  815:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated character class"));
        -:  816:      }
        -:  817:
    #####:  818:      return ECMA_VALUE_EMPTY;
        -:  819:    }
    #####:  820:    case LIT_CHAR_QUESTION:
        -:  821:    case LIT_CHAR_ASTERISK:
        -:  822:    case LIT_CHAR_PLUS:
        -:  823:    {
    #####:  824:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid quantifier"));
        -:  825:    }
    #####:  826:    case LIT_CHAR_LEFT_BRACE:
        -:  827:    {
    #####:  828:      re_ctx_p->input_curr_p--;
    #####:  829:      if (ecma_is_value_true (re_parse_quantifier (re_ctx_p)))
        -:  830:      {
    #####:  831:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Nothing to repeat"));
        -:  832:      }
        -:  833:
        -:  834:#if JERRY_ESNEXT
    #####:  835:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  836:      {
    #####:  837:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Lone quantifier bracket"));
        -:  838:      }
        -:  839:#endif /* JERRY_ESNEXT */
        -:  840:
    #####:  841:      re_ctx_p->input_curr_p++;
    #####:  842:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  843:      re_ctx_p->token.value = ch;
        -:  844:
        -:  845:      /* Check quantifier */
    #####:  846:      break;
        -:  847:    }
        -:  848:#if JERRY_ESNEXT
    #####:  849:    case LIT_CHAR_RIGHT_SQUARE:
        -:  850:    case LIT_CHAR_RIGHT_BRACE:
        -:  851:    {
    #####:  852:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  853:      {
    #####:  854:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Lone quantifier bracket"));
        -:  855:      }
        -:  856:
        -:  857:      /* FALLTHRU */
        -:  858:    }
        -:  859:#endif /* JERRY_ESNEXT */
    #####:  860:    default:
        -:  861:    {
    #####:  862:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  863:      re_ctx_p->token.value = ch;
        -:  864:
        -:  865:#if JERRY_ESNEXT
    #####:  866:      if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  867:          && lit_is_code_point_utf16_high_surrogate (ch)
    #####:  868:          && re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  869:      {
    #####:  870:        const ecma_char_t next = lit_cesu8_peek_next (re_ctx_p->input_curr_p);
    #####:  871:        if (lit_is_code_point_utf16_low_surrogate (next))
        -:  872:        {
    #####:  873:          re_ctx_p->token.value = lit_convert_surrogate_pair_to_code_point (ch, next);
    #####:  874:          re_ctx_p->input_curr_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  875:        }
        -:  876:      }
        -:  877:#endif /* JERRY_ESNEXT */
        -:  878:
        -:  879:      /* Check quantifier */
    #####:  880:      break;
        -:  881:    }
        -:  882:  }
        -:  883:
    #####:  884:  re_parse_quantifier (re_ctx_p);
    #####:  885:  return re_check_quantifier (re_ctx_p);
        -:  886:} /* re_parse_next_token */
        -:  887:
        -:  888:/**
        -:  889: * Append a character class range to the bytecode.
        -:  890: */
        -:  891:static void
    #####:  892:re_class_add_range (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  893:                    lit_code_point_t start, /**< range begin */
        -:  894:                    lit_code_point_t end) /**< range end */
        -:  895:{
    #####:  896:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  897:  {
    #####:  898:    start = ecma_regexp_canonicalize_char (start, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####:  899:    end = ecma_regexp_canonicalize_char (end, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  900:  }
        -:  901:
    #####:  902:  re_append_char (re_ctx_p, start);
    #####:  903:  re_append_char (re_ctx_p, end);
    #####:  904:} /* re_class_add_range */
        -:  905:
        -:  906:/**
        -:  907: * Add a single character to the character class
        -:  908: */
        -:  909:static void
    #####:  910:re_class_add_char (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  911:                    uint32_t class_offset, /**< character class bytecode offset*/
        -:  912:                    lit_code_point_t cp) /**< code point */
        -:  913:{
    #####:  914:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  915:  {
    #####:  916:    cp = ecma_regexp_canonicalize_char (cp, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  917:  }
        -:  918:
    #####:  919:  re_insert_char (re_ctx_p, class_offset, cp);
    #####:  920:} /* re_class_add_char */
        -:  921:
        -:  922:/**
        -:  923: * Invalid character code point
        -:  924: */
        -:  925:#define RE_INVALID_CP 0xFFFFFFFF
        -:  926:
        -:  927:/**
        -:  928: * Read the input pattern and parse the range of character class
        -:  929: *
        -:  930: * @return empty ecma value - if parsed successfully
        -:  931: *         error ecma value - otherwise
        -:  932: *
        -:  933: *         Returned value must be freed with ecma_free_value
        -:  934: */
        -:  935:static ecma_value_t
    #####:  936:re_parse_char_class (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  937:{
        -:  938:  static const uint8_t escape_flags[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20};
    #####:  939:  const uint32_t class_offset = re_bytecode_size (re_ctx_p);
        -:  940:
    #####:  941:  uint8_t found_escape_flags = 0;
    #####:  942:  uint8_t out_class_flags = 0;
        -:  943:
    #####:  944:  uint32_t range_count = 0;
    #####:  945:  uint32_t char_count = 0;
    #####:  946:  bool is_range = false;
        -:  947:
    #####:  948:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  949:  if (*re_ctx_p->input_curr_p == LIT_CHAR_CIRCUMFLEX)
        -:  950:  {
    #####:  951:    re_ctx_p->input_curr_p++;
    #####:  952:    out_class_flags |= RE_CLASS_INVERT;
        -:  953:  }
        -:  954:
    #####:  955:  lit_code_point_t start = RE_INVALID_CP;
        -:  956:
        -:  957:  while (true)
    #####:  958:  {
    #####:  959:    if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  960:    {
    #####:  961:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated character class"));
        -:  962:    }
        -:  963:
    #####:  964:    if (*re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_SQUARE)
        -:  965:    {
    #####:  966:      if (is_range)
        -:  967:      {
    #####:  968:        if (start != RE_INVALID_CP)
        -:  969:        {
    #####:  970:          re_class_add_char (re_ctx_p, class_offset, start);
    #####:  971:          char_count++;
        -:  972:        }
        -:  973:
    #####:  974:        re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####:  975:        char_count++;
        -:  976:      }
        -:  977:
    #####:  978:      re_ctx_p->input_curr_p++;
    #####:  979:      break;
        -:  980:    }
        -:  981:
    #####:  982:    JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
        -:  983:    lit_code_point_t current;
        -:  984:
    #####:  985:    if (*re_ctx_p->input_curr_p == LIT_CHAR_BACKSLASH)
        -:  986:    {
    #####:  987:      re_ctx_p->input_curr_p++;
    #####:  988:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  989:      {
    #####:  990:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  991:      }
        -:  992:
    #####:  993:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  994:      {
    #####:  995:        re_ctx_p->input_curr_p++;
    #####:  996:        current = LIT_CHAR_BS;
        -:  997:      }
        -:  998:#if JERRY_ESNEXT
    #####:  999:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -: 1000:      {
    #####: 1001:        re_ctx_p->input_curr_p++;
    #####: 1002:        current = LIT_CHAR_MINUS;
        -: 1003:      }
        -: 1004:#endif /* JERRY_ESNEXT */
    #####: 1005:      else if ((re_ctx_p->flags & RE_FLAG_UNICODE) == 0
    #####: 1006:               && *re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_C
    #####: 1007:               && re_ctx_p->input_curr_p + 1 < re_ctx_p->input_end_p
    #####: 1008:               && (lit_char_is_decimal_digit (*(re_ctx_p->input_curr_p + 1))
    #####: 1009:                   || *(re_ctx_p->input_curr_p + 1) == LIT_CHAR_UNDERSCORE))
        -: 1010:      {
    #####: 1011:        current = ((uint8_t) *(re_ctx_p->input_curr_p + 1) % 32);
    #####: 1012:        re_ctx_p->input_curr_p += 2;
        -: 1013:      }
        -: 1014:      else
        -: 1015:      {
    #####: 1016:        if (ECMA_IS_VALUE_ERROR (re_parse_char_escape (re_ctx_p)))
        -: 1017:        {
    #####: 1018:          return ECMA_VALUE_ERROR;
        -: 1019:        }
        -: 1020:
    #####: 1021:        if (re_ctx_p->token.type == RE_TOK_CLASS_ESCAPE)
        -: 1022:        {
    #####: 1023:          const uint8_t escape = (uint8_t) re_ctx_p->token.value;
    #####: 1024:          found_escape_flags |= escape_flags[escape];
    #####: 1025:          current = RE_INVALID_CP;
        -: 1026:        }
        -: 1027:        else
        -: 1028:        {
    #####: 1029:          JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
    #####: 1030:          current = re_ctx_p->token.value;
        -: 1031:        }
        -: 1032:      }
        -: 1033:    }
        -: 1034:#if JERRY_ESNEXT
    #####: 1035:    else if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1036:    {
    #####: 1037:      current = ecma_regexp_unicode_advance (&re_ctx_p->input_curr_p, re_ctx_p->input_end_p);
        -: 1038:    }
        -: 1039:#endif /* JERRY_ESNEXT */
        -: 1040:    else
        -: 1041:    {
    #####: 1042:      current = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -: 1043:    }
        -: 1044:
    #####: 1045:    if (is_range)
        -: 1046:    {
    #####: 1047:      is_range = false;
        -: 1048:
    #####: 1049:      if (start != RE_INVALID_CP && current != RE_INVALID_CP)
        -: 1050:      {
    #####: 1051:        if (start > current)
        -: 1052:        {
    #####: 1053:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Range out of order in character class"));
        -: 1054:        }
        -: 1055:
    #####: 1056:        re_class_add_range (re_ctx_p, start, current);
    #####: 1057:        range_count++;
    #####: 1058:        continue;
        -: 1059:      }
        -: 1060:
        -: 1061:#if JERRY_ESNEXT
    #####: 1062:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1063:      {
    #####: 1064:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid character class"));
        -: 1065:      }
        -: 1066:#endif /* JERRY_ESNEXT */
        -: 1067:
    #####: 1068:      if (start != RE_INVALID_CP)
        -: 1069:      {
    #####: 1070:        re_class_add_char (re_ctx_p, class_offset, start);
    #####: 1071:        char_count++;
        -: 1072:      }
    #####: 1073:      else if (current != RE_INVALID_CP)
        -: 1074:      {
    #####: 1075:        re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1076:        char_count++;
        -: 1077:      }
        -: 1078:
    #####: 1079:      re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####: 1080:      char_count++;
    #####: 1081:      continue;
        -: 1082:    }
        -: 1083:
    #####: 1084:    if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####: 1085:        && *re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -: 1086:    {
    #####: 1087:      re_ctx_p->input_curr_p++;
    #####: 1088:      start = current;
    #####: 1089:      is_range = true;
    #####: 1090:      continue;
        -: 1091:    }
        -: 1092:
    #####: 1093:    if (current != RE_INVALID_CP)
        -: 1094:    {
    #####: 1095:      re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1096:      char_count++;
        -: 1097:    }
        -: 1098:  }
        -: 1099:
    #####: 1100:  uint8_t escape_count = 0;
    #####: 1101:  for (ecma_class_escape_t escape = RE_ESCAPE__START; escape < RE_ESCAPE__COUNT; ++escape)
        -: 1102:  {
    #####: 1103:    if (found_escape_flags & escape_flags[escape])
        -: 1104:    {
    #####: 1105:      re_insert_byte (re_ctx_p, class_offset, (uint8_t) escape);
    #####: 1106:      escape_count++;
        -: 1107:    }
        -: 1108:  }
        -: 1109:
    #####: 1110:  if (range_count > 0)
        -: 1111:  {
    #####: 1112:    re_insert_value (re_ctx_p, class_offset, range_count);
    #####: 1113:    out_class_flags |= RE_CLASS_HAS_RANGES;
        -: 1114:  }
        -: 1115:
    #####: 1116:  if (char_count > 0)
        -: 1117:  {
    #####: 1118:    re_insert_value (re_ctx_p, class_offset, char_count);
    #####: 1119:    out_class_flags |= RE_CLASS_HAS_CHARS;
        -: 1120:  }
        -: 1121:
    #####: 1122:  JERRY_ASSERT (escape_count <= RE_CLASS_ESCAPE_COUNT_MASK);
    #####: 1123:  out_class_flags |= escape_count;
        -: 1124:
    #####: 1125:  re_insert_byte (re_ctx_p, class_offset, out_class_flags);
    #####: 1126:  re_insert_opcode (re_ctx_p, class_offset, RE_OP_CHAR_CLASS);
        -: 1127:
    #####: 1128:  re_parse_quantifier (re_ctx_p);
    #####: 1129:  return re_check_quantifier (re_ctx_p);
        -: 1130:} /* re_parse_char_class */
        -: 1131:
        -: 1132:/**
        -: 1133: * Parse alternatives
        -: 1134: *
        -: 1135: * @return empty ecma value - if alternative was successfully parsed
        -: 1136: *         error ecma value - otherwise
        -: 1137: *
        -: 1138: *         Returned value must be freed with ecma_free_value
        -: 1139: */
        -: 1140:ecma_value_t
    #####: 1141:re_parse_alternative (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -: 1142:                      bool expect_eof) /**< expect end of file */
        -: 1143:{
    #####: 1144:  ECMA_CHECK_STACK_USAGE ();
    #####: 1145:  uint32_t alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1146:  bool first_alternative = true;
        -: 1147:
        -: 1148:  while (true)
    #####: 1149:  {
    #####: 1150:    ecma_value_t next_token_result = re_parse_next_token (re_ctx_p);
    #####: 1151:    if (ECMA_IS_VALUE_ERROR (next_token_result))
        -: 1152:    {
    #####: 1153:      return next_token_result;
        -: 1154:    }
        -: 1155:
    #####: 1156:    JERRY_ASSERT (ecma_is_value_empty (next_token_result));
        -: 1157:
    #####: 1158:    uint32_t atom_offset = re_bytecode_size (re_ctx_p);
        -: 1159:
    #####: 1160:    switch (re_ctx_p->token.type)
        -: 1161:    {
    #####: 1162:      case RE_TOK_START_CAPTURE_GROUP:
        -: 1163:      {
    #####: 1164:        const uint32_t idx = re_ctx_p->captures_count++;
    #####: 1165:        const uint32_t capture_start = idx;
        -: 1166:
    #####: 1167:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1168:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1169:        {
    #####: 1170:          return result;
        -: 1171:        }
        -: 1172:
    #####: 1173:        re_parse_quantifier (re_ctx_p);
        -: 1174:
    #####: 1175:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1176:        {
    #####: 1177:          return ECMA_VALUE_ERROR;
        -: 1178:        }
        -: 1179:
    #####: 1180:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, true);
    #####: 1181:        break;
        -: 1182:      }
    #####: 1183:      case RE_TOK_START_NON_CAPTURE_GROUP:
        -: 1184:      {
    #####: 1185:        const uint32_t idx = re_ctx_p->non_captures_count++;
    #####: 1186:        const uint32_t capture_start = re_ctx_p->captures_count;
        -: 1187:
    #####: 1188:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1189:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1190:        {
    #####: 1191:          return result;
        -: 1192:        }
        -: 1193:
    #####: 1194:        re_parse_quantifier (re_ctx_p);
        -: 1195:
    #####: 1196:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1197:        {
    #####: 1198:          return ECMA_VALUE_ERROR;
        -: 1199:        }
        -: 1200:
    #####: 1201:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, false);
    #####: 1202:        break;
        -: 1203:      }
    #####: 1204:      case RE_TOK_PERIOD:
        -: 1205:      {
        -: 1206:#if JERRY_ESNEXT
    #####: 1207:        re_append_opcode (re_ctx_p, (re_ctx_p->flags & RE_FLAG_UNICODE) ? RE_OP_UNICODE_PERIOD : RE_OP_PERIOD);
        -: 1208:#else /* !JERRY_ESNEXT */
    #####: 1209:        re_append_opcode (re_ctx_p, RE_OP_PERIOD);
        -: 1210:#endif /* !JERRY_ESNEXT */
        -: 1211:
    #####: 1212:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1213:        break;
        -: 1214:      }
    #####: 1215:      case RE_TOK_ALTERNATIVE:
        -: 1216:      {
    #####: 1217:        re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1218:        re_insert_opcode (re_ctx_p, alternative_offset, first_alternative ? RE_OP_ALTERNATIVE_START
        -: 1219:                                                                          : RE_OP_ALTERNATIVE_NEXT);
        -: 1220:
    #####: 1221:        alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1222:        first_alternative = false;
    #####: 1223:        break;
        -: 1224:      }
    #####: 1225:      case RE_TOK_ASSERT_START:
        -: 1226:      {
    #####: 1227:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_START);
    #####: 1228:        break;
        -: 1229:      }
    #####: 1230:      case RE_TOK_ASSERT_END:
        -: 1231:      {
    #####: 1232:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_END);
    #####: 1233:        break;
        -: 1234:      }
    #####: 1235:      case RE_TOK_ASSERT_WORD_BOUNDARY:
        -: 1236:      {
    #####: 1237:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_WORD_BOUNDARY);
    #####: 1238:        break;
        -: 1239:      }
    #####: 1240:      case RE_TOK_ASSERT_NOT_WORD_BOUNDARY:
        -: 1241:      {
    #####: 1242:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_NOT_WORD_BOUNDARY);
    #####: 1243:        break;
        -: 1244:      }
    #####: 1245:      case RE_TOK_ASSERT_LOOKAHEAD:
        -: 1246:      {
    #####: 1247:        const uint32_t start_capture_count = re_ctx_p->captures_count;
    #####: 1248:        const bool is_negative = !!re_ctx_p->token.value;
        -: 1249:
    #####: 1250:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
        -: 1251:
    #####: 1252:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1253:        {
    #####: 1254:          return result;
        -: 1255:        }
        -: 1256:
        -: 1257:#if JERRY_ESNEXT
    #####: 1258:        if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1259:        {
    #####: 1260:          re_ctx_p->token.qmin = 1;
    #####: 1261:          re_ctx_p->token.qmax = 1;
    #####: 1262:          re_ctx_p->token.greedy = true;
        -: 1263:        }
        -: 1264:        else
        -: 1265:#endif /* JERRY_ESNEXT */
        -: 1266:        {
    #####: 1267:          re_parse_quantifier (re_ctx_p);
        -: 1268:
    #####: 1269:          if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1270:          {
    #####: 1271:            return ECMA_VALUE_ERROR;
        -: 1272:          }
        -: 1273:        }
        -: 1274:
    #####: 1275:        re_insert_assertion_lookahead (re_ctx_p, atom_offset, start_capture_count, is_negative);
    #####: 1276:        break;
        -: 1277:      }
    #####: 1278:      case RE_TOK_BACKREFERENCE:
        -: 1279:      {
    #####: 1280:        const uint32_t backref_idx = re_ctx_p->token.value;
    #####: 1281:        re_append_opcode (re_ctx_p, RE_OP_BACKREFERENCE);
    #####: 1282:        re_append_value (re_ctx_p, backref_idx);
        -: 1283:
    #####: 1284:        if (re_ctx_p->token.qmin != 1 || re_ctx_p->token.qmax != 1)
        -: 1285:        {
    #####: 1286:          const uint32_t group_idx = re_ctx_p->non_captures_count++;
    #####: 1287:          re_insert_into_group (re_ctx_p, atom_offset, group_idx, re_ctx_p->captures_count, false);
        -: 1288:        }
        -: 1289:
    #####: 1290:        break;
        -: 1291:      }
    #####: 1292:      case RE_TOK_CLASS_ESCAPE:
        -: 1293:      {
    #####: 1294:        const ecma_class_escape_t escape = (ecma_class_escape_t) re_ctx_p->token.value;
    #####: 1295:        re_append_opcode (re_ctx_p, RE_OP_CLASS_ESCAPE);
    #####: 1296:        re_append_byte (re_ctx_p, (uint8_t) escape);
        -: 1297:
    #####: 1298:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1299:        break;
        -: 1300:      }
    #####: 1301:      case RE_TOK_CHAR_CLASS:
        -: 1302:      {
    #####: 1303:        ecma_value_t result = re_parse_char_class (re_ctx_p);
        -: 1304:
    #####: 1305:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1306:        {
    #####: 1307:          return result;
        -: 1308:        }
        -: 1309:
    #####: 1310:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1311:        break;
        -: 1312:      }
    #####: 1313:      case RE_TOK_END_GROUP:
        -: 1314:      {
    #####: 1315:        if (expect_eof)
        -: 1316:        {
    #####: 1317:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unmatched close bracket"));
        -: 1318:        }
        -: 1319:
    #####: 1320:        if (!first_alternative)
        -: 1321:        {
    #####: 1322:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1323:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1324:        }
        -: 1325:
    #####: 1326:        return ECMA_VALUE_EMPTY;
        -: 1327:      }
    #####: 1328:      case RE_TOK_EOF:
        -: 1329:      {
    #####: 1330:        if (!expect_eof)
        -: 1331:        {
    #####: 1332:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unexpected end of pattern"));
        -: 1333:        }
        -: 1334:
    #####: 1335:        if (!first_alternative)
        -: 1336:        {
    #####: 1337:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1338:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1339:        }
        -: 1340:
    #####: 1341:        re_append_opcode (re_ctx_p, RE_OP_EOF);
    #####: 1342:        return ECMA_VALUE_EMPTY;
        -: 1343:      }
    #####: 1344:      default:
        -: 1345:      {
    #####: 1346:        JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
        -: 1347:
    #####: 1348:        lit_code_point_t ch = re_ctx_p->token.value;
        -: 1349:
    #####: 1350:        if (ch <= LIT_UTF8_1_BYTE_CODE_POINT_MAX && (re_ctx_p->flags & RE_FLAG_IGNORE_CASE) == 0)
        -: 1351:        {
    #####: 1352:          re_append_opcode (re_ctx_p, RE_OP_BYTE);
    #####: 1353:          re_append_byte (re_ctx_p, (uint8_t) ch);
        -: 1354:
    #####: 1355:          re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1356:          break;
        -: 1357:        }
        -: 1358:
    #####: 1359:        if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -: 1360:        {
    #####: 1361:          ch = ecma_regexp_canonicalize_char (ch, re_ctx_p->flags & RE_FLAG_UNICODE);
        -: 1362:        }
        -: 1363:
    #####: 1364:        re_append_opcode (re_ctx_p, RE_OP_CHAR);
    #####: 1365:        re_append_char (re_ctx_p, ch);
        -: 1366:
    #####: 1367:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1368:        break;
        -: 1369:      }
        -: 1370:    }
        -: 1371:  }
        -: 1372:
        -: 1373:  return ECMA_VALUE_EMPTY;
        -: 1374:} /* re_parse_alternative */
        -: 1375:
        -: 1376:/**
        -: 1377: * @}
        -: 1378: * @}
        -: 1379: * @}
        -: 1380: */
        -: 1381:
        -: 1382:#endif /* JERRY_BUILTIN_REGEXP */
