        -:    0:Source:/home/workspace/jerry-core/vm/opcodes.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-lex-env.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-promise-object.h"
        -:   30:#include "ecma-proxy-object.h"
        -:   31:#include "jcontext.h"
        -:   32:#include "opcodes.h"
        -:   33:#include "vm-defines.h"
        -:   34:#include "vm-stack.h"
        -:   35:
        -:   36:/** \addtogroup vm Virtual machine
        -:   37: * @{
        -:   38: *
        -:   39: * \addtogroup vm_opcodes Opcodes
        -:   40: * @{
        -:   41: */
        -:   42:
        -:   43:/**
        -:   44: * 'typeof' opcode handler.
        -:   45: *
        -:   46: * See also: ECMA-262 v5, 11.4.3
        -:   47: *
        -:   48: * @return ecma value
        -:   49: *         Returned value must be freed with ecma_free_value
        -:   50: */
        -:   51:ecma_value_t
    #####:   52:opfunc_typeof (ecma_value_t left_value) /**< left value */
        -:   53:{
    #####:   54:  return ecma_make_magic_string_value (ecma_get_typeof_lit_id (left_value));
        -:   55:} /* opfunc_typeof */
        -:   56:
        -:   57:/**
        -:   58: * Update data property for object literals.
        -:   59: */
        -:   60:void
        2:   61:opfunc_set_data_property (ecma_object_t *object_p, /**< object */
        -:   62:                          ecma_string_t *prop_name_p, /**< data property name */
        -:   63:                          ecma_value_t value) /**< new value */
        -:   64:{
        2:   65:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:   66:
        2:   67:  ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);
        -:   68:  ecma_property_value_t *prop_value_p;
        -:   69:
        2:   70:  if (property_p == NULL)
        -:   71:  {
        2:   72:    prop_value_p = ecma_create_named_data_property (object_p,
        -:   73:                                                    prop_name_p,
        -:   74:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:   75:                                                    NULL);
        -:   76:  }
        -:   77:  else
        -:   78:  {
    #####:   79:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:   80:
    #####:   81:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   82:
    #####:   83:    if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:   84:    {
        -:   85:#if JERRY_CPOINTER_32_BIT
        -:   86:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:   87:      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:   88:                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);
    #####:   89:      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -:   90:#endif /* JERRY_CPOINTER_32_BIT */
        -:   91:
    #####:   92:      *property_p |= ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE;
    #####:   93:      prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:   94:      return;
        -:   95:    }
        -:   96:  }
        -:   97:
        2:   98:  ecma_named_data_property_assign_value (object_p, prop_value_p, value);
        -:   99:} /* opfunc_set_data_property */
        -:  100:
        -:  101:/**
        -:  102: * Update getter or setter for object literals.
        -:  103: */
        -:  104:void
    #####:  105:opfunc_set_accessor (bool is_getter, /**< is getter accessor */
        -:  106:                     ecma_value_t object, /**< object value */
        -:  107:                     ecma_string_t *accessor_name_p, /**< accessor name */
        -:  108:                     ecma_value_t accessor) /**< accessor value */
        -:  109:{
    #####:  110:  ecma_object_t *object_p = ecma_get_object_from_value (object);
        -:  111:
    #####:  112:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:  113:
    #####:  114:  ecma_property_t *property_p = ecma_find_named_property (object_p, accessor_name_p);
    #####:  115:  ecma_object_t *accessor_p = ecma_get_object_from_value (accessor);
        -:  116:
    #####:  117:  ecma_object_t *getter_func_p = NULL;
    #####:  118:  ecma_object_t *setter_func_p = NULL;
        -:  119:
    #####:  120:  if (is_getter)
        -:  121:  {
    #####:  122:    getter_func_p = accessor_p;
        -:  123:  }
        -:  124:  else
        -:  125:  {
    #####:  126:    setter_func_p = accessor_p;
        -:  127:  }
        -:  128:
    #####:  129:  if (property_p == NULL)
        -:  130:  {
    #####:  131:    ecma_create_named_accessor_property (object_p,
        -:  132:                                         accessor_name_p,
        -:  133:                                         getter_func_p,
        -:  134:                                         setter_func_p,
        -:  135:                                         ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE,
        -:  136:                                         NULL);
        -:  137:  }
        -:  138:  else
        -:  139:  {
    #####:  140:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  141:
    #####:  142:    ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  143:
    #####:  144:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  145:    {
        -:  146:#if JERRY_CPOINTER_32_BIT
        -:  147:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:  148:      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        -:  149:#endif /* JERRY_CPOINTER_32_BIT */
        -:  150:
    #####:  151:      ecma_free_value_if_not_object (prop_value_p->value);
    #####:  152:      *property_p = (uint8_t) (*property_p & ~(ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE));
        -:  153:
        -:  154:#if JERRY_CPOINTER_32_BIT
    #####:  155:      ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_func_p);
    #####:  156:      ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_func_p);
    #####:  157:      ECMA_SET_NON_NULL_POINTER (prop_value_p->getter_setter_pair_cp, getter_setter_pair_p);
        -:  158:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  159:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_func_p);
    #####:  160:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_func_p);
        -:  161:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  162:      return;
        -:  163:    }
        -:  164:
    #####:  165:    if (is_getter)
        -:  166:    {
    #####:  167:      ecma_set_named_accessor_property_getter (object_p, prop_value_p, accessor_p);
        -:  168:    }
        -:  169:    else
        -:  170:    {
    #####:  171:      ecma_set_named_accessor_property_setter (object_p, prop_value_p, accessor_p);
        -:  172:    }
        -:  173:  }
        -:  174:} /* opfunc_set_accessor */
        -:  175:
        -:  176:/**
        -:  177: * Deletes an object property.
        -:  178: *
        -:  179: * @return ecma value
        -:  180: *         Returned value must be freed with ecma_free_value
        -:  181: */
        -:  182:ecma_value_t
    #####:  183:vm_op_delete_prop (ecma_value_t object, /**< base object */
        -:  184:                   ecma_value_t property, /**< property name */
        -:  185:                   bool is_strict) /**< strict mode */
        -:  186:{
        -:  187:#if !JERRY_ESNEXT
    #####:  188:  if (ecma_is_value_undefined (object))
        -:  189:  {
        -:  190:    return ECMA_VALUE_TRUE;
        -:  191:  }
        -:  192:#endif /* !JERRY_ESNEXT */
        -:  193:
    #####:  194:  if (!ecma_op_require_object_coercible (object))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:
    #####:  199:  ecma_string_t *name_string_p = ecma_op_to_property_key (property);
        -:  200:
    #####:  201:  if (JERRY_UNLIKELY (name_string_p == NULL))
        -:  202:  {
    #####:  203:    return ECMA_VALUE_ERROR;
        -:  204:  }
        -:  205:
    #####:  206:  ecma_value_t obj_value = ecma_op_to_object (object);
        -:  207:  /* The ecma_op_require_object_coercible call already checked the op_to_object error cases. */
    #####:  208:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_value));
    #####:  209:  JERRY_ASSERT (ecma_is_value_object (obj_value));
    #####:  210:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  211:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -:  212:
    #####:  213:  ecma_value_t delete_op_ret = ecma_op_object_delete (obj_p, name_string_p, is_strict);
    #####:  214:  JERRY_ASSERT (ecma_is_value_boolean (delete_op_ret) || ECMA_IS_VALUE_ERROR (delete_op_ret));
    #####:  215:  ecma_deref_object (obj_p);
    #####:  216:  ecma_deref_ecma_string (name_string_p);
        -:  217:
        -:  218:#if JERRY_ESNEXT
    #####:  219:  if (is_strict && ecma_is_value_false (delete_op_ret))
        -:  220:  {
    #####:  221:    return ecma_raise_type_error (ECMA_ERR_MSG ("Operator delete returned false in strict mode"));
        -:  222:  }
        -:  223:#endif /* JERRY_ESNEXT */
        -:  224:
    #####:  225:  return delete_op_ret;
        -:  226:} /* vm_op_delete_prop */
        -:  227:
        -:  228:/**
        -:  229: * Deletes a variable.
        -:  230: *
        -:  231: * @return ecma value
        -:  232: *         Returned value must be freed with ecma_free_value
        -:  233: */
        -:  234:ecma_value_t
    #####:  235:vm_op_delete_var (ecma_value_t name_literal, /**< name literal */
        -:  236:                  ecma_object_t *lex_env_p) /**< lexical environment */
        -:  237:{
    #####:  238:  ecma_value_t completion_value = ECMA_VALUE_EMPTY;
        -:  239:
    #####:  240:  ecma_string_t *var_name_str_p = ecma_get_string_from_value (name_literal);
        -:  241:
    #####:  242:  ecma_object_t *ref_base_lex_env_p = ecma_op_resolve_reference_base (lex_env_p, var_name_str_p);
        -:  243:
        -:  244:#if JERRY_BUILTIN_PROXY
    #####:  245:  if (JERRY_UNLIKELY (ref_base_lex_env_p == ECMA_OBJECT_POINTER_ERROR))
        -:  246:  {
    #####:  247:    return ECMA_VALUE_ERROR;
        -:  248:  }
        -:  249:#endif /* JERRY_BUILTIN_PROXY */
        -:  250:
    #####:  251:  if (ref_base_lex_env_p == NULL)
        -:  252:  {
    #####:  253:    completion_value = ECMA_VALUE_TRUE;
        -:  254:  }
        -:  255:  else
        -:  256:  {
    #####:  257:    JERRY_ASSERT (ecma_is_lexical_environment (ref_base_lex_env_p));
        -:  258:
    #####:  259:    completion_value = ecma_op_delete_binding (ref_base_lex_env_p, var_name_str_p);
        -:  260:  }
        -:  261:
    #####:  262:  return completion_value;
        -:  263:} /* vm_op_delete_var */
        -:  264:
        -:  265:/**
        -:  266: * 'for-in' opcode handler
        -:  267: *
        -:  268: *  Note: from ES2015 (ES6) the for-in can trigger error when
        -:  269: *        the property names are not available (ex.: via Proxy ownKeys).
        -:  270: *        In these cases an error must be returned.
        -:  271: *
        -:  272: *        This error is returned as the `result_obj_p` and the
        -:  273: *        function's return value is NULL.
        -:  274: *
        -:  275: * See also:
        -:  276: *          ECMA-262 v5, 12.6.4
        -:  277: *
        -:  278: * @return - chain list of property names
        -:  279: *         - In case of error: NULL is returned and the `result_obj_p`
        -:  280: *           must be checked.
        -:  281: */
        -:  282:ecma_collection_t *
        1:  283:opfunc_for_in (ecma_value_t iterable_value, /**< ideally an iterable value */
        -:  284:               ecma_value_t *result_obj_p) /**< expression object */
        -:  285:{
        -:  286:  /* 3. */
        1:  287:  if (ecma_is_value_undefined (iterable_value)
        1:  288:      || ecma_is_value_null (iterable_value))
        -:  289:  {
    #####:  290:    return NULL;
        -:  291:  }
        -:  292:
        -:  293:  /* 4. */
        1:  294:  ecma_value_t obj_expr_value = ecma_op_to_object (iterable_value);
        -:  295:  /* ecma_op_to_object will only raise error on null/undefined values but those are handled above. */
        1:  296:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_expr_value));
        1:  297:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_expr_value);
        1:  298:  ecma_collection_t *prop_names_p = ecma_op_object_enumerate (obj_p);
        -:  299:
        -:  300:#if JERRY_ESNEXT
        1:  301:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -:  302:  {
    #####:  303:    ecma_deref_object (obj_p);
    #####:  304:    *result_obj_p = ECMA_VALUE_ERROR;
    #####:  305:    return NULL;
        -:  306:  }
        -:  307:#endif /* JERRY_ESNEXT */
        -:  308:
        1:  309:  if (prop_names_p->item_count != 0)
        -:  310:  {
        1:  311:    *result_obj_p = ecma_make_object_value (obj_p);
        1:  312:    return prop_names_p;
        -:  313:  }
        -:  314:
    #####:  315:  ecma_deref_object (obj_p);
    #####:  316:  ecma_collection_destroy (prop_names_p);
        -:  317:
    #####:  318:  return NULL;
        -:  319:} /* opfunc_for_in */
        -:  320:
        -:  321:#if JERRY_ESNEXT
        -:  322:
        -:  323:/**
        -:  324: * 'VM_OC_APPEND_ARRAY' opcode handler specialized for spread objects
        -:  325: *
        -:  326: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  327: *         ECMA_VALUE_EMPTY, otherwise
        -:  328: */
        -:  329:static ecma_value_t JERRY_ATTR_NOINLINE
    #####:  330:opfunc_append_to_spread_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  331:                               uint16_t values_length) /**< number of elements to set */
        -:  332:{
    #####:  333:  JERRY_ASSERT (!(values_length & OPFUNC_HAS_SPREAD_ELEMENT));
        -:  334:
    #####:  335:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  336:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  337:
    #####:  338:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  339:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  340:
    #####:  341:  for (uint32_t i = 0, idx = old_length; i < values_length; i++, idx++)
        -:  342:  {
    #####:  343:    if (ecma_is_value_array_hole (stack_top_p[i]))
        -:  344:    {
    #####:  345:      continue;
        -:  346:    }
        -:  347:
    #####:  348:    if (stack_top_p[i] == ECMA_VALUE_SPREAD_ELEMENT)
        -:  349:    {
    #####:  350:      i++;
    #####:  351:      ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  352:      ecma_value_t spread_value = stack_top_p[i];
        -:  353:
    #####:  354:      ecma_value_t next_method;
    #####:  355:      ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  356:
    #####:  357:      if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  358:      {
        -:  359:        while (true)
    #####:  360:        {
    #####:  361:          ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  362:
    #####:  363:          if (ECMA_IS_VALUE_ERROR (next_value))
        -:  364:          {
    #####:  365:            break;
        -:  366:          }
        -:  367:
    #####:  368:          if (ecma_is_value_false (next_value))
        -:  369:          {
    #####:  370:            idx--;
    #####:  371:            ret_value = ECMA_VALUE_EMPTY;
    #####:  372:            break;
        -:  373:          }
        -:  374:
    #####:  375:          ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  376:
    #####:  377:          ecma_free_value (next_value);
        -:  378:
    #####:  379:          if (ECMA_IS_VALUE_ERROR (value))
        -:  380:          {
    #####:  381:            break;
        -:  382:          }
        -:  383:
        -:  384:          ecma_value_t put_comp;
    #####:  385:          put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  386:                                                            idx++,
        -:  387:                                                            value,
        -:  388:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  389:
    #####:  390:          JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  391:          ecma_free_value (value);
        -:  392:        }
        -:  393:      }
        -:  394:
    #####:  395:      ecma_free_value (iterator);
    #####:  396:      ecma_free_value (next_method);
    #####:  397:      ecma_free_value (spread_value);
        -:  398:
    #####:  399:      if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  400:      {
    #####:  401:        for (uint32_t k = i + 1; k < values_length; k++)
        -:  402:        {
    #####:  403:          ecma_free_value (stack_top_p[k]);
        -:  404:        }
        -:  405:
    #####:  406:        return ret_value;
        -:  407:      }
        -:  408:    }
        -:  409:    else
        -:  410:    {
    #####:  411:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
        -:  412:                                                                     idx,
    #####:  413:                                                                     stack_top_p[i],
        -:  414:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  415:      JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  416:      ecma_free_value (stack_top_p[i]);
        -:  417:    }
        -:  418:  }
        -:  419:
    #####:  420:  return ECMA_VALUE_EMPTY;
        -:  421:} /* opfunc_append_to_spread_array */
        -:  422:
        -:  423:/**
        -:  424: * Spread function call/construct arguments into an ecma-collection
        -:  425: *
        -:  426: * @return NULL - if the operation failed
        -:  427: *         pointer to the ecma-collection with the spreaded arguments, otherwise
        -:  428: */
        -:  429:JERRY_ATTR_NOINLINE ecma_collection_t *
    #####:  430:opfunc_spread_arguments (ecma_value_t *stack_top_p, /**< pointer to the current stack top */
        -:  431:                         uint8_t arguments_list_len) /**< number of arguments */
        -:  432:{
    #####:  433:  ecma_collection_t *buff_p = ecma_new_collection ();
        -:  434:
    #####:  435:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  436:  {
    #####:  437:    ecma_value_t arg = *stack_top_p++;
        -:  438:
    #####:  439:    if (arg != ECMA_VALUE_SPREAD_ELEMENT)
        -:  440:    {
    #####:  441:      ecma_collection_push_back (buff_p, arg);
    #####:  442:      continue;
        -:  443:    }
        -:  444:
    #####:  445:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  446:    ecma_value_t spread_value = *stack_top_p++;
    #####:  447:    i++;
        -:  448:
    #####:  449:    ecma_value_t next_method;
    #####:  450:    ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  451:
    #####:  452:    if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  453:    {
        -:  454:      while (true)
    #####:  455:      {
    #####:  456:        ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  457:
    #####:  458:        if (ECMA_IS_VALUE_ERROR (next_value))
        -:  459:        {
    #####:  460:          break;
        -:  461:        }
        -:  462:
    #####:  463:        if (ecma_is_value_false (next_value))
        -:  464:        {
    #####:  465:          ret_value = ECMA_VALUE_EMPTY;
    #####:  466:          break;
        -:  467:        }
        -:  468:
    #####:  469:        ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  470:
    #####:  471:        ecma_free_value (next_value);
        -:  472:
    #####:  473:        if (ECMA_IS_VALUE_ERROR (value))
        -:  474:        {
    #####:  475:          break;
        -:  476:        }
        -:  477:
    #####:  478:        ecma_collection_push_back (buff_p, value);
        -:  479:      }
        -:  480:    }
        -:  481:
    #####:  482:    ecma_free_value (iterator);
    #####:  483:    ecma_free_value (next_method);
    #####:  484:    ecma_free_value (spread_value);
        -:  485:
    #####:  486:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  487:    {
    #####:  488:      for (uint32_t k = i + 1; k < arguments_list_len; k++)
        -:  489:      {
    #####:  490:        ecma_free_value (*stack_top_p++);
        -:  491:      }
        -:  492:
    #####:  493:      ecma_collection_free (buff_p);
    #####:  494:      buff_p = NULL;
    #####:  495:      break;
        -:  496:    }
        -:  497:  }
        -:  498:
    #####:  499:  return buff_p;
        -:  500:} /* opfunc_spread_arguments */
        -:  501:
        -:  502:#endif /* JERRY_ESNEXT */
        -:  503:
        -:  504:/**
        -:  505: * 'VM_OC_APPEND_ARRAY' opcode handler, for setting array object properties
        -:  506: *
        -:  507: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  508: *         ECMA_VALUE_EMPTY, otherwise
        -:  509: */
        -:  510:ecma_value_t JERRY_ATTR_NOINLINE
    #####:  511:opfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  512:                     uint16_t values_length) /**< number of elements to set
        -:  513:                                              *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */
        -:  514:{
        -:  515:#if JERRY_ESNEXT
    #####:  516:  if (values_length >= OPFUNC_HAS_SPREAD_ELEMENT)
        -:  517:  {
    #####:  518:    return opfunc_append_to_spread_array (stack_top_p, (uint16_t) (values_length & ~OPFUNC_HAS_SPREAD_ELEMENT));
        -:  519:  }
        -:  520:#endif /* JERRY_ESNEXT */
        -:  521:
    #####:  522:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  523:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  524:
    #####:  525:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  526:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  527:
    #####:  528:  if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_array_obj_p)))
        -:  529:  {
    #####:  530:    uint32_t filled_holes = 0;
    #####:  531:    ecma_value_t *values_p = ecma_fast_array_extend (array_obj_p, old_length + values_length);
        -:  532:
    #####:  533:    for (uint32_t i = 0; i < values_length; i++)
        -:  534:    {
    #####:  535:      values_p[old_length + i] = stack_top_p[i];
        -:  536:
    #####:  537:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  538:      {
    #####:  539:        filled_holes++;
        -:  540:
    #####:  541:        ecma_deref_if_object (stack_top_p[i]);
        -:  542:      }
        -:  543:    }
        -:  544:
    #####:  545:    ext_array_obj_p->u.array.length_prop_and_hole_count -= filled_holes * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  546:
    #####:  547:    if (JERRY_UNLIKELY ((values_length - filled_holes) > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT))
        -:  548:    {
    #####:  549:      ecma_fast_array_convert_to_normal (array_obj_p);
        -:  550:    }
        -:  551:  }
        -:  552:  else
        -:  553:  {
    #####:  554:    for (uint32_t i = 0; i < values_length; i++)
        -:  555:    {
    #####:  556:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  557:      {
    #####:  558:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (old_length + i);
        -:  559:
        -:  560:        ecma_property_value_t *prop_value_p;
        -:  561:
    #####:  562:        prop_value_p = ecma_create_named_data_property (array_obj_p,
        -:  563:                                                        index_str_p,
        -:  564:                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  565:                                                        NULL);
        -:  566:
    #####:  567:        ecma_deref_ecma_string (index_str_p);
    #####:  568:        prop_value_p->value = stack_top_p[i];
    #####:  569:        ecma_deref_if_object (stack_top_p[i]);
        -:  570:      }
        -:  571:    }
    #####:  572:    ext_array_obj_p->u.array.length = old_length + values_length;
        -:  573:  }
        -:  574:
    #####:  575:  return ECMA_VALUE_EMPTY;
        -:  576:} /* opfunc_append_array */
        -:  577:
        -:  578:#if JERRY_ESNEXT
        -:  579:
        -:  580:/**
        -:  581: * Create an executable object using the current frame context
        -:  582: *
        -:  583: * @return executable object
        -:  584: */
        -:  585:vm_executable_object_t *
    #####:  586:opfunc_create_executable_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  587:                                 vm_create_executable_object_type_t type) /**< executable object type */
        -:  588:{
    #####:  589:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -:  590:  size_t size, register_end;
        -:  591:
    #####:  592:  ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_header_p);
        -:  593:
    #####:  594:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  595:  {
    #####:  596:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  597:    register_end = (size_t) args_p->register_end;
    #####:  598:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  599:  }
        -:  600:  else
        -:  601:  {
    #####:  602:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  603:    register_end = (size_t) args_p->register_end;
    #####:  604:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  605:  }
        -:  606:
    #####:  607:  size_t total_size = JERRY_ALIGNUP (sizeof (vm_executable_object_t) + size, sizeof (uintptr_t));
        -:  608:
    #####:  609:  ecma_object_t *proto_p = NULL;
        -:  610:  /* Async function objects are not accessible, so their class_id is not relevant. */
    #####:  611:  uint8_t class_type = ECMA_OBJECT_CLASS_GENERATOR;
        -:  612:
    #####:  613:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  614:  {
    #####:  615:    ecma_builtin_id_t default_proto_id = ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE;
        -:  616:
    #####:  617:    if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR)
        -:  618:    {
    #####:  619:      default_proto_id = ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE;
    #####:  620:      class_type = ECMA_OBJECT_CLASS_ASYNC_GENERATOR;
        -:  621:    }
        -:  622:
    #####:  623:    JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####:  624:    proto_p = ecma_op_get_prototype_from_constructor (frame_ctx_p->shared_p->function_object_p,
        -:  625:                                                      default_proto_id);
        -:  626:  }
        -:  627:
    #####:  628:  ecma_object_t *object_p = ecma_create_object (proto_p,
        -:  629:                                                total_size,
        -:  630:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  631:
    #####:  632:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  633:
    #####:  634:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  635:  {
    #####:  636:    ecma_deref_object (proto_p);
        -:  637:  }
        -:  638:
    #####:  639:  executable_object_p->extended_object.u.cls.type = class_type;
    #####:  640:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags = 0;
    #####:  641:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (executable_object_p->extended_object.u.cls.u3.head, NULL);
    #####:  642:  executable_object_p->iterator = ECMA_VALUE_UNDEFINED;
        -:  643:
    #####:  644:  JERRY_ASSERT (!(frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL));
        -:  645:
        -:  646:  /* Copy shared data and frame context. */
    #####:  647:  vm_frame_ctx_shared_t *new_shared_p = &(executable_object_p->shared);
    #####:  648:  *new_shared_p = *(frame_ctx_p->shared_p);
    #####:  649:  new_shared_p->status_flags &= (uint32_t) ~VM_FRAME_CTX_SHARED_HAS_ARG_LIST;
    #####:  650:  new_shared_p->status_flags |= VM_FRAME_CTX_SHARED_EXECUTABLE;
        -:  651:
    #####:  652:  vm_frame_ctx_t *new_frame_ctx_p = &(executable_object_p->frame_ctx);
    #####:  653:  *new_frame_ctx_p = *frame_ctx_p;
    #####:  654:  new_frame_ctx_p->shared_p = new_shared_p;
        -:  655:
        -:  656:  /* The old register values are discarded. */
    #####:  657:  ecma_value_t *new_registers_p = VM_GET_REGISTERS (new_frame_ctx_p);
    #####:  658:  memcpy (new_registers_p, VM_GET_REGISTERS (frame_ctx_p), size);
        -:  659:
    #####:  660:  size_t stack_top = (size_t) (frame_ctx_p->stack_top_p - VM_GET_REGISTERS (frame_ctx_p));
    #####:  661:  ecma_value_t *new_stack_top_p = new_registers_p + stack_top;
        -:  662:
    #####:  663:  new_frame_ctx_p->stack_top_p = new_stack_top_p;
        -:  664:
        -:  665:  /* Initial state is "not running", so all object references are released. */
        -:  666:
    #####:  667:  if (frame_ctx_p->context_depth > 0)
        -:  668:  {
    #####:  669:    JERRY_ASSERT (type != VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -:  670:
    #####:  671:    ecma_value_t *register_end_p = new_registers_p + register_end;
        -:  672:
    #####:  673:    JERRY_ASSERT (register_end_p <= new_stack_top_p);
        -:  674:
    #####:  675:    while (new_registers_p < register_end_p)
        -:  676:    {
    #####:  677:      ecma_deref_if_object (*new_registers_p++);
        -:  678:    }
        -:  679:
    #####:  680:    vm_ref_lex_env_chain (frame_ctx_p->lex_env_p,
    #####:  681:                          frame_ctx_p->context_depth,
        -:  682:                          new_registers_p,
        -:  683:                          false);
        -:  684:
    #####:  685:    new_registers_p += frame_ctx_p->context_depth;
        -:  686:
    #####:  687:    JERRY_ASSERT (new_registers_p <= new_stack_top_p);
        -:  688:  }
        -:  689:
    #####:  690:  while (new_registers_p < new_stack_top_p)
        -:  691:  {
    #####:  692:    ecma_deref_if_object (*new_registers_p++);
        -:  693:  }
        -:  694:
    #####:  695:  JERRY_ASSERT (*VM_GET_EXECUTABLE_ITERATOR (new_frame_ctx_p) == ECMA_VALUE_UNDEFINED);
        -:  696:
    #####:  697:  new_frame_ctx_p->this_binding = ecma_copy_value_if_not_object (new_frame_ctx_p->this_binding);
        -:  698:
    #####:  699:  JERRY_CONTEXT (vm_top_context_p) = new_frame_ctx_p->prev_context_p;
        -:  700:
    #####:  701:  return executable_object_p;
        -:  702:} /* opfunc_create_executable_object */
        -:  703:
        -:  704:/**
        -:  705: * Byte code which resumes an executable object with throw
        -:  706: */
        -:  707:const uint8_t opfunc_resume_executable_object_with_throw[1] =
        -:  708:{
        -:  709:  CBC_THROW
        -:  710:};
        -:  711:
        -:  712:/**
        -:  713: * Byte code which resumes an executable object with return
        -:  714: */
        -:  715:const uint8_t opfunc_resume_executable_object_with_return[2] =
        -:  716:{
        -:  717:  CBC_EXT_OPCODE, CBC_EXT_RETURN
        -:  718:};
        -:  719:
        -:  720:/**
        -:  721: * Resume the execution of an inactive executable object
        -:  722: *
        -:  723: * @return value provided by the execution
        -:  724: */
        -:  725:ecma_value_t
    #####:  726:opfunc_resume_executable_object (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  727:                                 ecma_value_t value) /**< value pushed onto the stack (takes the reference) */
        -:  728:{
    #####:  729:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
    #####:  730:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
        -:  731:  ecma_value_t *register_end_p;
        -:  732:
    #####:  733:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  734:  {
    #####:  735:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  736:    register_end_p = register_p + args_p->register_end;
        -:  737:  }
        -:  738:  else
        -:  739:  {
    #####:  740:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  741:    register_end_p = register_p + args_p->register_end;
        -:  742:  }
        -:  743:
    #####:  744:  ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  745:
    #####:  746:  if (value != ECMA_VALUE_EMPTY)
        -:  747:  {
    #####:  748:    *stack_top_p = value;
    #####:  749:    executable_object_p->frame_ctx.stack_top_p = stack_top_p + 1;
        -:  750:  }
        -:  751:
    #####:  752:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  753:  {
    #####:  754:    while (register_p < register_end_p)
        -:  755:    {
    #####:  756:      ecma_ref_if_object (*register_p++);
        -:  757:    }
        -:  758:
    #####:  759:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  760:                          executable_object_p->frame_ctx.context_depth,
        -:  761:                          register_p,
        -:  762:                          true);
        -:  763:
    #####:  764:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  765:  }
        -:  766:
    #####:  767:  while (register_p < stack_top_p)
        -:  768:  {
    #####:  769:    ecma_ref_if_object (*register_p++);
        -:  770:  }
        -:  771:
    #####:  772:  ecma_ref_if_object (executable_object_p->iterator);
        -:  773:
    #####:  774:  JERRY_ASSERT (ECMA_EXECUTABLE_OBJECT_IS_SUSPENDED (executable_object_p));
        -:  775:
    #####:  776:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  777:
    #####:  778:  executable_object_p->frame_ctx.prev_context_p = JERRY_CONTEXT (vm_top_context_p);
    #####:  779:  JERRY_CONTEXT (vm_top_context_p) = &executable_object_p->frame_ctx;
        -:  780:
        -:  781:  /* inside the generators the "new.target" is always "undefined" as it can't be invoked with "new" */
    #####:  782:  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target_p);
    #####:  783:  JERRY_CONTEXT (current_new_target_p) = NULL;
        -:  784:
        -:  785:#if JERRY_BUILTIN_REALMS
    #####:  786:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
    #####:  787:  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (bytecode_header_p);
        -:  788:#endif /* JERRY_BUILTIN_REALMS */
        -:  789:
    #####:  790:  ecma_value_t result = vm_execute (&executable_object_p->frame_ctx);
        -:  791:
        -:  792:#if JERRY_BUILTIN_REALMS
    #####:  793:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  794:#endif /* JERRY_BUILTIN_REALMS */
        -:  795:
    #####:  796:  JERRY_CONTEXT (current_new_target_p) = old_new_target;
    #####:  797:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= (uint8_t) ~ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  798:
    #####:  799:  if (executable_object_p->frame_ctx.call_operation != VM_EXEC_RETURN)
        -:  800:  {
    #####:  801:    JERRY_ASSERT (executable_object_p->frame_ctx.call_operation == VM_NO_EXEC_OP);
        -:  802:
        -:  803:    /* All resources are released. */
    #####:  804:    executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_COMPLETED;
    #####:  805:    return result;
        -:  806:  }
        -:  807:
    #####:  808:  JERRY_CONTEXT (vm_top_context_p) = executable_object_p->frame_ctx.prev_context_p;
        -:  809:
    #####:  810:  register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####:  811:  stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  812:
    #####:  813:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  814:  {
    #####:  815:    while (register_p < register_end_p)
        -:  816:    {
    #####:  817:      ecma_deref_if_object (*register_p++);
        -:  818:    }
        -:  819:
    #####:  820:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  821:                          executable_object_p->frame_ctx.context_depth,
        -:  822:                          register_p,
        -:  823:                          false);
        -:  824:
    #####:  825:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  826:  }
        -:  827:
    #####:  828:  while (register_p < stack_top_p)
        -:  829:  {
    #####:  830:    ecma_deref_if_object (*register_p++);
        -:  831:  }
        -:  832:
    #####:  833:  ecma_deref_if_object (executable_object_p->iterator);
        -:  834:
    #####:  835:  return result;
        -:  836:} /* opfunc_resume_executable_object */
        -:  837:
        -:  838:/**
        -:  839: * Fulfill the next promise of the async generator with the value
        -:  840: */
        -:  841:void
    #####:  842:opfunc_async_generator_yield (ecma_extended_object_t *async_generator_object_p, /**< async generator object */
        -:  843:                              ecma_value_t value) /**< value (takes the reference) */
        -:  844:{
        -:  845:  ecma_async_generator_task_t *task_p;
    #####:  846:  task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t,
        -:  847:                                            async_generator_object_p->u.cls.u3.head);
        -:  848:
    #####:  849:  ecma_value_t iter_result = ecma_create_iter_result_object (value, ECMA_VALUE_FALSE);
    #####:  850:  ecma_fulfill_promise (task_p->promise, iter_result);
        -:  851:
    #####:  852:  ecma_free_value (iter_result);
    #####:  853:  ecma_free_value (value);
        -:  854:
    #####:  855:  ecma_value_t next = task_p->next;
    #####:  856:  async_generator_object_p->u.cls.u3.head = next;
        -:  857:
    #####:  858:  JERRY_ASSERT (task_p->operation_value == ECMA_VALUE_UNDEFINED);
    #####:  859:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  860:
    #####:  861:  if (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  862:  {
    #####:  863:    ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:  864:    ecma_enqueue_promise_async_generator_job (executable_object);
        -:  865:  }
    #####:  866:} /* opfunc_async_generator_yield */
        -:  867:
        -:  868:/**
        -:  869: * Creates a new executable object and awaits for the value
        -:  870: *
        -:  871: * Note:
        -:  872: *   extra_flags can be used to set additional extra_info flags
        -:  873: *
        -:  874: * @return a new Promise object on success, error otherwise
        -:  875: */
        -:  876:ecma_value_t
    #####:  877:opfunc_async_create_and_await (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  878:                               ecma_value_t value, /**< awaited value (takes reference) */
        -:  879:                               uint16_t extra_flags) /**< extra flags */
        -:  880:{
    #####:  881:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC
        -:  882:                || (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -:  883:                    == CBC_FUNCTION_ASYNC_ARROW));
        -:  884:
    #####:  885:  ecma_object_t *promise_p = ecma_builtin_get (ECMA_BUILTIN_ID_PROMISE);
    #####:  886:  ecma_value_t result = ecma_promise_reject_or_resolve (ecma_make_object_value (promise_p), value, true);
    #####:  887:  ecma_free_value (value);
        -:  888:
    #####:  889:  if (ECMA_IS_VALUE_ERROR (result))
        -:  890:  {
    #####:  891:    return result;
        -:  892:  }
        -:  893:
        -:  894:  vm_executable_object_t *executable_object_p;
    #####:  895:  executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_ASYNC);
        -:  896:
    #####:  897:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= extra_flags;
        -:  898:
    #####:  899:  ecma_promise_async_then (result, ecma_make_object_value ((ecma_object_t *) executable_object_p));
    #####:  900:  ecma_deref_object ((ecma_object_t *) executable_object_p);
    #####:  901:  ecma_free_value (result);
        -:  902:
    #####:  903:  result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, promise_p);
        -:  904:
    #####:  905:  JERRY_ASSERT (ecma_is_value_object (result));
    #####:  906:  executable_object_p->iterator = result;
        -:  907:
    #####:  908:  return result;
        -:  909:} /* opfunc_async_create_and_await */
        -:  910:
        -:  911:/**
        -:  912: * Initialize class fields.
        -:  913: *
        -:  914: * @return ECMA_VALUE_ERROR - initialization fails
        -:  915: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  916: */
        -:  917:ecma_value_t
    #####:  918:opfunc_init_class_fields (ecma_object_t *class_object_p, /**< the function itself */
        -:  919:                          ecma_value_t this_val) /**< this_arg of the function */
        -:  920:{
    #####:  921:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -:  922:
    #####:  923:  ecma_string_t *name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####:  924:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -:  925:
    #####:  926:  if (property_p == NULL)
        -:  927:  {
    #####:  928:    return ECMA_VALUE_UNDEFINED;
        -:  929:  }
        -:  930:
    #####:  931:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####:  932:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####:  933:  shared_class_fields.computed_class_fields_p = NULL;
        -:  934:
    #####:  935:  name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####:  936:  ecma_property_t *class_field_property_p = ecma_find_named_property (class_object_p, name_p);
        -:  937:
    #####:  938:  if (class_field_property_p != NULL)
        -:  939:  {
    #####:  940:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####:  941:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -:  942:  }
        -:  943:
    #####:  944:  ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  945:  JERRY_ASSERT (ecma_op_is_callable (property_value_p->value));
        -:  946:
        -:  947:  ecma_extended_object_t *ext_function_p;
    #####:  948:  ext_function_p = (ecma_extended_object_t *) ecma_get_object_from_value (property_value_p->value);
    #####:  949:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
    #####:  950:  shared_class_fields.header.function_object_p = &ext_function_p->object;
        -:  951:
    #####:  952:  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  953:                                                                       ext_function_p->u.function.scope_cp);
        -:  954:
    #####:  955:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -:  956:
    #####:  957:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####:  958:  return result;
        -:  959:} /* opfunc_init_class_fields */
        -:  960:
        -:  961:/**
        -:  962: * Initialize static class fields.
        -:  963: *
        -:  964: * @return ECMA_VALUE_ERROR - initialization fails
        -:  965: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  966: */
        -:  967:ecma_value_t
    #####:  968:opfunc_init_static_class_fields (ecma_value_t function_object, /**< the function itself */
        -:  969:                                 ecma_value_t this_val) /**< this_arg of the function */
        -:  970:{
    #####:  971:  JERRY_ASSERT (ecma_op_is_callable (function_object));
    #####:  972:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -:  973:
    #####:  974:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####:  975:  ecma_object_t *function_object_p = ecma_get_object_from_value (function_object);
    #####:  976:  ecma_property_t *class_field_property_p = ecma_find_named_property (function_object_p, name_p);
        -:  977:
    #####:  978:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####:  979:  shared_class_fields.header.function_object_p = function_object_p;
    #####:  980:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####:  981:  shared_class_fields.computed_class_fields_p = NULL;
        -:  982:
    #####:  983:  if (class_field_property_p != NULL)
        -:  984:  {
    #####:  985:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####:  986:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -:  987:  }
        -:  988:
    #####:  989:  ecma_extended_object_t *ext_function_p = (ecma_extended_object_t *) function_object_p;
    #####:  990:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
        -:  991:
    #####:  992:  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  993:                                                                       ext_function_p->u.function.scope_cp);
        -:  994:
    #####:  995:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -:  996:
    #####:  997:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####:  998:  return result;
        -:  999:} /* opfunc_init_static_class_fields */
        -: 1000:
        -: 1001:/**
        -: 1002: * Add the name of a computed field to a name list
        -: 1003: *
        -: 1004: * @return ECMA_VALUE_ERROR - name is not a valid property name
        -: 1005: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1006: */
        -: 1007:ecma_value_t
    #####: 1008:opfunc_add_computed_field (ecma_value_t class_object, /**< class object */
        -: 1009:                           ecma_value_t name) /**< name of the property */
        -: 1010:{
    #####: 1011:  ecma_string_t *prop_name_p = ecma_op_to_property_key (name);
        -: 1012:
    #####: 1013:  if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1014:  {
    #####: 1015:    return ECMA_VALUE_ERROR;
        -: 1016:  }
        -: 1017:
    #####: 1018:  if (ecma_prop_name_is_symbol (prop_name_p))
        -: 1019:  {
    #####: 1020:    name = ecma_make_symbol_value (prop_name_p);
        -: 1021:  }
        -: 1022:  else
        -: 1023:  {
    #####: 1024:    name = ecma_make_string_value (prop_name_p);
        -: 1025:  }
        -: 1026:
    #####: 1027:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1028:  ecma_object_t *class_object_p = ecma_get_object_from_value (class_object);
        -: 1029:
    #####: 1030:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1031:  ecma_value_t *compact_collection_p;
        -: 1032:  ecma_property_value_t *property_value_p;
        -: 1033:
    #####: 1034:  if (property_p == NULL)
        -: 1035:  {
    #####: 1036:    ECMA_CREATE_INTERNAL_PROPERTY (class_object_p, name_p, property_p, property_value_p);
    #####: 1037:    compact_collection_p = ecma_new_compact_collection ();
        -: 1038:  }
        -: 1039:  else
        -: 1040:  {
    #####: 1041:    property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1042:    compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
        -: 1043:  }
        -: 1044:
    #####: 1045:  compact_collection_p = ecma_compact_collection_push_back (compact_collection_p, name);
    #####: 1046:  ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
    #####: 1047:  return ECMA_VALUE_UNDEFINED;
        -: 1048:} /* opfunc_add_computed_field */
        -: 1049:
        -: 1050:/**
        -: 1051: * Create implicit class constructor
        -: 1052: *
        -: 1053: * See also: ECMAScript v6, 14.5.14
        -: 1054: *
        -: 1055: * @return - new external function ecma-object
        -: 1056: */
        -: 1057:ecma_value_t
    #####: 1058:opfunc_create_implicit_class_constructor (uint8_t opcode, /**< current cbc opcode */
        -: 1059:                                          const ecma_compiled_code_t *bytecode_p) /**< current byte code */
        -: 1060:{
        -: 1061:  /* 8. */
    #####: 1062:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 1063:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 1064:
    #####: 1065:  if (JERRY_UNLIKELY (script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -: 1066:  {
    #####: 1067:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1068:  }
        -: 1069:
    #####: 1070:  ecma_object_t *function_object_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE),
        -: 1071:                                                         sizeof (ecma_extended_object_t),
        -: 1072:                                                         ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
        -: 1073:
    #####: 1074:  ecma_extended_object_t *constructor_object_p = (ecma_extended_object_t *) function_object_p;
        -: 1075:
    #####: 1076:  script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
    #####: 1077:  constructor_object_p->u.constructor_function.script_value = script_value;
    #####: 1078:  constructor_object_p->u.constructor_function.flags = 0;
        -: 1079:
        -: 1080:  /* 10.a.i */
    #####: 1081:  if (opcode == CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE)
        -: 1082:  {
    #####: 1083:    constructor_object_p->u.constructor_function.flags |= ECMA_CONSTRUCTOR_FUNCTION_HAS_HERITAGE;
        -: 1084:  }
        -: 1085:
        -: 1086:  ecma_property_value_t *prop_value_p;
    #####: 1087:  prop_value_p = ecma_create_named_data_property (function_object_p,
        -: 1088:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -: 1089:                                                  ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 1090:                                                  NULL);
    #####: 1091:  prop_value_p->value = ecma_make_uint32_value (0);
        -: 1092:
    #####: 1093:  return ecma_make_object_value (function_object_p);
        -: 1094:} /* opfunc_create_implicit_class_constructor */
        -: 1095:
        -: 1096:/**
        -: 1097: * Set the [[HomeObject]] attribute of the given functon object
        -: 1098: */
        -: 1099:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1100:opfunc_set_home_object (ecma_object_t *func_p, /**< function object */
        -: 1101:                        ecma_object_t *parent_env_p) /**< parent environment */
        -: 1102:{
    #####: 1103:  JERRY_ASSERT (ecma_is_lexical_environment (parent_env_p));
        -: 1104:
    #####: 1105:  if (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1106:  {
    #####: 1107:    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
    #####: 1108:    ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp,
        -: 1109:                                   parent_env_p,
        -: 1110:                                   JMEM_CP_GET_POINTER_TAG_BITS (ext_func_p->u.function.scope_cp));
        -: 1111:  }
    #####: 1112:} /* opfunc_set_home_object */
        -: 1113:
        -: 1114:/**
        -: 1115: * ClassDefinitionEvaluation environment initialization part
        -: 1116: *
        -: 1117: * See also: ECMAScript v6, 14.5.14
        -: 1118: *
        -: 1119: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1120: *           ECMA_VALUE_EMPTY - otherwise
        -: 1121: */
        -: 1122:void
    #####: 1123:opfunc_push_class_environment (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1124:                               ecma_value_t **vm_stack_top, /**< VM stack top */
        -: 1125:                               ecma_value_t class_name) /**< class name */
        -: 1126:{
    #####: 1127:  JERRY_ASSERT (ecma_is_value_string (class_name));
    #####: 1128:  ecma_object_t *class_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1129:
        -: 1130:  /* 4.a */
        -: 1131:  ecma_property_value_t *property_value_p;
    #####: 1132:  property_value_p = ecma_create_named_data_property (class_env_p,
        -: 1133:                                                      ecma_get_string_from_value (class_name),
        -: 1134:                                                      ECMA_PROPERTY_FLAG_ENUMERABLE,
        -: 1135:                                                      NULL);
        -: 1136:
    #####: 1137:  property_value_p->value = ECMA_VALUE_UNINITIALIZED;
    #####: 1138:  frame_ctx_p->lex_env_p = class_env_p;
        -: 1139:
    #####: 1140:  *(*vm_stack_top)++ = ECMA_VALUE_RELEASE_LEX_ENV;
    #####: 1141:} /* opfunc_push_class_environment */
        -: 1142:
        -: 1143:/**
        -: 1144: * ClassDefinitionEvaluation object initialization part
        -: 1145: *
        -: 1146: * See also: ECMAScript v6, 14.5.14
        -: 1147: *
        -: 1148: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1149: *           ECMA_VALUE_EMPTY - otherwise
        -: 1150: */
        -: 1151:ecma_value_t
    #####: 1152:opfunc_init_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1153:                   ecma_value_t *stack_top_p) /**< stack top */
        -: 1154:{
        -: 1155:  /* 5.b, 6.e.ii */
    #####: 1156:  ecma_object_t *ctor_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
    #####: 1157:  ecma_object_t *proto_parent_p = NULL;
    #####: 1158:  bool free_proto_parent = false;
        -: 1159:
    #####: 1160:  ecma_value_t super_class = stack_top_p[-2];
    #####: 1161:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1162:
    #####: 1163:  bool heritage_present = !ecma_is_value_array_hole (super_class);
        -: 1164:
        -: 1165:  /* 5. ClassHeritage opt is not present */
    #####: 1166:  if (!heritage_present)
        -: 1167:  {
        -: 1168:    /* 5.a */
    #####: 1169:    proto_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -: 1170:  }
    #####: 1171:  else if (!ecma_is_value_null (super_class))
        -: 1172:  {
        -: 1173:    /* 6.f, 6.g.i */
    #####: 1174:    if (!ecma_is_constructor (super_class))
        -: 1175:    {
    #####: 1176:      return ecma_raise_type_error ("Class extends value is not a constructor or null");
        -: 1177:    }
        -: 1178:
    #####: 1179:    ecma_object_t *parent_p = ecma_get_object_from_value (super_class);
        -: 1180:
        -: 1181:    /* 6.g.ii */
    #####: 1182:    ecma_value_t proto_parent = ecma_op_object_get_by_magic_id (parent_p, LIT_MAGIC_STRING_PROTOTYPE);
        -: 1183:
        -: 1184:    /* 6.g.iii */
    #####: 1185:    if (ECMA_IS_VALUE_ERROR (proto_parent))
        -: 1186:    {
    #####: 1187:      return proto_parent;
        -: 1188:    }
        -: 1189:
        -: 1190:    /* 6.g.iv */
    #####: 1191:    if (ecma_is_value_object (proto_parent))
        -: 1192:    {
    #####: 1193:      proto_parent_p = ecma_get_object_from_value (proto_parent);
    #####: 1194:      free_proto_parent = true;
        -: 1195:    }
    #####: 1196:    else if (ecma_is_value_null (proto_parent))
        -: 1197:    {
    #####: 1198:      proto_parent_p = NULL;
        -: 1199:    }
        -: 1200:    else
        -: 1201:    {
    #####: 1202:      ecma_free_value (proto_parent);
    #####: 1203:      return ecma_raise_type_error ("Property 'prototype' is not an object or null");
        -: 1204:    }
        -: 1205:
        -: 1206:    /* 6.g.v */
    #####: 1207:    ctor_parent_p = parent_p;
        -: 1208:  }
        -: 1209:
        -: 1210:  /* 7. */
    #####: 1211:  ecma_object_t *proto_p = ecma_create_object (proto_parent_p, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 1212:  ecma_value_t proto = ecma_make_object_value (proto_p);
        -: 1213:
    #####: 1214:  ECMA_SET_POINTER (ctor_p->u2.prototype_cp, ctor_parent_p);
        -: 1215:
    #####: 1216:  if (free_proto_parent)
        -: 1217:  {
    #####: 1218:    ecma_deref_object (proto_parent_p);
        -: 1219:  }
    #####: 1220:  ecma_free_value (super_class);
        -: 1221:
        -: 1222:  /* 16. */
        -: 1223:  ecma_property_value_t *property_value_p;
    #####: 1224:  property_value_p = ecma_create_named_data_property (ctor_p,
        -: 1225:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_PROTOTYPE),
        -: 1226:                                                      ECMA_PROPERTY_FIXED,
        -: 1227:                                                      NULL);
    #####: 1228:  property_value_p->value = proto;
        -: 1229:
        -: 1230:  /* 18. */
    #####: 1231:  property_value_p = ecma_create_named_data_property (proto_p,
        -: 1232:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_CONSTRUCTOR),
        -: 1233:                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1234:                                                      NULL);
    #####: 1235:  property_value_p->value = ecma_make_object_value (ctor_p);
        -: 1236:
    #####: 1237:  if (ecma_get_object_type (ctor_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1238:  {
    #####: 1239:    ecma_object_t *proto_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
    #####: 1240:    ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, proto_p);
        -: 1241:
    #####: 1242:    ECMA_SET_NON_NULL_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp, proto_env_p, 0);
        -: 1243:
        -: 1244:    /* 15. set F’s [[ConstructorKind]] internal slot to "derived". */
    #####: 1245:    if (heritage_present)
        -: 1246:    {
    #####: 1247:      ECMA_SET_THIRD_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp);
        -: 1248:    }
        -: 1249:
    #####: 1250:    ecma_deref_object (proto_env_p);
        -: 1251:  }
        -: 1252:
    #####: 1253:  stack_top_p[-2] = stack_top_p[-1];
    #####: 1254:  stack_top_p[-1] = proto;
        -: 1255:
    #####: 1256:  return ECMA_VALUE_EMPTY;
        -: 1257:} /* opfunc_init_class */
        -: 1258:
        -: 1259:/**
        -: 1260: * Set [[Enumerable]] and [[HomeObject]] attributes for all class method
        -: 1261: */
        -: 1262:static void
    #####: 1263:opfunc_set_class_attributes (ecma_object_t *obj_p, /**< object */
        -: 1264:                             ecma_object_t *parent_env_p) /**< parent environment */
        -: 1265:{
    #####: 1266:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 1267:
        -: 1268:#if JERRY_PROPERTY_HASHMAP
    #####: 1269:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 1270:  {
    #####: 1271:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1272:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 1273:    {
    #####: 1274:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1275:    }
        -: 1276:  }
        -: 1277:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 1278:
    #####: 1279:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 1280:  {
    #####: 1281:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1282:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 1283:
    #####: 1284:    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 1285:
    #####: 1286:    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)
        -: 1287:    {
    #####: 1288:      uint8_t property = property_pair_p->header.types[index];
        -: 1289:
    #####: 1290:      if (!ECMA_PROPERTY_IS_RAW (property))
        -: 1291:      {
    #####: 1292:        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED
        -: 1293:                      || (ECMA_PROPERTY_IS_INTERNAL (property)
        -: 1294:                          && property_pair_p->names_cp[index] == LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED));
    #####: 1295:        continue;
        -: 1296:      }
        -: 1297:
    #####: 1298:      if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1299:      {
    #####: 1300:        if (ecma_is_value_object (property_pair_p->values[index].value)
    #####: 1301:            && ecma_is_property_enumerable (property))
        -: 1302:        {
    #####: 1303:          property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1304:          opfunc_set_home_object (ecma_get_object_from_value (property_pair_p->values[index].value), parent_env_p);
        -: 1305:        }
    #####: 1306:        continue;
        -: 1307:      }
        -: 1308:
    #####: 1309:      property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1310:      ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;
        -: 1311:
    #####: 1312:      ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -: 1313:
    #####: 1314:      if (get_set_pair_p->getter_cp != JMEM_CP_NULL)
        -: 1315:      {
    #####: 1316:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp), parent_env_p);
        -: 1317:      }
        -: 1318:
    #####: 1319:      if (get_set_pair_p->setter_cp != JMEM_CP_NULL)
        -: 1320:      {
    #####: 1321:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp), parent_env_p);
        -: 1322:      }
        -: 1323:    }
        -: 1324:
    #####: 1325:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1326:  }
    #####: 1327:} /* opfunc_set_class_attributes */
        -: 1328:
        -: 1329:/**
        -: 1330: * Pop the current lexical environment referenced by the frame context
        -: 1331: */
        -: 1332:void
    #####: 1333:opfunc_pop_lexical_environment (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1334:{
    #####: 1335:  ecma_object_t *outer_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, frame_ctx_p->lex_env_p->u2.outer_reference_cp);
    #####: 1336:  ecma_deref_object (frame_ctx_p->lex_env_p);
    #####: 1337:  frame_ctx_p->lex_env_p = outer_env_p;
    #####: 1338:} /* opfunc_pop_lexical_environment */
        -: 1339:
        -: 1340:/**
        -: 1341: * ClassDefinitionEvaluation finalization part
        -: 1342: *
        -: 1343: * See also: ECMAScript v6, 14.5.14
        -: 1344: */
        -: 1345:void
    #####: 1346:opfunc_finalize_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1347:                       ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1348:                       ecma_value_t class_name) /**< class name */
        -: 1349:{
    #####: 1350:  JERRY_ASSERT (ecma_is_value_undefined (class_name) || ecma_is_value_string (class_name));
    #####: 1351:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1352:
    #####: 1353:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1354:  ecma_object_t *proto_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1355:
    #####: 1356:  ecma_object_t *class_env_p = frame_ctx_p->lex_env_p;
        -: 1357:
        -: 1358:  /* 23.a */
    #####: 1359:  if (!ecma_is_value_undefined (class_name))
        -: 1360:  {
    #####: 1361:    ecma_op_initialize_binding (class_env_p, ecma_get_string_from_value (class_name), stack_top_p[-2]);
        -: 1362:  }
        -: 1363:
    #####: 1364:  ecma_object_t *ctor_env_p = ecma_create_lex_env_class (class_env_p, 0);
    #####: 1365:  ECMA_SET_NON_NULL_POINTER (ctor_env_p->u1.bound_object_cp, ctor_p);
    #####: 1366:  ecma_object_t *proto_env_p = ecma_create_lex_env_class (class_env_p, 0);
    #####: 1367:  ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, proto_p);
        -: 1368:
    #####: 1369:  opfunc_set_class_attributes (ctor_p, ctor_env_p);
    #####: 1370:  opfunc_set_class_attributes (proto_p, proto_env_p);
        -: 1371:
    #####: 1372:  ecma_deref_object (proto_env_p);
    #####: 1373:  ecma_deref_object (ctor_env_p);
    #####: 1374:  ecma_deref_object (proto_p);
        -: 1375:
    #####: 1376:  JERRY_ASSERT ((ecma_is_value_undefined (class_name) ? stack_top_p[-3] == ECMA_VALUE_UNDEFINED
        -: 1377:                                                      : stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV));
        -: 1378:
        -: 1379:  /* only the current class remains on the stack */
    #####: 1380:  if (stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 1381:  {
    #####: 1382:    opfunc_pop_lexical_environment (frame_ctx_p);
        -: 1383:  }
        -: 1384:
    #####: 1385:  stack_top_p[-3] = stack_top_p[-2];
    #####: 1386:  *vm_stack_top_p -= 2;
    #####: 1387:} /* opfunc_finalize_class */
        -: 1388:
        -: 1389:/**
        -: 1390: * MakeSuperPropertyReference operation
        -: 1391: *
        -: 1392: * See also: ECMAScript v6, 12.3.5.3
        -: 1393: *
        -: 1394: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1395: *         ECMA_VALUE_EMPTY - otherwise
        -: 1396: */
        -: 1397:ecma_value_t
    #####: 1398:opfunc_form_super_reference (ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1399:                             vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1400:                             ecma_value_t prop_name, /**< property name to resolve */
        -: 1401:                             uint8_t opcode) /**< current cbc opcode */
        -: 1402:{
    #####: 1403:  if (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_CONSTRUCTOR)
        -: 1404:  {
    #####: 1405:    ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -: 1406:
    #####: 1407:    if (!ecma_op_this_binding_is_initialized (environment_record_p))
        -: 1408:    {
    #####: 1409:      return ecma_raise_reference_error (ECMA_ERR_MSG ("Must call super constructor in derived class before "
        -: 1410:                                                       "accessing 'this' or returning from it"));
        -: 1411:    }
        -: 1412:  }
        -: 1413:
    #####: 1414:  ecma_value_t parent = ecma_op_resolve_super_base (frame_ctx_p->lex_env_p);
        -: 1415:
    #####: 1416:  if (ECMA_IS_VALUE_ERROR (parent))
        -: 1417:  {
    #####: 1418:    return ecma_raise_type_error (ECMA_ERR_MSG ("Cannot invoke nullable super method"));
        -: 1419:  }
        -: 1420:
    #####: 1421:  if (!ecma_op_require_object_coercible (parent))
        -: 1422:  {
    #####: 1423:    return ECMA_VALUE_ERROR;
        -: 1424:  }
        -: 1425:
    #####: 1426:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1427:
    #####: 1428:  if (opcode >= CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE)
        -: 1429:  {
    #####: 1430:    JERRY_ASSERT (opcode == CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE
        -: 1431:                  || opcode == CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 1432:    *stack_top_p++ = parent;
    #####: 1433:    *stack_top_p++ = ecma_copy_value (prop_name);
    #####: 1434:    *vm_stack_top_p = stack_top_p;
        -: 1435:
    #####: 1436:    return ECMA_VALUE_EMPTY;
        -: 1437:  }
        -: 1438:
    #####: 1439:  ecma_object_t *parent_p = ecma_get_object_from_value (parent);
    #####: 1440:  ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name);
        -: 1441:
    #####: 1442:  if (prop_name_p == NULL)
        -: 1443:  {
    #####: 1444:    ecma_deref_object (parent_p);
    #####: 1445:    return ECMA_VALUE_ERROR;
        -: 1446:  }
        -: 1447:
    #####: 1448:  ecma_value_t result = ecma_op_object_get_with_receiver (parent_p, prop_name_p, frame_ctx_p->this_binding);
    #####: 1449:  ecma_deref_ecma_string (prop_name_p);
    #####: 1450:  ecma_deref_object (parent_p);
        -: 1451:
    #####: 1452:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1453:  {
    #####: 1454:    return result;
        -: 1455:  }
        -: 1456:
    #####: 1457:  if (opcode == CBC_EXT_SUPER_PROP_LITERAL_REFERENCE || opcode == CBC_EXT_SUPER_PROP_REFERENCE)
        -: 1458:  {
    #####: 1459:    *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1460:    *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 1461:  }
        -: 1462:
    #####: 1463:  *stack_top_p++ = result;
    #####: 1464:  *vm_stack_top_p = stack_top_p;
        -: 1465:
    #####: 1466:  return ECMA_VALUE_EMPTY;
        -: 1467:} /* opfunc_form_super_reference */
        -: 1468:
        -: 1469:/**
        -: 1470: * Assignment operation for SuperRefence base
        -: 1471: *
        -: 1472: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1473: *         ECMA_VALUE_EMPTY - otherwise
        -: 1474: */
        -: 1475:ecma_value_t
    #####: 1476:opfunc_assign_super_reference (ecma_value_t **vm_stack_top_p, /**< vm stack top */
        -: 1477:                               vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1478:                               uint32_t opcode_data) /**< opcode data to store the result */
        -: 1479:{
    #####: 1480:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1481:
    #####: 1482:  ecma_value_t base_obj = ecma_op_to_object (stack_top_p[-3]);
        -: 1483:
    #####: 1484:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 1485:  {
    #####: 1486:    return base_obj;
        -: 1487:  }
        -: 1488:
    #####: 1489:  ecma_object_t *base_obj_p = ecma_get_object_from_value (base_obj);
    #####: 1490:  ecma_string_t *prop_name_p = ecma_op_to_property_key (stack_top_p[-2]);
        -: 1491:
    #####: 1492:  if (prop_name_p == NULL)
        -: 1493:  {
    #####: 1494:    ecma_deref_object (base_obj_p);
    #####: 1495:    return ECMA_VALUE_ERROR;
        -: 1496:  }
        -: 1497:
    #####: 1498:  bool is_strict = (frame_ctx_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0;
        -: 1499:
    #####: 1500:  ecma_value_t result = ecma_op_object_put_with_receiver (base_obj_p,
        -: 1501:                                                          prop_name_p,
    #####: 1502:                                                          stack_top_p[-1],
        -: 1503:                                                          frame_ctx_p->this_binding,
        -: 1504:                                                          is_strict);
        -: 1505:
    #####: 1506:  ecma_deref_ecma_string (prop_name_p);
    #####: 1507:  ecma_deref_object (base_obj_p);
        -: 1508:
    #####: 1509:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1510:  {
    #####: 1511:    return result;
        -: 1512:  }
        -: 1513:
    #####: 1514:  for (int32_t i = 1; i <= 3; i++)
        -: 1515:  {
    #####: 1516:    ecma_free_value (stack_top_p[-i]);
        -: 1517:  }
        -: 1518:
    #####: 1519:  stack_top_p -= 3;
        -: 1520:
    #####: 1521:  if (opcode_data & VM_OC_PUT_STACK)
        -: 1522:  {
    #####: 1523:    *stack_top_p++ = result;
        -: 1524:  }
    #####: 1525:  else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 1526:  {
    #####: 1527:    ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 1528:    VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 1529:  }
        -: 1530:
    #####: 1531:  *vm_stack_top_p = stack_top_p;
        -: 1532:
    #####: 1533:  return result;
        -: 1534:} /* opfunc_assign_super_reference */
        -: 1535:
        -: 1536:/**
        -: 1537: * Copy data properties of an object
        -: 1538: *
        -: 1539: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1540: *         ECMA_VALUE_EMPTY - otherwise
        -: 1541: */
        -: 1542:ecma_value_t
    #####: 1543:opfunc_copy_data_properties (ecma_value_t target_object, /**< target object */
        -: 1544:                             ecma_value_t source_object, /**< source object */
        -: 1545:                             ecma_value_t filter_array) /**< filter array */
        -: 1546:{
    #####: 1547:  bool source_to_object = false;
        -: 1548:
    #####: 1549:  if (!ecma_is_value_object (source_object))
        -: 1550:  {
    #####: 1551:    source_object = ecma_op_to_object (source_object);
        -: 1552:
    #####: 1553:    if (ECMA_IS_VALUE_ERROR (source_object))
        -: 1554:    {
    #####: 1555:      return source_object;
        -: 1556:    }
        -: 1557:
    #####: 1558:    source_to_object = true;
        -: 1559:  }
        -: 1560:
    #####: 1561:  ecma_object_t *source_object_p = ecma_get_object_from_value (source_object);
    #####: 1562:  ecma_collection_t *names_p = ecma_op_object_own_property_keys (source_object_p, JERRY_PROPERTY_FILTER_ALL);
        -: 1563:
        -: 1564:#if JERRY_BUILTIN_PROXY
    #####: 1565:  if (names_p == NULL)
        -: 1566:  {
    #####: 1567:    JERRY_ASSERT (!source_to_object);
    #####: 1568:    return ECMA_VALUE_ERROR;
        -: 1569:  }
        -: 1570:#endif /* JERRY_BUILTIN_PROXY */
        -: 1571:
    #####: 1572:  ecma_object_t *target_object_p = ecma_get_object_from_value (target_object);
    #####: 1573:  ecma_value_t *buffer_p = names_p->buffer_p;
    #####: 1574:  ecma_value_t *buffer_end_p = buffer_p + names_p->item_count;
    #####: 1575:  ecma_value_t *filter_start_p = NULL;
    #####: 1576:  ecma_value_t *filter_end_p = NULL;
    #####: 1577:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 1578:
    #####: 1579:  if (filter_array != ECMA_VALUE_UNDEFINED)
        -: 1580:  {
    #####: 1581:    ecma_object_t *filter_array_p = ecma_get_object_from_value (filter_array);
        -: 1582:
    #####: 1583:    JERRY_ASSERT (ecma_get_object_type (filter_array_p) == ECMA_OBJECT_TYPE_ARRAY);
    #####: 1584:    JERRY_ASSERT (ecma_op_object_is_fast_array (filter_array_p));
        -: 1585:
    #####: 1586:    if (filter_array_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 1587:    {
    #####: 1588:      filter_start_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, filter_array_p->u1.property_list_cp);
    #####: 1589:      filter_end_p = filter_start_p + ((ecma_extended_object_t *) filter_array_p)->u.array.length;
        -: 1590:    }
        -: 1591:  }
        -: 1592:
    #####: 1593:  while (buffer_p < buffer_end_p)
        -: 1594:  {
    #####: 1595:    ecma_string_t *property_name_p = ecma_get_prop_name_from_value (*buffer_p++);
        -: 1596:
    #####: 1597:    if (filter_start_p != NULL)
        -: 1598:    {
    #####: 1599:      ecma_value_t *filter_p = filter_start_p;
        -: 1600:
        -: 1601:      do
        -: 1602:      {
    #####: 1603:        if (ecma_compare_ecma_strings (property_name_p, ecma_get_prop_name_from_value (*filter_p)))
        -: 1604:        {
    #####: 1605:          break;
        -: 1606:        }
        -: 1607:      }
    #####: 1608:      while (++filter_p < filter_end_p);
        -: 1609:
    #####: 1610:      if (filter_p != filter_end_p)
        -: 1611:      {
    #####: 1612:        continue;
        -: 1613:      }
        -: 1614:    }
        -: 1615:
    #####: 1616:    ecma_property_descriptor_t descriptor;
    #####: 1617:    result = ecma_op_object_get_own_property_descriptor (source_object_p, property_name_p, &descriptor);
        -: 1618:
    #####: 1619:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1620:    {
    #####: 1621:      break;
        -: 1622:    }
        -: 1623:
    #####: 1624:    if (result == ECMA_VALUE_FALSE)
        -: 1625:    {
    #####: 1626:      continue;
        -: 1627:    }
        -: 1628:
    #####: 1629:    if (!(descriptor.flags & JERRY_PROP_IS_ENUMERABLE))
        -: 1630:    {
    #####: 1631:      ecma_free_property_descriptor (&descriptor);
    #####: 1632:      continue;
        -: 1633:    }
        -: 1634:
    #####: 1635:    if ((descriptor.flags & JERRY_PROP_IS_VALUE_DEFINED) && !ECMA_OBJECT_IS_PROXY (source_object_p))
        -: 1636:    {
    #####: 1637:      result = descriptor.value;
        -: 1638:    }
        -: 1639:    else
        -: 1640:    {
    #####: 1641:      ecma_free_property_descriptor (&descriptor);
        -: 1642:
    #####: 1643:      result = ecma_op_object_get (source_object_p, property_name_p);
        -: 1644:
    #####: 1645:      if (ECMA_IS_VALUE_ERROR (result))
        -: 1646:      {
    #####: 1647:        break;
        -: 1648:      }
        -: 1649:    }
        -: 1650:
    #####: 1651:    opfunc_set_data_property (target_object_p, property_name_p, result);
    #####: 1652:    ecma_free_value (result);
        -: 1653:
    #####: 1654:    result = ECMA_VALUE_EMPTY;
        -: 1655:  }
        -: 1656:
    #####: 1657:  if (JERRY_UNLIKELY (source_to_object))
        -: 1658:  {
    #####: 1659:    ecma_deref_object (source_object_p);
        -: 1660:  }
        -: 1661:
    #####: 1662:  ecma_collection_free (names_p);
    #####: 1663:  return result;
        -: 1664:} /* opfunc_copy_data_properties */
        -: 1665:
        -: 1666:/**
        -: 1667: * Check whether the current lexical scope has restricted binding declaration with the given name
        -: 1668: *
        -: 1669: * Steps are include ES11: 8.1.1.4.14 HasRestrictedGlobalProperty abstract operation
        -: 1670: *
        -: 1671: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1672: *         ECMA_VALUE_TRUE - if it has restricted property binding
        -: 1673: *         ECMA_VALUE_FALSE - otherwise
        -: 1674: */
        -: 1675:ecma_value_t
    #####: 1676:opfunc_lexical_scope_has_restricted_binding (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1677:                                             ecma_string_t *name_p) /**< binding name */
        -: 1678:{
    #####: 1679:  JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1680:
        -: 1681:#if JERRY_BUILTIN_REALMS
    #####: 1682:  JERRY_ASSERT (frame_ctx_p->this_binding == JERRY_CONTEXT (global_object_p)->this_binding);
        -: 1683:#else /* !JERRY_BUILTIN_REALMS */
        -: 1684:  JERRY_ASSERT (frame_ctx_p->this_binding == ecma_builtin_get_global ());
        -: 1685:#endif /* JERRY_BUILTIN_REALMS */
        -: 1686:
    #####: 1687:  ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1688:  ecma_property_t *binding_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1689:
    #####: 1690:  if (binding_p != NULL)
        -: 1691:  {
    #####: 1692:    return ECMA_VALUE_TRUE;
        -: 1693:  }
        -: 1694:
        -: 1695:#if JERRY_BUILTIN_REALMS
    #####: 1696:  ecma_object_t *const global_scope_p = ecma_get_global_scope ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
        -: 1697:#else /* !JERRY_BUILTIN_REALMS */
        -: 1698:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -: 1699:#endif /* JERRY_BUILTIN_REALMS */
        -: 1700:
    #####: 1701:  if (global_scope_p != lex_env_p)
        -: 1702:  {
    #####: 1703:    return ECMA_VALUE_FALSE;
        -: 1704:  }
        -: 1705:
    #####: 1706:  ecma_object_t *global_obj_p = ecma_get_object_from_value (frame_ctx_p->this_binding);
        -: 1707:
        -: 1708:#if JERRY_BUILTIN_PROXY
    #####: 1709:  if (ECMA_OBJECT_IS_PROXY (global_obj_p))
        -: 1710:  {
    #####: 1711:    ecma_property_descriptor_t prop_desc;
    #####: 1712:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (global_obj_p, name_p, &prop_desc);
        -: 1713:
    #####: 1714:    if (ecma_is_value_true (status))
        -: 1715:    {
    #####: 1716:      status = ecma_make_boolean_value ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE) == 0);
    #####: 1717:      ecma_free_property_descriptor (&prop_desc);
        -: 1718:    }
        -: 1719:
    #####: 1720:    return status;
        -: 1721:  }
        -: 1722:#endif /* JERRY_BUILTIN_PROXY */
        -: 1723:
    #####: 1724:  ecma_property_t property = ecma_op_object_get_own_property (global_obj_p,
        -: 1725:                                                              name_p,
        -: 1726:                                                              NULL,
        -: 1727:                                                              ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 1728:
    #####: 1729:  return ecma_make_boolean_value ((property != ECMA_PROPERTY_TYPE_NOT_FOUND
    #####: 1730:                                   && !ecma_is_property_configurable (property)));
        -: 1731:} /* opfunc_lexical_scope_has_restricted_binding */
        -: 1732:
        -: 1733:#endif /* JERRY_ESNEXT */
        -: 1734:
        -: 1735:/**
        -: 1736: * @}
        -: 1737: * @}
        -: 1738: */
