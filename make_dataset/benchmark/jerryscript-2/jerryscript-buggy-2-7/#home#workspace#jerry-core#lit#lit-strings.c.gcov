        -:    0:Source:/home/workspace/jerry-core/lit/lit-strings.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "lit-strings.h"
        -:   17:
        -:   18:#include "jrt-libc-includes.h"
        -:   19:
        -:   20:#define LIT_UTF8_SURROGATE_MARKER 0xed /**< utf8 surrogate marker */
        -:   21:#define LIT_UTF8_HIGH_SURROGATE_MIN 0xa0 /**< utf8 high surrogate minimum */
        -:   22:#define LIT_UTF8_HIGH_SURROGATE_MAX 0xaf /**< utf8 high surrogate maximum */
        -:   23:#define LIT_UTF8_LOW_SURROGATE_MIN 0xb0 /**< utf8 low surrogate minimum */
        -:   24:#define LIT_UTF8_LOW_SURROGATE_MAX 0xbf /**< utf8 low surrogate maximum */
        -:   25:#define LIT_UTF8_1_BYTE_MAX 0xf4 /**< utf8 one byte max */
        -:   26:#define LIT_UTF8_2_BYTE_MAX 0x8f /**< utf8 two byte max */
        -:   27:#define LIT_UTF8_VALID_TWO_BYTE_START 0xc2 /**< utf8 two byte start */
        -:   28:
        -:   29:/**
        -:   30: * Validate utf-8 string
        -:   31: *
        -:   32: * NOTE:
        -:   33: *   Isolated surrogates are allowed.
        -:   34: *
        -:   35: * @return true if utf-8 string is well-formed
        -:   36: *         false otherwise
        -:   37: */
        -:   38:bool
        1:   39:lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:   40:                          lit_utf8_size_t buf_size, /**< string size */
        -:   41:                          bool is_strict) /**< true if surrogate pairs are not allowed */
        -:   42:{
        1:   43:  const unsigned char *end = buf_size + utf8_buf_p;
        -:   44:
        1:   45:  const unsigned char *idx = (const unsigned char *) utf8_buf_p;
        -:   46:
      333:   47:  while (idx < end)
        -:   48:  {
      331:   49:    const uint8_t first_byte = *idx++;
        -:   50:
      331:   51:    if (first_byte < LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   52:    {
      331:   53:      continue;
        -:   54:    }
        -:   55:
    #####:   56:    if (first_byte < LIT_UTF8_VALID_TWO_BYTE_START || idx >= end)
        -:   57:    {
    #####:   58:      return false;
        -:   59:    }
        -:   60:
    #####:   61:    const uint8_t second_byte = *idx++;
        -:   62:
    #####:   63:    if ((second_byte & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   64:    {
    #####:   65:      return false;
        -:   66:    }
        -:   67:
    #####:   68:    if (first_byte < LIT_UTF8_3_BYTE_MARKER)
        -:   69:    {
    #####:   70:      continue;
        -:   71:    }
        -:   72:
    #####:   73:    if (idx >= end || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   74:    {
    #####:   75:      return false;
        -:   76:    }
        -:   77:
    #####:   78:    if (first_byte < LIT_UTF8_4_BYTE_MARKER)
        -:   79:    {
    #####:   80:      if (first_byte == LIT_UTF8_3_BYTE_MARKER && (second_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   81:      {
    #####:   82:        return false;
        -:   83:      }
        -:   84:
    #####:   85:      if (is_strict
    #####:   86:          && first_byte == LIT_UTF8_SURROGATE_MARKER
    #####:   87:          && second_byte >= LIT_UTF8_HIGH_SURROGATE_MIN
    #####:   88:          && second_byte <= LIT_UTF8_HIGH_SURROGATE_MAX
    #####:   89:          && idx + 3 <= end
    #####:   90:          && idx[0] == LIT_UTF8_SURROGATE_MARKER
    #####:   91:          && idx[1] >= LIT_UTF8_LOW_SURROGATE_MIN
    #####:   92:          && idx[1] <= LIT_UTF8_LOW_SURROGATE_MAX)
        -:   93:      {
    #####:   94:        return false;
        -:   95:      }
    #####:   96:      continue;
        -:   97:    }
        -:   98:
    #####:   99:    if (idx >= end
    #####:  100:        || first_byte > LIT_UTF8_1_BYTE_MAX
    #####:  101:        || (first_byte == LIT_UTF8_4_BYTE_MARKER && second_byte <= LIT_UTF8_EXTRA_BYTE_MARKER)
    #####:  102:        || (first_byte == LIT_UTF8_1_BYTE_MAX && second_byte > LIT_UTF8_2_BYTE_MAX)
    #####:  103:        || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  104:    {
    #####:  105:      return false;
        -:  106:    }
        -:  107:  }
        -:  108:
        1:  109:  return true;
        -:  110:} /* lit_is_valid_utf8_string */
        -:  111:
        -:  112:/**
        -:  113: * Validate cesu-8 string
        -:  114: *
        -:  115: * @return true if cesu-8 string is well-formed
        -:  116: *         false otherwise
        -:  117: */
        -:  118:bool
       19:  119:lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  120:                           lit_utf8_size_t buf_size) /**< string size */
        -:  121:{
       19:  122:  lit_utf8_size_t idx = 0;
        -:  123:
      223:  124:  while (idx < buf_size)
        -:  125:  {
      185:  126:    lit_utf8_byte_t c = cesu8_buf_p[idx++];
      185:  127:    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  128:    {
      185:  129:      continue;
        -:  130:    }
        -:  131:
    #####:  132:    lit_code_point_t code_point = 0;
    #####:  133:    lit_code_point_t min_code_point = 0;
        -:  134:    lit_utf8_size_t extra_bytes_count;
    #####:  135:    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  136:    {
    #####:  137:      extra_bytes_count = 1;
    #####:  138:      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;
    #####:  139:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  140:    }
    #####:  141:    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  142:    {
    #####:  143:      extra_bytes_count = 2;
    #####:  144:      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;
    #####:  145:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  146:    }
        -:  147:    else
        -:  148:    {
    #####:  149:      return false;
        -:  150:    }
        -:  151:
    #####:  152:    if (idx + extra_bytes_count > buf_size)
        -:  153:    {
        -:  154:      /* cesu-8 string breaks in the middle */
    #####:  155:      return false;
        -:  156:    }
        -:  157:
    #####:  158:    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)
        -:  159:    {
    #####:  160:      c = cesu8_buf_p[idx + offset];
    #####:  161:      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  162:      {
        -:  163:        /* invalid continuation byte */
    #####:  164:        return false;
        -:  165:      }
    #####:  166:      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  167:      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);
        -:  168:    }
        -:  169:
    #####:  170:    if (code_point < min_code_point)
        -:  171:    {
        -:  172:      /* cesu-8 string doesn't encode valid unicode code point */
    #####:  173:      return false;
        -:  174:    }
        -:  175:
    #####:  176:    idx += extra_bytes_count;
        -:  177:  }
        -:  178:
       19:  179:  return true;
        -:  180:} /* lit_is_valid_cesu8_string */
        -:  181:
        -:  182:/**
        -:  183: * Check if the code point is UTF-16 low surrogate
        -:  184: *
        -:  185: * @return true / false
        -:  186: */
        -:  187:bool
    #####:  188:lit_is_code_point_utf16_low_surrogate (lit_code_point_t code_point) /**< code point */
        -:  189:{
    #####:  190:  return LIT_UTF16_LOW_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_LOW_SURROGATE_MAX;
        -:  191:} /* lit_is_code_point_utf16_low_surrogate */
        -:  192:
        -:  193:/**
        -:  194: * Check if the code point is UTF-16 high surrogate
        -:  195: *
        -:  196: * @return true / false
        -:  197: */
        -:  198:bool
    #####:  199:lit_is_code_point_utf16_high_surrogate (lit_code_point_t code_point) /**< code point */
        -:  200:{
    #####:  201:  return LIT_UTF16_HIGH_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX;
        -:  202:} /* lit_is_code_point_utf16_high_surrogate */
        -:  203:
        -:  204:/**
        -:  205: * Represents code point (>0xFFFF) as surrogate pair and returns its lower part
        -:  206: *
        -:  207: * @return lower code_unit of the surrogate pair
        -:  208: */
        -:  209:static ecma_char_t
    #####:  210:convert_code_point_to_low_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  211:{
    #####:  212:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
        -:  213:
        -:  214:  ecma_char_t code_unit_bits;
    #####:  215:  code_unit_bits = (ecma_char_t) (code_point & LIT_UTF16_LAST_10_BITS_MASK);
        -:  216:
    #####:  217:  return (ecma_char_t) (LIT_UTF16_LOW_SURROGATE_MARKER | code_unit_bits);
        -:  218:} /* convert_code_point_to_low_surrogate */
        -:  219:
        -:  220:/**
        -:  221: * Represents code point (>0xFFFF) as surrogate pair and returns its higher part
        -:  222: *
        -:  223: * @return higher code_unit of the surrogate pair
        -:  224: */
        -:  225:static ecma_char_t
    #####:  226:convert_code_point_to_high_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  227:{
    #####:  228:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
    #####:  229:  JERRY_ASSERT (code_point <= LIT_UNICODE_CODE_POINT_MAX);
        -:  230:
        -:  231:  ecma_char_t code_unit_bits;
    #####:  232:  code_unit_bits = (ecma_char_t) ((code_point - LIT_UTF16_FIRST_SURROGATE_CODE_POINT) >> LIT_UTF16_BITS_IN_SURROGATE);
        -:  233:
    #####:  234:  return (LIT_UTF16_HIGH_SURROGATE_MARKER | code_unit_bits);
        -:  235:} /* convert_code_point_to_high_surrogate */
        -:  236:
        -:  237:/**
        -:  238: * UTF16 Encoding method for a code point
        -:  239: *
        -:  240: * See also:
        -:  241: *          ECMA-262 v6, 10.1.1
        -:  242: *
        -:  243: * @return uint8_t, the number of returning code points
        -:  244: */
        -:  245:uint8_t
    #####:  246:lit_utf16_encode_code_point (lit_code_point_t cp, /**< the code point we encode */
        -:  247:                             ecma_char_t *cu_p) /**< result of the encoding */
        -:  248:{
    #####:  249:  if (cp <= LIT_UTF16_CODE_UNIT_MAX)
        -:  250:  {
    #####:  251:    cu_p[0] = (ecma_char_t) cp;
    #####:  252:    return 1;
        -:  253:  }
        -:  254:
    #####:  255:  cu_p[0] = convert_code_point_to_high_surrogate (cp);
    #####:  256:  cu_p[1] = convert_code_point_to_low_surrogate (cp);
    #####:  257:  return 2;
        -:  258:} /* lit_utf16_encode_code_point */
        -:  259:
        -:  260:/**
        -:  261: * Calculate size of a zero-terminated utf-8 string
        -:  262: *
        -:  263: * NOTE:
        -:  264: *   - string cannot be NULL
        -:  265: *   - string should not contain zero characters in the middle
        -:  266: *
        -:  267: * @return size of a string
        -:  268: */
        -:  269:lit_utf8_size_t
        6:  270:lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */
        -:  271:{
        6:  272:  JERRY_ASSERT (utf8_str_p != NULL);
        6:  273:  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);
        -:  274:} /* lit_zt_utf8_string_size */
        -:  275:
        -:  276:/**
        -:  277: * Calculate length of a cesu-8 encoded string
        -:  278: *
        -:  279: * @return UTF-16 code units count
        -:  280: */
        -:  281:lit_utf8_size_t
       20:  282:lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  283:                        lit_utf8_size_t utf8_buf_size) /**< string size */
        -:  284:{
       20:  285:  lit_utf8_size_t length = 0;
       20:  286:  lit_utf8_size_t size = 0;
        -:  287:
      299:  288:  while (size < utf8_buf_size)
        -:  289:  {
      518:  290:    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));
      259:  291:    length++;
        -:  292:  }
        -:  293:
       20:  294:  JERRY_ASSERT (size == utf8_buf_size);
        -:  295:
       20:  296:  return length;
        -:  297:} /* lit_utf8_string_length */
        -:  298:
        -:  299:/**
        -:  300: * Calculate the required size of an utf-8 encoded string from cesu-8 encoded string
        -:  301: *
        -:  302: * @return size of an utf-8 encoded string
        -:  303: */
        -:  304:lit_utf8_size_t
    #####:  305:lit_get_utf8_size_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  306:                                   lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  307:{
    #####:  308:  lit_utf8_size_t offset = 0;
    #####:  309:  lit_utf8_size_t utf8_buf_size = cesu8_buf_size;
    #####:  310:  ecma_char_t prev_ch = 0;
        -:  311:
    #####:  312:  while (offset < cesu8_buf_size)
        -:  313:  {
    #####:  314:    ecma_char_t ch;
    #####:  315:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  316:
    #####:  317:    if (lit_is_code_point_utf16_low_surrogate (ch) && lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  318:    {
    #####:  319:      utf8_buf_size -= 2;
        -:  320:    }
        -:  321:
    #####:  322:    prev_ch = ch;
        -:  323:  }
        -:  324:
    #####:  325:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  326:
    #####:  327:  return utf8_buf_size;
        -:  328:} /* lit_get_utf8_size_of_cesu8_string */
        -:  329:
        -:  330:/**
        -:  331: * Calculate length of an utf-8 encoded string from cesu-8 encoded string
        -:  332: *
        -:  333: * @return length of an utf-8 encoded string
        -:  334: */
        -:  335:lit_utf8_size_t
    #####:  336:lit_get_utf8_length_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  337:                                     lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  338:{
    #####:  339:  lit_utf8_size_t offset = 0;
    #####:  340:  lit_utf8_size_t utf8_length = 0;
    #####:  341:  ecma_char_t prev_ch = 0;
        -:  342:
    #####:  343:  while (offset < cesu8_buf_size)
        -:  344:  {
    #####:  345:    ecma_char_t ch;
    #####:  346:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  347:
    #####:  348:    if (!lit_is_code_point_utf16_low_surrogate (ch) || !lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  349:    {
    #####:  350:      utf8_length++;
        -:  351:    }
        -:  352:
    #####:  353:    prev_ch = ch;
        -:  354:  }
        -:  355:
    #####:  356:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  357:
    #####:  358:  return utf8_length;
        -:  359:} /* lit_get_utf8_length_of_cesu8_string */
        -:  360:
        -:  361:/**
        -:  362: * Decodes a unicode code point from non-empty utf-8-encoded buffer
        -:  363: *
        -:  364: * @return number of bytes occupied by code point in the string
        -:  365: */
        -:  366:lit_utf8_size_t
    #####:  367:lit_read_code_point_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  368:                               lit_utf8_size_t buf_size, /**< size of the buffer in bytes */
        -:  369:                               lit_code_point_t *code_point) /**< [out] code point */
        -:  370:{
    #####:  371:  JERRY_ASSERT (buf_p && buf_size);
        -:  372:
    #####:  373:  lit_utf8_byte_t c = buf_p[0];
    #####:  374:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  375:  {
    #####:  376:    *code_point = (lit_code_point_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
    #####:  377:    return 1;
        -:  378:  }
        -:  379:
    #####:  380:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
    #####:  381:  lit_utf8_size_t bytes_count = 0;
    #####:  382:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  383:  {
    #####:  384:    bytes_count = 2;
    #####:  385:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  386:  }
    #####:  387:  else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  388:  {
    #####:  389:    bytes_count = 3;
    #####:  390:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  391:  }
        -:  392:  else
        -:  393:  {
    #####:  394:    JERRY_ASSERT ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);
    #####:  395:    bytes_count = 4;
    #####:  396:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_3_BITS_MASK));
        -:  397:  }
        -:  398:
    #####:  399:  JERRY_ASSERT (buf_size >= bytes_count);
        -:  400:
    #####:  401:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  402:  {
    #####:  403:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  404:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  405:  }
        -:  406:
    #####:  407:  *code_point = ret;
    #####:  408:  return bytes_count;
        -:  409:} /* lit_read_code_point_from_utf8 */
        -:  410:
        -:  411:/**
        -:  412: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  413: *
        -:  414: * @return number of bytes occupied by code point in the string
        -:  415: */
        -:  416:lit_utf8_size_t
        6:  417:lit_read_code_unit_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  418:                               ecma_char_t *code_unit) /**< [out] code unit */
        -:  419:{
        6:  420:  JERRY_ASSERT (buf_p);
        -:  421:
        6:  422:  lit_utf8_byte_t c = buf_p[0];
        6:  423:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  424:  {
        6:  425:    *code_unit = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
        6:  426:    return 1;
        -:  427:  }
        -:  428:
    #####:  429:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
        -:  430:  lit_utf8_size_t bytes_count;
        -:  431:
    #####:  432:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  433:  {
    #####:  434:    bytes_count = 2;
    #####:  435:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  436:  }
        -:  437:  else
        -:  438:  {
    #####:  439:    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  440:    bytes_count = 3;
    #####:  441:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  442:  }
        -:  443:
    #####:  444:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  445:  {
    #####:  446:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  447:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  448:  }
        -:  449:
    #####:  450:  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);
    #####:  451:  *code_unit = (ecma_char_t) ret;
    #####:  452:  return bytes_count;
        -:  453:} /* lit_read_code_unit_from_cesu8 */
        -:  454:
        -:  455:/**
        -:  456: * Decodes a unicode code point from non-empty cesu-8-encoded buffer
        -:  457: *
        -:  458: * @return number of bytes occupied by code point in the string
        -:  459: */
        -:  460:lit_utf8_size_t
    #####:  461:lit_read_code_point_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  462:                                const lit_utf8_byte_t *buf_end_p, /**< buffer end */
        -:  463:                                lit_code_point_t *code_point) /**< [out] code point */
        -:  464:{
    #####:  465:  ecma_char_t code_unit;
    #####:  466:  lit_utf8_size_t size = lit_read_code_unit_from_cesu8 (buf_p, &code_unit);
        -:  467:
    #####:  468:  JERRY_ASSERT (buf_p + size <= buf_end_p);
        -:  469:
    #####:  470:  if (lit_is_code_point_utf16_high_surrogate (code_unit))
        -:  471:  {
    #####:  472:    buf_p += size;
        -:  473:
    #####:  474:    if (buf_p < buf_end_p)
        -:  475:    {
    #####:  476:      ecma_char_t next_code_unit;
    #####:  477:      lit_utf8_size_t next_size = lit_read_code_unit_from_cesu8 (buf_p, &next_code_unit);
        -:  478:
    #####:  479:      if (lit_is_code_point_utf16_low_surrogate (next_code_unit))
        -:  480:      {
    #####:  481:        JERRY_ASSERT (buf_p + next_size <= buf_end_p);
        -:  482:
    #####:  483:        *code_point = lit_convert_surrogate_pair_to_code_point (code_unit, next_code_unit);
    #####:  484:        return size + next_size;
        -:  485:      }
        -:  486:    }
        -:  487:  }
        -:  488:
    #####:  489:  *code_point = code_unit;
    #####:  490:  return size;
        -:  491:} /* lit_read_code_point_from_cesu8 */
        -:  492:
        -:  493:/**
        -:  494: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  495: *
        -:  496: * @return number of bytes occupied by code point in the string
        -:  497: */
        -:  498:lit_utf8_size_t
        3:  499:lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  500:                                   ecma_char_t *code_point) /**< [out] code point */
        -:  501:{
        3:  502:  JERRY_ASSERT (buf_p);
        -:  503:
        3:  504:  lit_utf8_decr (&buf_p);
        3:  505:  return lit_read_code_unit_from_cesu8 (buf_p, code_point);
        -:  506:} /* lit_read_prev_code_unit_from_utf8 */
        -:  507:
        -:  508:/**
        -:  509: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  510: *
        -:  511: * @return next code unit
        -:  512: */
        -:  513:ecma_char_t
    #####:  514:lit_cesu8_read_next (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  515:{
    #####:  516:  JERRY_ASSERT (*buf_p);
    #####:  517:  ecma_char_t ch;
        -:  518:
    #####:  519:  *buf_p += lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  520:
    #####:  521:  return ch;
        -:  522:} /* lit_cesu8_read_next */
        -:  523:
        -:  524:/**
        -:  525: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  526: *
        -:  527: * @return previous code unit
        -:  528: */
        -:  529:ecma_char_t
    #####:  530:lit_cesu8_read_prev (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  531:{
    #####:  532:  JERRY_ASSERT (*buf_p);
    #####:  533:  ecma_char_t ch;
        -:  534:
    #####:  535:  lit_utf8_decr (buf_p);
    #####:  536:  lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  537:
    #####:  538:  return ch;
        -:  539:} /* lit_cesu8_read_prev */
        -:  540:
        -:  541:/**
        -:  542: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  543: *
        -:  544: * @return next code unit
        -:  545: */
        -:  546:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  547:lit_cesu8_peek_next (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  548:{
    #####:  549:  JERRY_ASSERT (buf_p != NULL);
    #####:  550:  ecma_char_t ch;
        -:  551:
    #####:  552:  lit_read_code_unit_from_cesu8 (buf_p, &ch);
        -:  553:
    #####:  554:  return ch;
        -:  555:} /* lit_cesu8_peek_next */
        -:  556:
        -:  557:/**
        -:  558: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  559: *
        -:  560: * @return previous code unit
        -:  561: */
        -:  562:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  563:lit_cesu8_peek_prev (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  564:{
    #####:  565:  JERRY_ASSERT (buf_p != NULL);
    #####:  566:  ecma_char_t ch;
        -:  567:
    #####:  568:  lit_read_prev_code_unit_from_utf8 (buf_p, &ch);
        -:  569:
    #####:  570:  return ch;
        -:  571:} /* lit_cesu8_peek_prev */
        -:  572:
        -:  573:/**
        -:  574: * Increase cesu-8 encoded string pointer by one code unit.
        -:  575: */
        -:  576:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  577:lit_utf8_incr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  578:{
    #####:  579:  JERRY_ASSERT (*buf_p);
        -:  580:
    #####:  581:  *buf_p += lit_get_unicode_char_size_by_utf8_first_byte (**buf_p);
    #####:  582:} /* lit_utf8_incr */
        -:  583:
        -:  584:/**
        -:  585: * Decrease cesu-8 encoded string pointer by one code unit.
        -:  586: */
        -:  587:void
        3:  588:lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  589:{
        3:  590:  JERRY_ASSERT (*buf_p);
        3:  591:  const lit_utf8_byte_t *current_p = *buf_p;
        -:  592:
        -:  593:  do
        -:  594:  {
        3:  595:    current_p--;
        -:  596:  }
        3:  597:  while ((*(current_p) & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);
        -:  598:
        3:  599:  *buf_p = current_p;
        3:  600:} /* lit_utf8_decr */
        -:  601:
        -:  602:/**
        -:  603: * Calc hash using the specified hash_basis.
        -:  604: *
        -:  605: * NOTE:
        -:  606: *   This is implementation of FNV-1a hash function, which is released into public domain.
        -:  607: *   Constants used, are carefully picked primes by the authors.
        -:  608: *   More info: http://www.isthe.com/chongo/tech/comp/fnv/
        -:  609: *
        -:  610: * @return ecma-string's hash
        -:  611: */
        -:  612:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
        2:  613:lit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */
        -:  614:                              const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  615:                              lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  616:{
       20:  617:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  618:
       20:  619:  uint32_t hash = hash_basis;
        -:  620:
      279:  621:  for (uint32_t i = 0; i < utf8_buf_size; i++)
        -:  622:  {
        -:  623:    /* 16777619 is 32 bit FNV_prime = 2^24 + 2^8 + 0x93 = 16777619 */
      259:  624:    hash = (hash ^ utf8_buf_p[i]) * 16777619;
        -:  625:  }
        -:  626:
       20:  627:  return (lit_string_hash_t) hash;
        -:  628:} /* lit_utf8_string_hash_combine */
        -:  629:
        -:  630:/**
        -:  631: * Calculate hash from the buffer.
        -:  632: *
        -:  633: * @return ecma-string's hash
        -:  634: */
        -:  635:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
       18:  636:lit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  637:                           lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  638:{
       18:  639:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  640:
        -:  641:  /* 32 bit offset_basis for FNV = 2166136261 */
       18:  642:  return lit_utf8_string_hash_combine ((lit_string_hash_t) 2166136261, utf8_buf_p, utf8_buf_size);
        -:  643:} /* lit_utf8_string_calc_hash */
        -:  644:
        -:  645:/**
        -:  646: * Return code unit at the specified position in string
        -:  647: *
        -:  648: * NOTE:
        -:  649: *   code_unit_offset should be less then string's length
        -:  650: *
        -:  651: * @return code unit value
        -:  652: */
        -:  653:ecma_char_t
    #####:  654:lit_utf8_string_code_unit_at (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  655:                              lit_utf8_size_t utf8_buf_size, /**< string size in bytes */
        -:  656:                              lit_utf8_size_t code_unit_offset) /**< ofset of a code_unit */
        -:  657:{
    #####:  658:  lit_utf8_byte_t *current_p = (lit_utf8_byte_t *) utf8_buf_p;
    #####:  659:  ecma_char_t code_unit;
        -:  660:
        -:  661:  do
        -:  662:  {
    #####:  663:    JERRY_ASSERT (current_p < utf8_buf_p + utf8_buf_size);
    #####:  664:    current_p += lit_read_code_unit_from_cesu8 (current_p, &code_unit);
        -:  665:  }
    #####:  666:  while (code_unit_offset--);
        -:  667:
    #####:  668:  return code_unit;
        -:  669:} /* lit_utf8_string_code_unit_at */
        -:  670:
        -:  671:/**
        -:  672: * Get CESU-8 encoded size of character
        -:  673: *
        -:  674: * @return number of bytes occupied in CESU-8
        -:  675: */
        -:  676:extern inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
    #####:  677:lit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */
        -:  678:{
      259:  679:  if ((first_byte & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  680:  {
      259:  681:    return 1;
        -:  682:  }
    #####:  683:  else if ((first_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  684:  {
    #####:  685:    return 2;
        -:  686:  }
        -:  687:  else
        -:  688:  {
    #####:  689:    JERRY_ASSERT ((first_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  690:    return 3;
        -:  691:  }
        -:  692:} /* lit_get_unicode_char_size_by_utf8_first_byte */
        -:  693:
        -:  694:/**
        -:  695: * Convert code unit to cesu-8 representation
        -:  696: *
        -:  697: * @return byte count required to represent the code unit
        -:  698: */
        -:  699:lit_utf8_size_t
    #####:  700:lit_code_unit_to_utf8 (ecma_char_t code_unit, /**< code unit */
        -:  701:                       lit_utf8_byte_t *buf_p) /**< buffer where to store the result and its size
        -:  702:                                                *   should be at least LIT_UTF8_MAX_BYTES_IN_CODE_UNIT */
        -:  703:{
    #####:  704:  if (code_unit <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  705:  {
    #####:  706:    buf_p[0] = (lit_utf8_byte_t) code_unit;
    #####:  707:    return 1;
        -:  708:  }
    #####:  709:  else if (code_unit <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  710:  {
    #####:  711:    uint32_t code_unit_bits = code_unit;
    #####:  712:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  713:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  714:
    #####:  715:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  716:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  717:
    #####:  718:    buf_p[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  719:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  720:    return 2;
        -:  721:  }
        -:  722:  else
        -:  723:  {
    #####:  724:    uint32_t code_unit_bits = code_unit;
    #####:  725:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  726:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  727:
    #####:  728:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  729:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  730:
    #####:  731:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  732:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  733:
    #####:  734:    buf_p[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  735:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  736:    buf_p[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  737:    return 3;
        -:  738:  }
        -:  739:} /* lit_code_unit_to_utf8 */
        -:  740:
        -:  741:/**
        -:  742: * Convert code point to cesu-8 representation
        -:  743: *
        -:  744: * @return byte count required to represent the code point
        -:  745: */
        -:  746:lit_utf8_size_t
    #####:  747:lit_code_point_to_cesu8 (lit_code_point_t code_point, /**< code point */
        -:  748:                         lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  749:                                                *   its size should be at least 6 bytes */
        -:  750:{
    #####:  751:  if (code_point <= LIT_UTF16_CODE_UNIT_MAX)
        -:  752:  {
    #####:  753:    return lit_code_unit_to_utf8 ((ecma_char_t) code_point, buf);
        -:  754:  }
        -:  755:  else
        -:  756:  {
    #####:  757:    lit_utf8_size_t offset = lit_code_unit_to_utf8 (convert_code_point_to_high_surrogate (code_point), buf);
    #####:  758:    offset += lit_code_unit_to_utf8 (convert_code_point_to_low_surrogate (code_point), buf + offset);
    #####:  759:    return offset;
        -:  760:  }
        -:  761:} /* lit_code_point_to_cesu8 */
        -:  762:
        -:  763:/**
        -:  764: * Convert code point to utf-8 representation
        -:  765: *
        -:  766: * @return byte count required to represent the code point
        -:  767: */
        -:  768:lit_utf8_size_t
    #####:  769:lit_code_point_to_utf8 (lit_code_point_t code_point, /**< code point */
        -:  770:                        lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  771:                                              *   its size should be at least 4 bytes */
        -:  772:{
    #####:  773:  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  774:  {
    #####:  775:    buf[0] = (lit_utf8_byte_t) code_point;
    #####:  776:    return 1;
        -:  777:  }
    #####:  778:  else if (code_point <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  779:  {
    #####:  780:    uint32_t code_point_bits = code_point;
    #####:  781:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  782:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  783:
    #####:  784:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  785:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  786:
    #####:  787:    buf[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  788:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  789:    return 2;
        -:  790:  }
    #####:  791:  else if (code_point <= LIT_UTF8_3_BYTE_CODE_POINT_MAX)
        -:  792:  {
    #####:  793:    uint32_t code_point_bits = code_point;
    #####:  794:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  795:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  796:
    #####:  797:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  798:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  799:
    #####:  800:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  801:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  802:
    #####:  803:    buf[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  804:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  805:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  806:    return 3;
        -:  807:  }
        -:  808:  else
        -:  809:  {
    #####:  810:    JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MAX);
        -:  811:
    #####:  812:    uint32_t code_point_bits = code_point;
    #####:  813:    lit_utf8_byte_t fourth_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  814:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  815:
    #####:  816:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  817:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  818:
    #####:  819:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  820:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  821:
    #####:  822:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_3_BITS_MASK);
    #####:  823:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  824:
    #####:  825:    buf[0] = LIT_UTF8_4_BYTE_MARKER | first_byte_bits;
    #####:  826:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  827:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  828:    buf[3] = LIT_UTF8_EXTRA_BYTE_MARKER | fourth_byte_bits;
    #####:  829:    return 4;
        -:  830:  }
        -:  831:} /* lit_code_point_to_utf8 */
        -:  832:
        -:  833:/**
        -:  834: * Convert cesu-8 string to an utf-8 string and put it into the buffer.
        -:  835: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -:  836: *
        -:  837: * @return number of bytes copied to the buffer.
        -:  838: */
        -:  839:lit_utf8_size_t
    #####:  840:lit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *cesu8_string, /**< cesu-8 string */
        -:  841:                                         lit_utf8_size_t cesu8_size, /**< size of cesu-8 string */
        -:  842:                                         lit_utf8_byte_t *utf8_string, /**< destination utf-8 buffer pointer
        -:  843:                                                                        * (can be NULL if buffer_size == 0) */
        -:  844:                                         lit_utf8_size_t utf8_size) /**< size of utf-8 buffer */
        -:  845:{
    #####:  846:  const lit_utf8_byte_t *cesu8_pos = cesu8_string;
    #####:  847:  const lit_utf8_byte_t *cesu8_end_pos = cesu8_string + cesu8_size;
        -:  848:
    #####:  849:  lit_utf8_byte_t *utf8_pos = utf8_string;
    #####:  850:  lit_utf8_byte_t *utf8_end_pos = utf8_string + utf8_size;
        -:  851:
    #####:  852:  lit_utf8_size_t size = 0;
        -:  853:
    #####:  854:  ecma_char_t prev_ch = 0;
    #####:  855:  lit_utf8_size_t prev_ch_size = 0;
        -:  856:
    #####:  857:  while (cesu8_pos < cesu8_end_pos)
        -:  858:  {
    #####:  859:    ecma_char_t ch;
    #####:  860:    lit_utf8_size_t code_unit_size = lit_read_code_unit_from_cesu8 (cesu8_pos, &ch);
        -:  861:
    #####:  862:    if (lit_is_code_point_utf16_low_surrogate (ch) && lit_is_code_point_utf16_high_surrogate (prev_ch))
    #####:  863:    {
    #####:  864:      JERRY_ASSERT (code_unit_size == prev_ch_size);
    #####:  865:      utf8_pos -= prev_ch_size;
    #####:  866:      lit_code_point_t code_point = lit_convert_surrogate_pair_to_code_point (prev_ch, ch);
    #####:  867:      lit_code_point_to_utf8 (code_point, utf8_pos);
    #####:  868:      size++;
        -:  869:    }
        -:  870:    else
        -:  871:    {
    #####:  872:      memcpy (utf8_pos, cesu8_pos, code_unit_size);
    #####:  873:      size += code_unit_size;
        -:  874:    }
        -:  875:
    #####:  876:    utf8_pos = utf8_string + size;
    #####:  877:    cesu8_pos += code_unit_size;
    #####:  878:    prev_ch = ch;
    #####:  879:    prev_ch_size = code_unit_size;
        -:  880:  }
        -:  881:
    #####:  882:  JERRY_ASSERT (cesu8_pos == cesu8_end_pos);
    #####:  883:  JERRY_ASSERT (utf8_pos <= utf8_end_pos);
        -:  884:
    #####:  885:  return size;
        -:  886:} /* lit_convert_cesu8_string_to_utf8_string */
        -:  887:
        -:  888:/**
        -:  889: * Convert surrogate pair to code point
        -:  890: *
        -:  891: * @return code point
        -:  892: */
        -:  893:lit_code_point_t
    #####:  894:lit_convert_surrogate_pair_to_code_point (ecma_char_t high_surrogate, /**< high surrogate code point */
        -:  895:                                          ecma_char_t low_surrogate) /**< low surrogate code point */
        -:  896:{
    #####:  897:  JERRY_ASSERT (lit_is_code_point_utf16_high_surrogate (high_surrogate));
    #####:  898:  JERRY_ASSERT (lit_is_code_point_utf16_low_surrogate (low_surrogate));
        -:  899:
        -:  900:  lit_code_point_t code_point;
    #####:  901:  code_point = (uint16_t) (high_surrogate - LIT_UTF16_HIGH_SURROGATE_MIN);
    #####:  902:  code_point <<= LIT_UTF16_BITS_IN_SURROGATE;
        -:  903:
    #####:  904:  code_point += LIT_UTF16_FIRST_SURROGATE_CODE_POINT;
        -:  905:
    #####:  906:  code_point |= (uint16_t) (low_surrogate - LIT_UTF16_LOW_SURROGATE_MIN);
    #####:  907:  return code_point;
        -:  908:} /* lit_convert_surrogate_pair_to_code_point */
        -:  909:
        -:  910:/**
        -:  911: * Relational compare of cesu-8 strings
        -:  912: *
        -:  913: * First string is less than second string if:
        -:  914: *  - strings are not equal;
        -:  915: *  - first string is prefix of second or is lexicographically less than second.
        -:  916: *
        -:  917: * @return true - if first string is less than second string,
        -:  918: *         false - otherwise
        -:  919: */
    #####:  920:bool lit_compare_utf8_strings_relational (const lit_utf8_byte_t *string1_p, /**< utf-8 string */
        -:  921:                                          lit_utf8_size_t string1_size, /**< string size */
        -:  922:                                          const lit_utf8_byte_t *string2_p, /**< utf-8 string */
        -:  923:                                          lit_utf8_size_t string2_size) /**< string size */
        -:  924:{
    #####:  925:  lit_utf8_byte_t *string1_pos = (lit_utf8_byte_t *) string1_p;
    #####:  926:  lit_utf8_byte_t *string2_pos = (lit_utf8_byte_t *) string2_p;
    #####:  927:  const lit_utf8_byte_t *string1_end_p = string1_p + string1_size;
    #####:  928:  const lit_utf8_byte_t *string2_end_p = string2_p + string2_size;
        -:  929:
    #####:  930:  while (string1_pos < string1_end_p && string2_pos < string2_end_p)
        -:  931:  {
    #####:  932:    ecma_char_t ch1, ch2;
    #####:  933:    string1_pos += lit_read_code_unit_from_cesu8 (string1_pos, &ch1);
    #####:  934:    string2_pos += lit_read_code_unit_from_cesu8 (string2_pos, &ch2);
        -:  935:
    #####:  936:    if (ch1 < ch2)
        -:  937:    {
    #####:  938:      return true;
        -:  939:    }
    #####:  940:    else if (ch1 > ch2)
        -:  941:    {
    #####:  942:      return false;
        -:  943:    }
        -:  944:  }
        -:  945:
    #####:  946:  return (string1_pos >= string1_end_p && string2_pos < string2_end_p);
        -:  947:} /* lit_compare_utf8_strings_relational */
