        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-util.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:#include "ecma-helpers.h"
        -:   18:
        -:   19:#if JERRY_PARSER
        -:   20:
        -:   21:#if JERRY_LINE_INFO
        -:   22:#include "jcontext.h"
        -:   23:#endif /* JERRY_LINE_INFO */
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_utils Utility
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**********************************************************************/
        -:   36:/* Emitting byte codes                                                */
        -:   37:/**********************************************************************/
        -:   38:
        -:   39:/**
        -:   40: * Append two bytes to the cbc stream.
        -:   41: */
        -:   42:static void
       33:   43:parser_emit_two_bytes (parser_context_t *context_p, /**< context */
        -:   44:                       uint8_t first_byte, /**< first byte */
        -:   45:                       uint8_t second_byte) /**< second byte */
        -:   46:{
       33:   47:  uint32_t last_position = context_p->byte_code.last_position;
        -:   48:
       33:   49:  if (last_position + 2 <= PARSER_CBC_STREAM_PAGE_SIZE)
        -:   50:  {
       33:   51:    parser_mem_page_t *page_p = context_p->byte_code.last_p;
        -:   52:
       33:   53:    page_p->bytes[last_position] = first_byte;
       33:   54:    page_p->bytes[last_position + 1] = second_byte;
       33:   55:    context_p->byte_code.last_position = last_position + 2;
        -:   56:  }
    #####:   57:  else if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:   58:  {
        -:   59:    parser_mem_page_t *page_p;
        -:   60:
    #####:   61:    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);
    #####:   62:    page_p = context_p->byte_code.last_p;
    #####:   63:    page_p->bytes[0] = first_byte;
    #####:   64:    page_p->bytes[1] = second_byte;
    #####:   65:    context_p->byte_code.last_position = 2;
        -:   66:  }
        -:   67:  else
        -:   68:  {
    #####:   69:    context_p->byte_code.last_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] = first_byte;
    #####:   70:    parser_cbc_stream_alloc_page (context_p, &context_p->byte_code);
    #####:   71:    context_p->byte_code.last_p->bytes[0] = second_byte;
    #####:   72:    context_p->byte_code.last_position = 1;
        -:   73:  }
       33:   74:} /* parser_emit_two_bytes */
        -:   75:
        -:   76:/**
        -:   77: * Append byte to the end of the current byte code stream.
        -:   78: *
        -:   79: * @param context_p parser context
        -:   80: * @param byte byte
        -:   81: */
        -:   82:#define PARSER_APPEND_TO_BYTE_CODE(context_p, byte) \
        -:   83:  if ((context_p)->byte_code.last_position >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:   84:  { \
        -:   85:    parser_cbc_stream_alloc_page ((context_p), &(context_p)->byte_code); \
        -:   86:  } \
        -:   87:  (context_p)->byte_code.last_p->bytes[(context_p)->byte_code.last_position++] = (uint8_t) (byte)
        -:   88:
        -:   89:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:   90:
        -:   91:/**
        -:   92: * Print literal corresponding to the current index
        -:   93: */
        -:   94:static void
        -:   95:parser_print_literal (parser_context_t *context_p, /**< context */
        -:   96:                      uint16_t literal_index) /**< index of literal */
        -:   97:{
        -:   98:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p;
        -:   99:  parser_scope_stack_t *scope_stack_end_p = scope_stack_p + context_p->scope_stack_top;
        -:  100:  bool in_scope_literal = false;
        -:  101:
        -:  102:  while (scope_stack_p < scope_stack_end_p)
        -:  103:  {
        -:  104:    scope_stack_end_p--;
        -:  105:
        -:  106:    if (scope_stack_end_p->map_from == PARSER_SCOPE_STACK_FUNC)
        -:  107:    {
        -:  108:      if (literal_index == scope_stack_end_p->map_to)
        -:  109:      {
        -:  110:        in_scope_literal = true;
        -:  111:        break;
        -:  112:      }
        -:  113:    }
        -:  114:    else if (literal_index == scanner_decode_map_to (scope_stack_end_p))
        -:  115:    {
        -:  116:      in_scope_literal = true;
        -:  117:      break;
        -:  118:    }
        -:  119:  }
        -:  120:
        -:  121:  if (literal_index < PARSER_REGISTER_START)
        -:  122:  {
        -:  123:    JERRY_DEBUG_MSG (in_scope_literal ? " IDX:%d->" : " idx:%d->", literal_index);
        -:  124:    lexer_literal_t *literal_p = PARSER_GET_LITERAL (literal_index);
        -:  125:    util_print_literal (literal_p);
        -:  126:    return;
        -:  127:  }
        -:  128:
        -:  129:  if (!in_scope_literal)
        -:  130:  {
        -:  131:    JERRY_DEBUG_MSG (" reg:%d", (int) (literal_index - PARSER_REGISTER_START));
        -:  132:    return;
        -:  133:  }
        -:  134:
        -:  135:  JERRY_DEBUG_MSG (" REG:%d->", (int) (literal_index - PARSER_REGISTER_START));
        -:  136:
        -:  137:  lexer_literal_t *literal_p = PARSER_GET_LITERAL (scope_stack_end_p->map_from);
        -:  138:  util_print_literal (literal_p);
        -:  139:} /* parser_print_literal */
        -:  140:
        -:  141:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  142:
        -:  143:/**
        -:  144: * Append the current byte code to the stream
        -:  145: */
        -:  146:void
       48:  147:parser_flush_cbc (parser_context_t *context_p) /**< context */
        -:  148:{
        -:  149:  uint8_t flags;
       48:  150:  uint16_t last_opcode = context_p->last_cbc_opcode;
        -:  151:
       48:  152:  if (last_opcode == PARSER_CBC_UNAVAILABLE)
        -:  153:  {
       12:  154:    return;
        -:  155:  }
        -:  156:
       36:  157:  context_p->status_flags |= PARSER_NO_END_LABEL;
        -:  158:
       36:  159:  if (PARSER_IS_BASIC_OPCODE (last_opcode))
        -:  160:  {
       35:  161:    cbc_opcode_t opcode = (cbc_opcode_t) last_opcode;
        -:  162:
       35:  163:    JERRY_ASSERT (opcode < CBC_END);
       35:  164:    flags = cbc_flags[opcode];
        -:  165:
       35:  166:    PARSER_APPEND_TO_BYTE_CODE (context_p, opcode);
       35:  167:    context_p->byte_code_size++;
        -:  168:  }
        -:  169:  else
        -:  170:  {
        1:  171:    cbc_ext_opcode_t opcode = (cbc_ext_opcode_t) PARSER_GET_EXT_OPCODE (last_opcode);
        -:  172:
        1:  173:    JERRY_ASSERT (opcode < CBC_EXT_END);
        1:  174:    flags = cbc_ext_flags[opcode];
        1:  175:    parser_emit_two_bytes (context_p, CBC_EXT_OPCODE, (uint8_t) opcode);
        1:  176:    context_p->byte_code_size += 2;
        -:  177:  }
        -:  178:
       36:  179:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  180:                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
       36:  181:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  182:
       36:  183:  if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  184:  {
       20:  185:    uint16_t literal_index = context_p->last_cbc.literal_index;
        -:  186:
       40:  187:    parser_emit_two_bytes (context_p,
       20:  188:                           (uint8_t) (literal_index & 0xff),
       20:  189:                           (uint8_t) (literal_index >> 8));
       20:  190:    context_p->byte_code_size += 2;
        -:  191:  }
        -:  192:
       36:  193:  if (flags & CBC_HAS_LITERAL_ARG2)
        -:  194:  {
        5:  195:    uint16_t literal_index = context_p->last_cbc.value;
        -:  196:
       10:  197:    parser_emit_two_bytes (context_p,
        5:  198:                           (uint8_t) (literal_index & 0xff),
        5:  199:                           (uint8_t) (literal_index >> 8));
        5:  200:    context_p->byte_code_size += 2;
        -:  201:
        5:  202:    if (!(flags & CBC_HAS_LITERAL_ARG))
        -:  203:    {
        1:  204:      literal_index = context_p->last_cbc.third_literal_index;
        -:  205:
        2:  206:      parser_emit_two_bytes (context_p,
        1:  207:                             (uint8_t) (literal_index & 0xff),
        1:  208:                             (uint8_t) (literal_index >> 8));
        1:  209:      context_p->byte_code_size += 2;
        -:  210:    }
        -:  211:  }
        -:  212:
       36:  213:  if (flags & CBC_HAS_BYTE_ARG)
        -:  214:  {
        3:  215:    uint8_t byte_argument = (uint8_t) context_p->last_cbc.value;
        -:  216:
        3:  217:    JERRY_ASSERT (context_p->last_cbc.value <= CBC_MAXIMUM_BYTE_VALUE);
        -:  218:
        3:  219:    if (flags & CBC_POP_STACK_BYTE_ARG)
        -:  220:    {
        1:  221:      JERRY_ASSERT (context_p->stack_depth >= byte_argument);
        1:  222:      PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, byte_argument);
        -:  223:    }
        -:  224:
        3:  225:    PARSER_APPEND_TO_BYTE_CODE (context_p, byte_argument);
        3:  226:    context_p->byte_code_size++;
        -:  227:  }
        -:  228:
        -:  229:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  230:  if (context_p->is_show_opcodes)
        -:  231:  {
        -:  232:    JERRY_DEBUG_MSG ("  [%3d] %s",
        -:  233:                     (int) context_p->stack_depth,
        -:  234:                     PARSER_IS_BASIC_OPCODE (last_opcode) ? cbc_names[last_opcode]
        -:  235:                                                          : cbc_ext_names[PARSER_GET_EXT_OPCODE (last_opcode)]);
        -:  236:
        -:  237:    if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  238:    {
        -:  239:      parser_print_literal (context_p, context_p->last_cbc.literal_index);
        -:  240:    }
        -:  241:
        -:  242:    if (flags & CBC_HAS_LITERAL_ARG2)
        -:  243:    {
        -:  244:      parser_print_literal (context_p, context_p->last_cbc.value);
        -:  245:
        -:  246:      if (!(flags & CBC_HAS_LITERAL_ARG))
        -:  247:      {
        -:  248:        parser_print_literal (context_p, context_p->last_cbc.third_literal_index);
        -:  249:      }
        -:  250:    }
        -:  251:
        -:  252:    if (flags & CBC_HAS_BYTE_ARG)
        -:  253:    {
        -:  254:      if (last_opcode == CBC_PUSH_NUMBER_POS_BYTE
        -:  255:          || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)
        -:  256:      {
        -:  257:        JERRY_DEBUG_MSG (" number:%d", (int) context_p->last_cbc.value + 1);
        -:  258:      }
        -:  259:      else if (last_opcode == CBC_PUSH_NUMBER_NEG_BYTE
        -:  260:               || last_opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE)
        -:  261:      {
        -:  262:        JERRY_DEBUG_MSG (" number:%d", -((int) context_p->last_cbc.value + 1));
        -:  263:      }
        -:  264:      else
        -:  265:      {
        -:  266:        JERRY_DEBUG_MSG (" byte_arg:%d", (int) context_p->last_cbc.value);
        -:  267:      }
        -:  268:    }
        -:  269:
        -:  270:    JERRY_DEBUG_MSG ("\n");
        -:  271:  }
        -:  272:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  273:
       36:  274:  if (context_p->stack_depth > context_p->stack_limit)
        -:  275:  {
       10:  276:    context_p->stack_limit = context_p->stack_depth;
       10:  277:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  278:    {
    #####:  279:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  280:    }
        -:  281:  }
        -:  282:
       36:  283:  context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -:  284:} /* parser_flush_cbc */
        -:  285:
        -:  286:/**
        -:  287: * Append a byte code
        -:  288: */
        -:  289:void
       14:  290:parser_emit_cbc (parser_context_t *context_p, /**< context */
        -:  291:                 uint16_t opcode) /**< opcode */
        -:  292:{
       14:  293:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, 0));
        -:  294:
       14:  295:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  296:  {
       11:  297:    parser_flush_cbc (context_p);
        -:  298:  }
        -:  299:
       14:  300:  context_p->last_cbc_opcode = opcode;
       14:  301:} /* parser_emit_cbc */
        -:  302:
        -:  303:/**
        -:  304: * Append a byte code with a literal argument
        -:  305: */
        -:  306:void
       10:  307:parser_emit_cbc_literal (parser_context_t *context_p, /**< context */
        -:  308:                         uint16_t opcode, /**< opcode */
        -:  309:                         uint16_t literal_index) /**< literal index */
        -:  310:{
       10:  311:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));
        -:  312:
       10:  313:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  314:  {
        5:  315:    parser_flush_cbc (context_p);
        -:  316:  }
        -:  317:
       10:  318:  context_p->last_cbc_opcode = opcode;
       10:  319:  context_p->last_cbc.literal_index = literal_index;
       10:  320:  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;
       10:  321:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
       10:  322:} /* parser_emit_cbc_literal */
        -:  323:
        -:  324:/**
        -:  325: * Append a byte code with a literal and value argument
        -:  326: */
        -:  327:void
    #####:  328:parser_emit_cbc_literal_value (parser_context_t *context_p, /**< context */
        -:  329:                               uint16_t opcode, /**< opcode */
        -:  330:                               uint16_t literal_index, /**< literal index */
        -:  331:                               uint16_t value) /**< value */
        -:  332:{
    #####:  333:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -:  334:
    #####:  335:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  336:  {
    #####:  337:    parser_flush_cbc (context_p);
        -:  338:  }
        -:  339:
    #####:  340:  context_p->last_cbc_opcode = opcode;
    #####:  341:  context_p->last_cbc.literal_index = literal_index;
    #####:  342:  context_p->last_cbc.literal_type = LEXER_UNUSED_LITERAL;
    #####:  343:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####:  344:  context_p->last_cbc.value = value;
    #####:  345:} /* parser_emit_cbc_literal_value */
        -:  346:
        -:  347:/**
        -:  348: * Append a byte code with the current literal argument
        -:  349: */
        -:  350:void
       11:  351:parser_emit_cbc_literal_from_token (parser_context_t *context_p, /**< context */
        -:  352:                                    uint16_t opcode) /**< opcode */
        -:  353:{
       11:  354:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_LITERAL_ARG));
        -:  355:
       11:  356:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  357:  {
        2:  358:    parser_flush_cbc (context_p);
        -:  359:  }
        -:  360:
       11:  361:  context_p->last_cbc_opcode = opcode;
       11:  362:  context_p->last_cbc.literal_index = context_p->lit_object.index;
       11:  363:  context_p->last_cbc.literal_type = context_p->token.lit_location.type;
       11:  364:  context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
       11:  365:} /* parser_emit_cbc_literal_from_token */
        -:  366:
        -:  367:/**
        -:  368: * Append a byte code with a call argument
        -:  369: */
        -:  370:void
        1:  371:parser_emit_cbc_call (parser_context_t *context_p, /**< context */
        -:  372:                      uint16_t opcode, /**< opcode */
        -:  373:                      size_t call_arguments) /**< number of arguments */
        -:  374:{
        1:  375:  JERRY_ASSERT (PARSER_ARGS_EQ (opcode, CBC_HAS_BYTE_ARG));
        1:  376:  JERRY_ASSERT (call_arguments <= CBC_MAXIMUM_BYTE_VALUE);
        -:  377:
        1:  378:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  379:  {
        1:  380:    parser_flush_cbc (context_p);
        -:  381:  }
        -:  382:
        1:  383:  context_p->last_cbc_opcode = opcode;
        1:  384:  context_p->last_cbc.value = (uint16_t) call_arguments;
        1:  385:} /* parser_emit_cbc_call */
        -:  386:
        -:  387:/**
        -:  388: * Append a push number 1/2 byte code
        -:  389: */
        -:  390:void
        2:  391:parser_emit_cbc_push_number (parser_context_t *context_p, /**< context */
        -:  392:                             bool is_negative_number) /**< sign is negative */
        -:  393:{
        2:  394:  uint16_t value = context_p->lit_object.index;
        2:  395:  uint16_t lit_value = PARSER_INVALID_LITERAL_INDEX;
        -:  396:
        2:  397:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  398:  {
        1:  399:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  400:    {
        1:  401:      lit_value = context_p->last_cbc.literal_index;
        -:  402:    }
        -:  403:    else
        -:  404:    {
    #####:  405:      if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  406:      {
    #####:  407:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  408:        lit_value = context_p->last_cbc.value;
        -:  409:      }
    #####:  410:      else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -:  411:      {
    #####:  412:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  413:        lit_value = context_p->last_cbc.third_literal_index;
        -:  414:      }
        -:  415:
    #####:  416:      parser_flush_cbc (context_p);
        -:  417:    }
        -:  418:  }
        -:  419:
        2:  420:  if (value == 0)
        -:  421:  {
    #####:  422:    if (lit_value == PARSER_INVALID_LITERAL_INDEX)
        -:  423:    {
    #####:  424:      context_p->last_cbc_opcode = CBC_PUSH_NUMBER_0;
    #####:  425:      return;
        -:  426:    }
        -:  427:
    #####:  428:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL_PUSH_NUMBER_0;
    #####:  429:    context_p->last_cbc.literal_index = lit_value;
    #####:  430:    return;
        -:  431:  }
        -:  432:
        -:  433:  uint16_t opcode;
        -:  434:
        2:  435:  if (lit_value == PARSER_INVALID_LITERAL_INDEX)
        -:  436:  {
        1:  437:    opcode = (is_negative_number ? CBC_PUSH_NUMBER_NEG_BYTE
        -:  438:                                 : CBC_PUSH_NUMBER_POS_BYTE);
        -:  439:
        1:  440:    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 1);
        -:  441:  }
        -:  442:  else
        -:  443:  {
        1:  444:    opcode = (is_negative_number ? CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE
        -:  445:                                 : CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE);
        1:  446:    JERRY_ASSERT (CBC_STACK_ADJUST_VALUE (PARSER_GET_FLAGS (opcode)) == 2);
        -:  447:
        1:  448:    context_p->last_cbc.literal_index = lit_value;
        -:  449:  }
        -:  450:
        2:  451:  JERRY_ASSERT (value > 0 && value <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -:  452:
        2:  453:  context_p->last_cbc_opcode = opcode;
        2:  454:  context_p->last_cbc.value = (uint16_t) (value - 1);
        -:  455:} /* parser_emit_cbc_push_number */
        -:  456:
        -:  457:/**
        -:  458: * Append a byte code with a branch argument
        -:  459: */
        -:  460:void
        3:  461:parser_emit_cbc_forward_branch (parser_context_t *context_p, /**< context */
        -:  462:                                uint16_t opcode, /**< opcode */
        -:  463:                                parser_branch_t *branch_p) /**< branch result */
        -:  464:{
        -:  465:  uint8_t flags;
        -:  466:  uint32_t extra_byte_code_increase;
        -:  467:
        3:  468:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  469:  {
        1:  470:    parser_flush_cbc (context_p);
        -:  471:  }
        -:  472:
        3:  473:  context_p->status_flags |= PARSER_NO_END_LABEL;
        -:  474:
        3:  475:  if (PARSER_IS_BASIC_OPCODE (opcode))
        -:  476:  {
    #####:  477:    JERRY_ASSERT (opcode < CBC_END);
    #####:  478:    flags = cbc_flags[opcode];
    #####:  479:    extra_byte_code_increase = 0;
        -:  480:  }
        -:  481:  else
        -:  482:  {
        3:  483:    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);
        3:  484:    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);
        -:  485:
        3:  486:    JERRY_ASSERT (opcode < CBC_EXT_END);
        3:  487:    flags = cbc_ext_flags[opcode];
        3:  488:    extra_byte_code_increase = 1;
        -:  489:  }
        -:  490:
        3:  491:  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
        3:  492:  JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
        3:  493:  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);
        -:  494:
        -:  495:  /* Branch opcodes never push anything onto the stack. */
        3:  496:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  497:                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
        3:  498:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  499:
        -:  500:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  501:  if (context_p->is_show_opcodes)
        -:  502:  {
        -:  503:    JERRY_DEBUG_MSG ("  [%3d] %s\n",
        -:  504:                     (int) context_p->stack_depth,
        -:  505:                     extra_byte_code_increase == 0 ? cbc_names[opcode] : cbc_ext_names[opcode]);
        -:  506:  }
        -:  507:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  508:
        3:  509:  PARSER_PLUS_EQUAL_U16 (opcode, PARSER_MAX_BRANCH_LENGTH - 1);
        -:  510:
        3:  511:  parser_emit_two_bytes (context_p, (uint8_t) opcode, 0);
        3:  512:  branch_p->page_p = context_p->byte_code.last_p;
        3:  513:  branch_p->offset = (context_p->byte_code.last_position - 1) | (context_p->byte_code_size << 8);
        -:  514:
        3:  515:  context_p->byte_code_size += extra_byte_code_increase;
        -:  516:
        -:  517:#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX
        -:  518:  PARSER_APPEND_TO_BYTE_CODE (context_p, 0);
        -:  519:#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        3:  520:  parser_emit_two_bytes (context_p, 0, 0);
        -:  521:#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */
        -:  522:
        3:  523:  context_p->byte_code_size += PARSER_MAX_BRANCH_LENGTH + 1;
        -:  524:
        3:  525:  if (context_p->stack_depth > context_p->stack_limit)
        -:  526:  {
        1:  527:    context_p->stack_limit = context_p->stack_depth;
        1:  528:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  529:    {
    #####:  530:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  531:    }
        -:  532:  }
        3:  533:} /* parser_emit_cbc_forward_branch */
        -:  534:
        -:  535:/**
        -:  536: * Append a branch byte code and create an item.
        -:  537: *
        -:  538: * @return newly created parser branch node
        -:  539: */
        -:  540:parser_branch_node_t *
    #####:  541:parser_emit_cbc_forward_branch_item (parser_context_t *context_p, /**< context */
        -:  542:                                     uint16_t opcode, /**< opcode */
        -:  543:                                     parser_branch_node_t *next_p) /**< next branch */
        -:  544:{
    #####:  545:  parser_branch_t branch;
        -:  546:  parser_branch_node_t *new_item;
        -:  547:
        -:  548:  /* Since byte code insertion may throw an out-of-memory error,
        -:  549:   * the branch is constructed locally, and copied later. */
    #####:  550:  parser_emit_cbc_forward_branch (context_p, opcode, &branch);
        -:  551:
    #####:  552:  new_item = (parser_branch_node_t *) parser_malloc (context_p, sizeof (parser_branch_node_t));
    #####:  553:  new_item->branch = branch;
    #####:  554:  new_item->next_p = next_p;
    #####:  555:  return new_item;
        -:  556:} /* parser_emit_cbc_forward_branch_item */
        -:  557:
        -:  558:/**
        -:  559: * Append a byte code with a branch argument
        -:  560: */
        -:  561:void
        1:  562:parser_emit_cbc_backward_branch (parser_context_t *context_p, /**< context */
        -:  563:                                 uint16_t opcode, /**< opcode */
        -:  564:                                 uint32_t offset) /**< destination offset */
        -:  565:{
        -:  566:  uint8_t flags;
        -:  567:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  568:  const char *name;
        -:  569:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  570:
        1:  571:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  572:  {
    #####:  573:    parser_flush_cbc (context_p);
        -:  574:  }
        -:  575:
        1:  576:  context_p->status_flags |= PARSER_NO_END_LABEL;
        1:  577:  offset = context_p->byte_code_size - offset;
        -:  578:
        1:  579:  if (PARSER_IS_BASIC_OPCODE (opcode))
        -:  580:  {
    #####:  581:    JERRY_ASSERT (opcode < CBC_END);
    #####:  582:    flags = cbc_flags[opcode];
        -:  583:
        -:  584:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  585:    name = cbc_names[opcode];
        -:  586:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  587:  }
        -:  588:  else
        -:  589:  {
        1:  590:    PARSER_APPEND_TO_BYTE_CODE (context_p, CBC_EXT_OPCODE);
        1:  591:    opcode = (uint16_t) PARSER_GET_EXT_OPCODE (opcode);
        -:  592:
        1:  593:    JERRY_ASSERT (opcode < CBC_EXT_END);
        1:  594:    flags = cbc_ext_flags[opcode];
        1:  595:    context_p->byte_code_size++;
        -:  596:
        -:  597:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  598:    name = cbc_ext_names[opcode];
        -:  599:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  600:  }
        -:  601:
        1:  602:  JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
        1:  603:  JERRY_ASSERT (CBC_BRANCH_IS_BACKWARD (flags));
        1:  604:  JERRY_ASSERT (CBC_BRANCH_OFFSET_LENGTH (opcode) == 1);
        1:  605:  JERRY_ASSERT (offset <= context_p->byte_code_size);
        -:  606:
        -:  607:  /* Branch opcodes never push anything onto the stack. */
        1:  608:  JERRY_ASSERT ((flags >> CBC_STACK_ADJUST_SHIFT) >= CBC_STACK_ADJUST_BASE
        -:  609:                 || (CBC_STACK_ADJUST_BASE - (flags >> CBC_STACK_ADJUST_SHIFT)) <= context_p->stack_depth);
        1:  610:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, CBC_STACK_ADJUST_VALUE (flags));
        -:  611:
        -:  612:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  613:  if (context_p->is_show_opcodes)
        -:  614:  {
        -:  615:    JERRY_DEBUG_MSG ("  [%3d] %s\n", (int) context_p->stack_depth, name);
        -:  616:  }
        -:  617:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  618:
        1:  619:  context_p->byte_code_size += 2;
        -:  620:#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX
        1:  621:  if (offset > UINT16_MAX)
        -:  622:  {
    #####:  623:    opcode++;
    #####:  624:    context_p->byte_code_size++;
        -:  625:  }
        -:  626:#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        -:  627:
        1:  628:  if (offset > UINT8_MAX)
        -:  629:  {
    #####:  630:    opcode++;
    #####:  631:    context_p->byte_code_size++;
        -:  632:  }
        -:  633:
        1:  634:  PARSER_APPEND_TO_BYTE_CODE (context_p, (uint8_t) opcode);
        -:  635:
        -:  636:#if PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX
        1:  637:  if (offset > UINT16_MAX)
        -:  638:  {
    #####:  639:    PARSER_APPEND_TO_BYTE_CODE (context_p, offset >> 16);
        -:  640:  }
        -:  641:#endif /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        -:  642:
        1:  643:  if (offset > UINT8_MAX)
        -:  644:  {
    #####:  645:    PARSER_APPEND_TO_BYTE_CODE (context_p, (offset >> 8) & 0xff);
        -:  646:  }
        -:  647:
        1:  648:  PARSER_APPEND_TO_BYTE_CODE (context_p, offset & 0xff);
        1:  649:} /* parser_emit_cbc_backward_branch */
        -:  650:
        -:  651:#undef PARSER_CHECK_LAST_POSITION
        -:  652:#undef PARSER_APPEND_TO_BYTE_CODE
        -:  653:
        -:  654:/**
        -:  655: * Helper function for parser.
        -:  656: *
        -:  657: * @return a new string based on encode.
        -:  658: */
        -:  659:ecma_string_t *
    #####:  660:parser_new_ecma_string_from_literal (lexer_literal_t *literal_p) /**< literal */
        -:  661:{
    #####:  662:  JERRY_ASSERT (literal_p != NULL);
        -:  663:
    #####:  664:  ecma_string_t *new_string = NULL;
        -:  665:
    #####:  666:  if (literal_p->status_flags & LEXER_FLAG_ASCII)
        -:  667:  {
    #####:  668:    new_string = ecma_new_ecma_string_from_ascii (literal_p->u.char_p, literal_p->prop.length);
        -:  669:  }
        -:  670:  else
        -:  671:  {
    #####:  672:    new_string = ecma_new_ecma_string_from_utf8 (literal_p->u.char_p, literal_p->prop.length);
        -:  673:  }
        -:  674:
    #####:  675:  return new_string;
        -:  676:} /* parser_new_ecma_string_from_literal  */
        -:  677:
        -:  678:/**
        -:  679: * Set a branch to the current byte code position
        -:  680: */
        -:  681:void
        3:  682:parser_set_branch_to_current_position (parser_context_t *context_p, /**< context */
        -:  683:                                       parser_branch_t *branch_p) /**< branch result */
        -:  684:{
        -:  685:  uint32_t delta;
        -:  686:  size_t offset;
        3:  687:  parser_mem_page_t *page_p = branch_p->page_p;
        -:  688:
        3:  689:  if (context_p->last_cbc_opcode != PARSER_CBC_UNAVAILABLE)
        -:  690:  {
    #####:  691:    parser_flush_cbc (context_p);
        -:  692:  }
        -:  693:
        3:  694:  context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  695:
        3:  696:  JERRY_ASSERT (context_p->byte_code_size > (branch_p->offset >> 8));
        -:  697:
        3:  698:  delta = context_p->byte_code_size - (branch_p->offset >> 8);
        3:  699:  offset = (branch_p->offset & CBC_LOWER_SEVEN_BIT_MASK);
        -:  700:
        3:  701:  JERRY_ASSERT (delta <= PARSER_MAXIMUM_CODE_SIZE);
        -:  702:
        -:  703:#if PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX
        -:  704:  page_p->bytes[offset++] = (uint8_t) (delta >> 8);
        -:  705:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  706:  {
        -:  707:    page_p = page_p->next_p;
        -:  708:    offset = 0;
        -:  709:  }
        -:  710:#else /* PARSER_MAXIMUM_CODE_SIZE > UINT16_MAX */
        3:  711:  page_p->bytes[offset++] = (uint8_t) (delta >> 16);
        3:  712:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  713:  {
    #####:  714:    page_p = page_p->next_p;
    #####:  715:    offset = 0;
        -:  716:  }
        3:  717:  page_p->bytes[offset++] = (uint8_t) ((delta >> 8) & 0xff);
        3:  718:  if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  719:  {
    #####:  720:    page_p = page_p->next_p;
    #####:  721:    offset = 0;
        -:  722:  }
        -:  723:#endif /* PARSER_MAXIMUM_CODE_SIZE <= UINT16_MAX */
        3:  724:  page_p->bytes[offset] = delta & 0xff;
        3:  725:} /* parser_set_branch_to_current_position */
        -:  726:
        -:  727:/**
        -:  728: * Set breaks to the current byte code position
        -:  729: */
        -:  730:void
        1:  731:parser_set_breaks_to_current_position (parser_context_t *context_p, /**< context */
        -:  732:                                       parser_branch_node_t *current_p) /**< branch list */
        -:  733:{
        2:  734:  while (current_p != NULL)
        -:  735:  {
    #####:  736:    parser_branch_node_t *next_p = current_p->next_p;
        -:  737:
    #####:  738:    if (!(current_p->branch.offset & CBC_HIGHEST_BIT_MASK))
        -:  739:    {
    #####:  740:      parser_set_branch_to_current_position (context_p, &current_p->branch);
        -:  741:    }
    #####:  742:    parser_free (current_p, sizeof (parser_branch_node_t));
    #####:  743:    current_p = next_p;
        -:  744:  }
        1:  745:} /* parser_set_breaks_to_current_position */
        -:  746:
        -:  747:/**
        -:  748: * Set continues to the current byte code position
        -:  749: */
        -:  750:void
        1:  751:parser_set_continues_to_current_position (parser_context_t *context_p, /**< context */
        -:  752:                                          parser_branch_node_t *current_p) /**< branch list */
        -:  753:{
        2:  754:  while (current_p != NULL)
        -:  755:  {
    #####:  756:    if (current_p->branch.offset & CBC_HIGHEST_BIT_MASK)
        -:  757:    {
    #####:  758:      parser_set_branch_to_current_position (context_p, &current_p->branch);
        -:  759:    }
    #####:  760:    current_p = current_p->next_p;
        -:  761:  }
        1:  762:} /* parser_set_continues_to_current_position */
        -:  763:
        -:  764:#if JERRY_ESNEXT
        -:  765:
        -:  766:/**
        -:  767: * Return the size of internal record corresponding to a class field
        -:  768: *
        -:  769: * @return internal record size
        -:  770: */
        -:  771:static size_t
    #####:  772:parser_get_class_field_info_size (uint8_t class_field_type) /**< class field type */
        -:  773:{
    #####:  774:  if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -:  775:  {
    #####:  776:    return sizeof (scanner_range_t) + 1;
        -:  777:  }
        -:  778:
    #####:  779:  if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -:  780:  {
    #####:  781:    return sizeof (scanner_location_t) + 1;
        -:  782:  }
        -:  783:
    #####:  784:  return 1;
        -:  785:} /* parser_get_class_field_info_size */
        -:  786:
        -:  787:/**
        -:  788: * Reverse the field list of a class
        -:  789: */
        -:  790:void
    #####:  791:parser_reverse_class_fields (parser_context_t *context_p, /**< context */
        -:  792:                             size_t fields_size) /**< size of consumed memory */
        -:  793:{
    #####:  794:  uint8_t *data_p = (uint8_t *) parser_malloc (context_p, fields_size);
    #####:  795:  uint8_t *data_end_p = data_p + fields_size;
    #####:  796:  uint8_t *current_p = data_p;
    #####:  797:  bool has_fields = false;
    #####:  798:  parser_stack_iterator_t iterator;
        -:  799:
    #####:  800:  JERRY_ASSERT (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -:  801:
    #####:  802:  parser_stack_iterator_init (context_p, &iterator);
        -:  803:
        -:  804:  do
        -:  805:  {
    #####:  806:    uint8_t class_field_type = parser_stack_iterator_read_uint8 (&iterator);
    #####:  807:    size_t info_size = parser_get_class_field_info_size (class_field_type);
        -:  808:
    #####:  809:    parser_stack_iterator_read (&iterator, current_p, info_size);
    #####:  810:    parser_stack_iterator_skip (&iterator, info_size);
    #####:  811:    current_p += info_size;
        -:  812:
    #####:  813:    if (!(class_field_type & PARSER_CLASS_FIELD_STATIC))
        -:  814:    {
    #####:  815:      has_fields = true;
    #####:  816:      context_p->stack_top_uint8 = class_field_type;
        -:  817:    }
        -:  818:  }
    #####:  819:  while (current_p < data_end_p);
        -:  820:
    #####:  821:  parser_stack_iterator_init (context_p, &iterator);
    #####:  822:  current_p = data_end_p;
        -:  823:
    #####:  824:  bool has_static_fields = false;
        -:  825:
    #####:  826:  if (has_fields)
        -:  827:  {
        -:  828:    do
        -:  829:    {
    #####:  830:      uint8_t class_field_type = current_p[-1];
        -:  831:
    #####:  832:      size_t info_size = parser_get_class_field_info_size (class_field_type);
        -:  833:
    #####:  834:      if (!(class_field_type & PARSER_CLASS_FIELD_STATIC))
        -:  835:      {
    #####:  836:        current_p -= info_size;
    #####:  837:        parser_stack_iterator_write (&iterator, current_p, info_size);
    #####:  838:        parser_stack_iterator_skip (&iterator, info_size);
    #####:  839:        continue;
        -:  840:      }
        -:  841:
    #####:  842:      if (!has_static_fields)
        -:  843:      {
    #####:  844:        has_static_fields = true;
    #####:  845:        current_p[-1] |= PARSER_CLASS_FIELD_END;
        -:  846:      }
    #####:  847:      current_p -= info_size;
        -:  848:    }
    #####:  849:    while (current_p > data_p);
        -:  850:  }
        -:  851:  else
        -:  852:  {
        -:  853:    /* All class fields are static. */
    #####:  854:    has_static_fields = true;
    #####:  855:    JERRY_ASSERT (data_end_p[-1] & PARSER_CLASS_FIELD_STATIC);
    #####:  856:    context_p->stack_top_uint8 = data_end_p[-1];
        -:  857:  }
        -:  858:
    #####:  859:  if (has_static_fields)
        -:  860:  {
    #####:  861:    current_p = data_end_p;
        -:  862:
        -:  863:    do
        -:  864:    {
    #####:  865:      uint8_t class_field_type = current_p[-1];
        -:  866:
    #####:  867:      size_t info_size = parser_get_class_field_info_size (class_field_type);
    #####:  868:      current_p -= info_size;
        -:  869:
    #####:  870:      if (class_field_type & PARSER_CLASS_FIELD_STATIC)
        -:  871:      {
    #####:  872:        parser_stack_iterator_write (&iterator, current_p, info_size);
    #####:  873:        parser_stack_iterator_skip (&iterator, info_size);
        -:  874:      }
        -:  875:    }
    #####:  876:    while (current_p > data_p);
        -:  877:  }
        -:  878:
    #####:  879:  parser_free (data_p, fields_size);
    #####:  880:} /* parser_reverse_class_fields */
        -:  881:
        -:  882:#endif /* JERRY_ESNEXT */
        -:  883:
        -:  884:#if JERRY_ERROR_MESSAGES
        -:  885:/**
        -:  886: * Returns with the string representation of the error
        -:  887: */
        -:  888:const char *
    #####:  889:parser_error_to_string (parser_error_t error) /**< error code */
        -:  890:{
    #####:  891:  switch (error)
        -:  892:  {
    #####:  893:    case PARSER_ERR_OUT_OF_MEMORY:
        -:  894:    {
    #####:  895:      return "Out of memory";
        -:  896:    }
    #####:  897:    case PARSER_ERR_LITERAL_LIMIT_REACHED:
        -:  898:    {
    #####:  899:      return "Maximum number of literals reached";
        -:  900:    }
    #####:  901:    case PARSER_ERR_SCOPE_STACK_LIMIT_REACHED:
        -:  902:    {
    #####:  903:      return "Maximum depth of scope stack reached";
        -:  904:    }
    #####:  905:    case PARSER_ERR_ARGUMENT_LIMIT_REACHED:
        -:  906:    {
    #####:  907:      return "Maximum number of function arguments reached";
        -:  908:    }
    #####:  909:    case PARSER_ERR_STACK_LIMIT_REACHED:
        -:  910:    {
    #####:  911:      return "Maximum function stack size reached";
        -:  912:    }
    #####:  913:    case PARSER_ERR_INVALID_CHARACTER:
        -:  914:    {
    #####:  915:      return "Invalid (unexpected) character";
        -:  916:    }
    #####:  917:    case PARSER_ERR_INVALID_OCTAL_DIGIT:
        -:  918:    {
    #####:  919:      return "Invalid octal digit";
        -:  920:    }
    #####:  921:    case PARSER_ERR_INVALID_HEX_DIGIT:
        -:  922:    {
    #####:  923:      return "Invalid hexadecimal digit";
        -:  924:    }
        -:  925:#if JERRY_ESNEXT
    #####:  926:    case PARSER_ERR_INVALID_BIN_DIGIT:
        -:  927:    {
    #####:  928:      return "Invalid binary digit";
        -:  929:    }
        -:  930:#endif /* JERRY_ESNEXT */
    #####:  931:    case PARSER_ERR_INVALID_ESCAPE_SEQUENCE:
        -:  932:    {
    #####:  933:      return "Invalid escape sequence";
        -:  934:    }
    #####:  935:    case PARSER_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE:
        -:  936:    {
    #####:  937:      return "Invalid unicode escape sequence";
        -:  938:    }
    #####:  939:    case PARSER_ERR_INVALID_IDENTIFIER_START:
        -:  940:    {
    #####:  941:      return "Character cannot be start of an identifier";
        -:  942:    }
    #####:  943:    case PARSER_ERR_INVALID_IDENTIFIER_PART:
        -:  944:    {
    #####:  945:      return "Character cannot be part of an identifier";
        -:  946:    }
    #####:  947:    case PARSER_ERR_INVALID_KEYWORD:
        -:  948:    {
    #####:  949:      return "Escape sequences are not allowed in keywords";
        -:  950:    }
    #####:  951:    case PARSER_ERR_INVALID_NUMBER:
        -:  952:    {
    #####:  953:      return "Invalid number";
        -:  954:    }
    #####:  955:    case PARSER_ERR_MISSING_EXPONENT:
        -:  956:    {
    #####:  957:      return "Missing exponent part";
        -:  958:    }
    #####:  959:    case PARSER_ERR_INVALID_UNDERSCORE_IN_NUMBER:
        -:  960:    {
    #####:  961:      return "Invalid use of underscore character in number literals";
        -:  962:    }
    #####:  963:    case PARSER_ERR_IDENTIFIER_AFTER_NUMBER:
        -:  964:    {
    #####:  965:      return "Identifier cannot start after a number";
        -:  966:    }
        -:  967:#if JERRY_BUILTIN_BIGINT
    #####:  968:    case PARSER_ERR_INVALID_BIGINT:
        -:  969:    {
    #####:  970:      return "Number is not a valid BigInt";
        -:  971:    }
        -:  972:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  973:    case PARSER_ERR_INVALID_REGEXP:
        -:  974:    {
    #####:  975:      return "Invalid regular expression";
        -:  976:    }
    #####:  977:    case PARSER_ERR_UNKNOWN_REGEXP_FLAG:
        -:  978:    {
    #####:  979:      return "Unknown regexp flag";
        -:  980:    }
    #####:  981:    case PARSER_ERR_DUPLICATED_REGEXP_FLAG:
        -:  982:    {
    #####:  983:      return "Duplicated regexp flag";
        -:  984:    }
    #####:  985:    case PARSER_ERR_UNSUPPORTED_REGEXP:
        -:  986:    {
    #####:  987:      return "Regexp is not supported in the selected profile";
        -:  988:    }
    #####:  989:    case PARSER_ERR_IDENTIFIER_TOO_LONG:
        -:  990:    {
    #####:  991:      return "Identifier is too long";
        -:  992:    }
    #####:  993:    case PARSER_ERR_STRING_TOO_LONG:
        -:  994:    {
    #####:  995:      return "String is too long";
        -:  996:    }
    #####:  997:    case PARSER_ERR_NUMBER_TOO_LONG:
        -:  998:    {
    #####:  999:      return "Number is too long";
        -: 1000:    }
    #####: 1001:    case PARSER_ERR_REGEXP_TOO_LONG:
        -: 1002:    {
    #####: 1003:      return "Regexp is too long";
        -: 1004:    }
    #####: 1005:    case PARSER_ERR_UNTERMINATED_MULTILINE_COMMENT:
        -: 1006:    {
    #####: 1007:      return "Unterminated multiline comment";
        -: 1008:    }
    #####: 1009:    case PARSER_ERR_UNTERMINATED_STRING:
        -: 1010:    {
    #####: 1011:      return "Unterminated string literal";
        -: 1012:    }
    #####: 1013:    case PARSER_ERR_UNTERMINATED_REGEXP:
        -: 1014:    {
    #####: 1015:      return "Unterminated regexp literal";
        -: 1016:    }
    #####: 1017:    case PARSER_ERR_NEWLINE_NOT_ALLOWED:
        -: 1018:    {
    #####: 1019:      return "Newline is not allowed in strings or regexps";
        -: 1020:    }
    #####: 1021:    case PARSER_ERR_OCTAL_NUMBER_NOT_ALLOWED:
        -: 1022:    {
    #####: 1023:      return "Octal numbers are not allowed in strict mode";
        -: 1024:    }
    #####: 1025:    case PARSER_ERR_OCTAL_ESCAPE_NOT_ALLOWED:
        -: 1026:    {
    #####: 1027:      return "Octal escape sequences are not allowed in strict mode";
        -: 1028:    }
        -: 1029:#if JERRY_ESNEXT
    #####: 1030:    case PARSER_ERR_TEMPLATE_STR_OCTAL_ESCAPE:
        -: 1031:    {
    #####: 1032:      return "Octal escape sequences are not allowed in template strings";
        -: 1033:    }
        -: 1034:#endif /* JERRY_ESNEXT */
    #####: 1035:    case PARSER_ERR_STRICT_IDENT_NOT_ALLOWED:
        -: 1036:    {
    #####: 1037:      return "Identifier name is reserved in strict mode";
        -: 1038:    }
    #####: 1039:    case PARSER_ERR_EVAL_NOT_ALLOWED:
        -: 1040:    {
    #####: 1041:      return "Eval is not allowed to be used here in strict mode";
        -: 1042:    }
    #####: 1043:    case PARSER_ERR_ARGUMENTS_NOT_ALLOWED:
        -: 1044:    {
    #####: 1045:      return "Arguments is not allowed to be used here in strict mode";
        -: 1046:    }
        -: 1047:#if JERRY_ESNEXT
    #####: 1048:    case PARSER_ERR_USE_STRICT_NOT_ALLOWED:
        -: 1049:    {
    #####: 1050:      return "The 'use strict' directive is not allowed for functions with non-simple arguments";
        -: 1051:    }
    #####: 1052:    case PARSER_ERR_YIELD_NOT_ALLOWED:
        -: 1053:    {
    #####: 1054:      return "Yield expression is not allowed here";
        -: 1055:    }
    #####: 1056:    case PARSER_ERR_AWAIT_NOT_ALLOWED:
        -: 1057:    {
    #####: 1058:      return "Await expression is not allowed here";
        -: 1059:    }
    #####: 1060:    case PARSER_ERR_FOR_IN_OF_DECLARATION:
        -: 1061:    {
    #####: 1062:      return "for in-of loop variable declaration may not have an initializer";
        -: 1063:    }
    #####: 1064:    case PARSER_ERR_FOR_AWAIT_NO_ASYNC:
        -: 1065:    {
    #####: 1066:      return "for-await-of is only allowed inside async functions and generators";
        -: 1067:    }
    #####: 1068:    case PARSER_ERR_FOR_AWAIT_NO_OF:
        -: 1069:    {
    #####: 1070:      return "only 'of' form is allowed for for-await loops";
        -: 1071:    }
    #####: 1072:    case PARSER_ERR_DUPLICATED_PROTO:
        -: 1073:    {
    #####: 1074:      return "Duplicate __proto__ fields are not allowed in object literals";
        -: 1075:    }
    #####: 1076:    case PARSER_ERR_INVALID_LHS_ASSIGNMENT:
        -: 1077:    {
    #####: 1078:      return "Invalid left-hand side in assignment";
        -: 1079:    }
    #####: 1080:    case PARSER_ERR_INVALID_LHS_POSTFIX_OP:
        -: 1081:    {
    #####: 1082:      return "Invalid left-hand side expression in postfix operation";
        -: 1083:    }
    #####: 1084:    case PARSER_ERR_INVALID_LHS_PREFIX_OP:
        -: 1085:    {
    #####: 1086:      return "Invalid left-hand side expression in prefix operation";
        -: 1087:    }
    #####: 1088:    case PARSER_ERR_INVALID_LHS_FOR_LOOP:
        -: 1089:    {
    #####: 1090:      return "Invalid left-hand-side in for-loop";
        -: 1091:    }
        -: 1092:#endif /* JERRY_ESNEXT */
    #####: 1093:    case PARSER_ERR_DELETE_IDENT_NOT_ALLOWED:
        -: 1094:    {
    #####: 1095:      return "Deleting identifier is not allowed in strict mode";
        -: 1096:    }
    #####: 1097:    case PARSER_ERR_EVAL_CANNOT_ASSIGNED:
        -: 1098:    {
    #####: 1099:      return "Eval cannot be assigned to in strict mode";
        -: 1100:    }
    #####: 1101:    case PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED:
        -: 1102:    {
    #####: 1103:      return "Arguments cannot be assigned to in strict mode";
        -: 1104:    }
    #####: 1105:    case PARSER_ERR_WITH_NOT_ALLOWED:
        -: 1106:    {
    #####: 1107:      return "With statement not allowed in strict mode";
        -: 1108:    }
    #####: 1109:    case PARSER_ERR_MULTIPLE_DEFAULTS_NOT_ALLOWED:
        -: 1110:    {
    #####: 1111:      return "Multiple default cases are not allowed";
        -: 1112:    }
    #####: 1113:    case PARSER_ERR_DEFAULT_NOT_IN_SWITCH:
        -: 1114:    {
    #####: 1115:      return "Default statement must be in a switch block";
        -: 1116:    }
    #####: 1117:    case PARSER_ERR_CASE_NOT_IN_SWITCH:
        -: 1118:    {
    #####: 1119:      return "Case statement must be in a switch block";
        -: 1120:    }
    #####: 1121:    case PARSER_ERR_LEFT_PAREN_EXPECTED:
        -: 1122:    {
    #####: 1123:      return "Expected '(' token";
        -: 1124:    }
    #####: 1125:    case PARSER_ERR_LEFT_BRACE_EXPECTED:
        -: 1126:    {
    #####: 1127:      return "Expected '{' token";
        -: 1128:    }
    #####: 1129:    case PARSER_ERR_RIGHT_PAREN_EXPECTED:
        -: 1130:    {
    #####: 1131:      return "Expected ')' token";
        -: 1132:    }
    #####: 1133:    case PARSER_ERR_RIGHT_SQUARE_EXPECTED:
        -: 1134:    {
    #####: 1135:      return "Expected ']' token";
        -: 1136:    }
    #####: 1137:    case PARSER_ERR_COLON_EXPECTED:
        -: 1138:    {
    #####: 1139:      return "Expected ':' token";
        -: 1140:    }
    #####: 1141:    case PARSER_ERR_COLON_FOR_CONDITIONAL_EXPECTED:
        -: 1142:    {
    #####: 1143:      return "Expected ':' token for ?: conditional expression";
        -: 1144:    }
    #####: 1145:    case PARSER_ERR_SEMICOLON_EXPECTED:
        -: 1146:    {
    #####: 1147:      return "Expected ';' token";
        -: 1148:    }
    #####: 1149:    case PARSER_ERR_IN_EXPECTED:
        -: 1150:    {
    #####: 1151:      return "Expected 'in' token";
        -: 1152:    }
    #####: 1153:    case PARSER_ERR_WHILE_EXPECTED:
        -: 1154:    {
    #####: 1155:      return "While expected for do-while loop";
        -: 1156:    }
    #####: 1157:    case PARSER_ERR_CATCH_FINALLY_EXPECTED:
        -: 1158:    {
    #####: 1159:      return "Catch or finally block expected";
        -: 1160:    }
    #####: 1161:    case PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED:
        -: 1162:    {
    #####: 1163:      return "Expected ',' or ']' after an array item";
        -: 1164:    }
    #####: 1165:    case PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED:
        -: 1166:    {
    #####: 1167:      return "Expected ',' or '}' after a property definition";
        -: 1168:    }
    #####: 1169:    case PARSER_ERR_IDENTIFIER_EXPECTED:
        -: 1170:    {
    #####: 1171:      return "Identifier expected";
        -: 1172:    }
    #####: 1173:    case PARSER_ERR_EXPRESSION_EXPECTED:
        -: 1174:    {
    #####: 1175:      return "Expression expected";
        -: 1176:    }
    #####: 1177:    case PARSER_ERR_UNEXPECTED_END:
        -: 1178:    {
    #####: 1179:      return "Unexpected end of input";
        -: 1180:    }
    #####: 1181:    case PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED:
        -: 1182:    {
    #####: 1183:      return "Left-hand-side expression expected";
        -: 1184:    }
    #####: 1185:    case PARSER_ERR_STATEMENT_EXPECTED:
        -: 1186:    {
    #####: 1187:      return "Statement expected";
        -: 1188:    }
    #####: 1189:    case PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED:
        -: 1190:    {
    #####: 1191:      return "Property identifier expected";
        -: 1192:    }
    #####: 1193:    case PARSER_ERR_ARGUMENT_LIST_EXPECTED:
        -: 1194:    {
    #####: 1195:      return "Expected argument list";
        -: 1196:    }
    #####: 1197:    case PARSER_ERR_NO_ARGUMENTS_EXPECTED:
        -: 1198:    {
    #####: 1199:      return "Property getters must have no arguments";
        -: 1200:    }
    #####: 1201:    case PARSER_ERR_ONE_ARGUMENT_EXPECTED:
        -: 1202:    {
    #####: 1203:      return "Property setters must have one argument";
        -: 1204:    }
    #####: 1205:    case PARSER_ERR_INVALID_EXPRESSION:
        -: 1206:    {
    #####: 1207:      return "Invalid expression";
        -: 1208:    }
    #####: 1209:    case PARSER_ERR_INVALID_SWITCH:
        -: 1210:    {
    #####: 1211:      return "Invalid switch body";
        -: 1212:    }
    #####: 1213:    case PARSER_ERR_INVALID_BREAK:
        -: 1214:    {
    #####: 1215:      return "Break statement must be inside a loop or switch";
        -: 1216:    }
    #####: 1217:    case PARSER_ERR_INVALID_BREAK_LABEL:
        -: 1218:    {
    #####: 1219:      return "Labeled statement targeted by a break not found";
        -: 1220:    }
    #####: 1221:    case PARSER_ERR_INVALID_CONTINUE:
        -: 1222:    {
    #####: 1223:      return "Continue statement must be inside a loop";
        -: 1224:    }
    #####: 1225:    case PARSER_ERR_INVALID_CONTINUE_LABEL:
        -: 1226:    {
    #####: 1227:      return "Labeled statement targeted by a continue not found";
        -: 1228:    }
    #####: 1229:    case PARSER_ERR_INVALID_RETURN:
        -: 1230:    {
    #####: 1231:      return "Return statement must be inside a function body";
        -: 1232:    }
    #####: 1233:    case PARSER_ERR_INVALID_RIGHT_SQUARE:
        -: 1234:    {
    #####: 1235:      return "Unexpected '}' token";
        -: 1236:    }
    #####: 1237:    case PARSER_ERR_DUPLICATED_LABEL:
        -: 1238:    {
    #####: 1239:      return "Duplicated label";
        -: 1240:    }
    #####: 1241:    case PARSER_ERR_OBJECT_PROPERTY_REDEFINED:
        -: 1242:    {
    #####: 1243:      return "Property of object literal redefined";
        -: 1244:    }
    #####: 1245:    case PARSER_ERR_NON_STRICT_ARG_DEFINITION:
        -: 1246:    {
    #####: 1247:      return "Non-strict argument definition";
        -: 1248:    }
        -: 1249:#if JERRY_ESNEXT
    #####: 1250:    case PARSER_ERR_VARIABLE_REDECLARED:
        -: 1251:    {
    #####: 1252:      return ecma_error_local_variable_is_redeclared;
        -: 1253:    }
    #####: 1254:    case PARSER_ERR_LEXICAL_SINGLE_STATEMENT:
        -: 1255:    {
    #####: 1256:      return "Lexical declaration cannot appear in a single-statement context";
        -: 1257:    }
    #####: 1258:    case PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK:
        -: 1259:    {
    #####: 1260:      return "Labelled functions are only allowed inside blocks";
        -: 1261:    }
    #####: 1262:    case PARSER_ERR_LEXICAL_LET_BINDING:
        -: 1263:    {
    #####: 1264:      return "Let binding cannot appear in let/const declarations";
        -: 1265:    }
    #####: 1266:    case PARSER_ERR_MISSING_ASSIGN_AFTER_CONST:
        -: 1267:    {
    #####: 1268:      return "Value assignment is expected after a const declaration";
        -: 1269:    }
    #####: 1270:    case PARSER_ERR_MULTIPLE_CLASS_CONSTRUCTORS:
        -: 1271:    {
    #####: 1272:      return "Multiple constructors are not allowed";
        -: 1273:    }
    #####: 1274:    case PARSER_ERR_CLASS_CONSTRUCTOR_AS_ACCESSOR:
        -: 1275:    {
    #####: 1276:      return "Class constructor may not be an accessor";
        -: 1277:    }
    #####: 1278:    case PARSER_ERR_INVALID_CLASS_CONSTRUCTOR:
        -: 1279:    {
    #####: 1280:      return "Class constructor may not be a generator or async function";
        -: 1281:    }
    #####: 1282:    case PARSER_ERR_CLASS_STATIC_PROTOTYPE:
        -: 1283:    {
    #####: 1284:      return "Classes may not have a static property called 'prototype'";
        -: 1285:    }
    #####: 1286:    case PARSER_ERR_UNEXPECTED_SUPER_KEYWORD:
        -: 1287:    {
    #####: 1288:      return "Super is not allowed to be used here";
        -: 1289:    }
    #####: 1290:    case PARSER_ERR_TOO_MANY_CLASS_FIELDS:
        -: 1291:    {
    #####: 1292:      return "Too many computed class fields are declared";
        -: 1293:    }
    #####: 1294:    case PARSER_ERR_ARGUMENTS_IN_CLASS_FIELD:
        -: 1295:    {
    #####: 1296:      return "In class field declarations 'arguments' is not allowed";
        -: 1297:    }
    #####: 1298:    case PARSER_ERR_RIGHT_BRACE_EXPECTED:
        -: 1299:    {
    #####: 1300:      return "Expected '}' token";
        -: 1301:    }
    #####: 1302:    case PARSER_ERR_OF_EXPECTED:
        -: 1303:    {
    #####: 1304:      return "Expected 'of' token";
        -: 1305:    }
    #####: 1306:    case PARSER_ERR_ASSIGNMENT_EXPECTED:
        -: 1307:    {
    #####: 1308:      return "Unexpected arrow function or yield expression (parentheses around the expression may help)";
        -: 1309:    }
    #####: 1310:    case PARSER_ERR_DUPLICATED_ARGUMENT_NAMES:
        -: 1311:    {
    #####: 1312:      return "Duplicated function argument names are not allowed here";
        -: 1313:    }
    #####: 1314:    case PARSER_ERR_INVALID_DESTRUCTURING_PATTERN:
        -: 1315:    {
    #####: 1316:      return "Invalid destructuring assignment target";
        -: 1317:    }
    #####: 1318:    case PARSER_ERR_ILLEGAL_PROPERTY_IN_DECLARATION:
        -: 1319:    {
    #####: 1320:      return "Illegal property in declaration context";
        -: 1321:    }
    #####: 1322:    case PARSER_ERR_INVALID_EXPONENTIATION:
        -: 1323:    {
    #####: 1324:      return "Left operand of ** operator cannot be unary expression";
        -: 1325:    }
    #####: 1326:    case PARSER_ERR_INVALID_NULLISH_COALESCING:
        -: 1327:    {
    #####: 1328:      return "Cannot chain nullish with logical AND or OR";
        -: 1329:    }
    #####: 1330:    case PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER:
        -: 1331:    {
    #####: 1332:      return "Rest parameter must be the last formal parameter";
        -: 1333:    }
    #####: 1334:    case PARSER_ERR_SETTER_REST_PARAMETER:
        -: 1335:    {
    #####: 1336:      return "Setter function argument must not be a rest parameter";
        -: 1337:    }
    #####: 1338:    case PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER:
        -: 1339:    {
    #####: 1340:      return "Rest parameter may not have a default initializer";
        -: 1341:    }
    #####: 1342:    case PARSER_ERR_NEW_TARGET_EXPECTED:
        -: 1343:    {
    #####: 1344:      return "Expected new.target expression";
        -: 1345:    }
    #####: 1346:    case PARSER_ERR_NEW_TARGET_NOT_ALLOWED:
        -: 1347:    {
    #####: 1348:      return "new.target expression is not allowed here";
        -: 1349:    }
        -: 1350:#endif /* JERRY_ESNEXT */
        -: 1351:#if JERRY_MODULE_SYSTEM
    #####: 1352:    case PARSER_ERR_FILE_NOT_FOUND:
        -: 1353:    {
    #####: 1354:      return "Requested module not found";
        -: 1355:    }
    #####: 1356:    case PARSER_ERR_FROM_EXPECTED:
        -: 1357:    {
    #####: 1358:      return "Expected 'from' token";
        -: 1359:    }
    #####: 1360:    case PARSER_ERR_FROM_COMMA_EXPECTED:
        -: 1361:    {
    #####: 1362:      return "Expected 'from' or ',' token";
        -: 1363:    }
    #####: 1364:    case PARSER_ERR_AS_EXPECTED:
        -: 1365:    {
    #####: 1366:      return "Expected 'as' token";
        -: 1367:    }
    #####: 1368:    case PARSER_ERR_STRING_EXPECTED:
        -: 1369:    {
    #####: 1370:      return "Expected a string literal";
        -: 1371:    }
    #####: 1372:    case PARSER_ERR_MODULE_UNEXPECTED:
        -: 1373:    {
    #####: 1374:      return "Unexpected import or export statement";
        -: 1375:    }
    #####: 1376:    case PARSER_ERR_LEFT_BRACE_MULTIPLY_EXPECTED:
        -: 1377:    {
    #####: 1378:      return "Expected '{' or '*' token";
        -: 1379:    }
    #####: 1380:    case PARSER_ERR_LEFT_BRACE_MULTIPLY_LITERAL_EXPECTED:
        -: 1381:    {
    #####: 1382:      return "Expected '{' or '*' or literal token";
        -: 1383:    }
    #####: 1384:    case PARSER_ERR_RIGHT_BRACE_COMMA_EXPECTED:
        -: 1385:    {
    #####: 1386:      return "Expected '}' or ',' token";
        -: 1387:    }
    #####: 1388:    case PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER:
        -: 1389:    {
    #####: 1390:      return "Duplicate exported identifier";
        -: 1391:    }
    #####: 1392:    case PARSER_ERR_DUPLICATED_IMPORT_BINDING:
        -: 1393:    {
    #####: 1394:      return "Duplicated imported binding name";
        -: 1395:    }
    #####: 1396:    case PARSER_ERR_EXPORT_NOT_DEFINED:
        -: 1397:    {
    #####: 1398:      return "Export not defined in module";
        -: 1399:    }
    #####: 1400:    case PARSER_ERR_IMPORT_AFTER_NEW:
        -: 1401:    {
    #####: 1402:      return "Module import call is not allowed after new";
        -: 1403:    }
    #####: 1404:    case PARSER_ERR_META_EXPECTED:
        -: 1405:    {
    #####: 1406:      return "Expected 'meta' keyword";
        -: 1407:    }
    #####: 1408:    case PARSER_ERR_IMPORT_META_REQUIRE_MODULE:
        -: 1409:    {
    #####: 1410:      return "Cannot use 'import.meta' outside a module";
        -: 1411:    }
        -: 1412:#endif /* JERRY_MODULE_SYSTEM */
    #####: 1413:    default:
        -: 1414:    {
    #####: 1415:      JERRY_ASSERT (error == PARSER_ERR_NO_ERROR);
    #####: 1416:      return "No error";
        -: 1417:    }
        -: 1418:  }
        -: 1419:} /* parser_error_to_string */
        -: 1420:#endif /* JERRY_ERROR_MESSAGES */
        -: 1421:
        -: 1422:/**
        -: 1423: * @}
        -: 1424: * @}
        -: 1425: * @}
        -: 1426: */
        -: 1427:
        -: 1428:#endif /* JERRY_PARSER */
