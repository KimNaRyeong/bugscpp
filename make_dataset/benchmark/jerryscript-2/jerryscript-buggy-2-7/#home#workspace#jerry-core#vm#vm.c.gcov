        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-builtin-object.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-exceptions.h"
        -:   27:#include "ecma-function-object.h"
        -:   28:#include "ecma-gc.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-lcache.h"
        -:   32:#include "ecma-lex-env.h"
        -:   33:#include "ecma-objects.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-promise-object.h"
        -:   36:#include "ecma-regexp-object.h"
        -:   37:#include "jcontext.h"
        -:   38:#include "opcodes.h"
        -:   39:#include "vm.h"
        -:   40:#include "vm-stack.h"
        -:   41:
        -:   42:/** \addtogroup vm Virtual machine
        -:   43: * @{
        -:   44: *
        -:   45: * \addtogroup vm_executor Executor
        -:   46: * @{
        -:   47: */
        -:   48:
        -:   49:JERRY_STATIC_ASSERT ((sizeof (vm_frame_ctx_t) % sizeof (ecma_value_t)) == 0,
        -:   50:                     sizeof_vm_frame_ctx_must_be_sizeof_ecma_value_t_aligned);
        -:   51:
        -:   52:/**
        -:   53: * Get the value of object[property].
        -:   54: *
        -:   55: * @return ecma value
        -:   56: */
        -:   57:static ecma_value_t
        2:   58:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   59:                 ecma_value_t property) /**< property name */
        -:   60:{
        2:   61:  if (ecma_is_value_object (object))
        -:   62:  {
        2:   63:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        2:   64:    ecma_string_t *property_name_p = NULL;
        -:   65:
        2:   66:    if (ecma_is_value_integer_number (property))
        -:   67:    {
    #####:   68:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   69:
    #####:   70:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   71:      {
    #####:   72:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   73:        {
    #####:   74:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   75:
    #####:   76:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   77:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   78:          {
    #####:   79:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   80:
    #####:   81:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   82:            {
    #####:   83:              return ecma_fast_copy_value (values_p[int_value]);
        -:   84:            }
        -:   85:          }
        -:   86:        }
        -:   87:
    #####:   88:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,
        -:   89:                                                                       (uintptr_t) int_value);
        -:   90:      }
        -:   91:    }
        2:   92:    else if (ecma_is_value_string (property))
        -:   93:    {
        2:   94:      property_name_p = ecma_get_string_from_value (property);
        -:   95:    }
        -:   96:
        -:   97:#if JERRY_ESNEXT
        2:   98:    if (ecma_is_value_symbol (property))
        -:   99:    {
    #####:  100:      property_name_p = ecma_get_symbol_from_value (property);
        -:  101:    }
        -:  102:#endif /* JERRY_ESNEXT */
        -:  103:
        2:  104:    if (property_name_p != NULL)
        -:  105:    {
        -:  106:#if JERRY_LCACHE
        2:  107:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  108:
        2:  109:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  110:      {
    #####:  111:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  112:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  113:      }
        -:  114:#endif /* JERRY_LCACHE */
        -:  115:
        -:  116:      /* There is no need to free the name. */
        2:  117:      return ecma_op_object_get (object_p, property_name_p);
        -:  118:    }
        -:  119:  }
        -:  120:
    #####:  121:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  122:  {
        -:  123:#if JERRY_ERROR_MESSAGES
    #####:  124:    ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  125:                                                                      "Cannot read property '%' of %",
        -:  126:                                                                      property,
        -:  127:                                                                      object);
        -:  128:#else /* !JERRY_ERROR_MESSAGES */
        -:  129:    ecma_value_t error_value = ecma_raise_type_error (NULL);
        -:  130:#endif /* JERRY_ERROR_MESSAGES */
    #####:  131:    return error_value;
        -:  132:  }
        -:  133:
    #####:  134:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  135:
    #####:  136:  if (property_name_p == NULL)
        -:  137:  {
    #####:  138:    return ECMA_VALUE_ERROR;
        -:  139:  }
        -:  140:
    #####:  141:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  142:
    #####:  143:  ecma_deref_ecma_string (property_name_p);
    #####:  144:  return get_value_result;
        -:  145:} /* vm_op_get_value */
        -:  146:
        -:  147:/**
        -:  148: * Set the value of object[property].
        -:  149: *
        -:  150: * Note:
        -:  151: *  this function frees its object and property arguments
        -:  152: *
        -:  153: * @return an ecma value which contains an error
        -:  154: *         if the property setting is unsuccessful
        -:  155: */
        -:  156:static ecma_value_t
    #####:  157:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  158:                 ecma_value_t property, /**< property name */
        -:  159:                 ecma_value_t value, /**< ecma value */
        -:  160:                 bool is_strict) /**< strict mode */
        -:  161:{
    #####:  162:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  163:  ecma_object_t *object_p;
        -:  164:  ecma_string_t *property_p;
        -:  165:
    #####:  166:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  167:  {
    #####:  168:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  169:    {
        -:  170:#if JERRY_ERROR_MESSAGES
    #####:  171:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  172:                                                      "Cannot set property '%' of %",
        -:  173:                                                      property,
        -:  174:                                                      base);
        -:  175:#else /* !JERRY_ERROR_MESSAGES */
        -:  176:      result = ecma_raise_type_error (NULL);
        -:  177:#endif /* JERRY_ERROR_MESSAGES */
    #####:  178:      ecma_free_value (property);
    #####:  179:      return result;
        -:  180:    }
        -:  181:
    #####:  182:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  183:    {
    #####:  184:      property_p = ecma_op_to_string (property);
    #####:  185:      ecma_fast_free_value (property);
        -:  186:
    #####:  187:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  188:      {
    #####:  189:        ecma_free_value (base);
    #####:  190:        return ECMA_VALUE_ERROR;
        -:  191:      }
        -:  192:    }
        -:  193:    else
        -:  194:    {
    #####:  195:      property_p = ecma_get_prop_name_from_value (property);
        -:  196:    }
        -:  197:
    #####:  198:    ecma_value_t object = ecma_op_to_object (base);
    #####:  199:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  200:
    #####:  201:    object_p = ecma_get_object_from_value (object);
    #####:  202:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  203:
    #####:  204:    result = ecma_op_object_put_with_receiver (object_p,
        -:  205:                                               property_p,
        -:  206:                                               value,
        -:  207:                                               base,
        -:  208:                                               is_strict);
        -:  209:
    #####:  210:    ecma_free_value (base);
        -:  211:  }
        -:  212:  else
        -:  213:  {
    #####:  214:    object_p = ecma_get_object_from_value (base);
        -:  215:
    #####:  216:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  217:    {
    #####:  218:      property_p = ecma_op_to_string (property);
    #####:  219:      ecma_fast_free_value (property);
        -:  220:
    #####:  221:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  222:      {
    #####:  223:        ecma_deref_object (object_p);
    #####:  224:        return ECMA_VALUE_ERROR;
        -:  225:      }
        -:  226:    }
        -:  227:    else
        -:  228:    {
    #####:  229:      property_p = ecma_get_prop_name_from_value (property);
        -:  230:    }
        -:  231:
    #####:  232:    if (!ecma_is_lexical_environment (object_p))
        -:  233:    {
    #####:  234:      result = ecma_op_object_put_with_receiver (object_p,
        -:  235:                                                 property_p,
        -:  236:                                                 value,
        -:  237:                                                 base,
        -:  238:                                                 is_strict);
        -:  239:    }
        -:  240:    else
        -:  241:    {
    #####:  242:      result = ecma_op_set_mutable_binding (object_p,
        -:  243:                                            property_p,
        -:  244:                                            value,
        -:  245:                                            is_strict);
        -:  246:    }
        -:  247:  }
        -:  248:
    #####:  249:  ecma_deref_object (object_p);
    #####:  250:  ecma_deref_ecma_string (property_p);
    #####:  251:  return result;
        -:  252:} /* vm_op_set_value */
        -:  253:
        -:  254:/** Compact bytecode define */
        -:  255:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  256:
        -:  257:/**
        -:  258: * Decode table for both opcodes and extended opcodes.
        -:  259: */
        -:  260:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA =
        -:  261:{
        -:  262:  CBC_OPCODE_LIST
        -:  263:  CBC_EXT_OPCODE_LIST
        -:  264:};
        -:  265:
        -:  266:#undef CBC_OPCODE
        -:  267:
        -:  268:/**
        -:  269: * Run global code
        -:  270: *
        -:  271: * Note:
        -:  272: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  273: *
        -:  274: * @return ecma value
        -:  275: */
        -:  276:ecma_value_t
        1:  277:vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  278:               ecma_object_t *function_object_p) /**< function object if available */
        -:  279:{
        -:  280:#if JERRY_BUILTIN_REALMS
        1:  281:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  282:#else /* !JERRY_BUILTIN_REALMS */
    #####:  283:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  284:#endif /* JERRY_BUILTIN_REALMS */
        -:  285:
        -:  286:#if JERRY_ESNEXT
        1:  287:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  288:  {
    #####:  289:    ecma_create_global_lexical_block (global_obj_p);
        -:  290:  }
        -:  291:#endif /* JERRY_ESNEXT */
        -:  292:
        1:  293:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  294:
        1:  295:  vm_frame_ctx_shared_t shared;
        1:  296:  shared.bytecode_header_p = bytecode_p;
        1:  297:  shared.function_object_p = function_object_p;
        1:  298:  shared.status_flags = 0;
        -:  299:
        -:  300:#if JERRY_BUILTIN_REALMS
        1:  301:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  302:
        1:  303:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  304:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  305:#else /* !JERRY_BUILTIN_REALMS */
    #####:  306:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  307:#endif /* JERRY_BUILTIN_REALMS */
        -:  308:
        1:  309:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  310:
        -:  311:#if JERRY_BUILTIN_REALMS
    #####:  312:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  313:#endif /* JERRY_BUILTIN_REALMS */
        -:  314:
    #####:  315:  return result;
        -:  316:} /* vm_run_global */
        -:  317:
        -:  318:/**
        -:  319: * Run specified eval-mode bytecode
        -:  320: *
        -:  321: * @return ecma value
        -:  322: */
        -:  323:ecma_value_t
    #####:  324:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  325:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  326:{
        -:  327:  ecma_value_t this_binding;
        -:  328:  ecma_object_t *lex_env_p;
        -:  329:
        -:  330:  /* ECMA-262 v5, 10.4.2 */
    #####:  331:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  332:  {
    #####:  333:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  334:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  335:
        -:  336:#if JERRY_DEBUGGER
        -:  337:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  338:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  339:
        -:  340:    while (chain_index != 0)
        -:  341:    {
        -:  342:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  343:      {
        -:  344:        ecma_bytecode_deref (bytecode_data_p);
        -:  345:        ecma_free_value (this_binding);
        -:  346:        return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid scope chain index for eval"));
        -:  347:      }
        -:  348:
        -:  349:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  350:
        -:  351:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  352:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  353:      {
        -:  354:        chain_index--;
        -:  355:      }
        -:  356:    }
        -:  357:#endif /* JERRY_DEBUGGER */
        -:  358:  }
        -:  359:  else
        -:  360:  {
        -:  361:#if JERRY_BUILTIN_REALMS
    #####:  362:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  363:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  364:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  365:#else /* !JERRY_BUILTIN_REALMS */
    #####:  366:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  367:    ecma_ref_object (global_obj_p);
    #####:  368:    this_binding = ecma_make_object_value (global_obj_p);
        -:  369:#endif /* JERRY_BUILTIN_REALMS */
    #####:  370:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  371:  }
        -:  372:
    #####:  373:  ecma_ref_object (lex_env_p);
        -:  374:
    #####:  375:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  376:  {
    #####:  377:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  378:
    #####:  379:    ecma_deref_object (lex_env_p);
    #####:  380:    lex_env_p = strict_lex_env_p;
        -:  381:  }
        -:  382:
    #####:  383:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  384:  {
    #####:  385:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  386:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  387:
    #####:  388:    ecma_deref_object (lex_env_p);
    #####:  389:    lex_env_p = lex_block_p;
        -:  390:  }
        -:  391:
    #####:  392:  vm_frame_ctx_shared_t shared;
    #####:  393:  shared.bytecode_header_p = bytecode_data_p;
    #####:  394:  shared.function_object_p = NULL;
    #####:  395:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  396:
    #####:  397:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  398:
    #####:  399:  ecma_deref_object (lex_env_p);
    #####:  400:  ecma_free_value (this_binding);
        -:  401:
        -:  402:#if JERRY_SNAPSHOT_EXEC
    #####:  403:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  404:  {
    #####:  405:    ecma_bytecode_deref (bytecode_data_p);
        -:  406:  }
        -:  407:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  408:  ecma_bytecode_deref (bytecode_data_p);
        -:  409:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  410:
    #####:  411:  return completion_value;
        -:  412:} /* vm_run_eval */
        -:  413:
        -:  414:#if JERRY_MODULE_SYSTEM
        -:  415:
        -:  416:/**
        -:  417: * Run module code
        -:  418: *
        -:  419: * Note:
        -:  420: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  421: *
        -:  422: * @return ecma value
        -:  423: */
        -:  424:ecma_value_t
    #####:  425:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  426:{
    #####:  427:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  428:
    #####:  429:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  430:  {
    #####:  431:    return module_init_result;
        -:  432:  }
        -:  433:
    #####:  434:  vm_frame_ctx_shared_t shared;
    #####:  435:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  436:  shared.function_object_p = &module_p->header.object;
    #####:  437:  shared.status_flags = 0;
        -:  438:
    #####:  439:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  440:} /* vm_run_module */
        -:  441:
        -:  442:#endif /* JERRY_MODULE_SYSTEM */
        -:  443:
        -:  444:/**
        -:  445: * Construct object
        -:  446: *
        -:  447: * @return object value
        -:  448: */
        -:  449:static ecma_value_t
        2:  450:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  451:                             ecma_value_t lit_value) /**< literal */
        -:  452:{
        -:  453:  ecma_compiled_code_t *bytecode_p;
        -:  454:
        -:  455:#if JERRY_SNAPSHOT_EXEC
    #####:  456:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  457:  {
        -:  458:#endif /* JERRY_SNAPSHOT_EXEC */
        2:  459:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  460:                                                  lit_value);
        -:  461:#if JERRY_SNAPSHOT_EXEC
        -:  462:  }
        -:  463:  else
        -:  464:  {
    #####:  465:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  466:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  467:  }
        -:  468:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  469:
        -:  470:#if JERRY_BUILTIN_REGEXP
        2:  471:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  472:  {
    #####:  473:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  474:
    #####:  475:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  476:    {
    #####:  477:      return ECMA_VALUE_ERROR;
        -:  478:    }
        -:  479:
    #####:  480:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  481:  }
        -:  482:#else /* !JERRY_BUILTIN_REGEXP */
        -:  483:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  484:#endif /* JERRY_BUILTIN_REGEXP */
        -:  485:
        -:  486:  ecma_object_t *func_obj_p;
        -:  487:
        -:  488:#if JERRY_ESNEXT
        2:  489:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  490:  {
    #####:  491:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,
        -:  492:                                                       bytecode_p,
        -:  493:                                                       frame_ctx_p->this_binding);
        -:  494:  }
        -:  495:  else
        -:  496:  {
        2:  497:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  498:  }
        -:  499:#else /* !JERRY_ESNEXT */
    #####:  500:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  501:#endif /* JERRY_ESNEXT */
        -:  502:
        2:  503:  return ecma_make_object_value (func_obj_p);
        -:  504:} /* vm_construct_literal_object */
        -:  505:
        -:  506:/**
        -:  507: * Get implicit this value
        -:  508: *
        -:  509: * @return true - if the implicit 'this' value is updated,
        -:  510: *         false - otherwise
        -:  511: */
        -:  512:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  513:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  514:{
    #####:  515:  if (ecma_is_value_object (*this_value_p))
        -:  516:  {
    #####:  517:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  518:
    #####:  519:    if (ecma_is_lexical_environment (this_obj_p))
        -:  520:    {
    #####:  521:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  522:
    #####:  523:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  524:
    #####:  525:      *this_value_p = completion_value;
    #####:  526:      return true;
        -:  527:    }
        -:  528:  }
    #####:  529:  return false;
        -:  530:} /* vm_get_implicit_this_value */
        -:  531:
        -:  532:/**
        -:  533: * Special bytecode sequence for error handling while the vm_loop
        -:  534: * is preserved for an execute operation
        -:  535: */
        -:  536:static const uint8_t vm_error_byte_code_p[] =
        -:  537:{
        -:  538:  CBC_EXT_OPCODE, CBC_EXT_ERROR
        -:  539:};
        -:  540:
        -:  541:#if JERRY_ESNEXT
        -:  542:
        -:  543:static ecma_object_t *
    #####:  544:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  545:{
    #####:  546:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  547:
    #####:  548:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  549:  {
    #####:  550:    return frame_ctx_p->shared_p->function_object_p;
        -:  551:  }
        -:  552:
    #####:  553:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  554:
    #####:  555:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  556:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  557:} /* vm_get_class_function */
        -:  558:
        -:  559:/**
        -:  560: * 'super(...)' function call handler.
        -:  561: */
        -:  562:static void
    #####:  563:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  564:{
    #####:  565:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  566:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  567:
    #####:  568:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  569:  uint8_t opcode = byte_code_p[-2];
        -:  570:  uint32_t arguments_list_len;
        -:  571:
    #####:  572:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  573:
    #####:  574:  ecma_collection_t *collection_p = NULL;
        -:  575:  ecma_value_t *arguments_p;
        -:  576:
    #####:  577:  if (spread_arguments)
        -:  578:  {
    #####:  579:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  580:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  581:    arguments_p = collection_p->buffer_p;
    #####:  582:    arguments_list_len = collection_p->item_count;
        -:  583:  }
        -:  584:  else
        -:  585:  {
    #####:  586:    arguments_list_len = byte_code_p[-1];
    #####:  587:    arguments_p = frame_ctx_p->stack_top_p;
        -:  588:  }
        -:  589:
    #####:  590:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  591:  ecma_value_t completion_value;
        -:  592:
    #####:  593:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  594:
    #####:  595:  if (!ecma_is_constructor (func_value))
        -:  596:  {
    #####:  597:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Value for class heritage is not a constructor"));
        -:  598:  }
        -:  599:  else
        -:  600:  {
    #####:  601:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  602:    completion_value = ecma_op_function_construct (func_obj_p,
        -:  603:                                                   JERRY_CONTEXT (current_new_target_p),
        -:  604:                                                   arguments_p,
        -:  605:                                                   arguments_list_len);
        -:  606:
    #####:  607:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  608:    {
    #####:  609:      ecma_free_value (completion_value);
    #####:  610:      completion_value = ecma_raise_reference_error (ECMA_ERR_MSG ("Super constructor may only be called once"));
        -:  611:    }
        -:  612:  }
        -:  613:
        -:  614:  /* Free registers. */
    #####:  615:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  616:  {
    #####:  617:    ecma_fast_free_value (arguments_p[i]);
        -:  618:  }
        -:  619:
    #####:  620:  if (collection_p != NULL)
        -:  621:  {
    #####:  622:    ecma_collection_destroy (collection_p);
        -:  623:  }
        -:  624:
    #####:  625:  if (ecma_is_value_object (completion_value))
        -:  626:  {
    #####:  627:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  628:
    #####:  629:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  630:    {
    #####:  631:      ecma_free_value (completion_value);
    #####:  632:      completion_value = ECMA_VALUE_ERROR;
        -:  633:    }
        -:  634:  }
        -:  635:
    #####:  636:  ecma_free_value (func_value);
        -:  637:
    #####:  638:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  639:  {
        -:  640:#if JERRY_DEBUGGER
        -:  641:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  642:#endif /* JERRY_DEBUGGER */
    #####:  643:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  644:  }
        -:  645:  else
        -:  646:  {
    #####:  647:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  648:    frame_ctx_p->this_binding = completion_value;
        -:  649:
    #####:  650:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  651:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  652:
    #####:  653:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  654:    {
    #####:  655:      ecma_fast_free_value (completion_value);
        -:  656:    }
    #####:  657:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  658:    {
    #####:  659:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  660:    }
        -:  661:    else
        -:  662:    {
    #####:  663:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  664:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  665:    }
        -:  666:  }
    #####:  667:} /* vm_super_call */
        -:  668:
        -:  669:/**
        -:  670: * Perform one of the following call/construct operation with spreaded argument list
        -:  671: *   - f(...args)
        -:  672: *   - o.f(...args)
        -:  673: *   - new O(...args)
        -:  674: */
        -:  675:static void
    #####:  676:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  677:{
    #####:  678:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  679:
    #####:  680:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  681:  ecma_value_t completion_value;
    #####:  682:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  683:
    #####:  684:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  685:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  686:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  687:
    #####:  688:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  689:  {
    #####:  690:    const char *constructor_message_p = ecma_check_constructor (func_value);
    #####:  691:    if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  692:    {
    #####:  693:      completion_value = ecma_raise_type_error (constructor_message_p);
        -:  694:    }
        -:  695:    else
        -:  696:    {
    #####:  697:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  698:
    #####:  699:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  700:                                                     constructor_obj_p,
    #####:  701:                                                     collection_p->buffer_p,
        -:  702:                                                     collection_p->item_count);
        -:  703:    }
        -:  704:  }
        -:  705:  else
        -:  706:  {
    #####:  707:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  708:
    #####:  709:    if (!ecma_is_value_object (func_value)
    #####:  710:        || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  711:    {
    #####:  712:      completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  713:    }
        -:  714:    else
        -:  715:    {
    #####:  716:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  717:
    #####:  718:      completion_value = ecma_op_function_call (func_obj_p,
        -:  719:                                                this_value,
    #####:  720:                                                collection_p->buffer_p,
        -:  721:                                                collection_p->item_count);
        -:  722:    }
        -:  723:
    #####:  724:    if (is_call_prop)
        -:  725:    {
    #####:  726:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  727:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  728:    }
        -:  729:  }
        -:  730:
    #####:  731:  ecma_collection_free (collection_p);
    #####:  732:  ecma_free_value (func_value);
        -:  733:
    #####:  734:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  735:  {
        -:  736:#if JERRY_DEBUGGER
        -:  737:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  738:#endif /* JERRY_DEBUGGER */
    #####:  739:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  740:  }
        -:  741:  else
        -:  742:  {
    #####:  743:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  744:
    #####:  745:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  746:    {
    #####:  747:      ecma_fast_free_value (completion_value);
        -:  748:    }
    #####:  749:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  750:    {
    #####:  751:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  752:    }
        -:  753:    else
        -:  754:    {
    #####:  755:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  756:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  757:    }
        -:  758:
        -:  759:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  760:    frame_ctx_p->byte_code_p += 3;
        -:  761:  }
    #####:  762:} /* vm_spread_operation */
        -:  763:#endif /* JERRY_ESNEXT */
        -:  764:
        -:  765:/**
        -:  766: * 'Function call' opcode handler.
        -:  767: *
        -:  768: * See also: ECMA-262 v5, 11.2.3
        -:  769: */
        -:  770:static void
        1:  771:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  772:{
        1:  773:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        1:  774:  uint8_t opcode = byte_code_p[-1];
        -:  775:  uint32_t arguments_list_len;
        -:  776:
        1:  777:  if (opcode >= CBC_CALL0)
        -:  778:  {
        1:  779:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  780:  }
        -:  781:  else
        -:  782:  {
    #####:  783:    arguments_list_len = *byte_code_p++;
        -:  784:  }
        -:  785:
        1:  786:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  787:
        1:  788:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        1:  789:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
        1:  790:  ecma_value_t func_value = stack_top_p[-1];
        -:  791:  ecma_value_t completion_value;
        -:  792:
        1:  793:  if (!ecma_is_value_object (func_value)
        1:  794:      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  795:  {
    #####:  796:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  797:  }
        -:  798:  else
        -:  799:  {
        1:  800:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  801:
        1:  802:    completion_value = ecma_op_function_call (func_obj_p,
        -:  803:                                              this_value,
        -:  804:                                              stack_top_p,
        -:  805:                                              arguments_list_len);
        -:  806:  }
        -:  807:
        1:  808:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  809:
        -:  810:  /* Free registers. */
        2:  811:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  812:  {
        1:  813:    ecma_fast_free_value (stack_top_p[i]);
        -:  814:  }
        -:  815:
        1:  816:  if (is_call_prop)
        -:  817:  {
        1:  818:    ecma_free_value (*(--stack_top_p));
        1:  819:    ecma_free_value (*(--stack_top_p));
        -:  820:  }
        -:  821:
        1:  822:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  823:  {
        -:  824:#if JERRY_DEBUGGER
        -:  825:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  826:#endif /* JERRY_DEBUGGER */
        1:  827:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  828:  }
        -:  829:  else
        -:  830:  {
    #####:  831:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  832:    ecma_free_value (*(--stack_top_p));
    #####:  833:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  834:
    #####:  835:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  836:    {
    #####:  837:      ecma_fast_free_value (completion_value);
        -:  838:    }
    #####:  839:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  840:    {
    #####:  841:      *stack_top_p++ = completion_value;
        -:  842:    }
        -:  843:    else
        -:  844:    {
    #####:  845:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  846:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  847:    }
        -:  848:  }
        -:  849:
        1:  850:  frame_ctx_p->stack_top_p = stack_top_p;
        1:  851:} /* opfunc_call */
        -:  852:
        -:  853:/**
        -:  854: * 'Constructor call' opcode handler.
        -:  855: *
        -:  856: * See also: ECMA-262 v5, 11.2.2
        -:  857: */
        -:  858:static void
        2:  859:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  860:{
        2:  861:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        2:  862:  uint8_t opcode = byte_code_p[-1];
        -:  863:  unsigned int arguments_list_len;
        -:  864:
        2:  865:  if (opcode >= CBC_NEW0)
        -:  866:  {
        1:  867:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  868:  }
        -:  869:  else
        -:  870:  {
        1:  871:    arguments_list_len = *byte_code_p++;
        -:  872:  }
        -:  873:
        2:  874:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        2:  875:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  876:  ecma_value_t completion_value;
        -:  877:
        2:  878:  const char *constructor_message_p = ecma_check_constructor (constructor_value);
        2:  879:  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  880:  {
    #####:  881:    completion_value = ecma_raise_type_error (constructor_message_p);
        -:  882:  }
        -:  883:  else
        -:  884:  {
        2:  885:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  886:
        2:  887:    completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  888:                                                   constructor_obj_p,
        -:  889:                                                   stack_top_p,
        -:  890:                                                   arguments_list_len);
        -:  891:  }
        -:  892:
        -:  893:  /* Free registers. */
        5:  894:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  895:  {
        3:  896:    ecma_fast_free_value (stack_top_p[i]);
        -:  897:  }
        -:  898:
        2:  899:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  900:  {
        -:  901:#if JERRY_DEBUGGER
        -:  902:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  903:#endif /* JERRY_DEBUGGER */
    #####:  904:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  905:  }
        -:  906:  else
        -:  907:  {
        2:  908:    ecma_free_value (stack_top_p[-1]);
        2:  909:    frame_ctx_p->byte_code_p = byte_code_p;
        2:  910:    stack_top_p[-1] = completion_value;
        -:  911:  }
        -:  912:
        2:  913:  frame_ctx_p->stack_top_p = stack_top_p;
        2:  914:} /* opfunc_construct */
        -:  915:
        -:  916:/**
        -:  917: * Read literal index from the byte code stream into destination.
        -:  918: *
        -:  919: * @param destination destination
        -:  920: */
        -:  921:#define READ_LITERAL_INDEX(destination) \
        -:  922:  do \
        -:  923:  { \
        -:  924:    (destination) = *byte_code_p++; \
        -:  925:    if ((destination) >= encoding_limit) \
        -:  926:    { \
        -:  927:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  928:    } \
        -:  929:  } \
        -:  930:  while (0)
        -:  931:
        -:  932:/**
        -:  933: * Get literal value by literal index.
        -:  934: *
        -:  935: * @param literal_index literal index
        -:  936: * @param target_value target value
        -:  937: *
        -:  938: * TODO: For performance reasons, we define this as a macro.
        -:  939: * When we are able to construct a function with similar speed,
        -:  940: * we can remove this macro.
        -:  941: */
        -:  942:#define READ_LITERAL(literal_index, target_value) \
        -:  943:  do \
        -:  944:  { \
        -:  945:    if ((literal_index) < ident_end) \
        -:  946:    { \
        -:  947:      if ((literal_index) < register_end) \
        -:  948:      { \
        -:  949:        /* Note: There should be no specialization for arguments. */ \
        -:  950:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index)); \
        -:  951:      } \
        -:  952:      else \
        -:  953:      { \
        -:  954:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]); \
        -:  955:        \
        -:  956:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, \
        -:  957:                                                  name_p); \
        -:  958:        \
        -:  959:        if (ECMA_IS_VALUE_ERROR (result)) \
        -:  960:        { \
        -:  961:          goto error; \
        -:  962:        } \
        -:  963:        (target_value) = result; \
        -:  964:      } \
        -:  965:    } \
        -:  966:    else if (literal_index < const_literal_end) \
        -:  967:    { \
        -:  968:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]); \
        -:  969:    } \
        -:  970:    else \
        -:  971:    { \
        -:  972:      /* Object construction. */ \
        -:  973:      (target_value) = vm_construct_literal_object (frame_ctx_p, \
        -:  974:                                                    literal_start_p[literal_index]); \
        -:  975:    } \
        -:  976:  } \
        -:  977:  while (0)
        -:  978:
        -:  979:/**
        -:  980: * Store the original value for post increase/decrease operators
        -:  981: *
        -:  982: * @param value original value
        -:  983: */
        -:  984:#define POST_INCREASE_DECREASE_PUT_RESULT(value) \
        -:  985:  if (opcode_data & VM_OC_PUT_STACK) \
        -:  986:  { \
        -:  987:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG) \
        -:  988:    { \
        -:  989:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT \
        -:  990:                    || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  991:      *stack_top_p++ = (value); \
        -:  992:    } \
        -:  993:    else \
        -:  994:    { \
        -:  995:      /* The parser ensures there is enough space for the \
        -:  996:       * extra value on the stack. See js-parser-expr.c. */ \
        -:  997:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT \
        -:  998:                    || opcode == CBC_POST_DECR_PUSH_RESULT); \
        -:  999:      stack_top_p++; \
        -: 1000:      stack_top_p[-1] = stack_top_p[-2]; \
        -: 1001:      stack_top_p[-2] = stack_top_p[-3]; \
        -: 1002:      stack_top_p[-3] = (value); \
        -: 1003:    } \
        -: 1004:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK; \
        -: 1005:  } \
        -: 1006:  else \
        -: 1007:  { \
        -: 1008:    JERRY_ASSERT (opcode_data & VM_OC_PUT_BLOCK); \
        -: 1009:    ecma_free_value (VM_GET_REGISTER (frame_ctx_p, 0)); \
        -: 1010:    VM_GET_REGISTERS (frame_ctx_p)[0] = (value); \
        -: 1011:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK; \
        -: 1012:  }
        -: 1013:
        -: 1014:/**
        -: 1015: * Get the end of the existing topmost context
        -: 1016: */
        -: 1017:#define VM_LAST_CONTEXT_END() \
        -: 1018:  (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -: 1019:
        -: 1020:/**
        -: 1021: * Run generic byte code.
        -: 1022: *
        -: 1023: * @return ecma value
        -: 1024: */
        -: 1025:static ecma_value_t JERRY_ATTR_NOINLINE
        6: 1026:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1027:{
        6: 1028:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        6: 1029:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
        6: 1030:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -: 1031:
        6: 1032:  ecma_value_t *stack_top_p;
        -: 1033:  uint16_t encoding_limit;
        -: 1034:  uint16_t encoding_delta;
        -: 1035:  uint16_t register_end;
        -: 1036:  uint16_t ident_end;
        -: 1037:  uint16_t const_literal_end;
        6: 1038:  int32_t branch_offset = 0;
        6: 1039:  uint8_t branch_offset_length = 0;
        6: 1040:  ecma_value_t left_value;
        -: 1041:  ecma_value_t right_value;
        6: 1042:  ecma_value_t result = ECMA_VALUE_EMPTY;
        6: 1043:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -: 1044:
        -: 1045:  /* Prepare for byte code execution. */
        6: 1046:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 1047:  {
        6: 1048:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        6: 1049:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1050:  }
        -: 1051:  else
        -: 1052:  {
    #####: 1053:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1054:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1055:  }
        -: 1056:
        6: 1057:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1058:  {
    #####: 1059:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1060:    register_end = args_p->register_end;
    #####: 1061:    ident_end = args_p->ident_end;
    #####: 1062:    const_literal_end = args_p->const_literal_end;
        -: 1063:  }
        -: 1064:  else
        -: 1065:  {
        6: 1066:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
        6: 1067:    register_end = args_p->register_end;
        6: 1068:    ident_end = args_p->ident_end;
        6: 1069:    const_literal_end = args_p->const_literal_end;
        -: 1070:  }
        -: 1071:
        6: 1072:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1073:
        -: 1074:  /* Outer loop for exception handling. */
        1: 1075:  while (true)
        -: 1076:  {
        -: 1077:    /* Internal loop for byte code execution. */
        -: 1078:    while (true)
       27: 1079:    {
       34: 1080:      const uint8_t *byte_code_start_p = byte_code_p;
       34: 1081:      uint8_t opcode = *byte_code_p++;
       34: 1082:      uint32_t opcode_data = opcode;
        -: 1083:
       34: 1084:      if (opcode == CBC_EXT_OPCODE)
        -: 1085:      {
        5: 1086:        opcode = *byte_code_p++;
        5: 1087:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1088:      }
        -: 1089:
       34: 1090:      opcode_data = vm_decode_table[opcode_data];
        -: 1091:
       34: 1092:      left_value = ECMA_VALUE_UNDEFINED;
       34: 1093:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1094:
       34: 1095:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1096:
       34: 1097:      if (operands >= VM_OC_GET_LITERAL)
        -: 1098:      {
        -: 1099:        uint16_t literal_index;
       10: 1100:        READ_LITERAL_INDEX (literal_index);
       10: 1101:        READ_LITERAL (literal_index, left_value);
        -: 1102:
        9: 1103:        if (operands != VM_OC_GET_LITERAL)
        -: 1104:        {
        4: 1105:          switch (operands)
        -: 1106:          {
        4: 1107:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1108:            {
        -: 1109:              uint16_t second_literal_index;
        4: 1110:              READ_LITERAL_INDEX (second_literal_index);
        4: 1111:              READ_LITERAL (second_literal_index, right_value);
        4: 1112:              break;
        -: 1113:            }
    #####: 1114:            case VM_OC_GET_STACK_LITERAL:
        -: 1115:            {
    #####: 1116:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1117:              right_value = left_value;
    #####: 1118:              left_value = *(--stack_top_p);
    #####: 1119:              break;
        -: 1120:            }
    #####: 1121:            default:
        -: 1122:            {
    #####: 1123:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1124:
    #####: 1125:              right_value = left_value;
    #####: 1126:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1127:              break;
        -: 1128:            }
        -: 1129:          }
        5: 1130:        }
        -: 1131:      }
       24: 1132:      else if (operands >= VM_OC_GET_STACK)
        -: 1133:      {
        9: 1134:        JERRY_ASSERT (operands == VM_OC_GET_STACK
        -: 1135:                      || operands == VM_OC_GET_STACK_STACK);
        -: 1136:
        9: 1137:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        9: 1138:        left_value = *(--stack_top_p);
        -: 1139:
        9: 1140:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1141:        {
        1: 1142:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        1: 1143:          right_value = left_value;
        1: 1144:          left_value = *(--stack_top_p);
        -: 1145:        }
        -: 1146:      }
       15: 1147:      else if (operands == VM_OC_GET_BRANCH)
        -: 1148:      {
        3: 1149:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        3: 1150:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1151:
        3: 1152:        branch_offset = *(byte_code_p++);
        -: 1153:
        3: 1154:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1155:        {
    #####: 1156:          branch_offset <<= 8;
    #####: 1157:          branch_offset |= *(byte_code_p++);
        -: 1158:
    #####: 1159:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1160:          {
    #####: 1161:            branch_offset <<= 8;
    #####: 1162:            branch_offset |= *(byte_code_p++);
        -: 1163:          }
        -: 1164:        }
        -: 1165:
        3: 1166:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1167:        {
        -: 1168:#if JERRY_VM_EXEC_STOP
    #####: 1169:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL
    #####: 1170:              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1171:          {
    #####: 1172:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1173:
    #####: 1174:            if (ecma_is_value_undefined (result))
        -: 1175:            {
    #####: 1176:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1177:            }
        -: 1178:            else
        -: 1179:            {
    #####: 1180:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1181:
    #####: 1182:              if (ecma_is_value_error_reference (result))
        -: 1183:              {
    #####: 1184:                ecma_raise_error_from_error_reference (result);
        -: 1185:              }
        -: 1186:              else
        -: 1187:              {
    #####: 1188:                jcontext_raise_exception (result);
        -: 1189:              }
        -: 1190:
        -: 1191:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1192:              jcontext_set_abort_flag (true);
    #####: 1193:              result = ECMA_VALUE_ERROR;
    #####: 1194:              goto error;
        -: 1195:            }
        -: 1196:          }
        -: 1197:#endif /* JERRY_VM_EXEC_STOP */
        -: 1198:
        1: 1199:          branch_offset = -branch_offset;
        -: 1200:        }
        -: 1201:      }
        -: 1202:
       33: 1203:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1204:      {
    #####: 1205:        case VM_OC_POP:
        -: 1206:        {
    #####: 1207:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1208:          ecma_free_value (*(--stack_top_p));
    #####: 1209:          continue;
        -: 1210:        }
    #####: 1211:        case VM_OC_POP_BLOCK:
        -: 1212:        {
    #####: 1213:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 1214:          VM_GET_REGISTERS (frame_ctx_p)[0] = *(--stack_top_p);
    #####: 1215:          continue;
        -: 1216:        }
        4: 1217:        case VM_OC_PUSH:
        -: 1218:        {
        4: 1219:          *stack_top_p++ = left_value;
        4: 1220:          continue;
        -: 1221:        }
    #####: 1222:        case VM_OC_PUSH_TWO:
        -: 1223:        {
    #####: 1224:          *stack_top_p++ = left_value;
    #####: 1225:          *stack_top_p++ = right_value;
    #####: 1226:          continue;
        -: 1227:        }
    #####: 1228:        case VM_OC_PUSH_THREE:
        -: 1229:        {
        -: 1230:          uint16_t literal_index;
        -: 1231:
    #####: 1232:          *stack_top_p++ = left_value;
    #####: 1233:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1234:
    #####: 1235:          READ_LITERAL_INDEX (literal_index);
    #####: 1236:          READ_LITERAL (literal_index, left_value);
        -: 1237:
    #####: 1238:          *stack_top_p++ = right_value;
    #####: 1239:          *stack_top_p++ = left_value;
    #####: 1240:          continue;
        -: 1241:        }
    #####: 1242:        case VM_OC_PUSH_UNDEFINED:
        -: 1243:        {
    #####: 1244:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1245:          continue;
        -: 1246:        }
        1: 1247:        case VM_OC_PUSH_TRUE:
        -: 1248:        {
        1: 1249:          *stack_top_p++ = ECMA_VALUE_TRUE;
        1: 1250:          continue;
        -: 1251:        }
    #####: 1252:        case VM_OC_PUSH_FALSE:
        -: 1253:        {
    #####: 1254:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1255:          continue;
        -: 1256:        }
    #####: 1257:        case VM_OC_PUSH_NULL:
        -: 1258:        {
    #####: 1259:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1260:          continue;
        -: 1261:        }
        1: 1262:        case VM_OC_PUSH_THIS:
        -: 1263:        {
        1: 1264:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
        1: 1265:          continue;
        -: 1266:        }
    #####: 1267:        case VM_OC_PUSH_0:
        -: 1268:        {
    #####: 1269:          *stack_top_p++ = ecma_make_integer_value (0);
    #####: 1270:          continue;
        -: 1271:        }
        1: 1272:        case VM_OC_PUSH_POS_BYTE:
        -: 1273:        {
        1: 1274:          ecma_integer_value_t number = *byte_code_p++;
        1: 1275:          *stack_top_p++ = ecma_make_integer_value (number + 1);
        1: 1276:          continue;
        -: 1277:        }
    #####: 1278:        case VM_OC_PUSH_NEG_BYTE:
        -: 1279:        {
    #####: 1280:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1281:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1282:          continue;
        -: 1283:        }
    #####: 1284:        case VM_OC_PUSH_LIT_0:
        -: 1285:        {
    #####: 1286:          stack_top_p[0] = left_value;
    #####: 1287:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1288:          stack_top_p += 2;
    #####: 1289:          continue;
        -: 1290:        }
        1: 1291:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1292:        {
        1: 1293:          ecma_integer_value_t number = *byte_code_p++;
        1: 1294:          stack_top_p[0] = left_value;
        1: 1295:          stack_top_p[1] = ecma_make_integer_value (number + 1);
        1: 1296:          stack_top_p += 2;
        1: 1297:          continue;
        -: 1298:        }
    #####: 1299:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1300:        {
    #####: 1301:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1302:          stack_top_p[0] = left_value;
    #####: 1303:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1304:          stack_top_p += 2;
    #####: 1305:          continue;
        -: 1306:        }
        1: 1307:        case VM_OC_PUSH_OBJECT:
        -: 1308:        {
        1: 1309:          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
        -: 1310:                                                     0,
        -: 1311:                                                     ECMA_OBJECT_TYPE_GENERAL);
        -: 1312:
        1: 1313:          *stack_top_p++ = ecma_make_object_value (obj_p);
        1: 1314:          continue;
        -: 1315:        }
    #####: 1316:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1317:        {
    #####: 1318:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1319:
    #####: 1320:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1321:
    #####: 1322:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1323:
    #####: 1324:          JERRY_ASSERT (frame_ctx_p->lex_env_p ==
        -: 1325:                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1326:
    #####: 1327:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1328:
    #####: 1329:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1330:
    #####: 1331:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1332:
    #####: 1333:          ecma_free_value (right_value);
    #####: 1334:          ecma_deref_object (name_lex_env);
    #####: 1335:          *stack_top_p++ = left_value;
    #####: 1336:          continue;
        -: 1337:        }
    #####: 1338:        case VM_OC_CREATE_BINDING:
        -: 1339:        {
        -: 1340:#if !JERRY_ESNEXT
        -: 1341:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1342:#endif /* !JERRY_ESNEXT */
        -: 1343:
        -: 1344:          uint32_t literal_index;
        -: 1345:
    #####: 1346:          READ_LITERAL_INDEX (literal_index);
        -: 1347:
    #####: 1348:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1349:
    #####: 1350:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1351:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1352:
    #####: 1353:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1354:
        -: 1355:#if JERRY_ESNEXT
    #####: 1356:          if (opcode == CBC_CREATE_LET)
        -: 1357:          {
    #####: 1358:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1359:          }
    #####: 1360:          else if (opcode == CBC_CREATE_CONST)
        -: 1361:          {
    #####: 1362:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1363:          }
        -: 1364:
        -: 1365:          ecma_property_value_t *property_value_p;
    #####: 1366:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1367:
    #####: 1368:          if (opcode != CBC_CREATE_VAR)
        -: 1369:          {
    #####: 1370:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1371:          }
        -: 1372:#else /* !JERRY_ESNEXT */
    #####: 1373:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1374:#endif /* JERRY_ESNEXT */
        -: 1375:
    #####: 1376:          continue;
        -: 1377:        }
        1: 1378:        case VM_OC_VAR_EVAL:
        -: 1379:        {
        -: 1380:          uint32_t literal_index;
        1: 1381:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1382:
        1: 1383:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1384:          {
        -: 1385:            uint32_t value_index;
    #####: 1386:            READ_LITERAL_INDEX (value_index);
    #####: 1387:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1388:
    #####: 1389:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1390:                                                     literal_start_p[value_index]);
        -: 1391:          }
        -: 1392:
        1: 1393:          READ_LITERAL_INDEX (literal_index);
        1: 1394:          JERRY_ASSERT (literal_index >= register_end);
        -: 1395:
        1: 1396:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1397:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1398:
        2: 1399:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1400:          {
        -: 1401:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1402:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1403:            {
    #####: 1404:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1405:
    #####: 1406:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1407:            }
        -: 1408:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1409:
    #####: 1410:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1411:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1412:          }
        -: 1413:
        -: 1414:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
        1: 1415:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1416:          {
    #####: 1417:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1418:
    #####: 1419:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1420:          }
        -: 1421:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1422:
        -: 1423:          /* 'Variable declaration' */
        1: 1424:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1425:
        -: 1426:#if JERRY_BUILTIN_PROXY
        1: 1427:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1428:          {
    #####: 1429:            goto error;
        -: 1430:          }
        -: 1431:#endif /* JERRY_BUILTIN_PROXY */
        -: 1432:
        1: 1433:          ecma_property_t *prop_p = NULL;
        -: 1434:
        1: 1435:          if (ecma_is_value_false (result))
        -: 1436:          {
        1: 1437:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
        1: 1438:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1439:
        1: 1440:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1441:            {
    #####: 1442:              result = ECMA_VALUE_ERROR;
    #####: 1443:              goto error;
        -: 1444:            }
        -: 1445:          }
        -: 1446:
        1: 1447:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1448:          {
    #####: 1449:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1450:
    #####: 1451:            if (prop_p != NULL)
        -: 1452:            {
    #####: 1453:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1454:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1455:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1456:              ecma_free_object (lit_value);
        -: 1457:            }
        -: 1458:            else
        -: 1459:            {
    #####: 1460:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
    #####: 1461:              ecma_free_object (lit_value);
        -: 1462:
    #####: 1463:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1464:              {
    #####: 1465:                goto error;
        -: 1466:              }
        -: 1467:            }
        -: 1468:          }
        1: 1469:          continue;
        -: 1470:        }
        -: 1471:#if JERRY_ESNEXT
    #####: 1472:        case VM_OC_EXT_VAR_EVAL:
        -: 1473:        {
        -: 1474:          uint32_t literal_index;
    #####: 1475:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1476:
    #####: 1477:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1478:
    #####: 1479:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1480:          {
        -: 1481:            uint32_t value_index;
    #####: 1482:            READ_LITERAL_INDEX (value_index);
    #####: 1483:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1484:
    #####: 1485:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1486:                                                     literal_start_p[value_index]);
        -: 1487:          }
        -: 1488:
    #####: 1489:          READ_LITERAL_INDEX (literal_index);
    #####: 1490:          JERRY_ASSERT (literal_index >= register_end);
        -: 1491:
    #####: 1492:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1493:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1494:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1495:
    #####: 1496:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1497:          {
        -: 1498:#if !(defined JERRY_NDEBUG)
    #####: 1499:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1500:            {
    #####: 1501:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1502:
    #####: 1503:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1504:            }
        -: 1505:#endif /* !JERRY_NDEBUG */
        -: 1506:
    #####: 1507:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1508:            prev_lex_env_p = lex_env_p;
    #####: 1509:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1510:          }
        -: 1511:
    #####: 1512:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1513:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1514:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1515:
    #####: 1516:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1517:          ecma_property_value_t *property_value_p;
        -: 1518:
    #####: 1519:          if (property_p == NULL)
        -: 1520:          {
    #####: 1521:            property_value_p = ecma_create_named_data_property (prev_lex_env_p,
        -: 1522:                                                                name_p,
        -: 1523:                                                                ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1524:                                                                NULL);
        -: 1525:
    #####: 1526:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1527:            {
    #####: 1528:              continue;
        -: 1529:            }
        -: 1530:          }
        -: 1531:          else
        -: 1532:          {
    #####: 1533:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1534:            {
    #####: 1535:              continue;
        -: 1536:            }
        -: 1537:
    #####: 1538:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1539:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1540:          }
        -: 1541:
    #####: 1542:          property_value_p->value = lit_value;
    #####: 1543:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1544:          continue;
        -: 1545:        }
        -: 1546:#endif /* JERRY_ESNEXT */
    #####: 1547:        case VM_OC_CREATE_ARGUMENTS:
        -: 1548:        {
        -: 1549:          uint32_t literal_index;
    #####: 1550:          READ_LITERAL_INDEX (literal_index);
        -: 1551:
    #####: 1552:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1553:
    #####: 1554:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1555:                                                    frame_ctx_p->lex_env_p);
        -: 1556:
    #####: 1557:          if (literal_index < register_end)
        -: 1558:          {
    #####: 1559:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1560:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1561:            continue;
        -: 1562:          }
        -: 1563:
    #####: 1564:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1565:
    #####: 1566:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1567:
    #####: 1568:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1569:          ecma_property_value_t *property_value_p;
        -: 1570:
    #####: 1571:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1572:          property_value_p->value = result;
        -: 1573:
    #####: 1574:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1575:          continue;
        -: 1576:        }
        -: 1577:#if JERRY_SNAPSHOT_EXEC
    #####: 1578:        case VM_OC_SET_BYTECODE_PTR:
        -: 1579:        {
    #####: 1580:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1581:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1582:          continue;
        -: 1583:        }
        -: 1584:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 1585:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1586:        {
        -: 1587:          uint32_t literal_index, value_index;
        -: 1588:          ecma_value_t lit_value;
    #####: 1589:          bool release = false;
        -: 1590:
    #####: 1591:          READ_LITERAL_INDEX (value_index);
        -: 1592:
    #####: 1593:          if (value_index < register_end)
        -: 1594:          {
        -: 1595:            /* Take (not copy) the reference. */
    #####: 1596:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1597:          }
        -: 1598:          else
        -: 1599:          {
    #####: 1600:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1601:                                                     literal_start_p[value_index]);
    #####: 1602:            release = true;
        -: 1603:          }
        -: 1604:
    #####: 1605:          READ_LITERAL_INDEX (literal_index);
        -: 1606:
    #####: 1607:          JERRY_ASSERT (value_index != literal_index);
    #####: 1608:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1609:
    #####: 1610:          if (literal_index < register_end)
        -: 1611:          {
    #####: 1612:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1613:            JERRY_ASSERT (release);
    #####: 1614:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1615:            continue;
        -: 1616:          }
        -: 1617:
    #####: 1618:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1619:
    #####: 1620:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1621:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1622:
        -: 1623:          ecma_property_value_t *property_value_p;
    #####: 1624:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1625:                                                              name_p,
        -: 1626:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1627:                                                              NULL);
        -: 1628:
    #####: 1629:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 1630:          property_value_p->value = lit_value;
        -: 1631:
    #####: 1632:          if (release)
        -: 1633:          {
    #####: 1634:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1635:          }
    #####: 1636:          continue;
        -: 1637:        }
        -: 1638:#if JERRY_ESNEXT
        1: 1639:        case VM_OC_CHECK_VAR:
        -: 1640:        {
        1: 1641:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1642:                        == CBC_FUNCTION_SCRIPT);
        -: 1643:
        -: 1644:          uint32_t literal_index;
        1: 1645:          READ_LITERAL_INDEX (literal_index);
        -: 1646:
        1: 1647:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1648:          {
        1: 1649:            continue;
        -: 1650:          }
        -: 1651:
    #####: 1652:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1653:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1654:
    #####: 1655:          if (binding_p != NULL)
        -: 1656:          {
    #####: 1657:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1658:            goto error;
        -: 1659:          }
        -: 1660:
    #####: 1661:          continue;
        -: 1662:        }
    #####: 1663:        case VM_OC_CHECK_LET:
        -: 1664:        {
    #####: 1665:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1666:                        == CBC_FUNCTION_SCRIPT);
        -: 1667:
        -: 1668:          uint32_t literal_index;
    #####: 1669:          READ_LITERAL_INDEX (literal_index);
        -: 1670:
    #####: 1671:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1672:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1673:
    #####: 1674:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1675:          {
    #####: 1676:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1677:
    #####: 1678:            if (!ecma_is_value_false (result))
        -: 1679:            {
    #####: 1680:              if (ecma_is_value_true (result))
        -: 1681:              {
    #####: 1682:                result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
        -: 1683:              }
        -: 1684:
    #####: 1685:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1686:              goto error;
        -: 1687:            }
        -: 1688:
    #####: 1689:            continue;
        -: 1690:          }
        -: 1691:
    #####: 1692:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1693:
        -: 1694:#if JERRY_BUILTIN_PROXY
    #####: 1695:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1696:          {
    #####: 1697:            goto error;
        -: 1698:          }
        -: 1699:#endif /* JERRY_BUILTIN_PROXY */
        -: 1700:
    #####: 1701:          if (ecma_is_value_true (result))
        -: 1702:          {
    #####: 1703:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1704:            goto error;
        -: 1705:          }
        -: 1706:
    #####: 1707:          continue;
        -: 1708:        }
    #####: 1709:        case VM_OC_ASSIGN_LET_CONST:
        -: 1710:        {
        -: 1711:          uint32_t literal_index;
    #####: 1712:          READ_LITERAL_INDEX (literal_index);
        -: 1713:
    #####: 1714:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1715:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1716:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1717:                            && (frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)));
        -: 1718:
    #####: 1719:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1720:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1721:
    #####: 1722:          JERRY_ASSERT (property_p != NULL
        -: 1723:                        && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1724:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
    #####: 1725:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1726:
    #####: 1727:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1728:
    #####: 1729:          if (ecma_is_value_object (left_value))
        -: 1730:          {
    #####: 1731:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1732:          }
    #####: 1733:          continue;
        -: 1734:        }
    #####: 1735:        case VM_OC_INIT_BINDING:
        -: 1736:        {
        -: 1737:          uint32_t literal_index;
        -: 1738:
    #####: 1739:          READ_LITERAL_INDEX (literal_index);
        -: 1740:
    #####: 1741:          JERRY_ASSERT (literal_index >= register_end);
        -: 1742:
    #####: 1743:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1744:
    #####: 1745:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1746:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1747:
    #####: 1748:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1749:
    #####: 1750:          if (opcode == CBC_INIT_LET)
        -: 1751:          {
    #####: 1752:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1753:          }
    #####: 1754:          else if (opcode == CBC_INIT_CONST)
        -: 1755:          {
    #####: 1756:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1757:          }
        -: 1758:
        -: 1759:          ecma_property_value_t *property_value_p;
    #####: 1760:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1761:                                                              name_p,
        -: 1762:                                                              prop_attributes,
        -: 1763:                                                              NULL);
        -: 1764:
    #####: 1765:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1766:
    #####: 1767:          ecma_value_t value = *(--stack_top_p);
        -: 1768:
    #####: 1769:          property_value_p->value = value;
    #####: 1770:          ecma_deref_if_object (value);
    #####: 1771:          continue;
        -: 1772:        }
    #####: 1773:        case VM_OC_THROW_CONST_ERROR:
        -: 1774:        {
    #####: 1775:          result = ecma_raise_type_error (ECMA_ERR_MSG ("Constant bindings cannot be reassigned"));
    #####: 1776:          goto error;
        -: 1777:        }
    #####: 1778:        case VM_OC_COPY_TO_GLOBAL:
        -: 1779:        {
        -: 1780:          uint32_t literal_index;
    #####: 1781:          READ_LITERAL_INDEX (literal_index);
        -: 1782:
    #####: 1783:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1784:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1785:
    #####: 1786:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1787:          {
        -: 1788:#ifndef JERRY_NDEBUG
    #####: 1789:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1790:            {
    #####: 1791:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1792:
    #####: 1793:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1794:            }
        -: 1795:#endif /* !JERRY_NDEBUG */
        -: 1796:
    #####: 1797:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1798:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1799:          }
        -: 1800:
    #####: 1801:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1802:          {
    #####: 1803:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1804:            ecma_property_value_t *prop_value_p;
        -: 1805:
    #####: 1806:            if (property_p == NULL)
        -: 1807:            {
    #####: 1808:              prop_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1809:                                                              name_p,
        -: 1810:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1811:                                                              NULL);
        -: 1812:            }
        -: 1813:            else
        -: 1814:            {
        -: 1815:#ifndef JERRY_NDEBUG
    #####: 1816:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1817:#endif /* !JERRY_NDEBUG */
    #####: 1818:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1819:            }
        -: 1820:
    #####: 1821:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1822:          }
        -: 1823:          else
        -: 1824:          {
    #####: 1825:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1826:
    #####: 1827:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1828:            {
    #####: 1829:              goto error;
        -: 1830:            }
        -: 1831:          }
        -: 1832:
    #####: 1833:          goto free_left_value;
        -: 1834:        }
    #####: 1835:        case VM_OC_COPY_FROM_ARG:
        -: 1836:        {
        -: 1837:          uint32_t literal_index;
    #####: 1838:          READ_LITERAL_INDEX (literal_index);
    #####: 1839:          JERRY_ASSERT (literal_index >= register_end);
        -: 1840:
    #####: 1841:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1842:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1843:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1844:
    #####: 1845:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1846:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1847:          JERRY_ASSERT (arg_lex_env_p != NULL
        -: 1848:                        && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1849:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1850:
        -: 1851:          ecma_property_value_t *property_value_p;
    #####: 1852:          property_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1853:                                                              name_p,
        -: 1854:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1855:                                                              NULL);
        -: 1856:
    #####: 1857:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1858:          JERRY_ASSERT (property_p != NULL);
        -: 1859:
    #####: 1860:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1861:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1862:          continue;
        -: 1863:        }
    #####: 1864:        case VM_OC_CLONE_CONTEXT:
        -: 1865:        {
    #####: 1866:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1867:
    #####: 1868:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1869:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1870:          continue;
        -: 1871:        }
    #####: 1872:        case VM_OC_SET__PROTO__:
        -: 1873:        {
    #####: 1874:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1875:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1876:          {
    #####: 1877:            goto error;
        -: 1878:          }
    #####: 1879:          goto free_left_value;
        -: 1880:        }
    #####: 1881:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1882:        {
    #####: 1883:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1884:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1885:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1886:
    #####: 1887:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1888:          ecma_value_t value = stack_top_p[-1];
        -: 1889:
    #####: 1890:          if (!push_computed)
        -: 1891:          {
    #####: 1892:            stack_top_p++;
        -: 1893:          }
        -: 1894:
    #####: 1895:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1896:          stack_top_p[-4] = left_value;
        -: 1897:
    #####: 1898:          if (!push_computed)
        -: 1899:          {
    #####: 1900:            continue;
        -: 1901:          }
        -: 1902:
    #####: 1903:          left_value = value;
        -: 1904:          /* FALLTHRU */
        -: 1905:        }
    #####: 1906:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1907:        {
    #####: 1908:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1909:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1910:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1911:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1912:
    #####: 1913:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1914:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1915:
    #####: 1916:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1917:          {
    #####: 1918:            goto error;
        -: 1919:          }
    #####: 1920:          goto free_left_value;
        -: 1921:        }
    #####: 1922:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1923:        {
    #####: 1924:          left_value = *(--stack_top_p);
        -: 1925:
    #####: 1926:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1927:          {
    #####: 1928:            continue;
        -: 1929:          }
        -: 1930:
    #####: 1931:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1932:
    #####: 1933:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1934:          {
    #####: 1935:            goto error;
        -: 1936:          }
        -: 1937:
    #####: 1938:          goto free_left_value;
        -: 1939:        }
    #####: 1940:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1941:        {
        -: 1942:          /* Swap values. */
    #####: 1943:          left_value ^= right_value;
    #####: 1944:          right_value ^= left_value;
    #####: 1945:          left_value ^= right_value;
        -: 1946:          /* FALLTHRU */
        -: 1947:        }
        -: 1948:#endif /* JERRY_ESNEXT */
        2: 1949:        case VM_OC_SET_PROPERTY:
        -: 1950:        {
        -: 1951:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1952:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1953:
        2: 1954:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1955:
        2: 1956:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1957:
        2: 1958:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1959:          {
    #####: 1960:            result = ECMA_VALUE_ERROR;
    #####: 1961:            goto error;
        -: 1962:          }
        -: 1963:
        -: 1964:#if JERRY_ESNEXT
        2: 1965:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1966:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1967:          {
    #####: 1968:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 1969:            goto error;
        -: 1970:          }
        -: 1971:
        2: 1972:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1973:#else /* !JERRY_ESNEXT */
    #####: 1974:          const int index = -1;
        -: 1975:#endif /* JERRY_ESNEXT */
        -: 1976:
        2: 1977:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1978:
        2: 1979:          opfunc_set_data_property (object_p, prop_name_p, left_value);
        2: 1980:          ecma_deref_ecma_string (prop_name_p);
        -: 1981:
        2: 1982:          goto free_both_values;
        -: 1983:        }
    #####: 1984:        case VM_OC_SET_GETTER:
        -: 1985:        case VM_OC_SET_SETTER:
        -: 1986:        {
    #####: 1987:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1988:
    #####: 1989:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1990:
    #####: 1991:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1992:          {
    #####: 1993:            result = ECMA_VALUE_ERROR;
    #####: 1994:            goto error;
        -: 1995:          }
        -: 1996:
        -: 1997:#if JERRY_ESNEXT
    #####: 1998:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1999:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 2000:          {
    #####: 2001:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 2002:            goto error;
        -: 2003:          }
        -: 2004:
    #####: 2005:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 2006:#else /* !JERRY_ESNEXT */
    #####: 2007:          const int index = -1;
        -: 2008:#endif /* JERRY_ESNEXT */
        -: 2009:
    #####: 2010:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
    #####: 2011:                               stack_top_p[index],
        -: 2012:                               prop_name_p,
        -: 2013:                               right_value);
        -: 2014:
    #####: 2015:          ecma_deref_ecma_string (prop_name_p);
        -: 2016:
    #####: 2017:          goto free_both_values;
        -: 2018:        }
    #####: 2019:        case VM_OC_PUSH_ARRAY:
        -: 2020:        {
        -: 2021:          /* Note: this operation cannot throw an exception */
    #####: 2022:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
    #####: 2023:          continue;
        -: 2024:        }
        -: 2025:#if JERRY_ESNEXT
    #####: 2026:        case VM_OC_LOCAL_EVAL:
        -: 2027:        {
    #####: 2028:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 2029:          uint8_t parse_opts = *byte_code_p++;
    #####: 2030:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 2031:          continue;
        -: 2032:        }
    #####: 2033:        case VM_OC_SUPER_CALL:
        -: 2034:        {
    #####: 2035:          uint8_t arguments_list_len = *byte_code_p++;
        -: 2036:
    #####: 2037:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 2038:          {
    #####: 2039:            stack_top_p -= arguments_list_len;
    #####: 2040:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2041:
    #####: 2042:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2043:            {
    #####: 2044:              result = ECMA_VALUE_ERROR;
    #####: 2045:              goto error;
        -: 2046:            }
        -: 2047:
    #####: 2048:            stack_top_p++;
    #####: 2049:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2050:          }
        -: 2051:          else
        -: 2052:          {
    #####: 2053:            stack_top_p -= arguments_list_len;
        -: 2054:          }
        -: 2055:
    #####: 2056:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 2057:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2058:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2059:          return ECMA_VALUE_UNDEFINED;
        -: 2060:        }
    #####: 2061:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 2062:        {
        -: 2063:          uint16_t literal_index;
        -: 2064:
    #####: 2065:          READ_LITERAL_INDEX (literal_index);
    #####: 2066:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
    #####: 2067:          continue;
        -: 2068:        }
    #####: 2069:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2070:        {
    #####: 2071:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode,
    #####: 2072:                                                                     frame_ctx_p->shared_p->bytecode_header_p);
    #####: 2073:          continue;
        -: 2074:        }
    #####: 2075:        case VM_OC_INIT_CLASS:
        -: 2076:        {
    #####: 2077:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2078:
    #####: 2079:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2080:          {
    #####: 2081:            goto error;
        -: 2082:          }
    #####: 2083:          continue;
        -: 2084:        }
    #####: 2085:        case VM_OC_FINALIZE_CLASS:
        -: 2086:        {
    #####: 2087:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2088:
    #####: 2089:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2090:          {
        -: 2091:            uint16_t literal_index;
    #####: 2092:            READ_LITERAL_INDEX (literal_index);
    #####: 2093:            left_value = literal_start_p[literal_index];
        -: 2094:          }
        -: 2095:
    #####: 2096:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 2097:          continue;
        -: 2098:        }
    #####: 2099:        case VM_OC_SET_FIELD_INIT:
        -: 2100:        {
    #####: 2101:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2102:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-2]);
        -: 2103:
    #####: 2104:          ecma_property_value_t *property_value_p = ecma_create_named_data_property (object_p,
        -: 2105:                                                                                     property_name_p,
        -: 2106:                                                                                     ECMA_PROPERTY_FIXED,
        -: 2107:                                                                                     NULL);
    #####: 2108:          property_value_p->value = left_value;
        -: 2109:
    #####: 2110:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2111:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 2112:
    #####: 2113:          if (property_p != NULL)
        -: 2114:          {
    #####: 2115:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2116:            ecma_value_t *compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t,
        -: 2117:                                                                                  property_value_p->value);
    #####: 2118:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2119:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2120:          }
        -: 2121:
    #####: 2122:          goto free_left_value;
        -: 2123:        }
    #####: 2124:        case VM_OC_RUN_FIELD_INIT:
        -: 2125:        {
    #####: 2126:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2127:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2128:
    #####: 2129:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2130:          {
    #####: 2131:            goto error;
        -: 2132:          }
    #####: 2133:          continue;
        -: 2134:        }
    #####: 2135:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2136:        {
    #####: 2137:          left_value = stack_top_p[-2];
    #####: 2138:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2139:          stack_top_p--;
        -: 2140:
    #####: 2141:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2142:
    #####: 2143:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2144:          {
    #####: 2145:            goto error;
        -: 2146:          }
    #####: 2147:          goto free_left_value;
        -: 2148:        }
    #####: 2149:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2150:        {
    #####: 2151:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2152:          stack_top_p[-2] = ecma_make_integer_value (next_index);
    #####: 2153:          stack_top_p++;
        -: 2154:
    #####: 2155:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2156:
    #####: 2157:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2158:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
        -: 2159:
    #####: 2160:          result = stack_top_p[-2];
    #####: 2161:          stack_top_p[-1] = ecma_copy_value (computed_class_fields_p[next_index]);
    #####: 2162:          stack_top_p[-2] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2163:          break;
        -: 2164:        }
    #####: 2165:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2166:        {
    #####: 2167:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2168:
    #####: 2169:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2170:          {
    #####: 2171:            goto error;
        -: 2172:          }
        -: 2173:
    #####: 2174:          *stack_top_p++ = result;
    #####: 2175:          continue;
        -: 2176:        }
    #####: 2177:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2178:        {
    #####: 2179:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2180:
    #####: 2181:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2182:          {
    #####: 2183:            goto error;
        -: 2184:          }
        -: 2185:
    #####: 2186:          *stack_top_p++ = result;
    #####: 2187:          continue;
        -: 2188:        }
    #####: 2189:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2190:        {
    #####: 2191:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2192:          {
    #####: 2193:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2194:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2195:
    #####: 2196:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2197:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2198:            *stack_top_p++ = obj_value;
        -: 2199:          }
        -: 2200:          else
        -: 2201:          {
    #####: 2202:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2203:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2204:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2205:            stack_top_p--;
        -: 2206:          }
    #####: 2207:          continue;
        -: 2208:        }
    #####: 2209:        case VM_OC_SET_HOME_OBJECT:
        -: 2210:        {
    #####: 2211:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2212:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2213:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2214:          continue;
        -: 2215:        }
    #####: 2216:        case VM_OC_SUPER_REFERENCE:
        -: 2217:        {
    #####: 2218:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2219:
    #####: 2220:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2221:          {
    #####: 2222:            goto error;
        -: 2223:          }
        -: 2224:
    #####: 2225:          goto free_left_value;
        -: 2226:        }
    #####: 2227:        case VM_OC_SET_FUNCTION_NAME:
        -: 2228:        {
    #####: 2229:          char *prefix_p = NULL;
    #####: 2230:          lit_utf8_size_t prefix_size = 0;
        -: 2231:
    #####: 2232:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2233:          {
        -: 2234:            ecma_value_t prop_name_value;
        -: 2235:
    #####: 2236:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2237:            {
        -: 2238:              uint16_t literal_index;
    #####: 2239:              READ_LITERAL_INDEX (literal_index);
    #####: 2240:              prop_name_value = literal_start_p[literal_index];
        -: 2241:            }
        -: 2242:            else
        -: 2243:            {
    #####: 2244:              prop_name_value = stack_top_p[-2];
        -: 2245:            }
        -: 2246:
    #####: 2247:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2248:
    #####: 2249:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2250:            {
    #####: 2251:              result = ECMA_VALUE_ERROR;
    #####: 2252:              goto error;
        -: 2253:            }
        -: 2254:
    #####: 2255:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2256:
    #####: 2257:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2258:            {
    #####: 2259:              ecma_ref_ecma_string (prop_name_p);
    #####: 2260:              ecma_free_value (stack_top_p[-2]);
    #####: 2261:              stack_top_p[-2] = left_value;
        -: 2262:            }
        -: 2263:
    #####: 2264:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2265:            {
    #####: 2266:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2267:              prefix_size = 4;
        -: 2268:            }
        -: 2269:          }
        -: 2270:
    #####: 2271:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2272:
    #####: 2273:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2274:          {
    #####: 2275:            ecma_free_value (left_value);
    #####: 2276:            continue;
        -: 2277:          }
        -: 2278:
        -: 2279:          ecma_property_value_t *value_p;
    #####: 2280:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2281:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2282:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2283:                                                     NULL);
        -: 2284:
    #####: 2285:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2286:          {
    #####: 2287:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2288:          }
        -: 2289:
    #####: 2290:          value_p->value = ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value),
        -: 2291:                                                       prefix_p,
        -: 2292:                                                       prefix_size);
    #####: 2293:          ecma_free_value (left_value);
    #####: 2294:          continue;
        -: 2295:        }
    #####: 2296:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2297:        {
    #####: 2298:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2299:          continue;
        -: 2300:        }
    #####: 2301:        case VM_OC_PUSH_REST_OBJECT:
        -: 2302:        {
    #####: 2303:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2304:
    #####: 2305:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2306:
    #####: 2307:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2308:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2309:          uint16_t argument_end;
        -: 2310:
    #####: 2311:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2312:          {
    #####: 2313:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2314:          }
        -: 2315:          else
        -: 2316:          {
    #####: 2317:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2318:          }
        -: 2319:
    #####: 2320:          if (arg_list_len < argument_end)
        -: 2321:          {
    #####: 2322:            arg_list_len = argument_end;
        -: 2323:          }
        -: 2324:
    #####: 2325:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end,
        -: 2326:                                                         arg_list_len - argument_end);
        -: 2327:
    #####: 2328:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2329:          *stack_top_p++ = result;
    #####: 2330:          continue;
        -: 2331:        }
    #####: 2332:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2333:        {
    #####: 2334:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2335:
    #####: 2336:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2337:          {
    #####: 2338:            goto error;
        -: 2339:          }
        -: 2340:
    #####: 2341:          uint32_t context_size = (uint32_t) (stack_top_p
    #####: 2342:                                              + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION
    #####: 2343:                                              - VM_LAST_CONTEXT_END ());
    #####: 2344:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2345:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2346:
    #####: 2347:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2348:          stack_top_p[-2] = result;
    #####: 2349:          stack_top_p[-3] = left_value;
        -: 2350:
    #####: 2351:          continue;
        -: 2352:        }
    #####: 2353:        case VM_OC_ITERATOR_STEP:
        -: 2354:        {
    #####: 2355:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2356:
    #####: 2357:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2358:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2359:
    #####: 2360:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2361:
    #####: 2362:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2363:          {
    #####: 2364:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2365:            goto error;
        -: 2366:          }
        -: 2367:
    #####: 2368:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2369:
    #####: 2370:          if (!ecma_is_value_false (result))
        -: 2371:          {
    #####: 2372:            value = ecma_op_iterator_value (result);
    #####: 2373:            ecma_free_value (result);
        -: 2374:
    #####: 2375:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2376:            {
    #####: 2377:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2378:              result = value;
    #####: 2379:              goto error;
        -: 2380:            }
        -: 2381:          }
        -: 2382:          else
        -: 2383:          {
    #####: 2384:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2385:          }
        -: 2386:
    #####: 2387:          *stack_top_p++ = value;
    #####: 2388:          continue;
        -: 2389:        }
    #####: 2390:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2391:        {
    #####: 2392:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2393:
    #####: 2394:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2395:          {
    #####: 2396:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2397:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2398:
    #####: 2399:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2400:            {
    #####: 2401:              goto error;
        -: 2402:            }
        -: 2403:          }
        -: 2404:
    #####: 2405:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2406:                                                                stack_top_p,
        -: 2407:                                                                PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2408:          continue;
        -: 2409:        }
    #####: 2410:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2411:        {
    #####: 2412:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2413:
    #####: 2414:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2415:          {
    #####: 2416:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2417:            continue;
        -: 2418:          }
        -: 2419:
    #####: 2420:          stack_top_p--;
    #####: 2421:          continue;
        -: 2422:        }
    #####: 2423:        case VM_OC_REST_INITIALIZER:
        -: 2424:        {
    #####: 2425:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2426:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2427:
    #####: 2428:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2429:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2430:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2431:          uint32_t index = 0;
        -: 2432:
        -: 2433:          while (true)
    #####: 2434:          {
    #####: 2435:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2436:
    #####: 2437:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2438:            {
    #####: 2439:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2440:              ecma_deref_object (array_p);
    #####: 2441:              goto error;
        -: 2442:            }
        -: 2443:
    #####: 2444:            if (ecma_is_value_false (result))
        -: 2445:            {
    #####: 2446:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2447:              break;
        -: 2448:            }
        -: 2449:
    #####: 2450:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2451:            ecma_free_value (result);
        -: 2452:
    #####: 2453:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2454:            {
    #####: 2455:              ecma_deref_object (array_p);
    #####: 2456:              result = value;
    #####: 2457:              goto error;
        -: 2458:            }
        -: 2459:
    #####: 2460:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2461:            JERRY_ASSERT (set_result);
    #####: 2462:            ecma_free_value (value);
        -: 2463:          }
        -: 2464:
    #####: 2465:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2466:          continue;
        -: 2467:        }
    #####: 2468:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2469:        {
    #####: 2470:          left_value = stack_top_p[-1];
    #####: 2471:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2472:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2473:
    #####: 2474:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2475:          {
    #####: 2476:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2477:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2478:          }
        -: 2479:
    #####: 2480:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2481:          stack_top_p += context_stack_allocation;
    #####: 2482:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2483:
    #####: 2484:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2485:          stack_top_p[-2] = left_value;
        -: 2486:
    #####: 2487:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2488:          {
    #####: 2489:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2490:          }
    #####: 2491:          continue;
        -: 2492:        }
    #####: 2493:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2494:        {
    #####: 2495:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2496:
    #####: 2497:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2498:
    #####: 2499:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2500:          {
    #####: 2501:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2502:          }
        -: 2503:
    #####: 2504:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2505:                                                                stack_top_p,
        -: 2506:                                                                context_stack_allocation);
    #####: 2507:          continue;
        -: 2508:        }
    #####: 2509:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2510:        {
    #####: 2511:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2512:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2513:          {
    #####: 2514:            result = ECMA_VALUE_ERROR;
    #####: 2515:            goto error;
        -: 2516:          }
        -: 2517:
    #####: 2518:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2519:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2520:
    #####: 2521:          left_value = ecma_make_object_value (result_object_p);
    #####: 2522:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2523:
    #####: 2524:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2525:          {
    #####: 2526:            goto error;
        -: 2527:          }
        -: 2528:
    #####: 2529:          ecma_free_value (last_context_end_p[-3]);
    #####: 2530:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2531:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2532:
    #####: 2533:          *stack_top_p++ = left_value;
    #####: 2534:          continue;
        -: 2535:        }
    #####: 2536:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2537:        {
    #####: 2538:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2539:          {
    #####: 2540:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2541:
    #####: 2542:            if (property_key == NULL)
        -: 2543:            {
    #####: 2544:              result = ECMA_VALUE_ERROR;
    #####: 2545:              goto error;
        -: 2546:            }
        -: 2547:
    #####: 2548:            ecma_free_value (left_value);
    #####: 2549:            left_value = ecma_make_string_value (property_key);
        -: 2550:          }
        -: 2551:
    #####: 2552:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2553:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2554:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2555:
    #####: 2556:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2557:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2558:          /* FALLTHRU */
        -: 2559:        }
    #####: 2560:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2561:        {
    #####: 2562:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2563:          ecma_value_t base = last_context_end_p[-2];
        -: 2564:
    #####: 2565:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2566:          {
    #####: 2567:            left_value = *last_context_end_p++;
    #####: 2568:            while (last_context_end_p < stack_top_p)
        -: 2569:            {
    #####: 2570:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2571:              last_context_end_p++;
        -: 2572:            }
    #####: 2573:            stack_top_p--;
        -: 2574:          }
        -: 2575:
    #####: 2576:          result = vm_op_get_value (base, left_value);
        -: 2577:
    #####: 2578:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2579:          {
    #####: 2580:            goto error;
        -: 2581:          }
        -: 2582:
    #####: 2583:          *stack_top_p++ = result;
    #####: 2584:          goto free_left_value;
        -: 2585:        }
    #####: 2586:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2587:        {
    #####: 2588:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2589:          stack_top_p -= arguments_list_len;
        -: 2590:
    #####: 2591:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2592:
    #####: 2593:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2594:          {
    #####: 2595:            result = ECMA_VALUE_ERROR;
    #####: 2596:            goto error;
        -: 2597:          }
        -: 2598:
    #####: 2599:          stack_top_p++;
    #####: 2600:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2601:
    #####: 2602:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2603:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2604:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2605:          return ECMA_VALUE_UNDEFINED;
        -: 2606:        }
    #####: 2607:        case VM_OC_CREATE_GENERATOR:
        -: 2608:        {
    #####: 2609:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2610:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2611:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2612:
        -: 2613:          vm_executable_object_t *executable_object_p;
    #####: 2614:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2615:
    #####: 2616:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2617:        }
    #####: 2618:        case VM_OC_YIELD:
        -: 2619:        {
    #####: 2620:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2621:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2622:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2623:          return *stack_top_p;
        -: 2624:        }
    #####: 2625:        case VM_OC_ASYNC_YIELD:
        -: 2626:        {
    #####: 2627:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2628:
    #####: 2629:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2630:
    #####: 2631:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2632:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2633:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2634:          return ECMA_VALUE_UNDEFINED;
        -: 2635:        }
    #####: 2636:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2637:        {
    #####: 2638:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2639:
    #####: 2640:          JERRY_ASSERT (!(async_generator_object_p->u.cls.u2.executable_obj_flags
        -: 2641:                          & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2642:
        -: 2643:          /* Byte code is executed at the first time. */
    #####: 2644:          left_value = stack_top_p[-1];
    #####: 2645:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2646:
    #####: 2647:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2648:          {
    #####: 2649:            goto error;
        -: 2650:          }
        -: 2651:
    #####: 2652:          ecma_free_value (left_value);
    #####: 2653:          left_value = result;
    #####: 2654:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2655:
    #####: 2656:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2657:          {
    #####: 2658:            goto error;
        -: 2659:          }
        -: 2660:
    #####: 2661:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2662:
    #####: 2663:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2664:          {
    #####: 2665:            goto error;
        -: 2666:          }
        -: 2667:
    #####: 2668:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2669:          *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = left_value;
        -: 2670:
    #####: 2671:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2672:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2673:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2674:          return ECMA_VALUE_UNDEFINED;
        -: 2675:        }
    #####: 2676:        case VM_OC_AWAIT:
        -: 2677:        {
    #####: 2678:          if (JERRY_UNLIKELY (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE)))
        -: 2679:          {
    #####: 2680:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2681:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2682:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2683:
    #####: 2684:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2685:
    #####: 2686:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2687:            {
    #####: 2688:              goto error;
        -: 2689:            }
    #####: 2690:            return result;
        -: 2691:          }
        -: 2692:          /* FALLTHRU */
        -: 2693:        }
        -: 2694:        case VM_OC_GENERATOR_AWAIT:
        -: 2695:        {
    #####: 2696:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2697:
    #####: 2698:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2699:
    #####: 2700:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2701:          {
    #####: 2702:            goto error;
        -: 2703:          }
        -: 2704:
    #####: 2705:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2706:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2707:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2708:          return ECMA_VALUE_UNDEFINED;
        -: 2709:        }
    #####: 2710:        case VM_OC_EXT_RETURN:
        -: 2711:        {
    #####: 2712:          result = left_value;
    #####: 2713:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2714:
    #####: 2715:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2716:
    #####: 2717:          while (stack_top_p > stack_bottom_p)
        -: 2718:          {
    #####: 2719:            ecma_fast_free_value (*(--stack_top_p));
        -: 2720:          }
        -: 2721:
    #####: 2722:          goto error;
        -: 2723:        }
    #####: 2724:        case VM_OC_ASYNC_EXIT:
        -: 2725:        {
    #####: 2726:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2727:
    #####: 2728:          if (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 2729:          {
    #####: 2730:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2731:          }
        -: 2732:          else
        -: 2733:          {
    #####: 2734:            result = *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p);
    #####: 2735:            *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = ECMA_VALUE_UNDEFINED;
        -: 2736:          }
        -: 2737:
    #####: 2738:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2739:
    #####: 2740:          if (context_type == VM_CONTEXT_TRY)
        -: 2741:          {
    #####: 2742:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2743:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2744:          }
        -: 2745:          else
        -: 2746:          {
    #####: 2747:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2748:            left_value = stack_top_p[-2];
        -: 2749:          }
        -: 2750:
    #####: 2751:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2752:          {
    #####: 2753:            ecma_reject_promise (result, left_value);
        -: 2754:          }
        -: 2755:          else
        -: 2756:          {
    #####: 2757:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2758:            ecma_fulfill_promise (result, left_value);
        -: 2759:          }
        -: 2760:
    #####: 2761:          ecma_free_value (left_value);
        -: 2762:
    #####: 2763:          frame_ctx_p->context_depth = 0;
    #####: 2764:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2765:          return result;
        -: 2766:        }
    #####: 2767:        case VM_OC_STRING_CONCAT:
        -: 2768:        {
    #####: 2769:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2770:
    #####: 2771:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2772:          {
    #####: 2773:            result = ECMA_VALUE_ERROR;
    #####: 2774:            goto error;
        -: 2775:          }
    #####: 2776:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2777:
    #####: 2778:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2779:          {
    #####: 2780:            ecma_deref_ecma_string (left_str_p);
    #####: 2781:            result = ECMA_VALUE_ERROR;
    #####: 2782:            goto error;
        -: 2783:          }
        -: 2784:
    #####: 2785:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2786:          ecma_deref_ecma_string (right_str_p);
        -: 2787:
    #####: 2788:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2789:          goto free_both_values;
        -: 2790:        }
    #####: 2791:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2792:        {
    #####: 2793:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2794:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2795:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2796:
    #####: 2797:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2798:          continue;
        -: 2799:        }
    #####: 2800:        case VM_OC_PUSH_NEW_TARGET:
        -: 2801:        {
    #####: 2802:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2803:          if (new_target_object_p == NULL)
        -: 2804:          {
    #####: 2805:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2806:          }
        -: 2807:          else
        -: 2808:          {
    #####: 2809:            ecma_ref_object (new_target_object_p);
    #####: 2810:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2811:          }
    #####: 2812:          continue;
        -: 2813:        }
    #####: 2814:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2815:        {
    #####: 2816:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2817:          {
    #####: 2818:            result = ECMA_VALUE_ERROR;
    #####: 2819:            goto error;
        -: 2820:          }
    #####: 2821:          continue;
        -: 2822:        }
    #####: 2823:        case VM_OC_ASSIGN_SUPER:
        -: 2824:        {
    #####: 2825:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2826:
    #####: 2827:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2828:          {
    #####: 2829:            goto error;
        -: 2830:          }
    #####: 2831:          continue;
        -: 2832:        }
        -: 2833:#endif /* JERRY_ESNEXT */
    #####: 2834:        case VM_OC_PUSH_ELISON:
        -: 2835:        {
    #####: 2836:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2837:          continue;
        -: 2838:        }
    #####: 2839:        case VM_OC_APPEND_ARRAY:
        -: 2840:        {
    #####: 2841:          uint16_t values_length = *byte_code_p++;
    #####: 2842:          stack_top_p -= values_length;
        -: 2843:
        -: 2844:#if JERRY_ESNEXT
    #####: 2845:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2846:          {
    #####: 2847:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2848:          }
        -: 2849:#endif /* JERRY_ESNEXT */
    #####: 2850:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2851:
        -: 2852:#if JERRY_ESNEXT
    #####: 2853:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2854:          {
    #####: 2855:            goto error;
        -: 2856:          }
        -: 2857:#else /* !JERRY_ESNEXT */
        -: 2858:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2859:#endif /* JERRY_ESNEXT */
    #####: 2860:          continue;
        -: 2861:        }
        1: 2862:        case VM_OC_IDENT_REFERENCE:
        -: 2863:        {
        -: 2864:          uint16_t literal_index;
        -: 2865:
        1: 2866:          READ_LITERAL_INDEX (literal_index);
        -: 2867:
        1: 2868:          JERRY_ASSERT (literal_index < ident_end);
        -: 2869:
        1: 2870:          if (literal_index < register_end)
        -: 2871:          {
        1: 2872:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
        1: 2873:            *stack_top_p++ = ecma_make_integer_value (literal_index);
        1: 2874:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2875:          }
        -: 2876:          else
        -: 2877:          {
    #####: 2878:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2879:
    #####: 2880:            ecma_object_t *ref_base_lex_env_p;
        -: 2881:
    #####: 2882:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 2883:                                                     &ref_base_lex_env_p,
        -: 2884:                                                     name_p);
        -: 2885:
    #####: 2886:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2887:            {
    #####: 2888:              goto error;
        -: 2889:            }
        -: 2890:
    #####: 2891:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2892:            ecma_ref_ecma_string (name_p);
    #####: 2893:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2894:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2895:            *stack_top_p++ = result;
        -: 2896:          }
        1: 2897:          continue;
        -: 2898:        }
        1: 2899:        case VM_OC_PROP_GET:
        -: 2900:        {
        1: 2901:          result = vm_op_get_value (left_value, right_value);
        -: 2902:
        1: 2903:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2904:          {
    #####: 2905:            goto error;
        -: 2906:          }
        -: 2907:
        1: 2908:          *stack_top_p++ = result;
        1: 2909:          goto free_both_values;
        -: 2910:        }
        1: 2911:        case VM_OC_PROP_REFERENCE:
        -: 2912:        {
        -: 2913:          /* Forms with reference requires preserving the base and offset. */
        -: 2914:
        1: 2915:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2916:          {
    #####: 2917:            left_value = stack_top_p[-2];
    #####: 2918:            right_value = stack_top_p[-1];
        -: 2919:          }
        1: 2920:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2921:          {
    #####: 2922:            *stack_top_p++ = left_value;
    #####: 2923:            right_value = left_value;
    #####: 2924:            left_value = stack_top_p[-2];
        -: 2925:          }
        -: 2926:          else
        -: 2927:          {
        1: 2928:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2929:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
        1: 2930:            *stack_top_p++ = left_value;
        1: 2931:            *stack_top_p++ = right_value;
        -: 2932:          }
        -: 2933:          /* FALLTHRU */
        -: 2934:        }
        -: 2935:        case VM_OC_PROP_PRE_INCR:
        -: 2936:        case VM_OC_PROP_PRE_DECR:
        -: 2937:        case VM_OC_PROP_POST_INCR:
        -: 2938:        case VM_OC_PROP_POST_DECR:
        -: 2939:        {
        1: 2940:          result = vm_op_get_value (left_value,
        -: 2941:                                    right_value);
        -: 2942:
        1: 2943:          if (opcode < CBC_PRE_INCR)
        -: 2944:          {
        1: 2945:            left_value = ECMA_VALUE_UNDEFINED;
        1: 2946:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2947:          }
        -: 2948:
        1: 2949:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2950:          {
    #####: 2951:            goto error;
        -: 2952:          }
        -: 2953:
        1: 2954:          if (opcode < CBC_PRE_INCR)
        -: 2955:          {
        1: 2956:            break;
        -: 2957:          }
        -: 2958:
    #####: 2959:          stack_top_p += 2;
    #####: 2960:          left_value = result;
    #####: 2961:          right_value = ECMA_VALUE_UNDEFINED;
        -: 2962:          /* FALLTHRU */
        -: 2963:        }
    #####: 2964:        case VM_OC_PRE_INCR:
        -: 2965:        case VM_OC_PRE_DECR:
        -: 2966:        case VM_OC_POST_INCR:
        -: 2967:        case VM_OC_POST_DECR:
        -: 2968:        {
    #####: 2969:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
    #####: 2970:          ecma_number_t result_number;
        -: 2971:
    #####: 2972:          byte_code_p = byte_code_start_p + 1;
        -: 2973:
    #####: 2974:          if (ecma_is_value_integer_number (left_value))
        -: 2975:          {
    #####: 2976:            result = left_value;
    #####: 2977:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2978:
    #####: 2979:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
    #####: 2980:            ecma_integer_value_t int_increase = 0;
        -: 2981:
    #####: 2982:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 2983:            {
    #####: 2984:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 2985:              {
    #####: 2986:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 2987:              }
        -: 2988:            }
    #####: 2989:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 2990:            {
    #####: 2991:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 2992:            }
        -: 2993:
    #####: 2994:            if (JERRY_LIKELY (int_increase != 0))
        -: 2995:            {
        -: 2996:              /* Postfix operators require the unmodifed number value. */
    #####: 2997:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 2998:              {
    #####: 2999:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3000:              }
        -: 3001:
    #####: 3002:              result = (ecma_value_t) (int_value + int_increase);
    #####: 3003:              break;
        -: 3004:            }
    #####: 3005:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3006:          }
    #####: 3007:          else if (ecma_is_value_float_number (left_value))
        -: 3008:          {
    #####: 3009:            result = left_value;
    #####: 3010:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3011:            result_number = ecma_get_number_from_value (result);
        -: 3012:          }
        -: 3013:          else
        -: 3014:          {
    #####: 3015:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3016:
    #####: 3017:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3018:            {
    #####: 3019:              goto error;
        -: 3020:            }
        -: 3021:
    #####: 3022:            ecma_free_value (left_value);
    #####: 3023:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3024:
        -: 3025:#if JERRY_BUILTIN_BIGINT
    #####: 3026:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3027:            {
    #####: 3028:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3029:
    #####: 3030:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3031:              {
    #####: 3032:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3033:              }
        -: 3034:
        -: 3035:              /* Postfix operators require the unmodifed number value. */
    #####: 3036:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3037:              {
    #####: 3038:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3039:
    #####: 3040:                result = ecma_bigint_unary (result, operation_type);
        -: 3041:              }
        -: 3042:              else
        -: 3043:              {
    #####: 3044:                ecma_value_t original_value = result;
    #####: 3045:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3046:                ecma_free_value (original_value);
        -: 3047:              }
        -: 3048:
    #####: 3049:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3050:              {
    #####: 3051:                goto error;
        -: 3052:              }
    #####: 3053:              break;
        -: 3054:            }
        -: 3055:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3056:
    #####: 3057:            result = ecma_make_number_value (result_number);
        -: 3058:          }
        -: 3059:
    #####: 3060:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3061:
    #####: 3062:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3063:          {
        -: 3064:            /* For decrement operators */
    #####: 3065:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3066:          }
        -: 3067:
        -: 3068:          /* Postfix operators require the unmodifed number value. */
    #####: 3069:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3070:          {
    #####: 3071:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3072:
    #####: 3073:            result = ecma_make_number_value (result_number + increase);
    #####: 3074:            break;
        -: 3075:          }
        -: 3076:
    #####: 3077:          if (ecma_is_value_integer_number (result))
        -: 3078:          {
    #####: 3079:            result = ecma_make_number_value (result_number + increase);
        -: 3080:          }
        -: 3081:          else
        -: 3082:          {
    #####: 3083:            result = ecma_update_float_number (result, result_number + increase);
        -: 3084:          }
    #####: 3085:          break;
        -: 3086:        }
        3: 3087:        case VM_OC_ASSIGN:
        -: 3088:        {
        3: 3089:          result = left_value;
        3: 3090:          left_value = ECMA_VALUE_UNDEFINED;
        3: 3091:          break;
        -: 3092:        }
        4: 3093:        case VM_OC_MOV_IDENT:
        -: 3094:        {
        -: 3095:          uint32_t literal_index;
        -: 3096:
        4: 3097:          READ_LITERAL_INDEX (literal_index);
        -: 3098:
        4: 3099:          JERRY_ASSERT (literal_index < register_end);
        4: 3100:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3101:
        4: 3102:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        4: 3103:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
        4: 3104:          continue;
        -: 3105:        }
    #####: 3106:        case VM_OC_ASSIGN_PROP:
        -: 3107:        {
    #####: 3108:          result = stack_top_p[-1];
    #####: 3109:          stack_top_p[-1] = left_value;
    #####: 3110:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3111:          break;
        -: 3112:        }
    #####: 3113:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3114:        {
    #####: 3115:          result = stack_top_p[-1];
    #####: 3116:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 3117:          *stack_top_p++ = left_value;
    #####: 3118:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3119:          break;
        -: 3120:        }
    #####: 3121:        case VM_OC_RETURN_FUNCTION_END:
        -: 3122:        {
    #####: 3123:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_SCRIPT)
        -: 3124:          {
    #####: 3125:            result = VM_GET_REGISTER (frame_ctx_p, 0);
    #####: 3126:            VM_GET_REGISTERS (frame_ctx_p)[0] = ECMA_VALUE_UNDEFINED;
        -: 3127:          }
        -: 3128:          else
        -: 3129:          {
    #####: 3130:            result = ECMA_VALUE_UNDEFINED;
        -: 3131:          }
        -: 3132:
    #####: 3133:          goto error;
        -: 3134:        }
        1: 3135:        case VM_OC_RETURN:
        -: 3136:        {
        1: 3137:          JERRY_ASSERT (opcode == CBC_RETURN
        -: 3138:                        || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3139:
        1: 3140:          result = left_value;
        1: 3141:          left_value = ECMA_VALUE_UNDEFINED;
        1: 3142:          goto error;
        -: 3143:        }
    #####: 3144:        case VM_OC_THROW:
        -: 3145:        {
    #####: 3146:          jcontext_raise_exception (left_value);
        -: 3147:
    #####: 3148:          result = ECMA_VALUE_ERROR;
    #####: 3149:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3150:          goto error;
        -: 3151:        }
    #####: 3152:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3153:        {
    #####: 3154:          result = ecma_raise_reference_error (ECMA_ERR_MSG ("Undefined reference"));
    #####: 3155:          goto error;
        -: 3156:        }
    #####: 3157:        case VM_OC_EVAL:
        -: 3158:        {
    #####: 3159:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3160:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3161:                        || (*byte_code_p == CBC_EXT_OPCODE
        -: 3162:                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3163:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3164:          continue;
        -: 3165:        }
        1: 3166:        case VM_OC_CALL:
        -: 3167:        {
        1: 3168:          frame_ctx_p->call_operation = VM_EXEC_CALL;
        1: 3169:          frame_ctx_p->byte_code_p = byte_code_start_p;
        1: 3170:          frame_ctx_p->stack_top_p = stack_top_p;
        1: 3171:          return ECMA_VALUE_UNDEFINED;
        -: 3172:        }
        2: 3173:        case VM_OC_NEW:
        -: 3174:        {
        2: 3175:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
        2: 3176:          frame_ctx_p->byte_code_p = byte_code_start_p;
        2: 3177:          frame_ctx_p->stack_top_p = stack_top_p;
        2: 3178:          return ECMA_VALUE_UNDEFINED;
        -: 3179:        }
        1: 3180:        case VM_OC_ERROR:
        -: 3181:        {
        1: 3182:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3183:#if JERRY_DEBUGGER
        -: 3184:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3185:#endif /* JERRY_DEBUGGER */
        -: 3186:
        1: 3187:          result = ECMA_VALUE_ERROR;
        1: 3188:          goto error;
        -: 3189:        }
    #####: 3190:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3191:        {
    #####: 3192:          ecma_value_t this_value = stack_top_p[-3];
        -: 3193:
    #####: 3194:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3195:          {
        -: 3196:            /* Lexical environment cannot be 'this' value. */
    #####: 3197:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3198:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3199:          }
    #####: 3200:          else if (vm_get_implicit_this_value (&this_value))
        -: 3201:          {
    #####: 3202:            ecma_free_value (stack_top_p[-3]);
    #####: 3203:            stack_top_p[-3] = this_value;
        -: 3204:          }
        -: 3205:
    #####: 3206:          continue;
        -: 3207:        }
    #####: 3208:        case VM_OC_PROP_DELETE:
        -: 3209:        {
    #####: 3210:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3211:
    #####: 3212:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3213:          {
    #####: 3214:            goto error;
        -: 3215:          }
        -: 3216:
    #####: 3217:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3218:
    #####: 3219:          *stack_top_p++ = result;
    #####: 3220:          goto free_both_values;
        -: 3221:        }
    #####: 3222:        case VM_OC_DELETE:
        -: 3223:        {
        -: 3224:          uint16_t literal_index;
        -: 3225:
    #####: 3226:          READ_LITERAL_INDEX (literal_index);
        -: 3227:
    #####: 3228:          if (literal_index < register_end)
        -: 3229:          {
    #####: 3230:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3231:            continue;
        -: 3232:          }
        -: 3233:
    #####: 3234:          result = vm_op_delete_var (literal_start_p[literal_index],
        -: 3235:                                     frame_ctx_p->lex_env_p);
        -: 3236:
    #####: 3237:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3238:          {
    #####: 3239:            goto error;
        -: 3240:          }
        -: 3241:
    #####: 3242:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3243:
    #####: 3244:          *stack_top_p++ = result;
    #####: 3245:          continue;
        -: 3246:        }
    #####: 3247:        case VM_OC_JUMP:
        -: 3248:        {
    #####: 3249:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 3250:          continue;
        -: 3251:        }
    #####: 3252:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3253:        {
    #####: 3254:          ecma_value_t value = *(--stack_top_p);
        -: 3255:
    #####: 3256:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3257:
    #####: 3258:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3259:          {
    #####: 3260:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3261:            ecma_free_value (*--stack_top_p);
        -: 3262:          }
    #####: 3263:          ecma_free_value (value);
    #####: 3264:          continue;
        -: 3265:        }
    #####: 3266:        case VM_OC_BRANCH_IF_TRUE:
        -: 3267:        case VM_OC_BRANCH_IF_FALSE:
        -: 3268:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3269:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3270:        {
    #####: 3271:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 3272:          ecma_value_t value = *(--stack_top_p);
        -: 3273:
    #####: 3274:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3275:
    #####: 3276:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3277:          {
    #####: 3278:            boolean_value = !boolean_value;
        -: 3279:          }
        -: 3280:
    #####: 3281:          if (boolean_value)
        -: 3282:          {
    #####: 3283:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3284:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3285:            {
        -: 3286:              /* "Push" the value back to the stack. */
    #####: 3287:              ++stack_top_p;
    #####: 3288:              continue;
        -: 3289:            }
        -: 3290:          }
        -: 3291:
    #####: 3292:          ecma_fast_free_value (value);
    #####: 3293:          continue;
        -: 3294:        }
        -: 3295:#if JERRY_ESNEXT
    #####: 3296:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3297:        {
    #####: 3298:          left_value = stack_top_p[-1];
        -: 3299:
    #####: 3300:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3301:          {
    #####: 3302:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3303:            continue;
        -: 3304:          }
    #####: 3305:          --stack_top_p;
    #####: 3306:          continue;
        -: 3307:        }
        -: 3308:#endif /* JERRY_ESNEXT */
    #####: 3309:        case VM_OC_PLUS:
        -: 3310:        case VM_OC_MINUS:
        -: 3311:        {
    #####: 3312:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3313:
    #####: 3314:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3315:          {
    #####: 3316:            goto error;
        -: 3317:          }
        -: 3318:
    #####: 3319:          *stack_top_p++ = result;
    #####: 3320:          goto free_left_value;
        -: 3321:        }
    #####: 3322:        case VM_OC_NOT:
        -: 3323:        {
    #####: 3324:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3325:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3326:          goto free_left_value;
        -: 3327:        }
    #####: 3328:        case VM_OC_BIT_NOT:
        -: 3329:        {
        -: 3330:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3331:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3332:
    #####: 3333:          if (ecma_is_value_integer_number (left_value))
        -: 3334:          {
    #####: 3335:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3336:            goto free_left_value;
        -: 3337:          }
        -: 3338:
    #####: 3339:          result = do_number_bitwise_not (left_value);
        -: 3340:
    #####: 3341:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3342:          {
    #####: 3343:            goto error;
        -: 3344:          }
        -: 3345:
    #####: 3346:          *stack_top_p++ = result;
    #####: 3347:          goto free_left_value;
        -: 3348:        }
    #####: 3349:        case VM_OC_VOID:
        -: 3350:        {
    #####: 3351:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3352:          goto free_left_value;
        -: 3353:        }
    #####: 3354:        case VM_OC_TYPEOF_IDENT:
        -: 3355:        {
        -: 3356:          uint16_t literal_index;
        -: 3357:
    #####: 3358:          READ_LITERAL_INDEX (literal_index);
        -: 3359:
    #####: 3360:          JERRY_ASSERT (literal_index < ident_end);
        -: 3361:
    #####: 3362:          if (literal_index < register_end)
        -: 3363:          {
    #####: 3364:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3365:          }
        -: 3366:          else
        -: 3367:          {
    #####: 3368:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3369:
    #####: 3370:            ecma_object_t *ref_base_lex_env_p;
        -: 3371:
    #####: 3372:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 3373:                                                     &ref_base_lex_env_p,
        -: 3374:                                                     name_p);
        -: 3375:
    #####: 3376:            if (ref_base_lex_env_p == NULL)
        -: 3377:            {
    #####: 3378:              jcontext_release_exception ();
    #####: 3379:              result = ECMA_VALUE_UNDEFINED;
        -: 3380:            }
    #####: 3381:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3382:            {
    #####: 3383:              goto error;
        -: 3384:            }
        -: 3385:
    #####: 3386:            left_value = result;
        -: 3387:          }
        -: 3388:          /* FALLTHRU */
        -: 3389:        }
        -: 3390:        case VM_OC_TYPEOF:
        -: 3391:        {
    #####: 3392:          result = opfunc_typeof (left_value);
        -: 3393:
    #####: 3394:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3395:          {
    #####: 3396:            goto error;
        -: 3397:          }
        -: 3398:
    #####: 3399:          *stack_top_p++ = result;
    #####: 3400:          goto free_left_value;
        -: 3401:        }
        1: 3402:        case VM_OC_ADD:
        -: 3403:        {
        1: 3404:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3405:          {
    #####: 3406:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3407:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3408:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3409:            continue;
        -: 3410:          }
        -: 3411:
        1: 3412:          if (ecma_is_value_float_number (left_value)
    #####: 3413:              && ecma_is_value_number (right_value))
        -: 3414:          {
    #####: 3415:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +
    #####: 3416:                                       ecma_get_number_from_value (right_value));
        -: 3417:
    #####: 3418:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3419:            ecma_free_number (right_value);
    #####: 3420:            continue;
        -: 3421:          }
        -: 3422:
        1: 3423:          if (ecma_is_value_float_number (right_value)
    #####: 3424:              && ecma_is_value_integer_number (left_value))
        -: 3425:          {
    #####: 3426:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +
    #####: 3427:                                       ecma_get_float_from_value (right_value));
        -: 3428:
    #####: 3429:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3430:            continue;
        -: 3431:          }
        -: 3432:
        1: 3433:          result = opfunc_addition (left_value, right_value);
        -: 3434:
        1: 3435:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3436:          {
    #####: 3437:            goto error;
        -: 3438:          }
        -: 3439:
        1: 3440:          *stack_top_p++ = result;
        1: 3441:          goto free_both_values;
        -: 3442:        }
    #####: 3443:        case VM_OC_SUB:
        -: 3444:        {
        -: 3445:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX
        -: 3446:                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3447:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3448:
    #####: 3449:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3450:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3451:
    #####: 3452:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3453:          {
    #####: 3454:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3455:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3456:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3457:            continue;
        -: 3458:          }
        -: 3459:
    #####: 3460:          if (ecma_is_value_float_number (left_value)
    #####: 3461:              && ecma_is_value_number (right_value))
        -: 3462:          {
    #####: 3463:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -
    #####: 3464:                                       ecma_get_number_from_value (right_value));
        -: 3465:
    #####: 3466:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3467:            ecma_free_number (right_value);
    #####: 3468:            continue;
        -: 3469:          }
        -: 3470:
    #####: 3471:          if (ecma_is_value_float_number (right_value)
    #####: 3472:              && ecma_is_value_integer_number (left_value))
        -: 3473:          {
    #####: 3474:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -
    #####: 3475:                                       ecma_get_float_from_value (right_value));
        -: 3476:
    #####: 3477:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3478:            continue;
        -: 3479:          }
        -: 3480:
    #####: 3481:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,
        -: 3482:                                         left_value,
        -: 3483:                                         right_value);
        -: 3484:
    #####: 3485:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3486:          {
    #####: 3487:            goto error;
        -: 3488:          }
        -: 3489:
    #####: 3490:          *stack_top_p++ = result;
    #####: 3491:          goto free_both_values;
        -: 3492:        }
    #####: 3493:        case VM_OC_MUL:
        -: 3494:        {
    #####: 3495:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3496:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3497:
        -: 3498:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3499:                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3500:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3501:
    #####: 3502:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3503:          {
    #####: 3504:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3505:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3506:
    #####: 3507:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer
    #####: 3508:                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3509:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer
    #####: 3510:                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3511:                && left_integer != 0
    #####: 3512:                && right_integer != 0)
        -: 3513:            {
    #####: 3514:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3515:              continue;
        -: 3516:            }
        -: 3517:
    #####: 3518:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3519:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3520:            continue;
        -: 3521:          }
        -: 3522:
    #####: 3523:          if (ecma_is_value_float_number (left_value)
    #####: 3524:              && ecma_is_value_number (right_value))
        -: 3525:          {
    #####: 3526:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *
    #####: 3527:                                       ecma_get_number_from_value (right_value));
        -: 3528:
    #####: 3529:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3530:            ecma_free_number (right_value);
    #####: 3531:            continue;
        -: 3532:          }
        -: 3533:
    #####: 3534:          if (ecma_is_value_float_number (right_value)
    #####: 3535:              && ecma_is_value_integer_number (left_value))
        -: 3536:          {
    #####: 3537:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *
    #####: 3538:                                       ecma_get_float_from_value (right_value));
        -: 3539:
    #####: 3540:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3541:            continue;
        -: 3542:          }
        -: 3543:
    #####: 3544:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,
        -: 3545:                                         left_value,
        -: 3546:                                         right_value);
        -: 3547:
    #####: 3548:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3549:          {
    #####: 3550:            goto error;
        -: 3551:          }
        -: 3552:
    #####: 3553:          *stack_top_p++ = result;
    #####: 3554:          goto free_both_values;
        -: 3555:        }
    #####: 3556:        case VM_OC_DIV:
        -: 3557:        {
    #####: 3558:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3559:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3560:
    #####: 3561:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,
        -: 3562:                                         left_value,
        -: 3563:                                         right_value);
        -: 3564:
    #####: 3565:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3566:          {
    #####: 3567:            goto error;
        -: 3568:          }
        -: 3569:
    #####: 3570:          *stack_top_p++ = result;
    #####: 3571:          goto free_both_values;
        -: 3572:        }
    #####: 3573:        case VM_OC_MOD:
        -: 3574:        {
    #####: 3575:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3576:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3577:
    #####: 3578:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3579:          {
    #####: 3580:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3581:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3582:
    #####: 3583:            if (right_integer != 0)
        -: 3584:            {
    #####: 3585:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3586:
    #####: 3587:              if (mod_result != 0 || left_integer >= 0)
        -: 3588:              {
    #####: 3589:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3590:                continue;
        -: 3591:              }
        -: 3592:            }
        -: 3593:          }
        -: 3594:
    #####: 3595:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,
        -: 3596:                                         left_value,
        -: 3597:                                         right_value);
        -: 3598:
    #####: 3599:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3600:          {
    #####: 3601:            goto error;
        -: 3602:          }
        -: 3603:
    #####: 3604:          *stack_top_p++ = result;
    #####: 3605:          goto free_both_values;
        -: 3606:        }
        -: 3607:#if JERRY_ESNEXT
    #####: 3608:        case VM_OC_EXP:
        -: 3609:        {
    #####: 3610:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,
        -: 3611:                                         left_value,
        -: 3612:                                         right_value);
        -: 3613:
    #####: 3614:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3615:          {
    #####: 3616:            goto error;
        -: 3617:          }
        -: 3618:
    #####: 3619:          *stack_top_p++ = result;
    #####: 3620:          goto free_both_values;
        -: 3621:        }
        -: 3622:#endif /* JERRY_ESNEXT */
    #####: 3623:        case VM_OC_EQUAL:
        -: 3624:        {
    #####: 3625:          result = opfunc_equality (left_value, right_value);
        -: 3626:
    #####: 3627:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3628:          {
    #####: 3629:            goto error;
        -: 3630:          }
        -: 3631:
    #####: 3632:          *stack_top_p++ = result;
    #####: 3633:          goto free_both_values;
        -: 3634:        }
    #####: 3635:        case VM_OC_NOT_EQUAL:
        -: 3636:        {
    #####: 3637:          result = opfunc_equality (left_value, right_value);
        -: 3638:
    #####: 3639:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3640:          {
    #####: 3641:            goto error;
        -: 3642:          }
        -: 3643:
    #####: 3644:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3645:          goto free_both_values;
        -: 3646:        }
    #####: 3647:        case VM_OC_STRICT_EQUAL:
        -: 3648:        {
    #####: 3649:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3650:
    #####: 3651:          result = ecma_make_boolean_value (is_equal);
        -: 3652:
    #####: 3653:          *stack_top_p++ = result;
    #####: 3654:          goto free_both_values;
        -: 3655:        }
    #####: 3656:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3657:        {
    #####: 3658:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3659:
    #####: 3660:          result = ecma_make_boolean_value (!is_equal);
        -: 3661:
    #####: 3662:          *stack_top_p++ = result;
    #####: 3663:          goto free_both_values;
        -: 3664:        }
    #####: 3665:        case VM_OC_BIT_OR:
        -: 3666:        {
        -: 3667:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3668:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3669:
    #####: 3670:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3671:          {
    #####: 3672:            *stack_top_p++ = left_value | right_value;
    #####: 3673:            continue;
        -: 3674:          }
        -: 3675:
    #####: 3676:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,
        -: 3677:                                            left_value,
        -: 3678:                                            right_value);
        -: 3679:
    #####: 3680:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3681:          {
    #####: 3682:            goto error;
        -: 3683:          }
        -: 3684:
    #####: 3685:          *stack_top_p++ = result;
    #####: 3686:          goto free_both_values;
        -: 3687:        }
    #####: 3688:        case VM_OC_BIT_XOR:
        -: 3689:        {
        -: 3690:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3691:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3692:
    #####: 3693:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3694:          {
    #####: 3695:            *stack_top_p++ = left_value ^ right_value;
    #####: 3696:            continue;
        -: 3697:          }
        -: 3698:
    #####: 3699:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,
        -: 3700:                                            left_value,
        -: 3701:                                            right_value);
        -: 3702:
    #####: 3703:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3704:          {
    #####: 3705:            goto error;
        -: 3706:          }
        -: 3707:
    #####: 3708:          *stack_top_p++ = result;
    #####: 3709:          goto free_both_values;
        -: 3710:        }
    #####: 3711:        case VM_OC_BIT_AND:
        -: 3712:        {
        -: 3713:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3714:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3715:
    #####: 3716:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3717:          {
    #####: 3718:            *stack_top_p++ = left_value & right_value;
    #####: 3719:            continue;
        -: 3720:          }
        -: 3721:
    #####: 3722:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,
        -: 3723:                                            left_value,
        -: 3724:                                            right_value);
        -: 3725:
    #####: 3726:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3727:          {
    #####: 3728:            goto error;
        -: 3729:          }
        -: 3730:
    #####: 3731:          *stack_top_p++ = result;
    #####: 3732:          goto free_both_values;
        -: 3733:        }
    #####: 3734:        case VM_OC_LEFT_SHIFT:
        -: 3735:        {
        -: 3736:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3737:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3738:
    #####: 3739:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3740:          {
    #####: 3741:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3742:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3743:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 3744:            continue;
        -: 3745:          }
        -: 3746:
    #####: 3747:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,
        -: 3748:                                            left_value,
        -: 3749:                                            right_value);
        -: 3750:
    #####: 3751:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3752:          {
    #####: 3753:            goto error;
        -: 3754:          }
        -: 3755:
    #####: 3756:          *stack_top_p++ = result;
    #####: 3757:          goto free_both_values;
        -: 3758:        }
    #####: 3759:        case VM_OC_RIGHT_SHIFT:
        -: 3760:        {
        -: 3761:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3762:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3763:
    #####: 3764:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3765:          {
    #####: 3766:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3767:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3768:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3769:            continue;
        -: 3770:          }
        -: 3771:
    #####: 3772:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,
        -: 3773:                                            left_value,
        -: 3774:                                            right_value);
        -: 3775:
    #####: 3776:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3777:          {
    #####: 3778:            goto error;
        -: 3779:          }
        -: 3780:
    #####: 3781:          *stack_top_p++ = result;
    #####: 3782:          goto free_both_values;
        -: 3783:        }
    #####: 3784:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3785:        {
        -: 3786:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3787:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3788:
    #####: 3789:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3790:          {
    #####: 3791:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3792:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3793:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3794:            continue;
        -: 3795:          }
        -: 3796:
    #####: 3797:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,
        -: 3798:                                            left_value,
        -: 3799:                                            right_value);
        -: 3800:
    #####: 3801:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3802:          {
    #####: 3803:            goto error;
        -: 3804:          }
        -: 3805:
    #####: 3806:          *stack_top_p++ = result;
    #####: 3807:          goto free_both_values;
        -: 3808:        }
    #####: 3809:        case VM_OC_LESS:
        -: 3810:        {
    #####: 3811:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3812:          {
    #####: 3813:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3814:#if !JERRY_VM_EXEC_STOP
        -: 3815:            /* This is a lookahead to the next opcode to improve performance.
        -: 3816:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
    #####: 3817:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3818:            {
    #####: 3819:              byte_code_start_p = byte_code_p++;
    #####: 3820:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
    #####: 3821:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3822:
    #####: 3823:              if (is_less)
        -: 3824:              {
    #####: 3825:                branch_offset = *(byte_code_p++);
        -: 3826:
    #####: 3827:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3828:                {
    #####: 3829:                  branch_offset <<= 8;
    #####: 3830:                  branch_offset |= *(byte_code_p++);
    #####: 3831:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3832:                  {
    #####: 3833:                    branch_offset <<= 8;
    #####: 3834:                    branch_offset |= *(byte_code_p++);
        -: 3835:                  }
        -: 3836:                }
        -: 3837:
        -: 3838:                /* Note: The opcode is a backward branch. */
    #####: 3839:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3840:              }
        -: 3841:              else
        -: 3842:              {
    #####: 3843:                byte_code_p += branch_offset_length;
        -: 3844:              }
        -: 3845:
    #####: 3846:              continue;
        -: 3847:            }
        -: 3848:#endif /* !JERRY_VM_EXEC_STOP */
    #####: 3849:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3850:            continue;
        -: 3851:          }
        -: 3852:
    #####: 3853:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3854:          {
    #####: 3855:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3856:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3857:
    #####: 3858:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3859:            goto free_both_values;
        -: 3860:          }
        -: 3861:
    #####: 3862:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3863:
    #####: 3864:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3865:          {
    #####: 3866:            goto error;
        -: 3867:          }
        -: 3868:
    #####: 3869:          *stack_top_p++ = result;
    #####: 3870:          goto free_both_values;
        -: 3871:        }
    #####: 3872:        case VM_OC_GREATER:
        -: 3873:        {
    #####: 3874:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3875:          {
    #####: 3876:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3877:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3878:
    #####: 3879:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3880:            continue;
        -: 3881:          }
        -: 3882:
    #####: 3883:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3884:          {
    #####: 3885:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3886:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3887:
    #####: 3888:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3889:            goto free_both_values;
        -: 3890:          }
        -: 3891:
    #####: 3892:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3893:
    #####: 3894:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3895:          {
    #####: 3896:            goto error;
        -: 3897:          }
        -: 3898:
    #####: 3899:          *stack_top_p++ = result;
    #####: 3900:          goto free_both_values;
        -: 3901:        }
    #####: 3902:        case VM_OC_LESS_EQUAL:
        -: 3903:        {
    #####: 3904:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3905:          {
    #####: 3906:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3907:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3908:
    #####: 3909:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3910:            continue;
        -: 3911:          }
        -: 3912:
    #####: 3913:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3914:          {
    #####: 3915:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3916:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3917:
    #####: 3918:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3919:            goto free_both_values;
        -: 3920:          }
        -: 3921:
    #####: 3922:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3923:
    #####: 3924:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3925:          {
    #####: 3926:            goto error;
        -: 3927:          }
        -: 3928:
    #####: 3929:          *stack_top_p++ = result;
    #####: 3930:          goto free_both_values;
        -: 3931:        }
    #####: 3932:        case VM_OC_GREATER_EQUAL:
        -: 3933:        {
    #####: 3934:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3935:          {
    #####: 3936:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3937:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3938:
    #####: 3939:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3940:            continue;
        -: 3941:          }
        -: 3942:
    #####: 3943:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3944:          {
    #####: 3945:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3946:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3947:
    #####: 3948:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3949:            goto free_both_values;
        -: 3950:          }
        -: 3951:
    #####: 3952:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3953:
    #####: 3954:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3955:          {
    #####: 3956:            goto error;
        -: 3957:          }
        -: 3958:
    #####: 3959:          *stack_top_p++ = result;
    #####: 3960:          goto free_both_values;
        -: 3961:        }
    #####: 3962:        case VM_OC_IN:
        -: 3963:        {
    #####: 3964:          result = opfunc_in (left_value, right_value);
        -: 3965:
    #####: 3966:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3967:          {
    #####: 3968:            goto error;
        -: 3969:          }
        -: 3970:
    #####: 3971:          *stack_top_p++ = result;
    #####: 3972:          goto free_both_values;
        -: 3973:        }
    #####: 3974:        case VM_OC_INSTANCEOF:
        -: 3975:        {
    #####: 3976:          result = opfunc_instanceof (left_value, right_value);
        -: 3977:
    #####: 3978:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3979:          {
    #####: 3980:            goto error;
        -: 3981:          }
        -: 3982:
    #####: 3983:          *stack_top_p++ = result;
    #####: 3984:          goto free_both_values;
        -: 3985:        }
    #####: 3986:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3987:        {
        -: 3988:#if JERRY_ESNEXT
        -: 3989:          ecma_value_t *stack_context_top_p;
    #####: 3990:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3991:
    #####: 3992:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 3993:
    #####: 3994:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 3995:          {
    #####: 3996:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3997:
    #####: 3998:            if (stack_context_top_p != stack_top_p)
        -: 3999:            {
        -: 4000:               /* Preserve the value of switch statement. */
    #####: 4001:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 4002:            }
        -: 4003:
    #####: 4004:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 4005:
    #####: 4006:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 4007:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 4008:          }
        -: 4009:          else
        -: 4010:          {
    #####: 4011:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 4012:
    #####: 4013:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4014:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4015:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4016:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4017:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4018:
    #####: 4019:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4020:
    #####: 4021:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4022:          }
        -: 4023:#else /* !JERRY_ESNEXT */
        -: 4024:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4025:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4026:
    #####: 4027:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4028:#endif /* JERRY_ESNEXT */
        -: 4029:
    #####: 4030:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4031:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4032:
    #####: 4033:          continue;
        -: 4034:        }
    #####: 4035:        case VM_OC_WITH:
        -: 4036:        {
    #####: 4037:          ecma_value_t value = *(--stack_top_p);
        -: 4038:          ecma_object_t *object_p;
        -: 4039:          ecma_object_t *with_env_p;
        -: 4040:
    #####: 4041:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4042:
    #####: 4043:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4044:
    #####: 4045:          result = ecma_op_to_object (value);
    #####: 4046:          ecma_free_value (value);
        -: 4047:
    #####: 4048:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4049:          {
    #####: 4050:            goto error;
        -: 4051:          }
        -: 4052:
    #####: 4053:          object_p = ecma_get_object_from_value (result);
        -: 4054:
    #####: 4055:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4056:          ecma_deref_object (object_p);
        -: 4057:
    #####: 4058:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4059:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4060:
    #####: 4061:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4062:
    #####: 4063:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4064:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4065:          continue;
        -: 4066:        }
        1: 4067:        case VM_OC_FOR_IN_INIT:
        -: 4068:        {
        1: 4069:          ecma_value_t value = *(--stack_top_p);
        -: 4070:
        1: 4071:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4072:
        1: 4073:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
        1: 4074:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
        1: 4075:          ecma_free_value (value);
        -: 4076:
        1: 4077:          if (prop_names_p == NULL)
        -: 4078:          {
        -: 4079:#if JERRY_ESNEXT
    #####: 4080:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4081:            {
    #####: 4082:              result = expr_obj_value;
    #####: 4083:              goto error;
        -: 4084:            }
        -: 4085:#endif /* JERRY_ESNEXT */
        -: 4086:
        -: 4087:            /* The collection is already released */
    #####: 4088:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4089:            continue;
        -: 4090:          }
        -: 4091:
        1: 4092:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4093:
        1: 4094:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
        1: 4095:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        1: 4096:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
        1: 4097:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
        1: 4098:          stack_top_p[-3] = 0;
        1: 4099:          stack_top_p[-4] = expr_obj_value;
        -: 4100:
        -: 4101:#if JERRY_ESNEXT
        1: 4102:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4103:          {
        -: 4104:            /* No need to duplicate the first context. */
    #####: 4105:            byte_code_p += 2;
        -: 4106:          }
        -: 4107:#endif /* JERRY_ESNEXT */
        1: 4108:          continue;
        -: 4109:        }
        1: 4110:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4111:        {
        1: 4112:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4113:
        -: 4114:          ecma_collection_t *collection_p;
        1: 4115:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4116:
        1: 4117:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4118:
        1: 4119:          uint32_t index = context_top_p[-3];
        1: 4120:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4121:
        1: 4122:          *stack_top_p++ = buffer_p[index];
        1: 4123:          context_top_p[-3]++;
        1: 4124:          continue;
        -: 4125:        }
        1: 4126:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4127:        {
        1: 4128:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4129:
        -: 4130:          ecma_collection_t *collection_p;
        1: 4131:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4132:
        1: 4133:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4134:
        1: 4135:          ecma_value_t *buffer_p = collection_p->buffer_p;
        1: 4136:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
        1: 4137:          uint32_t index = stack_top_p[-3];
        -: 4138:
        6: 4139:          while (index < collection_p->item_count)
        -: 4140:          {
        5: 4141:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4142:
        5: 4143:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4144:
        5: 4145:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4146:            {
        1: 4147:              goto error;
        -: 4148:            }
        -: 4149:
        4: 4150:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4151:            {
    #####: 4152:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4153:              break;
        -: 4154:            }
        -: 4155:
        4: 4156:            ecma_deref_ecma_string (prop_name_p);
        4: 4157:            index++;
        -: 4158:          }
        -: 4159:
    #####: 4160:          if (index == collection_p->item_count)
        -: 4161:          {
    #####: 4162:            ecma_deref_object (object_p);
    #####: 4163:            ecma_collection_destroy (collection_p);
    #####: 4164:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4165:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4166:          }
        -: 4167:          else
        -: 4168:          {
    #####: 4169:            stack_top_p[-3] = index;
        -: 4170:          }
    #####: 4171:          continue;
        -: 4172:        }
        -: 4173:#if JERRY_ESNEXT
    #####: 4174:        case VM_OC_FOR_OF_INIT:
        -: 4175:        {
    #####: 4176:          ecma_value_t value = *(--stack_top_p);
        -: 4177:
    #####: 4178:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4179:
    #####: 4180:          ecma_value_t next_method;
    #####: 4181:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4182:
    #####: 4183:          ecma_free_value (value);
        -: 4184:
    #####: 4185:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4186:          {
    #####: 4187:            result = iterator;
    #####: 4188:            goto error;
        -: 4189:          }
        -: 4190:
    #####: 4191:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4192:
    #####: 4193:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4194:          {
    #####: 4195:            ecma_free_value (iterator);
    #####: 4196:            ecma_free_value (next_method);
    #####: 4197:            goto error;
        -: 4198:          }
        -: 4199:
    #####: 4200:          if (ecma_is_value_false (result))
        -: 4201:          {
    #####: 4202:            ecma_free_value (iterator);
    #####: 4203:            ecma_free_value (next_method);
    #####: 4204:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4205:            continue;
        -: 4206:          }
        -: 4207:
    #####: 4208:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4209:          ecma_free_value (result);
        -: 4210:
    #####: 4211:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4212:          {
    #####: 4213:            result = next_value;
    #####: 4214:            ecma_free_value (iterator);
    #####: 4215:            ecma_free_value (next_method);
    #####: 4216:            goto error;
        -: 4217:          }
        -: 4218:
    #####: 4219:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4220:
    #####: 4221:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4222:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4223:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4224:          stack_top_p[-2] = next_value;
    #####: 4225:          stack_top_p[-3] = iterator;
    #####: 4226:          stack_top_p[-4] = next_method;
        -: 4227:
    #####: 4228:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4229:          {
        -: 4230:            /* No need to duplicate the first context. */
    #####: 4231:            byte_code_p += 2;
        -: 4232:          }
    #####: 4233:          continue;
        -: 4234:        }
    #####: 4235:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4236:        {
    #####: 4237:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4238:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4239:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4240:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4241:
    #####: 4242:          *stack_top_p++ = context_top_p[-2];
    #####: 4243:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4244:          continue;
        -: 4245:        }
    #####: 4246:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4247:        {
    #####: 4248:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4249:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4250:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4251:
    #####: 4252:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4253:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4254:
    #####: 4255:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4256:          {
    #####: 4257:            goto error;
        -: 4258:          }
        -: 4259:
    #####: 4260:          if (ecma_is_value_false (result))
        -: 4261:          {
    #####: 4262:            ecma_free_value (stack_top_p[-2]);
    #####: 4263:            ecma_free_value (stack_top_p[-3]);
    #####: 4264:            ecma_free_value (stack_top_p[-4]);
    #####: 4265:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4266:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4267:            continue;
        -: 4268:          }
        -: 4269:
    #####: 4270:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4271:          ecma_free_value (result);
        -: 4272:
    #####: 4273:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4274:          {
    #####: 4275:            result = next_value;
    #####: 4276:            goto error;
        -: 4277:          }
        -: 4278:
    #####: 4279:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4280:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4281:          stack_top_p[-2] = next_value;
    #####: 4282:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4283:          continue;
        -: 4284:        }
    #####: 4285:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4286:        {
    #####: 4287:          ecma_value_t value = *(--stack_top_p);
        -: 4288:
    #####: 4289:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4290:
    #####: 4291:          ecma_value_t next_method;
    #####: 4292:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4293:
    #####: 4294:          ecma_free_value (value);
        -: 4295:
    #####: 4296:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4297:          {
    #####: 4298:            goto error;
        -: 4299:          }
        -: 4300:
    #####: 4301:          ecma_value_t iterator = result;
    #####: 4302:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4303:
    #####: 4304:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4305:          {
    #####: 4306:            ecma_free_value (iterator);
    #####: 4307:            ecma_free_value (next_method);
    #####: 4308:            goto error;
        -: 4309:          }
        -: 4310:
    #####: 4311:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4312:
    #####: 4313:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4314:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4315:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4316:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4317:          stack_top_p[-3] = iterator;
    #####: 4318:          stack_top_p[-4] = next_method;
        -: 4319:
    #####: 4320:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4321:          {
        -: 4322:            /* No need to duplicate the first context. */
    #####: 4323:            byte_code_p += 2;
        -: 4324:          }
        -: 4325:
    #####: 4326:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4327:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4328:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4329:
    #####: 4330:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4331:                                  | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4332:
    #####: 4333:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4334:              || (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 4335:          {
    #####: 4336:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4337:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4338:
    #####: 4339:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4340:            {
    #####: 4341:              goto error;
        -: 4342:            }
        -: 4343:
    #####: 4344:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4345:            return ECMA_VALUE_UNDEFINED;
        -: 4346:          }
        -: 4347:
    #####: 4348:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4349:
    #####: 4350:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4351:          {
    #####: 4352:            goto error;
        -: 4353:          }
    #####: 4354:          return result;
        -: 4355:        }
    #####: 4356:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4357:        {
    #####: 4358:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4359:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4360:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4361:
    #####: 4362:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4363:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4364:
    #####: 4365:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4366:          {
    #####: 4367:            goto error;
        -: 4368:          }
        -: 4369:
    #####: 4370:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4371:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4372:
    #####: 4373:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4374:          {
    #####: 4375:            goto error;
        -: 4376:          }
        -: 4377:
    #####: 4378:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4379:                                 | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4380:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4381:
    #####: 4382:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4383:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4384:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4385:          return ECMA_VALUE_UNDEFINED;
        -: 4386:        }
        -: 4387:#endif /* JERRY_ESNEXT */
        1: 4388:        case VM_OC_TRY:
        -: 4389:        {
        -: 4390:          /* Try opcode simply creates the try context. */
        1: 4391:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4392:
        1: 4393:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4394:
        1: 4395:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        1: 4396:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4397:
        1: 4398:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
        1: 4399:          continue;
        -: 4400:        }
    #####: 4401:        case VM_OC_CATCH:
        -: 4402:        {
        -: 4403:          /* Catches are ignored and turned to jumps. */
    #####: 4404:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4405:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4406:
    #####: 4407:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4408:          continue;
        -: 4409:        }
    #####: 4410:        case VM_OC_FINALLY:
        -: 4411:        {
    #####: 4412:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4413:
    #####: 4414:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4415:
    #####: 4416:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4417:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4418:
    #####: 4419:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4420:          {
    #####: 4421:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4422:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4423:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4424:            ecma_deref_object (lex_env_p);
        -: 4425:          }
        -: 4426:
    #####: 4427:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4428:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4429:
    #####: 4430:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4431:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4432:          continue;
        -: 4433:        }
    #####: 4434:        case VM_OC_CONTEXT_END:
        -: 4435:        {
    #####: 4436:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4437:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4438:
    #####: 4439:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4440:
    #####: 4441:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4442:          {
    #####: 4443:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4444:
    #####: 4445:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4446:            continue;
        -: 4447:          }
        -: 4448:
        -: 4449:#if JERRY_ESNEXT
    #####: 4450:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4451:          {
    #####: 4452:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4453:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4454:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4455:            ecma_deref_object (lex_env_p);
        -: 4456:          }
        -: 4457:#endif /* JERRY_ESNEXT */
        -: 4458:
    #####: 4459:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,
        -: 4460:                              PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4461:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4462:
    #####: 4463:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4464:          {
    #####: 4465:            result = *stack_top_p;
    #####: 4466:            goto error;
        -: 4467:          }
        -: 4468:
    #####: 4469:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4470:          {
    #####: 4471:            jcontext_raise_exception (*stack_top_p);
        -: 4472:#if JERRY_VM_THROW
    #####: 4473:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4474:#endif /* JERRY_VM_THROW */
    #####: 4475:            result = ECMA_VALUE_ERROR;
        -: 4476:
        -: 4477:#if JERRY_DEBUGGER
        -: 4478:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4479:#endif /* JERRY_DEBUGGER */
    #####: 4480:            goto error;
        -: 4481:          }
        -: 4482:
    #####: 4483:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4484:
    #####: 4485:          uint32_t jump_target = *stack_top_p;
        -: 4486:
    #####: 4487:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4488:                                                            stack_top_p,
        -: 4489:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4490:                                                            jump_target);
    #####: 4491:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4492:          switch (type)
        -: 4493:          {
    #####: 4494:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4495:            {
    #####: 4496:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4497:
    #####: 4498:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4499:              stack_top_p[-2] = jump_target;
    #####: 4500:              break;
        -: 4501:            }
        -: 4502:#if JERRY_ESNEXT
    #####: 4503:            case VM_CONTEXT_FOUND_ERROR:
        -: 4504:            {
    #####: 4505:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4506:              result = ECMA_VALUE_ERROR;
    #####: 4507:              goto error;
        -: 4508:            }
    #####: 4509:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4510:            {
    #####: 4511:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4512:              stack_top_p[-2] = jump_target;
    #####: 4513:              return ECMA_VALUE_UNDEFINED;
        -: 4514:            }
        -: 4515:#endif /* JERRY_ESNEXT */
    #####: 4516:            default:
        -: 4517:            {
    #####: 4518:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4519:              break;
        -: 4520:            }
        -: 4521:          }
        -: 4522:
    #####: 4523:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4524:          continue;
        -: 4525:        }
    #####: 4526:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4527:        {
    #####: 4528:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4529:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4530:
    #####: 4531:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4532:
    #####: 4533:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4534:                                                            stack_top_p,
        -: 4535:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4536:                                                            (uint32_t) branch_offset);
    #####: 4537:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4538:          switch (type)
        -: 4539:          {
    #####: 4540:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4541:            {
    #####: 4542:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4543:
    #####: 4544:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4545:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4546:              break;
        -: 4547:            }
        -: 4548:#if JERRY_ESNEXT
    #####: 4549:            case VM_CONTEXT_FOUND_ERROR:
        -: 4550:            {
    #####: 4551:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4552:              result = ECMA_VALUE_ERROR;
    #####: 4553:              goto error;
        -: 4554:            }
    #####: 4555:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4556:            {
    #####: 4557:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4558:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4559:              return ECMA_VALUE_UNDEFINED;
        -: 4560:            }
        -: 4561:#endif /* JERRY_ESNEXT */
    #####: 4562:            default:
        -: 4563:            {
    #####: 4564:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4565:              break;
        -: 4566:            }
        -: 4567:          }
        -: 4568:
    #####: 4569:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4570:          continue;
        -: 4571:        }
        -: 4572:#if JERRY_MODULE_SYSTEM
    #####: 4573:        case VM_OC_MODULE_IMPORT:
        -: 4574:        {
    #####: 4575:          left_value = *(--stack_top_p);
        -: 4576:
    #####: 4577:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4578:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4579:
        -: 4580:#if JERRY_SNAPSHOT_EXEC
    #####: 4581:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4582:          {
        -: 4583:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4584:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4585:
    #####: 4586:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4587:            {
    #####: 4588:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4589:            }
        -: 4590:#if JERRY_SNAPSHOT_EXEC
        -: 4591:          }
        -: 4592:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4593:
    #####: 4594:          result = ecma_module_import (left_value, user_value);
    #####: 4595:          ecma_free_value (left_value);
        -: 4596:
    #####: 4597:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4598:          {
    #####: 4599:            goto error;
        -: 4600:          }
        -: 4601:
    #####: 4602:          *stack_top_p++ = result;
    #####: 4603:          continue;
        -: 4604:        }
    #####: 4605:        case VM_OC_MODULE_IMPORT_META:
        -: 4606:        {
    #####: 4607:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4608:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4609:
    #####: 4610:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4611:
    #####: 4612:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4613:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4614:
    #####: 4615:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4616:          {
    #####: 4617:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4618:
    #####: 4619:            ecma_value_t module = import_meta;
    #####: 4620:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4621:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4622:
    #####: 4623:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4624:            {
    #####: 4625:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4626:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4627:            }
        -: 4628:
    #####: 4629:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4630:          }
        -: 4631:          else
        -: 4632:          {
    #####: 4633:            ecma_ref_object (import_meta_object_p);
        -: 4634:          }
        -: 4635:
    #####: 4636:          *stack_top_p++ = import_meta;
    #####: 4637:          continue;
        -: 4638:        }
        -: 4639:#endif /* JERRY_MODULE_SYSTEM */
        -: 4640:#if JERRY_DEBUGGER
        -: 4641:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4642:        {
        -: 4643:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4644:          {
        -: 4645:            continue;
        -: 4646:          }
        -: 4647:
        -: 4648:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4649:
        -: 4650:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4651:
        -: 4652:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4653:
        -: 4654:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4655:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4656:          {
        -: 4657:            result = ECMA_VALUE_ERROR;
        -: 4658:            goto error;
        -: 4659:          }
        -: 4660:          continue;
        -: 4661:        }
        -: 4662:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4663:        {
        -: 4664:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4665:          {
        -: 4666:            continue;
        -: 4667:          }
        -: 4668:
        -: 4669:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4670:
        -: 4671:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4672:
        -: 4673:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4674:
        -: 4675:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4676:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4677:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4678:          {
        -: 4679:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4680:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4681:            {
        -: 4682:              result = ECMA_VALUE_ERROR;
        -: 4683:              goto error;
        -: 4684:            }
        -: 4685:            continue;
        -: 4686:          }
        -: 4687:
        -: 4688:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4689:          {
        -: 4690:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4691:            continue;
        -: 4692:          }
        -: 4693:
        -: 4694:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4695:
        -: 4696:          if (jerry_debugger_receive (NULL))
        -: 4697:          {
        -: 4698:            continue;
        -: 4699:          }
        -: 4700:
        -: 4701:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4702:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4703:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4704:          {
        -: 4705:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4706:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4707:            {
        -: 4708:              result = ECMA_VALUE_ERROR;
        -: 4709:              goto error;
        -: 4710:            }
        -: 4711:          }
        -: 4712:          continue;
        -: 4713:        }
        -: 4714:#endif /* JERRY_DEBUGGER */
    #####: 4715:        case VM_OC_NONE:
        -: 4716:        default:
        -: 4717:        {
    #####: 4718:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4719:
    #####: 4720:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4721:        }
        -: 4722:      }
        -: 4723:
        4: 4724:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4725:
        4: 4726:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4727:      {
        -: 4728:        uint16_t literal_index;
        -: 4729:
        2: 4730:        READ_LITERAL_INDEX (literal_index);
        -: 4731:
        2: 4732:        if (literal_index < register_end)
        -: 4733:        {
    #####: 4734:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4735:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4736:
    #####: 4737:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4738:          {
    #####: 4739:            result = ecma_fast_copy_value (result);
        -: 4740:          }
        -: 4741:        }
        -: 4742:        else
        -: 4743:        {
        2: 4744:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4745:
        2: 4746:          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 4747:                                                                          var_name_str_p,
        -: 4748:                                                                          is_strict,
        -: 4749:                                                                          result);
        -: 4750:
        2: 4751:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4752:          {
    #####: 4753:            ecma_free_value (result);
    #####: 4754:            result = put_value_result;
    #####: 4755:            goto error;
        -: 4756:          }
        -: 4757:
        2: 4758:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4759:          {
        2: 4760:            ecma_fast_free_value (result);
        -: 4761:          }
        -: 4762:        }
        -: 4763:      }
        2: 4764:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4765:      {
        1: 4766:        ecma_value_t property = *(--stack_top_p);
        1: 4767:        ecma_value_t base = *(--stack_top_p);
        -: 4768:
        1: 4769:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4770:        {
        1: 4771:          property = (ecma_value_t) ecma_get_integer_from_value (property);
        1: 4772:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
        1: 4773:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4774:
        1: 4775:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4776:          {
        1: 4777:            goto free_both_values;
        -: 4778:          }
    #####: 4779:          result = ecma_fast_copy_value (result);
        -: 4780:        }
        -: 4781:        else
        -: 4782:        {
    #####: 4783:          ecma_value_t set_value_result = vm_op_set_value (base,
        -: 4784:                                                           property,
        -: 4785:                                                           result,
        -: 4786:                                                           is_strict);
        -: 4787:
    #####: 4788:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4789:          {
    #####: 4790:            ecma_free_value (result);
    #####: 4791:            result = set_value_result;
    #####: 4792:            goto error;
        -: 4793:          }
        -: 4794:
    #####: 4795:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4796:          {
    #####: 4797:            ecma_fast_free_value (result);
    #####: 4798:            goto free_both_values;
        -: 4799:          }
        -: 4800:        }
        -: 4801:      }
        -: 4802:
        3: 4803:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4804:      {
        1: 4805:        *stack_top_p++ = result;
        -: 4806:      }
        2: 4807:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4808:      {
    #####: 4809:        ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 4810:        VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 4811:      }
        -: 4812:
       10: 4813:free_both_values:
        8: 4814:      ecma_fast_free_value (right_value);
        8: 4815:free_left_value:
        8: 4816:      ecma_fast_free_value (left_value);
        -: 4817:    }
        -: 4818:
        3: 4819:error:
        3: 4820:    ecma_fast_free_value (left_value);
        3: 4821:    ecma_fast_free_value (right_value);
        -: 4822:
        3: 4823:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4824:    {
        2: 4825:      JERRY_ASSERT (jcontext_has_pending_exception ());
        2: 4826:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4827:
        5: 4828:      while (stack_top_p > stack_bottom_p)
        -: 4829:      {
        1: 4830:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4831:#if JERRY_ESNEXT
        1: 4832:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4833:        {
    #####: 4834:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4835:          continue;
        -: 4836:        }
        -: 4837:#endif /* JERRY_ESNEXT */
        1: 4838:        ecma_fast_free_value (stack_item);
        -: 4839:      }
        -: 4840:
        -: 4841:#if JERRY_VM_THROW
    #####: 4842:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4843:      {
    #####: 4844:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4845:
    #####: 4846:        jerry_vm_throw_callback_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4847:
    #####: 4848:        if (vm_throw_callback_p != NULL)
        -: 4849:        {
    #####: 4850:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4851:        }
        -: 4852:      }
        -: 4853:#endif /* JERRY_VM_THROW */
        -: 4854:
        -: 4855:#if JERRY_DEBUGGER
        -: 4856:      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION
        -: 4857:                                  | JERRY_DEBUGGER_VM_IGNORE
        -: 4858:                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4859:
        -: 4860:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4861:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4862:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4863:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4864:      {
        -: 4865:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4866:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4867:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4868:
        -: 4869:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4870:        {
        -: 4871:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4872:
        -: 4873:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4874:          {
        -: 4875:            ecma_free_value (current_error_value);
        -: 4876:          }
        -: 4877:          else
        -: 4878:          {
        -: 4879:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4880:          }
        -: 4881:
        -: 4882:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4883:        }
        -: 4884:      }
        -: 4885:#endif /* JERRY_DEBUGGER */
        -: 4886:    }
        -: 4887:
        3: 4888:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4889:
        3: 4890:    if (frame_ctx_p->context_depth == 0)
        -: 4891:    {
        -: 4892:      /* In most cases there is no context. */
        1: 4893:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
        1: 4894:      return result;
        -: 4895:    }
        -: 4896:
        2: 4897:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4898:    {
    #####: 4899:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4900:                                     stack_top_p,
        -: 4901:                                     VM_CONTEXT_FINALLY_RETURN,
        -: 4902:                                     0))
        -: 4903:      {
    #####: 4904:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4905:        {
    #####: 4906:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4907:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4908:
    #####: 4909:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4910:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4911:          stack_top_p[-2] = result;
    #####: 4912:          continue;
        -: 4913:        }
        -: 4914:#if JERRY_ESNEXT
    #####: 4915:        case VM_CONTEXT_FOUND_ERROR:
        -: 4916:        {
    #####: 4917:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4918:
    #####: 4919:          ecma_free_value (result);
    #####: 4920:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4921:          result = ECMA_VALUE_ERROR;
    #####: 4922:          break;
        -: 4923:        }
    #####: 4924:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4925:        {
    #####: 4926:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4927:
    #####: 4928:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4929:          stack_top_p[-2] = result;
    #####: 4930:          return ECMA_VALUE_UNDEFINED;
        -: 4931:        }
        -: 4932:#endif /* JERRY_ESNEXT */
    #####: 4933:        default:
        -: 4934:        {
    #####: 4935:          goto finish;
        -: 4936:        }
        -: 4937:      }
        2: 4938:    }
        -: 4939:
        2: 4940:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4941:
        2: 4942:    if (!jcontext_has_pending_abort ())
        -: 4943:    {
        2: 4944:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4945:                                     stack_top_p,
        -: 4946:                                     VM_CONTEXT_FINALLY_THROW,
        -: 4947:                                     0))
        -: 4948:      {
        1: 4949:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4950:        {
        1: 4951:          stack_top_p = frame_ctx_p->stack_top_p;
        1: 4952:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4953:
        1: 4954:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        1: 4955:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4956:
        -: 4957:#if JERRY_DEBUGGER
        -: 4958:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4959:#endif /* JERRY_DEBUGGER */
        -: 4960:
        1: 4961:          result = jcontext_take_exception ();
        -: 4962:
        1: 4963:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4964:          {
    #####: 4965:            stack_top_p[-2] = result;
    #####: 4966:            continue;
        -: 4967:          }
        -: 4968:
        1: 4969:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4970:
        1: 4971:          *stack_top_p++ = result;
        1: 4972:          continue;
        -: 4973:        }
        -: 4974:#if JERRY_ESNEXT
    #####: 4975:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4976:        {
    #####: 4977:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4978:          return ECMA_VALUE_UNDEFINED;
        -: 4979:        }
        -: 4980:#endif /* JERRY_ESNEXT */
        1: 4981:        default:
        -: 4982:        {
        1: 4983:          break;
        -: 4984:        }
        -: 4985:      }
        -: 4986:    }
        -: 4987:    else
        -: 4988:    {
        -: 4989:      do
        -: 4990:      {
    #####: 4991:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4992:
    #####: 4993:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4994:      }
    #####: 4995:      while (frame_ctx_p->context_depth > 0);
        -: 4996:    }
        -: 4997:
    #####: 4998:finish:
        1: 4999:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
        1: 5000:    return result;
        -: 5001:  }
        -: 5002:} /* vm_loop */
        -: 5003:
        -: 5004:#if JERRY_MODULE_SYSTEM
        -: 5005:
        -: 5006:/**
        -: 5007: * Create and initialize module scope with all data properties
        -: 5008: *
        -: 5009: * @return ECMA_VALUE_EMPTY on success,
        -: 5010: *         ECMA_VALUE_ERROR on failure
        -: 5011: */
        -: 5012:ecma_value_t
    #####: 5013:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5014:{
        -: 5015:  ecma_object_t *global_object_p;
        -: 5016:#if JERRY_BUILTIN_REALMS
    #####: 5017:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5018:#else /* !JERRY_BUILTIN_REALMS */
        -: 5019:  global_object_p = ecma_builtin_get_global ();
        -: 5020:#endif /* JERRY_BUILTIN_REALMS */
        -: 5021:
    #####: 5022:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5023:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5024:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5025:  ecma_value_t *literal_start_p;
        -: 5026:  uint8_t *byte_code_p;
        -: 5027:  uint16_t encoding_limit;
        -: 5028:  uint16_t encoding_delta;
        -: 5029:
    #####: 5030:  ((ecma_lexical_environment_class_t *) scope_p)->module_p = (ecma_object_t *) module_p;
        -: 5031:
    #####: 5032:  module_p->scope_p = scope_p;
    #####: 5033:  ecma_deref_object (scope_p);
        -: 5034:
    #####: 5035:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5036:  {
    #####: 5037:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5038:
    #####: 5039:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5040:    literal_start_p -= args_p->register_end;
    #####: 5041:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5042:  }
        -: 5043:  else
        -: 5044:  {
    #####: 5045:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5046:
    #####: 5047:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5048:    literal_start_p -= args_p->register_end;
    #####: 5049:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5050:  }
        -: 5051:
        -: 5052:  /* Prepare for byte code execution. */
    #####: 5053:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5054:  {
    #####: 5055:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5056:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5057:  }
        -: 5058:  else
        -: 5059:  {
    #####: 5060:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5061:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5062:  }
        -: 5063:
    #####: 5064:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5065:
    #####: 5066:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5067:
        -: 5068:  while (true)
    #####: 5069:  {
    #####: 5070:    uint8_t opcode = *byte_code_p++;
        -: 5071:
    #####: 5072:    switch (opcode)
        -: 5073:    {
    #####: 5074:      case CBC_CREATE_VAR:
        -: 5075:      case CBC_CREATE_LET:
        -: 5076:      case CBC_CREATE_CONST:
        -: 5077:      {
        -: 5078:        uint32_t literal_index;
        -: 5079:
    #####: 5080:        READ_LITERAL_INDEX (literal_index);
        -: 5081:
    #####: 5082:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5083:
    #####: 5084:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5085:
    #####: 5086:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5087:
    #####: 5088:        if (opcode == CBC_CREATE_LET)
        -: 5089:        {
    #####: 5090:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5091:        }
    #####: 5092:        else if (opcode == CBC_CREATE_CONST)
        -: 5093:        {
    #####: 5094:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5095:        }
        -: 5096:
        -: 5097:        ecma_property_value_t *property_value_p;
    #####: 5098:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5099:
    #####: 5100:        if (opcode != CBC_CREATE_VAR)
        -: 5101:        {
    #####: 5102:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5103:        }
    #####: 5104:        break;
        -: 5105:      }
    #####: 5106:      case CBC_INIT_ARG_OR_FUNC:
        -: 5107:      {
        -: 5108:        uint32_t literal_index;
        -: 5109:
    #####: 5110:        READ_LITERAL_INDEX (literal_index);
        -: 5111:
        -: 5112:        ecma_compiled_code_t *function_bytecode_p;
        -: 5113:#if JERRY_SNAPSHOT_EXEC
    #####: 5114:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5115:        {
        -: 5116:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5117:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5118:                                                                 literal_start_p[literal_index]);
        -: 5119:#if JERRY_SNAPSHOT_EXEC
        -: 5120:        }
        -: 5121:        else
        -: 5122:        {
    #####: 5123:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5124:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5125:        }
        -: 5126:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5127:
    #####: 5128:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5129:
        -: 5130:        ecma_object_t *function_obj_p;
        -: 5131:
    #####: 5132:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5133:        {
    #####: 5134:          function_obj_p = ecma_op_create_arrow_function_object (scope_p,
        -: 5135:                                                                 function_bytecode_p,
        -: 5136:                                                                 ECMA_VALUE_UNDEFINED);
        -: 5137:        }
        -: 5138:        else
        -: 5139:        {
    #####: 5140:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5141:        }
        -: 5142:
    #####: 5143:        READ_LITERAL_INDEX (literal_index);
    #####: 5144:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5145:
    #####: 5146:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5147:
        -: 5148:        ecma_property_value_t *property_value_p;
    #####: 5149:        property_value_p = ecma_create_named_data_property (scope_p,
        -: 5150:                                                            name_p,
        -: 5151:                                                            ECMA_PROPERTY_FLAG_WRITABLE,
        -: 5152:                                                            NULL);
        -: 5153:
    #####: 5154:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5155:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5156:        ecma_deref_object (function_obj_p);
    #####: 5157:        break;
        -: 5158:      }
    #####: 5159:      default:
        -: 5160:      {
    #####: 5161:        JERRY_ASSERT (opcode == CBC_RETURN_FUNCTION_END);
    #####: 5162:        return ECMA_VALUE_EMPTY;
        -: 5163:      }
        -: 5164:    }
        -: 5165:  }
        -: 5166:} /* vm_init_module_scope */
        -: 5167:
        -: 5168:#endif /* JERRY_MODULE_SYSTEM */
        -: 5169:
        -: 5170:#undef READ_LITERAL
        -: 5171:#undef READ_LITERAL_INDEX
        -: 5172:
        -: 5173:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5174:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5175:
        -: 5176:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5177:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5178:
        -: 5179:/**
        -: 5180: * Initialize code block execution
        -: 5181: *
        -: 5182: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5183: *         ECMA_VALUE_EMPTY - otherwise
        -: 5184: */
        -: 5185:static void JERRY_ATTR_NOINLINE
        3: 5186:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5187:{
        3: 5188:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        3: 5189:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5190:
        3: 5191:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
        3: 5192:  frame_ctx_p->context_depth = 0;
        6: 5193:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
        3: 5194:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5195:
        -: 5196:  uint16_t argument_end, register_end;
        -: 5197:  ecma_value_t *literal_p;
        -: 5198:
        3: 5199:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5200:  {
    #####: 5201:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5202:
    #####: 5203:    argument_end = args_p->argument_end;
    #####: 5204:    register_end = args_p->register_end;
        -: 5205:
    #####: 5206:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5207:    literal_p -= register_end;
    #####: 5208:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5209:    literal_p += args_p->literal_end;
        -: 5210:  }
        -: 5211:  else
        -: 5212:  {
        3: 5213:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5214:
        3: 5215:    argument_end = args_p->argument_end;
        3: 5216:    register_end = args_p->register_end;
        -: 5217:
        3: 5218:    literal_p = (ecma_value_t *) (args_p + 1);
        3: 5219:    literal_p -= register_end;
        3: 5220:    frame_ctx_p->literal_start_p = literal_p;
        3: 5221:    literal_p += args_p->literal_end;
        -: 5222:  }
        -: 5223:
        3: 5224:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
        3: 5225:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
        3: 5226:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5227:
        3: 5228:  uint32_t arg_list_len = 0;
        -: 5229:
        3: 5230:  if (argument_end > 0)
        -: 5231:  {
    #####: 5232:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5233:
    #####: 5234:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 5235:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5236:
    #####: 5237:    if (arg_list_len > argument_end)
        -: 5238:    {
    #####: 5239:      arg_list_len = argument_end;
        -: 5240:    }
        -: 5241:
    #####: 5242:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5243:    {
    #####: 5244:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5245:    }
        -: 5246:  }
        -: 5247:
        -: 5248:  /* The arg_list_len contains the end of the copied arguments.
        -: 5249:   * Fill everything else with undefined. */
        3: 5250:  if (register_end > arg_list_len)
        -: 5251:  {
        2: 5252:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5253:
        7: 5254:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5255:    {
        5: 5256:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5257:    }
        -: 5258:  }
        -: 5259:
        3: 5260:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        3: 5261:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
        3: 5262:} /* vm_init_exec */
        -: 5263:
        -: 5264:/**
        -: 5265: * Resume execution of a code block.
        -: 5266: *
        -: 5267: * @return ecma value
        -: 5268: */
        -: 5269:ecma_value_t JERRY_ATTR_NOINLINE
        6: 5270:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5271:{
        -: 5272:  while (true)
        3: 5273:  {
        6: 5274:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5275:
        5: 5276:    switch (frame_ctx_p->call_operation)
        -: 5277:    {
        1: 5278:      case VM_EXEC_CALL:
        -: 5279:      {
        1: 5280:        opfunc_call (frame_ctx_p);
        1: 5281:        break;
        -: 5282:      }
        -: 5283:#if JERRY_ESNEXT
    #####: 5284:      case VM_EXEC_SUPER_CALL:
        -: 5285:      {
    #####: 5286:        vm_super_call (frame_ctx_p);
    #####: 5287:        break;
        -: 5288:      }
    #####: 5289:      case VM_EXEC_SPREAD_OP:
        -: 5290:      {
    #####: 5291:        vm_spread_operation (frame_ctx_p);
    #####: 5292:        break;
        -: 5293:      }
    #####: 5294:      case VM_EXEC_RETURN:
        -: 5295:      {
    #####: 5296:        return completion_value;
        -: 5297:      }
        -: 5298:#endif /* JERRY_ESNEXT */
        2: 5299:      case VM_EXEC_CONSTRUCT:
        -: 5300:      {
        2: 5301:        opfunc_construct (frame_ctx_p);
        2: 5302:        break;
        -: 5303:      }
        2: 5304:      default:
        -: 5305:      {
        2: 5306:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5307:
        2: 5308:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5309:        uint32_t register_end;
        -: 5310:
        2: 5311:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5312:        {
    #####: 5313:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5314:        }
        -: 5315:        else
        -: 5316:        {
        2: 5317:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5318:        }
        -: 5319:
        -: 5320:        /* Free arguments and registers */
        2: 5321:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
        5: 5322:        for (uint32_t i = 0; i < register_end; i++)
        -: 5323:        {
        3: 5324:          ecma_fast_free_value (registers_p[i]);
        -: 5325:        }
        -: 5326:
        -: 5327:#if JERRY_DEBUGGER
        -: 5328:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5329:        {
        -: 5330:          /* The engine will stop when the next breakpoint is reached. */
        -: 5331:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5332:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5333:        }
        -: 5334:#endif /* JERRY_DEBUGGER */
        -: 5335:
        2: 5336:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
        2: 5337:        return completion_value;
        -: 5338:      }
        -: 5339:    }
        -: 5340:  }
        -: 5341:} /* vm_execute */
        -: 5342:
        -: 5343:/**
        -: 5344: * Run the code.
        -: 5345: *
        -: 5346: * @return ecma value
        -: 5347: */
        -: 5348:ecma_value_t
        3: 5349:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5350:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5351:        ecma_object_t *lex_env_p) /**< lexical environment to use */
        3: 5352:{
        3: 5353:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5354:  vm_frame_ctx_t *frame_ctx_p;
        -: 5355:  size_t frame_size;
        -: 5356:
        3: 5357:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5358:  {
    #####: 5359:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5360:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5361:  }
        -: 5362:  else
        -: 5363:  {
        3: 5364:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        3: 5365:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5366:  }
        -: 5367:
        3: 5368:  JERRY_VLA (ecma_value_t, stack, frame_size + (sizeof (vm_frame_ctx_t) / sizeof (ecma_value_t)));
        -: 5369:
        3: 5370:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5371:
        3: 5372:  frame_ctx_p->shared_p = shared_p;
        3: 5373:  frame_ctx_p->lex_env_p = lex_env_p;
        3: 5374:  frame_ctx_p->this_binding = this_binding_value;
        -: 5375:
        3: 5376:  vm_init_exec (frame_ctx_p);
        3: 5377:  return vm_execute (frame_ctx_p);
        -: 5378:} /* vm_run */
        -: 5379:
        -: 5380:/**
        -: 5381: * @}
        -: 5382: * @}
        -: 5383: */
