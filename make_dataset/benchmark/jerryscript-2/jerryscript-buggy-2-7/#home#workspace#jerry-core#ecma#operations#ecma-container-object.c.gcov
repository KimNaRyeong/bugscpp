        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-container-object.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:#include "jcontext.h"
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-function-object.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "ecma-iterator-object.h"
        -:   25:#include "ecma-container-object.h"
        -:   26:#include "ecma-property-hashmap.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#if JERRY_BUILTIN_CONTAINER
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup \addtogroup ecmamaphelpers ECMA builtin Map/Set helper functions
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Create a new internal buffer.
        -:   40: *
        -:   41: * Note:
        -:   42: *   The first element of the collection tracks the size of the buffer.
        -:   43: *   ECMA_VALUE_EMPTY values are not calculated into the size.
        -:   44: *
        -:   45: * @return pointer to the internal buffer
        -:   46: */
        -:   47:static inline ecma_collection_t *
    #####:   48:ecma_op_create_internal_buffer (void)
        -:   49:{
    #####:   50:  ecma_collection_t *collection_p = ecma_new_collection ();
    #####:   51:  ecma_collection_push_back (collection_p, (ecma_value_t) 0);
        -:   52:
    #####:   53:  return collection_p;
        -:   54:} /* ecma_op_create_internal_buffer */
        -:   55:
        -:   56:/**
        -:   57: * Append values to the internal buffer.
        -:   58: */
        -:   59:static void
    #####:   60:ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */
        -:   61:                                ecma_value_t key_arg, /**< key argument */
        -:   62:                                ecma_value_t value_arg, /**< value argument */
        -:   63:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   64:{
    #####:   65:  JERRY_ASSERT (container_p != NULL);
        -:   66:
    #####:   67:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   68:  {
    #####:   69:    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };
    #####:   70:    ecma_collection_append (container_p, values, 2);
        -:   71:  }
        -:   72:  else
        -:   73:  {
    #####:   74:    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));
        -:   75:  }
        -:   76:
    #####:   77:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);
    #####:   78:} /* ecma_op_internal_buffer_append */
        -:   79:
        -:   80:/**
        -:   81: * Update the value of a given entry.
        -:   82: */
        -:   83:static inline void
    #####:   84:ecma_op_internal_buffer_update (ecma_value_t *entry_p, /**< entry pointer */
        -:   85:                                ecma_value_t value_arg, /**< value argument */
        -:   86:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   87:{
    #####:   88:  JERRY_ASSERT (entry_p != NULL);
        -:   89:
    #####:   90:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   91:  {
    #####:   92:    ecma_free_value_if_not_object (((ecma_container_pair_t *) entry_p)->value);
        -:   93:
    #####:   94:    ((ecma_container_pair_t *) entry_p)->value = ecma_copy_value_if_not_object (value_arg);
        -:   95:  }
    #####:   96:} /* ecma_op_internal_buffer_update */
        -:   97:
        -:   98:/**
        -:   99: * Delete element from the internal buffer.
        -:  100: */
        -:  101:static void
    #####:  102:ecma_op_internal_buffer_delete (ecma_collection_t *container_p, /**< internal container pointer */
        -:  103:                                ecma_container_pair_t *entry_p, /**< entry pointer */
        -:  104:                                lit_magic_string_id_t lit_id) /**< class id */
        -:  105:{
    #####:  106:  JERRY_ASSERT (container_p != NULL);
    #####:  107:  JERRY_ASSERT (entry_p != NULL);
        -:  108:
    #####:  109:  ecma_free_value_if_not_object (entry_p->key);
    #####:  110:  entry_p->key = ECMA_VALUE_EMPTY;
        -:  111:
    #####:  112:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  113:  {
    #####:  114:    ecma_free_value_if_not_object (entry_p->value);
    #####:  115:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  116:  }
        -:  117:
    #####:  118:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) - 1);
    #####:  119:} /* ecma_op_internal_buffer_delete */
        -:  120:
        -:  121:/**
        -:  122: * Find an entry in the collection.
        -:  123: *
        -:  124: * @return pointer to the appropriate entry.
        -:  125: */
        -:  126:static ecma_value_t *
    #####:  127:ecma_op_internal_buffer_find (ecma_collection_t *container_p, /**< internal container pointer */
        -:  128:                              ecma_value_t key_arg, /**< key argument */
        -:  129:                              lit_magic_string_id_t lit_id) /**< class id */
        -:  130:{
    #####:  131:  JERRY_ASSERT (container_p != NULL);
        -:  132:
    #####:  133:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####:  134:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  135:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  136:
    #####:  137:  for (uint32_t i = 0; i < entry_count; i += entry_size)
        -:  138:  {
    #####:  139:    ecma_value_t *entry_p = start_p + i;
        -:  140:
    #####:  141:    if (ecma_op_same_value_zero (*entry_p, key_arg, false))
        -:  142:    {
    #####:  143:      return entry_p;
        -:  144:    }
        -:  145:  }
        -:  146:
    #####:  147:  return NULL;
        -:  148:} /* ecma_op_internal_buffer_find */
        -:  149:
        -:  150:/**
        -:  151: * Get the value that belongs to the key.
        -:  152: *
        -:  153: * Note: in case of Set containers, the values are the same as the keys.
        -:  154: *
        -:  155: * @return ecma value
        -:  156: */
        -:  157:static ecma_value_t
    #####:  158:ecma_op_container_get_value (ecma_value_t *entry_p, /**< entry (key) pointer */
        -:  159:                             lit_magic_string_id_t lit_id) /**< class id */
        -:  160:{
    #####:  161:  JERRY_ASSERT (entry_p != NULL);
        -:  162:
    #####:  163:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  164:  {
    #####:  165:    return ((ecma_container_pair_t *) entry_p)->value;
        -:  166:  }
        -:  167:
    #####:  168:  return *entry_p;
        -:  169:} /* ecma_op_container_get_value */
        -:  170:
        -:  171:/**
        -:  172: * Get the size (in ecma_value_t) of the stored entries.
        -:  173: *
        -:  174: * @return size of the entries.
        -:  175: */
        -:  176:uint8_t
    #####:  177:ecma_op_container_entry_size (lit_magic_string_id_t lit_id) /**< class id */
        -:  178:{
    #####:  179:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  180:  {
    #####:  181:    return ECMA_CONTAINER_PAIR_SIZE;
        -:  182:  }
        -:  183:
    #####:  184:  return ECMA_CONTAINER_VALUE_SIZE;
        -:  185:} /* ecma_op_container_entry_size */
        -:  186:
        -:  187:/**
        -:  188: * Release the entries in the WeakSet container.
        -:  189: */
        -:  190:static void
    #####:  191:ecma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */
        -:  192:                                        ecma_collection_t *container_p) /** internal buffer pointer */
        -:  193:{
    #####:  194:  JERRY_ASSERT (object_p != NULL);
    #####:  195:  JERRY_ASSERT (container_p != NULL);
        -:  196:
    #####:  197:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  198:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  199:
    #####:  200:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  201:  {
    #####:  202:    ecma_value_t *entry_p = start_p + i;
        -:  203:
    #####:  204:    if (ecma_is_value_empty (*entry_p))
        -:  205:    {
    #####:  206:      continue;
        -:  207:    }
        -:  208:
    #####:  209:    ecma_op_object_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));
    #####:  210:    ecma_op_container_remove_weak_entry (object_p, *entry_p);
        -:  211:
    #####:  212:    *entry_p = ECMA_VALUE_EMPTY;
        -:  213:  }
    #####:  214:} /* ecma_op_container_free_weakset_entries */
        -:  215:
        -:  216:/**
        -:  217: * Release the entries in the WeakMap container.
        -:  218: */
        -:  219:static void
    #####:  220:ecma_op_container_free_weakmap_entries (ecma_object_t *object_p, /**< object pointer */
        -:  221:                                        ecma_collection_t *container_p) /**< internal buffer pointer */
        -:  222:{
    #####:  223:  JERRY_ASSERT (object_p != NULL);
    #####:  224:  JERRY_ASSERT (container_p != NULL);
        -:  225:
    #####:  226:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  227:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  228:
    #####:  229:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  230:  {
    #####:  231:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  232:
    #####:  233:    if (ecma_is_value_empty (entry_p->key))
        -:  234:    {
    #####:  235:      continue;
        -:  236:    }
        -:  237:
    #####:  238:    ecma_op_object_unref_weak (ecma_get_object_from_value (entry_p->key), ecma_make_object_value (object_p));
    #####:  239:    ecma_op_container_remove_weak_entry (object_p, entry_p->key);
        -:  240:
    #####:  241:    ecma_free_value_if_not_object (entry_p->value);
        -:  242:
    #####:  243:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  244:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  245:  }
    #####:  246:} /* ecma_op_container_free_weakmap_entries */
        -:  247:
        -:  248:/**
        -:  249: * Release the entries in the Set container.
        -:  250: */
        -:  251:static void
    #####:  252:ecma_op_container_free_set_entries (ecma_collection_t *container_p)
        -:  253:{
    #####:  254:  JERRY_ASSERT (container_p != NULL);
        -:  255:
    #####:  256:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  257:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  258:
    #####:  259:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  260:  {
    #####:  261:    ecma_value_t *entry_p = start_p + i;
        -:  262:
    #####:  263:    if (ecma_is_value_empty (*entry_p))
        -:  264:    {
    #####:  265:      continue;
        -:  266:    }
        -:  267:
    #####:  268:    ecma_free_value_if_not_object (*entry_p);
    #####:  269:    *entry_p = ECMA_VALUE_EMPTY;
        -:  270:  }
    #####:  271:} /* ecma_op_container_free_set_entries */
        -:  272:
        -:  273:/**
        -:  274: * Release the entries in the Map container.
        -:  275: */
        -:  276:static void
    #####:  277:ecma_op_container_free_map_entries (ecma_collection_t *container_p)
        -:  278:{
    #####:  279:  JERRY_ASSERT (container_p != NULL);
        -:  280:
    #####:  281:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  282:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  283:
    #####:  284:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  285:  {
    #####:  286:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  287:
    #####:  288:    if (ecma_is_value_empty (entry_p->key))
        -:  289:    {
    #####:  290:      continue;
        -:  291:    }
        -:  292:
    #####:  293:    ecma_free_value_if_not_object (entry_p->key);
    #####:  294:    ecma_free_value_if_not_object (entry_p->value);
        -:  295:
    #####:  296:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  297:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  298:  }
    #####:  299:} /* ecma_op_container_free_map_entries */
        -:  300:
        -:  301:/**
        -:  302: * Release the internal buffer and the stored entries.
        -:  303: */
        -:  304:void
    #####:  305:ecma_op_container_free_entries (ecma_object_t *object_p) /**< collection object pointer */
        -:  306:{
    #####:  307:  JERRY_ASSERT (object_p != NULL);
        -:  308:
    #####:  309:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  310:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  311:                                                                    map_object_p->u.cls.u3.value);
        -:  312:
    #####:  313:  switch (map_object_p->u.cls.u2.container_id)
        -:  314:  {
    #####:  315:    case LIT_MAGIC_STRING_WEAKSET_UL:
        -:  316:    {
    #####:  317:      ecma_op_container_free_weakset_entries (object_p, container_p);
    #####:  318:      break;
        -:  319:    }
    #####:  320:    case LIT_MAGIC_STRING_WEAKMAP_UL:
        -:  321:    {
    #####:  322:      ecma_op_container_free_weakmap_entries (object_p, container_p);
    #####:  323:      break;
        -:  324:    }
    #####:  325:    case LIT_MAGIC_STRING_SET_UL:
        -:  326:    {
    #####:  327:      ecma_op_container_free_set_entries (container_p);
    #####:  328:      break;
        -:  329:    }
    #####:  330:    case LIT_MAGIC_STRING_MAP_UL:
        -:  331:    {
    #####:  332:      ecma_op_container_free_map_entries (container_p);
    #####:  333:      break;
        -:  334:    }
    #####:  335:    default:
        -:  336:    {
    #####:  337:      break;
        -:  338:    }
        -:  339:  }
        -:  340:
    #####:  341:  ECMA_CONTAINER_SET_SIZE (container_p, 0);
    #####:  342:} /* ecma_op_container_free_entries */
        -:  343:
        -:  344:/**
        -:  345: * Handle calling [[Construct]] of built-in Map/Set like objects
        -:  346: *
        -:  347: * @return ecma value
        -:  348: */
        -:  349:ecma_value_t
    #####:  350:ecma_op_container_create (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  351:                          uint32_t arguments_list_len, /**< number of arguments */
        -:  352:                          lit_magic_string_id_t lit_id, /**< internal class id */
        -:  353:                          ecma_builtin_id_t proto_id) /**< prototype builtin id */
        -:  354:{
    #####:  355:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
    #####:  356:  JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_MAP_UL
        -:  357:                || lit_id == LIT_MAGIC_STRING_SET_UL
        -:  358:                || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL
        -:  359:                || lit_id == LIT_MAGIC_STRING_WEAKSET_UL);
    #####:  360:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p) != NULL);
        -:  361:
    #####:  362:  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p), proto_id);
        -:  363:
    #####:  364:  if (JERRY_UNLIKELY (proto_p == NULL))
        -:  365:  {
    #####:  366:    return ECMA_VALUE_ERROR;
        -:  367:  }
        -:  368:
    #####:  369:  ecma_collection_t *container_p = ecma_op_create_internal_buffer ();
    #####:  370:  ecma_object_t *object_p  = ecma_create_object (proto_p,
        -:  371:                                                 sizeof (ecma_extended_object_t),
        -:  372:                                                 ECMA_OBJECT_TYPE_CLASS);
    #####:  373:  ecma_deref_object (proto_p);
    #####:  374:  ecma_extended_object_t *map_obj_p = (ecma_extended_object_t *) object_p;
    #####:  375:  map_obj_p->u.cls.type = ECMA_OBJECT_CLASS_CONTAINER;
    #####:  376:  map_obj_p->u.cls.u1.container_flags = ECMA_CONTAINER_FLAGS_EMPTY;
    #####:  377:  map_obj_p->u.cls.u2.container_id = (uint16_t) lit_id;
        -:  378:
    #####:  379:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
        -:  380:  {
    #####:  381:    map_obj_p->u.cls.u1.container_flags |= ECMA_CONTAINER_FLAGS_WEAK;
        -:  382:  }
        -:  383:
    #####:  384:  ECMA_SET_INTERNAL_VALUE_POINTER (map_obj_p->u.cls.u3.value, container_p);
        -:  385:
    #####:  386:  ecma_value_t set_value = ecma_make_object_value (object_p);
    #####:  387:  ecma_value_t result = set_value;
        -:  388:
        -:  389:#if JERRY_ESNEXT
    #####:  390:  if (arguments_list_len == 0)
        -:  391:  {
    #####:  392:    return result;
        -:  393:  }
        -:  394:
    #####:  395:  ecma_value_t iterable = arguments_list_p[0];
        -:  396:
    #####:  397:  if (ecma_is_value_undefined (iterable) || ecma_is_value_null (iterable))
        -:  398:  {
    #####:  399:    return result;
        -:  400:  }
        -:  401:
        -:  402:  lit_magic_string_id_t adder_string_id;
    #####:  403:  if (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -:  404:  {
    #####:  405:    adder_string_id = LIT_MAGIC_STRING_SET;
        -:  406:  }
        -:  407:  else
        -:  408:  {
    #####:  409:    adder_string_id = LIT_MAGIC_STRING_ADD;
        -:  410:  }
        -:  411:
    #####:  412:  result = ecma_op_object_get_by_magic_id (object_p, adder_string_id);
    #####:  413:  if (ECMA_IS_VALUE_ERROR (result))
        -:  414:  {
    #####:  415:    goto cleanup_object;
        -:  416:  }
        -:  417:
    #####:  418:  if (!ecma_op_is_callable (result))
        -:  419:  {
    #####:  420:    ecma_free_value (result);
    #####:  421:    result = ecma_raise_type_error (ECMA_ERR_MSG ("Function add/set is not callable"));
    #####:  422:    goto cleanup_object;
        -:  423:  }
        -:  424:
    #####:  425:  ecma_object_t *adder_func_p = ecma_get_object_from_value (result);
        -:  426:
    #####:  427:  ecma_value_t next_method;
    #####:  428:  result = ecma_op_get_iterator (iterable, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  429:
    #####:  430:  if (ECMA_IS_VALUE_ERROR (result))
        -:  431:  {
    #####:  432:    goto cleanup_adder;
        -:  433:  }
        -:  434:
    #####:  435:  const ecma_value_t iterator = result;
        -:  436:
        -:  437:  while (true)
    #####:  438:  {
    #####:  439:    result = ecma_op_iterator_step (iterator, next_method);
        -:  440:
    #####:  441:    if (ECMA_IS_VALUE_ERROR (result))
        -:  442:    {
    #####:  443:      goto cleanup_iterator;
        -:  444:    }
        -:  445:
    #####:  446:    if (ecma_is_value_false (result))
        -:  447:    {
    #####:  448:      break;
        -:  449:    }
        -:  450:
    #####:  451:    const ecma_value_t next = result;
    #####:  452:    result = ecma_op_iterator_value (next);
    #####:  453:    ecma_free_value (next);
        -:  454:
    #####:  455:    if (ECMA_IS_VALUE_ERROR (result))
        -:  456:    {
    #####:  457:      goto cleanup_iterator;
        -:  458:    }
        -:  459:
    #####:  460:    if (lit_id == LIT_MAGIC_STRING_SET_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
        -:  461:    {
    #####:  462:      const ecma_value_t value = result;
        -:  463:
    #####:  464:      ecma_value_t arguments[] = { value };
    #####:  465:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 1);
        -:  466:
    #####:  467:      ecma_free_value (value);
        -:  468:    }
        -:  469:    else
        -:  470:    {
    #####:  471:      if (!ecma_is_value_object (result))
        -:  472:      {
    #####:  473:        ecma_free_value (result);
    #####:  474:        ecma_raise_type_error (ECMA_ERR_MSG ("Iterator value is not an object"));
    #####:  475:        result = ecma_op_iterator_close (iterator);
    #####:  476:        JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####:  477:        goto cleanup_iterator;
        -:  478:      }
        -:  479:
    #####:  480:      ecma_object_t *next_object_p = ecma_get_object_from_value (result);
        -:  481:
    #####:  482:      result = ecma_op_object_get_by_index (next_object_p, 0);
        -:  483:
    #####:  484:      if (ECMA_IS_VALUE_ERROR (result))
        -:  485:      {
    #####:  486:        ecma_deref_object (next_object_p);
    #####:  487:        ecma_op_iterator_close (iterator);
    #####:  488:        goto cleanup_iterator;
        -:  489:      }
        -:  490:
    #####:  491:      const ecma_value_t key = result;
        -:  492:
    #####:  493:      result = ecma_op_object_get_by_index (next_object_p, 1);
        -:  494:
    #####:  495:      if (ECMA_IS_VALUE_ERROR (result))
        -:  496:      {
    #####:  497:        ecma_deref_object (next_object_p);
    #####:  498:        ecma_free_value (key);
    #####:  499:        ecma_op_iterator_close (iterator);
    #####:  500:        goto cleanup_iterator;
        -:  501:      }
        -:  502:
    #####:  503:      const ecma_value_t value = result;
    #####:  504:      ecma_value_t arguments[] = { key, value };
    #####:  505:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 2);
        -:  506:
    #####:  507:      ecma_free_value (key);
    #####:  508:      ecma_free_value (value);
    #####:  509:      ecma_deref_object (next_object_p);
        -:  510:    }
        -:  511:
    #####:  512:    if (ECMA_IS_VALUE_ERROR (result))
        -:  513:    {
    #####:  514:      ecma_op_iterator_close (iterator);
    #####:  515:      goto cleanup_iterator;
        -:  516:    }
        -:  517:
    #####:  518:    ecma_free_value (result);
        -:  519:  }
        -:  520:
    #####:  521:  ecma_ref_object (object_p);
    #####:  522:  result = ecma_make_object_value (object_p);
        -:  523:
    #####:  524:cleanup_iterator:
    #####:  525:  ecma_free_value (iterator);
    #####:  526:  ecma_free_value (next_method);
    #####:  527:cleanup_adder:
    #####:  528:  ecma_deref_object (adder_func_p);
    #####:  529:cleanup_object:
    #####:  530:  ecma_deref_object (object_p);
        -:  531:#endif /* JERRY_ESNEXT */
        -:  532:
    #####:  533:  return result;
        -:  534:} /* ecma_op_container_create */
        -:  535:
        -:  536:/**
        -:  537: * Get Map/Set object pointer
        -:  538: *
        -:  539: * Note:
        -:  540: *   If the function returns with NULL, the error object has
        -:  541: *   already set, and the caller must return with ECMA_VALUE_ERROR
        -:  542: *
        -:  543: * @return pointer to the Map/Set if this_arg is a valid Map/Set object
        -:  544: *         NULL otherwise
        -:  545: */
        -:  546:ecma_extended_object_t *
    #####:  547:ecma_op_container_get_object (ecma_value_t this_arg, /**< this argument */
        -:  548:                              lit_magic_string_id_t lit_id) /**< internal class id */
        -:  549:{
    #####:  550:  if (ecma_is_value_object (this_arg))
        -:  551:  {
    #####:  552:    ecma_object_t *map_object_p = ecma_get_object_from_value (this_arg);
        -:  553:
    #####:  554:    if (ecma_object_class_is (map_object_p, ECMA_OBJECT_CLASS_CONTAINER)
    #####:  555:        && ((ecma_extended_object_t *) map_object_p)->u.cls.u2.container_id == lit_id)
        -:  556:    {
    #####:  557:      return (ecma_extended_object_t *) map_object_p;
        -:  558:    }
        -:  559:  }
        -:  560:
        -:  561:#if JERRY_ERROR_MESSAGES
    #####:  562:  ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  563:                                         "Expected a % object",
    #####:  564:                                         ecma_make_string_value (ecma_get_magic_string (lit_id)));
        -:  565:#else /* !JERRY_ERROR_MESSAGES */
        -:  566:  ecma_raise_type_error (NULL);
        -:  567:#endif /* JERRY_ERROR_MESSAGES */
        -:  568:
    #####:  569:  return NULL;
        -:  570:} /* ecma_op_container_get_object */
        -:  571:
        -:  572:/**
        -:  573: * Returns with the size of the Map/Set object.
        -:  574: *
        -:  575: * @return size of the Map/Set object as ecma-value.
        -:  576: */
        -:  577:ecma_value_t
    #####:  578:ecma_op_container_size (ecma_extended_object_t *map_object_p) /**< internal class id */
        -:  579:{
    #####:  580:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  581:                                                                    map_object_p->u.cls.u3.value);
        -:  582:
    #####:  583:  return ecma_make_uint32_value (ECMA_CONTAINER_GET_SIZE (container_p));
        -:  584:} /* ecma_op_container_size */
        -:  585:
        -:  586:/**
        -:  587: * The generic Map/WeakMap prototype object's 'get' routine
        -:  588: *
        -:  589: * @return ecma value
        -:  590: *         Returned value must be freed with ecma_free_value.
        -:  591: */
        -:  592:ecma_value_t
    #####:  593:ecma_op_container_get (ecma_extended_object_t *map_object_p, /**< map object */
        -:  594:                       ecma_value_t key_arg, /**< key argument */
        -:  595:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  596:{
    #####:  597:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL && !ecma_is_value_object (key_arg))
        -:  598:  {
    #####:  599:    return ECMA_VALUE_UNDEFINED;
        -:  600:  }
        -:  601:
    #####:  602:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  603:                                                                    map_object_p->u.cls.u3.value);
        -:  604:
    #####:  605:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  606:  {
    #####:  607:    return ECMA_VALUE_UNDEFINED;
        -:  608:  }
        -:  609:
    #####:  610:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  611:
    #####:  612:  if (entry_p == NULL)
        -:  613:  {
    #####:  614:    return ECMA_VALUE_UNDEFINED;
        -:  615:  }
        -:  616:
    #####:  617:  return ecma_copy_value (((ecma_container_pair_t *) entry_p)->value);
        -:  618:} /* ecma_op_container_get */
        -:  619:
        -:  620:/**
        -:  621: * The generic Map/Set prototype object's 'has' routine
        -:  622: *
        -:  623: * @return ecma value
        -:  624: *         Returned value must be freed with ecma_free_value.
        -:  625: */
        -:  626:ecma_value_t
    #####:  627:ecma_op_container_has (ecma_extended_object_t *map_object_p, /**< map object */
        -:  628:                       ecma_value_t key_arg, /**< key argument */
        -:  629:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  630:{
    #####:  631:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  632:                                                                    map_object_p->u.cls.u3.value);
        -:  633:
    #####:  634:  if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0
    #####:  635:      && !ecma_is_value_object (key_arg))
        -:  636:  {
    #####:  637:    return ECMA_VALUE_FALSE;
        -:  638:  }
        -:  639:
    #####:  640:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  641:  {
    #####:  642:    return ECMA_VALUE_FALSE;
        -:  643:  }
        -:  644:
    #####:  645:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  646:
    #####:  647:  return ecma_make_boolean_value (entry_p != NULL);
        -:  648:} /* ecma_op_container_has */
        -:  649:
        -:  650:/**
        -:  651: * Helper method for the Map.prototype.set and Set.prototype.add methods to swap the sign of the given value if needed
        -:  652: *
        -:  653: * See also:
        -:  654: *          ECMA-262 v6, 23.2.3.1 step 6
        -:  655: *          ECMA-262 v6, 23.1.3.9 step 6
        -:  656: *
        -:  657: * @return ecma value
        -:  658: */
        -:  659:static ecma_value_t
    #####:  660:ecma_op_container_set_noramlize_zero (ecma_value_t this_arg) /*< this arg */
        -:  661:{
    #####:  662:  if (ecma_is_value_number (this_arg))
        -:  663:  {
    #####:  664:    ecma_number_t number_value = ecma_get_number_from_value (this_arg);
        -:  665:
    #####:  666:    if (JERRY_UNLIKELY (ecma_number_is_zero (number_value) && ecma_number_is_negative (number_value)))
        -:  667:    {
    #####:  668:      return ecma_make_integer_value (0);
        -:  669:    }
        -:  670:  }
        -:  671:
    #####:  672:  return this_arg;
        -:  673:} /* ecma_op_container_set_noramlize_zero */
        -:  674:
        -:  675:/**
        -:  676: * The generic Map prototype object's 'set' and Set prototype object's 'add' routine
        -:  677: *
        -:  678: * @return ecma value
        -:  679: *         Returned value must be freed with ecma_free_value.
        -:  680: */
        -:  681:ecma_value_t
    #####:  682:ecma_op_container_set (ecma_extended_object_t *map_object_p, /**< map object */
        -:  683:                       ecma_value_t key_arg, /**< key argument */
        -:  684:                       ecma_value_t value_arg, /**< value argument */
        -:  685:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  686:{
    #####:  687:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  688:                                                                    map_object_p->u.cls.u3.value);
        -:  689:
    #####:  690:  if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0
    #####:  691:      && !ecma_is_value_object (key_arg))
        -:  692:  {
    #####:  693:    return ecma_raise_type_error (ECMA_ERR_MSG ("Key must be an object"));
        -:  694:  }
        -:  695:
    #####:  696:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  697:
    #####:  698:  if (entry_p == NULL)
        -:  699:  {
    #####:  700:    ecma_op_internal_buffer_append (container_p,
        -:  701:                                    ecma_op_container_set_noramlize_zero (key_arg),
        -:  702:                                    value_arg,
        -:  703:                                    lit_id);
        -:  704:
    #####:  705:    if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0)
        -:  706:    {
    #####:  707:      ecma_object_t *key_p = ecma_get_object_from_value (key_arg);
    #####:  708:      ecma_op_object_set_weak (key_p, (ecma_object_t *) map_object_p);
        -:  709:    }
        -:  710:  }
        -:  711:  else
        -:  712:  {
    #####:  713:    ecma_op_internal_buffer_update (entry_p, ecma_op_container_set_noramlize_zero (value_arg), lit_id);
        -:  714:  }
        -:  715:
    #####:  716:  ecma_ref_object ((ecma_object_t *) map_object_p);
    #####:  717:  return ecma_make_object_value ((ecma_object_t *) map_object_p);
        -:  718:} /* ecma_op_container_set */
        -:  719:
        -:  720:/**
        -:  721: * The generic Map/Set prototype object's 'forEach' routine
        -:  722: *
        -:  723: * @return ecma value
        -:  724: *         Returned value must be freed with ecma_free_value.
        -:  725: */
        -:  726:ecma_value_t
    #####:  727:ecma_op_container_foreach (ecma_extended_object_t *map_object_p, /**< map object */
        -:  728:                           ecma_value_t predicate, /**< callback function */
        -:  729:                           ecma_value_t predicate_this_arg, /**< this argument for
        -:  730:                                                             *   invoke predicate */
        -:  731:                           lit_magic_string_id_t lit_id) /**< internal class id */
        -:  732:{
    #####:  733:  if (!ecma_op_is_callable (predicate))
        -:  734:  {
    #####:  735:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -:  736:  }
        -:  737:
    #####:  738:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####:  739:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
    #####:  740:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -:  741:
    #####:  742:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  743:                                                                    map_object_p->u.cls.u3.value);
        -:  744:
    #####:  745:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
        -:  746:
    #####:  747:  for (uint32_t i = 0; i < ECMA_CONTAINER_ENTRY_COUNT (container_p); i += entry_size)
        -:  748:  {
    #####:  749:    ecma_value_t *entry_p = ECMA_CONTAINER_START (container_p) + i;
        -:  750:
    #####:  751:    if (ecma_is_value_empty (*entry_p))
        -:  752:    {
    #####:  753:      continue;
        -:  754:    }
        -:  755:
    #####:  756:    ecma_value_t key_arg = *entry_p;
    #####:  757:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -:  758:
    #####:  759:    ecma_value_t this_arg = ecma_make_object_value ((ecma_object_t *) map_object_p);
    #####:  760:    ecma_value_t call_args[] = { value_arg, key_arg, this_arg };
    #####:  761:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -:  762:
    #####:  763:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  764:    {
    #####:  765:      ret_value = call_value;
    #####:  766:      break;
        -:  767:    }
        -:  768:
    #####:  769:    ecma_free_value (call_value);
        -:  770:  }
        -:  771:
    #####:  772:  return ret_value;
        -:  773:} /* ecma_op_container_foreach */
        -:  774:
        -:  775:/**
        -:  776: * The Map/Set prototype object's 'clear' routine
        -:  777: *
        -:  778: * @return ecma value
        -:  779: *         Returned value must be freed with ecma_free_value.
        -:  780: */
        -:  781:ecma_value_t
    #####:  782:ecma_op_container_clear (ecma_extended_object_t *map_object_p) /**< this argument */
        -:  783:{
        -:  784:
    #####:  785:  ecma_op_container_free_entries ((ecma_object_t *) map_object_p);
        -:  786:
    #####:  787:  return ECMA_VALUE_UNDEFINED;
        -:  788:} /* ecma_op_container_clear */
        -:  789:
        -:  790:/**
        -:  791: * The generic Map/Set prototype object's 'delete' routine
        -:  792: *
        -:  793: * @return ecma value
        -:  794: *         Returned value must be freed with ecma_free_value.
        -:  795: */
        -:  796:ecma_value_t
    #####:  797:ecma_op_container_delete (ecma_extended_object_t *map_object_p, /**< map object */
        -:  798:                          ecma_value_t key_arg, /**< key argument */
        -:  799:                          lit_magic_string_id_t lit_id) /**< internal class id */
        -:  800:{
    #####:  801:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  802:                                                                    map_object_p->u.cls.u3.value);
        -:  803:
    #####:  804:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  805:
    #####:  806:  if (entry_p == NULL)
        -:  807:  {
    #####:  808:    return ECMA_VALUE_FALSE;
        -:  809:  }
        -:  810:
    #####:  811:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
    #####:  812:  return ECMA_VALUE_TRUE;
        -:  813:} /* ecma_op_container_delete */
        -:  814:
        -:  815:/**
        -:  816: * The generic WeakMap/WeakSet prototype object's 'delete' routine
        -:  817: *
        -:  818: * @return ecma value
        -:  819: *         Returned value must be freed with ecma_free_value.
        -:  820: */
        -:  821:ecma_value_t
    #####:  822:ecma_op_container_delete_weak (ecma_extended_object_t *map_object_p, /**< map object */
        -:  823:                               ecma_value_t key_arg, /**< key argument */
        -:  824:                               lit_magic_string_id_t lit_id) /**< internal class id */
        -:  825:{
    #####:  826:  if (!ecma_is_value_object (key_arg))
        -:  827:  {
    #####:  828:    return ECMA_VALUE_FALSE;
        -:  829:  }
        -:  830:
    #####:  831:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  832:                                                                    map_object_p->u.cls.u3.value);
        -:  833:
    #####:  834:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  835:
    #####:  836:  if (entry_p == NULL)
        -:  837:  {
    #####:  838:    return ECMA_VALUE_FALSE;
        -:  839:  }
        -:  840:
    #####:  841:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
        -:  842:
    #####:  843:  ecma_object_t *key_object_p = ecma_get_object_from_value (key_arg);
    #####:  844:  ecma_op_object_unref_weak (key_object_p, ecma_make_object_value ((ecma_object_t *) map_object_p));
        -:  845:
    #####:  846:  return ECMA_VALUE_TRUE;
        -:  847:} /* ecma_op_container_delete_weak */
        -:  848:
        -:  849:/**
        -:  850: * Helper function to get the value from a weak container object
        -:  851: *
        -:  852: * @return value property
        -:  853: */
        -:  854:ecma_value_t
    #####:  855:ecma_op_container_find_weak_value (ecma_object_t *object_p, /**< internal container object */
        -:  856:                                   ecma_value_t key_arg) /**< key */
        -:  857:{
    #####:  858:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
        -:  859:
    #####:  860:  JERRY_ASSERT (map_object_p->u.cls.type == ECMA_OBJECT_CLASS_CONTAINER
        -:  861:                && map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL);
        -:  862:
    #####:  863:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  864:                                                                    map_object_p->u.cls.u3.value);
        -:  865:
    #####:  866:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.cls.u2.container_id);
        -:  867:
    #####:  868:  JERRY_ASSERT (entry_p != NULL);
        -:  869:
    #####:  870:  return entry_p[1];
        -:  871:} /* ecma_op_container_find_weak_value */
        -:  872:
        -:  873:/**
        -:  874: * Helper function to remove a key/value pair from a weak container object
        -:  875: */
        -:  876:void
    #####:  877:ecma_op_container_remove_weak_entry (ecma_object_t *object_p, /**< internal container object */
        -:  878:                                     ecma_value_t key_arg) /**< key */
        -:  879:{
    #####:  880:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
        -:  881:
    #####:  882:  JERRY_ASSERT (map_object_p->u.cls.type == ECMA_OBJECT_CLASS_CONTAINER
        -:  883:                && (map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKSET_UL
        -:  884:                    || map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL));
        -:  885:
    #####:  886:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  887:                                                                    map_object_p->u.cls.u3.value);
        -:  888:
    #####:  889:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.cls.u2.container_id);
        -:  890:
    #####:  891:  JERRY_ASSERT (entry_p != NULL);
        -:  892:
    #####:  893:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, map_object_p->u.cls.u2.container_id);
    #####:  894:} /* ecma_op_container_remove_weak_entry */
        -:  895:
        -:  896:#if JERRY_ESNEXT
        -:  897:
        -:  898:/**
        -:  899: * The Create{Set, Map}Iterator Abstract operation
        -:  900: *
        -:  901: * See also:
        -:  902: *          ECMA-262 v6, 23.1.5.1
        -:  903: *          ECMA-262 v6, 23.2.5.1
        -:  904: *
        -:  905: * Note:
        -:  906: *     Returned value must be freed with ecma_free_value.
        -:  907: *
        -:  908: * @return Map/Set iterator object, if success
        -:  909: *         error - otherwise
        -:  910: */
        -:  911:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  912:ecma_op_container_create_iterator (ecma_value_t this_arg, /**< this argument */
        -:  913:                                   ecma_builtin_id_t proto_id, /**< prototype builtin id */
        -:  914:                                   ecma_object_class_type_t iterator_type, /**< iterator type */
        -:  915:                                   ecma_iterator_kind_t kind) /**< iterator kind */
        -:  916:{
    #####:  917:  return ecma_op_create_iterator_object (this_arg,
        -:  918:                                         ecma_builtin_get (proto_id),
        -:  919:                                         iterator_type,
        -:  920:                                         kind);
        -:  921:} /* ecma_op_container_create_iterator */
        -:  922:
        -:  923:/**
        -:  924: * Get the index of the iterator object.
        -:  925: *
        -:  926: * @return index of the iterator.
        -:  927: */
        -:  928:static uint32_t
    #####:  929:ecma_op_iterator_get_index (ecma_object_t *iter_obj_p)  /**< iterator object pointer */
        -:  930:{
    #####:  931:  uint32_t index = ((ecma_extended_object_t *) iter_obj_p)->u.cls.u2.iterator_index;
        -:  932:
    #####:  933:  if (JERRY_UNLIKELY (index == ECMA_ITERATOR_INDEX_LIMIT))
        -:  934:  {
    #####:  935:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####:  936:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
    #####:  937:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  938:
    #####:  939:    return (uint32_t) (ecma_get_number_from_value (value_p->value));
        -:  940:  }
        -:  941:
    #####:  942:  return index;
        -:  943:} /* ecma_op_iterator_get_index */
        -:  944:
        -:  945:/**
        -:  946: * Set the index of the iterator object.
        -:  947: */
        -:  948:static void
    #####:  949:ecma_op_iterator_set_index (ecma_object_t *iter_obj_p, /**< iterator object pointer */
        -:  950:                            uint32_t index) /* iterator index to set */
        -:  951:{
    #####:  952:  if (JERRY_UNLIKELY (index >= ECMA_ITERATOR_INDEX_LIMIT))
        -:  953:  {
        -:  954:    /* After the ECMA_ITERATOR_INDEX_LIMIT limit is reached the [[%Iterator%NextIndex]]
        -:  955:       property is stored as an internal property */
    #####:  956:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####:  957:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
        -:  958:    ecma_property_value_t *value_p;
        -:  959:
    #####:  960:    if (property_p == NULL)
        -:  961:    {
    #####:  962:      value_p = ecma_create_named_data_property (iter_obj_p, prop_name_p, ECMA_PROPERTY_FLAG_WRITABLE, &property_p);
    #####:  963:      value_p->value = ecma_make_uint32_value (index);
        -:  964:    }
        -:  965:    else
        -:  966:    {
    #####:  967:      value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  968:      value_p->value = ecma_make_uint32_value (index);
        -:  969:    }
        -:  970:  }
        -:  971:  else
        -:  972:  {
    #####:  973:    ((ecma_extended_object_t *) iter_obj_p)->u.cls.u2.iterator_index = (uint16_t) index;
        -:  974:  }
    #####:  975:} /* ecma_op_iterator_set_index */
        -:  976:
        -:  977:/**
        -:  978: * The %{Set, Map}IteratorPrototype% object's 'next' routine
        -:  979: *
        -:  980: * See also:
        -:  981: *          ECMA-262 v6, 23.1.5.2.1
        -:  982: *          ECMA-262 v6, 23.2.5.2.1
        -:  983: *
        -:  984: * Note:
        -:  985: *     Returned value must be freed with ecma_free_value.
        -:  986: *
        -:  987: * @return iterator result object, if success
        -:  988: *         error - otherwise
        -:  989: */
        -:  990:ecma_value_t
    #####:  991:ecma_op_container_iterator_next (ecma_value_t this_val, /**< this argument */
        -:  992:                                 ecma_object_class_type_t iterator_type) /**< type of the iterator */
        -:  993:{
    #####:  994:  if (!ecma_is_value_object (this_val))
        -:  995:  {
    #####:  996:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -:  997:  }
        -:  998:
    #####:  999:  ecma_object_t *obj_p = ecma_get_object_from_value (this_val);
    #####: 1000:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1001:
    #####: 1002:  if (!ecma_object_class_is (obj_p, iterator_type))
        -: 1003:  {
    #####: 1004:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an iterator"));
        -: 1005:  }
        -: 1006:
    #####: 1007:  ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 1008:
    #####: 1009:  if (ecma_is_value_empty (iterated_value))
        -: 1010:  {
    #####: 1011:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -: 1012:  }
        -: 1013:
    #####: 1014:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
    #####: 1015:  lit_magic_string_id_t lit_id = map_object_p->u.cls.u2.container_id;
        -: 1016:
    #####: 1017:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 1018:                                                                    map_object_p->u.cls.u3.value);
    #####: 1019:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 1020:  uint32_t index = ecma_op_iterator_get_index (obj_p);
        -: 1021:
    #####: 1022:  if (index == entry_count)
        -: 1023:  {
    #####: 1024:    ext_obj_p->u.cls.u3.iterated_value = ECMA_VALUE_EMPTY;
        -: 1025:
    #####: 1026:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -: 1027:  }
        -: 1028:
    #####: 1029:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####: 1030:  uint8_t iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
    #####: 1031:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####: 1032:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -: 1033:
    #####: 1034:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 1035:  {
    #####: 1036:    ecma_value_t *entry_p = start_p + i;
        -: 1037:
    #####: 1038:    if (ecma_is_value_empty (*entry_p))
        -: 1039:    {
    #####: 1040:      if (i == (entry_count - entry_size))
        -: 1041:      {
    #####: 1042:        ret_value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
    #####: 1043:        break;
        -: 1044:      }
        -: 1045:
    #####: 1046:      continue;
        -: 1047:    }
        -: 1048:
    #####: 1049:    ecma_op_iterator_set_index (obj_p, i + entry_size);
        -: 1050:
    #####: 1051:    ecma_value_t key_arg = *entry_p;
    #####: 1052:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -: 1053:
    #####: 1054:    if (iterator_kind == ECMA_ITERATOR_KEYS)
        -: 1055:    {
    #####: 1056:      ret_value = ecma_create_iter_result_object (key_arg, ECMA_VALUE_FALSE);
        -: 1057:    }
    #####: 1058:    else if (iterator_kind == ECMA_ITERATOR_VALUES)
        -: 1059:    {
    #####: 1060:      ret_value = ecma_create_iter_result_object (value_arg, ECMA_VALUE_FALSE);
        -: 1061:    }
        -: 1062:    else
        -: 1063:    {
    #####: 1064:      JERRY_ASSERT (iterator_kind == ECMA_ITERATOR_ENTRIES);
        -: 1065:
        -: 1066:      ecma_value_t entry_array_value;
    #####: 1067:      entry_array_value = ecma_create_array_from_iter_element (value_arg, key_arg);
        -: 1068:
    #####: 1069:      ret_value = ecma_create_iter_result_object (entry_array_value, ECMA_VALUE_FALSE);
    #####: 1070:      ecma_free_value (entry_array_value);
        -: 1071:    }
        -: 1072:
    #####: 1073:    break;
        -: 1074:  }
        -: 1075:
    #####: 1076:  return ret_value;
        -: 1077:} /* ecma_op_container_iterator_next */
        -: 1078:
        -: 1079:/**
        -: 1080: * Dispatcher of builtin container routines.
        -: 1081: *
        -: 1082: * @return ecma value
        -: 1083: *         Returned value must be freed with ecma_free_value.
        -: 1084: */
        -: 1085:ecma_value_t
    #####: 1086:ecma_builtin_container_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine
        -: 1087:                                                                       *   identifier */
        -: 1088:                                         ecma_value_t this_arg, /**< 'this' argument value */
        -: 1089:                                         const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1090:                                                                                 *   passed to routine */
        -: 1091:                                         lit_magic_string_id_t lit_id) /**< internal class id */
        -: 1092:{
    #####: 1093:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -: 1094:
    #####: 1095:  if (map_object_p == NULL)
        -: 1096:  {
    #####: 1097:    return ECMA_VALUE_ERROR;
        -: 1098:  }
        -: 1099:
    #####: 1100:  switch (builtin_routine_id)
        -: 1101:  {
    #####: 1102:    case ECMA_CONTAINER_ROUTINE_DELETE:
        -: 1103:    {
    #####: 1104:      return ecma_op_container_delete (map_object_p, arguments_list_p[0], lit_id);
        -: 1105:    }
    #####: 1106:    case ECMA_CONTAINER_ROUTINE_DELETE_WEAK:
        -: 1107:    {
    #####: 1108:      return ecma_op_container_delete_weak (map_object_p, arguments_list_p[0], lit_id);
        -: 1109:    }
    #####: 1110:    case ECMA_CONTAINER_ROUTINE_GET:
        -: 1111:    {
    #####: 1112:      return ecma_op_container_get (map_object_p, arguments_list_p[0], lit_id);
        -: 1113:    }
    #####: 1114:    case ECMA_CONTAINER_ROUTINE_SET:
        -: 1115:    {
    #####: 1116:      return ecma_op_container_set (map_object_p, arguments_list_p[0], arguments_list_p[1], lit_id);
        -: 1117:    }
    #####: 1118:    case ECMA_CONTAINER_ROUTINE_HAS:
        -: 1119:    {
    #####: 1120:      return ecma_op_container_has (map_object_p, arguments_list_p[0], lit_id);
        -: 1121:    }
    #####: 1122:    case ECMA_CONTAINER_ROUTINE_FOREACH:
        -: 1123:    {
    #####: 1124:      return ecma_op_container_foreach (map_object_p, arguments_list_p[0], arguments_list_p[1], lit_id);
        -: 1125:    }
    #####: 1126:    case ECMA_CONTAINER_ROUTINE_SIZE_GETTER:
        -: 1127:    {
    #####: 1128:      return ecma_op_container_size (map_object_p);
        -: 1129:    }
    #####: 1130:    case ECMA_CONTAINER_ROUTINE_ADD:
        -: 1131:    {
    #####: 1132:      return ecma_op_container_set (map_object_p, arguments_list_p[0], arguments_list_p[0], lit_id);
        -: 1133:    }
    #####: 1134:    case ECMA_CONTAINER_ROUTINE_CLEAR:
        -: 1135:    {
    #####: 1136:      return ecma_op_container_clear (map_object_p);
        -: 1137:    }
    #####: 1138:    case ECMA_CONTAINER_ROUTINE_KEYS:
        -: 1139:    case ECMA_CONTAINER_ROUTINE_VALUES:
        -: 1140:    case ECMA_CONTAINER_ROUTINE_ENTRIES:
        -: 1141:    {
    #####: 1142:      ecma_builtin_id_t builtin_iterator_prototype = ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE;
    #####: 1143:      ecma_object_class_type_t iterator_type = ECMA_OBJECT_CLASS_MAP_ITERATOR;
        -: 1144:
    #####: 1145:      if (lit_id != LIT_MAGIC_STRING_MAP_UL)
        -: 1146:      {
    #####: 1147:        builtin_iterator_prototype = ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE;
    #####: 1148:        iterator_type = ECMA_OBJECT_CLASS_SET_ITERATOR;
        -: 1149:      }
        -: 1150:
    #####: 1151:      ecma_iterator_kind_t kind = (ecma_iterator_kind_t) (builtin_routine_id - ECMA_CONTAINER_ROUTINE_KEYS);
        -: 1152:
    #####: 1153:      return ecma_op_container_create_iterator (this_arg,
        -: 1154:                                                builtin_iterator_prototype,
        -: 1155:                                                iterator_type,
        -: 1156:                                                kind);
        -: 1157:    }
    #####: 1158:    default:
        -: 1159:    {
    #####: 1160:      JERRY_UNREACHABLE ();
        -: 1161:    }
        -: 1162:  }
        -: 1163:} /* ecma_builtin_container_dispatch_routine */
        -: 1164:
        -: 1165:#endif /* JERRY_ESNEXT */
        -: 1166:
        -: 1167:/**
        -: 1168: * @}
        -: 1169: * @}
        -: 1170: */
        -: 1171:
        -: 1172:#endif /* JERRY_BUILTIN_CONTAINER */
