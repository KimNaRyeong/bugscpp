        -:    0:Source:/home/workspace/jerry-math/sinh.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Developed at SunSoft, a Sun Microsystems, Inc. business.
        -:   21: *     Permission to use, copy, modify, and distribute this
        -:   22: *     software is freely granted, provided that this notice
        -:   23: *     is preserved.
        -:   24: *
        -:   25: *     @(#)e_sinh.c 1.3 95/01/18
        -:   26: */
        -:   27:
        -:   28:#include "jerry-math-internal.h"
        -:   29:
        -:   30:/* __sinh(x)
        -:   31: * Method:
        -:   32: * mathematically sinh(x) if defined to be (exp(x) - exp(-x)) / 2
        -:   33: *  1. Replace x by |x| (sinh(-x) = -sinh(x)).
        -:   34: *  2.
        -:   35: *                                             E + E/(E+1)
        -:   36: *      0        <= x <= 22     :  sinh(x) := -------------, E = expm1(x)
        -:   37: *                                                  2
        -:   38: *
        -:   39: *      22       <= x <= lnovft :  sinh(x) := exp(x) / 2
        -:   40: *      lnovft   <= x <= ln2ovft:  sinh(x) := exp(x / 2) / 2 * exp(x / 2)
        -:   41: *      ln2ovft  <  x           :  sinh(x) := x * shuge (overflow)
        -:   42: *
        -:   43: * Special cases:
        -:   44: *  sinh(x) is |x| if x is +INF, -INF, or NaN.
        -:   45: *  only sinh(0) = 0 is exact for finite x.
        -:   46: */
        -:   47:
        -:   48:#define one 1.0
        -:   49:#define half 0.5
        -:   50:#define shuge 1.0e307
        -:   51:
        -:   52:double
    #####:   53:sinh (double x)
        -:   54:{
        -:   55:  double t, w, h;
        -:   56:  int ix, jx;
        -:   57:  unsigned lx;
        -:   58:
        -:   59:  /* High word of |x|. */
    #####:   60:  jx = __HI (x);
    #####:   61:  ix = jx & 0x7fffffff;
        -:   62:
        -:   63:  /* x is INF or NaN */
    #####:   64:  if (ix >= 0x7ff00000)
        -:   65:  {
    #####:   66:    return x + x;
        -:   67:  }
        -:   68:
    #####:   69:  h = 0.5;
    #####:   70:  if (jx < 0)
        -:   71:  {
    #####:   72:    h = -h;
        -:   73:  }
        -:   74:  /* |x| in [0,22], return sign(x) * 0.5 * (E + E / (E + 1))) */
    #####:   75:  if (ix < 0x40360000)
        -:   76:  {
        -:   77:    /* |x| < 22 */
    #####:   78:    if (ix < 0x3e300000)
        -:   79:    {
        -:   80:      /* |x| < 2**-28 */
    #####:   81:      if (shuge + x > one)
        -:   82:      {
        -:   83:        /* sinh(tiny) = tiny with inexact */
        -:   84:        return x;
        -:   85:      }
        -:   86:    }
    #####:   87:    t = expm1 (fabs (x));
    #####:   88:    if (ix < 0x3ff00000)
        -:   89:    {
    #####:   90:      return h * (2.0 * t - t * t / (t + one));
        -:   91:    }
    #####:   92:    return h * (t + t / (t + one));
        -:   93:  }
        -:   94:
        -:   95:  /* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
    #####:   96:  if (ix < 0x40862E42)
        -:   97:  {
    #####:   98:    return h * exp (fabs (x));
        -:   99:  }
        -:  100:  /* |x| in [log(maxdouble), overflowthresold] */
    #####:  101:  lx = ((1 >> 29) + (unsigned int) x);
    #####:  102:  if (ix < 0x408633CE || ((ix == 0x408633ce) && (lx <= (unsigned) 0x8fb9f87d)))
        -:  103:  {
    #####:  104:    w = exp (0.5 * fabs (x));
    #####:  105:    t = h * w;
    #####:  106:    return t * w;
        -:  107:  }
        -:  108:
        -:  109:  /* |x| > overflowthresold, sinh(x) overflow */
    #####:  110:  return x * shuge;
        -:  111:} /* sinh */
        -:  112:
        -:  113:#undef one
        -:  114:#undef half
        -:  115:#undef huge
