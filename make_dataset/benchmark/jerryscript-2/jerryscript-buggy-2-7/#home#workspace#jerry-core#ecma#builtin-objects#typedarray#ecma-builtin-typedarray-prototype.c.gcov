        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-bigint.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-builtin-typedarray-helpers.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-comparison.h"
        -:   24:#include "ecma-conversion.h"
        -:   25:#include "ecma-exceptions.h"
        -:   26:#include "ecma-function-object.h"
        -:   27:#include "ecma-gc.h"
        -:   28:#include "ecma-globals.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-number-object.h"
        -:   32:#include "ecma-objects.h"
        -:   33:#include "ecma-typedarray-object.h"
        -:   34:#include "jcontext.h"
        -:   35:#include "jmem.h"
        -:   36:#include "jrt-libc-includes.h"
        -:   37:#include "jrt.h"
        -:   38:#include "lit-char-helpers.h"
        -:   39:
        -:   40:#if JERRY_BUILTIN_TYPEDARRAY
        -:   41:
        -:   42:#define ECMA_BUILTINS_INTERNAL
        -:   43:#include "ecma-builtins-internal.h"
        -:   44:
        -:   45:/**
        -:   46: * This object has a custom dispatch function.
        -:   47: */
        -:   48:#define BUILTIN_CUSTOM_DISPATCH
        -:   49:
        -:   50:/**
        -:   51: * List of built-in routine identifiers.
        -:   52: */
        -:   53:enum
        -:   54:{
        -:   55:  /* These routines must be in this order */
        -:   56:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   57:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP,
        -:   58:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE,
        -:   59:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT,
        -:   60:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY,
        -:   61:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME,
        -:   62:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH,
        -:   63:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER,
        -:   64:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND,
        -:   65:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX,
        -:   66:
        -:   67:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF,
        -:   68:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT,
        -:   69:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF,
        -:   70:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES,
        -:   71:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL,
        -:   72:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT,
        -:   73:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE,
        -:   74:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN,
        -:   75:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE,
        -:   76:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY,
        -:   77:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING,
        -:   78:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN,
        -:   79:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS,
        -:   80:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES,
        -:   81:
        -:   82:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER,
        -:   83:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER,
        -:   84:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER,
        -:   85:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER,
        -:   86:
        -:   87:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET,
        -:   88:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER,
        -:   89:};
        -:   90:
        -:   91:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-typedarray-prototype.inc.h"
        -:   92:#define BUILTIN_UNDERSCORED_ID typedarray_prototype
        -:   93:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   94:
        -:   95:/** \addtogroup ecma ECMA
        -:   96: * @{
        -:   97: *
        -:   98: * \addtogroup ecmabuiltins
        -:   99: * @{
        -:  100: *
        -:  101: * \addtogroup typedarrayprototype ECMA %TypedArray%.prototype object built-in
        -:  102: * @{
        -:  103: */
        -:  104:
        -:  105:/**
        -:  106: * Type of routine.
        -:  107: */
        -:  108:typedef enum
        -:  109:{
        -:  110:  TYPEDARRAY_ROUTINE_EVERY, /**< routine: every ES2015, 22.2.3.7 */
        -:  111:  TYPEDARRAY_ROUTINE_SOME, /**< routine: some ES2015, 22.2.3.9 */
        -:  112:  TYPEDARRAY_ROUTINE_FOREACH, /**< routine: forEach ES2015, 15.4.4.18 */
        -:  113:  TYPEDARRAY_ROUTINE__COUNT /**< count of the modes */
        -:  114:} typedarray_routine_mode;
        -:  115:
        -:  116:/**
        -:  117: * The common function for 'every', 'some' and 'forEach'
        -:  118: * because they have a similar structure.
        -:  119: *
        -:  120: * @return ecma value
        -:  121: *         Returned value must be freed with ecma_free_value.
        -:  122: */
        -:  123:static ecma_value_t
    #####:  124:ecma_builtin_typedarray_prototype_exec_routine (ecma_value_t this_arg, /**< this argument */
        -:  125:                                                ecma_typedarray_info_t *info_p, /**< object info */
        -:  126:                                                ecma_value_t cb_func_val, /**< callback function */
        -:  127:                                                ecma_value_t cb_this_arg, /**< 'this' of the callback function */
        -:  128:                                                typedarray_routine_mode mode) /**< mode: which routine */
        -:  129:{
    #####:  130:  JERRY_ASSERT (mode < TYPEDARRAY_ROUTINE__COUNT);
        -:  131:
    #####:  132:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####:  133:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  134:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####:  135:  uint32_t byte_pos = 0;
    #####:  136:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  137:
    #####:  138:  for (uint32_t index = 0; index < info_p->length && ecma_is_value_empty (ret_value); index++)
        -:  139:  {
    #####:  140:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  141:    ecma_value_t element = typedarray_getter_cb (buffer_p + byte_pos);
        -:  142:
    #####:  143:    ecma_value_t call_args[] = { element, current_index, this_arg };
        -:  144:
    #####:  145:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  146:
    #####:  147:    ecma_fast_free_value (current_index);
    #####:  148:    ecma_fast_free_value (element);
        -:  149:
    #####:  150:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  151:    {
    #####:  152:      return call_value;
        -:  153:    }
        -:  154:
    #####:  155:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  156:    {
    #####:  157:      ecma_free_value (call_value);
    #####:  158:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  159:    }
        -:  160:
    #####:  161:    bool to_bool_result = ecma_op_to_boolean (call_value);
    #####:  162:    ecma_free_value (call_value);
        -:  163:
    #####:  164:    if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  165:    {
    #####:  166:      if (!to_bool_result)
        -:  167:      {
    #####:  168:        return ECMA_VALUE_FALSE;
        -:  169:      }
        -:  170:    }
    #####:  171:    else if (mode == TYPEDARRAY_ROUTINE_SOME
    #####:  172:             && to_bool_result)
        -:  173:    {
    #####:  174:      return ECMA_VALUE_TRUE;
        -:  175:    }
        -:  176:
    #####:  177:    byte_pos += info_p->element_size;
        -:  178:  }
        -:  179:
    #####:  180:  if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  181:  {
    #####:  182:    ret_value = ECMA_VALUE_TRUE;
        -:  183:  }
    #####:  184:  else if (mode == TYPEDARRAY_ROUTINE_SOME)
        -:  185:  {
    #####:  186:    ret_value = ECMA_VALUE_FALSE;
        -:  187:  }
        -:  188:  else
        -:  189:  {
    #####:  190:    ret_value = ECMA_VALUE_UNDEFINED;
        -:  191:  }
        -:  192:
    #####:  193:  return ret_value;
        -:  194:} /* ecma_builtin_typedarray_prototype_exec_routine */
        -:  195:
        -:  196:/**
        -:  197: * The %TypedArray%.prototype object's 'map' routine
        -:  198: *
        -:  199: * See also:
        -:  200: *          ES2015, 22.2.3.8
        -:  201: *
        -:  202: * @return ecma value
        -:  203: *         Returned value must be freed with ecma_free_value.
        -:  204: */
        -:  205:static ecma_value_t
    #####:  206:ecma_builtin_typedarray_prototype_map (ecma_value_t this_arg, /**< this object */
        -:  207:                                       ecma_typedarray_info_t *src_info_p, /**< object info */
        -:  208:                                       ecma_value_t cb_func_val, /**< callback function */
        -:  209:                                       ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  210:{
    #####:  211:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
        -:  212:
        -:  213:  // TODO: 22.2.3.18, 7-8.
    #####:  214:  ecma_value_t len = ecma_make_number_value (src_info_p->length);
    #####:  215:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####:  216:  ecma_free_value (len);
        -:  217:
    #####:  218:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  219:  {
    #####:  220:    return new_typedarray;
        -:  221:  }
        -:  222:
    #####:  223:  ecma_object_t *target_obj_p = ecma_get_object_from_value (new_typedarray);
    #####:  224:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (src_info_p);
        -:  225:
    #####:  226:  if (JERRY_UNLIKELY (src_buffer_p == NULL))
        -:  227:  {
    #####:  228:    ecma_deref_object (target_obj_p);
    #####:  229:    return ECMA_VALUE_ERROR;
        -:  230:  }
        -:  231:
    #####:  232:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_obj_p);
    #####:  233:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  234:
    #####:  235:  if (JERRY_UNLIKELY (target_buffer_p == NULL))
        -:  236:  {
    #####:  237:    ecma_deref_object (target_obj_p);
    #####:  238:    return ECMA_VALUE_ERROR;
        -:  239:  }
        -:  240:
    #####:  241:  ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info_p->id);
    #####:  242:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  243:
    #####:  244:  for (uint32_t index = 0; index < src_info_p->length; index++)
        -:  245:  {
    #####:  246:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  247:    ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####:  248:    src_buffer_p += src_info_p->element_size;
        -:  249:
    #####:  250:    ecma_value_t call_args[] = { element, current_index, this_arg };
    #####:  251:    ecma_value_t mapped_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  252:
    #####:  253:    ecma_free_value (current_index);
    #####:  254:    ecma_free_value (element);
        -:  255:
    #####:  256:    if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  257:    {
    #####:  258:      ecma_free_value (new_typedarray);
    #####:  259:      return mapped_value;
        -:  260:    }
        -:  261:
    #####:  262:    if (ecma_arraybuffer_is_detached (src_info_p->array_buffer_p))
        -:  263:    {
    #####:  264:      ecma_free_value (mapped_value);
    #####:  265:      ecma_free_value (new_typedarray);
    #####:  266:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  267:    }
        -:  268:
    #####:  269:    ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, mapped_value);
    #####:  270:    target_buffer_p += target_info.element_size;
    #####:  271:    ecma_free_value (mapped_value);
        -:  272:
    #####:  273:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  274:    {
    #####:  275:      ecma_free_value (new_typedarray);
    #####:  276:      return set_element;
        -:  277:    }
        -:  278:  }
        -:  279:
    #####:  280:  return new_typedarray;
        -:  281:} /* ecma_builtin_typedarray_prototype_map */
        -:  282:
        -:  283:/**
        -:  284: * Reduce and reduceRight routines share a similar structure.
        -:  285: * And we use 'is_right' to distinguish between them.
        -:  286: *
        -:  287: * @return ecma value
        -:  288: *         Returned value must be freed with ecma_free_value.
        -:  289: */
        -:  290:static ecma_value_t
    #####:  291:ecma_builtin_typedarray_prototype_reduce_with_direction (ecma_value_t this_arg, /**< this object */
        -:  292:                                                         ecma_typedarray_info_t *info_p, /**< object info */
        -:  293:                                                         const ecma_value_t arguments_list_p[], /**arg_list*/
        -:  294:                                                         uint32_t arguments_number, /**< length of arguments' list*/
        -:  295:                                                         bool is_right) /**< choose order, true is reduceRight */
        -:  296:{
    #####:  297:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  298:  uint32_t byte_pos;
        -:  299:
    #####:  300:  if (info_p->length == 0)
        -:  301:  {
    #####:  302:    if (arguments_number < 2)
        -:  303:    {
    #####:  304:      return ecma_raise_type_error (ECMA_ERR_MSG ("Initial value cannot be undefined"));
        -:  305:    }
        -:  306:
    #####:  307:    return ecma_copy_value (arguments_list_p[1]);
        -:  308:  }
        -:  309:
    #####:  310:  JERRY_ASSERT (info_p->length > 0);
        -:  311:
    #####:  312:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
    #####:  313:  uint32_t index = is_right ? (info_p->length - 1) : 0;
    #####:  314:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        -:  315:
    #####:  316:  if (ecma_is_value_undefined (arguments_list_p[1]))
        -:  317:  {
    #####:  318:    byte_pos = index << info_p->shift;
    #####:  319:    accumulator = getter_cb (buffer_p + byte_pos);
        -:  320:
    #####:  321:    if (is_right)
        -:  322:    {
    #####:  323:      if (index == 0)
        -:  324:      {
    #####:  325:        return accumulator;
        -:  326:      }
        -:  327:
    #####:  328:      index--;
        -:  329:    }
        -:  330:    else
        -:  331:    {
    #####:  332:      index++;
        -:  333:
    #####:  334:      if (index == info_p->length)
        -:  335:      {
    #####:  336:        return accumulator;
        -:  337:      }
        -:  338:    }
        -:  339:  }
        -:  340:  else
        -:  341:  {
    #####:  342:    accumulator = ecma_copy_value (arguments_list_p[1]);
        -:  343:  }
        -:  344:
    #####:  345:  ecma_object_t *func_object_p = ecma_get_object_from_value (arguments_list_p[0]);
        -:  346:
        -:  347:  while (true)
    #####:  348:  {
    #####:  349:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  350:    byte_pos = index << info_p->shift;
    #####:  351:    ecma_value_t get_value = getter_cb (buffer_p + byte_pos);
        -:  352:
    #####:  353:    ecma_value_t call_args[] = { accumulator, get_value, current_index, this_arg };
        -:  354:
    #####:  355:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  356:
    #####:  357:    ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -:  358:                                                     ECMA_VALUE_UNDEFINED,
        -:  359:                                                     call_args,
        -:  360:                                                     4);
        -:  361:
    #####:  362:    ecma_fast_free_value (accumulator);
    #####:  363:    ecma_fast_free_value (get_value);
    #####:  364:    ecma_fast_free_value (current_index);
        -:  365:
    #####:  366:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  367:    {
    #####:  368:      return call_value;
        -:  369:    }
        -:  370:
    #####:  371:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  372:    {
    #####:  373:      ecma_free_value (call_value);
    #####:  374:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  375:    }
        -:  376:
    #####:  377:    accumulator = call_value;
        -:  378:
    #####:  379:    if (is_right)
        -:  380:    {
    #####:  381:      if (index == 0)
        -:  382:      {
    #####:  383:        break;
        -:  384:      }
        -:  385:
    #####:  386:      index--;
        -:  387:    }
        -:  388:    else
        -:  389:    {
    #####:  390:      index++;
        -:  391:
    #####:  392:      if (index == info_p->length)
        -:  393:      {
    #####:  394:        break;
        -:  395:      }
        -:  396:    }
        -:  397:  }
        -:  398:
    #####:  399:  return accumulator;
        -:  400:} /* ecma_builtin_typedarray_prototype_reduce_with_direction */
        -:  401:
        -:  402:/**
        -:  403: * The %TypedArray%.prototype object's 'filter' routine
        -:  404: *
        -:  405: * See also:
        -:  406: *          ES2015, 22.2.3.9
        -:  407: *
        -:  408: * @return ecma value
        -:  409: *         Returned value must be freed with ecma_free_value.
        -:  410: */
        -:  411:static ecma_value_t
    #####:  412:ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this object */
        -:  413:                                          ecma_typedarray_info_t *info_p, /**< object info */
        -:  414:                                          ecma_value_t cb_func_val, /**< callback function */
        -:  415:                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
        -:  416:{
    #####:  417:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  418:
    #####:  419:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  420:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  421:
        -:  422:  // TODO: 22.2.3.9, 7-8.
    #####:  423:  if (info_p->length == 0)
        -:  424:  {
    #####:  425:    return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);
        -:  426:  }
        -:  427:
    #####:  428:  ecma_collection_t *collected_p = ecma_new_collection ();
    #####:  429:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        -:  430:
    #####:  431:  for (uint32_t index = 0; index < info_p->length; index++)
        -:  432:  {
    #####:  433:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  434:    ecma_value_t get_value = getter_cb (buffer_p);
        -:  435:
    #####:  436:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  437:
    #####:  438:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  439:
    #####:  440:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  441:
    #####:  442:    ecma_fast_free_value (current_index);
        -:  443:
    #####:  444:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  445:    {
    #####:  446:      ecma_fast_free_value (get_value);
    #####:  447:      goto cleanup;
        -:  448:    }
        -:  449:
    #####:  450:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  451:    {
    #####:  452:      ecma_free_value (call_value);
    #####:  453:      ecma_fast_free_value (get_value);
    #####:  454:      ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
    #####:  455:      goto cleanup;
        -:  456:    }
        -:  457:
    #####:  458:    if (ecma_op_to_boolean (call_value))
        -:  459:    {
    #####:  460:      ecma_collection_push_back (collected_p, get_value);
        -:  461:    }
        -:  462:    else
        -:  463:    {
    #####:  464:      ecma_fast_free_value (get_value);
        -:  465:    }
        -:  466:
    #####:  467:    buffer_p += info_p->element_size;
    #####:  468:    ecma_fast_free_value (call_value);
        -:  469:  }
        -:  470:
    #####:  471:  ecma_value_t collected = ecma_make_number_value (collected_p->item_count);
    #####:  472:  ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);
    #####:  473:  ecma_free_value (collected);
        -:  474:
    #####:  475:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  476:  {
    #####:  477:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (ret_value);
    #####:  478:    ecma_typedarray_info_t target_info = ecma_typedarray_get_info (new_typedarray_p);
        -:  479:
    #####:  480:    JERRY_ASSERT (target_info.offset == 0);
        -:  481:
    #####:  482:    uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  483:
    #####:  484:    if (JERRY_UNLIKELY (target_buffer_p == NULL))
        -:  485:    {
    #####:  486:      ecma_deref_object (new_typedarray_p);
    #####:  487:      ret_value = ECMA_VALUE_ERROR;
    #####:  488:      goto cleanup;
        -:  489:    }
        -:  490:
    #####:  491:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  492:
    #####:  493:    for (uint32_t idx = 0; idx < collected_p->item_count; idx++)
        -:  494:    {
    #####:  495:      ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p,
    #####:  496:                                                              collected_p->buffer_p[idx]);
        -:  497:
    #####:  498:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  499:      {
    #####:  500:        ecma_deref_object (new_typedarray_p);
    #####:  501:        ret_value = ECMA_VALUE_ERROR;
    #####:  502:        goto cleanup;
        -:  503:      }
        -:  504:
    #####:  505:      target_buffer_p += target_info.element_size;
        -:  506:    }
        -:  507:  }
        -:  508:
    #####:  509:cleanup:
    #####:  510:  ecma_collection_free (collected_p);
        -:  511:
    #####:  512:  return ret_value;
        -:  513:} /* ecma_builtin_typedarray_prototype_filter */
        -:  514:
        -:  515:/**
        -:  516: * The %TypedArray%.prototype object's 'reverse' routine
        -:  517: *
        -:  518: * See also:
        -:  519: *          ES2015, 22.2.3.21
        -:  520: *
        -:  521: * @return ecma value
        -:  522: *         Returned value must be freed with ecma_free_value.
        -:  523: */
        -:  524:static ecma_value_t
    #####:  525:ecma_builtin_typedarray_prototype_reverse (ecma_value_t this_arg, /**< this argument */
        -:  526:                                           ecma_typedarray_info_t *info_p) /**< object info */
        -:  527:{
    #####:  528:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####:  529:  uint32_t middle = (info_p->length / 2) << info_p->shift;
    #####:  530:  uint32_t buffer_last = (info_p->length << info_p->shift) - info_p->element_size;
        -:  531:
    #####:  532:  for (uint32_t lower = 0; lower < middle; lower += info_p->element_size)
        -:  533:  {
    #####:  534:    uint32_t upper = buffer_last - lower;
    #####:  535:    uint8_t *lower_p = buffer_p + lower;
    #####:  536:    uint8_t *upper_p = buffer_p + upper;
        -:  537:
    #####:  538:    uint8_t tmp[8];
    #####:  539:    memcpy (&tmp[0], lower_p, info_p->element_size);
    #####:  540:    memcpy (lower_p, upper_p, info_p->element_size);
    #####:  541:    memcpy (upper_p, &tmp[0], info_p->element_size);
        -:  542:  }
        -:  543:
    #####:  544:  return ecma_copy_value (this_arg);
        -:  545:} /* ecma_builtin_typedarray_prototype_reverse */
        -:  546:
        -:  547:/**
        -:  548: * The %TypedArray%.prototype object's 'set' routine for a typedArray source
        -:  549: *
        -:  550: * See also:
        -:  551: *          ES2015, 22.2.3.22, 22.2.3.22.2
        -:  552: *
        -:  553: * @return ecma value of undefined if success, error otherwise.
        -:  554: *         Returned value must be freed with ecma_free_value.
        -:  555: */
        -:  556:static ecma_value_t
    #####:  557:ecma_op_typedarray_set_with_typedarray (ecma_value_t this_arg, /**< this argument */
        -:  558:                                        ecma_value_t arr_val, /**< typedarray object */
        -:  559:                                        ecma_value_t offset_val) /**< offset value */
        -:  560:{
        -:  561:  /* 6.~ 8. targetOffset */
    #####:  562:  ecma_number_t target_offset_num;
    #####:  563:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  564:  {
    #####:  565:    return ECMA_VALUE_ERROR;
        -:  566:  }
        -:  567:
    #####:  568:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  569:  {
    #####:  570:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  571:  }
        -:  572:
    #####:  573:  ecma_object_t *target_typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  574:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_typedarray_p);
    #####:  575:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  576:
    #####:  577:  if (JERRY_UNLIKELY (target_buffer_p == NULL))
        -:  578:  {
    #####:  579:    return ECMA_VALUE_ERROR;
        -:  580:  }
        -:  581:
    #####:  582:  ecma_object_t *src_typedarray_p = ecma_get_object_from_value (arr_val);
    #####:  583:  ecma_typedarray_info_t src_info = ecma_typedarray_get_info (src_typedarray_p);
    #####:  584:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (&src_info);
        -:  585:
    #####:  586:  if (JERRY_UNLIKELY (src_buffer_p == NULL))
        -:  587:  {
    #####:  588:    return ECMA_VALUE_ERROR;
        -:  589:  }
        -:  590:
    #####:  591:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  592:
    #####:  593:  if ((int64_t) src_info.length + target_offset_uint32 > target_info.length)
        -:  594:  {
    #####:  595:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  596:  }
        -:  597:
        -:  598:  /* Fast path first. If the source and target arrays are the same we do not need to copy anything. */
    #####:  599:  if (this_arg == arr_val)
        -:  600:  {
    #####:  601:    return ECMA_VALUE_UNDEFINED;
        -:  602:  }
        -:  603:
        -:  604:  /* 26. targetByteIndex */
    #####:  605:  target_buffer_p += target_offset_uint32 << target_info.shift;
        -:  606:
        -:  607:  /* 27. limit */
    #####:  608:  uint32_t limit = src_info.length << target_info.shift;
        -:  609:
    #####:  610:  if (src_info.id == target_info.id)
        -:  611:  {
    #####:  612:    memmove (target_buffer_p, src_buffer_p, limit);
        -:  613:  }
        -:  614:  else
        -:  615:  {
    #####:  616:    uint8_t *target_limit_p = target_buffer_p + limit;
    #####:  617:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info.id);
    #####:  618:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  619:
    #####:  620:    while (target_buffer_p < target_limit_p)
        -:  621:    {
    #####:  622:      ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####:  623:      ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, element);
    #####:  624:      ecma_free_value (element);
        -:  625:
    #####:  626:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  627:      {
    #####:  628:        return set_element;
        -:  629:      }
        -:  630:
    #####:  631:      src_buffer_p += src_info.element_size;
    #####:  632:      target_buffer_p += target_info.element_size;
        -:  633:    }
        -:  634:  }
        -:  635:
    #####:  636:  return ECMA_VALUE_UNDEFINED;
        -:  637:} /* ecma_op_typedarray_set_with_typedarray */
        -:  638:
        -:  639:/**
        -:  640: * The %TypedArray%.prototype object's 'set' routine
        -:  641: *
        -:  642: * See also:
        -:  643: *          ES2015, 22.2.3.22, 22.2.3.22.1
        -:  644: *
        -:  645: * @return ecma value of undefined if success, error otherwise.
        -:  646: *         Returned value must be freed with ecma_free_value.
        -:  647: */
        -:  648:static ecma_value_t
    #####:  649:ecma_builtin_typedarray_prototype_set (ecma_value_t this_arg, /**< this argument */
        -:  650:                                       ecma_value_t arr_val, /**< array object */
        -:  651:                                       ecma_value_t offset_val) /**< offset value */
        -:  652:{
        -:  653:  /* 1. */
    #####:  654:  if (ecma_is_typedarray (arr_val))
        -:  655:  {
        -:  656:    /* 22.2.3.22.2 */
    #####:  657:    return ecma_op_typedarray_set_with_typedarray (this_arg, arr_val, offset_val);
        -:  658:  }
        -:  659:
        -:  660:  /* 6.~ 8. targetOffset */
    #####:  661:  ecma_number_t target_offset_num;
        -:  662:
    #####:  663:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  664:  {
    #####:  665:    return ECMA_VALUE_ERROR;
        -:  666:  }
        -:  667:
    #####:  668:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  669:  {
    #####:  670:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  671:  }
    #####:  672:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  673:
        -:  674:  /* 11. ~ 15. */
    #####:  675:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  676:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);
    #####:  677:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  678:
    #####:  679:  if (JERRY_UNLIKELY (target_buffer_p == NULL))
        -:  680:  {
    #####:  681:    return ECMA_VALUE_ERROR;
        -:  682:  }
        -:  683:
        -:  684:  /* 16.~ 17. */
    #####:  685:  ecma_value_t source_obj = ecma_op_to_object (arr_val);
        -:  686:
    #####:  687:  if (ECMA_IS_VALUE_ERROR (source_obj))
        -:  688:  {
    #####:  689:    return source_obj;
        -:  690:  }
        -:  691:
        -:  692:  /* 18.~ 19. */
    #####:  693:  ecma_object_t *source_obj_p = ecma_get_object_from_value (source_obj);
        -:  694:
    #####:  695:  ecma_length_t source_length;
        -:  696:
    #####:  697:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (source_obj_p, &source_length)))
        -:  698:  {
    #####:  699:    ecma_deref_object (source_obj_p);
    #####:  700:    return ECMA_VALUE_ERROR;
        -:  701:  }
        -:  702:
        -:  703:  /* 20. if srcLength + targetOffset > targetLength, throw a RangeError */
    #####:  704:  if ((int64_t) source_length + target_offset_uint32 > target_info.length)
        -:  705:  {
    #####:  706:    ecma_deref_object (source_obj_p);
    #####:  707:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  708:  }
    #####:  709:  JERRY_ASSERT (source_length <= UINT32_MAX);
    #####:  710:  uint32_t source_length_uint32 = (uint32_t) source_length;
        -:  711:
        -:  712:  /* 21.~ 25. */
    #####:  713:  target_buffer_p += target_offset_uint32 << target_info.shift;
        -:  714:
    #####:  715:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
    #####:  716:  uint32_t k = 0;
        -:  717:
    #####:  718:  while (k < source_length_uint32)
        -:  719:  {
    #####:  720:    ecma_value_t elem = ecma_op_object_get_by_index (source_obj_p, k);
        -:  721:
    #####:  722:    if (ECMA_IS_VALUE_ERROR (elem))
        -:  723:    {
    #####:  724:      ecma_deref_object (source_obj_p);
    #####:  725:      return elem;
        -:  726:    }
        -:  727:
        -:  728:    ecma_value_t value_to_set;
        -:  729:
        -:  730:#if JERRY_BUILTIN_BIGINT
    #####:  731:    if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (target_info.id))
        -:  732:    {
    #####:  733:      value_to_set = ecma_bigint_to_bigint (elem, false);
        -:  734:
    #####:  735:      if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  736:      {
    #####:  737:        ecma_deref_object (source_obj_p);
    #####:  738:        ecma_free_value (elem);
    #####:  739:        return value_to_set;
        -:  740:      }
        -:  741:    }
        -:  742:    else
        -:  743:#endif /* JERRY_BUILTIN_BIGINT */
        -:  744:    {
    #####:  745:      ecma_number_t elem_num;
    #####:  746:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_numeric (elem, &elem_num, ECMA_TO_NUMERIC_NO_OPTS)))
        -:  747:      {
    #####:  748:        ecma_free_value (elem);
    #####:  749:        ecma_deref_object (source_obj_p);
    #####:  750:        return ECMA_VALUE_ERROR;
        -:  751:      }
        -:  752:
    #####:  753:      value_to_set = ecma_make_number_value (elem_num);
        -:  754:    }
        -:  755:
    #####:  756:    ecma_free_value (elem);
        -:  757:
    #####:  758:    if (ecma_arraybuffer_is_detached (target_info.array_buffer_p))
        -:  759:    {
    #####:  760:      ecma_deref_object (source_obj_p);
    #####:  761:      ecma_free_value (value_to_set);
    #####:  762:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  763:    }
        -:  764:
    #####:  765:    ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, value_to_set);
        -:  766:
    #####:  767:    ecma_free_value (value_to_set);
        -:  768:
    #####:  769:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  770:    {
    #####:  771:      ecma_deref_object (source_obj_p);
    #####:  772:      return set_element;
        -:  773:    }
        -:  774:
    #####:  775:    k++;
    #####:  776:    target_buffer_p += target_info.element_size;
        -:  777:  }
        -:  778:
    #####:  779:  ecma_deref_object (source_obj_p);
        -:  780:
    #####:  781:  return ECMA_VALUE_UNDEFINED;
        -:  782:} /* ecma_builtin_typedarray_prototype_set */
        -:  783:
        -:  784:/**
        -:  785: * TypedArray.prototype's 'toString' single element operation routine based
        -:  786: * on the Array.prototype's 'toString' single element operation routine
        -:  787: *
        -:  788: * See also:
        -:  789: *          ECMA-262 v5.1, 15.4.4.2
        -:  790: *
        -:  791: * @return NULL - if the converison fails
        -:  792: *         ecma_string_t * - otherwise
        -:  793: */
        -:  794:static ecma_string_t *
    #####:  795:ecma_op_typedarray_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  796:                                           uint32_t index) /**< array index */
        -:  797:{
    #####:  798:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  799:
    #####:  800:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  801:  {
    #####:  802:    return NULL;
        -:  803:  }
        -:  804:
    #####:  805:  if (ecma_is_value_undefined (index_value)
    #####:  806:      || ecma_is_value_null (index_value))
        -:  807:  {
    #####:  808:    ecma_free_value (index_value);
    #####:  809:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  810:  }
        -:  811:
    #####:  812:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  813:
    #####:  814:  ecma_free_value (index_value);
        -:  815:
    #####:  816:  return ret_str_p;
        -:  817:} /* ecma_op_typedarray_get_to_string_at_index */
        -:  818:
        -:  819:/**
        -:  820: * The TypedArray.prototype.toString's separator creation routine based on
        -:  821: * the Array.prototype.toString's separator routine
        -:  822: *
        -:  823: * See also:
        -:  824: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  825: *
        -:  826: * @return NULL - if the conversion fails
        -:  827: *         ecma_string_t * - otherwise
        -:  828: */
        -:  829:static ecma_string_t *
    #####:  830:ecma_op_typedarray_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  831:{
    #####:  832:  if (ecma_is_value_undefined (separator))
        -:  833:  {
    #####:  834:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  835:  }
        -:  836:
    #####:  837:  return ecma_op_to_string (separator);
        -:  838:} /* ecma_op_typedarray_get_separator_string */
        -:  839:
        -:  840:/**
        -:  841: * The TypedArray.prototype object's 'join' routine basen on
        -:  842: * the Array.porottype object's 'join'
        -:  843: *
        -:  844: * See also:
        -:  845: *          ECMA-262 v5, 15.4.4.5
        -:  846: *
        -:  847: * @return ecma value
        -:  848: *         Returned value must be freed with ecma_free_value.
        -:  849: */
        -:  850:static ecma_value_t
    #####:  851:ecma_builtin_typedarray_prototype_join (ecma_object_t *obj_p, /**< this object */
        -:  852:                                        ecma_value_t separator_arg) /**< separator argument */
        -:  853:{
        -:  854:  /* 2. */
    #####:  855:  uint32_t length = ecma_typedarray_get_length (obj_p);
    #####:  856:  ecma_string_t *separator_string_p = ecma_op_typedarray_get_separator_string (separator_arg);
        -:  857:
    #####:  858:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  859:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  860:  {
    #####:  861:    return ret_value;
        -:  862:  }
        -:  863:
        -:  864:  /* 7-8. */
    #####:  865:  ecma_string_t *first_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, 0);
        -:  866:
    #####:  867:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  868:  {
    #####:  869:    ecma_deref_ecma_string (separator_string_p);
    #####:  870:    return ret_value;
        -:  871:  }
        -:  872:
    #####:  873:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
        -:  874:
    #####:  875:  ecma_deref_ecma_string (first_string_p);
        -:  876:
        -:  877:  /* 9-10. */
    #####:  878:  for (uint32_t k = 1; k < length; k++)
        -:  879:  {
        -:  880:    /* 10.a */
    #####:  881:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  882:
        -:  883:    /* 10.d */
    #####:  884:    ecma_string_t *next_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, k);
        -:  885:
    #####:  886:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  887:    {
    #####:  888:      ecma_stringbuilder_destroy (&builder);
    #####:  889:      ecma_deref_ecma_string (separator_string_p);
    #####:  890:      return ret_value;
        -:  891:    }
        -:  892:
    #####:  893:    ecma_stringbuilder_append (&builder, next_string_p);
        -:  894:
    #####:  895:    ecma_deref_ecma_string (next_string_p);
        -:  896:  }
        -:  897:
    #####:  898:  ecma_deref_ecma_string (separator_string_p);
    #####:  899:  ret_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  900:
    #####:  901:  return ret_value;
        -:  902:} /* ecma_builtin_typedarray_prototype_join */
        -:  903:
        -:  904:/**
        -:  905: * The %TypedArray%.prototype object's 'subarray' routine.
        -:  906: *
        -:  907: * See also:
        -:  908: *          ES2015, 22.2.3.26
        -:  909: *
        -:  910: * @return ecma value
        -:  911: *         Returned value must be freed with ecma_free_value.
        -:  912: */
        -:  913:static ecma_value_t
    #####:  914:ecma_builtin_typedarray_prototype_subarray (ecma_value_t this_arg, /**< this object */
        -:  915:                                            ecma_typedarray_info_t *info_p, /**< object info */
        -:  916:                                            ecma_value_t begin, /**< begin */
        -:  917:                                            ecma_value_t end) /**< end */
        -:  918:{
    #####:  919:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  920:
        -:  921:  /* 9. beginIndex, 12. endIndex */
    #####:  922:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -:  923:
        -:  924:  /* 7. relativeBegin */
    #####:  925:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin,
        -:  926:                                                                       info_p->length,
        -:  927:                                                                       &begin_index_uint32)))
        -:  928:  {
    #####:  929:    return ECMA_VALUE_ERROR;
        -:  930:  }
        -:  931:
    #####:  932:  if (ecma_is_value_undefined (end))
        -:  933:  {
    #####:  934:    end_index_uint32 = (uint32_t) info_p->length;
        -:  935:  }
        -:  936:  else
        -:  937:  {
        -:  938:    /* 10. relativeEnd */
    #####:  939:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end,
        -:  940:                                                                         info_p->length,
        -:  941:                                                                         &end_index_uint32)))
        -:  942:    {
    #####:  943:      return ECMA_VALUE_ERROR;
        -:  944:    }
        -:  945:  }
        -:  946:
        -:  947:  /* 13. newLength */
    #####:  948:  uint32_t subarray_length = 0;
        -:  949:
    #####:  950:  if (end_index_uint32 > begin_index_uint32)
        -:  951:  {
    #####:  952:    subarray_length = end_index_uint32 - begin_index_uint32;
        -:  953:  }
        -:  954:
        -:  955:  /* 17. beginByteOffset */
    #####:  956:  uint32_t begin_byte_offset = info_p->offset + (begin_index_uint32 << info_p->shift);
        -:  957:
    #####:  958:  ecma_value_t arguments_p[3] =
        -:  959:  {
    #####:  960:    ecma_make_object_value (info_p->array_buffer_p),
    #####:  961:    ecma_make_uint32_value (begin_byte_offset),
    #####:  962:    ecma_make_uint32_value (subarray_length)
        -:  963:  };
        -:  964:
    #####:  965:  ret_value = ecma_typedarray_species_create (this_arg, arguments_p, 3);
        -:  966:
    #####:  967:  ecma_free_value (arguments_p[1]);
    #####:  968:  ecma_free_value (arguments_p[2]);
    #####:  969:  return ret_value;
        -:  970:} /* ecma_builtin_typedarray_prototype_subarray */
        -:  971:
        -:  972:/**
        -:  973: * The %TypedArray%.prototype object's 'fill' routine.
        -:  974: *
        -:  975: * See also:
        -:  976: *          ES2015, 22.2.3.8, 22.1.3.6
        -:  977: *
        -:  978: * @return ecma value
        -:  979: *         Returned value must be freed with ecma_free_value.
        -:  980: */
        -:  981:static ecma_value_t
    #####:  982:ecma_builtin_typedarray_prototype_fill (ecma_value_t this_arg, /**< this object */
        -:  983:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -:  984:                                        ecma_value_t value, /**< value */
        -:  985:                                        ecma_value_t begin, /**< begin */
        -:  986:                                        ecma_value_t end) /**< end */
        -:  987:{
        -:  988:  ecma_value_t value_to_set;
        -:  989:
        -:  990:#if JERRY_BUILTIN_BIGINT
    #####:  991:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -:  992:  {
    #####:  993:    value_to_set = ecma_bigint_to_bigint (value, true);
        -:  994:
    #####:  995:    if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  996:    {
    #####:  997:      return value_to_set;
        -:  998:    }
        -:  999:  }
        -: 1000:  else
        -: 1001:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1002:  {
    #####: 1003:    ecma_number_t value_num;
    #####: 1004:    ecma_value_t ret_value = ecma_op_to_numeric (value, &value_num, ECMA_TO_NUMERIC_NO_OPTS);
        -: 1005:
    #####: 1006:    if (!ecma_is_value_empty (ret_value))
        -: 1007:    {
    #####: 1008:      return ret_value;
        -: 1009:    }
        -: 1010:
    #####: 1011:    value_to_set = ecma_make_number_value (value_num);
        -: 1012:  }
        -: 1013:
    #####: 1014:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -: 1015:
    #####: 1016:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin,
        -: 1017:                                                                       info_p->length,
        -: 1018:                                                                       &begin_index_uint32)))
        -: 1019:  {
    #####: 1020:    ecma_free_value (value_to_set);
    #####: 1021:    return ECMA_VALUE_ERROR;
        -: 1022:  }
        -: 1023:
    #####: 1024:  if (ecma_is_value_undefined (end))
        -: 1025:  {
    #####: 1026:    end_index_uint32 = (uint32_t) info_p->length;
        -: 1027:  }
        -: 1028:  else
        -: 1029:  {
    #####: 1030:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end,
        -: 1031:                                                                         info_p->length,
        -: 1032:                                                                         &end_index_uint32)))
        -: 1033:    {
    #####: 1034:      ecma_free_value (value_to_set);
    #####: 1035:      return ECMA_VALUE_ERROR;
        -: 1036:    }
        -: 1037:  }
        -: 1038:
    #####: 1039:  uint32_t subarray_length = 0;
        -: 1040:
    #####: 1041:  if (end_index_uint32 > begin_index_uint32)
        -: 1042:  {
    #####: 1043:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1044:  }
        -: 1045:
    #####: 1046:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1047:
    #####: 1048:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1049:  {
    #####: 1050:    return ECMA_VALUE_ERROR;
        -: 1051:  }
        -: 1052:
    #####: 1053:  buffer_p += begin_index_uint32 << info_p->shift;
        -: 1054:
    #####: 1055:  uint8_t *limit_p = buffer_p + (subarray_length << info_p->shift);
    #####: 1056:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
        -: 1057:
    #####: 1058:  while (buffer_p < limit_p)
        -: 1059:  {
    #####: 1060:    ecma_value_t set_element = typedarray_setter_cb (buffer_p, value_to_set);
        -: 1061:
    #####: 1062:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1063:    {
    #####: 1064:      ecma_free_value (value_to_set);
    #####: 1065:      return set_element;
        -: 1066:    }
        -: 1067:
    #####: 1068:    buffer_p += info_p->element_size;
        -: 1069:  }
        -: 1070:
    #####: 1071:  ecma_free_value (value_to_set);
        -: 1072:
    #####: 1073:  return ecma_copy_value (this_arg);
        -: 1074:} /* ecma_builtin_typedarray_prototype_fill */
        -: 1075:
        -: 1076:/**
        -: 1077: * SortCompare abstract method
        -: 1078: *
        -: 1079: * See also:
        -: 1080: *          ECMA-262 v5, 15.4.4.11
        -: 1081: *
        -: 1082: * @return ecma value
        -: 1083: *         Returned value must be freed with ecma_free_value.
        -: 1084: */
        -: 1085:static ecma_value_t
        1: 1086:ecma_builtin_typedarray_prototype_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -: 1087:                                                       ecma_value_t rhs, /**< right value */
        -: 1088:                                                       ecma_value_t compare_func, /**< compare function */
        -: 1089:                                                       ecma_object_t *array_buffer_p) /**< array buffer */
        -: 1090:{
        1: 1091:  if (ecma_is_value_undefined (compare_func))
        -: 1092:  {
        -: 1093:    /* Default comparison when no comparefn is passed. */
        -: 1094:#if JERRY_BUILTIN_BIGINT
    #####: 1095:    if (ecma_is_value_bigint (lhs) && ecma_is_value_bigint (rhs))
        -: 1096:    {
    #####: 1097:      return ecma_make_number_value (ecma_bigint_compare_to_bigint (lhs, rhs));
        -: 1098:    }
        -: 1099:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1100:
    #####: 1101:    ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1102:
    #####: 1103:    double lhs_value = (double) ecma_get_number_from_value (lhs);
    #####: 1104:    double rhs_value = (double) ecma_get_number_from_value (rhs);
        -: 1105:
    #####: 1106:    if (ecma_number_is_nan (lhs_value))
        -: 1107:    {
        -: 1108:      // Keep NaNs at the end of the array.
    #####: 1109:      result = ECMA_NUMBER_ONE;
        -: 1110:    }
    #####: 1111:    else if (ecma_number_is_nan (rhs_value))
        -: 1112:    {
        -: 1113:      // Keep NaNs at the end of the array.
    #####: 1114:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1115:    }
    #####: 1116:    else if (lhs_value < rhs_value)
        -: 1117:    {
    #####: 1118:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1119:    }
    #####: 1120:    else if (lhs_value > rhs_value || (ecma_number_is_zero (rhs_value) && ecma_number_is_negative (rhs_value)))
        -: 1121:    {
    #####: 1122:      result = ECMA_NUMBER_ONE;
        -: 1123:    }
        -: 1124:    else
        -: 1125:    {
    #####: 1126:      result = ECMA_NUMBER_ZERO;
        -: 1127:    }
        -: 1128:
    #####: 1129:    return ecma_make_number_value (result);
        -: 1130:  }
        -: 1131:
        -: 1132:  /*
        -: 1133:   * compare_func, if not undefined, will always contain a callable function object.
        -: 1134:   * We checked this previously, before this function was called.
        -: 1135:   */
        1: 1136:  JERRY_ASSERT (ecma_op_is_callable (compare_func));
        1: 1137:  ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1138:
        1: 1139:  ecma_value_t compare_args[] = { lhs, rhs };
        -: 1140:
        1: 1141:  ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1142:                                                   ECMA_VALUE_UNDEFINED,
        -: 1143:                                                   compare_args,
        -: 1144:                                                   2);
        -: 1145:
        1: 1146:  if (ECMA_IS_VALUE_ERROR (call_value) || ecma_is_value_number (call_value))
        -: 1147:  {
        1: 1148:    return call_value;
        -: 1149:  }
        -: 1150:
    #####: 1151:  ecma_number_t ret_num;
    #####: 1152:  ecma_value_t number_result = ecma_op_to_number (call_value, &ret_num);
        -: 1153:
    #####: 1154:  ecma_free_value (call_value);
        -: 1155:
    #####: 1156:  if (ECMA_IS_VALUE_ERROR (number_result))
        -: 1157:  {
    #####: 1158:    return number_result;
        -: 1159:  }
        -: 1160:
    #####: 1161:  if (ecma_arraybuffer_is_detached (array_buffer_p))
        -: 1162:  {
    #####: 1163:    ecma_free_value (number_result);
    #####: 1164:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1165:  }
        -: 1166:
        -: 1167:  // If the coerced value can't be represented as a Number, compare them as equals.
    #####: 1168:  if (ecma_number_is_nan (ret_num))
        -: 1169:  {
    #####: 1170:    return ecma_make_number_value (ECMA_NUMBER_ZERO);
        -: 1171:  }
        -: 1172:
    #####: 1173:  return ecma_make_number_value (ret_num);
        -: 1174:} /* ecma_builtin_typedarray_prototype_sort_compare_helper */
        -: 1175:
        -: 1176:/**
        -: 1177: * The %TypedArray%.prototype object's 'sort' routine.
        -: 1178: *
        -: 1179: * See also:
        -: 1180: *          ES2015, 22.2.3.25, 22.1.3.24
        -: 1181: *
        -: 1182: * @return ecma value
        -: 1183: *         Returned value must be freed with ecma_free_value.
        -: 1184: */
        -: 1185:static ecma_value_t
        1: 1186:ecma_builtin_typedarray_prototype_sort (ecma_value_t this_arg, /**< this argument */
        -: 1187:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -: 1188:                                        ecma_value_t compare_func) /**< comparator fn */
        -: 1189:{
        1: 1190:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
        1: 1191:  JERRY_ASSERT (ecma_is_value_undefined (compare_func) || ecma_op_is_callable (compare_func));
        -: 1192:
        1: 1193:  if (!info_p->length)
        -: 1194:  {
    #####: 1195:    return ecma_copy_value (this_arg);
        -: 1196:  }
        -: 1197:
        1: 1198:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        1: 1199:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, info_p->length, ecma_value_t);
        -: 1200:
        1: 1201:  uint32_t buffer_index = 0;
        -: 1202:
        1: 1203:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        1: 1204:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        1: 1205:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
        -: 1206:
        -: 1207:  /* Copy unsorted array into a native c array. */
      258: 1208:  while (buffer_p < limit_p)
        -: 1209:  {
      256: 1210:    JERRY_ASSERT (buffer_index < info_p->length);
      256: 1211:    ecma_value_t element_value = typedarray_getter_cb (buffer_p);
      256: 1212:    values_buffer[buffer_index++] = element_value;
      256: 1213:    buffer_p += info_p->element_size;
        -: 1214:  }
        -: 1215:
        1: 1216:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1217:
        1: 1218:  const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_typedarray_prototype_sort_compare_helper;
        -: 1219:
        2: 1220:  ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
        1: 1221:                                                                         (uint32_t) (info_p->length),
        -: 1222:                                                                         compare_func,
        -: 1223:                                                                         sort_cb,
        -: 1224:                                                                         info_p->array_buffer_p);
        -: 1225:
        1: 1226:  if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1227:  {
        1: 1228:    ret_value = sort_value;
        1: 1229:    goto free_values;
        -: 1230:  }
        -: 1231:
    #####: 1232:  JERRY_ASSERT (sort_value == ECMA_VALUE_EMPTY);
        -: 1233:
    #####: 1234:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1235:  {
    #####: 1236:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1237:  }
        -: 1238:
    #####: 1239:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
        -: 1240:
    #####: 1241:  buffer_p = limit_p - (info_p->length << info_p->shift);
    #####: 1242:  buffer_index = 0;
        -: 1243:
        -: 1244:  /* Put sorted values from the native array back into the typedarray buffer. */
    #####: 1245:  while (buffer_p < limit_p)
        -: 1246:  {
    #####: 1247:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1248:    ecma_value_t element_value = values_buffer[buffer_index++];
    #####: 1249:    ecma_value_t set_element = typedarray_setter_cb (buffer_p, element_value);
        -: 1250:
    #####: 1251:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1252:    {
    #####: 1253:      ret_value = set_element;
    #####: 1254:      goto free_values;
        -: 1255:    }
        -: 1256:
    #####: 1257:    buffer_p += info_p->element_size;
        -: 1258:  }
        -: 1259:
    #####: 1260:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1261:
    #####: 1262:  ret_value = ecma_copy_value (this_arg);
        -: 1263:
        1: 1264:free_values:
        -: 1265:  /* Free values that were copied to the local array. */
      257: 1266:  for (uint32_t index = 0; index < info_p->length; index++)
        -: 1267:  {
      256: 1268:    ecma_free_value (values_buffer[index]);
        -: 1269:  }
        -: 1270:
        1: 1271:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1272:
        1: 1273:  return ret_value;
        -: 1274:} /* ecma_builtin_typedarray_prototype_sort */
        -: 1275:
        -: 1276:/**
        -: 1277: * The %TypedArray%.prototype object's 'find' and 'findIndex' routine helper
        -: 1278: *
        -: 1279: * @return ecma value
        -: 1280: *         Returned value must be freed with ecma_free_value.
        -: 1281: */
        -: 1282:static ecma_value_t
    #####: 1283:ecma_builtin_typedarray_prototype_find_helper (ecma_value_t this_arg, /**< this argument */
        -: 1284:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1285:                                               ecma_value_t predicate, /**< callback function */
        -: 1286:                                               ecma_value_t predicate_this_arg, /**< this argument for
        -: 1287:                                                                                 *   invoke predicate */
        -: 1288:                                               bool is_find) /**< true - find routine
        -: 1289:                                                              *   false - findIndex routine */
        -: 1290:{
    #####: 1291:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 1292:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
    #####: 1293:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####: 1294:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
    #####: 1295:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1296:  uint32_t buffer_index = 0;
        -: 1297:
    #####: 1298:  while (buffer_p < limit_p)
        -: 1299:  {
    #####: 1300:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1301:    ecma_value_t element_value = typedarray_getter_cb (buffer_p);
    #####: 1302:    buffer_p += info_p->element_size;
        -: 1303:
    #####: 1304:    ecma_value_t call_args[] = { element_value, ecma_make_uint32_value (buffer_index), this_arg };
    #####: 1305:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 1306:
    #####: 1307:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1308:    {
    #####: 1309:      ecma_free_value (element_value);
    #####: 1310:      return call_value;
        -: 1311:    }
        -: 1312:
    #####: 1313:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1314:    {
    #####: 1315:      ecma_free_value (element_value);
    #####: 1316:      ecma_free_value (call_value);
    #####: 1317:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1318:    }
        -: 1319:
    #####: 1320:    bool call_result = ecma_op_to_boolean (call_value);
    #####: 1321:    ecma_free_value (call_value);
        -: 1322:
    #####: 1323:    if (call_result)
        -: 1324:    {
    #####: 1325:      if (is_find)
        -: 1326:      {
    #####: 1327:        return element_value;
        -: 1328:      }
        -: 1329:
    #####: 1330:      ecma_free_value (element_value);
    #####: 1331:      return ecma_make_uint32_value (buffer_index);
        -: 1332:    }
        -: 1333:
    #####: 1334:    buffer_index++;
    #####: 1335:    ecma_free_value (element_value);
        -: 1336:  }
        -: 1337:
    #####: 1338:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 1339:} /* ecma_builtin_typedarray_prototype_find_helper */
        -: 1340:
        -: 1341:/**
        -: 1342: * The %TypedArray%.prototype object's 'at' routine
        -: 1343: *
        -: 1344: * See also:
        -: 1345: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1346: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1347: *
        -: 1348: * @return ecma value
        -: 1349: *         Returned value must be freed with ecma_free_value.
        -: 1350: */
        -: 1351:static ecma_value_t
    #####: 1352:ecma_builtin_typedarray_prototype_at (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1353:                                      const ecma_value_t index) /**< index argument */
        -: 1354:{
    #####: 1355:  ecma_length_t len = (ecma_length_t) info_p->length;
    #####: 1356:  ecma_length_t res_index;
    #####: 1357:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1358:
    #####: 1359:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1360:  {
    #####: 1361:    return return_value;
        -: 1362:  }
        -: 1363:
    #####: 1364:  return ecma_get_typedarray_element (info_p, (ecma_number_t) res_index);
        -: 1365:} /* ecma_builtin_typedarray_prototype_at */
        -: 1366:
        -: 1367:/**
        -: 1368: * The %TypedArray%.prototype object's 'indexOf' routine
        -: 1369: *
        -: 1370: * See also:
        -: 1371: *         ECMA-262 v6, 22.2.3.13
        -: 1372: *
        -: 1373: * @return ecma value
        -: 1374: *         Returned value must be freed with ecma_free_value.
        -: 1375: */
        -: 1376:static ecma_value_t
    #####: 1377:ecma_builtin_typedarray_prototype_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1378:                                            const ecma_value_t args[], /**< arguments list */
        -: 1379:                                            uint32_t args_number) /**< number of arguments */
        -: 1380:{
        -: 1381:#if JERRY_BUILTIN_BIGINT
    #####: 1382:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1383:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1384:  bool is_bigint = false;
        -: 1385:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1386:
    #####: 1387:  uint32_t from_index;
        -: 1388:
        -: 1389:   /* 5. */
    #####: 1390:  if (args_number == 0
    #####: 1391:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1392:      || info_p->length == 0)
        -: 1393:  {
    #####: 1394:    return ecma_make_integer_value (-1);
        -: 1395:  }
    #####: 1396:  if (args_number == 1)
        -: 1397:  {
    #####: 1398:    from_index = 0;
        -: 1399:  }
        -: 1400:  else
        -: 1401:  {
    #####: 1402:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1403:                                                                         info_p->length,
        -: 1404:                                                                         &from_index)))
        -: 1405:    {
    #####: 1406:      return ECMA_VALUE_ERROR;
        -: 1407:    }
        -: 1408:  }
        -: 1409:
    #####: 1410:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1411:
    #####: 1412:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1413:  {
    #####: 1414:    return ECMA_VALUE_ERROR;
        -: 1415:  }
        -: 1416:
    #####: 1417:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
    #####: 1418:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1419:
    #####: 1420:  buffer_p += from_index << info_p->shift;
        -: 1421:
        -: 1422:  /* 11. */
    #####: 1423:  while (buffer_p < limit_p)
        -: 1424:  {
    #####: 1425:    ecma_value_t element = getter_cb (buffer_p);
        -: 1426:
    #####: 1427:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1428:    {
    #####: 1429:      ecma_free_value (element);
    #####: 1430:      return ecma_make_number_value (from_index);
        -: 1431:    }
        -: 1432:
    #####: 1433:    ecma_free_value (element);
    #####: 1434:    buffer_p += info_p->element_size;
    #####: 1435:    from_index++;
        -: 1436:  }
        -: 1437:
        -: 1438:  /* 12. */
    #####: 1439:  return ecma_make_integer_value (-1);
        -: 1440:} /* ecma_builtin_typedarray_prototype_index_of */
        -: 1441:
        -: 1442:/**
        -: 1443: * The %TypedArray%.prototype object's 'lastIndexOf' routine
        -: 1444: *
        -: 1445: * See also:
        -: 1446: *          ECMA-262 v6, 22.2.3.16
        -: 1447: *
        -: 1448: * @return ecma value
        -: 1449: *         Returned value must be freed with ecma_free_value.
        -: 1450: */
        -: 1451:static ecma_value_t
    #####: 1452:ecma_builtin_typedarray_prototype_last_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1453:                                                const ecma_value_t args[], /**< arguments list */
        -: 1454:                                                uint32_t args_number) /**< number of arguments */
        -: 1455:{
        -: 1456:#if JERRY_BUILTIN_BIGINT
    #####: 1457:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1458:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1459:  bool is_bigint = false;
        -: 1460:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1461:
    #####: 1462:  uint32_t from_index;
        -: 1463:
        -: 1464:  /* 5. */
    #####: 1465:  if (args_number == 0
    #####: 1466:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1467:      || info_p->length == 0)
        -: 1468:  {
    #####: 1469:    return ecma_make_integer_value (-1);
        -: 1470:  }
        -: 1471:
    #####: 1472:  if (args_number == 1)
        -: 1473:  {
    #####: 1474:    from_index = info_p->length - 1;
        -: 1475:  }
        -: 1476:  else
        -: 1477:  {
    #####: 1478:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1479:                                                                         info_p->length,
        -: 1480:                                                                         &from_index)))
        -: 1481:    {
    #####: 1482:      return ECMA_VALUE_ERROR;
        -: 1483:    }
        -: 1484:
    #####: 1485:    ecma_number_t to_int;
        -: 1486:
    #####: 1487:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &to_int)))
        -: 1488:    {
    #####: 1489:      return ECMA_VALUE_ERROR;
        -: 1490:    }
        -: 1491:
    #####: 1492:    if (info_p->length + to_int < 0)
        -: 1493:    {
    #####: 1494:      return ecma_make_integer_value (-1);
        -: 1495:    }
        -: 1496:
    #####: 1497:    from_index = JERRY_MIN (from_index, info_p->length - 1);
        -: 1498:  }
        -: 1499:
    #####: 1500:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1501:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####: 1502:  uint8_t *current_element_p = buffer_p + (from_index << info_p->shift);
        -: 1503:
        -: 1504:  /* 10. */
    #####: 1505:  while (current_element_p >= buffer_p)
        -: 1506:  {
    #####: 1507:    ecma_value_t element = getter_cb (current_element_p);
        -: 1508:
    #####: 1509:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1510:    {
    #####: 1511:      ecma_free_value (element);
    #####: 1512:      return ecma_make_number_value ((ecma_number_t) from_index);
        -: 1513:    }
        -: 1514:
    #####: 1515:    ecma_free_value (element);
    #####: 1516:    current_element_p -= info_p->element_size;
    #####: 1517:    from_index--;
        -: 1518:  }
        -: 1519:
        -: 1520:  /* 11. */
    #####: 1521:  return ecma_make_integer_value (-1);
        -: 1522:} /* ecma_builtin_typedarray_prototype_last_index_of */
        -: 1523:
        -: 1524:/**
        -: 1525: * The %TypedArray%.prototype object's 'copyWithin' routine
        -: 1526: *
        -: 1527: * See also:
        -: 1528: *          ECMA-262 v6, 22.2.3.5
        -: 1529: *
        -: 1530: * @return ecma value
        -: 1531: *         Returned value must be freed with ecma_free_value.
        -: 1532: */
        -: 1533:static ecma_value_t
    #####: 1534:ecma_builtin_typedarray_prototype_copy_within (ecma_value_t this_arg, /**< this argument */
        -: 1535:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1536:                                               const ecma_value_t args[], /**< arguments list */
        -: 1537:                                               uint32_t args_number) /**< number of arguments */
        -: 1538:{
    #####: 1539:  uint32_t relative_target = 0;
    #####: 1540:  uint32_t relative_start = 0;
    #####: 1541:  uint32_t relative_end = info_p->length;
        -: 1542:
    #####: 1543:  if (args_number > 0)
        -: 1544:  {
    #####: 1545:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0],
        -: 1546:                                                                         info_p->length,
        -: 1547:                                                                         &relative_target)))
        -: 1548:    {
    #####: 1549:      return ECMA_VALUE_ERROR;
        -: 1550:    }
        -: 1551:
    #####: 1552:    if (args_number > 1)
        -: 1553:    {
    #####: 1554:      if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1555:                                                                           info_p->length,
        -: 1556:                                                                           &relative_start)))
        -: 1557:      {
    #####: 1558:        return ECMA_VALUE_ERROR;
        -: 1559:      }
        -: 1560:
    #####: 1561:      if (args_number > 2 && args[2] != ECMA_VALUE_UNDEFINED)
        -: 1562:      {
    #####: 1563:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[2],
        -: 1564:                                                                             info_p->length,
        -: 1565:                                                                             &relative_end)))
        -: 1566:        {
    #####: 1567:          return ECMA_VALUE_ERROR;
        -: 1568:        }
        -: 1569:      }
        -: 1570:    }
        -: 1571:  }
        -: 1572:
    #####: 1573:  if (relative_target >= info_p->length || relative_start >= relative_end || relative_end == 0)
        -: 1574:  {
    #####: 1575:    return ecma_copy_value (this_arg);
        -: 1576:  }
        -: 1577:
    #####: 1578:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1579:
    #####: 1580:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1581:  {
    #####: 1582:    return ECMA_VALUE_ERROR;
        -: 1583:  }
        -: 1584:
    #####: 1585:  uint32_t distance = relative_end - relative_start;
    #####: 1586:  uint32_t offset = info_p->length - relative_target;
    #####: 1587:  uint32_t count = JERRY_MIN (distance, offset);
        -: 1588:
    #####: 1589:  memmove (buffer_p + (relative_target << info_p->shift),
    #####: 1590:           buffer_p + (relative_start << info_p->shift),
    #####: 1591:           (size_t) (count << info_p->shift));
        -: 1592:
    #####: 1593:  return ecma_copy_value (this_arg);
        -: 1594:} /* ecma_builtin_typedarray_prototype_copy_within */
        -: 1595:
        -: 1596:/**
        -: 1597: * The %TypedArray%.prototype object's 'slice' routine
        -: 1598: *
        -: 1599: * See also:
        -: 1600: *          ECMA-262 v6, 22.2.3.23
        -: 1601: *
        -: 1602: * @return ecma value
        -: 1603: *         Returned value must be freed with ecma_free_value.
        -: 1604: */
        -: 1605:static ecma_value_t
    #####: 1606:ecma_builtin_typedarray_prototype_slice (ecma_value_t this_arg, /**< this argument */
        -: 1607:                                         ecma_typedarray_info_t *info_p, /**< object info */
        -: 1608:                                         const ecma_value_t args[], /**< arguments list */
        -: 1609:                                         uint32_t args_number) /**< number of arguments */
        -: 1610:{
    #####: 1611:  uint32_t relative_start = 0;
    #####: 1612:  uint32_t relative_end = info_p->length;
        -: 1613:
    #####: 1614:  if (args_number > 0)
        -: 1615:  {
    #####: 1616:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0],
        -: 1617:                                                                         info_p->length,
        -: 1618:                                                                         &relative_start)))
        -: 1619:    {
    #####: 1620:      return ECMA_VALUE_ERROR;
        -: 1621:    }
        -: 1622:
    #####: 1623:    if (args_number > 1
    #####: 1624:        && args[1] != ECMA_VALUE_UNDEFINED
    #####: 1625:        && ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1626:                                                                            info_p->length,
        -: 1627:                                                                            &relative_end)))
        -: 1628:    {
    #####: 1629:      return ECMA_VALUE_ERROR;
        -: 1630:    }
        -: 1631:  }
        -: 1632:
    #####: 1633:  int32_t distance = (int32_t) (relative_end - relative_start);
    #####: 1634:  uint32_t count = distance > 0 ? (uint32_t) distance : 0;
        -: 1635:
    #####: 1636:  ecma_value_t len = ecma_make_number_value (count);
        -: 1637:  // TODO: 22.2.3.23, 12-13.
    #####: 1638:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####: 1639:  ecma_free_value (len);
        -: 1640:
    #####: 1641:  if (ECMA_IS_VALUE_ERROR (new_typedarray) || count == 0)
        -: 1642:  {
    #####: 1643:    return new_typedarray;
        -: 1644:  }
        -: 1645:
    #####: 1646:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1647:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1648:
    #####: 1649:  if (JERRY_UNLIKELY (src_buffer_p == NULL))
        -: 1650:  {
    #####: 1651:    ecma_deref_object (new_typedarray_p);
    #####: 1652:    return ECMA_VALUE_ERROR;
        -: 1653:  }
        -: 1654:
    #####: 1655:  ecma_typedarray_info_t new_typedarray_info = ecma_typedarray_get_info (new_typedarray_p);
    #####: 1656:  uint8_t *dst_buffer_p = ecma_typedarray_get_buffer (&new_typedarray_info);
        -: 1657:
    #####: 1658:  if (JERRY_UNLIKELY (dst_buffer_p == NULL))
        -: 1659:  {
    #####: 1660:    ecma_deref_object (new_typedarray_p);
    #####: 1661:    return ECMA_VALUE_ERROR;
        -: 1662:  }
        -: 1663:
    #####: 1664:  JERRY_ASSERT (new_typedarray_info.offset == 0);
        -: 1665:
    #####: 1666:  src_buffer_p += relative_start << info_p->shift;
        -: 1667:
    #####: 1668:  if (info_p->id == new_typedarray_info.id)
        -: 1669:  {
        -: 1670:    // 22.2.3.23. Step 22. h-i.
    #####: 1671:    memcpy (dst_buffer_p, src_buffer_p, count << info_p->shift);
        -: 1672:  }
        -: 1673:  else
        -: 1674:  {
        -: 1675:    // 22.2.3.23. Step 21. b.
    #####: 1676:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1677:    ecma_typedarray_setter_fn_t new_typedarray_setter_cb = ecma_get_typedarray_setter_fn (new_typedarray_info.id);
        -: 1678:
    #####: 1679:    for (uint32_t idx = 0; idx < count; idx++)
        -: 1680:    {
    #####: 1681:      ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####: 1682:      ecma_value_t set_element = new_typedarray_setter_cb (dst_buffer_p, element);
    #####: 1683:      ecma_free_value (element);
        -: 1684:
    #####: 1685:      if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1686:      {
    #####: 1687:        ecma_deref_object (new_typedarray_p);
    #####: 1688:        return set_element;
        -: 1689:      }
        -: 1690:
    #####: 1691:      src_buffer_p += info_p->element_size;
    #####: 1692:      dst_buffer_p += new_typedarray_info.element_size;
        -: 1693:    }
        -: 1694:  }
        -: 1695:
    #####: 1696:  return new_typedarray;
        -: 1697:} /* ecma_builtin_typedarray_prototype_slice */
        -: 1698:
        -: 1699:/**
        -: 1700: * The TypedArray.prototype's 'toLocaleString' single element operation routine.
        -: 1701: *
        -: 1702: * See also:
        -: 1703: *          ECMA-262 v6, 22.1.3.26 steps 7-10 and 12.b-e
        -: 1704: *
        -: 1705: * @return ecma value
        -: 1706: *         Returned value must be freed with ecma_free_value.
        -: 1707:*/
        -: 1708:static ecma_value_t
    #####: 1709:ecma_builtin_typedarray_prototype_to_locale_string_helper (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1710:                                                           uint32_t index) /** array index */
        -: 1711:{
    #####: 1712:  ecma_value_t element_value = ecma_get_typedarray_element (info_p, index);
        -: 1713:
    #####: 1714:  ecma_value_t call_value = ecma_op_invoke_by_magic_id (element_value, LIT_MAGIC_STRING_TO_LOCALE_STRING_UL, NULL, 0);
        -: 1715:
    #####: 1716:  ecma_free_value (element_value);
        -: 1717:
    #####: 1718:  if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1719:  {
    #####: 1720:    return call_value;
        -: 1721:  }
        -: 1722:
    #####: 1723:  ecma_string_t *str_p = ecma_op_to_string (call_value);
        -: 1724:
    #####: 1725:  ecma_free_value (call_value);
        -: 1726:
    #####: 1727:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 1728:  {
    #####: 1729:    return ECMA_VALUE_ERROR;
        -: 1730:  }
        -: 1731:
    #####: 1732:  return ecma_make_string_value (str_p);
        -: 1733:} /* ecma_builtin_typedarray_prototype_to_locale_string_helper */
        -: 1734:
        -: 1735:/**
        -: 1736: * The %TypedArray%.prototype object's 'toLocaleString' routine
        -: 1737: *
        -: 1738: * See also:
        -: 1739: *          ECMA-262 v6, 22.2.3.27
        -: 1740: *
        -: 1741: * @return ecma value
        -: 1742: *         Returned value must be freed with ecma_free_value.
        -: 1743: */
        -: 1744:static ecma_value_t
    #####: 1745:ecma_builtin_typedarray_prototype_to_locale_string (ecma_typedarray_info_t *info_p) /**< object info */
        -: 1746:{
    #####: 1747:  if (info_p->length == 0)
        -: 1748:  {
    #####: 1749:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1750:  }
        -: 1751:
    #####: 1752:  ecma_value_t first_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, 0);
        -: 1753:
    #####: 1754:  if (ECMA_IS_VALUE_ERROR (first_element))
        -: 1755:  {
    #####: 1756:    return first_element;
        -: 1757:  }
        -: 1758:
    #####: 1759:  ecma_string_t *return_string_p = ecma_get_string_from_value (first_element);
    #####: 1760:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (return_string_p);
    #####: 1761:  ecma_deref_ecma_string (return_string_p);
        -: 1762:
    #####: 1763:  for (uint32_t k = 1; k < info_p->length; k++)
        -: 1764:  {
    #####: 1765:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
    #####: 1766:    ecma_value_t next_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, k);
        -: 1767:
    #####: 1768:    if (ECMA_IS_VALUE_ERROR (next_element))
        -: 1769:    {
    #####: 1770:      ecma_stringbuilder_destroy (&builder);
    #####: 1771:      return next_element;
        -: 1772:    }
        -: 1773:
    #####: 1774:    ecma_string_t *next_element_p = ecma_get_string_from_value (next_element);
    #####: 1775:    ecma_stringbuilder_append (&builder, next_element_p);
    #####: 1776:    ecma_deref_ecma_string (next_element_p);
        -: 1777:  }
        -: 1778:
    #####: 1779:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1780:} /* ecma_builtin_typedarray_prototype_to_locale_string */
        -: 1781:
        -: 1782:/**
        -: 1783: * The %TypedArray%.prototype object's 'includes' routine
        -: 1784: *
        -: 1785: * See also:
        -: 1786: *          ECMA-262 v11, 22.2.3.13.
        -: 1787: */
        -: 1788:static ecma_value_t
    #####: 1789:ecma_builtin_typedarray_prototype_includes (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1790:                                            const ecma_value_t args[], /**< arguments list */
        -: 1791:                                            uint32_t args_number) /**< number of arguments */
        -: 1792:{
        -: 1793:#if JERRY_BUILTIN_BIGINT
    #####: 1794:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1795:#else /* !JERRRY_BUILTIN_BIGINT */
        -: 1796:  bool is_bigint = false;
        -: 1797:#endif /* JERRRY_BUILTIN_BIGINT */
        -: 1798:
    #####: 1799:  if (args_number == 0
    #####: 1800:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1801:      || info_p->length == 0)
        -: 1802:  {
    #####: 1803:    return ECMA_VALUE_FALSE;
        -: 1804:  }
        -: 1805:
    #####: 1806:  uint32_t from_index = 0;
        -: 1807:
    #####: 1808:  if (args_number > 1)
        -: 1809:  {
    #####: 1810:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &from_index)))
        -: 1811:    {
    #####: 1812:      return ECMA_VALUE_ERROR;
        -: 1813:    }
        -: 1814:  }
        -: 1815:
    #####: 1816:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1817:
    #####: 1818:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1819:  {
    #####: 1820:    return ECMA_VALUE_ERROR;
        -: 1821:  }
        -: 1822:
    #####: 1823:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1824:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
        -: 1825:
    #####: 1826:  buffer_p += from_index << info_p->shift;
        -: 1827:
    #####: 1828:  while (buffer_p < limit_p)
        -: 1829:  {
    #####: 1830:    ecma_value_t element = getter_cb (buffer_p);
        -: 1831:
    #####: 1832:    if (ecma_op_same_value_zero (args[0], element, false))
        -: 1833:    {
    #####: 1834:      ecma_free_value (element);
    #####: 1835:      return ECMA_VALUE_TRUE;
        -: 1836:    }
        -: 1837:
    #####: 1838:    ecma_free_value (element);
    #####: 1839:    buffer_p += info_p->element_size;
        -: 1840:  }
        -: 1841:
    #####: 1842:  return ECMA_VALUE_FALSE;
        -: 1843:} /* ecma_builtin_typedarray_prototype_includes */
        -: 1844:
        -: 1845:/**
        -: 1846: *
        -: 1847: * @return ecma value
        -: 1848: *         Returned value must be freed with ecma_free_value.
        -: 1849: */
        -: 1850:ecma_value_t
        1: 1851:ecma_builtin_typedarray_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide
        -: 1852:                                                                                 *   routine identifier */
        -: 1853:                                                    ecma_value_t this_arg, /**< 'this' argument value */
        -: 1854:                                                    const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1855:                                                                                            *   passed to routine */
        -: 1856:                                                    uint32_t arguments_number) /**< length of arguments' list */
        -: 1857:{
        1: 1858:  if (!ecma_is_typedarray (this_arg))
        -: 1859:  {
    #####: 1860:    if (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER)
        -: 1861:    {
    #####: 1862:      return ECMA_VALUE_UNDEFINED;
        -: 1863:    }
        -: 1864:
    #####: 1865:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray"));
        -: 1866:  }
        -: 1867:
        1: 1868:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
        1: 1869:  ecma_typedarray_info_t info = { 0 };
        -: 1870:
        1: 1871:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER)
        -: 1872:  {
        1: 1873:    info = ecma_typedarray_get_info (typedarray_p);
        -: 1874:
        1: 1875:    if (builtin_routine_id != ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY
        1: 1876:        && ECMA_ARRAYBUFFER_CHECK_BUFFER_ERROR (info.array_buffer_p))
        -: 1877:    {
    #####: 1878:      return ECMA_VALUE_ERROR;
        -: 1879:    }
        -: 1880:  }
        -: 1881:
        1: 1882:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF && !ecma_op_is_callable (arguments_list_p[0]))
        -: 1883:  {
    #####: 1884:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1885:  }
        -: 1886:
        1: 1887:  switch (builtin_routine_id)
        -: 1888:  {
    #####: 1889:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES:
        -: 1890:    {
    #####: 1891:      return ecma_builtin_typedarray_prototype_includes (&info, arguments_list_p, arguments_number);
        -: 1892:    }
    #####: 1893:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN:
        -: 1894:    {
    #####: 1895:      return ecma_builtin_typedarray_prototype_join (typedarray_p, arguments_list_p[0]);
        -: 1896:    }
    #####: 1897:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY:
        -: 1898:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME:
        -: 1899:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH:
        -: 1900:    {
    #####: 1901:      uint8_t offset = (uint8_t) (builtin_routine_id - ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY);
        -: 1902:
    #####: 1903:      return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -: 1904:                                                             &info,
        -: 1905:                                                             arguments_list_p[0],
    #####: 1906:                                                             arguments_list_p[1],
        -: 1907:                                                             offset);
        -: 1908:    }
    #####: 1909:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP:
        -: 1910:    {
    #####: 1911:      return ecma_builtin_typedarray_prototype_map (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1912:    }
    #####: 1913:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE:
        -: 1914:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT:
        -: 1915:    {
    #####: 1916:      bool is_reduce =  builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT;
    #####: 1917:      return ecma_builtin_typedarray_prototype_reduce_with_direction (this_arg,
        -: 1918:                                                                      &info,
        -: 1919:                                                                      arguments_list_p,
        -: 1920:                                                                      arguments_number,
        -: 1921:                                                                      is_reduce);
        -: 1922:    }
    #####: 1923:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER:
        -: 1924:    {
    #####: 1925:      return ecma_builtin_typedarray_prototype_filter (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1926:    }
    #####: 1927:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE:
        -: 1928:    {
    #####: 1929:      return ecma_builtin_typedarray_prototype_reverse (this_arg, &info);
        -: 1930:    }
    #####: 1931:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET:
        -: 1932:    {
    #####: 1933:      return ecma_builtin_typedarray_prototype_set (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -: 1934:    }
    #####: 1935:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY:
        -: 1936:    {
    #####: 1937:      return ecma_builtin_typedarray_prototype_subarray (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1938:    }
    #####: 1939:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL:
        -: 1940:    {
    #####: 1941:      return ecma_builtin_typedarray_prototype_fill (this_arg,
        -: 1942:                                                     &info,
        -: 1943:                                                     arguments_list_p[0],
    #####: 1944:                                                     arguments_list_p[1],
    #####: 1945:                                                     arguments_list_p[2]);
        -: 1946:    }
        1: 1947:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT:
        -: 1948:    {
        1: 1949:      if (!ecma_is_value_undefined (arguments_list_p[0]) && !ecma_op_is_callable (arguments_list_p[0]))
        -: 1950:      {
    #####: 1951:        return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1952:      }
        -: 1953:
        1: 1954:      return ecma_builtin_typedarray_prototype_sort (this_arg, &info, arguments_list_p[0]);
        -: 1955:
        -: 1956:    }
    #####: 1957:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND:
        -: 1958:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX:
        -: 1959:    {
    #####: 1960:      bool is_find = builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND;
    #####: 1961:      return ecma_builtin_typedarray_prototype_find_helper (this_arg,
        -: 1962:                                                            &info,
        -: 1963:                                                            arguments_list_p[0],
    #####: 1964:                                                            arguments_list_p[1],
        -: 1965:                                                            is_find);
        -: 1966:    }
    #####: 1967:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT:
        -: 1968:    {
    #####: 1969:      return ecma_builtin_typedarray_prototype_at (&info, arguments_list_p[0]);
        -: 1970:    }
    #####: 1971:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF:
        -: 1972:    {
    #####: 1973:      return ecma_builtin_typedarray_prototype_index_of (&info, arguments_list_p, arguments_number);
        -: 1974:    }
    #####: 1975:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF:
        -: 1976:    {
    #####: 1977:      return ecma_builtin_typedarray_prototype_last_index_of (&info, arguments_list_p, arguments_number);
        -: 1978:    }
    #####: 1979:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN:
        -: 1980:    {
    #####: 1981:      return ecma_builtin_typedarray_prototype_copy_within (this_arg, &info, arguments_list_p, arguments_number);
        -: 1982:    }
    #####: 1983:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE:
        -: 1984:    {
    #####: 1985:      return ecma_builtin_typedarray_prototype_slice (this_arg, &info, arguments_list_p, arguments_number);
        -: 1986:    }
    #####: 1987:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING:
        -: 1988:    {
    #####: 1989:      return ecma_builtin_typedarray_prototype_to_locale_string (&info);
        -: 1990:    }
    #####: 1991:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS:
        -: 1992:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES:
        -: 1993:    {
    #####: 1994:      ecma_iterator_kind_t iter_id = (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS)
    #####: 1995:      ? ECMA_ITERATOR_KEYS : ECMA_ITERATOR_ENTRIES;
        -: 1996:
    #####: 1997:      return ecma_typedarray_iterators_helper (this_arg, iter_id);
        -: 1998:    }
    #####: 1999:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER:
        -: 2000:    {
    #####: 2001:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 2002:      ecma_ref_object (buffer_p);
        -: 2003:
    #####: 2004:      return ecma_make_object_value (buffer_p);
        -: 2005:    }
    #####: 2006:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER:
        -: 2007:    {
    #####: 2008:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2009:
    #####: 2010:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 2011:      {
    #####: 2012:        return ecma_make_uint32_value (0);
        -: 2013:      }
        -: 2014:
    #####: 2015:      uint32_t length = ecma_typedarray_get_length (typedarray_p);
    #####: 2016:      uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 2017:      return ecma_make_uint32_value (length << shift);
        -: 2018:    }
    #####: 2019:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER:
        -: 2020:    {
    #####: 2021:      return ecma_make_uint32_value (ecma_typedarray_get_offset (typedarray_p));
        -: 2022:    }
    #####: 2023:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER:
        -: 2024:    {
    #####: 2025:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2026:
    #####: 2027:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 2028:      {
    #####: 2029:        return ecma_make_uint32_value (0);
        -: 2030:      }
        -: 2031:
    #####: 2032:      return ecma_make_uint32_value (ecma_typedarray_get_length (typedarray_p));
        -: 2033:    }
    #####: 2034:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER:
        -: 2035:    {
    #####: 2036:      ecma_extended_object_t *object_p = (ecma_extended_object_t *) typedarray_p;
    #####: 2037:      return ecma_make_magic_string_value (ecma_get_typedarray_magic_string_id (object_p->u.cls.u1.typedarray_type));
        -: 2038:    }
    #####: 2039:    default:
        -: 2040:    {
    #####: 2041:      JERRY_UNREACHABLE ();
        -: 2042:    }
        -: 2043:  }
        -: 2044:} /* ecma_builtin_typedarray_prototype_dispatch_routine */
        -: 2045:
        -: 2046:/**
        -: 2047: * @}
        -: 2048: * @}
        -: 2049: * @}
        -: 2050: */
        -: 2051:
        -: 2052:#endif /* JERRY_BUILTIN_TYPEDARRAY */
