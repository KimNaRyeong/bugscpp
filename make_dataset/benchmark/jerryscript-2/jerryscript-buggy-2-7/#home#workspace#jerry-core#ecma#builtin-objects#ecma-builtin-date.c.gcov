        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-date.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "jcontext.h"
        -:   19:#include "ecma-function-object.h"
        -:   20:#include "ecma-alloc.h"
        -:   21:#include "ecma-builtin-helpers.h"
        -:   22:#include "ecma-conversion.h"
        -:   23:#include "ecma-exceptions.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "lit-char-helpers.h"
        -:   28:
        -:   29:#if JERRY_BUILTIN_DATE
        -:   30:
        -:   31:#define ECMA_BUILTINS_INTERNAL
        -:   32:#include "ecma-builtins-internal.h"
        -:   33:
        -:   34:/**
        -:   35: * This object has a custom dispatch function.
        -:   36: */
        -:   37:#define BUILTIN_CUSTOM_DISPATCH
        -:   38:
        -:   39:/**
        -:   40: * List of built-in routine identifiers.
        -:   41: */
        -:   42:enum
        -:   43:{
        -:   44:  ECMA_DATE_ROUTINE_START = 0,
        -:   45:  ECMA_DATE_ROUTINE_PARSE,
        -:   46:  ECMA_DATE_ROUTINE_UTC,
        -:   47:  ECMA_DATE_ROUTINE_NOW,
        -:   48:};
        -:   49:
        -:   50:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-date.inc.h"
        -:   51:#define BUILTIN_UNDERSCORED_ID date
        -:   52:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   53:
        -:   54:/** \addtogroup ecma ECMA
        -:   55: * @{
        -:   56: *
        -:   57: * \addtogroup ecmabuiltins
        -:   58: * @{
        -:   59: *
        -:   60: * \addtogroup date ECMA Date object built-in
        -:   61: * @{
        -:   62: */
        -:   63:
        -:   64:/**
        -:   65: * Encode minimum/maximum limits
        -:   66: *
        -:   67: * See: ecma_date_parse_date_chars
        -:   68: *
        -:   69: * @param min: 8 bits unsigned number
        -:   70: * @param max: 24 bits unsigned number
        -:   71: */
        -:   72:#define ECMA_DATE_LIMIT(min, max) (min << 24 | max)
        -:   73:
        -:   74:/**
        -:   75: * Decode the minimum value from the encoded limit
        -:   76: */
        -:   77:#define ECMA_DATE_LIMIT_MIN(limit) (limit >> 24)
        -:   78:
        -:   79:/**
        -:   80: * Decode the maximum value from the encoded limit
        -:   81: */
        -:   82:#define ECMA_DATE_LIMIT_MAX(limit) (limit & ((1 << 24) - 1))
        -:   83:
        -:   84:/**
        -:   85: * Helper function to try to parse a part of a date string
        -:   86: *
        -:   87: * @return NaN if cannot read from string, ToNumber() otherwise
        -:   88: */
        -:   89:static ecma_number_t
    #####:   90:ecma_date_parse_date_chars (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:   91:                            const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:   92:                            uint32_t num_of_chars, /**< number of characters to read and convert */
        -:   93:                            uint32_t limit) /**< minimum/maximum valid value */
        -:   94:{
    #####:   95:  JERRY_ASSERT (num_of_chars > 0 && num_of_chars <= 6);
        -:   96:
    #####:   97:  if (*str_p + num_of_chars > str_end_p)
        -:   98:  {
    #####:   99:    return ecma_number_make_nan ();
        -:  100:  }
        -:  101:
    #####:  102:  str_end_p = *str_p + num_of_chars;
        -:  103:
    #####:  104:  uint32_t num = 0;
        -:  105:
    #####:  106:  while (num_of_chars--)
        -:  107:  {
    #####:  108:    lit_utf8_byte_t c = **str_p;
    #####:  109:    if (!lit_char_is_decimal_digit (c))
        -:  110:    {
    #####:  111:      return ecma_number_make_nan ();
        -:  112:    }
        -:  113:
    #####:  114:    num = (num * 10) + (uint32_t) ((c - LIT_CHAR_0));
    #####:  115:    (*str_p)++;
        -:  116:  }
        -:  117:
    #####:  118:  if (num >= ECMA_DATE_LIMIT_MIN (limit) && num <= ECMA_DATE_LIMIT_MAX (limit))
        -:  119:  {
    #####:  120:    return (ecma_number_t) num;
        -:  121:  }
        -:  122:
    #####:  123:  return ecma_number_make_nan ();
        -:  124:} /* ecma_date_parse_date_chars */
        -:  125:
        -:  126:/**
        -:  127: * Helper function to try to parse a special chracter (+,-,T,Z,:,.) in a date string
        -:  128: *
        -:  129: * @return true if the first character is same as the expected, false otherwise
        -:  130: */
        -:  131:static bool
    #####:  132:ecma_date_parse_special_char (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  133:                              const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:  134:                              ecma_char_t expected_char) /**< expected character */
        -:  135:{
    #####:  136:  if ((*str_p < str_end_p) && (**str_p == expected_char))
        -:  137:  {
    #####:  138:    (*str_p)++;
    #####:  139:    return true;
        -:  140:  }
        -:  141:
    #####:  142:  return false;
        -:  143:} /* ecma_date_parse_special_char */
        -:  144:
        -:  145:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  146:ecma_date_check_two_chars (const lit_utf8_byte_t *str_p, /**< pointer to the cesu8 string */
        -:  147:                           const lit_utf8_byte_t *str_end_p, /**< pointer to the end of the string */
        -:  148:                           ecma_char_t expected_char1, /**< first expected character */
        -:  149:                           ecma_char_t expected_char2) /**< second expected character */
        -:  150:{
        -:  151:  return (str_p < str_end_p
    #####:  152:          && (*str_p == expected_char1 || *str_p == expected_char2));
        -:  153:} /* ecma_date_check_two_chars */
        -:  154:
        -:  155:/**
        -:  156: * Helper function to try to parse a 4-5-6 digit year with optional negative sign in a date string
        -:  157: *
        -:  158: * Date.prototype.toString() and Date.prototype.toUTCString() emits year
        -:  159: * in this format and Date.parse() should parse this format too.
        -:  160: *
        -:  161: * @return the parsed year or NaN.
        -:  162: */
        -:  163:static ecma_number_t
    #####:  164:ecma_date_parse_year (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  165:                      const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  166:{
    #####:  167:  bool is_year_sign_negative = ecma_date_parse_special_char (str_p, str_end_p, LIT_CHAR_MINUS);
    #####:  168:  const lit_utf8_byte_t *str_start_p = *str_p;
    #####:  169:  int32_t parsed_year = 0;
        -:  170:
    #####:  171:  while ((str_start_p - *str_p < 6) && (str_start_p < str_end_p) && lit_char_is_decimal_digit (*str_start_p))
        -:  172:  {
    #####:  173:    parsed_year = 10 * parsed_year + *str_start_p - LIT_CHAR_0;
    #####:  174:    str_start_p++;
        -:  175:  }
        -:  176:
    #####:  177:  if (str_start_p - *str_p >= 4)
        -:  178:  {
    #####:  179:    *str_p = str_start_p;
    #####:  180:    return is_year_sign_negative ? -parsed_year : parsed_year;
        -:  181:  }
        -:  182:
    #####:  183:  return ecma_number_make_nan ();
        -:  184:} /* ecma_date_parse_year */
        -:  185:
        -:  186:/**
        -:  187: * Helper function to try to parse a day name in a date string
        -:  188: * Valid day names: Sun, Mon, Tue, Wed, Thu, Fri, Sat
        -:  189: * See also:
        -:  190: *          ECMA-262 v9, 20.3.4.41.2 Table 46
        -:  191: *
        -:  192: * @return true if the string starts with a valid day name, false otherwise
        -:  193: */
        -:  194:static bool
    #####:  195:ecma_date_parse_day_name (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  196:                          const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  197:{
    #####:  198:  if (*str_p + 3 < str_end_p)
        -:  199:  {
    #####:  200:    for (uint32_t i = 0; i < 7; i++)
        -:  201:    {
    #####:  202:      if (!memcmp (day_names_p[i], *str_p, 3))
        -:  203:      {
    #####:  204:        (*str_p) += 3;
    #####:  205:        return true;
        -:  206:      }
        -:  207:    }
        -:  208:  }
    #####:  209:  return false;
        -:  210:} /* ecma_date_parse_day_name */
        -:  211:
        -:  212:/**
        -:  213: * Helper function to try to parse a month name in a date string
        -:  214: * Valid month names: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
        -:  215: * See also:
        -:  216: *          ECMA-262 v9, 20.3.4.41.2 Table 47
        -:  217: *
        -:  218: * @return number of the month if the string starts with a valid month name, 0 otherwise
        -:  219: */
        -:  220:static uint32_t
    #####:  221:ecma_date_parse_month_name (const lit_utf8_byte_t **str_p, /**< pointer to the cesu8 string */
        -:  222:                            const lit_utf8_byte_t *str_end_p) /**< pointer to the end of the string */
        -:  223:{
    #####:  224:  if (*str_p + 3 < str_end_p)
        -:  225:  {
    #####:  226:    for (uint32_t i = 0; i < 12; i++)
        -:  227:    {
    #####:  228:      if (!memcmp (month_names_p[i], *str_p, 3))
        -:  229:      {
    #####:  230:        (*str_p) += 3;
    #####:  231:        return (i + 1);
        -:  232:      }
        -:  233:    }
        -:  234:  }
    #####:  235:  return 0;
        -:  236:} /* ecma_date_parse_month_name */
        -:  237:
        -:  238:/**
        -:  239:  * Calculate MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)) for Date constructor and UTC
        -:  240:  *
        -:  241:  * See also:
        -:  242:  *          ECMA-262 v11, 20.4.3.4
        -:  243:  *
        -:  244:  * @return false - if the operation fails
        -:  245:  *         true - otherwise
        -:  246:  */
        -:  247:static bool
    #####:  248:ecma_date_construct_helper (const ecma_value_t *args, /**< arguments passed to the Date constructor */
        -:  249:                            uint32_t args_len, /**< number of arguments */
        -:  250:                            ecma_number_t *tv_p) /**< [out] time value */
        -:  251:{
    #####:  252:  ecma_number_t date_nums[7] =
        -:  253:  {
        -:  254:    ECMA_NUMBER_ZERO, /* year */
        -:  255:    ECMA_NUMBER_ZERO, /* month */
        -:  256:    ECMA_NUMBER_ONE, /* date */
        -:  257:    ECMA_NUMBER_ZERO, /* hours */
        -:  258:    ECMA_NUMBER_ZERO, /* minutes */
        -:  259:    ECMA_NUMBER_ZERO, /* seconds */
        -:  260:    ECMA_NUMBER_ZERO /* miliseconds */
        -:  261:  };
        -:  262:
    #####:  263:  args_len = JERRY_MIN (args_len, sizeof (date_nums) / sizeof (date_nums[0]));
        -:  264:
        -:  265:  /* 1-7. */
    #####:  266:  for (uint32_t i = 0; i < args_len; i++)
        -:  267:  {
    #####:  268:    ecma_value_t status = ecma_op_to_number (args[i], date_nums + i);
        -:  269:
    #####:  270:    if (ECMA_IS_VALUE_ERROR (status))
        -:  271:    {
    #####:  272:      return false;
        -:  273:    }
        -:  274:  }
        -:  275:
        -:  276:  /* 8. */
    #####:  277:  if (!ecma_number_is_nan (date_nums[0]))
        -:  278:  {
        -:  279:    /* 9.a */
    #####:  280:    ecma_number_t yi = ecma_number_trunc (date_nums[0]);
        -:  281:
        -:  282:    /* 9.b */
    #####:  283:    if (yi >= 0 && yi <= 99)
        -:  284:    {
    #####:  285:      date_nums[0] = 1900 + yi;
        -:  286:    }
        -:  287:  }
        -:  288:
        -:  289:  /* 10. */
    #####:  290:  *tv_p = ecma_date_make_date (ecma_date_make_day (date_nums[0],
        -:  291:                                                   date_nums[1],
        -:  292:                                                   date_nums[2]),
        -:  293:                               ecma_date_make_time (date_nums[3],
        -:  294:                                                    date_nums[4],
        -:  295:                                                    date_nums[5],
        -:  296:                                                    date_nums[6]));
    #####:  297:  return true;
        -:  298:} /* ecma_date_construct_helper */
        -:  299:
        -:  300:/**
        -:  301: * Helper function used by ecma_builtin_date_parse
        -:  302: *
        -:  303: * See also:
        -:  304: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  305: *          ECMA-262 v5, 15.9.1.15 Date Time String Format
        -:  306: *
        -:  307: * @return the parsed date as ecma_number_t or NaN otherwise
        -:  308: */
        -:  309:static ecma_number_t
    #####:  310:ecma_builtin_date_parse_basic (const lit_utf8_byte_t *date_str_curr_p, /**< date string start */
        -:  311:                               const lit_utf8_byte_t *date_str_end_p) /**< date string end */
        -:  312:{
        -:  313:  /* 1. read year */
        -:  314:
    #####:  315:  uint32_t year_digits = 4;
    #####:  316:  uint32_t year_limit = 9999;
        -:  317:
    #####:  318:  bool is_year_sign_negative = false;
        -:  319:
    #####:  320:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_PLUS))
        -:  321:  {
    #####:  322:    is_year_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
    #####:  323:    year_digits = 6;
    #####:  324:    year_limit = 999999;
        -:  325:  }
        -:  326:
    #####:  327:  ecma_number_t year = ecma_date_parse_date_chars (&date_str_curr_p,
        -:  328:                                                   date_str_end_p,
        -:  329:                                                   year_digits,
        -:  330:                                                   ECMA_DATE_LIMIT (0, year_limit));
    #####:  331:  if (is_year_sign_negative)
        -:  332:  {
    #####:  333:    year = -year;
        -:  334:  }
        -:  335:
    #####:  336:  if (ecma_number_is_nan (year))
        -:  337:  {
    #####:  338:    return year;
        -:  339:  }
        -:  340:
    #####:  341:  ecma_number_t month = ECMA_NUMBER_ONE;
    #####:  342:  ecma_number_t day = ECMA_NUMBER_ONE;
    #####:  343:  ecma_number_t time = ECMA_NUMBER_ZERO;
        -:  344:
        -:  345:  /* 2. read month if any */
    #####:  346:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_SLASH))
        -:  347:  {
    #####:  348:    lit_utf8_byte_t separator = *date_str_curr_p++;
    #####:  349:    month = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (1, 12));
        -:  350:
        -:  351:    /* 3. read day if any */
    #####:  352:    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, separator))
        -:  353:    {
    #####:  354:      day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (1, 31));
        -:  355:    }
        -:  356:  }
        -:  357:
    #####:  358:  bool is_utc = true;
        -:  359:  /* 4. read time if any */
    #####:  360:  if (ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_UPPERCASE_T, LIT_CHAR_SP))
        -:  361:  {
    #####:  362:    date_str_curr_p++;
        -:  363:
    #####:  364:    ecma_number_t hours = ECMA_NUMBER_ZERO;
    #####:  365:    ecma_number_t minutes = ECMA_NUMBER_ZERO;
    #####:  366:    ecma_number_t seconds = ECMA_NUMBER_ZERO;
    #####:  367:    ecma_number_t milliseconds = ECMA_NUMBER_ZERO;
        -:  368:
        -:  369:    /* 'HH:mm' must present */
    #####:  370:    if (date_str_end_p - date_str_curr_p < 5)
        -:  371:    {
    #####:  372:      return ecma_number_make_nan ();
        -:  373:    }
        -:  374:
        -:  375:    /* 4.1 read hours and minutes */
    #####:  376:    hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  377:
    #####:  378:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  379:    {
    #####:  380:      return ecma_number_make_nan ();
        -:  381:    }
        -:  382:
    #####:  383:    minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  384:
        -:  385:    /* 4.2 read seconds if any */
    #####:  386:    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  387:    {
    #####:  388:      seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  389:
        -:  390:      /* 4.3 read milliseconds if any */
    #####:  391:      if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_DOT))
        -:  392:      {
    #####:  393:        milliseconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 3, ECMA_DATE_LIMIT (0, 999));
        -:  394:      }
        -:  395:    }
        -:  396:
    #####:  397:    if (hours == 24 && (minutes != 0 || seconds != 0 || milliseconds != 0))
        -:  398:    {
    #####:  399:      return ecma_number_make_nan ();
        -:  400:    }
        -:  401:
    #####:  402:    time = ecma_date_make_time (hours, minutes, seconds, milliseconds);
        -:  403:
    #####:  404:    if (ecma_number_is_nan (time))
        -:  405:    {
    #####:  406:      return time;
        -:  407:    }
        -:  408:
        -:  409:    /* 4.4 read timezone if any */
    #####:  410:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_UPPERCASE_Z))
        -:  411:    {
    #####:  412:      if ((date_str_end_p - date_str_curr_p) == 6
    #####:  413:          && (*date_str_curr_p == LIT_CHAR_MINUS || *date_str_curr_p == LIT_CHAR_PLUS))
    #####:  414:      {
    #####:  415:        bool is_timezone_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
        -:  416:        /* read hours and minutes */
    #####:  417:        hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  418:
    #####:  419:        if (hours == 24)
        -:  420:        {
    #####:  421:          hours = ECMA_NUMBER_ZERO;
        -:  422:        }
        -:  423:
    #####:  424:        if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  425:        {
    #####:  426:          return ecma_number_make_nan ();
        -:  427:        }
        -:  428:
    #####:  429:        minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
    #####:  430:        ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);
    #####:  431:        time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;
        -:  432:      }
        -:  433:      else
        -:  434:      {
    #####:  435:        is_utc = false;
        -:  436:      }
        -:  437:    }
        -:  438:  }
        -:  439:
    #####:  440:  if (date_str_curr_p < date_str_end_p)
        -:  441:  {
    #####:  442:    return ecma_number_make_nan ();
        -:  443:  }
        -:  444:
    #####:  445:  ecma_number_t date = ecma_date_make_day (year, month - 1, day);
    #####:  446:  ecma_number_t result_date = ecma_date_make_date (date, time);
        -:  447:
    #####:  448:  if (!is_utc)
        -:  449:  {
    #####:  450:    result_date = ecma_date_utc (result_date);
        -:  451:  }
        -:  452:
    #####:  453:  return result_date;
        -:  454:} /* ecma_builtin_date_parse_basic */
        -:  455:
        -:  456:/**
        -:  457: * Helper function used by ecma_builtin_date_parse
        -:  458: *
        -:  459: * See also:
        -:  460: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  461: *          ECMA-262 v9, 20.3.4.41 Date.prototype.toString ()
        -:  462: *          ECMA-262 v9, 20.3.4.43 Date.prototype.toUTCString ()
        -:  463: *
        -:  464: * Used by: ecma_builtin_date_parse
        -:  465: *
        -:  466: * @return the parsed date as ecma_number_t or NaN otherwise
        -:  467: */
        -:  468:static ecma_number_t
    #####:  469:ecma_builtin_date_parse_toString_formats (const lit_utf8_byte_t *date_str_curr_p,
        -:  470:                                          const lit_utf8_byte_t *date_str_end_p)
        -:  471:{
    #####:  472:  const ecma_number_t nan = ecma_number_make_nan ();
        -:  473:
    #####:  474:  if (!ecma_date_parse_day_name (&date_str_curr_p, date_str_end_p))
        -:  475:  {
    #####:  476:    return nan;
        -:  477:  }
        -:  478:
    #####:  479:  const bool is_toUTCString_format = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COMMA);
        -:  480:
    #####:  481:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  482:  {
    #####:  483:    return nan;
        -:  484:  }
        -:  485:
    #####:  486:  ecma_number_t month = 0;
    #####:  487:  ecma_number_t day = 0;
    #####:  488:  if (is_toUTCString_format)
        -:  489:  {
    #####:  490:    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 31));
        -:  491:
    #####:  492:    if (ecma_number_is_nan (day))
        -:  493:    {
    #####:  494:      return nan;
        -:  495:    }
        -:  496:
    #####:  497:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  498:    {
    #####:  499:      return nan;
        -:  500:    }
        -:  501:
    #####:  502:    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);
        -:  503:
    #####:  504:    if (month == 0)
        -:  505:    {
    #####:  506:      return ecma_number_make_nan ();
        -:  507:    }
        -:  508:  }
        -:  509:  else
        -:  510:  {
    #####:  511:    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);
        -:  512:
    #####:  513:    if (month == 0)
        -:  514:    {
    #####:  515:      return nan;
        -:  516:    }
        -:  517:
    #####:  518:    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  519:    {
    #####:  520:      return nan;
        -:  521:    }
        -:  522:
    #####:  523:    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 31));
        -:  524:
    #####:  525:    if (ecma_number_is_nan (day))
        -:  526:    {
    #####:  527:      return nan;
        -:  528:    }
        -:  529:  }
        -:  530:
    #####:  531:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  532:  {
    #####:  533:    return nan;
        -:  534:  }
        -:  535:
    #####:  536:  ecma_number_t year = ecma_date_parse_year (&date_str_curr_p, date_str_end_p);
        -:  537:
    #####:  538:  if (ecma_number_is_nan (year))
        -:  539:  {
    #####:  540:    return nan;
        -:  541:  }
        -:  542:
    #####:  543:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_SP))
        -:  544:  {
    #####:  545:    return nan;
        -:  546:  }
        -:  547:
    #####:  548:  ecma_number_t hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  549:
    #####:  550:  if (ecma_number_is_nan (hours))
        -:  551:  {
    #####:  552:    return nan;
        -:  553:  }
        -:  554:
    #####:  555:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  556:  {
    #####:  557:    return nan;
        -:  558:  }
        -:  559:
    #####:  560:  ecma_number_t minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  561:
    #####:  562:  if (ecma_number_is_nan (minutes))
        -:  563:  {
    #####:  564:    return nan;
        -:  565:  }
        -:  566:
    #####:  567:  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, LIT_CHAR_COLON))
        -:  568:  {
    #####:  569:    return nan;
        -:  570:  }
        -:  571:
    #####:  572:  ecma_number_t seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  573:
    #####:  574:  if (ecma_number_is_nan (seconds))
        -:  575:  {
    #####:  576:    return nan;
        -:  577:  }
        -:  578:
    #####:  579:  if (hours == 24 && (minutes != 0 || seconds != 0))
        -:  580:  {
    #####:  581:    return nan;
        -:  582:  }
        -:  583:
    #####:  584:  const char gmt_p[] = " GMT";
    #####:  585:  if (date_str_end_p - date_str_curr_p < 4
    #####:  586:      || memcmp (date_str_curr_p, gmt_p, 4) != 0)
        -:  587:  {
    #####:  588:    return nan;
        -:  589:  }
        -:  590:
    #####:  591:  date_str_curr_p += 4;
        -:  592:
    #####:  593:  ecma_number_t time = ecma_date_make_time (hours, minutes, seconds, 0);
        -:  594:
    #####:  595:  if (!is_toUTCString_format)
        -:  596:  {
    #####:  597:    if (!ecma_date_check_two_chars (date_str_curr_p, date_str_end_p, LIT_CHAR_MINUS, LIT_CHAR_PLUS))
        -:  598:    {
    #####:  599:      return nan;
        -:  600:    }
        -:  601:
    #####:  602:    bool is_timezone_sign_negative = (*date_str_curr_p++ == LIT_CHAR_MINUS);
        -:  603:
    #####:  604:    hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 24));
        -:  605:
    #####:  606:    if (ecma_number_is_nan (hours))
        -:  607:    {
    #####:  608:      return nan;
        -:  609:    }
        -:  610:
    #####:  611:    if (hours == 24)
        -:  612:    {
    #####:  613:      hours = ECMA_NUMBER_ZERO;
        -:  614:    }
        -:  615:
    #####:  616:    minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, ECMA_DATE_LIMIT (0, 59));
        -:  617:
    #####:  618:    if (ecma_number_is_nan (minutes))
        -:  619:    {
    #####:  620:      return nan;
        -:  621:    }
        -:  622:
    #####:  623:    ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);
        -:  624:
    #####:  625:    time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;
        -:  626:  }
        -:  627:
    #####:  628:  if (date_str_curr_p < date_str_end_p)
        -:  629:  {
    #####:  630:    return nan;
        -:  631:  }
        -:  632:
    #####:  633:  ecma_number_t date = ecma_date_make_day (year, month - 1, day);
    #####:  634:  return ecma_date_make_date (date, time);
        -:  635:} /* ecma_builtin_date_parse_toString_formats */
        -:  636:
        -:  637:/**
        -:  638: * The Date object's 'parse' routine
        -:  639: *
        -:  640: * See also:
        -:  641: *          ECMA-262 v5, 15.9.4.2  Date.parse (string)
        -:  642: *          ECMA-262 v5, 15.9.1.15 Date Time String Format
        -:  643: *          ECMA-262 v9, 20.3.4.41 Date.prototype.toString ()
        -:  644: *          ECMA-262 v9, 20.3.4.43 Date.prototype.toUTCString ()
        -:  645: *
        -:  646: * @return parsed time
        -:  647: */
        -:  648:static ecma_number_t
    #####:  649:ecma_builtin_date_parse (ecma_string_t *string_p) /**< string */
        -:  650:{
    #####:  651:  ECMA_STRING_TO_UTF8_STRING (string_p, str_p, str_size);
    #####:  652:  const lit_utf8_byte_t *date_str_curr_p = str_p;
    #####:  653:  const lit_utf8_byte_t *date_str_end_p = str_p + str_size;
        -:  654:
        -:  655:  /* try to parse date string as ISO string - ECMA-262 v5, 15.9.1.15 */
    #####:  656:  ecma_number_t tv = ecma_builtin_date_parse_basic (date_str_curr_p, date_str_end_p);
        -:  657:
    #####:  658:  if (ecma_number_is_nan (tv))
        -:  659:  {
        -:  660:    /* try to parse date string in Date.prototype.toString() or toUTCString() format */
    #####:  661:    tv = ecma_builtin_date_parse_toString_formats (date_str_curr_p, date_str_end_p);
        -:  662:  }
        -:  663:
    #####:  664:  ECMA_FINALIZE_UTF8_STRING (str_p, str_size);
        -:  665:
    #####:  666:  return tv;
        -:  667:} /* ecma_builtin_date_parse */
        -:  668:
        -:  669:/**
        -:  670: * The Date object's 'UTC' routine
        -:  671: *
        -:  672: * See also:
        -:  673: *          ECMA-262 v5, 15.9.4.3
        -:  674: *
        -:  675: * @return ecma value
        -:  676: *         Returned value must be freed with ecma_free_value.
        -:  677: */
        -:  678:static ecma_value_t
    #####:  679:ecma_builtin_date_utc (const ecma_value_t args[], /**< arguments list */
        -:  680:                       uint32_t args_number) /**< number of arguments */
        -:  681:{
        -:  682:#if JERRY_ESNEXT
    #####:  683:  const uint32_t required_args_number = 1;
        -:  684:#else /* !JERRY_ESNEXT */
    #####:  685:  const uint32_t required_args_number = 2;
        -:  686:#endif /* JERRY_ESNEXT */
        -:  687:
    #####:  688:  if (args_number < required_args_number)
        -:  689:  {
    #####:  690:    return ecma_make_number_value (ecma_number_make_nan ());
        -:  691:  }
        -:  692:
    #####:  693:  ecma_number_t tv;
        -:  694:
    #####:  695:  if (!ecma_date_construct_helper (args, args_number, &tv))
        -:  696:  {
    #####:  697:    return ECMA_VALUE_ERROR;
        -:  698:  }
        -:  699:
    #####:  700:  return ecma_make_number_value ((ecma_number_t) ecma_date_time_clip (tv));
        -:  701:} /* ecma_builtin_date_utc */
        -:  702:
        -:  703:/**
        -:  704: * Helper method to get the current time
        -:  705: *
        -:  706: * @return ecma_number_t
        -:  707: */
        -:  708:static ecma_number_t
    #####:  709:ecma_builtin_date_now_helper (void)
        -:  710:{
    #####:  711:  return floor (DOUBLE_TO_ECMA_NUMBER_T (jerry_port_get_current_time ()));
        -:  712:} /* ecma_builtin_date_now_helper */
        -:  713:
        -:  714:/**
        -:  715: * Construct a date object with the given [[DateValue]]
        -:  716: *
        -:  717: * Note: New target must be a valid object
        -:  718: *
        -:  719: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  720: *         constructed date object - otherwise
        -:  721: */
        -:  722:static ecma_value_t
    #####:  723:ecma_builtin_date_create (ecma_number_t tv)
        -:  724:{
        -:  725:#if JERRY_ESNEXT
    #####:  726:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p) != NULL);
        -:  727:
    #####:  728:  ecma_object_t *prototype_obj_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p),
        -:  729:                                                                           ECMA_BUILTIN_ID_DATE_PROTOTYPE);
        -:  730:
    #####:  731:  if (JERRY_UNLIKELY (prototype_obj_p == NULL))
        -:  732:  {
    #####:  733:    return ECMA_VALUE_ERROR;
        -:  734:  }
        -:  735:
    #####:  736:  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, sizeof (ecma_date_object_t), ECMA_OBJECT_TYPE_CLASS);
    #####:  737:  ecma_deref_object (prototype_obj_p);
        -:  738:
    #####:  739:  ecma_date_object_t *date_object_p = (ecma_date_object_t *) obj_p;
    #####:  740:  date_object_p->header.u.cls.type = ECMA_OBJECT_CLASS_DATE;
    #####:  741:  date_object_p->header.u.cls.u1.date_flags = ECMA_DATE_TZA_NONE;
    #####:  742:  date_object_p->header.u.cls.u3.tza = 0;
    #####:  743:  date_object_p->date_value = tv;
        -:  744:#else /* !JERRY_ESNEXT */
    #####:  745:  ecma_number_t *date_value_p = ecma_alloc_number ();
    #####:  746:  *date_value_p = tv;
        -:  747:
    #####:  748:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_DATE_PROTOTYPE);
    #####:  749:  ecma_object_t *obj_p = ecma_create_object (prototype_obj_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  750:
    #####:  751:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
    #####:  752:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_DATE;
    #####:  753:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.date, date_value_p);
        -:  754:#endif /* JERRY_ESNEXT */
        -:  755:
    #####:  756:  return ecma_make_object_value (obj_p);
        -:  757:} /* ecma_builtin_date_create */
        -:  758:
        -:  759:/**
        -:  760: * Handle calling [[Call]] of built-in Date object
        -:  761: *
        -:  762: * See also:
        -:  763: *          ECMA-262 v5, 15.9.2.1
        -:  764: *
        -:  765: * @return ecma value
        -:  766: */
        -:  767:ecma_value_t
    #####:  768:ecma_builtin_date_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  769:                                 uint32_t arguments_list_len) /**< number of arguments */
        -:  770:{
        -:  771:  JERRY_UNUSED (arguments_list_p);
        -:  772:  JERRY_UNUSED (arguments_list_len);
        -:  773:
    #####:  774:  return ecma_date_value_to_string (ecma_builtin_date_now_helper ());
        -:  775:} /* ecma_builtin_date_dispatch_call */
        -:  776:
        -:  777:/**
        -:  778: * Handle calling [[Construct]] of built-in Date object
        -:  779: *
        -:  780: * See also:
        -:  781: *          ECMA-262 v5, 15.9.3.1
        -:  782: *          ECMA-262 v11, 20.4.2
        -:  783: *
        -:  784: * @return ecma value
        -:  785: */
        -:  786:ecma_value_t
    #####:  787:ecma_builtin_date_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  788:                                      uint32_t arguments_list_len) /**< number of arguments */
        -:  789:{
        -:  790:
        -:  791:  /* 20.4.2.3 */
    #####:  792:  if (arguments_list_len == 0)
        -:  793:  {
    #####:  794:    return ecma_builtin_date_create (ecma_builtin_date_now_helper ());
        -:  795:  }
        -:  796:
    #####:  797:  ecma_number_t tv;
        -:  798:  /* 20.4.2.2 */
    #####:  799:  if (arguments_list_len == 1)
        -:  800:  {
    #####:  801:    ecma_value_t argument = arguments_list_p[0];
        -:  802:
        -:  803:    /* 4.a */
    #####:  804:    if (ecma_is_value_object (argument)
    #####:  805:        && ecma_object_class_is (ecma_get_object_from_value (argument), ECMA_OBJECT_CLASS_DATE))
        -:  806:    {
        -:  807:
        -:  808:#if JERRY_ESNEXT
    #####:  809:      tv = ((ecma_date_object_t *) ecma_get_object_from_value (argument))->date_value;
        -:  810:#else /* !JERRY_ESNEXT */
    #####:  811:      ecma_extended_object_t *arg_ext_object_p = (ecma_extended_object_t *) ecma_get_object_from_value (argument);
    #####:  812:      tv = *ECMA_GET_INTERNAL_VALUE_POINTER (ecma_number_t, arg_ext_object_p->u.cls.u3.date);
        -:  813:#endif /* JERRY_ESNEXT */
        -:  814:
    #####:  815:      return ecma_builtin_date_create (tv);
        -:  816:    }
        -:  817:    /* 4.b */
    #####:  818:    ecma_value_t primitive = ecma_op_to_primitive (argument, ECMA_PREFERRED_TYPE_NO);
        -:  819:
    #####:  820:    if (ECMA_IS_VALUE_ERROR (primitive))
        -:  821:    {
    #####:  822:      return primitive;
        -:  823:    }
        -:  824:
    #####:  825:    if (ecma_is_value_string (primitive))
        -:  826:    {
    #####:  827:      ecma_string_t *prim_str_p = ecma_get_string_from_value (primitive);
    #####:  828:      tv = ecma_builtin_date_parse (prim_str_p);
    #####:  829:      ecma_deref_ecma_string (prim_str_p);
        -:  830:    }
        -:  831:    else
        -:  832:    {
    #####:  833:      ecma_value_t prim_value = ecma_op_to_number (primitive, &tv);
    #####:  834:      ecma_free_value (primitive);
        -:  835:
    #####:  836:      if (ECMA_IS_VALUE_ERROR (prim_value))
        -:  837:      {
    #####:  838:        return prim_value;
        -:  839:      }
        -:  840:    }
        -:  841:  }
        -:  842:  /* 20.4.2.1 */
    #####:  843:  else if (ecma_date_construct_helper (arguments_list_p, arguments_list_len, &tv))
        -:  844:  {
    #####:  845:    tv = ecma_date_utc (tv);
        -:  846:  }
        -:  847:  else
        -:  848:  {
    #####:  849:    return ECMA_VALUE_ERROR;
        -:  850:  }
        -:  851:
    #####:  852:  return ecma_builtin_date_create (ecma_date_time_clip (tv));
        -:  853:} /* ecma_builtin_date_dispatch_construct */
        -:  854:
        -:  855:/**
        -:  856: * Dispatcher of the built-in's routines
        -:  857: *
        -:  858: * @return ecma value
        -:  859: *         Returned value must be freed with ecma_free_value.
        -:  860: */
        -:  861:ecma_value_t
    #####:  862:ecma_builtin_date_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine  identifier */
        -:  863:                                    ecma_value_t this_arg, /**< 'this' argument value */
        -:  864:                                    const ecma_value_t arguments_list_p[], /**< list of arguments passed to routine */
        -:  865:                                    uint32_t arguments_number) /**< length of arguments' list */
        -:  866:{
        -:  867:  JERRY_UNUSED (this_arg);
        -:  868:
    #####:  869:  switch (builtin_routine_id)
        -:  870:  {
    #####:  871:    case ECMA_DATE_ROUTINE_NOW:
        -:  872:    {
    #####:  873:      return ecma_make_number_value (ecma_builtin_date_now_helper ());
        -:  874:    }
    #####:  875:    case ECMA_DATE_ROUTINE_UTC:
        -:  876:    {
    #####:  877:      return ecma_builtin_date_utc (arguments_list_p, arguments_number);
        -:  878:    }
    #####:  879:    case ECMA_DATE_ROUTINE_PARSE:
        -:  880:    {
    #####:  881:      if (arguments_number < 1)
        -:  882:      {
    #####:  883:        return ecma_make_number_value (ecma_number_make_nan ());
        -:  884:      }
        -:  885:
    #####:  886:      ecma_string_t *str_p = ecma_op_to_string (arguments_list_p[0]);
        -:  887:
    #####:  888:      if (JERRY_UNLIKELY (str_p == NULL))
        -:  889:      {
    #####:  890:        return ECMA_VALUE_ERROR;
        -:  891:      }
        -:  892:
    #####:  893:      ecma_value_t result = ecma_make_number_value (ecma_date_time_clip (ecma_builtin_date_parse (str_p)));
    #####:  894:      ecma_deref_ecma_string (str_p);
        -:  895:
    #####:  896:      return result;
        -:  897:    }
    #####:  898:    default:
        -:  899:    {
    #####:  900:      JERRY_UNREACHABLE ();
        -:  901:    }
        -:  902:  }
        -:  903:} /* ecma_builtin_date_dispatch_routine */
        -:  904:
        -:  905:/**
        -:  906: * @}
        -:  907: * @}
        -:  908: * @}
        -:  909: */
        -:  910:
        -:  911:#endif /* JERRY_BUILTIN_DATE */
