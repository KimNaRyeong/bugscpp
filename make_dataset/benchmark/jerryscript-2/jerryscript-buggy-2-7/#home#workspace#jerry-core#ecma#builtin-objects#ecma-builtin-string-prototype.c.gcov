        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-string-prototype.c
        -:    0:Programs:296
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-builtin-regexp.inc.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-iterator-object.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-string-object.h"
        -:   30:#include "jcontext.h"
        -:   31:#include "jrt.h"
        -:   32:#include "jrt-libc-includes.h"
        -:   33:#include "lit-char-helpers.h"
        -:   34:#include "lit-strings.h"
        -:   35:
        -:   36:#if JERRY_BUILTIN_REGEXP
        -:   37:#include "ecma-regexp-object.h"
        -:   38:#endif /* JERRY_BUILTIN_REGEXP */
        -:   39:
        -:   40:#if JERRY_BUILTIN_STRING
        -:   41:
        -:   42:#define ECMA_BUILTINS_INTERNAL
        -:   43:#include "ecma-builtins-internal.h"
        -:   44:
        -:   45:/**
        -:   46: * This object has a custom dispatch function.
        -:   47: */
        -:   48:#define BUILTIN_CUSTOM_DISPATCH
        -:   49:
        -:   50:/**
        -:   51: * List of built-in routine identifiers.
        -:   52: */
        -:   53:enum
        -:   54:{
        -:   55:  ECMA_STRING_PROTOTYPE_ROUTINE_START = 0,
        -:   56:  /* Note: These 4 routines MUST be in this order */
        -:   57:  ECMA_STRING_PROTOTYPE_TO_STRING,
        -:   58:  ECMA_STRING_PROTOTYPE_VALUE_OF,
        -:   59:  ECMA_STRING_PROTOTYPE_CHAR_AT,
        -:   60:  ECMA_STRING_PROTOTYPE_CHAR_CODE_AT,
        -:   61:
        -:   62:  ECMA_STRING_PROTOTYPE_CONCAT,
        -:   63:  ECMA_STRING_PROTOTYPE_SLICE,
        -:   64:  ECMA_STRING_PROTOTYPE_AT,
        -:   65:
        -:   66:  ECMA_STRING_PROTOTYPE_LOCALE_COMPARE,
        -:   67:
        -:   68:  ECMA_STRING_PROTOTYPE_MATCH,
        -:   69:  ECMA_STRING_PROTOTYPE_REPLACE,
        -:   70:  ECMA_STRING_PROTOTYPE_SEARCH,
        -:   71:
        -:   72:  ECMA_STRING_PROTOTYPE_SPLIT,
        -:   73:  ECMA_STRING_PROTOTYPE_SUBSTRING,
        -:   74:  ECMA_STRING_PROTOTYPE_TO_LOWER_CASE,
        -:   75:  ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE,
        -:   76:  ECMA_STRING_PROTOTYPE_TO_UPPER_CASE,
        -:   77:  ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE,
        -:   78:  ECMA_STRING_PROTOTYPE_TRIM,
        -:   79:
        -:   80:  ECMA_STRING_PROTOTYPE_SUBSTR,
        -:   81:
        -:   82:  ECMA_STRING_PROTOTYPE_REPEAT,
        -:   83:  ECMA_STRING_PROTOTYPE_CODE_POINT_AT,
        -:   84:  ECMA_STRING_PROTOTYPE_PAD_START,
        -:   85:  ECMA_STRING_PROTOTYPE_PAD_END,
        -:   86:  /* Note: These 5 routines MUST be in this order */
        -:   87:  ECMA_STRING_PROTOTYPE_LAST_INDEX_OF,
        -:   88:  ECMA_STRING_PROTOTYPE_INDEX_OF,
        -:   89:  ECMA_STRING_PROTOTYPE_STARTS_WITH,
        -:   90:  ECMA_STRING_PROTOTYPE_INCLUDES,
        -:   91:  ECMA_STRING_PROTOTYPE_ENDS_WITH,
        -:   92:
        -:   93:  ECMA_STRING_PROTOTYPE_ITERATOR,
        -:   94:  ECMA_STRING_PROTOTYPE_REPLACE_ALL,
        -:   95:  ECMA_STRING_PROTOTYPE_MATCH_ALL,
        -:   96:};
        -:   97:
        -:   98:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-string-prototype.inc.h"
        -:   99:#define BUILTIN_UNDERSCORED_ID string_prototype
        -:  100:#include "ecma-builtin-internal-routines-template.inc.h"
        -:  101:
        -:  102:/** \addtogroup ecma ECMA
        -:  103: * @{
        -:  104: *
        -:  105: * \addtogroup ecmabuiltins
        -:  106: * @{
        -:  107: *
        -:  108: * \addtogroup stringprototype ECMA String.prototype object built-in
        -:  109: * @{
        -:  110: */
        -:  111:
        -:  112:/**
        -:  113: * The String.prototype object's 'toString' and 'valueOf' routines
        -:  114: *
        -:  115: * See also:
        -:  116: *          ECMA-262 v5, 15.5.4.2
        -:  117: *          ECMA-262 v5, 15.5.4.3
        -:  118: *
        -:  119: * @return ecma value
        -:  120: *         Returned value must be freed with ecma_free_value.
        -:  121: */
        -:  122:static ecma_value_t
    #####:  123:ecma_builtin_string_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */
        -:  124:{
    #####:  125:  if (ecma_is_value_string (this_arg))
        -:  126:  {
    #####:  127:    return ecma_copy_value (this_arg);
        -:  128:  }
        -:  129:
    #####:  130:  if (ecma_is_value_object (this_arg))
        -:  131:  {
    #####:  132:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  133:
    #####:  134:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_STRING))
        -:  135:    {
    #####:  136:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  137:
    #####:  138:      JERRY_ASSERT (ecma_is_value_string (ext_object_p->u.cls.u3.value));
        -:  139:
    #####:  140:      return ecma_copy_value (ext_object_p->u.cls.u3.value);
        -:  141:    }
        -:  142:  }
        -:  143:
    #####:  144:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a string or a String object"));
        -:  145:} /* ecma_builtin_string_prototype_object_to_string */
        -:  146:
        -:  147:/**
        -:  148: * Helper function for the String.prototype object's 'charAt' and charCodeAt' routine
        -:  149: *
        -:  150: * @return ecma value
        -:  151: *         Returned value must be freed with ecma_free_value.
        -:  152: */
        -:  153:static ecma_value_t
    #####:  154:ecma_builtin_string_prototype_char_at_helper (ecma_value_t this_arg, /**< this argument */
        -:  155:                                              ecma_value_t arg, /**< routine's argument */
        -:  156:                                              bool charcode_mode) /**< routine mode */
        -:  157:{
        -:  158:  /* 3 */
    #####:  159:  ecma_number_t index_num;
    #####:  160:  ecma_value_t to_num_result = ecma_op_to_integer (arg, &index_num);
        -:  161:
    #####:  162:  if (JERRY_UNLIKELY (!ecma_is_value_empty (to_num_result)))
        -:  163:  {
    #####:  164:    return to_num_result;
        -:  165:  }
        -:  166:
        -:  167:  /* 2 */
    #####:  168:  ecma_string_t *original_string_p = ecma_op_to_string (this_arg);
    #####:  169:  if (JERRY_UNLIKELY (original_string_p == NULL))
        -:  170:  {
    #####:  171:    return ECMA_VALUE_ERROR;
        -:  172:  }
        -:  173:
        -:  174:  /* 4 */
    #####:  175:  const lit_utf8_size_t len = ecma_string_get_length (original_string_p);
        -:  176:
        -:  177:  /* 5 */
        -:  178:  // When index_num is NaN, then the first two comparisons are false
    #####:  179:  if (index_num < 0 || index_num >= len || (ecma_number_is_nan (index_num) && len == 0))
        -:  180:  {
    #####:  181:    ecma_deref_ecma_string (original_string_p);
        -:  182:    return (charcode_mode ? ecma_make_nan_value ()
    #####:  183:                          : ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY));
        -:  184:  }
        -:  185:
        -:  186:  /* 6 */
        -:  187:  /*
        -:  188:   * String length is currently uint32_t, but index_num may be bigger,
        -:  189:   * ToInteger performs floor, while ToUInt32 performs modulo 2^32,
        -:  190:   * hence after the check 0 <= index_num < len we assume to_uint32 can be used.
        -:  191:   * We assume to_uint32 (NaN) is 0.
        -:  192:   */
    #####:  193:  JERRY_ASSERT (ecma_number_is_nan (index_num) || ecma_number_to_uint32 (index_num) == ecma_number_trunc (index_num));
        -:  194:
    #####:  195:  ecma_char_t new_ecma_char = ecma_string_get_char_at_pos (original_string_p, ecma_number_to_uint32 (index_num));
    #####:  196:  ecma_deref_ecma_string (original_string_p);
        -:  197:
    #####:  198:  return (charcode_mode ? ecma_make_uint32_value (new_ecma_char)
    #####:  199:                        : ecma_make_string_value (ecma_new_ecma_string_from_code_unit (new_ecma_char)));
        -:  200:} /* ecma_builtin_string_prototype_char_at_helper */
        -:  201:
        -:  202:/**
        -:  203: * The String.prototype object's 'concat' routine
        -:  204: *
        -:  205: * See also:
        -:  206: *          ECMA-262 v5, 15.5.4.6
        -:  207: *
        -:  208: * @return ecma value
        -:  209: *         Returned value must be freed with ecma_free_value.
        -:  210: */
        -:  211:static ecma_value_t
    #####:  212:ecma_builtin_string_prototype_object_concat (ecma_string_t *this_string_p, /**< this argument */
        -:  213:                                             const ecma_value_t *argument_list_p, /**< arguments list */
        -:  214:                                             uint32_t arguments_number) /**< number of arguments */
        -:  215:{
    #####:  216:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (this_string_p);
        -:  217:
        -:  218:  /* 5 */
    #####:  219:  for (uint32_t arg_index = 0; arg_index < arguments_number; ++arg_index)
        -:  220:  {
        -:  221:    /* 5a, b */
    #####:  222:    ecma_string_t *get_arg_string_p = ecma_op_to_string (argument_list_p[arg_index]);
        -:  223:
    #####:  224:    if (JERRY_UNLIKELY (get_arg_string_p == NULL))
        -:  225:    {
    #####:  226:      ecma_stringbuilder_destroy (&builder);
    #####:  227:      return ECMA_VALUE_ERROR;
        -:  228:    }
        -:  229:
    #####:  230:    ecma_stringbuilder_append (&builder, get_arg_string_p);
        -:  231:
    #####:  232:    ecma_deref_ecma_string (get_arg_string_p);
        -:  233:  }
        -:  234:
        -:  235:  /* 6 */
    #####:  236:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  237:} /* ecma_builtin_string_prototype_object_concat */
        -:  238:
        -:  239:/**
        -:  240: * The String.prototype object's 'localeCompare' routine
        -:  241: *
        -:  242: * See also:
        -:  243: *          ECMA-262 v5, 15.5.4.9
        -:  244: *
        -:  245: * @return ecma value
        -:  246: *         Returned value must be freed with ecma_free_value.
        -:  247: */
        -:  248:static ecma_value_t
    #####:  249:ecma_builtin_string_prototype_object_locale_compare (ecma_string_t *this_string_p, /**< this argument */
        -:  250:                                                     ecma_value_t arg) /**< routine's argument */
        -:  251:{
        -:  252:  /* 3. */
    #####:  253:  ecma_string_t *arg_string_p = ecma_op_to_string (arg);
        -:  254:
    #####:  255:  if (JERRY_UNLIKELY (arg_string_p == NULL))
        -:  256:  {
    #####:  257:    return ECMA_VALUE_ERROR;
        -:  258:  }
        -:  259:
    #####:  260:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -:  261:
    #####:  262:  if (ecma_compare_ecma_strings_relational (this_string_p, arg_string_p))
        -:  263:  {
    #####:  264:    result = ECMA_NUMBER_MINUS_ONE;
        -:  265:  }
    #####:  266:  else if (!ecma_compare_ecma_strings (this_string_p, arg_string_p))
        -:  267:  {
    #####:  268:    result = ECMA_NUMBER_ONE;
        -:  269:  }
        -:  270:  else
        -:  271:  {
    #####:  272:    result = ECMA_NUMBER_ZERO;
        -:  273:  }
        -:  274:
    #####:  275:  ecma_deref_ecma_string (arg_string_p);
        -:  276:
    #####:  277:  return ecma_make_number_value (result);
        -:  278:} /* ecma_builtin_string_prototype_object_locale_compare */
        -:  279:
        -:  280:#if JERRY_BUILTIN_REGEXP
        -:  281:/**
        -:  282: * The String.prototype object's 'match' routine
        -:  283: *
        -:  284: * See also:
        -:  285: *          ECMA-262 v5, 15.5.4.10
        -:  286: *
        -:  287: * @return ecma value
        -:  288: *         Returned value must be freed with ecma_free_value.
        -:  289: */
        -:  290:static ecma_value_t
    #####:  291:ecma_builtin_string_prototype_object_match (ecma_value_t this_argument, /**< this argument */
        -:  292:                                            ecma_value_t regexp_arg) /**< routine's argument */
        -:  293:{
        -:  294:#if JERRY_ESNEXT
        -:  295:  /* 3. */
    #####:  296:  if (!(ecma_is_value_undefined (regexp_arg) || ecma_is_value_null (regexp_arg)))
        -:  297:  {
        -:  298:    /* 3.a */
    #####:  299:    ecma_value_t matcher = ecma_op_get_method_by_symbol_id (regexp_arg, LIT_GLOBAL_SYMBOL_MATCH);
        -:  300:
        -:  301:    /* 3.b */
    #####:  302:    if (ECMA_IS_VALUE_ERROR (matcher))
        -:  303:    {
    #####:  304:      return matcher;
        -:  305:    }
        -:  306:
        -:  307:    /* 3.c */
    #####:  308:    if (!ecma_is_value_undefined (matcher))
        -:  309:    {
        -:  310:      /* 3.c.i */
    #####:  311:      ecma_object_t *matcher_method = ecma_get_object_from_value (matcher);
    #####:  312:      ecma_value_t result = ecma_op_function_call (matcher_method, regexp_arg, &this_argument, 1);
    #####:  313:      ecma_deref_object (matcher_method);
    #####:  314:      return result;
        -:  315:    }
        -:  316:  }
        -:  317:
        -:  318:  /* 4. */
    #####:  319:  ecma_string_t *this_str_p = ecma_op_to_string (this_argument);
        -:  320:
        -:  321:  /* 5. */
    #####:  322:  if (JERRY_UNLIKELY (this_str_p == NULL))
        -:  323:  {
    #####:  324:    return ECMA_VALUE_ERROR;
        -:  325:  }
        -:  326:
        -:  327:  /* 6. */
    #####:  328:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  329:
    #####:  330:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  331:  {
    #####:  332:    ecma_deref_ecma_string (this_str_p);
    #####:  333:    return ECMA_VALUE_ERROR;
        -:  334:  }
        -:  335:
    #####:  336:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  337:
        -:  338:  /* 7. */
    #####:  339:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  340:  {
        -:  341:
    #####:  342:    ecma_deref_object (regexp_obj_p);
    #####:  343:    ecma_deref_ecma_string (this_str_p);
    #####:  344:    return new_regexp;
        -:  345:  }
    #####:  346:  ecma_value_t this_str_value = ecma_make_string_value (this_str_p);
        -:  347:
        -:  348:  /* 8. */
    #####:  349:  ecma_value_t ret_value = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_MATCH, &this_str_value, 1);
        -:  350:
    #####:  351:  ecma_deref_ecma_string (this_str_p);
    #####:  352:  ecma_free_value (new_regexp);
        -:  353:
    #####:  354:  return ret_value;
        -:  355:
        -:  356:#else /* !JERRY_ESNEXT */
    #####:  357:  if (ecma_object_is_regexp_object (regexp_arg))
        -:  358:  {
    #####:  359:    return ecma_regexp_match_helper (regexp_arg, this_argument);
        -:  360:  }
        -:  361:
    #####:  362:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  363:
    #####:  364:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  365:  {
        -:  366:    return ECMA_VALUE_ERROR;
        -:  367:  }
        -:  368:
    #####:  369:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  370:
    #####:  371:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  372:  {
    #####:  373:    ecma_deref_object (regexp_obj_p);
    #####:  374:    return new_regexp;
        -:  375:  }
        -:  376:
    #####:  377:  ecma_value_t result = ecma_regexp_match_helper (new_regexp, this_argument);
        -:  378:
    #####:  379:  ecma_free_value (new_regexp);
        -:  380:
    #####:  381:  return result;
        -:  382:#endif /* JERRY_ESNEXT */
        -:  383:} /* ecma_builtin_string_prototype_object_match */
        -:  384:
        -:  385:#if JERRY_ESNEXT
        -:  386:/**
        -:  387: * The String.prototype object's 'matchAll' routine
        -:  388: *
        -:  389: * See also:
        -:  390: *          ECMA-262 v11, 21.1.3.12
        -:  391: *
        -:  392: * @return ecma value
        -:  393: *         Returned value must be freed with ecma_free_value.
        -:  394: */
        -:  395:static ecma_value_t
    #####:  396:ecma_builtin_string_prototype_object_match_all (ecma_value_t this_argument, /**< this argument */
        -:  397:                                                ecma_value_t regexp_arg) /**< routine's argument */
        -:  398:{
        -:  399:  /* 2. */
    #####:  400:  if (!ecma_is_value_null (regexp_arg) && !ecma_is_value_undefined (regexp_arg))
        -:  401:  {
        -:  402:    /* 2.a */
    #####:  403:    ecma_value_t is_regexp = ecma_op_is_regexp (regexp_arg);
        -:  404:
    #####:  405:    if (ECMA_IS_VALUE_ERROR (is_regexp))
        -:  406:    {
    #####:  407:      return is_regexp;
        -:  408:    }
        -:  409:
        -:  410:    /* 2.b */
    #####:  411:    if (ecma_is_value_true (is_regexp))
        -:  412:    {
        -:  413:      /* 2.b.i */
    #####:  414:      ecma_object_t *regexp_obj_p = ecma_get_object_from_value (regexp_arg);
    #####:  415:      ecma_value_t get_flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  416:
    #####:  417:      if (ECMA_IS_VALUE_ERROR (get_flags))
        -:  418:      {
    #####:  419:        return get_flags;
        -:  420:      }
        -:  421:
        -:  422:      /* 2.b.ii */
    #####:  423:      if (!ecma_op_require_object_coercible (get_flags))
        -:  424:      {
    #####:  425:        ecma_free_value (get_flags);
    #####:  426:        return ECMA_VALUE_ERROR;
        -:  427:      }
        -:  428:
        -:  429:      /* 2.b.iii */
    #####:  430:      ecma_string_t *flags = ecma_op_to_string (get_flags);
        -:  431:
    #####:  432:      ecma_free_value (get_flags);
        -:  433:
    #####:  434:      if (JERRY_UNLIKELY (flags == NULL))
        -:  435:      {
    #####:  436:        return ECMA_VALUE_ERROR;
        -:  437:      }
        -:  438:
    #####:  439:      uint16_t parsed_flag;
    #####:  440:      ecma_value_t flag_parse = ecma_regexp_parse_flags (flags, &parsed_flag);
        -:  441:
    #####:  442:      ecma_deref_ecma_string (flags);
        -:  443:
    #####:  444:      if (ECMA_IS_VALUE_ERROR (flag_parse))
        -:  445:      {
    #####:  446:        return flag_parse;
        -:  447:      }
        -:  448:
    #####:  449:      if (!(parsed_flag & RE_FLAG_GLOBAL))
        -:  450:      {
    #####:  451:        return ecma_raise_type_error (ECMA_ERR_MSG ("RegExp argument should have global flag"));
        -:  452:      }
        -:  453:    }
        -:  454:
        -:  455:    /* 2.c */
    #####:  456:    ecma_value_t matcher = ecma_op_get_method_by_symbol_id (regexp_arg, LIT_GLOBAL_SYMBOL_MATCH_ALL);
        -:  457:
    #####:  458:    if (ECMA_IS_VALUE_ERROR (matcher))
        -:  459:    {
    #####:  460:      return matcher;
        -:  461:    }
        -:  462:
        -:  463:    /* 2.d */
    #####:  464:    if (!ecma_is_value_undefined (matcher))
        -:  465:    {
        -:  466:      /* 2.d.i */
    #####:  467:      ecma_object_t *matcher_method = ecma_get_object_from_value (matcher);
    #####:  468:      ecma_value_t result = ecma_op_function_call (matcher_method, regexp_arg, &this_argument, 1);
    #####:  469:      ecma_deref_object (matcher_method);
    #####:  470:      return result;
        -:  471:    }
        -:  472:  }
        -:  473:
        -:  474:  /* 3. */
    #####:  475:  ecma_string_t *str_p = ecma_op_to_string (this_argument);
        -:  476:
    #####:  477:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  478:  {
    #####:  479:    return ECMA_VALUE_ERROR;
        -:  480:  }
        -:  481:
        -:  482:  /* 4. */
    #####:  483:  ecma_object_t *new_regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  484:
    #####:  485:  if (JERRY_UNLIKELY (new_regexp_obj_p == NULL))
        -:  486:  {
    #####:  487:    ecma_deref_ecma_string (str_p);
    #####:  488:    return ECMA_VALUE_ERROR;
        -:  489:  }
        -:  490:
    #####:  491:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (new_regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  492:
    #####:  493:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  494:  {
    #####:  495:    ecma_deref_ecma_string (str_p);
    #####:  496:    ecma_deref_object (new_regexp_obj_p);
    #####:  497:    return new_regexp;
        -:  498:  }
        -:  499:
        -:  500:  /* 5. */
    #####:  501:  ecma_value_t string_arg = ecma_make_string_value (str_p);
    #####:  502:  ecma_value_t ret_value = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_MATCH_ALL, &string_arg, 1);
        -:  503:
    #####:  504:  ecma_deref_ecma_string (str_p);
    #####:  505:  ecma_free_value (new_regexp);
        -:  506:
    #####:  507:  return ret_value;
        -:  508:} /* ecma_builtin_string_prototype_object_match_all */
        -:  509:#endif /* JERRY_ESNEXT */
        -:  510:
        -:  511:/**
        -:  512: * The String.prototype object's 'replace' and 'replaceAll' routine
        -:  513: *
        -:  514: * See also:
        -:  515: *          ECMA-262 v5, 15.5.4.11 (replace ES5)
        -:  516: *          ECMA-262 v6, 21.1.3.14 (replace ES6)
        -:  517: *          ECMA-262 v12, 21.1.3.18 (replaceAll)
        -:  518: *
        -:  519: * @return ecma value
        -:  520: *         Returned value must be freed with ecma_free_value.
        -:  521: */
        -:  522:static ecma_value_t
    #####:  523:ecma_builtin_string_prototype_object_replace_helper (ecma_value_t this_value, /**< this argument */
        -:  524:                                                     ecma_value_t search_value, /**< routine's first argument */
        -:  525:                                                     ecma_value_t replace_value, /**< routine's second argument */
        -:  526:                                                     bool replace_all)
        -:  527:{
        -:  528:#if JERRY_ESNEXT
    #####:  529:  if (!(ecma_is_value_undefined (search_value) || ecma_is_value_null (search_value)))
        -:  530:  {
    #####:  531:    if (replace_all)
        -:  532:    {
    #####:  533:      ecma_value_t is_regexp = ecma_op_is_regexp (search_value);
        -:  534:
    #####:  535:      if (ECMA_IS_VALUE_ERROR (is_regexp))
        -:  536:      {
    #####:  537:        return is_regexp;
        -:  538:      }
        -:  539:
    #####:  540:      if (ecma_is_value_true (is_regexp))
        -:  541:      {
    #####:  542:        ecma_object_t *regexp_obj_p = ecma_get_object_from_value (search_value);
    #####:  543:        ecma_value_t get_flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  544:
    #####:  545:        if (ECMA_IS_VALUE_ERROR (get_flags))
        -:  546:        {
    #####:  547:          return get_flags;
        -:  548:        }
        -:  549:
    #####:  550:        if (!ecma_op_require_object_coercible (get_flags))
        -:  551:        {
    #####:  552:          ecma_free_value (get_flags);
    #####:  553:          return ECMA_VALUE_ERROR;
        -:  554:        }
        -:  555:
    #####:  556:        ecma_string_t *flags = ecma_op_to_string (get_flags);
        -:  557:
    #####:  558:        ecma_free_value (get_flags);
        -:  559:
    #####:  560:        if (JERRY_UNLIKELY (flags == NULL))
        -:  561:        {
    #####:  562:          return ECMA_VALUE_ERROR;
        -:  563:        }
        -:  564:
    #####:  565:        bool have_global_flag = lit_find_char_in_string (flags, LIT_CHAR_LOWERCASE_G);
        -:  566:
    #####:  567:        ecma_deref_ecma_string (flags);
        -:  568:
    #####:  569:        if (!have_global_flag)
        -:  570:        {
    #####:  571:          return ecma_raise_type_error (ECMA_ERR_MSG ("RegExp argument should have global flag"));
        -:  572:        }
        -:  573:      }
        -:  574:    }
        -:  575:
    #####:  576:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (search_value));
    #####:  577:    ecma_value_t replace_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_REPLACE);
    #####:  578:    ecma_deref_object (obj_p);
        -:  579:
    #####:  580:    if (ECMA_IS_VALUE_ERROR (replace_symbol))
        -:  581:    {
    #####:  582:      return replace_symbol;
        -:  583:    }
        -:  584:
    #####:  585:    if (!ecma_is_value_undefined (replace_symbol) && !ecma_is_value_null (replace_symbol))
        -:  586:    {
    #####:  587:      if (!ecma_op_is_callable (replace_symbol))
        -:  588:      {
    #####:  589:        ecma_free_value (replace_symbol);
    #####:  590:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@replace is not callable"));
        -:  591:      }
        -:  592:
    #####:  593:      ecma_object_t *replace_method = ecma_get_object_from_value (replace_symbol);
        -:  594:
    #####:  595:      ecma_value_t arguments[] = { this_value, replace_value };
    #####:  596:      ecma_value_t replace_result = ecma_op_function_call (replace_method, search_value, arguments, 2);
        -:  597:
    #####:  598:      ecma_deref_object (replace_method);
    #####:  599:      return replace_result;
        -:  600:    }
        -:  601:  }
        -:  602:#else /* !JERRY_ESNEXT */
    #####:  603:  if (ecma_object_is_regexp_object (search_value))
        -:  604:  {
    #####:  605:    return ecma_regexp_replace_helper (search_value, this_value, replace_value);
        -:  606:  }
        -:  607:#endif /* JERRY_ESNEXT */
        -:  608:
    #####:  609:  ecma_string_t *input_str_p = ecma_op_to_string (this_value);
        -:  610:
    #####:  611:  if (input_str_p == NULL)
        -:  612:  {
    #####:  613:    return ECMA_VALUE_ERROR;
        -:  614:  }
        -:  615:
    #####:  616:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  617:
    #####:  618:  ecma_string_t *search_str_p = ecma_op_to_string (search_value);
    #####:  619:  if (search_str_p == NULL)
        -:  620:  {
    #####:  621:    ecma_deref_ecma_string (input_str_p);
    #####:  622:    return result;
        -:  623:  }
        -:  624:
    #####:  625:  ecma_replace_context_t replace_ctx;
    #####:  626:  replace_ctx.capture_count = 0;
    #####:  627:  replace_ctx.u.captures_p = NULL;
        -:  628:
    #####:  629:  replace_ctx.replace_str_p = NULL;
    #####:  630:  if (!ecma_op_is_callable (replace_value))
        -:  631:  {
    #####:  632:    replace_ctx.replace_str_p = ecma_op_to_string (replace_value);
    #####:  633:    if (replace_ctx.replace_str_p == NULL)
        -:  634:    {
    #####:  635:      goto cleanup_search;
        -:  636:    }
        -:  637:  }
        -:  638:
    #####:  639:  uint8_t input_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  640:  replace_ctx.string_p = ecma_string_get_chars (input_str_p,
        -:  641:                                                &(replace_ctx.string_size),
        -:  642:                                                NULL,
        -:  643:                                                NULL,
        -:  644:                                                &input_flags);
        -:  645:
    #####:  646:  lit_utf8_size_t search_size;
    #####:  647:  lit_utf8_size_t search_length;
    #####:  648:  uint8_t search_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  649:  const lit_utf8_byte_t *search_buf_p = ecma_string_get_chars (search_str_p,
        -:  650:                                                               &search_size,
        -:  651:                                                               &search_length,
        -:  652:                                                               NULL,
        -:  653:                                                               &search_flags);
        -:  654:
    #####:  655:  ecma_string_t *result_string_p = NULL;
        -:  656:
    #####:  657:  if (replace_ctx.string_size >= search_size)
        -:  658:  {
    #####:  659:    replace_ctx.builder = ecma_stringbuilder_create ();
    #####:  660:    replace_ctx.matched_size = search_size;
    #####:  661:    const lit_utf8_byte_t *const input_end_p = replace_ctx.string_p + replace_ctx.string_size;
    #####:  662:    const lit_utf8_byte_t *const loop_end_p = input_end_p - search_size;
    #####:  663:    const lit_utf8_byte_t *last_match_end_p = replace_ctx.string_p;
    #####:  664:    const lit_utf8_byte_t *curr_p = replace_ctx.string_p;
        -:  665:
    #####:  666:    lit_utf8_size_t pos = 0;
    #####:  667:    while (curr_p <= loop_end_p)
        -:  668:    {
    #####:  669:      if (!memcmp (curr_p, search_buf_p, search_size))
        -:  670:      {
    #####:  671:        const lit_utf8_size_t prefix_size = (lit_utf8_size_t) (curr_p - last_match_end_p);
    #####:  672:        ecma_stringbuilder_append_raw (&replace_ctx.builder, last_match_end_p, prefix_size);
        -:  673:
    #####:  674:        last_match_end_p = curr_p + search_size;
        -:  675:
    #####:  676:        if (replace_ctx.replace_str_p == NULL)
        -:  677:        {
    #####:  678:          ecma_object_t *function_p = ecma_get_object_from_value (replace_value);
        -:  679:
    #####:  680:          ecma_value_t args[] =
        -:  681:          {
    #####:  682:            ecma_make_string_value (search_str_p),
    #####:  683:            ecma_make_uint32_value (pos),
    #####:  684:            ecma_make_string_value (input_str_p)
        -:  685:          };
        -:  686:
    #####:  687:          result = ecma_op_function_call (function_p,
        -:  688:                                          ECMA_VALUE_UNDEFINED,
        -:  689:                                          args,
        -:  690:                                          3);
        -:  691:
    #####:  692:          if (ECMA_IS_VALUE_ERROR (result))
        -:  693:          {
    #####:  694:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  695:            goto cleanup_replace;
        -:  696:          }
        -:  697:
    #####:  698:          ecma_string_t *const result_str_p = ecma_op_to_string (result);
    #####:  699:          ecma_free_value (result);
        -:  700:
    #####:  701:          if (result_str_p == NULL)
        -:  702:          {
    #####:  703:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  704:            result = ECMA_VALUE_ERROR;
    #####:  705:            goto cleanup_replace;
        -:  706:          }
        -:  707:
    #####:  708:          ecma_stringbuilder_append (&replace_ctx.builder, result_str_p);
    #####:  709:          ecma_deref_ecma_string (result_str_p);
        -:  710:        }
        -:  711:        else
        -:  712:        {
    #####:  713:          replace_ctx.matched_p = curr_p;
    #####:  714:          replace_ctx.match_byte_pos = (lit_utf8_size_t) (curr_p - replace_ctx.string_p);
        -:  715:
    #####:  716:          ecma_builtin_replace_substitute (&replace_ctx);
        -:  717:        }
        -:  718:
    #####:  719:        if (!replace_all
    #####:  720:            || last_match_end_p == input_end_p)
        -:  721:        {
        -:  722:          break;
        -:  723:        }
        -:  724:
    #####:  725:        if (search_size != 0)
        -:  726:        {
    #####:  727:          curr_p = last_match_end_p;
    #####:  728:          pos += search_length;
    #####:  729:          continue;
        -:  730:        }
        -:  731:      }
        -:  732:
    #####:  733:      pos++;
    #####:  734:      lit_utf8_incr (&curr_p);
        -:  735:    }
        -:  736:
    #####:  737:    ecma_stringbuilder_append_raw (&replace_ctx.builder,
        -:  738:                                    last_match_end_p,
    #####:  739:                                    (lit_utf8_size_t) (input_end_p - last_match_end_p));
    #####:  740:    result_string_p = ecma_stringbuilder_finalize (&replace_ctx.builder);
        -:  741:
        -:  742:  }
        -:  743:
    #####:  744:  if (result_string_p == NULL)
        -:  745:  {
    #####:  746:    ecma_ref_ecma_string (input_str_p);
    #####:  747:    result_string_p = input_str_p;
        -:  748:  }
        -:  749:
    #####:  750:  result = ecma_make_string_value (result_string_p);
        -:  751:
    #####:  752:cleanup_replace:
    #####:  753:  if (input_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  754:  {
    #####:  755:    jmem_heap_free_block ((void *) replace_ctx.string_p, replace_ctx.string_size);
        -:  756:  }
        -:  757:
    #####:  758:  if (search_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  759:  {
    #####:  760:    jmem_heap_free_block ((void *) search_buf_p, search_size);
        -:  761:  }
        -:  762:
    #####:  763:  if (replace_ctx.replace_str_p != NULL)
        -:  764:  {
    #####:  765:    ecma_deref_ecma_string (replace_ctx.replace_str_p);
        -:  766:  }
        -:  767:
    #####:  768:cleanup_search:
    #####:  769:  ecma_deref_ecma_string (search_str_p);
    #####:  770:  ecma_deref_ecma_string (input_str_p);
        -:  771:
    #####:  772:  return result;
        -:  773:} /* ecma_builtin_string_prototype_object_replace_helper */
        -:  774:
        -:  775:/**
        -:  776: * The String.prototype object's 'search' routine
        -:  777: *
        -:  778: * See also:
        -:  779: *          ECMA-262 v5, 15.5.4.12
        -:  780: *          ECMA-262 v6, 21.1.3.15
        -:  781: *
        -:  782: * @return ecma value
        -:  783: *         Returned value must be freed with ecma_free_value.
        -:  784: */
        -:  785:static ecma_value_t
    #####:  786:ecma_builtin_string_prototype_object_search (ecma_value_t this_value, /**< this argument */
        -:  787:                                             ecma_value_t regexp_value) /**< routine's argument */
        -:  788:{
        -:  789:#if JERRY_ESNEXT
    #####:  790:  if (!(ecma_is_value_undefined (regexp_value) || ecma_is_value_null (regexp_value)))
        -:  791:  {
    #####:  792:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (regexp_value));
    #####:  793:    ecma_value_t search_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SEARCH);
    #####:  794:    ecma_deref_object (obj_p);
        -:  795:
    #####:  796:    if (ECMA_IS_VALUE_ERROR (search_symbol))
        -:  797:    {
    #####:  798:      return search_symbol;
        -:  799:    }
        -:  800:
    #####:  801:    if (!ecma_is_value_undefined (search_symbol) && !ecma_is_value_null (search_symbol))
        -:  802:    {
    #####:  803:      if (!ecma_op_is_callable (search_symbol))
        -:  804:      {
    #####:  805:        ecma_free_value (search_symbol);
    #####:  806:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@search is not callable"));
        -:  807:      }
        -:  808:
    #####:  809:      ecma_object_t *search_method = ecma_get_object_from_value (search_symbol);
    #####:  810:      ecma_value_t search_result = ecma_op_function_call (search_method, regexp_value, &this_value, 1);
        -:  811:
    #####:  812:      ecma_deref_object (search_method);
    #####:  813:      return search_result;
        -:  814:    }
        -:  815:  }
        -:  816:#else /* !JERRY_ESNEXT */
    #####:  817:  if (ecma_object_is_regexp_object (regexp_value))
        -:  818:  {
    #####:  819:    return ecma_regexp_search_helper (regexp_value, this_value);
        -:  820:  }
        -:  821:#endif /* JERRY_ESNEXT */
        -:  822:
    #####:  823:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  824:
    #####:  825:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####:  826:  if (string_p == NULL)
        -:  827:  {
    #####:  828:    return result;
        -:  829:  }
        -:  830:
    #####:  831:  ecma_string_t *pattern_p = ecma_regexp_read_pattern_str_helper (regexp_value);
    #####:  832:  if (pattern_p == NULL)
        -:  833:  {
    #####:  834:    goto cleanup_string;
        -:  835:  }
        -:  836:
    #####:  837:  ecma_object_t *new_regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  838:
    #####:  839:  if (JERRY_UNLIKELY (new_regexp_obj_p == NULL))
        -:  840:  {
    #####:  841:    ecma_deref_ecma_string (string_p);
    #####:  842:    ecma_deref_ecma_string (pattern_p);
    #####:  843:    return ECMA_VALUE_ERROR;
        -:  844:  }
        -:  845:
    #####:  846:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (new_regexp_obj_p,
        -:  847:                                                                ecma_make_string_value (pattern_p),
        -:  848:                                                                ECMA_VALUE_UNDEFINED);
        -:  849:
    #####:  850:  ecma_deref_ecma_string (pattern_p);
        -:  851:
    #####:  852:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  853:  {
    #####:  854:    ecma_deref_object (new_regexp_obj_p);
    #####:  855:    goto cleanup_string;
        -:  856:  }
        -:  857:
        -:  858:#if !JERRY_ESNEXT
    #####:  859:  result = ecma_regexp_search_helper (new_regexp, ecma_make_string_value (string_p));
    #####:  860:  ecma_deref_object (ecma_get_object_from_value (new_regexp));
        -:  861:#else /* JERRY_ESNEXT */
    #####:  862:  ecma_object_t *regexp_obj_p = ecma_get_object_from_value (new_regexp);
    #####:  863:  ecma_value_t this_str_value = ecma_make_string_value (string_p);
    #####:  864:  result = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_SEARCH, &this_str_value, 1);
    #####:  865:  ecma_deref_object (regexp_obj_p);
        -:  866:#endif /* !JERRY_ESNEXT */
        -:  867:
    #####:  868:cleanup_string:
    #####:  869:  ecma_deref_ecma_string (string_p);
    #####:  870:  return result;
        -:  871:} /* ecma_builtin_string_prototype_object_search */
        -:  872:
        -:  873:#endif /* JERRY_BUILTIN_REGEXP */
        -:  874:
        -:  875:/**
        -:  876: * The String.prototype object's 'slice' routine
        -:  877: *
        -:  878: * See also:
        -:  879: *          ECMA-262 v5, 15.5.4.13
        -:  880: *
        -:  881: * @return ecma value
        -:  882: *         Returned value must be freed with ecma_free_value.
        -:  883: */
        -:  884:static ecma_value_t
    #####:  885:ecma_builtin_string_prototype_object_slice (ecma_string_t *get_string_val, /**< this argument */
        -:  886:                                            ecma_value_t arg1, /**< routine's first argument */
        -:  887:                                            ecma_value_t arg2) /**< routine's second argument */
        -:  888:{
    #####:  889:  const lit_utf8_size_t len = ecma_string_get_length (get_string_val);
        -:  890:
        -:  891:  /* 4. 6. */
    #####:  892:  lit_utf8_size_t start = 0, end = len;
        -:  893:
    #####:  894:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (arg1,
        -:  895:                                                                       len,
        -:  896:                                                                       &start)))
        -:  897:  {
    #####:  898:    return ECMA_VALUE_ERROR;
        -:  899:  }
        -:  900:
        -:  901:  /* 5. 7. */
    #####:  902:  if (ecma_is_value_undefined (arg2))
        -:  903:  {
    #####:  904:    end = len;
        -:  905:  }
        -:  906:  else
        -:  907:  {
    #####:  908:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (arg2,
        -:  909:                                                                         len,
        -:  910:                                                                         &end)))
        -:  911:    {
    #####:  912:      return ECMA_VALUE_ERROR;
        -:  913:    }
        -:  914:  }
        -:  915:
    #####:  916:  JERRY_ASSERT (start <= len && end <= len);
        -:  917:
        -:  918:  /* 8-9. */
    #####:  919:  ecma_string_t *new_str_p = ecma_string_substr (get_string_val, start, end);
        -:  920:
    #####:  921:  return ecma_make_string_value (new_str_p);
        -:  922:} /* ecma_builtin_string_prototype_object_slice */
        -:  923:
        -:  924:/**
        -:  925: * The String.prototype object's 'at' routine
        -:  926: *
        -:  927: * See also:
        -:  928: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -:  929: *          from: https://tc39.es/proposal-relative-indexing-method
        -:  930: *
        -:  931: * @return ecma value
        -:  932: *         Returned value must be freed with ecma_free_value.
        -:  933: */
        -:  934:static ecma_value_t
    #####:  935:ecma_builtin_string_prototype_object_at (ecma_string_t *string_val, /**< this argument */
        -:  936:                                         const ecma_value_t index) /**< index argument */
        -:  937:{
    #####:  938:  ecma_length_t len = (ecma_length_t) ecma_string_get_length (string_val);
    #####:  939:  ecma_length_t res_index;
    #####:  940:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -:  941:
    #####:  942:  if (return_value != ECMA_VALUE_EMPTY)
        -:  943:  {
    #####:  944:    return return_value;
        -:  945:  }
        -:  946:
    #####:  947:  ecma_char_t character = ecma_string_get_char_at_pos (string_val, (lit_utf8_size_t) res_index);
        -:  948:
    #####:  949:  return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (character));
        -:  950:} /* ecma_builtin_string_prototype_object_at */
        -:  951:
        -:  952:/**
        -:  953: * The String.prototype object's 'split' routine
        -:  954: *
        -:  955: * See also:
        -:  956: *          ECMA-262 v5, 15.5.4.14
        -:  957: *
        -:  958: * @return ecma value
        -:  959: *         Returned value must be freed with ecma_free_value.
        -:  960: */
        -:  961:static ecma_value_t
    #####:  962:ecma_builtin_string_prototype_object_split (ecma_value_t this_value, /**< this argument */
        -:  963:                                            ecma_value_t separator_value, /**< separator */
        -:  964:                                            ecma_value_t limit_value) /**< limit */
        -:  965:{
        -:  966:#if JERRY_ESNEXT
    #####:  967:  if (!(ecma_is_value_undefined (separator_value) || ecma_is_value_null (separator_value)))
        -:  968:  {
    #####:  969:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (separator_value));
    #####:  970:    ecma_value_t split_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SPLIT);
    #####:  971:    ecma_deref_object (obj_p);
        -:  972:
    #####:  973:    if (ECMA_IS_VALUE_ERROR (split_symbol))
        -:  974:    {
    #####:  975:      return split_symbol;
        -:  976:    }
        -:  977:
    #####:  978:    if (!ecma_is_value_undefined (split_symbol) && !ecma_is_value_null (split_symbol))
        -:  979:    {
    #####:  980:      if (!ecma_op_is_callable (split_symbol))
        -:  981:      {
    #####:  982:        ecma_free_value (split_symbol);
    #####:  983:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@split is not callable"));
        -:  984:      }
        -:  985:
    #####:  986:      ecma_object_t *split_method_p = ecma_get_object_from_value (split_symbol);
        -:  987:
    #####:  988:      ecma_value_t arguments[] = { this_value, limit_value };
    #####:  989:      ecma_value_t split_result = ecma_op_function_call (split_method_p, separator_value, arguments, 2);
        -:  990:
    #####:  991:      ecma_deref_object (split_method_p);
    #####:  992:      return split_result;
        -:  993:    }
        -:  994:  }
        -:  995:#else /* !JERRY_ESNEXT */
    #####:  996:  if (ecma_object_is_regexp_object (separator_value))
        -:  997:  {
    #####:  998:    return ecma_regexp_split_helper (separator_value, this_value, limit_value);
        -:  999:  }
        -: 1000:#endif /* JERRY_ESNEXT */
        -: 1001:
    #####: 1002:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 1003:
        -: 1004:  /* 4. */
    #####: 1005:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####: 1006:  if (string_p == NULL)
        -: 1007:  {
    #####: 1008:    return result;
        -: 1009:  }
        -: 1010:
        -: 1011:  /* 8. */
    #####: 1012:  uint32_t limit = UINT32_MAX - 1;
        -: 1013:
    #####: 1014:  if (!ecma_is_value_undefined (limit_value))
        -: 1015:  {
        -: 1016:    /* ECMA-262 v11, 21.1.3.20 6 */
    #####: 1017:    ecma_number_t num;
    #####: 1018:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (limit_value, &num)))
        -: 1019:    {
    #####: 1020:      goto cleanup_string;
        -: 1021:    }
    #####: 1022:    limit = ecma_number_to_uint32 (num);
        -: 1023:  }
        -: 1024:
        -: 1025:  /* 12. */
    #####: 1026:  ecma_string_t *separator_p = ecma_op_to_string (separator_value);
    #####: 1027:  if (separator_p == NULL)
        -: 1028:  {
    #####: 1029:    goto cleanup_string;
        -: 1030:  }
        -: 1031:
        -: 1032:  /* 6. */
    #####: 1033:  ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 1034:  result = ecma_make_object_value (array_p);
        -: 1035:
        -: 1036:  /* 14. */
    #####: 1037:  if (limit == 0)
        -: 1038:  {
    #####: 1039:    goto cleanup_separator;
        -: 1040:  }
        -: 1041:
        -: 1042:  /* 6. */
    #####: 1043:  lit_utf8_size_t array_length = 0;
        -: 1044:
        -: 1045:  /* 15. */
    #####: 1046:  if (ecma_is_value_undefined (separator_value))
        -: 1047:  {
    #####: 1048:    ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1049:                                                                     array_length,
        -: 1050:                                                                     ecma_make_string_value (string_p),
        -: 1051:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1052:    JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1053:    goto cleanup_separator;
        -: 1054:  }
        -: 1055:
        -: 1056:  /* 16. */
    #####: 1057:  if (ecma_string_is_empty (string_p))
        -: 1058:  {
    #####: 1059:    if (!ecma_string_is_empty (separator_p))
        -: 1060:    {
    #####: 1061:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1062:                                                                       array_length,
        -: 1063:                                                                       ecma_make_string_value (string_p),
        -: 1064:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1065:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
        -: 1066:    }
        -: 1067:
    #####: 1068:    goto cleanup_separator;
        -: 1069:  }
        -: 1070:
    #####: 1071:  lit_utf8_size_t string_size;
    #####: 1072:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1073:  const lit_utf8_byte_t *string_buffer_p = ecma_string_get_chars (string_p,
        -: 1074:                                                                  &string_size,
        -: 1075:                                                                  NULL,
        -: 1076:                                                                  NULL,
        -: 1077:                                                                  &string_flags);
    #####: 1078:  lit_utf8_size_t separator_size;
    #####: 1079:  uint8_t separator_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1080:  const lit_utf8_byte_t *separator_buffer_p = ecma_string_get_chars (separator_p,
        -: 1081:                                                                     &separator_size,
        -: 1082:                                                                     NULL,
        -: 1083:                                                                     NULL,
        -: 1084:                                                                     &separator_flags);
        -: 1085:
    #####: 1086:  const lit_utf8_byte_t *const string_end_p = string_buffer_p + string_size;
    #####: 1087:  const lit_utf8_byte_t *const compare_end_p = JERRY_MIN (string_end_p - separator_size + 1,
        -: 1088:                                                          string_end_p);
    #####: 1089:  const lit_utf8_byte_t *current_p = string_buffer_p;
    #####: 1090:  const lit_utf8_byte_t *last_str_begin_p = string_buffer_p;
        -: 1091:
    #####: 1092:  while (current_p < compare_end_p)
        -: 1093:  {
    #####: 1094:    if (!memcmp (current_p, separator_buffer_p, separator_size)
    #####: 1095:        && (last_str_begin_p != current_p + separator_size))
        -: 1096:    {
    #####: 1097:      ecma_string_t *substr_p = ecma_new_ecma_string_from_utf8 (last_str_begin_p,
    #####: 1098:                                                                (lit_utf8_size_t) (current_p - last_str_begin_p));
    #####: 1099:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 1100:                                                                       array_length++,
        -: 1101:                                                                       ecma_make_string_value (substr_p),
        -: 1102:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1103:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1104:      ecma_deref_ecma_string (substr_p);
        -: 1105:
    #####: 1106:      if (array_length >= limit)
        -: 1107:      {
    #####: 1108:        goto cleanup_buffers;
        -: 1109:      }
        -: 1110:
    #####: 1111:      current_p += separator_size;
    #####: 1112:      last_str_begin_p = current_p;
    #####: 1113:      continue;
        -: 1114:    }
        -: 1115:
    #####: 1116:    lit_utf8_incr (&current_p);
        -: 1117:  }
        -: 1118:
    #####: 1119:  ecma_string_t *end_substr_p = ecma_new_ecma_string_from_utf8 (last_str_begin_p,
    #####: 1120:                                                                (lit_utf8_size_t) (string_end_p - last_str_begin_p));
    #####: 1121:  ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1122:                                                                   array_length,
        -: 1123:                                                                   ecma_make_string_value (end_substr_p),
        -: 1124:                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1125:  JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1126:  ecma_deref_ecma_string (end_substr_p);
        -: 1127:
    #####: 1128:cleanup_buffers:
    #####: 1129:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1130:  {
    #####: 1131:    jmem_heap_free_block ((void *) string_buffer_p, string_size);
        -: 1132:  }
        -: 1133:
    #####: 1134:  if (separator_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1135:  {
    #####: 1136:    jmem_heap_free_block ((void *) separator_buffer_p, separator_size);
        -: 1137:  }
        -: 1138:
    #####: 1139:cleanup_separator:
    #####: 1140:  ecma_deref_ecma_string (separator_p);
    #####: 1141:cleanup_string:
    #####: 1142:  ecma_deref_ecma_string (string_p);
    #####: 1143:  return result;
        -: 1144:} /* ecma_builtin_string_prototype_object_split */
        -: 1145:
        -: 1146:/**
        -: 1147: * The String.prototype object's 'substring' routine
        -: 1148: *
        -: 1149: * See also:
        -: 1150: *          ECMA-262 v5, 15.5.4.15
        -: 1151: *
        -: 1152: * @return ecma value
        -: 1153: *         Returned value must be freed with ecma_free_value.
        -: 1154: */
        -: 1155:static ecma_value_t
    #####: 1156:ecma_builtin_string_prototype_object_substring (ecma_string_t *original_string_p, /**< this argument */
        -: 1157:                                                ecma_value_t arg1, /**< routine's first argument */
        -: 1158:                                                ecma_value_t arg2) /**< routine's second argument */
        -: 1159:{
        -: 1160:  /* 3 */
    #####: 1161:  const lit_utf8_size_t len = ecma_string_get_length (original_string_p);
    #####: 1162:  lit_utf8_size_t start = 0, end = len;
        -: 1163:
        -: 1164:  /* 4 */
    #####: 1165:  ecma_number_t start_num;
        -: 1166:
    #####: 1167:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg1, &start_num)))
        -: 1168:  {
    #####: 1169:    return ECMA_VALUE_ERROR;
        -: 1170:  }
        -: 1171:
        -: 1172:  /* 6 */
    #####: 1173:  start = (uint32_t) JERRY_MIN (JERRY_MAX (start_num, 0), len);
        -: 1174:
        -: 1175:  /* 5 */
    #####: 1176:  if (ecma_is_value_undefined (arg2))
        -: 1177:  {
    #####: 1178:    end = len;
        -: 1179:  }
        -: 1180:  else
        -: 1181:  {
        -: 1182:    /* 5 part 2 */
    #####: 1183:    ecma_number_t end_num;
        -: 1184:
    #####: 1185:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg2, &end_num)))
        -: 1186:    {
    #####: 1187:      return ECMA_VALUE_ERROR;
        -: 1188:    }
        -: 1189:    /* 7 */
    #####: 1190:    end = (uint32_t) JERRY_MIN (JERRY_MAX (end_num, 0), len);
        -: 1191:  }
        -: 1192:
    #####: 1193:  JERRY_ASSERT (start <= len && end <= len);
        -: 1194:
        -: 1195:  /* 8 */
    #####: 1196:  uint32_t from = start < end ? start : end;
        -: 1197:
        -: 1198:  /* 9 */
    #####: 1199:  uint32_t to = start > end ? start : end;
        -: 1200:
        -: 1201:  /* 10 */
    #####: 1202:  ecma_string_t *new_str_p = ecma_string_substr (original_string_p, from, to);
    #####: 1203:  return ecma_make_string_value (new_str_p);
        -: 1204:} /* ecma_builtin_string_prototype_object_substring */
        -: 1205:
        -: 1206:/**
        -: 1207: * The common implementation of the String.prototype object's
        -: 1208: * 'toLowerCase', 'toLocaleLowerCase', 'toUpperCase', 'toLocalUpperCase' routines
        -: 1209: *
        -: 1210: * See also:
        -: 1211: *          ECMA-262 v5, 15.5.4.16
        -: 1212: *          ECMA-262 v5, 15.5.4.17
        -: 1213: *          ECMA-262 v5, 15.5.4.18
        -: 1214: *          ECMA-262 v5, 15.5.4.19
        -: 1215: *
        -: 1216: * Helper function to convert a string to upper or lower case.
        -: 1217: *
        -: 1218: * @return ecma value
        -: 1219: *         Returned value must be freed with ecma_free_value.
        -: 1220: */
        -: 1221:static ecma_value_t
    #####: 1222:ecma_builtin_string_prototype_object_conversion_helper (ecma_string_t *input_string_p, /**< this argument */
        -: 1223:                                                        bool lower_case) /**< convert to lower (true)
        -: 1224:                                                                          *   or upper (false) case */
        -: 1225:{
    #####: 1226:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -: 1227:
    #####: 1228:  ECMA_STRING_TO_UTF8_STRING (input_string_p, input_start_p, input_start_size);
        -: 1229:
    #####: 1230:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####: 1231:  const lit_utf8_byte_t *input_str_end_p = input_start_p + input_start_size;
        -: 1232:
    #####: 1233:  while (input_curr_p < input_str_end_p)
        -: 1234:  {
    #####: 1235:    lit_code_point_t cp = lit_cesu8_read_next (&input_curr_p);
        -: 1236:
        -: 1237:#if JERRY_ESNEXT
    #####: 1238:    if (lit_is_code_point_utf16_high_surrogate (cp)
    #####: 1239:        && input_curr_p < input_str_end_p)
        -: 1240:    {
    #####: 1241:      const ecma_char_t next_ch = lit_cesu8_peek_next (input_curr_p);
    #####: 1242:      if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -: 1243:      {
    #####: 1244:        cp = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) cp, next_ch);
    #####: 1245:        input_curr_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -: 1246:      }
        -: 1247:    }
        -: 1248:#endif /* JERRY_ESNEXT */
        -: 1249:
    #####: 1250:    if (lower_case)
        -: 1251:    {
    #####: 1252:      lit_char_to_lower_case (cp, &builder);
        -: 1253:    }
        -: 1254:    else
        -: 1255:    {
    #####: 1256:      lit_char_to_upper_case (cp, &builder);
        -: 1257:    }
        -: 1258:  }
        -: 1259:
    #####: 1260:  ECMA_FINALIZE_UTF8_STRING (input_start_p, input_start_size);
        -: 1261:
    #####: 1262:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1263:} /* ecma_builtin_string_prototype_object_conversion_helper */
        -: 1264:
        -: 1265:/**
        -: 1266: * The String.prototype object's 'trim' routine
        -: 1267: *
        -: 1268: * See also:
        -: 1269: *          ECMA-262 v5, 15.5.4.20
        -: 1270: *
        -: 1271: * @return ecma value
        -: 1272: *         Returned value must be freed with ecma_free_value.
        -: 1273: */
        -: 1274:static ecma_value_t
    #####: 1275:ecma_builtin_string_prototype_object_trim (ecma_string_t *original_string_p) /**< this argument */
        -: 1276:{
    #####: 1277:  ecma_string_t *trimmed_string_p = ecma_string_trim (original_string_p);
        -: 1278:
    #####: 1279:  return ecma_make_string_value (trimmed_string_p);
        -: 1280:} /* ecma_builtin_string_prototype_object_trim */
        -: 1281:
        -: 1282:#if JERRY_ESNEXT
        -: 1283:
        -: 1284:/**
        -: 1285: * The String.prototype object's 'repeat' routine
        -: 1286: *
        -: 1287: * See also:
        -: 1288: *          ECMA-262 v6, 21.1.3.13
        -: 1289: *
        -: 1290: * @return ecma value
        -: 1291: *         Returned value must be freed with ecma_free_value.
        -: 1292: */
        -: 1293:static ecma_value_t
    #####: 1294:ecma_builtin_string_prototype_object_repeat (ecma_string_t *original_string_p, /**< this argument */
        -: 1295:                                             ecma_value_t repeat) /**< times to repeat */
        -: 1296:{
        -: 1297:  ecma_string_t *ret_string_p;
        -: 1298:
        -: 1299:  /* 4 */
    #####: 1300:  ecma_number_t count_number;
    #####: 1301:  ecma_value_t count_value = ecma_op_to_integer (repeat, &count_number);
        -: 1302:
        -: 1303:  /* 5 */
    #####: 1304:  if (ECMA_IS_VALUE_ERROR (count_value))
        -: 1305:  {
    #####: 1306:    return count_value;
        -: 1307:  }
        -: 1308:
    #####: 1309:  int32_t repeat_count = ecma_number_to_int32 (count_number);
        -: 1310:
    #####: 1311:  bool isNan = ecma_number_is_nan (count_number);
        -: 1312:
        -: 1313:  /* 6, 7 */
    #####: 1314:  if (count_number < 0 || (!isNan && ecma_number_is_infinity (count_number)))
        -: 1315:  {
    #####: 1316:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid count value"));
        -: 1317:  }
        -: 1318:
    #####: 1319:  lit_utf8_size_t size = ecma_string_get_size (original_string_p);
        -: 1320:
    #####: 1321:  if (repeat_count == 0 || size == 0 || isNan)
        -: 1322:  {
    #####: 1323:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1324:  }
        -: 1325:
    #####: 1326:  if ((uint32_t) repeat_count >= (ECMA_STRING_SIZE_LIMIT / size))
        -: 1327:  {
    #####: 1328:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid string length"));
        -: 1329:  }
        -: 1330:
    #####: 1331:  lit_utf8_size_t total_size = size * (lit_utf8_size_t) repeat_count;
        -: 1332:
    #####: 1333:  JMEM_DEFINE_LOCAL_ARRAY (str_buffer, total_size, lit_utf8_byte_t);
        -: 1334:
    #####: 1335:  lit_utf8_byte_t *buffer_ptr = str_buffer;
        -: 1336:
    #####: 1337:  for (int32_t n = 0; n < repeat_count; n++)
        -: 1338:  {
    #####: 1339:    buffer_ptr += ecma_string_copy_to_cesu8_buffer (original_string_p, buffer_ptr,
        -: 1340:                                                    (lit_utf8_size_t) (size));
        -: 1341:  }
        -: 1342:
    #####: 1343:  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));
    #####: 1344:  JMEM_FINALIZE_LOCAL_ARRAY (str_buffer);
        -: 1345:
    #####: 1346:  return ecma_make_string_value (ret_string_p);
        -: 1347:} /* ecma_builtin_string_prototype_object_repeat */
        -: 1348:
        -: 1349:/**
        -: 1350: * The String.prototype object's 'codePointAt' routine
        -: 1351: *
        -: 1352: * See also:
        -: 1353: *          ECMA-262 v6, 21.1.3.3
        -: 1354: *
        -: 1355: * @return lit_code_point_t
        -: 1356: */
        -: 1357:static ecma_value_t
    #####: 1358:ecma_builtin_string_prototype_object_code_point_at (ecma_string_t *this_string_p, /**< this argument */
        -: 1359:                                                    ecma_value_t pos) /**< given position */
        -: 1360:{
    #####: 1361:  ecma_number_t pos_num;
    #####: 1362:  ecma_value_t error = ecma_op_to_integer (pos, &pos_num);
        -: 1363:
    #####: 1364:  if (ECMA_IS_VALUE_ERROR (error))
        -: 1365:  {
    #####: 1366:    return error;
        -: 1367:  }
        -: 1368:
    #####: 1369:  lit_utf8_size_t length = ecma_string_get_length (this_string_p);
        -: 1370:
    #####: 1371:  if (pos_num < 0 || pos_num >= length)
        -: 1372:  {
    #####: 1373:    return ECMA_VALUE_UNDEFINED;
        -: 1374:  }
        -: 1375:
    #####: 1376:  uint32_t index = (uint32_t) pos_num;
        -: 1377:
    #####: 1378:  ecma_char_t first = ecma_string_get_char_at_pos (this_string_p, index);
        -: 1379:
    #####: 1380:  if (first < LIT_UTF16_HIGH_SURROGATE_MIN
    #####: 1381:      || first > LIT_UTF16_HIGH_SURROGATE_MAX
    #####: 1382:      || index + 1 == length)
        -: 1383:  {
    #####: 1384:    return ecma_make_uint32_value (first);
        -: 1385:  }
        -: 1386:
    #####: 1387:  ecma_char_t second = ecma_string_get_char_at_pos (this_string_p, index + 1);
        -: 1388:
    #####: 1389:  if (second < LIT_UTF16_LOW_SURROGATE_MARKER
    #####: 1390:      || second > LIT_UTF16_LOW_SURROGATE_MAX)
        -: 1391:  {
    #####: 1392:    return ecma_make_uint32_value (first);
        -: 1393:  }
        -: 1394:
    #####: 1395:  return ecma_make_uint32_value (lit_convert_surrogate_pair_to_code_point (first, second));
        -: 1396:} /* ecma_builtin_string_prototype_object_code_point_at */
        -: 1397:
        -: 1398:#endif /* JERRY_ESNEXT */
        -: 1399:
        -: 1400:#if JERRY_BUILTIN_ANNEXB
        -: 1401:
        -: 1402:/**
        -: 1403: * The String.prototype object's 'substr' routine
        -: 1404: *
        -: 1405: * See also:
        -: 1406: *          ECMA-262 v5, B.2.3
        -: 1407: *
        -: 1408: * @return ecma value
        -: 1409: *         Returned value must be freed with ecma_free_value.
        -: 1410: */
        -: 1411:static ecma_value_t
    #####: 1412:ecma_builtin_string_prototype_object_substr (ecma_string_t *this_string_p, /**< this argument */
        -: 1413:                                             ecma_value_t start, /**< routine's first argument */
        -: 1414:                                             ecma_value_t length) /**< routine's second argument */
        -: 1415:{
        -: 1416:  /* 2. */
    #####: 1417:  ecma_number_t start_num;
        -: 1418:
    #####: 1419:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (start, &start_num)))
        -: 1420:  {
    #####: 1421:    return ECMA_VALUE_ERROR;
        -: 1422:  }
        -: 1423:
        -: 1424:  /* 3. */
    #####: 1425:  ecma_number_t length_num = ecma_number_make_infinity (false);
        -: 1426:
    #####: 1427:  if (!ecma_is_value_undefined (length))
        -: 1428:  {
    #####: 1429:    ecma_number_t len;
        -: 1430:
    #####: 1431:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (length, &len)))
        -: 1432:    {
    #####: 1433:      return ECMA_VALUE_ERROR;
        -: 1434:    }
        -: 1435:
    #####: 1436:    length_num = ecma_number_is_nan (len) ? 0 : len;
        -: 1437:  }
        -: 1438:
        -: 1439:  /* 4. */
    #####: 1440:  lit_utf8_size_t this_len = ecma_string_get_length (this_string_p);
        -: 1441:
        -: 1442:  /* 5. */
    #####: 1443:  uint32_t from = (uint32_t) ((start_num < 0) ? JERRY_MAX (this_len + start_num, 0) : start_num);
        -: 1444:
    #####: 1445:  if (from > this_len)
        -: 1446:  {
    #####: 1447:    from = this_len;
        -: 1448:  }
        -: 1449:
        -: 1450:  /* 6. */
    #####: 1451:  ecma_number_t to_num = JERRY_MIN (JERRY_MAX (length_num, 0), this_len - from);
        -: 1452:
        -: 1453:  /* 7. */
    #####: 1454:  uint32_t to = from + (uint32_t) to_num;
        -: 1455:
        -: 1456:  /* 8. */
    #####: 1457:  ecma_string_t *new_str_p = ecma_string_substr (this_string_p, from, to);
    #####: 1458:  return ecma_make_string_value (new_str_p);
        -: 1459:} /* ecma_builtin_string_prototype_object_substr */
        -: 1460:
        -: 1461:#endif /* JERRY_BUILTIN_ANNEXB */
        -: 1462:
        -: 1463:#if JERRY_ESNEXT
        -: 1464:
        -: 1465:/**
        -: 1466: * The String.prototype object's @@iterator routine
        -: 1467: *
        -: 1468: * See also:
        -: 1469: *          ECMA-262 v6, 21.1.3.27
        -: 1470: *
        -: 1471: * @return ecma value
        -: 1472: *         Returned value must be freed with ecma_free_value.
        -: 1473: */
        -: 1474:static ecma_value_t
    #####: 1475:ecma_builtin_string_prototype_object_iterator (ecma_value_t to_string) /**< this argument */
        -: 1476:{
    #####: 1477:  return ecma_op_create_iterator_object (ecma_copy_value (to_string),
        -: 1478:                                         ecma_builtin_get (ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE),
        -: 1479:                                         ECMA_OBJECT_CLASS_STRING_ITERATOR,
        -: 1480:                                         ECMA_ITERATOR_VALUES);
        -: 1481:} /* ecma_builtin_string_prototype_object_iterator */
        -: 1482:
        -: 1483:#endif /* JERRY_ESNEXT */
        -: 1484:
        -: 1485:/**
        -: 1486: * Dispatcher of the built-in's routines
        -: 1487: *
        -: 1488: * @return ecma value
        -: 1489: *         Returned value must be freed with ecma_free_value.
        -: 1490: */
        -: 1491:ecma_value_t
    #####: 1492:ecma_builtin_string_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine
        -: 1493:                                                                             *   identifier */
        -: 1494:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -: 1495:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1496:                                                                                        *   passed to routine */
        -: 1497:                                                uint32_t arguments_number) /**< length of arguments' list */
        -: 1498:{
    #####: 1499:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_VALUE_OF)
        -: 1500:  {
    #####: 1501:    return ecma_builtin_string_prototype_object_to_string (this_arg);
        -: 1502:  }
        -: 1503:
    #####: 1504:  if (!ecma_op_require_object_coercible (this_arg))
        -: 1505:  {
    #####: 1506:    return ECMA_VALUE_ERROR;
        -: 1507:  }
        -: 1508:
    #####: 1509:  ecma_value_t arg1 = arguments_list_p[0];
    #####: 1510:  ecma_value_t arg2 = arguments_list_p[1];
        -: 1511:
        -: 1512:#if JERRY_BUILTIN_REGEXP
    #####: 1513:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_MATCH)
        -: 1514:  {
    #####: 1515:    return ecma_builtin_string_prototype_object_match (this_arg, arg1);
        -: 1516:  }
        -: 1517:
        -: 1518:#if JERRY_ESNEXT
    #####: 1519:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_MATCH_ALL)
        -: 1520:  {
    #####: 1521:    return ecma_builtin_string_prototype_object_match_all (this_arg, arg1);
        -: 1522:  }
        -: 1523:#endif /* JERRY_ESNEXT */
        -: 1524:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1525:
    #####: 1526:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_CHAR_CODE_AT)
        -: 1527:  {
    #####: 1528:    return ecma_builtin_string_prototype_char_at_helper (this_arg,
        -: 1529:                                                         arg1,
        -: 1530:                                                         builtin_routine_id == ECMA_STRING_PROTOTYPE_CHAR_CODE_AT);
        -: 1531:  }
        -: 1532:
        -: 1533:#if JERRY_BUILTIN_REGEXP
    #####: 1534:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_REPLACE)
        -: 1535:  {
    #####: 1536:    return ecma_builtin_string_prototype_object_replace_helper (this_arg, arg1, arg2, false);
        -: 1537:  }
        -: 1538:#if JERRY_ESNEXT
    #####: 1539:  else if (builtin_routine_id == ECMA_STRING_PROTOTYPE_REPLACE_ALL)
        -: 1540:  {
    #####: 1541:    return ecma_builtin_string_prototype_object_replace_helper (this_arg, arg1, arg2, true);
        -: 1542:  }
        -: 1543:#endif /* JERRY_ESNEXT  */
        -: 1544:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1545:
    #####: 1546:  ecma_string_t *string_p = ecma_op_to_string (this_arg);
        -: 1547:
    #####: 1548:  if (JERRY_UNLIKELY (string_p == NULL))
        -: 1549:  {
    #####: 1550:    return ECMA_VALUE_ERROR;
        -: 1551:  }
        -: 1552:
    #####: 1553:  ecma_value_t to_string_val = ecma_make_string_value (string_p);
    #####: 1554:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1555:
    #####: 1556:  switch (builtin_routine_id)
        -: 1557:  {
    #####: 1558:    case ECMA_STRING_PROTOTYPE_CONCAT:
        -: 1559:    {
    #####: 1560:      ret_value = ecma_builtin_string_prototype_object_concat (string_p, arguments_list_p, arguments_number);
    #####: 1561:      break;
        -: 1562:    }
    #####: 1563:    case ECMA_STRING_PROTOTYPE_SLICE:
        -: 1564:    {
    #####: 1565:      ret_value = ecma_builtin_string_prototype_object_slice (string_p, arg1, arg2);
    #####: 1566:      break;
        -: 1567:    }
    #####: 1568:    case ECMA_STRING_PROTOTYPE_AT:
        -: 1569:    {
    #####: 1570:      ret_value = ecma_builtin_string_prototype_object_at (string_p, arg1);
    #####: 1571:      break;
        -: 1572:    }
    #####: 1573:    case ECMA_STRING_PROTOTYPE_LAST_INDEX_OF:
        -: 1574:    case ECMA_STRING_PROTOTYPE_INDEX_OF:
        -: 1575:#if JERRY_ESNEXT
        -: 1576:    case ECMA_STRING_PROTOTYPE_STARTS_WITH:
        -: 1577:    case ECMA_STRING_PROTOTYPE_INCLUDES:
        -: 1578:    case ECMA_STRING_PROTOTYPE_ENDS_WITH:
        -: 1579:#endif /* JERRY_ESNEXT */
        -: 1580:    {
        -: 1581:      ecma_string_index_of_mode_t mode;
    #####: 1582:      mode = (ecma_string_index_of_mode_t) (builtin_routine_id - ECMA_STRING_PROTOTYPE_LAST_INDEX_OF);
    #####: 1583:      ret_value = ecma_builtin_helper_string_prototype_object_index_of (string_p, arg1, arg2, mode);
    #####: 1584:      break;
        -: 1585:    }
    #####: 1586:    case ECMA_STRING_PROTOTYPE_LOCALE_COMPARE:
        -: 1587:    {
    #####: 1588:      ret_value = ecma_builtin_string_prototype_object_locale_compare (string_p, arg1);
    #####: 1589:      break;
        -: 1590:    }
        -: 1591:#if JERRY_BUILTIN_REGEXP
    #####: 1592:    case ECMA_STRING_PROTOTYPE_SEARCH:
        -: 1593:    {
    #####: 1594:      ret_value = ecma_builtin_string_prototype_object_search (to_string_val, arg1);
    #####: 1595:      break;
        -: 1596:    }
        -: 1597:#endif /* JERRY_BUILTIN_REGEXP */
    #####: 1598:    case ECMA_STRING_PROTOTYPE_SPLIT:
        -: 1599:    {
    #####: 1600:      ret_value = ecma_builtin_string_prototype_object_split (to_string_val, arg1, arg2);
    #####: 1601:      break;
        -: 1602:    }
    #####: 1603:    case ECMA_STRING_PROTOTYPE_SUBSTRING:
        -: 1604:    {
    #####: 1605:      ret_value = ecma_builtin_string_prototype_object_substring (string_p, arg1, arg2);
    #####: 1606:      break;
        -: 1607:    }
    #####: 1608:    case ECMA_STRING_PROTOTYPE_TO_LOWER_CASE:
        -: 1609:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE:
        -: 1610:    case ECMA_STRING_PROTOTYPE_TO_UPPER_CASE:
        -: 1611:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE:
        -: 1612:    {
    #####: 1613:      bool is_lower_case = builtin_routine_id <= ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE;
    #####: 1614:      ret_value = ecma_builtin_string_prototype_object_conversion_helper (string_p, is_lower_case);
    #####: 1615:      break;
        -: 1616:    }
    #####: 1617:    case ECMA_STRING_PROTOTYPE_TRIM:
        -: 1618:    {
    #####: 1619:      ret_value = ecma_builtin_string_prototype_object_trim (string_p);
    #####: 1620:      break;
        -: 1621:    }
        -: 1622:#if JERRY_BUILTIN_ANNEXB
    #####: 1623:    case ECMA_STRING_PROTOTYPE_SUBSTR:
        -: 1624:    {
    #####: 1625:      ret_value = ecma_builtin_string_prototype_object_substr (string_p, arg1, arg2);
    #####: 1626:      break;
        -: 1627:    }
        -: 1628:#endif /* JERRY_BUILTIN_ANNEXB */
        -: 1629:#if JERRY_ESNEXT
    #####: 1630:    case ECMA_STRING_PROTOTYPE_REPEAT:
        -: 1631:    {
    #####: 1632:      ret_value = ecma_builtin_string_prototype_object_repeat (string_p, arg1);
    #####: 1633:      break;
        -: 1634:    }
    #####: 1635:    case ECMA_STRING_PROTOTYPE_CODE_POINT_AT:
        -: 1636:    {
    #####: 1637:      ret_value = ecma_builtin_string_prototype_object_code_point_at (string_p, arg1);
    #####: 1638:      break;
        -: 1639:    }
    #####: 1640:    case ECMA_STRING_PROTOTYPE_ITERATOR:
        -: 1641:    {
    #####: 1642:      ret_value = ecma_builtin_string_prototype_object_iterator (to_string_val);
    #####: 1643:      break;
        -: 1644:    }
    #####: 1645:    case ECMA_STRING_PROTOTYPE_PAD_END:
        -: 1646:    case ECMA_STRING_PROTOTYPE_PAD_START:
        -: 1647:    {
    #####: 1648:      ret_value = ecma_string_pad (to_string_val, arg1, arg2, builtin_routine_id == ECMA_STRING_PROTOTYPE_PAD_START);
    #####: 1649:      break;
        -: 1650:    }
        -: 1651:#endif /* JERRY_ESNEXT */
    #####: 1652:    default:
        -: 1653:    {
    #####: 1654:      JERRY_UNREACHABLE ();
        -: 1655:    }
        -: 1656:  }
        -: 1657:
    #####: 1658:  ecma_deref_ecma_string (string_p);
        -: 1659:
    #####: 1660:  return ret_value;
        -: 1661:} /* ecma_builtin_string_prototype_dispatch_routine */
        -: 1662:
        -: 1663:/**
        -: 1664: * @}
        -: 1665: * @}
        -: 1666: * @}
        -: 1667: */
        -: 1668:
        -: 1669:#endif /* JERRY_BUILTIN_STRING */
