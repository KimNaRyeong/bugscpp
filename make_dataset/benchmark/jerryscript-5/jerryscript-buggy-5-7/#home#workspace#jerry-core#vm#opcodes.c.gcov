        -:    0:Source:/home/workspace/jerry-core/vm/opcodes.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "opcodes.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-builtins.h"
        -:   22:#include "ecma-conversion.h"
        -:   23:#include "ecma-exceptions.h"
        -:   24:#include "ecma-function-object.h"
        -:   25:#include "ecma-gc.h"
        -:   26:#include "ecma-globals.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-iterator-object.h"
        -:   29:#include "ecma-lex-env.h"
        -:   30:#include "ecma-objects.h"
        -:   31:#include "ecma-promise-object.h"
        -:   32:#include "ecma-proxy-object.h"
        -:   33:
        -:   34:#include "jcontext.h"
        -:   35:#include "vm-defines.h"
        -:   36:#include "vm-stack.h"
        -:   37:
        -:   38:/** \addtogroup vm Virtual machine
        -:   39: * @{
        -:   40: *
        -:   41: * \addtogroup vm_opcodes Opcodes
        -:   42: * @{
        -:   43: */
        -:   44:
        -:   45:/**
        -:   46: * 'typeof' opcode handler.
        -:   47: *
        -:   48: * See also: ECMA-262 v5, 11.4.3
        -:   49: *
        -:   50: * @return ecma value
        -:   51: *         Returned value must be freed with ecma_free_value
        -:   52: */
        -:   53:ecma_value_t
    #####:   54:opfunc_typeof (ecma_value_t left_value) /**< left value */
        -:   55:{
    #####:   56:  return ecma_make_magic_string_value (ecma_get_typeof_lit_id (left_value));
        -:   57:} /* opfunc_typeof */
        -:   58:
        -:   59:/**
        -:   60: * Update data property for object literals.
        -:   61: */
        -:   62:void
    #####:   63:opfunc_set_data_property (ecma_object_t *object_p, /**< object */
        -:   64:                          ecma_string_t *prop_name_p, /**< data property name */
        -:   65:                          ecma_value_t value) /**< new value */
        -:   66:{
    #####:   67:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:   68:
    #####:   69:  ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);
        -:   70:  ecma_property_value_t *prop_value_p;
        -:   71:
    #####:   72:  if (property_p == NULL)
        -:   73:  {
    #####:   74:    prop_value_p =
        -:   75:      ecma_create_named_data_property (object_p, prop_name_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
        -:   76:  }
        -:   77:  else
        -:   78:  {
    #####:   79:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:   80:
    #####:   81:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   82:
    #####:   83:    if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:   84:    {
        -:   85:#if JERRY_CPOINTER_32_BIT
        -:   86:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:   87:      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:   88:                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);
        -:   89:      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -:   90:#endif /* JERRY_CPOINTER_32_BIT */
        -:   91:
    #####:   92:      *property_p |= ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE;
    #####:   93:      prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:   94:      return;
        -:   95:    }
        -:   96:  }
        -:   97:
    #####:   98:  ecma_named_data_property_assign_value (object_p, prop_value_p, value);
        -:   99:} /* opfunc_set_data_property */
        -:  100:
        -:  101:/**
        -:  102: * Update getter or setter for object literals.
        -:  103: */
        -:  104:void
    #####:  105:opfunc_set_accessor (bool is_getter, /**< is getter accessor */
        -:  106:                     ecma_value_t object, /**< object value */
        -:  107:                     ecma_string_t *accessor_name_p, /**< accessor name */
        -:  108:                     ecma_value_t accessor) /**< accessor value */
        -:  109:{
    #####:  110:  ecma_object_t *object_p = ecma_get_object_from_value (object);
        -:  111:
    #####:  112:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:  113:
    #####:  114:  ecma_property_t *property_p = ecma_find_named_property (object_p, accessor_name_p);
    #####:  115:  ecma_object_t *accessor_p = ecma_get_object_from_value (accessor);
        -:  116:
    #####:  117:  ecma_object_t *getter_func_p = NULL;
    #####:  118:  ecma_object_t *setter_func_p = NULL;
        -:  119:
    #####:  120:  if (is_getter)
        -:  121:  {
    #####:  122:    getter_func_p = accessor_p;
        -:  123:  }
        -:  124:  else
        -:  125:  {
    #####:  126:    setter_func_p = accessor_p;
        -:  127:  }
        -:  128:
    #####:  129:  if (property_p == NULL)
        -:  130:  {
    #####:  131:    ecma_create_named_accessor_property (object_p,
        -:  132:                                         accessor_name_p,
        -:  133:                                         getter_func_p,
        -:  134:                                         setter_func_p,
        -:  135:                                         ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE,
        -:  136:                                         NULL);
        -:  137:  }
        -:  138:  else
        -:  139:  {
    #####:  140:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  141:
    #####:  142:    ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  143:
    #####:  144:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  145:    {
        -:  146:#if JERRY_CPOINTER_32_BIT
        -:  147:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:  148:      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        -:  149:#endif /* JERRY_CPOINTER_32_BIT */
        -:  150:
    #####:  151:      ecma_free_value_if_not_object (prop_value_p->value);
    #####:  152:      *property_p = (uint8_t) (*property_p & ~(ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE));
        -:  153:
        -:  154:#if JERRY_CPOINTER_32_BIT
        -:  155:      ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_func_p);
        -:  156:      ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_func_p);
        -:  157:      ECMA_SET_NON_NULL_POINTER (prop_value_p->getter_setter_pair_cp, getter_setter_pair_p);
        -:  158:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  159:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_func_p);
    #####:  160:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_func_p);
        -:  161:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  162:      return;
        -:  163:    }
        -:  164:
    #####:  165:    if (is_getter)
        -:  166:    {
    #####:  167:      ecma_set_named_accessor_property_getter (object_p, prop_value_p, accessor_p);
        -:  168:    }
        -:  169:    else
        -:  170:    {
    #####:  171:      ecma_set_named_accessor_property_setter (object_p, prop_value_p, accessor_p);
        -:  172:    }
        -:  173:  }
        -:  174:} /* opfunc_set_accessor */
        -:  175:
        -:  176:/**
        -:  177: * Deletes an object property.
        -:  178: *
        -:  179: * @return ecma value
        -:  180: *         Returned value must be freed with ecma_free_value
        -:  181: */
        -:  182:ecma_value_t
    #####:  183:vm_op_delete_prop (ecma_value_t object, /**< base object */
        -:  184:                   ecma_value_t property, /**< property name */
        -:  185:                   bool is_strict) /**< strict mode */
        -:  186:{
        -:  187:#if !JERRY_ESNEXT
    #####:  188:  if (ecma_is_value_undefined (object))
        -:  189:  {
        -:  190:    return ECMA_VALUE_TRUE;
        -:  191:  }
        -:  192:#endif /* !JERRY_ESNEXT */
        -:  193:
    #####:  194:  if (!ecma_op_require_object_coercible (object))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:
    #####:  199:  ecma_string_t *name_string_p = ecma_op_to_property_key (property);
        -:  200:
    #####:  201:  if (JERRY_UNLIKELY (name_string_p == NULL))
        -:  202:  {
    #####:  203:    return ECMA_VALUE_ERROR;
        -:  204:  }
        -:  205:
    #####:  206:  ecma_value_t obj_value = ecma_op_to_object (object);
        -:  207:  /* The ecma_op_require_object_coercible call already checked the op_to_object error cases. */
    #####:  208:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_value));
    #####:  209:  JERRY_ASSERT (ecma_is_value_object (obj_value));
    #####:  210:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  211:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -:  212:
    #####:  213:  ecma_value_t delete_op_ret = ecma_op_object_delete (obj_p, name_string_p, is_strict);
    #####:  214:  JERRY_ASSERT (ecma_is_value_boolean (delete_op_ret) || ECMA_IS_VALUE_ERROR (delete_op_ret));
    #####:  215:  ecma_deref_object (obj_p);
    #####:  216:  ecma_deref_ecma_string (name_string_p);
        -:  217:
        -:  218:#if JERRY_ESNEXT
    #####:  219:  if (is_strict && ecma_is_value_false (delete_op_ret))
        -:  220:  {
    #####:  221:    return ecma_raise_type_error (ECMA_ERR_OPERATOR_DELETE_RETURNED_FALSE_IN_STRICT_MODE);
        -:  222:  }
        -:  223:#endif /* JERRY_ESNEXT */
        -:  224:
    #####:  225:  return delete_op_ret;
        -:  226:} /* vm_op_delete_prop */
        -:  227:
        -:  228:/**
        -:  229: * Deletes a variable.
        -:  230: *
        -:  231: * @return ecma value
        -:  232: *         Returned value must be freed with ecma_free_value
        -:  233: */
        -:  234:ecma_value_t
    #####:  235:vm_op_delete_var (ecma_value_t name_literal, /**< name literal */
        -:  236:                  ecma_object_t *lex_env_p) /**< lexical environment */
        -:  237:{
    #####:  238:  ecma_value_t completion_value = ECMA_VALUE_EMPTY;
        -:  239:
    #####:  240:  ecma_string_t *var_name_str_p = ecma_get_string_from_value (name_literal);
        -:  241:
    #####:  242:  ecma_object_t *ref_base_lex_env_p = ecma_op_resolve_reference_base (lex_env_p, var_name_str_p);
        -:  243:
        -:  244:#if JERRY_BUILTIN_PROXY
    #####:  245:  if (JERRY_UNLIKELY (ref_base_lex_env_p == ECMA_OBJECT_POINTER_ERROR))
        -:  246:  {
    #####:  247:    return ECMA_VALUE_ERROR;
        -:  248:  }
        -:  249:#endif /* JERRY_BUILTIN_PROXY */
        -:  250:
    #####:  251:  if (ref_base_lex_env_p == NULL)
        -:  252:  {
    #####:  253:    completion_value = ECMA_VALUE_TRUE;
        -:  254:  }
        -:  255:  else
        -:  256:  {
    #####:  257:    JERRY_ASSERT (ecma_is_lexical_environment (ref_base_lex_env_p));
        -:  258:
    #####:  259:    completion_value = ecma_op_delete_binding (ref_base_lex_env_p, var_name_str_p);
        -:  260:  }
        -:  261:
    #####:  262:  return completion_value;
        -:  263:} /* vm_op_delete_var */
        -:  264:
        -:  265:/**
        -:  266: * 'for-in' opcode handler
        -:  267: *
        -:  268: *  Note: from ES2015 (ES6) the for-in can trigger error when
        -:  269: *        the property names are not available (ex.: via Proxy ownKeys).
        -:  270: *        In these cases an error must be returned.
        -:  271: *
        -:  272: *        This error is returned as the `result_obj_p` and the
        -:  273: *        function's return value is NULL.
        -:  274: *
        -:  275: * See also:
        -:  276: *          ECMA-262 v5, 12.6.4
        -:  277: *
        -:  278: * @return - chain list of property names
        -:  279: *         - In case of error: NULL is returned and the `result_obj_p`
        -:  280: *           must be checked.
        -:  281: */
        -:  282:ecma_collection_t *
    #####:  283:opfunc_for_in (ecma_value_t iterable_value, /**< ideally an iterable value */
        -:  284:               ecma_value_t *result_obj_p) /**< expression object */
        -:  285:{
        -:  286:  /* 3. */
    #####:  287:  if (ecma_is_value_undefined (iterable_value) || ecma_is_value_null (iterable_value))
        -:  288:  {
    #####:  289:    return NULL;
        -:  290:  }
        -:  291:
        -:  292:  /* 4. */
    #####:  293:  ecma_value_t obj_expr_value = ecma_op_to_object (iterable_value);
        -:  294:  /* ecma_op_to_object will only raise error on null/undefined values but those are handled above. */
    #####:  295:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_expr_value));
    #####:  296:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_expr_value);
    #####:  297:  ecma_collection_t *prop_names_p = ecma_op_object_enumerate (obj_p);
        -:  298:
        -:  299:#if JERRY_ESNEXT
    #####:  300:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -:  301:  {
    #####:  302:    ecma_deref_object (obj_p);
    #####:  303:    *result_obj_p = ECMA_VALUE_ERROR;
    #####:  304:    return NULL;
        -:  305:  }
        -:  306:#endif /* JERRY_ESNEXT */
        -:  307:
    #####:  308:  if (prop_names_p->item_count != 0)
        -:  309:  {
    #####:  310:    *result_obj_p = ecma_make_object_value (obj_p);
    #####:  311:    return prop_names_p;
        -:  312:  }
        -:  313:
    #####:  314:  ecma_deref_object (obj_p);
    #####:  315:  ecma_collection_destroy (prop_names_p);
        -:  316:
    #####:  317:  return NULL;
        -:  318:} /* opfunc_for_in */
        -:  319:
        -:  320:#if JERRY_ESNEXT
        -:  321:
        -:  322:/**
        -:  323: * 'VM_OC_APPEND_ARRAY' opcode handler specialized for spread objects
        -:  324: *
        -:  325: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  326: *         ECMA_VALUE_EMPTY, otherwise
        -:  327: */
        -:  328:static ecma_value_t JERRY_ATTR_NOINLINE
    #####:  329:opfunc_append_to_spread_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  330:                               uint16_t values_length) /**< number of elements to set */
        -:  331:{
    #####:  332:  JERRY_ASSERT (!(values_length & OPFUNC_HAS_SPREAD_ELEMENT));
        -:  333:
    #####:  334:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  335:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  336:
    #####:  337:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  338:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  339:
    #####:  340:  for (uint32_t i = 0, idx = old_length; i < values_length; i++, idx++)
        -:  341:  {
    #####:  342:    if (ecma_is_value_array_hole (stack_top_p[i]))
        -:  343:    {
    #####:  344:      continue;
        -:  345:    }
        -:  346:
    #####:  347:    if (stack_top_p[i] == ECMA_VALUE_SPREAD_ELEMENT)
        -:  348:    {
    #####:  349:      i++;
    #####:  350:      ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  351:      ecma_value_t spread_value = stack_top_p[i];
        -:  352:
    #####:  353:      ecma_value_t next_method;
    #####:  354:      ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  355:
    #####:  356:      if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  357:      {
        -:  358:        while (true)
    #####:  359:        {
    #####:  360:          ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  361:
    #####:  362:          if (ECMA_IS_VALUE_ERROR (next_value))
        -:  363:          {
    #####:  364:            break;
        -:  365:          }
        -:  366:
    #####:  367:          if (ecma_is_value_false (next_value))
        -:  368:          {
    #####:  369:            idx--;
    #####:  370:            ret_value = ECMA_VALUE_EMPTY;
    #####:  371:            break;
        -:  372:          }
        -:  373:
    #####:  374:          ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  375:
    #####:  376:          ecma_free_value (next_value);
        -:  377:
    #####:  378:          if (ECMA_IS_VALUE_ERROR (value))
        -:  379:          {
    #####:  380:            break;
        -:  381:          }
        -:  382:
        -:  383:          ecma_value_t put_comp;
    #####:  384:          put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  385:                                                            idx++,
        -:  386:                                                            value,
        -:  387:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  388:
    #####:  389:          JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  390:          ecma_free_value (value);
        -:  391:        }
        -:  392:      }
        -:  393:
    #####:  394:      ecma_free_value (iterator);
    #####:  395:      ecma_free_value (next_method);
    #####:  396:      ecma_free_value (spread_value);
        -:  397:
    #####:  398:      if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  399:      {
    #####:  400:        for (uint32_t k = i + 1; k < values_length; k++)
        -:  401:        {
    #####:  402:          ecma_free_value (stack_top_p[k]);
        -:  403:        }
        -:  404:
    #####:  405:        return ret_value;
        -:  406:      }
        -:  407:    }
        -:  408:    else
        -:  409:    {
    #####:  410:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
        -:  411:                                                                     idx,
    #####:  412:                                                                     stack_top_p[i],
        -:  413:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  414:      JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  415:      ecma_free_value (stack_top_p[i]);
        -:  416:    }
        -:  417:  }
        -:  418:
    #####:  419:  return ECMA_VALUE_EMPTY;
        -:  420:} /* opfunc_append_to_spread_array */
        -:  421:
        -:  422:/**
        -:  423: * Spread function call/construct arguments into an ecma-collection
        -:  424: *
        -:  425: * @return NULL - if the operation failed
        -:  426: *         pointer to the ecma-collection with the spreaded arguments, otherwise
        -:  427: */
        -:  428:JERRY_ATTR_NOINLINE ecma_collection_t *
    #####:  429:opfunc_spread_arguments (ecma_value_t *stack_top_p, /**< pointer to the current stack top */
        -:  430:                         uint8_t arguments_list_len) /**< number of arguments */
        -:  431:{
    #####:  432:  ecma_collection_t *buff_p = ecma_new_collection ();
        -:  433:
    #####:  434:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  435:  {
    #####:  436:    ecma_value_t arg = *stack_top_p++;
        -:  437:
    #####:  438:    if (arg != ECMA_VALUE_SPREAD_ELEMENT)
        -:  439:    {
    #####:  440:      ecma_collection_push_back (buff_p, arg);
    #####:  441:      continue;
        -:  442:    }
        -:  443:
    #####:  444:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  445:    ecma_value_t spread_value = *stack_top_p++;
    #####:  446:    i++;
        -:  447:
    #####:  448:    ecma_value_t next_method;
    #####:  449:    ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  450:
    #####:  451:    if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  452:    {
        -:  453:      while (true)
    #####:  454:      {
    #####:  455:        ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  456:
    #####:  457:        if (ECMA_IS_VALUE_ERROR (next_value))
        -:  458:        {
    #####:  459:          break;
        -:  460:        }
        -:  461:
    #####:  462:        if (ecma_is_value_false (next_value))
        -:  463:        {
    #####:  464:          ret_value = ECMA_VALUE_EMPTY;
    #####:  465:          break;
        -:  466:        }
        -:  467:
    #####:  468:        ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  469:
    #####:  470:        ecma_free_value (next_value);
        -:  471:
    #####:  472:        if (ECMA_IS_VALUE_ERROR (value))
        -:  473:        {
    #####:  474:          break;
        -:  475:        }
        -:  476:
    #####:  477:        ecma_collection_push_back (buff_p, value);
        -:  478:      }
        -:  479:    }
        -:  480:
    #####:  481:    ecma_free_value (iterator);
    #####:  482:    ecma_free_value (next_method);
    #####:  483:    ecma_free_value (spread_value);
        -:  484:
    #####:  485:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  486:    {
    #####:  487:      for (uint32_t k = i + 1; k < arguments_list_len; k++)
        -:  488:      {
    #####:  489:        ecma_free_value (*stack_top_p++);
        -:  490:      }
        -:  491:
    #####:  492:      ecma_collection_free (buff_p);
    #####:  493:      buff_p = NULL;
    #####:  494:      break;
        -:  495:    }
        -:  496:  }
        -:  497:
    #####:  498:  return buff_p;
        -:  499:} /* opfunc_spread_arguments */
        -:  500:
        -:  501:#endif /* JERRY_ESNEXT */
        -:  502:
        -:  503:/**
        -:  504: * 'VM_OC_APPEND_ARRAY' opcode handler, for setting array object properties
        -:  505: *
        -:  506: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  507: *         ECMA_VALUE_EMPTY, otherwise
        -:  508: */
        -:  509:ecma_value_t JERRY_ATTR_NOINLINE
    #####:  510:opfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  511:                     uint16_t values_length) /**< number of elements to set
        -:  512:                                              *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */
        -:  513:{
        -:  514:#if JERRY_ESNEXT
    #####:  515:  if (values_length >= OPFUNC_HAS_SPREAD_ELEMENT)
        -:  516:  {
    #####:  517:    return opfunc_append_to_spread_array (stack_top_p, (uint16_t) (values_length & ~OPFUNC_HAS_SPREAD_ELEMENT));
        -:  518:  }
        -:  519:#endif /* JERRY_ESNEXT */
        -:  520:
    #####:  521:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  522:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  523:
    #####:  524:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  525:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  526:
    #####:  527:  if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_array_obj_p)))
        -:  528:  {
    #####:  529:    uint32_t filled_holes = 0;
    #####:  530:    ecma_value_t *values_p = ecma_fast_array_extend (array_obj_p, old_length + values_length);
        -:  531:
    #####:  532:    for (uint32_t i = 0; i < values_length; i++)
        -:  533:    {
    #####:  534:      values_p[old_length + i] = stack_top_p[i];
        -:  535:
    #####:  536:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  537:      {
    #####:  538:        filled_holes++;
        -:  539:
    #####:  540:        ecma_deref_if_object (stack_top_p[i]);
        -:  541:      }
        -:  542:    }
        -:  543:
    #####:  544:    ext_array_obj_p->u.array.length_prop_and_hole_count -= filled_holes * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  545:
    #####:  546:    if (JERRY_UNLIKELY ((values_length - filled_holes) > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT))
        -:  547:    {
    #####:  548:      ecma_fast_array_convert_to_normal (array_obj_p);
        -:  549:    }
        -:  550:  }
        -:  551:  else
        -:  552:  {
    #####:  553:    for (uint32_t i = 0; i < values_length; i++)
        -:  554:    {
    #####:  555:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  556:      {
    #####:  557:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (old_length + i);
        -:  558:
        -:  559:        ecma_property_value_t *prop_value_p;
        -:  560:
    #####:  561:        prop_value_p = ecma_create_named_data_property (array_obj_p,
        -:  562:                                                        index_str_p,
        -:  563:                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  564:                                                        NULL);
        -:  565:
    #####:  566:        ecma_deref_ecma_string (index_str_p);
    #####:  567:        prop_value_p->value = stack_top_p[i];
    #####:  568:        ecma_deref_if_object (stack_top_p[i]);
        -:  569:      }
        -:  570:    }
    #####:  571:    ext_array_obj_p->u.array.length = old_length + values_length;
        -:  572:  }
        -:  573:
    #####:  574:  return ECMA_VALUE_EMPTY;
        -:  575:} /* opfunc_append_array */
        -:  576:
        -:  577:#if JERRY_ESNEXT
        -:  578:
        -:  579:/**
        -:  580: * Create an executable object using the current frame context
        -:  581: *
        -:  582: * @return executable object
        -:  583: */
        -:  584:vm_executable_object_t *
    #####:  585:opfunc_create_executable_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  586:                                 vm_create_executable_object_type_t type) /**< executable object type */
        -:  587:{
    #####:  588:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -:  589:  size_t size, register_end;
        -:  590:
    #####:  591:  ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_header_p);
        -:  592:
    #####:  593:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  594:  {
    #####:  595:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  596:    register_end = (size_t) args_p->register_end;
    #####:  597:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  598:  }
        -:  599:  else
        -:  600:  {
    #####:  601:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  602:    register_end = (size_t) args_p->register_end;
    #####:  603:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  604:  }
        -:  605:
    #####:  606:  size_t total_size = JERRY_ALIGNUP (sizeof (vm_executable_object_t) + size, sizeof (uintptr_t));
        -:  607:
    #####:  608:  ecma_object_t *proto_p = NULL;
        -:  609:  /* Async function objects are not accessible, so their class_id is not relevant. */
    #####:  610:  uint8_t class_type = ECMA_OBJECT_CLASS_GENERATOR;
        -:  611:
    #####:  612:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  613:  {
    #####:  614:    ecma_builtin_id_t default_proto_id = ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE;
        -:  615:
    #####:  616:    if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR)
        -:  617:    {
    #####:  618:      default_proto_id = ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE;
    #####:  619:      class_type = ECMA_OBJECT_CLASS_ASYNC_GENERATOR;
        -:  620:    }
        -:  621:
    #####:  622:    JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####:  623:    proto_p = ecma_op_get_prototype_from_constructor (frame_ctx_p->shared_p->function_object_p, default_proto_id);
        -:  624:  }
        -:  625:
    #####:  626:  ecma_object_t *object_p = ecma_create_object (proto_p, total_size, ECMA_OBJECT_TYPE_CLASS);
        -:  627:
    #####:  628:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  629:
    #####:  630:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  631:  {
    #####:  632:    ecma_deref_object (proto_p);
        -:  633:  }
        -:  634:
    #####:  635:  executable_object_p->extended_object.u.cls.type = class_type;
    #####:  636:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags = 0;
    #####:  637:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (executable_object_p->extended_object.u.cls.u3.head, NULL);
    #####:  638:  executable_object_p->iterator = ECMA_VALUE_UNDEFINED;
        -:  639:
    #####:  640:  JERRY_ASSERT (!(frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL));
        -:  641:
        -:  642:  /* Copy shared data and frame context. */
    #####:  643:  vm_frame_ctx_shared_t *new_shared_p = &(executable_object_p->shared);
    #####:  644:  *new_shared_p = *(frame_ctx_p->shared_p);
    #####:  645:  new_shared_p->status_flags &= (uint32_t) ~VM_FRAME_CTX_SHARED_HAS_ARG_LIST;
    #####:  646:  new_shared_p->status_flags |= VM_FRAME_CTX_SHARED_EXECUTABLE;
        -:  647:
    #####:  648:  vm_frame_ctx_t *new_frame_ctx_p = &(executable_object_p->frame_ctx);
    #####:  649:  *new_frame_ctx_p = *frame_ctx_p;
    #####:  650:  new_frame_ctx_p->shared_p = new_shared_p;
        -:  651:
        -:  652:  /* The old register values are discarded. */
    #####:  653:  ecma_value_t *new_registers_p = VM_GET_REGISTERS (new_frame_ctx_p);
    #####:  654:  memcpy (new_registers_p, VM_GET_REGISTERS (frame_ctx_p), size);
        -:  655:
    #####:  656:  size_t stack_top = (size_t) (frame_ctx_p->stack_top_p - VM_GET_REGISTERS (frame_ctx_p));
    #####:  657:  ecma_value_t *new_stack_top_p = new_registers_p + stack_top;
        -:  658:
    #####:  659:  new_frame_ctx_p->stack_top_p = new_stack_top_p;
        -:  660:
        -:  661:  /* Initial state is "not running", so all object references are released. */
        -:  662:
    #####:  663:  if (frame_ctx_p->context_depth > 0)
        -:  664:  {
    #####:  665:    JERRY_ASSERT (type != VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -:  666:
    #####:  667:    ecma_value_t *register_end_p = new_registers_p + register_end;
        -:  668:
    #####:  669:    JERRY_ASSERT (register_end_p <= new_stack_top_p);
        -:  670:
    #####:  671:    while (new_registers_p < register_end_p)
        -:  672:    {
    #####:  673:      ecma_deref_if_object (*new_registers_p++);
        -:  674:    }
        -:  675:
    #####:  676:    vm_ref_lex_env_chain (frame_ctx_p->lex_env_p, frame_ctx_p->context_depth, new_registers_p, false);
        -:  677:
    #####:  678:    new_registers_p += frame_ctx_p->context_depth;
        -:  679:
    #####:  680:    JERRY_ASSERT (new_registers_p <= new_stack_top_p);
        -:  681:  }
        -:  682:
    #####:  683:  while (new_registers_p < new_stack_top_p)
        -:  684:  {
    #####:  685:    ecma_deref_if_object (*new_registers_p++);
        -:  686:  }
        -:  687:
    #####:  688:  JERRY_ASSERT (*VM_GET_EXECUTABLE_ITERATOR (new_frame_ctx_p) == ECMA_VALUE_UNDEFINED);
        -:  689:
    #####:  690:  new_frame_ctx_p->this_binding = ecma_copy_value_if_not_object (new_frame_ctx_p->this_binding);
        -:  691:
    #####:  692:  JERRY_CONTEXT (vm_top_context_p) = new_frame_ctx_p->prev_context_p;
        -:  693:
    #####:  694:  return executable_object_p;
        -:  695:} /* opfunc_create_executable_object */
        -:  696:
        -:  697:/**
        -:  698: * Byte code which resumes an executable object with throw
        -:  699: */
        -:  700:const uint8_t opfunc_resume_executable_object_with_throw[1] = { CBC_THROW };
        -:  701:
        -:  702:/**
        -:  703: * Byte code which resumes an executable object with return
        -:  704: */
        -:  705:const uint8_t opfunc_resume_executable_object_with_return[2] = { CBC_EXT_OPCODE, CBC_EXT_RETURN };
        -:  706:
        -:  707:/**
        -:  708: * Resume the execution of an inactive executable object
        -:  709: *
        -:  710: * @return value provided by the execution
        -:  711: */
        -:  712:ecma_value_t
    #####:  713:opfunc_resume_executable_object (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  714:                                 ecma_value_t value) /**< value pushed onto the stack (takes the reference) */
        -:  715:{
    #####:  716:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
    #####:  717:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
        -:  718:  ecma_value_t *register_end_p;
        -:  719:
    #####:  720:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  721:  {
    #####:  722:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  723:    register_end_p = register_p + args_p->register_end;
        -:  724:  }
        -:  725:  else
        -:  726:  {
    #####:  727:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  728:    register_end_p = register_p + args_p->register_end;
        -:  729:  }
        -:  730:
    #####:  731:  ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  732:
    #####:  733:  if (value != ECMA_VALUE_EMPTY)
        -:  734:  {
    #####:  735:    *stack_top_p = value;
    #####:  736:    executable_object_p->frame_ctx.stack_top_p = stack_top_p + 1;
        -:  737:  }
        -:  738:
    #####:  739:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  740:  {
    #####:  741:    while (register_p < register_end_p)
        -:  742:    {
    #####:  743:      ecma_ref_if_object (*register_p++);
        -:  744:    }
        -:  745:
    #####:  746:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  747:                          executable_object_p->frame_ctx.context_depth,
        -:  748:                          register_p,
        -:  749:                          true);
        -:  750:
    #####:  751:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  752:  }
        -:  753:
    #####:  754:  while (register_p < stack_top_p)
        -:  755:  {
    #####:  756:    ecma_ref_if_object (*register_p++);
        -:  757:  }
        -:  758:
    #####:  759:  ecma_ref_if_object (executable_object_p->iterator);
        -:  760:
    #####:  761:  JERRY_ASSERT (ECMA_EXECUTABLE_OBJECT_IS_SUSPENDED (executable_object_p));
        -:  762:
    #####:  763:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  764:
    #####:  765:  executable_object_p->frame_ctx.prev_context_p = JERRY_CONTEXT (vm_top_context_p);
    #####:  766:  JERRY_CONTEXT (vm_top_context_p) = &executable_object_p->frame_ctx;
        -:  767:
        -:  768:  /* inside the generators the "new.target" is always "undefined" as it can't be invoked with "new" */
    #####:  769:  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target_p);
    #####:  770:  JERRY_CONTEXT (current_new_target_p) = NULL;
        -:  771:
        -:  772:#if JERRY_BUILTIN_REALMS
    #####:  773:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
    #####:  774:  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (bytecode_header_p);
        -:  775:#endif /* JERRY_BUILTIN_REALMS */
        -:  776:
    #####:  777:  ecma_value_t result = vm_execute (&executable_object_p->frame_ctx);
        -:  778:
        -:  779:#if JERRY_BUILTIN_REALMS
    #####:  780:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  781:#endif /* JERRY_BUILTIN_REALMS */
        -:  782:
    #####:  783:  JERRY_CONTEXT (current_new_target_p) = old_new_target;
    #####:  784:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= (uint8_t) ~ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  785:
    #####:  786:  if (executable_object_p->frame_ctx.call_operation != VM_EXEC_RETURN)
        -:  787:  {
    #####:  788:    JERRY_ASSERT (executable_object_p->frame_ctx.call_operation == VM_NO_EXEC_OP);
        -:  789:
        -:  790:    /* All resources are released. */
    #####:  791:    executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_COMPLETED;
    #####:  792:    return result;
        -:  793:  }
        -:  794:
    #####:  795:  JERRY_CONTEXT (vm_top_context_p) = executable_object_p->frame_ctx.prev_context_p;
        -:  796:
    #####:  797:  register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####:  798:  stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  799:
    #####:  800:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  801:  {
    #####:  802:    while (register_p < register_end_p)
        -:  803:    {
    #####:  804:      ecma_deref_if_object (*register_p++);
        -:  805:    }
        -:  806:
    #####:  807:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  808:                          executable_object_p->frame_ctx.context_depth,
        -:  809:                          register_p,
        -:  810:                          false);
        -:  811:
    #####:  812:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  813:  }
        -:  814:
    #####:  815:  while (register_p < stack_top_p)
        -:  816:  {
    #####:  817:    ecma_deref_if_object (*register_p++);
        -:  818:  }
        -:  819:
    #####:  820:  ecma_deref_if_object (executable_object_p->iterator);
        -:  821:
    #####:  822:  return result;
        -:  823:} /* opfunc_resume_executable_object */
        -:  824:
        -:  825:/**
        -:  826: * Fulfill the next promise of the async generator with the value
        -:  827: */
        -:  828:void
    #####:  829:opfunc_async_generator_yield (ecma_extended_object_t *async_generator_object_p, /**< async generator object */
        -:  830:                              ecma_value_t value) /**< value (takes the reference) */
        -:  831:{
        -:  832:  ecma_async_generator_task_t *task_p;
    #####:  833:  task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, async_generator_object_p->u.cls.u3.head);
        -:  834:
    #####:  835:  ecma_value_t iter_result = ecma_create_iter_result_object (value, ECMA_VALUE_FALSE);
    #####:  836:  ecma_fulfill_promise (task_p->promise, iter_result);
        -:  837:
    #####:  838:  ecma_free_value (iter_result);
    #####:  839:  ecma_free_value (value);
        -:  840:
    #####:  841:  ecma_value_t next = task_p->next;
    #####:  842:  async_generator_object_p->u.cls.u3.head = next;
        -:  843:
    #####:  844:  JERRY_ASSERT (task_p->operation_value == ECMA_VALUE_UNDEFINED);
    #####:  845:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  846:
    #####:  847:  if (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  848:  {
    #####:  849:    ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:  850:    ecma_enqueue_promise_async_generator_job (executable_object);
        -:  851:  }
    #####:  852:} /* opfunc_async_generator_yield */
        -:  853:
        -:  854:/**
        -:  855: * Creates a new executable object and awaits for the value
        -:  856: *
        -:  857: * Note:
        -:  858: *   extra_flags can be used to set additional extra_info flags
        -:  859: *
        -:  860: * @return a new Promise object on success, error otherwise
        -:  861: */
        -:  862:ecma_value_t
    #####:  863:opfunc_async_create_and_await (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  864:                               ecma_value_t value, /**< awaited value (takes reference) */
        -:  865:                               uint16_t extra_flags) /**< extra flags */
        -:  866:{
    #####:  867:  JERRY_ASSERT (
        -:  868:    CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC
        -:  869:    || (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_ARROW));
        -:  870:
    #####:  871:  ecma_object_t *promise_p = ecma_builtin_get (ECMA_BUILTIN_ID_PROMISE);
    #####:  872:  ecma_value_t result = ecma_promise_reject_or_resolve (ecma_make_object_value (promise_p), value, true);
    #####:  873:  ecma_free_value (value);
        -:  874:
    #####:  875:  if (ECMA_IS_VALUE_ERROR (result))
        -:  876:  {
    #####:  877:    return result;
        -:  878:  }
        -:  879:
        -:  880:  vm_executable_object_t *executable_object_p;
    #####:  881:  executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_ASYNC);
        -:  882:
    #####:  883:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= extra_flags;
        -:  884:
    #####:  885:  ecma_promise_async_then (result, ecma_make_object_value ((ecma_object_t *) executable_object_p));
    #####:  886:  ecma_deref_object ((ecma_object_t *) executable_object_p);
    #####:  887:  ecma_free_value (result);
        -:  888:
    #####:  889:  result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, promise_p);
        -:  890:
    #####:  891:  JERRY_ASSERT (ecma_is_value_object (result));
    #####:  892:  executable_object_p->iterator = result;
        -:  893:
    #####:  894:  return result;
        -:  895:} /* opfunc_async_create_and_await */
        -:  896:
        -:  897:/**
        -:  898: * PrivateMethodOrAccessorAdd abstact operation.
        -:  899: *
        -:  900: * See also: ECMAScript v12, 7.3.29.
        -:  901: *
        -:  902: * @return ECMA_VALUE_ERROR - initialization fails
        -:  903: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  904: */
        -:  905:static ecma_value_t
    #####:  906:opfunc_private_method_or_accessor_add (ecma_object_t *class_object_p, /**< the function itself */
        -:  907:                                       ecma_object_t *this_obj_p, /**< this object */
        -:  908:                                       uint32_t static_flag)
        -:  909:{
    #####:  910:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####:  911:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -:  912:
    #####:  913:  if (prop_p == NULL)
        -:  914:  {
    #####:  915:    return ECMA_VALUE_UNDEFINED;
        -:  916:  }
        -:  917:
    #####:  918:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####:  919:  ecma_value_t *current_p = collection_p + 1;
    #####:  920:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -:  921:
    #####:  922:  while (current_p < end_p)
        -:  923:  {
    #####:  924:    uint32_t prop_desc = *current_p++;
    #####:  925:    ecma_private_property_kind_t kind = ECMA_PRIVATE_PROPERTY_KIND (prop_desc);
        -:  926:
    #####:  927:    if ((prop_desc & ECMA_PRIVATE_PROPERTY_STATIC_FLAG) != static_flag || kind == ECMA_PRIVATE_FIELD)
        -:  928:    {
    #####:  929:      current_p += 2;
    #####:  930:      continue;
        -:  931:    }
        -:  932:
    #####:  933:    ecma_string_t *prop_name_p = ecma_get_symbol_from_value (*current_p++);
    #####:  934:    ecma_value_t method = *current_p++;
        -:  935:
    #####:  936:    JERRY_ASSERT (prop_name_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD);
        -:  937:
    #####:  938:    prop_p = ecma_find_named_property (this_obj_p, prop_name_p);
    #####:  939:    ecma_object_t *method_p = ecma_get_object_from_value (method);
        -:  940:
    #####:  941:    if (kind == ECMA_PRIVATE_METHOD)
        -:  942:    {
    #####:  943:      if (prop_p != NULL)
        -:  944:      {
    #####:  945:        return ecma_raise_type_error (ECMA_ERR_CANNOT_DECLARE_SAME_PRIVATE_FIELD_TWICE);
        -:  946:      }
        -:  947:
    #####:  948:      ecma_property_value_t *prop_value_p =
        -:  949:        ecma_create_named_data_property (this_obj_p, prop_name_p, ECMA_PROPERTY_FIXED, NULL);
    #####:  950:      prop_value_p->value = method;
    #####:  951:      continue;
        -:  952:    }
        -:  953:
    #####:  954:    if (prop_p == NULL)
        -:  955:    {
    #####:  956:      ecma_object_t *getter_p = (kind == ECMA_PRIVATE_GETTER) ? method_p : NULL;
    #####:  957:      ecma_object_t *setter_p = (kind == ECMA_PRIVATE_SETTER) ? method_p : NULL;
    #####:  958:      ecma_create_named_accessor_property (this_obj_p, prop_name_p, getter_p, setter_p, ECMA_PROPERTY_FIXED, NULL);
    #####:  959:      continue;
        -:  960:    }
        -:  961:
    #####:  962:    ecma_property_value_t *accessor_objs_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  963:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -:  964:
    #####:  965:    if (kind == ECMA_PRIVATE_GETTER)
        -:  966:    {
    #####:  967:      ECMA_SET_POINTER (get_set_pair_p->getter_cp, method_p);
        -:  968:    }
        -:  969:    else
        -:  970:    {
    #####:  971:      JERRY_ASSERT (kind == ECMA_PRIVATE_SETTER);
    #####:  972:      ECMA_SET_POINTER (get_set_pair_p->setter_cp, method_p);
        -:  973:    }
        -:  974:  }
        -:  975:
    #####:  976:  return ECMA_VALUE_UNDEFINED;
        -:  977:} /* opfunc_private_method_or_accessor_add */
        -:  978:
        -:  979:/**
        -:  980: * DefineField abstract operation.
        -:  981: *
        -:  982: * See also: ECMAScript v12, 7.3.32.
        -:  983: *
        -:  984: * @return ECMA_VALUE_ERROR - operation fails
        -:  985: *         ECMA_VALUE_{TRUE/FALSE} - otherwise
        -:  986: */
        -:  987:ecma_value_t
    #####:  988:opfunc_define_field (ecma_value_t base, ecma_value_t property, ecma_value_t value)
        -:  989:{
    #####:  990:  ecma_string_t *property_key_p = ecma_op_to_property_key (property);
        -:  991:
    #####:  992:  JERRY_ASSERT (property_key_p != NULL);
    #####:  993:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####:  994:  ecma_property_descriptor_t desc = ecma_make_empty_property_descriptor ();
    #####:  995:  desc.value = value;
    #####:  996:  desc.flags = (JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_ENUMERABLE
        -:  997:                | JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED
        -:  998:                | JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_SHOULD_THROW);
        -:  999:
    #####: 1000:  ecma_value_t result = ecma_op_object_define_own_property (obj_p, property_key_p, &desc);
    #####: 1001:  ecma_deref_ecma_string (property_key_p);
        -: 1002:
    #####: 1003:  return result;
        -: 1004:} /* opfunc_define_field */
        -: 1005:
        -: 1006:/**
        -: 1007: * Initialize class fields.
        -: 1008: *
        -: 1009: * @return ECMA_VALUE_ERROR - initialization fails
        -: 1010: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1011: */
        -: 1012:ecma_value_t
    #####: 1013:opfunc_init_class_fields (ecma_object_t *class_object_p, /**< the function itself */
        -: 1014:                          ecma_value_t this_val) /**< this_arg of the function */
        -: 1015:{
    #####: 1016:  JERRY_ASSERT (ecma_is_value_object (this_val));
    #####: 1017:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_val);
        -: 1018:
    #####: 1019:  ecma_value_t result = opfunc_private_method_or_accessor_add (class_object_p, this_obj_p, 0);
        -: 1020:
    #####: 1021:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1022:  {
    #####: 1023:    return result;
        -: 1024:  }
        -: 1025:
    #####: 1026:  ecma_string_t *name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 1027:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1028:
    #####: 1029:  if (property_p == NULL)
        -: 1030:  {
    #####: 1031:    return ECMA_VALUE_UNDEFINED;
        -: 1032:  }
        -: 1033:
    #####: 1034:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####: 1035:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####: 1036:  shared_class_fields.computed_class_fields_p = NULL;
        -: 1037:
    #####: 1038:  name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1039:  ecma_property_t *class_field_property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1040:
    #####: 1041:  if (class_field_property_p != NULL)
        -: 1042:  {
    #####: 1043:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####: 1044:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -: 1045:  }
        -: 1046:
    #####: 1047:  ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1048:  JERRY_ASSERT (ecma_op_is_callable (property_value_p->value));
        -: 1049:
        -: 1050:  ecma_extended_object_t *ext_function_p;
    #####: 1051:  ext_function_p = (ecma_extended_object_t *) ecma_get_object_from_value (property_value_p->value);
    #####: 1052:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
    #####: 1053:  shared_class_fields.header.function_object_p = &ext_function_p->object;
        -: 1054:
    #####: 1055:  ecma_object_t *scope_p =
    #####: 1056:    ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_function_p->u.function.scope_cp);
        -: 1057:
    #####: 1058:  result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -: 1059:
    #####: 1060:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####: 1061:  return result;
        -: 1062:} /* opfunc_init_class_fields */
        -: 1063:
        -: 1064:/**
        -: 1065: * Initialize static class fields.
        -: 1066: *
        -: 1067: * @return ECMA_VALUE_ERROR - initialization fails
        -: 1068: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1069: */
        -: 1070:ecma_value_t
    #####: 1071:opfunc_init_static_class_fields (ecma_value_t function_object, /**< the function itself */
        -: 1072:                                 ecma_value_t this_val) /**< this_arg of the function */
        -: 1073:{
    #####: 1074:  JERRY_ASSERT (ecma_op_is_callable (function_object));
    #####: 1075:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -: 1076:
    #####: 1077:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1078:  ecma_object_t *function_object_p = ecma_get_object_from_value (function_object);
    #####: 1079:  ecma_property_t *class_field_property_p = ecma_find_named_property (function_object_p, name_p);
        -: 1080:
    #####: 1081:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####: 1082:  shared_class_fields.header.function_object_p = function_object_p;
    #####: 1083:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####: 1084:  shared_class_fields.computed_class_fields_p = NULL;
        -: 1085:
    #####: 1086:  if (class_field_property_p != NULL)
        -: 1087:  {
    #####: 1088:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####: 1089:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -: 1090:  }
        -: 1091:
    #####: 1092:  ecma_extended_object_t *ext_function_p = (ecma_extended_object_t *) function_object_p;
    #####: 1093:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
        -: 1094:
    #####: 1095:  ecma_object_t *scope_p =
    #####: 1096:    ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_function_p->u.function.scope_cp);
        -: 1097:
    #####: 1098:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -: 1099:
    #####: 1100:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####: 1101:  return result;
        -: 1102:} /* opfunc_init_static_class_fields */
        -: 1103:
        -: 1104:/**
        -: 1105: * Add the name of a computed field to a name list
        -: 1106: *
        -: 1107: * @return ECMA_VALUE_ERROR - name is not a valid property name
        -: 1108: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1109: */
        -: 1110:ecma_value_t
    #####: 1111:opfunc_add_computed_field (ecma_value_t class_object, /**< class object */
        -: 1112:                           ecma_value_t name) /**< name of the property */
        -: 1113:{
    #####: 1114:  ecma_string_t *prop_name_p = ecma_op_to_property_key (name);
        -: 1115:
    #####: 1116:  if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1117:  {
    #####: 1118:    return ECMA_VALUE_ERROR;
        -: 1119:  }
        -: 1120:
    #####: 1121:  if (ecma_prop_name_is_symbol (prop_name_p))
        -: 1122:  {
    #####: 1123:    name = ecma_make_symbol_value (prop_name_p);
        -: 1124:  }
        -: 1125:  else
        -: 1126:  {
    #####: 1127:    name = ecma_make_string_value (prop_name_p);
        -: 1128:  }
        -: 1129:
    #####: 1130:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1131:  ecma_object_t *class_object_p = ecma_get_object_from_value (class_object);
        -: 1132:
    #####: 1133:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1134:  ecma_value_t *compact_collection_p;
        -: 1135:  ecma_property_value_t *property_value_p;
        -: 1136:
    #####: 1137:  if (property_p == NULL)
        -: 1138:  {
    #####: 1139:    ECMA_CREATE_INTERNAL_PROPERTY (class_object_p, name_p, property_p, property_value_p);
    #####: 1140:    compact_collection_p = ecma_new_compact_collection ();
        -: 1141:  }
        -: 1142:  else
        -: 1143:  {
    #####: 1144:    property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1145:    compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
        -: 1146:  }
        -: 1147:
    #####: 1148:  compact_collection_p = ecma_compact_collection_push_back (compact_collection_p, name);
    #####: 1149:  ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
    #####: 1150:  return ECMA_VALUE_UNDEFINED;
        -: 1151:} /* opfunc_add_computed_field */
        -: 1152:
        -: 1153:/**
        -: 1154: * Create implicit class constructor
        -: 1155: *
        -: 1156: * See also: ECMAScript v6, 14.5.14
        -: 1157: *
        -: 1158: * @return - new external function ecma-object
        -: 1159: */
        -: 1160:ecma_value_t
    #####: 1161:opfunc_create_implicit_class_constructor (uint8_t opcode, /**< current cbc opcode */
        -: 1162:                                          const ecma_compiled_code_t *bytecode_p) /**< current byte code */
        -: 1163:{
        -: 1164:  /* 8. */
    #####: 1165:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 1166:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 1167:
    #####: 1168:  if (JERRY_UNLIKELY (script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -: 1169:  {
    #####: 1170:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1171:  }
        -: 1172:
    #####: 1173:  ecma_object_t *function_object_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE),
        -: 1174:                                                         sizeof (ecma_extended_object_t),
        -: 1175:                                                         ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
        -: 1176:
    #####: 1177:  ecma_extended_object_t *constructor_object_p = (ecma_extended_object_t *) function_object_p;
        -: 1178:
    #####: 1179:  script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
    #####: 1180:  constructor_object_p->u.constructor_function.script_value = script_value;
    #####: 1181:  constructor_object_p->u.constructor_function.flags = 0;
        -: 1182:
        -: 1183:  /* 10.a.i */
    #####: 1184:  if (opcode == CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE)
        -: 1185:  {
    #####: 1186:    constructor_object_p->u.constructor_function.flags |= ECMA_CONSTRUCTOR_FUNCTION_HAS_HERITAGE;
        -: 1187:  }
        -: 1188:
        -: 1189:  ecma_property_value_t *prop_value_p;
    #####: 1190:  prop_value_p = ecma_create_named_data_property (function_object_p,
        -: 1191:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -: 1192:                                                  ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 1193:                                                  NULL);
    #####: 1194:  prop_value_p->value = ecma_make_uint32_value (0);
        -: 1195:
    #####: 1196:  return ecma_make_object_value (function_object_p);
        -: 1197:} /* opfunc_create_implicit_class_constructor */
        -: 1198:
        -: 1199:/**
        -: 1200: * Set the [[HomeObject]] attribute of the given functon object
        -: 1201: */
        -: 1202:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1203:opfunc_set_home_object (ecma_object_t *func_p, /**< function object */
        -: 1204:                        ecma_object_t *parent_env_p) /**< parent environment */
        -: 1205:{
    #####: 1206:  JERRY_ASSERT (ecma_is_lexical_environment (parent_env_p));
        -: 1207:
    #####: 1208:  if (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1209:  {
    #####: 1210:    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
    #####: 1211:    ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp,
        -: 1212:                                   parent_env_p,
        -: 1213:                                   JMEM_CP_GET_POINTER_TAG_BITS (ext_func_p->u.function.scope_cp));
        -: 1214:  }
    #####: 1215:} /* opfunc_set_home_object */
        -: 1216:
        -: 1217:/**
        -: 1218: * Make private key from descriptor
        -: 1219: */
        -: 1220:ecma_string_t *
    #####: 1221:opfunc_make_private_key (ecma_value_t descriptor) /**< descriptor */
        -: 1222:{
    #####: 1223:  ecma_string_t *private_key_p = ecma_new_symbol_from_descriptor_string (descriptor);
    #####: 1224:  private_key_p->u.hash |= ECMA_SYMBOL_FLAG_PRIVATE_KEY;
        -: 1225:
    #####: 1226:  return (ecma_string_t *) private_key_p;
        -: 1227:} /* opfunc_make_private_key */
        -: 1228:
        -: 1229:/**
        -: 1230: * Find a private property in the private elements internal property given the key
        -: 1231: */
        -: 1232:static ecma_property_t *
    #####: 1233:opfunc_find_private_key (ecma_object_t *class_object_p, /**< class environment */
        -: 1234:                         ecma_object_t *obj_p, /**< object */
        -: 1235:                         ecma_string_t *search_key_p, /**< key */
        -: 1236:                         ecma_string_t **out_private_key_p) /**< [out] private key */
        -: 1237:{
    #####: 1238:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1239:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1240:
    #####: 1241:  if (prop_p == NULL)
        -: 1242:  {
    #####: 1243:    return NULL;
        -: 1244:  }
        -: 1245:
    #####: 1246:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1247:  ecma_value_t *current_p = collection_p + 1;
    #####: 1248:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1249:
    #####: 1250:  while (current_p < end_p)
        -: 1251:  {
    #####: 1252:    current_p++; /* skip kind */
    #####: 1253:    ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1254:    current_p++; /* skip value */
        -: 1255:
    #####: 1256:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1257:
    #####: 1258:    ecma_string_t *private_key_desc_p =
    #####: 1259:      ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1260:
    #####: 1261:    if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1262:    {
    #####: 1263:      prop_p = ecma_find_named_property (obj_p, private_key_p);
        -: 1264:
    #####: 1265:      if (out_private_key_p)
        -: 1266:      {
    #####: 1267:        *out_private_key_p = private_key_p;
        -: 1268:      }
        -: 1269:
    #####: 1270:      return prop_p;
        -: 1271:    }
        -: 1272:  }
        -: 1273:
    #####: 1274:  return NULL;
        -: 1275:} /* opfunc_find_private_key */
        -: 1276:
        -: 1277:/**
        -: 1278: * PrivateElementFind abstact operation
        -: 1279: *
        -: 1280: * See also: ECMAScript v12, 7.3.27
        -: 1281: *
        -: 1282: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1283: *           ECMA_VALUE_EMPTY - otherwise
        -: 1284: */
        -: 1285:static ecma_property_t *
    #####: 1286:opfunc_find_private_element (ecma_object_t *obj_p, /**< object */
        -: 1287:                             ecma_string_t *key_p, /**< key */
        -: 1288:                             ecma_string_t **private_key_p, /**< [out] private key */
        -: 1289:                             bool allow_heritage)
        -: 1290:{
    #####: 1291:  JERRY_ASSERT (private_key_p != NULL);
    #####: 1292:  JERRY_ASSERT (*private_key_p == NULL);
    #####: 1293:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1294:
        -: 1295:  while (true)
        -: 1296:  {
    #####: 1297:    JERRY_ASSERT (lex_env_p != NULL);
        -: 1298:
    #####: 1299:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1300:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) != 0
    #####: 1301:        && !ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -: 1302:    {
    #####: 1303:      ecma_object_t *class_object_p = ((ecma_lexical_environment_class_t *) lex_env_p)->object_p;
        -: 1304:
    #####: 1305:      ecma_property_t *prop_p = opfunc_find_private_key (class_object_p, obj_p, key_p, private_key_p);
        -: 1306:
    #####: 1307:      if (prop_p || *private_key_p != NULL)
        -: 1308:      {
        -: 1309:        /* Found non shadowed property */
    #####: 1310:        return prop_p;
        -: 1311:      }
        -: 1312:
    #####: 1313:      if (!allow_heritage)
        -: 1314:      {
    #####: 1315:        return NULL;
        -: 1316:      }
        -: 1317:    }
        -: 1318:
    #####: 1319:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -: 1320:    {
    #####: 1321:      break;
        -: 1322:    }
        -: 1323:
    #####: 1324:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1325:  }
        -: 1326:
    #####: 1327:  return NULL;
        -: 1328:} /* opfunc_find_private_element */
        -: 1329:
        -: 1330:/**
        -: 1331: * In expression runtime evaluation in case of private identifiers
        -: 1332: *
        -: 1333: * See also: ECMAScript v12, 13.10.1
        -: 1334: *
        -: 1335: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1336: *           ECMA_VALUE_TRUE - if the property was found in the base object
        -: 1337: *           ECMA_VALUE_FALSE - otherwise
        -: 1338: */
        -: 1339:ecma_value_t
    #####: 1340:opfunc_private_in (ecma_value_t base, ecma_value_t property)
        -: 1341:{
    #####: 1342:  if (!ecma_is_value_object (base))
        -: 1343:  {
    #####: 1344:    return ecma_raise_type_error (ECMA_ERR_RIGHT_VALUE_OF_IN_MUST_BE_AN_OBJECT);
        -: 1345:  }
        -: 1346:
    #####: 1347:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####: 1348:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (property);
    #####: 1349:  ecma_string_t *private_key_p = NULL;
        -: 1350:
    #####: 1351:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, false);
        -: 1352:
    #####: 1353:  return ecma_make_boolean_value (prop_p != NULL);
        -: 1354:} /* opfunc_private_in */
        -: 1355:
        -: 1356:/**
        -: 1357: * PrivateFieldAdd abstact operation
        -: 1358: *
        -: 1359: * See also: ECMAScript v12, 7.3.28
        -: 1360: *
        -: 1361: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1362: *           ECMA_VALUE_EMPTY - otherwise
        -: 1363: */
        -: 1364:ecma_value_t
    #####: 1365:opfunc_private_field_add (ecma_value_t base, /**< base object */
        -: 1366:                          ecma_value_t property, /**< property name */
        -: 1367:                          ecma_value_t value) /**< ecma value */
        -: 1368:{
    #####: 1369:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####: 1370:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
    #####: 1371:  ecma_string_t *private_key_p = NULL;
        -: 1372:
    #####: 1373:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, false);
        -: 1374:
    #####: 1375:  if (prop_p != NULL)
        -: 1376:  {
    #####: 1377:    return ecma_raise_type_error (ECMA_ERR_CANNOT_DECLARE_SAME_PRIVATE_FIELD_TWICE);
        -: 1378:  }
        -: 1379:
    #####: 1380:  ecma_property_value_t *value_p =
    #####: 1381:    ecma_create_named_data_property (obj_p, private_key_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1382:
    #####: 1383:  value_p->value = ecma_copy_value_if_not_object (value);
        -: 1384:
    #####: 1385:  return ECMA_VALUE_EMPTY;
        -: 1386:} /* opfunc_private_field_add */
        -: 1387:
        -: 1388:/**
        -: 1389: * PrivateSet abstact operation
        -: 1390: *
        -: 1391: * See also: ECMAScript v12, 7.3.31
        -: 1392: *
        -: 1393: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1394: *           ECMA_VALUE_EMPTY - otherwise
        -: 1395: */
        -: 1396:ecma_value_t
    #####: 1397:opfunc_private_set (ecma_value_t base, /**< this object */
        -: 1398:                    ecma_value_t property, /**< property name */
        -: 1399:                    ecma_value_t value) /**< ecma value */
        -: 1400:{
    #####: 1401:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####: 1402:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
    #####: 1403:  ecma_string_t *private_key_p = NULL;
        -: 1404:
    #####: 1405:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);
        -: 1406:
    #####: 1407:  if (prop_p == NULL)
        -: 1408:  {
    #####: 1409:    return ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);
        -: 1410:  }
        -: 1411:
    #####: 1412:  if (*prop_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1413:  {
    #####: 1414:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1415:
    #####: 1416:    if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD)
        -: 1417:    {
    #####: 1418:      return ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE);
        -: 1419:    }
        -: 1420:
    #####: 1421:    ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value);
    #####: 1422:    return ecma_copy_value (value);
        -: 1423:  }
        -: 1424:
    #####: 1425:  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));
        -: 1426:
    #####: 1427:  if (get_set_pair_p->setter_cp == JMEM_CP_NULL)
        -: 1428:  {
    #####: 1429:    return ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER);
        -: 1430:  }
        -: 1431:
    #####: 1432:  ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);
        -: 1433:
    #####: 1434:  return ecma_op_function_call (setter_p, base, &value, 1);
        -: 1435:} /* opfunc_private_set */
        -: 1436:
        -: 1437:/**
        -: 1438: * PrivateGet abstact operation
        -: 1439: *
        -: 1440: * See also: ECMAScript v12, 7.3.30
        -: 1441: *
        -: 1442: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1443: *           private property value - otherwise
        -: 1444: */
        -: 1445:ecma_value_t
    #####: 1446:opfunc_private_get (ecma_value_t base, /**< this object */
        -: 1447:                    ecma_value_t property) /**< property name */
        -: 1448:{
    #####: 1449:  ecma_value_t base_obj = ecma_op_to_object (base);
        -: 1450:
    #####: 1451:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 1452:  {
    #####: 1453:    return base_obj;
        -: 1454:  }
        -: 1455:
    #####: 1456:  ecma_object_t *obj_p = ecma_get_object_from_value (base_obj);
    #####: 1457:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
    #####: 1458:  ecma_string_t *private_key_p = NULL;
        -: 1459:
    #####: 1460:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);
        -: 1461:
        -: 1462:  ecma_value_t result;
        -: 1463:
    #####: 1464:  if (prop_p == NULL)
        -: 1465:  {
    #####: 1466:    result = ecma_raise_type_error (ECMA_ERR_CANNOT_READ_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);
        -: 1467:  }
    #####: 1468:  else if (*prop_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1469:  {
    #####: 1470:    result = ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
        -: 1471:  }
        -: 1472:  else
        -: 1473:  {
    #####: 1474:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));
        -: 1475:
    #####: 1476:    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -: 1477:    {
    #####: 1478:      result = ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_GETTER);
        -: 1479:    }
        -: 1480:    else
        -: 1481:    {
    #####: 1482:      ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
    #####: 1483:      result = ecma_op_function_call (getter_p, base, NULL, 0);
        -: 1484:    }
        -: 1485:  }
        -: 1486:
    #####: 1487:  ecma_deref_object (obj_p);
        -: 1488:
    #####: 1489:  return result;
        -: 1490:} /* opfunc_private_get */
        -: 1491:
        -: 1492:/**
        -: 1493: * Find the private property in the object who's private key descriptor matches the given key
        -: 1494: */
        -: 1495:static ecma_string_t *
    #####: 1496:opfunc_create_private_key (ecma_value_t *collection_p, /**< TODO */
        -: 1497:                           ecma_value_t search_key, /**< key */
        -: 1498:                           ecma_private_property_kind_t search_kind)
        -: 1499:{
    #####: 1500:  if (search_kind < ECMA_PRIVATE_GETTER)
        -: 1501:  {
    #####: 1502:    return opfunc_make_private_key (search_key);
        -: 1503:  }
        -: 1504:
    #####: 1505:  ecma_string_t *search_key_p = ecma_get_string_from_value (search_key);
        -: 1506:
    #####: 1507:  ecma_value_t *current_p = collection_p + 1;
    #####: 1508:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1509:
    #####: 1510:  while (current_p < end_p)
        -: 1511:  {
    #####: 1512:    ecma_private_property_kind_t kind = ECMA_PRIVATE_PROPERTY_KIND (*current_p++);
    #####: 1513:    ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1514:    current_p++; /* skip value */
        -: 1515:
    #####: 1516:    if (kind < ECMA_PRIVATE_GETTER)
        -: 1517:    {
    #####: 1518:      continue;
        -: 1519:    }
        -: 1520:
    #####: 1521:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1522:
    #####: 1523:    ecma_string_t *private_key_desc_p =
    #####: 1524:      ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1525:
    #####: 1526:    if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1527:    {
    #####: 1528:      ecma_deref_ecma_string (search_key_p);
    #####: 1529:      ecma_ref_ecma_string (private_key_p);
    #####: 1530:      return private_key_p;
        -: 1531:    }
        -: 1532:  }
        -: 1533:
    #####: 1534:  return opfunc_make_private_key (search_key);
        -: 1535:} /* opfunc_create_private_key */
        -: 1536:
        -: 1537:/**
        -: 1538: * Collect private members for PrivateMethodOrAccessorAdd and PrivateFieldAdd abstract operations
        -: 1539: */
        -: 1540:void
    #####: 1541:opfunc_collect_private_properties (ecma_value_t constructor, ecma_value_t prop_name, ecma_value_t value, uint8_t opcode)
        -: 1542:{
    #####: 1543:  ecma_private_property_kind_t kind = ECMA_PRIVATE_FIELD;
    #####: 1544:  bool is_static = false;
        -: 1545:
    #####: 1546:  if (opcode >= CBC_EXT_COLLECT_PRIVATE_STATIC_FIELD)
        -: 1547:  {
    #####: 1548:    opcode = (uint8_t) (opcode - PARSER_STATIC_PRIVATE_TO_PRIVATE_OFFSET);
    #####: 1549:    is_static = true;
        -: 1550:  }
        -: 1551:
    #####: 1552:  if (opcode == CBC_EXT_COLLECT_PRIVATE_METHOD)
        -: 1553:  {
    #####: 1554:    prop_name ^= value;
    #####: 1555:    value ^= prop_name;
    #####: 1556:    prop_name ^= value;
    #####: 1557:    kind = ECMA_PRIVATE_METHOD;
        -: 1558:  }
    #####: 1559:  else if (opcode == CBC_EXT_COLLECT_PRIVATE_GETTER)
        -: 1560:  {
    #####: 1561:    kind = ECMA_PRIVATE_GETTER;
        -: 1562:  }
    #####: 1563:  else if (opcode == CBC_EXT_COLLECT_PRIVATE_SETTER)
        -: 1564:  {
    #####: 1565:    kind = ECMA_PRIVATE_SETTER;
        -: 1566:  }
        -: 1567:
    #####: 1568:  JERRY_ASSERT (ecma_is_value_object (constructor));
    #####: 1569:  JERRY_ASSERT (ecma_is_value_string (prop_name));
    #####: 1570:  JERRY_ASSERT (ecma_is_value_object (value) || ecma_is_value_undefined (value));
        -: 1571:
    #####: 1572:  ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);
    #####: 1573:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1574:  ecma_property_t *prop_p = ecma_find_named_property (constructor_p, internal_string_p);
        -: 1575:  ecma_value_t *collection_p;
        -: 1576:  ecma_property_value_t *prop_value_p;
        -: 1577:
    #####: 1578:  if (prop_p == NULL)
        -: 1579:  {
    #####: 1580:    collection_p = ecma_new_compact_collection ();
    #####: 1581:    ECMA_CREATE_INTERNAL_PROPERTY (constructor_p, internal_string_p, prop_p, prop_value_p);
    #####: 1582:    ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, collection_p);
        -: 1583:  }
        -: 1584:  else
        -: 1585:  {
    #####: 1586:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####: 1587:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, prop_value_p->value);
        -: 1588:  }
        -: 1589:
    #####: 1590:  ecma_string_t *key_p = opfunc_create_private_key (collection_p, prop_name, kind);
        -: 1591:
    #####: 1592:  if (kind != ECMA_PRIVATE_FIELD)
        -: 1593:  {
    #####: 1594:    key_p->u.hash |= ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD;
        -: 1595:  }
        -: 1596:
    #####: 1597:  if (is_static)
        -: 1598:  {
    #####: 1599:    kind |= ECMA_PRIVATE_PROPERTY_STATIC_FLAG;
        -: 1600:  }
        -: 1601:
    #####: 1602:  collection_p = ecma_compact_collection_push_back (collection_p, (ecma_value_t) kind);
    #####: 1603:  collection_p = ecma_compact_collection_push_back (collection_p, ecma_make_symbol_value (key_p));
    #####: 1604:  collection_p = ecma_compact_collection_push_back (collection_p, value);
        -: 1605:
        -: 1606:#ifndef JERRY_NDEBUG
    #####: 1607:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
    #####: 1608:  ecma_value_t *current_p = collection_p + 1;
        -: 1609:
    #####: 1610:  JERRY_ASSERT ((end_p - current_p) % ECMA_PRIVATE_ELEMENT_LIST_SIZE == 0);
        -: 1611:#endif /* !defined (JERRY_NDEBUG) */
        -: 1612:
    #####: 1613:  ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, collection_p);
        -: 1614:
    #####: 1615:  ecma_free_value (value);
    #####: 1616:} /* opfunc_collect_private_properties */
        -: 1617:
        -: 1618:/**
        -: 1619: * ClassDefinitionEvaluation environment initialization part
        -: 1620: *
        -: 1621: * See also: ECMAScript v6, 14.5.14
        -: 1622: *
        -: 1623: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1624: *           ECMA_VALUE_EMPTY - otherwise
        -: 1625: */
        -: 1626:void
    #####: 1627:opfunc_push_class_environment (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1628:                               ecma_value_t **vm_stack_top, /**< VM stack top */
        -: 1629:                               ecma_value_t class_name) /**< class name */
        -: 1630:{
    #####: 1631:  JERRY_ASSERT (ecma_is_value_string (class_name));
    #####: 1632:  ecma_object_t *class_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1633:
        -: 1634:  /* 4.a */
        -: 1635:  ecma_property_value_t *property_value_p;
    #####: 1636:  property_value_p = ecma_create_named_data_property (class_env_p,
        -: 1637:                                                      ecma_get_string_from_value (class_name),
        -: 1638:                                                      ECMA_PROPERTY_FLAG_ENUMERABLE,
        -: 1639:                                                      NULL);
        -: 1640:
    #####: 1641:  property_value_p->value = ECMA_VALUE_UNINITIALIZED;
    #####: 1642:  frame_ctx_p->lex_env_p = class_env_p;
        -: 1643:
    #####: 1644:  *(*vm_stack_top)++ = ECMA_VALUE_RELEASE_LEX_ENV;
    #####: 1645:} /* opfunc_push_class_environment */
        -: 1646:
        -: 1647:/**
        -: 1648: * ClassDefinitionEvaluation object initialization part
        -: 1649: *
        -: 1650: * See also: ECMAScript v6, 14.5.14
        -: 1651: *
        -: 1652: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1653: *           ECMA_VALUE_EMPTY - otherwise
        -: 1654: */
        -: 1655:ecma_value_t
    #####: 1656:opfunc_init_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1657:                   ecma_value_t *stack_top_p) /**< stack top */
        -: 1658:{
        -: 1659:  /* 5.b, 6.e.ii */
    #####: 1660:  ecma_object_t *ctor_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
    #####: 1661:  ecma_object_t *proto_parent_p = NULL;
    #####: 1662:  bool free_proto_parent = false;
        -: 1663:
    #####: 1664:  ecma_value_t super_class = stack_top_p[-2];
    #####: 1665:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1666:
    #####: 1667:  bool heritage_present = !ecma_is_value_array_hole (super_class);
        -: 1668:
        -: 1669:  /* 5. ClassHeritage opt is not present */
    #####: 1670:  if (!heritage_present)
        -: 1671:  {
        -: 1672:    /* 5.a */
    #####: 1673:    proto_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -: 1674:  }
    #####: 1675:  else if (!ecma_is_value_null (super_class))
        -: 1676:  {
        -: 1677:    /* 6.f, 6.g.i */
    #####: 1678:    if (!ecma_is_constructor (super_class))
        -: 1679:    {
    #####: 1680:      return ecma_raise_type_error (ECMA_ERR_CLASS_EXTENDS_NOT_CONSTRUCTOR);
        -: 1681:    }
        -: 1682:
    #####: 1683:    ecma_object_t *parent_p = ecma_get_object_from_value (super_class);
        -: 1684:
        -: 1685:    /* 6.g.ii */
    #####: 1686:    ecma_value_t proto_parent = ecma_op_object_get_by_magic_id (parent_p, LIT_MAGIC_STRING_PROTOTYPE);
        -: 1687:
        -: 1688:    /* 6.g.iii */
    #####: 1689:    if (ECMA_IS_VALUE_ERROR (proto_parent))
        -: 1690:    {
    #####: 1691:      return proto_parent;
        -: 1692:    }
        -: 1693:
        -: 1694:    /* 6.g.iv */
    #####: 1695:    if (ecma_is_value_object (proto_parent))
        -: 1696:    {
    #####: 1697:      proto_parent_p = ecma_get_object_from_value (proto_parent);
    #####: 1698:      free_proto_parent = true;
        -: 1699:    }
    #####: 1700:    else if (ecma_is_value_null (proto_parent))
        -: 1701:    {
    #####: 1702:      proto_parent_p = NULL;
        -: 1703:    }
        -: 1704:    else
        -: 1705:    {
    #####: 1706:      ecma_free_value (proto_parent);
    #####: 1707:      return ecma_raise_type_error (ECMA_ERR_PROPERTY_PROTOTYPE_IS_NOT_AN_OBJECT);
        -: 1708:    }
        -: 1709:
        -: 1710:    /* 6.g.v */
    #####: 1711:    ctor_parent_p = parent_p;
        -: 1712:  }
        -: 1713:
        -: 1714:  /* 7. */
    #####: 1715:  ecma_object_t *proto_p = ecma_create_object (proto_parent_p, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 1716:  ecma_value_t proto = ecma_make_object_value (proto_p);
        -: 1717:
    #####: 1718:  ECMA_SET_POINTER (ctor_p->u2.prototype_cp, ctor_parent_p);
        -: 1719:
    #####: 1720:  if (free_proto_parent)
        -: 1721:  {
    #####: 1722:    ecma_deref_object (proto_parent_p);
        -: 1723:  }
    #####: 1724:  ecma_free_value (super_class);
        -: 1725:
        -: 1726:  /* 16. */
        -: 1727:  ecma_property_value_t *property_value_p;
    #####: 1728:  property_value_p = ecma_create_named_data_property (ctor_p,
        -: 1729:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_PROTOTYPE),
        -: 1730:                                                      ECMA_PROPERTY_FIXED,
        -: 1731:                                                      NULL);
    #####: 1732:  property_value_p->value = proto;
        -: 1733:
        -: 1734:  /* 18. */
    #####: 1735:  property_value_p = ecma_create_named_data_property (proto_p,
        -: 1736:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_CONSTRUCTOR),
        -: 1737:                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1738:                                                      NULL);
    #####: 1739:  property_value_p->value = ecma_make_object_value (ctor_p);
        -: 1740:
    #####: 1741:  if (ecma_get_object_type (ctor_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1742:  {
    #####: 1743:    opfunc_bind_class_environment (frame_ctx_p->lex_env_p, proto_p, ctor_p, ctor_p);
        -: 1744:
        -: 1745:    /* 15. set F’s [[ConstructorKind]] internal slot to "derived". */
    #####: 1746:    if (heritage_present)
        -: 1747:    {
    #####: 1748:      ECMA_SET_THIRD_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp);
        -: 1749:    }
        -: 1750:  }
        -: 1751:
    #####: 1752:  stack_top_p[-2] = stack_top_p[-1];
    #####: 1753:  stack_top_p[-1] = proto;
        -: 1754:
    #####: 1755:  return ECMA_VALUE_EMPTY;
        -: 1756:} /* opfunc_init_class */
        -: 1757:
        -: 1758:/**
        -: 1759: * Creates a new class lexical environment and binds the bound object and the class's object
        -: 1760: *
        -: 1761: * @return newly created class lexical environment - if func_obj_p is not present
        -: 1762: *         NULL - otherwise, also the environment is set as the func_obj_p's scope
        -: 1763: */
        -: 1764:ecma_object_t *
    #####: 1765:opfunc_bind_class_environment (ecma_object_t *lex_env_p, /**< lexical environment */
        -: 1766:                               ecma_object_t *home_object_p, /**< bound object */
        -: 1767:                               ecma_object_t *ctor_p, /**< constructor object */
        -: 1768:                               ecma_object_t *func_obj_p) /**< function object */
        -: 1769:{
    #####: 1770:  ecma_object_t *proto_env_p = ecma_create_lex_env_class (lex_env_p, sizeof (ecma_lexical_environment_class_t));
    #####: 1771:  ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, home_object_p);
    #####: 1772:  ((ecma_lexical_environment_class_t *) proto_env_p)->object_p = ctor_p;
    #####: 1773:  ((ecma_lexical_environment_class_t *) proto_env_p)->type = ECMA_LEX_ENV_CLASS_TYPE_CLASS_ENV;
        -: 1774:
    #####: 1775:  if (func_obj_p)
        -: 1776:  {
    #####: 1777:    JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);
    #####: 1778:    ECMA_SET_NON_NULL_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp, proto_env_p, 0);
    #####: 1779:    ecma_deref_object (proto_env_p);
    #####: 1780:    return NULL;
        -: 1781:  }
        -: 1782:
    #####: 1783:  return proto_env_p;
        -: 1784:} /* opfunc_bind_class_environment */
        -: 1785:
        -: 1786:/**
        -: 1787: * Set [[Enumerable]] and [[HomeObject]] attributes for all class method
        -: 1788: */
        -: 1789:static void
    #####: 1790:opfunc_set_class_attributes (ecma_object_t *obj_p, /**< object */
        -: 1791:                             ecma_object_t *parent_env_p) /**< parent environment */
        -: 1792:{
    #####: 1793:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 1794:
        -: 1795:#if JERRY_PROPERTY_HASHMAP
    #####: 1796:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 1797:  {
    #####: 1798:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1799:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 1800:    {
    #####: 1801:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1802:    }
        -: 1803:  }
        -: 1804:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 1805:
    #####: 1806:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 1807:  {
    #####: 1808:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1809:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 1810:
    #####: 1811:    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 1812:
    #####: 1813:    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)
        -: 1814:    {
    #####: 1815:      uint8_t property = property_pair_p->header.types[index];
        -: 1816:
    #####: 1817:      if (!ECMA_PROPERTY_IS_RAW (property))
        -: 1818:      {
    #####: 1819:        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED
        -: 1820:                      || (ECMA_PROPERTY_IS_INTERNAL (property)
        -: 1821:                          && LIT_INTERNAL_MAGIC_STRING_IGNORED (property_pair_p->names_cp[index])));
    #####: 1822:        continue;
        -: 1823:      }
        -: 1824:
    #####: 1825:      if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1826:      {
    #####: 1827:        if (ecma_is_value_object (property_pair_p->values[index].value) && ecma_is_property_enumerable (property))
        -: 1828:        {
    #####: 1829:          property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1830:          opfunc_set_home_object (ecma_get_object_from_value (property_pair_p->values[index].value), parent_env_p);
        -: 1831:        }
    #####: 1832:        continue;
        -: 1833:      }
        -: 1834:
    #####: 1835:      property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1836:      ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;
        -: 1837:
    #####: 1838:      ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -: 1839:
    #####: 1840:      if (get_set_pair_p->getter_cp != JMEM_CP_NULL)
        -: 1841:      {
    #####: 1842:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp), parent_env_p);
        -: 1843:      }
        -: 1844:
    #####: 1845:      if (get_set_pair_p->setter_cp != JMEM_CP_NULL)
        -: 1846:      {
    #####: 1847:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp), parent_env_p);
        -: 1848:      }
        -: 1849:    }
        -: 1850:
    #####: 1851:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1852:  }
    #####: 1853:} /* opfunc_set_class_attributes */
        -: 1854:
        -: 1855:/**
        -: 1856: * Set [[HomeObject]] attributes for all class private elements
        -: 1857: */
        -: 1858:static void
    #####: 1859:opfunc_set_private_instance_method_attributes (ecma_object_t *class_object_p, /**< class constructor  */
        -: 1860:                                               ecma_object_t *parent_env_p) /**< parent environment */
        -: 1861:{
    #####: 1862:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1863:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1864:
    #####: 1865:  if (prop_p == NULL)
        -: 1866:  {
    #####: 1867:    return;
        -: 1868:  }
        -: 1869:
    #####: 1870:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1871:  ecma_value_t *current_p = collection_p + 1;
    #####: 1872:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1873:
    #####: 1874:  while (current_p < end_p)
        -: 1875:  {
    #####: 1876:    current_p += 2; /* skip kind, name */
    #####: 1877:    ecma_value_t value = *current_p++;
        -: 1878:
    #####: 1879:    if (!ecma_is_value_undefined (value))
        -: 1880:    {
    #####: 1881:      opfunc_set_home_object (ecma_get_object_from_value (value), parent_env_p);
        -: 1882:    }
        -: 1883:  }
        -: 1884:} /* opfunc_set_private_instance_method_attributes */
        -: 1885:
        -: 1886:/**
        -: 1887: * Pop the current lexical environment referenced by the frame context
        -: 1888: */
        -: 1889:void
    #####: 1890:opfunc_pop_lexical_environment (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1891:{
    #####: 1892:  ecma_object_t *outer_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, frame_ctx_p->lex_env_p->u2.outer_reference_cp);
    #####: 1893:  ecma_deref_object (frame_ctx_p->lex_env_p);
    #####: 1894:  frame_ctx_p->lex_env_p = outer_env_p;
    #####: 1895:} /* opfunc_pop_lexical_environment */
        -: 1896:
        -: 1897:/**
        -: 1898: * ClassDefinitionEvaluation finalization part
        -: 1899: *
        -: 1900: * See also: ECMAScript v6, 14.5.14
        -: 1901: */
        -: 1902:void
    #####: 1903:opfunc_finalize_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1904:                       ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1905:                       ecma_value_t class_name) /**< class name */
        -: 1906:{
    #####: 1907:  JERRY_ASSERT (ecma_is_value_undefined (class_name) || ecma_is_value_string (class_name));
    #####: 1908:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1909:
    #####: 1910:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1911:  ecma_object_t *proto_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1912:
    #####: 1913:  ecma_object_t *class_env_p = frame_ctx_p->lex_env_p;
        -: 1914:
        -: 1915:  /* 23.a */
    #####: 1916:  if (!ecma_is_value_undefined (class_name))
        -: 1917:  {
    #####: 1918:    ecma_op_initialize_binding (class_env_p, ecma_get_string_from_value (class_name), stack_top_p[-2]);
        -: 1919:  }
        -: 1920:
    #####: 1921:  ecma_object_t *ctor_env_p = opfunc_bind_class_environment (class_env_p, ctor_p, ctor_p, NULL);
    #####: 1922:  ecma_object_t *proto_env_p = opfunc_bind_class_environment (class_env_p, proto_p, ctor_p, NULL);
        -: 1923:
    #####: 1924:  opfunc_set_class_attributes (ctor_p, ctor_env_p);
    #####: 1925:  opfunc_set_class_attributes (proto_p, proto_env_p);
    #####: 1926:  opfunc_set_private_instance_method_attributes (ctor_p, proto_env_p);
        -: 1927:
    #####: 1928:  ecma_deref_object (proto_env_p);
    #####: 1929:  ecma_deref_object (ctor_env_p);
    #####: 1930:  ecma_deref_object (proto_p);
        -: 1931:
    #####: 1932:  JERRY_ASSERT ((ecma_is_value_undefined (class_name) ? stack_top_p[-3] == ECMA_VALUE_UNDEFINED
        -: 1933:                                                      : stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV));
        -: 1934:
        -: 1935:  /* only the current class remains on the stack */
    #####: 1936:  if (stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 1937:  {
    #####: 1938:    opfunc_pop_lexical_environment (frame_ctx_p);
        -: 1939:  }
        -: 1940:
    #####: 1941:  ecma_value_t result = opfunc_private_method_or_accessor_add (ctor_p, ctor_p, ECMA_PRIVATE_PROPERTY_STATIC_FLAG);
    #####: 1942:  JERRY_ASSERT (ecma_is_value_undefined (result));
        -: 1943:
    #####: 1944:  stack_top_p[-3] = stack_top_p[-2];
    #####: 1945:  *vm_stack_top_p -= 2;
    #####: 1946:} /* opfunc_finalize_class */
        -: 1947:
        -: 1948:/**
        -: 1949: * MakeSuperPropertyReference operation
        -: 1950: *
        -: 1951: * See also: ECMAScript v6, 12.3.5.3
        -: 1952: *
        -: 1953: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1954: *         ECMA_VALUE_EMPTY - otherwise
        -: 1955: */
        -: 1956:ecma_value_t
    #####: 1957:opfunc_form_super_reference (ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1958:                             vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1959:                             ecma_value_t prop_name, /**< property name to resolve */
        -: 1960:                             uint8_t opcode) /**< current cbc opcode */
        -: 1961:{
    #####: 1962:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -: 1963:
    #####: 1964:  if (environment_record_p && !ecma_op_this_binding_is_initialized (environment_record_p))
        -: 1965:  {
    #####: 1966:    return ecma_raise_reference_error (ECMA_ERR_CALL_SUPER_CONSTRUCTOR_DERIVED_CLASS_BEFORE_THIS);
        -: 1967:  }
        -: 1968:
    #####: 1969:  ecma_value_t parent = ecma_op_resolve_super_base (frame_ctx_p->lex_env_p);
        -: 1970:
    #####: 1971:  if (ECMA_IS_VALUE_ERROR (parent))
        -: 1972:  {
    #####: 1973:    return ecma_raise_type_error (ECMA_ERR_INVOKE_NULLABLE_SUPER_METHOD);
        -: 1974:  }
        -: 1975:
    #####: 1976:  if (!ecma_op_require_object_coercible (parent))
        -: 1977:  {
    #####: 1978:    return ECMA_VALUE_ERROR;
        -: 1979:  }
        -: 1980:
    #####: 1981:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1982:
    #####: 1983:  if (opcode >= CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE)
        -: 1984:  {
    #####: 1985:    JERRY_ASSERT (opcode == CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE
        -: 1986:                  || opcode == CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 1987:    *stack_top_p++ = parent;
    #####: 1988:    *stack_top_p++ = ecma_copy_value (prop_name);
    #####: 1989:    *vm_stack_top_p = stack_top_p;
        -: 1990:
    #####: 1991:    return ECMA_VALUE_EMPTY;
        -: 1992:  }
        -: 1993:
    #####: 1994:  ecma_object_t *parent_p = ecma_get_object_from_value (parent);
    #####: 1995:  ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name);
        -: 1996:
    #####: 1997:  if (prop_name_p == NULL)
        -: 1998:  {
    #####: 1999:    ecma_deref_object (parent_p);
    #####: 2000:    return ECMA_VALUE_ERROR;
        -: 2001:  }
        -: 2002:
    #####: 2003:  ecma_value_t result = ecma_op_object_get_with_receiver (parent_p, prop_name_p, frame_ctx_p->this_binding);
    #####: 2004:  ecma_deref_ecma_string (prop_name_p);
    #####: 2005:  ecma_deref_object (parent_p);
        -: 2006:
    #####: 2007:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2008:  {
    #####: 2009:    return result;
        -: 2010:  }
        -: 2011:
    #####: 2012:  if (opcode == CBC_EXT_SUPER_PROP_LITERAL_REFERENCE || opcode == CBC_EXT_SUPER_PROP_REFERENCE)
        -: 2013:  {
    #####: 2014:    *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2015:    *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2016:  }
        -: 2017:
    #####: 2018:  *stack_top_p++ = result;
    #####: 2019:  *vm_stack_top_p = stack_top_p;
        -: 2020:
    #####: 2021:  return ECMA_VALUE_EMPTY;
        -: 2022:} /* opfunc_form_super_reference */
        -: 2023:
        -: 2024:/**
        -: 2025: * Assignment operation for SuperRefence base
        -: 2026: *
        -: 2027: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2028: *         ECMA_VALUE_EMPTY - otherwise
        -: 2029: */
        -: 2030:ecma_value_t
    #####: 2031:opfunc_assign_super_reference (ecma_value_t **vm_stack_top_p, /**< vm stack top */
        -: 2032:                               vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 2033:                               uint32_t opcode_data) /**< opcode data to store the result */
        -: 2034:{
    #####: 2035:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 2036:
    #####: 2037:  ecma_value_t base_obj = ecma_op_to_object (stack_top_p[-3]);
        -: 2038:
    #####: 2039:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 2040:  {
    #####: 2041:    return base_obj;
        -: 2042:  }
        -: 2043:
    #####: 2044:  ecma_object_t *base_obj_p = ecma_get_object_from_value (base_obj);
    #####: 2045:  ecma_string_t *prop_name_p = ecma_op_to_property_key (stack_top_p[-2]);
        -: 2046:
    #####: 2047:  if (prop_name_p == NULL)
        -: 2048:  {
    #####: 2049:    ecma_deref_object (base_obj_p);
    #####: 2050:    return ECMA_VALUE_ERROR;
        -: 2051:  }
        -: 2052:
    #####: 2053:  bool is_strict = (frame_ctx_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0;
        -: 2054:
    #####: 2055:  ecma_value_t result =
    #####: 2056:    ecma_op_object_put_with_receiver (base_obj_p, prop_name_p, stack_top_p[-1], frame_ctx_p->this_binding, is_strict);
        -: 2057:
    #####: 2058:  ecma_deref_ecma_string (prop_name_p);
    #####: 2059:  ecma_deref_object (base_obj_p);
        -: 2060:
    #####: 2061:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2062:  {
    #####: 2063:    return result;
        -: 2064:  }
        -: 2065:
    #####: 2066:  for (int32_t i = 1; i <= 3; i++)
        -: 2067:  {
    #####: 2068:    ecma_free_value (stack_top_p[-i]);
        -: 2069:  }
        -: 2070:
    #####: 2071:  stack_top_p -= 3;
        -: 2072:
    #####: 2073:  if (opcode_data & VM_OC_PUT_STACK)
        -: 2074:  {
    #####: 2075:    *stack_top_p++ = result;
        -: 2076:  }
    #####: 2077:  else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2078:  {
    #####: 2079:    ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 2080:    VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 2081:  }
        -: 2082:
    #####: 2083:  *vm_stack_top_p = stack_top_p;
        -: 2084:
    #####: 2085:  return result;
        -: 2086:} /* opfunc_assign_super_reference */
        -: 2087:
        -: 2088:/**
        -: 2089: * Copy data properties of an object
        -: 2090: *
        -: 2091: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2092: *         ECMA_VALUE_EMPTY - otherwise
        -: 2093: */
        -: 2094:ecma_value_t
    #####: 2095:opfunc_copy_data_properties (ecma_value_t target_object, /**< target object */
        -: 2096:                             ecma_value_t source_object, /**< source object */
        -: 2097:                             ecma_value_t filter_array) /**< filter array */
        -: 2098:{
    #####: 2099:  bool source_to_object = false;
        -: 2100:
    #####: 2101:  if (!ecma_is_value_object (source_object))
        -: 2102:  {
    #####: 2103:    source_object = ecma_op_to_object (source_object);
        -: 2104:
    #####: 2105:    if (ECMA_IS_VALUE_ERROR (source_object))
        -: 2106:    {
    #####: 2107:      return source_object;
        -: 2108:    }
        -: 2109:
    #####: 2110:    source_to_object = true;
        -: 2111:  }
        -: 2112:
    #####: 2113:  ecma_object_t *source_object_p = ecma_get_object_from_value (source_object);
    #####: 2114:  ecma_collection_t *names_p = ecma_op_object_own_property_keys (source_object_p, JERRY_PROPERTY_FILTER_ALL);
        -: 2115:
        -: 2116:#if JERRY_BUILTIN_PROXY
    #####: 2117:  if (names_p == NULL)
        -: 2118:  {
    #####: 2119:    JERRY_ASSERT (!source_to_object);
    #####: 2120:    return ECMA_VALUE_ERROR;
        -: 2121:  }
        -: 2122:#endif /* JERRY_BUILTIN_PROXY */
        -: 2123:
    #####: 2124:  ecma_object_t *target_object_p = ecma_get_object_from_value (target_object);
    #####: 2125:  ecma_value_t *buffer_p = names_p->buffer_p;
    #####: 2126:  ecma_value_t *buffer_end_p = buffer_p + names_p->item_count;
    #####: 2127:  ecma_value_t *filter_start_p = NULL;
    #####: 2128:  ecma_value_t *filter_end_p = NULL;
    #####: 2129:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 2130:
    #####: 2131:  if (filter_array != ECMA_VALUE_UNDEFINED)
        -: 2132:  {
    #####: 2133:    ecma_object_t *filter_array_p = ecma_get_object_from_value (filter_array);
        -: 2134:
    #####: 2135:    JERRY_ASSERT (ecma_get_object_type (filter_array_p) == ECMA_OBJECT_TYPE_ARRAY);
    #####: 2136:    JERRY_ASSERT (ecma_op_object_is_fast_array (filter_array_p));
        -: 2137:
    #####: 2138:    if (filter_array_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2139:    {
    #####: 2140:      filter_start_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, filter_array_p->u1.property_list_cp);
    #####: 2141:      filter_end_p = filter_start_p + ((ecma_extended_object_t *) filter_array_p)->u.array.length;
        -: 2142:    }
        -: 2143:  }
        -: 2144:
    #####: 2145:  while (buffer_p < buffer_end_p)
        -: 2146:  {
    #####: 2147:    ecma_string_t *property_name_p = ecma_get_prop_name_from_value (*buffer_p++);
        -: 2148:
    #####: 2149:    if (filter_start_p != NULL)
        -: 2150:    {
    #####: 2151:      ecma_value_t *filter_p = filter_start_p;
        -: 2152:
        -: 2153:      do
        -: 2154:      {
    #####: 2155:        if (ecma_compare_ecma_strings (property_name_p, ecma_get_prop_name_from_value (*filter_p)))
        -: 2156:        {
    #####: 2157:          break;
        -: 2158:        }
    #####: 2159:      } while (++filter_p < filter_end_p);
        -: 2160:
    #####: 2161:      if (filter_p != filter_end_p)
        -: 2162:      {
    #####: 2163:        continue;
        -: 2164:      }
        -: 2165:    }
        -: 2166:
    #####: 2167:    ecma_property_descriptor_t descriptor;
    #####: 2168:    result = ecma_op_object_get_own_property_descriptor (source_object_p, property_name_p, &descriptor);
        -: 2169:
    #####: 2170:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2171:    {
    #####: 2172:      break;
        -: 2173:    }
        -: 2174:
    #####: 2175:    if (result == ECMA_VALUE_FALSE)
        -: 2176:    {
    #####: 2177:      continue;
        -: 2178:    }
        -: 2179:
    #####: 2180:    if (!(descriptor.flags & JERRY_PROP_IS_ENUMERABLE))
        -: 2181:    {
    #####: 2182:      ecma_free_property_descriptor (&descriptor);
    #####: 2183:      continue;
        -: 2184:    }
        -: 2185:
    #####: 2186:    if ((descriptor.flags & JERRY_PROP_IS_VALUE_DEFINED) && !ECMA_OBJECT_IS_PROXY (source_object_p))
        -: 2187:    {
    #####: 2188:      result = descriptor.value;
        -: 2189:    }
        -: 2190:    else
        -: 2191:    {
    #####: 2192:      ecma_free_property_descriptor (&descriptor);
        -: 2193:
    #####: 2194:      result = ecma_op_object_get (source_object_p, property_name_p);
        -: 2195:
    #####: 2196:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2197:      {
    #####: 2198:        break;
        -: 2199:      }
        -: 2200:    }
        -: 2201:
    #####: 2202:    opfunc_set_data_property (target_object_p, property_name_p, result);
    #####: 2203:    ecma_free_value (result);
        -: 2204:
    #####: 2205:    result = ECMA_VALUE_EMPTY;
        -: 2206:  }
        -: 2207:
    #####: 2208:  if (JERRY_UNLIKELY (source_to_object))
        -: 2209:  {
    #####: 2210:    ecma_deref_object (source_object_p);
        -: 2211:  }
        -: 2212:
    #####: 2213:  ecma_collection_free (names_p);
    #####: 2214:  return result;
        -: 2215:} /* opfunc_copy_data_properties */
        -: 2216:
        -: 2217:/**
        -: 2218: * Check whether the current lexical scope has restricted binding declaration with the given name
        -: 2219: *
        -: 2220: * Steps are include ES11: 8.1.1.4.14 HasRestrictedGlobalProperty abstract operation
        -: 2221: *
        -: 2222: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2223: *         ECMA_VALUE_TRUE - if it has restricted property binding
        -: 2224: *         ECMA_VALUE_FALSE - otherwise
        -: 2225: */
        -: 2226:ecma_value_t
    #####: 2227:opfunc_lexical_scope_has_restricted_binding (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 2228:                                             ecma_string_t *name_p) /**< binding name */
        -: 2229:{
    #####: 2230:  JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 2231:
        -: 2232:#if JERRY_BUILTIN_REALMS
    #####: 2233:  JERRY_ASSERT (frame_ctx_p->this_binding == JERRY_CONTEXT (global_object_p)->this_binding);
        -: 2234:#else /* !JERRY_BUILTIN_REALMS */
        -: 2235:  JERRY_ASSERT (frame_ctx_p->this_binding == ecma_builtin_get_global ());
        -: 2236:#endif /* JERRY_BUILTIN_REALMS */
        -: 2237:
    #####: 2238:  ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 2239:  ecma_property_t *binding_p = ecma_find_named_property (lex_env_p, name_p);
        -: 2240:
    #####: 2241:  if (binding_p != NULL)
        -: 2242:  {
    #####: 2243:    return ECMA_VALUE_TRUE;
        -: 2244:  }
        -: 2245:
        -: 2246:#if JERRY_BUILTIN_REALMS
    #####: 2247:  ecma_object_t *const global_scope_p = ecma_get_global_scope ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
        -: 2248:#else /* !JERRY_BUILTIN_REALMS */
        -: 2249:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -: 2250:#endif /* JERRY_BUILTIN_REALMS */
        -: 2251:
    #####: 2252:  if (global_scope_p != lex_env_p)
        -: 2253:  {
    #####: 2254:    return ECMA_VALUE_FALSE;
        -: 2255:  }
        -: 2256:
    #####: 2257:  ecma_object_t *global_obj_p = ecma_get_object_from_value (frame_ctx_p->this_binding);
        -: 2258:
        -: 2259:#if JERRY_BUILTIN_PROXY
    #####: 2260:  if (ECMA_OBJECT_IS_PROXY (global_obj_p))
        -: 2261:  {
    #####: 2262:    ecma_property_descriptor_t prop_desc;
    #####: 2263:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (global_obj_p, name_p, &prop_desc);
        -: 2264:
    #####: 2265:    if (ecma_is_value_true (status))
        -: 2266:    {
    #####: 2267:      status = ecma_make_boolean_value ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE) == 0);
    #####: 2268:      ecma_free_property_descriptor (&prop_desc);
        -: 2269:    }
        -: 2270:
    #####: 2271:    return status;
        -: 2272:  }
        -: 2273:#endif /* JERRY_BUILTIN_PROXY */
        -: 2274:
    #####: 2275:  ecma_property_t property = ecma_op_object_get_own_property (global_obj_p, name_p, NULL, ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 2276:
    #####: 2277:  JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_NOT_FOUND || ECMA_PROPERTY_IS_FOUND (property));
        -: 2278:
    #####: 2279:  return ecma_make_boolean_value (property != ECMA_PROPERTY_TYPE_NOT_FOUND
    #####: 2280:                                  && !ecma_is_property_configurable (property));
        -: 2281:} /* opfunc_lexical_scope_has_restricted_binding */
        -: 2282:
        -: 2283:#endif /* JERRY_ESNEXT */
        -: 2284:
        -: 2285:/**
        -: 2286: * @}
        -: 2287: * @}
        -: 2288: */
