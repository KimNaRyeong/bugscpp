        -:    0:Source:/home/workspace/tests/unit-core/test-objects-foreach.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:
        -:   18:#include "test-common.h"
        -:   19:
        -:   20:static bool
    #####:   21:count_objects (jerry_value_t object, void *user_arg)
        -:   22:{
        -:   23:  (void) object;
    #####:   24:  TEST_ASSERT (user_arg != NULL);
        -:   25:
    #####:   26:  int *counter = (int *) user_arg;
        -:   27:
    #####:   28:  (*counter)++;
    #####:   29:  return true;
        -:   30:} /* count_objects */
        -:   31:
        -:   32:static void
    #####:   33:test_container (void)
        -:   34:{
    #####:   35:  jerry_value_t global = jerry_current_realm ();
    #####:   36:  jerry_value_t map_str = jerry_string_sz ("Map");
    #####:   37:  jerry_value_t map_result = jerry_object_get (global, map_str);
    #####:   38:  jerry_type_t type = jerry_value_type (map_result);
        -:   39:
    #####:   40:  jerry_value_free (map_result);
    #####:   41:  jerry_value_free (map_str);
    #####:   42:  jerry_value_free (global);
        -:   43:
        -:   44:  /* If there is no Map function this is not an es.next profile build, skip this test case. */
    #####:   45:  if (type != JERRY_TYPE_FUNCTION)
        -:   46:  {
    #####:   47:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Container based test is disabled!\n");
    #####:   48:    return;
        -:   49:  }
        -:   50:
        -:   51:  {
        -:   52:    /* Create a "DEMO" array which will be used for the Map below. */
    #####:   53:    const char array_str[] = "var DEMO = [[1, 2], [3, 4]]; DEMO";
    #####:   54:    jerry_value_t array = jerry_eval ((const jerry_char_t *) array_str, sizeof (array_str) - 1, 0);
    #####:   55:    TEST_ASSERT (jerry_value_is_object (array));
    #####:   56:    TEST_ASSERT (!jerry_value_is_exception (array));
    #####:   57:    jerry_value_free (array);
        -:   58:  }
        -:   59:
    #####:   60:  const char eval_str[] = "new Map (DEMO)";
        -:   61:  {
        -:   62:    /* Make sure that the Map and it's prototype object/function is initialized. */
    #####:   63:    jerry_value_t result = jerry_eval ((const jerry_char_t *) eval_str, sizeof (eval_str) - 1, 0);
    #####:   64:    TEST_ASSERT (jerry_value_is_object (result));
    #####:   65:    TEST_ASSERT (!jerry_value_is_exception (result));
    #####:   66:    jerry_value_free (result);
        -:   67:  }
        -:   68:
        -:   69:  /* Do a bit of cleaning to clear up old objects. */
    #####:   70:  jerry_heap_gc (JERRY_GC_PRESSURE_LOW);
        -:   71:
        -:   72:  /* Get the number of iterable objects. */
    #####:   73:  int start_count = 0;
    #####:   74:  jerry_foreach_live_object (count_objects, &start_count);
        -:   75:
        -:   76:  /* Create another map. */
    #####:   77:  jerry_value_t result = jerry_eval ((const jerry_char_t *) eval_str, sizeof (eval_str) - 1, 0);
        -:   78:
        -:   79:  /* Remove any old/unused objects. */
    #####:   80:  jerry_heap_gc (JERRY_GC_PRESSURE_LOW);
        -:   81:
        -:   82:  /* Get the current number of objects. */
    #####:   83:  int end_count = 0;
    #####:   84:  jerry_foreach_live_object (count_objects, &end_count);
        -:   85:
        -:   86:  /* As only one Map was created the number of available iterable objects should be incremented only by one. */
    #####:   87:  TEST_ASSERT (end_count > start_count);
    #####:   88:  TEST_ASSERT ((end_count - start_count) == 1);
        -:   89:
    #####:   90:  jerry_value_free (result);
        -:   91:} /* test_container */
        -:   92:
        -:   93:static void
    #####:   94:test_internal_prop (void)
        -:   95:{
        -:   96:  /* Make sure that the object is initialized in the engine. */
    #####:   97:  jerry_value_t object_dummy = jerry_object ();
        -:   98:
        -:   99:  /* Get the number of iterable objects. */
    #####:  100:  int before_object_count = 0;
    #####:  101:  jerry_foreach_live_object (count_objects, &before_object_count);
        -:  102:
    #####:  103:  jerry_value_t object = jerry_object ();
        -:  104:
        -:  105:  /* After creating the object, the number of objects is incremented by one. */
    #####:  106:  int after_object_count = 0;
        -:  107:  {
    #####:  108:    jerry_foreach_live_object (count_objects, &after_object_count);
        -:  109:
    #####:  110:    TEST_ASSERT (after_object_count > before_object_count);
    #####:  111:    TEST_ASSERT ((after_object_count - before_object_count) == 1);
        -:  112:  }
        -:  113:
    #####:  114:  jerry_value_t internal_prop_name = jerry_string_sz ("hidden_foo");
    #####:  115:  jerry_value_t internal_prop_object = jerry_object ();
    #####:  116:  bool internal_result = jerry_object_set_internal (object, internal_prop_name, internal_prop_object);
    #####:  117:  TEST_ASSERT (internal_result == true);
    #####:  118:  jerry_value_free (internal_prop_name);
    #####:  119:  jerry_value_free (internal_prop_object);
        -:  120:
        -:  121:  /* After adding an internal property object, the number of object is incremented by one. */
        -:  122:  {
    #####:  123:    int after_internal_count = 0;
    #####:  124:    jerry_foreach_live_object (count_objects, &after_internal_count);
        -:  125:
    #####:  126:    TEST_ASSERT (after_internal_count > after_object_count);
    #####:  127:    TEST_ASSERT ((after_internal_count - after_object_count) == 1);
        -:  128:  }
        -:  129:
    #####:  130:  jerry_value_free (object);
    #####:  131:  jerry_value_free (object_dummy);
    #####:  132:} /* test_internal_prop */
        -:  133:
        -:  134:static int test_data = 1;
        -:  135:
        -:  136:static void
    #####:  137:free_test_data (void *native_p, /**< native pointer */
        -:  138:                jerry_object_native_info_t *info_p) /**< native info */
        -:  139:{
    #####:  140:  TEST_ASSERT ((int *) native_p == &test_data);
    #####:  141:  TEST_ASSERT (info_p->free_cb == free_test_data);
    #####:  142:} /* free_test_data */
        -:  143:
        -:  144:static const jerry_object_native_info_t test_info = {
        -:  145:  .free_cb = free_test_data,
        -:  146:  .number_of_references = 0,
        -:  147:  .offset_of_references = 0,
        -:  148:};
        -:  149:
        -:  150:static const jerry_char_t strict_equal_source[] = "var x = function(a, b) {return a === b;}; x";
        -:  151:
        -:  152:static bool
    #####:  153:find_test_object_by_data (const jerry_value_t candidate, void *object_data_p, void *context_p)
        -:  154:{
    #####:  155:  if (object_data_p == &test_data)
        -:  156:  {
    #####:  157:    *((jerry_value_t *) context_p) = jerry_value_copy (candidate);
    #####:  158:    return false;
        -:  159:  }
        -:  160:  return true;
        -:  161:} /* find_test_object_by_data */
        -:  162:
        -:  163:static bool
    #####:  164:find_test_object_by_property (const jerry_value_t candidate, void *context_p)
        -:  165:{
    #####:  166:  jerry_value_t *args_p = (jerry_value_t *) context_p;
    #####:  167:  jerry_value_t result = jerry_object_has (candidate, args_p[0]);
        -:  168:
    #####:  169:  bool has_property = (!jerry_value_is_exception (result) && jerry_value_is_true (result));
        -:  170:
        -:  171:  /* If the object has the desired property, store a new reference to it in args_p[1]. */
    #####:  172:  if (has_property)
        -:  173:  {
    #####:  174:    args_p[1] = jerry_value_copy (candidate);
        -:  175:  }
        -:  176:
    #####:  177:  jerry_value_free (result);
        -:  178:
        -:  179:  /* Stop iterating if we've found our object. */
    #####:  180:  return !has_property;
        -:  181:} /* find_test_object_by_property */
        -:  182:
        -:  183:int
    #####:  184:main (void)
        -:  185:{
    #####:  186:  jerry_init (JERRY_INIT_EMPTY);
        -:  187:
        -:  188:  jerry_parse_options_t parse_options;
    #####:  189:  parse_options.options = JERRY_PARSE_STRICT_MODE;
        -:  190:
        -:  191:  /* Render strict-equal as a function. */
    #####:  192:  jerry_value_t parse_result = jerry_parse (strict_equal_source, sizeof (strict_equal_source) - 1, &parse_options);
    #####:  193:  TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  194:  jerry_value_t strict_equal = jerry_run (parse_result);
    #####:  195:  TEST_ASSERT (!jerry_value_is_exception (strict_equal));
    #####:  196:  jerry_value_free (parse_result);
        -:  197:
        -:  198:  /* Create an object and associate some native data with it. */
    #####:  199:  jerry_value_t object = jerry_object ();
    #####:  200:  jerry_object_set_native_ptr (object, &test_info, &test_data);
        -:  201:
        -:  202:  /* Retrieve the object by its native pointer. */
        -:  203:
        -:  204:  jerry_value_t found_object;
    #####:  205:  TEST_ASSERT (jerry_foreach_live_object_with_info (&test_info, find_test_object_by_data, &found_object));
    #####:  206:  jerry_value_t args[2] = { object, found_object };
        -:  207:
        -:  208:  /* Assert that the correct object was retrieved. */
    #####:  209:  jerry_value_t undefined = jerry_undefined ();
    #####:  210:  jerry_value_t strict_equal_result = jerry_call (strict_equal, undefined, args, 2);
    #####:  211:  TEST_ASSERT (jerry_value_is_boolean (strict_equal_result) && jerry_value_is_true (strict_equal_result));
    #####:  212:  jerry_value_free (strict_equal_result);
    #####:  213:  jerry_value_free (found_object);
    #####:  214:  jerry_value_free (object);
        -:  215:
        -:  216:  /* Collect garbage. */
    #####:  217:  jerry_heap_gc (JERRY_GC_PRESSURE_LOW);
        -:  218:
        -:  219:  /* Attempt to retrieve the object by its native pointer again. */
    #####:  220:  TEST_ASSERT (!jerry_foreach_live_object_with_info (&test_info, find_test_object_by_data, &found_object));
        -:  221:
        -:  222:  /* Create an object and set a property on it. */
    #####:  223:  object = jerry_object ();
    #####:  224:  jerry_value_t property_name = jerry_string_sz ("xyzzy");
    #####:  225:  jerry_value_t property_value = jerry_number (42);
    #####:  226:  jerry_value_free (jerry_object_set (object, property_name, property_value));
    #####:  227:  jerry_value_free (property_value);
        -:  228:
        -:  229:  /* Retrieve the object by the presence of its property, placing it at args[1]. */
    #####:  230:  args[0] = property_name;
    #####:  231:  TEST_ASSERT (jerry_foreach_live_object (find_test_object_by_property, args));
        -:  232:
        -:  233:  /* Assert that the right object was retrieved and release both the original reference to it and the retrieved one. */
    #####:  234:  args[0] = object;
    #####:  235:  strict_equal_result = jerry_call (strict_equal, undefined, args, 2);
    #####:  236:  TEST_ASSERT (jerry_value_is_boolean (strict_equal_result) && jerry_value_is_true (strict_equal_result));
    #####:  237:  jerry_value_free (strict_equal_result);
    #####:  238:  jerry_value_free (args[0]);
    #####:  239:  jerry_value_free (args[1]);
        -:  240:
        -:  241:  /* Collect garbage. */
    #####:  242:  jerry_heap_gc (JERRY_GC_PRESSURE_LOW);
        -:  243:
        -:  244:  /* Attempt to retrieve the object by the presence of its property again. */
    #####:  245:  args[0] = property_name;
    #####:  246:  TEST_ASSERT (!jerry_foreach_live_object (find_test_object_by_property, args));
        -:  247:
    #####:  248:  jerry_value_free (property_name);
    #####:  249:  jerry_value_free (undefined);
    #####:  250:  jerry_value_free (strict_equal);
        -:  251:
    #####:  252:  test_container ();
    #####:  253:  test_internal_prop ();
        -:  254:
    #####:  255:  jerry_cleanup ();
        -:  256:
        -:  257:  return 0;
        -:  258:} /* main */
