        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-array-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-array-object.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-property-hashmap.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmaarrayobject ECMA Array object related routines
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Property name type flag for array indices.
        -:   40: */
        -:   41:#define ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE (ECMA_DIRECT_STRING_UINT << ECMA_PROPERTY_NAME_TYPE_SHIFT)
        -:   42:
        -:   43:/**
        -:   44: * Allocate a new array object with the given length
        -:   45: *
        -:   46: * @return pointer to the constructed array object
        -:   47: */
        -:   48:static ecma_object_t *
    #####:   49:ecma_op_alloc_array_object (uint32_t length) /**< length of the new array */
        -:   50:{
        -:   51:#if JERRY_BUILTIN_ARRAY
    #####:   52:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);
        -:   53:#else /* !JERRY_BUILTIN_ARRAY */
        -:   54:  ecma_object_t *array_prototype_object_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -:   55:#endif /* JERRY_BUILTIN_ARRAY */
        -:   56:
    #####:   57:  ecma_object_t *object_p =
        -:   58:    ecma_create_object (array_prototype_object_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_ARRAY);
        -:   59:
        -:   60:  /*
        -:   61:   * [[Class]] property is not stored explicitly for objects of ECMA_OBJECT_TYPE_ARRAY type.
        -:   62:   *
        -:   63:   * See also: ecma_object_get_class_name
        -:   64:   */
        -:   65:
    #####:   66:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:   67:  ext_obj_p->u.array.length = length;
    #####:   68:  ext_obj_p->u.array.length_prop_and_hole_count = ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:   69:
    #####:   70:  return object_p;
        -:   71:} /* ecma_op_alloc_array_object */
        -:   72:
        -:   73:/**
        -:   74: * Check whether the given object is fast-access mode array
        -:   75: *
        -:   76: * @return true - if the object is fast-access mode array
        -:   77: *         false, otherwise
        -:   78: */
        -:   79:extern inline bool JERRY_ATTR_ALWAYS_INLINE
       35:   80:ecma_op_object_is_fast_array (ecma_object_t *object_p) /**< ecma-object */
        -:   81:{
       35:   82:  return (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY
       35:   83:          && ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p));
        -:   84:} /* ecma_op_object_is_fast_array */
        -:   85:
        -:   86:/**
        -:   87: * Check whether the given array object is fast-access mode array
        -:   88: *
        -:   89: * @return true - if the array object is fast-access mode array
        -:   90: *         false, otherwise
        -:   91: */
        -:   92:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####:   93:ecma_op_array_is_fast_array (ecma_extended_object_t *array_p) /**< ecma-array-object */
        -:   94:{
    #####:   95:  JERRY_ASSERT (ecma_get_object_base_type ((ecma_object_t *) array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:   96:
    #####:   97:  return array_p->u.array.length_prop_and_hole_count & ECMA_FAST_ARRAY_FLAG;
        -:   98:} /* ecma_op_array_is_fast_array */
        -:   99:
        -:  100:/**
        -:  101: * Allocate a new array object with the given length
        -:  102: *
        -:  103: * Note: The returned array can be normal of fast access mode
        -:  104: *
        -:  105: * @return pointer to the constructed array object
        -:  106: */
        -:  107:ecma_object_t *
    #####:  108:ecma_op_new_array_object (uint32_t length) /**< length of the new array */
        -:  109:{
    #####:  110:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
        -:  111:
    #####:  112:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
    #####:  113:  ecma_value_t *values_p = NULL;
        -:  114:
    #####:  115:  if (length > 0)
        -:  116:  {
    #####:  117:    if (length >= ECMA_FAST_ARRAY_MAX_HOLE_COUNT)
        -:  118:    {
    #####:  119:      return object_p;
        -:  120:    }
        -:  121:
    #####:  122:    values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  123:
    #####:  124:    if (JERRY_UNLIKELY (values_p == NULL))
        -:  125:    {
    #####:  126:      return object_p;
        -:  127:    }
        -:  128:  }
        -:  129:
    #####:  130:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  131:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  132:  ext_obj_p->u.array.length_prop_and_hole_count += length * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  133:
    #####:  134:  for (uint32_t i = 0; i < aligned_length; i++)
        -:  135:  {
    #####:  136:    values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  137:  }
        -:  138:
    #####:  139:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
    #####:  140:  ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
    #####:  141:  return object_p;
        -:  142:} /* ecma_op_new_array_object */
        -:  143:
        -:  144:/**
        -:  145: * Allocate a new array object from the given length
        -:  146: *
        -:  147: * Note: The returned array can be normal of fast access mode
        -:  148: *
        -:  149: * @return NULL - if the given length is invalid
        -:  150: *         pointer to the constructed array object - otherwise
        -:  151: */
        -:  152:ecma_object_t *
    #####:  153:ecma_op_new_array_object_from_length (ecma_length_t length) /**< length of the new array */
        -:  154:{
        -:  155:#if JERRY_ESNEXT
    #####:  156:  if (length > UINT32_MAX)
        -:  157:  {
    #####:  158:    ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
    #####:  159:    return NULL;
        -:  160:  }
        -:  161:#endif /* JERRY_ESNEXT */
        -:  162:
    #####:  163:  return ecma_op_new_array_object ((uint32_t) length);
        -:  164:} /* ecma_op_new_array_object_from_length */
        -:  165:
        -:  166:/**
        -:  167: * Allocate a new array object from the given buffer
        -:  168: *
        -:  169: * Note: The returned array can be normal of fast access mode
        -:  170: *
        -:  171: * @return ecma_value - constructed array object
        -:  172: */
        -:  173:ecma_value_t
    #####:  174:ecma_op_new_array_object_from_buffer (const ecma_value_t *args_p, /**< array element list */
        -:  175:                                      uint32_t length) /**< number of array elements */
        -:  176:{
    #####:  177:  if (length == 0)
        -:  178:  {
    #####:  179:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  180:  }
        -:  181:
    #####:  182:  ecma_object_t *object_p = ecma_op_alloc_array_object (length);
    #####:  183:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
        -:  184:  ecma_value_t *values_p;
    #####:  185:  values_p = (ecma_value_t *) jmem_heap_alloc_block_null_on_error (aligned_length * sizeof (ecma_value_t));
        -:  186:
    #####:  187:  if (values_p != NULL)
        -:  188:  {
    #####:  189:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  190:    ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  191:    JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
        -:  192:
    #####:  193:    for (uint32_t i = 0; i < length; i++)
        -:  194:    {
    #####:  195:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
    #####:  196:      values_p[i] = ecma_copy_value_if_not_object (args_p[i]);
        -:  197:    }
        -:  198:
    #####:  199:    for (uint32_t i = length; i < aligned_length; i++)
        -:  200:    {
    #####:  201:      values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  202:    }
        -:  203:
    #####:  204:    ECMA_SET_POINTER (object_p->u1.property_list_cp, values_p);
        -:  205:  }
        -:  206:  else
        -:  207:  {
    #####:  208:    for (uint32_t i = 0; i < length; i++)
        -:  209:    {
    #####:  210:      JERRY_ASSERT (!ecma_is_value_array_hole (args_p[i]));
        -:  211:
    #####:  212:      ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -:  213:      ecma_property_value_t *prop_value_p;
    #####:  214:      prop_value_p =
        -:  215:        ecma_create_named_data_property (object_p, prop_name_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
    #####:  216:      ecma_deref_ecma_string (prop_name_p);
    #####:  217:      prop_value_p->value = ecma_copy_value_if_not_object (args_p[i]);
        -:  218:    }
        -:  219:  }
        -:  220:
    #####:  221:  return ecma_make_object_value (object_p);
        -:  222:} /* ecma_op_new_array_object_from_buffer */
        -:  223:
        -:  224:/**
        -:  225: * Allocate a new fast acces mode array object from the given collection
        -:  226: *
        -:  227: * Note: The given collection will be unavailable after and it's underlying buffer is reused
        -:  228: *
        -:  229: * @return ecma_value - constructed fast access mode array object
        -:  230: */
        -:  231:ecma_value_t
    #####:  232:ecma_op_new_array_object_from_collection (ecma_collection_t *collection_p, /**< collection to create array from */
        -:  233:                                          bool unref_objects) /**< true - if the collection potentially
        -:  234:                                                                          containts objects
        -:  235:                                                                   false - otherwise */
        -:  236:{
    #####:  237:  const uint32_t item_count = collection_p->item_count;
        -:  238:
    #####:  239:  if (item_count == 0)
        -:  240:  {
    #####:  241:    ecma_collection_destroy (collection_p);
    #####:  242:    return ecma_make_object_value (ecma_op_new_array_object (0));
        -:  243:  }
        -:  244:
        -:  245:  ecma_object_t *object_p;
    #####:  246:  ecma_value_t *buffer_p = collection_p->buffer_p;
    #####:  247:  const uint32_t old_size = ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity);
    #####:  248:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (collection_p->item_count);
        -:  249:
    #####:  250:  jmem_heap_free_block (collection_p, sizeof (ecma_collection_t));
    #####:  251:  buffer_p = jmem_heap_realloc_block (buffer_p, old_size, aligned_length * sizeof (ecma_value_t));
    #####:  252:  object_p = ecma_op_alloc_array_object (item_count);
        -:  253:
    #####:  254:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  255:  ext_obj_p->u.array.length_prop_and_hole_count |= ECMA_FAST_ARRAY_FLAG;
    #####:  256:  JERRY_ASSERT (object_p->u1.property_list_cp == JMEM_CP_NULL);
    #####:  257:  JERRY_ASSERT (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE);
    #####:  258:  ECMA_SET_POINTER (object_p->u1.property_list_cp, buffer_p);
        -:  259:
    #####:  260:  if (JERRY_UNLIKELY (unref_objects))
        -:  261:  {
    #####:  262:    for (uint32_t i = 0; i < item_count; i++)
        -:  263:    {
        -:  264:      /* Strong references from the collection are no longer needed
        -:  265:         since GC will mark these object as a fast access mode array properties */
    #####:  266:      ecma_deref_if_object (buffer_p[i]);
        -:  267:    }
        -:  268:  }
        -:  269:
    #####:  270:  for (uint32_t i = item_count; i < aligned_length; i++)
        -:  271:  {
    #####:  272:    buffer_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  273:  }
        -:  274:
    #####:  275:  return ecma_make_object_value (object_p);
        -:  276:} /* ecma_op_new_array_object_from_collection */
        -:  277:
        -:  278:/**
        -:  279: * Converts a fast access mode array back to a normal property list based array
        -:  280: */
        -:  281:void
    #####:  282:ecma_fast_array_convert_to_normal (ecma_object_t *object_p) /**< fast access mode array object */
        -:  283:{
    #####:  284:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  285:
    #####:  286:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  287:
    #####:  288:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  289:  {
    #####:  290:    ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  291:    return;
        -:  292:  }
        -:  293:
    #####:  294:  uint32_t length = ext_obj_p->u.array.length;
    #####:  295:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (length);
    #####:  296:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  297:
    #####:  298:  ecma_ref_object (object_p);
        -:  299:
    #####:  300:  ecma_property_pair_t *property_pair_p = NULL;
    #####:  301:  jmem_cpointer_t next_property_pair_cp = JMEM_CP_NULL;
        -:  302:
    #####:  303:  uint32_t prop_index = 1;
    #####:  304:  int32_t index = (int32_t) (length - 1);
        -:  305:
    #####:  306:  while (index >= 0)
        -:  307:  {
    #####:  308:    if (ecma_is_value_array_hole (values_p[index]))
        -:  309:    {
    #####:  310:      index--;
    #####:  311:      continue;
        -:  312:    }
        -:  313:
    #####:  314:    if (prop_index == 1)
        -:  315:    {
    #####:  316:      property_pair_p = ecma_alloc_property_pair ();
    #####:  317:      property_pair_p->header.next_property_cp = next_property_pair_cp;
    #####:  318:      property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;
    #####:  319:      property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  320:      ECMA_SET_NON_NULL_POINTER (next_property_pair_cp, property_pair_p);
        -:  321:    }
        -:  322:
    #####:  323:    JERRY_ASSERT (index <= ECMA_DIRECT_STRING_MAX_IMM);
        -:  324:
    #####:  325:    property_pair_p->names_cp[prop_index] = (jmem_cpointer_t) index;
    #####:  326:    property_pair_p->header.types[prop_index] =
        -:  327:      (ecma_property_t) (ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE
        -:  328:                         | ECMA_FAST_ARRAY_UINT_DIRECT_STRING_PROP_TYPE);
        -:  329:
    #####:  330:    property_pair_p->values[prop_index].value = values_p[index];
        -:  331:
    #####:  332:    index--;
    #####:  333:    prop_index = !prop_index;
        -:  334:  }
        -:  335:
    #####:  336:  ext_obj_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_FAST_ARRAY_FLAG;
    #####:  337:  jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));
    #####:  338:  ECMA_SET_POINTER (object_p->u1.property_list_cp, property_pair_p);
        -:  339:
    #####:  340:  ecma_deref_object (object_p);
        -:  341:} /* ecma_fast_array_convert_to_normal */
        -:  342:
        -:  343:/**
        -:  344: * [[Put]] operation for a fast access mode array
        -:  345: *
        -:  346: * @return false - If the property name is not array index, or the requested index to be set
        -:  347: *                 would result too much array hole in the underlying buffer. The these cases
        -:  348: *                 the array is converted back to normal property list based array.
        -:  349: *         true - If the indexed property can be set with/without resizing the underlying buffer.
        -:  350: */
        -:  351:bool
    #####:  352:ecma_fast_array_set_property (ecma_object_t *object_p, /**< fast access mode array object */
        -:  353:                              uint32_t index, /**< property name index */
        -:  354:                              ecma_value_t value) /**< value to be set */
        -:  355:{
    #####:  356:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
    #####:  357:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  358:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  359:
        -:  360:  ecma_value_t *values_p;
        -:  361:
    #####:  362:  if (JERRY_LIKELY (index < old_length))
        -:  363:  {
    #####:  364:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  365:
    #####:  366:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  367:
    #####:  368:    if (ecma_is_value_array_hole (values_p[index]))
        -:  369:    {
    #####:  370:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  371:    }
        -:  372:    else
        -:  373:    {
    #####:  374:      ecma_free_value_if_not_object (values_p[index]);
        -:  375:    }
        -:  376:
    #####:  377:    values_p[index] = ecma_copy_value_if_not_object (value);
        -:  378:
    #####:  379:    return true;
        -:  380:  }
        -:  381:
    #####:  382:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
    #####:  383:  uint32_t new_holes = index - old_length;
        -:  384:
    #####:  385:  if (JERRY_UNLIKELY (new_holes > (ECMA_FAST_ARRAY_MAX_HOLE_COUNT - (old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT))))
        -:  386:  {
    #####:  387:    ecma_fast_array_convert_to_normal (object_p);
        -:  388:
    #####:  389:    return false;
        -:  390:  }
        -:  391:
    #####:  392:  uint32_t new_length = index + 1;
        -:  393:
    #####:  394:  JERRY_ASSERT (new_length < UINT32_MAX);
        -:  395:
    #####:  396:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
        -:  397:
    #####:  398:  if (JERRY_LIKELY (index < aligned_length))
        -:  399:  {
    #####:  400:    JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  401:
    #####:  402:    values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  403:    /* This area is filled with ECMA_VALUE_ARRAY_HOLE, but not counted in u.array.length_prop_and_hole_count */
    #####:  404:    JERRY_ASSERT (ecma_is_value_array_hole (values_p[index]));
    #####:  405:    ext_obj_p->u.array.length_prop_and_hole_count += new_holes * ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  406:    ext_obj_p->u.array.length = new_length;
        -:  407:  }
        -:  408:  else
        -:  409:  {
    #####:  410:    values_p = ecma_fast_array_extend (object_p, new_length);
    #####:  411:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  412:  }
        -:  413:
    #####:  414:  values_p[index] = ecma_copy_value_if_not_object (value);
        -:  415:
    #####:  416:  return true;
        -:  417:} /* ecma_fast_array_set_property */
        -:  418:
        -:  419:/**
        -:  420: * Get the number of array holes in a fast access array object
        -:  421: *
        -:  422: * @return number of array holes in a fast access array object
        -:  423: */
        -:  424:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    #####:  425:ecma_fast_array_get_hole_count (ecma_object_t *obj_p) /**< fast access mode array object */
        -:  426:{
    #####:  427:  JERRY_ASSERT (ecma_op_object_is_fast_array (obj_p));
        -:  428:
    #####:  429:  return ((ecma_extended_object_t *) obj_p)->u.array.length_prop_and_hole_count >> ECMA_FAST_ARRAY_HOLE_SHIFT;
        -:  430:} /* ecma_fast_array_get_hole_count */
        -:  431:
        -:  432:/**
        -:  433: * Extend the underlying buffer of a fast mode access array for the given new length
        -:  434: *
        -:  435: * @return pointer to the extended underlying buffer
        -:  436: */
        -:  437:ecma_value_t *
    #####:  438:ecma_fast_array_extend (ecma_object_t *object_p, /**< fast access mode array object */
        -:  439:                        uint32_t new_length) /**< new length of the fast access mode array */
        -:  440:{
    #####:  441:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
    #####:  442:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  443:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  444:
    #####:  445:  JERRY_ASSERT (old_length < new_length);
        -:  446:
    #####:  447:  ecma_ref_object (object_p);
        -:  448:
        -:  449:  ecma_value_t *new_values_p;
    #####:  450:  const uint32_t old_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
    #####:  451:  const uint32_t new_length_aligned = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  452:
    #####:  453:  if (object_p->u1.property_list_cp == JMEM_CP_NULL)
        -:  454:  {
    #####:  455:    new_values_p = jmem_heap_alloc_block (new_length_aligned * sizeof (ecma_value_t));
        -:  456:  }
        -:  457:  else
        -:  458:  {
    #####:  459:    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
    #####:  460:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  461:                                                             old_length_aligned * sizeof (ecma_value_t),
        -:  462:                                                             new_length_aligned * sizeof (ecma_value_t));
        -:  463:  }
        -:  464:
    #####:  465:  for (uint32_t i = old_length; i < new_length_aligned; i++)
        -:  466:  {
    #####:  467:    new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  468:  }
        -:  469:
    #####:  470:  ext_obj_p->u.array.length_prop_and_hole_count += (new_length - old_length) * ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  471:  ext_obj_p->u.array.length = new_length;
        -:  472:
    #####:  473:  ECMA_SET_NON_NULL_POINTER (object_p->u1.property_list_cp, new_values_p);
        -:  474:
    #####:  475:  ecma_deref_object (object_p);
    #####:  476:  return new_values_p;
        -:  477:} /* ecma_fast_array_extend */
        -:  478:
        -:  479:/**
        -:  480: * Delete the array object's property referenced by its value pointer.
        -:  481: *
        -:  482: * Note: specified property must be owned by specified object.
        -:  483: *
        -:  484: * @return true, if the property is deleted
        -:  485: *         false, otherwise
        -:  486: */
        -:  487:bool
    #####:  488:ecma_array_object_delete_property (ecma_object_t *object_p, /**< object */
        -:  489:                                   ecma_string_t *property_name_p) /**< property name */
        -:  490:{
    #####:  491:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
    #####:  492:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  493:
    #####:  494:  if (!ecma_op_object_is_fast_array (object_p))
        -:  495:  {
    #####:  496:    return false;
        -:  497:  }
        -:  498:
    #####:  499:  JERRY_ASSERT (object_p->u1.property_list_cp != JMEM_CP_NULL);
        -:  500:
    #####:  501:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  502:
    #####:  503:  JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
    #####:  504:  JERRY_ASSERT (index < ext_obj_p->u.array.length);
        -:  505:
    #####:  506:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  507:
    #####:  508:  if (ecma_is_value_array_hole (values_p[index]))
        -:  509:  {
    #####:  510:    return true;
        -:  511:  }
        -:  512:
    #####:  513:  ecma_free_value_if_not_object (values_p[index]);
        -:  514:
    #####:  515:  values_p[index] = ECMA_VALUE_ARRAY_HOLE;
    #####:  516:  ext_obj_p->u.array.length_prop_and_hole_count += ECMA_FAST_ARRAY_HOLE_ONE;
    #####:  517:  return true;
        -:  518:} /* ecma_array_object_delete_property */
        -:  519:
        -:  520:/**
        -:  521: * Low level delete of fast access mode array items
        -:  522: *
        -:  523: * @return the updated value of new_length
        -:  524: */
        -:  525:uint32_t
    #####:  526:ecma_delete_fast_array_properties (ecma_object_t *object_p, /**< fast access mode array */
        -:  527:                                   uint32_t new_length) /**< new length of the fast access mode array */
        -:  528:{
    #####:  529:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  530:
    #####:  531:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
        -:  532:
    #####:  533:  ecma_ref_object (object_p);
    #####:  534:  ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  535:
    #####:  536:  uint32_t old_length = ext_obj_p->u.array.length;
    #####:  537:  const uint32_t old_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (old_length);
    #####:  538:  JERRY_ASSERT (new_length < old_length);
        -:  539:
    #####:  540:  for (uint32_t i = new_length; i < old_length; i++)
        -:  541:  {
    #####:  542:    if (ecma_is_value_array_hole (values_p[i]))
        -:  543:    {
    #####:  544:      ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE;
        -:  545:    }
        -:  546:    else
        -:  547:    {
    #####:  548:      ecma_free_value_if_not_object (values_p[i]);
        -:  549:    }
        -:  550:  }
        -:  551:
        -:  552:  jmem_cpointer_t new_property_list_cp;
        -:  553:
    #####:  554:  if (new_length == 0)
        -:  555:  {
    #####:  556:    jmem_heap_free_block (values_p, old_aligned_length * sizeof (ecma_value_t));
    #####:  557:    new_property_list_cp = JMEM_CP_NULL;
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    const uint32_t new_aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (new_length);
        -:  562:
        -:  563:    ecma_value_t *new_values_p;
    #####:  564:    new_values_p = (ecma_value_t *) jmem_heap_realloc_block (values_p,
        -:  565:                                                             old_aligned_length * sizeof (ecma_value_t),
        -:  566:                                                             new_aligned_length * sizeof (ecma_value_t));
        -:  567:
    #####:  568:    for (uint32_t i = new_length; i < new_aligned_length; i++)
        -:  569:    {
    #####:  570:      new_values_p[i] = ECMA_VALUE_ARRAY_HOLE;
        -:  571:    }
        -:  572:
    #####:  573:    ECMA_SET_NON_NULL_POINTER (new_property_list_cp, new_values_p);
        -:  574:  }
        -:  575:
    #####:  576:  ext_obj_p->u.array.length = new_length;
    #####:  577:  object_p->u1.property_list_cp = new_property_list_cp;
        -:  578:
    #####:  579:  ecma_deref_object (object_p);
        -:  580:
    #####:  581:  return new_length;
        -:  582:} /* ecma_delete_fast_array_properties */
        -:  583:
        -:  584:/**
        -:  585: * Update the length of a fast access mode array to a new length
        -:  586: *
        -:  587: * Note: if the new length would result too much array hole in the underlying arraybuffer
        -:  588: *       the array is converted back to normal property list based array
        -:  589: */
        -:  590:static void
    #####:  591:ecma_fast_array_set_length (ecma_object_t *object_p, /**< fast access mode array object */
        -:  592:                            uint32_t new_length) /**< new length of the fast access mode array object*/
        -:  593:{
    #####:  594:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  595:
    #####:  596:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  597:  uint32_t old_length = ext_obj_p->u.array.length;
        -:  598:
    #####:  599:  JERRY_ASSERT (new_length >= old_length);
        -:  600:
    #####:  601:  if (new_length == old_length)
        -:  602:  {
    #####:  603:    return;
        -:  604:  }
        -:  605:
    #####:  606:  uint32_t old_holes = ext_obj_p->u.array.length_prop_and_hole_count;
    #####:  607:  uint32_t new_holes = new_length - old_length;
        -:  608:
    #####:  609:  if (JERRY_UNLIKELY (new_holes > (ECMA_FAST_ARRAY_MAX_HOLE_COUNT - (old_holes >> ECMA_FAST_ARRAY_HOLE_SHIFT))))
        -:  610:  {
    #####:  611:    ecma_fast_array_convert_to_normal (object_p);
        -:  612:  }
        -:  613:  else
        -:  614:  {
    #####:  615:    ecma_fast_array_extend (object_p, new_length);
        -:  616:  }
        -:  617:} /* ecma_fast_array_set_length */
        -:  618:
        -:  619:/**
        -:  620: * Get collection of property names of a fast access mode array object
        -:  621: *
        -:  622: * Note: Since the fast array object only contains indexed, enumerable, writable, configurable properties
        -:  623: *       we can return a collection of non-array hole array indices
        -:  624: *
        -:  625: * @return collection of strings - property names
        -:  626: */
        -:  627:ecma_collection_t *
    #####:  628:ecma_fast_array_object_own_property_keys (ecma_object_t *object_p, /**< fast access mode array object */
        -:  629:                                          jerry_property_filter_t filter) /**< property name filter options */
        -:  630:{
    #####:  631:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -:  632:
    #####:  633:  ecma_collection_t *ret_p = ecma_new_collection ();
        -:  634:
    #####:  635:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES))
        -:  636:  {
    #####:  637:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) object_p;
    #####:  638:    uint32_t length = ext_obj_p->u.array.length;
        -:  639:
    #####:  640:    if (length != 0)
        -:  641:    {
    #####:  642:      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  643:
    #####:  644:      for (uint32_t i = 0; i < length; i++)
        -:  645:      {
    #####:  646:        if (ecma_is_value_array_hole (values_p[i]))
        -:  647:        {
    #####:  648:          continue;
        -:  649:        }
        -:  650:
    #####:  651:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);
        -:  652:
    #####:  653:        ecma_collection_push_back (ret_p, ecma_make_string_value (index_str_p));
        -:  654:      }
        -:  655:    }
        -:  656:  }
        -:  657:
    #####:  658:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS))
        -:  659:  {
    #####:  660:    ecma_collection_push_back (ret_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
        -:  661:  }
        -:  662:
    #####:  663:  return ret_p;
        -:  664:} /* ecma_fast_array_object_own_property_keys */
        -:  665:
        -:  666:#if JERRY_ESNEXT
        -:  667:/**
        -:  668: * Array object creation with custom prototype.
        -:  669: *
        -:  670: * See also: ECMA-262 v6, 9.4.2.3
        -:  671: *
        -:  672: * @return ecma value
        -:  673: *         Returned value must be freed with ecma_free_value
        -:  674: */
        -:  675:ecma_object_t *
    #####:  676:ecma_op_array_species_create (ecma_object_t *original_array_p, /**< The object from whom the new array object
        -:  677:                                                                *   is being created */
        -:  678:                              ecma_length_t length) /**< length of the array */
        -:  679:{
    #####:  680:  ecma_value_t constructor = ECMA_VALUE_UNDEFINED;
    #####:  681:  ecma_value_t original_array = ecma_make_object_value (original_array_p);
        -:  682:
    #####:  683:  ecma_value_t is_array = ecma_is_value_array (original_array);
        -:  684:
    #####:  685:  if (ECMA_IS_VALUE_ERROR (is_array))
        -:  686:  {
    #####:  687:    return NULL;
        -:  688:  }
        -:  689:
    #####:  690:  if (ecma_is_value_true (is_array))
        -:  691:  {
    #####:  692:    constructor = ecma_op_object_get_by_magic_id (original_array_p, LIT_MAGIC_STRING_CONSTRUCTOR);
    #####:  693:    if (ECMA_IS_VALUE_ERROR (constructor))
        -:  694:    {
    #####:  695:      return NULL;
        -:  696:    }
        -:  697:
        -:  698:#if JERRY_BUILTIN_REALMS
    #####:  699:    if (ecma_is_constructor (constructor))
        -:  700:    {
    #####:  701:      ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);
    #####:  702:      ecma_global_object_t *global_object_p = ecma_op_function_get_function_realm (constructor_p);
        -:  703:
    #####:  704:      if ((ecma_object_t *) global_object_p != ecma_builtin_get_global ()
    #####:  705:          && constructor_p == ecma_builtin_get_from_realm (global_object_p, ECMA_BUILTIN_ID_ARRAY))
        -:  706:      {
    #####:  707:        ecma_deref_object (constructor_p);
    #####:  708:        constructor = ECMA_VALUE_UNDEFINED;
        -:  709:      }
        -:  710:    }
        -:  711:#endif /* JERRY_BUILTIN_REALMS */
        -:  712:
    #####:  713:    if (ecma_is_value_object (constructor))
        -:  714:    {
    #####:  715:      ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####:  716:      constructor = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
    #####:  717:      ecma_deref_object (ctor_object_p);
        -:  718:
    #####:  719:      if (ECMA_IS_VALUE_ERROR (constructor))
        -:  720:      {
    #####:  721:        return NULL;
        -:  722:      }
        -:  723:
    #####:  724:      if (ecma_is_value_null (constructor))
        -:  725:      {
    #####:  726:        constructor = ECMA_VALUE_UNDEFINED;
        -:  727:      }
        -:  728:    }
        -:  729:  }
        -:  730:
    #####:  731:  if (ecma_is_value_undefined (constructor))
        -:  732:  {
    #####:  733:    return ecma_op_new_array_object_from_length (length);
        -:  734:  }
        -:  735:
    #####:  736:  if (!ecma_is_constructor (constructor))
        -:  737:  {
    #####:  738:    ecma_free_value (constructor);
    #####:  739:    ecma_raise_type_error (ECMA_ERR_INVALID_SPECIES_CONSTRUCTOR);
    #####:  740:    return NULL;
        -:  741:  }
        -:  742:
    #####:  743:  ecma_value_t len_val = ecma_make_length_value (length);
    #####:  744:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####:  745:  ecma_value_t ret_val = ecma_op_function_construct (ctor_object_p, ctor_object_p, &len_val, 1);
        -:  746:
    #####:  747:  ecma_deref_object (ctor_object_p);
    #####:  748:  ecma_free_value (len_val);
        -:  749:
    #####:  750:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  751:  {
    #####:  752:    return NULL;
        -:  753:  }
        -:  754:
    #####:  755:  return ecma_get_object_from_value (ret_val);
        -:  756:} /* ecma_op_array_species_create */
        -:  757:
        -:  758:/**
        -:  759: * CreateArrayIterator Abstract Operation
        -:  760: *
        -:  761: * See also:
        -:  762: *          ECMA-262 v6, 22.1.5.1
        -:  763: *
        -:  764: * Referenced by:
        -:  765: *          ECMA-262 v6, 22.1.3.4
        -:  766: *          ECMA-262 v6, 22.1.3.13
        -:  767: *          ECMA-262 v6, 22.1.3.29
        -:  768: *          ECMA-262 v6, 22.1.3.30
        -:  769: *
        -:  770: * Note:
        -:  771: *      Returned value must be freed with ecma_free_value.
        -:  772: *
        -:  773: * @return array iterator object
        -:  774: */
        -:  775:ecma_value_t
    #####:  776:ecma_op_create_array_iterator (ecma_object_t *obj_p, /**< array object */
        -:  777:                               ecma_iterator_kind_t kind) /**< array iterator kind */
        -:  778:{
    #####:  779:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -:  780:
    #####:  781:  return ecma_op_create_iterator_object (ecma_make_object_value (obj_p),
        -:  782:                                         prototype_obj_p,
        -:  783:                                         ECMA_OBJECT_CLASS_ARRAY_ITERATOR,
        -:  784:                                         kind);
        -:  785:} /* ecma_op_create_array_iterator */
        -:  786:#endif /* JERRY_ESNEXT */
        -:  787:
        -:  788:/**
        -:  789: * Low level delete of array items from new_length to old_length
        -:  790: *
        -:  791: * Note: new_length must be less than old_length
        -:  792: *
        -:  793: * @return the updated value of new_length
        -:  794: */
        -:  795:static uint32_t
    #####:  796:ecma_delete_array_properties (ecma_object_t *object_p, /**< object */
        -:  797:                              uint32_t new_length, /**< new length */
        -:  798:                              uint32_t old_length) /**< old length */
        -:  799:{
    #####:  800:  JERRY_ASSERT (new_length < old_length);
    #####:  801:  JERRY_ASSERT (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -:  802:
    #####:  803:  if (ecma_op_object_is_fast_array (object_p))
        -:  804:  {
    #####:  805:    return ecma_delete_fast_array_properties (object_p, new_length);
        -:  806:  }
        -:  807:
        -:  808:  /* First the minimum value of new_length is updated. */
    #####:  809:  jmem_cpointer_t current_prop_cp = object_p->u1.property_list_cp;
        -:  810:
    #####:  811:  if (current_prop_cp == JMEM_CP_NULL)
        -:  812:  {
    #####:  813:    return new_length;
        -:  814:  }
        -:  815:
        -:  816:  ecma_property_header_t *current_prop_p;
        -:  817:
        -:  818:#if JERRY_PROPERTY_HASHMAP
    #####:  819:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  820:
    #####:  821:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  822:  {
    #####:  823:    current_prop_cp = current_prop_p->next_property_cp;
        -:  824:  }
        -:  825:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  826:
    #####:  827:  while (current_prop_cp != JMEM_CP_NULL)
        -:  828:  {
    #####:  829:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
    #####:  830:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
        -:  831:
    #####:  832:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  833:
    #####:  834:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  835:    {
    #####:  836:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  837:          && !ecma_is_property_configurable (current_prop_p->types[i]))
        -:  838:      {
    #####:  839:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i], prop_pair_p->names_cp[i]);
        -:  840:
    #####:  841:        if (index < old_length && index >= new_length)
        -:  842:        {
    #####:  843:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  844:
    #####:  845:          new_length = index + 1;
        -:  846:
    #####:  847:          if (new_length == old_length)
        -:  848:          {
        -:  849:            /* Early return. */
    #####:  850:            return new_length;
        -:  851:          }
        -:  852:        }
        -:  853:      }
        -:  854:    }
        -:  855:
    #####:  856:    current_prop_cp = current_prop_p->next_property_cp;
        -:  857:  }
        -:  858:
        -:  859:  /* Second all properties between new_length and old_length are deleted. */
    #####:  860:  current_prop_cp = object_p->u1.property_list_cp;
    #####:  861:  ecma_property_header_t *prev_prop_p = NULL;
        -:  862:
        -:  863:#if JERRY_PROPERTY_HASHMAP
    #####:  864:  JERRY_ASSERT (current_prop_cp != JMEM_CP_NULL);
        -:  865:
    #####:  866:  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;
    #####:  867:  current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  868:
    #####:  869:  if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  870:  {
    #####:  871:    prev_prop_p = current_prop_p;
    #####:  872:    current_prop_cp = current_prop_p->next_property_cp;
    #####:  873:    hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  874:  }
        -:  875:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  876:
    #####:  877:  while (current_prop_cp != JMEM_CP_NULL)
        -:  878:  {
    #####:  879:    current_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, current_prop_cp);
        -:  880:
    #####:  881:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (current_prop_p));
    #####:  882:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) current_prop_p;
        -:  883:
    #####:  884:    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  885:    {
    #####:  886:      if (current_prop_p->types[i] != ECMA_PROPERTY_TYPE_DELETED
    #####:  887:          && ecma_is_property_configurable (current_prop_p->types[i]))
        -:  888:      {
    #####:  889:        uint32_t index = ecma_string_get_property_index (current_prop_p->types[i], prop_pair_p->names_cp[i]);
        -:  890:
    #####:  891:        if (index < old_length && index >= new_length)
        -:  892:        {
    #####:  893:          JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -:  894:
        -:  895:#if JERRY_PROPERTY_HASHMAP
    #####:  896:          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)
        -:  897:          {
    #####:  898:            hashmap_status =
    #####:  899:              ecma_property_hashmap_delete (object_p, prop_pair_p->names_cp[i], current_prop_p->types + i);
        -:  900:          }
        -:  901:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  902:
    #####:  903:          ecma_gc_free_property (object_p, prop_pair_p, i);
    #####:  904:          current_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  905:          prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  906:        }
        -:  907:      }
        -:  908:    }
        -:  909:
    #####:  910:    if (current_prop_p->types[0] == ECMA_PROPERTY_TYPE_DELETED
    #####:  911:        && current_prop_p->types[1] == ECMA_PROPERTY_TYPE_DELETED)
    #####:  912:    {
    #####:  913:      if (prev_prop_p == NULL)
        -:  914:      {
    #####:  915:        object_p->u1.property_list_cp = current_prop_p->next_property_cp;
        -:  916:      }
        -:  917:      else
        -:  918:      {
    #####:  919:        prev_prop_p->next_property_cp = current_prop_p->next_property_cp;
        -:  920:      }
        -:  921:
    #####:  922:      jmem_cpointer_t next_prop_cp = current_prop_p->next_property_cp;
    #####:  923:      ecma_dealloc_property_pair ((ecma_property_pair_t *) current_prop_p);
    #####:  924:      current_prop_cp = next_prop_cp;
        -:  925:    }
        -:  926:    else
        -:  927:    {
    #####:  928:      prev_prop_p = current_prop_p;
    #####:  929:      current_prop_cp = current_prop_p->next_property_cp;
        -:  930:    }
        -:  931:  }
        -:  932:
        -:  933:#if JERRY_PROPERTY_HASHMAP
    #####:  934:  if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  935:  {
    #####:  936:    ecma_property_hashmap_free (object_p);
    #####:  937:    ecma_property_hashmap_create (object_p);
        -:  938:  }
        -:  939:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  940:
    #####:  941:  return new_length;
        -:  942:} /* ecma_delete_array_properties */
        -:  943:
        -:  944:/**
        -:  945: * Update the length of an array to a new length
        -:  946: *
        -:  947: * @return ecma value
        -:  948: *         Returned value must be freed with ecma_free_value
        -:  949: */
        -:  950:ecma_value_t
    #####:  951:ecma_op_array_object_set_length (ecma_object_t *object_p, /**< the array object */
        -:  952:                                 ecma_value_t new_value, /**< new length value */
        -:  953:                                 uint16_t flags) /**< property descriptor flags */
        -:  954:{
    #####:  955:  ecma_number_t new_len_num;
    #####:  956:  ecma_value_t completion = ecma_op_to_number (new_value, &new_len_num);
        -:  957:
    #####:  958:  if (ECMA_IS_VALUE_ERROR (completion))
        -:  959:  {
    #####:  960:    return completion;
        -:  961:  }
        -:  962:
    #####:  963:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion));
        -:  964:
    #####:  965:  if (ecma_is_value_object (new_value))
        -:  966:  {
    #####:  967:    ecma_value_t compared_num_val = ecma_op_to_number (new_value, &new_len_num);
        -:  968:
    #####:  969:    if (ECMA_IS_VALUE_ERROR (compared_num_val))
        -:  970:    {
    #####:  971:      return compared_num_val;
        -:  972:    }
        -:  973:  }
        -:  974:
    #####:  975:  uint32_t new_len_uint32 = ecma_number_to_uint32 (new_len_num);
        -:  976:
    #####:  977:  if (((ecma_number_t) new_len_uint32) != new_len_num)
        -:  978:  {
    #####:  979:    return ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -:  980:  }
        -:  981:
        -:  982:  /* Only the writable and data properties can be modified. */
    #####:  983:  if (flags
    #####:  984:      & (JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -:  985:  {
    #####:  986:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -:  987:  }
        -:  988:
    #####:  989:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  990:
    #####:  991:  uint32_t old_len_uint32 = ext_object_p->u.array.length;
        -:  992:
    #####:  993:  if (new_len_num == old_len_uint32)
        -:  994:  {
        -:  995:    /* Only the writable flag must be updated. */
    #####:  996:    if (flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -:  997:    {
    #####:  998:      if (!(flags & JERRY_PROP_IS_WRITABLE))
        -:  999:      {
    #####: 1000:        if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1001:        {
    #####: 1002:          ecma_fast_array_convert_to_normal (object_p);
        -: 1003:        }
        -: 1004:
    #####: 1005:        ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1006:      }
    #####: 1007:      else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1008:      {
    #####: 1009:        return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1010:      }
        -: 1011:    }
    #####: 1012:    return ECMA_VALUE_TRUE;
        -: 1013:  }
    #####: 1014:  else if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1015:  {
    #####: 1016:    return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1017:  }
        -: 1018:
    #####: 1019:  uint32_t current_len_uint32 = new_len_uint32;
        -: 1020:
    #####: 1021:  if (new_len_uint32 < old_len_uint32)
        -: 1022:  {
    #####: 1023:    current_len_uint32 = ecma_delete_array_properties (object_p, new_len_uint32, old_len_uint32);
        -: 1024:  }
    #####: 1025:  else if (ecma_op_object_is_fast_array (object_p))
        -: 1026:  {
    #####: 1027:    ecma_fast_array_set_length (object_p, new_len_uint32);
        -: 1028:  }
        -: 1029:
    #####: 1030:  ext_object_p->u.array.length = current_len_uint32;
        -: 1031:
    #####: 1032:  if ((flags & JERRY_PROP_IS_WRITABLE_DEFINED) && !(flags & JERRY_PROP_IS_WRITABLE))
        -: 1033:  {
    #####: 1034:    if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1035:    {
    #####: 1036:      ecma_fast_array_convert_to_normal (object_p);
        -: 1037:    }
        -: 1038:
    #####: 1039:    ext_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1040:  }
        -: 1041:
    #####: 1042:  if (current_len_uint32 == new_len_uint32)
        -: 1043:  {
    #####: 1044:    return ECMA_VALUE_TRUE;
        -: 1045:  }
        -: 1046:
    #####: 1047:  return ecma_raise_property_redefinition (ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), flags);
        -: 1048:} /* ecma_op_array_object_set_length */
        -: 1049:
        -: 1050:/**
        -: 1051: * Property descriptor bitset for fast array data properties.
        -: 1052: * If the property desciptor fields contains all the flags below
        -: 1053: * attempt to stay fast access array during [[DefineOwnProperty]] operation.
        -: 1054: */
        -: 1055:#define ECMA_FAST_ARRAY_DATA_PROP_FLAGS                                                               \
        -: 1056:  (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_ENUMERABLE          \
        -: 1057:   | JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_WRITABLE_DEFINED \
        -: 1058:   | JERRY_PROP_IS_WRITABLE)
        -: 1059:
        -: 1060:/**
        -: 1061: * [[DefineOwnProperty]] ecma array object's operation
        -: 1062: *
        -: 1063: * See also:
        -: 1064: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1065: *          ECMA-262 v5, 15.4.5.1
        -: 1066: *
        -: 1067: * @return ecma value
        -: 1068: *         Returned value must be freed with ecma_free_value
        -: 1069: */
        -: 1070:ecma_value_t
    #####: 1071:ecma_op_array_object_define_own_property (ecma_object_t *object_p, /**< the array object */
        -: 1072:                                          ecma_string_t *property_name_p, /**< property name */
        -: 1073:                                          const ecma_property_descriptor_t *property_desc_p) /**< property descriptor */
        -: 1074:{
    #####: 1075:  if (ecma_string_is_length (property_name_p))
        -: 1076:  {
    #####: 1077:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 1078:                  || !(property_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE));
    #####: 1079:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 1080:                  || !(property_desc_p->flags & JERRY_PROP_IS_ENUMERABLE));
    #####: 1081:    JERRY_ASSERT ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 1082:                  || !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE));
        -: 1083:
    #####: 1084:    if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 1085:    {
    #####: 1086:      return ecma_op_array_object_set_length (object_p, property_desc_p->value, property_desc_p->flags);
        -: 1087:    }
        -: 1088:
    #####: 1089:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 1090:    ecma_value_t length_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -: 1091:
    #####: 1092:    ecma_value_t result = ecma_op_array_object_set_length (object_p, length_value, property_desc_p->flags);
        -: 1093:
    #####: 1094:    ecma_fast_free_value (length_value);
    #####: 1095:    return result;
        -: 1096:  }
        -: 1097:
    #####: 1098:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1099:
    #####: 1100:  if (ecma_op_object_is_fast_array (object_p))
        -: 1101:  {
    #####: 1102:    if ((property_desc_p->flags & ECMA_FAST_ARRAY_DATA_PROP_FLAGS) == ECMA_FAST_ARRAY_DATA_PROP_FLAGS)
        -: 1103:    {
    #####: 1104:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1105:
    #####: 1106:      if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1107:      {
    #####: 1108:        ecma_fast_array_convert_to_normal (object_p);
        -: 1109:      }
    #####: 1110:      else if (ecma_fast_array_set_property (object_p, index, property_desc_p->value))
        -: 1111:      {
    #####: 1112:        return ECMA_VALUE_TRUE;
        -: 1113:      }
        -: 1114:
    #####: 1115:      JERRY_ASSERT (!ecma_op_array_is_fast_array (ext_object_p));
        -: 1116:    }
        -: 1117:    else
        -: 1118:    {
    #####: 1119:      ecma_fast_array_convert_to_normal (object_p);
        -: 1120:    }
        -: 1121:  }
        -: 1122:
    #####: 1123:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
    #####: 1124:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1125:
    #####: 1126:  if (index == ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1127:  {
    #####: 1128:    return ecma_op_general_object_define_own_property (object_p, property_name_p, property_desc_p);
        -: 1129:  }
        -: 1130:
    #####: 1131:  bool update_length = (index >= ext_object_p->u.array.length);
        -: 1132:
    #####: 1133:  if (update_length && !ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1134:  {
    #####: 1135:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1136:  }
        -: 1137:
    #####: 1138:  ecma_property_descriptor_t prop_desc;
        -: 1139:
    #####: 1140:  prop_desc = *property_desc_p;
    #####: 1141:  prop_desc.flags &= (uint16_t) ~JERRY_PROP_SHOULD_THROW;
        -: 1142:
    #####: 1143:  ecma_value_t completition = ecma_op_general_object_define_own_property (object_p, property_name_p, &prop_desc);
    #####: 1144:  JERRY_ASSERT (ecma_is_value_boolean (completition));
        -: 1145:
    #####: 1146:  if (ecma_is_value_false (completition))
        -: 1147:  {
    #####: 1148:    return ecma_raise_property_redefinition (property_name_p, property_desc_p->flags);
        -: 1149:  }
        -: 1150:
    #####: 1151:  if (update_length)
        -: 1152:  {
    #####: 1153:    ext_object_p->u.array.length = index + 1;
        -: 1154:  }
        -: 1155:
    #####: 1156:  return ECMA_VALUE_TRUE;
        -: 1157:} /* ecma_op_array_object_define_own_property */
        -: 1158:
        -: 1159:/**
        -: 1160: * Get the length of the an array object
        -: 1161: *
        -: 1162: * @return the array length
        -: 1163: */
        -: 1164:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1165:ecma_array_get_length (ecma_object_t *array_p) /**< array object */
        -: 1166:{
    #####: 1167:  JERRY_ASSERT (ecma_get_object_base_type (array_p) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1168:
    #####: 1169:  return ((ecma_extended_object_t *) array_p)->u.array.length;
        -: 1170:} /* ecma_array_get_length */
        -: 1171:
        -: 1172:/**
        -: 1173: * The Array.prototype and %TypedArray%.prototype objects' 'toString' routine.
        -: 1174: *
        -: 1175: * See also:
        -: 1176: *          ECMA-262 v5, 15.4.4.2
        -: 1177: *          ECMA-262 v6, 22.1.3.7
        -: 1178: *
        -: 1179: * @return ecma value
        -: 1180: *         Returned value must be freed with ecma_free_value.
        -: 1181: */
        -: 1182:ecma_value_t
    #####: 1183:ecma_array_object_to_string (ecma_value_t this_arg) /**< this argument */
        -: 1184:{
    #####: 1185:  JERRY_ASSERT (ecma_is_value_object (this_arg));
        -: 1186:
    #####: 1187:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1188:
    #####: 1189:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
        -: 1190:
        -: 1191:  /* 2. */
    #####: 1192:  ecma_value_t join_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_JOIN);
    #####: 1193:  if (ECMA_IS_VALUE_ERROR (join_value))
        -: 1194:  {
    #####: 1195:    return join_value;
        -: 1196:  }
        -: 1197:
    #####: 1198:  if (!ecma_op_is_callable (join_value))
        -: 1199:  {
        -: 1200:    /* 3. */
    #####: 1201:    ret_value = ecma_builtin_helper_object_to_string (this_arg);
        -: 1202:  }
        -: 1203:  else
        -: 1204:  {
        -: 1205:    /* 4. */
    #####: 1206:    ecma_object_t *join_func_obj_p = ecma_get_object_from_value (join_value);
        -: 1207:
    #####: 1208:    ret_value = ecma_op_function_call (join_func_obj_p, this_arg, NULL, 0);
        -: 1209:  }
        -: 1210:
    #####: 1211:  ecma_free_value (join_value);
        -: 1212:
    #####: 1213:  return ret_value;
        -: 1214:} /* ecma_array_object_to_string */
        -: 1215:
        -: 1216:/**
        -: 1217: * @}
        -: 1218: * @}
        -: 1219: */
