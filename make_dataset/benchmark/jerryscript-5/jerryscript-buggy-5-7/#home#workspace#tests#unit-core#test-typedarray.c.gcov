        -:    0:Source:/home/workspace/tests/unit-core/test-typedarray.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:
        -:   18:#include "jerryscript-port-default.h"
        -:   19:#include "jerryscript-port.h"
        -:   20:#include "jerryscript.h"
        -:   21:
        -:   22:#include "test-common.h"
        -:   23:
        -:   24:/**
        -:   25: * Type to describe test cases.
        -:   26: */
        -:   27:typedef struct
        -:   28:{
        -:   29:  jerry_typedarray_type_t typedarray_type; /**< what kind of TypedArray */
        -:   30:  char *constructor_name; /**< JS constructor name for TypedArray */
        -:   31:  uint32_t element_count; /**< number of elements for the TypedArray */
        -:   32:  uint32_t bytes_per_element; /**< bytes per elment of the given typedarray_type */
        -:   33:} test_entry_t;
        -:   34:
        -:   35:/**
        -:   36: * Register a JavaScript value in the global object.
        -:   37: */
        -:   38:static void
    #####:   39:register_js_value (const char *name_p, /**< name of the function */
        -:   40:                   jerry_value_t value) /**< function callback */
        -:   41:{
    #####:   42:  jerry_value_t global_obj_val = jerry_current_realm ();
        -:   43:
    #####:   44:  jerry_value_t name_val = jerry_string_sz (name_p);
    #####:   45:  jerry_value_t result_val = jerry_object_set (global_obj_val, name_val, value);
        -:   46:
    #####:   47:  jerry_value_free (name_val);
    #####:   48:  jerry_value_free (global_obj_val);
        -:   49:
    #####:   50:  jerry_value_free (result_val);
    #####:   51:} /* register_js_value */
        -:   52:
        -:   53:static jerry_value_t
    #####:   54:assert_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   55:                const jerry_value_t args_p[], /**< function arguments */
        -:   56:                const jerry_length_t args_cnt) /**< number of function arguments */
        -:   57:{
        -:   58:  JERRY_UNUSED (call_info_p);
        -:   59:
    #####:   60:  if (jerry_value_is_true (args_p[0]))
        -:   61:  {
    #####:   62:    return jerry_boolean (true);
        -:   63:  }
        -:   64:  else
        -:   65:  {
    #####:   66:    if (args_cnt > 1 && jerry_value_is_string (args_p[1]))
        -:   67:    {
        -:   68:      jerry_char_t utf8_string[128];
    #####:   69:      jerry_size_t copied =
    #####:   70:        jerry_string_to_buffer (args_p[1], JERRY_ENCODING_UTF8, utf8_string, sizeof (utf8_string) - 1);
    #####:   71:      utf8_string[copied] = '\0';
        -:   72:
    #####:   73:      printf ("JS assert: %s\n", utf8_string);
        -:   74:    }
    #####:   75:    TEST_ASSERT (false);
        -:   76:  }
        -:   77:} /* assert_handler */
        -:   78:
        -:   79:/**
        -:   80: * Do simple TypedArray property validation.
        -:   81: */
        -:   82:static void
    #####:   83:test_typedarray_info (jerry_value_t typedarray, /**< target TypedArray to query */
        -:   84:                      jerry_typedarray_type_t typedarray_type, /**< expected TypedArray type */
        -:   85:                      jerry_length_t element_count, /**< expected element count */
        -:   86:                      jerry_length_t bytes_per_element) /**< bytes per element for the given type */
        -:   87:{
    #####:   88:  TEST_ASSERT (!jerry_value_is_exception (typedarray));
    #####:   89:  TEST_ASSERT (jerry_value_is_typedarray (typedarray));
    #####:   90:  TEST_ASSERT (jerry_typedarray_type (typedarray) == typedarray_type);
    #####:   91:  TEST_ASSERT (jerry_typedarray_length (typedarray) == element_count);
        -:   92:
    #####:   93:  jerry_length_t byte_length = (uint32_t) -1;
    #####:   94:  jerry_length_t byte_offset = (uint32_t) -1;
    #####:   95:  jerry_value_t arraybuffer = jerry_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:   96:  TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
        -:   97:
    #####:   98:  TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:   99:  TEST_ASSERT (byte_offset == 0);
        -:  100:
    #####:  101:  jerry_value_free (arraybuffer);
    #####:  102:} /* test_typedarray_info */
        -:  103:
        -:  104:/**
        -:  105: * Test construction of TypedArrays and validate properties.
        -:  106: */
        -:  107:static void
    #####:  108:test_typedarray_queries (test_entry_t test_entries[]) /**< test cases */
        -:  109:{
    #####:  110:  jerry_value_t global_obj_val = jerry_current_realm ();
        -:  111:
    #####:  112:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  113:  {
        -:  114:    /* Create TypedArray via construct call */
        -:  115:    {
    #####:  116:      jerry_value_t prop_name = jerry_string_sz (test_entries[i].constructor_name);
    #####:  117:      jerry_value_t prop_value = jerry_object_get (global_obj_val, prop_name);
    #####:  118:      TEST_ASSERT (!jerry_value_is_exception (prop_value));
    #####:  119:      jerry_value_t length_arg = jerry_number (test_entries[i].element_count);
        -:  120:
    #####:  121:      jerry_value_t typedarray = jerry_construct (prop_value, &length_arg, 1);
        -:  122:
    #####:  123:      jerry_value_free (prop_name);
    #####:  124:      jerry_value_free (prop_value);
    #####:  125:      jerry_value_free (length_arg);
        -:  126:
    #####:  127:      test_typedarray_info (typedarray,
        -:  128:                            test_entries[i].typedarray_type,
        -:  129:                            test_entries[i].element_count,
        -:  130:                            test_entries[i].bytes_per_element);
    #####:  131:      jerry_value_free (typedarray);
        -:  132:    }
        -:  133:
        -:  134:    /* Create TypedArray via api call */
        -:  135:    {
    #####:  136:      jerry_value_t typedarray = jerry_typedarray (test_entries[i].typedarray_type, test_entries[i].element_count);
    #####:  137:      test_typedarray_info (typedarray,
        -:  138:                            test_entries[i].typedarray_type,
        -:  139:                            test_entries[i].element_count,
        -:  140:                            test_entries[i].bytes_per_element);
    #####:  141:      jerry_value_free (typedarray);
        -:  142:    }
        -:  143:  }
        -:  144:
    #####:  145:  jerry_value_free (global_obj_val);
    #####:  146:} /* test_typedarray_queries */
        -:  147:
        -:  148:/**
        -:  149: * Test value at given position in the buffer based on TypedArray type.
        -:  150: */
        -:  151:static void
    #####:  152:test_buffer_value (uint64_t value, /**< value to test for */
        -:  153:                   const void *buffer, /**< buffer to read value from */
        -:  154:                   uint32_t start_offset, /**< start offset of the value */
        -:  155:                   jerry_typedarray_type_t typedarray_type, /**< type of TypedArray */
        -:  156:                   uint32_t bytes_per_element) /**< bytes per element for the given type */
        -:  157:{
    #####:  158:  uint32_t offset = start_offset / bytes_per_element;
        -:  159:
        -:  160:#define TEST_VALUE_AT(TYPE, BUFFER, OFFSET, VALUE) TEST_ASSERT (((TYPE *) BUFFER)[OFFSET] == (TYPE) (VALUE))
        -:  161:
    #####:  162:  switch (typedarray_type)
        -:  163:  {
    #####:  164:    case JERRY_TYPEDARRAY_UINT8:
    #####:  165:      TEST_VALUE_AT (uint8_t, buffer, offset, value);
        -:  166:      break;
    #####:  167:    case JERRY_TYPEDARRAY_INT8:
    #####:  168:      TEST_VALUE_AT (int8_t, buffer, offset, value);
        -:  169:      break;
    #####:  170:    case JERRY_TYPEDARRAY_UINT16:
    #####:  171:      TEST_VALUE_AT (uint16_t, buffer, offset, value);
        -:  172:      break;
    #####:  173:    case JERRY_TYPEDARRAY_INT16:
    #####:  174:      TEST_VALUE_AT (int16_t, buffer, offset, value);
        -:  175:      break;
    #####:  176:    case JERRY_TYPEDARRAY_UINT32:
    #####:  177:      TEST_VALUE_AT (uint32_t, buffer, offset, value);
        -:  178:      break;
    #####:  179:    case JERRY_TYPEDARRAY_INT32:
    #####:  180:      TEST_VALUE_AT (int32_t, buffer, offset, value);
        -:  181:      break;
    #####:  182:    case JERRY_TYPEDARRAY_FLOAT32:
    #####:  183:      TEST_VALUE_AT (float, buffer, offset, value);
        -:  184:      break;
    #####:  185:    case JERRY_TYPEDARRAY_FLOAT64:
    #####:  186:      TEST_VALUE_AT (double, buffer, offset, value);
        -:  187:      break;
    #####:  188:    case JERRY_TYPEDARRAY_BIGINT64:
    #####:  189:      TEST_VALUE_AT (int64_t, buffer, offset, value);
        -:  190:      break;
    #####:  191:    case JERRY_TYPEDARRAY_BIGUINT64:
    #####:  192:      TEST_VALUE_AT (uint64_t, buffer, offset, value);
        -:  193:      break;
        -:  194:
    #####:  195:    case JERRY_TYPEDARRAY_UINT8CLAMPED:
        -:  196:    {
    #####:  197:      int64_t signed_value = (int64_t) value;
    #####:  198:      uint8_t expected = (uint8_t) value;
        -:  199:
        -:  200:      /* clamp the value if required*/
    #####:  201:      if (signed_value > 0xFF)
        -:  202:      {
        -:  203:        expected = 0xFF;
        -:  204:      }
    #####:  205:      else if (signed_value < 0)
        -:  206:      {
    #####:  207:        expected = 0;
        -:  208:      }
        -:  209:
    #####:  210:      TEST_VALUE_AT (uint8_t, buffer, offset, expected);
        -:  211:      break;
        -:  212:    }
        -:  213:    default:
    #####:  214:      TEST_ASSERT (false);
        -:  215:      break;
        -:  216:  }
        -:  217:
        -:  218:#undef TEST_VALUE_AT
    #####:  219:} /* test_buffer_value */
        -:  220:
        -:  221:static void
    #####:  222:test_typedarray_complex_creation (test_entry_t test_entries[], /**< test cases */
        -:  223:                                  bool use_external_buffer) /**< run tests using arraybuffer with external memory */
        -:  224:{
    #####:  225:  const uint32_t arraybuffer_size = 256;
        -:  226:
    #####:  227:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  228:  {
    #####:  229:    const uint32_t offset = 8;
    #####:  230:    uint32_t element_count = test_entries[i].element_count;
    #####:  231:    uint32_t bytes_per_element = test_entries[i].bytes_per_element;
    #####:  232:    uint8_t *buffer_p = NULL;
        -:  233:
        -:  234:    /* new %TypedArray% (buffer, offset, length); */
        -:  235:    jerry_value_t typedarray;
        -:  236:    {
        -:  237:      jerry_value_t arraybuffer;
        -:  238:
    #####:  239:      if (use_external_buffer)
        -:  240:      {
    #####:  241:        buffer_p = (uint8_t *) jerry_heap_alloc (arraybuffer_size);
    #####:  242:        arraybuffer = jerry_arraybuffer_external (buffer_p, arraybuffer_size, NULL);
        -:  243:      }
        -:  244:      else
        -:  245:      {
    #####:  246:        arraybuffer = jerry_arraybuffer (arraybuffer_size);
        -:  247:      }
        -:  248:
    #####:  249:      jerry_value_t js_offset = jerry_number (offset);
    #####:  250:      jerry_value_t js_element_count = jerry_number (element_count);
        -:  251:
    #####:  252:      register_js_value ("expected_offset", js_offset);
    #####:  253:      register_js_value ("expected_length", js_element_count);
        -:  254:
    #####:  255:      typedarray =
    #####:  256:        jerry_typedarray_with_buffer_span (test_entries[i].typedarray_type, arraybuffer, offset, element_count);
    #####:  257:      TEST_ASSERT (!jerry_value_is_exception (typedarray));
        -:  258:
    #####:  259:      jerry_value_free (js_offset);
    #####:  260:      jerry_value_free (js_element_count);
    #####:  261:      jerry_value_free (arraybuffer);
        -:  262:    }
        -:  263:
    #####:  264:    register_js_value ("array", typedarray);
        -:  265:
    #####:  266:    const jerry_char_t test_exptected_src[] =
        -:  267:      TEST_STRING_LITERAL ("assert (array.length == expected_length,"
        -:  268:                           "        'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  269:                           "assert (array.byteOffset == expected_offset);");
    #####:  270:    jerry_value_t result = jerry_eval (test_exptected_src, sizeof (test_exptected_src) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  271:    TEST_ASSERT (!jerry_value_is_exception (result));
    #####:  272:    jerry_value_free (result);
        -:  273:
    #####:  274:    const jerry_char_t set_element_src[] = TEST_STRING_LITERAL ("array[0] = 0x11223344n");
        -:  275:
        -:  276:    /* crop the last 'n' character */
    #####:  277:    size_t src_length = sizeof (set_element_src) - 2;
        -:  278:
    #####:  279:    if (test_entries[i].typedarray_type >= JERRY_TYPEDARRAY_BIGINT64)
        -:  280:    {
        -:  281:      /* use the last 'n' character */
    #####:  282:      src_length++;
        -:  283:    }
        -:  284:
    #####:  285:    result = jerry_eval (set_element_src, src_length, JERRY_PARSE_STRICT_MODE);
    #####:  286:    TEST_ASSERT (!jerry_value_is_exception (result));
    #####:  287:    jerry_value_free (result);
        -:  288:
    #####:  289:    {
    #####:  290:      jerry_length_t byte_length = 0;
    #####:  291:      jerry_length_t byte_offset = 0;
    #####:  292:      jerry_value_t buffer = jerry_typedarray_buffer (typedarray, &byte_offset, &byte_length);
    #####:  293:      TEST_ASSERT (byte_length == element_count * bytes_per_element);
    #####:  294:      TEST_ASSERT (byte_offset == offset);
        -:  295:
    #####:  296:      JERRY_VLA (uint8_t, test_buffer, arraybuffer_size);
        -:  297:
    #####:  298:      jerry_typedarray_type_t type = jerry_typedarray_type (typedarray);
    #####:  299:      jerry_value_t read_count = jerry_arraybuffer_read (buffer, 0, test_buffer, offset + byte_length);
    #####:  300:      TEST_ASSERT (read_count == offset + byte_length);
    #####:  301:      test_buffer_value (0x11223344, test_buffer, offset, type, bytes_per_element);
        -:  302:
    #####:  303:      if (use_external_buffer)
        -:  304:      {
    #####:  305:        test_buffer_value (0x11223344, buffer_p, offset, type, bytes_per_element);
    #####:  306:        TEST_ASSERT (memcmp (buffer_p, test_buffer, offset + byte_length) == 0);
        -:  307:      }
        -:  308:
    #####:  309:      jerry_value_free (buffer);
        -:  310:    }
        -:  311:
    #####:  312:    jerry_value_free (typedarray);
        -:  313:  }
    #####:  314:} /* test_typedarray_complex_creation */
        -:  315:
        -:  316:/**
        -:  317: * Test get/set/delete property by index.
        -:  318: */
        -:  319:static void
    #####:  320:test_property_by_index (test_entry_t test_entries[])
        -:  321:{
    #####:  322:  int test_int_numbers[5] = { -5, -70, 13, 0, 56 };
    #####:  323:  double test_double_numbers[5] = { -83.153, -35.15, 0, 13.1, 89.8975 };
    #####:  324:  uint8_t test_uint_numbers[5] = { 83, 15, 36, 0, 43 };
    #####:  325:  uint64_t test_uint64_numbers[5] = { 83, 0, 1, UINT32_MAX, UINT64_MAX };
    #####:  326:  int64_t test_int64_numbers[5] = { INT64_MAX, INT64_MIN, 0, INT32_MAX, INT32_MIN };
        -:  327:
    #####:  328:  for (uint32_t i = 0; test_entries[i].constructor_name != NULL; i++)
        -:  329:  {
        -:  330:    jerry_value_t test_number;
    #####:  331:    uint32_t test_numbers_length = sizeof (test_int_numbers) / sizeof (int);
    #####:  332:    jerry_value_t typedarray = jerry_typedarray (test_entries[i].typedarray_type, test_numbers_length);
    #####:  333:    jerry_typedarray_type_t type = jerry_typedarray_type (typedarray);
        -:  334:
        -:  335:    jerry_value_t set_result;
        -:  336:    jerry_value_t get_result;
        -:  337:
    #####:  338:    switch (type)
        -:  339:    {
        -:  340:      case JERRY_TYPEDARRAY_INT8:
        -:  341:      case JERRY_TYPEDARRAY_INT16:
        -:  342:      case JERRY_TYPEDARRAY_INT32:
        -:  343:      {
    #####:  344:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  345:        {
    #####:  346:          test_number = jerry_number (test_int_numbers[j]);
    #####:  347:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  348:          set_result = jerry_object_set_index (typedarray, j, test_number);
    #####:  349:          get_result = jerry_object_get_index (typedarray, j);
        -:  350:
    #####:  351:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  352:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  353:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  354:          TEST_ASSERT (jerry_value_as_number (get_result) == test_int_numbers[j]);
        -:  355:
    #####:  356:          jerry_value_free (test_number);
    #####:  357:          jerry_value_free (set_result);
    #####:  358:          jerry_value_free (get_result);
        -:  359:        }
        -:  360:        break;
        -:  361:      }
        -:  362:      case JERRY_TYPEDARRAY_FLOAT32:
        -:  363:      case JERRY_TYPEDARRAY_FLOAT64:
        -:  364:      {
    #####:  365:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  366:        {
    #####:  367:          test_number = jerry_number (test_double_numbers[j]);
    #####:  368:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  369:          set_result = jerry_object_set_index (typedarray, j, test_number);
    #####:  370:          get_result = jerry_object_get_index (typedarray, j);
        -:  371:
    #####:  372:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  373:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  374:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
        -:  375:
    #####:  376:          double epsilon = pow (10, -5);
    #####:  377:          double get_abs = fabs (jerry_value_as_number (get_result) - test_double_numbers[j]);
    #####:  378:          TEST_ASSERT (get_abs < epsilon);
        -:  379:
    #####:  380:          jerry_value_free (test_number);
    #####:  381:          jerry_value_free (set_result);
    #####:  382:          jerry_value_free (get_result);
        -:  383:
        -:  384:          /* Testing positive and negative infinity */
    #####:  385:          for (uint8_t k = 0; k < 2; k++)
        -:  386:          {
    #####:  387:            jerry_value_t inf = jerry_infinity (k);
    #####:  388:            jerry_value_t set_inf = jerry_object_set_index (typedarray, 0, inf);
    #####:  389:            TEST_ASSERT (jerry_value_is_boolean (set_inf));
    #####:  390:            TEST_ASSERT (jerry_value_is_true (set_inf));
    #####:  391:            jerry_value_t get_inf = jerry_object_get_index (typedarray, 0);
    #####:  392:            TEST_ASSERT (isinf (jerry_value_as_number (get_inf)));
        -:  393:
    #####:  394:            jerry_value_free (inf);
    #####:  395:            jerry_value_free (set_inf);
    #####:  396:            jerry_value_free (get_inf);
        -:  397:          }
        -:  398:        }
        -:  399:        break;
        -:  400:      }
        -:  401:      case JERRY_TYPEDARRAY_BIGINT64:
        -:  402:      {
    #####:  403:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  404:        {
    #####:  405:          test_number = jerry_bigint ((uint64_t *) &test_int64_numbers[j], 1, true);
    #####:  406:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  407:          set_result = jerry_object_set_index (typedarray, j, test_number);
    #####:  408:          get_result = jerry_object_get_index (typedarray, j);
        -:  409:
    #####:  410:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  411:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  412:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
        -:  413:          int64_t get_number;
        -:  414:          bool sign;
    #####:  415:          jerry_bigint_to_digits (get_result, (uint64_t *) &get_number, 1, &sign);
        -:  416:
    #####:  417:          TEST_ASSERT (sign ? get_number : -get_number == test_int64_numbers[j]);
        -:  418:
    #####:  419:          jerry_value_free (test_number);
    #####:  420:          jerry_value_free (set_result);
    #####:  421:          jerry_value_free (get_result);
        -:  422:        }
        -:  423:        break;
        -:  424:      }
        -:  425:      case JERRY_TYPEDARRAY_BIGUINT64:
        -:  426:      {
    #####:  427:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  428:        {
    #####:  429:          test_number = jerry_bigint (&test_uint64_numbers[j], 1, false);
    #####:  430:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  431:          set_result = jerry_object_set_index (typedarray, j, test_number);
    #####:  432:          get_result = jerry_object_get_index (typedarray, j);
        -:  433:
    #####:  434:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  435:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  436:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
        -:  437:          uint64_t get_number;
        -:  438:          bool sign;
    #####:  439:          jerry_bigint_to_digits (get_result, &get_number, 1, &sign);
        -:  440:
    #####:  441:          TEST_ASSERT (get_number == test_uint64_numbers[j]);
        -:  442:
    #####:  443:          jerry_value_free (test_number);
    #####:  444:          jerry_value_free (set_result);
    #####:  445:          jerry_value_free (get_result);
        -:  446:        }
        -:  447:        break;
        -:  448:      }
        -:  449:      default:
        -:  450:      {
    #####:  451:        for (uint8_t j = 0; j < test_numbers_length; j++)
        -:  452:        {
    #####:  453:          test_number = jerry_number (test_uint_numbers[j]);
    #####:  454:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  455:          set_result = jerry_object_set_index (typedarray, j, test_number);
    #####:  456:          get_result = jerry_object_get_index (typedarray, j);
        -:  457:
    #####:  458:          TEST_ASSERT (jerry_value_is_boolean (set_result));
    #####:  459:          TEST_ASSERT (jerry_value_is_true (set_result));
    #####:  460:          TEST_ASSERT (jerry_value_is_false (jerry_object_delete_index (typedarray, j)));
    #####:  461:          TEST_ASSERT (jerry_value_as_number (get_result) == test_uint_numbers[j]);
        -:  462:
    #####:  463:          jerry_value_free (test_number);
    #####:  464:          jerry_value_free (set_result);
    #####:  465:          jerry_value_free (get_result);
        -:  466:        }
        -:  467:        break;
        -:  468:      }
        -:  469:    }
        -:  470:
    #####:  471:    jerry_value_t set_undefined = jerry_object_set_index (typedarray, 100, jerry_number (50));
        -:  472:
    #####:  473:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  474:    {
    #####:  475:      TEST_ASSERT (jerry_value_is_exception (set_undefined));
        -:  476:    }
        -:  477:    else
        -:  478:    {
    #####:  479:      TEST_ASSERT (jerry_value_is_boolean (set_undefined) && !jerry_value_is_true (set_undefined));
        -:  480:    }
        -:  481:
    #####:  482:    jerry_value_t get_undefined = jerry_object_get_index (typedarray, 100);
        -:  483:
    #####:  484:    if (type == JERRY_TYPEDARRAY_BIGINT64 || type == JERRY_TYPEDARRAY_BIGUINT64)
        -:  485:    {
    #####:  486:      TEST_ASSERT (jerry_value_is_exception (set_undefined));
        -:  487:    }
        -:  488:    else
        -:  489:    {
    #####:  490:      TEST_ASSERT (jerry_value_is_undefined (get_undefined));
        -:  491:    }
        -:  492:
    #####:  493:    TEST_ASSERT (jerry_value_is_undefined (get_undefined));
    #####:  494:    jerry_value_free (set_undefined);
    #####:  495:    jerry_value_free (get_undefined);
    #####:  496:    jerry_value_free (typedarray);
        -:  497:  }
    #####:  498:} /* test_property_by_index */
        -:  499:
        -:  500:static void
    #####:  501:test_detached_arraybuffer (void)
        -:  502:{
        -:  503:  static jerry_typedarray_type_t types[] = {
        -:  504:    JERRY_TYPEDARRAY_UINT8,   JERRY_TYPEDARRAY_UINT8CLAMPED, JERRY_TYPEDARRAY_INT8,      JERRY_TYPEDARRAY_UINT16,
        -:  505:    JERRY_TYPEDARRAY_INT16,   JERRY_TYPEDARRAY_UINT32,       JERRY_TYPEDARRAY_INT32,     JERRY_TYPEDARRAY_FLOAT32,
        -:  506:    JERRY_TYPEDARRAY_FLOAT64, JERRY_TYPEDARRAY_BIGINT64,     JERRY_TYPEDARRAY_BIGUINT64,
        -:  507:  };
        -:  508:
        -:  509:  /* Creating an TypedArray for a detached array buffer with a given length/offset is invalid */
        -:  510:  {
    #####:  511:    const uint32_t length = 1;
    #####:  512:    uint8_t *buffer_p = (uint8_t *) jerry_heap_alloc (length);
    #####:  513:    jerry_value_t arraybuffer = jerry_arraybuffer_external (buffer_p, length, NULL);
    #####:  514:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  515:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  516:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
        -:  517:
    #####:  518:    TEST_ASSERT (jerry_arraybuffer_is_detachable (arraybuffer));
        -:  519:
    #####:  520:    jerry_value_t res = jerry_arraybuffer_detach (arraybuffer);
    #####:  521:    TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  522:    jerry_value_free (res);
        -:  523:
    #####:  524:    TEST_ASSERT (!jerry_arraybuffer_is_detachable (arraybuffer));
        -:  525:
    #####:  526:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  527:    {
    #####:  528:      jerry_value_t typedarray = jerry_typedarray_with_buffer_span (types[idx], arraybuffer, 0, 4);
    #####:  529:      TEST_ASSERT (jerry_value_is_exception (typedarray));
    #####:  530:      TEST_ASSERT (jerry_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  531:      jerry_value_free (typedarray);
        -:  532:    }
        -:  533:
    #####:  534:    jerry_value_free (arraybuffer);
        -:  535:  }
        -:  536:
        -:  537:  /* Creating an TypedArray for a detached array buffer without length/offset is valid */
        -:  538:  {
    #####:  539:    const uint32_t length = 1;
    #####:  540:    uint8_t *buffer_p = (uint8_t *) jerry_heap_alloc (length);
    #####:  541:    jerry_value_t arraybuffer = jerry_arraybuffer_external (buffer_p, length, NULL);
    #####:  542:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  543:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  544:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
        -:  545:
    #####:  546:    TEST_ASSERT (jerry_arraybuffer_is_detachable (arraybuffer));
        -:  547:
    #####:  548:    jerry_value_t res = jerry_arraybuffer_detach (arraybuffer);
    #####:  549:    TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  550:    jerry_value_free (res);
        -:  551:
    #####:  552:    TEST_ASSERT (!jerry_arraybuffer_is_detachable (arraybuffer));
        -:  553:
    #####:  554:    for (size_t idx = 0; idx < (sizeof (types) / sizeof (types[0])); idx++)
        -:  555:    {
    #####:  556:      jerry_value_t typedarray = jerry_typedarray_with_buffer (types[idx], arraybuffer);
    #####:  557:      TEST_ASSERT (jerry_value_is_exception (typedarray));
    #####:  558:      TEST_ASSERT (jerry_error_type (typedarray) == JERRY_ERROR_TYPE);
    #####:  559:      jerry_value_free (typedarray);
        -:  560:    }
        -:  561:
    #####:  562:    jerry_value_free (arraybuffer);
        -:  563:  }
    #####:  564:} /* test_detached_arraybuffer */
        -:  565:
        -:  566:int
    #####:  567:main (void)
        -:  568:{
    #####:  569:  jerry_init (JERRY_INIT_EMPTY);
        -:  570:
    #####:  571:  if (!jerry_feature_enabled (JERRY_FEATURE_TYPEDARRAY))
        -:  572:  {
    #####:  573:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TypedArray is disabled!\n");
    #####:  574:    jerry_cleanup ();
    #####:  575:    return 0;
        -:  576:  }
        -:  577:
    #####:  578:  jerry_value_t function_val = jerry_function_external (assert_handler);
    #####:  579:  register_js_value ("assert", function_val);
    #####:  580:  jerry_value_free (function_val);
        -:  581:
    #####:  582:  test_entry_t test_entries[] = {
        -:  583:#define TEST_ENTRY(TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT) { TYPE, CONSTRUCTOR, COUNT, BYTES_PER_ELEMENT }
        -:  584:
        -:  585:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8, "Uint8Array", 12, 1),
        -:  586:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT8CLAMPED, "Uint8ClampedArray", 12, 1),
        -:  587:    TEST_ENTRY (JERRY_TYPEDARRAY_INT8, "Int8Array", 12, 1),
        -:  588:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16, "Uint16Array", 12, 2),
        -:  589:    TEST_ENTRY (JERRY_TYPEDARRAY_INT16, "Int16Array", 12, 2),
        -:  590:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT16, "Uint16Array", 12, 2),
        -:  591:    TEST_ENTRY (JERRY_TYPEDARRAY_INT32, "Int32Array", 12, 4),
        -:  592:    TEST_ENTRY (JERRY_TYPEDARRAY_UINT32, "Uint32Array", 12, 4),
        -:  593:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT32, "Float32Array", 12, 4),
        -:  594:    /* TODO: add check if the float64 is supported */
        -:  595:    TEST_ENTRY (JERRY_TYPEDARRAY_FLOAT64, "Float64Array", 12, 8),
        -:  596:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGINT64, "BigInt64Array", 12, 8),
        -:  597:    TEST_ENTRY (JERRY_TYPEDARRAY_BIGUINT64, "BigUint64Array", 12, 8),
        -:  598:
        -:  599:    TEST_ENTRY (JERRY_TYPEDARRAY_INVALID, NULL, 0, 0)
        -:  600:#undef TEST_ENTRY
        -:  601:  };
        -:  602:
        -:  603:  /* Test TypedArray queries */
    #####:  604:  test_typedarray_queries (test_entries);
        -:  605:
        -:  606:  /* Test TypedArray operations in js */
        -:  607:  {
    #####:  608:    const uint32_t element_count = 14;
        -:  609:
    #####:  610:    jerry_value_t array = jerry_typedarray (JERRY_TYPEDARRAY_UINT8, element_count);
        -:  611:
    #####:  612:    {
    #####:  613:      uint8_t expected_value = 42;
    #####:  614:      JERRY_VLA (uint8_t, expected_data, element_count);
    #####:  615:      memset (expected_data, expected_value, element_count);
        -:  616:
        -:  617:      jerry_length_t byte_length;
        -:  618:      jerry_length_t offset;
    #####:  619:      jerry_value_t buffer = jerry_typedarray_buffer (array, &offset, &byte_length);
    #####:  620:      TEST_ASSERT (byte_length == element_count);
    #####:  621:      jerry_length_t written = jerry_arraybuffer_write (buffer, offset, expected_data, element_count);
    #####:  622:      TEST_ASSERT (written == element_count);
    #####:  623:      jerry_value_free (buffer);
        -:  624:
    #####:  625:      jerry_value_t js_element_count = jerry_number (element_count);
    #####:  626:      jerry_value_t js_expected_value = jerry_number (expected_value);
        -:  627:
    #####:  628:      register_js_value ("array", array);
    #####:  629:      register_js_value ("expected_length", js_element_count);
    #####:  630:      register_js_value ("expected_value", js_expected_value);
        -:  631:
    #####:  632:      jerry_value_free (js_element_count);
    #####:  633:      jerry_value_free (js_expected_value);
        -:  634:    }
        -:  635:
        -:  636:    /* Check read and to write */
    #####:  637:    const jerry_char_t eval_src[] = TEST_STRING_LITERAL (
        -:  638:      "assert (array.length == expected_length, 'expected length: ' + expected_length + ' got: ' + array.length);"
        -:  639:      "for (var i = 0; i < array.length; i++)"
        -:  640:      "{"
        -:  641:      "  assert (array[i] == expected_value);"
        -:  642:      "  array[i] = i;"
        -:  643:      "};");
    #####:  644:    jerry_value_t result = jerry_eval (eval_src, sizeof (eval_src) - 1, JERRY_PARSE_STRICT_MODE);
        -:  645:
    #####:  646:    TEST_ASSERT (!jerry_value_is_exception (result));
    #####:  647:    jerry_value_free (result);
        -:  648:
        -:  649:    /* Check write results */
    #####:  650:    {
        -:  651:      jerry_length_t byte_length;
        -:  652:      jerry_length_t offset;
    #####:  653:      jerry_value_t buffer = jerry_typedarray_buffer (array, &offset, &byte_length);
    #####:  654:      TEST_ASSERT (byte_length == element_count);
        -:  655:
    #####:  656:      JERRY_VLA (uint8_t, result_data, element_count);
        -:  657:
    #####:  658:      jerry_length_t read_count = jerry_arraybuffer_read (buffer, offset, result_data, byte_length);
    #####:  659:      TEST_ASSERT (read_count == byte_length);
        -:  660:
    #####:  661:      for (uint8_t i = 0; i < read_count; i++)
        -:  662:      {
    #####:  663:        TEST_ASSERT (result_data[i] == i);
        -:  664:      }
        -:  665:
    #####:  666:      jerry_value_free (buffer);
        -:  667:    }
        -:  668:
    #####:  669:    jerry_value_free (array);
        -:  670:  }
        -:  671:
    #####:  672:  test_typedarray_complex_creation (test_entries, false);
    #####:  673:  test_typedarray_complex_creation (test_entries, true);
        -:  674:
    #####:  675:  test_property_by_index (test_entries);
        -:  676:
        -:  677:  /* test invalid things */
        -:  678:  {
    #####:  679:    jerry_value_t values[] = {
    #####:  680:      jerry_number (11),
    #####:  681:      jerry_boolean (false),
    #####:  682:      jerry_string_sz ("test"),
    #####:  683:      jerry_object (),
    #####:  684:      jerry_null (),
    #####:  685:      jerry_arraybuffer (16),
    #####:  686:      jerry_error_sz (JERRY_ERROR_TYPE, "error"),
    #####:  687:      jerry_undefined (),
    #####:  688:      jerry_promise (),
        -:  689:    };
        -:  690:
    #####:  691:    for (size_t idx = 0; idx < sizeof (values) / sizeof (values[0]); idx++)
        -:  692:    {
        -:  693:      /* A non-TypedArray object should not be regarded a TypedArray. */
    #####:  694:      bool is_typedarray = jerry_value_is_typedarray (values[idx]);
    #####:  695:      TEST_ASSERT (is_typedarray == false);
        -:  696:
        -:  697:      /* JERRY_TYPEDARRAY_INVALID should be returned for non-TypedArray objects */
    #####:  698:      jerry_typedarray_type_t type = jerry_typedarray_type (values[idx]);
    #####:  699:      TEST_ASSERT (type == JERRY_TYPEDARRAY_INVALID);
        -:  700:
        -:  701:      /* Zero should be returned for non-TypedArray objects */
    #####:  702:      jerry_length_t length = jerry_typedarray_length (values[idx]);
    #####:  703:      TEST_ASSERT (length == 0);
        -:  704:
        -:  705:      /**
        -:  706:       * Getting the ArrayBuffer from a non-TypedArray object(s) should return an error
        -:  707:       * and should not modify the output parameter values.
        -:  708:       */
        -:  709:      {
    #####:  710:        jerry_length_t offset = 22;
    #####:  711:        jerry_length_t byte_count = 23;
    #####:  712:        jerry_value_t error = jerry_typedarray_buffer (values[idx], &offset, &byte_count);
    #####:  713:        TEST_ASSERT (jerry_value_is_exception (error));
    #####:  714:        TEST_ASSERT (offset == 22);
    #####:  715:        TEST_ASSERT (byte_count == 23);
    #####:  716:        jerry_value_free (error);
        -:  717:      }
        -:  718:
        -:  719:      /**
        -:  720:       * Creating a TypedArray from a non-ArrayBuffer should result an error.
        -:  721:       */
    #####:  722:      if (!jerry_value_is_arraybuffer (values[idx]))
        -:  723:      {
    #####:  724:        jerry_value_t error = jerry_typedarray_with_buffer (JERRY_TYPEDARRAY_UINT8, values[idx]);
    #####:  725:        TEST_ASSERT (jerry_value_is_exception (error));
    #####:  726:        jerry_value_free (error);
        -:  727:      }
        -:  728:
    #####:  729:      jerry_value_free (values[idx]);
        -:  730:    }
        -:  731:  }
        -:  732:
    #####:  733:  test_detached_arraybuffer ();
        -:  734:
    #####:  735:  jerry_cleanup ();
        -:  736:
    #####:  737:  return 0;
        -:  738:} /* main */
