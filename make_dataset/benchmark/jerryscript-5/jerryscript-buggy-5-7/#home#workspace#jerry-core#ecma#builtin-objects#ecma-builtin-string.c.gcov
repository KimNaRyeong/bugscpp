        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-string.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:#include "ecma-objects.h"
        -:   24:#include "ecma-string-object.h"
        -:   25:
        -:   26:#include "lit-strings.h"
        -:   27:#if JERRY_ESNEXT
        -:   28:#include "ecma-symbol-object.h"
        -:   29:#endif /* JERRY_ESNEXT */
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_STRING
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_BUILTIN_STRING_ROUTINE_START = 0,
        -:   48:  ECMA_BUILTIN_STRING_OBJECT_FROM_CHAR_CODE,
        -:   49:  ECMA_BUILTIN_STRING_OBJECT_FROM_CODE_POINT,
        -:   50:  ECMA_BUILTIN_STRING_OBJECT_RAW,
        -:   51:};
        -:   52:
        -:   53:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-string.inc.h"
        -:   54:#define BUILTIN_UNDERSCORED_ID  string
        -:   55:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   56:
        -:   57:/** \addtogroup ecma ECMA
        -:   58: * @{
        -:   59: *
        -:   60: * \addtogroup ecmabuiltins
        -:   61: * @{
        -:   62: *
        -:   63: * \addtogroup string ECMA String object built-in
        -:   64: * @{
        -:   65: */
        -:   66:
        -:   67:/**
        -:   68: * The String object's 'fromCharCode' routine
        -:   69: *
        -:   70: * See also:
        -:   71: *          ECMA-262 v5, 15.5.3.2
        -:   72: *
        -:   73: * @return ecma value
        -:   74: *         Returned value must be freed with ecma_free_value.
        -:   75: */
        -:   76:static ecma_value_t
    #####:   77:ecma_builtin_string_object_from_char_code (const ecma_value_t args[], /**< arguments list */
        -:   78:                                           uint32_t args_number) /**< number of arguments */
        -:   79:{
    #####:   80:  if (args_number == 0)
        -:   81:  {
    #####:   82:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:   83:  }
        -:   84:
    #####:   85:  lit_utf8_size_t utf8_buf_size = args_number * LIT_CESU8_MAX_BYTES_IN_CODE_UNIT;
    #####:   86:  ecma_string_t *ret_string_p = NULL;
    #####:   87:  bool isError = false;
        -:   88:
    #####:   89:  JMEM_DEFINE_LOCAL_ARRAY (utf8_buf_p, utf8_buf_size, lit_utf8_byte_t);
        -:   90:
    #####:   91:  lit_utf8_size_t utf8_buf_used = 0;
        -:   92:
    #####:   93:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:   94:  {
    #####:   95:    ecma_number_t arg_num;
        -:   96:
    #####:   97:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (args[arg_index], &arg_num)))
        -:   98:    {
    #####:   99:      isError = true;
    #####:  100:      break;
        -:  101:    }
        -:  102:
    #####:  103:    uint32_t uint32_char_code = ecma_number_to_uint32 (arg_num);
    #####:  104:    ecma_char_t code_unit = (uint16_t) uint32_char_code;
        -:  105:
    #####:  106:    JERRY_ASSERT (utf8_buf_used <= utf8_buf_size - LIT_UTF8_MAX_BYTES_IN_CODE_UNIT);
    #####:  107:    utf8_buf_used += lit_code_unit_to_utf8 (code_unit, utf8_buf_p + utf8_buf_used);
    #####:  108:    JERRY_ASSERT (utf8_buf_used <= utf8_buf_size);
        -:  109:  }
        -:  110:
    #####:  111:  if (!isError)
        -:  112:  {
    #####:  113:    ret_string_p = ecma_new_ecma_string_from_utf8 (utf8_buf_p, utf8_buf_used);
        -:  114:  }
        -:  115:
    #####:  116:  JMEM_FINALIZE_LOCAL_ARRAY (utf8_buf_p);
        -:  117:
    #####:  118:  return isError ? ECMA_VALUE_ERROR : ecma_make_string_value (ret_string_p);
        -:  119:} /* ecma_builtin_string_object_from_char_code */
        -:  120:
        -:  121:#if JERRY_ESNEXT
        -:  122:
        -:  123:/**
        -:  124: * The String object's 'raw' routine
        -:  125: *
        -:  126: * See also:
        -:  127: *          ECMA-262 v6, 21.1.2.4
        -:  128: *
        -:  129: * @return ecma value
        -:  130: *         Returned value must be freed with ecma_free_value.
        -:  131: */
        -:  132:static ecma_value_t
    #####:  133:ecma_builtin_string_object_raw (const ecma_value_t args[], /**< arguments list */
        -:  134:                                uint32_t args_number) /**< number of arguments */
        -:  135:{
        -:  136:  /* 1 - 2. */
        -:  137:  const ecma_value_t *substitutions;
        -:  138:  uint32_t number_of_substitutions;
        -:  139:
    #####:  140:  if (args_number > 1)
        -:  141:  {
    #####:  142:    substitutions = args + 1;
    #####:  143:    number_of_substitutions = args_number - 1;
        -:  144:  }
        -:  145:  else
        -:  146:  {
    #####:  147:    substitutions = NULL;
    #####:  148:    number_of_substitutions = 0;
        -:  149:  }
        -:  150:
        -:  151:  /* 3. */
    #####:  152:  ecma_value_t template = args_number > 0 ? args[0] : ECMA_VALUE_UNDEFINED;
        -:  153:
    #####:  154:  ecma_value_t cooked = ecma_op_to_object (template);
        -:  155:
        -:  156:  /* 4. */
    #####:  157:  if (ECMA_IS_VALUE_ERROR (cooked))
        -:  158:  {
    #####:  159:    return cooked;
        -:  160:  }
        -:  161:
    #####:  162:  ecma_object_t *cooked_obj_p = ecma_get_object_from_value (cooked);
        -:  163:
        -:  164:  /* 5. */
    #####:  165:  ecma_value_t raw = ecma_op_object_get_by_magic_id (cooked_obj_p, LIT_MAGIC_STRING_RAW);
        -:  166:
    #####:  167:  ecma_deref_object (cooked_obj_p);
        -:  168:
    #####:  169:  if (ECMA_IS_VALUE_ERROR (raw))
        -:  170:  {
    #####:  171:    return raw;
        -:  172:  }
        -:  173:
    #####:  174:  ecma_value_t raw_obj = ecma_op_to_object (raw);
        -:  175:
        -:  176:  /* 6. */
    #####:  177:  if (ECMA_IS_VALUE_ERROR (raw_obj))
        -:  178:  {
    #####:  179:    ecma_free_value (raw);
    #####:  180:    return raw_obj;
        -:  181:  }
        -:  182:
    #####:  183:  ecma_object_t *raw_obj_p = ecma_get_object_from_value (raw_obj);
        -:  184:
    #####:  185:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  186:
        -:  187:  /* 7 - 8. */
    #####:  188:  ecma_length_t literal_segments;
    #####:  189:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (raw_obj_p, &literal_segments)))
        -:  190:  {
    #####:  191:    goto cleanup;
        -:  192:  }
        -:  193:
        -:  194:  /* 9. */
    #####:  195:  if (literal_segments == 0)
        -:  196:  {
    #####:  197:    ret_value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
    #####:  198:    goto cleanup;
        -:  199:  }
        -:  200:
        -:  201:  /* 10. */
    #####:  202:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  203:
        -:  204:  /* 11. */
    #####:  205:  ecma_length_t next_index = 0;
        -:  206:
        -:  207:  /* 12. */
        -:  208:  while (true)
    #####:  209:  {
        -:  210:    /* 12.a,b */
    #####:  211:    ecma_value_t next_seg = ecma_op_object_get_by_index (raw_obj_p, next_index);
        -:  212:
    #####:  213:    if (ECMA_IS_VALUE_ERROR (next_seg))
        -:  214:    {
    #####:  215:      goto builder_cleanup;
        -:  216:    }
        -:  217:
    #####:  218:    ecma_string_t *next_seg_srt_p = ecma_op_to_string (next_seg);
        -:  219:
        -:  220:    /* 12.c */
    #####:  221:    if (JERRY_UNLIKELY (next_seg_srt_p == NULL))
        -:  222:    {
    #####:  223:      ecma_free_value (next_seg);
    #####:  224:      goto builder_cleanup;
        -:  225:    }
        -:  226:
        -:  227:    /* 12.d */
    #####:  228:    ecma_stringbuilder_append (&builder, next_seg_srt_p);
        -:  229:
    #####:  230:    ecma_deref_ecma_string (next_seg_srt_p);
    #####:  231:    ecma_free_value (next_seg);
        -:  232:
        -:  233:    /* 12.e */
    #####:  234:    if (next_index + 1 == literal_segments)
        -:  235:    {
    #####:  236:      ret_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
    #####:  237:      goto cleanup;
        -:  238:    }
        -:  239:
        -:  240:    /* 12.f-g */
    #####:  241:    if (next_index >= number_of_substitutions)
        -:  242:    {
    #####:  243:      next_index++;
    #####:  244:      continue;
        -:  245:    }
        -:  246:
        -:  247:    /* 12.h */
    #####:  248:    ecma_string_t *next_sub_p = ecma_op_to_string (substitutions[next_index]);
        -:  249:
        -:  250:    /* 12.i */
    #####:  251:    if (JERRY_UNLIKELY (next_sub_p == NULL))
        -:  252:    {
    #####:  253:      goto builder_cleanup;
        -:  254:    }
        -:  255:
        -:  256:    /* 12.j */
    #####:  257:    ecma_stringbuilder_append (&builder, next_sub_p);
    #####:  258:    ecma_deref_ecma_string (next_sub_p);
        -:  259:
        -:  260:    /* 12.k */
    #####:  261:    next_index++;
        -:  262:  }
        -:  263:
    #####:  264:builder_cleanup:
    #####:  265:  ecma_stringbuilder_destroy (&builder);
        -:  266:
    #####:  267:cleanup:
    #####:  268:  ecma_deref_object (raw_obj_p);
    #####:  269:  ecma_free_value (raw);
        -:  270:
    #####:  271:  return ret_value;
        -:  272:} /* ecma_builtin_string_object_raw */
        -:  273:
        -:  274:/**
        -:  275: * The String object's 'fromCodePoint' routine
        -:  276: *
        -:  277: * See also:
        -:  278: *          ECMA-262 v6, 21.1.2.2
        -:  279: *
        -:  280: * @return ecma value
        -:  281: *         Returned value must be freed with ecma_free_value.
        -:  282: */
        -:  283:static ecma_value_t
    #####:  284:ecma_builtin_string_object_from_code_point (const ecma_value_t args[], /**< arguments list */
        -:  285:                                            uint32_t args_number) /**< number of arguments */
        -:  286:{
    #####:  287:  if (args_number == 0)
        -:  288:  {
    #####:  289:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  290:  }
        -:  291:
    #####:  292:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  293:
    #####:  294:  for (uint32_t index = 0; index < args_number; index++)
        -:  295:  {
    #####:  296:    ecma_number_t to_number_num;
    #####:  297:    ecma_value_t to_number_value = ecma_op_to_number (args[index], &to_number_num);
        -:  298:
    #####:  299:    if (ECMA_IS_VALUE_ERROR (to_number_value))
        -:  300:    {
    #####:  301:      ecma_stringbuilder_destroy (&builder);
    #####:  302:      return to_number_value;
        -:  303:    }
        -:  304:
    #####:  305:    if (!ecma_op_is_integer (to_number_num))
        -:  306:    {
    #####:  307:      ecma_stringbuilder_destroy (&builder);
    #####:  308:      return ecma_raise_range_error (ECMA_ERR_INVALID_CODE_POINT_ERROR);
        -:  309:    }
        -:  310:
    #####:  311:    ecma_free_value (to_number_value);
        -:  312:
    #####:  313:    if (to_number_num < 0 || to_number_num > LIT_UNICODE_CODE_POINT_MAX)
        -:  314:    {
    #####:  315:      ecma_stringbuilder_destroy (&builder);
    #####:  316:      return ecma_raise_range_error (ECMA_ERR_INVALID_CODE_POINT);
        -:  317:    }
        -:  318:
    #####:  319:    lit_code_point_t code_point = (lit_code_point_t) to_number_num;
        -:  320:
    #####:  321:    ecma_char_t converted_cp[2];
    #####:  322:    uint8_t encoded_size = lit_utf16_encode_code_point (code_point, converted_cp);
        -:  323:
    #####:  324:    for (uint8_t i = 0; i < encoded_size; i++)
        -:  325:    {
    #####:  326:      ecma_stringbuilder_append_char (&builder, converted_cp[i]);
        -:  327:    }
        -:  328:  }
        -:  329:
    #####:  330:  ecma_string_t *ret_str_p = ecma_stringbuilder_finalize (&builder);
        -:  331:
    #####:  332:  return ecma_make_string_value (ret_str_p);
        -:  333:} /* ecma_builtin_string_object_from_code_point */
        -:  334:
        -:  335:#endif /* JERRY_ESNEXT */
        -:  336:
        -:  337:/**
        -:  338: * Handle calling [[Call]] of built-in String object
        -:  339: *
        -:  340: * See also:
        -:  341: *          ECMA-262 v6, 21.1.1.1
        -:  342: *
        -:  343: * @return ecma value
        -:  344: */
        -:  345:ecma_value_t
    #####:  346:ecma_builtin_string_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  347:                                   uint32_t arguments_list_len) /**< number of arguments */
        -:  348:{
    #####:  349:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  350:
    #####:  351:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  352:
        -:  353:  /* 1. */
    #####:  354:  if (arguments_list_len == 0)
        -:  355:  {
    #####:  356:    ret_value = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  357:  }
        -:  358:#if JERRY_ESNEXT
        -:  359:  /* 2.a */
    #####:  360:  else if (ecma_is_value_symbol (arguments_list_p[0]))
        -:  361:  {
    #####:  362:    ret_value = ecma_get_symbol_descriptive_string (arguments_list_p[0]);
        -:  363:  }
        -:  364:#endif /* JERRY_ESNEXT */
        -:  365:  /* 2.b */
        -:  366:  else
        -:  367:  {
    #####:  368:    ecma_string_t *str_p = ecma_op_to_string (arguments_list_p[0]);
    #####:  369:    if (JERRY_UNLIKELY (str_p == NULL))
        -:  370:    {
    #####:  371:      return ECMA_VALUE_ERROR;
        -:  372:    }
        -:  373:
    #####:  374:    ret_value = ecma_make_string_value (str_p);
        -:  375:  }
        -:  376:
    #####:  377:  return ret_value;
        -:  378:} /* ecma_builtin_string_dispatch_call */
        -:  379:
        -:  380:/**
        -:  381: * Handle calling [[Construct]] of built-in String object
        -:  382: *
        -:  383: * @return ecma value
        -:  384: */
        -:  385:ecma_value_t
    #####:  386:ecma_builtin_string_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  387:                                        uint32_t arguments_list_len) /**< number of arguments */
        -:  388:{
    #####:  389:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  390:
    #####:  391:  return ecma_op_create_string_object (arguments_list_p, arguments_list_len);
        -:  392:} /* ecma_builtin_string_dispatch_construct */
        -:  393:
        -:  394:/**
        -:  395: * Dispatcher of the built-in's routines
        -:  396: *
        -:  397: * @return ecma value
        -:  398: *         Returned value must be freed with ecma_free_value.
        -:  399: */
        -:  400:ecma_value_t
    #####:  401:ecma_builtin_string_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  402:                                      ecma_value_t this_arg, /**< 'this' argument value */
        -:  403:                                      const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  404:                                                                              *   passed to routine */
        -:  405:                                      uint32_t arguments_number) /**< length of arguments' list */
        -:  406:{
        -:  407:  JERRY_UNUSED (this_arg);
        -:  408:
    #####:  409:  switch (builtin_routine_id)
        -:  410:  {
    #####:  411:    case ECMA_BUILTIN_STRING_OBJECT_FROM_CHAR_CODE:
        -:  412:    {
    #####:  413:      return ecma_builtin_string_object_from_char_code (arguments_list_p, arguments_number);
        -:  414:    }
        -:  415:#if JERRY_ESNEXT
    #####:  416:    case ECMA_BUILTIN_STRING_OBJECT_FROM_CODE_POINT:
        -:  417:    {
    #####:  418:      return ecma_builtin_string_object_from_code_point (arguments_list_p, arguments_number);
        -:  419:    }
    #####:  420:    case ECMA_BUILTIN_STRING_OBJECT_RAW:
        -:  421:    {
    #####:  422:      return ecma_builtin_string_object_raw (arguments_list_p, arguments_number);
        -:  423:    }
        -:  424:#endif /* JERRY_ESNEXT */
    #####:  425:    default:
        -:  426:    {
    #####:  427:      JERRY_UNREACHABLE ();
        -:  428:    }
        -:  429:  }
        -:  430:} /* ecma_builtin_string_dispatch_routine */
        -:  431:
        -:  432:/**
        -:  433: * @}
        -:  434: * @}
        -:  435: * @}
        -:  436: */
        -:  437:
        -:  438:#endif /* JERRY_BUILTIN_STRING */
