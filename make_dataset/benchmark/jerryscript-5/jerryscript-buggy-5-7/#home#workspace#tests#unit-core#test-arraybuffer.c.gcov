        -:    0:Source:/home/workspace/tests/unit-core/test-arraybuffer.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript-port-default.h"
        -:   17:#include "jerryscript-port.h"
        -:   18:#include "jerryscript.h"
        -:   19:
        -:   20:#include "test-common.h"
        -:   21:
        -:   22:/**
        -:   23: * Register a JavaScript value in the global object.
        -:   24: */
        -:   25:static void
    #####:   26:register_js_value (const char *name_p, /**< name of the function */
        -:   27:                   jerry_value_t value) /**< JS value */
        -:   28:{
    #####:   29:  jerry_value_t global_obj_val = jerry_current_realm ();
        -:   30:
    #####:   31:  jerry_value_t name_val = jerry_string_sz (name_p);
    #####:   32:  jerry_value_t result_val = jerry_object_set (global_obj_val, name_val, value);
    #####:   33:  TEST_ASSERT (jerry_value_is_boolean (result_val));
        -:   34:
    #####:   35:  jerry_value_free (name_val);
    #####:   36:  jerry_value_free (global_obj_val);
        -:   37:
    #####:   38:  jerry_value_free (result_val);
    #####:   39:} /* register_js_value */
        -:   40:
        -:   41:static jerry_value_t
    #####:   42:assert_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   43:                const jerry_value_t args_p[], /**< function arguments */
        -:   44:                const jerry_length_t args_cnt) /**< number of function arguments */
        -:   45:{
        -:   46:  JERRY_UNUSED (call_info_p);
        -:   47:
    #####:   48:  if (args_cnt > 0 && jerry_value_is_true (args_p[0]))
        -:   49:  {
    #####:   50:    return jerry_boolean (true);
        -:   51:  }
        -:   52:
    #####:   53:  if (args_cnt > 1 && jerry_value_is_string (args_p[1]))
    #####:   54:  {
    #####:   55:    jerry_length_t utf8_sz = jerry_string_size (args_p[1], JERRY_ENCODING_CESU8);
    #####:   56:    TEST_ASSERT (utf8_sz <= 127); /* 127 is the expected max assert fail message size. */
    #####:   57:    JERRY_VLA (char, string_from_utf8, utf8_sz + 1);
    #####:   58:    string_from_utf8[utf8_sz] = 0;
        -:   59:
    #####:   60:    jerry_string_to_buffer (args_p[1], JERRY_ENCODING_CESU8, (jerry_char_t *) string_from_utf8, utf8_sz);
        -:   61:
    #####:   62:    printf ("JS assert: %s\n", string_from_utf8);
        -:   63:  }
        -:   64:
    #####:   65:  TEST_ASSERT (false);
        -:   66:} /* assert_handler */
        -:   67:
        -:   68:/**
        -:   69: * Test ArrayBuffer 'read' api call with various offset values.
        -:   70: */
        -:   71:static void
    #####:   72:test_read_with_offset (uint8_t offset) /**< offset for buffer read. */
        -:   73:{
    #####:   74:  const jerry_char_t eval_arraybuffer_src[] =
        -:   75:    TEST_STRING_LITERAL ("var array = new Uint8Array (15);"
        -:   76:                         "for (var i = 0; i < array.length; i++) { array[i] = i * 2; };"
        -:   77:                         "array.buffer");
    #####:   78:  jerry_value_t arraybuffer =
        -:   79:    jerry_eval (eval_arraybuffer_src, sizeof (eval_arraybuffer_src) - 1, JERRY_PARSE_STRICT_MODE);
        -:   80:
    #####:   81:  TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:   82:  TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:   83:  TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == 15);
        -:   84:
        -:   85:  uint8_t buffer[20];
    #####:   86:  memset (buffer, 120, 20);
        -:   87:
        -:   88:  /* Try to copy more than the target buffer size. */
    #####:   89:  jerry_length_t copied = jerry_arraybuffer_read (arraybuffer, offset, buffer, 20);
    #####:   90:  TEST_ASSERT (copied == (jerry_length_t) (15 - offset));
        -:   91:
    #####:   92:  for (uint8_t i = 0; i < copied; i++)
        -:   93:  {
    #####:   94:    TEST_ASSERT (buffer[i] == (i + offset) * 2);
        -:   95:  }
    #####:   96:  TEST_ASSERT (buffer[15 - offset] == 120);
        -:   97:
    #####:   98:  jerry_value_free (arraybuffer);
    #####:   99:} /* test_read_with_offset */
        -:  100:
        -:  101:/**
        -:  102: * Test ArrayBuffer 'write' api call with various offset values.
        -:  103: */
        -:  104:static void
    #####:  105:test_write_with_offset (uint8_t offset) /**< offset for buffer write. */
        -:  106:{
        -:  107:  {
    #####:  108:    jerry_value_t offset_val = jerry_number (offset);
    #####:  109:    register_js_value ("offset", offset_val);
    #####:  110:    jerry_value_free (offset_val);
        -:  111:  }
        -:  112:
    #####:  113:  const jerry_char_t eval_arraybuffer_src[] = "var array = new Uint8Array (15); array.buffer";
    #####:  114:  jerry_value_t arraybuffer =
        -:  115:    jerry_eval (eval_arraybuffer_src, sizeof (eval_arraybuffer_src) - 1, JERRY_PARSE_STRICT_MODE);
        -:  116:
    #####:  117:  TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  118:  TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  119:  TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == 15);
        -:  120:
        -:  121:  uint8_t buffer[20];
        -:  122:
    #####:  123:  for (uint8_t i = 0; i < 20; i++)
        -:  124:  {
    #####:  125:    buffer[i] = (uint8_t) (i * 3);
        -:  126:  }
        -:  127:
        -:  128:  /* Intentionally copy more than the allowed space. */
    #####:  129:  jerry_length_t copied = jerry_arraybuffer_write (arraybuffer, offset, buffer, 20);
    #####:  130:  TEST_ASSERT (copied == (jerry_length_t) (15 - offset));
        -:  131:
    #####:  132:  const jerry_char_t eval_test_arraybuffer[] = TEST_STRING_LITERAL (
        -:  133:    "for (var i = 0; i < offset; i++)"
        -:  134:    "{"
        -:  135:    "  assert (array[i] == 0, 'offset check for: ' + i + ' was: ' + array[i] + ' should be: 0');"
        -:  136:    "};"
        -:  137:    "for (var i = offset; i < array.length; i++)"
        -:  138:    "{"
        -:  139:    "  var expected = (i - offset) * 3;"
        -:  140:    "  assert (array[i] == expected, 'calc check for: ' + i + ' was: ' + array[i] + ' should be: ' + expected);"
        -:  141:    "};"
        -:  142:    "assert (array[15] === undefined, 'ArrayBuffer out of bounds index should return undefined value');");
    #####:  143:  jerry_value_t res = jerry_eval (eval_test_arraybuffer, sizeof (eval_test_arraybuffer) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  144:  jerry_value_free (res);
    #####:  145:  jerry_value_free (arraybuffer);
    #####:  146:} /* test_write_with_offset */
        -:  147:
        -:  148:static int allocate_mode = 0;
        -:  149:static int allocate_count = 0;
        -:  150:static int free_count = 0;
        -:  151:
        -:  152:static uint8_t *
    #####:  153:test_allocate_cb (jerry_arraybuffer_type_t buffer_type, /**< type of the array buffer object */
        -:  154:                  uint32_t buffer_size, /**< size of the requested buffer */
        -:  155:                  void **buffer_user_p, /**< [in/out] user pointer assigned to the array buffer object */
        -:  156:                  void *user_p) /**< user pointer passed to jerry_arraybuffer_set_allocation_callbacks */
        -:  157:{
    #####:  158:  TEST_ASSERT (buffer_type == JERRY_ARRAYBUFFER_TYPE_ARRAYBUFFER);
    #####:  159:  TEST_ASSERT (user_p == (void *) &allocate_mode);
        -:  160:
    #####:  161:  if (*buffer_user_p != NULL)
        -:  162:  {
    #####:  163:    TEST_ASSERT (*buffer_user_p == (void *) &allocate_count);
    #####:  164:    TEST_ASSERT (buffer_size == 20);
    #####:  165:    allocate_count++;
    #####:  166:    *buffer_user_p = (void *) &free_count;
        -:  167:  }
        -:  168:  else
        -:  169:  {
    #####:  170:    *buffer_user_p = (void *) &allocate_mode;
        -:  171:  }
    #####:  172:  return (uint8_t *) malloc (buffer_size);
        -:  173:} /* test_allocate_cb */
        -:  174:
        -:  175:static void
    #####:  176:test_free_cb (jerry_arraybuffer_type_t buffer_type, /**< type of the array buffer object */
        -:  177:              uint8_t *buffer_p, /**< pointer to the allocated buffer */
        -:  178:              uint32_t buffer_size, /**< size of the allocated buffer */
        -:  179:              void *buffer_user_p, /**< user pointer assigned to the array buffer object */
        -:  180:              void *user_p) /**< user pointer passed to jerry_arraybuffer_set_allocation_callbacks */
        -:  181:{
    #####:  182:  TEST_ASSERT (buffer_type == JERRY_ARRAYBUFFER_TYPE_ARRAYBUFFER);
    #####:  183:  TEST_ASSERT (user_p == (void *) &allocate_mode);
        -:  184:
    #####:  185:  if (buffer_user_p == NULL)
        -:  186:  {
    #####:  187:    TEST_ASSERT (buffer_size == 15);
    #####:  188:    free_count++;
        -:  189:  }
    #####:  190:  else if (buffer_user_p == (void *) &free_count)
        -:  191:  {
    #####:  192:    TEST_ASSERT (buffer_size == 20);
    #####:  193:    free_count++;
        -:  194:  }
        -:  195:  else
        -:  196:  {
    #####:  197:    TEST_ASSERT (buffer_user_p == (void *) &allocate_mode);
        -:  198:  }
        -:  199:
    #####:  200:  free (buffer_p);
    #####:  201:} /* test_free_cb */
        -:  202:
        -:  203:int
    #####:  204:main (void)
        -:  205:{
    #####:  206:  jerry_init (JERRY_INIT_EMPTY);
        -:  207:
    #####:  208:  if (!jerry_feature_enabled (JERRY_FEATURE_TYPEDARRAY))
        -:  209:  {
    #####:  210:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "ArrayBuffer is disabled!\n");
    #####:  211:    jerry_cleanup ();
    #####:  212:    return 0;
        -:  213:  }
        -:  214:
    #####:  215:  jerry_arraybuffer_heap_allocation_limit (4);
    #####:  216:  jerry_arraybuffer_allocator (test_allocate_cb, test_free_cb, (void *) &allocate_mode);
        -:  217:
    #####:  218:  jerry_value_t function_val = jerry_function_external (assert_handler);
    #####:  219:  register_js_value ("assert", function_val);
    #####:  220:  jerry_value_free (function_val);
        -:  221:
        -:  222:  /* Test array buffer queries */
        -:  223:  {
    #####:  224:    const jerry_char_t eval_arraybuffer_src[] = "new ArrayBuffer (10)";
    #####:  225:    jerry_value_t eval_arraybuffer =
        -:  226:      jerry_eval (eval_arraybuffer_src, sizeof (eval_arraybuffer_src) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  227:    TEST_ASSERT (!jerry_value_is_exception (eval_arraybuffer));
    #####:  228:    TEST_ASSERT (jerry_value_is_arraybuffer (eval_arraybuffer));
    #####:  229:    TEST_ASSERT (jerry_arraybuffer_size (eval_arraybuffer) == 10);
    #####:  230:    jerry_value_free (eval_arraybuffer);
        -:  231:  }
        -:  232:
        -:  233:  /* Test array buffer creation */
        -:  234:  {
    #####:  235:    const uint32_t length = 15;
    #####:  236:    jerry_value_t arraybuffer = jerry_arraybuffer (length);
    #####:  237:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  238:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  239:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
    #####:  240:    jerry_value_free (arraybuffer);
        -:  241:  }
        -:  242:
        -:  243:  /* Test array buffer read operations */
    #####:  244:  for (uint8_t i = 0; i < 15; i++)
        -:  245:  {
    #####:  246:    test_read_with_offset (i);
        -:  247:  }
        -:  248:
        -:  249:  /* Test zero length ArrayBuffer read */
        -:  250:  {
    #####:  251:    const uint32_t length = 0;
    #####:  252:    jerry_value_t arraybuffer = jerry_arraybuffer (length);
    #####:  253:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  254:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  255:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
        -:  256:
        -:  257:    uint8_t data[20];
    #####:  258:    memset (data, 11, 20);
        -:  259:
    #####:  260:    jerry_length_t bytes_read = jerry_arraybuffer_read (arraybuffer, 0, data, 20);
    #####:  261:    TEST_ASSERT (bytes_read == 0);
        -:  262:
    #####:  263:    for (int i = 0; i < 20; i++)
        -:  264:    {
    #####:  265:      TEST_ASSERT (data[i] == 11);
        -:  266:    }
        -:  267:
    #####:  268:    jerry_value_free (arraybuffer);
        -:  269:  }
        -:  270:
        -:  271:  /* Test array buffer write operations */
    #####:  272:  for (uint8_t i = 0; i < 15; i++)
        -:  273:  {
    #####:  274:    test_write_with_offset (i);
        -:  275:  }
        -:  276:
        -:  277:  /* Test zero length ArrayBuffer write */
        -:  278:  {
    #####:  279:    const uint32_t length = 0;
    #####:  280:    jerry_value_t arraybuffer = jerry_arraybuffer (length);
    #####:  281:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  282:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  283:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
        -:  284:
        -:  285:    uint8_t data[20];
    #####:  286:    memset (data, 11, 20);
        -:  287:
    #####:  288:    jerry_length_t bytes_written = jerry_arraybuffer_write (arraybuffer, 0, data, 20);
    #####:  289:    TEST_ASSERT (bytes_written == 0);
        -:  290:
    #####:  291:    jerry_value_free (arraybuffer);
        -:  292:  }
        -:  293:
        -:  294:  /* Test zero length external ArrayBuffer */
        -:  295:  {
    #####:  296:    const uint32_t length = 0;
    #####:  297:    jerry_value_t arraybuffer = jerry_arraybuffer_external (NULL, length, NULL);
    #####:  298:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  299:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  300:    TEST_ASSERT (jerry_arraybuffer_is_detachable (arraybuffer));
    #####:  301:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
        -:  302:
        -:  303:    uint8_t data[20];
    #####:  304:    memset (data, 11, 20);
        -:  305:
    #####:  306:    jerry_length_t bytes_written = jerry_arraybuffer_write (arraybuffer, 0, data, 20);
    #####:  307:    TEST_ASSERT (bytes_written == 0);
        -:  308:
    #####:  309:    jerry_value_free (arraybuffer);
        -:  310:  }
        -:  311:
        -:  312:  /* Test ArrayBuffer with buffer allocated externally */
        -:  313:  {
    #####:  314:    const uint32_t buffer_size = 15;
    #####:  315:    const uint8_t base_value = 51;
        -:  316:
    #####:  317:    uint8_t *buffer_p = (uint8_t *) malloc (buffer_size);
    #####:  318:    memset (buffer_p, base_value, buffer_size);
        -:  319:
    #####:  320:    jerry_value_t arrayb = jerry_arraybuffer_external (buffer_p, buffer_size, NULL);
    #####:  321:    uint8_t new_value = 123;
    #####:  322:    jerry_length_t copied = jerry_arraybuffer_write (arrayb, 0, &new_value, 1);
    #####:  323:    TEST_ASSERT (copied == 1);
    #####:  324:    TEST_ASSERT (buffer_p[0] == new_value);
    #####:  325:    TEST_ASSERT (jerry_arraybuffer_size (arrayb) == buffer_size);
        -:  326:
    #####:  327:    for (uint32_t i = 1; i < buffer_size; i++)
        -:  328:    {
    #####:  329:      TEST_ASSERT (buffer_p[i] == base_value);
        -:  330:    }
        -:  331:
    #####:  332:    JERRY_VLA (uint8_t, test_buffer, buffer_size);
    #####:  333:    jerry_length_t read = jerry_arraybuffer_read (arrayb, 0, test_buffer, buffer_size);
    #####:  334:    TEST_ASSERT (read == buffer_size);
    #####:  335:    TEST_ASSERT (test_buffer[0] == new_value);
        -:  336:
    #####:  337:    for (uint32_t i = 1; i < buffer_size; i++)
        -:  338:    {
    #####:  339:      TEST_ASSERT (test_buffer[i] == base_value);
        -:  340:    }
        -:  341:
    #####:  342:    TEST_ASSERT (jerry_value_is_arraybuffer (arrayb));
    #####:  343:    jerry_value_free (arrayb);
        -:  344:  }
        -:  345:
        -:  346:  /* Test ArrayBuffer external memory map/unmap */
        -:  347:  {
    #####:  348:    const uint32_t buffer_size = 20;
        -:  349:
    #####:  350:    jerry_value_t input_buffer = jerry_arraybuffer_external (NULL, buffer_size, (void *) &allocate_count);
    #####:  351:    register_js_value ("input_buffer", input_buffer);
    #####:  352:    jerry_value_free (input_buffer);
        -:  353:
    #####:  354:    const jerry_char_t eval_arraybuffer_src[] = TEST_STRING_LITERAL ("var array = new Uint8Array(input_buffer);"
        -:  355:                                                                     "for (var i = 0; i < array.length; i++)"
        -:  356:                                                                     "{"
        -:  357:                                                                     "  array[i] = i * 2;"
        -:  358:                                                                     "};"
        -:  359:                                                                     "array.buffer");
    #####:  360:    jerry_value_t buffer =
        -:  361:      jerry_eval (eval_arraybuffer_src, sizeof (eval_arraybuffer_src) - 1, JERRY_PARSE_STRICT_MODE);
        -:  362:
    #####:  363:    TEST_ASSERT (!jerry_value_is_exception (buffer));
    #####:  364:    TEST_ASSERT (jerry_value_is_arraybuffer (buffer));
    #####:  365:    TEST_ASSERT (jerry_arraybuffer_size (buffer) == 20);
        -:  366:
    #####:  367:    uint8_t *const data = jerry_arraybuffer_data (buffer);
        -:  368:
    #####:  369:    TEST_ASSERT (data != NULL);
        -:  370:
        -:  371:    /* test memory read */
    #####:  372:    for (int i = 0; i < 20; i++)
        -:  373:    {
    #####:  374:      TEST_ASSERT (data[i] == (uint8_t) (i * 2));
        -:  375:    }
        -:  376:
        -:  377:    /* "upload" new data */
        -:  378:    double sum = 0;
    #####:  379:    for (int i = 0; i < 20; i++)
        -:  380:    {
    #####:  381:      data[i] = (uint8_t) (i * 3);
    #####:  382:      sum += data[i];
        -:  383:    }
        -:  384:
    #####:  385:    const jerry_char_t eval_test_arraybuffer[] = TEST_STRING_LITERAL (
        -:  386:      "var sum = 0;"
        -:  387:      "for (var i = 0; i < array.length; i++)"
        -:  388:      "{"
        -:  389:      "  var expected = i * 3;"
        -:  390:      "  assert(array[i] == expected, 'Array at index ' + i + ' was: ' + array[i] + ' should be: ' + expected);"
        -:  391:      "  sum += array[i]"
        -:  392:      "};"
        -:  393:      "sum");
    #####:  394:    jerry_value_t res = jerry_eval (eval_test_arraybuffer, sizeof (eval_test_arraybuffer) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  395:    TEST_ASSERT (jerry_value_is_number (res));
    #####:  396:    TEST_ASSERT (jerry_value_as_number (res) == sum);
    #####:  397:    jerry_value_free (res);
        -:  398:
    #####:  399:    jerry_value_free (buffer);
        -:  400:  }
        -:  401:
        -:  402:  /* Test internal ArrayBuffer detach */
        -:  403:  {
    #####:  404:    const uint32_t length = 4;
    #####:  405:    jerry_value_t arraybuffer = jerry_arraybuffer (length);
    #####:  406:    TEST_ASSERT (jerry_arraybuffer_has_buffer (arraybuffer));
    #####:  407:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  408:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  409:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
    #####:  410:    TEST_ASSERT (jerry_arraybuffer_is_detachable (arraybuffer));
        -:  411:
    #####:  412:    jerry_value_t res = jerry_arraybuffer_detach (arraybuffer);
    #####:  413:    TEST_ASSERT (!jerry_arraybuffer_has_buffer (arraybuffer));
    #####:  414:    TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  415:    TEST_ASSERT (jerry_arraybuffer_data (arraybuffer) == NULL);
    #####:  416:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == 0);
    #####:  417:    TEST_ASSERT (!jerry_arraybuffer_is_detachable (arraybuffer));
        -:  418:
    #####:  419:    jerry_value_free (res);
    #####:  420:    jerry_value_free (arraybuffer);
        -:  421:  }
        -:  422:
        -:  423:  /* Test external ArrayBuffer detach */
        -:  424:  {
    #####:  425:    const uint32_t length = 64;
    #####:  426:    jerry_value_t arraybuffer = jerry_arraybuffer_external (NULL, length, NULL);
    #####:  427:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  428:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  429:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
    #####:  430:    TEST_ASSERT (!jerry_arraybuffer_has_buffer (arraybuffer));
        -:  431:
    #####:  432:    uint8_t buf[1] = { 1 };
    #####:  433:    TEST_ASSERT (jerry_arraybuffer_write (arraybuffer, 0, buf, 1) == 1);
    #####:  434:    TEST_ASSERT (jerry_arraybuffer_has_buffer (arraybuffer));
    #####:  435:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == length);
    #####:  436:    TEST_ASSERT (jerry_arraybuffer_is_detachable (arraybuffer));
        -:  437:
    #####:  438:    jerry_value_t res = jerry_arraybuffer_detach (arraybuffer);
    #####:  439:    TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  440:    TEST_ASSERT (jerry_arraybuffer_data (arraybuffer) == NULL);
    #####:  441:    TEST_ASSERT (jerry_arraybuffer_size (arraybuffer) == 0);
    #####:  442:    TEST_ASSERT (!jerry_arraybuffer_has_buffer (arraybuffer));
    #####:  443:    TEST_ASSERT (!jerry_arraybuffer_is_detachable (arraybuffer));
        -:  444:
    #####:  445:    jerry_value_free (res);
    #####:  446:    jerry_value_free (arraybuffer);
        -:  447:  }
        -:  448:
        -:  449:  /* Test ArrayBuffer created in ECMAScript */
    #####:  450:  for (int i = 0; i < 3; i++)
        -:  451:  {
    #####:  452:    const jerry_char_t source[] = TEST_STRING_LITERAL ("new ArrayBuffer(64)");
    #####:  453:    jerry_value_t arraybuffer = jerry_eval (source, sizeof (source) - 1, JERRY_PARSE_NO_OPTS);
    #####:  454:    TEST_ASSERT (!jerry_value_is_exception (arraybuffer));
    #####:  455:    TEST_ASSERT (jerry_value_is_arraybuffer (arraybuffer));
    #####:  456:    TEST_ASSERT (!jerry_arraybuffer_has_buffer (arraybuffer));
        -:  457:
    #####:  458:    if (i == 0)
        -:  459:    {
    #####:  460:      uint8_t buf[2] = { 2, 3 };
    #####:  461:      TEST_ASSERT (jerry_arraybuffer_write (arraybuffer, 63, buf, 2) == 1);
        -:  462:    }
    #####:  463:    else if (i == 1)
        -:  464:    {
    #####:  465:      uint8_t buf[2] = { 1, 1 };
    #####:  466:      TEST_ASSERT (jerry_arraybuffer_read (arraybuffer, 63, buf, 2) == 1);
    #####:  467:      TEST_ASSERT (buf[0] == 0 && buf[1] == 1);
        -:  468:    }
        -:  469:    else
        -:  470:    {
    #####:  471:      uint8_t *buffer_p = jerry_arraybuffer_data (arraybuffer);
    #####:  472:      TEST_ASSERT (buffer_p != NULL);
        -:  473:    }
        -:  474:
    #####:  475:    TEST_ASSERT (jerry_arraybuffer_has_buffer (arraybuffer));
        -:  476:
    #####:  477:    jerry_value_free (arraybuffer);
        -:  478:  }
        -:  479:
    #####:  480:  jerry_cleanup ();
        -:  481:
    #####:  482:  TEST_ASSERT (allocate_count == 1);
    #####:  483:  TEST_ASSERT (free_count == 2);
        -:  484:
        -:  485:  return 0;
        -:  486:} /* main */
