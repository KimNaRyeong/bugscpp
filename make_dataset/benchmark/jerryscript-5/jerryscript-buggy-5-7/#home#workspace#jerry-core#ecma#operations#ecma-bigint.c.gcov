        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-bigint.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-bigint.h"
        -:   17:
        -:   18:#include "ecma-big-uint.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-helpers-number.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "ecma-objects.h"
        -:   23:
        -:   24:#include "lit-char-helpers.h"
        -:   25:
        -:   26:#if JERRY_BUILTIN_BIGINT
        -:   27:
        -:   28:/**
        -:   29: * Raise a not enough memory error
        -:   30: *
        -:   31: * @return ECMA_VALUE_ERROR
        -:   32: *         Returned value must be freed with ecma_free_value.
        -:   33: */
        -:   34:static ecma_value_t
    #####:   35:ecma_bigint_raise_memory_error (void)
        -:   36:{
    #####:   37:  return ecma_raise_range_error (ECMA_ERR_ALLOCATE_BIGINT_VALUE);
        -:   38:} /* ecma_bigint_raise_memory_error */
        -:   39:
        -:   40:/**
        -:   41: * Create a single digit long BigInt value
        -:   42: *
        -:   43: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:   44: *         Returned value must be freed with ecma_free_value.
        -:   45: */
        -:   46:static ecma_value_t
    #####:   47:ecma_bigint_create_from_digit (ecma_bigint_digit_t digit, /* single digit */
        -:   48:                               bool sign) /* set ECMA_BIGINT_SIGN if true */
        -:   49:{
    #####:   50:  JERRY_ASSERT (digit != 0);
        -:   51:
    #####:   52:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:   53:
    #####:   54:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:   55:  {
    #####:   56:    return ecma_bigint_raise_memory_error ();
        -:   57:  }
        -:   58:
    #####:   59:  if (sign)
        -:   60:  {
    #####:   61:    result_value_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:   62:  }
        -:   63:
    #####:   64:  *ECMA_BIGINT_GET_DIGITS (result_value_p, 0) = digit;
    #####:   65:  return ecma_make_extended_primitive_value (result_value_p, ECMA_TYPE_BIGINT);
        -:   66:} /* ecma_bigint_create_from_digit */
        -:   67:
        -:   68:/**
        -:   69: * Parse a string and create a BigInt value
        -:   70: *
        -:   71: * @return ecma BigInt value or a special value allowed by the option flags
        -:   72: *         Returned value must be freed with ecma_free_value.
        -:   73: */
        -:   74:ecma_value_t
    #####:   75:ecma_bigint_parse_string (const lit_utf8_byte_t *string_p, /**< string represenation of the BigInt */
        -:   76:                          lit_utf8_size_t size, /**< string size */
        -:   77:                          uint32_t options) /**< ecma_bigint_parse_string_options_t option bits */
        -:   78:{
    #####:   79:  ecma_bigint_digit_t radix = 10;
    #####:   80:  uint32_t sign = (options & ECMA_BIGINT_PARSE_SET_NEGATIVE) ? ECMA_BIGINT_SIGN : 0;
    #####:   81:  bool allow_underscore = options & ECMA_BIGINT_PARSE_ALLOW_UNDERSCORE;
        -:   82:
    #####:   83:  const lit_utf8_byte_t *string_end_p = string_p + size;
    #####:   84:  string_p = ecma_string_trim_front (string_p, string_p + size);
    #####:   85:  size = (lit_utf8_size_t) (string_end_p - string_p);
        -:   86:
    #####:   87:  if (size >= 3 && string_p[0] == LIT_CHAR_0)
        -:   88:  {
    #####:   89:    radix = lit_char_to_radix (string_p[1]);
        -:   90:
    #####:   91:    if (radix != 10)
        -:   92:    {
    #####:   93:      string_p += 2;
    #####:   94:      size -= 2;
        -:   95:    }
        -:   96:  }
    #####:   97:  else if (size >= 2)
        -:   98:  {
    #####:   99:    if (string_p[0] == LIT_CHAR_PLUS)
        -:  100:    {
    #####:  101:      size--;
    #####:  102:      string_p++;
        -:  103:    }
    #####:  104:    else if (string_p[0] == LIT_CHAR_MINUS)
        -:  105:    {
    #####:  106:      sign = ECMA_BIGINT_SIGN;
    #####:  107:      size--;
    #####:  108:      string_p++;
        -:  109:    }
        -:  110:  }
    #####:  111:  else if (size == 0)
        -:  112:  {
    #####:  113:    return ECMA_BIGINT_ZERO;
        -:  114:  }
        -:  115:
    #####:  116:  while (string_p < string_end_p && (*string_p == LIT_CHAR_0 || (*string_p == LIT_CHAR_UNDERSCORE && allow_underscore)))
        -:  117:  {
    #####:  118:    string_p++;
        -:  119:  }
        -:  120:
    #####:  121:  ecma_extended_primitive_t *result_p = NULL;
        -:  122:
    #####:  123:  if (string_p == string_end_p)
        -:  124:  {
    #####:  125:    return ECMA_BIGINT_ZERO;
        -:  126:  }
        -:  127:
        -:  128:  do
        -:  129:  {
    #####:  130:    ecma_bigint_digit_t digit = radix;
        -:  131:
    #####:  132:    if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)
        -:  133:    {
    #####:  134:      digit = (ecma_bigint_digit_t) (*string_p - LIT_CHAR_0);
        -:  135:    }
    #####:  136:    else if (*string_p == LIT_CHAR_UNDERSCORE && allow_underscore)
        -:  137:    {
    #####:  138:      continue;
        -:  139:    }
        -:  140:    else
        -:  141:    {
    #####:  142:      lit_utf8_byte_t character = (lit_utf8_byte_t) LEXER_TO_ASCII_LOWERCASE (*string_p);
        -:  143:
    #####:  144:      if (character >= LIT_CHAR_LOWERCASE_A && character <= LIT_CHAR_LOWERCASE_F)
        -:  145:      {
    #####:  146:        digit = (ecma_bigint_digit_t) (character - (LIT_CHAR_LOWERCASE_A - 10));
        -:  147:      }
    #####:  148:      else if (ecma_string_trim_front (string_p, string_end_p) == string_end_p)
        -:  149:      {
    #####:  150:        string_p = string_end_p;
    #####:  151:        break;
        -:  152:      }
        -:  153:    }
    #####:  154:    if (digit >= radix)
        -:  155:    {
    #####:  156:      if (result_p != NULL)
        -:  157:      {
    #####:  158:        ecma_deref_bigint (result_p);
        -:  159:      }
        -:  160:
    #####:  161:      if (options & ECMA_BIGINT_PARSE_DISALLOW_SYNTAX_ERROR)
        -:  162:      {
    #####:  163:        return ECMA_VALUE_FALSE;
        -:  164:      }
    #####:  165:      return ecma_raise_syntax_error (ECMA_ERR_STRING_CANNOT_BE_CONVERTED_TO_BIGINT_VALUE);
        -:  166:    }
        -:  167:
    #####:  168:    result_p = ecma_big_uint_mul_digit (result_p, radix, digit);
        -:  169:
    #####:  170:    if (JERRY_UNLIKELY (result_p == NULL))
        -:  171:    {
    #####:  172:      break;
        -:  173:    }
    #####:  174:  } while (++string_p < string_end_p);
        -:  175:
    #####:  176:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  177:  {
    #####:  178:    if (options & ECMA_BIGINT_PARSE_DISALLOW_MEMORY_ERROR)
        -:  179:    {
    #####:  180:      return ECMA_VALUE_NULL;
        -:  181:    }
    #####:  182:    return ecma_bigint_raise_memory_error ();
        -:  183:  }
        -:  184:
    #####:  185:  result_p->u.bigint_sign_and_size |= sign;
    #####:  186:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -:  187:} /* ecma_bigint_parse_string */
        -:  188:
        -:  189:/**
        -:  190: * Parse a string value and create a BigInt value
        -:  191: *
        -:  192: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  193: *         Returned value must be freed with ecma_free_value.
        -:  194: */
        -:  195:ecma_value_t
    #####:  196:ecma_bigint_parse_string_value (ecma_value_t string, /**< ecma string */
        -:  197:                                uint32_t options) /**< ecma_bigint_parse_string_options_t option bits */
        -:  198:{
    #####:  199:  JERRY_ASSERT (ecma_is_value_string (string));
        -:  200:
    #####:  201:  ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (string), string_buffer_p, string_buffer_size);
        -:  202:
    #####:  203:  ecma_value_t result = ecma_bigint_parse_string (string_buffer_p, string_buffer_size, options);
    #####:  204:  ECMA_FINALIZE_UTF8_STRING (string_buffer_p, string_buffer_size);
        -:  205:
    #####:  206:  return result;
        -:  207:} /* ecma_bigint_parse_string_value */
        -:  208:
        -:  209:/**
        -:  210: * Create a string representation for a BigInt value
        -:  211: *
        -:  212: * @return ecma string or ECMA_VALUE_ERROR
        -:  213: *         Returned value must be freed with ecma_free_value.
        -:  214: */
        -:  215:ecma_string_t *
    #####:  216:ecma_bigint_to_string (ecma_value_t value, /**< BigInt value */
        -:  217:                       ecma_bigint_digit_t radix) /**< conversion radix */
        -:  218:{
    #####:  219:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  220:
    #####:  221:  if (value == ECMA_BIGINT_ZERO)
        -:  222:  {
    #####:  223:    return ecma_new_ecma_string_from_code_unit (LIT_CHAR_0);
        -:  224:  }
        -:  225:
    #####:  226:  uint32_t char_start_p, char_size_p;
    #####:  227:  ecma_extended_primitive_t *bigint_p = ecma_get_extended_primitive_from_value (value);
    #####:  228:  lit_utf8_byte_t *string_buffer_p = ecma_big_uint_to_string (bigint_p, radix, &char_start_p, &char_size_p);
        -:  229:
    #####:  230:  if (JERRY_UNLIKELY (string_buffer_p == NULL))
        -:  231:  {
    #####:  232:    ecma_raise_range_error (ECMA_ERR_ALLOCATE_BIGINT_STRING);
    #####:  233:    return NULL;
        -:  234:  }
        -:  235:
    #####:  236:  JERRY_ASSERT (char_start_p > 0);
        -:  237:
    #####:  238:  if (bigint_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -:  239:  {
    #####:  240:    string_buffer_p[--char_start_p] = LIT_CHAR_MINUS;
        -:  241:  }
        -:  242:
        -:  243:  ecma_string_t *string_p;
    #####:  244:  string_p = ecma_new_ecma_string_from_ascii (string_buffer_p + char_start_p, char_size_p - char_start_p);
        -:  245:
    #####:  246:  jmem_heap_free_block (string_buffer_p, char_size_p);
    #####:  247:  return string_p;
        -:  248:} /* ecma_bigint_to_string */
        -:  249:
        -:  250:/**
        -:  251: * Get the size of zero digits from the result of ecma_bigint_number_to_digits
        -:  252: */
        -:  253:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE(value) (((value) &0xffff) * (uint32_t) sizeof (ecma_bigint_digit_t))
        -:  254:
        -:  255:/**
        -:  256: * Get the number of digits from the result of ecma_bigint_number_to_digits
        -:  257: */
        -:  258:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS(value) ((value) >> 20)
        -:  259:
        -:  260:/**
        -:  261: * Get the size of digits from the result of ecma_bigint_number_to_digits
        -:  262: */
        -:  263:#define ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE(value) \
        -:  264:  (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (value) * (uint32_t) sizeof (ecma_bigint_digit_t))
        -:  265:
        -:  266:/**
        -:  267: * Set number of digits in the result of ecma_bigint_number_to_digits
        -:  268: */
        -:  269:#define ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS(value) ((uint32_t) (value) << 20)
        -:  270:
        -:  271:/**
        -:  272: * This flag is set when the number passed to ecma_bigint_number_to_digits has fraction part
        -:  273: */
        -:  274:#define ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION 0x10000
        -:  275:
        -:  276:/**
        -:  277: * Convert a number to maximum of 3 digits and left shift
        -:  278: *
        -:  279: * @return packed value, ECMA_BIGINT_NUMBER_TO_DIGITS* macros can be used to decode it
        -:  280: */
        -:  281:static uint32_t
    #####:  282:ecma_bigint_number_to_digits (ecma_number_t number, /**< ecma number */
        -:  283:                              ecma_bigint_digit_t *digits_p) /**< [out] BigInt digits */
        -:  284:{
    #####:  285:  if (ecma_number_is_zero (number))
        -:  286:  {
    #####:  287:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (0);
        -:  288:  }
        -:  289:
    #####:  290:  ecma_binary_num_t binary = ecma_number_to_binary (number);
    #####:  291:  uint32_t biased_exp = ecma_number_biased_exp (binary);
    #####:  292:  uint64_t fraction = ecma_number_fraction (binary);
        -:  293:
    #####:  294:  if (biased_exp < ((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1))
        -:  295:  {
        -:  296:    /* Number is less than 1. */
    #####:  297:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (0) | ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION;
        -:  298:  }
        -:  299:
    #####:  300:  biased_exp -= ((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1);
    #####:  301:  fraction |= ((uint64_t) 1) << ECMA_NUMBER_FRACTION_WIDTH;
        -:  302:
    #####:  303:  if (biased_exp <= ECMA_NUMBER_FRACTION_WIDTH)
        -:  304:  {
    #####:  305:    uint32_t has_fraction = 0;
        -:  306:
    #####:  307:    if (biased_exp < ECMA_NUMBER_FRACTION_WIDTH
    #####:  308:        && (fraction << (biased_exp + ((8 * sizeof (uint64_t)) - ECMA_NUMBER_FRACTION_WIDTH))) != 0)
        -:  309:    {
    #####:  310:      has_fraction |= ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION;
        -:  311:    }
        -:  312:
    #####:  313:    fraction >>= ECMA_NUMBER_FRACTION_WIDTH - biased_exp;
    #####:  314:    digits_p[0] = (ecma_bigint_digit_t) fraction;
        -:  315:
        -:  316:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  317:    digits_p[1] = (ecma_bigint_digit_t) (fraction >> (8 * sizeof (ecma_bigint_digit_t)));
    #####:  318:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[1] == 0 ? 1 : 2) | has_fraction;
        -:  319:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  320:    return ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (1) | has_fraction;
        -:  321:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  322:  }
        -:  323:
    #####:  324:  digits_p[0] = (ecma_bigint_digit_t) fraction;
        -:  325:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  326:  digits_p[1] = (ecma_bigint_digit_t) (fraction >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  327:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  328:
    #####:  329:  biased_exp -= ECMA_NUMBER_FRACTION_WIDTH;
        -:  330:
    #####:  331:  uint32_t shift_left = biased_exp & ((8 * sizeof (ecma_bigint_digit_t)) - 1);
    #####:  332:  biased_exp = biased_exp >> ECMA_BIGINT_DIGIT_SHIFT;
        -:  333:
    #####:  334:  if (shift_left == 0)
        -:  335:  {
        -:  336:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  337:    return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (2);
        -:  338:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  339:    return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (1);
        -:  340:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  341:  }
        -:  342:
    #####:  343:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -:  344:
        -:  345:#if JERRY_NUMBER_TYPE_FLOAT64
    #####:  346:  digits_p[2] = digits_p[1] >> shift_right;
    #####:  347:  digits_p[1] = (digits_p[1] << shift_left) | (digits_p[0] >> shift_right);
    #####:  348:  digits_p[0] <<= shift_left;
        -:  349:
    #####:  350:  return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[2] == 0 ? 2 : 3);
        -:  351:#else /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  352:  digits_p[1] = digits_p[0] >> shift_right;
        -:  353:  digits_p[0] <<= shift_left;
        -:  354:
        -:  355:  return biased_exp | ECMA_BIGINT_NUMBER_TO_DIGITS_SET_DIGITS (digits_p[1] == 0 ? 1 : 2);
        -:  356:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  357:} /* ecma_bigint_number_to_digits */
        -:  358:
        -:  359:/**
        -:  360: * Convert an ecma number to BigInt value
        -:  361: *
        -:  362: * See also:
        -:  363: *          ECMA-262 v11, 20.2.1.1.1
        -:  364: *
        -:  365: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  366: *         Returned value must be freed with ecma_free_value.
        -:  367: */
        -:  368:static ecma_value_t
    #####:  369:ecma_bigint_number_to_bigint (ecma_number_t number) /**< ecma number */
        -:  370:{
    #####:  371:  if (ecma_number_is_nan (number) || ecma_number_is_infinity (number))
        -:  372:  {
    #####:  373:    return ecma_raise_range_error (ECMA_ERR_INFINITY_OR_NAN_CANNOT_BE_CONVERTED_TO_BIGINT);
        -:  374:  }
        -:  375:
    #####:  376:  ecma_bigint_digit_t digits[3];
    #####:  377:  uint32_t result = ecma_bigint_number_to_digits (number, digits);
        -:  378:
    #####:  379:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -:  380:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -:  381:
    #####:  382:  if (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION)
        -:  383:  {
    #####:  384:    return ecma_raise_range_error (ECMA_ERR_ONLY_INTEGER_NUMBERS_CAN_BE_CONVERTED_TO_BIGINT);
        -:  385:  }
        -:  386:
    #####:  387:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
        -:  388:
    #####:  389:  if (digits_size == 0)
        -:  390:  {
    #####:  391:    return ECMA_BIGINT_ZERO;
        -:  392:  }
        -:  393:
    #####:  394:  uint32_t zero_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -:  395:
    #####:  396:  ecma_extended_primitive_t *result_p = ecma_bigint_create (digits_size + zero_size);
        -:  397:
    #####:  398:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  399:  {
    #####:  400:    return ecma_bigint_raise_memory_error ();
        -:  401:  }
        -:  402:
    #####:  403:  uint8_t *data_p = (uint8_t *) ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  404:  memset (data_p, 0, zero_size);
    #####:  405:  memcpy (data_p + zero_size, digits, digits_size);
        -:  406:
    #####:  407:  if (number < 0)
        -:  408:  {
    #####:  409:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:  410:  }
        -:  411:
    #####:  412:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -:  413:} /* ecma_bigint_number_to_bigint */
        -:  414:
        -:  415:/**
        -:  416: * Convert a value to BigInt value
        -:  417: *
        -:  418: * See also:
        -:  419: *          ECMA-262 v11, 7.1.13
        -:  420: *
        -:  421: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  422: *         Returned value must be freed with ecma_free_value.
        -:  423: */
        -:  424:ecma_value_t
    #####:  425:ecma_bigint_to_bigint (ecma_value_t value, /**< any value */
        -:  426:                       bool allow_numbers) /**< converting ecma numbers is allowed */
        -:  427:{
    #####:  428:  bool free_value = false;
        -:  429:
    #####:  430:  if (ecma_is_value_object (value))
        -:  431:  {
    #####:  432:    value = ecma_op_object_default_value (ecma_get_object_from_value (value), ECMA_PREFERRED_TYPE_NUMBER);
    #####:  433:    free_value = true;
        -:  434:
    #####:  435:    if (ECMA_IS_VALUE_ERROR (value))
        -:  436:    {
    #####:  437:      return value;
        -:  438:    }
        -:  439:  }
        -:  440:
        -:  441:  ecma_value_t result;
        -:  442:
    #####:  443:  if (ecma_is_value_string (value))
        -:  444:  {
    #####:  445:    result = ecma_bigint_parse_string_value (value, ECMA_BIGINT_PARSE_NO_OPTIONS);
        -:  446:  }
    #####:  447:  else if (ecma_is_value_bigint (value))
        -:  448:  {
    #####:  449:    result = value;
        -:  450:
    #####:  451:    if (!free_value && value != ECMA_BIGINT_ZERO)
        -:  452:    {
    #####:  453:      ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
        -:  454:    }
        -:  455:    else
        -:  456:    {
    #####:  457:      free_value = false;
        -:  458:    }
        -:  459:  }
    #####:  460:  else if (allow_numbers && ecma_is_value_number (value))
        -:  461:  {
    #####:  462:    result = ecma_bigint_number_to_bigint (ecma_get_number_from_value (value));
        -:  463:  }
    #####:  464:  else if (ecma_is_value_false (value))
        -:  465:  {
    #####:  466:    result = ECMA_BIGINT_ZERO;
        -:  467:  }
    #####:  468:  else if (ecma_is_value_true (value))
        -:  469:  {
    #####:  470:    result = ecma_bigint_create_from_digit (1, false);
        -:  471:  }
        -:  472:  else
        -:  473:  {
    #####:  474:    result = ecma_raise_type_error (ECMA_ERR_VALUE_CANNOT_BE_CONVERTED_TO_BIGINT);
        -:  475:  }
        -:  476:
    #####:  477:  if (free_value)
        -:  478:  {
    #####:  479:    ecma_free_value (value);
        -:  480:  }
        -:  481:
    #####:  482:  return result;
        -:  483:} /* ecma_bigint_to_bigint */
        -:  484:
        -:  485:/**
        -:  486: * Convert a BigInt value to number value
        -:  487: *
        -:  488: * @return ecma number value or ECMA_VALUE_ERROR
        -:  489: *         Returned value must be freed with ecma_free_value.
        -:  490: */
        -:  491:ecma_value_t
    #####:  492:ecma_bigint_to_number (ecma_value_t value) /**< BigInt value */
        -:  493:{
    #####:  494:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  495:
    #####:  496:  if (value == ECMA_BIGINT_ZERO)
        -:  497:  {
    #####:  498:    return ecma_make_integer_value (0);
        -:  499:  }
        -:  500:
    #####:  501:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
    #####:  502:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
    #####:  503:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  504:
    #####:  505:  if (size == sizeof (ecma_bigint_digit_t))
        -:  506:  {
    #####:  507:    if (!(value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -:  508:    {
    #####:  509:      if (digits_p[-1] <= ECMA_INTEGER_NUMBER_MAX)
        -:  510:      {
    #####:  511:        return ecma_make_integer_value ((ecma_integer_value_t) digits_p[-1]);
        -:  512:      }
        -:  513:    }
    #####:  514:    else if (digits_p[-1] <= -ECMA_INTEGER_NUMBER_MIN)
        -:  515:    {
    #####:  516:      return ecma_make_integer_value (-(ecma_integer_value_t) digits_p[-1]);
        -:  517:    }
        -:  518:  }
        -:  519:
    #####:  520:  uint64_t fraction = 0;
        -:  521:  ecma_bigint_digit_t shift_left;
        -:  522:
    #####:  523:  if (digits_p[-1] == 1)
        -:  524:  {
    #####:  525:    JERRY_ASSERT (size > sizeof (ecma_bigint_digit_t));
        -:  526:
    #####:  527:    fraction = ((uint64_t) digits_p[-2]) << (8 * sizeof (ecma_bigint_digit_t));
    #####:  528:    shift_left = (uint32_t) (8 * sizeof (ecma_bigint_digit_t));
        -:  529:
    #####:  530:    if (size >= 3 * sizeof (ecma_bigint_digit_t))
        -:  531:    {
    #####:  532:      fraction |= (uint64_t) digits_p[-3];
        -:  533:    }
        -:  534:  }
        -:  535:  else
        -:  536:  {
    #####:  537:    shift_left = ecma_big_uint_count_leading_zero (digits_p[-1]) + 1;
        -:  538:
    #####:  539:    fraction = ((uint64_t) digits_p[-1]) << (8 * sizeof (ecma_bigint_digit_t) + shift_left);
        -:  540:
    #####:  541:    if (size >= 2 * sizeof (ecma_bigint_digit_t))
        -:  542:    {
    #####:  543:      fraction |= ((uint64_t) digits_p[-2]) << shift_left;
        -:  544:    }
        -:  545:
    #####:  546:    if (size >= 3 * sizeof (ecma_bigint_digit_t))
        -:  547:    {
    #####:  548:      fraction |= ((uint64_t) digits_p[-3]) >> (8 * sizeof (ecma_bigint_digit_t) - shift_left);
        -:  549:    }
        -:  550:  }
        -:  551:
    #####:  552:  uint32_t biased_exp = (uint32_t) (((1 << (ECMA_NUMBER_BIASED_EXP_WIDTH - 1)) - 1) + (size * 8 - shift_left));
        -:  553:
        -:  554:  /* Rounding result. */
    #####:  555:  const uint64_t rounding_bit = (((uint64_t) 1) << (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH - 1));
    #####:  556:  bool round_up = false;
        -:  557:
    #####:  558:  if (fraction & rounding_bit)
        -:  559:  {
    #####:  560:    round_up = true;
        -:  561:
        -:  562:    /* IEEE_754 roundTiesToEven mode: when rounding_bit is set, and all the remaining bits
        -:  563:     * are zero, the number needs to be rounded down the bit before rounding_bit is zero. */
    #####:  564:    if ((fraction & ((rounding_bit << 2) - 1)) == rounding_bit)
        -:  565:    {
    #####:  566:      round_up = false;
        -:  567:
    #####:  568:      if ((size >= (3 * sizeof (ecma_bigint_digit_t)))
    #####:  569:          && (shift_left == (8 * sizeof (ecma_bigint_digit_t))
    #####:  570:              || (digits_p[-3] & ((((ecma_bigint_digit_t) 1) << shift_left) - 1)) == 0))
        -:  571:      {
    #####:  572:        ecma_bigint_digit_t *digits_start_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  573:
    #####:  574:        digits_p -= 3;
        -:  575:
    #####:  576:        while (digits_p > digits_start_p)
        -:  577:        {
    #####:  578:          if (digits_p[-1] != 0)
        -:  579:          {
    #####:  580:            round_up = true;
    #####:  581:            break;
        -:  582:          }
    #####:  583:          digits_p--;
        -:  584:        }
        -:  585:      }
        -:  586:    }
        -:  587:  }
        -:  588:
    #####:  589:  if (round_up)
        -:  590:  {
    #####:  591:    fraction += rounding_bit;
    #####:  592:    fraction >>= (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH);
        -:  593:
    #####:  594:    if (fraction == 0)
        -:  595:    {
    #####:  596:      biased_exp++;
        -:  597:    }
        -:  598:  }
        -:  599:  else
        -:  600:  {
    #####:  601:    fraction >>= (8 * sizeof (uint64_t) - ECMA_NUMBER_FRACTION_WIDTH);
        -:  602:  }
        -:  603:
    #####:  604:  bool sign = (value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -:  605:  ecma_number_t result;
        -:  606:
    #####:  607:  if (biased_exp < (1u << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1)
        -:  608:  {
    #####:  609:    result = ecma_number_create (sign, biased_exp, fraction);
        -:  610:  }
        -:  611:  else
        -:  612:  {
    #####:  613:    result = ecma_number_make_infinity (sign);
        -:  614:  }
        -:  615:
    #####:  616:  return ecma_make_number_value (result);
        -:  617:} /* ecma_bigint_to_number */
        -:  618:
        -:  619:/**
        -:  620: * Returns with a BigInt if the value is BigInt,
        -:  621: * or the value is object, and its default value is BigInt
        -:  622: *
        -:  623: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  624: *         Returned value must be freed with ecma_free_value.
        -:  625: */
        -:  626:ecma_value_t
    #####:  627:ecma_bigint_get_bigint (ecma_value_t value, /**< any value */
        -:  628:                        bool *free_result_p) /**< [out] result should be freed */
        -:  629:{
    #####:  630:  *free_result_p = false;
        -:  631:
    #####:  632:  if (ecma_is_value_bigint (value))
        -:  633:  {
    #####:  634:    return value;
        -:  635:  }
        -:  636:
    #####:  637:  if (ecma_is_value_object (value))
        -:  638:  {
    #####:  639:    ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####:  640:    ecma_value_t default_value = ecma_op_object_default_value (object_p, ECMA_PREFERRED_TYPE_NUMBER);
        -:  641:
    #####:  642:    if (ECMA_IS_VALUE_ERROR (default_value))
        -:  643:    {
    #####:  644:      return default_value;
        -:  645:    }
        -:  646:
    #####:  647:    if (ecma_is_value_bigint (default_value))
        -:  648:    {
    #####:  649:      *free_result_p = (default_value != ECMA_BIGINT_ZERO);
    #####:  650:      return default_value;
        -:  651:    }
        -:  652:
    #####:  653:    ecma_free_value (default_value);
        -:  654:  }
        -:  655:
    #####:  656:  return ecma_raise_type_error (ECMA_ERR_CONVERT_BIGINT_TO_NUMBER);
        -:  657:} /* ecma_bigint_get_bigint */
        -:  658:
        -:  659:/**
        -:  660: * Create BigInt value from uint64 digits
        -:  661: *
        -:  662: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -:  663: *         Returned value must be freed with ecma_free_value.
        -:  664: */
        -:  665:ecma_value_t
    #####:  666:ecma_bigint_create_from_digits (const uint64_t *digits_p, /**< BigInt digits */
        -:  667:                                uint32_t size, /**< number of BigInt digits */
        -:  668:                                bool sign) /**< sign bit, true if the result should be negative */
        -:  669:{
    #####:  670:  const uint64_t *digits_end_p = digits_p + size;
        -:  671:
    #####:  672:  while (digits_end_p > digits_p && digits_end_p[-1] == 0)
        -:  673:  {
    #####:  674:    digits_end_p--;
        -:  675:  }
        -:  676:
    #####:  677:  if (digits_p == digits_end_p)
        -:  678:  {
    #####:  679:    return ECMA_BIGINT_ZERO;
        -:  680:  }
        -:  681:
    #####:  682:  size = (uint32_t) (digits_end_p - digits_p);
        -:  683:
    #####:  684:  if (size < ECMA_BIGINT_MAX_SIZE)
        -:  685:  {
    #####:  686:    size *= (uint32_t) sizeof (uint64_t);
        -:  687:  }
        -:  688:
    #####:  689:  if ((digits_end_p[-1] >> (8 * sizeof (ecma_bigint_digit_t))) == 0)
        -:  690:  {
    #####:  691:    size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  692:  }
        -:  693:
    #####:  694:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  695:
    #####:  696:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  697:  {
    #####:  698:    return ecma_bigint_raise_memory_error ();
        -:  699:  }
        -:  700:
    #####:  701:  if (sign)
        -:  702:  {
    #####:  703:    result_value_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -:  704:  }
        -:  705:
    #####:  706:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  707:
    #####:  708:  while (digits_p < digits_end_p)
        -:  709:  {
    #####:  710:    uint64_t digit = *digits_p++;
        -:  711:
    #####:  712:    result_p[0] = (ecma_bigint_digit_t) digit;
    #####:  713:    result_p[1] = (ecma_bigint_digit_t) (digit >> (8 * sizeof (ecma_bigint_digit_t)));
    #####:  714:    result_p += 2;
        -:  715:  }
        -:  716:
    #####:  717:  return ecma_make_extended_primitive_value (result_value_p, ECMA_TYPE_BIGINT);
        -:  718:} /* ecma_bigint_create_from_digits */
        -:  719:
        -:  720:/**
        -:  721: * Get the number of uint64 digits of a BigInt value
        -:  722: *
        -:  723: * @return number of uint64 digits
        -:  724: */
        -:  725:uint32_t
    #####:  726:ecma_bigint_get_size_in_digits (ecma_value_t value) /**< BigInt value */
        -:  727:{
    #####:  728:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  729:
    #####:  730:  if (value == ECMA_BIGINT_ZERO)
        -:  731:  {
    #####:  732:    return 0;
        -:  733:  }
        -:  734:
    #####:  735:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
    #####:  736:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  737:
    #####:  738:  return (size + (uint32_t) sizeof (ecma_bigint_digit_t)) / sizeof (uint64_t);
        -:  739:} /* ecma_bigint_get_size_in_digits */
        -:  740:
        -:  741:/**
        -:  742: * Get the uint64 digits of a BigInt value
        -:  743: */
        -:  744:void
    #####:  745:ecma_bigint_get_digits_and_sign (ecma_value_t value, /**< BigInt value */
        -:  746:                                 uint64_t *digits_p, /**< [out] buffer for digits */
        -:  747:                                 uint32_t size, /**< buffer size in digits */
        -:  748:                                 bool *sign_p) /**< [out] sign of BigInt */
        -:  749:{
    #####:  750:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -:  751:
    #####:  752:  if (value == ECMA_BIGINT_ZERO)
        -:  753:  {
    #####:  754:    if (sign_p != NULL)
        -:  755:    {
    #####:  756:      *sign_p = false;
        -:  757:    }
    #####:  758:    memset (digits_p, 0, size * sizeof (uint64_t));
    #####:  759:    return;
        -:  760:  }
        -:  761:
    #####:  762:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
        -:  763:
    #####:  764:  if (sign_p != NULL)
        -:  765:  {
    #####:  766:    *sign_p = (value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) != 0;
        -:  767:  }
        -:  768:
    #####:  769:  uint32_t bigint_size = ECMA_BIGINT_GET_SIZE (value_p);
    #####:  770:  uint32_t copy_size = bigint_size / sizeof (uint64_t);
        -:  771:
    #####:  772:  if (copy_size > size)
        -:  773:  {
    #####:  774:    copy_size = size;
        -:  775:  }
        -:  776:
    #####:  777:  const uint64_t *digits_end_p = digits_p + copy_size;
    #####:  778:  ecma_bigint_digit_t *source_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  779:
    #####:  780:  while (digits_p < digits_end_p)
        -:  781:  {
    #####:  782:    *digits_p++ = source_p[0] | (((uint64_t) source_p[1]) << (8 * sizeof (ecma_bigint_digit_t)));
    #####:  783:    source_p += 2;
        -:  784:  }
        -:  785:
    #####:  786:  size -= copy_size;
        -:  787:
    #####:  788:  if (size == 0)
        -:  789:  {
    #####:  790:    return;
        -:  791:  }
        -:  792:
    #####:  793:  if (ECMA_BIGINT_SIZE_IS_ODD (bigint_size))
        -:  794:  {
    #####:  795:    *digits_p++ = source_p[0];
    #####:  796:    size--;
        -:  797:  }
        -:  798:
    #####:  799:  if (size > 0)
        -:  800:  {
    #####:  801:    memset (digits_p, 0, size * sizeof (uint64_t));
        -:  802:  }
        -:  803:} /* ecma_bigint_get_digits_and_sign */
        -:  804:
        -:  805:/**
        -:  806: * Compare two BigInt values
        -:  807: *
        -:  808: * @return true if they are the same, false otherwise
        -:  809: */
        -:  810:bool
    #####:  811:ecma_bigint_is_equal_to_bigint (ecma_value_t left_value, /**< left BigInt value */
        -:  812:                                ecma_value_t right_value) /**< right BigInt value */
        -:  813:{
    #####:  814:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -:  815:
    #####:  816:  if (left_value == ECMA_BIGINT_ZERO)
        -:  817:  {
    #####:  818:    return right_value == ECMA_BIGINT_ZERO;
        -:  819:  }
    #####:  820:  else if (right_value == ECMA_BIGINT_ZERO)
        -:  821:  {
    #####:  822:    return false;
        -:  823:  }
        -:  824:
    #####:  825:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####:  826:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -:  827:
    #####:  828:  if (left_p->u.bigint_sign_and_size != right_p->u.bigint_sign_and_size)
        -:  829:  {
    #####:  830:    return false;
        -:  831:  }
        -:  832:
    #####:  833:  uint32_t size = ECMA_BIGINT_GET_SIZE (left_p);
    #####:  834:  return memcmp (ECMA_BIGINT_GET_DIGITS (left_p, 0), ECMA_BIGINT_GET_DIGITS (right_p, 0), size) == 0;
        -:  835:} /* ecma_bigint_is_equal_to_bigint */
        -:  836:
        -:  837:/**
        -:  838: * Compare a BigInt value and a number
        -:  839: *
        -:  840: * @return true if they are the same, false otherwise
        -:  841: */
        -:  842:bool
    #####:  843:ecma_bigint_is_equal_to_number (ecma_value_t left_value, /**< left BigInt value */
        -:  844:                                ecma_number_t right_value) /**< right number value */
        -:  845:{
    #####:  846:  JERRY_ASSERT (ecma_is_value_bigint (left_value));
        -:  847:
    #####:  848:  if (ecma_number_is_nan (right_value) || ecma_number_is_infinity (right_value))
        -:  849:  {
    #####:  850:    return false;
        -:  851:  }
        -:  852:
    #####:  853:  if (left_value == ECMA_BIGINT_ZERO)
        -:  854:  {
    #####:  855:    return right_value == 0;
        -:  856:  }
        -:  857:
    #####:  858:  ecma_extended_primitive_t *left_value_p = ecma_get_extended_primitive_from_value (left_value);
        -:  859:
        -:  860:  /* Sign must be the same. */
    #####:  861:  if (left_value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -:  862:  {
    #####:  863:    if (right_value > 0)
        -:  864:    {
    #####:  865:      return false;
        -:  866:    }
        -:  867:  }
    #####:  868:  else if (right_value < 0)
        -:  869:  {
    #####:  870:    return false;
        -:  871:  }
        -:  872:
    #####:  873:  ecma_bigint_digit_t digits[3];
    #####:  874:  uint32_t result = ecma_bigint_number_to_digits (right_value, digits);
        -:  875:
    #####:  876:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -:  877:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -:  878:
    #####:  879:  if (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION)
        -:  880:  {
    #####:  881:    return false;
        -:  882:  }
        -:  883:
    #####:  884:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
    #####:  885:  uint32_t zero_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -:  886:
    #####:  887:  if (ECMA_BIGINT_GET_SIZE (left_value_p) != digits_size + zero_size)
        -:  888:  {
    #####:  889:    return false;
        -:  890:  }
        -:  891:
    #####:  892:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  893:  ecma_bigint_digit_t *left_end_p = (ecma_bigint_digit_t *) (((uint8_t *) left_p) + zero_size);
        -:  894:
        -:  895:  /* Check value bits first. */
    #####:  896:  if (memcmp (left_end_p, digits, digits_size) != 0)
        -:  897:  {
    #####:  898:    return false;
        -:  899:  }
        -:  900:
    #####:  901:  while (left_p < left_end_p)
        -:  902:  {
    #####:  903:    if (*left_p++ != 0)
        -:  904:    {
    #####:  905:      return false;
        -:  906:    }
        -:  907:  }
        -:  908:
    #####:  909:  return true;
        -:  910:} /* ecma_bigint_is_equal_to_number */
        -:  911:
        -:  912:/**
        -:  913: * Convert 0 to 1, and 1 to -1. Useful for getting sign.
        -:  914: */
        -:  915:#define ECMA_BIGINT_TO_SIGN(value) (1 - (((int) (value)) << 1))
        -:  916:
        -:  917:/**
        -:  918: * Convert 0 to -1, and 1 to 1. Useful for getting negated sign.
        -:  919: */
        -:  920:#define ECMA_BIGINT_TO_NEGATED_SIGN(value) (-1 + (((int) (value)) << 1))
        -:  921:
        -:  922:/**
        -:  923: * Compare two BigInt values
        -:  924: *
        -:  925: * return -1, if left value < right value, 0 if they are equal, 1 otherwise
        -:  926: */
        -:  927:int
    #####:  928:ecma_bigint_compare_to_bigint (ecma_value_t left_value, /**< left BigInt value */
        -:  929:                               ecma_value_t right_value) /**< right BigInt value */
        -:  930:{
    #####:  931:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -:  932:
    #####:  933:  if (left_value == ECMA_BIGINT_ZERO)
        -:  934:  {
    #####:  935:    if (right_value == ECMA_BIGINT_ZERO)
        -:  936:    {
    #####:  937:      return 0;
        -:  938:    }
        -:  939:
    #####:  940:    ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####:  941:    return ECMA_BIGINT_TO_NEGATED_SIGN (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -:  942:  }
        -:  943:
    #####:  944:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####:  945:  uint32_t left_sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -:  946:
    #####:  947:  if (right_value == ECMA_BIGINT_ZERO)
        -:  948:  {
    #####:  949:    return ECMA_BIGINT_TO_SIGN (left_sign);
        -:  950:  }
        -:  951:
    #####:  952:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####:  953:  uint32_t right_sign = right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -:  954:
    #####:  955:  if ((left_sign ^ right_sign) != 0)
        -:  956:  {
    #####:  957:    return ECMA_BIGINT_TO_SIGN (left_sign);
        -:  958:  }
        -:  959:
    #####:  960:  if (left_sign == 0)
        -:  961:  {
    #####:  962:    return ecma_big_uint_compare (left_p, right_p);
        -:  963:  }
        -:  964:
    #####:  965:  return -ecma_big_uint_compare (left_p, right_p);
        -:  966:} /* ecma_bigint_compare_to_bigint */
        -:  967:
        -:  968:/**
        -:  969: * Compare a BigInt value and a number
        -:  970: *
        -:  971: * return -1, if left value < right value, 0 if they are equal, 1 otherwise
        -:  972: */
        -:  973:int
    #####:  974:ecma_bigint_compare_to_number (ecma_value_t left_value, /**< left BigInt value */
        -:  975:                               ecma_number_t right_value) /**< right number value */
        -:  976:{
    #####:  977:  JERRY_ASSERT (ecma_is_value_bigint (left_value));
    #####:  978:  JERRY_ASSERT (!ecma_number_is_nan (right_value));
        -:  979:
    #####:  980:  int right_invert_sign = ECMA_BIGINT_TO_SIGN (right_value > 0);
        -:  981:
    #####:  982:  if (left_value == ECMA_BIGINT_ZERO)
        -:  983:  {
    #####:  984:    if (right_value == 0)
        -:  985:    {
    #####:  986:      return 0;
        -:  987:    }
        -:  988:
    #####:  989:    return right_invert_sign;
        -:  990:  }
        -:  991:
    #####:  992:  ecma_extended_primitive_t *left_value_p = ecma_get_extended_primitive_from_value (left_value);
    #####:  993:  int left_sign = ECMA_BIGINT_TO_SIGN (left_value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN);
        -:  994:
    #####:  995:  if (right_value == 0 || left_sign == right_invert_sign)
        -:  996:  {
        -:  997:    /* Second condition: a positive BigInt is always greater than any negative number, and the opposite is true. */
    #####:  998:    return left_sign;
        -:  999:  }
        -: 1000:
    #####: 1001:  if (ecma_number_is_infinity (right_value))
        -: 1002:  {
        -: 1003:    /* Infinity is always bigger than any BigInt number. */
    #####: 1004:    return right_invert_sign;
        -: 1005:  }
        -: 1006:
    #####: 1007:  ecma_bigint_digit_t digits[3];
    #####: 1008:  uint32_t result = ecma_bigint_number_to_digits (right_value, digits);
        -: 1009:
    #####: 1010:  JERRY_ASSERT (ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) == 0
        -: 1011:                || digits[ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS (result) - 1] > 0);
        -: 1012:
    #####: 1013:  uint32_t digits_size = ECMA_BIGINT_NUMBER_TO_DIGITS_GET_DIGITS_SIZE (result);
        -: 1014:
    #####: 1015:  if (digits_size == 0)
        -: 1016:  {
    #####: 1017:    JERRY_ASSERT (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION);
        -: 1018:    /* The number is between [-1 .. 1] exclusive. */
    #####: 1019:    return left_sign;
        -: 1020:  }
        -: 1021:
    #####: 1022:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1023:  uint32_t right_size = digits_size + ECMA_BIGINT_NUMBER_TO_DIGITS_GET_ZERO_SIZE (result);
        -: 1024:
    #####: 1025:  if (left_size != right_size)
        -: 1026:  {
    #####: 1027:    return left_size > right_size ? left_sign : -left_sign;
        -: 1028:  }
        -: 1029:
    #####: 1030:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, right_size);
    #####: 1031:  ecma_bigint_digit_t *left_end_p = (ecma_bigint_digit_t *) (((uint8_t *) left_p) - digits_size);
    #####: 1032:  ecma_bigint_digit_t *digits_p = (ecma_bigint_digit_t *) (((uint8_t *) digits) + digits_size);
        -: 1033:
        -: 1034:  do
        -: 1035:  {
    #####: 1036:    ecma_bigint_digit_t left = *(--left_p);
    #####: 1037:    ecma_bigint_digit_t right = *(--digits_p);
        -: 1038:
    #####: 1039:    if (left != right)
        -: 1040:    {
    #####: 1041:      return left > right ? left_sign : -left_sign;
        -: 1042:    }
    #####: 1043:  } while (left_p > left_end_p);
        -: 1044:
    #####: 1045:  left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
        -: 1046:
    #####: 1047:  while (left_p > left_end_p)
        -: 1048:  {
    #####: 1049:    if (*(--left_p) != 0)
        -: 1050:    {
    #####: 1051:      return left_sign;
        -: 1052:    }
        -: 1053:  }
        -: 1054:
    #####: 1055:  return (result & ECMA_BIGINT_NUMBER_TO_DIGITS_HAS_FRACTION) ? -left_sign : 0;
        -: 1056:} /* ecma_bigint_compare_to_number */
        -: 1057:
        -: 1058:#undef ECMA_BIGINT_TO_SIGN
        -: 1059:
        -: 1060:/**
        -: 1061: * Negate a non-zero BigInt value
        -: 1062: *
        -: 1063: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1064: *         Returned value must be freed with ecma_free_value.
        -: 1065: */
        -: 1066:ecma_value_t
    #####: 1067:ecma_bigint_negate (ecma_extended_primitive_t *value_p) /**< BigInt value */
        -: 1068:{
    #####: 1069:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -: 1070:
    #####: 1071:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -: 1072:
    #####: 1073:  ecma_extended_primitive_t *result_p = ecma_bigint_create (size);
        -: 1074:
    #####: 1075:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1076:  {
    #####: 1077:    return ecma_bigint_raise_memory_error ();
        -: 1078:  }
        -: 1079:
    #####: 1080:  memcpy (result_p + 1, value_p + 1, size);
    #####: 1081:  result_p->refs_and_type = ECMA_EXTENDED_PRIMITIVE_REF_ONE | ECMA_TYPE_BIGINT;
    #####: 1082:  result_p->u.bigint_sign_and_size = value_p->u.bigint_sign_and_size ^ ECMA_BIGINT_SIGN;
        -: 1083:
    #####: 1084:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1085:} /* ecma_bigint_negate */
        -: 1086:
        -: 1087:/**
        -: 1088: * Invert all bits of a BigInt value
        -: 1089: *
        -: 1090: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1091: *         Returned value must be freed with ecma_free_value.
        -: 1092: */
        -: 1093:ecma_value_t
    #####: 1094:ecma_bigint_unary (ecma_value_t value, /**< BigInt value */
        -: 1095:                   ecma_bigint_unary_operation_type type) /**< type of unary operation */
        -: 1096:{
    #####: 1097:  JERRY_ASSERT (ecma_is_value_bigint (value));
        -: 1098:
    #####: 1099:  if (value == ECMA_BIGINT_ZERO)
        -: 1100:  {
    #####: 1101:    return ecma_bigint_create_from_digit (1, type != ECMA_BIGINT_UNARY_INCREASE);
        -: 1102:  }
        -: 1103:
    #####: 1104:  ecma_extended_primitive_t *value_p = ecma_get_extended_primitive_from_value (value);
        -: 1105:
    #####: 1106:  uint32_t sign = (type != ECMA_BIGINT_UNARY_DECREASE) ? ECMA_BIGINT_SIGN : 0;
        -: 1107:
    #####: 1108:  if ((value_p->u.bigint_sign_and_size == (uint32_t) (sizeof (ecma_bigint_digit_t) | sign))
    #####: 1109:      && *ECMA_BIGINT_GET_DIGITS (value_p, 0) == 1)
        -: 1110:  {
    #####: 1111:    return ECMA_BIGINT_ZERO;
        -: 1112:  }
        -: 1113:
        -: 1114:  ecma_extended_primitive_t *result_p;
        -: 1115:
    #####: 1116:  if ((value_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) == (sign ^ ECMA_BIGINT_SIGN))
        -: 1117:  {
    #####: 1118:    result_p = ecma_big_uint_increase (value_p);
        -: 1119:
    #####: 1120:    if (type != ECMA_BIGINT_UNARY_INCREASE && result_p != NULL)
        -: 1121:    {
    #####: 1122:      result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1123:    }
        -: 1124:  }
        -: 1125:  else
        -: 1126:  {
    #####: 1127:    result_p = ecma_big_uint_decrease (value_p);
        -: 1128:
    #####: 1129:    if (type == ECMA_BIGINT_UNARY_INCREASE && result_p != NULL)
        -: 1130:    {
    #####: 1131:      result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1132:    }
        -: 1133:  }
        -: 1134:
    #####: 1135:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1136:  {
    #####: 1137:    return ecma_bigint_raise_memory_error ();
        -: 1138:  }
        -: 1139:
    #####: 1140:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1141:} /* ecma_bigint_unary */
        -: 1142:
        -: 1143:/**
        -: 1144: * Add/subtract right BigInt value to/from left BigInt value
        -: 1145: *
        -: 1146: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1147: *         Returned value must be freed with ecma_free_value.
        -: 1148: */
        -: 1149:ecma_value_t
    #####: 1150:ecma_bigint_add_sub (ecma_value_t left_value, /**< left BigInt value */
        -: 1151:                     ecma_value_t right_value, /**< right BigInt value */
        -: 1152:                     bool is_add) /**< true if add operation should be performed */
        -: 1153:{
    #####: 1154:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1155:
    #####: 1156:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1157:  {
    #####: 1158:    return ecma_copy_value (left_value);
        -: 1159:  }
        -: 1160:
    #####: 1161:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1162:
    #####: 1163:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1164:  {
    #####: 1165:    if (!is_add)
        -: 1166:    {
    #####: 1167:      return ecma_bigint_negate (right_p);
        -: 1168:    }
        -: 1169:
    #####: 1170:    ecma_ref_extended_primitive (right_p);
    #####: 1171:    return right_value;
        -: 1172:  }
        -: 1173:
    #####: 1174:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1175:  uint32_t sign = is_add ? 0 : ECMA_BIGINT_SIGN;
        -: 1176:
    #####: 1177:  if (((left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN) == sign)
        -: 1178:  {
    #####: 1179:    ecma_extended_primitive_t *result_p = ecma_big_uint_add (left_p, right_p);
        -: 1180:
    #####: 1181:    if (JERRY_UNLIKELY (result_p == NULL))
        -: 1182:    {
    #####: 1183:      return ecma_bigint_raise_memory_error ();
        -: 1184:    }
        -: 1185:
    #####: 1186:    result_p->u.bigint_sign_and_size |= left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
    #####: 1187:    return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1188:  }
        -: 1189:
    #####: 1190:  int compare_result = ecma_big_uint_compare (left_p, right_p);
        -: 1191:  ecma_extended_primitive_t *result_p;
        -: 1192:
    #####: 1193:  if (compare_result == 0)
        -: 1194:  {
    #####: 1195:    return ECMA_BIGINT_ZERO;
        -: 1196:  }
        -: 1197:
    #####: 1198:  if (compare_result > 0)
        -: 1199:  {
    #####: 1200:    sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
    #####: 1201:    result_p = ecma_big_uint_sub (left_p, right_p);
        -: 1202:  }
        -: 1203:  else
        -: 1204:  {
    #####: 1205:    sign = right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1206:
    #####: 1207:    if (!is_add)
        -: 1208:    {
    #####: 1209:      sign ^= ECMA_BIGINT_SIGN;
        -: 1210:    }
        -: 1211:
    #####: 1212:    result_p = ecma_big_uint_sub (right_p, left_p);
        -: 1213:  }
        -: 1214:
    #####: 1215:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1216:  {
    #####: 1217:    return ecma_bigint_raise_memory_error ();
        -: 1218:  }
        -: 1219:
    #####: 1220:  result_p->u.bigint_sign_and_size |= sign;
    #####: 1221:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1222:} /* ecma_bigint_add_sub */
        -: 1223:
        -: 1224:/**
        -: 1225: * Multiply two BigInt values
        -: 1226: *
        -: 1227: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1228: *         Returned value must be freed with ecma_free_value.
        -: 1229: */
        -: 1230:ecma_value_t
    #####: 1231:ecma_bigint_mul (ecma_value_t left_value, /**< left BigInt value */
        -: 1232:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1233:{
    #####: 1234:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1235:
    #####: 1236:  if (left_value == ECMA_BIGINT_ZERO || right_value == ECMA_BIGINT_ZERO)
        -: 1237:  {
    #####: 1238:    return ECMA_BIGINT_ZERO;
        -: 1239:  }
        -: 1240:
    #####: 1241:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1242:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
    #####: 1243:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_p);
    #####: 1244:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_p);
        -: 1245:
    #####: 1246:  if (left_size == sizeof (ecma_bigint_digit_t)
    #####: 1247:      && ECMA_BIGINT_GET_LAST_DIGIT (left_p, sizeof (ecma_bigint_digit_t)) == 1)
        -: 1248:  {
    #####: 1249:    if (left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1250:    {
    #####: 1251:      return ecma_bigint_negate (right_p);
        -: 1252:    }
        -: 1253:
    #####: 1254:    ecma_ref_extended_primitive (right_p);
    #####: 1255:    return right_value;
        -: 1256:  }
        -: 1257:
    #####: 1258:  if (right_size == sizeof (ecma_bigint_digit_t)
    #####: 1259:      && ECMA_BIGINT_GET_LAST_DIGIT (right_p, sizeof (ecma_bigint_digit_t)) == 1)
        -: 1260:  {
    #####: 1261:    if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1262:    {
    #####: 1263:      return ecma_bigint_negate (left_p);
        -: 1264:    }
        -: 1265:
    #####: 1266:    ecma_ref_extended_primitive (left_p);
    #####: 1267:    return left_value;
        -: 1268:  }
        -: 1269:
    #####: 1270:  ecma_extended_primitive_t *result_p = ecma_big_uint_mul (left_p, right_p);
        -: 1271:
    #####: 1272:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1273:  {
    #####: 1274:    return ecma_bigint_raise_memory_error ();
        -: 1275:  }
        -: 1276:
    #####: 1277:  uint32_t sign = (left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN;
    #####: 1278:  result_p->u.bigint_sign_and_size |= sign;
    #####: 1279:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1280:} /* ecma_bigint_mul */
        -: 1281:
        -: 1282:/**
        -: 1283: * Divide two BigInt values
        -: 1284: *
        -: 1285: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1286: *         Returned value must be freed with ecma_free_value.
        -: 1287: */
        -: 1288:ecma_value_t
    #####: 1289:ecma_bigint_div_mod (ecma_value_t left_value, /**< left BigInt value */
        -: 1290:                     ecma_value_t right_value, /**< right BigInt value */
        -: 1291:                     bool is_mod) /**< true if return with remainder */
        -: 1292:{
    #####: 1293:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1294:
    #####: 1295:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1296:  {
    #####: 1297:    return ecma_raise_range_error (ECMA_ERR_BIGINT_ZERO_DIVISION);
        -: 1298:  }
        -: 1299:
    #####: 1300:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1301:  {
    #####: 1302:    return left_value;
        -: 1303:  }
        -: 1304:
    #####: 1305:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1306:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1307:
    #####: 1308:  int compare_result = ecma_big_uint_compare (left_p, right_p);
        -: 1309:  ecma_extended_primitive_t *result_p;
        -: 1310:
    #####: 1311:  if (compare_result < 0)
        -: 1312:  {
    #####: 1313:    if (!is_mod)
        -: 1314:    {
    #####: 1315:      return ECMA_BIGINT_ZERO;
        -: 1316:    }
        -: 1317:
    #####: 1318:    ecma_ref_extended_primitive (left_p);
    #####: 1319:    return left_value;
        -: 1320:  }
    #####: 1321:  else if (compare_result == 0)
        -: 1322:  {
    #####: 1323:    if (is_mod)
        -: 1324:    {
    #####: 1325:      return ECMA_BIGINT_ZERO;
        -: 1326:    }
        -: 1327:
    #####: 1328:    result_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -: 1329:
    #####: 1330:    if (result_p != NULL)
        -: 1331:    {
    #####: 1332:      *ECMA_BIGINT_GET_DIGITS (result_p, 0) = 1;
        -: 1333:    }
        -: 1334:  }
        -: 1335:  else
        -: 1336:  {
    #####: 1337:    result_p = ecma_big_uint_div_mod (left_p, right_p, is_mod);
        -: 1338:
    #####: 1339:    if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1340:    {
    #####: 1341:      return ECMA_BIGINT_ZERO;
        -: 1342:    }
        -: 1343:  }
        -: 1344:
    #####: 1345:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1346:  {
    #####: 1347:    return ecma_bigint_raise_memory_error ();
        -: 1348:  }
        -: 1349:
    #####: 1350:  if (is_mod)
        -: 1351:  {
    #####: 1352:    result_p->u.bigint_sign_and_size |= left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1353:  }
        -: 1354:  else
        -: 1355:  {
    #####: 1356:    uint32_t sign = (left_p->u.bigint_sign_and_size ^ right_p->u.bigint_sign_and_size) & ECMA_BIGINT_SIGN;
    #####: 1357:    result_p->u.bigint_sign_and_size |= sign;
        -: 1358:  }
        -: 1359:
    #####: 1360:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1361:} /* ecma_bigint_div_mod */
        -: 1362:
        -: 1363:/**
        -: 1364: * Shift left BigInt value to left or right
        -: 1365: *
        -: 1366: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1367: *         Returned value must be freed with ecma_free_value.
        -: 1368: */
        -: 1369:ecma_value_t
    #####: 1370:ecma_bigint_shift (ecma_value_t left_value, /**< left BigInt value */
        -: 1371:                   ecma_value_t right_value, /**< right BigInt value */
        -: 1372:                   bool is_left) /**< true if left shift operation should be performed */
        -: 1373:{
    #####: 1374:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1375:
    #####: 1376:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1377:  {
    #####: 1378:    return ECMA_BIGINT_ZERO;
        -: 1379:  }
        -: 1380:
    #####: 1381:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
        -: 1382:
    #####: 1383:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1384:  {
    #####: 1385:    ecma_ref_extended_primitive (left_p);
    #####: 1386:    return left_value;
        -: 1387:  }
        -: 1388:
    #####: 1389:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1390:
    #####: 1391:  if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1392:  {
    #####: 1393:    is_left = !is_left;
        -: 1394:  }
        -: 1395:
    #####: 1396:  if (ECMA_BIGINT_GET_SIZE (right_p) > sizeof (ecma_bigint_digit_t))
        -: 1397:  {
    #####: 1398:    if (is_left)
        -: 1399:    {
    #####: 1400:      return ecma_bigint_raise_memory_error ();
        -: 1401:    }
    #####: 1402:    else if (left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1403:    {
        -: 1404:      /* Shifting a negative value with a very big number to the right should be -1. */
    #####: 1405:      return ecma_bigint_create_from_digit (1, true);
        -: 1406:    }
        -: 1407:
    #####: 1408:    return ECMA_BIGINT_ZERO;
        -: 1409:  }
        -: 1410:
        -: 1411:  ecma_extended_primitive_t *result_p;
    #####: 1412:  ecma_bigint_digit_t shift = ECMA_BIGINT_GET_LAST_DIGIT (right_p, sizeof (ecma_bigint_digit_t));
    #####: 1413:  uint32_t left_sign = left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN;
        -: 1414:
    #####: 1415:  if (is_left)
        -: 1416:  {
    #####: 1417:    result_p = ecma_big_uint_shift_left (left_p, shift);
        -: 1418:  }
        -: 1419:  else
        -: 1420:  {
        -: 1421:    /* -x >> y == ~(x - 1) >> y == ~((x - 1) >> y) == -(((x - 1) >> y) + 1)
        -: 1422:     * When a non-zero bit is shifted out: (x - 1) >> y == x >> y, so the formula is -((x >> y) + 1)
        -: 1423:     * When only zero bits are shifted out: (((x - 1) >> y) + 1) == x >> y so the formula is: -(x >> y) */
    #####: 1424:    result_p = ecma_big_uint_shift_right (left_p, shift, left_sign != 0);
        -: 1425:
    #####: 1426:    if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1427:    {
    #####: 1428:      return ECMA_BIGINT_ZERO;
        -: 1429:    }
        -: 1430:  }
        -: 1431:
    #####: 1432:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1433:  {
    #####: 1434:    return ecma_bigint_raise_memory_error ();
        -: 1435:  }
        -: 1436:
    #####: 1437:  result_p->u.bigint_sign_and_size |= left_sign;
    #####: 1438:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1439:} /* ecma_bigint_shift */
        -: 1440:
        -: 1441:#if JERRY_ESNEXT
        -: 1442:
        -: 1443:/**
        -: 1444: * Compute the left value raised to the power of right value
        -: 1445: *
        -: 1446: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1447: *         Returned value must be freed with ecma_free_value.
        -: 1448: */
        -: 1449:ecma_value_t
    #####: 1450:ecma_bigint_pow (ecma_value_t left_value, /**< left BigInt value */
        -: 1451:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1452:{
    #####: 1453:  JERRY_ASSERT (ecma_is_value_bigint (left_value) && ecma_is_value_bigint (right_value));
        -: 1454:
    #####: 1455:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1456:  {
    #####: 1457:    return ecma_bigint_create_from_digit (1, false);
        -: 1458:  }
        -: 1459:
    #####: 1460:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1461:
    #####: 1462:  if (right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -: 1463:  {
    #####: 1464:    return ecma_raise_range_error (ECMA_ERR_NEGATIVE_EXPONENT_IS_NOT_ALLOWED_FOR_BIGINTS);
        -: 1465:  }
        -: 1466:
    #####: 1467:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1468:  {
    #####: 1469:    return ECMA_BIGINT_ZERO;
        -: 1470:  }
        -: 1471:
    #####: 1472:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1473:  ecma_bigint_digit_t base = 0;
        -: 1474:
    #####: 1475:  if (ECMA_BIGINT_GET_SIZE (left_p) == sizeof (ecma_bigint_digit_t))
        -: 1476:  {
    #####: 1477:    base = *ECMA_BIGINT_GET_DIGITS (left_p, 0);
        -: 1478:
    #####: 1479:    JERRY_ASSERT (base != 0);
        -: 1480:
    #####: 1481:    if (base == 1)
        -: 1482:    {
    #####: 1483:      if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
    #####: 1484:          || ECMA_BIGINT_NUMBER_IS_ODD (*ECMA_BIGINT_GET_DIGITS (right_p, 0)))
        -: 1485:      {
    #####: 1486:        ecma_ref_extended_primitive (left_p);
    #####: 1487:        return left_value;
        -: 1488:      }
        -: 1489:
    #####: 1490:      return ecma_bigint_create_from_digit (1, false);
        -: 1491:    }
        -: 1492:  }
        -: 1493:
    #####: 1494:  if (JERRY_UNLIKELY (ECMA_BIGINT_GET_SIZE (right_p) > sizeof (ecma_bigint_digit_t)))
        -: 1495:  {
    #####: 1496:    return ecma_bigint_raise_memory_error ();
        -: 1497:  }
        -: 1498:
    #####: 1499:  ecma_bigint_digit_t power = *ECMA_BIGINT_GET_DIGITS (right_p, 0);
        -: 1500:
    #####: 1501:  if (power == 1)
        -: 1502:  {
    #####: 1503:    ecma_ref_extended_primitive (left_p);
    #####: 1504:    return left_value;
        -: 1505:  }
        -: 1506:
        -: 1507:  ecma_extended_primitive_t *result_p;
        -: 1508:
    #####: 1509:  if (base == 2)
        -: 1510:  {
    #####: 1511:    result_p = ecma_big_uint_shift_left (left_p, power - 1);
        -: 1512:  }
        -: 1513:  else
        -: 1514:  {
    #####: 1515:    result_p = ecma_big_uint_pow (left_p, power);
        -: 1516:  }
        -: 1517:
    #####: 1518:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1519:  {
    #####: 1520:    return ecma_bigint_raise_memory_error ();
        -: 1521:  }
        -: 1522:
    #####: 1523:  if ((left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN) && ECMA_BIGINT_NUMBER_IS_ODD (power))
        -: 1524:  {
    #####: 1525:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1526:  }
        -: 1527:
    #####: 1528:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1529:} /* ecma_bigint_pow */
        -: 1530:
        -: 1531:#endif /* JERRY_ESNEXT */
        -: 1532:
        -: 1533:/**
        -: 1534: * Convert the result to an ecma value
        -: 1535: *
        -: 1536: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1537: *         Returned value must be freed with ecma_free_value.
        -: 1538: */
        -: 1539:static ecma_value_t
    #####: 1540:ecma_bigint_bitwise_op (uint32_t operation_and_options, /**< bitwise operation type and options */
        -: 1541:                        ecma_extended_primitive_t *left_value_p, /**< left BigInt value */
        -: 1542:                        ecma_extended_primitive_t *right_value_p) /**< right BigInt value */
        -: 1543:{
        -: 1544:  ecma_extended_primitive_t *result_p;
    #####: 1545:  result_p = ecma_big_uint_bitwise_op (operation_and_options, left_value_p, right_value_p);
        -: 1546:
    #####: 1547:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1548:  {
    #####: 1549:    return ecma_bigint_raise_memory_error ();
        -: 1550:  }
        -: 1551:
    #####: 1552:  if (result_p == ECMA_BIGINT_POINTER_TO_ZERO)
        -: 1553:  {
    #####: 1554:    return ECMA_BIGINT_ZERO;
        -: 1555:  }
        -: 1556:
    #####: 1557:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1558:  {
    #####: 1559:    result_p->u.bigint_sign_and_size |= ECMA_BIGINT_SIGN;
        -: 1560:  }
        -: 1561:
    #####: 1562:  return ecma_make_extended_primitive_value (result_p, ECMA_TYPE_BIGINT);
        -: 1563:} /* ecma_bigint_bitwise_op */
        -: 1564:
        -: 1565:/**
        -: 1566: * Perform bitwise 'and' operations on two BigUInt numbers
        -: 1567: *
        -: 1568: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1569: *         Returned value must be freed with ecma_free_value.
        -: 1570: */
        -: 1571:ecma_value_t
    #####: 1572:ecma_bigint_and (ecma_value_t left_value, /**< left BigInt value */
        -: 1573:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1574:{
    #####: 1575:  if (left_value == ECMA_BIGINT_ZERO || right_value == ECMA_BIGINT_ZERO)
        -: 1576:  {
    #####: 1577:    return ECMA_BIGINT_ZERO;
        -: 1578:  }
        -: 1579:
    #####: 1580:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1581:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1582:
    #####: 1583:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1584:  {
    #####: 1585:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1586:    {
    #####: 1587:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_AND, left_p, right_p);
        -: 1588:    }
        -: 1589:
        -: 1590:    /* x & (-y) == x & ~(y-1) == x &~ (y-1) */
    #####: 1591:    uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT;
    #####: 1592:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1593:  }
        -: 1594:
    #####: 1595:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1596:  {
        -: 1597:    /* (-x) & y == ~(x-1) & y == y &~ (x-1) */
    #####: 1598:    uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT;
    #####: 1599:    return ecma_bigint_bitwise_op (operation_and_options, right_p, left_p);
        -: 1600:  }
        -: 1601:
        -: 1602:  /* (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1) */
    #####: 1603:  uint32_t operation_and_options =
        -: 1604:    (ECMA_BIG_UINT_BITWISE_OR | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1605:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1606:} /* ecma_bigint_and */
        -: 1607:
        -: 1608:/**
        -: 1609: * Perform bitwise 'or' operations on two BigUInt numbers
        -: 1610: *
        -: 1611: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1612: *         Returned value must be freed with ecma_free_value.
        -: 1613: */
        -: 1614:ecma_value_t
    #####: 1615:ecma_bigint_or (ecma_value_t left_value, /**< left BigInt value */
        -: 1616:                ecma_value_t right_value) /**< right BigInt value */
        -: 1617:{
    #####: 1618:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1619:  {
    #####: 1620:    return ecma_copy_value (right_value);
        -: 1621:  }
        -: 1622:
    #####: 1623:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1624:  {
    #####: 1625:    return ecma_copy_value (left_value);
        -: 1626:  }
        -: 1627:
    #####: 1628:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1629:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1630:
    #####: 1631:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1632:  {
    #####: 1633:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1634:    {
    #####: 1635:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_OR, left_p, right_p);
        -: 1636:    }
        -: 1637:
        -: 1638:    /* x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1) */
    #####: 1639:    uint32_t operation_and_options =
        -: 1640:      (ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1641:    return ecma_bigint_bitwise_op (operation_and_options, right_p, left_p);
        -: 1642:  }
        -: 1643:
    #####: 1644:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1645:  {
        -: 1646:    /* (-x) | y == ~(x-1) | y == ~((x-1) &~ y) == -(((x-1) &~ y) + 1) */
    #####: 1647:    uint32_t operation_and_options =
        -: 1648:      (ECMA_BIG_UINT_BITWISE_AND_NOT | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1649:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1650:  }
        -: 1651:
        -: 1652:  /* (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1)) = -(((x-1) & (y-1)) + 1) */
    #####: 1653:  uint32_t operation_and_options =
        -: 1654:    (ECMA_BIG_UINT_BITWISE_AND | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1655:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1656:} /* ecma_bigint_or */
        -: 1657:
        -: 1658:/**
        -: 1659: * Perform bitwise 'xor' operations on two BigUInt numbers
        -: 1660: *
        -: 1661: * @return ecma BigInt value or ECMA_VALUE_ERROR
        -: 1662: *         Returned value must be freed with ecma_free_value.
        -: 1663: */
        -: 1664:ecma_value_t
    #####: 1665:ecma_bigint_xor (ecma_value_t left_value, /**< left BigInt value */
        -: 1666:                 ecma_value_t right_value) /**< right BigInt value */
        -: 1667:{
    #####: 1668:  if (left_value == ECMA_BIGINT_ZERO)
        -: 1669:  {
    #####: 1670:    return ecma_copy_value (right_value);
        -: 1671:  }
        -: 1672:
    #####: 1673:  if (right_value == ECMA_BIGINT_ZERO)
        -: 1674:  {
    #####: 1675:    return ecma_copy_value (left_value);
        -: 1676:  }
        -: 1677:
    #####: 1678:  ecma_extended_primitive_t *left_p = ecma_get_extended_primitive_from_value (left_value);
    #####: 1679:  ecma_extended_primitive_t *right_p = ecma_get_extended_primitive_from_value (right_value);
        -: 1680:
    #####: 1681:  if (!(left_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1682:  {
    #####: 1683:    if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1684:    {
    #####: 1685:      return ecma_bigint_bitwise_op (ECMA_BIG_UINT_BITWISE_XOR, left_p, right_p);
        -: 1686:    }
        -: 1687:
        -: 1688:    /* x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1) */
    #####: 1689:    uint32_t operation_and_options =
        -: 1690:      (ECMA_BIG_UINT_BITWISE_XOR | ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1691:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1692:  }
        -: 1693:
    #####: 1694:  if (!(right_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN))
        -: 1695:  {
        -: 1696:    /* (-x) | y == ~(x-1) ^ y == ~((x-1) ^ y) == -(((x-1) ^ y) + 1) */
    #####: 1697:    uint32_t operation_and_options =
        -: 1698:      (ECMA_BIG_UINT_BITWISE_XOR | ECMA_BIG_UINT_BITWISE_DECREASE_LEFT | ECMA_BIG_UINT_BITWISE_INCREASE_RESULT);
    #####: 1699:    return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1700:  }
        -: 1701:
        -: 1702:  /* (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1) */
    #####: 1703:  uint32_t operation_and_options = ECMA_BIG_UINT_BITWISE_XOR | ECMA_BIG_UINT_BITWISE_DECREASE_BOTH;
    #####: 1704:  return ecma_bigint_bitwise_op (operation_and_options, left_p, right_p);
        -: 1705:} /* ecma_bigint_xor */
        -: 1706:
        -: 1707:#endif /* JERRY_BUILTIN_BIGINT */
