        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-external-pointers.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-globals.h"
        -:   19:#include "ecma-helpers.h"
        -:   20:#include "ecma-objects-general.h"
        -:   21:#include "ecma-objects.h"
        -:   22:
        -:   23:/** \addtogroup ecma ECMA
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   27: * @{
        -:   28: */
        -:   29:
        -:   30:/**
        -:   31: * Create a native pointer property to store the native pointer and its type info.
        -:   32: *
        -:   33: * @return true - if property was just created with specified value,
        -:   34: *         false - otherwise, if property existed before the call, it's value was updated
        -:   35: */
        -:   36:bool
    #####:   37:ecma_create_native_pointer_property (ecma_object_t *obj_p, /**< object to create property in */
        -:   38:                                     void *native_p, /**< native pointer */
        -:   39:                                     const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:   40:{
    #####:   41:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:   42:
    #####:   43:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:   44:  {
    #####:   45:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:   46:  }
        -:   47:
    #####:   48:  if (ecma_op_object_is_fast_array (obj_p))
        -:   49:  {
    #####:   50:    ecma_fast_array_convert_to_normal (obj_p);
        -:   51:  }
        -:   52:
    #####:   53:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:   54:
    #####:   55:  bool is_new = (property_p == NULL);
        -:   56:
        -:   57:  ecma_native_pointer_t *native_pointer_p;
        -:   58:
    #####:   59:  if (property_p == NULL)
        -:   60:  {
    #####:   61:    native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
        -:   62:
        -:   63:    ecma_property_value_t *value_p;
    #####:   64:    ECMA_CREATE_INTERNAL_PROPERTY (obj_p, name_p, property_p, value_p);
        -:   65:
    #####:   66:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
    #####:   67:    *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:   68:  }
    #####:   69:  else if (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL)
        -:   70:  {
    #####:   71:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   72:
    #####:   73:    native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value_p->value);
        -:   74:
    #####:   75:    if (native_pointer_p->native_info_p == native_info_p)
        -:   76:    {
    #####:   77:      native_pointer_p->native_p = native_p;
    #####:   78:      return false;
        -:   79:    }
        -:   80:
    #####:   81:    value_p->value = JMEM_CP_NULL;
        -:   82:    (void) value_p->value; /* Make cppcheck happy. */
    #####:   83:    *property_p &= (ecma_property_t) ~ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:   84:
        -:   85:    ecma_native_pointer_chain_t *item_p;
    #####:   86:    item_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:   87:    item_p->data = *native_pointer_p;
        -:   88:
    #####:   89:    jmem_heap_free_block (native_pointer_p, sizeof (ecma_native_pointer_t));
        -:   90:
    #####:   91:    item_p->next_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:   92:    item_p->next_p->next_p = NULL;
        -:   93:
    #####:   94:    native_pointer_p = &item_p->next_p->data;
    #####:   95:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, item_p);
        -:   96:  }
        -:   97:  else
        -:   98:  {
    #####:   99:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  100:
    #####:  101:    if (value_p->value == JMEM_CP_NULL)
        -:  102:    {
    #####:  103:      native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
    #####:  104:      ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
        -:  105:
    #####:  106:      *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:  107:    }
        -:  108:    else
        -:  109:    {
        -:  110:      ecma_native_pointer_chain_t *item_p;
    #####:  111:      item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  112:
        -:  113:      /* There should be at least 2 native pointers in the chain */
    #####:  114:      JERRY_ASSERT (item_p != NULL && item_p->next_p != NULL);
        -:  115:
        -:  116:      while (true)
        -:  117:      {
    #####:  118:        if (item_p->data.native_info_p == native_info_p)
        -:  119:        {
        -:  120:          /* The native info already exists -> update the corresponding data */
    #####:  121:          item_p->data.native_p = native_p;
    #####:  122:          return false;
        -:  123:        }
        -:  124:
    #####:  125:        if (item_p->next_p == NULL)
        -:  126:        {
        -:  127:          /* The native info does not exist -> append a new element to the chain */
    #####:  128:          break;
        -:  129:        }
        -:  130:
    #####:  131:        item_p = item_p->next_p;
        -:  132:      }
        -:  133:
        -:  134:      ecma_native_pointer_chain_t *new_item_p;
        -:  135:
    #####:  136:      new_item_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:  137:      item_p->next_p = new_item_p;
    #####:  138:      new_item_p->next_p = NULL;
        -:  139:
    #####:  140:      native_pointer_p = &new_item_p->data;
        -:  141:    }
        -:  142:  }
        -:  143:
    #####:  144:  native_pointer_p->native_p = native_p;
    #####:  145:  native_pointer_p->native_info_p = (jerry_object_native_info_t *) native_info_p;
        -:  146:
    #####:  147:  return is_new;
        -:  148:} /* ecma_create_native_pointer_property */
        -:  149:
        -:  150:/**
        -:  151: * Get value of native package stored in the object's property with specified identifier
        -:  152: *
        -:  153: * Note:
        -:  154: *      property identifier should be one of the following:
        -:  155: *        - LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER
        -:  156: *
        -:  157: * @return native pointer data if property exists
        -:  158: *         NULL otherwise
        -:  159: */
        -:  160:ecma_native_pointer_t *
    #####:  161:ecma_get_native_pointer_value (ecma_object_t *obj_p, /**< object to get property value from */
        -:  162:                               const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:  163:{
    #####:  164:  if (ecma_op_object_is_fast_array (obj_p))
        -:  165:  {
        -:  166:    /* Fast access mode array can not have native pointer properties */
    #####:  167:    return NULL;
        -:  168:  }
        -:  169:
    #####:  170:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:  171:
    #####:  172:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:  173:  {
    #####:  174:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:  175:  }
        -:  176:
    #####:  177:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  178:
    #####:  179:  if (property_p == NULL)
        -:  180:  {
    #####:  181:    return NULL;
        -:  182:  }
        -:  183:
    #####:  184:  ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  185:
    #####:  186:  if (JERRY_LIKELY (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL))
        -:  187:  {
    #####:  188:    ecma_native_pointer_t *native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value_p->value);
        -:  189:
    #####:  190:    if (native_pointer_p->native_info_p == native_info_p)
        -:  191:    {
    #####:  192:      return native_pointer_p;
        -:  193:    }
        -:  194:
    #####:  195:    return NULL;
        -:  196:  }
        -:  197:
    #####:  198:  if (value_p->value == JMEM_CP_NULL)
        -:  199:  {
    #####:  200:    return NULL;
        -:  201:  }
        -:  202:
        -:  203:  ecma_native_pointer_chain_t *item_p;
    #####:  204:  item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  205:
        -:  206:  /* There should be at least 2 native pointers in the chain */
    #####:  207:  JERRY_ASSERT (item_p != NULL && item_p->next_p != NULL);
        -:  208:
        -:  209:  do
        -:  210:  {
    #####:  211:    if (item_p->data.native_info_p == native_info_p)
        -:  212:    {
    #####:  213:      return &item_p->data;
        -:  214:    }
        -:  215:
    #####:  216:    item_p = item_p->next_p;
    #####:  217:  } while (item_p != NULL);
        -:  218:
    #####:  219:  return NULL;
        -:  220:} /* ecma_get_native_pointer_value */
        -:  221:
        -:  222:/**
        -:  223: * Delete the previously set native pointer by the native type info from the specified object.
        -:  224: *
        -:  225: * Note:
        -:  226: *      If the specified object has no matching native pointer for the given native type info
        -:  227: *      the function has no effect.
        -:  228: *
        -:  229: * @return true - if the native pointer has been deleted succesfully
        -:  230: *         false - otherwise
        -:  231: */
        -:  232:bool
    #####:  233:ecma_delete_native_pointer_property (ecma_object_t *obj_p, /**< object to delete property from */
        -:  234:                                     const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:  235:{
    #####:  236:  if (ecma_op_object_is_fast_array (obj_p))
        -:  237:  {
        -:  238:    /* Fast access mode array can not have native pointer properties */
    #####:  239:    return false;
        -:  240:  }
        -:  241:
    #####:  242:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:  243:
    #####:  244:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:  245:  {
    #####:  246:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:  247:  }
        -:  248:
    #####:  249:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  250:
    #####:  251:  if (property_p == NULL)
        -:  252:  {
    #####:  253:    return false;
        -:  254:  }
        -:  255:
    #####:  256:  ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  257:
    #####:  258:  if (JERRY_LIKELY (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL))
        -:  259:  {
    #####:  260:    ecma_native_pointer_t *native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value_p->value);
        -:  261:
    #####:  262:    if (native_pointer_p->native_info_p != native_info_p)
        -:  263:    {
    #####:  264:      return false;
        -:  265:    }
        -:  266:
    #####:  267:    value_p->value = JMEM_CP_NULL;
    #####:  268:    *property_p &= (ecma_property_t) ~ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
    #####:  269:    jmem_heap_free_block (native_pointer_p, sizeof (ecma_native_pointer_t));
    #####:  270:    return true;
        -:  271:  }
        -:  272:
    #####:  273:  if (value_p->value == JMEM_CP_NULL)
        -:  274:  {
    #####:  275:    return false;
        -:  276:  }
        -:  277:
        -:  278:  ecma_native_pointer_chain_t *first_p;
    #####:  279:  first_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  280:
        -:  281:  /* There should be at least 2 native pointers in the chain */
    #####:  282:  JERRY_ASSERT (first_p != NULL && first_p->next_p != NULL);
        -:  283:
    #####:  284:  ecma_native_pointer_chain_t *item_p = first_p;
    #####:  285:  ecma_native_pointer_chain_t *prev_p = NULL;
        -:  286:
        -:  287:  do
        -:  288:  {
    #####:  289:    if (item_p->data.native_info_p == native_info_p)
        -:  290:    {
    #####:  291:      if (prev_p == NULL)
        -:  292:      {
        -:  293:        /* The first element is deleted from the chain: change the property value. */
    #####:  294:        first_p = item_p->next_p;
    #####:  295:        ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, first_p);
        -:  296:      }
        -:  297:      else
        -:  298:      {
        -:  299:        /* A non-first element is deleted from the chain: update the previous pointer. */
    #####:  300:        prev_p->next_p = item_p->next_p;
        -:  301:      }
        -:  302:
    #####:  303:      jmem_heap_free_block (item_p, sizeof (ecma_native_pointer_chain_t));
        -:  304:
    #####:  305:      if (first_p->next_p != NULL)
        -:  306:      {
    #####:  307:        return true;
        -:  308:      }
        -:  309:
        -:  310:      /* Only one item remained. The ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL flag is
        -:  311:       * set early to avoid using the chain if the allocation below triggers a GC. */
    #####:  312:      *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:  313:
        -:  314:      ecma_native_pointer_t *native_pointer_p;
    #####:  315:      native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
    #####:  316:      *native_pointer_p = first_p->data;
        -:  317:
    #####:  318:      ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
        -:  319:
    #####:  320:      jmem_heap_free_block (first_p, sizeof (ecma_native_pointer_chain_t));
    #####:  321:      return true;
        -:  322:    }
        -:  323:
    #####:  324:    prev_p = item_p;
    #####:  325:    item_p = item_p->next_p;
    #####:  326:  } while (item_p != NULL);
        -:  327:
    #####:  328:  return false;
        -:  329:} /* ecma_delete_native_pointer_property */
        -:  330:
        -:  331:/**
        -:  332: * @}
        -:  333: * @}
        -:  334: */
