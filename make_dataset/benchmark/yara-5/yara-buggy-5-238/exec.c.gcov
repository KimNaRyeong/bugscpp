        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/libyara/exec.gcno
        -:    0:Data:/home/workspace/libyara/exec.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <string.h>
        -:   31:#include <assert.h>
        -:   32:#include <math.h>
        -:   33:#include <float.h>
        -:   34:
        -:   35:#include <yara/globals.h>
        -:   36:#include <yara/arena.h>
        -:   37:#include <yara/endian.h>
        -:   38:#include <yara/exec.h>
        -:   39:#include <yara/limits.h>
        -:   40:#include <yara/error.h>
        -:   41:#include <yara/object.h>
        -:   42:#include <yara/modules.h>
        -:   43:#include <yara/re.h>
        -:   44:#include <yara/strutils.h>
        -:   45:#include <yara/utils.h>
        -:   46:#include <yara/mem.h>
        -:   47:#include <yara/stopwatch.h>
        -:   48:
        -:   49:
        -:   50:#include <yara.h>
        -:   51:
        -:   52:
        -:   53:// Turn on paranoid mode by default if not defined otherwise. In paranoid
        -:   54:// mode additional checks are performed in order to mitigate the effects of
        -:   55:// malicious tampering with compiled rules. Such checks are not necessary
        -:   56:// when you can ensure that the compiled rules are executed exactly as they
        -:   57:// were generated by YARA, without any further modification. Check issue #891
        -:   58:// (https://github.com/VirusTotal/yara/issues/891) for more context.
        -:   59://
        -:   60:// Paranoid mode does not guarantee that it's safe to load compiled rules from
        -:   61:// third parties, it only prevents severe security issues. Maliciously crafted
        -:   62:// compiled rules can still crash YARA. Loading third-party compiled rules is
        -:   63:// *highly* discouraged. If you need to distribute YARA rules in compiled
        -:   64:// form you should encapsulate them in some digitally-signed package that
        -:   65:// ensure that they haven't been modified by someone else.
        -:   66:
        -:   67:#if !defined(YR_PARANOID_EXEC)
        -:   68:#define YR_PARANOID_EXEC   1
        -:   69:#endif
        -:   70:
        -:   71:
        -:   72:#define MEM_SIZE \
        -:   73:    YR_MAX_LOOP_NESTING * (YR_MAX_LOOP_VARS + YR_INTERNAL_LOOP_VARS)
        -:   74:
        -:   75:
        -:   76:#define push(x)  \
        -:   77:    if (stack.sp < stack.capacity) \
        -:   78:    { \
        -:   79:      stack.items[stack.sp++] = (x); \
        -:   80:    } \
        -:   81:    else \
        -:   82:    { \
        -:   83:      result = ERROR_EXEC_STACK_OVERFLOW; \
        -:   84:      stop = true; \
        -:   85:      break; \
        -:   86:    } \
        -:   87:
        -:   88:
        -:   89:#define pop(x) { assert(stack.sp > 0); x = stack.items[--stack.sp]; }
        -:   90:
        -:   91:#define is_undef(x) IS_UNDEFINED((x).i)
        -:   92:
        -:   93:#define ensure_defined(x) \
        -:   94:    if (is_undef(x)) \
        -:   95:    { \
        -:   96:      r1.i = YR_UNDEFINED; \
        -:   97:      push(r1); \
        -:   98:      break; \
        -:   99:    }
        -:  100:
        -:  101:#define ensure_within_mem(x) \
        -:  102:    if (x < 0 || x >= MEM_SIZE) \
        -:  103:    { \
        -:  104:      stop = true; \
        -:  105:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  106:      break; \
        -:  107:    }
        -:  108:
        -:  109:// Make sure that the string pointer is within the rules arena.
        -:  110:#define ensure_within_rules_arena(x) \
        -:  111:    { \
        -:  112:      YR_ARENA_REF ref; \
        -:  113:      if (yr_arena_ptr_to_ref(context->rules->arena, x, &ref) == 0) \
        -:  114:      { \
        -:  115:        stop = true; \
        -:  116:        result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  117:        break; \
        -:  118:      } \
        -:  119:    }
        -:  120:
        -:  121:#define check_object_canary(o) \
        -:  122:    if (o->canary != context->canary) \
        -:  123:    { \
        -:  124:      stop = true; \
        -:  125:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  126:      break; \
        -:  127:    }
        -:  128:
        -:  129:#define little_endian_uint8_t(x)     (x)
        -:  130:#define little_endian_int8_t(x)      (x)
        -:  131:#define little_endian_uint16_t(x)    yr_le16toh(x)
        -:  132:#define little_endian_int16_t(x)     yr_le16toh(x)
        -:  133:#define little_endian_uint32_t(x)    yr_le32toh(x)
        -:  134:#define little_endian_int32_t(x)     yr_le32toh(x)
        -:  135:
        -:  136:#define big_endian_uint8_t(x)        (x)
        -:  137:#define big_endian_int8_t(x)         (x)
        -:  138:#define big_endian_uint16_t(x)       yr_be16toh(x)
        -:  139:#define big_endian_int16_t(x)        yr_be16toh(x)
        -:  140:#define big_endian_uint32_t(x)       yr_be32toh(x)
        -:  141:#define big_endian_int32_t(x)        yr_be32toh(x)
        -:  142:
        -:  143:
        -:  144:#define function_read(type, endianess) \
        -:  145:    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \
        -:  146:    { \
        -:  147:      YR_MEMORY_BLOCK* block = iterator->first(iterator); \
        -:  148:      while (block != NULL) \
        -:  149:      { \
        -:  150:        if (offset >= block->base && \
        -:  151:            block->size >= sizeof(type) && \
        -:  152:            offset <= block->base + block->size - sizeof(type)) \
        -:  153:        { \
        -:  154:          type result; \
        -:  155:          const uint8_t* data = block->fetch_data(block); \
        -:  156:          if (data == NULL) \
        -:  157:            return YR_UNDEFINED; \
        -:  158:          result = *(type *)(data + offset - block->base); \
        -:  159:          result = endianess##_##type(result); \
        -:  160:          return result; \
        -:  161:        } \
        -:  162:        block = iterator->next(iterator); \
        -:  163:      } \
        -:  164:      return YR_UNDEFINED; \
        -:  165:    };
        -:  166:
        -:  167:
    #####:  168:function_read(uint8_t, little_endian)
    #####:  169:function_read(uint16_t, little_endian)
    #####:  170:function_read(uint32_t, little_endian)
    #####:  171:function_read(int8_t, little_endian)
    #####:  172:function_read(int16_t, little_endian)
    #####:  173:function_read(int32_t, little_endian)
    #####:  174:function_read(uint8_t, big_endian)
    #####:  175:function_read(uint16_t, big_endian)
    #####:  176:function_read(uint32_t, big_endian)
    #####:  177:function_read(int8_t, big_endian)
    #####:  178:function_read(int16_t, big_endian)
    #####:  179:function_read(int32_t, big_endian)
        -:  180:
        -:  181:
    #####:  182:static const uint8_t* jmp_if(
        -:  183:    int condition,
        -:  184:    const uint8_t* ip)
        -:  185:{
        -:  186:  size_t off;
        -:  187:
    #####:  188:  if (condition)
        -:  189:  {
        -:  190:    // The condition is true, the instruction pointer is incremented in the
        -:  191:    // amount specified by the jump's offset. The offset is relative to the
        -:  192:    // jump opcode, but now the instruction pointer is pointing past the opcode
        -:  193:    // that's why we decrement the offset by 1.
    #####:  194:    off = *(int32_t*)(ip) - 1;
        -:  195:  }
        -:  196:  else
        -:  197:  {
        -:  198:    // The condition is false, the execution flow proceeds with the instruction
        -:  199:    // right after the jump.
    #####:  200:    off = sizeof(int32_t);
        -:  201:  }
        -:  202:
    #####:  203:  return ip + off;
        -:  204:}
        -:  205:
        -:  206:
    #####:  207:static int iter_array_next(
        -:  208:    YR_ITERATOR* self,
        -:  209:    YR_VALUE_STACK* stack)
        -:  210:{
        -:  211:  YR_OBJECT* obj;
        -:  212:
        -:  213:  // Check that there's two available slots in the stack, one for the next
        -:  214:  // item returned by the iterator and another one for the boolean that
        -:  215:  // indicates if there are more items.
    #####:  216:  if (stack->sp + 1 >= stack->capacity)
    #####:  217:    return ERROR_EXEC_STACK_OVERFLOW;
        -:  218:
    #####:  219:  if (self->array_it.index < yr_object_array_length(self->array_it.array))
        -:  220:  {
        -:  221:    // Push the false value that indicates that the iterator is not exhausted.
    #####:  222:    stack->items[stack->sp++].i = 0;
        -:  223:
    #####:  224:    obj = yr_object_array_get_item(
        -:  225:        self->array_it.array, 0, self->array_it.index);
        -:  226:
    #####:  227:    if (obj != NULL)
    #####:  228:      stack->items[stack->sp++].o = obj;
        -:  229:    else
    #####:  230:      stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  231:
    #####:  232:    self->array_it.index++;
        -:  233:  }
        -:  234:  else
        -:  235:  {
        -:  236:    // Push true for indicating the iterator has been exhausted.
    #####:  237:    stack->items[stack->sp++].i = 1;
        -:  238:    // Push YR_UNDEFINED as a placeholder for the next item.
    #####:  239:    stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  240:  }
        -:  241:
    #####:  242:  return ERROR_SUCCESS;
        -:  243:}
        -:  244:
        -:  245:
    #####:  246:static int iter_dict_next(
        -:  247:    YR_ITERATOR* self,
        -:  248:    YR_VALUE_STACK* stack)
        -:  249:{
    #####:  250:  YR_DICTIONARY_ITEMS* items = object_as_dictionary(self->dict_it.dict)->items;
        -:  251:
        -:  252:  // Check that there's three available slots in the stack, two for the next
        -:  253:  // item returned by the iterator and its key, and another one for the boolean
        -:  254:  // that indicates if there are more items.
    #####:  255:  if (stack->sp + 2 >= stack->capacity)
    #####:  256:    return ERROR_EXEC_STACK_OVERFLOW;
        -:  257:
        -:  258:  // If the dictionary has no items or the iterator reached the last item, abort
        -:  259:  // the iteration, if not push the next key and value.
    #####:  260:  if (items == NULL || self->dict_it.index == items->used)
        -:  261:  {
        -:  262:    // Push true for indicating the iterator has been exhausted.
    #####:  263:    stack->items[stack->sp++].i = 1;
        -:  264:    // Push YR_UNDEFINED as a placeholder for the next key and value.
    #####:  265:    stack->items[stack->sp++].i = YR_UNDEFINED;
    #####:  266:    stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  267:  }
        -:  268:  else
        -:  269:  {
        -:  270:    // Push the false value that indicates that the iterator is not exhausted.
    #####:  271:    stack->items[stack->sp++].i = 0;
        -:  272:
    #####:  273:    if (items->objects[self->dict_it.index].obj != NULL)
        -:  274:    {
    #####:  275:      stack->items[stack->sp++].o = items->objects[self->dict_it.index].obj;
    #####:  276:      stack->items[stack->sp++].p = items->objects[self->dict_it.index].key;
        -:  277:    }
        -:  278:    else
        -:  279:    {
    #####:  280:      stack->items[stack->sp++].i = YR_UNDEFINED;
    #####:  281:      stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  282:    }
        -:  283:
    #####:  284:    self->dict_it.index++;
        -:  285:  }
        -:  286:
    #####:  287:  return ERROR_SUCCESS;
        -:  288:}
        -:  289:
        -:  290:
    #####:  291:static int iter_int_range_next(
        -:  292:    YR_ITERATOR* self,
        -:  293:    YR_VALUE_STACK* stack)
        -:  294:{
        -:  295:  // Check that there's two available slots in the stack, one for the next
        -:  296:  // item returned by the iterator and another one for the boolean that
        -:  297:  // indicates if there are more items.
    #####:  298:  if (stack->sp + 1 >= stack->capacity)
    #####:  299:    return ERROR_EXEC_STACK_OVERFLOW;
        -:  300:
    #####:  301:  if (!IS_UNDEFINED(self->int_range_it.next) &&
    #####:  302:      !IS_UNDEFINED(self->int_range_it.last) &&
    #####:  303:      self->int_range_it.next <= self->int_range_it.last)
        -:  304:  {
        -:  305:    // Push the false value that indicates that the iterator is not exhausted.
    #####:  306:    stack->items[stack->sp++].i = 0;
    #####:  307:    stack->items[stack->sp++].i = self->int_range_it.next;
    #####:  308:    self->int_range_it.next++;
        -:  309:  }
        -:  310:  else
        -:  311:  {
        -:  312:    // Push true for indicating the iterator has been exhausted.
    #####:  313:    stack->items[stack->sp++].i = 1;
        -:  314:    // Push YR_UNDEFINED as a placeholder for the next item.
    #####:  315:    stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  316:  }
        -:  317:
    #####:  318:  return ERROR_SUCCESS;
        -:  319:}
        -:  320:
        -:  321:
    #####:  322:static int iter_int_enum_next(
        -:  323:    YR_ITERATOR* self,
        -:  324:    YR_VALUE_STACK* stack)
        -:  325:{
        -:  326:  // Check that there's two available slots in the stack, one for the next
        -:  327:  // item returned by the iterator and another one for the boolean that
        -:  328:  // indicates if there are more items.
    #####:  329:  if (stack->sp + 1 >= stack->capacity)
    #####:  330:    return ERROR_EXEC_STACK_OVERFLOW;
        -:  331:
    #####:  332:  if (!IS_UNDEFINED(self->int_enum_it.next) &&
        -:  333:      !IS_UNDEFINED(self->int_enum_it.count) &&
    #####:  334:      self->int_enum_it.next < self->int_enum_it.count)
        -:  335:  {
        -:  336:    // Push the false value that indicates that the iterator is not exhausted.
    #####:  337:    stack->items[stack->sp++].i = 0;
    #####:  338:    stack->items[stack->sp++].i = self->int_enum_it.items[self->int_enum_it.next];
    #####:  339:    self->int_enum_it.next++;
        -:  340:  }
        -:  341:  else
        -:  342:  {
        -:  343:    // Push true for indicating the iterator has been exhausted.
    #####:  344:    stack->items[stack->sp++].i = 1;
        -:  345:    // Push YR_UNDEFINED as a placeholder for the next item.
    #####:  346:    stack->items[stack->sp++].i = YR_UNDEFINED;
        -:  347:  }
        -:  348:
    #####:  349:  return ERROR_SUCCESS;
        -:  350:}
        -:  351:
        -:  352:
    #####:  353:int yr_execute_code(
        -:  354:    YR_SCAN_CONTEXT* context)
        -:  355:{
    #####:  356:  const uint8_t* ip = context->rules->code_start;
        -:  357:
        -:  358:  YR_VALUE mem[MEM_SIZE];
        -:  359:  YR_VALUE args[YR_MAX_FUNCTION_ARGS];
        -:  360:  YR_VALUE r1;
        -:  361:  YR_VALUE r2;
        -:  362:  YR_VALUE r3;
        -:  363:  YR_VALUE r4;
        -:  364:
        -:  365:  YR_VALUE_STACK stack;
        -:  366:
        -:  367:  uint64_t elapsed_time;
        -:  368:
        -:  369:  #ifdef YR_PROFILING_ENABLED
        -:  370:  uint64_t start_time;
        -:  371:  #endif
        -:  372:
        -:  373:  uint32_t current_rule_idx;
    #####:  374:  YR_RULE* current_rule = NULL;
        -:  375:  YR_RULE* rule;
        -:  376:  YR_MATCH* match;
        -:  377:  YR_OBJECT_FUNCTION* function;
        -:  378:  YR_OBJECT** obj_ptr;
        -:  379:  YR_ARENA* obj_arena;
        -:  380:  YR_NOTEBOOK* it_notebook;
        -:  381:
        -:  382:  char* identifier;
        -:  383:  char* args_fmt;
        -:  384:
        -:  385:  int i;
        -:  386:  int found;
        -:  387:  int count;
    #####:  388:  int result = ERROR_SUCCESS;
    #####:  389:  int cycle = 0;
    #####:  390:  int obj_count = 0;
        -:  391:
    #####:  392:  bool stop = false;
        -:  393:
        -:  394:  uint8_t opcode;
        -:  395:
    #####:  396:  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack.capacity);
        -:  397:
    #####:  398:  stack.sp = 0;
    #####:  399:  stack.items = (YR_VALUE*) yr_malloc(stack.capacity * sizeof(YR_VALUE));
        -:  400:
    #####:  401:  if (stack.items == NULL)
    #####:  402:    return ERROR_INSUFFICIENT_MEMORY;
        -:  403:
    #####:  404:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  405:      yr_arena_create(1, 512 * sizeof(YR_OBJECT*), &obj_arena),
        -:  406:      yr_free(stack.items));
        -:  407:
    #####:  408:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  409:      yr_notebook_create(512 * sizeof(YR_ITERATOR), &it_notebook),
        -:  410:      yr_arena_release(obj_arena);
        -:  411:      yr_free(stack.items));
        -:  412:
        -:  413:  #ifdef YR_PROFILING_ENABLED
        -:  414:  start_time = yr_stopwatch_elapsed_ns(&context->stopwatch);
        -:  415:  #endif
        -:  416:
        -:  417:  #if YR_PARANOID_EXEC
    #####:  418:  memset(mem, 0, MEM_SIZE * sizeof(mem[0]));
        -:  419:  #endif
        -:  420:
    #####:  421:  while(!stop)
        -:  422:  {
        -:  423:    // Read the opcode from the address indicated by the instruction pointer.
    #####:  424:    opcode = *ip;
        -:  425:
        -:  426:    // Advance the instruction pointer, which now points past the opcode.
    #####:  427:    ip++;
        -:  428:
    #####:  429:    switch(opcode)
        -:  430:    {
    #####:  431:      case OP_NOP:
    #####:  432:        break;
        -:  433:
    #####:  434:      case OP_HALT:
    #####:  435:        assert(stack.sp == 0); // When HALT is reached the stack should be empty.
    #####:  436:        stop = true;
    #####:  437:        break;
        -:  438:
    #####:  439:      case OP_ITER_START_ARRAY:
    #####:  440:        r2.p = yr_notebook_alloc(it_notebook, sizeof(YR_ITERATOR));
        -:  441:
    #####:  442:        if (r2.p == NULL)
        -:  443:        {
    #####:  444:          result = ERROR_INSUFFICIENT_MEMORY;
        -:  445:        }
        -:  446:        else
        -:  447:        {
    #####:  448:          pop(r1);
    #####:  449:          r2.it->array_it.array = r1.o;
    #####:  450:          r2.it->array_it.index = 0;
    #####:  451:          r2.it->next = iter_array_next;
    #####:  452:          push(r2);
        -:  453:        }
        -:  454:
    #####:  455:        stop = (result != ERROR_SUCCESS);
    #####:  456:        break;
        -:  457:
    #####:  458:      case OP_ITER_START_DICT:
    #####:  459:        r2.p = yr_notebook_alloc(it_notebook, sizeof(YR_ITERATOR));
        -:  460:
    #####:  461:        if (r2.p == NULL)
        -:  462:        {
    #####:  463:          result = ERROR_INSUFFICIENT_MEMORY;
        -:  464:        }
        -:  465:        else
        -:  466:        {
    #####:  467:          pop(r1);
    #####:  468:          r2.it->dict_it.dict = r1.o;
    #####:  469:          r2.it->dict_it.index = 0;
    #####:  470:          r2.it->next = iter_dict_next;
    #####:  471:          push(r2);
        -:  472:        }
        -:  473:
    #####:  474:        stop = (result != ERROR_SUCCESS);
    #####:  475:        break;
        -:  476:
    #####:  477:      case OP_ITER_START_INT_RANGE:
        -:  478:        // Creates an iterator for an integer range. The higher bound of the
        -:  479:        // range is at the top of the stack followed by the lower bound.
    #####:  480:        r3.p = yr_notebook_alloc(it_notebook, sizeof(YR_ITERATOR));
        -:  481:
    #####:  482:        if (r3.p == NULL)
        -:  483:        {
    #####:  484:          result = ERROR_INSUFFICIENT_MEMORY;
        -:  485:        }
        -:  486:        else
        -:  487:        {
    #####:  488:          pop(r2);
    #####:  489:          pop(r1);
    #####:  490:          r3.it->int_range_it.next = r1.i;
    #####:  491:          r3.it->int_range_it.last = r2.i;
    #####:  492:          r3.it->next = iter_int_range_next;
    #####:  493:          push(r3);
        -:  494:        }
        -:  495:
    #####:  496:        stop = (result != ERROR_SUCCESS);
    #####:  497:        break;
        -:  498:
    #####:  499:      case OP_ITER_START_INT_ENUM:
        -:  500:        // Creates an iterator for an integer enumeration. The number of items
        -:  501:        // in the enumeration is at the top of the stack, followed by the
        -:  502:        // items in reverse order.
    #####:  503:        pop(r1);
        -:  504:
    #####:  505:        r3.p = yr_notebook_alloc(
    #####:  506:            it_notebook, sizeof(YR_ITERATOR) + sizeof(uint64_t) * r1.i);
        -:  507:
    #####:  508:        if (r3.p == NULL)
        -:  509:        {
    #####:  510:          result = ERROR_INSUFFICIENT_MEMORY;
        -:  511:        }
        -:  512:        else
        -:  513:        {
    #####:  514:          r3.it->int_enum_it.count = r1.i;
    #####:  515:          r3.it->int_enum_it.next = 0;
    #####:  516:          r3.it->next = iter_int_enum_next;
        -:  517:
    #####:  518:          for (i = r1.i; i > 0; i--)
        -:  519:          {
    #####:  520:             pop(r2);
    #####:  521:             r3.it->int_enum_it.items[i - 1] = r2.i;
        -:  522:          }
        -:  523:
    #####:  524:          push(r3);
        -:  525:        }
        -:  526:
    #####:  527:        stop = (result != ERROR_SUCCESS);
    #####:  528:        break;
        -:  529:
    #####:  530:      case OP_ITER_NEXT:
        -:  531:        // Loads the iterator in r1, but leaves the iterator in the stack.
    #####:  532:        pop(r1);
    #####:  533:        push(r1);
        -:  534:        // The iterator's next function is responsible for pushing the next
        -:  535:        // item in the stack, and a boolean indicating if there are more items
        -:  536:        // to retrieve. The boolean will be at the top of the stack after
        -:  537:        // calling "next".
    #####:  538:        result = r1.it->next(r1.it, &stack);
    #####:  539:        stop = (result != ERROR_SUCCESS);
    #####:  540:        break;
        -:  541:
    #####:  542:      case OP_PUSH:
    #####:  543:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  544:        ip += sizeof(uint64_t);
    #####:  545:        push(r1);
    #####:  546:        break;
        -:  547:
    #####:  548:      case OP_POP:
    #####:  549:        pop(r1);
    #####:  550:        break;
        -:  551:
    #####:  552:      case OP_CLEAR_M:
    #####:  553:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  554:        ip += sizeof(uint64_t);
        -:  555:        #if YR_PARANOID_EXEC
    #####:  556:        ensure_within_mem(r1.i);
        -:  557:        #endif
    #####:  558:        mem[r1.i].i = 0;
    #####:  559:        break;
        -:  560:
    #####:  561:      case OP_ADD_M:
    #####:  562:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  563:        ip += sizeof(uint64_t);
        -:  564:        #if YR_PARANOID_EXEC
    #####:  565:        ensure_within_mem(r1.i);
        -:  566:        #endif
    #####:  567:        pop(r2);
    #####:  568:        if (!is_undef(r2))
    #####:  569:          mem[r1.i].i += r2.i;
    #####:  570:        break;
        -:  571:
    #####:  572:      case OP_INCR_M:
    #####:  573:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  574:        ip += sizeof(uint64_t);
        -:  575:        #if YR_PARANOID_EXEC
    #####:  576:        ensure_within_mem(r1.i);
        -:  577:        #endif
    #####:  578:        mem[r1.i].i++;
    #####:  579:        break;
        -:  580:
    #####:  581:      case OP_PUSH_M:
    #####:  582:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  583:        ip += sizeof(uint64_t);
        -:  584:        #if YR_PARANOID_EXEC
    #####:  585:        ensure_within_mem(r1.i);
        -:  586:        #endif
    #####:  587:        r1 = mem[r1.i];
    #####:  588:        push(r1);
    #####:  589:        break;
        -:  590:
    #####:  591:      case OP_POP_M:
    #####:  592:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  593:        ip += sizeof(uint64_t);
        -:  594:        #if YR_PARANOID_EXEC
    #####:  595:        ensure_within_mem(r1.i);
        -:  596:        #endif
    #####:  597:        pop(r2);
    #####:  598:        mem[r1.i] = r2;
    #####:  599:        break;
        -:  600:
    #####:  601:      case OP_SET_M:
    #####:  602:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  603:        ip += sizeof(uint64_t);
        -:  604:        #if YR_PARANOID_EXEC
    #####:  605:        ensure_within_mem(r1.i);
        -:  606:        #endif
    #####:  607:        pop(r2);
    #####:  608:        push(r2);
    #####:  609:        if (!is_undef(r2))
    #####:  610:          mem[r1.i] = r2;
    #####:  611:        break;
        -:  612:
    #####:  613:      case OP_SWAPUNDEF:
    #####:  614:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  615:        ip += sizeof(uint64_t);
        -:  616:        #if YR_PARANOID_EXEC
    #####:  617:        ensure_within_mem(r1.i);
        -:  618:        #endif
    #####:  619:        pop(r2);
        -:  620:
    #####:  621:        if (is_undef(r2))
        -:  622:        {
    #####:  623:          r1 = mem[r1.i];
    #####:  624:          push(r1);
        -:  625:        }
        -:  626:        else
        -:  627:        {
    #####:  628:          push(r2);
        -:  629:        }
    #####:  630:        break;
        -:  631:
    #####:  632:      case OP_JNUNDEF:
    #####:  633:        pop(r1);
    #####:  634:        push(r1);
    #####:  635:        ip = jmp_if(!is_undef(r1), ip);
    #####:  636:        break;
        -:  637:
    #####:  638:      case OP_JUNDEF_P:
    #####:  639:        pop(r1);
    #####:  640:        ip = jmp_if(is_undef(r1), ip);
    #####:  641:        break;
        -:  642:
    #####:  643:      case OP_JL_P:
    #####:  644:        pop(r2);
    #####:  645:        pop(r1);
    #####:  646:        ip = jmp_if(r1.i < r2.i, ip);
    #####:  647:        break;
        -:  648:
    #####:  649:      case OP_JLE_P:
    #####:  650:        pop(r2);
    #####:  651:        pop(r1);
    #####:  652:        ip = jmp_if(r1.i <= r2.i, ip);
    #####:  653:        break;
        -:  654:
    #####:  655:      case OP_JTRUE:
    #####:  656:        pop(r1);
    #####:  657:        push(r1);
    #####:  658:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  659:        break;
        -:  660:
    #####:  661:      case OP_JTRUE_P:
    #####:  662:        pop(r1);
    #####:  663:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  664:        break;
        -:  665:
    #####:  666:      case OP_JFALSE:
    #####:  667:        pop(r1);
    #####:  668:        push(r1);
    #####:  669:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  670:        break;
        -:  671:
    #####:  672:      case OP_JFALSE_P:
    #####:  673:        pop(r1);
    #####:  674:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  675:        break;
        -:  676:
    #####:  677:      case OP_JZ:
    #####:  678:        pop(r1);
    #####:  679:        push(r1);
    #####:  680:        ip = jmp_if(r1.i == 0, ip);
    #####:  681:        break;
        -:  682:
    #####:  683:      case OP_JZ_P:
    #####:  684:        pop(r1);
    #####:  685:        ip = jmp_if(r1.i == 0, ip);
    #####:  686:        break;
        -:  687:
    #####:  688:      case OP_AND:
    #####:  689:        pop(r2);
    #####:  690:        pop(r1);
        -:  691:
    #####:  692:        if (is_undef(r1) || is_undef(r2))
    #####:  693:          r1.i = 0;
        -:  694:        else
    #####:  695:          r1.i = r1.i && r2.i;
        -:  696:
    #####:  697:        push(r1);
    #####:  698:        break;
        -:  699:
    #####:  700:      case OP_OR:
    #####:  701:        pop(r2);
    #####:  702:        pop(r1);
        -:  703:
    #####:  704:        if (is_undef(r1))
        -:  705:        {
    #####:  706:          push(r2);
        -:  707:        }
    #####:  708:        else if (is_undef(r2))
        -:  709:        {
    #####:  710:          push(r1);
        -:  711:        }
        -:  712:        else
        -:  713:        {
    #####:  714:          r1.i = r1.i || r2.i;
    #####:  715:          push(r1);
        -:  716:        }
    #####:  717:        break;
        -:  718:
    #####:  719:      case OP_NOT:
    #####:  720:        pop(r1);
        -:  721:
    #####:  722:        if (is_undef(r1))
    #####:  723:          r1.i = YR_UNDEFINED;
        -:  724:        else
    #####:  725:          r1.i = !r1.i;
        -:  726:
    #####:  727:        push(r1);
    #####:  728:        break;
        -:  729:
    #####:  730:      case OP_MOD:
    #####:  731:        pop(r2);
    #####:  732:        pop(r1);
    #####:  733:        ensure_defined(r2);
    #####:  734:        ensure_defined(r1);
    #####:  735:        if (r2.i != 0)
    #####:  736:          r1.i = r1.i % r2.i;
        -:  737:        else
    #####:  738:          r1.i = YR_UNDEFINED;
    #####:  739:        push(r1);
    #####:  740:        break;
        -:  741:
    #####:  742:      case OP_SHR:
    #####:  743:        pop(r2);
    #####:  744:        pop(r1);
    #####:  745:        ensure_defined(r2);
    #####:  746:        ensure_defined(r1);
    #####:  747:        if (r2.i < 0)
    #####:  748:          r1.i = YR_UNDEFINED;
    #####:  749:        else if (r2.i < 64)
    #####:  750:          r1.i = r1.i >> r2.i;
        -:  751:        else
    #####:  752:          r1.i = 0;
    #####:  753:        push(r1);
    #####:  754:        break;
        -:  755:
    #####:  756:      case OP_SHL:
    #####:  757:        pop(r2);
    #####:  758:        pop(r1);
    #####:  759:        ensure_defined(r2);
    #####:  760:        ensure_defined(r1);
    #####:  761:        if (r2.i < 0)
    #####:  762:          r1.i = YR_UNDEFINED;
    #####:  763:        else if (r2.i < 64)
    #####:  764:          r1.i = r1.i << r2.i;
        -:  765:        else
    #####:  766:          r1.i = 0;
    #####:  767:        push(r1);
    #####:  768:        break;
        -:  769:
    #####:  770:      case OP_BITWISE_NOT:
    #####:  771:        pop(r1);
    #####:  772:        ensure_defined(r1);
    #####:  773:        r1.i = ~r1.i;
    #####:  774:        push(r1);
    #####:  775:        break;
        -:  776:
    #####:  777:      case OP_BITWISE_AND:
    #####:  778:        pop(r2);
    #####:  779:        pop(r1);
    #####:  780:        ensure_defined(r2);
    #####:  781:        ensure_defined(r1);
    #####:  782:        r1.i = r1.i & r2.i;
    #####:  783:        push(r1);
    #####:  784:        break;
        -:  785:
    #####:  786:      case OP_BITWISE_OR:
    #####:  787:        pop(r2);
    #####:  788:        pop(r1);
    #####:  789:        ensure_defined(r2);
    #####:  790:        ensure_defined(r1);
    #####:  791:        r1.i = r1.i | r2.i;
    #####:  792:        push(r1);
    #####:  793:        break;
        -:  794:
    #####:  795:      case OP_BITWISE_XOR:
    #####:  796:        pop(r2);
    #####:  797:        pop(r1);
    #####:  798:        ensure_defined(r2);
    #####:  799:        ensure_defined(r1);
    #####:  800:        r1.i = r1.i ^ r2.i;
    #####:  801:        push(r1);
    #####:  802:        break;
        -:  803:
    #####:  804:      case OP_PUSH_RULE:
    #####:  805:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####:  806:        ip += sizeof(uint64_t);
        -:  807:
    #####:  808:        rule = &context->rules->rules_list_head[r1.i];
        -:  809:
    #####:  810:        if (RULE_IS_DISABLED(rule))
        -:  811:        {
    #####:  812:          r2.i = YR_UNDEFINED;
        -:  813:        }
        -:  814:        else
        -:  815:        {
    #####:  816:          if yr_bitmask_is_set(context->rule_matches_flags, r1.i)
    #####:  817:            r2.i = 1;
        -:  818:          else
    #####:  819:            r2.i = 0;
        -:  820:        }
        -:  821:
    #####:  822:        push(r2);
    #####:  823:        break;
        -:  824:
    #####:  825:      case OP_INIT_RULE:
        -:  826:        // After the opcode there's an int32_t corresponding to the jump's
        -:  827:        // offset and an uint32_t corresponding to the rule's index.
    #####:  828:        current_rule_idx = *(uint32_t*)(ip + sizeof(int32_t));
        -:  829:
    #####:  830:        assert(current_rule_idx < context->rules->num_rules);
        -:  831:
    #####:  832:        current_rule = &context->rules->rules_list_head[current_rule_idx];
        -:  833:
        -:  834:        // If the rule is disabled let's skip its code.
    #####:  835:        ip = jmp_if(RULE_IS_DISABLED(current_rule), ip);
        -:  836:
        -:  837:        // Skip the bytes corresponding to the rule's index, but only if not
        -:  838:        // taking the jump.
    #####:  839:        if (!RULE_IS_DISABLED(current_rule))
    #####:  840:          ip += sizeof(uint32_t);
        -:  841:
    #####:  842:        break;
        -:  843:
    #####:  844:      case OP_MATCH_RULE:
    #####:  845:        pop(r1);
        -:  846:
    #####:  847:        memcpy(&r2.i, ip, sizeof(uint64_t));
    #####:  848:        ip += sizeof(uint64_t);
        -:  849:
    #####:  850:        rule = &context->rules->rules_list_head[r2.i];
        -:  851:
        -:  852:        #if YR_PARANOID_EXEC
    #####:  853:        ensure_within_rules_arena(rule);
        -:  854:        #endif
        -:  855:
    #####:  856:        if (!is_undef(r1) && r1.i)
    #####:  857:          yr_bitmask_set(context->rule_matches_flags, r2.i);
    #####:  858:        else if (RULE_IS_GLOBAL(rule))
    #####:  859:          yr_bitmask_set(context->ns_unsatisfied_flags, rule->ns->idx);
        -:  860:
        -:  861:        #ifdef YR_PROFILING_ENABLED
        -:  862:        elapsed_time = yr_stopwatch_elapsed_ns(&context->stopwatch);
        -:  863:        context->profiling_info[r2.i].exec_time += (elapsed_time - start_time);
        -:  864:        start_time = elapsed_time;
        -:  865:        #endif
        -:  866:
    #####:  867:        assert(stack.sp == 0); // at this point the stack should be empty.
    #####:  868:        break;
        -:  869:
    #####:  870:      case OP_OBJ_LOAD:
    #####:  871:        identifier = *(char**)(ip);
    #####:  872:        ip += sizeof(uint64_t);
        -:  873:
        -:  874:        #if YR_PARANOID_EXEC
    #####:  875:        ensure_within_rules_arena(identifier);
        -:  876:        #endif
        -:  877:
    #####:  878:        r1.o = (YR_OBJECT*) yr_hash_table_lookup(
        -:  879:            context->objects_table,
        -:  880:            identifier,
        -:  881:            NULL);
        -:  882:
    #####:  883:        assert(r1.o != NULL);
    #####:  884:        push(r1);
    #####:  885:        break;
        -:  886:
    #####:  887:      case OP_OBJ_FIELD:
    #####:  888:        identifier = *(char**)(ip);
    #####:  889:        ip += sizeof(uint64_t);
        -:  890:
        -:  891:        #if YR_PARANOID_EXEC
    #####:  892:        ensure_within_rules_arena(identifier);
        -:  893:        #endif
        -:  894:
    #####:  895:        pop(r1);
    #####:  896:        ensure_defined(r1);
        -:  897:
    #####:  898:        r1.o = yr_object_lookup_field(r1.o, identifier);
        -:  899:
    #####:  900:        if (r1.o == NULL)
        -:  901:        {
    #####:  902:          result = ERROR_INVALID_FIELD_NAME;
    #####:  903:          stop = true;
    #####:  904:          break;
        -:  905:        }
        -:  906:
    #####:  907:        push(r1);
    #####:  908:        break;
        -:  909:
    #####:  910:      case OP_OBJ_VALUE:
    #####:  911:        pop(r1);
    #####:  912:        ensure_defined(r1);
        -:  913:
        -:  914:        #if YR_PARANOID_EXEC
    #####:  915:        check_object_canary(r1.o);
        -:  916:        #endif
        -:  917:
    #####:  918:        switch(r1.o->type)
        -:  919:        {
    #####:  920:          case OBJECT_TYPE_INTEGER:
    #####:  921:            r1.i = r1.o->value.i;
    #####:  922:            break;
        -:  923:
    #####:  924:          case OBJECT_TYPE_FLOAT:
    #####:  925:            if (isnan(r1.o->value.d))
    #####:  926:              r1.i = YR_UNDEFINED;
        -:  927:            else
    #####:  928:              r1.d = r1.o->value.d;
    #####:  929:            break;
        -:  930:
    #####:  931:          case OBJECT_TYPE_STRING:
    #####:  932:            if (r1.o->value.ss == NULL)
    #####:  933:              r1.i = YR_UNDEFINED;
        -:  934:            else
    #####:  935:              r1.ss = r1.o->value.ss;
    #####:  936:            break;
        -:  937:
    #####:  938:          default:
    #####:  939:            assert(false);
        -:  940:        }
        -:  941:
    #####:  942:        push(r1);
    #####:  943:        break;
        -:  944:
    #####:  945:      case OP_INDEX_ARRAY:
    #####:  946:        pop(r1);  // index
    #####:  947:        pop(r2);  // array
        -:  948:
    #####:  949:        ensure_defined(r1);
    #####:  950:        ensure_defined(r2);
        -:  951:
    #####:  952:        assert(r2.o->type == OBJECT_TYPE_ARRAY);
        -:  953:
        -:  954:        #if YR_PARANOID_EXEC
    #####:  955:        check_object_canary(r2.o);
        -:  956:        #endif
        -:  957:
    #####:  958:        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
        -:  959:
    #####:  960:        if (r1.o == NULL)
    #####:  961:          r1.i = YR_UNDEFINED;
        -:  962:
    #####:  963:        push(r1);
    #####:  964:        break;
        -:  965:
    #####:  966:      case OP_LOOKUP_DICT:
    #####:  967:        pop(r1);  // key
    #####:  968:        pop(r2);  // dictionary
        -:  969:
    #####:  970:        ensure_defined(r1);
    #####:  971:        ensure_defined(r2);
        -:  972:
    #####:  973:        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
        -:  974:
        -:  975:        #if YR_PARANOID_EXEC
    #####:  976:        check_object_canary(r2.o);
        -:  977:        #endif
        -:  978:
    #####:  979:        r1.o = yr_object_dict_get_item(
    #####:  980:            r2.o, 0, r1.ss->c_string);
        -:  981:
    #####:  982:        if (r1.o == NULL)
    #####:  983:          r1.i = YR_UNDEFINED;
        -:  984:
    #####:  985:        push(r1);
    #####:  986:        break;
        -:  987:
    #####:  988:      case OP_CALL:
    #####:  989:        args_fmt = *(char**)(ip);
    #####:  990:        ip += sizeof(uint64_t);
        -:  991:
    #####:  992:        i = (int) strlen(args_fmt);
    #####:  993:        count = 0;
        -:  994:
        -:  995:        #if YR_PARANOID_EXEC
    #####:  996:        if (i > YR_MAX_FUNCTION_ARGS)
        -:  997:        {
    #####:  998:          stop = true;
    #####:  999:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1000:          break;
        -: 1001:        }
        -: 1002:        #endif
        -: 1003:
        -: 1004:        // pop arguments from stack and copy them to args array
        -: 1005:
    #####: 1006:        while (i > 0)
        -: 1007:        {
    #####: 1008:          pop(r1);
        -: 1009:
    #####: 1010:          if (is_undef(r1))  // count the number of undefined args
    #####: 1011:            count++;
        -: 1012:
    #####: 1013:          args[i - 1] = r1;
    #####: 1014:          i--;
        -: 1015:        }
        -: 1016:
    #####: 1017:        pop(r2);
    #####: 1018:        ensure_defined(r2);
        -: 1019:
        -: 1020:        #if YR_PARANOID_EXEC
    #####: 1021:        check_object_canary(r2.o);
        -: 1022:        #endif
        -: 1023:
    #####: 1024:        if (count > 0)
        -: 1025:        {
        -: 1026:          // If there are undefined args, result for function call
        -: 1027:          // is undefined as well.
        -: 1028:
    #####: 1029:          r1.i = YR_UNDEFINED;
    #####: 1030:          push(r1);
    #####: 1031:          break;
        -: 1032:        }
        -: 1033:
    #####: 1034:        function = object_as_function(r2.o);
    #####: 1035:        result = ERROR_INTERNAL_FATAL_ERROR;
        -: 1036:
    #####: 1037:        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -: 1038:        {
    #####: 1039:          if (function->prototypes[i].arguments_fmt == NULL)
    #####: 1040:            break;
        -: 1041:
    #####: 1042:          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
        -: 1043:          {
    #####: 1044:            result = function->prototypes[i].code(args, context, function);
    #####: 1045:            break;
        -: 1046:          }
        -: 1047:        }
        -: 1048:
        -: 1049:        // If i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching
        -: 1050:        // prototype was found, but this shouldn't happen.
    #####: 1051:        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);
        -: 1052:
        -: 1053:        // Make a copy of the returned object and push the copy into the stack,
        -: 1054:        // function->return_obj can't be pushed because it can change in
        -: 1055:        // subsequent calls to the same function.
    #####: 1056:        if (result == ERROR_SUCCESS)
    #####: 1057:          result = yr_object_copy(function->return_obj, &r1.o);
        -: 1058:
        -: 1059:        // A pointer to the copied object is stored in a arena in order to
        -: 1060:        // free the object before exiting yr_execute_code, obj_count tracks
        -: 1061:        // the number of objects written.
    #####: 1062:        if (result == ERROR_SUCCESS)
        -: 1063:        {
    #####: 1064:          result = yr_arena_write_data(
        -: 1065:              obj_arena, 0, &r1.o, sizeof(r1.o), NULL);
    #####: 1066:          obj_count++;
        -: 1067:        }
        -: 1068:
    #####: 1069:        stop = (result != ERROR_SUCCESS);
    #####: 1070:        push(r1);
    #####: 1071:        break;
        -: 1072:
    #####: 1073:      case OP_FOUND:
    #####: 1074:        pop(r1);
    #####: 1075:        r2.i = context->matches[r1.s->idx].tail != NULL ? 1 : 0;
    #####: 1076:        push(r2);
    #####: 1077:        break;
        -: 1078:
    #####: 1079:      case OP_FOUND_AT:
    #####: 1080:        pop(r2);
    #####: 1081:        pop(r1);
        -: 1082:
    #####: 1083:        if (is_undef(r1))
        -: 1084:        {
    #####: 1085:          r1.i = 0;
    #####: 1086:          push(r1);
    #####: 1087:          break;
        -: 1088:        }
        -: 1089:
        -: 1090:        #if YR_PARANOID_EXEC
    #####: 1091:        ensure_within_rules_arena(r2.p);
        -: 1092:        #endif
        -: 1093:
    #####: 1094:        match = context->matches[r2.s->idx].head;
    #####: 1095:        r3.i = false;
        -: 1096:
    #####: 1097:        while (match != NULL)
        -: 1098:        {
    #####: 1099:          if (r1.i == match->base + match->offset)
        -: 1100:          {
    #####: 1101:            r3.i = true;
    #####: 1102:            break;
        -: 1103:          }
        -: 1104:
    #####: 1105:          if (r1.i < match->base + match->offset)
    #####: 1106:            break;
        -: 1107:
    #####: 1108:          match = match->next;
        -: 1109:        }
        -: 1110:
    #####: 1111:        push(r3);
    #####: 1112:        break;
        -: 1113:
    #####: 1114:      case OP_FOUND_IN:
    #####: 1115:        pop(r3);
    #####: 1116:        pop(r2);
    #####: 1117:        pop(r1);
        -: 1118:
    #####: 1119:        ensure_defined(r1);
    #####: 1120:        ensure_defined(r2);
        -: 1121:
        -: 1122:        #if YR_PARANOID_EXEC
    #####: 1123:        ensure_within_rules_arena(r3.p);
        -: 1124:        #endif
        -: 1125:
    #####: 1126:        match = context->matches[r3.s->idx].head;
    #####: 1127:        r4.i = false;
        -: 1128:
    #####: 1129:        while (match != NULL && !r4.i)
        -: 1130:        {
    #####: 1131:          if (match->base + match->offset >= r1.i &&
    #####: 1132:              match->base + match->offset <= r2.i)
        -: 1133:          {
    #####: 1134:            r4.i = true;
        -: 1135:          }
        -: 1136:
    #####: 1137:          if (match->base + match->offset > r2.i)
    #####: 1138:            break;
        -: 1139:
    #####: 1140:          match = match->next;
        -: 1141:        }
        -: 1142:
    #####: 1143:        push(r4);
    #####: 1144:        break;
        -: 1145:
    #####: 1146:      case OP_COUNT:
    #####: 1147:        pop(r1);
        -: 1148:
        -: 1149:        #if YR_PARANOID_EXEC
    #####: 1150:        ensure_within_rules_arena(r1.p);
        -: 1151:        #endif
        -: 1152:
    #####: 1153:        r2.i = context->matches[r1.s->idx].count;
    #####: 1154:        push(r2);
    #####: 1155:        break;
        -: 1156:
    #####: 1157:      case OP_OFFSET:
    #####: 1158:        pop(r2);
    #####: 1159:        pop(r1);
        -: 1160:
    #####: 1161:        ensure_defined(r1);
        -: 1162:
        -: 1163:        #if YR_PARANOID_EXEC
    #####: 1164:        ensure_within_rules_arena(r2.p);
        -: 1165:        #endif
        -: 1166:
    #####: 1167:        match = context->matches[r2.s->idx].head;
        -: 1168:
    #####: 1169:        i = 1;
    #####: 1170:        r3.i = YR_UNDEFINED;
        -: 1171:
    #####: 1172:        while (match != NULL && r3.i == YR_UNDEFINED)
        -: 1173:        {
    #####: 1174:          if (r1.i == i)
    #####: 1175:            r3.i = match->base + match->offset;
        -: 1176:
    #####: 1177:          i++;
    #####: 1178:          match = match->next;
        -: 1179:        }
        -: 1180:
    #####: 1181:        push(r3);
    #####: 1182:        break;
        -: 1183:
    #####: 1184:      case OP_LENGTH:
    #####: 1185:        pop(r2);
    #####: 1186:        pop(r1);
        -: 1187:
    #####: 1188:        ensure_defined(r1);
        -: 1189:
        -: 1190:        #if YR_PARANOID_EXEC
    #####: 1191:        ensure_within_rules_arena(r2.p);
        -: 1192:        #endif
        -: 1193:
    #####: 1194:        match = context->matches[r2.s->idx].head;
        -: 1195:
    #####: 1196:        i = 1;
    #####: 1197:        r3.i = YR_UNDEFINED;
        -: 1198:
    #####: 1199:        while (match != NULL && r3.i == YR_UNDEFINED)
        -: 1200:        {
    #####: 1201:          if (r1.i == i)
    #####: 1202:            r3.i = match->match_length;
        -: 1203:
    #####: 1204:          i++;
    #####: 1205:          match = match->next;
        -: 1206:        }
        -: 1207:
    #####: 1208:        push(r3);
    #####: 1209:        break;
        -: 1210:
    #####: 1211:      case OP_OF:
    #####: 1212:        found = 0;
    #####: 1213:        count = 0;
    #####: 1214:        pop(r1);
        -: 1215:
    #####: 1216:        while (!is_undef(r1))
        -: 1217:        {
    #####: 1218:          if (context->matches[r1.s->idx].tail != NULL)
        -: 1219:          {
    #####: 1220:            found++;
        -: 1221:          }
    #####: 1222:          count++;
    #####: 1223:          pop(r1);
        -: 1224:        }
        -: 1225:
    #####: 1226:        pop(r2);
        -: 1227:
    #####: 1228:        if (is_undef(r2))
    #####: 1229:          r1.i = found >= count ? 1 : 0;
        -: 1230:        else
    #####: 1231:          r1.i = found >= r2.i ? 1 : 0;
        -: 1232:
    #####: 1233:        push(r1);
    #####: 1234:        break;
        -: 1235:
    #####: 1236:      case OP_FILESIZE:
    #####: 1237:        r1.i = context->file_size;
    #####: 1238:        push(r1);
    #####: 1239:        break;
        -: 1240:
    #####: 1241:      case OP_ENTRYPOINT:
    #####: 1242:        r1.i = context->entry_point;
    #####: 1243:        push(r1);
    #####: 1244:        break;
        -: 1245:
    #####: 1246:      case OP_INT8:
    #####: 1247:        pop(r1);
    #####: 1248:        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1249:        push(r1);
    #####: 1250:        break;
        -: 1251:
    #####: 1252:      case OP_INT16:
    #####: 1253:        pop(r1);
    #####: 1254:        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1255:        push(r1);
    #####: 1256:        break;
        -: 1257:
    #####: 1258:      case OP_INT32:
    #####: 1259:        pop(r1);
    #####: 1260:        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1261:        push(r1);
    #####: 1262:        break;
        -: 1263:
    #####: 1264:      case OP_UINT8:
    #####: 1265:        pop(r1);
    #####: 1266:        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1267:        push(r1);
    #####: 1268:        break;
        -: 1269:
    #####: 1270:      case OP_UINT16:
    #####: 1271:        pop(r1);
    #####: 1272:        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1273:        push(r1);
    #####: 1274:        break;
        -: 1275:
    #####: 1276:      case OP_UINT32:
    #####: 1277:        pop(r1);
    #####: 1278:        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
    #####: 1279:        push(r1);
    #####: 1280:        break;
        -: 1281:
    #####: 1282:      case OP_INT8BE:
    #####: 1283:        pop(r1);
    #####: 1284:        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1285:        push(r1);
    #####: 1286:        break;
        -: 1287:
    #####: 1288:      case OP_INT16BE:
    #####: 1289:        pop(r1);
    #####: 1290:        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1291:        push(r1);
    #####: 1292:        break;
        -: 1293:
    #####: 1294:      case OP_INT32BE:
    #####: 1295:        pop(r1);
    #####: 1296:        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1297:        push(r1);
    #####: 1298:        break;
        -: 1299:
    #####: 1300:      case OP_UINT8BE:
    #####: 1301:        pop(r1);
    #####: 1302:        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1303:        push(r1);
    #####: 1304:        break;
        -: 1305:
    #####: 1306:      case OP_UINT16BE:
    #####: 1307:        pop(r1);
    #####: 1308:        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1309:        push(r1);
    #####: 1310:        break;
        -: 1311:
    #####: 1312:      case OP_UINT32BE:
    #####: 1313:        pop(r1);
    #####: 1314:        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
    #####: 1315:        push(r1);
    #####: 1316:        break;
        -: 1317:
    #####: 1318:      case OP_CONTAINS:
    #####: 1319:        pop(r2);
    #####: 1320:        pop(r1);
        -: 1321:
    #####: 1322:        if (is_undef(r1) || is_undef(r2))
        -: 1323:        {
    #####: 1324:          r1.i = false;
        -: 1325:        }
        -: 1326:        else
        -: 1327:        {
    #####: 1328:          r1.i = memmem(r1.ss->c_string, r1.ss->length,
    #####: 1329:                        r2.ss->c_string, r2.ss->length) != NULL;
        -: 1330:        }
        -: 1331:
    #####: 1332:        push(r1);
    #####: 1333:        break;
        -: 1334:
    #####: 1335:      case OP_IMPORT:
    #####: 1336:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####: 1337:        ip += sizeof(uint64_t);
        -: 1338:
        -: 1339:        #if YR_PARANOID_EXEC
    #####: 1340:        ensure_within_rules_arena(r1.p);
        -: 1341:        #endif
        -: 1342:
    #####: 1343:        result = yr_modules_load((char*) r1.p, context);
        -: 1344:
    #####: 1345:        if (result != ERROR_SUCCESS)
    #####: 1346:          stop = true;
        -: 1347:
    #####: 1348:        break;
        -: 1349:
    #####: 1350:      case OP_MATCHES:
    #####: 1351:        pop(r2);
    #####: 1352:        pop(r1);
        -: 1353:
    #####: 1354:        if (is_undef(r1) || is_undef(r2) || r1.ss->length == 0)
        -: 1355:        {
    #####: 1356:          r1.i = false;
    #####: 1357:          push(r1);
    #####: 1358:          break;
        -: 1359:        }
        -: 1360:
    #####: 1361:        result = yr_re_exec(
        -: 1362:            context,
    #####: 1363:            (uint8_t*) r2.re->code,
    #####: 1364:            (uint8_t*) r1.ss->c_string,
    #####: 1365:            r1.ss->length,
        -: 1366:            0,
    #####: 1367:            r2.re->flags | RE_FLAGS_SCAN,
        -: 1368:            NULL,
        -: 1369:            NULL,
        -: 1370:            &found);
        -: 1371:
    #####: 1372:        if (result != ERROR_SUCCESS)
    #####: 1373:          stop = true;
        -: 1374:
    #####: 1375:        r1.i = found >= 0;
    #####: 1376:        push(r1);
    #####: 1377:        break;
        -: 1378:
    #####: 1379:      case OP_INT_TO_DBL:
    #####: 1380:        memcpy(&r1.i, ip, sizeof(uint64_t));
    #####: 1381:        ip += sizeof(uint64_t);
        -: 1382:
        -: 1383:        #if YR_PARANOID_EXEC
    #####: 1384:        if (r1.i > stack.sp || stack.sp - r1.i >= stack.capacity)
        -: 1385:        {
    #####: 1386:          stop = true;
    #####: 1387:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1388:          break;
        -: 1389:        }
        -: 1390:        #endif
        -: 1391:
    #####: 1392:        r2 = stack.items[stack.sp - r1.i];
        -: 1393:
    #####: 1394:        if (is_undef(r2))
    #####: 1395:          stack.items[stack.sp - r1.i].i = YR_UNDEFINED;
        -: 1396:        else
    #####: 1397:          stack.items[stack.sp - r1.i].d = (double) r2.i;
    #####: 1398:        break;
        -: 1399:
    #####: 1400:      case OP_STR_TO_BOOL:
    #####: 1401:        pop(r1);
    #####: 1402:        ensure_defined(r1);
    #####: 1403:        r1.i = r1.ss->length > 0;
    #####: 1404:        push(r1);
    #####: 1405:        break;
        -: 1406:
    #####: 1407:      case OP_INT_EQ:
    #####: 1408:        pop(r2);
    #####: 1409:        pop(r1);
    #####: 1410:        if (is_undef(r1) || is_undef(r2))
    #####: 1411:          r1.i = false;
        -: 1412:        else
    #####: 1413:          r1.i = r1.i == r2.i;
    #####: 1414:        push(r1);
    #####: 1415:        break;
        -: 1416:
    #####: 1417:      case OP_INT_NEQ:
    #####: 1418:        pop(r2);
    #####: 1419:        pop(r1);
    #####: 1420:        if (is_undef(r1) || is_undef(r2))
    #####: 1421:          r1.i = false;
        -: 1422:        else
    #####: 1423:          r1.i = r1.i != r2.i;
    #####: 1424:        push(r1);
    #####: 1425:        break;
        -: 1426:
    #####: 1427:      case OP_INT_LT:
    #####: 1428:        pop(r2);
    #####: 1429:        pop(r1);
    #####: 1430:        if (is_undef(r1) || is_undef(r2))
    #####: 1431:          r1.i = false;
        -: 1432:        else
    #####: 1433:          r1.i = r1.i < r2.i;
    #####: 1434:        push(r1);
    #####: 1435:        break;
        -: 1436:
    #####: 1437:      case OP_INT_GT:
    #####: 1438:        pop(r2);
    #####: 1439:        pop(r1);
    #####: 1440:        if (is_undef(r1) || is_undef(r2))
    #####: 1441:          r1.i = false;
        -: 1442:        else
    #####: 1443:          r1.i = r1.i > r2.i;
    #####: 1444:        push(r1);
    #####: 1445:        break;
        -: 1446:
    #####: 1447:      case OP_INT_LE:
    #####: 1448:        pop(r2);
    #####: 1449:        pop(r1);
    #####: 1450:        if (is_undef(r1) || is_undef(r2))
    #####: 1451:          r1.i = false;
        -: 1452:        else
    #####: 1453:          r1.i = r1.i <= r2.i;
    #####: 1454:        push(r1);
    #####: 1455:        break;
        -: 1456:
    #####: 1457:      case OP_INT_GE:
    #####: 1458:        pop(r2);
    #####: 1459:        pop(r1);
    #####: 1460:        if (is_undef(r1) || is_undef(r2))
    #####: 1461:          r1.i = false;
        -: 1462:        else
    #####: 1463:          r1.i = r1.i >= r2.i;
    #####: 1464:        push(r1);
    #####: 1465:        break;
        -: 1466:
    #####: 1467:      case OP_INT_ADD:
    #####: 1468:        pop(r2);
    #####: 1469:        pop(r1);
    #####: 1470:        ensure_defined(r2);
    #####: 1471:        ensure_defined(r1);
    #####: 1472:        r1.i = r1.i + r2.i;
    #####: 1473:        push(r1);
    #####: 1474:        break;
        -: 1475:
    #####: 1476:      case OP_INT_SUB:
    #####: 1477:        pop(r2);
    #####: 1478:        pop(r1);
    #####: 1479:        ensure_defined(r2);
    #####: 1480:        ensure_defined(r1);
    #####: 1481:        r1.i = r1.i - r2.i;
    #####: 1482:        push(r1);
    #####: 1483:        break;
        -: 1484:
    #####: 1485:      case OP_INT_MUL:
    #####: 1486:        pop(r2);
    #####: 1487:        pop(r1);
    #####: 1488:        ensure_defined(r2);
    #####: 1489:        ensure_defined(r1);
    #####: 1490:        r1.i = r1.i * r2.i;
    #####: 1491:        push(r1);
    #####: 1492:        break;
        -: 1493:
    #####: 1494:      case OP_INT_DIV:
    #####: 1495:        pop(r2);
    #####: 1496:        pop(r1);
    #####: 1497:        ensure_defined(r2);
    #####: 1498:        ensure_defined(r1);
    #####: 1499:        if (r2.i != 0)
    #####: 1500:          r1.i = r1.i / r2.i;
        -: 1501:        else
    #####: 1502:          r1.i = YR_UNDEFINED;
    #####: 1503:        push(r1);
    #####: 1504:        break;
        -: 1505:
    #####: 1506:      case OP_INT_MINUS:
    #####: 1507:        pop(r1);
    #####: 1508:        ensure_defined(r1);
    #####: 1509:        r1.i = -r1.i;
    #####: 1510:        push(r1);
    #####: 1511:        break;
        -: 1512:
    #####: 1513:      case OP_DBL_LT:
    #####: 1514:        pop(r2);
    #####: 1515:        pop(r1);
    #####: 1516:        if (is_undef(r1) || is_undef(r2))
    #####: 1517:          r1.i = false;
        -: 1518:        else
    #####: 1519:          r1.i = r1.d < r2.d;
    #####: 1520:        push(r1);
    #####: 1521:        break;
        -: 1522:
    #####: 1523:      case OP_DBL_GT:
    #####: 1524:        pop(r2);
    #####: 1525:        pop(r1);
    #####: 1526:        if (is_undef(r1) || is_undef(r2))
    #####: 1527:          r1.i = false;
        -: 1528:        else
    #####: 1529:          r1.i = r1.d > r2.d;
    #####: 1530:        push(r1);
    #####: 1531:        break;
        -: 1532:
    #####: 1533:      case OP_DBL_LE:
    #####: 1534:        pop(r2);
    #####: 1535:        pop(r1);
    #####: 1536:        if (is_undef(r1) || is_undef(r2))
    #####: 1537:          r1.i = false;
        -: 1538:        else
    #####: 1539:          r1.i = r1.d <= r2.d;
    #####: 1540:        push(r1);
    #####: 1541:        break;
        -: 1542:
    #####: 1543:      case OP_DBL_GE:
    #####: 1544:        pop(r2);
    #####: 1545:        pop(r1);
    #####: 1546:        if (is_undef(r1) || is_undef(r2))
    #####: 1547:          r1.i = false;
        -: 1548:        else
    #####: 1549:          r1.i = r1.d >= r2.d;
    #####: 1550:        push(r1);
    #####: 1551:        break;
        -: 1552:
    #####: 1553:      case OP_DBL_EQ:
    #####: 1554:        pop(r2);
    #####: 1555:        pop(r1);
    #####: 1556:        if (is_undef(r1) || is_undef(r2))
    #####: 1557:          r1.i = false;
        -: 1558:        else
    #####: 1559:          r1.i = fabs(r1.d - r2.d) < DBL_EPSILON;
    #####: 1560:        push(r1);
    #####: 1561:        break;
        -: 1562:
    #####: 1563:      case OP_DBL_NEQ:
    #####: 1564:        pop(r2);
    #####: 1565:        pop(r1);
    #####: 1566:        if (is_undef(r1) || is_undef(r2))
    #####: 1567:          r1.i = false;
        -: 1568:        else
    #####: 1569:          r1.i = fabs(r1.d - r2.d) >= DBL_EPSILON;
    #####: 1570:        push(r1);
    #####: 1571:        break;
        -: 1572:
    #####: 1573:      case OP_DBL_ADD:
    #####: 1574:        pop(r2);
    #####: 1575:        pop(r1);
    #####: 1576:        ensure_defined(r2);
    #####: 1577:        ensure_defined(r1);
    #####: 1578:        r1.d = r1.d + r2.d;
    #####: 1579:        push(r1);
    #####: 1580:        break;
        -: 1581:
    #####: 1582:      case OP_DBL_SUB:
    #####: 1583:        pop(r2);
    #####: 1584:        pop(r1);
    #####: 1585:        ensure_defined(r2);
    #####: 1586:        ensure_defined(r1);
    #####: 1587:        r1.d = r1.d - r2.d;
    #####: 1588:        push(r1);
    #####: 1589:        break;
        -: 1590:
    #####: 1591:      case OP_DBL_MUL:
    #####: 1592:        pop(r2);
    #####: 1593:        pop(r1);
    #####: 1594:        ensure_defined(r2);
    #####: 1595:        ensure_defined(r1);
    #####: 1596:        r1.d = r1.d * r2.d;
    #####: 1597:        push(r1);
    #####: 1598:        break;
        -: 1599:
    #####: 1600:      case OP_DBL_DIV:
    #####: 1601:        pop(r2);
    #####: 1602:        pop(r1);
    #####: 1603:        ensure_defined(r2);
    #####: 1604:        ensure_defined(r1);
    #####: 1605:        r1.d = r1.d / r2.d;
    #####: 1606:        push(r1);
    #####: 1607:        break;
        -: 1608:
    #####: 1609:      case OP_DBL_MINUS:
    #####: 1610:        pop(r1);
    #####: 1611:        ensure_defined(r1);
    #####: 1612:        r1.d = -r1.d;
    #####: 1613:        push(r1);
    #####: 1614:        break;
        -: 1615:
    #####: 1616:      case OP_STR_EQ:
        -: 1617:      case OP_STR_NEQ:
        -: 1618:      case OP_STR_LT:
        -: 1619:      case OP_STR_LE:
        -: 1620:      case OP_STR_GT:
        -: 1621:      case OP_STR_GE:
        -: 1622:
    #####: 1623:        pop(r2);
    #####: 1624:        pop(r1);
        -: 1625:
    #####: 1626:        if (is_undef(r1) || is_undef(r2))
        -: 1627:        {
    #####: 1628:          r1.i = false;
        -: 1629:        }
        -: 1630:        else
        -: 1631:        {
    #####: 1632:          switch(opcode)
        -: 1633:          {
    #####: 1634:            case OP_STR_EQ:
    #####: 1635:              r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
    #####: 1636:              break;
    #####: 1637:            case OP_STR_NEQ:
    #####: 1638:              r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
    #####: 1639:              break;
    #####: 1640:            case OP_STR_LT:
    #####: 1641:              r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
    #####: 1642:              break;
    #####: 1643:            case OP_STR_LE:
    #####: 1644:              r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
    #####: 1645:              break;
    #####: 1646:            case OP_STR_GT:
    #####: 1647:              r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
    #####: 1648:              break;
    #####: 1649:            case OP_STR_GE:
    #####: 1650:              r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
    #####: 1651:              break;
        -: 1652:          }
    #####: 1653:        }
        -: 1654:
    #####: 1655:        push(r1);
    #####: 1656:        break;
        -: 1657:
    #####: 1658:      default:
        -: 1659:        // Unknown instruction, this shouldn't happen.
    #####: 1660:        assert(false);
        -: 1661:    }
        -: 1662:
        -: 1663:    // Check for timeout every 100 instruction cycles. If timeout == 0 it means
        -: 1664:    // no timeout at all.
        -: 1665:
    #####: 1666:    if (context->timeout > 0L && ++cycle == 100)
        -: 1667:    {
    #####: 1668:      elapsed_time = yr_stopwatch_elapsed_ns(&context->stopwatch);
        -: 1669:
    #####: 1670:      if (elapsed_time > context->timeout)
        -: 1671:      {
        -: 1672:        #ifdef YR_PROFILING_ENABLED
        -: 1673:        context->profiling_info[current_rule_idx].exec_time += (
        -: 1674:            elapsed_time - start_time);
        -: 1675:        #endif
    #####: 1676:        result = ERROR_SCAN_TIMEOUT;
    #####: 1677:        stop = true;
        -: 1678:      }
        -: 1679:
    #####: 1680:      cycle = 0;
        -: 1681:    }
        -: 1682:  }
        -: 1683:
    #####: 1684:  obj_ptr = yr_arena_get_ptr(obj_arena, 0, 0);
        -: 1685:
    #####: 1686:  for (int i = 0; i < obj_count; i++)
    #####: 1687:    yr_object_destroy(obj_ptr[i]);
        -: 1688:
    #####: 1689:  yr_arena_release(obj_arena);
    #####: 1690:  yr_notebook_destroy(it_notebook);
    #####: 1691:  yr_modules_unload_all(context);
    #####: 1692:  yr_free(stack.items);
        -: 1693:
    #####: 1694:  return result;
        -: 1695:}
