        -:    0:Source:re_lexer.c
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:10
        -:    1:#line 2 "re_lexer.c"
        -:    2:
        -:    3:#line 4 "re_lexer.c"
        -:    4:
        -:    5:#define  YY_INT_ALIGNED short int
        -:    6:
        -:    7:/* A lexical scanner generated by flex */
        -:    8:
        -:    9:#define FLEX_SCANNER
        -:   10:#define YY_FLEX_MAJOR_VERSION 2
        -:   11:#define YY_FLEX_MINOR_VERSION 6
        -:   12:#define YY_FLEX_SUBMINOR_VERSION 4
        -:   13:#if YY_FLEX_SUBMINOR_VERSION > 0
        -:   14:#define FLEX_BETA
        -:   15:#endif
        -:   16:
        -:   17:#ifdef yy_create_buffer
        -:   18:#define re_yy_create_buffer_ALREADY_DEFINED
        -:   19:#else
        -:   20:#define yy_create_buffer re_yy_create_buffer
        -:   21:#endif
        -:   22:
        -:   23:#ifdef yy_delete_buffer
        -:   24:#define re_yy_delete_buffer_ALREADY_DEFINED
        -:   25:#else
        -:   26:#define yy_delete_buffer re_yy_delete_buffer
        -:   27:#endif
        -:   28:
        -:   29:#ifdef yy_scan_buffer
        -:   30:#define re_yy_scan_buffer_ALREADY_DEFINED
        -:   31:#else
        -:   32:#define yy_scan_buffer re_yy_scan_buffer
        -:   33:#endif
        -:   34:
        -:   35:#ifdef yy_scan_string
        -:   36:#define re_yy_scan_string_ALREADY_DEFINED
        -:   37:#else
        -:   38:#define yy_scan_string re_yy_scan_string
        -:   39:#endif
        -:   40:
        -:   41:#ifdef yy_scan_bytes
        -:   42:#define re_yy_scan_bytes_ALREADY_DEFINED
        -:   43:#else
        -:   44:#define yy_scan_bytes re_yy_scan_bytes
        -:   45:#endif
        -:   46:
        -:   47:#ifdef yy_init_buffer
        -:   48:#define re_yy_init_buffer_ALREADY_DEFINED
        -:   49:#else
        -:   50:#define yy_init_buffer re_yy_init_buffer
        -:   51:#endif
        -:   52:
        -:   53:#ifdef yy_flush_buffer
        -:   54:#define re_yy_flush_buffer_ALREADY_DEFINED
        -:   55:#else
        -:   56:#define yy_flush_buffer re_yy_flush_buffer
        -:   57:#endif
        -:   58:
        -:   59:#ifdef yy_load_buffer_state
        -:   60:#define re_yy_load_buffer_state_ALREADY_DEFINED
        -:   61:#else
        -:   62:#define yy_load_buffer_state re_yy_load_buffer_state
        -:   63:#endif
        -:   64:
        -:   65:#ifdef yy_switch_to_buffer
        -:   66:#define re_yy_switch_to_buffer_ALREADY_DEFINED
        -:   67:#else
        -:   68:#define yy_switch_to_buffer re_yy_switch_to_buffer
        -:   69:#endif
        -:   70:
        -:   71:#ifdef yypush_buffer_state
        -:   72:#define re_yypush_buffer_state_ALREADY_DEFINED
        -:   73:#else
        -:   74:#define yypush_buffer_state re_yypush_buffer_state
        -:   75:#endif
        -:   76:
        -:   77:#ifdef yypop_buffer_state
        -:   78:#define re_yypop_buffer_state_ALREADY_DEFINED
        -:   79:#else
        -:   80:#define yypop_buffer_state re_yypop_buffer_state
        -:   81:#endif
        -:   82:
        -:   83:#ifdef yyensure_buffer_stack
        -:   84:#define re_yyensure_buffer_stack_ALREADY_DEFINED
        -:   85:#else
        -:   86:#define yyensure_buffer_stack re_yyensure_buffer_stack
        -:   87:#endif
        -:   88:
        -:   89:#ifdef yylex
        -:   90:#define re_yylex_ALREADY_DEFINED
        -:   91:#else
        -:   92:#define yylex re_yylex
        -:   93:#endif
        -:   94:
        -:   95:#ifdef yyrestart
        -:   96:#define re_yyrestart_ALREADY_DEFINED
        -:   97:#else
        -:   98:#define yyrestart re_yyrestart
        -:   99:#endif
        -:  100:
        -:  101:#ifdef yylex_init
        -:  102:#define re_yylex_init_ALREADY_DEFINED
        -:  103:#else
        -:  104:#define yylex_init re_yylex_init
        -:  105:#endif
        -:  106:
        -:  107:#ifdef yylex_init_extra
        -:  108:#define re_yylex_init_extra_ALREADY_DEFINED
        -:  109:#else
        -:  110:#define yylex_init_extra re_yylex_init_extra
        -:  111:#endif
        -:  112:
        -:  113:#ifdef yylex_destroy
        -:  114:#define re_yylex_destroy_ALREADY_DEFINED
        -:  115:#else
        -:  116:#define yylex_destroy re_yylex_destroy
        -:  117:#endif
        -:  118:
        -:  119:#ifdef yyget_debug
        -:  120:#define re_yyget_debug_ALREADY_DEFINED
        -:  121:#else
        -:  122:#define yyget_debug re_yyget_debug
        -:  123:#endif
        -:  124:
        -:  125:#ifdef yyset_debug
        -:  126:#define re_yyset_debug_ALREADY_DEFINED
        -:  127:#else
        -:  128:#define yyset_debug re_yyset_debug
        -:  129:#endif
        -:  130:
        -:  131:#ifdef yyget_extra
        -:  132:#define re_yyget_extra_ALREADY_DEFINED
        -:  133:#else
        -:  134:#define yyget_extra re_yyget_extra
        -:  135:#endif
        -:  136:
        -:  137:#ifdef yyset_extra
        -:  138:#define re_yyset_extra_ALREADY_DEFINED
        -:  139:#else
        -:  140:#define yyset_extra re_yyset_extra
        -:  141:#endif
        -:  142:
        -:  143:#ifdef yyget_in
        -:  144:#define re_yyget_in_ALREADY_DEFINED
        -:  145:#else
        -:  146:#define yyget_in re_yyget_in
        -:  147:#endif
        -:  148:
        -:  149:#ifdef yyset_in
        -:  150:#define re_yyset_in_ALREADY_DEFINED
        -:  151:#else
        -:  152:#define yyset_in re_yyset_in
        -:  153:#endif
        -:  154:
        -:  155:#ifdef yyget_out
        -:  156:#define re_yyget_out_ALREADY_DEFINED
        -:  157:#else
        -:  158:#define yyget_out re_yyget_out
        -:  159:#endif
        -:  160:
        -:  161:#ifdef yyset_out
        -:  162:#define re_yyset_out_ALREADY_DEFINED
        -:  163:#else
        -:  164:#define yyset_out re_yyset_out
        -:  165:#endif
        -:  166:
        -:  167:#ifdef yyget_leng
        -:  168:#define re_yyget_leng_ALREADY_DEFINED
        -:  169:#else
        -:  170:#define yyget_leng re_yyget_leng
        -:  171:#endif
        -:  172:
        -:  173:#ifdef yyget_text
        -:  174:#define re_yyget_text_ALREADY_DEFINED
        -:  175:#else
        -:  176:#define yyget_text re_yyget_text
        -:  177:#endif
        -:  178:
        -:  179:#ifdef yyget_lineno
        -:  180:#define re_yyget_lineno_ALREADY_DEFINED
        -:  181:#else
        -:  182:#define yyget_lineno re_yyget_lineno
        -:  183:#endif
        -:  184:
        -:  185:#ifdef yyset_lineno
        -:  186:#define re_yyset_lineno_ALREADY_DEFINED
        -:  187:#else
        -:  188:#define yyset_lineno re_yyset_lineno
        -:  189:#endif
        -:  190:
        -:  191:#ifdef yyget_column
        -:  192:#define re_yyget_column_ALREADY_DEFINED
        -:  193:#else
        -:  194:#define yyget_column re_yyget_column
        -:  195:#endif
        -:  196:
        -:  197:#ifdef yyset_column
        -:  198:#define re_yyset_column_ALREADY_DEFINED
        -:  199:#else
        -:  200:#define yyset_column re_yyset_column
        -:  201:#endif
        -:  202:
        -:  203:#ifdef yywrap
        -:  204:#define re_yywrap_ALREADY_DEFINED
        -:  205:#else
        -:  206:#define yywrap re_yywrap
        -:  207:#endif
        -:  208:
        -:  209:#ifdef yyget_lval
        -:  210:#define re_yyget_lval_ALREADY_DEFINED
        -:  211:#else
        -:  212:#define yyget_lval re_yyget_lval
        -:  213:#endif
        -:  214:
        -:  215:#ifdef yyset_lval
        -:  216:#define re_yyset_lval_ALREADY_DEFINED
        -:  217:#else
        -:  218:#define yyset_lval re_yyset_lval
        -:  219:#endif
        -:  220:
        -:  221:#ifdef yyalloc
        -:  222:#define re_yyalloc_ALREADY_DEFINED
        -:  223:#else
        -:  224:#define yyalloc re_yyalloc
        -:  225:#endif
        -:  226:
        -:  227:#ifdef yyrealloc
        -:  228:#define re_yyrealloc_ALREADY_DEFINED
        -:  229:#else
        -:  230:#define yyrealloc re_yyrealloc
        -:  231:#endif
        -:  232:
        -:  233:#ifdef yyfree
        -:  234:#define re_yyfree_ALREADY_DEFINED
        -:  235:#else
        -:  236:#define yyfree re_yyfree
        -:  237:#endif
        -:  238:
        -:  239:/* First, we deal with  platform-specific or compiler-specific issues. */
        -:  240:
        -:  241:/* begin standard C headers. */
        -:  242:#include <stdio.h>
        -:  243:#include <string.h>
        -:  244:#include <errno.h>
        -:  245:#include <stdlib.h>
        -:  246:
        -:  247:/* end standard C headers. */
        -:  248:
        -:  249:/* flex integer type definitions */
        -:  250:
        -:  251:#ifndef FLEXINT_H
        -:  252:#define FLEXINT_H
        -:  253:
        -:  254:/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
        -:  255:
        -:  256:#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
        -:  257:
        -:  258:/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
        -:  259: * if you want the limit (max/min) macros for int types. 
        -:  260: */
        -:  261:#ifndef __STDC_LIMIT_MACROS
        -:  262:#define __STDC_LIMIT_MACROS 1
        -:  263:#endif
        -:  264:
        -:  265:#include <inttypes.h>
        -:  266:typedef int8_t flex_int8_t;
        -:  267:typedef uint8_t flex_uint8_t;
        -:  268:typedef int16_t flex_int16_t;
        -:  269:typedef uint16_t flex_uint16_t;
        -:  270:typedef int32_t flex_int32_t;
        -:  271:typedef uint32_t flex_uint32_t;
        -:  272:#else
        -:  273:typedef signed char flex_int8_t;
        -:  274:typedef short int flex_int16_t;
        -:  275:typedef int flex_int32_t;
        -:  276:typedef unsigned char flex_uint8_t; 
        -:  277:typedef unsigned short int flex_uint16_t;
        -:  278:typedef unsigned int flex_uint32_t;
        -:  279:
        -:  280:/* Limits of integral types. */
        -:  281:#ifndef INT8_MIN
        -:  282:#define INT8_MIN               (-128)
        -:  283:#endif
        -:  284:#ifndef INT16_MIN
        -:  285:#define INT16_MIN              (-32767-1)
        -:  286:#endif
        -:  287:#ifndef INT32_MIN
        -:  288:#define INT32_MIN              (-2147483647-1)
        -:  289:#endif
        -:  290:#ifndef INT8_MAX
        -:  291:#define INT8_MAX               (127)
        -:  292:#endif
        -:  293:#ifndef INT16_MAX
        -:  294:#define INT16_MAX              (32767)
        -:  295:#endif
        -:  296:#ifndef INT32_MAX
        -:  297:#define INT32_MAX              (2147483647)
        -:  298:#endif
        -:  299:#ifndef UINT8_MAX
        -:  300:#define UINT8_MAX              (255U)
        -:  301:#endif
        -:  302:#ifndef UINT16_MAX
        -:  303:#define UINT16_MAX             (65535U)
        -:  304:#endif
        -:  305:#ifndef UINT32_MAX
        -:  306:#define UINT32_MAX             (4294967295U)
        -:  307:#endif
        -:  308:
        -:  309:#ifndef SIZE_MAX
        -:  310:#define SIZE_MAX               (~(size_t)0)
        -:  311:#endif
        -:  312:
        -:  313:#endif /* ! C99 */
        -:  314:
        -:  315:#endif /* ! FLEXINT_H */
        -:  316:
        -:  317:/* begin standard C++ headers. */
        -:  318:
        -:  319:/* TODO: this is always defined, so inline it */
        -:  320:#define yyconst const
        -:  321:
        -:  322:#if defined(__GNUC__) && __GNUC__ >= 3
        -:  323:#define yynoreturn __attribute__((__noreturn__))
        -:  324:#else
        -:  325:#define yynoreturn
        -:  326:#endif
        -:  327:
        -:  328:/* Returned upon end-of-file. */
        -:  329:#define YY_NULL 0
        -:  330:
        -:  331:/* Promotes a possibly negative, possibly signed char to an
        -:  332: *   integer in range [0..255] for use as an array index.
        -:  333: */
        -:  334:#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
        -:  335:
        -:  336:/* An opaque pointer. */
        -:  337:#ifndef YY_TYPEDEF_YY_SCANNER_T
        -:  338:#define YY_TYPEDEF_YY_SCANNER_T
        -:  339:typedef void* yyscan_t;
        -:  340:#endif
        -:  341:
        -:  342:/* For convenience, these vars (plus the bison vars far below)
        -:  343:   are macros in the reentrant scanner. */
        -:  344:#define yyin yyg->yyin_r
        -:  345:#define yyout yyg->yyout_r
        -:  346:#define yyextra yyg->yyextra_r
        -:  347:#define yyleng yyg->yyleng_r
        -:  348:#define yytext yyg->yytext_r
        -:  349:#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
        -:  350:#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
        -:  351:#define yy_flex_debug yyg->yy_flex_debug_r
        -:  352:
        -:  353:/* Enter a start condition.  This macro really ought to take a parameter,
        -:  354: * but we do it the disgusting crufty way forced on us by the ()-less
        -:  355: * definition of BEGIN.
        -:  356: */
        -:  357:#define BEGIN yyg->yy_start = 1 + 2 *
        -:  358:/* Translate the current start state into a value that can be later handed
        -:  359: * to BEGIN to return to the state.  The YYSTATE alias is for lex
        -:  360: * compatibility.
        -:  361: */
        -:  362:#define YY_START ((yyg->yy_start - 1) / 2)
        -:  363:#define YYSTATE YY_START
        -:  364:/* Action number for EOF rule of a given start state. */
        -:  365:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -:  366:/* Special action meaning "start processing a new file". */
        -:  367:#define YY_NEW_FILE yyrestart( yyin , yyscanner )
        -:  368:#define YY_END_OF_BUFFER_CHAR 0
        -:  369:
        -:  370:/* Size of default input buffer. */
        -:  371:#ifndef YY_BUF_SIZE
        -:  372:#ifdef __ia64__
        -:  373:/* On IA-64, the buffer size is 16k, not 8k.
        -:  374: * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
        -:  375: * Ditto for the __ia64__ case accordingly.
        -:  376: */
        -:  377:#define YY_BUF_SIZE 32768
        -:  378:#else
        -:  379:#define YY_BUF_SIZE 16384
        -:  380:#endif /* __ia64__ */
        -:  381:#endif
        -:  382:
        -:  383:/* The state buf must be large enough to hold one state per character in the main buffer.
        -:  384: */
        -:  385:#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
        -:  386:
        -:  387:#ifndef YY_TYPEDEF_YY_BUFFER_STATE
        -:  388:#define YY_TYPEDEF_YY_BUFFER_STATE
        -:  389:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -:  390:#endif
        -:  391:
        -:  392:#ifndef YY_TYPEDEF_YY_SIZE_T
        -:  393:#define YY_TYPEDEF_YY_SIZE_T
        -:  394:typedef size_t yy_size_t;
        -:  395:#endif
        -:  396:
        -:  397:#define EOB_ACT_CONTINUE_SCAN 0
        -:  398:#define EOB_ACT_END_OF_FILE 1
        -:  399:#define EOB_ACT_LAST_MATCH 2
        -:  400:    
        -:  401:    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
        -:  402:     *       access to the local variable yy_act. Since yyless() is a macro, it would break
        -:  403:     *       existing scanners that call yyless() from OUTSIDE yylex.
        -:  404:     *       One obvious solution it to make yy_act a global. I tried that, and saw
        -:  405:     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
        -:  406:     *       normally declared as a register variable-- so it is not worth it.
        -:  407:     */
        -:  408:    #define  YY_LESS_LINENO(n) \
        -:  409:            do { \
        -:  410:                int yyl;\
        -:  411:                for ( yyl = n; yyl < yyleng; ++yyl )\
        -:  412:                    if ( yytext[yyl] == '\n' )\
        -:  413:                        --yylineno;\
        -:  414:            }while(0)
        -:  415:    #define YY_LINENO_REWIND_TO(dst) \
        -:  416:            do {\
        -:  417:                const char *p;\
        -:  418:                for ( p = yy_cp-1; p >= (dst); --p)\
        -:  419:                    if ( *p == '\n' )\
        -:  420:                        --yylineno;\
        -:  421:            }while(0)
        -:  422:    
        -:  423:/* Return all but the first "n" matched characters back to the input stream. */
        -:  424:#define yyless(n) \
        -:  425:	do \
        -:  426:		{ \
        -:  427:		/* Undo effects of setting up yytext. */ \
        -:  428:        int yyless_macro_arg = (n); \
        -:  429:        YY_LESS_LINENO(yyless_macro_arg);\
        -:  430:		*yy_cp = yyg->yy_hold_char; \
        -:  431:		YY_RESTORE_YY_MORE_OFFSET \
        -:  432:		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        -:  433:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -:  434:		} \
        -:  435:	while ( 0 )
        -:  436:#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
        -:  437:
        -:  438:#ifndef YY_STRUCT_YY_BUFFER_STATE
        -:  439:#define YY_STRUCT_YY_BUFFER_STATE
        -:  440:struct yy_buffer_state
        -:  441:	{
        -:  442:	FILE *yy_input_file;
        -:  443:
        -:  444:	char *yy_ch_buf;		/* input buffer */
        -:  445:	char *yy_buf_pos;		/* current position in input buffer */
        -:  446:
        -:  447:	/* Size of input buffer in bytes, not including room for EOB
        -:  448:	 * characters.
        -:  449:	 */
        -:  450:	int yy_buf_size;
        -:  451:
        -:  452:	/* Number of characters read into yy_ch_buf, not including EOB
        -:  453:	 * characters.
        -:  454:	 */
        -:  455:	int yy_n_chars;
        -:  456:
        -:  457:	/* Whether we "own" the buffer - i.e., we know we created it,
        -:  458:	 * and can realloc() it to grow it, and should free() it to
        -:  459:	 * delete it.
        -:  460:	 */
        -:  461:	int yy_is_our_buffer;
        -:  462:
        -:  463:	/* Whether this is an "interactive" input source; if so, and
        -:  464:	 * if we're using stdio for input, then we want to use getc()
        -:  465:	 * instead of fread(), to make sure we stop fetching input after
        -:  466:	 * each newline.
        -:  467:	 */
        -:  468:	int yy_is_interactive;
        -:  469:
        -:  470:	/* Whether we're considered to be at the beginning of a line.
        -:  471:	 * If so, '^' rules will be active on the next match, otherwise
        -:  472:	 * not.
        -:  473:	 */
        -:  474:	int yy_at_bol;
        -:  475:
        -:  476:    int yy_bs_lineno; /**< The line count. */
        -:  477:    int yy_bs_column; /**< The column count. */
        -:  478:
        -:  479:	/* Whether to try to fill the input buffer when we reach the
        -:  480:	 * end of it.
        -:  481:	 */
        -:  482:	int yy_fill_buffer;
        -:  483:
        -:  484:	int yy_buffer_status;
        -:  485:
        -:  486:#define YY_BUFFER_NEW 0
        -:  487:#define YY_BUFFER_NORMAL 1
        -:  488:	/* When an EOF's been seen but there's still some text to process
        -:  489:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -:  490:	 * shouldn't try reading from the input source any more.  We might
        -:  491:	 * still have a bunch of tokens to match, though, because of
        -:  492:	 * possible backing-up.
        -:  493:	 *
        -:  494:	 * When we actually see the EOF, we change the status to "new"
        -:  495:	 * (via yyrestart()), so that the user can continue scanning by
        -:  496:	 * just pointing yyin at a new input file.
        -:  497:	 */
        -:  498:#define YY_BUFFER_EOF_PENDING 2
        -:  499:
        -:  500:	};
        -:  501:#endif /* !YY_STRUCT_YY_BUFFER_STATE */
        -:  502:
        -:  503:/* We provide macros for accessing buffer states in case in the
        -:  504: * future we want to put the buffer states in a more general
        -:  505: * "scanner state".
        -:  506: *
        -:  507: * Returns the top of the stack, or NULL.
        -:  508: */
        -:  509:#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
        -:  510:                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
        -:  511:                          : NULL)
        -:  512:/* Same as previous macro, but useful when we know that the buffer stack is not
        -:  513: * NULL or when we need an lvalue. For internal use only.
        -:  514: */
        -:  515:#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
        -:  516:
        -:  517:void yyrestart ( FILE *input_file , yyscan_t yyscanner );
        -:  518:void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
        -:  519:YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
        -:  520:void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
        -:  521:void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
        -:  522:void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
        -:  523:void yypop_buffer_state ( yyscan_t yyscanner );
        -:  524:
        -:  525:static void yyensure_buffer_stack ( yyscan_t yyscanner );
        -:  526:static void yy_load_buffer_state ( yyscan_t yyscanner );
        -:  527:static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
        -:  528:#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
        -:  529:
        -:  530:YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
        -:  531:YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
        -:  532:YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
        -:  533:
        -:  534:void *yyalloc ( yy_size_t , yyscan_t yyscanner );
        -:  535:void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
        -:  536:void yyfree ( void * , yyscan_t yyscanner );
        -:  537:
        -:  538:#define yy_new_buffer yy_create_buffer
        -:  539:#define yy_set_interactive(is_interactive) \
        -:  540:	{ \
        -:  541:	if ( ! YY_CURRENT_BUFFER ){ \
        -:  542:        yyensure_buffer_stack (yyscanner); \
        -:  543:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  544:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
        -:  545:	} \
        -:  546:	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
        -:  547:	}
        -:  548:#define yy_set_bol(at_bol) \
        -:  549:	{ \
        -:  550:	if ( ! YY_CURRENT_BUFFER ){\
        -:  551:        yyensure_buffer_stack (yyscanner); \
        -:  552:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  553:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
        -:  554:	} \
        -:  555:	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
        -:  556:	}
        -:  557:#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
        -:  558:
        -:  559:/* Begin user sect3 */
        -:  560:
        -:  561:#define re_yywrap(yyscanner) (/*CONSTCOND*/1)
        -:  562:#define YY_SKIP_YYWRAP
        -:  563:typedef flex_uint8_t YY_CHAR;
        -:  564:
        -:  565:typedef int yy_state_type;
        -:  566:
        -:  567:#define yytext_ptr yytext_r
        -:  568:
        -:  569:static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
        -:  570:static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
        -:  571:static int yy_get_next_buffer ( yyscan_t yyscanner );
        -:  572:static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
        -:  573:
        -:  574:/* Done after the current pattern has been matched and before the
        -:  575: * corresponding action - sets up yytext.
        -:  576: */
        -:  577:#define YY_DO_BEFORE_ACTION \
        -:  578:	yyg->yytext_ptr = yy_bp; \
        -:  579:	yyleng = (int) (yy_cp - yy_bp); \
        -:  580:	yyg->yy_hold_char = *yy_cp; \
        -:  581:	*yy_cp = '\0'; \
        -:  582:	yyg->yy_c_buf_p = yy_cp;
        -:  583:#define YY_NUM_RULES 29
        -:  584:#define YY_END_OF_BUFFER 30
        -:  585:/* This struct is not used in this scanner,
        -:  586:   but its presence is necessary. */
        -:  587:struct yy_trans_info
        -:  588:	{
        -:  589:	flex_int32_t yy_verify;
        -:  590:	flex_int32_t yy_nxt;
        -:  591:	};
        -:  592:static const flex_int16_t yy_accept[45] =
        -:  593:    {   0,
        -:  594:        0,    0,    0,    0,   30,    7,    7,   28,    6,   17,
        -:  595:        7,   27,   29,   26,   18,    5,    3,   16,   15,   13,
        -:  596:       11,    9,   14,   12,   10,    8,    0,    0,    0,    0,
        -:  597:       25,   23,   21,   24,   22,   20,    0,    4,    0,    1,
        -:  598:        2,   19,    0,    0
        -:  599:    } ;
        -:  600:
        -:  601:static const YY_CHAR yy_ec[256] =
        -:  602:    {   0,
        -:  603:        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        -:  604:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  605:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  606:        1,    1,    1,    1,    1,    3,    1,    1,    1,    3,
        -:  607:        3,    3,    3,    4,    5,    3,    1,    6,    6,    6,
        -:  608:        6,    6,    6,    6,    6,    6,    6,    1,    1,    1,
        -:  609:        1,    1,    3,    1,    7,    8,    7,    9,    7,    7,
        -:  610:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  611:        1,    1,   10,    1,    1,    1,   11,    1,    1,    1,
        -:  612:       12,   13,   14,   15,    1,    1,    7,   16,    7,   17,
        -:  613:
        -:  614:        7,    7,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  615:        1,    1,    1,    1,   18,    1,    1,    1,   19,   20,
        -:  616:        1,    1,   21,    3,   22,    1,    1,    1,    1,    1,
        -:  617:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  618:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  619:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  620:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  621:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  622:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  623:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  624:
        -:  625:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  626:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  627:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  628:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  629:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  630:        1,    1,    1,    1,    1
        -:  631:    } ;
        -:  632:
        -:  633:static const YY_CHAR yy_meta[23] =
        -:  634:    {   0,
        -:  635:        1,    2,    1,    1,    3,    4,    4,    4,    4,    1,
        -:  636:        1,    1,    1,    5,    1,    4,    4,    1,    1,    1,
        -:  637:        1,    1
        -:  638:    } ;
        -:  639:
        -:  640:static const flex_int16_t yy_base[51] =
        -:  641:    {   0,
        -:  642:        0,   20,    3,    5,   50,   89,   89,   89,   10,   36,
        -:  643:        0,   44,   43,   47,   38,   89,   26,   33,   89,   89,
        -:  644:       89,   89,   89,   89,   89,   89,    4,    5,    0,   33,
        -:  645:       32,   31,   29,   26,   24,   23,   15,   89,    8,   89,
        -:  646:       89,   89,    0,   89,   67,   72,   77,   82,   84,    4
        -:  647:    } ;
        -:  648:
        -:  649:static const flex_int16_t yy_def[51] =
        -:  650:    {   0,
        -:  651:       45,   45,   46,   46,   44,   44,   44,   44,   44,   44,
        -:  652:       44,   44,   44,   47,   44,   44,   44,   44,   44,   44,
        -:  653:       44,   44,   44,   44,   44,   44,   44,   44,   48,   44,
        -:  654:       44,   44,   44,   44,   44,   44,   49,   44,   44,   44,
        -:  655:       44,   44,   50,    0,   44,   44,   44,   44,   44,   44
        -:  656:    } ;
        -:  657:
        -:  658:static const flex_int16_t yy_nxt[112] =
        -:  659:    {   0,
        -:  660:       44,    7,    8,   27,   13,   28,   13,   30,   27,   39,
        -:  661:       28,    9,   10,   39,    8,   14,   15,   14,   15,   29,
        -:  662:       11,    7,    8,   16,   17,   40,   41,   29,   29,   40,
        -:  663:       29,    9,   10,   29,    8,   29,   29,   29,   18,   38,
        -:  664:       11,   18,   29,   19,   20,   21,   22,   29,   29,   44,
        -:  665:       44,   23,   24,   25,   26,   31,   32,   33,   44,   44,
        -:  666:       44,   44,   44,   34,   35,   36,   37,    6,    6,    6,
        -:  667:        6,    6,   12,   12,   12,   12,   12,   30,   44,   30,
        -:  668:       30,   30,   42,   42,   42,   42,   43,   43,    5,   44,
        -:  669:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:  670:
        -:  671:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:  672:       44
        -:  673:    } ;
        -:  674:
        -:  675:static const flex_int16_t yy_chk[112] =
        -:  676:    {   0,
        -:  677:        0,    1,    1,   11,    3,   11,    4,   50,   28,   27,
        -:  678:       28,    1,    1,   39,    1,    3,    3,    4,    4,   37,
        -:  679:        1,    2,    2,    9,    9,   27,   28,   36,   35,   39,
        -:  680:       34,    2,    2,   33,    2,   32,   31,   30,   18,   17,
        -:  681:        2,   10,   15,   10,   10,   10,   10,   13,   12,    5,
        -:  682:        0,   10,   10,   10,   10,   14,   14,   14,    0,    0,
        -:  683:        0,    0,    0,   14,   14,   14,   14,   45,   45,   45,
        -:  684:       45,   45,   46,   46,   46,   46,   46,   47,    0,   47,
        -:  685:       47,   47,   48,   48,   48,   48,   49,   49,   44,   44,
        -:  686:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:  687:
        -:  688:       44,   44,   44,   44,   44,   44,   44,   44,   44,   44,
        -:  689:       44
        -:  690:    } ;
        -:  691:
        -:  692:/* Table of booleans, true if rule could match eol. */
        -:  693:static const flex_int32_t yy_rule_can_match_eol[30] =
        -:  694:    {   0,
        -:  695:0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
        -:  696:    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     };
        -:  697:
        -:  698:/* The intent behind this definition is that it'll catch
        -:  699: * any uses of REJECT which flex missed.
        -:  700: */
        -:  701:#define REJECT reject_used_but_not_detected
        -:  702:#define yymore() yymore_used_but_not_detected
        -:  703:#define YY_MORE_ADJ 0
        -:  704:#define YY_RESTORE_YY_MORE_OFFSET
        -:  705:#line 1 "re_lexer.l"
        -:  706:/*
        -:  707:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:  708:
        -:  709:Redistribution and use in source and binary forms, with or without modification,
        -:  710:are permitted provided that the following conditions are met:
        -:  711:
        -:  712:1. Redistributions of source code must retain the above copyright notice, this
        -:  713:list of conditions and the following disclaimer.
        -:  714:
        -:  715:2. Redistributions in binary form must reproduce the above copyright notice,
        -:  716:this list of conditions and the following disclaimer in the documentation and/or
        -:  717:other materials provided with the distribution.
        -:  718:
        -:  719:3. Neither the name of the copyright holder nor the names of its contributors
        -:  720:may be used to endorse or promote products derived from this software without
        -:  721:specific prior written permission.
        -:  722:
        -:  723:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:  724:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:  725:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:  726:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:  727:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:  728:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:  729:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:  730:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:  731:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:  732:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:  733:*/
        -:  734:/* Lexical analyzer for regular expressions */
        -:  735:#line 33 "re_lexer.l"
        -:  736:
        -:  737:/* Disable warnings for unused functions in this file.
        -:  738:
        -:  739:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:  740:yy_fatal_error function generated by Flex is not actually used, causing a
        -:  741:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:  742:function. When they include something like %option noyy_fatal_error as they do
        -:  743:with noyywrap then we can remove this pragma.
        -:  744:*/
        -:  745:
        -:  746:#ifdef __GNUC__
        -:  747:#pragma GCC diagnostic ignored "-Wunused-function"
        -:  748:#endif
        -:  749:
        -:  750:#include <assert.h>
        -:  751:#include <setjmp.h>
        -:  752:
        -:  753:#include <yara/globals.h>
        -:  754:#include <yara/utils.h>
        -:  755:#include <yara/error.h>
        -:  756:#include <yara/limits.h>
        -:  757:#include <yara/mem.h>
        -:  758:#include <yara/re.h>
        -:  759:#include <yara/re_lexer.h>
        -:  760:#include <yara/threading.h>
        -:  761:#include <yara/strutils.h>
        -:  762:
        -:  763:
        -:  764:#ifdef _WIN32
        -:  765:#define snprintf _snprintf
        -:  766:#endif
        -:  767:
        -:  768:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:  769:// is set to 1 if the corresponding character is alphanumeric or 0 if otherwise.
        -:  770:static uint8_t word_chars[] = {
        -:  771:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:  772:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:  773:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:  774:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:  775:
        -:  776:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:  777:// is set to 1 if the corresponding character is considered a space. Space
        -:  778:// characters include horizontal and vertical tabs, carriage return, new line
        -:  779:// and form feed (\t, \v, \r, \n, \f).
        -:  780:static uint8_t space_chars[] = {
        -:  781:    0x00, 0x3E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        -:  782:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:  783:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:  784:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:  785:
        -:  786:int escaped_char_value(
        -:  787:    char* text,
        -:  788:    uint8_t* value);
        -:  789:
        -:  790:int read_escaped_char(
        -:  791:    yyscan_t yyscanner,
        -:  792:    uint8_t* escaped_char);
        -:  793:
        -:  794:#line 795 "re_lexer.c"
        -:  795:#define YY_NO_UNISTD_H 1
        -:  796:
        -:  797:#line 798 "re_lexer.c"
        -:  798:
        -:  799:#define INITIAL 0
        -:  800:#define char_class 1
        -:  801:
        -:  802:#ifndef YY_NO_UNISTD_H
        -:  803:/* Special case for "unistd.h", since it is non-ANSI. We include it way
        -:  804: * down here because we want the user's section 1 to have been scanned first.
        -:  805: * The user has a chance to override it with an option.
        -:  806: */
        -:  807:#include <unistd.h>
        -:  808:#endif
        -:  809:
        -:  810:#ifndef YY_EXTRA_TYPE
        -:  811:#define YY_EXTRA_TYPE void *
        -:  812:#endif
        -:  813:
        -:  814:/* Holds the entire state of the reentrant scanner. */
        -:  815:struct yyguts_t
        -:  816:    {
        -:  817:
        -:  818:    /* User-defined. Not touched by flex. */
        -:  819:    YY_EXTRA_TYPE yyextra_r;
        -:  820:
        -:  821:    /* The rest are the same as the globals declared in the non-reentrant scanner. */
        -:  822:    FILE *yyin_r, *yyout_r;
        -:  823:    size_t yy_buffer_stack_top; /**< index of top of stack. */
        -:  824:    size_t yy_buffer_stack_max; /**< capacity of stack. */
        -:  825:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
        -:  826:    char yy_hold_char;
        -:  827:    int yy_n_chars;
        -:  828:    int yyleng_r;
        -:  829:    char *yy_c_buf_p;
        -:  830:    int yy_init;
        -:  831:    int yy_start;
        -:  832:    int yy_did_buffer_switch_on_eof;
        -:  833:    int yy_start_stack_ptr;
        -:  834:    int yy_start_stack_depth;
        -:  835:    int *yy_start_stack;
        -:  836:    yy_state_type yy_last_accepting_state;
        -:  837:    char* yy_last_accepting_cpos;
        -:  838:
        -:  839:    int yylineno_r;
        -:  840:    int yy_flex_debug_r;
        -:  841:
        -:  842:    char *yytext_r;
        -:  843:    int yy_more_flag;
        -:  844:    int yy_more_len;
        -:  845:
        -:  846:    YYSTYPE * yylval_r;
        -:  847:
        -:  848:    }; /* end struct yyguts_t */
        -:  849:
        -:  850:static int yy_init_globals ( yyscan_t yyscanner );
        -:  851:
        -:  852:    /* This must go here because YYSTYPE and YYLTYPE are included
        -:  853:     * from bison output in section 1.*/
        -:  854:    #    define yylval yyg->yylval_r
        -:  855:    
        -:  856:int yylex_init (yyscan_t* scanner);
        -:  857:
        -:  858:int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
        -:  859:
        -:  860:/* Accessor methods to globals.
        -:  861:   These are made visible to non-reentrant scanners for convenience. */
        -:  862:
        -:  863:int yylex_destroy ( yyscan_t yyscanner );
        -:  864:
        -:  865:int yyget_debug ( yyscan_t yyscanner );
        -:  866:
        -:  867:void yyset_debug ( int debug_flag , yyscan_t yyscanner );
        -:  868:
        -:  869:YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
        -:  870:
        -:  871:void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
        -:  872:
        -:  873:FILE *yyget_in ( yyscan_t yyscanner );
        -:  874:
        -:  875:void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
        -:  876:
        -:  877:FILE *yyget_out ( yyscan_t yyscanner );
        -:  878:
        -:  879:void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
        -:  880:
        -:  881:			int yyget_leng ( yyscan_t yyscanner );
        -:  882:
        -:  883:char *yyget_text ( yyscan_t yyscanner );
        -:  884:
        -:  885:int yyget_lineno ( yyscan_t yyscanner );
        -:  886:
        -:  887:void yyset_lineno ( int _line_number , yyscan_t yyscanner );
        -:  888:
        -:  889:int yyget_column  ( yyscan_t yyscanner );
        -:  890:
        -:  891:void yyset_column ( int _column_no , yyscan_t yyscanner );
        -:  892:
        -:  893:YYSTYPE * yyget_lval ( yyscan_t yyscanner );
        -:  894:
        -:  895:void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
        -:  896:
        -:  897:/* Macros after this point can all be overridden by user definitions in
        -:  898: * section 1.
        -:  899: */
        -:  900:
        -:  901:#ifndef YY_SKIP_YYWRAP
        -:  902:#ifdef __cplusplus
        -:  903:extern "C" int yywrap ( yyscan_t yyscanner );
        -:  904:#else
        -:  905:extern int yywrap ( yyscan_t yyscanner );
        -:  906:#endif
        -:  907:#endif
        -:  908:
        -:  909:#ifndef YY_NO_UNPUT
        -:  910:    
        -:  911:#endif
        -:  912:
        -:  913:#ifndef yytext_ptr
        -:  914:static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
        -:  915:#endif
        -:  916:
        -:  917:#ifdef YY_NEED_STRLEN
        -:  918:static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
        -:  919:#endif
        -:  920:
        -:  921:#ifndef YY_NO_INPUT
        -:  922:#ifdef __cplusplus
        -:  923:static int yyinput ( yyscan_t yyscanner );
        -:  924:#else
        -:  925:static int input ( yyscan_t yyscanner );
        -:  926:#endif
        -:  927:
        -:  928:#endif
        -:  929:
        -:  930:/* Amount of stuff to slurp up with each read. */
        -:  931:#ifndef YY_READ_BUF_SIZE
        -:  932:#ifdef __ia64__
        -:  933:/* On IA-64, the buffer size is 16k, not 8k */
        -:  934:#define YY_READ_BUF_SIZE 16384
        -:  935:#else
        -:  936:#define YY_READ_BUF_SIZE 8192
        -:  937:#endif /* __ia64__ */
        -:  938:#endif
        -:  939:
        -:  940:/* Copy whatever the last rule matched to the standard output. */
        -:  941:#ifndef ECHO
        -:  942:/* This used to be an fputs(), but since the string might contain NUL's,
        -:  943: * we now use fwrite().
        -:  944: */
        -:  945:#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
        -:  946:#endif
        -:  947:
        -:  948:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:  949: * is returned in "result".
        -:  950: */
        -:  951:#ifndef YY_INPUT
        -:  952:#define YY_INPUT(buf,result,max_size) \
        -:  953:	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
        -:  954:		{ \
        -:  955:		int c = '*'; \
        -:  956:		int n; \
        -:  957:		for ( n = 0; n < max_size && \
        -:  958:			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
        -:  959:			buf[n] = (char) c; \
        -:  960:		if ( c == '\n' ) \
        -:  961:			buf[n++] = (char) c; \
        -:  962:		if ( c == EOF && ferror( yyin ) ) \
        -:  963:			YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:  964:		result = n; \
        -:  965:		} \
        -:  966:	else \
        -:  967:		{ \
        -:  968:		errno=0; \
        -:  969:		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
        -:  970:			{ \
        -:  971:			if( errno != EINTR) \
        -:  972:				{ \
        -:  973:				YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:  974:				break; \
        -:  975:				} \
        -:  976:			errno=0; \
        -:  977:			clearerr(yyin); \
        -:  978:			} \
        -:  979:		}\
        -:  980:\
        -:  981:
        -:  982:#endif
        -:  983:
        -:  984:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:  985: * we don't want an extra ';' after the "return" because that will cause
        -:  986: * some compilers to complain about unreachable statements.
        -:  987: */
        -:  988:#ifndef yyterminate
        -:  989:#define yyterminate() return YY_NULL
        -:  990:#endif
        -:  991:
        -:  992:/* Number of entries by which start-condition stack grows. */
        -:  993:#ifndef YY_START_STACK_INCR
        -:  994:#define YY_START_STACK_INCR 25
        -:  995:#endif
        -:  996:
        -:  997:/* Report a fatal error. */
        -:  998:#ifndef YY_FATAL_ERROR
        -:  999:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
        -: 1000:#endif
        -: 1001:
        -: 1002:/* end tables serialization structures and prototypes */
        -: 1003:
        -: 1004:/* Default declaration of generated scanner - a define so the user can
        -: 1005: * easily add parameters.
        -: 1006: */
        -: 1007:#ifndef YY_DECL
        -: 1008:#define YY_DECL_IS_OURS 1
        -: 1009:
        -: 1010:extern int yylex \
        -: 1011:               (YYSTYPE * yylval_param , yyscan_t yyscanner);
        -: 1012:
        -: 1013:#define YY_DECL int yylex \
        -: 1014:               (YYSTYPE * yylval_param , yyscan_t yyscanner)
        -: 1015:#endif /* !YY_DECL */
        -: 1016:
        -: 1017:/* Code executed at the beginning of each rule, after yytext and yyleng
        -: 1018: * have been set up.
        -: 1019: */
        -: 1020:#ifndef YY_USER_ACTION
        -: 1021:#define YY_USER_ACTION
        -: 1022:#endif
        -: 1023:
        -: 1024:/* Code executed at the end of each rule. */
        -: 1025:#ifndef YY_BREAK
        -: 1026:#define YY_BREAK /*LINTED*/break;
        -: 1027:#endif
        -: 1028:
        -: 1029:#define YY_RULE_SETUP \
        -: 1030:	YY_USER_ACTION
        -: 1031:
        -: 1032:/** The main scanner function which does all the work.
        -: 1033: */
        8: 1034:YY_DECL
        -: 1035:{
        -: 1036:	yy_state_type yy_current_state;
        -: 1037:	char *yy_cp, *yy_bp;
        -: 1038:	int yy_act;
        8: 1039:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 1040:
        8: 1041:    yylval = yylval_param;
        -: 1042:
        8: 1043:	if ( !yyg->yy_init )
        -: 1044:		{
        2: 1045:		yyg->yy_init = 1;
        -: 1046:
        -: 1047:#ifdef YY_USER_INIT
        -: 1048:		YY_USER_INIT;
        -: 1049:#endif
        -: 1050:
        2: 1051:		if ( ! yyg->yy_start )
        2: 1052:			yyg->yy_start = 1;	/* first start state */
        -: 1053:
        2: 1054:		if ( ! yyin )
        2: 1055:			yyin = stdin;
        -: 1056:
        2: 1057:		if ( ! yyout )
        2: 1058:			yyout = stdout;
        -: 1059:
        2: 1060:		if ( ! YY_CURRENT_BUFFER ) {
    #####: 1061:			yyensure_buffer_stack (yyscanner);
    #####: 1062:			YY_CURRENT_BUFFER_LVALUE =
    #####: 1063:				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
        -: 1064:		}
        -: 1065:
        2: 1066:		yy_load_buffer_state( yyscanner );
        -: 1067:		}
        -: 1068:
        -: 1069:	{
        -: 1070:#line 111 "re_lexer.l"
        -: 1071:
        -: 1072:
        -: 1073:#line 1074 "re_lexer.c"
        -: 1074:
        -: 1075:	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
        -: 1076:		{
        8: 1077:		yy_cp = yyg->yy_c_buf_p;
        -: 1078:
        -: 1079:		/* Support of yytext. */
        8: 1080:		*yy_cp = yyg->yy_hold_char;
        -: 1081:
        -: 1082:		/* yy_bp points to the position in yy_ch_buf of the start of
        -: 1083:		 * the current run.
        -: 1084:		 */
        8: 1085:		yy_bp = yy_cp;
        -: 1086:
        8: 1087:		yy_current_state = yyg->yy_start;
       18: 1088:yy_match:
        -: 1089:		do
        -: 1090:			{
       18: 1091:			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
       18: 1092:			if ( yy_accept[yy_current_state] )
        -: 1093:				{
       10: 1094:				yyg->yy_last_accepting_state = yy_current_state;
       10: 1095:				yyg->yy_last_accepting_cpos = yy_cp;
        -: 1096:				}
       33: 1097:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 1098:				{
       15: 1099:				yy_current_state = (int) yy_def[yy_current_state];
       15: 1100:				if ( yy_current_state >= 45 )
        7: 1101:					yy_c = yy_meta[yy_c];
        -: 1102:				}
       18: 1103:			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
       18: 1104:			++yy_cp;
        -: 1105:			}
       18: 1106:		while ( yy_current_state != 44 );
        8: 1107:		yy_cp = yyg->yy_last_accepting_cpos;
        8: 1108:		yy_current_state = yyg->yy_last_accepting_state;
        -: 1109:
       10: 1110:yy_find_action:
       10: 1111:		yy_act = yy_accept[yy_current_state];
        -: 1112:
       10: 1113:		YY_DO_BEFORE_ACTION;
        -: 1114:
       10: 1115:		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
        -: 1116:			{
        -: 1117:			int yyl;
       10: 1118:			for ( yyl = 0; yyl < yyleng; ++yyl )
        5: 1119:				if ( yytext[yyl] == '\n' )
        -: 1120:					
    #####: 1121:    do{ yylineno++;
    #####: 1122:        yycolumn=0;
        -: 1123:    }while(0)
        -: 1124:;
        -: 1125:			}
        -: 1126:
       10: 1127:do_action:	/* This label is used only to access EOF actions. */
        -: 1128:
       12: 1129:		switch ( yy_act )
        -: 1130:	{ /* beginning of action switch */
    #####: 1131:			case 0: /* must back up */
        -: 1132:			/* undo the effects of YY_DO_BEFORE_ACTION */
    #####: 1133:			*yy_cp = yyg->yy_hold_char;
    #####: 1134:			yy_cp = yyg->yy_last_accepting_cpos;
    #####: 1135:			yy_current_state = yyg->yy_last_accepting_state;
    #####: 1136:			goto yy_find_action;
        -: 1137:
    #####: 1138:case 1:
        -: 1139:YY_RULE_SETUP
        -: 1140:#line 113 "re_lexer.l"
        -: 1141:{
        -: 1142:
        -: 1143:  // Examples: {3,8} {0,5} {,5} {7,}
        -: 1144:
        -: 1145:  int hi_bound;
        -: 1146:  int lo_bound = atoi(yytext + 1);
        -: 1147:
        -: 1148:  char* comma = strchr(yytext, ',');
        -: 1149:
        -: 1150:  if (comma - yytext == strlen(yytext) - 2)
        -: 1151:    // if comma is followed by the closing curly bracket
        -: 1152:    // (example: {2,}) set high bound value to maximum.
        -: 1153:    hi_bound = INT16_MAX;
        -: 1154:  else
        -: 1155:    hi_bound = atoi(comma + 1);
        -: 1156:
        -: 1157:  if (hi_bound > INT16_MAX)
        -: 1158:  {
        -: 1159:    yyerror(yyscanner, lex_env, "repeat interval too large");
        -: 1160:    yyterminate();
        -: 1161:  }
        -: 1162:
        -: 1163:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
        -: 1164:  {
        -: 1165:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -: 1166:    yyterminate();
        -: 1167:  }
        -: 1168:
        -: 1169:  if (hi_bound == 0 && lo_bound == 0)
        -: 1170:  {
        -: 1171:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -: 1172:    yyterminate();
        -: 1173:  }
        -: 1174:
        -: 1175:  yylval->range = (hi_bound << 16) | lo_bound;
        -: 1176:
        -: 1177:  return _RANGE_;
        -: 1178:}
        -: 1179:	YY_BREAK
        -: 1180:case 2:
        -: 1181:YY_RULE_SETUP
        -: 1182:#line 153 "re_lexer.l"
        -: 1183:{
        -: 1184:
        -: 1185:  // Example: {10}
        -: 1186:
        -: 1187:  int value = atoi(yytext + 1);
        -: 1188:
        -: 1189:  // atoi can return a negative value if the input string represents a number
        -: 1190:  // too large to fit in an integer.
        -: 1191:
        -: 1192:  if (value > INT16_MAX || value < 0)
        -: 1193:  {
        -: 1194:    yyerror(yyscanner, lex_env, "repeat interval too large");
        -: 1195:    yyterminate();
        -: 1196:  }
        -: 1197:
        -: 1198:  if (value == 0)
        -: 1199:  {
        -: 1200:    yyerror(yyscanner, lex_env, "bad repeat interval");
        -: 1201:    yyterminate();
        -: 1202:  }
        -: 1203:
        -: 1204:  yylval->range = (value << 16) | value;
        -: 1205:
        -: 1206:  return _RANGE_;
        -: 1207:}
        -: 1208:	YY_BREAK
        -: 1209:case 3:
        -: 1210:YY_RULE_SETUP
        -: 1211:#line 180 "re_lexer.l"
        -: 1212:{
        -: 1213:
        -: 1214:  // Start of a negated character class. Example: [^abcd]
        -: 1215:
        -: 1216:  BEGIN(char_class);
        -: 1217:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        -: 1218:  LEX_ENV->re_class.negated = true;
        -: 1219:}
        -: 1220:	YY_BREAK
        -: 1221:case 4:
        -: 1222:YY_RULE_SETUP
        -: 1223:#line 189 "re_lexer.l"
        -: 1224:{
        -: 1225:
        -: 1226:  // Start of character negated class containing a ].
        -: 1227:  // Example: [^]abc] this must be interpreted as a class
        -: 1228:  // not matching ], a, b, nor c
        -: 1229:
        -: 1230:  BEGIN(char_class);
        -: 1231:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        -: 1232:  LEX_ENV->re_class.negated = true;
        -: 1233:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -: 1234:}
        -: 1235:	YY_BREAK
        -: 1236:case 5:
        -: 1237:YY_RULE_SETUP
        -: 1238:#line 202 "re_lexer.l"
        -: 1239:{
        -: 1240:
        -: 1241:  // Start of character class containing a ].
        -: 1242:  // Example: []abc] this must be interpreted as a class
        -: 1243:  // matching ], a, b, or c.
        -: 1244:
        -: 1245:  BEGIN(char_class);
        -: 1246:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        -: 1247:  LEX_ENV->re_class.negated = false;
        -: 1248:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -: 1249:}
        -: 1250:	YY_BREAK
        -: 1251:case 6:
        -: 1252:YY_RULE_SETUP
        -: 1253:#line 215 "re_lexer.l"
        -: 1254:{
        -: 1255:
        -: 1256:  // Start of character class. Example: [abcd]
        -: 1257:
        -: 1258:  BEGIN(char_class);
        -: 1259:  memset(LEX_ENV->re_class.bitmap, 0, 32);
        -: 1260:  LEX_ENV->re_class.negated = false;
        -: 1261:}
        -: 1262:	YY_BREAK
        -: 1263:case 7:
        -: 1264:/* rule 7 can match eol */
        -: 1265:YY_RULE_SETUP
        -: 1266:#line 225 "re_lexer.l"
        -: 1267:{
        -: 1268:
        -: 1269:  // Any non-special character is passed as a CHAR token to the scanner.
        -: 1270:
        -: 1271:  yylval->integer = yytext[0];
        -: 1272:  return _CHAR_;
        -: 1273:}
        -: 1274:	YY_BREAK
        -: 1275:case 8:
        -: 1276:YY_RULE_SETUP
        -: 1277:#line 234 "re_lexer.l"
        -: 1278:{
        -: 1279:  return _WORD_CHAR_;
        -: 1280:}
        -: 1281:	YY_BREAK
        -: 1282:case 9:
        -: 1283:YY_RULE_SETUP
        -: 1284:#line 239 "re_lexer.l"
        -: 1285:{
        -: 1286:  return _NON_WORD_CHAR_;
        -: 1287:}
        -: 1288:	YY_BREAK
        -: 1289:case 10:
        -: 1290:YY_RULE_SETUP
        -: 1291:#line 244 "re_lexer.l"
        -: 1292:{
        -: 1293:  return _SPACE_;
        -: 1294:}
        -: 1295:	YY_BREAK
        -: 1296:case 11:
        -: 1297:YY_RULE_SETUP
        -: 1298:#line 249 "re_lexer.l"
        -: 1299:{
        -: 1300:  return _NON_SPACE_;
        -: 1301:}
        -: 1302:	YY_BREAK
        -: 1303:case 12:
        -: 1304:YY_RULE_SETUP
        -: 1305:#line 254 "re_lexer.l"
        -: 1306:{
        -: 1307:  return _DIGIT_;
        -: 1308:}
        -: 1309:	YY_BREAK
        -: 1310:case 13:
        -: 1311:YY_RULE_SETUP
        -: 1312:#line 259 "re_lexer.l"
        -: 1313:{
        -: 1314:  return _NON_DIGIT_;
        -: 1315:}
        -: 1316:	YY_BREAK
        -: 1317:case 14:
        -: 1318:YY_RULE_SETUP
        -: 1319:#line 264 "re_lexer.l"
        -: 1320:{
        -: 1321:  return _WORD_BOUNDARY_;
        -: 1322:}
        -: 1323:	YY_BREAK
        -: 1324:case 15:
        -: 1325:YY_RULE_SETUP
        -: 1326:#line 268 "re_lexer.l"
        -: 1327:{
        -: 1328:  return _NON_WORD_BOUNDARY_;
        -: 1329:}
        -: 1330:	YY_BREAK
        -: 1331:case 16:
        -: 1332:YY_RULE_SETUP
        -: 1333:#line 273 "re_lexer.l"
        -: 1334:{
        -: 1335:
        -: 1336:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
        -: 1337:  yyterminate();
        -: 1338:}
        -: 1339:	YY_BREAK
        -: 1340:case 17:
        -: 1341:YY_RULE_SETUP
        -: 1342:#line 280 "re_lexer.l"
        -: 1343:{
        -: 1344:
        -: 1345:  uint8_t c;
        -: 1346:
        -: 1347:  if (read_escaped_char(yyscanner, &c))
        -: 1348:  {
        -: 1349:    yylval->integer = c;
        -: 1350:    return _CHAR_;
        -: 1351:  }
        -: 1352:  else
        -: 1353:  {
        -: 1354:    yyerror(yyscanner, lex_env, "illegal escape sequence");
        -: 1355:    yyterminate();
        -: 1356:  }
        -: 1357:}
        -: 1358:	YY_BREAK
        -: 1359:case 18:
        -: 1360:YY_RULE_SETUP
        -: 1361:#line 297 "re_lexer.l"
        -: 1362:{
        -: 1363:
        -: 1364:  // End of character class.
        -: 1365:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
        -: 1366:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -: 1367:
        -: 1368:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -: 1369:
        -: 1370:  BEGIN(INITIAL);
        -: 1371:  return _CLASS_;
        -: 1372:}
        -: 1373:	YY_BREAK
        -: 1374:case 19:
        -: 1375:/* rule 19 can match eol */
        -: 1376:YY_RULE_SETUP
        -: 1377:#line 311 "re_lexer.l"
        -: 1378:{
        -: 1379:
        -: 1380:  // A range inside a character class.
        -: 1381:  //  [abc0-9]
        -: 1382:  //      ^- matching here
        -: 1383:
        -: 1384:  uint16_t c;
        -: 1385:  uint8_t start = yytext[0];
        -: 1386:  uint8_t end = yytext[2];
        -: 1387:
        -: 1388:  if (start == '\\')
        -: 1389:  {
        -: 1390:    if (!escaped_char_value(yytext, &start))
        -: 1391:    {
        -: 1392:      yyerror(yyscanner, lex_env, "illegal escape sequence");
        -: 1393:      yyterminate();
        -: 1394:    }
        -: 1395:
        -: 1396:    if (yytext[1] == 'x')
        -: 1397:      end = yytext[5];
        -: 1398:    else
        -: 1399:      end = yytext[3];
        -: 1400:  }
        -: 1401:
        -: 1402:  if (end == '\\')
        -: 1403:  {
        -: 1404:    if (!read_escaped_char(yyscanner, &end))
        -: 1405:    {
        -: 1406:      yyerror(yyscanner, lex_env, "illegal escape sequence");
        -: 1407:      yyterminate();
        -: 1408:    }
        -: 1409:  }
        -: 1410:
        -: 1411:  if (end < start)
        -: 1412:  {
        -: 1413:    yyerror(yyscanner, lex_env, "bad character range");
        -: 1414:    yyterminate();
        -: 1415:  }
        -: 1416:
        -: 1417:  for (c = start; c <= end; c++)
        -: 1418:  {
        -: 1419:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -: 1420:  }
        -: 1421:}
        -: 1422:	YY_BREAK
        -: 1423:case 20:
        -: 1424:YY_RULE_SETUP
        -: 1425:#line 357 "re_lexer.l"
        -: 1426:{
        -: 1427:
        -: 1428:  int i;
        -: 1429:
        -: 1430:  for (i = 0; i < 32; i++)
        -: 1431:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -: 1432:}
        -: 1433:	YY_BREAK
        -: 1434:case 21:
        -: 1435:YY_RULE_SETUP
        -: 1436:#line 366 "re_lexer.l"
        -: 1437:{
        -: 1438:
        -: 1439:  int i;
        -: 1440:
        -: 1441:  for (i = 0; i < 32; i++)
        -: 1442:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -: 1443:}
        -: 1444:	YY_BREAK
        -: 1445:case 22:
        -: 1446:YY_RULE_SETUP
        -: 1447:#line 375 "re_lexer.l"
        -: 1448:{
        -: 1449:
        -: 1450:  int i;
        -: 1451:
        -: 1452:  for (i = 0; i < 32; i++)
        -: 1453:    LEX_ENV->re_class.bitmap[i] |= space_chars[i];
        -: 1454:}
        -: 1455:	YY_BREAK
        -: 1456:case 23:
        -: 1457:YY_RULE_SETUP
        -: 1458:#line 384 "re_lexer.l"
        -: 1459:{
        -: 1460:
        -: 1461:  int i;
        -: 1462:
        -: 1463:  for (i = 0; i < 32; i++)
        -: 1464:    LEX_ENV->re_class.bitmap[i] |= ~space_chars[i];
        -: 1465:}
        -: 1466:	YY_BREAK
        -: 1467:case 24:
        -: 1468:YY_RULE_SETUP
        -: 1469:#line 393 "re_lexer.l"
        -: 1470:{
        -: 1471:
        -: 1472:  char c;
        -: 1473:
        -: 1474:  for (c = '0'; c <= '9'; c++)
        -: 1475:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -: 1476:}
        -: 1477:	YY_BREAK
        -: 1478:case 25:
        -: 1479:YY_RULE_SETUP
        -: 1480:#line 402 "re_lexer.l"
        -: 1481:{
        -: 1482:
        -: 1483:  int i;
        -: 1484:
        -: 1485:  for (i = 0; i < 32; i++)
        -: 1486:  {
        -: 1487:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
        -: 1488:    if (i == 6)
        -: 1489:      continue;
        -: 1490:
        -: 1491:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -: 1492:    // vector, let those bits alone.
        -: 1493:    if (i == 7)
        -: 1494:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -: 1495:    else
        -: 1496:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -: 1497:  }
        -: 1498:}
        -: 1499:	YY_BREAK
        -: 1500:case 26:
        -: 1501:YY_RULE_SETUP
        -: 1502:#line 422 "re_lexer.l"
        -: 1503:{
        -: 1504:
        -: 1505:  uint8_t c;
        -: 1506:
        -: 1507:  if (read_escaped_char(yyscanner, &c))
        -: 1508:  {
        -: 1509:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -: 1510:  }
        -: 1511:  else
        -: 1512:  {
        -: 1513:    yyerror(yyscanner, lex_env, "illegal escape sequence");
        -: 1514:    yyterminate();
        -: 1515:  }
        -: 1516:}
        -: 1517:	YY_BREAK
        -: 1518:case 27:
        -: 1519:YY_RULE_SETUP
        -: 1520:#line 438 "re_lexer.l"
        -: 1521:{
        -: 1522:
        -: 1523:  if (yytext[0] >= 32 && yytext[0] < 127)
        -: 1524:  {
        -: 1525:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -: 1526:    // here we set to 1 the vector's bit corresponding to the input character.
        -: 1527:
        -: 1528:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -: 1529:  }
        -: 1530:  else
        -: 1531:  {
        -: 1532:    yyerror(yyscanner, lex_env, "non-ascii character");
        -: 1533:    yyterminate();
        -: 1534:  }
        -: 1535:}
        -: 1536:	YY_BREAK
        -: 1537:case YY_STATE_EOF(char_class):
        -: 1538:#line 455 "re_lexer.l"
        -: 1539:{
        -: 1540:
        -: 1541:  // End of regexp reached while scanning a character class.
        -: 1542:
        -: 1543:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
        -: 1544:  yyterminate();
        -: 1545:}
        -: 1546:	YY_BREAK
        -: 1547:case 28:
        -: 1548:YY_RULE_SETUP
        -: 1549:#line 464 "re_lexer.l"
        -: 1550:{
        -: 1551:
        -: 1552:  if (yytext[0] >= 32 && yytext[0] < 127)
        -: 1553:  {
        -: 1554:    return yytext[0];
        -: 1555:  }
        -: 1556:  else
        -: 1557:  {
        -: 1558:    yyerror(yyscanner, lex_env, "non-ascii character");
        -: 1559:    yyterminate();
        -: 1560:  }
        -: 1561:}
        -: 1562:	YY_BREAK
        -: 1563:case YY_STATE_EOF(INITIAL):
        -: 1564:#line 478 "re_lexer.l"
        -: 1565:{
        -: 1566:
        -: 1567:  yyterminate();
        -: 1568:}
        -: 1569:	YY_BREAK
        -: 1570:case 29:
        -: 1571:YY_RULE_SETUP
        -: 1572:#line 483 "re_lexer.l"
        -: 1573:ECHO;
        -: 1574:	YY_BREAK
        -: 1575:#line 1576 "re_lexer.c"
        -: 1576:
        4: 1577:	case YY_END_OF_BUFFER:
        -: 1578:		{
        -: 1579:		/* Amount of text matched not including the EOB char. */
        4: 1580:		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
        -: 1581:
        -: 1582:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
        4: 1583:		*yy_cp = yyg->yy_hold_char;
        -: 1584:		YY_RESTORE_YY_MORE_OFFSET
        -: 1585:
        4: 1586:		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
        -: 1587:			{
        -: 1588:			/* We're scanning a new file or input source.  It's
        -: 1589:			 * possible that this happened because the user
        -: 1590:			 * just pointed yyin at a new source and called
        -: 1591:			 * yylex().  If so, then we have to assure
        -: 1592:			 * consistency between YY_CURRENT_BUFFER and our
        -: 1593:			 * globals.  Here is the right place to do so, because
        -: 1594:			 * this is the first action (other than possibly a
        -: 1595:			 * back-up) that will match for the new input source.
        -: 1596:			 */
        2: 1597:			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        2: 1598:			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
        2: 1599:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
        -: 1600:			}
        -: 1601:
        -: 1602:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -: 1603:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -: 1604:		 * already have been incremented past the NUL character
        -: 1605:		 * (since all states make transitions on EOB to the
        -: 1606:		 * end-of-buffer state).  Contrast this with the test
        -: 1607:		 * in input().
        -: 1608:		 */
        4: 1609:		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
        -: 1610:			{ /* This was really a NUL. */
        -: 1611:			yy_state_type yy_next_state;
        -: 1612:
    #####: 1613:			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
        -: 1614:
    #####: 1615:			yy_current_state = yy_get_previous_state( yyscanner );
        -: 1616:
        -: 1617:			/* Okay, we're now positioned to make the NUL
        -: 1618:			 * transition.  We couldn't have
        -: 1619:			 * yy_get_previous_state() go ahead and do it
        -: 1620:			 * for us because it doesn't know how to deal
        -: 1621:			 * with the possibility of jamming (and we don't
        -: 1622:			 * want to build jamming into it because then it
        -: 1623:			 * will run more slowly).
        -: 1624:			 */
        -: 1625:
    #####: 1626:			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
        -: 1627:
    #####: 1628:			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        -: 1629:
    #####: 1630:			if ( yy_next_state )
        -: 1631:				{
        -: 1632:				/* Consume the NUL. */
    #####: 1633:				yy_cp = ++yyg->yy_c_buf_p;
    #####: 1634:				yy_current_state = yy_next_state;
    #####: 1635:				goto yy_match;
        -: 1636:				}
        -: 1637:
        -: 1638:			else
        -: 1639:				{
    #####: 1640:				yy_cp = yyg->yy_last_accepting_cpos;
    #####: 1641:				yy_current_state = yyg->yy_last_accepting_state;
    #####: 1642:				goto yy_find_action;
        -: 1643:				}
        -: 1644:			}
        -: 1645:
        4: 1646:		else switch ( yy_get_next_buffer( yyscanner ) )
        -: 1647:			{
        2: 1648:			case EOB_ACT_END_OF_FILE:
        -: 1649:				{
        2: 1650:				yyg->yy_did_buffer_switch_on_eof = 0;
        -: 1651:
        -: 1652:				if ( yywrap( yyscanner ) )
        -: 1653:					{
        -: 1654:					/* Note: because we've taken care in
        -: 1655:					 * yy_get_next_buffer() to have set up
        -: 1656:					 * yytext, we can now set up
        -: 1657:					 * yy_c_buf_p so that if some total
        -: 1658:					 * hoser (like flex itself) wants to
        -: 1659:					 * call the scanner after we return the
        -: 1660:					 * YY_NULL, it'll still work - another
        -: 1661:					 * YY_NULL will get returned.
        -: 1662:					 */
        2: 1663:					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
        -: 1664:
        2: 1665:					yy_act = YY_STATE_EOF(YY_START);
        2: 1666:					goto do_action;
        -: 1667:					}
        -: 1668:
        -: 1669:				else
        -: 1670:					{
        -: 1671:					if ( ! yyg->yy_did_buffer_switch_on_eof )
        -: 1672:						YY_NEW_FILE;
        -: 1673:					}
        -: 1674:				break;
        -: 1675:				}
        -: 1676:
    #####: 1677:			case EOB_ACT_CONTINUE_SCAN:
    #####: 1678:				yyg->yy_c_buf_p =
    #####: 1679:					yyg->yytext_ptr + yy_amount_of_matched_text;
        -: 1680:
    #####: 1681:				yy_current_state = yy_get_previous_state( yyscanner );
        -: 1682:
    #####: 1683:				yy_cp = yyg->yy_c_buf_p;
    #####: 1684:				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
    #####: 1685:				goto yy_match;
        -: 1686:
        2: 1687:			case EOB_ACT_LAST_MATCH:
        2: 1688:				yyg->yy_c_buf_p =
        2: 1689:				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
        -: 1690:
        2: 1691:				yy_current_state = yy_get_previous_state( yyscanner );
        -: 1692:
        2: 1693:				yy_cp = yyg->yy_c_buf_p;
        2: 1694:				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        2: 1695:				goto yy_find_action;
        -: 1696:			}
    #####: 1697:		break;
        -: 1698:		}
        -: 1699:
    #####: 1700:	default:
    #####: 1701:		YY_FATAL_ERROR(
        -: 1702:			"fatal flex scanner internal error--no action found" );
        -: 1703:	} /* end of action switch */
        -: 1704:		} /* end of scanning one token */
        -: 1705:	} /* end of user's declarations */
        -: 1706:} /* end of yylex */
        -: 1707:
        -: 1708:/* yy_get_next_buffer - try to read in a new buffer
        -: 1709: *
        -: 1710: * Returns a code representing an action:
        -: 1711: *	EOB_ACT_LAST_MATCH -
        -: 1712: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -: 1713: *	EOB_ACT_END_OF_FILE - end of file
        -: 1714: */
        4: 1715:static int yy_get_next_buffer (yyscan_t yyscanner)
        -: 1716:{
        4: 1717:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        4: 1718:	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        4: 1719:	char *source = yyg->yytext_ptr;
        -: 1720:	int number_to_move, i;
        -: 1721:	int ret_val;
        -: 1722:
        4: 1723:	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    #####: 1724:		YY_FATAL_ERROR(
        -: 1725:		"fatal flex scanner internal error--end of buffer missed" );
        -: 1726:
        4: 1727:	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
        -: 1728:		{ /* Don't try to fill the buffer, so this is an EOF. */
        4: 1729:		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
        -: 1730:			{
        -: 1731:			/* We matched a single character, the EOB, so
        -: 1732:			 * treat this as a final EOF.
        -: 1733:			 */
        2: 1734:			return EOB_ACT_END_OF_FILE;
        -: 1735:			}
        -: 1736:
        -: 1737:		else
        -: 1738:			{
        -: 1739:			/* We matched some text prior to the EOB, first
        -: 1740:			 * process it.
        -: 1741:			 */
        2: 1742:			return EOB_ACT_LAST_MATCH;
        -: 1743:			}
        -: 1744:		}
        -: 1745:
        -: 1746:	/* Try to read more data. */
        -: 1747:
        -: 1748:	/* First move last chars to start of buffer. */
    #####: 1749:	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
        -: 1750:
    #####: 1751:	for ( i = 0; i < number_to_move; ++i )
    #####: 1752:		*(dest++) = *(source++);
        -: 1753:
    #####: 1754:	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        -: 1755:		/* don't do the read, it's not guaranteed to return an EOF,
        -: 1756:		 * just force an EOF
        -: 1757:		 */
    #####: 1758:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
        -: 1759:
        -: 1760:	else
        -: 1761:		{
    #####: 1762:			int num_to_read =
    #####: 1763:			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        -: 1764:
    #####: 1765:		while ( num_to_read <= 0 )
        -: 1766:			{ /* Not enough room in the buffer - grow it. */
        -: 1767:
        -: 1768:			/* just a shorter name for the current buffer */
    #####: 1769:			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
        -: 1770:
    #####: 1771:			int yy_c_buf_p_offset =
    #####: 1772:				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
        -: 1773:
    #####: 1774:			if ( b->yy_is_our_buffer )
        -: 1775:				{
    #####: 1776:				int new_size = b->yy_buf_size * 2;
        -: 1777:
    #####: 1778:				if ( new_size <= 0 )
    #####: 1779:					b->yy_buf_size += b->yy_buf_size / 8;
        -: 1780:				else
    #####: 1781:					b->yy_buf_size *= 2;
        -: 1782:
    #####: 1783:				b->yy_ch_buf = (char *)
        -: 1784:					/* Include room in for 2 EOB chars. */
    #####: 1785:					yyrealloc( (void *) b->yy_ch_buf,
    #####: 1786:							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
        -: 1787:				}
        -: 1788:			else
        -: 1789:				/* Can't grow it, we don't own it. */
    #####: 1790:				b->yy_ch_buf = NULL;
        -: 1791:
    #####: 1792:			if ( ! b->yy_ch_buf )
    #####: 1793:				YY_FATAL_ERROR(
        -: 1794:				"fatal error - scanner input buffer overflow" );
        -: 1795:
    #####: 1796:			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
        -: 1797:
    #####: 1798:			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
        -: 1799:						number_to_move - 1;
        -: 1800:
        -: 1801:			}
        -: 1802:
    #####: 1803:		if ( num_to_read > YY_READ_BUF_SIZE )
    #####: 1804:			num_to_read = YY_READ_BUF_SIZE;
        -: 1805:
        -: 1806:		/* Read in more data. */
    #####: 1807:		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
        -: 1808:			yyg->yy_n_chars, num_to_read );
        -: 1809:
    #####: 1810:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 1811:		}
        -: 1812:
    #####: 1813:	if ( yyg->yy_n_chars == 0 )
        -: 1814:		{
    #####: 1815:		if ( number_to_move == YY_MORE_ADJ )
        -: 1816:			{
    #####: 1817:			ret_val = EOB_ACT_END_OF_FILE;
    #####: 1818:			yyrestart( yyin  , yyscanner);
        -: 1819:			}
        -: 1820:
        -: 1821:		else
        -: 1822:			{
    #####: 1823:			ret_val = EOB_ACT_LAST_MATCH;
    #####: 1824:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        -: 1825:				YY_BUFFER_EOF_PENDING;
        -: 1826:			}
        -: 1827:		}
        -: 1828:
        -: 1829:	else
    #####: 1830:		ret_val = EOB_ACT_CONTINUE_SCAN;
        -: 1831:
    #####: 1832:	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
        -: 1833:		/* Extend the array by 50%, plus the number we really need. */
    #####: 1834:		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
    #####: 1835:		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
    #####: 1836:			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
    #####: 1837:		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
    #####: 1838:			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
        -: 1839:		/* "- 2" to take care of EOB's */
    #####: 1840:		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
        -: 1841:	}
        -: 1842:
    #####: 1843:	yyg->yy_n_chars += number_to_move;
    #####: 1844:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    #####: 1845:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
        -: 1846:
    #####: 1847:	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
        -: 1848:
    #####: 1849:	return ret_val;
        -: 1850:}
        -: 1851:
        -: 1852:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -: 1853:
        2: 1854:    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
        -: 1855:{
        -: 1856:	yy_state_type yy_current_state;
        -: 1857:	char *yy_cp;
        2: 1858:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 1859:
        2: 1860:	yy_current_state = yyg->yy_start;
        -: 1861:
        4: 1862:	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
        -: 1863:		{
       2*: 1864:		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        2: 1865:		if ( yy_accept[yy_current_state] )
        -: 1866:			{
    #####: 1867:			yyg->yy_last_accepting_state = yy_current_state;
    #####: 1868:			yyg->yy_last_accepting_cpos = yy_cp;
        -: 1869:			}
        4: 1870:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 1871:			{
        2: 1872:			yy_current_state = (int) yy_def[yy_current_state];
        2: 1873:			if ( yy_current_state >= 45 )
        2: 1874:				yy_c = yy_meta[yy_c];
        -: 1875:			}
        2: 1876:		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        -: 1877:		}
        -: 1878:
        2: 1879:	return yy_current_state;
        -: 1880:}
        -: 1881:
        -: 1882:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -: 1883: *
        -: 1884: * synopsis
        -: 1885: *	next_state = yy_try_NUL_trans( current_state );
        -: 1886: */
    #####: 1887:    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
        -: 1888:{
        -: 1889:	int yy_is_jam;
    #####: 1890:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
    #####: 1891:	char *yy_cp = yyg->yy_c_buf_p;
        -: 1892:
    #####: 1893:	YY_CHAR yy_c = 1;
    #####: 1894:	if ( yy_accept[yy_current_state] )
        -: 1895:		{
    #####: 1896:		yyg->yy_last_accepting_state = yy_current_state;
    #####: 1897:		yyg->yy_last_accepting_cpos = yy_cp;
        -: 1898:		}
    #####: 1899:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        -: 1900:		{
    #####: 1901:		yy_current_state = (int) yy_def[yy_current_state];
    #####: 1902:		if ( yy_current_state >= 45 )
    #####: 1903:			yy_c = yy_meta[yy_c];
        -: 1904:		}
    #####: 1905:	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    #####: 1906:	yy_is_jam = (yy_current_state == 44);
        -: 1907:
        -: 1908:	(void)yyg;
    #####: 1909:	return yy_is_jam ? 0 : yy_current_state;
        -: 1910:}
        -: 1911:
        -: 1912:#ifndef YY_NO_UNPUT
        -: 1913:
        -: 1914:#endif
        -: 1915:
        -: 1916:#ifndef YY_NO_INPUT
        -: 1917:#ifdef __cplusplus
        -: 1918:    static int yyinput (yyscan_t yyscanner)
        -: 1919:#else
    #####: 1920:    static int input  (yyscan_t yyscanner)
        -: 1921:#endif
        -: 1922:
        -: 1923:{
        -: 1924:	int c;
    #####: 1925:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 1926:
    #####: 1927:	*yyg->yy_c_buf_p = yyg->yy_hold_char;
        -: 1928:
    #####: 1929:	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        -: 1930:		{
        -: 1931:		/* yy_c_buf_p now points to the character we want to return.
        -: 1932:		 * If this occurs *before* the EOB characters, then it's a
        -: 1933:		 * valid NUL; if not, then we've hit the end of the buffer.
        -: 1934:		 */
    #####: 1935:		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
        -: 1936:			/* This was really a NUL. */
    #####: 1937:			*yyg->yy_c_buf_p = '\0';
        -: 1938:
        -: 1939:		else
        -: 1940:			{ /* need more input */
    #####: 1941:			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
    #####: 1942:			++yyg->yy_c_buf_p;
        -: 1943:
    #####: 1944:			switch ( yy_get_next_buffer( yyscanner ) )
        -: 1945:				{
    #####: 1946:				case EOB_ACT_LAST_MATCH:
        -: 1947:					/* This happens because yy_g_n_b()
        -: 1948:					 * sees that we've accumulated a
        -: 1949:					 * token and flags that we need to
        -: 1950:					 * try matching the token before
        -: 1951:					 * proceeding.  But for input(),
        -: 1952:					 * there's no matching to consider.
        -: 1953:					 * So convert the EOB_ACT_LAST_MATCH
        -: 1954:					 * to EOB_ACT_END_OF_FILE.
        -: 1955:					 */
        -: 1956:
        -: 1957:					/* Reset buffer status. */
    #####: 1958:					yyrestart( yyin , yyscanner);
        -: 1959:
        -: 1960:					/*FALLTHROUGH*/
        -: 1961:
    #####: 1962:				case EOB_ACT_END_OF_FILE:
        -: 1963:					{
        -: 1964:					if ( yywrap( yyscanner ) )
    #####: 1965:						return 0;
        -: 1966:
        -: 1967:					if ( ! yyg->yy_did_buffer_switch_on_eof )
        -: 1968:						YY_NEW_FILE;
        -: 1969:#ifdef __cplusplus
        -: 1970:					return yyinput(yyscanner);
        -: 1971:#else
        -: 1972:					return input(yyscanner);
        -: 1973:#endif
        -: 1974:					}
        -: 1975:
    #####: 1976:				case EOB_ACT_CONTINUE_SCAN:
    #####: 1977:					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
    #####: 1978:					break;
        -: 1979:				}
    #####: 1980:			}
        -: 1981:		}
        -: 1982:
    #####: 1983:	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
    #####: 1984:	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
    #####: 1985:	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
        -: 1986:
    #####: 1987:	if ( c == '\n' )
        -: 1988:		
    #####: 1989:    do{ yylineno++;
    #####: 1990:        yycolumn=0;
        -: 1991:    }while(0)
        -: 1992:;
        -: 1993:
    #####: 1994:	return c;
        -: 1995:}
        -: 1996:#endif	/* ifndef YY_NO_INPUT */
        -: 1997:
        -: 1998:/** Immediately switch to a different input stream.
        -: 1999: * @param input_file A readable stream.
        -: 2000: * @param yyscanner The scanner object.
        -: 2001: * @note This function does not reset the start condition to @c INITIAL .
        -: 2002: */
    #####: 2003:    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
        -: 2004:{
    #####: 2005:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2006:
    #####: 2007:	if ( ! YY_CURRENT_BUFFER ){
    #####: 2008:        yyensure_buffer_stack (yyscanner);
    #####: 2009:		YY_CURRENT_BUFFER_LVALUE =
    #####: 2010:            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
        -: 2011:	}
        -: 2012:
    #####: 2013:	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
    #####: 2014:	yy_load_buffer_state( yyscanner );
    #####: 2015:}
        -: 2016:
        -: 2017:/** Switch to a different input buffer.
        -: 2018: * @param new_buffer The new input buffer.
        -: 2019: * @param yyscanner The scanner object.
        -: 2020: */
        2: 2021:    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
        -: 2022:{
        2: 2023:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2024:
        -: 2025:	/* TODO. We should be able to replace this entire function body
        -: 2026:	 * with
        -: 2027:	 *		yypop_buffer_state();
        -: 2028:	 *		yypush_buffer_state(new_buffer);
        -: 2029:     */
        2: 2030:	yyensure_buffer_stack (yyscanner);
       2*: 2031:	if ( YY_CURRENT_BUFFER == new_buffer )
    #####: 2032:		return;
        -: 2033:
        2: 2034:	if ( YY_CURRENT_BUFFER )
        -: 2035:		{
        -: 2036:		/* Flush out information for old buffer. */
    #####: 2037:		*yyg->yy_c_buf_p = yyg->yy_hold_char;
    #####: 2038:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    #####: 2039:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 2040:		}
        -: 2041:
        2: 2042:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
        2: 2043:	yy_load_buffer_state( yyscanner );
        -: 2044:
        -: 2045:	/* We don't actually know whether we did this switch during
        -: 2046:	 * EOF (yywrap()) processing, but the only time this flag
        -: 2047:	 * is looked at is after yywrap() is called, so it's safe
        -: 2048:	 * to go ahead and always set it.
        -: 2049:	 */
        2: 2050:	yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2051:}
        -: 2052:
        4: 2053:static void yy_load_buffer_state  (yyscan_t yyscanner)
        -: 2054:{
        4: 2055:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        4: 2056:	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        4: 2057:	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
        4: 2058:	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
        4: 2059:	yyg->yy_hold_char = *yyg->yy_c_buf_p;
        4: 2060:}
        -: 2061:
        -: 2062:/** Allocate and initialize an input buffer state.
        -: 2063: * @param file A readable stream.
        -: 2064: * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
        -: 2065: * @param yyscanner The scanner object.
        -: 2066: * @return the allocated buffer state.
        -: 2067: */
    #####: 2068:    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
        -: 2069:{
        -: 2070:	YY_BUFFER_STATE b;
        -: 2071:    
    #####: 2072:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
    #####: 2073:	if ( ! b )
    #####: 2074:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -: 2075:
    #####: 2076:	b->yy_buf_size = size;
        -: 2077:
        -: 2078:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -: 2079:	 * we need to put in 2 end-of-buffer characters.
        -: 2080:	 */
    #####: 2081:	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
    #####: 2082:	if ( ! b->yy_ch_buf )
    #####: 2083:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        -: 2084:
    #####: 2085:	b->yy_is_our_buffer = 1;
        -: 2086:
    #####: 2087:	yy_init_buffer( b, file , yyscanner);
        -: 2088:
    #####: 2089:	return b;
        -: 2090:}
        -: 2091:
        -: 2092:/** Destroy the buffer.
        -: 2093: * @param b a buffer created with yy_create_buffer()
        -: 2094: * @param yyscanner The scanner object.
        -: 2095: */
        2: 2096:    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
        -: 2097:{
        2: 2098:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2099:
        2: 2100:	if ( ! b )
    #####: 2101:		return;
        -: 2102:
       2*: 2103:	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
        2: 2104:		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
        -: 2105:
        2: 2106:	if ( b->yy_is_our_buffer )
        2: 2107:		yyfree( (void *) b->yy_ch_buf , yyscanner );
        -: 2108:
        2: 2109:	yyfree( (void *) b , yyscanner );
        -: 2110:}
        -: 2111:
        -: 2112:/* Initializes or reinitializes a buffer.
        -: 2113: * This function is sometimes called more than once on the same buffer,
        -: 2114: * such as during a yyrestart() or at EOF.
        -: 2115: */
    #####: 2116:    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
        -: 2117:
        -: 2118:{
    #####: 2119:	int oerrno = errno;
    #####: 2120:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2121:
    #####: 2122:	yy_flush_buffer( b , yyscanner);
        -: 2123:
    #####: 2124:	b->yy_input_file = file;
    #####: 2125:	b->yy_fill_buffer = 1;
        -: 2126:
        -: 2127:    /* If b is the current buffer, then yy_init_buffer was _probably_
        -: 2128:     * called from yyrestart() or through yy_get_next_buffer.
        -: 2129:     * In that case, we don't want to reset the lineno or column.
        -: 2130:     */
    #####: 2131:    if (b != YY_CURRENT_BUFFER){
    #####: 2132:        b->yy_bs_lineno = 1;
    #####: 2133:        b->yy_bs_column = 0;
        -: 2134:    }
        -: 2135:
    #####: 2136:        b->yy_is_interactive = 0;
        -: 2137:    
    #####: 2138:	errno = oerrno;
    #####: 2139:}
        -: 2140:
        -: 2141:/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
        -: 2142: * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
        -: 2143: * @param yyscanner The scanner object.
        -: 2144: */
    #####: 2145:    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
        -: 2146:{
    #####: 2147:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2148:	if ( ! b )
    #####: 2149:		return;
        -: 2150:
    #####: 2151:	b->yy_n_chars = 0;
        -: 2152:
        -: 2153:	/* We always need two end-of-buffer characters.  The first causes
        -: 2154:	 * a transition to the end-of-buffer state.  The second causes
        -: 2155:	 * a jam in that state.
        -: 2156:	 */
    #####: 2157:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    #####: 2158:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        -: 2159:
    #####: 2160:	b->yy_buf_pos = &b->yy_ch_buf[0];
        -: 2161:
    #####: 2162:	b->yy_at_bol = 1;
    #####: 2163:	b->yy_buffer_status = YY_BUFFER_NEW;
        -: 2164:
    #####: 2165:	if ( b == YY_CURRENT_BUFFER )
    #####: 2166:		yy_load_buffer_state( yyscanner );
        -: 2167:}
        -: 2168:
        -: 2169:/** Pushes the new state onto the stack. The new state becomes
        -: 2170: *  the current state. This function will allocate the stack
        -: 2171: *  if necessary.
        -: 2172: *  @param new_buffer The new state.
        -: 2173: *  @param yyscanner The scanner object.
        -: 2174: */
    #####: 2175:void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
        -: 2176:{
    #####: 2177:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2178:	if (new_buffer == NULL)
    #####: 2179:		return;
        -: 2180:
    #####: 2181:	yyensure_buffer_stack(yyscanner);
        -: 2182:
        -: 2183:	/* This block is copied from yy_switch_to_buffer. */
    #####: 2184:	if ( YY_CURRENT_BUFFER )
        -: 2185:		{
        -: 2186:		/* Flush out information for old buffer. */
    #####: 2187:		*yyg->yy_c_buf_p = yyg->yy_hold_char;
    #####: 2188:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
    #####: 2189:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
        -: 2190:		}
        -: 2191:
        -: 2192:	/* Only push if top exists. Otherwise, replace top. */
    #####: 2193:	if (YY_CURRENT_BUFFER)
    #####: 2194:		yyg->yy_buffer_stack_top++;
    #####: 2195:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
        -: 2196:
        -: 2197:	/* copied from yy_switch_to_buffer. */
    #####: 2198:	yy_load_buffer_state( yyscanner );
    #####: 2199:	yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2200:}
        -: 2201:
        -: 2202:/** Removes and deletes the top of the stack, if present.
        -: 2203: *  The next element becomes the new top.
        -: 2204: *  @param yyscanner The scanner object.
        -: 2205: */
        2: 2206:void yypop_buffer_state (yyscan_t yyscanner)
        -: 2207:{
        2: 2208:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        2: 2209:	if (!YY_CURRENT_BUFFER)
        2: 2210:		return;
        -: 2211:
    #####: 2212:	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
    #####: 2213:	YY_CURRENT_BUFFER_LVALUE = NULL;
    #####: 2214:	if (yyg->yy_buffer_stack_top > 0)
    #####: 2215:		--yyg->yy_buffer_stack_top;
        -: 2216:
    #####: 2217:	if (YY_CURRENT_BUFFER) {
    #####: 2218:		yy_load_buffer_state( yyscanner );
    #####: 2219:		yyg->yy_did_buffer_switch_on_eof = 1;
        -: 2220:	}
        -: 2221:}
        -: 2222:
        -: 2223:/* Allocates the stack if it does not exist.
        -: 2224: *  Guarantees space for at least one push.
        -: 2225: */
        2: 2226:static void yyensure_buffer_stack (yyscan_t yyscanner)
        -: 2227:{
        -: 2228:	yy_size_t num_to_alloc;
        2: 2229:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2230:
        2: 2231:	if (!yyg->yy_buffer_stack) {
        -: 2232:
        -: 2233:		/* First allocation is just for 2 elements, since we don't know if this
        -: 2234:		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
        -: 2235:		 * immediate realloc on the next call.
        -: 2236:         */
        2: 2237:      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
        2: 2238:		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
        -: 2239:								(num_to_alloc * sizeof(struct yy_buffer_state*)
        -: 2240:								, yyscanner);
        2: 2241:		if ( ! yyg->yy_buffer_stack )
    #####: 2242:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        -: 2243:
        2: 2244:		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
        -: 2245:
        2: 2246:		yyg->yy_buffer_stack_max = num_to_alloc;
        2: 2247:		yyg->yy_buffer_stack_top = 0;
        2: 2248:		return;
        -: 2249:	}
        -: 2250:
    #####: 2251:	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
        -: 2252:
        -: 2253:		/* Increase the buffer to prepare for a possible push. */
    #####: 2254:		yy_size_t grow_size = 8 /* arbitrary grow size */;
        -: 2255:
    #####: 2256:		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
    #####: 2257:		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
    #####: 2258:								(yyg->yy_buffer_stack,
        -: 2259:								num_to_alloc * sizeof(struct yy_buffer_state*)
        -: 2260:								, yyscanner);
    #####: 2261:		if ( ! yyg->yy_buffer_stack )
    #####: 2262:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        -: 2263:
        -: 2264:		/* zero only the new slots.*/
    #####: 2265:		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
    #####: 2266:		yyg->yy_buffer_stack_max = num_to_alloc;
        -: 2267:	}
        -: 2268:}
        -: 2269:
        -: 2270:/** Setup the input buffer state to scan directly from a user-specified character buffer.
        -: 2271: * @param base the character buffer
        -: 2272: * @param size the size in bytes of the character buffer
        -: 2273: * @param yyscanner The scanner object.
        -: 2274: * @return the newly allocated buffer state object.
        -: 2275: */
        2: 2276:YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
        -: 2277:{
        -: 2278:	YY_BUFFER_STATE b;
        -: 2279:    
        2: 2280:	if ( size < 2 ||
        2: 2281:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
        2: 2282:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
        -: 2283:		/* They forgot to leave room for the EOB's. */
    #####: 2284:		return NULL;
        -: 2285:
        2: 2286:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
        2: 2287:	if ( ! b )
    #####: 2288:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
        -: 2289:
        2: 2290:	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
        2: 2291:	b->yy_buf_pos = b->yy_ch_buf = base;
        2: 2292:	b->yy_is_our_buffer = 0;
        2: 2293:	b->yy_input_file = NULL;
        2: 2294:	b->yy_n_chars = b->yy_buf_size;
        2: 2295:	b->yy_is_interactive = 0;
        2: 2296:	b->yy_at_bol = 1;
        2: 2297:	b->yy_fill_buffer = 0;
        2: 2298:	b->yy_buffer_status = YY_BUFFER_NEW;
        -: 2299:
        2: 2300:	yy_switch_to_buffer( b , yyscanner );
        -: 2301:
        2: 2302:	return b;
        -: 2303:}
        -: 2304:
        -: 2305:/** Setup the input buffer state to scan a string. The next call to yylex() will
        -: 2306: * scan from a @e copy of @a str.
        -: 2307: * @param yystr a NUL-terminated string to scan
        -: 2308: * @param yyscanner The scanner object.
        -: 2309: * @return the newly allocated buffer state object.
        -: 2310: * @note If you want to scan bytes that may contain NUL values, then use
        -: 2311: *       yy_scan_bytes() instead.
        -: 2312: */
        2: 2313:YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
        -: 2314:{
        -: 2315:    
        2: 2316:	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
        -: 2317:}
        -: 2318:
        -: 2319:/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
        -: 2320: * scan from a @e copy of @a bytes.
        -: 2321: * @param yybytes the byte buffer to scan
        -: 2322: * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
        -: 2323: * @param yyscanner The scanner object.
        -: 2324: * @return the newly allocated buffer state object.
        -: 2325: */
        2: 2326:YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
        -: 2327:{
        -: 2328:	YY_BUFFER_STATE b;
        -: 2329:	char *buf;
        -: 2330:	yy_size_t n;
        -: 2331:	int i;
        -: 2332:    
        -: 2333:	/* Get memory for full buffer, including space for trailing EOB's. */
        2: 2334:	n = (yy_size_t) (_yybytes_len + 2);
        2: 2335:	buf = (char *) yyalloc( n , yyscanner );
        2: 2336:	if ( ! buf )
    #####: 2337:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
        -: 2338:
        8: 2339:	for ( i = 0; i < _yybytes_len; ++i )
        6: 2340:		buf[i] = yybytes[i];
        -: 2341:
        2: 2342:	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
        -: 2343:
        2: 2344:	b = yy_scan_buffer( buf, n , yyscanner);
        2: 2345:	if ( ! b )
    #####: 2346:		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        -: 2347:
        -: 2348:	/* It's okay to grow etc. this buffer, and we should throw it
        -: 2349:	 * away when we're done.
        -: 2350:	 */
        2: 2351:	b->yy_is_our_buffer = 1;
        -: 2352:
        2: 2353:	return b;
        -: 2354:}
        -: 2355:
        -: 2356:#ifndef YY_EXIT_FAILURE
        -: 2357:#define YY_EXIT_FAILURE 2
        -: 2358:#endif
        -: 2359:
    #####: 2360:static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
        -: 2361:{
    #####: 2362:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2363:	(void)yyg;
    #####: 2364:	fprintf( stderr, "%s\n", msg );
    #####: 2365:	exit( YY_EXIT_FAILURE );
        -: 2366:}
        -: 2367:
        -: 2368:/* Redefine yyless() so it works in section 3 code. */
        -: 2369:
        -: 2370:#undef yyless
        -: 2371:#define yyless(n) \
        -: 2372:	do \
        -: 2373:		{ \
        -: 2374:		/* Undo effects of setting up yytext. */ \
        -: 2375:        int yyless_macro_arg = (n); \
        -: 2376:        YY_LESS_LINENO(yyless_macro_arg);\
        -: 2377:		yytext[yyleng] = yyg->yy_hold_char; \
        -: 2378:		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
        -: 2379:		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
        -: 2380:		*yyg->yy_c_buf_p = '\0'; \
        -: 2381:		yyleng = yyless_macro_arg; \
        -: 2382:		} \
        -: 2383:	while ( 0 )
        -: 2384:
        -: 2385:/* Accessor  methods (get/set functions) to struct members. */
        -: 2386:
        -: 2387:/** Get the user-defined data for this scanner.
        -: 2388: * @param yyscanner The scanner object.
        -: 2389: */
        2: 2390:YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
        -: 2391:{
        2: 2392:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        2: 2393:    return yyextra;
        -: 2394:}
        -: 2395:
        -: 2396:/** Get the current line number.
        -: 2397: * @param yyscanner The scanner object.
        -: 2398: */
    #####: 2399:int yyget_lineno  (yyscan_t yyscanner)
        -: 2400:{
    #####: 2401:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2402:
    #####: 2403:        if (! YY_CURRENT_BUFFER)
    #####: 2404:            return 0;
        -: 2405:    
    #####: 2406:    return yylineno;
        -: 2407:}
        -: 2408:
        -: 2409:/** Get the current column number.
        -: 2410: * @param yyscanner The scanner object.
        -: 2411: */
    #####: 2412:int yyget_column  (yyscan_t yyscanner)
        -: 2413:{
    #####: 2414:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2415:
    #####: 2416:        if (! YY_CURRENT_BUFFER)
    #####: 2417:            return 0;
        -: 2418:    
    #####: 2419:    return yycolumn;
        -: 2420:}
        -: 2421:
        -: 2422:/** Get the input stream.
        -: 2423: * @param yyscanner The scanner object.
        -: 2424: */
    #####: 2425:FILE *yyget_in  (yyscan_t yyscanner)
        -: 2426:{
    #####: 2427:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2428:    return yyin;
        -: 2429:}
        -: 2430:
        -: 2431:/** Get the output stream.
        -: 2432: * @param yyscanner The scanner object.
        -: 2433: */
    #####: 2434:FILE *yyget_out  (yyscan_t yyscanner)
        -: 2435:{
    #####: 2436:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2437:    return yyout;
        -: 2438:}
        -: 2439:
        -: 2440:/** Get the length of the current token.
        -: 2441: * @param yyscanner The scanner object.
        -: 2442: */
    #####: 2443:int yyget_leng  (yyscan_t yyscanner)
        -: 2444:{
    #####: 2445:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2446:    return yyleng;
        -: 2447:}
        -: 2448:
        -: 2449:/** Get the current token.
        -: 2450: * @param yyscanner The scanner object.
        -: 2451: */
        -: 2452:
    #####: 2453:char *yyget_text  (yyscan_t yyscanner)
        -: 2454:{
    #####: 2455:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2456:    return yytext;
        -: 2457:}
        -: 2458:
        -: 2459:/** Set the user-defined data. This data is never touched by the scanner.
        -: 2460: * @param user_defined The data to be associated with this scanner.
        -: 2461: * @param yyscanner The scanner object.
        -: 2462: */
        2: 2463:void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
        -: 2464:{
        2: 2465:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        2: 2466:    yyextra = user_defined ;
        2: 2467:}
        -: 2468:
        -: 2469:/** Set the current line number.
        -: 2470: * @param _line_number line number
        -: 2471: * @param yyscanner The scanner object.
        -: 2472: */
    #####: 2473:void yyset_lineno (int  _line_number , yyscan_t yyscanner)
        -: 2474:{
    #####: 2475:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2476:
        -: 2477:        /* lineno is only valid if an input buffer exists. */
    #####: 2478:        if (! YY_CURRENT_BUFFER )
    #####: 2479:           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
        -: 2480:    
    #####: 2481:    yylineno = _line_number;
    #####: 2482:}
        -: 2483:
        -: 2484:/** Set the current column.
        -: 2485: * @param _column_no column number
        -: 2486: * @param yyscanner The scanner object.
        -: 2487: */
    #####: 2488:void yyset_column (int  _column_no , yyscan_t yyscanner)
        -: 2489:{
    #####: 2490:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2491:
        -: 2492:        /* column is only valid if an input buffer exists. */
    #####: 2493:        if (! YY_CURRENT_BUFFER )
    #####: 2494:           YY_FATAL_ERROR( "yyset_column called with no buffer" );
        -: 2495:    
    #####: 2496:    yycolumn = _column_no;
    #####: 2497:}
        -: 2498:
        -: 2499:/** Set the input stream. This does not discard the current
        -: 2500: * input buffer.
        -: 2501: * @param _in_str A readable stream.
        -: 2502: * @param yyscanner The scanner object.
        -: 2503: * @see yy_switch_to_buffer
        -: 2504: */
    #####: 2505:void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
        -: 2506:{
    #####: 2507:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2508:    yyin = _in_str ;
    #####: 2509:}
        -: 2510:
    #####: 2511:void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
        -: 2512:{
    #####: 2513:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2514:    yyout = _out_str ;
    #####: 2515:}
        -: 2516:
    #####: 2517:int yyget_debug  (yyscan_t yyscanner)
        -: 2518:{
    #####: 2519:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2520:    return yy_flex_debug;
        -: 2521:}
        -: 2522:
    #####: 2523:void yyset_debug (int  _bdebug , yyscan_t yyscanner)
        -: 2524:{
    #####: 2525:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2526:    yy_flex_debug = _bdebug ;
    #####: 2527:}
        -: 2528:
        -: 2529:/* Accessor methods for yylval and yylloc */
        -: 2530:
    #####: 2531:YYSTYPE * yyget_lval  (yyscan_t yyscanner)
        -: 2532:{
    #####: 2533:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2534:    return yylval;
        -: 2535:}
        -: 2536:
    #####: 2537:void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
        -: 2538:{
    #####: 2539:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    #####: 2540:    yylval = yylval_param;
    #####: 2541:}
        -: 2542:
        -: 2543:/* User-visible API */
        -: 2544:
        -: 2545:/* yylex_init is special because it creates the scanner itself, so it is
        -: 2546: * the ONLY reentrant function that doesn't take the scanner as the last argument.
        -: 2547: * That's why we explicitly handle the declaration, instead of using our macros.
        -: 2548: */
        2: 2549:int yylex_init(yyscan_t* ptr_yy_globals)
        -: 2550:{
        2: 2551:    if (ptr_yy_globals == NULL){
    #####: 2552:        errno = EINVAL;
    #####: 2553:        return 1;
        -: 2554:    }
        -: 2555:
        2: 2556:    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
        -: 2557:
        2: 2558:    if (*ptr_yy_globals == NULL){
    #####: 2559:        errno = ENOMEM;
    #####: 2560:        return 1;
        -: 2561:    }
        -: 2562:
        -: 2563:    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
        2: 2564:    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
        -: 2565:
        2: 2566:    return yy_init_globals ( *ptr_yy_globals );
        -: 2567:}
        -: 2568:
        -: 2569:/* yylex_init_extra has the same functionality as yylex_init, but follows the
        -: 2570: * convention of taking the scanner as the last argument. Note however, that
        -: 2571: * this is a *pointer* to a scanner, as it will be allocated by this call (and
        -: 2572: * is the reason, too, why this function also must handle its own declaration).
        -: 2573: * The user defined value in the first argument will be available to yyalloc in
        -: 2574: * the yyextra field.
        -: 2575: */
    #####: 2576:int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
        -: 2577:{
        -: 2578:    struct yyguts_t dummy_yyguts;
        -: 2579:
    #####: 2580:    yyset_extra (yy_user_defined, &dummy_yyguts);
        -: 2581:
    #####: 2582:    if (ptr_yy_globals == NULL){
    #####: 2583:        errno = EINVAL;
    #####: 2584:        return 1;
        -: 2585:    }
        -: 2586:
    #####: 2587:    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
        -: 2588:
    #####: 2589:    if (*ptr_yy_globals == NULL){
    #####: 2590:        errno = ENOMEM;
    #####: 2591:        return 1;
        -: 2592:    }
        -: 2593:
        -: 2594:    /* By setting to 0xAA, we expose bugs in
        -: 2595:    yy_init_globals. Leave at 0x00 for releases. */
    #####: 2596:    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
        -: 2597:
    #####: 2598:    yyset_extra (yy_user_defined, *ptr_yy_globals);
        -: 2599:
    #####: 2600:    return yy_init_globals ( *ptr_yy_globals );
        -: 2601:}
        -: 2602:
        4: 2603:static int yy_init_globals (yyscan_t yyscanner)
        -: 2604:{
        4: 2605:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2606:    /* Initialization is the same as for the non-reentrant scanner.
        -: 2607:     * This function is called from yylex_destroy(), so don't allocate here.
        -: 2608:     */
        -: 2609:
        4: 2610:    yyg->yy_buffer_stack = NULL;
        4: 2611:    yyg->yy_buffer_stack_top = 0;
        4: 2612:    yyg->yy_buffer_stack_max = 0;
        4: 2613:    yyg->yy_c_buf_p = NULL;
        4: 2614:    yyg->yy_init = 0;
        4: 2615:    yyg->yy_start = 0;
        -: 2616:
        4: 2617:    yyg->yy_start_stack_ptr = 0;
        4: 2618:    yyg->yy_start_stack_depth = 0;
        4: 2619:    yyg->yy_start_stack =  NULL;
        -: 2620:
        -: 2621:/* Defined in main.c */
        -: 2622:#ifdef YY_STDINIT
        -: 2623:    yyin = stdin;
        -: 2624:    yyout = stdout;
        -: 2625:#else
        4: 2626:    yyin = NULL;
        4: 2627:    yyout = NULL;
        -: 2628:#endif
        -: 2629:
        -: 2630:    /* For future reference: Set errno on error, since we are called by
        -: 2631:     * yylex_init()
        -: 2632:     */
        4: 2633:    return 0;
        -: 2634:}
        -: 2635:
        -: 2636:/* yylex_destroy is for both reentrant and non-reentrant scanners. */
        2: 2637:int yylex_destroy  (yyscan_t yyscanner)
        -: 2638:{
        2: 2639:    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2640:
        -: 2641:    /* Pop the buffer stack, destroying each element. */
        4: 2642:	while(YY_CURRENT_BUFFER){
       2*: 2643:		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
        2: 2644:		YY_CURRENT_BUFFER_LVALUE = NULL;
        2: 2645:		yypop_buffer_state(yyscanner);
        -: 2646:	}
        -: 2647:
        -: 2648:	/* Destroy the stack itself. */
        2: 2649:	yyfree(yyg->yy_buffer_stack , yyscanner);
        2: 2650:	yyg->yy_buffer_stack = NULL;
        -: 2651:
        -: 2652:    /* Destroy the start condition stack. */
        2: 2653:        yyfree( yyg->yy_start_stack , yyscanner );
        2: 2654:        yyg->yy_start_stack = NULL;
        -: 2655:
        -: 2656:    /* Reset the globals. This is important in a non-reentrant scanner so the next time
        -: 2657:     * yylex() is called, initialization will occur. */
        2: 2658:    yy_init_globals( yyscanner);
        -: 2659:
        -: 2660:    /* Destroy the main struct (reentrant only). */
        2: 2661:    yyfree ( yyscanner , yyscanner );
        2: 2662:    yyscanner = NULL;
        2: 2663:    return 0;
        -: 2664:}
        -: 2665:
        -: 2666:/*
        -: 2667: * Internal utility routines.
        -: 2668: */
        -: 2669:
        -: 2670:#ifndef yytext_ptr
        -: 2671:static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
        -: 2672:{
        -: 2673:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2674:	(void)yyg;
        -: 2675:
        -: 2676:	int i;
        -: 2677:	for ( i = 0; i < n; ++i )
        -: 2678:		s1[i] = s2[i];
        -: 2679:}
        -: 2680:#endif
        -: 2681:
        -: 2682:#ifdef YY_NEED_STRLEN
        -: 2683:static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
        -: 2684:{
        -: 2685:	int n;
        -: 2686:	for ( n = 0; s[n]; ++n )
        -: 2687:		;
        -: 2688:
        -: 2689:	return n;
        -: 2690:}
        -: 2691:#endif
        -: 2692:
        8: 2693:void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
        -: 2694:{
        8: 2695:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2696:	(void)yyg;
        8: 2697:	return malloc(size);
        -: 2698:}
        -: 2699:
    #####: 2700:void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
        -: 2701:{
    #####: 2702:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2703:	(void)yyg;
        -: 2704:
        -: 2705:	/* The cast to (char *) in the following accommodates both
        -: 2706:	 * implementations that use char* generic pointers, and those
        -: 2707:	 * that use void* generic pointers.  It works with the latter
        -: 2708:	 * because both ANSI C and C++ allow castless assignment from
        -: 2709:	 * any pointer type to void*, and deal with argument conversions
        -: 2710:	 * as though doing an assignment.
        -: 2711:	 */
    #####: 2712:	return realloc(ptr, size);
        -: 2713:}
        -: 2714:
       10: 2715:void yyfree (void * ptr , yyscan_t yyscanner)
        -: 2716:{
       10: 2717:	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        -: 2718:	(void)yyg;
       10: 2719:	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
       10: 2720:}
        -: 2721:
        -: 2722:#define YYTABLES_NAME "yytables"
        -: 2723:
        -: 2724:#line 483 "re_lexer.l"
        -: 2725:
        -: 2726:
        -: 2727:int escaped_char_value(
        -: 2728:    char* text,
        -: 2729:    uint8_t* value)
        -: 2730:{
        -: 2731:  unsigned int hex_value;
        -: 2732:  char hex[3];
        -: 2733:
        -: 2734:  assert(text[0] == '\\');
        -: 2735:
        -: 2736:  switch(text[1])
        -: 2737:  {
        -: 2738:  case 'x':
        -: 2739:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
        -: 2740:      return 0;
        -: 2741:    hex[0] = text[2];
        -: 2742:    hex[1] = text[3];
        -: 2743:    hex[2] = '\0';
        -: 2744:    sscanf(hex, "%x", &hex_value);
        -: 2745:    *value = (uint8_t) hex_value;
        -: 2746:    break;
        -: 2747:
        -: 2748:  case 'n':
        -: 2749:    *value = '\n';
        -: 2750:    break;
        -: 2751:
        -: 2752:  case 't':
        -: 2753:    *value = '\t';
        -: 2754:    break;
        -: 2755:
        -: 2756:  case 'r':
        -: 2757:    *value = '\r';
        -: 2758:    break;
        -: 2759:
        -: 2760:  case 'f':
        -: 2761:    *value = '\f';
        -: 2762:    break;
        -: 2763:
        -: 2764:  case 'a':
        -: 2765:    *value = '\a';
        -: 2766:    break;
        -: 2767:
        -: 2768:  default:
        -: 2769:    *value = text[1];
        -: 2770:  }
        -: 2771:
        -: 2772:  return 1;
        -: 2773:}
        -: 2774:
        -: 2775:
        -: 2776:#ifdef __cplusplus
        -: 2777:#define RE_YY_INPUT yyinput
        -: 2778:#else
        -: 2779:#define RE_YY_INPUT input
        -: 2780:#endif
        -: 2781:
        -: 2782:
        -: 2783:int read_escaped_char(
        -: 2784:    yyscan_t yyscanner,
        -: 2785:    uint8_t* escaped_char)
        -: 2786:{
        -: 2787:  char text[4] = {0, 0, 0, 0};
        -: 2788:
        -: 2789:  text[0] = '\\';
        -: 2790:  text[1] = RE_YY_INPUT(yyscanner);
        -: 2791:
        -: 2792:  if (text[1] == EOF || text[1] == 0)
        -: 2793:    return 0;
        -: 2794:
        -: 2795:  if (text[1] == 'x')
        -: 2796:  {
        -: 2797:    text[2] = RE_YY_INPUT(yyscanner);
        -: 2798:
        -: 2799:    if (text[2] == EOF || text[2] == 0)
        -: 2800:      return 0;
        -: 2801:
        -: 2802:    text[3] = RE_YY_INPUT(yyscanner);
        -: 2803:
        -: 2804:    if (text[3] == EOF || text[3] == 0)
        -: 2805:      return 0;
        -: 2806:  }
        -: 2807:
        -: 2808:  return escaped_char_value(text, escaped_char);
        -: 2809:}
        -: 2810:
        -: 2811:
        -: 2812://
        -: 2813:// yyfatal (actually named re_yyfatal because of the '%option prefix="re_yy"'
        -: 2814:// directive) is called when a fatal error occurs in the parser. When this
        -: 2815:// happens we are deep inside the parsing logic generated by flex/bison and
        -: 2816:// the only way to exit gracefully from there is using setjmp/longjmp.
        -: 2817://
        -: 2818:void yyfatal(
        -: 2819:    yyscan_t yyscanner,
        -: 2820:    const char *error_message)
        -: 2821:{
        -: 2822:  jmp_buf* recovery_trampoline = (jmp_buf*) yr_thread_storage_get_value(
        -: 2823:      &yr_yyfatal_trampoline_tls);
        -: 2824:
        -: 2825:  longjmp(*recovery_trampoline, 1);
        -: 2826:}
        -: 2827:
        -: 2828:
        -: 2829:void yyerror(
        -: 2830:    yyscan_t yyscanner,
        -: 2831:    RE_LEX_ENVIRONMENT* lex_env,
        -: 2832:    const char *error_message)
        -: 2833:{
        -: 2834:  // if lex_env->last_error was set to some error code before
        -: 2835:  // don't overwrite it, we are interested in the first error, not in
        -: 2836:  // subsequent errors like "syntax error, unexpected $end" caused by
        -: 2837:  // early parser termination.
        -: 2838:
        -: 2839:  if (lex_env->last_error == ERROR_SUCCESS)
        -: 2840:  {
        -: 2841:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -: 2842:
        -: 2843:    strlcpy(
        -: 2844:        lex_env->last_error_message,
        -: 2845:        error_message,
        -: 2846:        sizeof(lex_env->last_error_message));
        -: 2847:  }
        -: 2848:}
        -: 2849:
        -: 2850:
        -: 2851:int yr_parse_re_string(
        -: 2852:  const char* re_string,
        -: 2853:  RE_AST** re_ast,
        -: 2854:  RE_ERROR* error)
        -: 2855:{
        -: 2856:  yyscan_t yyscanner;
        -: 2857:  jmp_buf recovery_trampoline;
        -: 2858:  RE_LEX_ENVIRONMENT lex_env;
        -: 2859:
        -: 2860:  lex_env.last_error = ERROR_SUCCESS;
        -: 2861:  lex_env.last_error_message[0] = '\0';
        -: 2862:
        -: 2863:  yr_thread_storage_set_value(
        -: 2864:      &yr_yyfatal_trampoline_tls,
        -: 2865:      &recovery_trampoline);
        -: 2866:
        -: 2867:  // setjmp returns a non-zero value only when we are returning to this
        -: 2868:  // point via a call to longjmp to the recovery trampoline.
        -: 2869:  if (setjmp(recovery_trampoline) != 0)
        -: 2870:    return ERROR_INTERNAL_FATAL_ERROR;
        -: 2871:
        -: 2872:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -: 2873:
        -: 2874:  yylex_init(&yyscanner);
        -: 2875:  yyset_extra(*re_ast, yyscanner);
        -: 2876:  yy_scan_string(re_string, yyscanner);
        -: 2877:  yyparse(yyscanner, &lex_env);
        -: 2878:  yylex_destroy(yyscanner);
        -: 2879:
        -: 2880:  if (lex_env.last_error != ERROR_SUCCESS)
        -: 2881:  {
        -: 2882:    yr_re_ast_destroy(*re_ast);
        -: 2883:    *re_ast = NULL;
        -: 2884:
        -: 2885:    strlcpy(
        -: 2886:        error->message,
        -: 2887:        lex_env.last_error_message,
        -: 2888:        sizeof(error->message));
        -: 2889:
        -: 2890:    return lex_env.last_error;
        -: 2891:  }
        -: 2892:
        -: 2893:  return ERROR_SUCCESS;
        -: 2894:}
        -: 2895:
