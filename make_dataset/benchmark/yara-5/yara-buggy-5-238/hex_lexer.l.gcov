        -:    0:Source:hex_lexer.l
        -:    0:Graph:/home/workspace/libyara/hex_lexer.gcno
        -:    0:Data:/home/workspace/libyara/hex_lexer.gcda
        -:    0:Runs:10
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for hex strings */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function hex_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <setjmp.h>
        -:   48:
        -:   49:#include <yara/globals.h>
        -:   50:#include <yara/limits.h>
        -:   51:#include <yara/error.h>
        -:   52:#include <yara/mem.h>
        -:   53:#include <yara/re.h>
        -:   54:#include <yara/threading.h>
        -:   55:#include <yara/strutils.h>
        -:   56:#include <yara/hex_lexer.h>
        -:   57:
        -:   58:#include "hex_grammar.h"
        -:   59:
        -:   60:#ifdef _WIN32
        -:   61:#define snprintf _snprintf
        -:   62:#endif
        -:   63:
        -:   64:#define ERROR_IF(x, error) \
        -:   65:    if (x) \
        -:   66:    { \
        -:   67:      RE_AST* re_ast = yyget_extra(yyscanner); \
        -:   68:      re_ast->error_code = error; \
        -:   69:      YYABORT; \
        -:   70:    } \
        -:   71:
        -:   72:%}
        -:   73:
        -:   74:%option reentrant bison-bridge
        -:   75:%option noyywrap
        -:   76:%option nounistd
        -:   77:%option noinput
        -:   78:%option nounput
        -:   79:%option never-interactive
        -:   80:%option yylineno
        -:   81:%option prefix="hex_yy"
        -:   82:
        -:   83:%option outfile="lex.yy.c"
        -:   84:
        -:   85:%option verbose
        -:   86:%option warn
        -:   87:
        -:   88:digit         [0-9]
        -:   89:letter        [a-zA-Z]
        -:   90:hexdigit      [a-fA-F0-9]
        -:   91:
        -:   92:%x comment
        -:   93:%x range
        -:   94:
        -:   95:%%
        -:   96:
        -:   97:
        -:   98:<INITIAL>{hexdigit}{2}  {
        -:   99:
       12:  100:  yylval->integer = xtoi(yytext);
       12:  101:  return _BYTE_;
        -:  102:}
        -:  103:
        1:  104:<INITIAL>{hexdigit}\?  {
        -:  105:
        1:  106:  yytext[1] = '0'; // replace ? by 0
        1:  107:  yylval->integer = xtoi(yytext) | 0xF000 ;
        1:  108:  return _MASKED_BYTE_;
        -:  109:}
        -:  110:
    #####:  111:\?{hexdigit}  {
        -:  112:
    #####:  113:  yytext[0] = '0'; // replace ? by 0
    #####:  114:  yylval->integer = xtoi(yytext) | 0x0F00 ;
    #####:  115:  return _MASKED_BYTE_;
        -:  116:}
        -:  117:
        1:  118:\?\? {
        -:  119:
        1:  120:  yylval->integer = 0x0000;
        1:  121:  return _MASKED_BYTE_;
        -:  122:}
        -:  123:
    #####:  124:\[ {
        -:  125:
    #####:  126:  BEGIN(range);
    #####:  127:  return yytext[0];
        -:  128:}
        -:  129:
    #####:  130:"/*" {
        -:  131:
    #####:  132:  BEGIN(comment);
        -:  133:}
    #####:  134:
    #####:  135:<comment>"*/" {
        -:  136:
    #####:  137:  BEGIN(INITIAL);
        -:  138:}
    #####:  139:
    #####:  140:<comment>.|\n      // skip comments
    #####:  141:
    #####:  142:"//".*             // skip single-line comments
    #####:  143:
    #####:  144:<range>\- {
        -:  145:
    #####:  146:  return yytext[0];
        -:  147:}
        -:  148:
    #####:  149:<range>{digit}+ {
        -:  150:
    #####:  151:  yylval->integer = atoi(yytext);
    #####:  152:  return _NUMBER_;
        -:  153:}
        -:  154:
    #####:  155:<range>\] {
        -:  156:
    #####:  157:  BEGIN(INITIAL);
    #####:  158:  return yytext[0];
        -:  159:}
        -:  160:
    #####:  161:<range>[ \t\r\n]   // skip whitespaces
    #####:  162:
    #####:  163:<range>. {
        -:  164:
    #####:  165:  yyerror(yyscanner, lex_env, "invalid character in hex string jump");
    #####:  166:  yyterminate();
        -:  167:}
        -:  168:
       11:  169:[ \t\r\n]         // skip whitespaces
       11:  170:
        6:  171:[{}()|]  {        // pass valid characters to the parser
        -:  172:
        6:  173:  return yytext[0];
        -:  174:}
        -:  175:
    #####:  176:. {               // reject all other characters
        -:  177:
    #####:  178:  yyerror(yyscanner, lex_env, "invalid character in hex string");
    #####:  179:  yyterminate();
        -:  180:}
        -:  181:
    #####:  182:%%
    #####:  183:
        -:  184://
        -:  185:// yyfatal (actually named hex_yyfatal because of the '%option prefix="hex_yy"'
        -:  186:// directive) is called when a fatal error occurs in the parser. When this
        -:  187:// happens we are deep inside the parsing logic generated by flex/bison and
        -:  188:// the only way to exit gracefully from there is using setjmp/longjmp.
        -:  189://
    #####:  190:void yyfatal(
        -:  191:    yyscan_t yyscanner,
        -:  192:    const char *error_message)
        -:  193:{
    #####:  194:  jmp_buf* recovery_trampoline = (jmp_buf*) yr_thread_storage_get_value(
        -:  195:      &yr_yyfatal_trampoline_tls);
        -:  196:
        -:  197:  // Never returns.
    #####:  198:  longjmp(*recovery_trampoline, 1);
        -:  199:}
        -:  200:
    #####:  201:void yyerror(
        -:  202:    yyscan_t yyscanner,
        -:  203:    HEX_LEX_ENVIRONMENT* lex_env,
        -:  204:    const char *error_message)
        -:  205:{
        -:  206:  // if lex_env->last_error was set to some error code before
        -:  207:  // don't overwrite it, we are interested in the first error, not in
        -:  208:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  209:  // early parser termination.
        -:  210:
    #####:  211:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  212:  {
    #####:  213:    lex_env->last_error = ERROR_INVALID_HEX_STRING;
        -:  214:
    #####:  215:    strlcpy(
    #####:  216:        lex_env->last_error_message,
        -:  217:        error_message,
        -:  218:        sizeof(lex_env->last_error_message));
        -:  219:  }
    #####:  220:}
        -:  221:
        -:  222:
        3:  223:int yr_parse_hex_string(
        -:  224:    const char* hex_string,
        -:  225:    RE_AST** re_ast,
        -:  226:    RE_ERROR* error)
        -:  227:{
        -:  228:  yyscan_t yyscanner;
        -:  229:  jmp_buf recovery_trampoline;
        -:  230:  HEX_LEX_ENVIRONMENT lex_env;
        -:  231:
        3:  232:  lex_env.last_error = ERROR_SUCCESS;
        3:  233:  lex_env.inside_or = 0;
        -:  234:
        3:  235:  yr_thread_storage_set_value(
        -:  236:     &yr_yyfatal_trampoline_tls,
        -:  237:     &recovery_trampoline);
        -:  238:
        3:  239:  if (setjmp(recovery_trampoline) != 0)
    #####:  240:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  241:
       3*:  242:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  243:
        -:  244:  // The RE_FLAGS_FAST_REGEXP flag indicates a regular expression can be
        -:  245:  // matched by faster algorithm. These regular expressions come from hex
        -:  246:  // strings that do not contain alternatives, like in:
        -:  247:  //
        -:  248:  // { ( 01 02 | 03 04) 05 06 }.
        -:  249:  //
        -:  250:  // This flag is unset later during parsing if alternatives are used.
        -:  251:
        3:  252:  (*re_ast)->flags |= RE_FLAGS_FAST_REGEXP;
        -:  253:
        -:  254:  // Set RE_FLAGS_DOT_ALL because in hex strings the "dot" (?? in this case)
        -:  255:  // must match all characters including new-line.
        -:  256:
        3:  257:  (*re_ast)->flags |= RE_FLAGS_DOT_ALL;
        -:  258:
        3:  259:  yylex_init(&yyscanner);
        3:  260:  yyset_extra(*re_ast, yyscanner);
        3:  261:  yy_scan_string(hex_string, yyscanner);
        3:  262:  yyparse(yyscanner, &lex_env);
        3:  263:  yylex_destroy(yyscanner);
        -:  264:
        3:  265:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  266:  {
    #####:  267:    strlcpy(error->message, lex_env.last_error_message, sizeof(error->message));
    #####:  268:    return lex_env.last_error;
        -:  269:  }
        -:  270:
        3:  271:  return ERROR_SUCCESS;
        -:  272:}
