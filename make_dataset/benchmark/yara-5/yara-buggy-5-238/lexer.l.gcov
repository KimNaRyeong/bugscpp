        -:    0:Source:lexer.l
        -:    0:Graph:/home/workspace/libyara/lexer.gcno
        -:    0:Data:/home/workspace/libyara/lexer.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for YARA */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function yara_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <math.h>
        -:   48:#include <stdarg.h>
        -:   49:#include <stdio.h>
        -:   50:#include <stdlib.h>
        -:   51:#include <string.h>
        -:   52:#include <setjmp.h>
        -:   53:
        -:   54:#if defined(_WIN32) || defined(__CYGWIN__)
        -:   55:#include <windows.h>
        -:   56:#else
        -:   57:#include <sys/stat.h>
        -:   58:#include <unistd.h>
        -:   59:#endif
        -:   60:
        -:   61:#if defined(_WIN32)
        -:   62:#define strtoll _strtoi64
        -:   63:#endif
        -:   64:
        -:   65:#include <yara/integers.h>
        -:   66:#include <yara/lexer.h>
        -:   67:#include <yara/sizedstr.h>
        -:   68:#include <yara/error.h>
        -:   69:#include <yara/mem.h>
        -:   70:#include <yara/utils.h>
        -:   71:#include <yara/strutils.h>
        -:   72:
        -:   73:#include "grammar.h"
        -:   74:
        -:   75:#define error(error_code) \
        -:   76:    { \
        -:   77:      compiler->last_error = error_code; \
        -:   78:      yyerror(yyscanner, compiler, NULL); \
        -:   79:      yyterminate(); \
        -:   80:    }
        -:   81:
        -:   82:#define syntax_error(error_msg) \
        -:   83:    { \
        -:   84:      yr_compiler_set_error_extra_info(compiler, error_msg); \
        -:   85:      error(ERROR_SYNTAX_ERROR); \
        -:   86:    }
        -:   87:
        -:   88:#define lex_check_space_ok(data, current_size, max_length) \
        -:   89:    if (strlen(data) + current_size >= max_length - 1) \
        -:   90:    { \
        -:   91:      yyerror(yyscanner, compiler, "out of space in lex_buf"); \
        -:   92:      yyterminate(); \
        -:   93:    }
        -:   94:
        -:   95:#define yytext_to_buffer \
        -:   96:    { \
        -:   97:      char *yptr = yytext; \
        -:   98:      lex_check_space_ok(yptr, yyextra->lex_buf_len, YR_LEX_BUF_SIZE); \
        -:   99:      while(*yptr) \
        -:  100:      { \
        -:  101:        *yyextra->lex_buf_ptr++ = *yptr++; \
        -:  102:        yyextra->lex_buf_len++; \
        -:  103:      } \
        -:  104:    }
        -:  105:
        -:  106:#define alloc_sized_string(str, str_len) \
        -:  107:  SIZED_STRING* str = (SIZED_STRING*) yr_malloc( \
        -:  108:      str_len + sizeof(SIZED_STRING)); \
        -:  109:  if (str == NULL) \
        -:  110:  { \
        -:  111:    yyerror(yyscanner, compiler, "not enough memory"); \
        -:  112:    yyterminate(); \
        -:  113:  } \
        -:  114:  else \
        -:  115:  { \
        -:  116:    str->length = (uint32_t) (str_len); \
        -:  117:    str->flags = 0; \
        -:  118:  } \
        -:  119:
        -:  120:#ifdef _WIN32
        -:  121:#define snprintf _snprintf
        -:  122:#endif
        -:  123:
    #####:  124:static bool is_absolute_path(
        -:  125:    char* path)
        -:  126:{
    #####:  127:  if (path == NULL)
    #####:  128:    return false;
        -:  129:
        -:  130:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  131:  return strlen(path) > 2 &&
        -:  132:      path[1] == ':' && (path[2] == '/' || path[2] == '\\');
        -:  133:  #else
    #####:  134:  return strlen(path) > 0 && path[0] == '/';
        -:  135:  #endif
        -:  136:}
        -:  137:
        -:  138:%}
        -:  139:
        -:  140:%option reentrant bison-bridge
        -:  141:%option noyywrap
        -:  142:%option nounistd
        -:  143:%option noinput
        -:  144:%option nounput
        -:  145:%option never-interactive
        -:  146:%option yylineno
        -:  147:%option prefix="yara_yy"
        -:  148:%option outfile="lex.yy.c"
        -:  149:
        -:  150:%option verbose
        -:  151:%option warn
        -:  152:
        -:  153:%x str
        -:  154:%x regexp
        -:  155:%x include
        -:  156:%x comment
        -:  157:
        -:  158:digit         [0-9]
        -:  159:letter        [a-zA-Z]
        -:  160:hexdigit      [a-fA-F0-9]
        -:  161:octdigit      [0-7]
        -:  162:
        -:  163:%%
        -:  164:
    #####:  165:".."                    { return _DOT_DOT_;     }
    #####:  166:"<"                     { return _LT_;          }
    #####:  167:">"                     { return _GT_;          }
    #####:  168:"<="                    { return _LE_;          }
    #####:  169:">="                    { return _GE_;          }
    #####:  170:"=="                    { return _EQ_;          }
    #####:  171:"!="                    { return _NEQ_;         }
    #####:  172:"<<"                    { return _SHIFT_LEFT_;  }
    #####:  173:">>"                    { return _SHIFT_RIGHT_; }
    #####:  174:"private"               { return _PRIVATE_;     }
    #####:  175:"global"                { return _GLOBAL_;      }
    #####:  176:"rule"                  { return _RULE_;        }
       8*:  177:"meta"                  { return _META_;        }
    #####:  178:"strings"               { return _STRINGS_;     }
       6*:  179:"ascii"                 { return _ASCII_;       }
    #####:  180:"wide"                  { return _WIDE_;        }
    #####:  181:"xor"                   { return _XOR_;         }
       5*:  182:"base64"                { return _BASE64_;      }
    #####:  183:"base64wide"            { return _BASE64_WIDE_; }
    #####:  184:"fullword"              { return _FULLWORD_;    }
    #####:  185:"nocase"                { return _NOCASE_;      }
    #####:  186:"condition"             { return _CONDITION_;   }
       6*:  187:"true"                  { return _TRUE_;        }
    #####:  188:"false"                 { return _FALSE_;       }
    #####:  189:"not"                   { return _NOT_;         }
    #####:  190:"and"                   { return _AND_;         }
    #####:  191:"or"                    { return _OR_;          }
    #####:  192:"at"                    { return _AT_;          }
    #####:  193:"in"                    { return _IN_;          }
    #####:  194:"of"                    { return _OF_;          }
        1:  195:"them"                  { return _THEM_;        }
       1*:  196:"for"                   { return _FOR_;         }
    #####:  197:"all"                   { return _ALL_;         }
       1*:  198:"any"                   { return _ANY_;         }
    #####:  199:"entrypoint"            { return _ENTRYPOINT_;  }
    #####:  200:"filesize"              { return _FILESIZE_;    }
    #####:  201:"matches"               { return _MATCHES_;     }
    #####:  202:"contains"              { return _CONTAINS_;    }
    #####:  203:"import"                { return _IMPORT_;      }
    #####:  204:
    #####:  205:
    #####:  206:"/*"                    { BEGIN(comment);       }
    #####:  207:<comment>"*/"           { BEGIN(INITIAL);       }
    #####:  208:<comment>(.|\n)         { /* skip comments */   }
    #####:  209:
    #####:  210:
        -:  211:"//"[^\n]*              { /* skip single-line comments */ }
    #####:  212:
    #####:  213:
        -:  214:include[ \t]+\"         {
    #####:  215:                          yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  216:                          yyextra->lex_buf_len = 0;
    #####:  217:                          BEGIN(include);
        -:  218:                        }
    #####:  219:
    #####:  220:
    #####:  221:<include>[^\"]+         { yytext_to_buffer; }
    #####:  222:
    #####:  223:
        -:  224:<include>\"             {
        -:  225:
    #####:  226:  if (compiler->include_callback != NULL)
        -:  227:  {
        -:  228:    #ifdef _MSC_VER
        -:  229:    char* b = NULL;
        -:  230:    #endif
    #####:  231:    char* s = NULL;
        -:  232:    char* f;
        -:  233:
        -:  234:    char buffer[1024];
        -:  235:    const char* included_rules;
        -:  236:    char* current_file_name;
        -:  237:    char* include_path;
        -:  238:
    #####:  239:    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path
        -:  240:
    #####:  241:    current_file_name = yr_compiler_get_current_file_name(compiler);
        -:  242:
    #####:  243:    if (current_file_name == NULL ||
    #####:  244:        compiler->include_callback != _yr_compiler_default_include_callback ||
    #####:  245:        is_absolute_path(yyextra->lex_buf))
        -:  246:    {
    #####:  247:      include_path = yyextra->lex_buf;
        -:  248:    }
        -:  249:    else
        -:  250:    {
    #####:  251:      strlcpy(buffer, current_file_name, sizeof(buffer));
    #####:  252:      s = strrchr(buffer, '/');
        -:  253:
        -:  254:      #ifdef _MSC_VER
        -:  255:      b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
        -:  256:      #endif
        -:  257:
        -:  258:      #ifdef _MSC_VER
        -:  259:      if (s != NULL || b != NULL)
        -:  260:      #else
    #####:  261:      if (s != NULL)
        -:  262:      #endif
        -:  263:      {
        -:  264:        #ifdef _MSC_VER
        -:  265:        f = (b > s) ? (b + 1) : (s + 1);
        -:  266:        #else
    #####:  267:        f = s + 1;
        -:  268:        #endif
        -:  269:
    #####:  270:        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));
    #####:  271:        include_path = buffer;
        -:  272:      }
        -:  273:      else
        -:  274:      {
    #####:  275:        include_path = yyextra->lex_buf;
        -:  276:      }
        -:  277:    }
        -:  278:
    #####:  279:    YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(
        -:  280:        compiler->arena,
        -:  281:        YR_NAMESPACES_TABLE,
    #####:  282:        compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));
        -:  283:
    #####:  284:    included_rules = compiler->include_callback(
        -:  285:        include_path,
        -:  286:        current_file_name,
        -:  287:        ns->name,
        -:  288:        compiler->incl_clbk_user_data);
        -:  289:
    #####:  290:    if (included_rules != NULL)
        -:  291:    {
    #####:  292:      int error_code = _yr_compiler_push_file_name(compiler, include_path);
        -:  293:
    #####:  294:      if (error_code != ERROR_SUCCESS)
        -:  295:      {
    #####:  296:        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        -:  297:        {
    #####:  298:          yyerror(yyscanner, compiler, "includes circular reference");
        -:  299:        }
    #####:  300:        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        -:  301:        {
    #####:  302:          yyerror(yyscanner, compiler, "includes depth exceeded");
        -:  303:        }
        -:  304:
    #####:  305:        if (compiler->include_free != NULL)
        -:  306:        {
    #####:  307:          compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  308:        }
        -:  309:
    #####:  310:        yyterminate();
        -:  311:      }
        -:  312:
        -:  313:      // Workaround for flex issue: https://github.com/westes/flex/issues/58
    #####:  314:      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);
    #####:  315:      yy_scan_string(included_rules, yyscanner);
    #####:  316:      yyset_lineno(1, yyscanner);
        -:  317:
    #####:  318:      if (compiler->include_free != NULL)
        -:  319:      {
    #####:  320:        compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  321:      }
        -:  322:    }
        -:  323:    else
        -:  324:    {
        -:  325:      char* err_msg_fmt;
        -:  326:      char err_msg[512];
        -:  327:
    #####:  328:      if (compiler->include_callback == _yr_compiler_default_include_callback)
        -:  329:      {
    #####:  330:        err_msg_fmt = "can't open include file: %s";
        -:  331:      }
        -:  332:      else
        -:  333:      {
    #####:  334:        err_msg_fmt = "callback failed to provide include resource: %s";
        -:  335:      }
        -:  336:
    #####:  337:      snprintf(
        -:  338:          err_msg,
        -:  339:          sizeof(err_msg),
        -:  340:          err_msg_fmt,
    #####:  341:          yyextra->lex_buf);
        -:  342:
    #####:  343:      yyerror(yyscanner, compiler, err_msg);
        -:  344:    }
        -:  345:
        -:  346:  }
        -:  347:  else // not allowing includes
        -:  348:  {
    #####:  349:    yyerror(yyscanner, compiler, "includes are disabled");
        -:  350:  }
        -:  351:
    #####:  352:  BEGIN(INITIAL);
        -:  353:}
    #####:  354:
        6:  355:
        -:  356:<<EOF>> {
        -:  357:
        6:  358:  yypop_buffer_state(yyscanner);
        -:  359:
        6:  360:  if (!YY_CURRENT_BUFFER)
        6:  361:    yyterminate();
        -:  362:
    #####:  363:  return _END_OF_INCLUDED_FILE_;
        -:  364:}
        -:  365:
    #####:  366:
        -:  367:$({letter}|{digit}|_)*"*"  {
        -:  368:
    #####:  369:  yylval->c_string = yr_strdup(yytext);
        -:  370:
    #####:  371:  if (yylval->c_string == NULL)
    #####:  372:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  373:
    #####:  374:  return _STRING_IDENTIFIER_WITH_WILDCARD_;
        -:  375:}
        -:  376:
       12:  377:
        -:  378:$({letter}|{digit}|_)*  {
        -:  379:
       12:  380:  yylval->c_string = yr_strdup(yytext);
        -:  381:
       12:  382:  if (yylval->c_string == NULL)
    #####:  383:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  384:
       12:  385:  return _STRING_IDENTIFIER_;
        -:  386:}
        -:  387:
    #####:  388:
        -:  389:#({letter}|{digit}|_)*  {
        -:  390:
    #####:  391:  yylval->c_string = yr_strdup(yytext);
        -:  392:
    #####:  393:  if (yylval->c_string == NULL)
        -:  394:  {
    #####:  395:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  396:  }
        -:  397:  else
        -:  398:  {
    #####:  399:    yylval->c_string[0] = '$'; /* replace # by $*/
        -:  400:  }
        -:  401:
    #####:  402:  return _STRING_COUNT_;
        -:  403:}
        -:  404:
    #####:  405:
        -:  406:@({letter}|{digit}|_)*  {
        -:  407:
    #####:  408:  yylval->c_string = yr_strdup(yytext);
        -:  409:
    #####:  410:  if (yylval->c_string == NULL)
        -:  411:  {
    #####:  412:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  413:  }
        -:  414:  else
        -:  415:  {
    #####:  416:    yylval->c_string[0] = '$'; /* replace @ by $*/
        -:  417:  }
        -:  418:
    #####:  419:  return _STRING_OFFSET_;
        -:  420:}
        -:  421:
    #####:  422:
        -:  423:!({letter}|{digit}|_)*  {
        -:  424:
    #####:  425:  yylval->c_string = yr_strdup(yytext);
        -:  426:
    #####:  427:  if (yylval->c_string == NULL)
        -:  428:  {
    #####:  429:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  430:  }
        -:  431:  else
        -:  432:  {
    #####:  433:    yylval->c_string[0] = '$'; /* replace ! by $*/
        -:  434:  }
        -:  435:
    #####:  436:  return _STRING_LENGTH_;
        -:  437:}
        -:  438:
    #####:  439:
        -:  440:u?int(8|16|32)(be)? {
        -:  441:
    #####:  442:  char* text = yytext;
        -:  443:
    #####:  444:  if (*text == 'u')
        -:  445:  {
    #####:  446:    yylval->integer = 3;
    #####:  447:    text++;
        -:  448:  }
        -:  449:  else
        -:  450:  {
    #####:  451:    yylval->integer = 0;
        -:  452:  }
        -:  453:
    #####:  454:  if (strstr(text, "int8") == text)
        -:  455:  {
    #####:  456:    yylval->integer += 0;
    #####:  457:    text += 4;
        -:  458:  }
    #####:  459:  else if (strstr(text, "int16") == text)
        -:  460:  {
    #####:  461:    yylval->integer += 1;
    #####:  462:    text += 5;
        -:  463:  }
    #####:  464:  else if (strstr(text, "int32") == text)
        -:  465:  {
    #####:  466:    yylval->integer += 2;
    #####:  467:    text += 5;
        -:  468:  }
        -:  469:
    #####:  470:  if (strcmp(text, "be") == 0)
        -:  471:  {
    #####:  472:    yylval->integer += 6;
        -:  473:  }
        -:  474:
    #####:  475:  return _INTEGER_FUNCTION_;
        -:  476:}
        -:  477:
        8:  478:
        -:  479:({letter}|_)({letter}|{digit}|_)*  {
        -:  480:
        8:  481:  if (strlen(yytext) > 128)
    #####:  482:    syntax_error("identifier too long");
        -:  483:
        8:  484:  yylval->c_string = yr_strdup(yytext);
        -:  485:
        8:  486:  if (yylval->c_string == NULL)
    #####:  487:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  488:
        8:  489:  return _IDENTIFIER_;
        -:  490:}
        -:  491:
    #####:  492:
        -:  493:{digit}+(MB|KB){0,1}  {
        -:  494:
        -:  495:  char *endptr;
        -:  496:
    #####:  497:  errno = 0;
    #####:  498:  yylval->integer = strtoll(yytext, &endptr, 10);
        -:  499:
    #####:  500:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  501:  {
    #####:  502:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  503:    error(ERROR_INTEGER_OVERFLOW);
        -:  504:  }
    #####:  505:  else if (strstr(yytext, "KB") != NULL)
        -:  506:  {
    #####:  507:    if (yylval->integer > LLONG_MAX / 1024)
        -:  508:    {
    #####:  509:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  510:      error(ERROR_INTEGER_OVERFLOW);
        -:  511:    }
        -:  512:    else
        -:  513:    {
    #####:  514:      yylval->integer *= 1024;
        -:  515:    }
        -:  516:  }
    #####:  517:  else if (strstr(yytext, "MB") != NULL)
        -:  518:  {
    #####:  519:    if (yylval->integer > LLONG_MAX / 1048576)
        -:  520:    {
    #####:  521:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  522:      error(ERROR_INTEGER_OVERFLOW);
        -:  523:    }
        -:  524:    else
        -:  525:    {
    #####:  526:      yylval->integer *= 1048576;
        -:  527:    }
        -:  528:  }
        -:  529:
    #####:  530:  return _NUMBER_;
        -:  531:}
        -:  532:
    #####:  533:{digit}+"."{digit}+  {
    #####:  534:  yylval->double_ = atof(yytext);
    #####:  535:  return _DOUBLE_;
        -:  536:}
        -:  537:
    #####:  538:0x{hexdigit}+  {
        -:  539:
        -:  540:  char *endptr;
        -:  541:
    #####:  542:  errno = 0;
    #####:  543:  yylval->integer = strtoll(yytext, &endptr, 16);
        -:  544:
    #####:  545:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  546:  {
    #####:  547:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  548:    error(ERROR_INTEGER_OVERFLOW);
        -:  549:  }
        -:  550:
    #####:  551:  return _NUMBER_;
        -:  552:}
        -:  553:
    #####:  554:0o{octdigit}+  {
        -:  555:
        -:  556:  char *endptr;
        -:  557:
    #####:  558:  errno = 0;
    #####:  559:  yylval->integer = strtoll(yytext + 2, &endptr, 8);
        -:  560:
    #####:  561:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  562:  {
    #####:  563:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  564:    error(ERROR_INTEGER_OVERFLOW);
        -:  565:  }
        -:  566:
    #####:  567:  return _NUMBER_;
        -:  568:}
        -:  569:
        2:  570:
        -:  571:<str>\"   {     /* saw closing quote - all done */
        -:  572:
       2*:  573:  alloc_sized_string(s, yyextra->lex_buf_len);
        -:  574:
        2:  575:  *yyextra->lex_buf_ptr = '\0';
        2:  576:  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
        2:  577:  yylval->sized_string = s;
        -:  578:
        2:  579:  BEGIN(INITIAL);
        -:  580:
        2:  581:  return _TEXT_STRING_;
        -:  582:}
        -:  583:
    #####:  584:
        -:  585:<str>\\t   {
        -:  586:
    #####:  587:  lex_check_space_ok("\t", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  588:  *yyextra->lex_buf_ptr++ = '\t';
    #####:  589:  yyextra->lex_buf_len++;
        -:  590:}
    #####:  591:
    #####:  592:
        -:  593:<str>\\n   {
        -:  594:
    #####:  595:  lex_check_space_ok("\n", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  596:  *yyextra->lex_buf_ptr++ = '\n';
    #####:  597:  yyextra->lex_buf_len++;
        -:  598:}
    #####:  599:
    #####:  600:
        -:  601:<str>\\\"   {
        -:  602:
    #####:  603:  lex_check_space_ok("\"", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  604:  *yyextra->lex_buf_ptr++ = '\"';
    #####:  605:  yyextra->lex_buf_len++;
        -:  606:}
    #####:  607:
    #####:  608:
        -:  609:<str>\\\\   {
        -:  610:
    #####:  611:  lex_check_space_ok("\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  612:  *yyextra->lex_buf_ptr++ = '\\';
    #####:  613:  yyextra->lex_buf_len++;
        -:  614:}
    #####:  615:
    #####:  616:
        -:  617:<str>\\x{hexdigit}{2} {
        -:  618:
        -:  619:   int result;
        -:  620:
    #####:  621:   sscanf( yytext + 2, "%x", &result );
    #####:  622:   lex_check_space_ok("X", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  623:   *yyextra->lex_buf_ptr++ = result;
    #####:  624:   yyextra->lex_buf_len++;
        -:  625:}
    #####:  626:
        2:  627:
       4*:  628:<str>[^\\\n\"]+   { yytext_to_buffer; }
        2:  629:
    #####:  630:
        -:  631:<str>\n  {
    #####:  632:  syntax_error("unterminated string");
        -:  633:}
        -:  634:
    #####:  635:
        -:  636:<str>\\(.|\n) {
    #####:  637:  syntax_error("illegal escape sequence");
        -:  638:}
        -:  639:
        2:  640:
        -:  641:<regexp>\/i?s?  {
        -:  642:
        2:  643:  if (yyextra->lex_buf_len > 0)
        -:  644:  {
       2*:  645:    alloc_sized_string(s, yyextra->lex_buf_len);
        -:  646:
        2:  647:    if (yytext[1] == 'i')
    #####:  648:      s->flags |= SIZED_STRING_FLAGS_NO_CASE;
        -:  649:
        2:  650:    if (yytext[1] == 's' || yytext[2] == 's')
    #####:  651:      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;
        -:  652:
        2:  653:    *yyextra->lex_buf_ptr = '\0';
        2:  654:    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
        2:  655:    yylval->sized_string = s;
        -:  656:  }
        -:  657:  else
        -:  658:  {
    #####:  659:    syntax_error("empty regular expression");
        -:  660:  }
        -:  661:
        2:  662:  BEGIN(INITIAL);
        2:  663:  return _REGEXP_;
        -:  664:}
        -:  665:
    #####:  666:
        -:  667:<regexp>\\\/  {
        -:  668:
    #####:  669:  lex_check_space_ok("/", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  670:  *yyextra->lex_buf_ptr++ = '/';
    #####:  671:  yyextra->lex_buf_len++ ;
        -:  672:}
    #####:  673:
    #####:  674:
        -:  675:<regexp>\\. {
        -:  676:
    #####:  677:  lex_check_space_ok("\\.", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -:  678:
    #####:  679:  if (yytext[1] == 0)
    #####:  680:    syntax_error("malformed regular expression");
        -:  681:
    #####:  682:  *yyextra->lex_buf_ptr++ = yytext[0];
    #####:  683:  *yyextra->lex_buf_ptr++ = yytext[1];
    #####:  684:  yyextra->lex_buf_len += 2;
        -:  685:}
    #####:  686:
        2:  687:
       8*:  688:<regexp>[^/\n\\]+ { yytext_to_buffer; }
        2:  689:
    #####:  690:
        -:  691:<regexp>\n  {
    #####:  692:  syntax_error("unterminated regular expression");
        -:  693:}
        -:  694:
        2:  695:
        -:  696:\"  {
        -:  697:
        2:  698:  yylval->sized_string = NULL;
        2:  699:  yyextra->lex_buf_ptr = yyextra->lex_buf;
        2:  700:  yyextra->lex_buf_len = 0;
        2:  701:  BEGIN(str);
        -:  702:}
        2:  703:
        2:  704:
        -:  705:"/"  {
        -:  706:
        2:  707:  yylval->sized_string = NULL;
        2:  708:  yyextra->lex_buf_ptr = yyextra->lex_buf;
        2:  709:  yyextra->lex_buf_len = 0;
        2:  710:  BEGIN(regexp);
        -:  711:}
        2:  712:
        3:  713:
        -:  714:\{(({hexdigit}|[ \-|\?\[\]\(\)\n\r\t]|\/\*(\/|\**[^*/])*\*+\/)+|\/\/.*)+\}  {
        -:  715:  // Match hex-digits with whitespace or comments. The latter are stripped
        -:  716:  // out by hex_lexer.l
        -:  717:  // TODO(vmalvarez): Integrate the hex string lexer and parser into this one,
        -:  718:  // by having a single lexer/parser instead of two different ones we can avoid
        -:  719:  // complex regular expressions like the one above, which is actually trying to
        -:  720:  // do some parsing in the lexer.
        -:  721:
       3*:  722:  alloc_sized_string(s, strlen(yytext));
        -:  723:
        3:  724:  strlcpy(s->c_string, yytext, s->length + 1);
        3:  725:  yylval->sized_string = s;
        -:  726:
        3:  727:  return _HEX_STRING_;
        -:  728:}
        -:  729:
       67:  730:
        -:  731:[ \t\r\n]   /* skip whitespace */
       67:  732:
       31:  733:.   {
        -:  734:
       31:  735:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  736:  {
       31:  737:    return yytext[0];
        -:  738:  }
        -:  739:  else
        -:  740:  {
    #####:  741:    syntax_error("non-ascii character");
        -:  742:  }
        -:  743:}
        -:  744:
    #####:  745:%%
    #####:  746:
        -:  747:
        2:  748:void yywarning(
        -:  749:    yyscan_t yyscanner,
        -:  750:    const char *message_fmt,
        -:  751:    ...)
        -:  752:{
        2:  753:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  754:
        -:  755:  char* file_name;
        -:  756:  char message[512];
        -:  757:  va_list message_args;
        -:  758:
        2:  759:  if (compiler->callback == NULL)
    #####:  760:    return;
        -:  761:
        2:  762:  va_start(message_args, message_fmt);
        -:  763:
        2:  764:  if (compiler->file_name_stack_ptr > 0)
    #####:  765:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  766:  else
        2:  767:    file_name = NULL;
        -:  768:
        2:  769:  vsnprintf(message, sizeof(message), message_fmt, message_args);
        -:  770:
        2:  771:  YR_RULE* current_rule = NULL;
        -:  772:
        2:  773:  if (compiler->current_rule_idx != UINT32_MAX)
        2:  774:    current_rule = yr_arena_get_ptr(
        -:  775:        compiler->arena,
        -:  776:        YR_RULES_TABLE,
        2:  777:        compiler->current_rule_idx * sizeof(YR_RULE));
        -:  778:
        2:  779:  compiler->callback(
        -:  780:      YARA_ERROR_LEVEL_WARNING,
        -:  781:      file_name,
       2*:  782:      compiler->current_line ? compiler->current_line : yyget_lineno(yyscanner),
        -:  783:      current_rule,
        -:  784:      message,
        -:  785:      compiler->user_data);
        -:  786:
        2:  787:  va_end(message_args);
        -:  788:}
        -:  789:
        -:  790:
    #####:  791:void yyfatal(
        -:  792:    yyscan_t yyscanner,
        -:  793:    const char *error_message)
        -:  794:{
    #####:  795:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  796:
    #####:  797:  yyerror(yyscanner, compiler, error_message);
    #####:  798:  longjmp(compiler->error_recovery, 1);
        -:  799:}
        -:  800:
        -:  801:
        8:  802:void yyerror(
        -:  803:    yyscan_t yyscanner,
        -:  804:    YR_COMPILER* compiler,
        -:  805:    const char *error_message)
        -:  806:{
        8:  807:  char message[512] = {'\0'};
        8:  808:  char* file_name = NULL;
        -:  809:
        -:  810:  /*
        -:  811:    if error_message != NULL the error comes from yyparse internal code
        -:  812:    else the error comes from my code and the error code is set in
        -:  813:    compiler->last_error
        -:  814:  */
        -:  815:
        8:  816:  compiler->errors++;
        -:  817:
        8:  818:  if (compiler->current_line != 0)
        1:  819:    compiler->last_error_line = compiler->current_line;
        -:  820:  else
        7:  821:    compiler->last_error_line = yyget_lineno(yyscanner);
        -:  822:
        8:  823:  compiler->current_line = 0;
        -:  824:
        8:  825:  if (compiler->file_name_stack_ptr > 0)
        -:  826:  {
    #####:  827:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  828:  }
        -:  829:  else
        -:  830:  {
        8:  831:    file_name = NULL;
        -:  832:  }
        -:  833:
        8:  834:  YR_RULE* current_rule = NULL;
        -:  835:
        8:  836:  if (compiler->current_rule_idx != UINT32_MAX)
        8:  837:    current_rule = yr_arena_get_ptr(
        -:  838:        compiler->arena,
        -:  839:        YR_RULES_TABLE,
        8:  840:        compiler->current_rule_idx * sizeof(YR_RULE));
        -:  841:
        7:  842:  if (error_message != NULL)
        -:  843:  {
        6:  844:    yr_compiler_set_error_extra_info(compiler, error_message);
        6:  845:    compiler->last_error = ERROR_SYNTAX_ERROR;
        -:  846:
        6:  847:    if (compiler->callback != NULL)
        -:  848:    {
        6:  849:      compiler->callback(
        -:  850:          YARA_ERROR_LEVEL_ERROR,
        -:  851:          file_name,
        -:  852:          compiler->last_error_line,
        -:  853:          current_rule,
        -:  854:          error_message,
        -:  855:          compiler->user_data);
        -:  856:    }
        -:  857:  }
        1:  858:  else if (compiler->callback != NULL)
        -:  859:  {
        1:  860:    yr_compiler_get_error_message(compiler, message, sizeof(message));
        -:  861:
        1:  862:    compiler->callback(
        -:  863:        YARA_ERROR_LEVEL_ERROR,
        -:  864:        file_name,
        -:  865:        compiler->last_error_line,
        -:  866:        current_rule,
        -:  867:        message,
        -:  868:        compiler->user_data);
        -:  869:  }
        7:  870:}
        -:  871:
        -:  872:
        7:  873:int yr_lex_parse_rules_string(
        -:  874:    const char* rules_string,
        -:  875:    YR_COMPILER* compiler)
        -:  876:{
        -:  877:  yyscan_t yyscanner;
        -:  878:
        7:  879:  compiler->errors = 0;
        -:  880:
        7:  881:  if (setjmp(compiler->error_recovery) != 0)
    #####:  882:    return compiler->errors;
        -:  883:
        7:  884:  yylex_init(&yyscanner);
        -:  885:
        -:  886:  #if YYDEBUG
        -:  887:  yydebug = 1;
        -:  888:  #endif
        -:  889:
        7:  890:  yyset_extra(compiler, yyscanner);
        7:  891:  yy_scan_string(rules_string, yyscanner);
        7:  892:  yyset_lineno(1, yyscanner);
        7:  893:  yyparse(yyscanner, compiler);
        6:  894:  yylex_destroy(yyscanner);
        -:  895:
        6:  896:  return compiler->errors;
        -:  897:}
        -:  898:
        -:  899:
    #####:  900:int yr_lex_parse_rules_file(
        -:  901:    FILE* rules_file,
        -:  902:    YR_COMPILER* compiler)
        -:  903:{
        -:  904:  yyscan_t yyscanner;
        -:  905:
    #####:  906:  compiler->errors = 0;
        -:  907:
    #####:  908:  if (setjmp(compiler->error_recovery) != 0)
    #####:  909:    return compiler->errors;
        -:  910:
    #####:  911:  yylex_init(&yyscanner);
        -:  912:
        -:  913:  #if YYDEBUG
        -:  914:  yydebug = 1;
        -:  915:  #endif
        -:  916:
    #####:  917:  yyset_in(rules_file, yyscanner);
    #####:  918:  yyset_extra(compiler, yyscanner);
    #####:  919:  yyparse(yyscanner, compiler);
    #####:  920:  yylex_destroy(yyscanner);
        -:  921:
    #####:  922:  return compiler->errors;
        -:  923:}
        -:  924:
        -:  925:
    #####:  926:int yr_lex_parse_rules_fd(
        -:  927:    YR_FILE_DESCRIPTOR rules_fd,
        -:  928:    YR_COMPILER* compiler)
        -:  929:{
        -:  930:  yyscan_t yyscanner;
        -:  931:  size_t file_size;
        -:  932:  void* buffer;
        -:  933:
        -:  934:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  935:  DWORD bytes_read;
        -:  936:  #endif
        -:  937:
    #####:  938:  compiler->errors = 0;
        -:  939:
    #####:  940:  if (setjmp(compiler->error_recovery) != 0)
    #####:  941:    return compiler->errors;
        -:  942:
        -:  943:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  944:  file_size = (size_t) GetFileSize(rules_fd, NULL);
        -:  945:  #else
        -:  946:  struct stat fs;
    #####:  947:  if (fstat(rules_fd, &fs) != 0)
        -:  948:  {
    #####:  949:    compiler->errors = 1;
    #####:  950:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  951:    return compiler->errors;
        -:  952:  }
    #####:  953:  file_size = (size_t) fs.st_size;
        -:  954:  #endif
        -:  955:
    #####:  956:  buffer = yr_malloc(file_size);
        -:  957:
    #####:  958:  if (buffer == NULL)
        -:  959:  {
    #####:  960:    compiler->errors = 1;
    #####:  961:    compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
    #####:  962:    return compiler->errors;
        -:  963:  }
        -:  964:
        -:  965:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  966:  if (!ReadFile(rules_fd, buffer, file_size, &bytes_read, NULL))
        -:  967:  #else
    #####:  968:  if (read(rules_fd, buffer, file_size) != file_size)
        -:  969:  #endif
        -:  970:  {
    #####:  971:    yr_free(buffer);
    #####:  972:    compiler->errors = 1;
    #####:  973:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  974:    return compiler->errors;
        -:  975:  }
        -:  976:
    #####:  977:  yylex_init(&yyscanner);
        -:  978:
        -:  979:  #if YYDEBUG
        -:  980:  yydebug = 1;
        -:  981:  #endif
        -:  982:
    #####:  983:  yyset_extra(compiler, yyscanner);
    #####:  984:  yy_scan_bytes((const char*) buffer, (int) file_size, yyscanner);
    #####:  985:  yyset_lineno(1, yyscanner);
    #####:  986:  yyparse(yyscanner, compiler);
    #####:  987:  yylex_destroy(yyscanner);
        -:  988:
    #####:  989:  yr_free(buffer);
        -:  990:
    #####:  991:  return compiler->errors;
        -:  992:}
