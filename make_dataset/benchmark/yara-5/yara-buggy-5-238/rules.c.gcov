        -:    0:Source:rules.c
        -:    0:Graph:/home/workspace/libyara/rules.gcno
        -:    0:Data:/home/workspace/libyara/rules.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:
        -:   34:#include <yara/error.h>
        -:   35:#include <yara/filemap.h>
        -:   36:#include <yara/mem.h>
        -:   37:#include <yara/proc.h>
        -:   38:#include <yara/rules.h>
        -:   39:#include <yara/utils.h>
        -:   40:#include <yara/globals.h>
        -:   41:#include <yara/scan.h>
        -:   42:#include <yara/scanner.h>
        -:   43:#include <yara/compiler.h>
        -:   44:
        -:   45:
    #####:   46:YR_API int yr_rules_define_integer_variable(
        -:   47:    YR_RULES* rules,
        -:   48:    const char* identifier,
        -:   49:    int64_t value)
        -:   50:{
        -:   51:  YR_EXTERNAL_VARIABLE* external;
        -:   52:
    #####:   53:  if (identifier == NULL)
    #####:   54:    return ERROR_INVALID_ARGUMENT;
        -:   55:
    #####:   56:  external = rules->externals_list_head;
        -:   57:
    #####:   58:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   59:  {
    #####:   60:    if (strcmp(external->identifier, identifier) == 0)
        -:   61:    {
    #####:   62:      if (external->type != EXTERNAL_VARIABLE_TYPE_INTEGER)
    #####:   63:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   64:
    #####:   65:      external->value.i = value;
    #####:   66:      return ERROR_SUCCESS;
        -:   67:    }
        -:   68:
    #####:   69:    external++;
        -:   70:  }
        -:   71:
    #####:   72:  return ERROR_INVALID_ARGUMENT;
        -:   73:}
        -:   74:
        -:   75:
    #####:   76:YR_API int yr_rules_define_boolean_variable(
        -:   77:    YR_RULES* rules,
        -:   78:    const char* identifier,
        -:   79:    int value)
        -:   80:{
        -:   81:  YR_EXTERNAL_VARIABLE* external;
        -:   82:
    #####:   83:  if (identifier == NULL)
    #####:   84:    return ERROR_INVALID_ARGUMENT;
        -:   85:
    #####:   86:  external = rules->externals_list_head;
        -:   87:
    #####:   88:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   89:  {
    #####:   90:    if (strcmp(external->identifier, identifier) == 0)
        -:   91:    {
    #####:   92:      if (external->type != EXTERNAL_VARIABLE_TYPE_BOOLEAN)
    #####:   93:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   94:
    #####:   95:      external->value.i = value;
    #####:   96:      return ERROR_SUCCESS;
        -:   97:    }
        -:   98:
    #####:   99:    external++;
        -:  100:  }
        -:  101:
    #####:  102:  return ERROR_INVALID_ARGUMENT;
        -:  103:}
        -:  104:
        -:  105:
    #####:  106:YR_API int yr_rules_define_float_variable(
        -:  107:    YR_RULES* rules,
        -:  108:    const char* identifier,
        -:  109:    double value)
        -:  110:{
        -:  111:  YR_EXTERNAL_VARIABLE* external;
        -:  112:
    #####:  113:  if (identifier == NULL)
    #####:  114:    return ERROR_INVALID_ARGUMENT;
        -:  115:
    #####:  116:  external = rules->externals_list_head;
        -:  117:
    #####:  118:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  119:  {
    #####:  120:    if (strcmp(external->identifier, identifier) == 0)
        -:  121:    {
    #####:  122:      if (external->type != EXTERNAL_VARIABLE_TYPE_FLOAT)
    #####:  123:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  124:
    #####:  125:      external->value.f = value;
    #####:  126:      return ERROR_SUCCESS;
        -:  127:    }
        -:  128:
    #####:  129:    external++;
        -:  130:  }
        -:  131:
    #####:  132:  return ERROR_INVALID_ARGUMENT;
        -:  133:}
        -:  134:
        -:  135:
    #####:  136:YR_API int yr_rules_define_string_variable(
        -:  137:    YR_RULES* rules,
        -:  138:    const char* identifier,
        -:  139:    const char* value)
        -:  140:{
        -:  141:  YR_EXTERNAL_VARIABLE* external;
        -:  142:
    #####:  143:  if (identifier == NULL || value == NULL)
    #####:  144:    return ERROR_INVALID_ARGUMENT;
        -:  145:
    #####:  146:  external = rules->externals_list_head;
        -:  147:
    #####:  148:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  149:  {
    #####:  150:    if (strcmp(external->identifier, identifier) == 0)
        -:  151:    {
    #####:  152:      if (external->type != EXTERNAL_VARIABLE_TYPE_STRING &&
    #####:  153:          external->type != EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  154:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  155:
    #####:  156:      if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING &&
    #####:  157:          external->value.s != NULL)
        -:  158:      {
    #####:  159:        yr_free(external->value.s);
        -:  160:      }
        -:  161:
    #####:  162:      external->type = EXTERNAL_VARIABLE_TYPE_MALLOC_STRING;
    #####:  163:      external->value.s = yr_strdup(value);
        -:  164:
    #####:  165:      if (external->value.s == NULL)
    #####:  166:        return ERROR_INSUFFICIENT_MEMORY;
        -:  167:      else
    #####:  168:        return ERROR_SUCCESS;
        -:  169:    }
        -:  170:
    #####:  171:    external++;
        -:  172:  }
        -:  173:
    #####:  174:  return ERROR_INVALID_ARGUMENT;
        -:  175:}
        -:  176:
        -:  177:
    #####:  178:YR_API int yr_rules_scan_mem_blocks(
        -:  179:    YR_RULES* rules,
        -:  180:    YR_MEMORY_BLOCK_ITERATOR* iterator,
        -:  181:    int flags,
        -:  182:    YR_CALLBACK_FUNC callback,
        -:  183:    void* user_data,
        -:  184:    int timeout)
        -:  185:{
        -:  186:  YR_SCANNER* scanner;
        -:  187:  int result;
        -:  188:
    #####:  189:  FAIL_ON_ERROR(yr_scanner_create(rules, &scanner));
        -:  190:
    #####:  191:  yr_scanner_set_callback(scanner, callback, user_data);
    #####:  192:  yr_scanner_set_timeout(scanner, timeout);
    #####:  193:  yr_scanner_set_flags(scanner, flags);
        -:  194:
    #####:  195:  result = yr_scanner_scan_mem_blocks(scanner, iterator);
        -:  196:
    #####:  197:  yr_scanner_destroy(scanner);
        -:  198:
    #####:  199:  return result;
        -:  200:}
        -:  201:
        -:  202:
    #####:  203:static YR_MEMORY_BLOCK* _yr_get_first_block(
        -:  204:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  205:{
    #####:  206:  return (YR_MEMORY_BLOCK*) iterator->context;
        -:  207:}
        -:  208:
        -:  209:
    #####:  210:static YR_MEMORY_BLOCK* _yr_get_next_block(
        -:  211:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  212:{
    #####:  213:  return NULL;
        -:  214:}
        -:  215:
        -:  216:
    #####:  217:static const uint8_t* _yr_fetch_block_data(
        -:  218:    YR_MEMORY_BLOCK* block)
        -:  219:{
    #####:  220:  return (const uint8_t*) block->context;
        -:  221:}
        -:  222:
        -:  223:
    #####:  224:YR_API int yr_rules_scan_mem(
        -:  225:    YR_RULES* rules,
        -:  226:    const uint8_t* buffer,
        -:  227:    size_t buffer_size,
        -:  228:    int flags,
        -:  229:    YR_CALLBACK_FUNC callback,
        -:  230:    void* user_data,
        -:  231:    int timeout)
        -:  232:{
        -:  233:  YR_MEMORY_BLOCK block;
        -:  234:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  235:
    #####:  236:  block.size = buffer_size;
    #####:  237:  block.base = 0;
    #####:  238:  block.fetch_data = _yr_fetch_block_data;
    #####:  239:  block.context = (void*) buffer;
        -:  240:
    #####:  241:  iterator.context = &block;
    #####:  242:  iterator.first = _yr_get_first_block;
    #####:  243:  iterator.next = _yr_get_next_block;
        -:  244:
    #####:  245:  return yr_rules_scan_mem_blocks(
        -:  246:      rules,
        -:  247:      &iterator,
        -:  248:      flags,
        -:  249:      callback,
        -:  250:      user_data,
        -:  251:      timeout);
        -:  252:}
        -:  253:
        -:  254:
    #####:  255:YR_API int yr_rules_scan_file(
        -:  256:    YR_RULES* rules,
        -:  257:    const char* filename,
        -:  258:    int flags,
        -:  259:    YR_CALLBACK_FUNC callback,
        -:  260:    void* user_data,
        -:  261:    int timeout)
        -:  262:{
        -:  263:  YR_MAPPED_FILE mfile;
        -:  264:
    #####:  265:  int result = yr_filemap_map(filename, &mfile);
        -:  266:
    #####:  267:  if (result == ERROR_SUCCESS)
        -:  268:  {
    #####:  269:    result = yr_rules_scan_mem(
        -:  270:        rules,
        -:  271:        mfile.data,
        -:  272:        mfile.size,
        -:  273:        flags,
        -:  274:        callback,
        -:  275:        user_data,
        -:  276:        timeout);
        -:  277:
    #####:  278:    yr_filemap_unmap(&mfile);
        -:  279:  }
        -:  280:
    #####:  281:  return result;
        -:  282:}
        -:  283:
        -:  284:
    #####:  285:YR_API int yr_rules_scan_fd(
        -:  286:    YR_RULES* rules,
        -:  287:    YR_FILE_DESCRIPTOR fd,
        -:  288:    int flags,
        -:  289:    YR_CALLBACK_FUNC callback,
        -:  290:    void* user_data,
        -:  291:    int timeout)
        -:  292:{
        -:  293:  YR_MAPPED_FILE mfile;
        -:  294:
    #####:  295:  int result = yr_filemap_map_fd(fd, 0, 0, &mfile);
        -:  296:
    #####:  297:  if (result == ERROR_SUCCESS)
        -:  298:  {
    #####:  299:    result = yr_rules_scan_mem(
        -:  300:        rules,
        -:  301:        mfile.data,
        -:  302:        mfile.size,
        -:  303:        flags,
        -:  304:        callback,
        -:  305:        user_data,
        -:  306:        timeout);
        -:  307:
    #####:  308:    yr_filemap_unmap_fd(&mfile);
        -:  309:  }
        -:  310:
    #####:  311:  return result;
        -:  312:}
        -:  313:
        -:  314:
    #####:  315:YR_API int yr_rules_scan_proc(
        -:  316:    YR_RULES* rules,
        -:  317:    int pid,
        -:  318:    int flags,
        -:  319:    YR_CALLBACK_FUNC callback,
        -:  320:    void* user_data,
        -:  321:    int timeout)
        -:  322:{
        -:  323:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  324:
    #####:  325:  int result = yr_process_open_iterator(
        -:  326:      pid,
        -:  327:      &iterator);
        -:  328:
    #####:  329:  if (result == ERROR_SUCCESS)
        -:  330:  {
    #####:  331:    result = yr_rules_scan_mem_blocks(
        -:  332:        rules,
        -:  333:        &iterator,
        -:  334:        flags | SCAN_FLAGS_PROCESS_MEMORY,
        -:  335:        callback,
        -:  336:        user_data,
        -:  337:        timeout);
        -:  338:
    #####:  339:    yr_process_close_iterator(&iterator);
        -:  340:  }
        -:  341:
    #####:  342:  return result;
        -:  343:}
        -:  344:
        -:  345:
    #####:  346:int yr_rules_from_arena(
        -:  347:    YR_ARENA* arena,
        -:  348:    YR_RULES** rules)
        -:  349:{
    #####:  350:  YR_RULES* new_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));
        -:  351:
    #####:  352:  if (new_rules == NULL)
    #####:  353:    return ERROR_INSUFFICIENT_MEMORY;
        -:  354:
    #####:  355:  YR_SUMMARY* summary = (YR_SUMMARY*) yr_arena_get_ptr(
        -:  356:      arena, YR_SUMMARY_SECTION, 0);
        -:  357:
        -:  358:  // Now YR_RULES relies on this arena, let's increment the arena's
        -:  359:  // reference count so that if the original owner of the arena calls
        -:  360:  // yr_arena_destroy the arena is not destroyed.
    #####:  361:  yr_arena_acquire(arena);
        -:  362:
    #####:  363:  new_rules->arena = arena;
    #####:  364:  new_rules->num_rules = summary->num_rules;
    #####:  365:  new_rules->num_strings = summary->num_strings;
    #####:  366:  new_rules->num_namespaces = summary->num_namespaces;
        -:  367:
    #####:  368:  new_rules->rules_list_head = yr_arena_get_ptr(
        -:  369:      arena, YR_RULES_TABLE, 0);
        -:  370:
    #####:  371:  new_rules->strings_list_head = yr_arena_get_ptr(
        -:  372:      arena, YR_STRINGS_TABLE, 0);
        -:  373:
    #####:  374:  new_rules->externals_list_head = yr_arena_get_ptr(
        -:  375:      arena, YR_EXTERNAL_VARIABLES_TABLE, 0);
        -:  376:
    #####:  377:  new_rules->ac_transition_table = yr_arena_get_ptr(
        -:  378:      arena, YR_AC_TRANSITION_TABLE, 0);
        -:  379:
    #####:  380:  new_rules->ac_match_table = yr_arena_get_ptr(
        -:  381:      arena, YR_AC_STATE_MATCHES_TABLE, 0);
        -:  382:
    #####:  383:  new_rules->ac_match_pool = yr_arena_get_ptr(
        -:  384:      arena, YR_AC_STATE_MATCHES_POOL, 0);
        -:  385:
    #####:  386:  new_rules->code_start = yr_arena_get_ptr(
        -:  387:      arena, YR_CODE_SECTION, 0);
        -:  388:
    #####:  389:  *rules = new_rules;
        -:  390:
    #####:  391:  return ERROR_SUCCESS;
        -:  392:}
        -:  393:
        -:  394:
        -:  395:
    #####:  396:YR_API int yr_rules_load_stream(
        -:  397:    YR_STREAM* stream,
        -:  398:    YR_RULES** rules)
        -:  399:{
        -:  400:  YR_ARENA* arena;
        -:  401:
        -:  402:  // Load the arena's data the stream. We are the owners of the arena.
    #####:  403:  FAIL_ON_ERROR(yr_arena_load_stream(stream, &arena));
        -:  404:
        -:  405:  // Create the YR_RULES object from the arena, this makes YR_RULES owner
        -:  406:  // of the arena too.
    #####:  407:  FAIL_ON_ERROR(yr_rules_from_arena(arena, rules));
        -:  408:
        -:  409:  // Release our ownership so that YR_RULES is the single owner. This way the
        -:  410:  // arena is destroyed when YR_RULES is destroyed.
    #####:  411:  yr_arena_release(arena);
        -:  412:
    #####:  413:  return ERROR_SUCCESS;
        -:  414:}
        -:  415:
        -:  416:
    #####:  417:YR_API int yr_rules_load(
        -:  418:    const char* filename,
        -:  419:    YR_RULES** rules)
        -:  420:{
        -:  421:  int result;
        -:  422:
        -:  423:  YR_STREAM stream;
    #####:  424:  FILE* fh = fopen(filename, "rb");
        -:  425:
    #####:  426:  if (fh == NULL)
    #####:  427:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  428:
    #####:  429:  stream.user_data = fh;
    #####:  430:  stream.read = (YR_STREAM_READ_FUNC) fread;
        -:  431:
    #####:  432:  result = yr_rules_load_stream(&stream, rules);
        -:  433:
    #####:  434:  fclose(fh);
    #####:  435:  return result;
        -:  436:}
        -:  437:
        -:  438:
    #####:  439:YR_API int yr_rules_save_stream(
        -:  440:    YR_RULES* rules,
        -:  441:    YR_STREAM* stream)
        -:  442:{
    #####:  443:  return yr_arena_save_stream(rules->arena, stream);
        -:  444:}
        -:  445:
        -:  446:
    #####:  447:YR_API int yr_rules_save(
        -:  448:    YR_RULES* rules,
        -:  449:    const char* filename)
        -:  450:{
        -:  451:  int result;
        -:  452:
        -:  453:  YR_STREAM stream;
    #####:  454:  FILE* fh = fopen(filename, "wb");
        -:  455:
    #####:  456:  if (fh == NULL)
    #####:  457:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  458:
    #####:  459:  stream.user_data = fh;
    #####:  460:  stream.write = (YR_STREAM_WRITE_FUNC) fwrite;
        -:  461:
    #####:  462:  result = yr_rules_save_stream(rules, &stream);
        -:  463:
    #####:  464:  fclose(fh);
    #####:  465:  return result;
        -:  466:}
        -:  467:
        -:  468:
    #####:  469:static int _uint32_cmp (
        -:  470:    const void * a,
        -:  471:    const void * b)
        -:  472:{
    #####:  473:   return (*(uint32_t*) a - *(uint32_t*) b);
        -:  474:}
        -:  475:
    #####:  476:YR_API int yr_rules_get_stats(
        -:  477:    YR_RULES* rules,
        -:  478:    YR_RULES_STATS *stats)
        -:  479:{
    #####:  480:  memset(stats, 0, sizeof(YR_RULES_STATS));
        -:  481:
    #####:  482:  stats->ac_tables_size = yr_arena_get_current_offset(
        -:  483:      rules->arena, YR_AC_TRANSITION_TABLE) / sizeof(YR_AC_TRANSITION);
        -:  484:
    #####:  485:  uint32_t* match_list_lengths = (uint32_t*) yr_malloc(
    #####:  486:      sizeof(uint32_t) * stats->ac_tables_size);
        -:  487:
    #####:  488:  if (match_list_lengths == NULL)
    #####:  489:    return ERROR_INSUFFICIENT_MEMORY;
        -:  490:
    #####:  491:  stats->num_rules = rules->num_rules;
    #####:  492:  stats->num_strings = rules->num_strings;
        -:  493:
    #####:  494:  float match_list_length_sum = 0;
    #####:  495:  int c = 0;
        -:  496:
    #####:  497:  for (int i = 0; i < stats->ac_tables_size; i++)
        -:  498:  {
    #####:  499:    int match_list_length = 0;
        -:  500:
    #####:  501:    if (rules->ac_match_table[i] != 0)
        -:  502:    {
    #####:  503:      YR_AC_MATCH *m = &rules->ac_match_pool[rules->ac_match_table[i]-1];
        -:  504:
    #####:  505:      while (m != NULL)
        -:  506:      {
    #####:  507:        match_list_length++;
    #####:  508:        stats->ac_matches++;
    #####:  509:        m = m->next;
        -:  510:      }
        -:  511:    }
        -:  512:
    #####:  513:    if (i == 0)
    #####:  514:      stats->ac_root_match_list_length = match_list_length;
        -:  515:
    #####:  516:    match_list_length_sum += match_list_length;
        -:  517:
    #####:  518:    if (match_list_length > 0)
        -:  519:    {
    #####:  520:      match_list_lengths[c] = match_list_length;
    #####:  521:      c++;
        -:  522:    }
        -:  523:  }
        -:  524:
    #####:  525:  if (c == 0)
        -:  526:  {
    #####:  527:    yr_free(match_list_lengths);
    #####:  528:    return ERROR_SUCCESS;
        -:  529:  }
        -:  530:
        -:  531:  // sort match_list_lengths in increasing order for computing percentiles.
    #####:  532:  qsort(match_list_lengths, c, sizeof(match_list_lengths[0]), _uint32_cmp);
        -:  533:
    #####:  534:  for (int i = 0; i < 100; i++)
        -:  535:  {
    #####:  536:    if (i < c)
    #####:  537:      stats->top_ac_match_list_lengths[i] = match_list_lengths[c-i-1];
        -:  538:    else
    #####:  539:      stats->top_ac_match_list_lengths[i] = 0;
        -:  540:  }
        -:  541:
    #####:  542:  stats->ac_average_match_list_length = match_list_length_sum / c;
    #####:  543:  stats->ac_match_list_length_pctls[0] = match_list_lengths[0];
    #####:  544:  stats->ac_match_list_length_pctls[100] = match_list_lengths[c-1];
        -:  545:
    #####:  546:  for (int i = 1; i < 100; i++)
    #####:  547:    stats->ac_match_list_length_pctls[i] = match_list_lengths[(c * i) / 100];
        -:  548:
    #####:  549:  yr_free(match_list_lengths);
        -:  550:
    #####:  551:  return ERROR_SUCCESS;
        -:  552:}
        -:  553:
        -:  554:
    #####:  555:YR_API int yr_rules_destroy(
        -:  556:    YR_RULES* rules)
        -:  557:{
    #####:  558:  YR_EXTERNAL_VARIABLE* external = rules->externals_list_head;
        -:  559:
    #####:  560:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  561:  {
    #####:  562:    if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  563:      yr_free(external->value.s);
        -:  564:
    #####:  565:    external++;
        -:  566:  }
        -:  567:
    #####:  568:  yr_arena_release(rules->arena);
    #####:  569:  yr_free(rules);
        -:  570:
    #####:  571:  return ERROR_SUCCESS;
        -:  572:}
        -:  573:
    #####:  574:YR_API void yr_rule_disable(
        -:  575:    YR_RULE* rule)
        -:  576:{
        -:  577:  YR_STRING* string;
        -:  578:
    #####:  579:  rule->flags |= RULE_FLAGS_DISABLED;
        -:  580:
    #####:  581:  yr_rule_strings_foreach(rule, string)
        -:  582:  {
    #####:  583:    string->flags |= STRING_FLAGS_DISABLED;
        -:  584:  }
    #####:  585:}
        -:  586:
        -:  587:
    #####:  588:YR_API void yr_rule_enable(
        -:  589:    YR_RULE* rule)
        -:  590:{
        -:  591:  YR_STRING* string;
        -:  592:
    #####:  593:  rule->flags &= ~RULE_FLAGS_DISABLED;
        -:  594:
    #####:  595:  yr_rule_strings_foreach(rule, string)
        -:  596:  {
    #####:  597:    string->flags &= ~STRING_FLAGS_DISABLED;
        -:  598:  }
    #####:  599:}
