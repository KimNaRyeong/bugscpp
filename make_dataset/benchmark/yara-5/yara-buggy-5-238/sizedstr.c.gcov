        -:    0:Source:sizedstr.c
        -:    0:Graph:/home/workspace/libyara/sizedstr.gcno
        -:    0:Data:/home/workspace/libyara/sizedstr.gcda
        -:    0:Runs:10
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <ctype.h>
        -:   31:#include <string.h>
        -:   32:#include <yara/globals.h>
        -:   33:#include <yara/mem.h>
        -:   34:#include <yara/sizedstr.h>
        -:   35:#include <yara/types.h>
        -:   36:
        -:   37:
    #####:   38:int sized_string_cmp_nocase(
        -:   39:    SIZED_STRING* s1,
        -:   40:    SIZED_STRING* s2)
        -:   41:{
    #####:   42:  size_t i = 0;
        -:   43:
    #####:   44:  while (s1->length > i &&
    #####:   45:         s2->length > i &&
    #####:   46:         yr_lowercase[(uint8_t) s1->c_string[i]] ==
    #####:   47:         yr_lowercase[(uint8_t) s2->c_string[i]])
        -:   48:  {
    #####:   49:    i++;
        -:   50:  }
        -:   51:
    #####:   52:  if (i == s1->length && i == s2->length)
    #####:   53:    return 0;
    #####:   54:  else if (i == s1->length)
    #####:   55:    return -1;
    #####:   56:  else if (i == s2->length)
    #####:   57:    return 1;
    #####:   58:  else if (s1->c_string[i] < s2->c_string[i])
    #####:   59:    return -1;
        -:   60:  else
    #####:   61:    return 1;
        -:   62:}
        -:   63:
        -:   64:
    #####:   65:int sized_string_cmp(
        -:   66:    SIZED_STRING* s1,
        -:   67:    SIZED_STRING* s2)
        -:   68:{
    #####:   69:  size_t i = 0;
        -:   70:
    #####:   71:  while (s1->length > i &&
    #####:   72:         s2->length > i &&
    #####:   73:         s1->c_string[i] == s2->c_string[i])
        -:   74:  {
    #####:   75:    i++;
        -:   76:  }
        -:   77:
    #####:   78:  if (i == s1->length && i == s2->length)
    #####:   79:    return 0;
    #####:   80:  else if (i == s1->length)
    #####:   81:    return -1;
    #####:   82:  else if (i == s2->length)
    #####:   83:    return 1;
    #####:   84:  else if (s1->c_string[i] < s2->c_string[i])
    #####:   85:    return -1;
        -:   86:  else
    #####:   87:    return 1;
        -:   88:}
        -:   89:
        -:   90:
    #####:   91:SIZED_STRING* sized_string_dup(
        -:   92:    SIZED_STRING* s)
        -:   93:{
    #####:   94:  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(
    #####:   95:      sizeof(SIZED_STRING) + s->length);
        -:   96:
    #####:   97:  if (result == NULL)
    #####:   98:    return NULL;
        -:   99:
    #####:  100:  result->length = s->length;
    #####:  101:  result->flags = s->flags;
        -:  102:
    #####:  103:  strncpy(result->c_string, s->c_string, s->length + 1);
        -:  104:
    #####:  105:  return result;
        -:  106:}
        -:  107:
        -:  108:
    #####:  109:SIZED_STRING* sized_string_new(
        -:  110:    const char* s)
        -:  111:{
        -:  112:  SIZED_STRING* result;
        -:  113:
    #####:  114:  int length = strlen(s);
        -:  115:
    #####:  116:  result = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);
        -:  117:
    #####:  118:  if (result == NULL)
    #####:  119:    return NULL;
        -:  120:
    #####:  121:  result->length = length;
    #####:  122:  result->flags = 0;
        -:  123:
        -:  124:  // Copy the string and the null terminator.
    #####:  125:  strcpy(result->c_string, s);
        -:  126:  
    #####:  127:  return result;
        -:  128:}
        -:  129:
        -:  130://
        -:  131:// Convert a SIZED_STRING to a wide version. It is up to the caller to free
        -:  132:// the returned string.
        -:  133://
        -:  134:
    #####:  135:SIZED_STRING* sized_string_convert_to_wide(
        -:  136:    SIZED_STRING* s)
        -:  137:{
        -:  138:  size_t i;
    #####:  139:  size_t j = 0;
        -:  140:
    #####:  141:  SIZED_STRING* wide = (SIZED_STRING*) yr_malloc(
    #####:  142:      sizeof(SIZED_STRING) + s->length * 2);
        -:  143:
    #####:  144:  if (wide == NULL)
    #####:  145:    return NULL;
        -:  146:
    #####:  147:  for (i = 0; i <= s->length; i++)
        -:  148:  {
    #####:  149:    wide->c_string[j++] = s->c_string[i];
    #####:  150:    wide->c_string[j++] = '\x00';
        -:  151:  }
        -:  152:
    #####:  153:  wide->length = s->length * 2;
    #####:  154:  wide->flags = s->flags | STRING_FLAGS_WIDE;
        -:  155:
    #####:  156:  return wide;
        -:  157:}
