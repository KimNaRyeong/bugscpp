        -:    0:Source:base64.c
        -:    0:Graph:/home/workspace/libyara/base64.gcno
        -:    0:Data:/home/workspace/libyara/base64.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2020. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <string.h>
        -:   31:
        -:   32:#include <yara/base64.h>
        -:   33:#include <yara/error.h>
        -:   34:#include <yara/mem.h>
        -:   35:#include <yara/re.h>
        -:   36:#include <yara/sizedstr.h>
        -:   37:
        -:   38:
        -:   39://
        -:   40:// _yr_modified_base64_encode
        -:   41://
        -:   42:// Given a pointer to a SIZED_STRING append 0, 1 or 2 bytes and base64 encode
        -:   43:// the string. The number of padding bytes is returned in "pad" and the caller
        -:   44:// is expected to trim the appropriate number of leading and trailing bytes.
        -:   45://
        -:   46:// This is based upon the ideas at:
        -:   47:// https://www.leeholmes.com/blog/2019/12/10/searching-for-content-in-base-64-strings-2/
        -:   48://
        -:   49:// The caller is responsible for freeing the returned string.
        -:   50://
    #####:   51:static SIZED_STRING* _yr_modified_base64_encode(
        -:   52:    SIZED_STRING* in,
        -:   53:    SIZED_STRING* alphabet,
        -:   54:    int i,
        -:   55:    int* pad)
        -:   56:{
    #####:   57:  uint8_t* src = (uint8_t*) in->c_string;
    #####:   58:  size_t len = in->length;
        -:   59:  SIZED_STRING* out;
        -:   60:  uint8_t* p;
        -:   61:  uint8_t* end;
    #####:   62:  char* alphabet_str = alphabet->c_string;
        -:   63:  uint8_t* tmp;
        -:   64:  int j;
        -:   65:
    #####:   66:  *pad = ((i + len) % 3) ? 3 - ((i + len) % 3) : 0;
        -:   67:
        -:   68:  // Add "i" for the number of prepended bytes.
    #####:   69:  out = (SIZED_STRING*) yr_malloc(
    #####:   70:      sizeof(SIZED_STRING) + i + ((len * 4 + 3) / 3) + *pad);
    #####:   71:  if (out == NULL)
    #####:   72:    return NULL;
        -:   73:
    #####:   74:  tmp = (uint8_t*) yr_malloc(sizeof(uint8_t) * (len + i));
    #####:   75:  if (tmp == NULL)
        -:   76:  {
    #####:   77:    yr_free(out);
    #####:   78:    return NULL;
        -:   79:  }
        -:   80:
        -:   81:  // Prepend appropriate number of bytes and copy remaining input bytes into
        -:   82:  // temporary buffer.
    #####:   83:  for (j = 0; j < i; j++)
    #####:   84:    tmp[j] = 'A';
        -:   85:
    #####:   86:  memcpy(tmp + j, src, len);
    #####:   87:  src = tmp;
        -:   88:
    #####:   89:  p = (uint8_t*) out->c_string;
    #####:   90:  end = src + len + j;
    #####:   91:  while (end - src >= 3)
        -:   92:  {
    #####:   93:    *p++ = alphabet_str[src[0] >> 2];
    #####:   94:    *p++ = alphabet_str[((src[0] & 0x03) << 4 | src[1] >> 4)];
    #####:   95:    *p++ = alphabet_str[((src[1] & 0x0f) << 2 | (src[2] >> 6))];
    #####:   96:    *p++ = alphabet_str[src[2] & 0x3f];
    #####:   97:    src += 3;
        -:   98:  }
        -:   99:
        -:  100:  // Handle remaining bytes and padding.
    #####:  101:  if (end - src)
        -:  102:  {
    #####:  103:    *p++ = alphabet_str[src[0] >> 2];
    #####:  104:    if (end - src == 1)
        -:  105:    {
    #####:  106:      *p++ = alphabet_str[(src[0] & 0x03) << 4];
    #####:  107:      *p++ = '=';
        -:  108:    }
        -:  109:    else
        -:  110:    {
    #####:  111:      *p++ = alphabet_str[((src[0] & 0x03) << 4 | src[1] >> 4)];
    #####:  112:      *p++ = alphabet_str[(src[1] & 0x0f) << 2];
        -:  113:    }
    #####:  114:    *p++ = '=';
        -:  115:  }
        -:  116:
    #####:  117:  yr_free(tmp);
    #####:  118:  out->length = p - (uint8_t*) out->c_string;
    #####:  119:  return out;
        -:  120:}
        -:  121:
        -:  122:
        -:  123://
        -:  124:// Given a base64 encoded string, return a new string with leading and trailing
        -:  125:// bytes stripped appropriately. The number of leading bytes to skip is always
        -:  126:// (i + 1) or zero when no leading bytes are added and the number of trailing
        -:  127:// bytes is always (pad + 1) or zero when pad is zero. Also, convert the final
        -:  128:// string to wide if desired.
        -:  129://
        -:  130:// Note: This implementation assumes you only prepend 0, 1 or 2 bytes.
        -:  131://
    #####:  132:static SIZED_STRING* _yr_base64_get_base64_substring(
        -:  133:    SIZED_STRING* encoded_str,
        -:  134:    int wide,
        -:  135:    int i,
        -:  136:    int pad)
        -:  137:{
        -:  138:  SIZED_STRING* new_str;
        -:  139:  SIZED_STRING* final_str;
        -:  140:  char* start;
        -:  141:  uint32_t length;
        -:  142:  int trailing;
        -:  143:  int leading;
        -:  144:
    #####:  145:  trailing = pad ? pad + 1 : 0;
    #####:  146:  leading = i ? i + 1 : 0;
        -:  147:
    #####:  148:  length = encoded_str->length - (leading + trailing);
        -:  149:
    #####:  150:  new_str = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);
        -:  151:
    #####:  152:  if (new_str == NULL)
    #####:  153:    return NULL;
        -:  154:
    #####:  155:  start = encoded_str->c_string + leading;
        -:  156:
    #####:  157:  memcpy(new_str->c_string, start, length);
    #####:  158:  new_str->length = length;
        -:  159:
    #####:  160:  if (wide)
        -:  161:  {
    #####:  162:    final_str = sized_string_convert_to_wide(new_str);
    #####:  163:    yr_free(new_str);
        -:  164:  }
        -:  165:  else
        -:  166:  {
    #####:  167:    final_str = new_str;
        -:  168:  }
        -:  169:
    #####:  170:  return final_str;
        -:  171:}
        -:  172:
        -:  173:
        -:  174:// RE metacharacters which need to be escaped when generating the final RE.
        -:  175:#define IS_METACHAR(x) \
        -:  176:  (x == '\\' || \
        -:  177:   x == '^' || \
        -:  178:   x == '$' || \
        -:  179:   x == '|' || \
        -:  180:   x == '(' || \
        -:  181:   x == ')' || \
        -:  182:   x == '[' || \
        -:  183:   x == ']' || \
        -:  184:   x == '*' || \
        -:  185:   x == '?' || \
        -:  186:   x == '{' || \
        -:  187:   x == ',' || \
        -:  188:   x == '.' || \
        -:  189:   x == '+' || \
        -:  190:   x == '}')
        -:  191:
        -:  192:
        -:  193://
        -:  194:// Given a SIZED_STRING return the number of characters which will need to be
        -:  195:// escaped when generating the final string to pass to the regexp compiler.
        -:  196://
    #####:  197:static int _yr_base64_count_escaped(
        -:  198:    SIZED_STRING* str)
        -:  199:{
        -:  200:  uint32_t i;
    #####:  201:  int c = 0;
        -:  202:
    #####:  203:  for (i = 0; i < str->length; i++)
        -:  204:  {
        -:  205:    // We must be careful to escape null bytes because they break the RE lexer.
    #####:  206:    if (IS_METACHAR(str->c_string[i]))
    #####:  207:      c++;
    #####:  208:    else if (str->c_string[i] == '\x00')
    #####:  209:      c += 4;
        -:  210:  }
        -:  211:
    #####:  212:  return c;
        -:  213:}
        -:  214:
        -:  215://
        -:  216:// Create nodes representing the different encodings of a base64 string.
        -:  217://
    #####:  218:static int _yr_base64_create_nodes(
        -:  219:    SIZED_STRING* str,
        -:  220:    SIZED_STRING* alphabet,
        -:  221:    int wide,
        -:  222:    BASE64_NODE** head,
        -:  223:    BASE64_NODE** tail)
        -:  224:{
        -:  225:  SIZED_STRING* encoded_str;
        -:  226:  SIZED_STRING* final_str;
        -:  227:  BASE64_NODE* node;
        -:  228:  int i;
        -:  229:  int pad;
        -:  230:
    #####:  231:  for (i = 0; i <= 2; i++)
        -:  232:  {
    #####:  233:    if (i == 1 && str->length == 1)
    #####:  234:      continue;
        -:  235:
    #####:  236:    node = (BASE64_NODE*) yr_malloc(sizeof(BASE64_NODE));
    #####:  237:    if (node == NULL)
    #####:  238:      return ERROR_INSUFFICIENT_MEMORY;
        -:  239:
    #####:  240:    FAIL_ON_NULL_WITH_CLEANUP(
        -:  241:        encoded_str = _yr_modified_base64_encode(str, alphabet, i, &pad),
        -:  242:        yr_free(node));
        -:  243:
        -:  244:    // Now take the encoded string and strip the bytes which are affected by
        -:  245:    // the leading and trailing bytes of the plaintext.
    #####:  246:    FAIL_ON_NULL_WITH_CLEANUP(
        -:  247:      final_str = _yr_base64_get_base64_substring(encoded_str, wide, i, pad),
        -:  248:      {
        -:  249:        yr_free(encoded_str);
        -:  250:        yr_free(node);
        -:  251:      });
        -:  252:
    #####:  253:    yr_free(encoded_str);
        -:  254:
    #####:  255:    node->str = final_str;
    #####:  256:    node->escaped = _yr_base64_count_escaped(node->str);
    #####:  257:    node->next = NULL;
        -:  258:
    #####:  259:    if (*head == NULL)
    #####:  260:      *head = node;
        -:  261:
    #####:  262:    if (*tail == NULL)
        -:  263:    {
    #####:  264:      *tail = node;
        -:  265:    }
        -:  266:    else
        -:  267:    {
    #####:  268:      (*tail)->next = node;
    #####:  269:      *tail = node;
        -:  270:    }
        -:  271:  }
        -:  272:
    #####:  273:  return ERROR_SUCCESS;
        -:  274:}
        -:  275:
        -:  276:
        -:  277://
        -:  278:// Useful for printing the encoded strings.
        -:  279://
    #####:  280:void _yr_base64_print_nodes(
        -:  281:    BASE64_NODE* head)
        -:  282:{
        -:  283:  size_t i;
    #####:  284:  BASE64_NODE* p = head;
        -:  285:
    #####:  286:  while (p != NULL)
        -:  287:  {
    #####:  288:    for (i = 0; i < p->str->length; i++)
        -:  289:    {
    #####:  290:      if (p->str->c_string[i] >= 32 && p->str->c_string[i] <= 126)
    #####:  291:        printf("%c", p->str->c_string[i]);
        -:  292:      else
    #####:  293:        printf("\\x%02x", p->str->c_string[i]);
        -:  294:    }
    #####:  295:    printf("\n");
        -:  296:
    #####:  297:    p = p->next;
        -:  298:  }
        -:  299:
    #####:  300:  return;
        -:  301:}
        -:  302:
        -:  303:
        -:  304://
        -:  305:// Destroy a list of base64 nodes.
        -:  306://
    #####:  307:static void _yr_base64_destroy_nodes(
        -:  308:    BASE64_NODE* head)
        -:  309:{
    #####:  310:  BASE64_NODE* p = head;
        -:  311:  BASE64_NODE* next;
        -:  312:
    #####:  313:  while (p != NULL)
        -:  314:  {
    #####:  315:    yr_free(p->str);
    #####:  316:    next = p->next;
    #####:  317:    yr_free(p);
    #####:  318:    p = next;
        -:  319:  }
        -:  320:
    #####:  321:  return;
        -:  322:}
        -:  323:
        -:  324:
        -:  325://
        -:  326:// Create the regexp that is the alternatives of each of the strings collected
        -:  327:// in the BASE64_NODE list.
        -:  328://
    #####:  329:int _yr_base64_create_regexp(
        -:  330:    BASE64_NODE* head,
        -:  331:    RE_AST** re_ast,
        -:  332:    RE_ERROR* re_error)
        -:  333:{
        -:  334:  char* re_str;
        -:  335:  char* s;
        -:  336:  uint32_t i;
    #####:  337:  uint32_t length = 0;
    #####:  338:  uint32_t c = 0; // The number of nodes in the list, used to know how many '|'.
    #####:  339:  BASE64_NODE* p = head;
        -:  340:
    #####:  341:  while (p != NULL)
        -:  342:  {
    #####:  343:    length += (p->str->length + p->escaped);
    #####:  344:    c++;
    #####:  345:    p = p->next;
        -:  346:  }
        -:  347:
    #####:  348:  if (c == 0)
    #####:  349:    return ERROR_INSUFFICIENT_MEMORY;
        -:  350:
        -:  351:  // Make sure to include '(' and ')'.
        -:  352:  // The number of '|' is number of nodes - 1.
    #####:  353:  re_str = (char*) yr_malloc(length + 2 + (c - 1) + 1);
    #####:  354:  if (re_str == NULL)
    #####:  355:    return ERROR_INSUFFICIENT_MEMORY;
        -:  356:
    #####:  357:  s = re_str;
    #####:  358:  p = head;
    #####:  359:  *s++ = '(';
    #####:  360:  while (p != NULL)
        -:  361:  {
    #####:  362:    for (i = 0; i < p->str->length; i++)
        -:  363:    {
    #####:  364:      if (IS_METACHAR(p->str->c_string[i]))
    #####:  365:        *s++ = '\\';
        -:  366:
    #####:  367:      if (p->str->c_string[i] == '\x00')
        -:  368:      {
    #####:  369:        *s++ = '\\';
    #####:  370:        *s++ = 'x';
    #####:  371:        *s++ = '0';
    #####:  372:        *s++ = '0';
        -:  373:      }
        -:  374:      else
    #####:  375:        *s++ = p->str->c_string[i];
        -:  376:    }
        -:  377:
    #####:  378:    if (p->next != NULL)
    #####:  379:      *s++ = '|';
        -:  380:
    #####:  381:    p = p->next;
        -:  382:  }
    #####:  383:  *s++ = ')';
    #####:  384:  *s = '\x00';
        -:  385:
        -:  386:  // Useful for debugging as long as the string has no NULL bytes in it. ;)
        -:  387:  //printf("%s\n", re_str);
        -:  388:
    #####:  389:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  390:      yr_re_parse(re_str, re_ast, re_error),
        -:  391:      yr_free(re_str));
        -:  392:
    #####:  393:  yr_free(re_str);
    #####:  394:  return ERROR_SUCCESS;
        -:  395:}
        -:  396:
        -:  397:
        -:  398://
        -:  399:// Given a string and an alphabet, generate the RE_AST suitable for representing
        -:  400:// the different encodings of the string. This means we generate
        -:  401:// "(ABCD|EFGH|IJKL)" and must be careful to escape any special characters as
        -:  402:// a result of the base64 encoding.
        -:  403://
        -:  404:// This uses ideas from:
        -:  405:// https://www.leeholmes.com/blog/2019/12/10/searching-for-content-in-base-64-strings-2/
        -:  406://
        -:  407:// This does not emit the code for the RE. A further call to yr_re_ast_emit_code
        -:  408:// is required to get the code.
        -:  409://
    #####:  410:int yr_base64_ast_from_string(
        -:  411:    SIZED_STRING* in_str,
        -:  412:    YR_MODIFIER modifier,
        -:  413:    RE_AST** re_ast,
        -:  414:    RE_ERROR* error)
        -:  415:{
    #####:  416:  BASE64_NODE* head = NULL;
    #####:  417:  BASE64_NODE* tail = NULL;
        -:  418:  SIZED_STRING* wide_str;
        -:  419:
    #####:  420:  if (modifier.flags & STRING_FLAGS_WIDE)
        -:  421:  {
    #####:  422:    wide_str = sized_string_convert_to_wide(in_str);
        -:  423:
    #####:  424:    if (modifier.flags & STRING_FLAGS_BASE64)
        -:  425:    {
    #####:  426:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  427:          _yr_base64_create_nodes(wide_str, modifier.alphabet, 0, &head, &tail),
        -:  428:          {
        -:  429:            strcpy(error->message, "Failure encoding base64 wide string");
        -:  430:            yr_free(wide_str);
        -:  431:            _yr_base64_destroy_nodes(head);
        -:  432:          });
        -:  433:    }
        -:  434:
    #####:  435:    if (modifier.flags & STRING_FLAGS_BASE64_WIDE)
        -:  436:    {
    #####:  437:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  438:          _yr_base64_create_nodes(wide_str, modifier.alphabet, 1, &head, &tail),
        -:  439:          {
        -:  440:            strcpy(error->message, "Failure encoding base64wide wide string");
        -:  441:            yr_free(wide_str);
        -:  442:            _yr_base64_destroy_nodes(head);
        -:  443:          });
        -:  444:    }
        -:  445:
    #####:  446:    yr_free(wide_str);
        -:  447:  }
        -:  448:
    #####:  449:  if (modifier.flags & STRING_FLAGS_ASCII)
        -:  450:  {
    #####:  451:    if (modifier.flags & STRING_FLAGS_BASE64)
        -:  452:    {
    #####:  453:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  454:          _yr_base64_create_nodes(in_str, modifier.alphabet, 0, &head, &tail),
        -:  455:          {
        -:  456:            strcpy(error->message, "Failure encoding base64 ascii string");
        -:  457:            _yr_base64_destroy_nodes(head);
        -:  458:          });
        -:  459:    }
        -:  460:
    #####:  461:    if (modifier.flags & STRING_FLAGS_BASE64_WIDE)
        -:  462:    {
    #####:  463:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  464:          _yr_base64_create_nodes(in_str, modifier.alphabet, 1, &head, &tail),
        -:  465:          {
        -:  466:            strcpy(error->message, "Failure encoding base64wide ascii string");
        -:  467:            _yr_base64_destroy_nodes(head);
        -:  468:          });
        -:  469:    }
        -:  470:  }
        -:  471:
    #####:  472:  if (!(modifier.flags & STRING_FLAGS_WIDE) &&
    #####:  473:      !(modifier.flags & STRING_FLAGS_ASCII))
        -:  474:  {
    #####:  475:    if (modifier.flags & STRING_FLAGS_BASE64)
        -:  476:    {
    #####:  477:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  478:          _yr_base64_create_nodes(in_str, modifier.alphabet, 0, &head, &tail),
        -:  479:          {
        -:  480:            strcpy(error->message, "Failure encoding base64 string");
        -:  481:            _yr_base64_destroy_nodes(head);
        -:  482:          });
        -:  483:    }
        -:  484:
    #####:  485:    if (modifier.flags & STRING_FLAGS_BASE64_WIDE)
        -:  486:    {
    #####:  487:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  488:          _yr_base64_create_nodes(in_str, modifier.alphabet, 1, &head, &tail),
        -:  489:          {
        -:  490:            strcpy(error->message, "Failure encoding base64wide string");
        -:  491:            _yr_base64_destroy_nodes(head);
        -:  492:          });
        -:  493:    }
        -:  494:  }
        -:  495:
        -:  496:  // Useful for printing the contents of the nodes, to make sure they were
        -:  497:  // encoded and stripped properly.
        -:  498:  //_yr_base64_print_nodes(head);
        -:  499:
        -:  500:  // Create the final regex string to be parsed from all the nodes.
        -:  501:  // Error message is filled in by the caller in case of failure.
    #####:  502:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  503:      _yr_base64_create_regexp(head, re_ast, error),
        -:  504:      _yr_base64_destroy_nodes(head));
        -:  505:
    #####:  506:  _yr_base64_destroy_nodes(head);
        -:  507:
    #####:  508:  return ERROR_SUCCESS;
        -:  509:}
