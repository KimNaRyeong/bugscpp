        -:    0:Source:mem.c
        -:    0:Graph:/home/workspace/libyara/mem.gcno
        -:    0:Data:/home/workspace/libyara/mem.gcda
        -:    0:Runs:10
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <yara/mem.h>
        -:   31:#include <yara/error.h>
        -:   32:
        -:   33:#if defined(_WIN32) || defined(__CYGWIN__)
        -:   34:
        -:   35:#include <windows.h>
        -:   36:#include <string.h>
        -:   37:
        -:   38:static HANDLE hHeap;
        -:   39:
        -:   40:int yr_heap_alloc(void)
        -:   41:{
        -:   42:  hHeap = HeapCreate(0, 0x8000, 0);
        -:   43:
        -:   44:  if (hHeap == NULL)
        -:   45:    return ERROR_INTERNAL_FATAL_ERROR;
        -:   46:
        -:   47:  return ERROR_SUCCESS;
        -:   48:}
        -:   49:
        -:   50:
        -:   51:int yr_heap_free(void)
        -:   52:{
        -:   53:  if (HeapDestroy(hHeap))
        -:   54:    return ERROR_SUCCESS;
        -:   55:  else
        -:   56:    return ERROR_INTERNAL_FATAL_ERROR;
        -:   57:}
        -:   58:
        -:   59:
        -:   60:void* yr_calloc(size_t count, size_t size)
        -:   61:{
        -:   62:  return (void*) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, count * size);
        -:   63:}
        -:   64:
        -:   65:
        -:   66:void* yr_malloc(size_t size)
        -:   67:{
        -:   68:  return (void*) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, size);
        -:   69:}
        -:   70:
        -:   71:
        -:   72:void* yr_realloc(void* ptr, size_t size)
        -:   73:{
        -:   74:  if (ptr == NULL)
        -:   75:    return (void*) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, size);
        -:   76:
        -:   77:  return (void*) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, ptr, size);
        -:   78:}
        -:   79:
        -:   80:
        -:   81:void yr_free(void* ptr)
        -:   82:{
        -:   83:  HeapFree(hHeap, 0, ptr);
        -:   84:}
        -:   85:
        -:   86:
        -:   87:char* yr_strdup(const char *str)
        -:   88:{
        -:   89:  size_t len = strlen(str);
        -:   90:  char *dup = (char*) yr_malloc(len + 1);
        -:   91:
        -:   92:  if (dup == NULL)
        -:   93:    return NULL;
        -:   94:
        -:   95:  memcpy(dup, str, len);
        -:   96:  dup[len] = '\0';
        -:   97:
        -:   98:  return (char*) dup;
        -:   99:}
        -:  100:
        -:  101:
        -:  102:char* yr_strndup(const char *str, size_t n)
        -:  103:{
        -:  104:  size_t len = strnlen(str, n);
        -:  105:  char *dup = (char*) yr_malloc(len + 1);
        -:  106:
        -:  107:  if (dup == NULL)
        -:  108:    return NULL;
        -:  109:
        -:  110:  memcpy(dup, str, len);
        -:  111:  dup[len] = '\0';
        -:  112:
        -:  113:  return (char *) dup;
        -:  114:}
        -:  115:
        -:  116:#else
        -:  117:
        -:  118:#include <stdlib.h>
        -:  119:#include <string.h>
        -:  120:#include <stdio.h>
        -:  121:
        6:  122:int yr_heap_alloc(void)
        -:  123:{
        6:  124:  return ERROR_SUCCESS;
        -:  125:}
        -:  126:
        -:  127:
        5:  128:int yr_heap_free(void)
        -:  129:{
        5:  130:  return ERROR_SUCCESS;
        -:  131:}
        -:  132:
        -:  133:
       14:  134:void* yr_calloc(size_t count, size_t size)
        -:  135:{
       14:  136:  return calloc(count, size);
        -:  137:}
        -:  138:
        -:  139:
     3908:  140:void* yr_malloc(size_t size)
        -:  141:{
     3908:  142:  return malloc(size);
        -:  143:}
        -:  144:
        -:  145:
       43:  146:void* yr_realloc(void* ptr, size_t size)
        -:  147:{
       43:  148:  return realloc(ptr, size);
        -:  149:}
        -:  150:
        -:  151:
     3978:  152:void yr_free(void *ptr)
        -:  153:{
     3978:  154:  free(ptr);
     3978:  155:}
        -:  156:
        -:  157:
       27:  158:char* yr_strdup(const char *str)
        -:  159:{
       27:  160:  return strdup(str);
        -:  161:}
        -:  162:
        -:  163:
    #####:  164:char* yr_strndup(const char *str, size_t n)
        -:  165:{
    #####:  166:  return strndup(str, n);
        -:  167:}
        -:  168:
        -:  169:#endif
