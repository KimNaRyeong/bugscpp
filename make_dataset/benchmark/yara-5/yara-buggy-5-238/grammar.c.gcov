        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         yara_yyparse
        -:   68:#define yylex           yara_yylex
        -:   69:#define yyerror         yara_yyerror
        -:   70:#define yydebug         yara_yydebug
        -:   71:#define yynerrs         yara_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "grammar.y"
        -:   75:
        -:   76:
        -:   77:
        -:   78:#include <assert.h>
        -:   79:#include <stdio.h>
        -:   80:#include <string.h>
        -:   81:#include <limits.h>
        -:   82:#include <stdlib.h>
        -:   83:#include <stddef.h>
        -:   84:
        -:   85:#include <yara/arena.h>
        -:   86:#include <yara/integers.h>
        -:   87:#include <yara/utils.h>
        -:   88:#include <yara/strutils.h>
        -:   89:#include <yara/compiler.h>
        -:   90:#include <yara/object.h>
        -:   91:#include <yara/sizedstr.h>
        -:   92:#include <yara/exec.h>
        -:   93:#include <yara/error.h>
        -:   94:#include <yara/mem.h>
        -:   95:#include <yara/lexer.h>
        -:   96:#include <yara/parser.h>
        -:   97:
        -:   98:#if defined(_MSC_VER)
        -:   99:#define llabs _abs64
        -:  100:#endif
        -:  101:
        -:  102:#define YYERROR_VERBOSE
        -:  103:
        -:  104:#define YYMALLOC yr_malloc
        -:  105:#define YYFREE yr_free
        -:  106:
        -:  107:#define FOR_EXPRESSION_ALL 1
        -:  108:#define FOR_EXPRESSION_ANY 2
        -:  109:
        -:  110:#define fail_with_error(e) \
        -:  111:    { \
        -:  112:      compiler->last_error = e; \
        -:  113:      yyerror(yyscanner, compiler, NULL); \
        -:  114:      YYERROR; \
        -:  115:    }
        -:  116:
        -:  117:
        -:  118:#define fail_if_error(e) \
        -:  119:    if (e != ERROR_SUCCESS) \
        -:  120:    { \
        -:  121:      fail_with_error(e); \
        -:  122:    } \
        -:  123:
        -:  124:
        -:  125:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  126:    if (((expression.type) & (expected_type)) == 0) \
        -:  127:    { \
        -:  128:      switch(expression.type) \
        -:  129:      { \
        -:  130:        case EXPRESSION_TYPE_INTEGER: \
        -:  131:          yr_compiler_set_error_extra_info( \
        -:  132:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  133:          break; \
        -:  134:        case EXPRESSION_TYPE_FLOAT: \
        -:  135:          yr_compiler_set_error_extra_info( \
        -:  136:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  137:          break; \
        -:  138:        case EXPRESSION_TYPE_STRING: \
        -:  139:          yr_compiler_set_error_extra_info( \
        -:  140:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  141:          break; \
        -:  142:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  143:          yr_compiler_set_error_extra_info( \
        -:  144:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  145:          break; \
        -:  146:      } \
        -:  147:      cleanup; \
        -:  148:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  149:      yyerror(yyscanner, compiler, NULL); \
        -:  150:      YYERROR; \
        -:  151:    }
        -:  152:
        -:  153:// check_type(expression, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT) is
        -:  154:// used to ensure that the type of "expression" is either integer or float.
        -:  155:#define check_type(expression, expected_type, op) \
        -:  156:    check_type_with_cleanup(expression, expected_type, op, )
        -:  157:
        -:  158:
        -:  159:#define loop_vars_cleanup(loop_index) \
        -:  160:    {  \
        -:  161:      YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[loop_index]; \
        -:  162:      for (int i = 0; i < loop_ctx->vars_count; i++) \
        -:  163:      { \
        -:  164:        yr_free((void*) loop_ctx->vars[i].identifier.ptr); \
        -:  165:        loop_ctx->vars[i].identifier.ptr = NULL; \
        -:  166:        loop_ctx->vars[i].identifier.ref = YR_ARENA_NULL_REF; \
        -:  167:      } \
        -:  168:      loop_ctx->vars_count = 0; \
        -:  169:    } \
        -:  170:
        -:  171:
        -:  172:// Given a YR_EXPRESSION returns its identifier. It returns identifier.ptr if
        -:  173:// not NULL and relies on identifier.ref if otherwise.
        -:  174:#define expression_identifier(expr) \
        -:  175:    ((expr).identifier.ptr != NULL ? \
        -:  176:     (expr).identifier.ptr : \
        -:  177:     (const char*) yr_arena_ref_to_ptr(compiler->arena, &(expr).identifier.ref))
        -:  178:
        -:  179:
        -:  180:#define DEFAULT_BASE64_ALPHABET \
        -:  181:    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        -:  182:
        -:  183:
        -:  184:#line 185 "grammar.c"
        -:  185:
        -:  186:# ifndef YY_CAST
        -:  187:#  ifdef __cplusplus
        -:  188:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  189:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  190:#  else
        -:  191:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  192:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  193:#  endif
        -:  194:# endif
        -:  195:# ifndef YY_NULLPTR
        -:  196:#  if defined __cplusplus
        -:  197:#   if 201103L <= __cplusplus
        -:  198:#    define YY_NULLPTR nullptr
        -:  199:#   else
        -:  200:#    define YY_NULLPTR 0
        -:  201:#   endif
        -:  202:#  else
        -:  203:#   define YY_NULLPTR ((void*)0)
        -:  204:#  endif
        -:  205:# endif
        -:  206:
        -:  207:/* Enabling verbose error messages.  */
        -:  208:#ifdef YYERROR_VERBOSE
        -:  209:# undef YYERROR_VERBOSE
        -:  210:# define YYERROR_VERBOSE 1
        -:  211:#else
        -:  212:# define YYERROR_VERBOSE 0
        -:  213:#endif
        -:  214:
        -:  215:/* Use api.header.include to #include this header
        -:  216:   instead of duplicating it here.  */
        -:  217:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  218:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  219:/* Debug traces.  */
        -:  220:#ifndef YYDEBUG
        -:  221:# define YYDEBUG 0
        -:  222:#endif
        -:  223:#if YYDEBUG
        -:  224:extern int yara_yydebug;
        -:  225:#endif
        -:  226:
        -:  227:/* Token type.  */
        -:  228:#ifndef YYTOKENTYPE
        -:  229:# define YYTOKENTYPE
        -:  230:  enum yytokentype
        -:  231:  {
        -:  232:    _END_OF_FILE_ = 0,
        -:  233:    _END_OF_INCLUDED_FILE_ = 258,
        -:  234:    _DOT_DOT_ = 259,
        -:  235:    _RULE_ = 260,
        -:  236:    _PRIVATE_ = 261,
        -:  237:    _GLOBAL_ = 262,
        -:  238:    _META_ = 263,
        -:  239:    _STRINGS_ = 264,
        -:  240:    _CONDITION_ = 265,
        -:  241:    _IDENTIFIER_ = 266,
        -:  242:    _STRING_IDENTIFIER_ = 267,
        -:  243:    _STRING_COUNT_ = 268,
        -:  244:    _STRING_OFFSET_ = 269,
        -:  245:    _STRING_LENGTH_ = 270,
        -:  246:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 271,
        -:  247:    _NUMBER_ = 272,
        -:  248:    _DOUBLE_ = 273,
        -:  249:    _INTEGER_FUNCTION_ = 274,
        -:  250:    _TEXT_STRING_ = 275,
        -:  251:    _HEX_STRING_ = 276,
        -:  252:    _REGEXP_ = 277,
        -:  253:    _ASCII_ = 278,
        -:  254:    _WIDE_ = 279,
        -:  255:    _XOR_ = 280,
        -:  256:    _BASE64_ = 281,
        -:  257:    _BASE64_WIDE_ = 282,
        -:  258:    _NOCASE_ = 283,
        -:  259:    _FULLWORD_ = 284,
        -:  260:    _AT_ = 285,
        -:  261:    _FILESIZE_ = 286,
        -:  262:    _ENTRYPOINT_ = 287,
        -:  263:    _ALL_ = 288,
        -:  264:    _ANY_ = 289,
        -:  265:    _IN_ = 290,
        -:  266:    _OF_ = 291,
        -:  267:    _FOR_ = 292,
        -:  268:    _THEM_ = 293,
        -:  269:    _MATCHES_ = 294,
        -:  270:    _CONTAINS_ = 295,
        -:  271:    _IMPORT_ = 296,
        -:  272:    _TRUE_ = 297,
        -:  273:    _FALSE_ = 298,
        -:  274:    _OR_ = 299,
        -:  275:    _AND_ = 300,
        -:  276:    _NOT_ = 301,
        -:  277:    _EQ_ = 302,
        -:  278:    _NEQ_ = 303,
        -:  279:    _LT_ = 304,
        -:  280:    _LE_ = 305,
        -:  281:    _GT_ = 306,
        -:  282:    _GE_ = 307,
        -:  283:    _SHIFT_LEFT_ = 308,
        -:  284:    _SHIFT_RIGHT_ = 309,
        -:  285:    UNARY_MINUS = 310
        -:  286:  };
        -:  287:#endif
        -:  288:/* Tokens.  */
        -:  289:#define _END_OF_FILE_ 0
        -:  290:#define _END_OF_INCLUDED_FILE_ 258
        -:  291:#define _DOT_DOT_ 259
        -:  292:#define _RULE_ 260
        -:  293:#define _PRIVATE_ 261
        -:  294:#define _GLOBAL_ 262
        -:  295:#define _META_ 263
        -:  296:#define _STRINGS_ 264
        -:  297:#define _CONDITION_ 265
        -:  298:#define _IDENTIFIER_ 266
        -:  299:#define _STRING_IDENTIFIER_ 267
        -:  300:#define _STRING_COUNT_ 268
        -:  301:#define _STRING_OFFSET_ 269
        -:  302:#define _STRING_LENGTH_ 270
        -:  303:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 271
        -:  304:#define _NUMBER_ 272
        -:  305:#define _DOUBLE_ 273
        -:  306:#define _INTEGER_FUNCTION_ 274
        -:  307:#define _TEXT_STRING_ 275
        -:  308:#define _HEX_STRING_ 276
        -:  309:#define _REGEXP_ 277
        -:  310:#define _ASCII_ 278
        -:  311:#define _WIDE_ 279
        -:  312:#define _XOR_ 280
        -:  313:#define _BASE64_ 281
        -:  314:#define _BASE64_WIDE_ 282
        -:  315:#define _NOCASE_ 283
        -:  316:#define _FULLWORD_ 284
        -:  317:#define _AT_ 285
        -:  318:#define _FILESIZE_ 286
        -:  319:#define _ENTRYPOINT_ 287
        -:  320:#define _ALL_ 288
        -:  321:#define _ANY_ 289
        -:  322:#define _IN_ 290
        -:  323:#define _OF_ 291
        -:  324:#define _FOR_ 292
        -:  325:#define _THEM_ 293
        -:  326:#define _MATCHES_ 294
        -:  327:#define _CONTAINS_ 295
        -:  328:#define _IMPORT_ 296
        -:  329:#define _TRUE_ 297
        -:  330:#define _FALSE_ 298
        -:  331:#define _OR_ 299
        -:  332:#define _AND_ 300
        -:  333:#define _NOT_ 301
        -:  334:#define _EQ_ 302
        -:  335:#define _NEQ_ 303
        -:  336:#define _LT_ 304
        -:  337:#define _LE_ 305
        -:  338:#define _GT_ 306
        -:  339:#define _GE_ 307
        -:  340:#define _SHIFT_LEFT_ 308
        -:  341:#define _SHIFT_RIGHT_ 309
        -:  342:#define UNARY_MINUS 310
        -:  343:
        -:  344:/* Value type.  */
        -:  345:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  346:union YYSTYPE
        -:  347:{
        -:  348:#line 297 "grammar.y"
        -:  349:
        -:  350:  YR_EXPRESSION   expression;
        -:  351:  SIZED_STRING*   sized_string;
        -:  352:  char*           c_string;
        -:  353:  int64_t         integer;
        -:  354:  double          double_;
        -:  355:  YR_MODIFIER     modifier;
        -:  356:
        -:  357:  YR_ARENA_REF tag;
        -:  358:  YR_ARENA_REF rule;
        -:  359:  YR_ARENA_REF meta;
        -:  360:  YR_ARENA_REF string;
        -:  361:
        -:  362:#line 363 "grammar.c"
        -:  363:
        -:  364:};
        -:  365:typedef union YYSTYPE YYSTYPE;
        -:  366:# define YYSTYPE_IS_TRIVIAL 1
        -:  367:# define YYSTYPE_IS_DECLARED 1
        -:  368:#endif
        -:  369:
        -:  370:
        -:  371:
        -:  372:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  373:
        -:  374:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  375:
        -:  376:
        -:  377:
        -:  378:#ifdef short
        -:  379:# undef short
        -:  380:#endif
        -:  381:
        -:  382:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  383:   <limits.h> and (if available) <stdint.h> are included
        -:  384:   so that the code can choose integer types of a good width.  */
        -:  385:
        -:  386:#ifndef __PTRDIFF_MAX__
        -:  387:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  388:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  389:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  390:#  define YY_STDINT_H
        -:  391:# endif
        -:  392:#endif
        -:  393:
        -:  394:/* Narrow types that promote to a signed type and that can represent a
        -:  395:   signed or unsigned integer of at least N bits.  In tables they can
        -:  396:   save space and decrease cache pressure.  Promoting to a signed type
        -:  397:   helps avoid bugs in integer arithmetic.  */
        -:  398:
        -:  399:#ifdef __INT_LEAST8_MAX__
        -:  400:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  401:#elif defined YY_STDINT_H
        -:  402:typedef int_least8_t yytype_int8;
        -:  403:#else
        -:  404:typedef signed char yytype_int8;
        -:  405:#endif
        -:  406:
        -:  407:#ifdef __INT_LEAST16_MAX__
        -:  408:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  409:#elif defined YY_STDINT_H
        -:  410:typedef int_least16_t yytype_int16;
        -:  411:#else
        -:  412:typedef short yytype_int16;
        -:  413:#endif
        -:  414:
        -:  415:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  416:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  417:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  418:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  419:typedef uint_least8_t yytype_uint8;
        -:  420:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  421:typedef unsigned char yytype_uint8;
        -:  422:#else
        -:  423:typedef short yytype_uint8;
        -:  424:#endif
        -:  425:
        -:  426:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  427:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  428:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  429:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  430:typedef uint_least16_t yytype_uint16;
        -:  431:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  432:typedef unsigned short yytype_uint16;
        -:  433:#else
        -:  434:typedef int yytype_uint16;
        -:  435:#endif
        -:  436:
        -:  437:#ifndef YYPTRDIFF_T
        -:  438:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  439:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  440:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  441:# elif defined PTRDIFF_MAX
        -:  442:#  ifndef ptrdiff_t
        -:  443:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  444:#  endif
        -:  445:#  define YYPTRDIFF_T ptrdiff_t
        -:  446:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  447:# else
        -:  448:#  define YYPTRDIFF_T long
        -:  449:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  450:# endif
        -:  451:#endif
        -:  452:
        -:  453:#ifndef YYSIZE_T
        -:  454:# ifdef __SIZE_TYPE__
        -:  455:#  define YYSIZE_T __SIZE_TYPE__
        -:  456:# elif defined size_t
        -:  457:#  define YYSIZE_T size_t
        -:  458:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  459:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  460:#  define YYSIZE_T size_t
        -:  461:# else
        -:  462:#  define YYSIZE_T unsigned
        -:  463:# endif
        -:  464:#endif
        -:  465:
        -:  466:#define YYSIZE_MAXIMUM                                  \
        -:  467:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  468:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  469:            ? YYPTRDIFF_MAXIMUM                         \
        -:  470:            : YY_CAST (YYSIZE_T, -1)))
        -:  471:
        -:  472:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  473:
        -:  474:/* Stored state numbers (used for stacks). */
        -:  475:typedef yytype_uint8 yy_state_t;
        -:  476:
        -:  477:/* State numbers in computations.  */
        -:  478:typedef int yy_state_fast_t;
        -:  479:
        -:  480:#ifndef YY_
        -:  481:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  482:#  if ENABLE_NLS
        -:  483:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  484:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  485:#  endif
        -:  486:# endif
        -:  487:# ifndef YY_
        -:  488:#  define YY_(Msgid) Msgid
        -:  489:# endif
        -:  490:#endif
        -:  491:
        -:  492:#ifndef YY_ATTRIBUTE_PURE
        -:  493:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  494:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  495:# else
        -:  496:#  define YY_ATTRIBUTE_PURE
        -:  497:# endif
        -:  498:#endif
        -:  499:
        -:  500:#ifndef YY_ATTRIBUTE_UNUSED
        -:  501:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  502:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  503:# else
        -:  504:#  define YY_ATTRIBUTE_UNUSED
        -:  505:# endif
        -:  506:#endif
        -:  507:
        -:  508:/* Suppress unused-variable warnings by "using" E.  */
        -:  509:#if ! defined lint || defined __GNUC__
        -:  510:# define YYUSE(E) ((void) (E))
        -:  511:#else
        -:  512:# define YYUSE(E) /* empty */
        -:  513:#endif
        -:  514:
        -:  515:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  516:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  517:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  518:    _Pragma ("GCC diagnostic push")                                     \
        -:  519:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  520:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  521:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  522:    _Pragma ("GCC diagnostic pop")
        -:  523:#else
        -:  524:# define YY_INITIAL_VALUE(Value) Value
        -:  525:#endif
        -:  526:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  527:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  528:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  529:#endif
        -:  530:#ifndef YY_INITIAL_VALUE
        -:  531:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  532:#endif
        -:  533:
        -:  534:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  535:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  536:    _Pragma ("GCC diagnostic push")                            \
        -:  537:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  538:# define YY_IGNORE_USELESS_CAST_END            \
        -:  539:    _Pragma ("GCC diagnostic pop")
        -:  540:#endif
        -:  541:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  542:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  543:# define YY_IGNORE_USELESS_CAST_END
        -:  544:#endif
        -:  545:
        -:  546:
        -:  547:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  548:
        -:  549:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  550:
        -:  551:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  552:
        -:  553:# ifdef YYSTACK_USE_ALLOCA
        -:  554:#  if YYSTACK_USE_ALLOCA
        -:  555:#   ifdef __GNUC__
        -:  556:#    define YYSTACK_ALLOC __builtin_alloca
        -:  557:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  558:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  559:#   elif defined _AIX
        -:  560:#    define YYSTACK_ALLOC __alloca
        -:  561:#   elif defined _MSC_VER
        -:  562:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  563:#    define alloca _alloca
        -:  564:#   else
        -:  565:#    define YYSTACK_ALLOC alloca
        -:  566:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  567:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  568:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  569:#     ifndef EXIT_SUCCESS
        -:  570:#      define EXIT_SUCCESS 0
        -:  571:#     endif
        -:  572:#    endif
        -:  573:#   endif
        -:  574:#  endif
        -:  575:# endif
        -:  576:
        -:  577:# ifdef YYSTACK_ALLOC
        -:  578:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  579:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  580:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  581:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  582:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  583:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  584:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  585:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  586:#  endif
        -:  587:# else
        -:  588:#  define YYSTACK_ALLOC YYMALLOC
        -:  589:#  define YYSTACK_FREE YYFREE
        -:  590:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  591:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  592:#  endif
        -:  593:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  594:       && ! ((defined YYMALLOC || defined malloc) \
        -:  595:             && (defined YYFREE || defined free)))
        -:  596:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  597:#   ifndef EXIT_SUCCESS
        -:  598:#    define EXIT_SUCCESS 0
        -:  599:#   endif
        -:  600:#  endif
        -:  601:#  ifndef YYMALLOC
        -:  602:#   define YYMALLOC malloc
        -:  603:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  604:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  605:#   endif
        -:  606:#  endif
        -:  607:#  ifndef YYFREE
        -:  608:#   define YYFREE free
        -:  609:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  610:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  611:#   endif
        -:  612:#  endif
        -:  613:# endif
        -:  614:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  615:
        -:  616:
        -:  617:#if (! defined yyoverflow \
        -:  618:     && (! defined __cplusplus \
        -:  619:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  620:
        -:  621:/* A type that is properly aligned for any stack member.  */
        -:  622:union yyalloc
        -:  623:{
        -:  624:  yy_state_t yyss_alloc;
        -:  625:  YYSTYPE yyvs_alloc;
        -:  626:};
        -:  627:
        -:  628:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  629:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  630:
        -:  631:/* The size of an array large to enough to hold all stacks, each with
        -:  632:   N elements.  */
        -:  633:# define YYSTACK_BYTES(N) \
        -:  634:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  635:      + YYSTACK_GAP_MAXIMUM)
        -:  636:
        -:  637:# define YYCOPY_NEEDED 1
        -:  638:
        -:  639:/* Relocate STACK from its old location to the new one.  The
        -:  640:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  641:   elements in the stack, and YYPTR gives the new location of the
        -:  642:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  643:   stack.  */
        -:  644:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  645:    do                                                                  \
        -:  646:      {                                                                 \
        -:  647:        YYPTRDIFF_T yynewbytes;                                         \
        -:  648:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  649:        Stack = &yyptr->Stack_alloc;                                    \
        -:  650:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  651:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  652:      }                                                                 \
        -:  653:    while (0)
        -:  654:
        -:  655:#endif
        -:  656:
        -:  657:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  658:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  659:   not overlap.  */
        -:  660:# ifndef YYCOPY
        -:  661:#  if defined __GNUC__ && 1 < __GNUC__
        -:  662:#   define YYCOPY(Dst, Src, Count) \
        -:  663:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  664:#  else
        -:  665:#   define YYCOPY(Dst, Src, Count)              \
        -:  666:      do                                        \
        -:  667:        {                                       \
        -:  668:          YYPTRDIFF_T yyi;                      \
        -:  669:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  670:            (Dst)[yyi] = (Src)[yyi];            \
        -:  671:        }                                       \
        -:  672:      while (0)
        -:  673:#  endif
        -:  674:# endif
        -:  675:#endif /* !YYCOPY_NEEDED */
        -:  676:
        -:  677:/* YYFINAL -- State number of the termination state.  */
        -:  678:#define YYFINAL  2
        -:  679:/* YYLAST -- Last index in YYTABLE.  */
        -:  680:#define YYLAST   387
        -:  681:
        -:  682:/* YYNTOKENS -- Number of terminals.  */
        -:  683:#define YYNTOKENS  76
        -:  684:/* YYNNTS -- Number of nonterminals.  */
        -:  685:#define YYNNTS  48
        -:  686:/* YYNRULES -- Number of rules.  */
        -:  687:#define YYNRULES  146
        -:  688:/* YYNSTATES -- Number of states.  */
        -:  689:#define YYNSTATES  242
        -:  690:
        -:  691:#define YYUNDEFTOK  2
        -:  692:#define YYMAXUTOK   311
        -:  693:
        -:  694:
        -:  695:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  696:   as returned by yylex, with out-of-bounds checking.  */
        -:  697:#define YYTRANSLATE(YYX)                                                \
        -:  698:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  699:
        -:  700:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  701:   as returned by yylex.  */
        -:  702:static const yytype_int8 yytranslate[] =
        -:  703:{
        -:  704:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  705:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  706:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  707:       2,     2,     2,     2,     2,     2,     2,    62,    57,     2,
        -:  708:      70,    71,    60,    58,    75,    59,    72,     2,     2,     2,
        -:  709:       2,     2,     2,     2,     2,     2,     2,     2,    68,     2,
        -:  710:       2,    69,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  711:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  712:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  713:       2,    73,    61,    74,    56,     2,     2,     2,     2,     2,
        -:  714:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  715:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  716:       2,     2,     2,    66,    55,    67,    63,     2,     2,     2,
        -:  717:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  718:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  719:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  720:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  721:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  722:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  723:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  724:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  725:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  726:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  727:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  728:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  729:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  730:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  731:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  732:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  733:      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
        -:  734:      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
        -:  735:      64,    65
        -:  736:};
        -:  737:
        -:  738:#if YYDEBUG
        -:  739:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  740:static const yytype_int16 yyrline[] =
        -:  741:{
        -:  742:       0,   315,   315,   316,   317,   318,   319,   320,   321,   329,
        -:  743:     342,   347,   341,   374,   377,   393,   396,   411,   416,   417,
        -:  744:     422,   423,   429,   432,   448,   457,   499,   500,   505,   522,
        -:  745:     536,   550,   564,   582,   583,   589,   588,   605,   604,   625,
        -:  746:     624,   649,   655,   715,   716,   717,   718,   719,   720,   726,
        -:  747:     747,   778,   783,   800,   805,   825,   826,   840,   841,   842,
        -:  748:     843,   844,   848,   849,   863,   867,   962,  1010,  1071,  1118,
        -:  749:    1119,  1123,  1158,  1211,  1254,  1277,  1284,  1291,  1303,  1313,
        -:  750:    1327,  1342,  1353,  1432,  1470,  1372,  1630,  1629,  1719,  1725,
        -:  751:    1732,  1731,  1777,  1776,  1820,  1827,  1834,  1841,  1848,  1855,
        -:  752:    1862,  1866,  1874,  1894,  1922,  1996,  2024,  2033,  2042,  2066,
        -:  753:    2081,  2101,  2100,  2106,  2118,  2119,  2124,  2131,  2142,  2146,
        -:  754:    2151,  2160,  2164,  2172,  2184,  2198,  2206,  2213,  2239,  2251,
        -:  755:    2263,  2279,  2291,  2307,  2350,  2371,  2406,  2441,  2475,  2500,
        -:  756:    2517,  2527,  2537,  2547,  2557,  2577,  2597
        -:  757:};
        -:  758:#endif
        -:  759:
        -:  760:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  761:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  762:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  763:static const char *const yytname[] =
        -:  764:{
        -:  765:  "\"end of file\"", "error", "$undefined", "\"end of included file\"",
        -:  766:  "\"..\"", "\"<rule>\"", "\"<private>\"", "\"<global>\"", "\"<meta>\"",
        -:  767:  "\"<strings>\"", "\"<condition>\"", "\"identifier\"",
        -:  768:  "\"string identifier\"", "\"string count\"", "\"string offset\"",
        -:  769:  "\"string length\"", "\"string identifier with wildcard\"",
        -:  770:  "\"integer number\"", "\"floating point number\"",
        -:  771:  "\"integer function\"", "\"text string\"", "\"hex string\"",
        -:  772:  "\"regular expression\"", "\"<ascii>\"", "\"<wide>\"", "\"<xor>\"",
        -:  773:  "\"<base64>\"", "\"<base64wide>\"", "\"<nocase>\"", "\"<fullword>\"",
        -:  774:  "\"<at>\"", "\"<filesize>\"", "\"<entrypoint>\"", "\"<all>\"",
        -:  775:  "\"<any>\"", "\"<in>\"", "\"<of>\"", "\"<for>\"", "\"<them>\"",
        -:  776:  "\"<matches>\"", "\"<contains>\"", "\"<import>\"", "\"<true>\"",
        -:  777:  "\"<false\"", "\"<or>\"", "\"<and>\"", "\"<not>\"", "\"==\"", "\"!=\"",
        -:  778:  "\"<\"", "\"<=\"", "\">\"", "\">=\"", "\"<<\"", "\">>\"", "'|'", "'^'",
        -:  779:  "'&'", "'+'", "'-'", "'*'", "'\\\\'", "'%'", "'~'", "UNARY_MINUS",
        -:  780:  "\"include\"", "'{'", "'}'", "':'", "'='", "'('", "')'", "'.'", "'['",
        -:  781:  "']'", "','", "$accept", "rules", "import", "rule", "@1", "$@2", "meta",
        -:  782:  "strings", "condition", "rule_modifiers", "rule_modifier", "tags",
        -:  783:  "tag_list", "meta_declarations", "meta_declaration",
        -:  784:  "string_declarations", "string_declaration", "$@3", "$@4", "$@5",
        -:  785:  "string_modifiers", "string_modifier", "regexp_modifiers",
        -:  786:  "regexp_modifier", "hex_modifiers", "hex_modifier", "identifier",
        -:  787:  "arguments", "arguments_list", "regexp", "boolean_expression",
        -:  788:  "expression", "$@6", "$@7", "$@8", "$@9", "$@10", "for_variables",
        -:  789:  "iterator", "integer_set", "range", "integer_enumeration", "string_set",
        -:  790:  "$@11", "string_enumeration", "string_enumeration_item",
        -:  791:  "for_expression", "primary_expression", YY_NULLPTR
        -:  792:};
        -:  793:#endif
        -:  794:
        -:  795:# ifdef YYPRINT
        -:  796:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  797:   (internal) symbol number NUM (which must be that of a token).  */
        -:  798:static const yytype_int16 yytoknum[] =
        -:  799:{
        -:  800:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  801:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  802:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  803:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  804:     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
        -:  805:     305,   306,   307,   308,   309,   124,    94,    38,    43,    45,
        -:  806:      42,    92,    37,   126,   310,   311,   123,   125,    58,    61,
        -:  807:      40,    41,    46,    91,    93,    44
        -:  808:};
        -:  809:# endif
        -:  810:
        -:  811:#define YYPACT_NINF (-74)
        -:  812:
        -:  813:#define yypact_value_is_default(Yyn) \
        -:  814:  ((Yyn) == YYPACT_NINF)
        -:  815:
        -:  816:#define YYTABLE_NINF (-119)
        -:  817:
        -:  818:#define yytable_value_is_error(Yyn) \
        -:  819:  0
        -:  820:
        -:  821:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  822:     STATE-NUM.  */
        -:  823:static const yytype_int16 yypact[] =
        -:  824:{
        -:  825:     -74,    97,   -74,   -38,   -74,   -11,   -74,   -74,   153,   -74,
        -:  826:     -74,   -74,   -74,     0,   -74,   -74,   -74,   -74,   -50,    13,
        -:  827:     -29,   -74,    21,    58,   -74,   -10,    68,    77,    17,   -74,
        -:  828:      22,    77,   -74,    87,    98,    14,   -74,    41,    87,   -74,
        -:  829:      47,    57,   -74,   -74,   -74,   -74,   120,     8,   -74,    50,
        -:  830:     -74,   -74,   109,   121,   128,   -74,   -22,   -74,    81,    84,
        -:  831:     -74,   -74,    91,   -74,   -74,   -74,   -74,   -74,   -74,   108,
        -:  832:     -74,   -74,    50,   133,   133,    50,    44,   -74,   124,   -74,
        -:  833:     127,   206,   -74,   -74,   -74,   133,   100,   133,   133,   133,
        -:  834:     133,    24,   315,   -74,   -74,   -74,   124,   115,   179,    50,
        -:  835:     176,   133,   -74,   -74,   -34,   166,   133,   133,   133,   133,
        -:  836:     133,   133,   133,   133,   133,   133,   133,   133,   133,   133,
        -:  837:     133,   133,   133,   156,    83,   183,   315,   133,   -74,   216,
        -:  838:     226,   258,   277,   -74,   -34,   180,   -74,   -74,   149,   129,
        -:  839:     131,   -74,   248,    50,    50,   -74,   -74,   -74,   -74,   315,
        -:  840:     315,   315,   315,   315,   315,   315,    74,    74,   325,   140,
        -:  841:     163,   112,   112,   -74,   -74,   -74,   -74,   -74,   -74,   125,
        -:  842:     173,   174,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  843:     -74,   -74,   -74,   152,   -74,   -74,   -74,   181,   -74,   -20,
        -:  844:     -74,    50,   -74,   202,   -74,    -2,   231,   232,   269,   133,
        -:  845:     -74,     1,   240,   131,   -74,   -74,     5,   -74,   -43,   220,
        -:  846:     221,   296,   223,   133,    44,   227,   -74,   -74,   -74,   -74,
        -:  847:      -2,   279,   -74,   -74,   -74,   -74,    50,    15,   152,   -74,
        -:  848:     -74,   228,    30,   -74,   133,   224,   -74,   -74,   315,    50,
        -:  849:      34,   -74
        -:  850:};
        -:  851:
        -:  852:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  853:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  854:     means the default is an error.  */
        -:  855:static const yytype_uint8 yydefact[] =
        -:  856:{
        -:  857:       2,     0,     1,    18,     8,     0,     4,     3,     0,     7,
        -:  858:       6,     5,     9,     0,    20,    21,    19,    10,    22,     0,
        -:  859:       0,    24,    23,    13,    25,     0,    15,     0,     0,    11,
        -:  860:       0,    14,    26,     0,     0,     0,    27,     0,    16,    33,
        -:  861:       0,     0,    29,    28,    31,    32,     0,    35,    34,     0,
        -:  862:      12,    30,     0,     0,     0,    65,    79,   128,   130,   132,
        -:  863:     125,   126,     0,   127,    73,   122,   123,   119,   120,     0,
        -:  864:      75,    76,     0,     0,     0,     0,   133,   146,    17,    74,
        -:  865:       0,   100,    41,    55,    62,     0,     0,     0,     0,     0,
        -:  866:       0,     0,   118,    89,   134,   143,     0,    74,   100,    69,
        -:  867:       0,     0,    92,    90,     0,     0,     0,     0,     0,     0,
        -:  868:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  869:       0,     0,     0,    36,    38,    40,    80,     0,    81,     0,
        -:  870:       0,     0,     0,    82,     0,     0,   101,   121,     0,    70,
        -:  871:      71,    66,     0,     0,     0,   113,   111,    88,    77,    78,
        -:  872:      98,    99,    94,    96,    95,    97,   144,   145,   142,   140,
        -:  873:     141,   135,   136,   137,   138,   139,    47,    44,    43,    48,
        -:  874:      51,    53,    45,    46,    42,    61,    58,    57,    59,    60,
        -:  875:      56,    64,    63,     0,   129,   131,   124,     0,   102,     0,
        -:  876:      68,     0,    67,    93,    91,     0,     0,     0,     0,     0,
        -:  877:      86,     0,     0,    72,   116,   117,     0,   114,     0,     0,
        -:  878:       0,     0,     0,     0,   104,     0,   105,   107,   103,   112,
        -:  879:       0,     0,    49,    52,    54,   108,     0,     0,   109,    84,
        -:  880:     115,     0,     0,   106,     0,     0,    50,    87,   110,     0,
        -:  881:       0,    85
        -:  882:};
        -:  883:
        -:  884:  /* YYPGOTO[NTERM-NUM].  */
        -:  885:static const yytype_int16 yypgoto[] =
        -:  886:{
        -:  887:     -74,   -74,   294,   295,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  888:     -74,   -74,   -74,   -74,   290,   -74,   285,   -74,   -74,   -74,
        -:  889:     -74,   -74,   -74,   -74,   -74,   -74,   123,   -74,   -74,   222,
        -:  890:     -49,   -73,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
        -:  891:     139,   -74,   191,   -74,   -74,   106,   259,   -68
        -:  892:};
        -:  893:
        -:  894:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  895:static const yytype_int16 yydefgoto[] =
        -:  896:{
        -:  897:      -1,     1,     6,     7,    18,    34,    26,    29,    41,     8,
        -:  898:      16,    20,    22,    31,    32,    38,    39,    52,    53,    54,
        -:  899:     123,   174,   124,   180,   125,   182,    76,   138,   139,    77,
        -:  900:      96,    79,   135,   235,   212,   144,   143,   189,   215,   216,
        -:  901:     128,   227,   147,   195,   206,   207,    80,    81
        -:  902:};
        -:  903:
        -:  904:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  905:     positive, shift that token.  If negative, reduce the rule whose
        -:  906:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  907:static const yytype_int16 yytable[] =
        -:  908:{
        -:  909:      78,    92,    97,     5,   145,    94,    95,    98,    85,    12,
        -:  910:     204,    17,    55,    86,   205,   201,   221,   126,    19,   129,
        -:  911:     130,   131,   132,    93,    21,   133,   140,     9,   222,   -39,
        -:  912:     -37,    42,    24,   142,    43,   -83,   146,    23,   149,   150,
        -:  913:     151,   152,   153,   154,   155,   156,   157,   158,   159,   160,
        -:  914:     161,   162,   163,   164,   165,   202,    44,    45,    27,   183,
        -:  915:     134,    55,    56,    57,    58,    59,    25,    60,    61,    62,
        -:  916:      63,   213,    64,    46,   102,   103,   219,    28,   102,   103,
        -:  917:     220,    65,    66,    67,    68,    33,   233,    69,    30,   175,
        -:  918:     234,    35,    70,    71,   193,   194,    72,     2,     3,    37,
        -:  919:       4,   237,   -18,   -18,   -18,   241,   176,   177,    40,    73,
        -:  920:      47,   178,   179,    74,    99,    49,   100,   101,   203,    55,
        -:  921:      75,    57,    58,    59,    50,    60,    61,    62,    63,    82,
        -:  922:      64,   211,   118,   119,   120,   121,   122,    51,     5,    65,
        -:  923:      66,    67,    68,    83,    55,   228,    57,    58,    59,    84,
        -:  924:      60,    61,    62,    63,    87,    64,   199,    88,    13,    14,
        -:  925:      15,    89,   166,   104,    65,    66,   238,    73,   102,   103,
        -:  926:     127,    74,   120,   121,   122,   -74,   -74,   232,    90,   167,
        -:  927:     168,   169,   170,   171,   172,   173,   136,   141,    64,   181,
        -:  928:     240,   188,    73,   113,   114,   196,    74,   117,   118,   119,
        -:  929:     120,   121,   122,    90,   191,   113,   114,   115,   116,   117,
        -:  930:     118,   119,   120,   121,   122,  -118,   113,   114,   105,   106,
        -:  931:     190,   118,   119,   120,   121,   122,   107,   108,   109,   110,
        -:  932:     111,   112,   113,   114,   115,   116,   117,   118,   119,   120,
        -:  933:     121,   122,  -118,   197,   198,   105,   106,   103,   208,   200,
        -:  934:     137,   218,   209,   107,   108,   109,   110,   111,   112,   113,
        -:  935:     114,   115,   116,   117,   118,   119,   120,   121,   122,   113,
        -:  936:     114,   115,   116,   117,   118,   119,   120,   121,   122,   113,
        -:  937:     114,   115,   116,   117,   118,   119,   120,   121,   122,   210,
        -:  938:     184,   223,   224,   226,   239,   229,   231,    10,    11,   236,
        -:  939:     185,   113,   114,   115,   116,   117,   118,   119,   120,   121,
        -:  940:     122,   113,   114,   115,   116,   117,   118,   119,   120,   121,
        -:  941:     122,    36,   192,    48,   214,   187,   230,   148,    91,   186,
        -:  942:     113,   114,   115,   116,   117,   118,   119,   120,   121,   122,
        -:  943:     217,     0,     0,     0,     0,     0,     0,     0,   137,   113,
        -:  944:     114,   115,   116,   117,   118,   119,   120,   121,   122,     0,
        -:  945:       0,     0,     0,     0,     0,     0,     0,   225,   113,   114,
        -:  946:     115,   116,   117,   118,   119,   120,   121,   122,   113,   114,
        -:  947:       0,   116,   117,   118,   119,   120,   121,   122
        -:  948:};
        -:  949:
        -:  950:static const yytype_int16 yycheck[] =
        -:  951:{
        -:  952:      49,    69,    75,    41,    38,    73,    74,    75,    30,    20,
        -:  953:      12,    11,    11,    35,    16,    35,    59,    85,    68,    87,
        -:  954:      88,    89,    90,    72,    11,     1,    99,    65,    71,    21,
        -:  955:      22,    17,    11,   101,    20,    11,    70,    66,   106,   107,
        -:  956:     108,   109,   110,   111,   112,   113,   114,   115,   116,   117,
        -:  957:     118,   119,   120,   121,   122,    75,    42,    43,    68,   127,
        -:  958:      36,    11,    12,    13,    14,    15,     8,    17,    18,    19,
        -:  959:      20,    70,    22,    59,    44,    45,    71,     9,    44,    45,
        -:  960:      75,    31,    32,    33,    34,    68,    71,    37,    11,     6,
        -:  961:      75,    69,    42,    43,   143,   144,    46,     0,     1,    12,
        -:  962:       3,    71,     5,     6,     7,    71,    23,    24,    10,    59,
        -:  963:      69,    28,    29,    63,    70,    68,    72,    73,   191,    11,
        -:  964:      70,    13,    14,    15,    67,    17,    18,    19,    20,    20,
        -:  965:      22,   199,    58,    59,    60,    61,    62,    17,    41,    31,
        -:  966:      32,    33,    34,    22,    11,   213,    13,    14,    15,    21,
        -:  967:      17,    18,    19,    20,    73,    22,     4,    73,     5,     6,
        -:  968:       7,    70,     6,    36,    31,    32,   234,    59,    44,    45,
        -:  969:      70,    63,    60,    61,    62,    44,    45,   226,    70,    23,
        -:  970:      24,    25,    26,    27,    28,    29,    71,    11,    22,     6,
        -:  971:     239,    11,    59,    53,    54,    70,    63,    57,    58,    59,
        -:  972:      60,    61,    62,    70,    75,    53,    54,    55,    56,    57,
        -:  973:      58,    59,    60,    61,    62,    36,    53,    54,    39,    40,
        -:  974:      71,    58,    59,    60,    61,    62,    47,    48,    49,    50,
        -:  975:      51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
        -:  976:      61,    62,    36,    70,    70,    39,    40,    45,    17,    68,
        -:  977:      71,    11,    20,    47,    48,    49,    50,    51,    52,    53,
        -:  978:      54,    55,    56,    57,    58,    59,    60,    61,    62,    53,
        -:  979:      54,    55,    56,    57,    58,    59,    60,    61,    62,    53,
        -:  980:      54,    55,    56,    57,    58,    59,    60,    61,    62,    20,
        -:  981:      74,    71,    71,    70,    70,    68,    17,     3,     3,    71,
        -:  982:      74,    53,    54,    55,    56,    57,    58,    59,    60,    61,
        -:  983:      62,    53,    54,    55,    56,    57,    58,    59,    60,    61,
        -:  984:      62,    31,    74,    38,   201,   134,   220,   105,    69,    71,
        -:  985:      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
        -:  986:     201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    53,
        -:  987:      54,    55,    56,    57,    58,    59,    60,    61,    62,    -1,
        -:  988:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    71,    53,    54,
        -:  989:      55,    56,    57,    58,    59,    60,    61,    62,    53,    54,
        -:  990:      -1,    56,    57,    58,    59,    60,    61,    62
        -:  991:};
        -:  992:
        -:  993:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  994:     symbol of state STATE-NUM.  */
        -:  995:static const yytype_int8 yystos[] =
        -:  996:{
        -:  997:       0,    77,     0,     1,     3,    41,    78,    79,    85,    65,
        -:  998:      78,    79,    20,     5,     6,     7,    86,    11,    80,    68,
        -:  999:      87,    11,    88,    66,    11,     8,    82,    68,     9,    83,
        -: 1000:      11,    89,    90,    68,    81,    69,    90,    12,    91,    92,
        -: 1001:      10,    84,    17,    20,    42,    43,    59,    69,    92,    68,
        -: 1002:      67,    17,    93,    94,    95,    11,    12,    13,    14,    15,
        -: 1003:      17,    18,    19,    20,    22,    31,    32,    33,    34,    37,
        -: 1004:      42,    43,    46,    59,    63,    70,   102,   105,   106,   107,
        -: 1005:     122,   123,    20,    22,    21,    30,    35,    73,    73,    70,
        -: 1006:      70,   122,   123,   106,   123,   123,   106,   107,   123,    70,
        -: 1007:      72,    73,    44,    45,    36,    39,    40,    47,    48,    49,
        -: 1008:      50,    51,    52,    53,    54,    55,    56,    57,    58,    59,
        -: 1009:      60,    61,    62,    96,    98,   100,   123,    70,   116,   123,
        -: 1010:     123,   123,   123,     1,    36,   108,    71,    71,   103,   104,
        -: 1011:     107,    11,   123,   112,   111,    38,    70,   118,   105,   123,
        -: 1012:     123,   123,   123,   123,   123,   123,   123,   123,   123,   123,
        -: 1013:     123,   123,   123,   123,   123,   123,     6,    23,    24,    25,
        -: 1014:      26,    27,    28,    29,    97,     6,    23,    24,    28,    29,
        -: 1015:      99,     6,   101,   123,    74,    74,    71,   118,    11,   113,
        -: 1016:      71,    75,    74,   106,   106,   119,    70,    70,    70,     4,
        -: 1017:      68,    35,    75,   107,    12,    16,   120,   121,    17,    20,
        -: 1018:      20,   123,   110,    70,   102,   114,   115,   116,    11,    71,
        -: 1019:      75,    59,    71,    71,    71,    71,    70,   117,   123,    68,
        -: 1020:     121,    17,   106,    71,    75,   109,    71,    71,   123,    70,
        -: 1021:     106,    71
        -: 1022:};
        -: 1023:
        -: 1024:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -: 1025:static const yytype_int8 yyr1[] =
        -: 1026:{
        -: 1027:       0,    76,    77,    77,    77,    77,    77,    77,    77,    78,
        -: 1028:      80,    81,    79,    82,    82,    83,    83,    84,    85,    85,
        -: 1029:      86,    86,    87,    87,    88,    88,    89,    89,    90,    90,
        -: 1030:      90,    90,    90,    91,    91,    93,    92,    94,    92,    95,
        -: 1031:      92,    96,    96,    97,    97,    97,    97,    97,    97,    97,
        -: 1032:      97,    97,    97,    97,    97,    98,    98,    99,    99,    99,
        -: 1033:      99,    99,   100,   100,   101,   102,   102,   102,   102,   103,
        -: 1034:     103,   104,   104,   105,   106,   107,   107,   107,   107,   107,
        -: 1035:     107,   107,   107,   108,   109,   107,   110,   107,   107,   107,
        -: 1036:     111,   107,   112,   107,   107,   107,   107,   107,   107,   107,
        -: 1037:     107,   107,   113,   113,   114,   114,   115,   115,   116,   117,
        -: 1038:     117,   119,   118,   118,   120,   120,   121,   121,   122,   122,
        -: 1039:     122,   123,   123,   123,   123,   123,   123,   123,   123,   123,
        -: 1040:     123,   123,   123,   123,   123,   123,   123,   123,   123,   123,
        -: 1041:     123,   123,   123,   123,   123,   123,   123
        -: 1042:};
        -: 1043:
        -: 1044:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -: 1045:static const yytype_int8 yyr2[] =
        -: 1046:{
        -: 1047:       0,     2,     0,     2,     2,     3,     3,     3,     2,     2,
        -: 1048:       0,     0,    11,     0,     3,     0,     3,     3,     0,     2,
        -: 1049:       1,     1,     0,     2,     1,     2,     1,     2,     3,     3,
        -: 1050:       4,     3,     3,     1,     2,     0,     5,     0,     5,     0,
        -: 1051:       5,     0,     2,     1,     1,     1,     1,     1,     1,     4,
        -: 1052:       6,     1,     4,     1,     4,     0,     2,     1,     1,     1,
        -: 1053:       1,     1,     0,     2,     1,     1,     3,     4,     4,     0,
        -: 1054:       1,     1,     3,     1,     1,     1,     1,     3,     3,     1,
        -: 1055:       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,
        -: 1056:       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,
        -: 1057:       1,     3,     1,     3,     1,     1,     3,     1,     5,     1,
        -: 1058:       3,     0,     4,     1,     1,     3,     1,     1,     1,     1,
        -: 1059:       1,     3,     1,     1,     4,     1,     1,     1,     1,     4,
        -: 1060:       1,     4,     1,     1,     2,     3,     3,     3,     3,     3,
        -: 1061:       3,     3,     3,     2,     3,     3,     1
        -: 1062:};
        -: 1063:
        -: 1064:
        -: 1065:#define yyerrok         (yyerrstatus = 0)
        -: 1066:#define yyclearin       (yychar = YYEMPTY)
        -: 1067:#define YYEMPTY         (-2)
        -: 1068:#define YYEOF           0
        -: 1069:
        -: 1070:#define YYACCEPT        goto yyacceptlab
        -: 1071:#define YYABORT         goto yyabortlab
        -: 1072:#define YYERROR         goto yyerrorlab
        -: 1073:
        -: 1074:
        -: 1075:#define YYRECOVERING()  (!!yyerrstatus)
        -: 1076:
        -: 1077:#define YYBACKUP(Token, Value)                                    \
        -: 1078:  do                                                              \
        -: 1079:    if (yychar == YYEMPTY)                                        \
        -: 1080:      {                                                           \
        -: 1081:        yychar = (Token);                                         \
        -: 1082:        yylval = (Value);                                         \
        -: 1083:        YYPOPSTACK (yylen);                                       \
        -: 1084:        yystate = *yyssp;                                         \
        -: 1085:        goto yybackup;                                            \
        -: 1086:      }                                                           \
        -: 1087:    else                                                          \
        -: 1088:      {                                                           \
        -: 1089:        yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -: 1090:        YYERROR;                                                  \
        -: 1091:      }                                                           \
        -: 1092:  while (0)
        -: 1093:
        -: 1094:/* Error token number */
        -: 1095:#define YYTERROR        1
        -: 1096:#define YYERRCODE       256
        -: 1097:
        -: 1098:
        -: 1099:
        -: 1100:/* Enable debugging if requested.  */
        -: 1101:#if YYDEBUG
        -: 1102:
        -: 1103:# ifndef YYFPRINTF
        -: 1104:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -: 1105:#  define YYFPRINTF fprintf
        -: 1106:# endif
        -: 1107:
        -: 1108:# define YYDPRINTF(Args)                        \
        -: 1109:do {                                            \
        -: 1110:  if (yydebug)                                  \
        -: 1111:    YYFPRINTF Args;                             \
        -: 1112:} while (0)
        -: 1113:
        -: 1114:/* This macro is provided for backward compatibility. */
        -: 1115:#ifndef YY_LOCATION_PRINT
        -: 1116:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -: 1117:#endif
        -: 1118:
        -: 1119:
        -: 1120:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -: 1121:do {                                                                      \
        -: 1122:  if (yydebug)                                                            \
        -: 1123:    {                                                                     \
        -: 1124:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -: 1125:      yy_symbol_print (stderr,                                            \
        -: 1126:                  Type, Value, yyscanner, compiler); \
        -: 1127:      YYFPRINTF (stderr, "\n");                                           \
        -: 1128:    }                                                                     \
        -: 1129:} while (0)
        -: 1130:
        -: 1131:
        -: 1132:/*-----------------------------------.
        -: 1133:| Print this symbol's value on YYO.  |
        -: 1134:`-----------------------------------*/
        -: 1135:
        -: 1136:static void
        -: 1137:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1138:{
        -: 1139:  FILE *yyoutput = yyo;
        -: 1140:  YYUSE (yyoutput);
        -: 1141:  YYUSE (yyscanner);
        -: 1142:  YYUSE (compiler);
        -: 1143:  if (!yyvaluep)
        -: 1144:    return;
        -: 1145:# ifdef YYPRINT
        -: 1146:  if (yytype < YYNTOKENS)
        -: 1147:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -: 1148:# endif
        -: 1149:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -: 1150:  YYUSE (yytype);
        -: 1151:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1152:}
        -: 1153:
        -: 1154:
        -: 1155:/*---------------------------.
        -: 1156:| Print this symbol on YYO.  |
        -: 1157:`---------------------------*/
        -: 1158:
        -: 1159:static void
        -: 1160:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1161:{
        -: 1162:  YYFPRINTF (yyo, "%s %s (",
        -: 1163:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1164:
        -: 1165:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, compiler);
        -: 1166:  YYFPRINTF (yyo, ")");
        -: 1167:}
        -: 1168:
        -: 1169:/*------------------------------------------------------------------.
        -: 1170:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1171:| TOP (included).                                                   |
        -: 1172:`------------------------------------------------------------------*/
        -: 1173:
        -: 1174:static void
        -: 1175:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -: 1176:{
        -: 1177:  YYFPRINTF (stderr, "Stack now");
        -: 1178:  for (; yybottom <= yytop; yybottom++)
        -: 1179:    {
        -: 1180:      int yybot = *yybottom;
        -: 1181:      YYFPRINTF (stderr, " %d", yybot);
        -: 1182:    }
        -: 1183:  YYFPRINTF (stderr, "\n");
        -: 1184:}
        -: 1185:
        -: 1186:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1187:do {                                                            \
        -: 1188:  if (yydebug)                                                  \
        -: 1189:    yy_stack_print ((Bottom), (Top));                           \
        -: 1190:} while (0)
        -: 1191:
        -: 1192:
        -: 1193:/*------------------------------------------------.
        -: 1194:| Report that the YYRULE is going to be reduced.  |
        -: 1195:`------------------------------------------------*/
        -: 1196:
        -: 1197:static void
        -: 1198:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1199:{
        -: 1200:  int yylno = yyrline[yyrule];
        -: 1201:  int yynrhs = yyr2[yyrule];
        -: 1202:  int yyi;
        -: 1203:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -: 1204:             yyrule - 1, yylno);
        -: 1205:  /* The symbols being reduced.  */
        -: 1206:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1207:    {
        -: 1208:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1209:      yy_symbol_print (stderr,
        -: 1210:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -: 1211:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -: 1212:                                              , yyscanner, compiler);
        -: 1213:      YYFPRINTF (stderr, "\n");
        -: 1214:    }
        -: 1215:}
        -: 1216:
        -: 1217:# define YY_REDUCE_PRINT(Rule)          \
        -: 1218:do {                                    \
        -: 1219:  if (yydebug)                          \
        -: 1220:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1221:} while (0)
        -: 1222:
        -: 1223:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1224:   multiple parsers can coexist.  */
        -: 1225:int yydebug;
        -: 1226:#else /* !YYDEBUG */
        -: 1227:# define YYDPRINTF(Args)
        -: 1228:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1229:# define YY_STACK_PRINT(Bottom, Top)
        -: 1230:# define YY_REDUCE_PRINT(Rule)
        -: 1231:#endif /* !YYDEBUG */
        -: 1232:
        -: 1233:
        -: 1234:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1235:#ifndef YYINITDEPTH
        -: 1236:# define YYINITDEPTH 200
        -: 1237:#endif
        -: 1238:
        -: 1239:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1240:   if the built-in stack extension method is used).
        -: 1241:
        -: 1242:   Do not make this value too large; the results are undefined if
        -: 1243:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1244:   evaluated with infinite-precision integer arithmetic.  */
        -: 1245:
        -: 1246:#ifndef YYMAXDEPTH
        -: 1247:# define YYMAXDEPTH 10000
        -: 1248:#endif
        -: 1249:
        -: 1250:
        -: 1251:#if YYERROR_VERBOSE
        -: 1252:
        -: 1253:# ifndef yystrlen
        -: 1254:#  if defined __GLIBC__ && defined _STRING_H
        -: 1255:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -: 1256:#  else
        -: 1257:/* Return the length of YYSTR.  */
        -: 1258:static YYPTRDIFF_T
        -: 1259:yystrlen (const char *yystr)
        -: 1260:{
        -: 1261:  YYPTRDIFF_T yylen;
        -: 1262:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1263:    continue;
        -: 1264:  return yylen;
        -: 1265:}
        -: 1266:#  endif
        -: 1267:# endif
        -: 1268:
        -: 1269:# ifndef yystpcpy
        -: 1270:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1271:#   define yystpcpy stpcpy
        -: 1272:#  else
        -: 1273:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1274:   YYDEST.  */
        -: 1275:static char *
        -: 1276:yystpcpy (char *yydest, const char *yysrc)
        -: 1277:{
        -: 1278:  char *yyd = yydest;
        -: 1279:  const char *yys = yysrc;
        -: 1280:
        -: 1281:  while ((*yyd++ = *yys++) != '\0')
        -: 1282:    continue;
        -: 1283:
        -: 1284:  return yyd - 1;
        -: 1285:}
        -: 1286:#  endif
        -: 1287:# endif
        -: 1288:
        -: 1289:# ifndef yytnamerr
        -: 1290:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1291:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1292:   heuristic is that double-quoting is unnecessary unless the string
        -: 1293:   contains an apostrophe, a comma, or backslash (other than
        -: 1294:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1295:   null, do not copy; instead, return the length of what the result
        -: 1296:   would have been.  */
        -: 1297:static YYPTRDIFF_T
       24: 1298:yytnamerr (char *yyres, const char *yystr)
        -: 1299:{
       24: 1300:  if (*yystr == '"')
        -: 1301:    {
       22: 1302:      YYPTRDIFF_T yyn = 0;
       22: 1303:      char const *yyp = yystr;
        -: 1304:
        -: 1305:      for (;;)
      194: 1306:        switch (*++yyp)
        -: 1307:          {
    #####: 1308:          case '\'':
        -: 1309:          case ',':
    #####: 1310:            goto do_not_strip_quotes;
        -: 1311:
    #####: 1312:          case '\\':
    #####: 1313:            if (*++yyp != '\\')
    #####: 1314:              goto do_not_strip_quotes;
        -: 1315:            else
    #####: 1316:              goto append;
        -: 1317:
      172: 1318:          append:
        -: 1319:          default:
      172: 1320:            if (yyres)
       86: 1321:              yyres[yyn] = *yyp;
      172: 1322:            yyn++;
      172: 1323:            break;
        -: 1324:
       22: 1325:          case '"':
       22: 1326:            if (yyres)
       11: 1327:              yyres[yyn] = '\0';
       22: 1328:            return yyn;
        -: 1329:          }
        2: 1330:    do_not_strip_quotes: ;
        -: 1331:    }
        -: 1332:
        2: 1333:  if (yyres)
        1: 1334:    return yystpcpy (yyres, yystr) - yyres;
        -: 1335:  else
        1: 1336:    return yystrlen (yystr);
        -: 1337:}
        -: 1338:# endif
        -: 1339:
        -: 1340:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1341:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1342:   YYSSP.
        -: 1343:
        -: 1344:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1345:   not large enough to hold the message.  In that case, also set
        -: 1346:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1347:   required number of bytes is too large to store.  */
        -: 1348:static int
        6: 1349:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -: 1350:                yy_state_t *yyssp, int yytoken)
        -: 1351:{
        -: 1352:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1353:  /* Internationalized format string. */
        6: 1354:  const char *yyformat = YY_NULLPTR;
        -: 1355:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -: 1356:     one per "expected"). */
        -: 1357:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1358:  /* Actual size of YYARG. */
        6: 1359:  int yycount = 0;
        -: 1360:  /* Cumulated lengths of YYARG.  */
        6: 1361:  YYPTRDIFF_T yysize = 0;
        -: 1362:
        -: 1363:  /* There are many possibilities here to consider:
        -: 1364:     - If this state is a consistent state with a default action, then
        -: 1365:       the only way this function was invoked is if the default action
        -: 1366:       is an error action.  In that case, don't check for expected
        -: 1367:       tokens because there are none.
        -: 1368:     - The only way there can be no lookahead present (in yychar) is if
        -: 1369:       this state is a consistent state with a default action.  Thus,
        -: 1370:       detecting the absence of a lookahead is sufficient to determine
        -: 1371:       that there is no unexpected or expected token to report.  In that
        -: 1372:       case, just report a simple "syntax error".
        -: 1373:     - Don't assume there isn't a lookahead just because this state is a
        -: 1374:       consistent state with a default action.  There might have been a
        -: 1375:       previous inconsistent state, consistent state with a non-default
        -: 1376:       action, or user semantic action that manipulated yychar.
        -: 1377:     - Of course, the expected token list depends on states to have
        -: 1378:       correct lookahead information, and it depends on the parser not
        -: 1379:       to perform extra reductions after fetching a lookahead from the
        -: 1380:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1381:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1382:       token list.  However, the list is correct for canonical LR with
        -: 1383:       one exception: it will still contain any token that will not be
        -: 1384:       accepted due to an error action in a later state.
        -: 1385:  */
        6: 1386:  if (yytoken != YYEMPTY)
        -: 1387:    {
        6: 1388:      int yyn = yypact[+*yyssp];
        6: 1389:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
        6: 1390:      yysize = yysize0;
        6: 1391:      yyarg[yycount++] = yytname[yytoken];
        6: 1392:      if (!yypact_value_is_default (yyn))
        -: 1393:        {
        -: 1394:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1395:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1396:             this state because they are default actions.  */
        6: 1397:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1398:          /* Stay within bounds of both yycheck and yytname.  */
        6: 1399:          int yychecklim = YYLAST - yyn + 1;
        6: 1400:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1401:          int yyx;
        -: 1402:
      433: 1403:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
      427: 1404:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
        6: 1405:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1406:              {
        6: 1407:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1408:                  {
    #####: 1409:                    yycount = 1;
    #####: 1410:                    yysize = yysize0;
    #####: 1411:                    break;
        -: 1412:                  }
        6: 1413:                yyarg[yycount++] = yytname[yyx];
        -: 1414:                {
        6: 1415:                  YYPTRDIFF_T yysize1
        6: 1416:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
        6: 1417:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        6: 1418:                    yysize = yysize1;
        -: 1419:                  else
    #####: 1420:                    return 2;
        -: 1421:                }
        -: 1422:              }
        -: 1423:        }
        -: 1424:    }
        -: 1425:
        6: 1426:  switch (yycount)
        -: 1427:    {
        -: 1428:# define YYCASE_(N, S)                      \
        -: 1429:      case N:                               \
        -: 1430:        yyformat = S;                       \
        -: 1431:      break
    #####: 1432:    default: /* Avoid compiler warnings. */
    #####: 1433:      YYCASE_(0, YY_("syntax error"));
    #####: 1434:      YYCASE_(1, YY_("syntax error, unexpected %s"));
        6: 1435:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1436:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1437:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1438:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1439:# undef YYCASE_
        -: 1440:    }
        -: 1441:
        -: 1442:  {
        -: 1443:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1444:       the terminator.  */
        6: 1445:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
        6: 1446:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
        6: 1447:      yysize = yysize1;
        -: 1448:    else
    #####: 1449:      return 2;
        -: 1450:  }
        -: 1451:
        6: 1452:  if (*yymsg_alloc < yysize)
        -: 1453:    {
    #####: 1454:      *yymsg_alloc = 2 * yysize;
    #####: 1455:      if (! (yysize <= *yymsg_alloc
        -: 1456:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1457:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1458:      return 1;
        -: 1459:    }
        -: 1460:
        -: 1461:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1462:     Don't have undefined behavior even if the translation
        -: 1463:     produced a string with the wrong number of "%s"s.  */
        -: 1464:  {
        6: 1465:    char *yyp = *yymsg;
        6: 1466:    int yyi = 0;
      240: 1467:    while ((*yyp = *yyformat) != '\0')
      234: 1468:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1469:        {
       12: 1470:          yyp += yytnamerr (yyp, yyarg[yyi++]);
       12: 1471:          yyformat += 2;
        -: 1472:        }
        -: 1473:      else
        -: 1474:        {
      222: 1475:          ++yyp;
      222: 1476:          ++yyformat;
        -: 1477:        }
        -: 1478:  }
        6: 1479:  return 0;
        -: 1480:}
        -: 1481:#endif /* YYERROR_VERBOSE */
        -: 1482:
        -: 1483:/*-----------------------------------------------.
        -: 1484:| Release the memory associated to this symbol.  |
        -: 1485:`-----------------------------------------------*/
        -: 1486:
        -: 1487:static void
      177: 1488:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1489:{
        -: 1490:  YYUSE (yyvaluep);
        -: 1491:  YYUSE (yyscanner);
        -: 1492:  YYUSE (compiler);
      177: 1493:  if (!yymsg)
    #####: 1494:    yymsg = "Deleting";
        -: 1495:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1496:
        -: 1497:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
      177: 1498:  switch (yytype)
        -: 1499:    {
        7: 1500:    case 11: /* "identifier"  */
        -: 1501:#line 267 "grammar.y"
        -: 1502:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1503:#line 1504 "grammar.c"
        7: 1504:        break;
        -: 1505:
        5: 1506:    case 12: /* "string identifier"  */
        -: 1507:#line 271 "grammar.y"
        -: 1508:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1509:#line 1510 "grammar.c"
        5: 1510:        break;
        -: 1511:
    #####: 1512:    case 13: /* "string count"  */
        -: 1513:#line 268 "grammar.y"
        -: 1514:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1515:#line 1516 "grammar.c"
    #####: 1516:        break;
        -: 1517:
    #####: 1518:    case 14: /* "string offset"  */
        -: 1519:#line 269 "grammar.y"
        -: 1520:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1521:#line 1522 "grammar.c"
    #####: 1522:        break;
        -: 1523:
    #####: 1524:    case 15: /* "string length"  */
        -: 1525:#line 270 "grammar.y"
        -: 1526:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1527:#line 1528 "grammar.c"
    #####: 1528:        break;
        -: 1529:
    #####: 1530:    case 16: /* "string identifier with wildcard"  */
        -: 1531:#line 272 "grammar.y"
        -: 1532:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1533:#line 1534 "grammar.c"
    #####: 1534:        break;
        -: 1535:
    #####: 1536:    case 20: /* "text string"  */
        -: 1537:#line 273 "grammar.y"
        -: 1538:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1539:#line 1540 "grammar.c"
    #####: 1540:        break;
        -: 1541:
    #####: 1542:    case 21: /* "hex string"  */
        -: 1543:#line 274 "grammar.y"
        -: 1544:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1545:#line 1546 "grammar.c"
    #####: 1546:        break;
        -: 1547:
    #####: 1548:    case 22: /* "regular expression"  */
        -: 1549:#line 275 "grammar.y"
        -: 1550:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1551:#line 1552 "grammar.c"
    #####: 1552:        break;
        -: 1553:
    #####: 1554:    case 96: /* string_modifiers  */
        -: 1555:#line 288 "grammar.y"
        -: 1556:            {
        -: 1557:  if (((*yyvaluep).modifier).alphabet != NULL)
        -: 1558:  {
        -: 1559:    yr_free(((*yyvaluep).modifier).alphabet);
        -: 1560:    ((*yyvaluep).modifier).alphabet = NULL;
        -: 1561:  }
        -: 1562:}
        -: 1563:#line 1564 "grammar.c"
    #####: 1564:        break;
        -: 1565:
    #####: 1566:    case 97: /* string_modifier  */
        -: 1567:#line 280 "grammar.y"
        -: 1568:            {
        -: 1569:  if (((*yyvaluep).modifier).alphabet != NULL)
        -: 1570:  {
        -: 1571:    yr_free(((*yyvaluep).modifier).alphabet);
        -: 1572:    ((*yyvaluep).modifier).alphabet = NULL;
        -: 1573:  }
        -: 1574:}
        -: 1575:#line 1576 "grammar.c"
    #####: 1576:        break;
        -: 1577:
    #####: 1578:    case 103: /* arguments  */
        -: 1579:#line 277 "grammar.y"
        -: 1580:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1581:#line 1582 "grammar.c"
    #####: 1582:        break;
        -: 1583:
    #####: 1584:    case 104: /* arguments_list  */
        -: 1585:#line 278 "grammar.y"
        -: 1586:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1587:#line 1588 "grammar.c"
    #####: 1588:        break;
        -: 1589:
      165: 1590:      default:
      165: 1591:        break;
        -: 1592:    }
        -: 1593:  YY_IGNORE_MAYBE_UNINITIALIZED_END
      177: 1594:}
        -: 1595:
        -: 1596:
        -: 1597:
        -: 1598:
        -: 1599:/*----------.
        -: 1600:| yyparse.  |
        -: 1601:`----------*/
        -: 1602:
        -: 1603:int
        7: 1604:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1605:{
        -: 1606:/* The lookahead symbol.  */
        -: 1607:int yychar;
        -: 1608:
        -: 1609:
        -: 1610:/* The semantic value of the lookahead symbol.  */
        -: 1611:/* Default value used for initialization, for pacifying older GCCs
        -: 1612:   or non-GCC compilers.  */
        -: 1613:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1614:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1615:
        -: 1616:    /* Number of syntax errors so far.  */
        -: 1617:    int yynerrs;
        -: 1618:
        -: 1619:    yy_state_fast_t yystate;
        -: 1620:    /* Number of tokens to shift before error messages enabled.  */
        -: 1621:    int yyerrstatus;
        -: 1622:
        -: 1623:    /* The stacks and their tools:
        -: 1624:       'yyss': related to states.
        -: 1625:       'yyvs': related to semantic values.
        -: 1626:
        -: 1627:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1628:       to reallocate them elsewhere.  */
        -: 1629:
        -: 1630:    /* The state stack.  */
        -: 1631:    yy_state_t yyssa[YYINITDEPTH];
        -: 1632:    yy_state_t *yyss;
        -: 1633:    yy_state_t *yyssp;
        -: 1634:
        -: 1635:    /* The semantic value stack.  */
        -: 1636:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1637:    YYSTYPE *yyvs;
        -: 1638:    YYSTYPE *yyvsp;
        -: 1639:
        -: 1640:    YYPTRDIFF_T yystacksize;
        -: 1641:
        -: 1642:  int yyn;
        -: 1643:  int yyresult;
        -: 1644:  /* Lookahead token as an internal (translated) token number.  */
        7: 1645:  int yytoken = 0;
        -: 1646:  /* The variables used to return semantic value and location from the
        -: 1647:     action routines.  */
        -: 1648:  YYSTYPE yyval;
        -: 1649:
        -: 1650:#if YYERROR_VERBOSE
        -: 1651:  /* Buffer for error messages, and its allocated size.  */
        -: 1652:  char yymsgbuf[128];
        7: 1653:  char *yymsg = yymsgbuf;
        7: 1654:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1655:#endif
        -: 1656:
        -: 1657:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1658:
        -: 1659:  /* The number of symbols on the RHS of the reduced rule.
        -: 1660:     Keep to zero when no symbol should be popped.  */
        7: 1661:  int yylen = 0;
        -: 1662:
        7: 1663:  yyssp = yyss = yyssa;
        7: 1664:  yyvsp = yyvs = yyvsa;
        7: 1665:  yystacksize = YYINITDEPTH;
        -: 1666:
        -: 1667:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1668:
        7: 1669:  yystate = 0;
        7: 1670:  yyerrstatus = 0;
        7: 1671:  yynerrs = 0;
        7: 1672:  yychar = YYEMPTY; /* Cause a token to be read.  */
        7: 1673:  goto yysetstate;
        -: 1674:
        -: 1675:
        -: 1676:/*------------------------------------------------------------.
        -: 1677:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1678:`------------------------------------------------------------*/
      201: 1679:yynewstate:
        -: 1680:  /* In all cases, when you get here, the value and location stacks
        -: 1681:     have just been pushed.  So pushing a state here evens the stacks.  */
      201: 1682:  yyssp++;
        -: 1683:
        -: 1684:
        -: 1685:/*--------------------------------------------------------------------.
        -: 1686:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1687:`--------------------------------------------------------------------*/
      208: 1688:yysetstate:
        -: 1689:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1690:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1691:  YY_IGNORE_USELESS_CAST_BEGIN
      208: 1692:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1693:  YY_IGNORE_USELESS_CAST_END
        -: 1694:
      208: 1695:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1696:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1697:    goto yyexhaustedlab;
        -: 1698:#else
        -: 1699:    {
        -: 1700:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1701:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1702:
        -: 1703:# if defined yyoverflow
        -: 1704:      {
        -: 1705:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1706:           these so that the &'s don't force the real ones into
        -: 1707:           memory.  */
        -: 1708:        yy_state_t *yyss1 = yyss;
        -: 1709:        YYSTYPE *yyvs1 = yyvs;
        -: 1710:
        -: 1711:        /* Each stack pointer address is followed by the size of the
        -: 1712:           data in use in that stack, in bytes.  This used to be a
        -: 1713:           conditional around just the two extra args, but that might
        -: 1714:           be undefined if yyoverflow is a macro.  */
        -: 1715:        yyoverflow (YY_("memory exhausted"),
        -: 1716:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1717:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1718:                    &yystacksize);
        -: 1719:        yyss = yyss1;
        -: 1720:        yyvs = yyvs1;
        -: 1721:      }
        -: 1722:# else /* defined YYSTACK_RELOCATE */
        -: 1723:      /* Extend the stack our own way.  */
    #####: 1724:      if (YYMAXDEPTH <= yystacksize)
    #####: 1725:        goto yyexhaustedlab;
    #####: 1726:      yystacksize *= 2;
    #####: 1727:      if (YYMAXDEPTH < yystacksize)
    #####: 1728:        yystacksize = YYMAXDEPTH;
        -: 1729:
        -: 1730:      {
    #####: 1731:        yy_state_t *yyss1 = yyss;
        -: 1732:        union yyalloc *yyptr =
    #####: 1733:          YY_CAST (union yyalloc *,
        -: 1734:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1735:        if (! yyptr)
    #####: 1736:          goto yyexhaustedlab;
    #####: 1737:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1738:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1739:# undef YYSTACK_RELOCATE
    #####: 1740:        if (yyss1 != yyssa)
    #####: 1741:          YYSTACK_FREE (yyss1);
        -: 1742:      }
        -: 1743:# endif
        -: 1744:
    #####: 1745:      yyssp = yyss + yysize - 1;
    #####: 1746:      yyvsp = yyvs + yysize - 1;
        -: 1747:
        -: 1748:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1749:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1750:                  YY_CAST (long, yystacksize)));
        -: 1751:      YY_IGNORE_USELESS_CAST_END
        -: 1752:
    #####: 1753:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1754:        YYABORT;
        -: 1755:    }
        -: 1756:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1757:
      208: 1758:  if (yystate == YYFINAL)
    #####: 1759:    YYACCEPT;
        -: 1760:
      208: 1761:  goto yybackup;
        -: 1762:
        -: 1763:
        -: 1764:/*-----------.
        -: 1765:| yybackup.  |
        -: 1766:`-----------*/
      208: 1767:yybackup:
        -: 1768:  /* Do appropriate processing given the current state.  Read a
        -: 1769:     lookahead token if we need one and don't already have one.  */
        -: 1770:
        -: 1771:  /* First try to decide what to do without reference to lookahead token.  */
      208: 1772:  yyn = yypact[yystate];
      208: 1773:  if (yypact_value_is_default (yyn))
       33: 1774:    goto yydefault;
        -: 1775:
        -: 1776:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1777:
        -: 1778:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
      175: 1779:  if (yychar == YYEMPTY)
        -: 1780:    {
        -: 1781:      YYDPRINTF ((stderr, "Reading a token: "));
       92: 1782:      yychar = yylex (&yylval, yyscanner, compiler);
        -: 1783:    }
        -: 1784:
      175: 1785:  if (yychar <= YYEOF)
        -: 1786:    {
       12: 1787:      yychar = yytoken = YYEOF;
        -: 1788:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1789:    }
        -: 1790:  else
        -: 1791:    {
     163*: 1792:      yytoken = YYTRANSLATE (yychar);
        -: 1793:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1794:    }
        -: 1795:
        -: 1796:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1797:     detect an error, take that action.  */
      175: 1798:  yyn += yytoken;
      175: 1799:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
      108: 1800:    goto yydefault;
       67: 1801:  yyn = yytable[yyn];
       67: 1802:  if (yyn <= 0)
        -: 1803:    {
        -: 1804:      if (yytable_value_is_error (yyn))
        -: 1805:        goto yyerrlab;
       12: 1806:      yyn = -yyn;
       12: 1807:      goto yyreduce;
        -: 1808:    }
        -: 1809:
        -: 1810:  /* Count tokens shifted since error; after three, turn off error
        -: 1811:     status.  */
       55: 1812:  if (yyerrstatus)
        2: 1813:    yyerrstatus--;
        -: 1814:
        -: 1815:  /* Shift the lookahead token.  */
        -: 1816:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
       55: 1817:  yystate = yyn;
        -: 1818:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       55: 1819:  *++yyvsp = yylval;
        -: 1820:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1821:
        -: 1822:  /* Discard the shifted token.  */
       55: 1823:  yychar = YYEMPTY;
       55: 1824:  goto yynewstate;
        -: 1825:
        -: 1826:
        -: 1827:/*-----------------------------------------------------------.
        -: 1828:| yydefault -- do the default action for the current state.  |
        -: 1829:`-----------------------------------------------------------*/
      141: 1830:yydefault:
      141: 1831:  yyn = yydefact[yystate];
      141: 1832:  if (yyn == 0)
       43: 1833:    goto yyerrlab;
       98: 1834:  goto yyreduce;
        -: 1835:
        -: 1836:
        -: 1837:/*-----------------------------.
        -: 1838:| yyreduce -- do a reduction.  |
        -: 1839:`-----------------------------*/
      110: 1840:yyreduce:
        -: 1841:  /* yyn is the number of a rule to reduce with.  */
      110: 1842:  yylen = yyr2[yyn];
        -: 1843:
        -: 1844:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1845:     '$$ = $1'.
        -: 1846:
        -: 1847:     Otherwise, the following line sets YYVAL to garbage.
        -: 1848:     This behavior is undocumented and Bison
        -: 1849:     users should not rely upon it.  Assigning to YYVAL
        -: 1850:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1851:     GCC warning that YYVAL may be used uninitialized.  */
      110: 1852:  yyval = yyvsp[1-yylen];
        -: 1853:
        -: 1854:
        -: 1855:  YY_REDUCE_PRINT (yyn);
      110: 1856:  switch (yyn)
        -: 1857:    {
    #####: 1858:  case 8:
        -: 1859:#line 322 "grammar.y"
        -: 1860:      {
        -: 1861:        _yr_compiler_pop_file_name(compiler);
        -: 1862:      }
        -: 1863:#line 1864 "grammar.c"
    #####: 1864:    break;
        -: 1865:
    #####: 1866:  case 9:
        -: 1867:#line 330 "grammar.y"
        -: 1868:      {
        -: 1869:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1870:
        -: 1871:        yr_free((yyvsp[0].sized_string));
        -: 1872:
        -: 1873:        fail_if_error(result);
        -: 1874:      }
        -: 1875:#line 1876 "grammar.c"
    #####: 1876:    break;
        -: 1877:
        8: 1878:  case 10:
        -: 1879:#line 342 "grammar.y"
        -: 1880:      {
        -: 1881:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1882:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1883:      }
        -: 1884:#line 1885 "grammar.c"
        7: 1885:    break;
        -: 1886:
        5: 1887:  case 11:
        -: 1888:#line 347 "grammar.y"
        -: 1889:      {
        -: 1890:        YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(
        -: 1891:            compiler->arena, &(yyvsp[-4].rule));
        -: 1892:
        -: 1893:        rule->tags = (char*) yr_arena_ref_to_ptr(
        -: 1894:            compiler->arena, &(yyvsp[-3].tag));
        -: 1895:
        -: 1896:        rule->metas = (YR_META*) yr_arena_ref_to_ptr(
        -: 1897:            compiler->arena, &(yyvsp[-1].meta));
        -: 1898:
        -: 1899:        rule->strings = (YR_STRING*) yr_arena_ref_to_ptr(
        -: 1900:            compiler->arena, &(yyvsp[0].string));
        -: 1901:      }
        -: 1902:#line 1903 "grammar.c"
        5: 1903:    break;
        -: 1904:
    #####: 1905:  case 12:
        -: 1906:#line 361 "grammar.y"
        -: 1907:      {
        -: 1908:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1909:            yyscanner, &(yyvsp[-7].rule)); // rule created in phase 1
        -: 1910:
        -: 1911:        yr_free((yyvsp[-8].c_string));
        -: 1912:
        -: 1913:        fail_if_error(result);
        -: 1914:      }
        -: 1915:#line 1916 "grammar.c"
    #####: 1916:    break;
        -: 1917:
        6: 1918:  case 13:
        -: 1919:#line 374 "grammar.y"
        -: 1920:      {
        -: 1921:        (yyval.meta) = YR_ARENA_NULL_REF;
        -: 1922:      }
        -: 1923:#line 1924 "grammar.c"
        6: 1924:    break;
        -: 1925:
    #####: 1926:  case 14:
        -: 1927:#line 378 "grammar.y"
        -: 1928:      {
        -: 1929:        YR_META* meta = yr_arena_get_ptr(
        -: 1930:            compiler->arena,
        -: 1931:            YR_METAS_TABLE,
        -: 1932:            (compiler->current_meta_idx - 1) * sizeof(YR_META));
        -: 1933:
        -: 1934:        meta->flags |= META_FLAGS_LAST_IN_RULE;
        -: 1935:
        -: 1936:        (yyval.meta) = (yyvsp[0].meta);
        -: 1937:      }
        -: 1938:#line 1939 "grammar.c"
    #####: 1939:    break;
        -: 1940:
    #####: 1941:  case 15:
        -: 1942:#line 393 "grammar.y"
        -: 1943:      {
        -: 1944:        (yyval.string) = YR_ARENA_NULL_REF;
        -: 1945:      }
        -: 1946:#line 1947 "grammar.c"
    #####: 1947:    break;
        -: 1948:
        5: 1949:  case 16:
        -: 1950:#line 397 "grammar.y"
        -: 1951:      {
        -: 1952:        YR_STRING* string = (YR_STRING*) yr_arena_get_ptr(
        -: 1953:            compiler->arena,
        -: 1954:            YR_STRINGS_TABLE,
        -: 1955:            (compiler->current_string_idx - 1) * sizeof(YR_STRING));
        -: 1956:
        -: 1957:        string->flags |= STRING_FLAGS_LAST_IN_RULE;
        -: 1958:
        -: 1959:        (yyval.string) = (yyvsp[0].string);
        -: 1960:      }
        -: 1961:#line 1962 "grammar.c"
        5: 1962:    break;
        -: 1963:
       45: 1964:  case 18:
        -: 1965:#line 416 "grammar.y"
        -: 1966:                                       { (yyval.integer) = 0;  }
        -: 1967:#line 1968 "grammar.c"
       45: 1968:    break;
        -: 1969:
    #####: 1970:  case 19:
        -: 1971:#line 417 "grammar.y"
        -: 1972:                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1973:#line 1974 "grammar.c"
    #####: 1974:    break;
        -: 1975:
    #####: 1976:  case 20:
        -: 1977:#line 422 "grammar.y"
        -: 1978:                     { (yyval.integer) = RULE_FLAGS_PRIVATE; }
        -: 1979:#line 1980 "grammar.c"
    #####: 1980:    break;
        -: 1981:
    #####: 1982:  case 21:
        -: 1983:#line 423 "grammar.y"
        -: 1984:                     { (yyval.integer) = RULE_FLAGS_GLOBAL; }
        -: 1985:#line 1986 "grammar.c"
    #####: 1986:    break;
        -: 1987:
        7: 1988:  case 22:
        -: 1989:#line 429 "grammar.y"
        -: 1990:      {
        -: 1991:        (yyval.tag) = YR_ARENA_NULL_REF;
        -: 1992:      }
        -: 1993:#line 1994 "grammar.c"
        7: 1994:    break;
        -: 1995:
    #####: 1996:  case 23:
        -: 1997:#line 433 "grammar.y"
        -: 1998:      {
        -: 1999:        // Tags list is represented in the arena as a sequence
        -: 2000:        // of null-terminated strings, the sequence ends with an
        -: 2001:        // additional null character. Here we write the ending null
        -: 2002:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 2003:
        -: 2004:        fail_if_error(yr_arena_write_string(
        -: 2005:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, "", NULL));
        -: 2006:
        -: 2007:        (yyval.tag) = (yyvsp[0].tag);
        -: 2008:      }
        -: 2009:#line 2010 "grammar.c"
    #####: 2010:    break;
        -: 2011:
    #####: 2012:  case 24:
        -: 2013:#line 449 "grammar.y"
        -: 2014:      {
        -: 2015:        int result = yr_arena_write_string(
        -: 2016:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, (yyvsp[0].c_string), &(yyval.tag));
        -: 2017:
        -: 2018:        yr_free((yyvsp[0].c_string));
        -: 2019:
        -: 2020:        fail_if_error(result);
        -: 2021:      }
        -: 2022:#line 2023 "grammar.c"
    #####: 2023:    break;
        -: 2024:
    #####: 2025:  case 25:
        -: 2026:#line 458 "grammar.y"
        -: 2027:      {
        -: 2028:        YR_ARENA_REF ref;
        -: 2029:
        -: 2030:        // Write the new tag identifier.
        -: 2031:        int result = yr_arena_write_string(
        -: 2032:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);
        -: 2033:
        -: 2034:        yr_free((yyvsp[0].c_string));
        -: 2035:
        -: 2036:        fail_if_error(result);
        -: 2037:
        -: 2038:        // Get the address for the tag identifier just written.
        -: 2039:        char* new_tag = (char*) yr_arena_ref_to_ptr(
        -: 2040:            compiler->arena, &ref);
        -: 2041:
        -: 2042:        // Take the address of first tag's identifier in the list.
        -: 2043:        char* tag = (char*) yr_arena_ref_to_ptr(
        -: 2044:            compiler->arena, &(yyval.tag));
        -: 2045:
        -: 2046:	// Search for duplicated tags. Tags are written one after
        -: 2047:	// the other, with zeroes in between (i.e: tag1/0tag2/0tag3)
        -: 2048:	// that's why can use tag < new_tag as the condition for the
        -: 2049:	// loop.
        -: 2050:        while (tag < new_tag)
        -: 2051:        {
        -: 2052:          if (strcmp(tag, new_tag) == 0)
        -: 2053:          {
        -: 2054:            yr_compiler_set_error_extra_info(compiler, tag);
        -: 2055:            fail_with_error(ERROR_DUPLICATED_TAG_IDENTIFIER);
        -: 2056:          }
        -: 2057:
        -: 2058:          tag += strlen(tag) + 1;
        -: 2059:        }
        -: 2060:
        -: 2061:        (yyval.tag) = (yyvsp[-1].tag);
        -: 2062:      }
        -: 2063:#line 2064 "grammar.c"
    #####: 2064:    break;
        -: 2065:
    #####: 2066:  case 26:
        -: 2067:#line 499 "grammar.y"
        -: 2068:                                          {  (yyval.meta) = (yyvsp[0].meta); }
        -: 2069:#line 2070 "grammar.c"
    #####: 2070:    break;
        -: 2071:
    #####: 2072:  case 27:
        -: 2073:#line 500 "grammar.y"
        -: 2074:                                          {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 2075:#line 2076 "grammar.c"
    #####: 2076:    break;
        -: 2077:
    #####: 2078:  case 28:
        -: 2079:#line 506 "grammar.y"
        -: 2080:      {
        -: 2081:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2082:
        -: 2083:        int result = yr_parser_reduce_meta_declaration(
        -: 2084:            yyscanner,
        -: 2085:            META_TYPE_STRING,
        -: 2086:            (yyvsp[-2].c_string),
        -: 2087:            sized_string->c_string,
        -: 2088:            0,
        -: 2089:            &(yyval.meta));
        -: 2090:
        -: 2091:        yr_free((yyvsp[-2].c_string));
        -: 2092:        yr_free((yyvsp[0].sized_string));
        -: 2093:
        -: 2094:        fail_if_error(result);
        -: 2095:      }
        -: 2096:#line 2097 "grammar.c"
    #####: 2097:    break;
        -: 2098:
    #####: 2099:  case 29:
        -: 2100:#line 523 "grammar.y"
        -: 2101:      {
        -: 2102:        int result = yr_parser_reduce_meta_declaration(
        -: 2103:            yyscanner,
        -: 2104:            META_TYPE_INTEGER,
        -: 2105:            (yyvsp[-2].c_string),
        -: 2106:            NULL,
        -: 2107:            (yyvsp[0].integer),
        -: 2108:            &(yyval.meta));
        -: 2109:
        -: 2110:        yr_free((yyvsp[-2].c_string));
        -: 2111:
        -: 2112:        fail_if_error(result);
        -: 2113:      }
        -: 2114:#line 2115 "grammar.c"
    #####: 2115:    break;
        -: 2116:
    #####: 2117:  case 30:
        -: 2118:#line 537 "grammar.y"
        -: 2119:      {
        -: 2120:        int result = yr_parser_reduce_meta_declaration(
        -: 2121:            yyscanner,
        -: 2122:            META_TYPE_INTEGER,
        -: 2123:            (yyvsp[-3].c_string),
        -: 2124:            NULL,
        -: 2125:            -(yyvsp[0].integer),
        -: 2126:            &(yyval.meta));
        -: 2127:
        -: 2128:        yr_free((yyvsp[-3].c_string));
        -: 2129:
        -: 2130:        fail_if_error(result);
        -: 2131:      }
        -: 2132:#line 2133 "grammar.c"
    #####: 2133:    break;
        -: 2134:
    #####: 2135:  case 31:
        -: 2136:#line 551 "grammar.y"
        -: 2137:      {
        -: 2138:        int result = yr_parser_reduce_meta_declaration(
        -: 2139:            yyscanner,
        -: 2140:            META_TYPE_BOOLEAN,
        -: 2141:            (yyvsp[-2].c_string),
        -: 2142:            NULL,
        -: 2143:            true,
        -: 2144:            &(yyval.meta));
        -: 2145:
        -: 2146:        yr_free((yyvsp[-2].c_string));
        -: 2147:
        -: 2148:        fail_if_error(result);
        -: 2149:      }
        -: 2150:#line 2151 "grammar.c"
    #####: 2151:    break;
        -: 2152:
    #####: 2153:  case 32:
        -: 2154:#line 565 "grammar.y"
        -: 2155:      {
        -: 2156:        int result = yr_parser_reduce_meta_declaration(
        -: 2157:            yyscanner,
        -: 2158:            META_TYPE_BOOLEAN,
        -: 2159:            (yyvsp[-2].c_string),
        -: 2160:            NULL,
        -: 2161:            false,
        -: 2162:            &(yyval.meta));
        -: 2163:
        -: 2164:        yr_free((yyvsp[-2].c_string));
        -: 2165:
        -: 2166:        fail_if_error(result);
        -: 2167:      }
        -: 2168:#line 2169 "grammar.c"
    #####: 2169:    break;
        -: 2170:
        6: 2171:  case 33:
        -: 2172:#line 582 "grammar.y"
        -: 2173:                                              { (yyval.string) = (yyvsp[0].string); }
        -: 2174:#line 2175 "grammar.c"
        6: 2175:    break;
        -: 2176:
    #####: 2177:  case 34:
        -: 2178:#line 583 "grammar.y"
        -: 2179:                                              { (yyval.string) = (yyvsp[-1].string); }
        -: 2180:#line 2181 "grammar.c"
    #####: 2181:    break;
        -: 2182:
        2: 2183:  case 35:
        -: 2184:#line 589 "grammar.y"
        -: 2185:      {
        -: 2186:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2187:      }
        -: 2188:#line 2189 "grammar.c"
        2: 2189:    break;
        -: 2190:
        2: 2191:  case 36:
        -: 2192:#line 593 "grammar.y"
        -: 2193:      {
        -: 2194:        int result = yr_parser_reduce_string_declaration(
        -: 2195:            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2196:
        -: 2197:        yr_free((yyvsp[-4].c_string));
        -: 2198:        yr_free((yyvsp[-1].sized_string));
        -: 2199:        yr_free((yyvsp[0].modifier).alphabet);
        -: 2200:
        -: 2201:        fail_if_error(result);
        -: 2202:        compiler->current_line = 0;
        -: 2203:      }
        -: 2204:#line 2205 "grammar.c"
        1: 2205:    break;
        -: 2206:
        2: 2207:  case 37:
        -: 2208:#line 605 "grammar.y"
        -: 2209:      {
        -: 2210:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2211:      }
        -: 2212:#line 2213 "grammar.c"
        2: 2213:    break;
        -: 2214:
        2: 2215:  case 38:
        -: 2216:#line 609 "grammar.y"
        -: 2217:      {
        -: 2218:        int result;
        -: 2219:
        -: 2220:        (yyvsp[0].modifier).flags |= STRING_FLAGS_REGEXP;
        -: 2221:
        -: 2222:        result = yr_parser_reduce_string_declaration(
        -: 2223:            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2224:
        -: 2225:        yr_free((yyvsp[-4].c_string));
        -: 2226:        yr_free((yyvsp[-1].sized_string));
        -: 2227:
        -: 2228:        fail_if_error(result);
        -: 2229:
        -: 2230:        compiler->current_line = 0;
        -: 2231:      }
        -: 2232:#line 2233 "grammar.c"
        2: 2233:    break;
        -: 2234:
        3: 2235:  case 39:
        -: 2236:#line 625 "grammar.y"
        -: 2237:      {
        -: 2238:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2239:      }
        -: 2240:#line 2241 "grammar.c"
        3: 2241:    break;
        -: 2242:
        3: 2243:  case 40:
        -: 2244:#line 629 "grammar.y"
        -: 2245:      {
        -: 2246:        int result;
        -: 2247:
        -: 2248:        (yyvsp[0].modifier).flags |= STRING_FLAGS_HEXADECIMAL;
        -: 2249:
        -: 2250:        result = yr_parser_reduce_string_declaration(
        -: 2251:            yyscanner, (yyvsp[0].modifier), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2252:
        -: 2253:        yr_free((yyvsp[-4].c_string));
        -: 2254:        yr_free((yyvsp[-1].sized_string));
        -: 2255:
        -: 2256:        fail_if_error(result);
        -: 2257:
        -: 2258:        compiler->current_line = 0;
        -: 2259:      }
        -: 2260:#line 2261 "grammar.c"
        3: 2261:    break;
        -: 2262:
        2: 2263:  case 41:
        -: 2264:#line 649 "grammar.y"
        -: 2265:      {
        -: 2266:        (yyval.modifier).flags = 0;
        -: 2267:        (yyval.modifier).xor_min = 0;
        -: 2268:        (yyval.modifier).xor_max = 0;
        -: 2269:        (yyval.modifier).alphabet = NULL;
        -: 2270:      }
        -: 2271:#line 2272 "grammar.c"
        2: 2272:    break;
        -: 2273:
    #####: 2274:  case 42:
        -: 2275:#line 656 "grammar.y"
        -: 2276:      {
        -: 2277:        (yyval.modifier) = (yyvsp[-1].modifier);
        -: 2278:
        -: 2279:        // Only set the xor minimum and maximum if we are dealing with the
        -: 2280:        // xor modifier. If we don't check for this then we can end up with
        -: 2281:        // "xor wide" resulting in whatever is on the stack for "wide"
        -: 2282:        // overwriting the values for xor.
        -: 2283:        if ((yyvsp[0].modifier).flags & STRING_FLAGS_XOR)
        -: 2284:        {
        -: 2285:          (yyval.modifier).xor_min = (yyvsp[0].modifier).xor_min;
        -: 2286:          (yyval.modifier).xor_max = (yyvsp[0].modifier).xor_max;
        -: 2287:        }
        -: 2288:
        -: 2289:        // Only set the base64 alphabet if we are dealing with the base64
        -: 2290:        // modifier. If we don't check for this then we can end up with
        -: 2291:        // "base64 ascii" resulting in whatever is on the stack for "ascii"
        -: 2292:        // overwriting the values for base64.
        -: 2293:        if (((yyvsp[0].modifier).flags & STRING_FLAGS_BASE64) ||
        -: 2294:            ((yyvsp[0].modifier).flags & STRING_FLAGS_BASE64_WIDE))
        -: 2295:        {
        -: 2296:          if ((yyval.modifier).alphabet != NULL)
        -: 2297:          {
        -: 2298:            if (sized_string_cmp((yyval.modifier).alphabet, (yyvsp[0].modifier).alphabet) != 0)
        -: 2299:            {
        -: 2300:              yr_compiler_set_error_extra_info(
        -: 2301:                  compiler, "can not specify multiple alphabets");
        -: 2302:
        -: 2303:              yr_free((yyvsp[0].modifier).alphabet);
        -: 2304:              yr_free((yyval.modifier).alphabet);
        -: 2305:
        -: 2306:              fail_with_error(ERROR_INVALID_MODIFIER);
        -: 2307:            }
        -: 2308:            else
        -: 2309:            {
        -: 2310:              yr_free((yyvsp[0].modifier).alphabet);
        -: 2311:            }
        -: 2312:          }
        -: 2313:          else
        -: 2314:          {
        -: 2315:            (yyval.modifier).alphabet = (yyvsp[0].modifier).alphabet;
        -: 2316:          }
        -: 2317:        }
        -: 2318:
        -: 2319:        if ((yyval.modifier).flags & (yyvsp[0].modifier).flags)
        -: 2320:        {
        -: 2321:          if ((yyval.modifier).alphabet != NULL)
        -: 2322:            yr_free((yyval.modifier).alphabet);
        -: 2323:
        -: 2324:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -: 2325:        }
        -: 2326:        else
        -: 2327:        {
        -: 2328:          (yyval.modifier).flags = (yyval.modifier).flags | (yyvsp[0].modifier).flags;
        -: 2329:        }
        -: 2330:      }
        -: 2331:#line 2332 "grammar.c"
    #####: 2332:    break;
        -: 2333:
    #####: 2334:  case 43:
        -: 2335:#line 715 "grammar.y"
        -: 2336:                    { (yyval.modifier).flags = STRING_FLAGS_WIDE; }
        -: 2337:#line 2338 "grammar.c"
    #####: 2338:    break;
        -: 2339:
    #####: 2340:  case 44:
        -: 2341:#line 716 "grammar.y"
        -: 2342:                    { (yyval.modifier).flags = STRING_FLAGS_ASCII; }
        -: 2343:#line 2344 "grammar.c"
    #####: 2344:    break;
        -: 2345:
    #####: 2346:  case 45:
        -: 2347:#line 717 "grammar.y"
        -: 2348:                    { (yyval.modifier).flags = STRING_FLAGS_NO_CASE; }
        -: 2349:#line 2350 "grammar.c"
    #####: 2350:    break;
        -: 2351:
    #####: 2352:  case 46:
        -: 2353:#line 718 "grammar.y"
        -: 2354:                    { (yyval.modifier).flags = STRING_FLAGS_FULL_WORD; }
        -: 2355:#line 2356 "grammar.c"
    #####: 2356:    break;
        -: 2357:
    #####: 2358:  case 47:
        -: 2359:#line 719 "grammar.y"
        -: 2360:                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }
        -: 2361:#line 2362 "grammar.c"
    #####: 2362:    break;
        -: 2363:
    #####: 2364:  case 48:
        -: 2365:#line 721 "grammar.y"
        -: 2366:      {
        -: 2367:        (yyval.modifier).flags = STRING_FLAGS_XOR;
        -: 2368:        (yyval.modifier).xor_min = 0;
        -: 2369:        (yyval.modifier).xor_max = 255;
        -: 2370:      }
        -: 2371:#line 2372 "grammar.c"
    #####: 2372:    break;
        -: 2373:
    #####: 2374:  case 49:
        -: 2375:#line 727 "grammar.y"
        -: 2376:      {
        -: 2377:        int result = ERROR_SUCCESS;
        -: 2378:
        -: 2379:        if ((yyvsp[-1].integer) < 0 || (yyvsp[-1].integer) > 255)
        -: 2380:        {
        -: 2381:          yr_compiler_set_error_extra_info(compiler, "invalid xor range");
        -: 2382:          result = ERROR_INVALID_MODIFIER;
        -: 2383:        }
        -: 2384:
        -: 2385:        fail_if_error(result);
        -: 2386:
        -: 2387:        (yyval.modifier).flags = STRING_FLAGS_XOR;
        -: 2388:        (yyval.modifier).xor_min = (yyvsp[-1].integer);
        -: 2389:        (yyval.modifier).xor_max = (yyvsp[-1].integer);
        -: 2390:      }
        -: 2391:#line 2392 "grammar.c"
    #####: 2392:    break;
        -: 2393:
    #####: 2394:  case 50:
        -: 2395:#line 748 "grammar.y"
        -: 2396:      {
        -: 2397:        int result = ERROR_SUCCESS;
        -: 2398:
        -: 2399:        if ((yyvsp[-3].integer) < 0)
        -: 2400:        {
        -: 2401:          yr_compiler_set_error_extra_info(
        -: 2402:              compiler, "lower bound for xor range exceeded (min: 0)");
        -: 2403:          result = ERROR_INVALID_MODIFIER;
        -: 2404:        }
        -: 2405:
        -: 2406:        if ((yyvsp[-1].integer) > 255)
        -: 2407:        {
        -: 2408:          yr_compiler_set_error_extra_info(
        -: 2409:              compiler, "upper bound for xor range exceeded (max: 255)");
        -: 2410:          result = ERROR_INVALID_MODIFIER;
        -: 2411:        }
        -: 2412:
        -: 2413:        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))
        -: 2414:        {
        -: 2415:          yr_compiler_set_error_extra_info(
        -: 2416:              compiler, "xor lower bound exceeds upper bound");
        -: 2417:          result = ERROR_INVALID_MODIFIER;
        -: 2418:        }
        -: 2419:
        -: 2420:        fail_if_error(result);
        -: 2421:
        -: 2422:        (yyval.modifier).flags = STRING_FLAGS_XOR;
        -: 2423:        (yyval.modifier).xor_min = (yyvsp[-3].integer);
        -: 2424:        (yyval.modifier).xor_max = (yyvsp[-1].integer);
        -: 2425:      }
        -: 2426:#line 2427 "grammar.c"
    #####: 2427:    break;
        -: 2428:
    #####: 2429:  case 51:
        -: 2430:#line 779 "grammar.y"
        -: 2431:      {
        -: 2432:        (yyval.modifier).flags = STRING_FLAGS_BASE64;
        -: 2433:        (yyval.modifier).alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);
        -: 2434:      }
        -: 2435:#line 2436 "grammar.c"
    #####: 2436:    break;
        -: 2437:
    #####: 2438:  case 52:
        -: 2439:#line 784 "grammar.y"
        -: 2440:      {
        -: 2441:        int result = ERROR_SUCCESS;
        -: 2442:
        -: 2443:        if ((yyvsp[-1].sized_string)->length != 64)
        -: 2444:        {
        -: 2445:          yr_free((yyvsp[-1].sized_string));
        -: 2446:          result = yr_compiler_set_error_extra_info(
        -: 2447:              compiler, "length of base64 alphabet must be 64");
        -: 2448:          result = ERROR_INVALID_MODIFIER;
        -: 2449:        }
        -: 2450:
        -: 2451:        fail_if_error(result);
        -: 2452:
        -: 2453:        (yyval.modifier).flags = STRING_FLAGS_BASE64;
        -: 2454:        (yyval.modifier).alphabet = (yyvsp[-1].sized_string);
        -: 2455:      }
        -: 2456:#line 2457 "grammar.c"
    #####: 2457:    break;
        -: 2458:
    #####: 2459:  case 53:
        -: 2460:#line 801 "grammar.y"
        -: 2461:      {
        -: 2462:        (yyval.modifier).flags = STRING_FLAGS_BASE64_WIDE;
        -: 2463:        (yyval.modifier).alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);
        -: 2464:      }
        -: 2465:#line 2466 "grammar.c"
    #####: 2466:    break;
        -: 2467:
    #####: 2468:  case 54:
        -: 2469:#line 806 "grammar.y"
        -: 2470:      {
        -: 2471:        int result = ERROR_SUCCESS;
        -: 2472:
        -: 2473:        if ((yyvsp[-1].sized_string)->length != 64)
        -: 2474:        {
        -: 2475:          yr_free((yyvsp[-1].sized_string));
        -: 2476:          result = yr_compiler_set_error_extra_info(
        -: 2477:              compiler, "length of base64 alphabet must be 64");
        -: 2478:          result = ERROR_INVALID_MODIFIER;
        -: 2479:        }
        -: 2480:
        -: 2481:        fail_if_error(result);
        -: 2482:
        -: 2483:        (yyval.modifier).flags = STRING_FLAGS_BASE64_WIDE;
        -: 2484:        (yyval.modifier).alphabet = (yyvsp[-1].sized_string);
        -: 2485:      }
        -: 2486:#line 2487 "grammar.c"
    #####: 2487:    break;
        -: 2488:
        2: 2489:  case 55:
        -: 2490:#line 825 "grammar.y"
        -: 2491:                                          { (yyval.modifier).flags = 0; }
        -: 2492:#line 2493 "grammar.c"
        2: 2493:    break;
        -: 2494:
    #####: 2495:  case 56:
        -: 2496:#line 827 "grammar.y"
        -: 2497:      {
        -: 2498:        if ((yyvsp[-1].modifier).flags & (yyvsp[0].modifier).flags)
        -: 2499:        {
        -: 2500:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -: 2501:        }
        -: 2502:        else
        -: 2503:        {
        -: 2504:          (yyval.modifier).flags = (yyvsp[-1].modifier).flags | (yyvsp[0].modifier).flags;
        -: 2505:        }
        -: 2506:      }
        -: 2507:#line 2508 "grammar.c"
    #####: 2508:    break;
        -: 2509:
    #####: 2510:  case 57:
        -: 2511:#line 840 "grammar.y"
        -: 2512:                    { (yyval.modifier).flags = STRING_FLAGS_WIDE; }
        -: 2513:#line 2514 "grammar.c"
    #####: 2514:    break;
        -: 2515:
    #####: 2516:  case 58:
        -: 2517:#line 841 "grammar.y"
        -: 2518:                    { (yyval.modifier).flags = STRING_FLAGS_ASCII; }
        -: 2519:#line 2520 "grammar.c"
    #####: 2520:    break;
        -: 2521:
    #####: 2522:  case 59:
        -: 2523:#line 842 "grammar.y"
        -: 2524:                    { (yyval.modifier).flags = STRING_FLAGS_NO_CASE; }
        -: 2525:#line 2526 "grammar.c"
    #####: 2526:    break;
        -: 2527:
    #####: 2528:  case 60:
        -: 2529:#line 843 "grammar.y"
        -: 2530:                    { (yyval.modifier).flags = STRING_FLAGS_FULL_WORD; }
        -: 2531:#line 2532 "grammar.c"
    #####: 2532:    break;
        -: 2533:
    #####: 2534:  case 61:
        -: 2535:#line 844 "grammar.y"
        -: 2536:                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }
        -: 2537:#line 2538 "grammar.c"
    #####: 2538:    break;
        -: 2539:
        3: 2540:  case 62:
        -: 2541:#line 848 "grammar.y"
        -: 2542:                                          { (yyval.modifier).flags = 0; }
        -: 2543:#line 2544 "grammar.c"
        3: 2544:    break;
        -: 2545:
    #####: 2546:  case 63:
        -: 2547:#line 850 "grammar.y"
        -: 2548:      {
        -: 2549:        if ((yyvsp[-1].modifier).flags & (yyvsp[0].modifier).flags)
        -: 2550:        {
        -: 2551:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -: 2552:        }
        -: 2553:        else
        -: 2554:        {
        -: 2555:          (yyval.modifier).flags = (yyvsp[-1].modifier).flags | (yyvsp[0].modifier).flags;
        -: 2556:        }
        -: 2557:      }
        -: 2558:#line 2559 "grammar.c"
    #####: 2559:    break;
        -: 2560:
    #####: 2561:  case 64:
        -: 2562:#line 863 "grammar.y"
        -: 2563:                    { (yyval.modifier).flags = STRING_FLAGS_PRIVATE; }
        -: 2564:#line 2565 "grammar.c"
    #####: 2565:    break;
        -: 2566:
    #####: 2567:  case 65:
        -: 2568:#line 868 "grammar.y"
        -: 2569:      {
        -: 2570:        YR_EXPRESSION expr;
        -: 2571:
        -: 2572:        int result = ERROR_SUCCESS;
        -: 2573:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), &expr);
        -: 2574:
        -: 2575:        if (var_index >= 0)
        -: 2576:        {
        -: 2577:          // The identifier corresponds to a loop variable.
        -: 2578:          result = yr_parser_emit_with_arg(
        -: 2579:              yyscanner,
        -: 2580:              OP_PUSH_M,
        -: 2581:              var_index,
        -: 2582:              NULL,
        -: 2583:              NULL);
        -: 2584:
        -: 2585:          // The expression associated to this identifier is the same one
        -: 2586:          // associated to the loop variable.
        -: 2587:          (yyval.expression) = expr;
        -: 2588:        }
        -: 2589:        else
        -: 2590:        {
        -: 2591:          // Search for identifier within the global namespace, where the
        -: 2592:          // externals variables reside.
        -: 2593:
        -: 2594:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2595:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2596:
        -: 2597:          YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(
        -: 2598:              compiler->arena,
        -: 2599:              YR_NAMESPACES_TABLE,
        -: 2600:              compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));
        -: 2601:
        -: 2602:          if (object == NULL)
        -: 2603:          {
        -: 2604:            // If not found, search within the current namespace.
        -: 2605:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2606:                compiler->objects_table, (yyvsp[0].c_string), ns->name);
        -: 2607:          }
        -: 2608:
        -: 2609:          if (object != NULL)
        -: 2610:          {
        -: 2611:            YR_ARENA_REF ref;
        -: 2612:
        -: 2613:            result = yr_arena_write_string(
        -: 2614:                compiler->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);
        -: 2615:
        -: 2616:            if (result == ERROR_SUCCESS)
        -: 2617:              result = yr_parser_emit_with_arg_reloc(
        -: 2618:                  yyscanner,
        -: 2619:                  OP_OBJ_LOAD,
        -: 2620:                  yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 2621:                  NULL,
        -: 2622:                  NULL);
        -: 2623:
        -: 2624:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2625:            (yyval.expression).value.object = object;
        -: 2626:            (yyval.expression).identifier.ptr = NULL;
        -: 2627:            (yyval.expression).identifier.ref = ref;
        -: 2628:          }
        -: 2629:          else
        -: 2630:          {
        -: 2631:            uint32_t rule_idx = yr_hash_table_lookup_uint32(
        -: 2632:                compiler->rules_table, (yyvsp[0].c_string), ns->name);
        -: 2633:
        -: 2634:            if (rule_idx != UINT32_MAX)
        -: 2635:            {
        -: 2636:              result = yr_parser_emit_with_arg(
        -: 2637:                  yyscanner,
        -: 2638:                  OP_PUSH_RULE,
        -: 2639:                  rule_idx,
        -: 2640:                  NULL,
        -: 2641:                  NULL);
        -: 2642:
        -: 2643:              YR_RULE* rule = _yr_compiler_get_rule_by_idx(compiler, rule_idx);
        -: 2644:
        -: 2645:              yr_arena_ptr_to_ref(compiler->arena, rule->identifier, &(yyval.expression).identifier.ref);
        -: 2646:
        -: 2647:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2648:              (yyval.expression).value.integer = YR_UNDEFINED;
        -: 2649:              (yyval.expression).identifier.ptr = NULL;
        -: 2650:            }
        -: 2651:            else
        -: 2652:            {
        -: 2653:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2654:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2655:            }
        -: 2656:          }
        -: 2657:        }
        -: 2658:
        -: 2659:        yr_free((yyvsp[0].c_string));
        -: 2660:
        -: 2661:        fail_if_error(result);
        -: 2662:      }
        -: 2663:#line 2664 "grammar.c"
    #####: 2664:    break;
        -: 2665:
    #####: 2666:  case 66:
        -: 2667:#line 963 "grammar.y"
        -: 2668:      {
        -: 2669:        int result = ERROR_SUCCESS;
        -: 2670:        YR_OBJECT* field = NULL;
        -: 2671:
        -: 2672:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2673:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2674:        {
        -: 2675:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2676:
        -: 2677:          if (field != NULL)
        -: 2678:          {
        -: 2679:            YR_ARENA_REF ref;
        -: 2680:
        -: 2681:            result = yr_arena_write_string(
        -: 2682:                compiler->arena, YR_SZ_POOL, (yyvsp[0].c_string), &ref);
        -: 2683:
        -: 2684:            if (result == ERROR_SUCCESS)
        -: 2685:              result = yr_parser_emit_with_arg_reloc(
        -: 2686:                  yyscanner,
        -: 2687:                  OP_OBJ_FIELD,
        -: 2688:                  yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 2689:                  NULL,
        -: 2690:                  NULL);
        -: 2691:
        -: 2692:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2693:            (yyval.expression).value.object = field;
        -: 2694:            (yyval.expression).identifier.ref = ref;
        -: 2695:            (yyval.expression).identifier.ptr = NULL;
        -: 2696:          }
        -: 2697:          else
        -: 2698:          {
        -: 2699:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2700:            result = ERROR_INVALID_FIELD_NAME;
        -: 2701:          }
        -: 2702:        }
        -: 2703:        else
        -: 2704:        {
        -: 2705:          yr_compiler_set_error_extra_info(
        -: 2706:             compiler, expression_identifier((yyvsp[-2].expression)));
        -: 2707:
        -: 2708:          result = ERROR_NOT_A_STRUCTURE;
        -: 2709:        }
        -: 2710:
        -: 2711:        yr_free((yyvsp[0].c_string));
        -: 2712:
        -: 2713:        fail_if_error(result);
        -: 2714:      }
        -: 2715:#line 2716 "grammar.c"
    #####: 2716:    break;
        -: 2717:
    #####: 2718:  case 67:
        -: 2719:#line 1011 "grammar.y"
        -: 2720:      {
        -: 2721:        int result = ERROR_SUCCESS;
        -: 2722:        YR_OBJECT_ARRAY* array;
        -: 2723:        YR_OBJECT_DICTIONARY* dict;
        -: 2724:
        -: 2725:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2726:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2727:        {
        -: 2728:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2729:          {
        -: 2730:            yr_compiler_set_error_extra_info(
        -: 2731:                compiler, "array indexes must be of integer type");
        -: 2732:            result = ERROR_WRONG_TYPE;
        -: 2733:          }
        -: 2734:
        -: 2735:          fail_if_error(result);
        -: 2736:
        -: 2737:          result = yr_parser_emit(
        -: 2738:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2739:
        -: 2740:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2741:
        -: 2742:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2743:          (yyval.expression).value.object = array->prototype_item;
        -: 2744:          (yyval.expression).identifier.ptr = array->identifier;
        -: 2745:          (yyval.expression).identifier.ref = YR_ARENA_NULL_REF;
        -: 2746:        }
        -: 2747:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2748:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2749:        {
        -: 2750:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2751:          {
        -: 2752:            yr_compiler_set_error_extra_info(
        -: 2753:                compiler, "dictionary keys must be of string type");
        -: 2754:            result = ERROR_WRONG_TYPE;
        -: 2755:          }
        -: 2756:
        -: 2757:          fail_if_error(result);
        -: 2758:
        -: 2759:          result = yr_parser_emit(
        -: 2760:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2761:
        -: 2762:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2763:
        -: 2764:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2765:          (yyval.expression).value.object = dict->prototype_item;
        -: 2766:          (yyval.expression).identifier.ptr = dict->identifier;
        -: 2767:          (yyval.expression).identifier.ref = YR_ARENA_NULL_REF;
        -: 2768:        }
        -: 2769:        else
        -: 2770:        {
        -: 2771:          yr_compiler_set_error_extra_info(
        -: 2772:              compiler, expression_identifier((yyvsp[-3].expression)));
        -: 2773:
        -: 2774:          result = ERROR_NOT_INDEXABLE;
        -: 2775:        }
        -: 2776:
        -: 2777:        fail_if_error(result);
        -: 2778:      }
        -: 2779:#line 2780 "grammar.c"
    #####: 2780:    break;
        -: 2781:
    #####: 2782:  case 68:
        -: 2783:#line 1072 "grammar.y"
        -: 2784:      {
        -: 2785:        YR_ARENA_REF ref;
        -: 2786:        int result = ERROR_SUCCESS;
        -: 2787:        YR_OBJECT_FUNCTION* function;
        -: 2788:
        -: 2789:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2790:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2791:        {
        -: 2792:          result = yr_parser_check_types(
        -: 2793:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2794:
        -: 2795:          if (result == ERROR_SUCCESS)
        -: 2796:            result = yr_arena_write_string(
        -: 2797:                compiler->arena, YR_SZ_POOL, (yyvsp[-1].c_string), &ref);
        -: 2798:
        -: 2799:          if (result == ERROR_SUCCESS)
        -: 2800:            result = yr_parser_emit_with_arg_reloc(
        -: 2801:                yyscanner,
        -: 2802:                OP_CALL,
        -: 2803:                yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 2804:                NULL,
        -: 2805:                NULL);
        -: 2806:
        -: 2807:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2808:
        -: 2809:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2810:          (yyval.expression).value.object = function->return_obj;
        -: 2811:          (yyval.expression).identifier.ref = ref;
        -: 2812:          (yyval.expression).identifier.ptr = NULL;
        -: 2813:        }
        -: 2814:        else
        -: 2815:        {
        -: 2816:          yr_compiler_set_error_extra_info(
        -: 2817:              compiler, expression_identifier((yyvsp[-3].expression)));
        -: 2818:
        -: 2819:          result = ERROR_NOT_A_FUNCTION;
        -: 2820:        }
        -: 2821:
        -: 2822:        yr_free((yyvsp[-1].c_string));
        -: 2823:
        -: 2824:        fail_if_error(result);
        -: 2825:      }
        -: 2826:#line 2827 "grammar.c"
    #####: 2827:    break;
        -: 2828:
    #####: 2829:  case 69:
        -: 2830:#line 1118 "grammar.y"
        -: 2831:                      { (yyval.c_string) = yr_strdup(""); }
        -: 2832:#line 2833 "grammar.c"
    #####: 2833:    break;
        -: 2834:
    #####: 2835:  case 70:
        -: 2836:#line 1119 "grammar.y"
        -: 2837:                      { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2838:#line 2839 "grammar.c"
    #####: 2839:    break;
        -: 2840:
    #####: 2841:  case 71:
        -: 2842:#line 1124 "grammar.y"
        -: 2843:      {
        -: 2844:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2845:
        -: 2846:        if ((yyval.c_string) == NULL)
        -: 2847:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2848:
        -: 2849:        switch((yyvsp[0].expression).type)
        -: 2850:        {
        -: 2851:          case EXPRESSION_TYPE_INTEGER:
        -: 2852:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2853:            break;
        -: 2854:          case EXPRESSION_TYPE_FLOAT:
        -: 2855:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2856:            break;
        -: 2857:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2858:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2859:            break;
        -: 2860:          case EXPRESSION_TYPE_STRING:
        -: 2861:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2862:            break;
        -: 2863:          case EXPRESSION_TYPE_REGEXP:
        -: 2864:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2865:            break;
        -: 2866:          case EXPRESSION_TYPE_UNKNOWN:
        -: 2867:            yr_free((yyval.c_string));
        -: 2868:            yr_compiler_set_error_extra_info(
        -: 2869:                compiler, "unknown type for argument 1 in function call");
        -: 2870:            fail_with_error(ERROR_WRONG_TYPE);
        -: 2871:            break;
        -: 2872:          default:
        -: 2873:            // An unknown expression type is OK iff an error ocurred.
        -: 2874:            assert(compiler->last_error != ERROR_SUCCESS);
        -: 2875:        }
        -: 2876:      }
        -: 2877:#line 2878 "grammar.c"
    #####: 2878:    break;
        -: 2879:
    #####: 2880:  case 72:
        -: 2881:#line 1159 "grammar.y"
        -: 2882:      {
        -: 2883:        int result = ERROR_SUCCESS;
        -: 2884:
        -: 2885:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2886:        {
        -: 2887:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2888:        }
        -: 2889:        else
        -: 2890:        {
        -: 2891:          switch((yyvsp[0].expression).type)
        -: 2892:          {
        -: 2893:            case EXPRESSION_TYPE_INTEGER:
        -: 2894:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2895:              break;
        -: 2896:            case EXPRESSION_TYPE_FLOAT:
        -: 2897:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2898:              break;
        -: 2899:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2900:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2901:              break;
        -: 2902:            case EXPRESSION_TYPE_STRING:
        -: 2903:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2904:              break;
        -: 2905:            case EXPRESSION_TYPE_REGEXP:
        -: 2906:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2907:              break;
        -: 2908:            case EXPRESSION_TYPE_UNKNOWN:
        -: 2909:              result = ERROR_WRONG_TYPE;
        -: 2910:              yr_compiler_set_error_extra_info_fmt(
        -: 2911:                  compiler, "unknown type for argument %zu in function call",
        -: 2912:                  // As we add one character per argument, the length of $1 is
        -: 2913:                  // the number of arguments parsed so far, and the argument
        -: 2914:                  // represented by <expression> is length of $1 plus one.
        -: 2915:                  strlen((yyvsp[-2].c_string)) + 1);
        -: 2916:              break;
        -: 2917:            default:
        -: 2918:              // An unknown expression type is OK iff an error ocurred.
        -: 2919:              assert(compiler->last_error != ERROR_SUCCESS);
        -: 2920:          }
        -: 2921:        }
        -: 2922:
        -: 2923:        if (result != ERROR_SUCCESS)
        -: 2924:          yr_free((yyvsp[-2].c_string));
        -: 2925:
        -: 2926:        fail_if_error(result);
        -: 2927:
        -: 2928:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2929:      }
        -: 2930:#line 2931 "grammar.c"
    #####: 2931:    break;
        -: 2932:
    #####: 2933:  case 73:
        -: 2934:#line 1212 "grammar.y"
        -: 2935:      {
        -: 2936:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2937:        YR_ARENA_REF re_ref;
        -: 2938:        RE_ERROR error;
        -: 2939:
        -: 2940:        int result = ERROR_SUCCESS;
        -: 2941:        int re_flags = 0;
        -: 2942:
        -: 2943:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2944:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2945:
        -: 2946:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2947:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2948:
        -: 2949:        result = yr_re_compile(
        -: 2950:            sized_string->c_string,
        -: 2951:            re_flags,
        -: 2952:            compiler->arena,
        -: 2953:            &re_ref,
        -: 2954:            &error);
        -: 2955:
        -: 2956:        yr_free((yyvsp[0].sized_string));
        -: 2957:
        -: 2958:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2959:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2960:
        -: 2961:        if (result == ERROR_SUCCESS)
        -: 2962:          result = yr_parser_emit_with_arg_reloc(
        -: 2963:              yyscanner,
        -: 2964:              OP_PUSH,
        -: 2965:              yr_arena_ref_to_ptr(compiler->arena, &re_ref),
        -: 2966:              NULL,
        -: 2967:              NULL);
        -: 2968:
        -: 2969:        fail_if_error(result);
        -: 2970:
        -: 2971:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2972:      }
        -: 2973:#line 2974 "grammar.c"
    #####: 2974:    break;
        -: 2975:
    #####: 2976:  case 74:
        -: 2977:#line 1255 "grammar.y"
        -: 2978:      {
        -: 2979:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2980:        {
        -: 2981:          if (!YR_ARENA_IS_NULL_REF((yyvsp[0].expression).value.sized_string_ref))
        -: 2982:          {
        -: 2983:            SIZED_STRING* sized_string = yr_arena_ref_to_ptr(
        -: 2984:                compiler->arena, &(yyvsp[0].expression).value.sized_string_ref);
        -: 2985:
        -: 2986:            yywarning(yyscanner,
        -: 2987:                "Using literal string \"%s\" in a boolean operation.",
        -: 2988:                sized_string->c_string);
        -: 2989:          }
        -: 2990:
        -: 2991:          fail_if_error(yr_parser_emit(
        -: 2992:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2993:        }
        -: 2994:
        -: 2995:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2996:      }
        -: 2997:#line 2998 "grammar.c"
    #####: 2998:    break;
        -: 2999:
    #####: 3000:  case 75:
        -: 3001:#line 1278 "grammar.y"
        -: 3002:      {
        -: 3003:        fail_if_error(yr_parser_emit_with_arg(
        -: 3004:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 3005:
        -: 3006:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3007:      }
        -: 3008:#line 3009 "grammar.c"
    #####: 3009:    break;
        -: 3010:
    #####: 3011:  case 76:
        -: 3012:#line 1285 "grammar.y"
        -: 3013:      {
        -: 3014:        fail_if_error(yr_parser_emit_with_arg(
        -: 3015:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 3016:
        -: 3017:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3018:      }
        -: 3019:#line 3020 "grammar.c"
    #####: 3020:    break;
        -: 3021:
    #####: 3022:  case 77:
        -: 3023:#line 1292 "grammar.y"
        -: 3024:      {
        -: 3025:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 3026:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 3027:
        -: 3028:        fail_if_error(yr_parser_emit(
        -: 3029:            yyscanner,
        -: 3030:            OP_MATCHES,
        -: 3031:            NULL));
        -: 3032:
        -: 3033:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3034:      }
        -: 3035:#line 3036 "grammar.c"
    #####: 3036:    break;
        -: 3037:
    #####: 3038:  case 78:
        -: 3039:#line 1304 "grammar.y"
        -: 3040:      {
        -: 3041:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 3042:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 3043:
        -: 3044:        fail_if_error(yr_parser_emit(
        -: 3045:            yyscanner, OP_CONTAINS, NULL));
        -: 3046:
        -: 3047:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3048:      }
        -: 3049:#line 3050 "grammar.c"
    #####: 3050:    break;
        -: 3051:
    #####: 3052:  case 79:
        -: 3053:#line 1314 "grammar.y"
        -: 3054:      {
        -: 3055:        int result = yr_parser_reduce_string_identifier(
        -: 3056:            yyscanner,
        -: 3057:            (yyvsp[0].c_string),
        -: 3058:            OP_FOUND,
        -: 3059:            YR_UNDEFINED);
        -: 3060:
        -: 3061:        yr_free((yyvsp[0].c_string));
        -: 3062:
        -: 3063:        fail_if_error(result);
        -: 3064:
        -: 3065:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3066:      }
        -: 3067:#line 3068 "grammar.c"
    #####: 3068:    break;
        -: 3069:
    #####: 3070:  case 80:
        -: 3071:#line 1328 "grammar.y"
        -: 3072:      {
        -: 3073:        int result;
        -: 3074:
        -: 3075:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 3076:
        -: 3077:        result = yr_parser_reduce_string_identifier(
        -: 3078:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 3079:
        -: 3080:        yr_free((yyvsp[-2].c_string));
        -: 3081:
        -: 3082:        fail_if_error(result);
        -: 3083:
        -: 3084:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3085:      }
        -: 3086:#line 3087 "grammar.c"
    #####: 3087:    break;
        -: 3088:
    #####: 3089:  case 81:
        -: 3090:#line 1343 "grammar.y"
        -: 3091:      {
        -: 3092:        int result = yr_parser_reduce_string_identifier(
        -: 3093:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, YR_UNDEFINED);
        -: 3094:
        -: 3095:        yr_free((yyvsp[-2].c_string));
        -: 3096:
        -: 3097:        fail_if_error(result);
        -: 3098:
        -: 3099:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3100:      }
        -: 3101:#line 3102 "grammar.c"
    #####: 3102:    break;
        -: 3103:
    #####: 3104:  case 82:
        -: 3105:#line 1354 "grammar.y"
        -: 3106:      {
        -: 3107:        int i;
        -: 3108:
        -: 3109:        // Free all the loop variable identifiers, including the variables for
        -: 3110:        // the current loop (represented by loop_index), and set loop_index to
        -: 3111:        // -1. This is OK even if we have nested loops. If an error occurs while
        -: 3112:        // parsing the inner loop, it will be propagated to the outer loop
        -: 3113:        // anyways, so it's safe to do this cleanup while processing the error
        -: 3114:        // for the inner loop.
        -: 3115:
        -: 3116:        for (i = 0; i <= compiler->loop_index; i++)
        -: 3117:        {
        -: 3118:          loop_vars_cleanup(i);
        -: 3119:        }
        -: 3120:
        -: 3121:        compiler->loop_index = -1;
        -: 3122:        YYERROR;
        -: 3123:      }
        -: 3124:#line 3125 "grammar.c"
        -: 3125:    break;
        -: 3126:
    #####: 3127:  case 83:
        -: 3128:#line 1432 "grammar.y"
        -: 3129:      {
        -: 3130:        // var_frame is used for accessing local variables used in this loop.
        -: 3131:        // All local variables are accessed using var_frame as a reference,
        -: 3132:        // like var_frame + 0, var_frame + 1, etc. Here we initialize var_frame
        -: 3133:        // with the correct value, which depends on the number of variables
        -: 3134:        // defined by any outer loops.
        -: 3135:
        -: 3136:        int var_frame;
        -: 3137:        int result = ERROR_SUCCESS;
        -: 3138:
        -: 3139:        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)
        -: 3140:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 3141:
        -: 3142:        fail_if_error(result);
        -: 3143:
        -: 3144:        compiler->loop_index++;
        -: 3145:
        -: 3146:        // This loop uses internal variables besides the ones explicitly
        -: 3147:        // defined by the user.
        -: 3148:        compiler->loop[compiler->loop_index].vars_internal_count = \
        -: 3149:       		YR_INTERNAL_LOOP_VARS;
        -: 3150:
        -: 3151:        // Initialize the number of variables, this number will be incremented
        -: 3152:        // as variable declaration are processed by for_variables.
        -: 3153:        compiler->loop[compiler->loop_index].vars_count = 0;
        -: 3154:
        -: 3155:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 3156:
        -: 3157:        fail_if_error(yr_parser_emit_with_arg(
        -: 3158:            yyscanner, OP_CLEAR_M, var_frame + 0, NULL, NULL));
        -: 3159:
        -: 3160:        fail_if_error(yr_parser_emit_with_arg(
        -: 3161:            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL));
        -: 3162:
        -: 3163:        fail_if_error(yr_parser_emit_with_arg(
        -: 3164:            yyscanner, OP_POP_M, var_frame + 2, NULL, NULL));
        -: 3165:      }
        -: 3166:#line 3167 "grammar.c"
    #####: 3167:    break;
        -: 3168:
    #####: 3169:  case 84:
        -: 3170:#line 1470 "grammar.y"
        -: 3171:      {
        -: 3172:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 3173:        YR_FIXUP* fixup;
        -: 3174:
        -: 3175:        YR_ARENA_REF loop_start_ref;
        -: 3176:        YR_ARENA_REF jmp_offset_ref;
        -: 3177:
        -: 3178:        int var_frame = _yr_compiler_get_var_frame(compiler);
        -: 3179:        int i;
        -: 3180:
        -: 3181:        fail_if_error(yr_parser_emit(
        -: 3182:            yyscanner, OP_ITER_NEXT, &loop_start_ref));
        -: 3183:
        -: 3184:        // For each variable generate an instruction that pops the value from
        -: 3185:        // the stack and store it into one memory slot starting at var_frame +
        -: 3186:        // YR_INTERNAL_LOOP_VARS because the first YR_INTERNAL_LOOP_VARS slots
        -: 3187:        // in the frame are for the internal variables.
        -: 3188:
        -: 3189:        for (i = 0; i < loop_ctx->vars_count; i++)
        -: 3190:        {
        -: 3191:          fail_if_error(yr_parser_emit_with_arg(
        -: 3192:              yyscanner,
        -: 3193:              OP_POP_M,
        -: 3194:              var_frame + YR_INTERNAL_LOOP_VARS + i,
        -: 3195:              NULL,
        -: 3196:              NULL));
        -: 3197:        }
        -: 3198:
        -: 3199:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3200:            yyscanner,
        -: 3201:            OP_JTRUE_P,
        -: 3202:            0,              // still don't know the jump offset, use 0 for now.
        -: 3203:            NULL,
        -: 3204:            &jmp_offset_ref));
        -: 3205:
        -: 3206:        // We still don't know the jump's target, so we push a fixup entry
        -: 3207:        // in the stack, so that the jump's offset can be set once we know it.
        -: 3208:
        -: 3209:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3210:
        -: 3211:        if (fixup == NULL)
        -: 3212:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3213:
        -: 3214:        fixup->ref = jmp_offset_ref;
        -: 3215:        fixup->next = compiler->fixup_stack_head;
        -: 3216:        compiler->fixup_stack_head = fixup;
        -: 3217:
        -: 3218:        loop_ctx->start_ref = loop_start_ref;
        -: 3219:      }
        -: 3220:#line 3221 "grammar.c"
    #####: 3221:    break;
        -: 3222:
    #####: 3223:  case 85:
        -: 3224:#line 1520 "grammar.y"
        -: 3225:      {
        -: 3226:        int32_t jmp_offset;
        -: 3227:        YR_FIXUP* fixup;
        -: 3228:        YR_ARENA_REF pop_ref;
        -: 3229:        YR_ARENA_REF jmp_offset_ref;
        -: 3230:
        -: 3231:        int var_frame = _yr_compiler_get_var_frame(compiler);
        -: 3232:
        -: 3233:        fail_if_error(yr_parser_emit_with_arg(
        -: 3234:            yyscanner, OP_ADD_M, var_frame + 0, NULL, NULL));
        -: 3235:
        -: 3236:        fail_if_error(yr_parser_emit_with_arg(
        -: 3237:            yyscanner, OP_INCR_M, var_frame + 1, NULL, NULL));
        -: 3238:
        -: 3239:        fail_if_error(yr_parser_emit_with_arg(
        -: 3240:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 3241:
        -: 3242:        jmp_offset = \
        -: 3243:            compiler->loop[compiler->loop_index].start_ref.offset -
        -: 3244:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 3245:
        -: 3246:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3247:            yyscanner,
        -: 3248:            OP_JUNDEF_P,
        -: 3249:            jmp_offset,
        -: 3250:            NULL,
        -: 3251:            NULL));
        -: 3252:
        -: 3253:        fail_if_error(yr_parser_emit_with_arg(
        -: 3254:            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));
        -: 3255:
        -: 3256:        fail_if_error(yr_parser_emit_with_arg(
        -: 3257:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 3258:
        -: 3259:        jmp_offset = \
        -: 3260:            compiler->loop[compiler->loop_index].start_ref.offset -
        -: 3261:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 3262:
        -: 3263:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3264:            yyscanner,
        -: 3265:            OP_JL_P,
        -: 3266:            jmp_offset,
        -: 3267:            NULL,
        -: 3268:            NULL));
        -: 3269:
        -: 3270:        fail_if_error(yr_parser_emit(
        -: 3271:            yyscanner, OP_POP, &pop_ref));
        -: 3272:
        -: 3273:        fail_if_error(yr_parser_emit_with_arg(
        -: 3274:            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL));
        -: 3275:
        -: 3276:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3277:            yyscanner,
        -: 3278:            OP_JZ,
        -: 3279:            0,      // still don't know the jump offset, use 0 for now.
        -: 3280:            NULL,
        -: 3281:            &jmp_offset_ref));
        -: 3282:
        -: 3283:        fail_if_error(yr_parser_emit(
        -: 3284:            yyscanner, OP_POP, NULL));
        -: 3285:
        -: 3286:        // Pop from the stack the fixup entry containing the reference to
        -: 3287:        // the jump offset that needs to be fixed.
        -: 3288:
        -: 3289:        fixup = compiler->fixup_stack_head;
        -: 3290:        compiler->fixup_stack_head = fixup->next;
        -: 3291:
        -: 3292:        // The fixup entry has a reference to the jump offset that need
        -: 3293:        // to be fixed, convert the address into a pointer.
        -: 3294:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 3295:            compiler->arena, &fixup->ref);
        -: 3296:
        -: 3297:        // The reference in the fixup entry points to the jump's offset
        -: 3298:        // but the jump instruction is one byte before, that's why we add
        -: 3299:        // one to the offset.
        -: 3300:        jmp_offset = pop_ref.offset - fixup->ref.offset + 1;
        -: 3301:
        -: 3302:        // Fix the jump's offset.
        -: 3303:        *jmp_offset_addr = jmp_offset;
        -: 3304:
        -: 3305:        yr_free(fixup);
        -: 3306:
        -: 3307:        fail_if_error(yr_parser_emit_with_arg(
        -: 3308:            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));
        -: 3309:
        -: 3310:        fail_if_error(yr_parser_emit_with_arg(
        -: 3311:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 3312:
        -: 3313:        fail_if_error(yr_parser_emit_with_arg(
        -: 3314:            yyscanner, OP_SWAPUNDEF, var_frame + 1, NULL, NULL));
        -: 3315:
        -: 3316:        fail_if_error(yr_parser_emit(
        -: 3317:            yyscanner, OP_INT_GE, NULL));
        -: 3318:
        -: 3319:        jmp_offset = \
        -: 3320:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
        -: 3321:            jmp_offset_ref.offset + 1;
        -: 3322:
        -: 3323:        jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 3324:            compiler->arena, &jmp_offset_ref);
        -: 3325:
        -: 3326:        *jmp_offset_addr = jmp_offset;
        -: 3327:
        -: 3328:        loop_vars_cleanup(compiler->loop_index);
        -: 3329:
        -: 3330:        compiler->loop_index--;
        -: 3331:
        -: 3332:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3333:      }
        -: 3334:#line 3335 "grammar.c"
    #####: 3335:    break;
        -: 3336:
    #####: 3337:  case 86:
        -: 3338:#line 1630 "grammar.y"
        -: 3339:      {
        -: 3340:        YR_ARENA_REF ref;
        -: 3341:
        -: 3342:        int result = ERROR_SUCCESS;
        -: 3343:        int var_frame;
        -: 3344:
        -: 3345:        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)
        -: 3346:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 3347:
        -: 3348:        if (compiler->loop_for_of_var_index != -1)
        -: 3349:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 3350:
        -: 3351:        fail_if_error(result);
        -: 3352:
        -: 3353:        compiler->loop_index++;
        -: 3354:
        -: 3355:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 3356:
        -: 3357:        yr_parser_emit_with_arg(
        -: 3358:            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL);
        -: 3359:
        -: 3360:        yr_parser_emit_with_arg(
        -: 3361:            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL);
        -: 3362:
        -: 3363:        // Pop the first string.
        -: 3364:        yr_parser_emit_with_arg(
        -: 3365:            yyscanner, OP_POP_M, var_frame, &ref, NULL);
        -: 3366:
        -: 3367:        compiler->loop_for_of_var_index = var_frame;
        -: 3368:        compiler->loop[compiler->loop_index].start_ref = ref;
        -: 3369:        compiler->loop[compiler->loop_index].vars_count = 0;
        -: 3370:        compiler->loop[compiler->loop_index].vars_internal_count = \
        -: 3371:            YR_INTERNAL_LOOP_VARS;
        -: 3372:      }
        -: 3373:#line 3374 "grammar.c"
    #####: 3374:    break;
        -: 3375:
    #####: 3376:  case 87:
        -: 3377:#line 1665 "grammar.y"
        -: 3378:      {
        -: 3379:        int var_frame = 0;
        -: 3380:
        -: 3381:        compiler->loop_for_of_var_index = -1;
        -: 3382:
        -: 3383:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 3384:
        -: 3385:        // Increment counter by the value returned by the
        -: 3386:        // boolean expression (0 or 1). If the boolean expression
        -: 3387:        // returned YR_UNDEFINED the OP_ADD_M won't do anything.
        -: 3388:
        -: 3389:        yr_parser_emit_with_arg(
        -: 3390:            yyscanner, OP_ADD_M, var_frame + 1, NULL, NULL);
        -: 3391:
        -: 3392:        // Increment iterations counter.
        -: 3393:        yr_parser_emit_with_arg(
        -: 3394:            yyscanner, OP_INCR_M, var_frame + 2, NULL, NULL);
        -: 3395:
        -: 3396:        int32_t jmp_offset = \
        -: 3397:            compiler->loop[compiler->loop_index].start_ref.offset -
        -: 3398:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 3399:
        -: 3400:        // If next string is not undefined, go back to the
        -: 3401:        // beginning of the loop.
        -: 3402:        yr_parser_emit_with_arg_int32(
        -: 3403:            yyscanner,
        -: 3404:            OP_JNUNDEF,
        -: 3405:            jmp_offset,
        -: 3406:            NULL,
        -: 3407:            NULL);
        -: 3408:
        -: 3409:        // Pop end-of-list marker.
        -: 3410:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 3411:
        -: 3412:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 3413:        // is at top of the stack. Check if the quantifier is
        -: 3414:        // undefined (meaning "all") and replace it with the
        -: 3415:        // iterations counter in that case.
        -: 3416:        yr_parser_emit_with_arg(
        -: 3417:            yyscanner, OP_SWAPUNDEF, var_frame + 2, NULL, NULL);
        -: 3418:
        -: 3419:        // Compare the loop quantifier with the number of
        -: 3420:        // expressions evaluating to true.
        -: 3421:        yr_parser_emit_with_arg(
        -: 3422:            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL);
        -: 3423:
        -: 3424:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 3425:
        -: 3426:        loop_vars_cleanup(compiler->loop_index);
        -: 3427:
        -: 3428:        compiler->loop_index--;
        -: 3429:
        -: 3430:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3431:      }
        -: 3432:#line 3433 "grammar.c"
    #####: 3433:    break;
        -: 3434:
    #####: 3435:  case 88:
        -: 3436:#line 1720 "grammar.y"
        -: 3437:      {
        -: 3438:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 3439:
        -: 3440:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3441:      }
        -: 3442:#line 3443 "grammar.c"
    #####: 3443:    break;
        -: 3444:
    #####: 3445:  case 89:
        -: 3446:#line 1726 "grammar.y"
        -: 3447:      {
        -: 3448:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 3449:
        -: 3450:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3451:      }
        -: 3452:#line 3453 "grammar.c"
    #####: 3453:    break;
        -: 3454:
    #####: 3455:  case 90:
        -: 3456:#line 1732 "grammar.y"
        -: 3457:      {
        -: 3458:        YR_FIXUP* fixup;
        -: 3459:        YR_ARENA_REF jmp_offset_ref;
        -: 3460:
        -: 3461:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3462:            yyscanner,
        -: 3463:            OP_JFALSE,
        -: 3464:            0,          // still don't know the jump offset, use 0 for now.
        -: 3465:            NULL,
        -: 3466:            &jmp_offset_ref));
        -: 3467:
        -: 3468:        // Create a fixup entry for the jump and push it in the stack.
        -: 3469:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3470:
        -: 3471:        if (fixup == NULL)
        -: 3472:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3473:
        -: 3474:        fixup->ref = jmp_offset_ref;
        -: 3475:        fixup->next = compiler->fixup_stack_head;
        -: 3476:        compiler->fixup_stack_head = fixup;
        -: 3477:      }
        -: 3478:#line 3479 "grammar.c"
    #####: 3479:    break;
        -: 3480:
    #####: 3481:  case 91:
        -: 3482:#line 1754 "grammar.y"
        -: 3483:      {
        -: 3484:        YR_FIXUP* fixup;
        -: 3485:
        -: 3486:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 3487:
        -: 3488:        fixup = compiler->fixup_stack_head;
        -: 3489:
        -: 3490:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 3491:            compiler->arena, &fixup->ref);
        -: 3492:
        -: 3493:        int32_t jmp_offset = \
        -: 3494:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
        -: 3495:            fixup->ref.offset + 1;
        -: 3496:
        -: 3497:        *jmp_offset_addr = jmp_offset;
        -: 3498:
        -: 3499:        // Remove fixup from the stack.
        -: 3500:        compiler->fixup_stack_head = fixup->next;
        -: 3501:        yr_free(fixup);
        -: 3502:
        -: 3503:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3504:      }
        -: 3505:#line 3506 "grammar.c"
    #####: 3506:    break;
        -: 3507:
    #####: 3508:  case 92:
        -: 3509:#line 1777 "grammar.y"
        -: 3510:      {
        -: 3511:        YR_FIXUP* fixup;
        -: 3512:        YR_ARENA_REF jmp_offset_ref;
        -: 3513:
        -: 3514:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 3515:            yyscanner,
        -: 3516:            OP_JTRUE,
        -: 3517:            0,         // still don't know the jump destination, use 0 for now.
        -: 3518:            NULL,
        -: 3519:            &jmp_offset_ref));
        -: 3520:
        -: 3521:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3522:
        -: 3523:        if (fixup == NULL)
        -: 3524:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3525:
        -: 3526:        fixup->ref = jmp_offset_ref;
        -: 3527:        fixup->next = compiler->fixup_stack_head;
        -: 3528:        compiler->fixup_stack_head = fixup;
        -: 3529:      }
        -: 3530:#line 3531 "grammar.c"
    #####: 3531:    break;
        -: 3532:
    #####: 3533:  case 93:
        -: 3534:#line 1798 "grammar.y"
        -: 3535:      {
        -: 3536:        YR_FIXUP* fixup;
        -: 3537:
        -: 3538:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 3539:
        -: 3540:        fixup = compiler->fixup_stack_head;
        -: 3541:
        -: 3542:        int32_t jmp_offset = \
        -: 3543:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
        -: 3544:            fixup->ref.offset + 1;
        -: 3545:
        -: 3546:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 3547:            compiler->arena, &fixup->ref);
        -: 3548:
        -: 3549:        *jmp_offset_addr = jmp_offset;
        -: 3550:
        -: 3551:        // Remove fixup from the stack.
        -: 3552:        compiler->fixup_stack_head = fixup->next;
        -: 3553:        yr_free(fixup);
        -: 3554:
        -: 3555:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3556:      }
        -: 3557:#line 3558 "grammar.c"
    #####: 3558:    break;
        -: 3559:
    #####: 3560:  case 94:
        -: 3561:#line 1821 "grammar.y"
        -: 3562:      {
        -: 3563:        fail_if_error(yr_parser_reduce_operation(
        -: 3564:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3565:
        -: 3566:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3567:      }
        -: 3568:#line 3569 "grammar.c"
    #####: 3569:    break;
        -: 3570:
    #####: 3571:  case 95:
        -: 3572:#line 1828 "grammar.y"
        -: 3573:      {
        -: 3574:        fail_if_error(yr_parser_reduce_operation(
        -: 3575:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3576:
        -: 3577:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3578:      }
        -: 3579:#line 3580 "grammar.c"
    #####: 3580:    break;
        -: 3581:
    #####: 3582:  case 96:
        -: 3583:#line 1835 "grammar.y"
        -: 3584:      {
        -: 3585:        fail_if_error(yr_parser_reduce_operation(
        -: 3586:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3587:
        -: 3588:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3589:      }
        -: 3590:#line 3591 "grammar.c"
    #####: 3591:    break;
        -: 3592:
    #####: 3593:  case 97:
        -: 3594:#line 1842 "grammar.y"
        -: 3595:      {
        -: 3596:        fail_if_error(yr_parser_reduce_operation(
        -: 3597:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3598:
        -: 3599:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3600:      }
        -: 3601:#line 3602 "grammar.c"
    #####: 3602:    break;
        -: 3603:
    #####: 3604:  case 98:
        -: 3605:#line 1849 "grammar.y"
        -: 3606:      {
        -: 3607:        fail_if_error(yr_parser_reduce_operation(
        -: 3608:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3609:
        -: 3610:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3611:      }
        -: 3612:#line 3613 "grammar.c"
    #####: 3613:    break;
        -: 3614:
    #####: 3615:  case 99:
        -: 3616:#line 1856 "grammar.y"
        -: 3617:      {
        -: 3618:        fail_if_error(yr_parser_reduce_operation(
        -: 3619:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3620:
        -: 3621:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3622:      }
        -: 3623:#line 3624 "grammar.c"
    #####: 3624:    break;
        -: 3625:
    #####: 3626:  case 100:
        -: 3627:#line 1863 "grammar.y"
        -: 3628:      {
        -: 3629:        (yyval.expression) = (yyvsp[0].expression);
        -: 3630:      }
        -: 3631:#line 3632 "grammar.c"
    #####: 3632:    break;
        -: 3633:
    #####: 3634:  case 101:
        -: 3635:#line 1867 "grammar.y"
        -: 3636:      {
        -: 3637:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3638:      }
        -: 3639:#line 3640 "grammar.c"
    #####: 3640:    break;
        -: 3641:
    #####: 3642:  case 102:
        -: 3643:#line 1875 "grammar.y"
        -: 3644:      {
        -: 3645:        int result = ERROR_SUCCESS;
        -: 3646:
        -: 3647:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 3648:
        -: 3649:        if (yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), NULL) >= 0)
        -: 3650:        {
        -: 3651:          yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 3652:          yr_free((yyvsp[0].c_string));
        -: 3653:
        -: 3654:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 3655:        }
        -: 3656:
        -: 3657:        fail_if_error(result);
        -: 3658:
        -: 3659:        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = (yyvsp[0].c_string);
        -: 3660:
        -: 3661:        assert(loop_ctx->vars_count <= YR_MAX_LOOP_VARS);
        -: 3662:      }
        -: 3663:#line 3664 "grammar.c"
    #####: 3664:    break;
        -: 3665:
    #####: 3666:  case 103:
        -: 3667:#line 1895 "grammar.y"
        -: 3668:      {
        -: 3669:        int result = ERROR_SUCCESS;
        -: 3670:
        -: 3671:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 3672:
        -: 3673:        if (loop_ctx->vars_count == YR_MAX_LOOP_VARS)
        -: 3674:        {
        -: 3675:          yr_compiler_set_error_extra_info(compiler, "too many loop variables");
        -: 3676:          yr_free((yyvsp[0].c_string));
        -: 3677:
        -: 3678:          result = ERROR_SYNTAX_ERROR;
        -: 3679:        }
        -: 3680:        else if (yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string), NULL) >= 0)
        -: 3681:        {
        -: 3682:          yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 3683:          yr_free((yyvsp[0].c_string));
        -: 3684:
        -: 3685:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 3686:        }
        -: 3687:
        -: 3688:        fail_if_error(result);
        -: 3689:
        -: 3690:        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = (yyvsp[0].c_string);
        -: 3691:      }
        -: 3692:#line 3693 "grammar.c"
    #####: 3693:    break;
        -: 3694:
    #####: 3695:  case 104:
        -: 3696:#line 1923 "grammar.y"
        -: 3697:      {
        -: 3698:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 3699:
        -: 3700:        // Initially we assume that the identifier is from a non-iterable type,
        -: 3701:        // this will change later if it's iterable.
        -: 3702:        int result = ERROR_WRONG_TYPE;
        -: 3703:
        -: 3704:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3705:        {
        -: 3706:          switch((yyvsp[0].expression).value.object->type)
        -: 3707:          {
        -: 3708:            case OBJECT_TYPE_ARRAY:
        -: 3709:              // If iterating an array the loop must define a single variable
        -: 3710:              // that will hold the current item. If a different number of
        -: 3711:              // variables were defined that's an error.
        -: 3712:              if (loop_ctx->vars_count == 1)
        -: 3713:              {
        -: 3714:                loop_ctx->vars[0].type = EXPRESSION_TYPE_OBJECT;
        -: 3715:                loop_ctx->vars[0].value.object = \
        -: 3716:                    object_as_array((yyvsp[0].expression).value.object)->prototype_item;
        -: 3717:
        -: 3718:                result = yr_parser_emit(yyscanner, OP_ITER_START_ARRAY, NULL);
        -: 3719:              }
        -: 3720:              else
        -: 3721:              {
        -: 3722:                yr_compiler_set_error_extra_info_fmt(
        -: 3723:                    compiler,
        -: 3724:                    "iterator for \"%s\" yields a single item on each iteration"
        -: 3725:                    ", but the loop expects %d",
        -: 3726:                    expression_identifier((yyvsp[0].expression)),
        -: 3727:                    loop_ctx->vars_count);
        -: 3728:
        -: 3729:                result = ERROR_SYNTAX_ERROR;
        -: 3730:              }
        -: 3731:              break;
        -: 3732:
        -: 3733:            case OBJECT_TYPE_DICTIONARY:
        -: 3734:              // If iterating a dictionary the loop must define exactly two
        -: 3735:              // variables, one for the key and another for the value . If a
        -: 3736:              // different number of variables were defined that's an error.
        -: 3737:              if (loop_ctx->vars_count == 2)
        -: 3738:              {
        -: 3739:                loop_ctx->vars[0].type = EXPRESSION_TYPE_STRING;
        -: 3740:                loop_ctx->vars[0].value.sized_string_ref = YR_ARENA_NULL_REF;
        -: 3741:                loop_ctx->vars[1].type = EXPRESSION_TYPE_OBJECT;
        -: 3742:                loop_ctx->vars[1].value.object = \
        -: 3743:                    object_as_array((yyvsp[0].expression).value.object)->prototype_item;
        -: 3744:
        -: 3745:                result = yr_parser_emit(yyscanner, OP_ITER_START_DICT, NULL);
        -: 3746:              }
        -: 3747:              else
        -: 3748:              {
        -: 3749:                yr_compiler_set_error_extra_info_fmt(
        -: 3750:                    compiler,
        -: 3751:                    "iterator for \"%s\" yields a key,value pair item on each iteration",
        -: 3752:                    expression_identifier((yyvsp[0].expression)));
        -: 3753:
        -: 3754:                result = ERROR_SYNTAX_ERROR;
        -: 3755:              }
        -: 3756:              break;
        -: 3757:          }
        -: 3758:        }
        -: 3759:
        -: 3760:        if (result == ERROR_WRONG_TYPE)
        -: 3761:        {
        -: 3762:          yr_compiler_set_error_extra_info_fmt(
        -: 3763:              compiler,
        -: 3764:              "identifier \"%s\" is not iterable",
        -: 3765:              expression_identifier((yyvsp[0].expression)));
        -: 3766:        }
        -: 3767:
        -: 3768:        fail_if_error(result);
        -: 3769:      }
        -: 3770:#line 3771 "grammar.c"
    #####: 3771:    break;
        -: 3772:
    #####: 3773:  case 105:
        -: 3774:#line 1997 "grammar.y"
        -: 3775:      {
        -: 3776:        int result = ERROR_SUCCESS;
        -: 3777:
        -: 3778:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 3779:
        -: 3780:        if (loop_ctx->vars_count == 1)
        -: 3781:        {
        -: 3782:          loop_ctx->vars[0].type = EXPRESSION_TYPE_INTEGER;
        -: 3783:          loop_ctx->vars[0].value.integer = YR_UNDEFINED;
        -: 3784:        }
        -: 3785:        else
        -: 3786:        {
        -: 3787:          yr_compiler_set_error_extra_info_fmt(
        -: 3788:              compiler,
        -: 3789:              "iterator yields an integer on each iteration "
        -: 3790:              ", but the loop expects %d",
        -: 3791:              loop_ctx->vars_count);
        -: 3792:
        -: 3793:          result = ERROR_SYNTAX_ERROR;
        -: 3794:        }
        -: 3795:
        -: 3796:        fail_if_error(result);
        -: 3797:      }
        -: 3798:#line 3799 "grammar.c"
    #####: 3799:    break;
        -: 3800:
    #####: 3801:  case 106:
        -: 3802:#line 2025 "grammar.y"
        -: 3803:      {
        -: 3804:        // $2 contains the number of integers in the enumeration
        -: 3805:        fail_if_error(yr_parser_emit_with_arg(
        -: 3806:            yyscanner, OP_PUSH, (yyvsp[-1].integer), NULL, NULL));
        -: 3807:
        -: 3808:        fail_if_error(yr_parser_emit(
        -: 3809:            yyscanner, OP_ITER_START_INT_ENUM, NULL));
        -: 3810:      }
        -: 3811:#line 3812 "grammar.c"
    #####: 3812:    break;
        -: 3813:
    #####: 3814:  case 107:
        -: 3815:#line 2034 "grammar.y"
        -: 3816:      {
        -: 3817:        fail_if_error(yr_parser_emit(
        -: 3818:            yyscanner, OP_ITER_START_INT_RANGE, NULL));
        -: 3819:      }
        -: 3820:#line 3821 "grammar.c"
    #####: 3821:    break;
        -: 3822:
    #####: 3823:  case 108:
        -: 3824:#line 2043 "grammar.y"
        -: 3825:      {
        -: 3826:        int result = ERROR_SUCCESS;
        -: 3827:
        -: 3828:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3829:        {
        -: 3830:          yr_compiler_set_error_extra_info(
        -: 3831:              compiler, "wrong type for range's lower bound");
        -: 3832:          result = ERROR_WRONG_TYPE;
        -: 3833:        }
        -: 3834:
        -: 3835:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3836:        {
        -: 3837:          yr_compiler_set_error_extra_info(
        -: 3838:              compiler, "wrong type for range's upper bound");
        -: 3839:          result = ERROR_WRONG_TYPE;
        -: 3840:        }
        -: 3841:
        -: 3842:        fail_if_error(result);
        -: 3843:      }
        -: 3844:#line 3845 "grammar.c"
    #####: 3845:    break;
        -: 3846:
    #####: 3847:  case 109:
        -: 3848:#line 2067 "grammar.y"
        -: 3849:      {
        -: 3850:        int result = ERROR_SUCCESS;
        -: 3851:
        -: 3852:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3853:        {
        -: 3854:          yr_compiler_set_error_extra_info(
        -: 3855:              compiler, "wrong type for enumeration item");
        -: 3856:          result = ERROR_WRONG_TYPE;
        -: 3857:        }
        -: 3858:
        -: 3859:        fail_if_error(result);
        -: 3860:
        -: 3861:        (yyval.integer) = 1;
        -: 3862:      }
        -: 3863:#line 3864 "grammar.c"
    #####: 3864:    break;
        -: 3865:
    #####: 3866:  case 110:
        -: 3867:#line 2082 "grammar.y"
        -: 3868:      {
        -: 3869:        int result = ERROR_SUCCESS;
        -: 3870:
        -: 3871:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3872:        {
        -: 3873:          yr_compiler_set_error_extra_info(
        -: 3874:              compiler, "wrong type for enumeration item");
        -: 3875:          result = ERROR_WRONG_TYPE;
        -: 3876:        }
        -: 3877:
        -: 3878:        fail_if_error(result);
        -: 3879:
        -: 3880:        (yyval.integer) = (yyvsp[-2].integer) + 1;
        -: 3881:      }
        -: 3882:#line 3883 "grammar.c"
    #####: 3883:    break;
        -: 3884:
    #####: 3885:  case 111:
        -: 3886:#line 2101 "grammar.y"
        -: 3887:      {
        -: 3888:        // Push end-of-list marker
        -: 3889:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);
        -: 3890:      }
        -: 3891:#line 3892 "grammar.c"
    #####: 3892:    break;
        -: 3893:
    #####: 3894:  case 113:
        -: 3895:#line 2107 "grammar.y"
        -: 3896:      {
        -: 3897:        fail_if_error(yr_parser_emit_with_arg(
        -: 3898:            yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL));
        -: 3899:
        -: 3900:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3901:            yyscanner, "$*"));
        -: 3902:      }
        -: 3903:#line 3904 "grammar.c"
    #####: 3904:    break;
        -: 3905:
    #####: 3906:  case 116:
        -: 3907:#line 2125 "grammar.y"
        -: 3908:      {
        -: 3909:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3910:        yr_free((yyvsp[0].c_string));
        -: 3911:
        -: 3912:        fail_if_error(result);
        -: 3913:      }
        -: 3914:#line 3915 "grammar.c"
    #####: 3915:    break;
        -: 3916:
    #####: 3917:  case 117:
        -: 3918:#line 2132 "grammar.y"
        -: 3919:      {
        -: 3920:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3921:        yr_free((yyvsp[0].c_string));
        -: 3922:
        -: 3923:        fail_if_error(result);
        -: 3924:      }
        -: 3925:#line 3926 "grammar.c"
    #####: 3926:    break;
        -: 3927:
    #####: 3928:  case 118:
        -: 3929:#line 2143 "grammar.y"
        -: 3930:      {
        -: 3931:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3932:      }
        -: 3933:#line 3934 "grammar.c"
    #####: 3934:    break;
        -: 3935:
    #####: 3936:  case 119:
        -: 3937:#line 2147 "grammar.y"
        -: 3938:      {
        -: 3939:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);
        -: 3940:        (yyval.integer) = FOR_EXPRESSION_ALL;
        -: 3941:      }
        -: 3942:#line 3943 "grammar.c"
    #####: 3943:    break;
        -: 3944:
    #####: 3945:  case 120:
        -: 3946:#line 2152 "grammar.y"
        -: 3947:      {
        -: 3948:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3949:        (yyval.integer) = FOR_EXPRESSION_ANY;
        -: 3950:      }
        -: 3951:#line 3952 "grammar.c"
    #####: 3952:    break;
        -: 3953:
    #####: 3954:  case 121:
        -: 3955:#line 2161 "grammar.y"
        -: 3956:      {
        -: 3957:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3958:      }
        -: 3959:#line 3960 "grammar.c"
    #####: 3960:    break;
        -: 3961:
    #####: 3962:  case 122:
        -: 3963:#line 2165 "grammar.y"
        -: 3964:      {
        -: 3965:        fail_if_error(yr_parser_emit(
        -: 3966:            yyscanner, OP_FILESIZE, NULL));
        -: 3967:
        -: 3968:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3969:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 3970:      }
        -: 3971:#line 3972 "grammar.c"
    #####: 3972:    break;
        -: 3973:
    #####: 3974:  case 123:
        -: 3975:#line 2173 "grammar.y"
        -: 3976:      {
        -: 3977:        yywarning(yyscanner,
        -: 3978:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3979:            "function from PE module instead.");
        -: 3980:
        -: 3981:        fail_if_error(yr_parser_emit(
        -: 3982:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3983:
        -: 3984:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3985:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 3986:      }
        -: 3987:#line 3988 "grammar.c"
    #####: 3988:    break;
        -: 3989:
    #####: 3990:  case 124:
        -: 3991:#line 2185 "grammar.y"
        -: 3992:      {
        -: 3993:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3994:
        -: 3995:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3996:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3997:        // in the proper OP_INTXX opcode.
        -: 3998:
        -: 3999:        fail_if_error(yr_parser_emit(
        -: 4000:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 4001:
        -: 4002:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4003:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4004:      }
        -: 4005:#line 4006 "grammar.c"
    #####: 4006:    break;
        -: 4007:
    #####: 4008:  case 125:
        -: 4009:#line 2199 "grammar.y"
        -: 4010:      {
        -: 4011:        fail_if_error(yr_parser_emit_with_arg(
        -: 4012:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 4013:
        -: 4014:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4015:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 4016:      }
        -: 4017:#line 4018 "grammar.c"
    #####: 4018:    break;
        -: 4019:
    #####: 4020:  case 126:
        -: 4021:#line 2207 "grammar.y"
        -: 4022:      {
        -: 4023:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 4024:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 4025:
        -: 4026:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4027:      }
        -: 4028:#line 4029 "grammar.c"
    #####: 4029:    break;
        -: 4030:
    #####: 4031:  case 127:
        -: 4032:#line 2214 "grammar.y"
        -: 4033:      {
        -: 4034:        YR_ARENA_REF ref;
        -: 4035:
        -: 4036:        int result = yr_arena_write_data(
        -: 4037:            compiler->arena,
        -: 4038:            YR_SZ_POOL,
        -: 4039:            (yyvsp[0].sized_string),
        -: 4040:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 4041:            &ref);
        -: 4042:
        -: 4043:        yr_free((yyvsp[0].sized_string));
        -: 4044:
        -: 4045:        if (result == ERROR_SUCCESS)
        -: 4046:          result = yr_parser_emit_with_arg_reloc(
        -: 4047:              yyscanner,
        -: 4048:              OP_PUSH,
        -: 4049:              yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 4050:              NULL,
        -: 4051:              NULL);
        -: 4052:
        -: 4053:        fail_if_error(result);
        -: 4054:
        -: 4055:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 4056:        (yyval.expression).value.sized_string_ref = ref;
        -: 4057:      }
        -: 4058:#line 4059 "grammar.c"
    #####: 4059:    break;
        -: 4060:
    #####: 4061:  case 128:
        -: 4062:#line 2240 "grammar.y"
        -: 4063:      {
        -: 4064:        int result = yr_parser_reduce_string_identifier(
        -: 4065:            yyscanner, (yyvsp[0].c_string), OP_COUNT, YR_UNDEFINED);
        -: 4066:
        -: 4067:        yr_free((yyvsp[0].c_string));
        -: 4068:
        -: 4069:        fail_if_error(result);
        -: 4070:
        -: 4071:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4072:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4073:      }
        -: 4074:#line 4075 "grammar.c"
    #####: 4075:    break;
        -: 4076:
    #####: 4077:  case 129:
        -: 4078:#line 2252 "grammar.y"
        -: 4079:      {
        -: 4080:        int result = yr_parser_reduce_string_identifier(
        -: 4081:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, YR_UNDEFINED);
        -: 4082:
        -: 4083:        yr_free((yyvsp[-3].c_string));
        -: 4084:
        -: 4085:        fail_if_error(result);
        -: 4086:
        -: 4087:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4088:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4089:      }
        -: 4090:#line 4091 "grammar.c"
    #####: 4091:    break;
        -: 4092:
    #####: 4093:  case 130:
        -: 4094:#line 2264 "grammar.y"
        -: 4095:      {
        -: 4096:        int result = yr_parser_emit_with_arg(
        -: 4097:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 4098:
        -: 4099:        if (result == ERROR_SUCCESS)
        -: 4100:          result = yr_parser_reduce_string_identifier(
        -: 4101:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, YR_UNDEFINED);
        -: 4102:
        -: 4103:        yr_free((yyvsp[0].c_string));
        -: 4104:
        -: 4105:        fail_if_error(result);
        -: 4106:
        -: 4107:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4108:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4109:      }
        -: 4110:#line 4111 "grammar.c"
    #####: 4111:    break;
        -: 4112:
    #####: 4113:  case 131:
        -: 4114:#line 2280 "grammar.y"
        -: 4115:      {
        -: 4116:        int result = yr_parser_reduce_string_identifier(
        -: 4117:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, YR_UNDEFINED);
        -: 4118:
        -: 4119:        yr_free((yyvsp[-3].c_string));
        -: 4120:
        -: 4121:        fail_if_error(result);
        -: 4122:
        -: 4123:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4124:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4125:      }
        -: 4126:#line 4127 "grammar.c"
    #####: 4127:    break;
        -: 4128:
    #####: 4129:  case 132:
        -: 4130:#line 2292 "grammar.y"
        -: 4131:      {
        -: 4132:        int result = yr_parser_emit_with_arg(
        -: 4133:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 4134:
        -: 4135:        if (result == ERROR_SUCCESS)
        -: 4136:          result = yr_parser_reduce_string_identifier(
        -: 4137:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, YR_UNDEFINED);
        -: 4138:
        -: 4139:        yr_free((yyvsp[0].c_string));
        -: 4140:
        -: 4141:        fail_if_error(result);
        -: 4142:
        -: 4143:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4144:        (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4145:      }
        -: 4146:#line 4147 "grammar.c"
    #####: 4147:    break;
        -: 4148:
    #####: 4149:  case 133:
        -: 4150:#line 2308 "grammar.y"
        -: 4151:      {
        -: 4152:        int result = ERROR_SUCCESS;
        -: 4153:
        -: 4154:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 4155:        {
        -: 4156:          result = yr_parser_emit(
        -: 4157:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 4158:
        -: 4159:          switch((yyvsp[0].expression).value.object->type)
        -: 4160:          {
        -: 4161:            case OBJECT_TYPE_INTEGER:
        -: 4162:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4163:              (yyval.expression).value.integer = YR_UNDEFINED;
        -: 4164:              break;
        -: 4165:            case OBJECT_TYPE_FLOAT:
        -: 4166:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4167:              break;
        -: 4168:            case OBJECT_TYPE_STRING:
        -: 4169:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 4170:              (yyval.expression).value.sized_string_ref = YR_ARENA_NULL_REF;
        -: 4171:              break;
        -: 4172:            default:
        -: 4173:              // In a primary expression any identifier that corresponds to an
        -: 4174:              // object must be of type integer, float or string. If "foobar" is
        -: 4175:              // either a function, structure, dictionary or array you can not
        -: 4176:              // use it as:
        -: 4177:              //   condition: foobar
        -: 4178:              yr_compiler_set_error_extra_info_fmt(
        -: 4179:                  compiler,
        -: 4180:                  "wrong usage of identifier \"%s\"",
        -: 4181:                  expression_identifier((yyvsp[0].expression)));
        -: 4182:
        -: 4183:              result = ERROR_WRONG_TYPE;
        -: 4184:          }
        -: 4185:        }
        -: 4186:        else
        -: 4187:        {
        -: 4188:          (yyval.expression) = (yyvsp[0].expression);
        -: 4189:        }
        -: 4190:
        -: 4191:        fail_if_error(result);
        -: 4192:      }
        -: 4193:#line 4194 "grammar.c"
    #####: 4194:    break;
        -: 4195:
    #####: 4196:  case 134:
        -: 4197:#line 2351 "grammar.y"
        -: 4198:      {
        -: 4199:        int result = ERROR_SUCCESS;
        -: 4200:
        -: 4201:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 4202:
        -: 4203:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 4204:        {
        -: 4205:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4206:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == YR_UNDEFINED) ?
        -: 4207:              YR_UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 4208:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 4209:        }
        -: 4210:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 4211:        {
        -: 4212:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4213:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 4214:        }
        -: 4215:
        -: 4216:        fail_if_error(result);
        -: 4217:      }
        -: 4218:#line 4219 "grammar.c"
    #####: 4219:    break;
        -: 4220:
    #####: 4221:  case 135:
        -: 4222:#line 2372 "grammar.y"
        -: 4223:      {
        -: 4224:        int result = yr_parser_reduce_operation(
        -: 4225:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 4226:
        -: 4227:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 4228:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 4229:        {
        -: 4230:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 4231:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 4232:
        -: 4233:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 4234:              (
        -: 4235:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 4236:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 4237:              ))
        -: 4238:          {
        -: 4239:            yr_compiler_set_error_extra_info_fmt(
        -: 4240:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 4241:
        -: 4242:            result = ERROR_INTEGER_OVERFLOW;
        -: 4243:          }
        -: 4244:          else
        -: 4245:          {
        -: 4246:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 4247:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4248:          }
        -: 4249:        }
        -: 4250:        else
        -: 4251:        {
        -: 4252:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4253:        }
        -: 4254:
        -: 4255:        fail_if_error(result);
        -: 4256:      }
        -: 4257:#line 4258 "grammar.c"
    #####: 4258:    break;
        -: 4259:
    #####: 4260:  case 136:
        -: 4261:#line 2407 "grammar.y"
        -: 4262:      {
        -: 4263:        int result = yr_parser_reduce_operation(
        -: 4264:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 4265:
        -: 4266:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 4267:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 4268:        {
        -: 4269:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 4270:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 4271:
        -: 4272:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 4273:              (
        -: 4274:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 4275:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 4276:              ))
        -: 4277:          {
        -: 4278:            yr_compiler_set_error_extra_info_fmt(
        -: 4279:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 4280:
        -: 4281:            result = ERROR_INTEGER_OVERFLOW;
        -: 4282:          }
        -: 4283:          else
        -: 4284:          {
        -: 4285:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 4286:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4287:          }
        -: 4288:        }
        -: 4289:        else
        -: 4290:        {
        -: 4291:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4292:        }
        -: 4293:
        -: 4294:        fail_if_error(result);
        -: 4295:      }
        -: 4296:#line 4297 "grammar.c"
    #####: 4297:    break;
        -: 4298:
    #####: 4299:  case 137:
        -: 4300:#line 2442 "grammar.y"
        -: 4301:      {
        -: 4302:        int result = yr_parser_reduce_operation(
        -: 4303:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 4304:
        -: 4305:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 4306:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 4307:        {
        -: 4308:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 4309:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 4310:
        -: 4311:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 4312:              (
        -: 4313:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 4314:              ))
        -: 4315:          {
        -: 4316:            yr_compiler_set_error_extra_info_fmt(
        -: 4317:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 4318:
        -: 4319:            result = ERROR_INTEGER_OVERFLOW;
        -: 4320:          }
        -: 4321:          else
        -: 4322:          {
        -: 4323:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 4324:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4325:          }
        -: 4326:        }
        -: 4327:        else
        -: 4328:        {
        -: 4329:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4330:        }
        -: 4331:
        -: 4332:        fail_if_error(result);
        -: 4333:      }
        -: 4334:#line 4335 "grammar.c"
    #####: 4335:    break;
        -: 4336:
    #####: 4337:  case 138:
        -: 4338:#line 2476 "grammar.y"
        -: 4339:      {
        -: 4340:        int result = yr_parser_reduce_operation(
        -: 4341:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 4342:
        -: 4343:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 4344:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 4345:        {
        -: 4346:          if ((yyvsp[0].expression).value.integer != 0)
        -: 4347:          {
        -: 4348:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4349:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4350:          }
        -: 4351:          else
        -: 4352:          {
        -: 4353:            result = ERROR_DIVISION_BY_ZERO;
        -: 4354:          }
        -: 4355:        }
        -: 4356:        else
        -: 4357:        {
        -: 4358:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 4359:        }
        -: 4360:
        -: 4361:        fail_if_error(result);
        -: 4362:      }
        -: 4363:#line 4364 "grammar.c"
    #####: 4364:    break;
        -: 4365:
    #####: 4366:  case 139:
        -: 4367:#line 2501 "grammar.y"
        -: 4368:      {
        -: 4369:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 4370:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 4371:
        -: 4372:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 4373:
        -: 4374:        if ((yyvsp[0].expression).value.integer != 0)
        -: 4375:        {
        -: 4376:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4377:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4378:        }
        -: 4379:        else
        -: 4380:        {
        -: 4381:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 4382:        }
        -: 4383:      }
        -: 4384:#line 4385 "grammar.c"
    #####: 4385:    break;
        -: 4386:
    #####: 4387:  case 140:
        -: 4388:#line 2518 "grammar.y"
        -: 4389:      {
        -: 4390:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4391:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4392:
        -: 4393:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 4394:
        -: 4395:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4396:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4397:      }
        -: 4398:#line 4399 "grammar.c"
    #####: 4399:    break;
        -: 4400:
    #####: 4401:  case 141:
        -: 4402:#line 2528 "grammar.y"
        -: 4403:      {
        -: 4404:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4405:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 4406:
        -: 4407:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 4408:
        -: 4409:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4410:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4411:      }
        -: 4412:#line 4413 "grammar.c"
    #####: 4413:    break;
        -: 4414:
    #####: 4415:  case 142:
        -: 4416:#line 2538 "grammar.y"
        -: 4417:      {
        -: 4418:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 4419:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 4420:
        -: 4421:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 4422:
        -: 4423:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4424:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4425:      }
        -: 4426:#line 4427 "grammar.c"
    #####: 4427:    break;
        -: 4428:
    #####: 4429:  case 143:
        -: 4430:#line 2548 "grammar.y"
        -: 4431:      {
        -: 4432:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 4433:
        -: 4434:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 4435:
        -: 4436:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4437:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == YR_UNDEFINED) ?
        -: 4438:            YR_UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 4439:      }
        -: 4440:#line 4441 "grammar.c"
    #####: 4441:    break;
        -: 4442:
    #####: 4443:  case 144:
        -: 4444:#line 2558 "grammar.y"
        -: 4445:      {
        -: 4446:        int result;
        -: 4447:
        -: 4448:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 4449:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 4450:
        -: 4451:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 4452:
        -: 4453:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 4454:          result = ERROR_INVALID_OPERAND;
        -: 4455:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 4456:          (yyval.expression).value.integer = 0;
        -: 4457:        else
        -: 4458:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4459:
        -: 4460:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4461:
        -: 4462:        fail_if_error(result);
        -: 4463:      }
        -: 4464:#line 4465 "grammar.c"
    #####: 4465:    break;
        -: 4466:
    #####: 4467:  case 145:
        -: 4468:#line 2578 "grammar.y"
        -: 4469:      {
        -: 4470:        int result;
        -: 4471:
        -: 4472:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 4473:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 4474:
        -: 4475:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 4476:
        -: 4477:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 4478:          result = ERROR_INVALID_OPERAND;
        -: 4479:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 4480:          (yyval.expression).value.integer = 0;
        -: 4481:        else
        -: 4482:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 4483:
        -: 4484:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 4485:
        -: 4486:        fail_if_error(result);
        -: 4487:      }
        -: 4488:#line 4489 "grammar.c"
    #####: 4489:    break;
        -: 4490:
    #####: 4491:  case 146:
        -: 4492:#line 2598 "grammar.y"
        -: 4493:      {
        -: 4494:        (yyval.expression) = (yyvsp[0].expression);
        -: 4495:      }
        -: 4496:#line 4497 "grammar.c"
    #####: 4497:    break;
        -: 4498:
        -: 4499:
        -: 4500:#line 4501 "grammar.c"
        -: 4501:
        7: 4502:      default: break;
        -: 4503:    }
        -: 4504:  /* User semantic actions sometimes alter yychar, and that requires
        -: 4505:     that yytoken be updated with the new translation.  We take the
        -: 4506:     approach of translating immediately before every use of yytoken.
        -: 4507:     One alternative is translating here after every semantic action,
        -: 4508:     but that translation would be missed if the semantic action invokes
        -: 4509:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 4510:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 4511:     incorrect destructor might then be invoked immediately.  In the
        -: 4512:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 4513:     to an incorrect destructor call or verbose syntax error message
        -: 4514:     before the lookahead is translated.  */
        -: 4515:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 4516:
      108: 4517:  YYPOPSTACK (yylen);
      108: 4518:  yylen = 0;
        -: 4519:  YY_STACK_PRINT (yyss, yyssp);
        -: 4520:
      108: 4521:  *++yyvsp = yyval;
        -: 4522:
        -: 4523:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 4524:     that goes to, based on the state we popped back to and the rule
        -: 4525:     number reduced by.  */
        -: 4526:  {
      108: 4527:    const int yylhs = yyr1[yyn] - YYNTOKENS;
      108: 4528:    const int yyi = yypgoto[yylhs] + *yyssp;
       13: 4529:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
    #####: 4530:               ? yytable[yyi]
     121*: 4531:               : yydefgoto[yylhs]);
        -: 4532:  }
        -: 4533:
      108: 4534:  goto yynewstate;
        -: 4535:
        -: 4536:
        -: 4537:/*--------------------------------------.
        -: 4538:| yyerrlab -- here on detecting error.  |
        -: 4539:`--------------------------------------*/
       43: 4540:yyerrlab:
        -: 4541:  /* Make sure we have latest lookahead translation.  See comments at
        -: 4542:     user semantic actions for why this is necessary.  */
      43*: 4543:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 4544:
        -: 4545:  /* If not already recovering from an error, report this error.  */
       43: 4546:  if (!yyerrstatus)
        -: 4547:    {
        6: 4548:      ++yynerrs;
        -: 4549:#if ! YYERROR_VERBOSE
        -: 4550:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 4551:#else
        -: 4552:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 4553:                                        yyssp, yytoken)
        -: 4554:      {
        6: 4555:        char const *yymsgp = YY_("syntax error");
        -: 4556:        int yysyntax_error_status;
        6: 4557:        yysyntax_error_status = YYSYNTAX_ERROR;
        6: 4558:        if (yysyntax_error_status == 0)
        6: 4559:          yymsgp = yymsg;
    #####: 4560:        else if (yysyntax_error_status == 1)
        -: 4561:          {
    #####: 4562:            if (yymsg != yymsgbuf)
    #####: 4563:              YYSTACK_FREE (yymsg);
    #####: 4564:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 4565:            if (!yymsg)
        -: 4566:              {
    #####: 4567:                yymsg = yymsgbuf;
    #####: 4568:                yymsg_alloc = sizeof yymsgbuf;
    #####: 4569:                yysyntax_error_status = 2;
        -: 4570:              }
        -: 4571:            else
        -: 4572:              {
    #####: 4573:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 4574:                yymsgp = yymsg;
        -: 4575:              }
        -: 4576:          }
        6: 4577:        yyerror (yyscanner, compiler, yymsgp);
        6: 4578:        if (yysyntax_error_status == 2)
    #####: 4579:          goto yyexhaustedlab;
        -: 4580:      }
        -: 4581:# undef YYSYNTAX_ERROR
        -: 4582:#endif
        -: 4583:    }
        -: 4584:
        -: 4585:
        -: 4586:
       43: 4587:  if (yyerrstatus == 3)
        -: 4588:    {
        -: 4589:      /* If just tried and failed to reuse lookahead token after an
        -: 4590:         error, discard it.  */
        -: 4591:
       37: 4592:      if (yychar <= YYEOF)
        -: 4593:        {
        -: 4594:          /* Return failure if at end of input.  */
        6: 4595:          if (yychar == YYEOF)
        6: 4596:            YYABORT;
        -: 4597:        }
        -: 4598:      else
        -: 4599:        {
       31: 4600:          yydestruct ("Error: discarding",
        -: 4601:                      yytoken, &yylval, yyscanner, compiler);
       31: 4602:          yychar = YYEMPTY;
        -: 4603:        }
        -: 4604:    }
        -: 4605:
        -: 4606:  /* Else will try to reuse lookahead token after shifting the error
        -: 4607:     token.  */
       37: 4608:  goto yyerrlab1;
        -: 4609:
        -: 4610:
        -: 4611:/*---------------------------------------------------.
        -: 4612:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 4613:`---------------------------------------------------*/
        1: 4614:yyerrorlab:
        -: 4615:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 4616:     label yyerrorlab therefore never appears in user code.  */
        -: 4617:  if (0)
        -: 4618:    YYERROR;
        -: 4619:
        -: 4620:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4621:     this YYERROR.  */
        1: 4622:  YYPOPSTACK (yylen);
        1: 4623:  yylen = 0;
        -: 4624:  YY_STACK_PRINT (yyss, yyssp);
        1: 4625:  yystate = *yyssp;
        1: 4626:  goto yyerrlab1;
        -: 4627:
        -: 4628:
        -: 4629:/*-------------------------------------------------------------.
        -: 4630:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 4631:`-------------------------------------------------------------*/
       38: 4632:yyerrlab1:
       38: 4633:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 4634:
        -: 4635:  for (;;)
        -: 4636:    {
      160: 4637:      yyn = yypact[yystate];
      160: 4638:      if (!yypact_value_is_default (yyn))
        -: 4639:        {
      148: 4640:          yyn += YYTERROR;
      148: 4641:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 4642:            {
       38: 4643:              yyn = yytable[yyn];
       38: 4644:              if (0 < yyn)
       38: 4645:                break;
        -: 4646:            }
        -: 4647:        }
        -: 4648:
        -: 4649:      /* Pop the current state because it cannot handle the error token.  */
      122: 4650:      if (yyssp == yyss)
    #####: 4651:        YYABORT;
        -: 4652:
        -: 4653:
      122: 4654:      yydestruct ("Error: popping",
      122: 4655:                  yystos[yystate], yyvsp, yyscanner, compiler);
      122: 4656:      YYPOPSTACK (1);
      122: 4657:      yystate = *yyssp;
        -: 4658:      YY_STACK_PRINT (yyss, yyssp);
        -: 4659:    }
        -: 4660:
        -: 4661:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
       38: 4662:  *++yyvsp = yylval;
        -: 4663:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 4664:
        -: 4665:
        -: 4666:  /* Shift the error token.  */
        -: 4667:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 4668:
       38: 4669:  yystate = yyn;
       38: 4670:  goto yynewstate;
        -: 4671:
        -: 4672:
        -: 4673:/*-------------------------------------.
        -: 4674:| yyacceptlab -- YYACCEPT comes here.  |
        -: 4675:`-------------------------------------*/
    #####: 4676:yyacceptlab:
    #####: 4677:  yyresult = 0;
    #####: 4678:  goto yyreturn;
        -: 4679:
        -: 4680:
        -: 4681:/*-----------------------------------.
        -: 4682:| yyabortlab -- YYABORT comes here.  |
        -: 4683:`-----------------------------------*/
        6: 4684:yyabortlab:
        6: 4685:  yyresult = 1;
        6: 4686:  goto yyreturn;
        -: 4687:
        -: 4688:
        -: 4689:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 4690:/*-------------------------------------------------.
        -: 4691:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 4692:`-------------------------------------------------*/
    #####: 4693:yyexhaustedlab:
    #####: 4694:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
    #####: 4695:  yyresult = 2;
        -: 4696:  /* Fall through.  */
        -: 4697:#endif
        -: 4698:
        -: 4699:
        -: 4700:/*-----------------------------------------------------.
        -: 4701:| yyreturn -- parsing is finished, return the result.  |
        -: 4702:`-----------------------------------------------------*/
        6: 4703:yyreturn:
        6: 4704:  if (yychar != YYEMPTY)
        -: 4705:    {
        -: 4706:      /* Make sure we have latest lookahead translation.  See comments at
        -: 4707:         user semantic actions for why this is necessary.  */
       6*: 4708:      yytoken = YYTRANSLATE (yychar);
        6: 4709:      yydestruct ("Cleanup: discarding lookahead",
        -: 4710:                  yytoken, &yylval, yyscanner, compiler);
        -: 4711:    }
        -: 4712:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4713:     this YYABORT or YYACCEPT.  */
        6: 4714:  YYPOPSTACK (yylen);
        -: 4715:  YY_STACK_PRINT (yyss, yyssp);
       24: 4716:  while (yyssp != yyss)
        -: 4717:    {
       18: 4718:      yydestruct ("Cleanup: popping",
       18: 4719:                  yystos[+*yyssp], yyvsp, yyscanner, compiler);
       18: 4720:      YYPOPSTACK (1);
        -: 4721:    }
        -: 4722:#ifndef yyoverflow
        6: 4723:  if (yyss != yyssa)
    #####: 4724:    YYSTACK_FREE (yyss);
        -: 4725:#endif
        -: 4726:#if YYERROR_VERBOSE
        6: 4727:  if (yymsg != yymsgbuf)
    #####: 4728:    YYSTACK_FREE (yymsg);
        -: 4729:#endif
        6: 4730:  return yyresult;
        -: 4731:}
        -: 4732:#line 2603 "grammar.y"
        -: 4733:
