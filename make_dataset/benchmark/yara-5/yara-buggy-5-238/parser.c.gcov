        -:    0:Source:parser.c
        -:    0:Graph:/home/workspace/libyara/parser.gcno
        -:    0:Data:/home/workspace/libyara/parser.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <stddef.h>
        -:   31:#include <string.h>
        -:   32:#include <limits.h>
        -:   33:
        -:   34:#include <yara/ahocorasick.h>
        -:   35:#include <yara/arena.h>
        -:   36:#include <yara/base64.h>
        -:   37:#include <yara/re.h>
        -:   38:#include <yara/error.h>
        -:   39:#include <yara/exec.h>
        -:   40:#include <yara/object.h>
        -:   41:#include <yara/strutils.h>
        -:   42:#include <yara/utils.h>
        -:   43:#include <yara/modules.h>
        -:   44:#include <yara/parser.h>
        -:   45:#include <yara/mem.h>
        -:   46:#include <yara/integers.h>
        -:   47:
        -:   48:
        -:   49:#define todigit(x)  ((x) >='A'&& (x) <='F')? \
        -:   50:                    ((uint8_t) (x - 'A' + 10)) : \
        -:   51:                    ((uint8_t) (x - '0'))
        -:   52:
        -:   53:
    #####:   54:int yr_parser_emit(
        -:   55:    yyscan_t yyscanner,
        -:   56:    uint8_t instruction,
        -:   57:    YR_ARENA_REF* instruction_ref)
        -:   58:{
    #####:   59:  return yr_arena_write_data(
    #####:   60:      yyget_extra(yyscanner)->arena,
        -:   61:      YR_CODE_SECTION,
        -:   62:      &instruction,
        -:   63:      sizeof(uint8_t),
        -:   64:      instruction_ref);
        -:   65:}
        -:   66:
        -:   67:
    #####:   68:int yr_parser_emit_with_arg_double(
        -:   69:    yyscan_t yyscanner,
        -:   70:    uint8_t instruction,
        -:   71:    double argument,
        -:   72:    YR_ARENA_REF* instruction_ref,
        -:   73:    YR_ARENA_REF* argument_ref)
        -:   74:{
    #####:   75:  int result = yr_arena_write_data(
    #####:   76:      yyget_extra(yyscanner)->arena,
        -:   77:      YR_CODE_SECTION,
        -:   78:      &instruction,
        -:   79:      sizeof(uint8_t),
        -:   80:      instruction_ref);
        -:   81:
    #####:   82:  if (result == ERROR_SUCCESS)
    #####:   83:    result = yr_arena_write_data(
    #####:   84:        yyget_extra(yyscanner)->arena,
        -:   85:        YR_CODE_SECTION,
        -:   86:        &argument,
        -:   87:        sizeof(double),
        -:   88:        argument_ref);
        -:   89:
    #####:   90:  return result;
        -:   91:}
        -:   92:
        -:   93:
        7:   94:int yr_parser_emit_with_arg_int32(
        -:   95:    yyscan_t yyscanner,
        -:   96:    uint8_t instruction,
        -:   97:    int32_t argument,
        -:   98:    YR_ARENA_REF* instruction_ref,
        -:   99:    YR_ARENA_REF* argument_ref)
        -:  100:{
        7:  101:  int result = yr_arena_write_data(
        7:  102:      yyget_extra(yyscanner)->arena,
        -:  103:      YR_CODE_SECTION,
        -:  104:      &instruction,
        -:  105:      sizeof(uint8_t),
        -:  106:      instruction_ref);
        -:  107:
        7:  108:  if (result == ERROR_SUCCESS)
        7:  109:    result = yr_arena_write_data(
        7:  110:        yyget_extra(yyscanner)->arena,
        -:  111:        YR_CODE_SECTION,
        -:  112:        &argument,
        -:  113:        sizeof(int32_t),
        -:  114:        argument_ref);
        -:  115:
        7:  116:  return result;
        -:  117:}
        -:  118:
        -:  119:
    #####:  120:int yr_parser_emit_with_arg(
        -:  121:    yyscan_t yyscanner,
        -:  122:    uint8_t instruction,
        -:  123:    int64_t argument,
        -:  124:    YR_ARENA_REF* instruction_ref,
        -:  125:    YR_ARENA_REF* argument_ref)
        -:  126:{
    #####:  127:  int result = yr_arena_write_data(
    #####:  128:      yyget_extra(yyscanner)->arena,
        -:  129:      YR_CODE_SECTION,
        -:  130:      &instruction,
        -:  131:      sizeof(uint8_t),
        -:  132:      instruction_ref);
        -:  133:
    #####:  134:  if (result == ERROR_SUCCESS)
    #####:  135:    result = yr_arena_write_data(
    #####:  136:        yyget_extra(yyscanner)->arena,
        -:  137:        YR_CODE_SECTION,
        -:  138:        &argument,
        -:  139:        sizeof(int64_t),
        -:  140:        argument_ref);
        -:  141:
    #####:  142:  return result;
        -:  143:}
        -:  144:
        -:  145:
    #####:  146:int yr_parser_emit_with_arg_reloc(
        -:  147:    yyscan_t yyscanner,
        -:  148:    uint8_t instruction,
        -:  149:    void* argument,
        -:  150:    YR_ARENA_REF* instruction_ref,
        -:  151:    YR_ARENA_REF* argument_ref)
        -:  152:{
    #####:  153:  YR_ARENA_REF ref = YR_ARENA_NULL_REF;
        -:  154:
        -:  155:  DECLARE_REFERENCE(void*, ptr) arg;
        -:  156:
    #####:  157:  memset(&arg, 0, sizeof(arg));
    #####:  158:  arg.ptr = argument;
        -:  159:
    #####:  160:  int result = yr_arena_write_data(
    #####:  161:      yyget_extra(yyscanner)->arena,
        -:  162:      YR_CODE_SECTION,
        -:  163:      &instruction,
        -:  164:      sizeof(uint8_t),
        -:  165:      instruction_ref);
        -:  166:
    #####:  167:  if (result == ERROR_SUCCESS)
    #####:  168:    result = yr_arena_write_data(
    #####:  169:        yyget_extra(yyscanner)->arena,
        -:  170:        YR_CODE_SECTION,
        -:  171:        &arg,
        -:  172:        sizeof(arg),
        -:  173:        &ref);
        -:  174:
    #####:  175:  if (result == ERROR_SUCCESS)
    #####:  176:    result = yr_arena_make_ptr_relocatable(
    #####:  177:        yyget_extra(yyscanner)->arena,
        -:  178:        YR_CODE_SECTION,
        -:  179:        ref.offset,
        -:  180:        EOL);
        -:  181:
    #####:  182:  if (argument_ref != NULL)
    #####:  183:    *argument_ref = ref;
        -:  184:
    #####:  185:  return result;
        -:  186:}
        -:  187:
        -:  188:
    #####:  189:int yr_parser_emit_pushes_for_strings(
        -:  190:    yyscan_t yyscanner,
        -:  191:    const char* identifier)
        -:  192:{
    #####:  193:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  194:
    #####:  195:  YR_RULE* current_rule = _yr_compiler_get_rule_by_idx(
        -:  196:      compiler, compiler->current_rule_idx);
        -:  197:
        -:  198:  YR_STRING* string;
        -:  199:
        -:  200:  const char* string_identifier;
        -:  201:  const char* target_identifier;
        -:  202:
    #####:  203:  int matching = 0;
        -:  204:
    #####:  205:  yr_rule_strings_foreach(current_rule, string)
        -:  206:  {
        -:  207:    // Don't generate pushes for strings chained to another one, we are
        -:  208:    // only interested in non-chained strings or the head of the chain.
        -:  209:
    #####:  210:    if (string->chained_to == NULL)
        -:  211:    {
    #####:  212:      string_identifier = string->identifier;
    #####:  213:      target_identifier = identifier;
        -:  214:
    #####:  215:      while (*target_identifier != '\0' &&
    #####:  216:             *string_identifier != '\0' &&
    #####:  217:             *target_identifier == *string_identifier)
        -:  218:      {
    #####:  219:        target_identifier++;
    #####:  220:        string_identifier++;
        -:  221:      }
        -:  222:
    #####:  223:      if ((*target_identifier == '\0' && *string_identifier == '\0') ||
    #####:  224:           *target_identifier == '*')
        -:  225:      {
    #####:  226:        yr_parser_emit_with_arg_reloc(
        -:  227:            yyscanner,
        -:  228:            OP_PUSH,
        -:  229:            string,
        -:  230:            NULL,
        -:  231:            NULL);
        -:  232:
    #####:  233:        string->flags |= STRING_FLAGS_REFERENCED;
    #####:  234:        string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
    #####:  235:        matching++;
        -:  236:      }
        -:  237:    }
        -:  238:  }
        -:  239:
    #####:  240:  if (matching == 0)
        -:  241:  {
    #####:  242:    yr_compiler_set_error_extra_info(compiler, identifier)
    #####:  243:    return ERROR_UNDEFINED_STRING;
        -:  244:  }
        -:  245:
    #####:  246:  return ERROR_SUCCESS;
        -:  247:}
        -:  248:
        -:  249:
    #####:  250:int yr_parser_check_types(
        -:  251:    YR_COMPILER* compiler,
        -:  252:    YR_OBJECT_FUNCTION* function,
        -:  253:    const char* actual_args_fmt)
        -:  254:{
        -:  255:  int i;
        -:  256:
    #####:  257:  for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  258:  {
    #####:  259:    if (function->prototypes[i].arguments_fmt == NULL)
    #####:  260:      break;
        -:  261:
    #####:  262:    if (strcmp(function->prototypes[i].arguments_fmt, actual_args_fmt) == 0)
    #####:  263:      return ERROR_SUCCESS;
        -:  264:  }
        -:  265:
    #####:  266:  yr_compiler_set_error_extra_info(compiler, function->identifier)
        -:  267:
    #####:  268:  return ERROR_WRONG_ARGUMENTS;
        -:  269:}
        -:  270:
        -:  271:
    #####:  272:int yr_parser_lookup_string(
        -:  273:    yyscan_t yyscanner,
        -:  274:    const char* identifier,
        -:  275:    YR_STRING** string)
        -:  276:{
    #####:  277:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  278:
    #####:  279:  YR_RULE* current_rule = _yr_compiler_get_rule_by_idx(
        -:  280:      compiler, compiler->current_rule_idx);
        -:  281:
    #####:  282:  yr_rule_strings_foreach(current_rule, *string)
        -:  283:  {
        -:  284:    // If some string $a gets fragmented into multiple chained
        -:  285:    // strings, all those fragments have the same $a identifier
        -:  286:    // but we are interested in the heading fragment, which is
        -:  287:    // that with chained_to == NULL
        -:  288:
    #####:  289:    if ((*string)->chained_to == NULL &&
    #####:  290:        strcmp((*string)->identifier, identifier) == 0)
        -:  291:    {
    #####:  292:      return ERROR_SUCCESS;
        -:  293:    }
        -:  294:  }
        -:  295:
    #####:  296:  yr_compiler_set_error_extra_info(compiler, identifier)
        -:  297:
    #####:  298:  *string = NULL;
        -:  299:
    #####:  300:  return ERROR_UNDEFINED_STRING;
        -:  301:}
        -:  302:
        -:  303:
        -:  304://
        -:  305:// yr_parser_lookup_loop_variable
        -:  306://
        -:  307:// Searches for a variable with the given identifier in the scope of the current
        -:  308:// "for" loop. In case of nested "for" loops the identifier is searched starting
        -:  309:// at the top-level loop and going down thorough the nested loops until the
        -:  310:// current one. This is ok because inner loops can not re-define an identifier
        -:  311:// already defined by an outer loop.
        -:  312://
        -:  313:// If the variable is found, the return value is the position that the variable
        -:  314:// occupies among all the currently defined variables. If the variable doesn't
        -:  315:// exist the return value is -1.
        -:  316://
        -:  317:// The function can receive a pointer to a YR_EXPRESSION that will populated
        -:  318:// with information about the variable if found. This pointer can be NULL if
        -:  319:// the caller is not interested in getting that information.
        -:  320://
    #####:  321:int yr_parser_lookup_loop_variable(
        -:  322:    yyscan_t yyscanner,
        -:  323:    const char* identifier,
        -:  324:    YR_EXPRESSION* expr)
        -:  325:{
    #####:  326:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  327:  int i, j;
    #####:  328:  int var_offset = 0;
        -:  329:
    #####:  330:  for (i = 0; i <= compiler->loop_index; i++)
        -:  331:  {
    #####:  332:    var_offset += compiler->loop[i].vars_internal_count;
        -:  333:
    #####:  334:    for (j = 0; j < compiler->loop[i].vars_count; j++)
        -:  335:    {
    #####:  336:        if (compiler->loop[i].vars[j].identifier.ptr != NULL &&
    #####:  337:            strcmp(identifier, compiler->loop[i].vars[j].identifier.ptr) == 0)
        -:  338:        {
    #####:  339:          if (expr != NULL)
    #####:  340:            *expr = compiler->loop[i].vars[j];
        -:  341:
    #####:  342:          return var_offset + j;
        -:  343:        }
        -:  344:    }
        -:  345:
    #####:  346:    var_offset += compiler->loop[i].vars_count;
        -:  347:  }
        -:  348:
    #####:  349:  return -1;
        -:  350:}
        -:  351:
        -:  352:
        6:  353:static int _yr_parser_write_string(
        -:  354:    const char* identifier,
        -:  355:    YR_MODIFIER modifier,
        -:  356:    YR_COMPILER* compiler,
        -:  357:    SIZED_STRING* str,
        -:  358:    RE_AST* re_ast,
        -:  359:    YR_ARENA_REF* string_ref,
        -:  360:    int* min_atom_quality,
        -:  361:    int* num_atom)
        -:  362:{
        -:  363:  SIZED_STRING* literal_string;
        -:  364:  YR_ATOM_LIST_ITEM* atom;
        6:  365:  YR_ATOM_LIST_ITEM* atom_list = NULL;
        -:  366:
        -:  367:  int c, result;
        -:  368:  int max_string_len;
        6:  369:  bool free_literal = false;
        -:  370:
       6*:  371:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  372:      compiler->arena,
        -:  373:      YR_STRINGS_TABLE,
        -:  374:      sizeof(YR_STRING),
        -:  375:      string_ref,
        -:  376:      offsetof(YR_STRING, identifier),
        -:  377:      offsetof(YR_STRING, string),
        -:  378:      offsetof(YR_STRING, chained_to),
        -:  379:      EOL));
        -:  380:
        6:  381:  YR_STRING* string = (YR_STRING*) yr_arena_ref_to_ptr(
        -:  382:      compiler->arena, string_ref);
        -:  383:
        -:  384:  YR_ARENA_REF ref;
        -:  385:
       6*:  386:  FAIL_ON_ERROR(yr_arena_write_string(
        -:  387:      compiler->arena,
        -:  388:      YR_SZ_POOL,
        -:  389:      identifier,
        -:  390:      &ref));
        -:  391:
        6:  392:  string->identifier = (const char*) yr_arena_ref_to_ptr(
        -:  393:      compiler->arena, &ref);
        -:  394:
        6:  395:  if (modifier.flags & STRING_FLAGS_HEXADECIMAL ||
        3:  396:      modifier.flags & STRING_FLAGS_REGEXP ||
        1:  397:      modifier.flags & STRING_FLAGS_BASE64 ||
        1:  398:      modifier.flags & STRING_FLAGS_BASE64_WIDE)
        -:  399:  {
        5:  400:    literal_string = yr_re_ast_extract_literal(re_ast);
        -:  401:
        5:  402:    if (literal_string != NULL)
        -:  403:    {
        2:  404:      modifier.flags |= STRING_FLAGS_LITERAL;
        2:  405:      free_literal = true;
        -:  406:    }
        -:  407:    else
        -:  408:    {
        -:  409:      // Non-literal strings can't be marked as fixed offset because once we
        -:  410:      // find a string atom in the scanned data we don't know the offset where
        -:  411:      // the string should start, as the non-literal strings can contain
        -:  412:      // variable-length portions.
        -:  413:
        3:  414:      modifier.flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -:  415:    }
        -:  416:  }
        -:  417:  else
        -:  418:  {
        1:  419:    literal_string = str;
        1:  420:    modifier.flags |= STRING_FLAGS_LITERAL;
        -:  421:  }
        -:  422:
        6:  423:  string->flags = modifier.flags;
        6:  424:  string->rule_idx = compiler->current_rule_idx;
        6:  425:  string->idx = compiler->current_string_idx;
        6:  426:  string->fixed_offset = YR_UNDEFINED;
        6:  427:  string->chained_to = NULL;
        6:  428:  string->string = NULL;
        -:  429:
        6:  430:  if (modifier.flags & STRING_FLAGS_LITERAL)
        -:  431:  {
        3:  432:    result = yr_arena_write_data(
        -:  433:        compiler->arena,
        -:  434:        YR_SZ_POOL,
        3:  435:        literal_string->c_string,
        3:  436:        literal_string->length + 1,   // +1 to include terminating NULL
        -:  437:        &ref);
        -:  438:
        3:  439:    string->length = (uint32_t) literal_string->length;
        3:  440:    string->string = (uint8_t*) yr_arena_ref_to_ptr(compiler->arena, &ref);
        -:  441:
        3:  442:    if (result == ERROR_SUCCESS)
        -:  443:    {
        3:  444:      result = yr_atoms_extract_from_string(
        -:  445:          &compiler->atoms_config,
        3:  446:          (uint8_t*) literal_string->c_string,
        3:  447:          (int32_t) literal_string->length,
        -:  448:          modifier,
        -:  449:          &atom_list,
        -:  450:          min_atom_quality);
        -:  451:    }
        -:  452:  }
        -:  453:  else
        -:  454:  {
        -:  455:    // Emit forwards code
        3:  456:    result = yr_re_ast_emit_code(
        -:  457:        re_ast, compiler->arena, false);
        -:  458:
        -:  459:    // Emit backwards code
        3:  460:    if (result == ERROR_SUCCESS)
        3:  461:      result = yr_re_ast_emit_code(
        -:  462:          re_ast, compiler->arena, true);
        -:  463:
        3:  464:    if (result == ERROR_SUCCESS)
        3:  465:      result = yr_atoms_extract_from_re(
        -:  466:          &compiler->atoms_config,
        -:  467:          re_ast,
        -:  468:          modifier,
        -:  469:          &atom_list,
        -:  470:          min_atom_quality);
        -:  471:  }
        -:  472:
        6:  473:  if (result == ERROR_SUCCESS)
        -:  474:  {
        -:  475:    // Add the string to Aho-Corasick automaton.
        6:  476:    result = yr_ac_add_string(
        -:  477:        compiler->automaton,
        -:  478:        string,
        -:  479:        compiler->current_string_idx,
        -:  480:        atom_list,
        -:  481:        compiler->arena);
        -:  482:  }
        -:  483:
        6:  484:  if (modifier.flags & STRING_FLAGS_LITERAL)
        -:  485:  {
        3:  486:    if (modifier.flags & STRING_FLAGS_WIDE)
    #####:  487:      max_string_len = string->length * 2;
        -:  488:    else
        3:  489:      max_string_len = string->length;
        -:  490:
        3:  491:    if (max_string_len <= YR_MAX_ATOM_LENGTH)
        3:  492:      string->flags |= STRING_FLAGS_FITS_IN_ATOM;
        -:  493:  }
        -:  494:
        6:  495:  atom = atom_list;
        6:  496:  c = 0;
        -:  497:
      537:  498:  while (atom != NULL)
        -:  499:  {
      531:  500:    atom = atom->next;
      531:  501:    c++;
        -:  502:  }
        -:  503:
        6:  504:  (*num_atom) += c;
        -:  505:
        6:  506:  compiler->current_string_idx++;
        -:  507:
        6:  508:  if (free_literal)
        2:  509:    yr_free(literal_string);
        -:  510:
        6:  511:  if (atom_list != NULL)
        6:  512:    yr_atoms_list_destroy(atom_list);
        -:  513:
        6:  514:  return result;
        -:  515:}
        -:  516:
        7:  517:int yr_parser_reduce_string_declaration(
        -:  518:    yyscan_t yyscanner,
        -:  519:    YR_MODIFIER modifier,
        -:  520:    const char* identifier,
        -:  521:    SIZED_STRING* str,
        -:  522:    YR_ARENA_REF* string_ref)
        -:  523:{
        7:  524:  int result = ERROR_SUCCESS;
        7:  525:  int min_atom_quality = YR_MAX_ATOM_QUALITY;
        -:  526:  int atom_quality;
        -:  527:
        -:  528:  char message[512];
        -:  529:
        7:  530:  int32_t min_gap = 0;
        7:  531:  int32_t max_gap = 0;
        -:  532:
        7:  533:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  534:
        7:  535:  RE_AST* re_ast = NULL;
        7:  536:  RE_AST* remainder_re_ast = NULL;
        -:  537:  RE_ERROR re_error;
        -:  538:
        7:  539:  YR_RULE* current_rule = _yr_compiler_get_rule_by_idx(
        -:  540:      compiler, compiler->current_rule_idx);
        -:  541:
        -:  542:  // Determine if a string with the same identifier was already defined
        -:  543:  // by searching for the identifier in strings_table.
        7:  544:  uint32_t string_idx = yr_hash_table_lookup_uint32(
        -:  545:      compiler->strings_table,
        -:  546:      identifier,
        -:  547:      NULL);
        -:  548:
        -:  549:  // The string was already defined, return an error.
        7:  550:  if (string_idx != UINT32_MAX)
        -:  551:  {
        1:  552:    result = ERROR_DUPLICATED_STRING_IDENTIFIER;
        1:  553:    yr_compiler_set_error_extra_info(compiler, identifier)
        1:  554:    goto _exit;
        -:  555:  }
        -:  556:
        -:  557:  // Empty strings are not allowed
        6:  558:  if (str->length == 0)
        -:  559:  {
    #####:  560:    result = ERROR_EMPTY_STRING;
    #####:  561:    yr_compiler_set_error_extra_info(compiler, identifier)
    #####:  562:    goto _exit;
        -:  563:  }
        -:  564:
        -:  565:  // If string identifier is $ this is an anonymous string, if not add the
        -:  566:  // identifier to strings_table.
        6:  567:  if (strcmp(identifier, "$") == 0)
        -:  568:  {
    #####:  569:    modifier.flags |= STRING_FLAGS_ANONYMOUS;
        -:  570:  }
        -:  571:  else
        -:  572:  {
        6:  573:    result = yr_hash_table_add_uint32(
        -:  574:        compiler->strings_table,
        -:  575:        identifier,
        -:  576:        NULL,
        -:  577:        compiler->current_string_idx);
        -:  578:
        6:  579:    if (result != ERROR_SUCCESS)
    #####:  580:      goto _exit;
        -:  581:  }
        -:  582:
        6:  583:  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  584:    modifier.flags |= STRING_FLAGS_NO_CASE;
        -:  585:
        6:  586:  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####:  587:    modifier.flags |= STRING_FLAGS_DOT_ALL;
        -:  588:
        -:  589:  // Hex strings are always handled as DOT_ALL regexps.
        6:  590:  if (modifier.flags & STRING_FLAGS_HEXADECIMAL)
        3:  591:    modifier.flags |= STRING_FLAGS_DOT_ALL;
        -:  592:
        -:  593:  // xor and nocase together is not implemented.
       6*:  594:  if (modifier.flags & STRING_FLAGS_XOR &&
    #####:  595:      modifier.flags & STRING_FLAGS_NO_CASE)
        -:  596:  {
    #####:  597:      result = ERROR_INVALID_MODIFIER;
    #####:  598:      yr_compiler_set_error_extra_info(compiler, "xor nocase")
    #####:  599:      goto _exit;
        -:  600:  }
        -:  601:
        -:  602:  // base64 and nocase together is not implemented.
       6*:  603:  if (modifier.flags & STRING_FLAGS_NO_CASE &&
    #####:  604:      (modifier.flags & STRING_FLAGS_BASE64 ||
    #####:  605:       modifier.flags & STRING_FLAGS_BASE64_WIDE))
        -:  606:  {
    #####:  607:      result = ERROR_INVALID_MODIFIER;
    #####:  608:      yr_compiler_set_error_extra_info(
        -:  609:          compiler,
        -:  610:          modifier.flags & STRING_FLAGS_BASE64 ?
        -:  611:             "base64 nocase" :
        -:  612:             "base64wide nocase")
    #####:  613:      goto _exit;
        -:  614:  }
        -:  615:
        -:  616:  // base64 and fullword together is not implemented.
       6*:  617:  if (modifier.flags & STRING_FLAGS_FULL_WORD &&
    #####:  618:      (modifier.flags & STRING_FLAGS_BASE64 ||
    #####:  619:       modifier.flags & STRING_FLAGS_BASE64_WIDE))
        -:  620:  {
    #####:  621:      result = ERROR_INVALID_MODIFIER;
    #####:  622:      yr_compiler_set_error_extra_info(
        -:  623:          compiler,
        -:  624:          modifier.flags & STRING_FLAGS_BASE64 ?
        -:  625:             "base64 fullword" :
        -:  626:             "base64wide fullword")
    #####:  627:      goto _exit;
        -:  628:  }
        -:  629:
        -:  630:  // base64 and xor together is not implemented.
       6*:  631:  if (modifier.flags & STRING_FLAGS_XOR &&
    #####:  632:      (modifier.flags & STRING_FLAGS_BASE64 ||
    #####:  633:       modifier.flags & STRING_FLAGS_BASE64_WIDE))
        -:  634:  {
    #####:  635:      result = ERROR_INVALID_MODIFIER;
    #####:  636:      yr_compiler_set_error_extra_info(
        -:  637:          compiler,
        -:  638:          modifier.flags & STRING_FLAGS_BASE64 ?
        -:  639:             "base64 xor" :
        -:  640:             "base64wide xor")
    #####:  641:      goto _exit;
        -:  642:  }
        -:  643:
        6:  644:  if (!(modifier.flags & STRING_FLAGS_WIDE) &&
        6:  645:      !(modifier.flags & STRING_FLAGS_XOR) &&
        6:  646:      !(modifier.flags & STRING_FLAGS_BASE64 ||
        6:  647:        modifier.flags & STRING_FLAGS_BASE64_WIDE))
        -:  648:  {
        6:  649:    modifier.flags |= STRING_FLAGS_ASCII;
        -:  650:  }
        -:  651:
        -:  652:  // The STRING_FLAGS_SINGLE_MATCH flag indicates that finding
        -:  653:  // a single match for the string is enough. This is true in
        -:  654:  // most cases, except when the string count (#) and string offset (@)
        -:  655:  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH
        -:  656:  // initially, and unmarked later if required.
        6:  657:  modifier.flags |= STRING_FLAGS_SINGLE_MATCH;
        -:  658:
        -:  659:  // The STRING_FLAGS_FIXED_OFFSET indicates that the string doesn't
        -:  660:  // need to be searched all over the file because the user is using the
        -:  661:  // "at" operator. The string must be searched at a fixed offset in the
        -:  662:  // file. All strings are marked STRING_FLAGS_FIXED_OFFSET initially,
        -:  663:  // and unmarked later if required.
        6:  664:  modifier.flags |= STRING_FLAGS_FIXED_OFFSET;
        -:  665:
        -:  666:
        6:  667:  if (modifier.flags & STRING_FLAGS_HEXADECIMAL ||
        3:  668:      modifier.flags & STRING_FLAGS_REGEXP ||
        1:  669:      modifier.flags & STRING_FLAGS_BASE64 ||
        1:  670:      modifier.flags & STRING_FLAGS_BASE64_WIDE)
        5:  671:  {
        5:  672:    if (modifier.flags & STRING_FLAGS_HEXADECIMAL)
        3:  673:      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);
        2:  674:    else if (modifier.flags & STRING_FLAGS_REGEXP)
        2:  675:      result = yr_re_parse(str->c_string, &re_ast, &re_error);
        -:  676:    else
    #####:  677:      result = yr_base64_ast_from_string(str, modifier, &re_ast, &re_error);
        -:  678:
        5:  679:    if (result != ERROR_SUCCESS)
        -:  680:    {
    #####:  681:      snprintf(
        -:  682:          message,
        -:  683:          sizeof(message),
        -:  684:          "invalid %s \"%s\": %s",
    #####:  685:          (modifier.flags & STRING_FLAGS_HEXADECIMAL) ?
        -:  686:              "hex string" : "regular expression",
        -:  687:          identifier,
        -:  688:          re_error.message);
        -:  689:
    #####:  690:      yr_compiler_set_error_extra_info(
        -:  691:          compiler, message)
        -:  692:
    #####:  693:      goto _exit;
        -:  694:    }
        -:  695:
        5:  696:    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)
        3:  697:      modifier.flags |= STRING_FLAGS_FAST_REGEXP;
        -:  698:
        5:  699:    if (re_ast->flags & RE_FLAGS_GREEDY)
    #####:  700:      modifier.flags |= STRING_FLAGS_GREEDY_REGEXP;
        -:  701:
        -:  702:    // Regular expressions in the strings section can't mix greedy and ungreedy
        -:  703:    // quantifiers like .* and .*?. That's because these regular expressions can
        -:  704:    // be matched forwards and/or backwards depending on the atom found, and we
        -:  705:    // need the regexp to be all-greedy or all-ungreedy to be able to properly
        -:  706:    // calculate the length of the match.
        -:  707:
       5*:  708:    if ((re_ast->flags & RE_FLAGS_GREEDY) &&
    #####:  709:        (re_ast->flags & RE_FLAGS_UNGREEDY))
        -:  710:    {
    #####:  711:      result = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  712:
    #####:  713:      yr_compiler_set_error_extra_info(compiler,
        -:  714:          "greedy and ungreedy quantifiers can't be mixed in a regular "
        -:  715:          "expression")
        -:  716:
    #####:  717:      goto _exit;
        -:  718:    }
        -:  719:
        5:  720:    if (yr_re_ast_contains_dot_star(re_ast))
        -:  721:    {
    #####:  722:      yywarning(
        -:  723:          yyscanner,
        -:  724:          "%s contains .* or .+, consider using .{,N} or .{1,N} with a reasonable value for N",
        -:  725:          identifier);
        -:  726:    }
        -:  727:
        5:  728:    if (compiler->re_ast_callback != NULL)
        -:  729:    {
    #####:  730:      compiler->re_ast_callback(
        -:  731:          current_rule,
        -:  732:          identifier,
        -:  733:          re_ast,
        -:  734:          compiler->re_ast_clbk_user_data);
        -:  735:    }
        -:  736:
        5:  737:    *string_ref = YR_ARENA_NULL_REF;
        -:  738:
       10:  739:    while (re_ast != NULL)
        -:  740:    {
        -:  741:      YR_ARENA_REF ref;
        -:  742:
        5:  743:      uint32_t prev_string_idx = compiler->current_string_idx - 1;
        -:  744:
        5:  745:      int32_t prev_min_gap = min_gap;
        5:  746:      int32_t prev_max_gap = max_gap;
        -:  747:
        5:  748:      result = yr_re_ast_split_at_chaining_point(
        -:  749:          re_ast, &remainder_re_ast, &min_gap, &max_gap);
        -:  750:
        5:  751:      if (result != ERROR_SUCCESS)
    #####:  752:        goto _exit;
        -:  753:
        5:  754:      result = _yr_parser_write_string(
        -:  755:          identifier,
        -:  756:          modifier,
        -:  757:          compiler,
        -:  758:          NULL,
        -:  759:          re_ast,
        -:  760:          &ref,
        -:  761:          &atom_quality,
        5:  762:          &current_rule->num_atoms);
        -:  763:
        5:  764:      if (result != ERROR_SUCCESS)
    #####:  765:        goto _exit;
        -:  766:
        5:  767:      if (atom_quality < min_atom_quality)
        4:  768:        min_atom_quality = atom_quality;
        -:  769:
        5:  770:      if (YR_ARENA_IS_NULL_REF(*string_ref))
        -:  771:      {
        -:  772:        // This is the first string in the chain, the string reference returned
        -:  773:        // by this function must point to this string.
        5:  774:        *string_ref = ref;
        -:  775:      }
        -:  776:      else
        -:  777:      {
        -:  778:        // This is not the first string in the chain, set the appropriate flags
        -:  779:        // and fill the chained_to, chain_gap_min and chain_gap_max fields.
    #####:  780:        YR_STRING* prev_string = (YR_STRING*) yr_arena_get_ptr(
        -:  781:            compiler->arena,
        -:  782:            YR_STRINGS_TABLE,
        -:  783:            prev_string_idx * sizeof(YR_STRING));
        -:  784:
    #####:  785:        YR_STRING* new_string = (YR_STRING*) yr_arena_ref_to_ptr(
        -:  786:            compiler->arena, &ref);
        -:  787:
    #####:  788:        new_string->chained_to = prev_string;
    #####:  789:        new_string->chain_gap_min = prev_min_gap;
    #####:  790:        new_string->chain_gap_max = prev_max_gap;
        -:  791:
        -:  792:        // A string chained to another one can't have a fixed offset, only the
        -:  793:        // head of the string chain can have a fixed offset.
    #####:  794:        new_string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -:  795:
        -:  796:        // There is a previous string, but that string wasn't marked as part of
        -:  797:        // a chain because we can't do that until knowing there will be another
        -:  798:        // string, let's flag it now the we know.
    #####:  799:        prev_string->flags |= STRING_FLAGS_CHAIN_PART;
        -:  800:
        -:  801:        // There is a previous string, so this string is part of a chain, but
        -:  802:        // there will be no more strings because there are no more AST to split,
        -:  803:        // which means that this is the chain's tail.
    #####:  804:        if (remainder_re_ast == NULL)
    #####:  805:          new_string->flags |= STRING_FLAGS_CHAIN_PART |
        -:  806:                               STRING_FLAGS_CHAIN_TAIL;
        -:  807:      }
        -:  808:
        5:  809:      yr_re_ast_destroy(re_ast);
        5:  810:      re_ast = remainder_re_ast;
        -:  811:    }
        -:  812:  }
        -:  813:  else  // not a STRING_FLAGS_HEXADECIMAL or STRING_FLAGS_REGEXP or
        -:  814:        // STRING_FLAGS_BASE64 or STRING_FLAGS_BASE64_WIDE
        -:  815:  {
        1:  816:    result = _yr_parser_write_string(
        -:  817:        identifier,
        -:  818:        modifier,
        -:  819:        compiler,
        -:  820:        str,
        -:  821:        NULL,
        -:  822:        string_ref,
        -:  823:        &min_atom_quality,
        1:  824:        &current_rule->num_atoms);
        -:  825:
        1:  826:    if (result != ERROR_SUCCESS)
    #####:  827:      goto _exit;
        -:  828:  }
        -:  829:
        6:  830:  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)
        -:  831:  {
        2:  832:    yywarning(yyscanner, "%s is slowing down scanning", identifier);
        -:  833:  }
        -:  834:
        4:  835:_exit:
        -:  836:
        7:  837:  if (re_ast != NULL)
    #####:  838:    yr_re_ast_destroy(re_ast);
        -:  839:
        7:  840:  if (remainder_re_ast != NULL)
    #####:  841:    yr_re_ast_destroy(remainder_re_ast);
        -:  842:
        7:  843:  return result;
        -:  844:}
        -:  845:
        -:  846:
        9:  847:int yr_parser_reduce_rule_declaration_phase_1(
        -:  848:    yyscan_t yyscanner,
        -:  849:    int32_t flags,
        -:  850:    const char* identifier,
        -:  851:    YR_ARENA_REF* rule_ref)
        -:  852:{
        -:  853:  YR_FIXUP *fixup;
        9:  854:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        9:  855:  compiler->current_rule_idx = compiler->next_rule_idx;
        9:  856:  compiler->next_rule_idx++;
        -:  857:
        9:  858:  YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(
        -:  859:      compiler->arena,
        -:  860:      YR_NAMESPACES_TABLE,
        9:  861:      compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));
        -:  862:
        9:  863:  if (yr_hash_table_lookup_uint32(
        -:  864:          compiler->rules_table,
        -:  865:          identifier,
        7:  866:          ns->name) != UINT32_MAX ||
        7:  867:      yr_hash_table_lookup(
        -:  868:          compiler->objects_table,
        -:  869:          identifier,
        -:  870:          NULL) != NULL)
        -:  871:  {
        -:  872:    // A rule or variable with the same identifier already exists, return the
        -:  873:    // appropriate error.
        -:  874:
        2:  875:    yr_compiler_set_error_extra_info(compiler, identifier)
        2:  876:    return ERROR_DUPLICATED_IDENTIFIER;
        -:  877:  }
        -:  878:
       7*:  879:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  880:      compiler->arena,
        -:  881:      YR_RULES_TABLE,
        -:  882:      sizeof(YR_RULE),
        -:  883:      rule_ref,
        -:  884:      offsetof(YR_RULE, identifier),
        -:  885:      offsetof(YR_RULE, tags),
        -:  886:      offsetof(YR_RULE, strings),
        -:  887:      offsetof(YR_RULE, metas),
        -:  888:      offsetof(YR_RULE, ns),
        -:  889:      EOL));
        -:  890:
        7:  891:  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);
        -:  892:
        -:  893:  YR_ARENA_REF ref;
        -:  894:
       7*:  895:  FAIL_ON_ERROR(yr_arena_write_string(
        -:  896:      compiler->arena,
        -:  897:      YR_SZ_POOL,
        -:  898:      identifier,
        -:  899:      &ref));
        -:  900:
        7:  901:  rule->identifier = (const char*) yr_arena_ref_to_ptr(compiler->arena, &ref);
        7:  902:  rule->flags = flags;
        7:  903:  rule->ns = ns;
        7:  904:  rule->num_atoms = 0;
        -:  905:
        -:  906:  YR_ARENA_REF jmp_offset_ref;
        -:  907:
        -:  908:  // We are starting to parse a new rule, set current_rule_idx accordingly.
        -:  909:
        -:  910:  // The OP_INIT_RULE instruction behaves like a jump. When the rule is disabled
        -:  911:  // it skips over the rule's code and go straight to the next rule's code. The
        -:  912:  // jmp_offset_ref variable points to the jump's offset. The offset is set to 0
        -:  913:  // as we don't know the jump target yet. When we finish generating the rule's
        -:  914:  // code in yr_parser_reduce_rule_declaration_phase_2 the jump offset is set to
        -:  915:  // its final value.
        -:  916:
       7*:  917:  FAIL_ON_ERROR(yr_parser_emit_with_arg_int32(
        -:  918:      yyscanner,
        -:  919:      OP_INIT_RULE,
        -:  920:      0,
        -:  921:      NULL,
        -:  922:      &jmp_offset_ref));
        -:  923:
       7*:  924:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  925:      compiler->arena,
        -:  926:      YR_CODE_SECTION,
        -:  927:      &compiler->current_rule_idx,
        -:  928:      sizeof(compiler->current_rule_idx),
        -:  929:      NULL));
        -:  930:
        -:  931:  // Create a fixup entry for the jump and push it in the stack
        7:  932:  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -:  933:
        7:  934:  if (fixup == NULL)
    #####:  935:    return ERROR_INSUFFICIENT_MEMORY;
        -:  936:
        7:  937:  fixup->ref = jmp_offset_ref;
        7:  938:  fixup->next = compiler->fixup_stack_head;
        7:  939:  compiler->fixup_stack_head = fixup;
        -:  940:
        -:  941:  // Clean strings_table as we are starting to parse a new rule.
        7:  942:  yr_hash_table_clean(compiler->strings_table, NULL);
        -:  943:
       7*:  944:  FAIL_ON_ERROR(yr_hash_table_add_uint32(
        -:  945:      compiler->rules_table,
        -:  946:      identifier,
        -:  947:      ns->name,
        -:  948:      compiler->current_rule_idx));
        -:  949:
        7:  950:  return ERROR_SUCCESS;
        -:  951:}
        -:  952:
    #####:  953:int yr_parser_reduce_rule_declaration_phase_2(
        -:  954:    yyscan_t yyscanner,
        -:  955:    YR_ARENA_REF* rule_ref)
        -:  956:{
        -:  957:  uint32_t max_strings_per_rule;
    #####:  958:  uint32_t strings_in_rule = 0;
        -:  959:
        -:  960:  YR_FIXUP *fixup;
        -:  961:  YR_STRING* string;
    #####:  962:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  963:
    #####:  964:  yr_get_configuration(
        -:  965:      YR_CONFIG_MAX_STRINGS_PER_RULE,
        -:  966:      (void*) &max_strings_per_rule);
        -:  967:
    #####:  968:  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);
        -:  969:
        -:  970:  // Show warning if the rule is generating too many atoms. The warning is
        -:  971:  // shown if the number of atoms is greater than 20 times the maximum number
        -:  972:  // of strings allowed for a rule, as 20 is minimum number of atoms generated
        -:  973:  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneously.
        -:  974:
    #####:  975:  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)
        -:  976:  {
    #####:  977:    yywarning(yyscanner, "rule is slowing down scanning");
        -:  978:  }
        -:  979:
    #####:  980:  yr_rule_strings_foreach(rule, string)
        -:  981:  {
        -:  982:    // Only the heading fragment in a chain of strings (the one with
        -:  983:    // chained_to == NULL) must be referenced. All other fragments
        -:  984:    // are never marked as referenced.
        -:  985:
    #####:  986:    if (!STRING_IS_REFERENCED(string) &&
    #####:  987:        string->chained_to == NULL)
        -:  988:    {
    #####:  989:      yr_compiler_set_error_extra_info(compiler, string->identifier)
    #####:  990:      return ERROR_UNREFERENCED_STRING;
        -:  991:    }
        -:  992:
    #####:  993:    strings_in_rule++;
        -:  994:
    #####:  995:    if (strings_in_rule > max_strings_per_rule)
        -:  996:    {
    #####:  997:      yr_compiler_set_error_extra_info(compiler, rule->identifier)
    #####:  998:      return ERROR_TOO_MANY_STRINGS;
        -:  999:    }
        -: 1000:  }
        -: 1001:
    #####: 1002:  FAIL_ON_ERROR(yr_parser_emit_with_arg(
        -: 1003:      yyscanner,
        -: 1004:      OP_MATCH_RULE,
        -: 1005:      compiler->current_rule_idx,
        -: 1006:      NULL,
        -: 1007:      NULL));
        -: 1008:
    #####: 1009:  fixup = compiler->fixup_stack_head;
        -: 1010:
    #####: 1011:  int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 1012:      compiler->arena, &fixup->ref);
        -: 1013:
    #####: 1014:  int32_t jmp_offset = \
    #####: 1015:      yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
    #####: 1016:      fixup->ref.offset + 1;
        -: 1017:
    #####: 1018:  *jmp_offset_addr = jmp_offset;
        -: 1019:
        -: 1020:  // Remove fixup from the stack.
    #####: 1021:  compiler->fixup_stack_head = fixup->next;
    #####: 1022:  yr_free(fixup);
        -: 1023:
        -: 1024:  // We have finished parsing the current rule set current_rule_idx to
        -: 1025:  // UINT32_MAX indicating that we are not currently parsing a rule.
    #####: 1026:  compiler->current_rule_idx = UINT32_MAX;
        -: 1027:
    #####: 1028:  return ERROR_SUCCESS;
        -: 1029:}
        -: 1030:
        -: 1031:
    #####: 1032:int yr_parser_reduce_string_identifier(
        -: 1033:    yyscan_t yyscanner,
        -: 1034:    const char* identifier,
        -: 1035:    uint8_t instruction,
        -: 1036:    uint64_t at_offset)
        -: 1037:{
        -: 1038:  YR_STRING* string;
    #####: 1039:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1040:
    #####: 1041:  if (strcmp(identifier, "$") == 0) // is an anonymous string ?
        -: 1042:  {
    #####: 1043:    if (compiler->loop_for_of_var_index >= 0) // inside a loop ?
        -: 1044:    {
    #####: 1045:      yr_parser_emit_with_arg(
        -: 1046:          yyscanner,
        -: 1047:          OP_PUSH_M,
    #####: 1048:          compiler->loop_for_of_var_index,
        -: 1049:          NULL,
        -: 1050:          NULL);
        -: 1051:
    #####: 1052:      yr_parser_emit(yyscanner, instruction, NULL);
        -: 1053:
    #####: 1054:      YR_RULE* current_rule = _yr_compiler_get_rule_by_idx(
        -: 1055:          compiler, compiler->current_rule_idx);
        -: 1056:
    #####: 1057:      yr_rule_strings_foreach(current_rule, string)
        -: 1058:      {
    #####: 1059:        if (instruction != OP_FOUND)
    #####: 1060:          string->flags &= ~STRING_FLAGS_SINGLE_MATCH;
        -: 1061:
    #####: 1062:        if (instruction == OP_FOUND_AT)
        -: 1063:        {
        -: 1064:          // Avoid overwriting any previous fixed offset
    #####: 1065:          if (string->fixed_offset == YR_UNDEFINED)
    #####: 1066:            string->fixed_offset = at_offset;
        -: 1067:
        -: 1068:          // If a previous fixed offset was different, disable
        -: 1069:          // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -: 1070:          // have room to store a single fixed offset value
    #####: 1071:          if (string->fixed_offset != at_offset)
    #####: 1072:            string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -: 1073:        }
        -: 1074:        else
        -: 1075:        {
    #####: 1076:          string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -: 1077:        }
        -: 1078:      }
        -: 1079:    }
        -: 1080:    else
        -: 1081:    {
        -: 1082:      // Anonymous strings not allowed outside of a loop
    #####: 1083:      return ERROR_MISPLACED_ANONYMOUS_STRING;
        -: 1084:    }
        -: 1085:  }
        -: 1086:  else
        -: 1087:  {
    #####: 1088:    FAIL_ON_ERROR(yr_parser_lookup_string(
        -: 1089:        yyscanner, identifier, &string));
        -: 1090:
    #####: 1091:    FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -: 1092:        yyscanner,
        -: 1093:        OP_PUSH,
        -: 1094:        string,
        -: 1095:        NULL,
        -: 1096:        NULL));
        -: 1097:
    #####: 1098:    if (instruction != OP_FOUND)
    #####: 1099:      string->flags &= ~STRING_FLAGS_SINGLE_MATCH;
        -: 1100:
    #####: 1101:    if (instruction == OP_FOUND_AT)
        -: 1102:    {
        -: 1103:      // Avoid overwriting any previous fixed offset
        -: 1104:
    #####: 1105:      if (string->fixed_offset == YR_UNDEFINED)
    #####: 1106:        string->fixed_offset = at_offset;
        -: 1107:
        -: 1108:      // If a previous fixed offset was different, disable
        -: 1109:      // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -: 1110:      // have room to store a single fixed offset value
        -: 1111:
    #####: 1112:      if (string->fixed_offset == YR_UNDEFINED ||
    #####: 1113:          string->fixed_offset != at_offset)
        -: 1114:      {
    #####: 1115:        string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -: 1116:      }
        -: 1117:    }
        -: 1118:    else
        -: 1119:    {
    #####: 1120:      string->flags &= ~STRING_FLAGS_FIXED_OFFSET;
        -: 1121:    }
        -: 1122:
    #####: 1123:    FAIL_ON_ERROR(yr_parser_emit(yyscanner, instruction, NULL));
        -: 1124:
    #####: 1125:    string->flags |= STRING_FLAGS_REFERENCED;
        -: 1126:  }
        -: 1127:
    #####: 1128:  return ERROR_SUCCESS;
        -: 1129:}
        -: 1130:
        -: 1131:
    #####: 1132:int yr_parser_reduce_meta_declaration(
        -: 1133:    yyscan_t yyscanner,
        -: 1134:    int32_t type,
        -: 1135:    const char* identifier,
        -: 1136:    const char* string,
        -: 1137:    int64_t integer,
        -: 1138:    YR_ARENA_REF* meta_ref)
        -: 1139:{
        -: 1140:  YR_ARENA_REF ref;
    #####: 1141:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1142:
    #####: 1143:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -: 1144:      compiler->arena,
        -: 1145:      YR_METAS_TABLE,
        -: 1146:      sizeof(YR_META),
        -: 1147:      meta_ref,
        -: 1148:      offsetof(YR_META, identifier),
        -: 1149:      offsetof(YR_META, string),
        -: 1150:      EOL));
        -: 1151:
    #####: 1152:  YR_META* meta = (YR_META*) yr_arena_ref_to_ptr(compiler->arena, meta_ref);
        -: 1153:
    #####: 1154:  meta->type = type;
    #####: 1155:  meta->integer = integer;
        -: 1156:
    #####: 1157:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1158:      compiler->arena,
        -: 1159:      YR_SZ_POOL,
        -: 1160:      identifier,
        -: 1161:      &ref));
        -: 1162:
    #####: 1163:  meta->identifier = (const char*) yr_arena_ref_to_ptr(compiler->arena, &ref);
        -: 1164:
    #####: 1165:  if (string != NULL)
        -: 1166:  {
    #####: 1167:    FAIL_ON_ERROR(yr_arena_write_string(
        -: 1168:        compiler->arena,
        -: 1169:        YR_SZ_POOL,
        -: 1170:        string,
        -: 1171:        &ref));
        -: 1172:
    #####: 1173:    meta->string = (const char*) yr_arena_ref_to_ptr(compiler->arena, &ref);
        -: 1174:  }
        -: 1175:  else
        -: 1176:  {
    #####: 1177:    meta->string = NULL;
        -: 1178:  }
        -: 1179:
    #####: 1180:  compiler->current_meta_idx++;
        -: 1181:
    #####: 1182:  return ERROR_SUCCESS;
        -: 1183:}
        -: 1184:
        -: 1185:
    #####: 1186:static int _yr_parser_valid_module_name(
        -: 1187:    SIZED_STRING* module_name)
        -: 1188:{
    #####: 1189:  if (module_name->length == 0)
    #####: 1190:    return false;
        -: 1191:
    #####: 1192:  if (strlen(module_name->c_string) != module_name->length)
    #####: 1193:    return false;
        -: 1194:
    #####: 1195:  return true;
        -: 1196:}
        -: 1197:
        -: 1198:
    #####: 1199:int yr_parser_reduce_import(
        -: 1200:    yyscan_t yyscanner,
        -: 1201:    SIZED_STRING* module_name)
        -: 1202:{
        -: 1203:  int result;
        -: 1204:
        -: 1205:  YR_ARENA_REF ref;
    #####: 1206:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1207:  YR_OBJECT* module_structure;
        -: 1208:
    #####: 1209:  if (!_yr_parser_valid_module_name(module_name))
        -: 1210:  {
    #####: 1211:    yr_compiler_set_error_extra_info(compiler, module_name->c_string)
    #####: 1212:    return ERROR_INVALID_MODULE_NAME;
        -: 1213:  }
        -: 1214:
    #####: 1215:  YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(
        -: 1216:      compiler->arena,
        -: 1217:      YR_NAMESPACES_TABLE,
    #####: 1218:      compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));
        -: 1219:
    #####: 1220:  module_structure = (YR_OBJECT*) yr_hash_table_lookup(
        -: 1221:      compiler->objects_table,
    #####: 1222:      module_name->c_string,
        -: 1223:      ns->name);
        -: 1224:
        -: 1225:  // if module already imported, do nothing
        -: 1226:
    #####: 1227:  if (module_structure != NULL)
    #####: 1228:    return ERROR_SUCCESS;
        -: 1229:
    #####: 1230:  FAIL_ON_ERROR(yr_object_create(
        -: 1231:      OBJECT_TYPE_STRUCTURE,
        -: 1232:      module_name->c_string,
        -: 1233:      NULL,
        -: 1234:      &module_structure));
        -: 1235:
    #####: 1236:  FAIL_ON_ERROR(yr_hash_table_add(
        -: 1237:      compiler->objects_table,
        -: 1238:      module_name->c_string,
        -: 1239:      ns->name,
        -: 1240:      module_structure));
        -: 1241:
    #####: 1242:  result = yr_modules_do_declarations(
    #####: 1243:      module_name->c_string,
        -: 1244:      module_structure);
        -: 1245:
    #####: 1246:  if (result == ERROR_UNKNOWN_MODULE)
    #####: 1247:    yr_compiler_set_error_extra_info(compiler, module_name->c_string)
        -: 1248:
    #####: 1249:  if (result != ERROR_SUCCESS)
    #####: 1250:    return result;
        -: 1251:
    #####: 1252:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1253:      compiler->arena,
        -: 1254:      YR_SZ_POOL,
        -: 1255:      module_name->c_string,
        -: 1256:      &ref));
        -: 1257:
    #####: 1258:  FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -: 1259:      yyscanner,
        -: 1260:      OP_IMPORT,
        -: 1261:      yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 1262:      NULL,
        -: 1263:      NULL));
        -: 1264:
    #####: 1265:  return ERROR_SUCCESS;
        -: 1266:}
        -: 1267:
        -: 1268:
    #####: 1269:static int _yr_parser_operator_to_opcode(
        -: 1270:    const char* op,
        -: 1271:    int expression_type)
        -: 1272:{
    #####: 1273:  int opcode = 0;
        -: 1274:
    #####: 1275:  switch(expression_type)
        -: 1276:  {
    #####: 1277:    case EXPRESSION_TYPE_INTEGER:
    #####: 1278:      opcode = OP_INT_BEGIN;
    #####: 1279:      break;
    #####: 1280:    case EXPRESSION_TYPE_FLOAT:
    #####: 1281:      opcode = OP_DBL_BEGIN;
    #####: 1282:      break;
    #####: 1283:    case EXPRESSION_TYPE_STRING:
    #####: 1284:      opcode = OP_STR_BEGIN;
    #####: 1285:      break;
    #####: 1286:    default:
    #####: 1287:      assert(false);
        -: 1288:  }
        -: 1289:
    #####: 1290:  if (op[0] == '<')
        -: 1291:  {
    #####: 1292:    if (op[1] == '=')
    #####: 1293:      opcode += _OP_LE;
        -: 1294:    else
    #####: 1295:      opcode += _OP_LT;
        -: 1296:  }
    #####: 1297:  else if (op[0] == '>')
        -: 1298:  {
    #####: 1299:    if (op[1] == '=')
    #####: 1300:      opcode += _OP_GE;
        -: 1301:    else
    #####: 1302:      opcode += _OP_GT;
        -: 1303:  }
    #####: 1304:  else if (op[1] == '=')
        -: 1305:  {
    #####: 1306:    if (op[0] == '=')
    #####: 1307:      opcode += _OP_EQ;
        -: 1308:    else
    #####: 1309:      opcode += _OP_NEQ;
        -: 1310:  }
    #####: 1311:  else if (op[0] == '+')
        -: 1312:  {
    #####: 1313:    opcode += _OP_ADD;
        -: 1314:  }
    #####: 1315:  else if (op[0] == '-')
        -: 1316:  {
    #####: 1317:    opcode += _OP_SUB;
        -: 1318:  }
    #####: 1319:  else if (op[0] == '*')
        -: 1320:  {
    #####: 1321:    opcode += _OP_MUL;
        -: 1322:  }
    #####: 1323:  else if (op[0] == '\\')
        -: 1324:  {
    #####: 1325:    opcode += _OP_DIV;
        -: 1326:  }
        -: 1327:
    #####: 1328:  if (IS_INT_OP(opcode) || IS_DBL_OP(opcode) || IS_STR_OP(opcode))
        -: 1329:  {
    #####: 1330:    return opcode;
        -: 1331:  }
        -: 1332:
    #####: 1333:  return OP_ERROR;
        -: 1334:}
        -: 1335:
        -: 1336:
    #####: 1337:int yr_parser_reduce_operation(
        -: 1338:    yyscan_t yyscanner,
        -: 1339:    const char* op,
        -: 1340:    YR_EXPRESSION left_operand,
        -: 1341:    YR_EXPRESSION right_operand)
        -: 1342:{
        -: 1343:  int expression_type;
        -: 1344:
    #####: 1345:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1346:
    #####: 1347:  if ((left_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1348:       left_operand.type == EXPRESSION_TYPE_FLOAT) &&
    #####: 1349:      (right_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1350:       right_operand.type == EXPRESSION_TYPE_FLOAT))
        -: 1351:  {
    #####: 1352:    if (left_operand.type != right_operand.type)
        -: 1353:    {
        -: 1354:      // One operand is double and the other is integer,
        -: 1355:      // cast the integer to double
        -: 1356:
    #####: 1357:      FAIL_ON_ERROR(yr_parser_emit_with_arg(
        -: 1358:          yyscanner,
        -: 1359:          OP_INT_TO_DBL,
        -: 1360:          (left_operand.type == EXPRESSION_TYPE_INTEGER) ? 2 : 1,
        -: 1361:          NULL,
        -: 1362:          NULL));
        -: 1363:    }
        -: 1364:
    #####: 1365:    expression_type = EXPRESSION_TYPE_FLOAT;
        -: 1366:
    #####: 1367:    if (left_operand.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1368:        right_operand.type == EXPRESSION_TYPE_INTEGER)
        -: 1369:    {
    #####: 1370:      expression_type = EXPRESSION_TYPE_INTEGER;
        -: 1371:    }
        -: 1372:
    #####: 1373:    FAIL_ON_ERROR(yr_parser_emit(
        -: 1374:        yyscanner,
        -: 1375:        _yr_parser_operator_to_opcode(op, expression_type),
        -: 1376:        NULL));
        -: 1377:  }
    #####: 1378:  else if (left_operand.type == EXPRESSION_TYPE_STRING &&
    #####: 1379:           right_operand.type == EXPRESSION_TYPE_STRING)
    #####: 1380:  {
    #####: 1381:    int opcode = _yr_parser_operator_to_opcode(op, EXPRESSION_TYPE_STRING);
        -: 1382:
    #####: 1383:    if (opcode != OP_ERROR)
        -: 1384:    {
    #####: 1385:      FAIL_ON_ERROR(yr_parser_emit(
        -: 1386:          yyscanner,
        -: 1387:          opcode,
        -: 1388:          NULL));
        -: 1389:    }
        -: 1390:    else
        -: 1391:    {
    #####: 1392:      yr_compiler_set_error_extra_info_fmt(
        -: 1393:          compiler, "strings don't support \"%s\" operation", op)
        -: 1394:
    #####: 1395:      return ERROR_WRONG_TYPE;
        -: 1396:    }
        -: 1397:  }
        -: 1398:  else
        -: 1399:  {
    #####: 1400:    yr_compiler_set_error_extra_info(compiler, "type mismatch")
        -: 1401:
    #####: 1402:    return ERROR_WRONG_TYPE;
        -: 1403:  }
        -: 1404:
    #####: 1405:  return ERROR_SUCCESS;
        -: 1406:}
