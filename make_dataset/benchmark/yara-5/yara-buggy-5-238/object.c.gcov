        -:    0:Source:object.c
        -:    0:Graph:/home/workspace/libyara/object.gcno
        -:    0:Data:/home/workspace/libyara/object.gcda
        -:    0:Runs:10
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:
        -:   31:#include <assert.h>
        -:   32:#include <ctype.h>
        -:   33:#include <stdarg.h>
        -:   34:#include <stdio.h>
        -:   35:#include <stdlib.h>
        -:   36:#include <string.h>
        -:   37:#include <math.h>
        -:   38:
        -:   39:#include <yara/globals.h>
        -:   40:#include <yara/mem.h>
        -:   41:#include <yara/error.h>
        -:   42:#include <yara/object.h>
        -:   43:#include <yara/exec.h>
        -:   44:#include <yara/utils.h>
        -:   45:
        -:   46:
    #####:   47:int yr_object_create(
        -:   48:    int8_t type,
        -:   49:    const char* identifier,
        -:   50:    YR_OBJECT* parent,
        -:   51:    YR_OBJECT** object)
        -:   52:{
        -:   53:  YR_OBJECT* obj;
        -:   54:  int i;
    #####:   55:  size_t object_size = 0;
        -:   56:
    #####:   57:  assert(parent != NULL || object != NULL);
        -:   58:
    #####:   59:  switch (type)
        -:   60:  {
    #####:   61:    case OBJECT_TYPE_STRUCTURE:
    #####:   62:      object_size = sizeof(YR_OBJECT_STRUCTURE);
    #####:   63:      break;
    #####:   64:    case OBJECT_TYPE_ARRAY:
    #####:   65:      object_size = sizeof(YR_OBJECT_ARRAY);
    #####:   66:      break;
    #####:   67:    case OBJECT_TYPE_DICTIONARY:
    #####:   68:      object_size = sizeof(YR_OBJECT_DICTIONARY);
    #####:   69:      break;
    #####:   70:    case OBJECT_TYPE_INTEGER:
    #####:   71:      object_size = sizeof(YR_OBJECT);
    #####:   72:      break;
    #####:   73:    case OBJECT_TYPE_FLOAT:
    #####:   74:      object_size = sizeof(YR_OBJECT);
    #####:   75:      break;
    #####:   76:    case OBJECT_TYPE_STRING:
    #####:   77:      object_size = sizeof(YR_OBJECT);
    #####:   78:      break;
    #####:   79:    case OBJECT_TYPE_FUNCTION:
    #####:   80:      object_size = sizeof(YR_OBJECT_FUNCTION);
    #####:   81:      break;
    #####:   82:    default:
    #####:   83:      assert(false);
        -:   84:  }
        -:   85:
    #####:   86:  obj = (YR_OBJECT*) yr_malloc(object_size);
        -:   87:
    #####:   88:  if (obj == NULL)
    #####:   89:    return ERROR_INSUFFICIENT_MEMORY;
        -:   90:
    #####:   91:  obj->type = type;
    #####:   92:  obj->identifier = yr_strdup(identifier);
    #####:   93:  obj->parent = parent;
    #####:   94:  obj->data = NULL;
        -:   95:
    #####:   96:  switch(type)
        -:   97:  {
    #####:   98:    case OBJECT_TYPE_INTEGER:
    #####:   99:      obj->value.i = YR_UNDEFINED;
    #####:  100:      break;
    #####:  101:    case OBJECT_TYPE_FLOAT:
    #####:  102:      obj->value.d = NAN;
    #####:  103:      break;
    #####:  104:    case OBJECT_TYPE_STRING:
    #####:  105:      obj->value.ss = NULL;
    #####:  106:      break;
    #####:  107:    case OBJECT_TYPE_STRUCTURE:
    #####:  108:      object_as_structure(obj)->members = NULL;
    #####:  109:      break;
    #####:  110:    case OBJECT_TYPE_ARRAY:
    #####:  111:      object_as_array(obj)->items = NULL;
    #####:  112:      object_as_array(obj)->prototype_item = NULL;
    #####:  113:      break;
    #####:  114:    case OBJECT_TYPE_DICTIONARY:
    #####:  115:      object_as_dictionary(obj)->items = NULL;
    #####:  116:      object_as_dictionary(obj)->prototype_item = NULL;
    #####:  117:      break;
    #####:  118:    case OBJECT_TYPE_FUNCTION:
    #####:  119:      object_as_function(obj)->return_obj = NULL;
    #####:  120:      for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  121:      {
    #####:  122:        object_as_function(obj)->prototypes[i].arguments_fmt = NULL;
    #####:  123:        object_as_function(obj)->prototypes[i].code = NULL;
        -:  124:      }
    #####:  125:      break;
        -:  126:  }
        -:  127:
    #####:  128:  if (obj->identifier == NULL)
        -:  129:  {
    #####:  130:    yr_free(obj);
    #####:  131:    return ERROR_INSUFFICIENT_MEMORY;
        -:  132:  }
        -:  133:
    #####:  134:  if (parent != NULL)
        -:  135:  {
    #####:  136:    assert(parent->type == OBJECT_TYPE_STRUCTURE ||
        -:  137:           parent->type == OBJECT_TYPE_ARRAY ||
        -:  138:           parent->type == OBJECT_TYPE_DICTIONARY ||
        -:  139:           parent->type == OBJECT_TYPE_FUNCTION);
        -:  140:
        -:  141:    // Objects with a parent take the canary from it.
    #####:  142:    obj->canary = parent->canary;
        -:  143:
    #####:  144:    switch(parent->type)
        -:  145:    {
    #####:  146:      case OBJECT_TYPE_STRUCTURE:
    #####:  147:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  148:            yr_object_structure_set_member(parent, obj),
        -:  149:            {
        -:  150:              yr_free((void*) obj->identifier);
        -:  151:              yr_free(obj);
        -:  152:            });
    #####:  153:        break;
        -:  154:
    #####:  155:      case OBJECT_TYPE_ARRAY:
    #####:  156:        object_as_array(parent)->prototype_item = obj;
    #####:  157:        break;
        -:  158:
    #####:  159:      case OBJECT_TYPE_DICTIONARY:
    #####:  160:        object_as_dictionary(parent)->prototype_item = obj;
    #####:  161:        break;
        -:  162:
    #####:  163:      case OBJECT_TYPE_FUNCTION:
    #####:  164:        object_as_function(parent)->return_obj = obj;
    #####:  165:        break;
        -:  166:    }
    #####:  167:  }
        -:  168:
    #####:  169:  if (object != NULL)
    #####:  170:    *object = obj;
        -:  171:
    #####:  172:  return ERROR_SUCCESS;
        -:  173:}
        -:  174:
        -:  175:
    #####:  176:void yr_object_set_canary(
        -:  177:    YR_OBJECT* object,
        -:  178:    int canary)
        -:  179:{
    #####:  180:  object->canary = canary;
    #####:  181:}
        -:  182:
        -:  183:
    #####:  184:int yr_object_function_create(
        -:  185:    const char* identifier,
        -:  186:    const char* arguments_fmt,
        -:  187:    const char* return_fmt,
        -:  188:    YR_MODULE_FUNC code,
        -:  189:    YR_OBJECT* parent,
        -:  190:    YR_OBJECT** function)
        -:  191:{
        -:  192:  YR_OBJECT* return_obj;
    #####:  193:  YR_OBJECT* o = NULL;
    #####:  194:  YR_OBJECT_FUNCTION* f = NULL;
        -:  195:
        -:  196:  int8_t return_type;
        -:  197:  int i;
        -:  198:
        -:  199:  // The parent of a function must be a structure.
    #####:  200:  assert(parent != NULL && parent->type == OBJECT_TYPE_STRUCTURE);
        -:  201:
    #####:  202:  switch (*return_fmt)
        -:  203:  {
    #####:  204:    case 'i':
    #####:  205:      return_type = OBJECT_TYPE_INTEGER;
    #####:  206:      break;
    #####:  207:    case 's':
    #####:  208:      return_type = OBJECT_TYPE_STRING;
    #####:  209:      break;
    #####:  210:    case 'f':
    #####:  211:      return_type = OBJECT_TYPE_FLOAT;
    #####:  212:      break;
    #####:  213:    default:
    #####:  214:      return ERROR_INVALID_FORMAT;
        -:  215:  }
        -:  216:
        -:  217:  // Try to find if the structure already has a function
        -:  218:  // with that name. In that case this is a function overload.
    #####:  219:  f = object_as_function(yr_object_lookup_field(parent, identifier));
        -:  220:
        -:  221:  // Overloaded functions must have the same return type.
    #####:  222:  if (f != NULL && return_type != f->return_obj->type)
    #####:  223:    return ERROR_WRONG_RETURN_TYPE;
        -:  224:
    #####:  225:  if (f == NULL) // Function doesn't exist yet
        -:  226:  {
    #####:  227:    FAIL_ON_ERROR(
        -:  228:        yr_object_create(
        -:  229:            OBJECT_TYPE_FUNCTION,
        -:  230:            identifier,
        -:  231:            parent,
        -:  232:            &o));
        -:  233:
    #####:  234:    FAIL_ON_ERROR_WITH_CLEANUP(
        -:  235:        yr_object_create(
        -:  236:            return_type,
        -:  237:            "result",
        -:  238:            o,
        -:  239:            &return_obj),
        -:  240:        yr_object_destroy(o));
        -:  241:
    #####:  242:    f = object_as_function(o);
        -:  243:  }
        -:  244:
    #####:  245:  for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  246:  {
    #####:  247:    if (f->prototypes[i].arguments_fmt == NULL)
        -:  248:    {
    #####:  249:      f->prototypes[i].arguments_fmt = arguments_fmt;
    #####:  250:      f->prototypes[i].code = code;
        -:  251:
    #####:  252:      break;
        -:  253:    }
        -:  254:  }
        -:  255:
    #####:  256:  if (function != NULL)
    #####:  257:    *function = (YR_OBJECT*) f;
        -:  258:
    #####:  259:  return ERROR_SUCCESS;
        -:  260:}
        -:  261:
        -:  262:
    #####:  263:int yr_object_from_external_variable(
        -:  264:    YR_EXTERNAL_VARIABLE* external,
        -:  265:    YR_OBJECT** object)
        -:  266:{
        -:  267:  YR_OBJECT* obj;
        -:  268:  int result;
    #####:  269:  uint8_t obj_type = 0;
        -:  270:
    #####:  271:  switch(external->type)
        -:  272:  {
    #####:  273:    case EXTERNAL_VARIABLE_TYPE_INTEGER:
        -:  274:    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:
    #####:  275:      obj_type = OBJECT_TYPE_INTEGER;
    #####:  276:      break;
        -:  277:
    #####:  278:    case EXTERNAL_VARIABLE_TYPE_FLOAT:
    #####:  279:      obj_type = OBJECT_TYPE_FLOAT;
    #####:  280:      break;
        -:  281:
    #####:  282:    case EXTERNAL_VARIABLE_TYPE_STRING:
        -:  283:    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:
    #####:  284:      obj_type = OBJECT_TYPE_STRING;
    #####:  285:      break;
        -:  286:
    #####:  287:    default:
    #####:  288:      assert(false);
        -:  289:  }
        -:  290:
    #####:  291:  result = yr_object_create(
        -:  292:      obj_type,
        -:  293:      external->identifier,
        -:  294:      NULL,
        -:  295:      &obj);
        -:  296:
    #####:  297:  if (result == ERROR_SUCCESS)
        -:  298:  {
    #####:  299:    switch(external->type)
        -:  300:    {
    #####:  301:      case EXTERNAL_VARIABLE_TYPE_INTEGER:
        -:  302:      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:
    #####:  303:        result = yr_object_set_integer(external->value.i, obj, NULL);
    #####:  304:        break;
        -:  305:
    #####:  306:      case EXTERNAL_VARIABLE_TYPE_FLOAT:
    #####:  307:        result = yr_object_set_float(external->value.f, obj, NULL);
    #####:  308:        break;
        -:  309:
    #####:  310:      case EXTERNAL_VARIABLE_TYPE_STRING:
        -:  311:      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:
    #####:  312:        result = yr_object_set_string(
    #####:  313:            external->value.s, strlen(external->value.s), obj, NULL);
    #####:  314:        break;
        -:  315:    }
        -:  316:
    #####:  317:    if (result == ERROR_SUCCESS)
        -:  318:    {
    #####:  319:      *object = obj;
        -:  320:    }
        -:  321:    else
        -:  322:    {
    #####:  323:      yr_object_destroy(obj);
        -:  324:    }
        -:  325:  }
        -:  326:
    #####:  327:  return result;
        -:  328:}
        -:  329:
        -:  330:
    #####:  331:void yr_object_destroy(
        -:  332:    YR_OBJECT* object)
        -:  333:{
        -:  334:  YR_STRUCTURE_MEMBER* member;
        -:  335:  YR_STRUCTURE_MEMBER* next_member;
        -:  336:  YR_ARRAY_ITEMS* array_items;
        -:  337:  YR_DICTIONARY_ITEMS* dict_items;
        -:  338:
        -:  339:  int i;
        -:  340:
    #####:  341:  if (object == NULL)
    #####:  342:    return;
        -:  343:
    #####:  344:  switch(object->type)
        -:  345:  {
    #####:  346:    case OBJECT_TYPE_STRUCTURE:
    #####:  347:      member = object_as_structure(object)->members;
        -:  348:
    #####:  349:      while (member != NULL)
        -:  350:      {
    #####:  351:        next_member = member->next;
    #####:  352:        yr_object_destroy(member->object);
    #####:  353:        yr_free(member);
    #####:  354:        member = next_member;
        -:  355:      }
    #####:  356:      break;
        -:  357:
    #####:  358:    case OBJECT_TYPE_STRING:
    #####:  359:      if (object->value.ss != NULL)
    #####:  360:        yr_free(object->value.ss);
    #####:  361:      break;
        -:  362:
    #####:  363:    case OBJECT_TYPE_ARRAY:
    #####:  364:      if (object_as_array(object)->prototype_item != NULL)
    #####:  365:        yr_object_destroy(object_as_array(object)->prototype_item);
        -:  366:
    #####:  367:      array_items = object_as_array(object)->items;
        -:  368:
    #####:  369:      if (array_items != NULL)
        -:  370:      {
    #####:  371:        for (i = 0; i < array_items->length; i++)
    #####:  372:          if (array_items->objects[i] != NULL)
    #####:  373:            yr_object_destroy(array_items->objects[i]);
        -:  374:      }
        -:  375:
    #####:  376:      yr_free(array_items);
    #####:  377:      break;
        -:  378:
    #####:  379:    case OBJECT_TYPE_DICTIONARY:
    #####:  380:      if (object_as_dictionary(object)->prototype_item != NULL)
    #####:  381:        yr_object_destroy(object_as_dictionary(object)->prototype_item);
        -:  382:
    #####:  383:      dict_items = object_as_dictionary(object)->items;
        -:  384:
    #####:  385:      if (dict_items != NULL)
        -:  386:      {
    #####:  387:        for (i = 0; i < dict_items->used; i++)
        -:  388:        {
    #####:  389:          if (dict_items->objects[i].key != NULL)
    #####:  390:            yr_free(dict_items->objects[i].key);
        -:  391:
    #####:  392:          if (dict_items->objects[i].obj != NULL)
    #####:  393:            yr_object_destroy(dict_items->objects[i].obj);
        -:  394:        }
        -:  395:      }
        -:  396:
    #####:  397:      yr_free(dict_items);
    #####:  398:      break;
        -:  399:
    #####:  400:    case OBJECT_TYPE_FUNCTION:
    #####:  401:      yr_object_destroy(object_as_function(object)->return_obj);
    #####:  402:      break;
        -:  403:  }
        -:  404:
    #####:  405:  yr_free((void*) object->identifier);
    #####:  406:  yr_free(object);
        -:  407:}
        -:  408:
        -:  409:
    #####:  410:YR_OBJECT* yr_object_lookup_field(
        -:  411:    YR_OBJECT* object,
        -:  412:    const char* field_name)
        -:  413:{
        -:  414:  YR_STRUCTURE_MEMBER* member;
        -:  415:
    #####:  416:  assert(object != NULL);
    #####:  417:  assert(object->type == OBJECT_TYPE_STRUCTURE);
        -:  418:
    #####:  419:  member = object_as_structure(object)->members;
        -:  420:
    #####:  421:  while (member != NULL)
        -:  422:  {
    #####:  423:    if (strcmp(member->object->identifier, field_name) == 0)
    #####:  424:      return member->object;
        -:  425:
    #####:  426:    member = member->next;
        -:  427:  }
        -:  428:
    #####:  429:  return NULL;
        -:  430:}
        -:  431:
        -:  432:
    #####:  433:static YR_OBJECT* _yr_object_lookup(
        -:  434:    YR_OBJECT* object,
        -:  435:    int flags,
        -:  436:    const char* pattern,
        -:  437:    va_list args)
        -:  438:{
    #####:  439:  YR_OBJECT* obj = object;
        -:  440:
    #####:  441:  const char* p = pattern;
    #####:  442:  const char* key = NULL;
        -:  443:
        -:  444:  char str[256];
        -:  445:
        -:  446:  int i;
    #####:  447:  int index = -1;
        -:  448:
    #####:  449:  while (obj != NULL)
        -:  450:  {
    #####:  451:    i = 0;
        -:  452:
    #####:  453:    while (*p != '\0' && *p != '.' && *p != '[' && i < sizeof(str) - 1)
        -:  454:    {
    #####:  455:      str[i++] = *p++;
        -:  456:    }
        -:  457:
    #####:  458:    str[i] = '\0';
        -:  459:
    #####:  460:    if (obj->type != OBJECT_TYPE_STRUCTURE)
    #####:  461:      return NULL;
        -:  462:
    #####:  463:    obj = yr_object_lookup_field(obj, str);
        -:  464:
    #####:  465:    if (obj == NULL)
    #####:  466:      return NULL;
        -:  467:
    #####:  468:    if (*p == '[')
        -:  469:    {
    #####:  470:      p++;
        -:  471:
    #####:  472:      if (*p == '%')
        -:  473:      {
    #####:  474:        p++;
        -:  475:
    #####:  476:        switch(*p++)
        -:  477:        {
    #####:  478:          case 'i':
    #####:  479:            index = va_arg(args, int);
    #####:  480:            break;
    #####:  481:          case 's':
    #####:  482:            key = va_arg(args, const char*);
    #####:  483:            break;
        -:  484:
    #####:  485:          default:
    #####:  486:            return NULL;
        -:  487:        }
        -:  488:      }
    #####:  489:      else if (*p >= '0' && *p <= '9')
        -:  490:      {
    #####:  491:        index = (int) strtol(p, (char**) &p, 10);
        -:  492:      }
    #####:  493:      else if (*p == '"')
        -:  494:      {
    #####:  495:        i = 0;
    #####:  496:        p++;              // skip the opening quotation mark
        -:  497:
    #####:  498:        while (*p != '"' && *p != '\0' && i < sizeof(str) - 1)
    #####:  499:          str[i++] = *p++;
        -:  500:
    #####:  501:        str[i] = '\0';
    #####:  502:        p++;              // skip the closing quotation mark
    #####:  503:        key = str;
        -:  504:      }
        -:  505:      else
        -:  506:      {
    #####:  507:        return NULL;
        -:  508:      }
        -:  509:
    #####:  510:      assert(*p == ']');
    #####:  511:      p++;
    #####:  512:      assert(*p == '.' || *p == '\0');
        -:  513:
    #####:  514:      switch(obj->type)
        -:  515:      {
    #####:  516:        case OBJECT_TYPE_ARRAY:
    #####:  517:          assert(index != -1);
    #####:  518:          obj = yr_object_array_get_item(obj, flags, index);
    #####:  519:          break;
        -:  520:
    #####:  521:        case OBJECT_TYPE_DICTIONARY:
    #####:  522:          assert(key != NULL);
    #####:  523:          obj = yr_object_dict_get_item(obj, flags, key);
    #####:  524:          break;
        -:  525:      }
    #####:  526:    }
        -:  527:
    #####:  528:    if (*p == '\0')
    #####:  529:      break;
        -:  530:
    #####:  531:    p++;
        -:  532:  }
        -:  533:
    #####:  534:  return obj;
        -:  535:}
        -:  536:
        -:  537:
    #####:  538:YR_OBJECT* yr_object_lookup(
        -:  539:    YR_OBJECT* object,
        -:  540:    int flags,
        -:  541:    const char* pattern,
        -:  542:    ...)
        -:  543:{
        -:  544:  YR_OBJECT* result;
        -:  545:
        -:  546:  va_list args;
    #####:  547:  va_start(args, pattern);
        -:  548:
    #####:  549:  result = _yr_object_lookup(object, flags, pattern, args);
        -:  550:
    #####:  551:  va_end(args);
        -:  552:
    #####:  553:  return result;
        -:  554:
        -:  555:}
        -:  556:
        -:  557:
    #####:  558:int yr_object_copy(
        -:  559:    YR_OBJECT* object,
        -:  560:    YR_OBJECT** object_copy)
        -:  561:{
        -:  562:  YR_OBJECT* copy;
        -:  563:  YR_OBJECT* o;
        -:  564:
        -:  565:  YR_STRUCTURE_MEMBER* structure_member;
        -:  566:
        -:  567:  int i;
        -:  568:
    #####:  569:  *object_copy = NULL;
        -:  570:
    #####:  571:  FAIL_ON_ERROR(yr_object_create(
        -:  572:      object->type,
        -:  573:      object->identifier,
        -:  574:      NULL,
        -:  575:      &copy));
        -:  576:
    #####:  577:  copy->canary = object->canary;
        -:  578:
    #####:  579:  switch(object->type)
        -:  580:  {
    #####:  581:    case OBJECT_TYPE_INTEGER:
    #####:  582:      copy->value.i = object->value.i;
    #####:  583:      break;
        -:  584:
    #####:  585:    case OBJECT_TYPE_FLOAT:
    #####:  586:      copy->value.d = object->value.d;
    #####:  587:      break;
        -:  588:
    #####:  589:    case OBJECT_TYPE_STRING:
        -:  590:
    #####:  591:      if (object->value.ss != NULL)
    #####:  592:        copy->value.ss = sized_string_dup(object->value.ss);
        -:  593:      else
    #####:  594:        copy->value.ss = NULL;
        -:  595:
    #####:  596:      break;
        -:  597:
    #####:  598:    case OBJECT_TYPE_FUNCTION:
        -:  599:
    #####:  600:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  601:          yr_object_copy(
        -:  602:              object_as_function(object)->return_obj,
        -:  603:              &object_as_function(copy)->return_obj),
        -:  604:          // cleanup
        -:  605:          yr_object_destroy(copy));
        -:  606:
    #####:  607:      for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
    #####:  608:        object_as_function(copy)->prototypes[i] = \
        -:  609:            object_as_function(object)->prototypes[i];
        -:  610:
    #####:  611:      break;
        -:  612:
    #####:  613:    case OBJECT_TYPE_STRUCTURE:
        -:  614:
    #####:  615:      structure_member = object_as_structure(object)->members;
        -:  616:
    #####:  617:      while (structure_member != NULL)
        -:  618:      {
    #####:  619:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  620:            yr_object_copy(structure_member->object, &o),
        -:  621:            yr_object_destroy(copy));
        -:  622:
    #####:  623:        FAIL_ON_ERROR_WITH_CLEANUP(
        -:  624:            yr_object_structure_set_member(copy, o),
        -:  625:            // cleanup
        -:  626:            yr_free(o);
        -:  627:            yr_object_destroy(copy));
        -:  628:
    #####:  629:        structure_member = structure_member->next;
        -:  630:      }
        -:  631:
    #####:  632:      break;
        -:  633:
    #####:  634:    case OBJECT_TYPE_ARRAY:
        -:  635:
    #####:  636:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  637:          yr_object_copy(object_as_array(object)->prototype_item, &o),
        -:  638:          yr_object_destroy(copy));
        -:  639:
    #####:  640:      object_as_array(copy)->prototype_item = o;
        -:  641:
    #####:  642:      break;
        -:  643:
    #####:  644:    case OBJECT_TYPE_DICTIONARY:
        -:  645:
    #####:  646:      FAIL_ON_ERROR_WITH_CLEANUP(
        -:  647:          yr_object_copy(object_as_dictionary(object)->prototype_item, &o),
        -:  648:          yr_object_destroy(copy));
        -:  649:
    #####:  650:      object_as_dictionary(copy)->prototype_item = o;
        -:  651:
    #####:  652:      break;
        -:  653:
    #####:  654:    default:
    #####:  655:      assert(false);
        -:  656:
        -:  657:  }
        -:  658:
    #####:  659:  *object_copy = copy;
        -:  660:
    #####:  661:  return ERROR_SUCCESS;
        -:  662:}
        -:  663:
        -:  664:
    #####:  665:int yr_object_structure_set_member(
        -:  666:    YR_OBJECT* object,
        -:  667:    YR_OBJECT* member)
        -:  668:{
        -:  669:  YR_STRUCTURE_MEMBER* sm;
        -:  670:
    #####:  671:  assert(object->type == OBJECT_TYPE_STRUCTURE);
        -:  672:
        -:  673:  // Check if the object already have a member with the same identifier
        -:  674:
    #####:  675:  if (yr_object_lookup_field(object,  member->identifier) != NULL)
    #####:  676:    return ERROR_DUPLICATED_STRUCTURE_MEMBER;
        -:  677:
    #####:  678:  sm = (YR_STRUCTURE_MEMBER*) yr_malloc(sizeof(YR_STRUCTURE_MEMBER));
        -:  679:
    #####:  680:  if (sm == NULL)
    #####:  681:    return ERROR_INSUFFICIENT_MEMORY;
        -:  682:
    #####:  683:  member->parent = object;
    #####:  684:  sm->object = member;
    #####:  685:  sm->next = object_as_structure(object)->members;
        -:  686:
    #####:  687:  object_as_structure(object)->members = sm;
        -:  688:
    #####:  689:  return ERROR_SUCCESS;
        -:  690:}
        -:  691:
        -:  692:
    #####:  693:int yr_object_array_length(
        -:  694:    YR_OBJECT* object)
        -:  695:{
        -:  696:  YR_OBJECT_ARRAY* array;
        -:  697:
    #####:  698:  assert(object->type == OBJECT_TYPE_ARRAY);
    #####:  699:  array = object_as_array(object);
        -:  700:
    #####:  701:  if (array->items == NULL)
    #####:  702:    return 0;
        -:  703:
    #####:  704:  return array->items->length;
        -:  705:}
        -:  706:
        -:  707:
    #####:  708:YR_OBJECT* yr_object_array_get_item(
        -:  709:    YR_OBJECT* object,
        -:  710:    int flags,
        -:  711:    int index)
        -:  712:{
    #####:  713:  YR_OBJECT* result = NULL;
        -:  714:  YR_OBJECT_ARRAY* array;
        -:  715:
    #####:  716:  assert(object->type == OBJECT_TYPE_ARRAY);
        -:  717:
    #####:  718:  if (index < 0)
    #####:  719:    return NULL;
        -:  720:
    #####:  721:  array = object_as_array(object);
        -:  722:
    #####:  723:  if (array->items != NULL && array->items->capacity > index)
    #####:  724:    result = array->items->objects[index];
        -:  725:
    #####:  726:  if (result == NULL && flags & OBJECT_CREATE)
        -:  727:  {
    #####:  728:    yr_object_copy(array->prototype_item, &result);
        -:  729:
    #####:  730:    if (result != NULL)
    #####:  731:      yr_object_array_set_item(object, result, index);
        -:  732:  }
        -:  733:
    #####:  734:  return result;
        -:  735:}
        -:  736:
        -:  737:
    #####:  738:int yr_object_array_set_item(
        -:  739:    YR_OBJECT* object,
        -:  740:    YR_OBJECT* item,
        -:  741:    int index)
        -:  742:{
        -:  743:  YR_OBJECT_ARRAY* array;
        -:  744:
        -:  745:  int i;
        -:  746:  int capacity;
        -:  747:
    #####:  748:  assert(index >= 0);
    #####:  749:  assert(object->type == OBJECT_TYPE_ARRAY);
        -:  750:
    #####:  751:  array = object_as_array(object);
        -:  752:
    #####:  753:  if (array->items == NULL)
        -:  754:  {
    #####:  755:    capacity = 64;
        -:  756:
    #####:  757:    while (capacity <= index)
    #####:  758:      capacity *= 2;
        -:  759:
    #####:  760:    array->items = (YR_ARRAY_ITEMS*) yr_malloc(
    #####:  761:        sizeof(YR_ARRAY_ITEMS) + capacity * sizeof(YR_OBJECT*));
        -:  762:
    #####:  763:    if (array->items == NULL)
    #####:  764:      return ERROR_INSUFFICIENT_MEMORY;
        -:  765:
    #####:  766:    memset(array->items->objects, 0, capacity * sizeof(YR_OBJECT*));
        -:  767:
    #####:  768:    array->items->capacity = capacity;
    #####:  769:    array->items->length = 0;
        -:  770:  }
    #####:  771:  else if (index >= array->items->capacity)
        -:  772:  {
    #####:  773:    capacity = array->items->capacity * 2;
        -:  774:
    #####:  775:    while (capacity <= index)
    #####:  776:      capacity *= 2;
        -:  777:
    #####:  778:    array->items = (YR_ARRAY_ITEMS*) yr_realloc(
    #####:  779:        array->items,
    #####:  780:        sizeof(YR_ARRAY_ITEMS) + capacity * sizeof(YR_OBJECT*));
        -:  781:
    #####:  782:    if (array->items == NULL)
    #####:  783:      return ERROR_INSUFFICIENT_MEMORY;
        -:  784:
    #####:  785:    for (i = array->items->capacity; i < capacity; i++)
    #####:  786:      array->items->objects[i] = NULL;
        -:  787:
    #####:  788:    array->items->capacity = capacity;
        -:  789:  }
        -:  790:
    #####:  791:  item->parent = object;
    #####:  792:  array->items->objects[index] = item;
        -:  793:
    #####:  794:  if (index >= array->items->length)
    #####:  795:    array->items->length = index + 1;
        -:  796:
    #####:  797:  return ERROR_SUCCESS;
        -:  798:}
        -:  799:
        -:  800:
    #####:  801:YR_OBJECT* yr_object_dict_get_item(
        -:  802:    YR_OBJECT* object,
        -:  803:    int flags,
        -:  804:    const char* key)
        -:  805:{
        -:  806:  int i;
        -:  807:
    #####:  808:  YR_OBJECT* result = NULL;
        -:  809:  YR_OBJECT_DICTIONARY* dict;
        -:  810:
    #####:  811:  assert(object->type == OBJECT_TYPE_DICTIONARY);
        -:  812:
    #####:  813:  dict = object_as_dictionary(object);
        -:  814:
    #####:  815:  if (dict->items != NULL)
        -:  816:  {
    #####:  817:    for (i = 0; i < dict->items->used; i++)
        -:  818:    {
    #####:  819:      if (strcmp(dict->items->objects[i].key->c_string, key) == 0)
    #####:  820:        result = dict->items->objects[i].obj;
        -:  821:    }
        -:  822:  }
        -:  823:
    #####:  824:  if (result == NULL && flags & OBJECT_CREATE)
        -:  825:  {
    #####:  826:    yr_object_copy(dict->prototype_item, &result);
        -:  827:
    #####:  828:    if (result != NULL)
    #####:  829:      yr_object_dict_set_item(object, result, key);
        -:  830:  }
        -:  831:
    #####:  832:  return result;
        -:  833:}
        -:  834:
        -:  835:
    #####:  836:int yr_object_dict_set_item(
        -:  837:    YR_OBJECT* object,
        -:  838:    YR_OBJECT* item,
        -:  839:    const char* key)
        -:  840:{
        -:  841:  YR_OBJECT_DICTIONARY* dict;
        -:  842:
        -:  843:  int i;
        -:  844:  int count;
        -:  845:
    #####:  846:  assert(object->type == OBJECT_TYPE_DICTIONARY);
        -:  847:
    #####:  848:  dict = object_as_dictionary(object);
        -:  849:
    #####:  850:  if (dict->items == NULL)
        -:  851:  {
    #####:  852:    count = 64;
        -:  853:
    #####:  854:    dict->items = (YR_DICTIONARY_ITEMS*) yr_malloc(
    #####:  855:        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));
        -:  856:
    #####:  857:    if (dict->items == NULL)
    #####:  858:      return ERROR_INSUFFICIENT_MEMORY;
        -:  859:
    #####:  860:    memset(dict->items->objects, 0, count * sizeof(dict->items->objects[0]));
        -:  861:
    #####:  862:    dict->items->free = count;
    #####:  863:    dict->items->used = 0;
        -:  864:  }
    #####:  865:  else if (dict->items->free == 0)
        -:  866:  {
    #####:  867:    count = dict->items->used * 2;
    #####:  868:    dict->items = (YR_DICTIONARY_ITEMS*) yr_realloc(
    #####:  869:        dict->items,
    #####:  870:        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));
        -:  871:
    #####:  872:    if (dict->items == NULL)
    #####:  873:      return ERROR_INSUFFICIENT_MEMORY;
        -:  874:
    #####:  875:    for (i = dict->items->used; i < count; i++)
        -:  876:    {
    #####:  877:      dict->items->objects[i].key = NULL;
    #####:  878:      dict->items->objects[i].obj = NULL;
        -:  879:    }
        -:  880:
    #####:  881:    dict->items->free = dict->items->used;
        -:  882:  }
        -:  883:
    #####:  884:  item->parent = object;
        -:  885:
    #####:  886:  dict->items->objects[dict->items->used].key = sized_string_new(key);
    #####:  887:  dict->items->objects[dict->items->used].obj = item;
        -:  888:
    #####:  889:  dict->items->used++;
    #####:  890:  dict->items->free--;
        -:  891:
    #####:  892:  return ERROR_SUCCESS;
        -:  893:}
        -:  894:
        -:  895:
    #####:  896:bool yr_object_has_undefined_value(
        -:  897:    YR_OBJECT* object,
        -:  898:    const char* field,
        -:  899:    ...)
        -:  900:{
        -:  901:  YR_OBJECT* field_obj;
        -:  902:
        -:  903:  va_list args;
    #####:  904:  va_start(args, field);
        -:  905:
    #####:  906:  if (field != NULL)
    #####:  907:    field_obj = _yr_object_lookup(object, 0, field, args);
        -:  908:  else
    #####:  909:    field_obj = object;
        -:  910:
    #####:  911:  va_end(args);
        -:  912:
    #####:  913:  if (field_obj == NULL)
    #####:  914:    return true;
        -:  915:
    #####:  916:  switch(field_obj->type)
        -:  917:  {
    #####:  918:    case OBJECT_TYPE_FLOAT:
    #####:  919:      return isnan(field_obj->value.d);
    #####:  920:    case OBJECT_TYPE_STRING:
    #####:  921:      return field_obj->value.ss == NULL;
    #####:  922:    case OBJECT_TYPE_INTEGER:
    #####:  923:      return field_obj->value.i == YR_UNDEFINED;
        -:  924:  }
        -:  925:
    #####:  926:  return false;
        -:  927:}
        -:  928:
        -:  929:
    #####:  930:int64_t yr_object_get_integer(
        -:  931:    YR_OBJECT* object,
        -:  932:    const char* field,
        -:  933:    ...)
        -:  934:{
        -:  935:  YR_OBJECT* integer_obj;
        -:  936:
        -:  937:  va_list args;
    #####:  938:  va_start(args, field);
        -:  939:
    #####:  940:  if (field != NULL)
    #####:  941:    integer_obj = _yr_object_lookup(object, 0, field, args);
        -:  942:  else
    #####:  943:    integer_obj = object;
        -:  944:
    #####:  945:  va_end(args);
        -:  946:
    #####:  947:  if (integer_obj == NULL)
    #####:  948:    return YR_UNDEFINED;
        -:  949:
    #####:  950:  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,
        -:  951:          "type of \"%s\" is not integer\n", field);
        -:  952:
    #####:  953:  return integer_obj->value.i;
        -:  954:}
        -:  955:
        -:  956:
    #####:  957:double yr_object_get_float(
        -:  958:    YR_OBJECT* object,
        -:  959:    const char* field,
        -:  960:    ...)
        -:  961:{
        -:  962:  YR_OBJECT* double_obj;
        -:  963:
        -:  964:  va_list args;
    #####:  965:  va_start(args, field);
        -:  966:
    #####:  967:  if (field != NULL)
    #####:  968:    double_obj = _yr_object_lookup(object, 0, field, args);
        -:  969:  else
    #####:  970:    double_obj = object;
        -:  971:
    #####:  972:  va_end(args);
        -:  973:
    #####:  974:  if (double_obj == NULL)
    #####:  975:    return NAN;
        -:  976:
    #####:  977:  assertf(double_obj->type == OBJECT_TYPE_FLOAT,
        -:  978:          "type of \"%s\" is not double\n", field);
        -:  979:
    #####:  980:  return double_obj->value.d;
        -:  981:}
        -:  982:
        -:  983:
    #####:  984:SIZED_STRING* yr_object_get_string(
        -:  985:    YR_OBJECT* object,
        -:  986:    const char* field,
        -:  987:    ...)
        -:  988:{
        -:  989:  YR_OBJECT* string_obj;
        -:  990:
        -:  991:  va_list args;
    #####:  992:  va_start(args, field);
        -:  993:
    #####:  994:  if (field != NULL)
    #####:  995:    string_obj = _yr_object_lookup(object, 0, field, args);
        -:  996:  else
    #####:  997:    string_obj = object;
        -:  998:
    #####:  999:  va_end(args);
        -: 1000:
    #####: 1001:  if (string_obj == NULL)
    #####: 1002:    return NULL;
        -: 1003:
    #####: 1004:  assertf(string_obj->type == OBJECT_TYPE_STRING,
        -: 1005:          "type of \"%s\" is not string\n", field);
        -: 1006:
    #####: 1007:  return string_obj->value.ss;
        -: 1008:}
        -: 1009:
        -: 1010:
    #####: 1011:int yr_object_set_integer(
        -: 1012:    int64_t value,
        -: 1013:    YR_OBJECT* object,
        -: 1014:    const char* field,
        -: 1015:    ...)
        -: 1016:{
        -: 1017:  YR_OBJECT* integer_obj;
        -: 1018:
        -: 1019:  va_list args;
    #####: 1020:  va_start(args, field);
        -: 1021:
    #####: 1022:  if (field != NULL)
    #####: 1023:    integer_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -: 1024:  else
    #####: 1025:    integer_obj = object;
        -: 1026:
    #####: 1027:  va_end(args);
        -: 1028:
    #####: 1029:  if (integer_obj == NULL)
        -: 1030:  {
    #####: 1031:    if (field != NULL)
    #####: 1032:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1033:    else
    #####: 1034:      return ERROR_INVALID_ARGUMENT;
        -: 1035:  }
        -: 1036:
    #####: 1037:  assert(integer_obj->type == OBJECT_TYPE_INTEGER);
        -: 1038:
    #####: 1039:  integer_obj->value.i = value;
        -: 1040:
    #####: 1041:  return ERROR_SUCCESS;
        -: 1042:}
        -: 1043:
        -: 1044:
    #####: 1045:int yr_object_set_float(
        -: 1046:    double value,
        -: 1047:    YR_OBJECT* object,
        -: 1048:    const char* field,
        -: 1049:    ...)
        -: 1050:{
        -: 1051:  YR_OBJECT* double_obj;
        -: 1052:
        -: 1053:  va_list args;
    #####: 1054:  va_start(args, field);
        -: 1055:
    #####: 1056:  if (field != NULL)
    #####: 1057:    double_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -: 1058:  else
    #####: 1059:    double_obj = object;
        -: 1060:
    #####: 1061:  va_end(args);
        -: 1062:
    #####: 1063:  if (double_obj == NULL)
        -: 1064:  {
    #####: 1065:    if (field != NULL)
    #####: 1066:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1067:    else
    #####: 1068:      return ERROR_INVALID_ARGUMENT;
        -: 1069:  }
        -: 1070:
    #####: 1071:  assert(double_obj->type == OBJECT_TYPE_FLOAT);
        -: 1072:
    #####: 1073:  double_obj->value.d = value;
        -: 1074:
    #####: 1075:  return ERROR_SUCCESS;
        -: 1076:}
        -: 1077:
        -: 1078:
    #####: 1079:int yr_object_set_string(
        -: 1080:    const char* value,
        -: 1081:    size_t len,
        -: 1082:    YR_OBJECT* object,
        -: 1083:    const char* field,
        -: 1084:    ...)
        -: 1085:{
        -: 1086:  YR_OBJECT* string_obj;
        -: 1087:
        -: 1088:  va_list args;
    #####: 1089:  va_start(args, field);
        -: 1090:
    #####: 1091:  if (field != NULL)
    #####: 1092:    string_obj = _yr_object_lookup(object, OBJECT_CREATE, field, args);
        -: 1093:  else
    #####: 1094:    string_obj = object;
        -: 1095:
    #####: 1096:  va_end(args);
        -: 1097:
    #####: 1098:  if (string_obj == NULL)
        -: 1099:  {
    #####: 1100:    if (field != NULL)
    #####: 1101:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1102:    else
    #####: 1103:      return ERROR_INVALID_ARGUMENT;
        -: 1104:  }
        -: 1105:
    #####: 1106:  assert(string_obj->type == OBJECT_TYPE_STRING);
        -: 1107:
    #####: 1108:  if (string_obj->value.ss != NULL)
    #####: 1109:    yr_free(string_obj->value.ss);
        -: 1110:
    #####: 1111:  if (value != NULL)
        -: 1112:  {
    #####: 1113:    string_obj->value.ss = (SIZED_STRING*) yr_malloc(
        -: 1114:        len + sizeof(SIZED_STRING));
        -: 1115:
    #####: 1116:    if (string_obj->value.ss == NULL)
    #####: 1117:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1118:
    #####: 1119:    string_obj->value.ss->length = (uint32_t) len;
    #####: 1120:    string_obj->value.ss->flags = 0;
        -: 1121:
    #####: 1122:    memcpy(string_obj->value.ss->c_string, value, len);
    #####: 1123:    string_obj->value.ss->c_string[len] = '\0';
        -: 1124:  }
        -: 1125:  else
        -: 1126:  {
    #####: 1127:    string_obj->value.ss = NULL;
        -: 1128:  }
        -: 1129:
    #####: 1130:  return ERROR_SUCCESS;
        -: 1131:}
        -: 1132:
        -: 1133:
    #####: 1134:YR_OBJECT* yr_object_get_root(
        -: 1135:    YR_OBJECT* object)
        -: 1136:{
    #####: 1137:  YR_OBJECT* o = object;
        -: 1138:
    #####: 1139:  while (o->parent != NULL)
    #####: 1140:    o = o->parent;
        -: 1141:
    #####: 1142:  return o;
        -: 1143:}
        -: 1144:
    #####: 1145:YR_API void yr_object_print_data(
        -: 1146:    YR_OBJECT* object,
        -: 1147:    int indent,
        -: 1148:    int print_identifier)
        -: 1149:{
        -: 1150:  YR_DICTIONARY_ITEMS* dict_items;
        -: 1151:  YR_STRUCTURE_MEMBER* member;
        -: 1152:
        -: 1153:  char indent_spaces[32];
        -: 1154:  int i;
        -: 1155:
    #####: 1156:  indent = yr_min(indent, sizeof(indent_spaces) - 1);
        -: 1157:
    #####: 1158:  memset(indent_spaces, '\t', indent);
    #####: 1159:  indent_spaces[indent] = '\0';
        -: 1160:
    #####: 1161:  if (print_identifier && object->type != OBJECT_TYPE_FUNCTION)
    #####: 1162:    printf("%s%s", indent_spaces, object->identifier);
        -: 1163:
    #####: 1164:  switch(object->type)
        -: 1165:  {
    #####: 1166:    case OBJECT_TYPE_FLOAT:
    #####: 1167:      if (object->value.i != YR_UNDEFINED)
    #####: 1168:        printf(" = %f", object->value.d);
        -: 1169:      else
    #####: 1170:        printf(" = YR_UNDEFINED");
        -: 1171:
    #####: 1172:      break;
        -: 1173:
    #####: 1174:    case OBJECT_TYPE_INTEGER:
        -: 1175:
    #####: 1176:      if (object->value.i != YR_UNDEFINED)
    #####: 1177:        printf(" = %" PRId64, object->value.i);
        -: 1178:      else
    #####: 1179:        printf(" = YR_UNDEFINED");
        -: 1180:
    #####: 1181:      break;
        -: 1182:
    #####: 1183:    case OBJECT_TYPE_STRING:
        -: 1184:
    #####: 1185:      if (object->value.ss != NULL)
        -: 1186:      {
        -: 1187:        size_t l;
    #####: 1188:        printf(" = \"");
        -: 1189:
    #####: 1190:        for (l = 0; l < object->value.ss->length; l++)
        -: 1191:        {
    #####: 1192:          char c = object->value.ss->c_string[l];
        -: 1193:
    #####: 1194:          if (isprint((unsigned char) c))
    #####: 1195:            printf("%c", c);
        -: 1196:          else
    #####: 1197:            printf("\\x%02x", (unsigned char) c);
        -: 1198:        }
        -: 1199:
    #####: 1200:        printf("\"");
        -: 1201:      }
        -: 1202:      else
        -: 1203:      {
    #####: 1204:        printf(" = YR_UNDEFINED");
        -: 1205:      }
        -: 1206:
    #####: 1207:      break;
        -: 1208:
    #####: 1209:    case OBJECT_TYPE_STRUCTURE:
        -: 1210:
    #####: 1211:      member = object_as_structure(object)->members;
        -: 1212:
    #####: 1213:      while (member != NULL)
        -: 1214:      {
    #####: 1215:        if (member->object->type != OBJECT_TYPE_FUNCTION)
        -: 1216:        {
    #####: 1217:          printf("\n");
    #####: 1218:          yr_object_print_data(member->object, indent + 1, 1);
        -: 1219:        }
    #####: 1220:        member = member->next;
        -: 1221:      }
        -: 1222:
    #####: 1223:      break;
        -: 1224:
    #####: 1225:    case OBJECT_TYPE_ARRAY:
    #####: 1226:      for (i = 0; i < yr_object_array_length(object); i++)
        -: 1227:      {
    #####: 1228:        YR_OBJECT* o = yr_object_array_get_item(object, 0, i);
        -: 1229:
    #####: 1230:        if (o != NULL)
        -: 1231:        {
    #####: 1232:          printf("\n%s\t[%d]", indent_spaces, i);
    #####: 1233:          yr_object_print_data(o, indent + 1, 0);
        -: 1234:        }
        -: 1235:      }
    #####: 1236:      break;
        -: 1237:
    #####: 1238:    case OBJECT_TYPE_DICTIONARY:
        -: 1239:
    #####: 1240:      dict_items = object_as_dictionary(object)->items;
        -: 1241:
    #####: 1242:      if (dict_items != NULL)
        -: 1243:      {
    #####: 1244:        for (i = 0; i < dict_items->used; i++)
        -: 1245:        {
    #####: 1246:          printf(
        -: 1247:              "\n%s\t%s",
        -: 1248:              indent_spaces,
    #####: 1249:              dict_items->objects[i].key->c_string);
        -: 1250:
    #####: 1251:          yr_object_print_data(dict_items->objects[i].obj, indent + 1, 0);
        -: 1252:        }
        -: 1253:      }
        -: 1254:
    #####: 1255:      break;
        -: 1256:  }
    #####: 1257:}
