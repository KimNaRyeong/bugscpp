        -:    0:Source:re_lexer.l
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:10
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for regular expressions */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <assert.h>
        -:   48:#include <setjmp.h>
        -:   49:
        -:   50:#include <yara/globals.h>
        -:   51:#include <yara/utils.h>
        -:   52:#include <yara/error.h>
        -:   53:#include <yara/limits.h>
        -:   54:#include <yara/mem.h>
        -:   55:#include <yara/re.h>
        -:   56:#include <yara/re_lexer.h>
        -:   57:#include <yara/threading.h>
        -:   58:#include <yara/strutils.h>
        -:   59:
        -:   60:
        -:   61:#ifdef _WIN32
        -:   62:#define snprintf _snprintf
        -:   63:#endif
        -:   64:
        -:   65:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:   66:// is set to 1 if the corresponding character is alphanumeric or 0 if otherwise.
        -:   67:static uint8_t word_chars[] = {
        -:   68:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:   69:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:   70:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   71:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   72:
        -:   73:// Bitmap with 1 bit for each of the 256 characters in the ASCII table. The bit
        -:   74:// is set to 1 if the corresponding character is considered a space. Space
        -:   75:// characters include horizontal and vertical tabs, carriage return, new line
        -:   76:// and form feed (\t, \v, \r, \n, \f).
        -:   77:static uint8_t space_chars[] = {
        -:   78:    0x00, 0x3E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        -:   79:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   80:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   81:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   82:
        -:   83:int escaped_char_value(
        -:   84:    char* text,
        -:   85:    uint8_t* value);
        -:   86:
        -:   87:int read_escaped_char(
        -:   88:    yyscan_t yyscanner,
        -:   89:    uint8_t* escaped_char);
        -:   90:
        -:   91:%}
        -:   92:
        -:   93:%option reentrant bison-bridge
        -:   94:%option noyywrap
        -:   95:%option nounistd
        -:   96:%option nounput
        -:   97:%option never-interactive
        -:   98:%option yylineno
        -:   99:%option prefix="re_yy"
        -:  100:
        -:  101:%option outfile="lex.yy.c"
        -:  102:
        -:  103:%option verbose
        -:  104:%option warn
        -:  105:
        -:  106:%x char_class
        -:  107:
        -:  108:digit         [0-9]
        -:  109:hex_digit     [0-9a-fA-F]
        -:  110:
        -:  111:%%
        -:  112:
        -:  113:\{{digit}*,{digit}*\} {
        -:  114:
        -:  115:  // Examples: {3,8} {0,5} {,5} {7,}
        -:  116:
        -:  117:  int hi_bound;
    #####:  118:  int lo_bound = atoi(yytext + 1);
        -:  119:
    #####:  120:  char* comma = strchr(yytext, ',');
        -:  121:
    #####:  122:  if (comma - yytext == strlen(yytext) - 2)
        -:  123:    // if comma is followed by the closing curly bracket
        -:  124:    // (example: {2,}) set high bound value to maximum.
    #####:  125:    hi_bound = INT16_MAX;
        -:  126:  else
    #####:  127:    hi_bound = atoi(comma + 1);
        -:  128:
    #####:  129:  if (hi_bound > INT16_MAX)
        -:  130:  {
    #####:  131:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  132:    yyterminate();
        -:  133:  }
        -:  134:
    #####:  135:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
        -:  136:  {
    #####:  137:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  138:    yyterminate();
        -:  139:  }
        -:  140:
    #####:  141:  if (hi_bound == 0 && lo_bound == 0)
        -:  142:  {
    #####:  143:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  144:    yyterminate();
        -:  145:  }
        -:  146:
    #####:  147:  yylval->range = (hi_bound << 16) | lo_bound;
        -:  148:
    #####:  149:  return _RANGE_;
        -:  150:}
        -:  151:
    #####:  152:
        -:  153:\{{digit}+\} {
        -:  154:
        -:  155:  // Example: {10}
        -:  156:
    #####:  157:  int value = atoi(yytext + 1);
        -:  158:
        -:  159:  // atoi can return a negative value if the input string represents a number
        -:  160:  // too large to fit in an integer.
        -:  161:
    #####:  162:  if (value > INT16_MAX || value < 0)
        -:  163:  {
    #####:  164:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  165:    yyterminate();
        -:  166:  }
        -:  167:
    #####:  168:  if (value == 0)
        -:  169:  {
    #####:  170:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  171:    yyterminate();
        -:  172:  }
        -:  173:
    #####:  174:  yylval->range = (value << 16) | value;
        -:  175:
    #####:  176:  return _RANGE_;
        -:  177:}
        -:  178:
    #####:  179:
        -:  180:\[\^ {
        -:  181:
        -:  182:  // Start of a negated character class. Example: [^abcd]
        -:  183:
    #####:  184:  BEGIN(char_class);
    #####:  185:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  186:  LEX_ENV->re_class.negated = true;
        -:  187:}
    #####:  188:
    #####:  189:\[\^\] {
        -:  190:
        -:  191:  // Start of character negated class containing a ].
        -:  192:  // Example: [^]abc] this must be interpreted as a class
        -:  193:  // not matching ], a, b, nor c
        -:  194:
    #####:  195:  BEGIN(char_class);
    #####:  196:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  197:  LEX_ENV->re_class.negated = true;
    #####:  198:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  199:}
    #####:  200:
    #####:  201:
        -:  202:\[\] {
        -:  203:
        -:  204:  // Start of character class containing a ].
        -:  205:  // Example: []abc] this must be interpreted as a class
        -:  206:  // matching ], a, b, or c.
        -:  207:
    #####:  208:  BEGIN(char_class);
    #####:  209:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  210:  LEX_ENV->re_class.negated = false;
    #####:  211:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  212:}
    #####:  213:
    #####:  214:
        -:  215:\[ {
        -:  216:
        -:  217:  // Start of character class. Example: [abcd]
        -:  218:
    #####:  219:  BEGIN(char_class);
    #####:  220:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  221:  LEX_ENV->re_class.negated = false;
        -:  222:}
    #####:  223:
        5:  224:
        -:  225:[^\\\[\(\)\|\$\.\^\+\*\?] {
        -:  226:
        -:  227:  // Any non-special character is passed as a CHAR token to the scanner.
        -:  228:
        5:  229:  yylval->integer = yytext[0];
        5:  230:  return _CHAR_;
        -:  231:}
        -:  232:
    #####:  233:
        -:  234:\\w {
    #####:  235:  return _WORD_CHAR_;
        -:  236:}
        -:  237:
    #####:  238:
        -:  239:\\W {
    #####:  240:  return _NON_WORD_CHAR_;
        -:  241:}
        -:  242:
    #####:  243:
        -:  244:\\s {
    #####:  245:  return _SPACE_;
        -:  246:}
        -:  247:
    #####:  248:
        -:  249:\\S {
    #####:  250:  return _NON_SPACE_;
        -:  251:}
        -:  252:
    #####:  253:
        -:  254:\\d {
    #####:  255:  return _DIGIT_;
        -:  256:}
        -:  257:
    #####:  258:
        -:  259:\\D {
    #####:  260:  return _NON_DIGIT_;
        -:  261:}
        -:  262:
    #####:  263:
        -:  264:\\b {
    #####:  265:  return _WORD_BOUNDARY_;
        -:  266:}
        -:  267:
    #####:  268:\\B {
    #####:  269:  return _NON_WORD_BOUNDARY_;
        -:  270:}
        -:  271:
    #####:  272:
        -:  273:\\{digit}+ {
        -:  274:
    #####:  275:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
    #####:  276:  yyterminate();
        -:  277:}
        -:  278:
    #####:  279:
        -:  280:\\ {
        -:  281:
        -:  282:  uint8_t c;
        -:  283:
    #####:  284:  if (read_escaped_char(yyscanner, &c))
        -:  285:  {
    #####:  286:    yylval->integer = c;
    #####:  287:    return _CHAR_;
        -:  288:  }
        -:  289:  else
        -:  290:  {
    #####:  291:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  292:    yyterminate();
        -:  293:  }
        -:  294:}
        -:  295:
    #####:  296:
        -:  297:<char_class>\] {
        -:  298:
        -:  299:  // End of character class.
    #####:  300:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
    #####:  301:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -:  302:
    #####:  303:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -:  304:
    #####:  305:  BEGIN(INITIAL);
    #####:  306:  return _CLASS_;
        -:  307:}
        -:  308:
    #####:  309:
        -:  310:
        -:  311:<char_class>(\\x{hex_digit}{2}|\\.|[^\\])\-[^]] {
        -:  312:
        -:  313:  // A range inside a character class.
        -:  314:  //  [abc0-9]
        -:  315:  //      ^- matching here
        -:  316:
        -:  317:  uint16_t c;
    #####:  318:  uint8_t start = yytext[0];
    #####:  319:  uint8_t end = yytext[2];
        -:  320:
    #####:  321:  if (start == '\\')
        -:  322:  {
    #####:  323:    if (!escaped_char_value(yytext, &start))
        -:  324:    {
    #####:  325:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  326:      yyterminate();
        -:  327:    }
        -:  328:
    #####:  329:    if (yytext[1] == 'x')
    #####:  330:      end = yytext[5];
        -:  331:    else
    #####:  332:      end = yytext[3];
        -:  333:  }
        -:  334:
    #####:  335:  if (end == '\\')
        -:  336:  {
    #####:  337:    if (!read_escaped_char(yyscanner, &end))
        -:  338:    {
    #####:  339:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  340:      yyterminate();
        -:  341:    }
        -:  342:  }
        -:  343:
    #####:  344:  if (end < start)
        -:  345:  {
    #####:  346:    yyerror(yyscanner, lex_env, "bad character range");
    #####:  347:    yyterminate();
        -:  348:  }
        -:  349:
    #####:  350:  for (c = start; c <= end; c++)
        -:  351:  {
    #####:  352:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  353:  }
        -:  354:}
    #####:  355:
    #####:  356:
        -:  357:<char_class>\\w {
        -:  358:
        -:  359:  int i;
        -:  360:
    #####:  361:  for (i = 0; i < 32; i++)
    #####:  362:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -:  363:}
    #####:  364:
    #####:  365:
        -:  366:<char_class>\\W {
        -:  367:
        -:  368:  int i;
        -:  369:
    #####:  370:  for (i = 0; i < 32; i++)
    #####:  371:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -:  372:}
    #####:  373:
    #####:  374:
        -:  375:<char_class>\\s {
        -:  376:
        -:  377:  int i;
        -:  378:
    #####:  379:  for (i = 0; i < 32; i++)
    #####:  380:    LEX_ENV->re_class.bitmap[i] |= space_chars[i];
        -:  381:}
    #####:  382:
    #####:  383:
        -:  384:<char_class>\\S {
        -:  385:
        -:  386:  int i;
        -:  387:
    #####:  388:  for (i = 0; i < 32; i++)
    #####:  389:    LEX_ENV->re_class.bitmap[i] |= ~space_chars[i];
        -:  390:}
    #####:  391:
    #####:  392:
        -:  393:<char_class>\\d {
        -:  394:
        -:  395:  char c;
        -:  396:
    #####:  397:  for (c = '0'; c <= '9'; c++)
    #####:  398:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  399:}
    #####:  400:
    #####:  401:
        -:  402:<char_class>\\D {
        -:  403:
        -:  404:  int i;
        -:  405:
    #####:  406:  for (i = 0; i < 32; i++)
        -:  407:  {
        -:  408:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
    #####:  409:    if (i == 6)
    #####:  410:      continue;
        -:  411:
        -:  412:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -:  413:    // vector, let those bits alone.
    #####:  414:    if (i == 7)
    #####:  415:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -:  416:    else
    #####:  417:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  418:  }
        -:  419:}
    #####:  420:
    #####:  421:
        -:  422:<char_class>\\ {
        -:  423:
        -:  424:  uint8_t c;
        -:  425:
    #####:  426:  if (read_escaped_char(yyscanner, &c))
        -:  427:  {
    #####:  428:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  429:  }
        -:  430:  else
        -:  431:  {
    #####:  432:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  433:    yyterminate();
        -:  434:  }
        -:  435:}
    #####:  436:
    #####:  437:
        -:  438:<char_class>. {
        -:  439:
    #####:  440:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  441:  {
        -:  442:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -:  443:    // here we set to 1 the vector's bit corresponding to the input character.
        -:  444:
    #####:  445:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -:  446:  }
        -:  447:  else
        -:  448:  {
    #####:  449:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  450:    yyterminate();
        -:  451:  }
        -:  452:}
    #####:  453:
    #####:  454:
        -:  455:<char_class><<EOF>> {
        -:  456:
        -:  457:  // End of regexp reached while scanning a character class.
        -:  458:
    #####:  459:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
    #####:  460:  yyterminate();
        -:  461:}
        -:  462:
        1:  463:
        -:  464:. {
        -:  465:
        1:  466:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  467:  {
        1:  468:    return yytext[0];
        -:  469:  }
        -:  470:  else
        -:  471:  {
    #####:  472:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  473:    yyterminate();
        -:  474:  }
        -:  475:}
        -:  476:
        2:  477:
        -:  478:<<EOF>> {
        -:  479:
        2:  480:  yyterminate();
        -:  481:}
        -:  482:
    #####:  483:%%
    #####:  484:
    #####:  485:int escaped_char_value(
        -:  486:    char* text,
        -:  487:    uint8_t* value)
        -:  488:{
        -:  489:  unsigned int hex_value;
        -:  490:  char hex[3];
        -:  491:
    #####:  492:  assert(text[0] == '\\');
        -:  493:
    #####:  494:  switch(text[1])
        -:  495:  {
    #####:  496:  case 'x':
    #####:  497:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
    #####:  498:      return 0;
    #####:  499:    hex[0] = text[2];
    #####:  500:    hex[1] = text[3];
    #####:  501:    hex[2] = '\0';
    #####:  502:    sscanf(hex, "%x", &hex_value);
    #####:  503:    *value = (uint8_t) hex_value;
    #####:  504:    break;
        -:  505:
    #####:  506:  case 'n':
    #####:  507:    *value = '\n';
    #####:  508:    break;
        -:  509:
    #####:  510:  case 't':
    #####:  511:    *value = '\t';
    #####:  512:    break;
        -:  513:
    #####:  514:  case 'r':
    #####:  515:    *value = '\r';
    #####:  516:    break;
        -:  517:
    #####:  518:  case 'f':
    #####:  519:    *value = '\f';
    #####:  520:    break;
        -:  521:
    #####:  522:  case 'a':
    #####:  523:    *value = '\a';
    #####:  524:    break;
        -:  525:
    #####:  526:  default:
    #####:  527:    *value = text[1];
        -:  528:  }
        -:  529:
    #####:  530:  return 1;
        -:  531:}
        -:  532:
        -:  533:
        -:  534:#ifdef __cplusplus
        -:  535:#define RE_YY_INPUT yyinput
        -:  536:#else
        -:  537:#define RE_YY_INPUT input
        -:  538:#endif
        -:  539:
        -:  540:
    #####:  541:int read_escaped_char(
        -:  542:    yyscan_t yyscanner,
        -:  543:    uint8_t* escaped_char)
        -:  544:{
    #####:  545:  char text[4] = {0, 0, 0, 0};
        -:  546:
    #####:  547:  text[0] = '\\';
    #####:  548:  text[1] = RE_YY_INPUT(yyscanner);
        -:  549:
    #####:  550:  if (text[1] == EOF || text[1] == 0)
    #####:  551:    return 0;
        -:  552:
    #####:  553:  if (text[1] == 'x')
        -:  554:  {
    #####:  555:    text[2] = RE_YY_INPUT(yyscanner);
        -:  556:
    #####:  557:    if (text[2] == EOF || text[2] == 0)
    #####:  558:      return 0;
        -:  559:
    #####:  560:    text[3] = RE_YY_INPUT(yyscanner);
        -:  561:
    #####:  562:    if (text[3] == EOF || text[3] == 0)
    #####:  563:      return 0;
        -:  564:  }
        -:  565:
    #####:  566:  return escaped_char_value(text, escaped_char);
        -:  567:}
        -:  568:
        -:  569:
        -:  570://
        -:  571:// yyfatal (actually named re_yyfatal because of the '%option prefix="re_yy"'
        -:  572:// directive) is called when a fatal error occurs in the parser. When this
        -:  573:// happens we are deep inside the parsing logic generated by flex/bison and
        -:  574:// the only way to exit gracefully from there is using setjmp/longjmp.
        -:  575://
    #####:  576:void yyfatal(
        -:  577:    yyscan_t yyscanner,
        -:  578:    const char *error_message)
        -:  579:{
    #####:  580:  jmp_buf* recovery_trampoline = (jmp_buf*) yr_thread_storage_get_value(
        -:  581:      &yr_yyfatal_trampoline_tls);
        -:  582:
    #####:  583:  longjmp(*recovery_trampoline, 1);
        -:  584:}
        -:  585:
        -:  586:
    #####:  587:void yyerror(
        -:  588:    yyscan_t yyscanner,
        -:  589:    RE_LEX_ENVIRONMENT* lex_env,
        -:  590:    const char *error_message)
        -:  591:{
        -:  592:  // if lex_env->last_error was set to some error code before
        -:  593:  // don't overwrite it, we are interested in the first error, not in
        -:  594:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  595:  // early parser termination.
        -:  596:
    #####:  597:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  598:  {
    #####:  599:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  600:
    #####:  601:    strlcpy(
    #####:  602:        lex_env->last_error_message,
        -:  603:        error_message,
        -:  604:        sizeof(lex_env->last_error_message));
        -:  605:  }
    #####:  606:}
        -:  607:
        -:  608:
        2:  609:int yr_parse_re_string(
        -:  610:  const char* re_string,
        -:  611:  RE_AST** re_ast,
        -:  612:  RE_ERROR* error)
        -:  613:{
        -:  614:  yyscan_t yyscanner;
        -:  615:  jmp_buf recovery_trampoline;
        -:  616:  RE_LEX_ENVIRONMENT lex_env;
        -:  617:
        2:  618:  lex_env.last_error = ERROR_SUCCESS;
        2:  619:  lex_env.last_error_message[0] = '\0';
        -:  620:
        2:  621:  yr_thread_storage_set_value(
        -:  622:      &yr_yyfatal_trampoline_tls,
        -:  623:      &recovery_trampoline);
        -:  624:
        -:  625:  // setjmp returns a non-zero value only when we are returning to this
        -:  626:  // point via a call to longjmp to the recovery trampoline.
        2:  627:  if (setjmp(recovery_trampoline) != 0)
    #####:  628:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  629:
       2*:  630:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  631:
        2:  632:  yylex_init(&yyscanner);
        2:  633:  yyset_extra(*re_ast, yyscanner);
        2:  634:  yy_scan_string(re_string, yyscanner);
        2:  635:  yyparse(yyscanner, &lex_env);
        2:  636:  yylex_destroy(yyscanner);
        -:  637:
        2:  638:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  639:  {
    #####:  640:    yr_re_ast_destroy(*re_ast);
    #####:  641:    *re_ast = NULL;
        -:  642:
    #####:  643:    strlcpy(
    #####:  644:        error->message,
        -:  645:        lex_env.last_error_message,
        -:  646:        sizeof(error->message));
        -:  647:
    #####:  648:    return lex_env.last_error;
        -:  649:  }
        -:  650:
        2:  651:  return ERROR_SUCCESS;
        -:  652:}
