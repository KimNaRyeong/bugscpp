        -:    0:Source:notebook.c
        -:    0:Graph:/home/workspace/libyara/notebook.gcno
        -:    0:Data:/home/workspace/libyara/notebook.gcda
        -:    0:Runs:7
        -:    1:#include <stdint.h>
        -:    2:
        -:    3:/*
        -:    4:Copyright (c) 2020. The YARA Authors. All Rights Reserved.
        -:    5:
        -:    6:Redistribution and use in source and binary forms, with or without modification,
        -:    7:are permitted provided that the following conditions are met:
        -:    8:
        -:    9:1. Redistributions of source code must retain the above copyright notice, this
        -:   10:list of conditions and the following disclaimer.
        -:   11:
        -:   12:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   13:this list of conditions and the following disclaimer in the documentation and/or
        -:   14:other materials provided with the distribution.
        -:   15:
        -:   16:3. Neither the name of the copyright holder nor the names of its contributors
        -:   17:may be used to endorse or promote products derived from this software without
        -:   18:specific prior written permission.
        -:   19:
        -:   20:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   21:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   22:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   23:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   24:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   25:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   26:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   27:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   28:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   29:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   30:*/
        -:   31:
        -:   32:#include <assert.h>
        -:   33:
        -:   34:#include <yara/error.h>
        -:   35:#include <yara/mem.h>
        -:   36:#include <yara/notebook.h>
        -:   37:
        -:   38:
        -:   39:// Forward declaration of YR_NOTEBOOK_PAGE.
        -:   40:typedef struct YR_NOTEBOOK_PAGE YR_NOTEBOOK_PAGE;
        -:   41:
        -:   42:
        -:   43:// A notebook is a data structure that can be used for allocating memory
        -:   44:// space in the same way malloc() would do. However, the buffers returned
        -:   45:// by yr_notebook_alloc() are backed by a larger buffer reserved by the notebook
        -:   46:// beforehand called a "page". The notebook fulfills the allocations performed
        -:   47:// via yr_notebook_alloc() with space taken from the current page, or creates
        -:   48:// a new page when necessary. It's recommended that the page size is at least
        -:   49:// 4x the size of the buffers you plan to allocate with yr_notebook_alloc().
        -:   50:
        -:   51:// Once the notebook is destroyed all the pages are freed, and consequently
        -:   52:// all the buffers allocated via yr_notebook_alloc().
        -:   53:struct YR_NOTEBOOK
        -:   54:{
        -:   55:  // Size of each page in the notebook.
        -:   56:  size_t page_size;
        -:   57:  // Pointer to the first page in the book, this also the most recently
        -:   58:  // created page, the one that is being filled.
        -:   59:  YR_NOTEBOOK_PAGE* page_list_head;
        -:   60:};
        -:   61:
        -:   62:
        -:   63:// YR_NOTEBOOK_PAGE
        -:   64:struct YR_NOTEBOOK_PAGE
        -:   65:{
        -:   66:  // Amount of bytes in the page that are actually used.
        -:   67:  size_t used;
        -:   68:  // Pointer to next page.
        -:   69:  YR_NOTEBOOK_PAGE* next;
        -:   70:  // Page's data.
        -:   71:  uint8_t data[0];
        -:   72:};
        -:   73:
        -:   74:
        -:   75:
        -:   76:// Creates a new notebook. The notebook initially has a single page of the
        -:   77:// specified size, but more pages are created if needed.
    #####:   78:int yr_notebook_create(
        -:   79:    size_t page_size,
        -:   80:    YR_NOTEBOOK** pool)
        -:   81:{
    #####:   82:  YR_NOTEBOOK* new_notebook = yr_malloc(sizeof(YR_NOTEBOOK));
        -:   83:
    #####:   84:  if (new_notebook == NULL)
    #####:   85:    return ERROR_INSUFFICIENT_MEMORY;
        -:   86:
    #####:   87:  new_notebook->page_list_head = yr_malloc(
        -:   88:      sizeof(YR_NOTEBOOK_PAGE) + page_size);
        -:   89:
    #####:   90:  if (new_notebook->page_list_head == NULL)
        -:   91:  {
    #####:   92:    yr_free(new_notebook);
    #####:   93:    return ERROR_INSUFFICIENT_MEMORY;
        -:   94:  }
        -:   95:
    #####:   96:  new_notebook->page_size = page_size;
    #####:   97:  new_notebook->page_list_head->used = 0;
    #####:   98:  new_notebook->page_list_head->next = NULL;
        -:   99:
    #####:  100:  *pool = new_notebook;
        -:  101:
    #####:  102:  return ERROR_SUCCESS;
        -:  103:}
        -:  104:
        -:  105:
        -:  106:// Destroys a notebook and frees all the notebook's pages.
    #####:  107:int yr_notebook_destroy(
        -:  108:    YR_NOTEBOOK* pool)
        -:  109:{
    #####:  110:  YR_NOTEBOOK_PAGE* page = pool->page_list_head;
        -:  111:
    #####:  112:  while (page != NULL)
        -:  113:  {
    #####:  114:    YR_NOTEBOOK_PAGE* next = page->next;
    #####:  115:    yr_free(page);
    #####:  116:    page = next;
        -:  117:  }
        -:  118:
    #####:  119:  yr_free(pool);
        -:  120:
    #####:  121:  return ERROR_SUCCESS;
        -:  122:}
        -:  123:
        -:  124:
    #####:  125:void* yr_notebook_alloc(
        -:  126:    YR_NOTEBOOK* notebook,
        -:  127:    size_t size)
        -:  128:{
        -:  129:  // The requested memory size can't be larger than a notebook's page.
    #####:  130:  assert(size <= notebook->page_size);
        -:  131:
        -:  132:  // If the requested size doesn't fit in current page's free space, allocate
        -:  133:  // a new page.
    #####:  134:  if (notebook->page_size - notebook->page_list_head->used < size)
        -:  135:  {
    #####:  136:    YR_NOTEBOOK_PAGE* new_page = yr_malloc(
    #####:  137:        sizeof(YR_NOTEBOOK_PAGE) + notebook->page_size);
        -:  138:
    #####:  139:    if (new_page == NULL)
    #####:  140:      return NULL;
        -:  141:
    #####:  142:    new_page->used = 0;
    #####:  143:    new_page->next = notebook->page_list_head;
    #####:  144:    notebook->page_list_head = new_page;
        -:  145:  }
        -:  146:
    #####:  147:  void *ptr = notebook->page_list_head->data + notebook->page_list_head->used;
        -:  148:
        -:  149:  // In ARM make sure the alignment of the returned buffer is 4 bytes.
        -:  150:  #if defined(__arm__)
        -:  151:  uintptr_t misalignment = (uintptr_t) ptr & 3;
        -:  152:
        -:  153:  if (misalignment)
        -:  154:  {
        -:  155:    size += 4 - misalignment;
        -:  156:    ptr += 4 - misalignment;
        -:  157:  }
        -:  158:  #endif
        -:  159:
    #####:  160:  notebook->page_list_head->used += size;
        -:  161:
    #####:  162:  return ptr;
        -:  163:}
