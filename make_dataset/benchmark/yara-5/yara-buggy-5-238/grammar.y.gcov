        -:    0:Source:grammar.y
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:%{
        -:   31:
        -:   32:
        -:   33:#include <assert.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <limits.h>
        -:   37:#include <stdlib.h>
        -:   38:#include <stddef.h>
        -:   39:
        -:   40:#include <yara/arena.h>
        -:   41:#include <yara/integers.h>
        -:   42:#include <yara/utils.h>
        -:   43:#include <yara/strutils.h>
        -:   44:#include <yara/compiler.h>
        -:   45:#include <yara/object.h>
        -:   46:#include <yara/sizedstr.h>
        -:   47:#include <yara/exec.h>
        -:   48:#include <yara/error.h>
        -:   49:#include <yara/mem.h>
        -:   50:#include <yara/lexer.h>
        -:   51:#include <yara/parser.h>
        -:   52:
        -:   53:#if defined(_MSC_VER)
        -:   54:#define llabs _abs64
        -:   55:#endif
        -:   56:
        -:   57:#define YYERROR_VERBOSE
        -:   58:
        -:   59:#define YYMALLOC yr_malloc
        -:   60:#define YYFREE yr_free
        -:   61:
        -:   62:#define FOR_EXPRESSION_ALL 1
        -:   63:#define FOR_EXPRESSION_ANY 2
        -:   64:
        -:   65:#define fail_with_error(e) \
        -:   66:    { \
        -:   67:      compiler->last_error = e; \
        -:   68:      yyerror(yyscanner, compiler, NULL); \
        -:   69:      YYERROR; \
        -:   70:    }
        -:   71:
        -:   72:
        -:   73:#define fail_if_error(e) \
        -:   74:    if (e != ERROR_SUCCESS) \
        -:   75:    { \
        -:   76:      fail_with_error(e); \
        -:   77:    } \
        -:   78:
        -:   79:
        -:   80:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:   81:    if (((expression.type) & (expected_type)) == 0) \
        -:   82:    { \
        -:   83:      switch(expression.type) \
        -:   84:      { \
        -:   85:        case EXPRESSION_TYPE_INTEGER: \
        -:   86:          yr_compiler_set_error_extra_info( \
        -:   87:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:   88:          break; \
        -:   89:        case EXPRESSION_TYPE_FLOAT: \
        -:   90:          yr_compiler_set_error_extra_info( \
        -:   91:              compiler, "wrong type \"float\" for " op " operator"); \
        -:   92:          break; \
        -:   93:        case EXPRESSION_TYPE_STRING: \
        -:   94:          yr_compiler_set_error_extra_info( \
        -:   95:              compiler, "wrong type \"string\" for " op " operator"); \
        -:   96:          break; \
        -:   97:        case EXPRESSION_TYPE_BOOLEAN: \
        -:   98:          yr_compiler_set_error_extra_info( \
        -:   99:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  100:          break; \
        -:  101:      } \
        -:  102:      cleanup; \
        -:  103:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  104:      yyerror(yyscanner, compiler, NULL); \
        -:  105:      YYERROR; \
        -:  106:    }
        -:  107:
        -:  108:// check_type(expression, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT) is
        -:  109:// used to ensure that the type of "expression" is either integer or float.
        -:  110:#define check_type(expression, expected_type, op) \
        -:  111:    check_type_with_cleanup(expression, expected_type, op, )
        -:  112:
        -:  113:
        -:  114:#define loop_vars_cleanup(loop_index) \
        -:  115:    {  \
        -:  116:      YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[loop_index]; \
        -:  117:      for (int i = 0; i < loop_ctx->vars_count; i++) \
        -:  118:      { \
        -:  119:        yr_free((void*) loop_ctx->vars[i].identifier.ptr); \
        -:  120:        loop_ctx->vars[i].identifier.ptr = NULL; \
        -:  121:        loop_ctx->vars[i].identifier.ref = YR_ARENA_NULL_REF; \
        -:  122:      } \
        -:  123:      loop_ctx->vars_count = 0; \
        -:  124:    } \
        -:  125:
        -:  126:
        -:  127:// Given a YR_EXPRESSION returns its identifier. It returns identifier.ptr if
        -:  128:// not NULL and relies on identifier.ref if otherwise.
        -:  129:#define expression_identifier(expr) \
        -:  130:    ((expr).identifier.ptr != NULL ? \
        -:  131:     (expr).identifier.ptr : \
        -:  132:     (const char*) yr_arena_ref_to_ptr(compiler->arena, &(expr).identifier.ref))
        -:  133:
        -:  134:
        -:  135:#define DEFAULT_BASE64_ALPHABET \
        -:  136:    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        -:  137:
        -:  138:%}
        -:  139:
        -:  140:%expect 1   // expect 1 shift/reduce conflicts
        -:  141:
        -:  142:// Uncomment this line to print parsing information that can be useful to
        -:  143:// debug YARA's grammar.
        -:  144:
        -:  145:// %debug
        -:  146:
        -:  147:%name-prefix "yara_yy"
        -:  148:%pure-parser
        -:  149:%parse-param {void *yyscanner}
        -:  150:%parse-param {YR_COMPILER* compiler}
        -:  151:%lex-param {yyscan_t yyscanner}
        -:  152:%lex-param {YR_COMPILER* compiler}
        -:  153:
        -:  154:// Token that marks the end of the original file.
        -:  155:%token _END_OF_FILE_  0                                "end of file"
        -:  156:
        -:  157:// Token that marks the end of included files, we can't use  _END_OF_FILE_
        -:  158:// because bison stops parsing when it sees _END_OF_FILE_, we want to be
        -:  159:// be able to identify the point where an included file ends, but continuing
        -:  160:// parsing any content that follows.
        -:  161:%token _END_OF_INCLUDED_FILE_                          "end of included file"
        -:  162:
        -:  163:%token _DOT_DOT_                                       ".."
        -:  164:%token _RULE_                                          "<rule>"
        -:  165:%token _PRIVATE_                                       "<private>"
        -:  166:%token _GLOBAL_                                        "<global>"
        -:  167:%token _META_                                          "<meta>"
        -:  168:%token <string> _STRINGS_                              "<strings>"
        -:  169:%token _CONDITION_                                     "<condition>"
        -:  170:%token <c_string> _IDENTIFIER_                         "identifier"
        -:  171:%token <c_string> _STRING_IDENTIFIER_                  "string identifier"
        -:  172:%token <c_string> _STRING_COUNT_                       "string count"
        -:  173:%token <c_string> _STRING_OFFSET_                      "string offset"
        -:  174:%token <c_string> _STRING_LENGTH_                      "string length"
        -:  175:%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_
        -:  176:    "string identifier with wildcard"
        -:  177:%token <integer> _NUMBER_                              "integer number"
        -:  178:%token <double_> _DOUBLE_                              "floating point number"
        -:  179:%token <integer> _INTEGER_FUNCTION_                    "integer function"
        -:  180:%token <sized_string> _TEXT_STRING_                    "text string"
        -:  181:%token <sized_string> _HEX_STRING_                     "hex string"
        -:  182:%token <sized_string> _REGEXP_                         "regular expression"
        -:  183:%token _ASCII_                                         "<ascii>"
        -:  184:%token _WIDE_                                          "<wide>"
        -:  185:%token _XOR_                                           "<xor>"
        -:  186:%token _BASE64_                                        "<base64>"
        -:  187:%token _BASE64_WIDE_                                   "<base64wide>"
        -:  188:%token _NOCASE_                                        "<nocase>"
        -:  189:%token _FULLWORD_                                      "<fullword>"
        -:  190:%token _AT_                                            "<at>"
        -:  191:%token _FILESIZE_                                      "<filesize>"
        -:  192:%token _ENTRYPOINT_                                    "<entrypoint>"
        -:  193:%token _ALL_                                           "<all>"
        -:  194:%token _ANY_                                           "<any>"
        -:  195:%token _IN_                                            "<in>"
        -:  196:%token _OF_                                            "<of>"
        -:  197:%token _FOR_                                           "<for>"
        -:  198:%token _THEM_                                          "<them>"
        -:  199:%token _MATCHES_                                       "<matches>"
        -:  200:%token _CONTAINS_                                      "<contains>"
        -:  201:%token _IMPORT_                                        "<import>"
        -:  202:%token _TRUE_                                          "<true>"
        -:  203:%token _FALSE_                                         "<false"
        -:  204:%token _OR_                                            "<or>"
        -:  205:%token _AND_                                           "<and>"
        -:  206:%token _NOT_                                           "<not>"
        -:  207:%token _EQ_                                            "=="
        -:  208:%token _NEQ_                                           "!="
        -:  209:%token _LT_                                            "<"
        -:  210:%token _LE_                                            "<="
        -:  211:%token _GT_                                            ">"
        -:  212:%token _GE_                                            ">="
        -:  213:%token _SHIFT_LEFT_                                    "<<"
        -:  214:%token _SHIFT_RIGHT_                                   ">>"
        -:  215:
        -:  216:// Operator precedence and associativity. Higher precedence operators are lower
        -:  217:// in the list. Operators that appear in the same line have the same precedence.
        -:  218:%left _OR_
        -:  219:%left _AND_
        -:  220:%left _EQ_ _NEQ_ _CONTAINS_ _MATCHES_
        -:  221:%left _LT_ _LE_ _GT_ _GE_
        -:  222:%left '|'
        -:  223:%left '^'
        -:  224:%left '&'
        -:  225:%left _SHIFT_LEFT_ _SHIFT_RIGHT_
        -:  226:%left '+' '-'
        -:  227:%left '*' '\\' '%'
        -:  228:%right _NOT_ '~' UNARY_MINUS
        -:  229:
        -:  230:%type <rule>   rule
        -:  231:
        -:  232:%type <string> strings
        -:  233:%type <string> string_declaration
        -:  234:%type <string> string_declarations
        -:  235:
        -:  236:%type <meta> meta
        -:  237:%type <meta> meta_declaration
        -:  238:%type <meta> meta_declarations
        -:  239:
        -:  240:%type <tag> tags
        -:  241:%type <tag> tag_list
        -:  242:
        -:  243:%type <modifier> string_modifier
        -:  244:%type <modifier> string_modifiers
        -:  245:
        -:  246:%type <modifier> regexp_modifier
        -:  247:%type <modifier> regexp_modifiers
        -:  248:
        -:  249:%type <modifier> hex_modifier
        -:  250:%type <modifier> hex_modifiers
        -:  251:
        -:  252:%type <integer> integer_set
        -:  253:%type <integer> integer_enumeration
        -:  254:%type <integer> for_expression
        -:  255:%type <integer> rule_modifier
        -:  256:%type <integer> rule_modifiers
        -:  257:
        -:  258:%type <expression> primary_expression
        -:  259:%type <expression> boolean_expression
        -:  260:%type <expression> expression
        -:  261:%type <expression> identifier
        -:  262:%type <expression> regexp
        -:  263:
        -:  264:%type <c_string> arguments
        -:  265:%type <c_string> arguments_list
        -:  266:
        7:  267:%destructor { yr_free($$); $$ = NULL; } _IDENTIFIER_
    #####:  268:%destructor { yr_free($$); $$ = NULL; } _STRING_COUNT_
    #####:  269:%destructor { yr_free($$); $$ = NULL; } _STRING_OFFSET_
    #####:  270:%destructor { yr_free($$); $$ = NULL; } _STRING_LENGTH_
        5:  271:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_
    #####:  272:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_WITH_WILDCARD_
    #####:  273:%destructor { yr_free($$); $$ = NULL; } _TEXT_STRING_
    #####:  274:%destructor { yr_free($$); $$ = NULL; } _HEX_STRING_
    #####:  275:%destructor { yr_free($$); $$ = NULL; } _REGEXP_
        -:  276:
    #####:  277:%destructor { yr_free($$); $$ = NULL; } arguments
    #####:  278:%destructor { yr_free($$); $$ = NULL; } arguments_list
        -:  279:
        -:  280:%destructor {
    #####:  281:  if ($$.alphabet != NULL)
        -:  282:  {
    #####:  283:    yr_free($$.alphabet);
    #####:  284:    $$.alphabet = NULL;
        -:  285:  }
        -:  286:} string_modifier
        -:  287:
        -:  288:%destructor {
    #####:  289:  if ($$.alphabet != NULL)
        -:  290:  {
    #####:  291:    yr_free($$.alphabet);
    #####:  292:    $$.alphabet = NULL;
        -:  293:  }
        -:  294:} string_modifiers
        -:  295:
        -:  296:
        -:  297:%union {
        -:  298:  YR_EXPRESSION   expression;
        -:  299:  SIZED_STRING*   sized_string;
        -:  300:  char*           c_string;
        -:  301:  int64_t         integer;
        -:  302:  double          double_;
        -:  303:  YR_MODIFIER     modifier;
        -:  304:
        -:  305:  YR_ARENA_REF tag;
        -:  306:  YR_ARENA_REF rule;
        -:  307:  YR_ARENA_REF meta;
        -:  308:  YR_ARENA_REF string;
        -:  309:}
        -:  310:
        -:  311:
        -:  312:%%
        -:  313:
        -:  314:rules
        -:  315:    : /* empty */
        -:  316:    | rules rule
        -:  317:    | rules import
        -:  318:    | rules error rule      /* on error skip until next rule..*/
        -:  319:    | rules error import    /* .. or import statement */
        -:  320:    | rules error "include" /* .. or include statement */
        -:  321:    | rules _END_OF_INCLUDED_FILE_
        -:  322:      {
    #####:  323:        _yr_compiler_pop_file_name(compiler);
        -:  324:      }
        -:  325:    ;
        -:  326:
        -:  327:
        -:  328:import
        -:  329:    : _IMPORT_ _TEXT_STRING_
        -:  330:      {
    #####:  331:        int result = yr_parser_reduce_import(yyscanner, $2);
        -:  332:
    #####:  333:        yr_free($2);
        -:  334:
    #####:  335:        fail_if_error(result);
        -:  336:      }
        -:  337:    ;
        -:  338:
        -:  339:
        -:  340:rule
        -:  341:    : rule_modifiers _RULE_ _IDENTIFIER_
        -:  342:      {
       8*:  343:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -:  344:            yyscanner, (int32_t) $1, $3, &$<rule>$));
        -:  345:      }
        -:  346:      tags '{' meta strings
        -:  347:      {
        5:  348:        YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(
        5:  349:            compiler->arena, &$<rule>4);
        -:  350:
       10:  351:        rule->tags = (char*) yr_arena_ref_to_ptr(
        5:  352:            compiler->arena, &$5);
        -:  353:
       10:  354:        rule->metas = (YR_META*) yr_arena_ref_to_ptr(
        5:  355:            compiler->arena, &$7);
        -:  356:
        5:  357:        rule->strings = (YR_STRING*) yr_arena_ref_to_ptr(
        -:  358:            compiler->arena, &$8);
        -:  359:      }
        -:  360:      condition '}'
        -:  361:      {
    #####:  362:        int result = yr_parser_reduce_rule_declaration_phase_2(
    #####:  363:            yyscanner, &$<rule>4); // rule created in phase 1
        -:  364:
    #####:  365:        yr_free($3);
        -:  366:
    #####:  367:        fail_if_error(result);
        -:  368:      }
        -:  369:    ;
        -:  370:
        -:  371:
        -:  372:meta
        -:  373:    : /* empty */
        -:  374:      {
        6:  375:        $$ = YR_ARENA_NULL_REF;
        -:  376:      }
        -:  377:    | _META_ ':' meta_declarations
        -:  378:      {
    #####:  379:        YR_META* meta = yr_arena_get_ptr(
        -:  380:            compiler->arena,
        -:  381:            YR_METAS_TABLE,
    #####:  382:            (compiler->current_meta_idx - 1) * sizeof(YR_META));
        -:  383:
    #####:  384:        meta->flags |= META_FLAGS_LAST_IN_RULE;
        -:  385:
    #####:  386:        $$ = $3;
        -:  387:      }
        -:  388:    ;
        -:  389:
        -:  390:
        -:  391:strings
        -:  392:    : /* empty */
        -:  393:      {
    #####:  394:        $$ = YR_ARENA_NULL_REF;
        -:  395:      }
        -:  396:    | _STRINGS_ ':' string_declarations
        -:  397:      {
        5:  398:        YR_STRING* string = (YR_STRING*) yr_arena_get_ptr(
        -:  399:            compiler->arena,
        -:  400:            YR_STRINGS_TABLE,
        5:  401:            (compiler->current_string_idx - 1) * sizeof(YR_STRING));
        -:  402:
        5:  403:        string->flags |= STRING_FLAGS_LAST_IN_RULE;
        -:  404:
        5:  405:        $$ = $3;
        -:  406:      }
        -:  407:    ;
        -:  408:
        -:  409:
        -:  410:condition
        -:  411:    : _CONDITION_ ':' boolean_expression
        -:  412:    ;
        -:  413:
        -:  414:
        -:  415:rule_modifiers
       45:  416:    : /* empty */                      { $$ = 0;  }
    #####:  417:    | rule_modifiers rule_modifier     { $$ = $1 | $2; }
        -:  418:    ;
        -:  419:
        -:  420:
        -:  421:rule_modifier
    #####:  422:    : _PRIVATE_      { $$ = RULE_FLAGS_PRIVATE; }
    #####:  423:    | _GLOBAL_       { $$ = RULE_FLAGS_GLOBAL; }
        -:  424:    ;
        -:  425:
        -:  426:
        -:  427:tags
        -:  428:    : /* empty */
        -:  429:      {
        7:  430:        $$ = YR_ARENA_NULL_REF;
        -:  431:      }
        -:  432:    | ':' tag_list
        -:  433:      {
        -:  434:        // Tags list is represented in the arena as a sequence
        -:  435:        // of null-terminated strings, the sequence ends with an
        -:  436:        // additional null character. Here we write the ending null
        -:  437:        //character. Example: tag1\0tag2\0tag3\0\0
        -:  438:
    #####:  439:        fail_if_error(yr_arena_write_string(
        -:  440:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, "", NULL));
        -:  441:
    #####:  442:        $$ = $2;
        -:  443:      }
        -:  444:    ;
        -:  445:
        -:  446:
        -:  447:tag_list
        -:  448:    : _IDENTIFIER_
        -:  449:      {
    #####:  450:        int result = yr_arena_write_string(
    #####:  451:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, $1, &$<tag>$);
        -:  452:
    #####:  453:        yr_free($1);
        -:  454:
    #####:  455:        fail_if_error(result);
        -:  456:      }
        -:  457:    | tag_list _IDENTIFIER_
        -:  458:      {
        -:  459:        YR_ARENA_REF ref;
        -:  460:
        -:  461:        // Write the new tag identifier.
    #####:  462:        int result = yr_arena_write_string(
    #####:  463:            yyget_extra(yyscanner)->arena, YR_SZ_POOL, $2, &ref);
        -:  464:
    #####:  465:        yr_free($2);
        -:  466:
    #####:  467:        fail_if_error(result);
        -:  468:
        -:  469:        // Get the address for the tag identifier just written.
    #####:  470:        char* new_tag = (char*) yr_arena_ref_to_ptr(
        -:  471:            compiler->arena, &ref);
        -:  472:
        -:  473:        // Take the address of first tag's identifier in the list.
    #####:  474:        char* tag = (char*) yr_arena_ref_to_ptr(
        -:  475:            compiler->arena, &$<tag>$);
        -:  476:
        -:  477:	// Search for duplicated tags. Tags are written one after
        -:  478:	// the other, with zeroes in between (i.e: tag1/0tag2/0tag3)
        -:  479:	// that's why can use tag < new_tag as the condition for the
        -:  480:	// loop.
    #####:  481:        while (tag < new_tag)
        -:  482:        {
    #####:  483:          if (strcmp(tag, new_tag) == 0)
        -:  484:          {
    #####:  485:            yr_compiler_set_error_extra_info(compiler, tag);
    #####:  486:            fail_with_error(ERROR_DUPLICATED_TAG_IDENTIFIER);
        -:  487:          }
        -:  488:
    #####:  489:          tag += strlen(tag) + 1;
        -:  490:        }
        -:  491:
    #####:  492:        $$ = $1;
        -:  493:      }
        -:  494:    ;
        -:  495:
        -:  496:
        -:  497:
        -:  498:meta_declarations
    #####:  499:    : meta_declaration                    {  $$ = $1; }
    #####:  500:    | meta_declarations meta_declaration  {  $$ = $1; }
        -:  501:    ;
        -:  502:
        -:  503:
        -:  504:meta_declaration
        -:  505:    : _IDENTIFIER_ '=' _TEXT_STRING_
        -:  506:      {
    #####:  507:        SIZED_STRING* sized_string = $3;
        -:  508:
    #####:  509:        int result = yr_parser_reduce_meta_declaration(
        -:  510:            yyscanner,
        -:  511:            META_TYPE_STRING,
    #####:  512:            $1,
    #####:  513:            sized_string->c_string,
        -:  514:            0,
        -:  515:            &$<meta>$);
        -:  516:
    #####:  517:        yr_free($1);
    #####:  518:        yr_free($3);
        -:  519:
    #####:  520:        fail_if_error(result);
        -:  521:      }
        -:  522:    | _IDENTIFIER_ '=' _NUMBER_
        -:  523:      {
    #####:  524:        int result = yr_parser_reduce_meta_declaration(
        -:  525:            yyscanner,
        -:  526:            META_TYPE_INTEGER,
    #####:  527:            $1,
        -:  528:            NULL,
        -:  529:            $3,
        -:  530:            &$<meta>$);
        -:  531:
    #####:  532:        yr_free($1);
        -:  533:
    #####:  534:        fail_if_error(result);
        -:  535:      }
        -:  536:    | _IDENTIFIER_ '=' '-' _NUMBER_
        -:  537:      {
    #####:  538:        int result = yr_parser_reduce_meta_declaration(
        -:  539:            yyscanner,
        -:  540:            META_TYPE_INTEGER,
    #####:  541:            $1,
        -:  542:            NULL,
    #####:  543:            -$4,
        -:  544:            &$<meta>$);
        -:  545:
    #####:  546:        yr_free($1);
        -:  547:
    #####:  548:        fail_if_error(result);
        -:  549:      }
        -:  550:    | _IDENTIFIER_ '=' _TRUE_
        -:  551:      {
    #####:  552:        int result = yr_parser_reduce_meta_declaration(
        -:  553:            yyscanner,
        -:  554:            META_TYPE_BOOLEAN,
    #####:  555:            $1,
        -:  556:            NULL,
        -:  557:            true,
        -:  558:            &$<meta>$);
        -:  559:
    #####:  560:        yr_free($1);
        -:  561:
    #####:  562:        fail_if_error(result);
        -:  563:      }
        -:  564:    | _IDENTIFIER_ '=' _FALSE_
        -:  565:      {
    #####:  566:        int result = yr_parser_reduce_meta_declaration(
        -:  567:            yyscanner,
        -:  568:            META_TYPE_BOOLEAN,
    #####:  569:            $1,
        -:  570:            NULL,
        -:  571:            false,
        -:  572:            &$<meta>$);
        -:  573:
    #####:  574:        yr_free($1);
        -:  575:
    #####:  576:        fail_if_error(result);
        -:  577:      }
        -:  578:    ;
        -:  579:
        -:  580:
        -:  581:string_declarations
        6:  582:    : string_declaration                      { $$ = $1; }
    #####:  583:    | string_declarations string_declaration  { $$ = $1; }
        -:  584:    ;
        -:  585:
        -:  586:
        -:  587:string_declaration
        -:  588:    : _STRING_IDENTIFIER_ '='
        -:  589:      {
        2:  590:        compiler->current_line = yyget_lineno(yyscanner);
        -:  591:      }
        -:  592:      _TEXT_STRING_ string_modifiers
        -:  593:      {
        2:  594:        int result = yr_parser_reduce_string_declaration(
        2:  595:            yyscanner, $5, $1, $4, &$<string>$);
        -:  596:
        2:  597:        yr_free($1);
        2:  598:        yr_free($4);
        2:  599:        yr_free($5.alphabet);
        -:  600:
        2:  601:        fail_if_error(result);
        1:  602:        compiler->current_line = 0;
        -:  603:      }
        -:  604:    | _STRING_IDENTIFIER_ '='
        -:  605:      {
        2:  606:        compiler->current_line = yyget_lineno(yyscanner);
        -:  607:      }
        -:  608:      _REGEXP_ regexp_modifiers
        -:  609:      {
        -:  610:        int result;
        -:  611:
        2:  612:        $5.flags |= STRING_FLAGS_REGEXP;
        -:  613:
        2:  614:        result = yr_parser_reduce_string_declaration(
        2:  615:            yyscanner, $5, $1, $4, &$<string>$);
        -:  616:
        2:  617:        yr_free($1);
        2:  618:        yr_free($4);
        -:  619:
       2*:  620:        fail_if_error(result);
        -:  621:
        2:  622:        compiler->current_line = 0;
        -:  623:      }
        -:  624:    | _STRING_IDENTIFIER_ '='
        -:  625:      {
        3:  626:        compiler->current_line = yyget_lineno(yyscanner);
        -:  627:      }
        -:  628:      _HEX_STRING_ hex_modifiers
        -:  629:      {
        -:  630:        int result;
        -:  631:
        3:  632:        $5.flags |= STRING_FLAGS_HEXADECIMAL;
        -:  633:
        3:  634:        result = yr_parser_reduce_string_declaration(
        3:  635:            yyscanner, $5, $1, $4, &$<string>$);
        -:  636:
        3:  637:        yr_free($1);
        3:  638:        yr_free($4);
        -:  639:
       3*:  640:        fail_if_error(result);
        -:  641:
        3:  642:        compiler->current_line = 0;
        -:  643:      }
        -:  644:    ;
        -:  645:
        -:  646:
        -:  647:string_modifiers
        -:  648:    : /* empty */
        -:  649:      {
        2:  650:        $$.flags = 0;
        2:  651:        $$.xor_min = 0;
        2:  652:        $$.xor_max = 0;
        2:  653:        $$.alphabet = NULL;
        -:  654:      }
        -:  655:    | string_modifiers string_modifier
        -:  656:      {
    #####:  657:        $$ = $1;
        -:  658:
        -:  659:        // Only set the xor minimum and maximum if we are dealing with the
        -:  660:        // xor modifier. If we don't check for this then we can end up with
        -:  661:        // "xor wide" resulting in whatever is on the stack for "wide"
        -:  662:        // overwriting the values for xor.
    #####:  663:        if ($2.flags & STRING_FLAGS_XOR)
        -:  664:        {
    #####:  665:          $$.xor_min = $2.xor_min;
    #####:  666:          $$.xor_max = $2.xor_max;
        -:  667:        }
        -:  668:
        -:  669:        // Only set the base64 alphabet if we are dealing with the base64
        -:  670:        // modifier. If we don't check for this then we can end up with
        -:  671:        // "base64 ascii" resulting in whatever is on the stack for "ascii"
        -:  672:        // overwriting the values for base64.
    #####:  673:        if (($2.flags & STRING_FLAGS_BASE64) ||
    #####:  674:            ($2.flags & STRING_FLAGS_BASE64_WIDE))
        -:  675:        {
    #####:  676:          if ($$.alphabet != NULL)
        -:  677:          {
    #####:  678:            if (sized_string_cmp($$.alphabet, $2.alphabet) != 0)
        -:  679:            {
    #####:  680:              yr_compiler_set_error_extra_info(
        -:  681:                  compiler, "can not specify multiple alphabets");
        -:  682:
    #####:  683:              yr_free($2.alphabet);
    #####:  684:              yr_free($$.alphabet);
        -:  685:
    #####:  686:              fail_with_error(ERROR_INVALID_MODIFIER);
        -:  687:            }
        -:  688:            else
        -:  689:            {
    #####:  690:              yr_free($2.alphabet);
        -:  691:            }
        -:  692:          }
        -:  693:          else
        -:  694:          {
    #####:  695:            $$.alphabet = $2.alphabet;
        -:  696:          }
        -:  697:        }
        -:  698:
    #####:  699:        if ($$.flags & $2.flags)
        -:  700:        {
    #####:  701:          if ($$.alphabet != NULL)
    #####:  702:            yr_free($$.alphabet);
        -:  703:
    #####:  704:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -:  705:        }
        -:  706:        else
        -:  707:        {
    #####:  708:          $$.flags = $$.flags | $2.flags;
        -:  709:        }
        -:  710:      }
        -:  711:    ;
        -:  712:
        -:  713:
        -:  714:string_modifier
    #####:  715:    : _WIDE_        { $$.flags = STRING_FLAGS_WIDE; }
    #####:  716:    | _ASCII_       { $$.flags = STRING_FLAGS_ASCII; }
    #####:  717:    | _NOCASE_      { $$.flags = STRING_FLAGS_NO_CASE; }
    #####:  718:    | _FULLWORD_    { $$.flags = STRING_FLAGS_FULL_WORD; }
    #####:  719:    | _PRIVATE_     { $$.flags = STRING_FLAGS_PRIVATE; }
        -:  720:    | _XOR_
        -:  721:      {
    #####:  722:        $$.flags = STRING_FLAGS_XOR;
    #####:  723:        $$.xor_min = 0;
    #####:  724:        $$.xor_max = 255;
        -:  725:      }
        -:  726:    | _XOR_ '(' _NUMBER_ ')'
        -:  727:      {
    #####:  728:        int result = ERROR_SUCCESS;
        -:  729:
    #####:  730:        if ($3 < 0 || $3 > 255)
        -:  731:        {
    #####:  732:          yr_compiler_set_error_extra_info(compiler, "invalid xor range");
    #####:  733:          result = ERROR_INVALID_MODIFIER;
        -:  734:        }
        -:  735:
    #####:  736:        fail_if_error(result);
        -:  737:
    #####:  738:        $$.flags = STRING_FLAGS_XOR;
    #####:  739:        $$.xor_min = $3;
    #####:  740:        $$.xor_max = $3;
        -:  741:      }
        -:  742:    /*
        -:  743:     * Would love to use range here for consistency in the language but that
        -:  744:     * uses a primary expression which pushes a value on the VM stack we don't
        -:  745:     * account for.
        -:  746:     */
        -:  747:    | _XOR_ '(' _NUMBER_ '-' _NUMBER_ ')'
        -:  748:      {
    #####:  749:        int result = ERROR_SUCCESS;
        -:  750:
    #####:  751:        if ($3 < 0)
        -:  752:        {
    #####:  753:          yr_compiler_set_error_extra_info(
        -:  754:              compiler, "lower bound for xor range exceeded (min: 0)");
    #####:  755:          result = ERROR_INVALID_MODIFIER;
        -:  756:        }
        -:  757:
    #####:  758:        if ($5 > 255)
        -:  759:        {
    #####:  760:          yr_compiler_set_error_extra_info(
        -:  761:              compiler, "upper bound for xor range exceeded (max: 255)");
    #####:  762:          result = ERROR_INVALID_MODIFIER;
        -:  763:        }
        -:  764:
    #####:  765:        if ($3 > $5)
        -:  766:        {
    #####:  767:          yr_compiler_set_error_extra_info(
        -:  768:              compiler, "xor lower bound exceeds upper bound");
    #####:  769:          result = ERROR_INVALID_MODIFIER;
        -:  770:        }
        -:  771:
    #####:  772:        fail_if_error(result);
        -:  773:
    #####:  774:        $$.flags = STRING_FLAGS_XOR;
    #####:  775:        $$.xor_min = $3;
    #####:  776:        $$.xor_max = $5;
        -:  777:      }
        -:  778:    | _BASE64_
        -:  779:      {
    #####:  780:        $$.flags = STRING_FLAGS_BASE64;
    #####:  781:        $$.alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);
        -:  782:      }
        -:  783:    | _BASE64_ '(' _TEXT_STRING_ ')'
        -:  784:      {
    #####:  785:        int result = ERROR_SUCCESS;
        -:  786:
    #####:  787:        if ($3->length != 64)
        -:  788:        {
    #####:  789:          yr_free($3);
    #####:  790:          result = yr_compiler_set_error_extra_info(
        -:  791:              compiler, "length of base64 alphabet must be 64");
    #####:  792:          result = ERROR_INVALID_MODIFIER;
        -:  793:        }
        -:  794:
    #####:  795:        fail_if_error(result);
        -:  796:
    #####:  797:        $$.flags = STRING_FLAGS_BASE64;
    #####:  798:        $$.alphabet = $3;
        -:  799:      }
        -:  800:    | _BASE64_WIDE_
        -:  801:      {
    #####:  802:        $$.flags = STRING_FLAGS_BASE64_WIDE;
    #####:  803:        $$.alphabet = sized_string_new(DEFAULT_BASE64_ALPHABET);
        -:  804:      }
        -:  805:    | _BASE64_WIDE_ '(' _TEXT_STRING_ ')'
        -:  806:      {
    #####:  807:        int result = ERROR_SUCCESS;
        -:  808:
    #####:  809:        if ($3->length != 64)
        -:  810:        {
    #####:  811:          yr_free($3);
    #####:  812:          result = yr_compiler_set_error_extra_info(
        -:  813:              compiler, "length of base64 alphabet must be 64");
    #####:  814:          result = ERROR_INVALID_MODIFIER;
        -:  815:        }
        -:  816:
    #####:  817:        fail_if_error(result);
        -:  818:
    #####:  819:        $$.flags = STRING_FLAGS_BASE64_WIDE;
    #####:  820:        $$.alphabet = $3;
        -:  821:      }
        -:  822:    ;
        -:  823:
        -:  824:regexp_modifiers
        2:  825:    : /* empty */                         { $$.flags = 0; }
        -:  826:    | regexp_modifiers regexp_modifier
        -:  827:      {
    #####:  828:        if ($1.flags & $2.flags)
        -:  829:        {
    #####:  830:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -:  831:        }
        -:  832:        else
        -:  833:        {
    #####:  834:          $$.flags = $1.flags | $2.flags;
        -:  835:        }
        -:  836:      }
        -:  837:    ;
        -:  838:
        -:  839:regexp_modifier
    #####:  840:    : _WIDE_        { $$.flags = STRING_FLAGS_WIDE; }
    #####:  841:    | _ASCII_       { $$.flags = STRING_FLAGS_ASCII; }
    #####:  842:    | _NOCASE_      { $$.flags = STRING_FLAGS_NO_CASE; }
    #####:  843:    | _FULLWORD_    { $$.flags = STRING_FLAGS_FULL_WORD; }
    #####:  844:    | _PRIVATE_     { $$.flags = STRING_FLAGS_PRIVATE; }
        -:  845:    ;
        -:  846:
        -:  847:hex_modifiers
        3:  848:    : /* empty */                         { $$.flags = 0; }
        -:  849:    | hex_modifiers hex_modifier
        -:  850:      {
    #####:  851:        if ($1.flags & $2.flags)
        -:  852:        {
    #####:  853:          fail_with_error(ERROR_DUPLICATED_MODIFIER);
        -:  854:        }
        -:  855:        else
        -:  856:        {
    #####:  857:          $$.flags = $1.flags | $2.flags;
        -:  858:        }
        -:  859:      }
        -:  860:    ;
        -:  861:
        -:  862:hex_modifier
    #####:  863:    : _PRIVATE_     { $$.flags = STRING_FLAGS_PRIVATE; }
        -:  864:    ;
        -:  865:
        -:  866:identifier
        -:  867:    : _IDENTIFIER_
        -:  868:      {
        -:  869:        YR_EXPRESSION expr;
        -:  870:
    #####:  871:        int result = ERROR_SUCCESS;
    #####:  872:        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1, &expr);
        -:  873:
    #####:  874:        if (var_index >= 0)
        -:  875:        {
        -:  876:          // The identifier corresponds to a loop variable.
    #####:  877:          result = yr_parser_emit_with_arg(
        -:  878:              yyscanner,
        -:  879:              OP_PUSH_M,
        -:  880:              var_index,
        -:  881:              NULL,
        -:  882:              NULL);
        -:  883:
        -:  884:          // The expression associated to this identifier is the same one
        -:  885:          // associated to the loop variable.
    #####:  886:          $$ = expr;
        -:  887:        }
        -:  888:        else
        -:  889:        {
        -:  890:          // Search for identifier within the global namespace, where the
        -:  891:          // externals variables reside.
        -:  892:
    #####:  893:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  894:              compiler->objects_table, $1, NULL);
        -:  895:
    #####:  896:          YR_NAMESPACE* ns = (YR_NAMESPACE*) yr_arena_get_ptr(
        -:  897:              compiler->arena,
        -:  898:              YR_NAMESPACES_TABLE,
    #####:  899:              compiler->current_namespace_idx * sizeof(struct YR_NAMESPACE));
        -:  900:
    #####:  901:          if (object == NULL)
        -:  902:          {
        -:  903:            // If not found, search within the current namespace.
    #####:  904:            object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  905:                compiler->objects_table, $1, ns->name);
        -:  906:          }
        -:  907:
    #####:  908:          if (object != NULL)
        -:  909:          {
        -:  910:            YR_ARENA_REF ref;
        -:  911:
    #####:  912:            result = yr_arena_write_string(
    #####:  913:                compiler->arena, YR_SZ_POOL, $1, &ref);
        -:  914:
    #####:  915:            if (result == ERROR_SUCCESS)
    #####:  916:              result = yr_parser_emit_with_arg_reloc(
        -:  917:                  yyscanner,
        -:  918:                  OP_OBJ_LOAD,
        -:  919:                  yr_arena_ref_to_ptr(compiler->arena, &ref),
        -:  920:                  NULL,
        -:  921:                  NULL);
        -:  922:
    #####:  923:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  924:            $$.value.object = object;
    #####:  925:            $$.identifier.ptr = NULL;
    #####:  926:            $$.identifier.ref = ref;
        -:  927:          }
        -:  928:          else
        -:  929:          {
    #####:  930:            uint32_t rule_idx = yr_hash_table_lookup_uint32(
    #####:  931:                compiler->rules_table, $1, ns->name);
        -:  932:
    #####:  933:            if (rule_idx != UINT32_MAX)
        -:  934:            {
    #####:  935:              result = yr_parser_emit_with_arg(
        -:  936:                  yyscanner,
        -:  937:                  OP_PUSH_RULE,
        -:  938:                  rule_idx,
        -:  939:                  NULL,
        -:  940:                  NULL);
        -:  941:
    #####:  942:              YR_RULE* rule = _yr_compiler_get_rule_by_idx(compiler, rule_idx);
        -:  943:
    #####:  944:              yr_arena_ptr_to_ref(compiler->arena, rule->identifier, &$$.identifier.ref);
        -:  945:
    #####:  946:              $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####:  947:              $$.value.integer = YR_UNDEFINED;
    #####:  948:              $$.identifier.ptr = NULL;
        -:  949:            }
        -:  950:            else
        -:  951:            {
    #####:  952:              yr_compiler_set_error_extra_info(compiler, $1);
    #####:  953:              result = ERROR_UNDEFINED_IDENTIFIER;
        -:  954:            }
        -:  955:          }
        -:  956:        }
        -:  957:
    #####:  958:        yr_free($1);
        -:  959:
    #####:  960:        fail_if_error(result);
        -:  961:      }
        -:  962:    | identifier '.' _IDENTIFIER_
        -:  963:      {
    #####:  964:        int result = ERROR_SUCCESS;
    #####:  965:        YR_OBJECT* field = NULL;
        -:  966:
    #####:  967:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  968:            $1.value.object->type == OBJECT_TYPE_STRUCTURE)
        -:  969:        {
    #####:  970:          field = yr_object_lookup_field($1.value.object, $3);
        -:  971:
    #####:  972:          if (field != NULL)
        -:  973:          {
        -:  974:            YR_ARENA_REF ref;
        -:  975:
    #####:  976:            result = yr_arena_write_string(
    #####:  977:                compiler->arena, YR_SZ_POOL, $3, &ref);
        -:  978:
    #####:  979:            if (result == ERROR_SUCCESS)
    #####:  980:              result = yr_parser_emit_with_arg_reloc(
        -:  981:                  yyscanner,
        -:  982:                  OP_OBJ_FIELD,
        -:  983:                  yr_arena_ref_to_ptr(compiler->arena, &ref),
        -:  984:                  NULL,
        -:  985:                  NULL);
        -:  986:
    #####:  987:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  988:            $$.value.object = field;
    #####:  989:            $$.identifier.ref = ref;
    #####:  990:            $$.identifier.ptr = NULL;
        -:  991:          }
        -:  992:          else
        -:  993:          {
    #####:  994:            yr_compiler_set_error_extra_info(compiler, $3);
    #####:  995:            result = ERROR_INVALID_FIELD_NAME;
        -:  996:          }
        -:  997:        }
        -:  998:        else
        -:  999:        {
    #####: 1000:          yr_compiler_set_error_extra_info(
        -: 1001:             compiler, expression_identifier($1));
        -: 1002:
    #####: 1003:          result = ERROR_NOT_A_STRUCTURE;
        -: 1004:        }
        -: 1005:
    #####: 1006:        yr_free($3);
        -: 1007:
    #####: 1008:        fail_if_error(result);
        -: 1009:      }
        -: 1010:    | identifier '[' primary_expression ']'
        -: 1011:      {
    #####: 1012:        int result = ERROR_SUCCESS;
        -: 1013:        YR_OBJECT_ARRAY* array;
        -: 1014:        YR_OBJECT_DICTIONARY* dict;
        -: 1015:
    #####: 1016:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####: 1017:            $1.value.object->type == OBJECT_TYPE_ARRAY)
    #####: 1018:        {
    #####: 1019:          if ($3.type != EXPRESSION_TYPE_INTEGER)
        -: 1020:          {
    #####: 1021:            yr_compiler_set_error_extra_info(
        -: 1022:                compiler, "array indexes must be of integer type");
    #####: 1023:            result = ERROR_WRONG_TYPE;
        -: 1024:          }
        -: 1025:
    #####: 1026:          fail_if_error(result);
        -: 1027:
    #####: 1028:          result = yr_parser_emit(
        -: 1029:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 1030:
    #####: 1031:          array = object_as_array($1.value.object);
        -: 1032:
    #####: 1033:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####: 1034:          $$.value.object = array->prototype_item;
    #####: 1035:          $$.identifier.ptr = array->identifier;
    #####: 1036:          $$.identifier.ref = YR_ARENA_NULL_REF;
        -: 1037:        }
    #####: 1038:        else if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####: 1039:                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)
    #####: 1040:        {
    #####: 1041:          if ($3.type != EXPRESSION_TYPE_STRING)
        -: 1042:          {
    #####: 1043:            yr_compiler_set_error_extra_info(
        -: 1044:                compiler, "dictionary keys must be of string type");
    #####: 1045:            result = ERROR_WRONG_TYPE;
        -: 1046:          }
        -: 1047:
    #####: 1048:          fail_if_error(result);
        -: 1049:
    #####: 1050:          result = yr_parser_emit(
        -: 1051:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 1052:
    #####: 1053:          dict = object_as_dictionary($1.value.object);
        -: 1054:
    #####: 1055:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####: 1056:          $$.value.object = dict->prototype_item;
    #####: 1057:          $$.identifier.ptr = dict->identifier;
    #####: 1058:          $$.identifier.ref = YR_ARENA_NULL_REF;
        -: 1059:        }
        -: 1060:        else
        -: 1061:        {
    #####: 1062:          yr_compiler_set_error_extra_info(
        -: 1063:              compiler, expression_identifier($1));
        -: 1064:
    #####: 1065:          result = ERROR_NOT_INDEXABLE;
        -: 1066:        }
        -: 1067:
    #####: 1068:        fail_if_error(result);
        -: 1069:      }
        -: 1070:
        -: 1071:    | identifier '(' arguments ')'
        -: 1072:      {
        -: 1073:        YR_ARENA_REF ref;
    #####: 1074:        int result = ERROR_SUCCESS;
        -: 1075:        YR_OBJECT_FUNCTION* function;
        -: 1076:
    #####: 1077:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####: 1078:            $1.value.object->type == OBJECT_TYPE_FUNCTION)
        -: 1079:        {
    #####: 1080:          result = yr_parser_check_types(
    #####: 1081:              compiler, object_as_function($1.value.object), $3);
        -: 1082:
    #####: 1083:          if (result == ERROR_SUCCESS)
    #####: 1084:            result = yr_arena_write_string(
    #####: 1085:                compiler->arena, YR_SZ_POOL, $3, &ref);
        -: 1086:
    #####: 1087:          if (result == ERROR_SUCCESS)
    #####: 1088:            result = yr_parser_emit_with_arg_reloc(
        -: 1089:                yyscanner,
        -: 1090:                OP_CALL,
        -: 1091:                yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 1092:                NULL,
        -: 1093:                NULL);
        -: 1094:
    #####: 1095:          function = object_as_function($1.value.object);
        -: 1096:
    #####: 1097:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####: 1098:          $$.value.object = function->return_obj;
    #####: 1099:          $$.identifier.ref = ref;
    #####: 1100:          $$.identifier.ptr = NULL;
        -: 1101:        }
        -: 1102:        else
        -: 1103:        {
    #####: 1104:          yr_compiler_set_error_extra_info(
        -: 1105:              compiler, expression_identifier($1));
        -: 1106:
    #####: 1107:          result = ERROR_NOT_A_FUNCTION;
        -: 1108:        }
        -: 1109:
    #####: 1110:        yr_free($3);
        -: 1111:
    #####: 1112:        fail_if_error(result);
        -: 1113:      }
        -: 1114:    ;
        -: 1115:
        -: 1116:
        -: 1117:arguments
    #####: 1118:    : /* empty */     { $$ = yr_strdup(""); }
    #####: 1119:    | arguments_list  { $$ = $1; }
        -: 1120:
        -: 1121:
        -: 1122:arguments_list
        -: 1123:    : expression
        -: 1124:      {
    #####: 1125:        $$ = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 1126:
    #####: 1127:        if ($$ == NULL)
    #####: 1128:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1129:
    #####: 1130:        switch($1.type)
        -: 1131:        {
    #####: 1132:          case EXPRESSION_TYPE_INTEGER:
    #####: 1133:            strlcpy($$, "i", YR_MAX_FUNCTION_ARGS);
    #####: 1134:            break;
    #####: 1135:          case EXPRESSION_TYPE_FLOAT:
    #####: 1136:            strlcpy($$, "f", YR_MAX_FUNCTION_ARGS);
    #####: 1137:            break;
    #####: 1138:          case EXPRESSION_TYPE_BOOLEAN:
    #####: 1139:            strlcpy($$, "b", YR_MAX_FUNCTION_ARGS);
    #####: 1140:            break;
    #####: 1141:          case EXPRESSION_TYPE_STRING:
    #####: 1142:            strlcpy($$, "s", YR_MAX_FUNCTION_ARGS);
    #####: 1143:            break;
    #####: 1144:          case EXPRESSION_TYPE_REGEXP:
    #####: 1145:            strlcpy($$, "r", YR_MAX_FUNCTION_ARGS);
    #####: 1146:            break;
    #####: 1147:          case EXPRESSION_TYPE_UNKNOWN:
    #####: 1148:            yr_free($$);
    #####: 1149:            yr_compiler_set_error_extra_info(
        -: 1150:                compiler, "unknown type for argument 1 in function call");
    #####: 1151:            fail_with_error(ERROR_WRONG_TYPE);
        -: 1152:            break;
    #####: 1153:          default:
        -: 1154:            // An unknown expression type is OK iff an error ocurred.
    #####: 1155:            assert(compiler->last_error != ERROR_SUCCESS);
        -: 1156:        }
        -: 1157:      }
        -: 1158:    | arguments_list ',' expression
        -: 1159:      {
    #####: 1160:        int result = ERROR_SUCCESS;
        -: 1161:
    #####: 1162:        if (strlen($1) == YR_MAX_FUNCTION_ARGS)
        -: 1163:        {
    #####: 1164:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 1165:        }
        -: 1166:        else
        -: 1167:        {
    #####: 1168:          switch($3.type)
        -: 1169:          {
    #####: 1170:            case EXPRESSION_TYPE_INTEGER:
    #####: 1171:              strlcat($1, "i", YR_MAX_FUNCTION_ARGS);
    #####: 1172:              break;
    #####: 1173:            case EXPRESSION_TYPE_FLOAT:
    #####: 1174:              strlcat($1, "f", YR_MAX_FUNCTION_ARGS);
    #####: 1175:              break;
    #####: 1176:            case EXPRESSION_TYPE_BOOLEAN:
    #####: 1177:              strlcat($1, "b", YR_MAX_FUNCTION_ARGS);
    #####: 1178:              break;
    #####: 1179:            case EXPRESSION_TYPE_STRING:
    #####: 1180:              strlcat($1, "s", YR_MAX_FUNCTION_ARGS);
    #####: 1181:              break;
    #####: 1182:            case EXPRESSION_TYPE_REGEXP:
    #####: 1183:              strlcat($1, "r", YR_MAX_FUNCTION_ARGS);
    #####: 1184:              break;
    #####: 1185:            case EXPRESSION_TYPE_UNKNOWN:
    #####: 1186:              result = ERROR_WRONG_TYPE;
    #####: 1187:              yr_compiler_set_error_extra_info_fmt(
        -: 1188:                  compiler, "unknown type for argument %zu in function call",
        -: 1189:                  // As we add one character per argument, the length of $1 is
        -: 1190:                  // the number of arguments parsed so far, and the argument
        -: 1191:                  // represented by <expression> is length of $1 plus one.
        -: 1192:                  strlen($1) + 1);
    #####: 1193:              break;
    #####: 1194:            default:
        -: 1195:              // An unknown expression type is OK iff an error ocurred.
    #####: 1196:              assert(compiler->last_error != ERROR_SUCCESS);
        -: 1197:          }
        -: 1198:        }
        -: 1199:
    #####: 1200:        if (result != ERROR_SUCCESS)
    #####: 1201:          yr_free($1);
        -: 1202:
    #####: 1203:        fail_if_error(result);
        -: 1204:
    #####: 1205:        $$ = $1;
        -: 1206:      }
        -: 1207:    ;
        -: 1208:
        -: 1209:
        -: 1210:regexp
        -: 1211:    : _REGEXP_
        -: 1212:      {
    #####: 1213:        SIZED_STRING* sized_string = $1;
        -: 1214:        YR_ARENA_REF re_ref;
        -: 1215:        RE_ERROR error;
        -: 1216:
    #####: 1217:        int result = ERROR_SUCCESS;
    #####: 1218:        int re_flags = 0;
        -: 1219:
    #####: 1220:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####: 1221:          re_flags |= RE_FLAGS_NO_CASE;
        -: 1222:
    #####: 1223:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####: 1224:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 1225:
    #####: 1226:        result = yr_re_compile(
    #####: 1227:            sized_string->c_string,
        -: 1228:            re_flags,
        -: 1229:            compiler->arena,
        -: 1230:            &re_ref,
        -: 1231:            &error);
        -: 1232:
    #####: 1233:        yr_free($1);
        -: 1234:
    #####: 1235:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
    #####: 1236:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 1237:
    #####: 1238:        if (result == ERROR_SUCCESS)
    #####: 1239:          result = yr_parser_emit_with_arg_reloc(
        -: 1240:              yyscanner,
        -: 1241:              OP_PUSH,
        -: 1242:              yr_arena_ref_to_ptr(compiler->arena, &re_ref),
        -: 1243:              NULL,
        -: 1244:              NULL);
        -: 1245:
    #####: 1246:        fail_if_error(result);
        -: 1247:
    #####: 1248:        $$.type = EXPRESSION_TYPE_REGEXP;
        -: 1249:      }
        -: 1250:    ;
        -: 1251:
        -: 1252:
        -: 1253:boolean_expression
        -: 1254:    : expression
        -: 1255:      {
    #####: 1256:        if ($1.type == EXPRESSION_TYPE_STRING)
        -: 1257:        {
    #####: 1258:          if (!YR_ARENA_IS_NULL_REF($1.value.sized_string_ref))
        -: 1259:          {
    #####: 1260:            SIZED_STRING* sized_string = yr_arena_ref_to_ptr(
        -: 1261:                compiler->arena, &$1.value.sized_string_ref);
        -: 1262:
    #####: 1263:            yywarning(yyscanner,
        -: 1264:                "Using literal string \"%s\" in a boolean operation.",
    #####: 1265:                sized_string->c_string);
        -: 1266:          }
        -: 1267:
    #####: 1268:          fail_if_error(yr_parser_emit(
        -: 1269:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 1270:        }
        -: 1271:
    #####: 1272:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1273:      }
        -: 1274:    ;
        -: 1275:
        -: 1276:expression
        -: 1277:    : _TRUE_
        -: 1278:      {
    #####: 1279:        fail_if_error(yr_parser_emit_with_arg(
        -: 1280:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 1281:
    #####: 1282:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1283:      }
        -: 1284:    | _FALSE_
        -: 1285:      {
    #####: 1286:        fail_if_error(yr_parser_emit_with_arg(
        -: 1287:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 1288:
    #####: 1289:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1290:      }
        -: 1291:    | primary_expression _MATCHES_ regexp
        -: 1292:      {
    #####: 1293:        check_type($1, EXPRESSION_TYPE_STRING, "matches");
    #####: 1294:        check_type($3, EXPRESSION_TYPE_REGEXP, "matches");
        -: 1295:
    #####: 1296:        fail_if_error(yr_parser_emit(
        -: 1297:            yyscanner,
        -: 1298:            OP_MATCHES,
        -: 1299:            NULL));
        -: 1300:
    #####: 1301:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1302:      }
        -: 1303:    | primary_expression _CONTAINS_ primary_expression
        -: 1304:      {
    #####: 1305:        check_type($1, EXPRESSION_TYPE_STRING, "contains");
    #####: 1306:        check_type($3, EXPRESSION_TYPE_STRING, "contains");
        -: 1307:
    #####: 1308:        fail_if_error(yr_parser_emit(
        -: 1309:            yyscanner, OP_CONTAINS, NULL));
        -: 1310:
    #####: 1311:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1312:      }
        -: 1313:    | _STRING_IDENTIFIER_
        -: 1314:      {
    #####: 1315:        int result = yr_parser_reduce_string_identifier(
        -: 1316:            yyscanner,
    #####: 1317:            $1,
        -: 1318:            OP_FOUND,
        -: 1319:            YR_UNDEFINED);
        -: 1320:
    #####: 1321:        yr_free($1);
        -: 1322:
    #####: 1323:        fail_if_error(result);
        -: 1324:
    #####: 1325:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1326:      }
        -: 1327:    | _STRING_IDENTIFIER_ _AT_ primary_expression
        -: 1328:      {
        -: 1329:        int result;
        -: 1330:
    #####: 1331:        check_type_with_cleanup($3, EXPRESSION_TYPE_INTEGER, "at", yr_free($1));
        -: 1332:
    #####: 1333:        result = yr_parser_reduce_string_identifier(
    #####: 1334:            yyscanner, $1, OP_FOUND_AT, $3.value.integer);
        -: 1335:
    #####: 1336:        yr_free($1);
        -: 1337:
    #####: 1338:        fail_if_error(result);
        -: 1339:
    #####: 1340:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1341:      }
        -: 1342:    | _STRING_IDENTIFIER_ _IN_ range
        -: 1343:      {
    #####: 1344:        int result = yr_parser_reduce_string_identifier(
    #####: 1345:            yyscanner, $1, OP_FOUND_IN, YR_UNDEFINED);
        -: 1346:
    #####: 1347:        yr_free($1);
        -: 1348:
    #####: 1349:        fail_if_error(result);
        -: 1350:
    #####: 1351:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1352:      }
        -: 1353:    | _FOR_ for_expression error
        -: 1354:      {
        -: 1355:        int i;
        -: 1356:
        -: 1357:        // Free all the loop variable identifiers, including the variables for
        -: 1358:        // the current loop (represented by loop_index), and set loop_index to
        -: 1359:        // -1. This is OK even if we have nested loops. If an error occurs while
        -: 1360:        // parsing the inner loop, it will be propagated to the outer loop
        -: 1361:        // anyways, so it's safe to do this cleanup while processing the error
        -: 1362:        // for the inner loop.
        -: 1363:
    #####: 1364:        for (i = 0; i <= compiler->loop_index; i++)
        -: 1365:        {
    #####: 1366:          loop_vars_cleanup(i);
        -: 1367:        }
        -: 1368:
    #####: 1369:        compiler->loop_index = -1;
    #####: 1370:        YYERROR;
        -: 1371:      }
        -: 1372:    | _FOR_ for_expression
        -: 1373:      //
        -: 1374:      //  for <min_expression> <identifier> in <iterator> : (<expression>)
        -: 1375:      //
        -: 1376:      //  CLEAR_M 0       ; clear number of true results returned by <expression>
        -: 1377:      //  CLEAR_M 1       ; clear loop iteration counter
        -: 1378:      //  POP_M 2         ; takes the result of <min_expression> from the stack
        -: 1379:      //                  ; and puts it in M[2], once M[0] reaches M[2] the whole
        -: 1380:      //                  ; for expression is satisfied
        -: 1381:      //  <iterator>      ; the instructions generated by the <iterator> depend
        -: 1382:      //                  ; on the type of iterator, but they will initialize the
        -: 1383:      //                  ; iterator and get it ready for the ITER_NEXT instruction
        -: 1384:      // repeat:
        -: 1385:      //  ITER_NEXT       ; reads the iterator object from the stack but leaves it there,
        -: 1386:      //                  ; puts next item in the sequence in the stack, and also a TRUE
        -: 1387:      //                  ; or a FALSE value indicating whether or not there are more items
        -: 1388:      //
        -: 1389:      //  POP_M 3         ; pops the next item from the stack and puts it in M[3], it
        -: 1390:      //
        -: 1391:      //  JTRUE_P epilog  ; pops the boolean that tells if we already reached
        -: 1392:      //                  ; the end of the iterator
        -: 1393:      //  <expression>    ; here goes the code for <expression> the value of the
        -: 1394:      //                  ; expressions ends up being at the top of the stack
        -: 1395:      //
        -: 1396:      //  ADD_M 0         ; if <expression> was true M[0] is incremented by one,
        -: 1397:      //                  ; this consumes the <expression>'s result from the stack
        -: 1398:      //  INCR_M 1        ; increments iteration counter
        -: 1399:      //
        -: 1400:      //  PUSH_M 2
        -: 1401:      //  JUNDEF_P repeat ; if M[2] is undefined it's because <min_expression> is "all",
        -: 1402:      //                  ; in that case we need to repeat until there are no more items
        -: 1403:      //
        -: 1404:      //  PUSH_M 0        ; pushes number of true results for <expression>
        -: 1405:      //  PUSH_M 2        ; pushes value of <min_expression>
        -: 1406:      //
        -: 1407:      //  JL_P repeat     ; if M[1] is less M[3] repeat
        -: 1408:      //
        -: 1409:      // epilog:
        -: 1410:      //  POP             ; remove the iterator object from the stack
        -: 1411:      //
        -: 1412:      //  PUSH_M 1        ; push iteration counter
        -: 1413:      //  JZ end          ; if iteration counter is 0 the loop evaluates to false
        -: 1414:      //                  ; in all cases, we jump to "end" leaving a 0 in the stack
        -: 1415:      //                  ; that will used as the resulting false value.
        -: 1416:      //  POP             ; the iteration counter wasn't 0, remove it from the
        -: 1417:      //                  ; stack
        -: 1418:      //
        -: 1419:      //  PUSH_M 0        ; pushes number of true results for <expression>
        -: 1420:      //  PUSH_M 2        ; pushes value of <min_expression>
        -: 1421:      //
        -: 1422:      //  SWAPUNDEF 1     ; if the value at the top of the stack (M[2]) is UNDEF
        -: 1423:      //                  ; swap the UNDEF with loop iteration counter at M[1]
        -: 1424:      //
        -: 1425:      //  INT_GE          ; compares the the number of true results returned by
        -: 1426:      //                  ; <expression> with the value of <min_expression> or
        -: 1427:      //                  ; with the number of iterations, if <min_expression>
        -: 1428:      //                  ; was "all". A 1 is pushed into the stack if the former
        -: 1429:      //                  ; is greater than or equal to the latter
        -: 1430:      // end:
        -: 1431:      //
        -: 1432:      {
        -: 1433:        // var_frame is used for accessing local variables used in this loop.
        -: 1434:        // All local variables are accessed using var_frame as a reference,
        -: 1435:        // like var_frame + 0, var_frame + 1, etc. Here we initialize var_frame
        -: 1436:        // with the correct value, which depends on the number of variables
        -: 1437:        // defined by any outer loops.
        -: 1438:
        -: 1439:        int var_frame;
    #####: 1440:        int result = ERROR_SUCCESS;
        -: 1441:
    #####: 1442:        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)
    #####: 1443:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1444:
    #####: 1445:        fail_if_error(result);
        -: 1446:
    #####: 1447:        compiler->loop_index++;
        -: 1448:
        -: 1449:        // This loop uses internal variables besides the ones explicitly
        -: 1450:        // defined by the user.
    #####: 1451:        compiler->loop[compiler->loop_index].vars_internal_count = \
        -: 1452:       		YR_INTERNAL_LOOP_VARS;
        -: 1453:
        -: 1454:        // Initialize the number of variables, this number will be incremented
        -: 1455:        // as variable declaration are processed by for_variables.
    #####: 1456:        compiler->loop[compiler->loop_index].vars_count = 0;
        -: 1457:
    #####: 1458:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 1459:
    #####: 1460:        fail_if_error(yr_parser_emit_with_arg(
        -: 1461:            yyscanner, OP_CLEAR_M, var_frame + 0, NULL, NULL));
        -: 1462:
    #####: 1463:        fail_if_error(yr_parser_emit_with_arg(
        -: 1464:            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL));
        -: 1465:
    #####: 1466:        fail_if_error(yr_parser_emit_with_arg(
        -: 1467:            yyscanner, OP_POP_M, var_frame + 2, NULL, NULL));
        -: 1468:      }
        -: 1469:      for_variables _IN_ iterator ':'
        -: 1470:      {
    #####: 1471:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 1472:        YR_FIXUP* fixup;
        -: 1473:
        -: 1474:        YR_ARENA_REF loop_start_ref;
        -: 1475:        YR_ARENA_REF jmp_offset_ref;
        -: 1476:
    #####: 1477:        int var_frame = _yr_compiler_get_var_frame(compiler);
        -: 1478:        int i;
        -: 1479:
    #####: 1480:        fail_if_error(yr_parser_emit(
        -: 1481:            yyscanner, OP_ITER_NEXT, &loop_start_ref));
        -: 1482:
        -: 1483:        // For each variable generate an instruction that pops the value from
        -: 1484:        // the stack and store it into one memory slot starting at var_frame +
        -: 1485:        // YR_INTERNAL_LOOP_VARS because the first YR_INTERNAL_LOOP_VARS slots
        -: 1486:        // in the frame are for the internal variables.
        -: 1487:
    #####: 1488:        for (i = 0; i < loop_ctx->vars_count; i++)
        -: 1489:        {
    #####: 1490:          fail_if_error(yr_parser_emit_with_arg(
        -: 1491:              yyscanner,
        -: 1492:              OP_POP_M,
        -: 1493:              var_frame + YR_INTERNAL_LOOP_VARS + i,
        -: 1494:              NULL,
        -: 1495:              NULL));
        -: 1496:        }
        -: 1497:
    #####: 1498:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1499:            yyscanner,
        -: 1500:            OP_JTRUE_P,
        -: 1501:            0,              // still don't know the jump offset, use 0 for now.
        -: 1502:            NULL,
        -: 1503:            &jmp_offset_ref));
        -: 1504:
        -: 1505:        // We still don't know the jump's target, so we push a fixup entry
        -: 1506:        // in the stack, so that the jump's offset can be set once we know it.
        -: 1507:
    #####: 1508:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1509:
    #####: 1510:        if (fixup == NULL)
    #####: 1511:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1512:
    #####: 1513:        fixup->ref = jmp_offset_ref;
    #####: 1514:        fixup->next = compiler->fixup_stack_head;
    #####: 1515:        compiler->fixup_stack_head = fixup;
        -: 1516:
    #####: 1517:        loop_ctx->start_ref = loop_start_ref;
        -: 1518:      }
        -: 1519:      '(' boolean_expression ')'
        -: 1520:      {
        -: 1521:        int32_t jmp_offset;
        -: 1522:        YR_FIXUP* fixup;
        -: 1523:        YR_ARENA_REF pop_ref;
        -: 1524:        YR_ARENA_REF jmp_offset_ref;
        -: 1525:
    #####: 1526:        int var_frame = _yr_compiler_get_var_frame(compiler);
        -: 1527:
    #####: 1528:        fail_if_error(yr_parser_emit_with_arg(
        -: 1529:            yyscanner, OP_ADD_M, var_frame + 0, NULL, NULL));
        -: 1530:
    #####: 1531:        fail_if_error(yr_parser_emit_with_arg(
        -: 1532:            yyscanner, OP_INCR_M, var_frame + 1, NULL, NULL));
        -: 1533:
    #####: 1534:        fail_if_error(yr_parser_emit_with_arg(
        -: 1535:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 1536:
    #####: 1537:        jmp_offset = \
    #####: 1538:            compiler->loop[compiler->loop_index].start_ref.offset -
    #####: 1539:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 1540:
    #####: 1541:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1542:            yyscanner,
        -: 1543:            OP_JUNDEF_P,
        -: 1544:            jmp_offset,
        -: 1545:            NULL,
        -: 1546:            NULL));
        -: 1547:
    #####: 1548:        fail_if_error(yr_parser_emit_with_arg(
        -: 1549:            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));
        -: 1550:
    #####: 1551:        fail_if_error(yr_parser_emit_with_arg(
        -: 1552:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 1553:
    #####: 1554:        jmp_offset = \
    #####: 1555:            compiler->loop[compiler->loop_index].start_ref.offset -
    #####: 1556:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 1557:
    #####: 1558:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1559:            yyscanner,
        -: 1560:            OP_JL_P,
        -: 1561:            jmp_offset,
        -: 1562:            NULL,
        -: 1563:            NULL));
        -: 1564:
    #####: 1565:        fail_if_error(yr_parser_emit(
        -: 1566:            yyscanner, OP_POP, &pop_ref));
        -: 1567:
    #####: 1568:        fail_if_error(yr_parser_emit_with_arg(
        -: 1569:            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL));
        -: 1570:
    #####: 1571:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1572:            yyscanner,
        -: 1573:            OP_JZ,
        -: 1574:            0,      // still don't know the jump offset, use 0 for now.
        -: 1575:            NULL,
        -: 1576:            &jmp_offset_ref));
        -: 1577:
    #####: 1578:        fail_if_error(yr_parser_emit(
        -: 1579:            yyscanner, OP_POP, NULL));
        -: 1580:
        -: 1581:        // Pop from the stack the fixup entry containing the reference to
        -: 1582:        // the jump offset that needs to be fixed.
        -: 1583:
    #####: 1584:        fixup = compiler->fixup_stack_head;
    #####: 1585:        compiler->fixup_stack_head = fixup->next;
        -: 1586:
        -: 1587:        // The fixup entry has a reference to the jump offset that need
        -: 1588:        // to be fixed, convert the address into a pointer.
    #####: 1589:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 1590:            compiler->arena, &fixup->ref);
        -: 1591:
        -: 1592:        // The reference in the fixup entry points to the jump's offset
        -: 1593:        // but the jump instruction is one byte before, that's why we add
        -: 1594:        // one to the offset.
    #####: 1595:        jmp_offset = pop_ref.offset - fixup->ref.offset + 1;
        -: 1596:
        -: 1597:        // Fix the jump's offset.
    #####: 1598:        *jmp_offset_addr = jmp_offset;
        -: 1599:
    #####: 1600:        yr_free(fixup);
        -: 1601:
    #####: 1602:        fail_if_error(yr_parser_emit_with_arg(
        -: 1603:            yyscanner, OP_PUSH_M, var_frame + 0, NULL, NULL));
        -: 1604:
    #####: 1605:        fail_if_error(yr_parser_emit_with_arg(
        -: 1606:            yyscanner, OP_PUSH_M, var_frame + 2, NULL, NULL));
        -: 1607:
    #####: 1608:        fail_if_error(yr_parser_emit_with_arg(
        -: 1609:            yyscanner, OP_SWAPUNDEF, var_frame + 1, NULL, NULL));
        -: 1610:
    #####: 1611:        fail_if_error(yr_parser_emit(
        -: 1612:            yyscanner, OP_INT_GE, NULL));
        -: 1613:
    #####: 1614:        jmp_offset = \
    #####: 1615:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
    #####: 1616:            jmp_offset_ref.offset + 1;
        -: 1617:
    #####: 1618:        jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 1619:            compiler->arena, &jmp_offset_ref);
        -: 1620:
    #####: 1621:        *jmp_offset_addr = jmp_offset;
        -: 1622:
    #####: 1623:        loop_vars_cleanup(compiler->loop_index);
        -: 1624:
    #####: 1625:        compiler->loop_index--;
        -: 1626:
    #####: 1627:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1628:      }
        -: 1629:    | _FOR_ for_expression _OF_ string_set ':'
        -: 1630:      {
        -: 1631:        YR_ARENA_REF ref;
        -: 1632:
    #####: 1633:        int result = ERROR_SUCCESS;
        -: 1634:        int var_frame;
        -: 1635:
    #####: 1636:        if (compiler->loop_index + 1 == YR_MAX_LOOP_NESTING)
    #####: 1637:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1638:
    #####: 1639:        if (compiler->loop_for_of_var_index != -1)
    #####: 1640:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 1641:
    #####: 1642:        fail_if_error(result);
        -: 1643:
    #####: 1644:        compiler->loop_index++;
        -: 1645:
    #####: 1646:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 1647:
    #####: 1648:        yr_parser_emit_with_arg(
    #####: 1649:            yyscanner, OP_CLEAR_M, var_frame + 1, NULL, NULL);
        -: 1650:
    #####: 1651:        yr_parser_emit_with_arg(
    #####: 1652:            yyscanner, OP_CLEAR_M, var_frame + 2, NULL, NULL);
        -: 1653:
        -: 1654:        // Pop the first string.
    #####: 1655:        yr_parser_emit_with_arg(
        -: 1656:            yyscanner, OP_POP_M, var_frame, &ref, NULL);
        -: 1657:
    #####: 1658:        compiler->loop_for_of_var_index = var_frame;
    #####: 1659:        compiler->loop[compiler->loop_index].start_ref = ref;
    #####: 1660:        compiler->loop[compiler->loop_index].vars_count = 0;
    #####: 1661:        compiler->loop[compiler->loop_index].vars_internal_count = \
        -: 1662:            YR_INTERNAL_LOOP_VARS;
        -: 1663:      }
        -: 1664:      '(' boolean_expression ')'
        -: 1665:      {
    #####: 1666:        int var_frame = 0;
        -: 1667:
    #####: 1668:        compiler->loop_for_of_var_index = -1;
        -: 1669:
    #####: 1670:        var_frame = _yr_compiler_get_var_frame(compiler);
        -: 1671:
        -: 1672:        // Increment counter by the value returned by the
        -: 1673:        // boolean expression (0 or 1). If the boolean expression
        -: 1674:        // returned YR_UNDEFINED the OP_ADD_M won't do anything.
        -: 1675:
    #####: 1676:        yr_parser_emit_with_arg(
    #####: 1677:            yyscanner, OP_ADD_M, var_frame + 1, NULL, NULL);
        -: 1678:
        -: 1679:        // Increment iterations counter.
    #####: 1680:        yr_parser_emit_with_arg(
    #####: 1681:            yyscanner, OP_INCR_M, var_frame + 2, NULL, NULL);
        -: 1682:
    #####: 1683:        int32_t jmp_offset = \
    #####: 1684:            compiler->loop[compiler->loop_index].start_ref.offset -
    #####: 1685:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION);
        -: 1686:
        -: 1687:        // If next string is not undefined, go back to the
        -: 1688:        // beginning of the loop.
    #####: 1689:        yr_parser_emit_with_arg_int32(
        -: 1690:            yyscanner,
        -: 1691:            OP_JNUNDEF,
        -: 1692:            jmp_offset,
        -: 1693:            NULL,
        -: 1694:            NULL);
        -: 1695:
        -: 1696:        // Pop end-of-list marker.
    #####: 1697:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1698:
        -: 1699:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1700:        // is at top of the stack. Check if the quantifier is
        -: 1701:        // undefined (meaning "all") and replace it with the
        -: 1702:        // iterations counter in that case.
    #####: 1703:        yr_parser_emit_with_arg(
    #####: 1704:            yyscanner, OP_SWAPUNDEF, var_frame + 2, NULL, NULL);
        -: 1705:
        -: 1706:        // Compare the loop quantifier with the number of
        -: 1707:        // expressions evaluating to true.
    #####: 1708:        yr_parser_emit_with_arg(
    #####: 1709:            yyscanner, OP_PUSH_M, var_frame + 1, NULL, NULL);
        -: 1710:
    #####: 1711:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1712:
    #####: 1713:        loop_vars_cleanup(compiler->loop_index);
        -: 1714:
    #####: 1715:        compiler->loop_index--;
        -: 1716:
    #####: 1717:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1718:      }
        -: 1719:    | for_expression _OF_ string_set
        -: 1720:      {
    #####: 1721:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 1722:
    #####: 1723:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1724:      }
        -: 1725:    | _NOT_ boolean_expression
        -: 1726:      {
    #####: 1727:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 1728:
    #####: 1729:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1730:      }
        -: 1731:    | boolean_expression _AND_
        -: 1732:      {
        -: 1733:        YR_FIXUP* fixup;
        -: 1734:        YR_ARENA_REF jmp_offset_ref;
        -: 1735:
    #####: 1736:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1737:            yyscanner,
        -: 1738:            OP_JFALSE,
        -: 1739:            0,          // still don't know the jump offset, use 0 for now.
        -: 1740:            NULL,
        -: 1741:            &jmp_offset_ref));
        -: 1742:
        -: 1743:        // Create a fixup entry for the jump and push it in the stack.
    #####: 1744:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1745:
    #####: 1746:        if (fixup == NULL)
    #####: 1747:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1748:
    #####: 1749:        fixup->ref = jmp_offset_ref;
    #####: 1750:        fixup->next = compiler->fixup_stack_head;
    #####: 1751:        compiler->fixup_stack_head = fixup;
        -: 1752:      }
        -: 1753:      boolean_expression
        -: 1754:      {
        -: 1755:        YR_FIXUP* fixup;
        -: 1756:
    #####: 1757:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 1758:
    #####: 1759:        fixup = compiler->fixup_stack_head;
        -: 1760:
    #####: 1761:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 1762:            compiler->arena, &fixup->ref);
        -: 1763:
    #####: 1764:        int32_t jmp_offset = \
    #####: 1765:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
    #####: 1766:            fixup->ref.offset + 1;
        -: 1767:
    #####: 1768:        *jmp_offset_addr = jmp_offset;
        -: 1769:
        -: 1770:        // Remove fixup from the stack.
    #####: 1771:        compiler->fixup_stack_head = fixup->next;
    #####: 1772:        yr_free(fixup);
        -: 1773:
    #####: 1774:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1775:      }
        -: 1776:    | boolean_expression _OR_
        -: 1777:      {
        -: 1778:        YR_FIXUP* fixup;
        -: 1779:        YR_ARENA_REF jmp_offset_ref;
        -: 1780:
    #####: 1781:        fail_if_error(yr_parser_emit_with_arg_int32(
        -: 1782:            yyscanner,
        -: 1783:            OP_JTRUE,
        -: 1784:            0,         // still don't know the jump destination, use 0 for now.
        -: 1785:            NULL,
        -: 1786:            &jmp_offset_ref));
        -: 1787:
    #####: 1788:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1789:
    #####: 1790:        if (fixup == NULL)
    #####: 1791:          fail_with_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1792:
    #####: 1793:        fixup->ref = jmp_offset_ref;
    #####: 1794:        fixup->next = compiler->fixup_stack_head;
    #####: 1795:        compiler->fixup_stack_head = fixup;
        -: 1796:      }
        -: 1797:      boolean_expression
        -: 1798:      {
        -: 1799:        YR_FIXUP* fixup;
        -: 1800:
    #####: 1801:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 1802:
    #####: 1803:        fixup = compiler->fixup_stack_head;
        -: 1804:
    #####: 1805:        int32_t jmp_offset = \
    #####: 1806:            yr_arena_get_current_offset(compiler->arena, YR_CODE_SECTION) -
    #####: 1807:            fixup->ref.offset + 1;
        -: 1808:
    #####: 1809:        int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(
        -: 1810:            compiler->arena, &fixup->ref);
        -: 1811:
    #####: 1812:        *jmp_offset_addr = jmp_offset;
        -: 1813:
        -: 1814:        // Remove fixup from the stack.
    #####: 1815:        compiler->fixup_stack_head = fixup->next;
    #####: 1816:        yr_free(fixup);
        -: 1817:
    #####: 1818:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1819:      }
        -: 1820:    | primary_expression _LT_ primary_expression
        -: 1821:      {
    #####: 1822:        fail_if_error(yr_parser_reduce_operation(
        -: 1823:            yyscanner, "<", $1, $3));
        -: 1824:
    #####: 1825:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1826:      }
        -: 1827:    | primary_expression _GT_ primary_expression
        -: 1828:      {
    #####: 1829:        fail_if_error(yr_parser_reduce_operation(
        -: 1830:            yyscanner, ">", $1, $3));
        -: 1831:
    #####: 1832:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1833:      }
        -: 1834:    | primary_expression _LE_ primary_expression
        -: 1835:      {
    #####: 1836:        fail_if_error(yr_parser_reduce_operation(
        -: 1837:            yyscanner, "<=", $1, $3));
        -: 1838:
    #####: 1839:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1840:      }
        -: 1841:    | primary_expression _GE_ primary_expression
        -: 1842:      {
    #####: 1843:        fail_if_error(yr_parser_reduce_operation(
        -: 1844:            yyscanner, ">=", $1, $3));
        -: 1845:
    #####: 1846:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1847:      }
        -: 1848:    | primary_expression _EQ_ primary_expression
        -: 1849:      {
    #####: 1850:        fail_if_error(yr_parser_reduce_operation(
        -: 1851:            yyscanner, "==", $1, $3));
        -: 1852:
    #####: 1853:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1854:      }
        -: 1855:    | primary_expression _NEQ_ primary_expression
        -: 1856:      {
    #####: 1857:        fail_if_error(yr_parser_reduce_operation(
        -: 1858:            yyscanner, "!=", $1, $3));
        -: 1859:
    #####: 1860:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1861:      }
        -: 1862:    | primary_expression
        -: 1863:      {
    #####: 1864:        $$ = $1;
        -: 1865:      }
        -: 1866:    |'(' expression ')'
        -: 1867:      {
    #####: 1868:        $$ = $2;
        -: 1869:      }
        -: 1870:    ;
        -: 1871:
        -: 1872:
        -: 1873:for_variables
        -: 1874:    : _IDENTIFIER_
        -: 1875:      {
    #####: 1876:        int result = ERROR_SUCCESS;
        -: 1877:
    #####: 1878:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 1879:
    #####: 1880:        if (yr_parser_lookup_loop_variable(yyscanner, $1, NULL) >= 0)
        -: 1881:        {
    #####: 1882:          yr_compiler_set_error_extra_info(compiler, $1);
    #####: 1883:          yr_free($1);
        -: 1884:
    #####: 1885:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 1886:        }
        -: 1887:
    #####: 1888:        fail_if_error(result);
        -: 1889:
    #####: 1890:        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = $1;
        -: 1891:
    #####: 1892:        assert(loop_ctx->vars_count <= YR_MAX_LOOP_VARS);
        -: 1893:      }
        -: 1894:    | for_variables ',' _IDENTIFIER_
        -: 1895:      {
    #####: 1896:        int result = ERROR_SUCCESS;
        -: 1897:
    #####: 1898:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 1899:
    #####: 1900:        if (loop_ctx->vars_count == YR_MAX_LOOP_VARS)
        -: 1901:        {
    #####: 1902:          yr_compiler_set_error_extra_info(compiler, "too many loop variables");
    #####: 1903:          yr_free($3);
        -: 1904:
    #####: 1905:          result = ERROR_SYNTAX_ERROR;
        -: 1906:        }
    #####: 1907:        else if (yr_parser_lookup_loop_variable(yyscanner, $3, NULL) >= 0)
        -: 1908:        {
    #####: 1909:          yr_compiler_set_error_extra_info(compiler, $3);
    #####: 1910:          yr_free($3);
        -: 1911:
    #####: 1912:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 1913:        }
        -: 1914:
    #####: 1915:        fail_if_error(result);
        -: 1916:
    #####: 1917:        loop_ctx->vars[loop_ctx->vars_count++].identifier.ptr = $3;
        -: 1918:      }
        -: 1919:    ;
        -: 1920:
        -: 1921:iterator
        -: 1922:    : identifier
        -: 1923:      {
    #####: 1924:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 1925:
        -: 1926:        // Initially we assume that the identifier is from a non-iterable type,
        -: 1927:        // this will change later if it's iterable.
    #####: 1928:        int result = ERROR_WRONG_TYPE;
        -: 1929:
    #####: 1930:        if ($1.type == EXPRESSION_TYPE_OBJECT)
        -: 1931:        {
    #####: 1932:          switch($1.value.object->type)
        -: 1933:          {
    #####: 1934:            case OBJECT_TYPE_ARRAY:
        -: 1935:              // If iterating an array the loop must define a single variable
        -: 1936:              // that will hold the current item. If a different number of
        -: 1937:              // variables were defined that's an error.
    #####: 1938:              if (loop_ctx->vars_count == 1)
        -: 1939:              {
    #####: 1940:                loop_ctx->vars[0].type = EXPRESSION_TYPE_OBJECT;
    #####: 1941:                loop_ctx->vars[0].value.object = \
    #####: 1942:                    object_as_array($1.value.object)->prototype_item;
        -: 1943:
    #####: 1944:                result = yr_parser_emit(yyscanner, OP_ITER_START_ARRAY, NULL);
        -: 1945:              }
        -: 1946:              else
        -: 1947:              {
    #####: 1948:                yr_compiler_set_error_extra_info_fmt(
        -: 1949:                    compiler,
        -: 1950:                    "iterator for \"%s\" yields a single item on each iteration"
        -: 1951:                    ", but the loop expects %d",
        -: 1952:                    expression_identifier($1),
        -: 1953:                    loop_ctx->vars_count);
        -: 1954:
    #####: 1955:                result = ERROR_SYNTAX_ERROR;
        -: 1956:              }
    #####: 1957:              break;
        -: 1958:
    #####: 1959:            case OBJECT_TYPE_DICTIONARY:
        -: 1960:              // If iterating a dictionary the loop must define exactly two
        -: 1961:              // variables, one for the key and another for the value . If a
        -: 1962:              // different number of variables were defined that's an error.
    #####: 1963:              if (loop_ctx->vars_count == 2)
        -: 1964:              {
    #####: 1965:                loop_ctx->vars[0].type = EXPRESSION_TYPE_STRING;
    #####: 1966:                loop_ctx->vars[0].value.sized_string_ref = YR_ARENA_NULL_REF;
    #####: 1967:                loop_ctx->vars[1].type = EXPRESSION_TYPE_OBJECT;
    #####: 1968:                loop_ctx->vars[1].value.object = \
    #####: 1969:                    object_as_array($1.value.object)->prototype_item;
        -: 1970:
    #####: 1971:                result = yr_parser_emit(yyscanner, OP_ITER_START_DICT, NULL);
        -: 1972:              }
        -: 1973:              else
        -: 1974:              {
    #####: 1975:                yr_compiler_set_error_extra_info_fmt(
        -: 1976:                    compiler,
        -: 1977:                    "iterator for \"%s\" yields a key,value pair item on each iteration",
        -: 1978:                    expression_identifier($1));
        -: 1979:
    #####: 1980:                result = ERROR_SYNTAX_ERROR;
        -: 1981:              }
    #####: 1982:              break;
        -: 1983:          }
    #####: 1984:        }
        -: 1985:
    #####: 1986:        if (result == ERROR_WRONG_TYPE)
        -: 1987:        {
    #####: 1988:          yr_compiler_set_error_extra_info_fmt(
        -: 1989:              compiler,
        -: 1990:              "identifier \"%s\" is not iterable",
        -: 1991:              expression_identifier($1));
        -: 1992:        }
        -: 1993:
    #####: 1994:        fail_if_error(result);
        -: 1995:      }
        -: 1996:    | integer_set
        -: 1997:      {
    #####: 1998:        int result = ERROR_SUCCESS;
        -: 1999:
    #####: 2000:        YR_LOOP_CONTEXT* loop_ctx = &compiler->loop[compiler->loop_index];
        -: 2001:
    #####: 2002:        if (loop_ctx->vars_count == 1)
        -: 2003:        {
    #####: 2004:          loop_ctx->vars[0].type = EXPRESSION_TYPE_INTEGER;
    #####: 2005:          loop_ctx->vars[0].value.integer = YR_UNDEFINED;
        -: 2006:        }
        -: 2007:        else
        -: 2008:        {
    #####: 2009:          yr_compiler_set_error_extra_info_fmt(
        -: 2010:              compiler,
        -: 2011:              "iterator yields an integer on each iteration "
        -: 2012:              ", but the loop expects %d",
        -: 2013:              loop_ctx->vars_count);
        -: 2014:
    #####: 2015:          result = ERROR_SYNTAX_ERROR;
        -: 2016:        }
        -: 2017:
    #####: 2018:        fail_if_error(result);
        -: 2019:      }
        -: 2020:    ;
        -: 2021:
        -: 2022:
        -: 2023:integer_set
        -: 2024:    : '(' integer_enumeration ')'
        -: 2025:      {
        -: 2026:        // $2 contains the number of integers in the enumeration
    #####: 2027:        fail_if_error(yr_parser_emit_with_arg(
        -: 2028:            yyscanner, OP_PUSH, $2, NULL, NULL));
        -: 2029:
    #####: 2030:        fail_if_error(yr_parser_emit(
        -: 2031:            yyscanner, OP_ITER_START_INT_ENUM, NULL));
        -: 2032:      }
        -: 2033:    | range
        -: 2034:      {
    #####: 2035:        fail_if_error(yr_parser_emit(
        -: 2036:            yyscanner, OP_ITER_START_INT_RANGE, NULL));
        -: 2037:      }
        -: 2038:    ;
        -: 2039:
        -: 2040:
        -: 2041:range
        -: 2042:    : '(' primary_expression _DOT_DOT_ primary_expression ')'
        -: 2043:      {
    #####: 2044:        int result = ERROR_SUCCESS;
        -: 2045:
    #####: 2046:        if ($2.type != EXPRESSION_TYPE_INTEGER)
        -: 2047:        {
    #####: 2048:          yr_compiler_set_error_extra_info(
        -: 2049:              compiler, "wrong type for range's lower bound");
    #####: 2050:          result = ERROR_WRONG_TYPE;
        -: 2051:        }
        -: 2052:
    #####: 2053:        if ($4.type != EXPRESSION_TYPE_INTEGER)
        -: 2054:        {
    #####: 2055:          yr_compiler_set_error_extra_info(
        -: 2056:              compiler, "wrong type for range's upper bound");
    #####: 2057:          result = ERROR_WRONG_TYPE;
        -: 2058:        }
        -: 2059:
    #####: 2060:        fail_if_error(result);
        -: 2061:      }
        -: 2062:    ;
        -: 2063:
        -: 2064:
        -: 2065:integer_enumeration
        -: 2066:    : primary_expression
        -: 2067:      {
    #####: 2068:        int result = ERROR_SUCCESS;
        -: 2069:
    #####: 2070:        if ($1.type != EXPRESSION_TYPE_INTEGER)
        -: 2071:        {
    #####: 2072:          yr_compiler_set_error_extra_info(
        -: 2073:              compiler, "wrong type for enumeration item");
    #####: 2074:          result = ERROR_WRONG_TYPE;
        -: 2075:        }
        -: 2076:
    #####: 2077:        fail_if_error(result);
        -: 2078:
    #####: 2079:        $$ = 1;
        -: 2080:      }
        -: 2081:    | integer_enumeration ',' primary_expression
        -: 2082:      {
    #####: 2083:        int result = ERROR_SUCCESS;
        -: 2084:
    #####: 2085:        if ($3.type != EXPRESSION_TYPE_INTEGER)
        -: 2086:        {
    #####: 2087:          yr_compiler_set_error_extra_info(
        -: 2088:              compiler, "wrong type for enumeration item");
    #####: 2089:          result = ERROR_WRONG_TYPE;
        -: 2090:        }
        -: 2091:
    #####: 2092:        fail_if_error(result);
        -: 2093:
    #####: 2094:        $$ = $1 + 1;
        -: 2095:      }
        -: 2096:    ;
        -: 2097:
        -: 2098:
        -: 2099:string_set
        -: 2100:    : '('
        -: 2101:      {
        -: 2102:        // Push end-of-list marker
    #####: 2103:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);
        -: 2104:      }
        -: 2105:      string_enumeration ')'
        -: 2106:    | _THEM_
        -: 2107:      {
    #####: 2108:        fail_if_error(yr_parser_emit_with_arg(
        -: 2109:            yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL));
        -: 2110:
    #####: 2111:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 2112:            yyscanner, "$*"));
        -: 2113:      }
        -: 2114:    ;
        -: 2115:
        -: 2116:
        -: 2117:string_enumeration
        -: 2118:    : string_enumeration_item
        -: 2119:    | string_enumeration ',' string_enumeration_item
        -: 2120:    ;
        -: 2121:
        -: 2122:
        -: 2123:string_enumeration_item
        -: 2124:    : _STRING_IDENTIFIER_
        -: 2125:      {
    #####: 2126:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 2127:        yr_free($1);
        -: 2128:
    #####: 2129:        fail_if_error(result);
        -: 2130:      }
        -: 2131:    | _STRING_IDENTIFIER_WITH_WILDCARD_
        -: 2132:      {
    #####: 2133:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 2134:        yr_free($1);
        -: 2135:
    #####: 2136:        fail_if_error(result);
        -: 2137:      }
        -: 2138:    ;
        -: 2139:
        -: 2140:
        -: 2141:for_expression
        -: 2142:    : primary_expression
        -: 2143:      {
    #####: 2144:        $$ = FOR_EXPRESSION_ANY;
        -: 2145:      }
        -: 2146:    | _ALL_
        -: 2147:      {
    #####: 2148:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, YR_UNDEFINED, NULL, NULL);
    #####: 2149:        $$ = FOR_EXPRESSION_ALL;
        -: 2150:      }
        -: 2151:    | _ANY_
        -: 2152:      {
    #####: 2153:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
    #####: 2154:        $$ = FOR_EXPRESSION_ANY;
        -: 2155:      }
        -: 2156:    ;
        -: 2157:
        -: 2158:
        -: 2159:primary_expression
        -: 2160:    : '(' primary_expression ')'
        -: 2161:      {
    #####: 2162:        $$ = $2;
        -: 2163:      }
        -: 2164:    | _FILESIZE_
        -: 2165:      {
    #####: 2166:        fail_if_error(yr_parser_emit(
        -: 2167:            yyscanner, OP_FILESIZE, NULL));
        -: 2168:
    #####: 2169:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2170:        $$.value.integer = YR_UNDEFINED;
        -: 2171:      }
        -: 2172:    | _ENTRYPOINT_
        -: 2173:      {
    #####: 2174:        yywarning(yyscanner,
        -: 2175:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 2176:            "function from PE module instead.");
        -: 2177:
    #####: 2178:        fail_if_error(yr_parser_emit(
        -: 2179:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 2180:
    #####: 2181:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2182:        $$.value.integer = YR_UNDEFINED;
        -: 2183:      }
        -: 2184:    | _INTEGER_FUNCTION_ '(' primary_expression ')'
        -: 2185:      {
    #####: 2186:        check_type($3, EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 2187:
        -: 2188:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 2189:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 2190:        // in the proper OP_INTXX opcode.
        -: 2191:
    #####: 2192:        fail_if_error(yr_parser_emit(
        -: 2193:            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL));
        -: 2194:
    #####: 2195:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2196:        $$.value.integer = YR_UNDEFINED;
        -: 2197:      }
        -: 2198:    | _NUMBER_
        -: 2199:      {
    #####: 2200:        fail_if_error(yr_parser_emit_with_arg(
        -: 2201:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 2202:
    #####: 2203:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2204:        $$.value.integer = $1;
        -: 2205:      }
        -: 2206:    | _DOUBLE_
        -: 2207:      {
    #####: 2208:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 2209:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 2210:
    #####: 2211:        $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2212:      }
        -: 2213:    | _TEXT_STRING_
        -: 2214:      {
        -: 2215:        YR_ARENA_REF ref;
        -: 2216:
    #####: 2217:        int result = yr_arena_write_data(
        -: 2218:            compiler->arena,
        -: 2219:            YR_SZ_POOL,
    #####: 2220:            $1,
    #####: 2221:            $1->length + sizeof(SIZED_STRING),
        -: 2222:            &ref);
        -: 2223:
    #####: 2224:        yr_free($1);
        -: 2225:
    #####: 2226:        if (result == ERROR_SUCCESS)
    #####: 2227:          result = yr_parser_emit_with_arg_reloc(
        -: 2228:              yyscanner,
        -: 2229:              OP_PUSH,
        -: 2230:              yr_arena_ref_to_ptr(compiler->arena, &ref),
        -: 2231:              NULL,
        -: 2232:              NULL);
        -: 2233:
    #####: 2234:        fail_if_error(result);
        -: 2235:
    #####: 2236:        $$.type = EXPRESSION_TYPE_STRING;
    #####: 2237:        $$.value.sized_string_ref = ref;
        -: 2238:      }
        -: 2239:    | _STRING_COUNT_
        -: 2240:      {
    #####: 2241:        int result = yr_parser_reduce_string_identifier(
    #####: 2242:            yyscanner, $1, OP_COUNT, YR_UNDEFINED);
        -: 2243:
    #####: 2244:        yr_free($1);
        -: 2245:
    #####: 2246:        fail_if_error(result);
        -: 2247:
    #####: 2248:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2249:        $$.value.integer = YR_UNDEFINED;
        -: 2250:      }
        -: 2251:    | _STRING_OFFSET_ '[' primary_expression ']'
        -: 2252:      {
    #####: 2253:        int result = yr_parser_reduce_string_identifier(
    #####: 2254:            yyscanner, $1, OP_OFFSET, YR_UNDEFINED);
        -: 2255:
    #####: 2256:        yr_free($1);
        -: 2257:
    #####: 2258:        fail_if_error(result);
        -: 2259:
    #####: 2260:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2261:        $$.value.integer = YR_UNDEFINED;
        -: 2262:      }
        -: 2263:    | _STRING_OFFSET_
        -: 2264:      {
    #####: 2265:        int result = yr_parser_emit_with_arg(
        -: 2266:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 2267:
    #####: 2268:        if (result == ERROR_SUCCESS)
    #####: 2269:          result = yr_parser_reduce_string_identifier(
    #####: 2270:              yyscanner, $1, OP_OFFSET, YR_UNDEFINED);
        -: 2271:
    #####: 2272:        yr_free($1);
        -: 2273:
    #####: 2274:        fail_if_error(result);
        -: 2275:
    #####: 2276:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2277:        $$.value.integer = YR_UNDEFINED;
        -: 2278:      }
        -: 2279:    | _STRING_LENGTH_ '[' primary_expression ']'
        -: 2280:      {
    #####: 2281:        int result = yr_parser_reduce_string_identifier(
    #####: 2282:            yyscanner, $1, OP_LENGTH, YR_UNDEFINED);
        -: 2283:
    #####: 2284:        yr_free($1);
        -: 2285:
    #####: 2286:        fail_if_error(result);
        -: 2287:
    #####: 2288:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2289:        $$.value.integer = YR_UNDEFINED;
        -: 2290:      }
        -: 2291:    | _STRING_LENGTH_
        -: 2292:      {
    #####: 2293:        int result = yr_parser_emit_with_arg(
        -: 2294:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 2295:
    #####: 2296:        if (result == ERROR_SUCCESS)
    #####: 2297:          result = yr_parser_reduce_string_identifier(
    #####: 2298:              yyscanner, $1, OP_LENGTH, YR_UNDEFINED);
        -: 2299:
    #####: 2300:        yr_free($1);
        -: 2301:
    #####: 2302:        fail_if_error(result);
        -: 2303:
    #####: 2304:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2305:        $$.value.integer = YR_UNDEFINED;
        -: 2306:      }
        -: 2307:    | identifier
        -: 2308:      {
    #####: 2309:        int result = ERROR_SUCCESS;
        -: 2310:
    #####: 2311:        if ($1.type == EXPRESSION_TYPE_OBJECT)
        -: 2312:        {
    #####: 2313:          result = yr_parser_emit(
        -: 2314:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 2315:
    #####: 2316:          switch($1.value.object->type)
        -: 2317:          {
    #####: 2318:            case OBJECT_TYPE_INTEGER:
    #####: 2319:              $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2320:              $$.value.integer = YR_UNDEFINED;
    #####: 2321:              break;
    #####: 2322:            case OBJECT_TYPE_FLOAT:
    #####: 2323:              $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 2324:              break;
    #####: 2325:            case OBJECT_TYPE_STRING:
    #####: 2326:              $$.type = EXPRESSION_TYPE_STRING;
    #####: 2327:              $$.value.sized_string_ref = YR_ARENA_NULL_REF;
    #####: 2328:              break;
    #####: 2329:            default:
        -: 2330:              // In a primary expression any identifier that corresponds to an
        -: 2331:              // object must be of type integer, float or string. If "foobar" is
        -: 2332:              // either a function, structure, dictionary or array you can not
        -: 2333:              // use it as:
        -: 2334:              //   condition: foobar
    #####: 2335:              yr_compiler_set_error_extra_info_fmt(
        -: 2336:                  compiler,
        -: 2337:                  "wrong usage of identifier \"%s\"",
        -: 2338:                  expression_identifier($1));
        -: 2339:
    #####: 2340:              result = ERROR_WRONG_TYPE;
        -: 2341:          }
        -: 2342:        }
        -: 2343:        else
        -: 2344:        {
    #####: 2345:          $$ = $1;
        -: 2346:        }
        -: 2347:
    #####: 2348:        fail_if_error(result);
        -: 2349:      }
        -: 2350:    | '-' primary_expression %prec UNARY_MINUS
        -: 2351:      {
    #####: 2352:        int result = ERROR_SUCCESS;
        -: 2353:
    #####: 2354:        check_type($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 2355:
    #####: 2356:        if ($2.type == EXPRESSION_TYPE_INTEGER)
        -: 2357:        {
    #####: 2358:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2359:          $$.value.integer = ($2.value.integer == YR_UNDEFINED) ?
    #####: 2360:              YR_UNDEFINED : -($2.value.integer);
    #####: 2361:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 2362:        }
    #####: 2363:        else if ($2.type == EXPRESSION_TYPE_FLOAT)
        -: 2364:        {
    #####: 2365:          $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 2366:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 2367:        }
        -: 2368:
    #####: 2369:        fail_if_error(result);
        -: 2370:      }
        -: 2371:    | primary_expression '+' primary_expression
        -: 2372:      {
    #####: 2373:        int result = yr_parser_reduce_operation(
    #####: 2374:            yyscanner, "+", $1, $3);
        -: 2375:
    #####: 2376:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2377:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 2378:        {
    #####: 2379:          int64_t i1 = $1.value.integer;
    #####: 2380:          int64_t i2 = $3.value.integer;
        -: 2381:
    #####: 2382:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 2383:              (
    #####: 2384:                (i2 > 0 && i1 > INT64_MAX - i2) ||
    #####: 2385:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 2386:              ))
        -: 2387:          {
    #####: 2388:            yr_compiler_set_error_extra_info_fmt(
        -: 2389:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 2390:
    #####: 2391:            result = ERROR_INTEGER_OVERFLOW;
        -: 2392:          }
        -: 2393:          else
        -: 2394:          {
    #####: 2395:            $$.value.integer = OPERATION(+, i1, i2);
    #####: 2396:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2397:          }
        -: 2398:        }
        -: 2399:        else
        -: 2400:        {
    #####: 2401:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2402:        }
        -: 2403:
    #####: 2404:        fail_if_error(result);
        -: 2405:      }
        -: 2406:    | primary_expression '-' primary_expression
        -: 2407:      {
    #####: 2408:        int result = yr_parser_reduce_operation(
    #####: 2409:            yyscanner, "-", $1, $3);
        -: 2410:
    #####: 2411:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2412:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 2413:        {
    #####: 2414:          int64_t i1 = $1.value.integer;
    #####: 2415:          int64_t i2 = $3.value.integer;
        -: 2416:
    #####: 2417:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 2418:              (
    #####: 2419:                (i2 < 0 && i1 > INT64_MAX + i2) ||
    #####: 2420:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 2421:              ))
        -: 2422:          {
    #####: 2423:            yr_compiler_set_error_extra_info_fmt(
        -: 2424:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 2425:
    #####: 2426:            result = ERROR_INTEGER_OVERFLOW;
        -: 2427:          }
        -: 2428:          else
        -: 2429:          {
    #####: 2430:            $$.value.integer = OPERATION(-, i1, i2);
    #####: 2431:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2432:          }
        -: 2433:        }
        -: 2434:        else
        -: 2435:        {
    #####: 2436:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2437:        }
        -: 2438:
    #####: 2439:        fail_if_error(result);
        -: 2440:      }
        -: 2441:    | primary_expression '*' primary_expression
        -: 2442:      {
    #####: 2443:        int result = yr_parser_reduce_operation(
    #####: 2444:            yyscanner, "*", $1, $3);
        -: 2445:
    #####: 2446:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2447:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 2448:        {
    #####: 2449:          int64_t i1 = $1.value.integer;
    #####: 2450:          int64_t i2 = $3.value.integer;
        -: 2451:
    #####: 2452:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 2453:              (
    #####: 2454:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 2455:              ))
        -: 2456:          {
    #####: 2457:            yr_compiler_set_error_extra_info_fmt(
        -: 2458:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 2459:
    #####: 2460:            result = ERROR_INTEGER_OVERFLOW;
        -: 2461:          }
        -: 2462:          else
        -: 2463:          {
    #####: 2464:            $$.value.integer = OPERATION(*, i1, i2);
    #####: 2465:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2466:          }
        -: 2467:        }
        -: 2468:        else
        -: 2469:        {
    #####: 2470:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2471:        }
        -: 2472:
    #####: 2473:        fail_if_error(result);
        -: 2474:      }
        -: 2475:    | primary_expression '\\' primary_expression
        -: 2476:      {
    #####: 2477:        int result = yr_parser_reduce_operation(
    #####: 2478:            yyscanner, "\\", $1, $3);
        -: 2479:
    #####: 2480:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 2481:            $3.type == EXPRESSION_TYPE_INTEGER)
        -: 2482:        {
    #####: 2483:          if ($3.value.integer != 0)
        -: 2484:          {
    #####: 2485:            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);
    #####: 2486:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2487:          }
        -: 2488:          else
        -: 2489:          {
    #####: 2490:            result = ERROR_DIVISION_BY_ZERO;
        -: 2491:          }
        -: 2492:        }
        -: 2493:        else
        -: 2494:        {
    #####: 2495:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 2496:        }
        -: 2497:
    #####: 2498:        fail_if_error(result);
        -: 2499:      }
        -: 2500:    | primary_expression '%' primary_expression
        -: 2501:      {
    #####: 2502:        check_type($1, EXPRESSION_TYPE_INTEGER, "%");
    #####: 2503:        check_type($3, EXPRESSION_TYPE_INTEGER, "%");
        -: 2504:
    #####: 2505:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 2506:
    #####: 2507:        if ($3.value.integer != 0)
        -: 2508:        {
    #####: 2509:          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);
    #####: 2510:          $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2511:        }
        -: 2512:        else
        -: 2513:        {
    #####: 2514:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 2515:        }
        -: 2516:      }
        -: 2517:    | primary_expression '^' primary_expression
        -: 2518:      {
    #####: 2519:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 2520:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 2521:
    #####: 2522:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 2523:
    #####: 2524:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2525:        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);
        -: 2526:      }
        -: 2527:    | primary_expression '&' primary_expression
        -: 2528:      {
    #####: 2529:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 2530:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 2531:
    #####: 2532:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 2533:
    #####: 2534:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2535:        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);
        -: 2536:      }
        -: 2537:    | primary_expression '|' primary_expression
        -: 2538:      {
    #####: 2539:        check_type($1, EXPRESSION_TYPE_INTEGER, "|");
    #####: 2540:        check_type($3, EXPRESSION_TYPE_INTEGER, "|");
        -: 2541:
    #####: 2542:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 2543:
    #####: 2544:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2545:        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);
        -: 2546:      }
        -: 2547:    | '~' primary_expression
        -: 2548:      {
    #####: 2549:        check_type($2, EXPRESSION_TYPE_INTEGER, "~");
        -: 2550:
    #####: 2551:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 2552:
    #####: 2553:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 2554:        $$.value.integer = ($2.value.integer == YR_UNDEFINED) ?
    #####: 2555:            YR_UNDEFINED : ~($2.value.integer);
        -: 2556:      }
        -: 2557:    | primary_expression _SHIFT_LEFT_ primary_expression
        -: 2558:      {
        -: 2559:        int result;
        -: 2560:
    #####: 2561:        check_type($1, EXPRESSION_TYPE_INTEGER, "<<");
    #####: 2562:        check_type($3, EXPRESSION_TYPE_INTEGER, "<<");
        -: 2563:
    #####: 2564:        result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 2565:
    #####: 2566:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 2567:          result = ERROR_INVALID_OPERAND;
    #####: 2568:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 2569:          $$.value.integer = 0;
        -: 2570:        else
    #####: 2571:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 2572:
    #####: 2573:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2574:
    #####: 2575:        fail_if_error(result);
        -: 2576:      }
        -: 2577:    | primary_expression _SHIFT_RIGHT_ primary_expression
        -: 2578:      {
        -: 2579:        int result;
        -: 2580:
    #####: 2581:        check_type($1, EXPRESSION_TYPE_INTEGER, ">>");
    #####: 2582:        check_type($3, EXPRESSION_TYPE_INTEGER, ">>");
        -: 2583:
    #####: 2584:        result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 2585:
    #####: 2586:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 2587:          result = ERROR_INVALID_OPERAND;
    #####: 2588:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 2589:          $$.value.integer = 0;
        -: 2590:        else
    #####: 2591:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 2592:
    #####: 2593:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 2594:
    #####: 2595:        fail_if_error(result);
        -: 2596:      }
        -: 2597:    | regexp
        -: 2598:      {
    #####: 2599:        $$ = $1;
        -: 2600:      }
        -: 2601:    ;
        -: 2602:
        -: 2603:%%
