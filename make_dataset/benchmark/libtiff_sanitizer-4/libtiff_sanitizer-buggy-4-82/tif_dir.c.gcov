        -:    0:Source:tif_dir.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library.
        -:   29: *
        -:   30: * Directory Tag Get & Set Routines.
        -:   31: * (and also some miscellaneous stuff)
        -:   32: */
        -:   33:#include "tiffiop.h"
        -:   34:
        -:   35:/*
        -:   36: * These are used in the backwards compatibility code...
        -:   37: */
        -:   38:#define DATATYPE_VOID		0       /* !untyped data */
        -:   39:#define DATATYPE_INT		1       /* !signed integer data */
        -:   40:#define DATATYPE_UINT		2       /* !unsigned integer data */
        -:   41:#define DATATYPE_IEEEFP		3       /* !IEEE floating point data */
        -:   42:
        -:   43:static void
        1:   44:setByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)
        -:   45:{
        1:   46:	if (*vpp) {
    #####:   47:		_TIFFfree(*vpp);
    #####:   48:		*vpp = 0;
        -:   49:	}
        1:   50:	if (vp) {
        1:   51:		tmsize_t bytes = (tmsize_t)(nmemb * elem_size);
       1*:   52:		if (elem_size && bytes / elem_size == nmemb)
        1:   53:			*vpp = (void*) _TIFFmalloc(bytes);
        1:   54:		if (*vpp)
        1:   55:			_TIFFmemcpy(*vpp, vp, bytes);
        -:   56:	}
        1:   57:}
    #####:   58:void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)
    #####:   59:    { setByteArray(vpp, vp, n, 1); }
    #####:   60:void _TIFFsetString(char** cpp, char* cp)
    #####:   61:    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }
    #####:   62:static void _TIFFsetNString(char** cpp, char* cp, uint32 n)
    #####:   63:    { setByteArray((void**) cpp, (void*) cp, n, 1); }
    #####:   64:void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)
    #####:   65:    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }
    #####:   66:void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)
    #####:   67:    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }
    #####:   68:static void _TIFFsetLong8Array(uint64** lpp, uint64* lp, uint32 n)
    #####:   69:    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint64)); }
    #####:   70:void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)
    #####:   71:    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }
    #####:   72:void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)
    #####:   73:    { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }
        -:   74:
        -:   75:static void
    #####:   76:setDoubleArrayOneValue(double** vpp, double value, size_t nmemb)
        -:   77:{
    #####:   78:	if (*vpp)
    #####:   79:		_TIFFfree(*vpp);
    #####:   80:	*vpp = _TIFFmalloc(nmemb*sizeof(double));
    #####:   81:	if (*vpp)
        -:   82:	{
    #####:   83:		while (nmemb--)
    #####:   84:			((double*)*vpp)[nmemb] = value;
        -:   85:	}
    #####:   86:}
        -:   87:
        -:   88:/*
        -:   89: * Install extra samples information.
        -:   90: */
        -:   91:static int
    #####:   92:setExtraSamples(TIFFDirectory* td, va_list ap, uint32* v)
        -:   93:{
        -:   94:/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
        -:   95:#define EXTRASAMPLE_COREL_UNASSALPHA 999 
        -:   96:
        -:   97:	uint16* va;
        -:   98:	uint32 i;
        -:   99:
    #####:  100:	*v = (uint16) va_arg(ap, uint16_vap);
    #####:  101:	if ((uint16) *v > td->td_samplesperpixel)
    #####:  102:		return 0;
    #####:  103:	va = va_arg(ap, uint16*);
    #####:  104:	if (*v > 0 && va == NULL)		/* typically missing param */
    #####:  105:		return 0;
    #####:  106:	for (i = 0; i < *v; i++) {
    #####:  107:		if (va[i] > EXTRASAMPLE_UNASSALPHA) {
        -:  108:			/*
        -:  109:			 * XXX: Corel Draw is known to produce incorrect
        -:  110:			 * ExtraSamples tags which must be patched here if we
        -:  111:			 * want to be able to open some of the damaged TIFF
        -:  112:			 * files: 
        -:  113:			 */
    #####:  114:			if (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)
    #####:  115:				va[i] = EXTRASAMPLE_UNASSALPHA;
        -:  116:			else
    #####:  117:				return 0;
        -:  118:		}
        -:  119:	}
    #####:  120:	td->td_extrasamples = (uint16) *v;
    #####:  121:	_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);
    #####:  122:	return 1;
        -:  123:
        -:  124:#undef EXTRASAMPLE_COREL_UNASSALPHA
        -:  125:}
        -:  126:
        -:  127:/*
        -:  128: * Confirm we have "samplesperpixel" ink names separated by \0.  Returns 
        -:  129: * zero if the ink names are not as expected.
        -:  130: */
        -:  131:static uint32
    #####:  132:checkInkNamesString(TIFF* tif, uint32 slen, const char* s)
        -:  133:{
    #####:  134:	TIFFDirectory* td = &tif->tif_dir;
    #####:  135:	uint16 i = td->td_samplesperpixel;
        -:  136:
    #####:  137:	if (slen > 0) {
    #####:  138:		const char* ep = s+slen;
    #####:  139:		const char* cp = s;
    #####:  140:		for (; i > 0; i--) {
    #####:  141:			for (; cp < ep && *cp != '\0'; cp++) {}
    #####:  142:			if (cp >= ep)
    #####:  143:				goto bad;
    #####:  144:			cp++;				/* skip \0 */
        -:  145:		}
    #####:  146:		return ((uint32)(cp-s));
        -:  147:	}
    #####:  148:bad:
    #####:  149:	TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
        -:  150:	    "%s: Invalid InkNames value; expecting %d names, found %d",
        -:  151:	    tif->tif_name,
    #####:  152:	    td->td_samplesperpixel,
    #####:  153:	    td->td_samplesperpixel-i);
    #####:  154:	return (0);
        -:  155:}
        -:  156:
        -:  157:static int
       19:  158:_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
        -:  159:{
        -:  160:	static const char module[] = "_TIFFVSetField";
        -:  161:
       19:  162:	TIFFDirectory* td = &tif->tif_dir;
       19:  163:	int status = 1;
       19:  164:	uint32 v32, i, v;
        -:  165:    double dblval;
        -:  166:	char* s;
       19:  167:	const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);
       19:  168:	uint32 standard_tag = tag;
       19:  169:	if( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */
    #####:  170:	    return 0;
        -:  171:	/*
        -:  172:	 * We want to force the custom code to be used for custom
        -:  173:	 * fields even if the tag happens to match a well known 
        -:  174:	 * one - important for reinterpreted handling of standard
        -:  175:	 * tag values in custom directories (i.e. EXIF) 
        -:  176:	 */
       19:  177:	if (fip->field_bit == FIELD_CUSTOM) {
        1:  178:		standard_tag = 0;
        -:  179:	}
        -:  180:
       19:  181:	switch (standard_tag) {
    #####:  182:	case TIFFTAG_SUBFILETYPE:
    #####:  183:		td->td_subfiletype = (uint32) va_arg(ap, uint32);
    #####:  184:		break;
        2:  185:	case TIFFTAG_IMAGEWIDTH:
        2:  186:		td->td_imagewidth = (uint32) va_arg(ap, uint32);
        2:  187:		break;
        1:  188:	case TIFFTAG_IMAGELENGTH:
        1:  189:		td->td_imagelength = (uint32) va_arg(ap, uint32);
        1:  190:		break;
        2:  191:	case TIFFTAG_BITSPERSAMPLE:
        2:  192:		td->td_bitspersample = (uint16) va_arg(ap, uint16_vap);
        -:  193:		/*
        -:  194:		 * If the data require post-decoding processing to byte-swap
        -:  195:		 * samples, set it up here.  Note that since tags are required
        -:  196:		 * to be ordered, compression code can override this behaviour
        -:  197:		 * in the setup method if it wants to roll the post decoding
        -:  198:		 * work in with its normal work.
        -:  199:		 */
        2:  200:		if (tif->tif_flags & TIFF_SWAB) {
    #####:  201:			if (td->td_bitspersample == 8)
    #####:  202:				tif->tif_postdecode = _TIFFNoPostDecode;
    #####:  203:			else if (td->td_bitspersample == 16)
    #####:  204:				tif->tif_postdecode = _TIFFSwab16BitData;
    #####:  205:			else if (td->td_bitspersample == 24)
    #####:  206:				tif->tif_postdecode = _TIFFSwab24BitData;
    #####:  207:			else if (td->td_bitspersample == 32)
    #####:  208:				tif->tif_postdecode = _TIFFSwab32BitData;
    #####:  209:			else if (td->td_bitspersample == 64)
    #####:  210:				tif->tif_postdecode = _TIFFSwab64BitData;
    #####:  211:			else if (td->td_bitspersample == 128) /* two 64's */
    #####:  212:				tif->tif_postdecode = _TIFFSwab64BitData;
        -:  213:		}
        2:  214:		break;
        4:  215:	case TIFFTAG_COMPRESSION:
        4:  216:		v = (uint16) va_arg(ap, uint16_vap);
        -:  217:		/*
        -:  218:		 * If we're changing the compression scheme, the notify the
        -:  219:		 * previous module so that it can cleanup any state it's
        -:  220:		 * setup.
        -:  221:		 */
        4:  222:		if (TIFFFieldSet(tif, FIELD_COMPRESSION)) {
        2:  223:			if ((uint32)td->td_compression == v)
    #####:  224:				break;
        2:  225:			(*tif->tif_cleanup)(tif);
        2:  226:			tif->tif_flags &= ~TIFF_CODERSETUP;
        -:  227:		}
        -:  228:		/*
        -:  229:		 * Setup new compression routine state.
        -:  230:		 */
        4:  231:		if( (status = TIFFSetCompressionScheme(tif, v)) != 0 )
        4:  232:		    td->td_compression = (uint16) v;
        -:  233:		else
    #####:  234:		    status = 0;
        4:  235:		break;
        2:  236:	case TIFFTAG_PHOTOMETRIC:
        2:  237:		td->td_photometric = (uint16) va_arg(ap, uint16_vap);
        2:  238:		break;
    #####:  239:	case TIFFTAG_THRESHHOLDING:
    #####:  240:		td->td_threshholding = (uint16) va_arg(ap, uint16_vap);
    #####:  241:		break;
    #####:  242:	case TIFFTAG_FILLORDER:
    #####:  243:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  244:		if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)
    #####:  245:			goto badvalue;
    #####:  246:		td->td_fillorder = (uint16) v;
    #####:  247:		break;
    #####:  248:	case TIFFTAG_ORIENTATION:
    #####:  249:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  250:		if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)
    #####:  251:			goto badvalue;
        -:  252:		else
    #####:  253:			td->td_orientation = (uint16) v;
    #####:  254:		break;
        2:  255:	case TIFFTAG_SAMPLESPERPIXEL:
        2:  256:		v = (uint16) va_arg(ap, uint16_vap);
        2:  257:		if (v == 0)
    #####:  258:			goto badvalue;
        2:  259:        if( v != td->td_samplesperpixel )
        -:  260:        {
        -:  261:            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */
        1:  262:            if( td->td_sminsamplevalue != NULL )
        -:  263:            {
    #####:  264:                TIFFWarningExt(tif->tif_clientdata,module,
        -:  265:                    "SamplesPerPixel tag value is changing, "
        -:  266:                    "but SMinSampleValue tag was read with a different value. Cancelling it");
    #####:  267:                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);
    #####:  268:                _TIFFfree(td->td_sminsamplevalue);
    #####:  269:                td->td_sminsamplevalue = NULL;
        -:  270:            }
        1:  271:            if( td->td_smaxsamplevalue != NULL )
        -:  272:            {
    #####:  273:                TIFFWarningExt(tif->tif_clientdata,module,
        -:  274:                    "SamplesPerPixel tag value is changing, "
        -:  275:                    "but SMaxSampleValue tag was read with a different value. Cancelling it");
    #####:  276:                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);
    #####:  277:                _TIFFfree(td->td_smaxsamplevalue);
    #####:  278:                td->td_smaxsamplevalue = NULL;
        -:  279:            }
        -:  280:        }
        2:  281:		td->td_samplesperpixel = (uint16) v;
        2:  282:		break;
        1:  283:	case TIFFTAG_ROWSPERSTRIP:
        1:  284:		v32 = (uint32) va_arg(ap, uint32);
        1:  285:		if (v32 == 0)
    #####:  286:			goto badvalue32;
        1:  287:		td->td_rowsperstrip = v32;
        1:  288:		if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
        1:  289:			td->td_tilelength = v32;
        1:  290:			td->td_tilewidth = td->td_imagewidth;
        -:  291:		}
        1:  292:		break;
    #####:  293:	case TIFFTAG_MINSAMPLEVALUE:
    #####:  294:		td->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);
    #####:  295:		break;
    #####:  296:	case TIFFTAG_MAXSAMPLEVALUE:
    #####:  297:		td->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);
    #####:  298:		break;
    #####:  299:	case TIFFTAG_SMINSAMPLEVALUE:
    #####:  300:		if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  301:			_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);
        -:  302:		else
    #####:  303:			setDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);
    #####:  304:		break;
    #####:  305:	case TIFFTAG_SMAXSAMPLEVALUE:
    #####:  306:		if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  307:			_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);
        -:  308:		else
    #####:  309:			setDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);
    #####:  310:		break;
    #####:  311:	case TIFFTAG_XRESOLUTION:
    #####:  312:        dblval = va_arg(ap, double);
    #####:  313:        if( dblval < 0 )
    #####:  314:            goto badvaluedouble;
    #####:  315:		td->td_xresolution = (float) dblval;
    #####:  316:		break;
    #####:  317:	case TIFFTAG_YRESOLUTION:
    #####:  318:        dblval = va_arg(ap, double);
    #####:  319:        if( dblval < 0 )
    #####:  320:            goto badvaluedouble;
    #####:  321:		td->td_yresolution = (float) dblval;
    #####:  322:		break;
        2:  323:	case TIFFTAG_PLANARCONFIG:
        2:  324:		v = (uint16) va_arg(ap, uint16_vap);
       2*:  325:		if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)
    #####:  326:			goto badvalue;
        2:  327:		td->td_planarconfig = (uint16) v;
        2:  328:		break;
    #####:  329:	case TIFFTAG_XPOSITION:
    #####:  330:		td->td_xposition = (float) va_arg(ap, double);
    #####:  331:		break;
    #####:  332:	case TIFFTAG_YPOSITION:
    #####:  333:		td->td_yposition = (float) va_arg(ap, double);
    #####:  334:		break;
    #####:  335:	case TIFFTAG_RESOLUTIONUNIT:
    #####:  336:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  337:		if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)
    #####:  338:			goto badvalue;
    #####:  339:		td->td_resolutionunit = (uint16) v;
    #####:  340:		break;
    #####:  341:	case TIFFTAG_PAGENUMBER:
    #####:  342:		td->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);
    #####:  343:		td->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);
    #####:  344:		break;
    #####:  345:	case TIFFTAG_HALFTONEHINTS:
    #####:  346:		td->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);
    #####:  347:		td->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);
    #####:  348:		break;
    #####:  349:	case TIFFTAG_COLORMAP:
    #####:  350:		v32 = (uint32)(1L<<td->td_bitspersample);
    #####:  351:		_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);
    #####:  352:		_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);
    #####:  353:		_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);
    #####:  354:		break;
    #####:  355:	case TIFFTAG_EXTRASAMPLES:
    #####:  356:		if (!setExtraSamples(td, ap, &v))
    #####:  357:			goto badvalue;
    #####:  358:		break;
    #####:  359:	case TIFFTAG_MATTEING:
    #####:  360:		td->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);
    #####:  361:		if (td->td_extrasamples) {
    #####:  362:			uint16 sv = EXTRASAMPLE_ASSOCALPHA;
    #####:  363:			_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);
        -:  364:		}
    #####:  365:		break;
    #####:  366:	case TIFFTAG_TILEWIDTH:
    #####:  367:		v32 = (uint32) va_arg(ap, uint32);
    #####:  368:		if (v32 % 16) {
    #####:  369:			if (tif->tif_mode != O_RDONLY)
    #####:  370:				goto badvalue32;
    #####:  371:			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -:  372:				"Nonstandard tile width %d, convert file", v32);
        -:  373:		}
    #####:  374:		td->td_tilewidth = v32;
    #####:  375:		tif->tif_flags |= TIFF_ISTILED;
    #####:  376:		break;
    #####:  377:	case TIFFTAG_TILELENGTH:
    #####:  378:		v32 = (uint32) va_arg(ap, uint32);
    #####:  379:		if (v32 % 16) {
    #####:  380:			if (tif->tif_mode != O_RDONLY)
    #####:  381:				goto badvalue32;
    #####:  382:			TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -:  383:			    "Nonstandard tile length %d, convert file", v32);
        -:  384:		}
    #####:  385:		td->td_tilelength = v32;
    #####:  386:		tif->tif_flags |= TIFF_ISTILED;
    #####:  387:		break;
    #####:  388:	case TIFFTAG_TILEDEPTH:
    #####:  389:		v32 = (uint32) va_arg(ap, uint32);
    #####:  390:		if (v32 == 0)
    #####:  391:			goto badvalue32;
    #####:  392:		td->td_tiledepth = v32;
    #####:  393:		break;
    #####:  394:	case TIFFTAG_DATATYPE:
    #####:  395:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  396:		switch (v) {
    #####:  397:		case DATATYPE_VOID:	v = SAMPLEFORMAT_VOID;	break;
    #####:  398:		case DATATYPE_INT:	v = SAMPLEFORMAT_INT;	break;
    #####:  399:		case DATATYPE_UINT:	v = SAMPLEFORMAT_UINT;	break;
    #####:  400:		case DATATYPE_IEEEFP:	v = SAMPLEFORMAT_IEEEFP;break;
    #####:  401:		default:		goto badvalue;
        -:  402:		}
    #####:  403:		td->td_sampleformat = (uint16) v;
    #####:  404:		break;
    #####:  405:	case TIFFTAG_SAMPLEFORMAT:
    #####:  406:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  407:		if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)
    #####:  408:			goto badvalue;
    #####:  409:		td->td_sampleformat = (uint16) v;
        -:  410:
        -:  411:		/*  Try to fix up the SWAB function for complex data. */
    #####:  412:		if( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT
    #####:  413:		    && td->td_bitspersample == 32
    #####:  414:		    && tif->tif_postdecode == _TIFFSwab32BitData )
    #####:  415:		    tif->tif_postdecode = _TIFFSwab16BitData;
    #####:  416:		else if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT
    #####:  417:			  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)
    #####:  418:			 && td->td_bitspersample == 64
    #####:  419:			 && tif->tif_postdecode == _TIFFSwab64BitData )
    #####:  420:		    tif->tif_postdecode = _TIFFSwab32BitData;
    #####:  421:		break;
    #####:  422:	case TIFFTAG_IMAGEDEPTH:
    #####:  423:		td->td_imagedepth = (uint32) va_arg(ap, uint32);
    #####:  424:		break;
    #####:  425:	case TIFFTAG_SUBIFD:
    #####:  426:		if ((tif->tif_flags & TIFF_INSUBIFD) == 0) {
    #####:  427:			td->td_nsubifd = (uint16) va_arg(ap, uint16_vap);
    #####:  428:			_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),
    #####:  429:			    (uint32) td->td_nsubifd);
        -:  430:		} else {
    #####:  431:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  432:				     "%s: Sorry, cannot nest SubIFDs",
        -:  433:				     tif->tif_name);
    #####:  434:			status = 0;
        -:  435:		}
    #####:  436:		break;
    #####:  437:	case TIFFTAG_YCBCRPOSITIONING:
    #####:  438:		td->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);
    #####:  439:		break;
        2:  440:	case TIFFTAG_YCBCRSUBSAMPLING:
        2:  441:		td->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);
        2:  442:		td->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);
        2:  443:		break;
    #####:  444:	case TIFFTAG_TRANSFERFUNCTION:
    #####:  445:		v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;
    #####:  446:		for (i = 0; i < v; i++)
    #####:  447:			_TIFFsetShortArray(&td->td_transferfunction[i],
    #####:  448:			    va_arg(ap, uint16*), 1U<<td->td_bitspersample);
    #####:  449:		break;
    #####:  450:	case TIFFTAG_REFERENCEBLACKWHITE:
        -:  451:		/* XXX should check for null range */
    #####:  452:		_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);
    #####:  453:		break;
    #####:  454:	case TIFFTAG_INKNAMES:
    #####:  455:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  456:		s = va_arg(ap, char*);
    #####:  457:		v = checkInkNamesString(tif, v, s);
    #####:  458:		status = v > 0;
    #####:  459:		if( v > 0 ) {
    #####:  460:			_TIFFsetNString(&td->td_inknames, s, v);
    #####:  461:			td->td_inknameslen = v;
        -:  462:		}
    #####:  463:		break;
    #####:  464:	case TIFFTAG_PERSAMPLE:
    #####:  465:		v = (uint16) va_arg(ap, uint16_vap);
    #####:  466:		if( v == PERSAMPLE_MULTI )
    #####:  467:			tif->tif_flags |= TIFF_PERSAMPLE;
        -:  468:		else
    #####:  469:			tif->tif_flags &= ~TIFF_PERSAMPLE;
    #####:  470:		break;
        1:  471:	default: {
        -:  472:		TIFFTagValue *tv;
        -:  473:		int tv_size, iCustom;
        -:  474:
        -:  475:		/*
        -:  476:		 * This can happen if multiple images are open with different
        -:  477:		 * codecs which have private tags.  The global tag information
        -:  478:		 * table may then have tags that are valid for one file but not
        -:  479:		 * the other. If the client tries to set a tag that is not valid
        -:  480:		 * for the image's codec then we'll arrive here.  This
        -:  481:		 * happens, for example, when tiffcp is used to convert between
        -:  482:		 * compression schemes and codec-specific tags are blindly copied.
        -:  483:		 */
        1:  484:		if(fip->field_bit != FIELD_CUSTOM) {
    #####:  485:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  486:			    "%s: Invalid %stag \"%s\" (not supported by codec)",
        -:  487:			    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "",
        -:  488:			    fip->field_name);
    #####:  489:			status = 0;
    #####:  490:			break;
        -:  491:		}
        -:  492:
        -:  493:		/*
        -:  494:		 * Find the existing entry for this custom value.
        -:  495:		 */
        1:  496:		tv = NULL;
       1*:  497:		for (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {
    #####:  498:			if (td->td_customValues[iCustom].info->field_tag == tag) {
    #####:  499:				tv = td->td_customValues + iCustom;
    #####:  500:				if (tv->value != NULL) {
    #####:  501:					_TIFFfree(tv->value);
    #####:  502:					tv->value = NULL;
        -:  503:				}
    #####:  504:				break;
        -:  505:			}
        -:  506:		}
        -:  507:
        -:  508:		/*
        -:  509:		 * Grow the custom list if the entry was not found.
        -:  510:		 */
        1:  511:		if(tv == NULL) {
        -:  512:			TIFFTagValue *new_customValues;
        -:  513:
        1:  514:			td->td_customValueCount++;
        -:  515:			new_customValues = (TIFFTagValue *)
        1:  516:			    _TIFFrealloc(td->td_customValues,
        1:  517:			    sizeof(TIFFTagValue) * td->td_customValueCount);
        1:  518:			if (!new_customValues) {
    #####:  519:				TIFFErrorExt(tif->tif_clientdata, module,
        -:  520:				    "%s: Failed to allocate space for list of custom values",
        -:  521:				    tif->tif_name);
    #####:  522:				status = 0;
    #####:  523:				goto end;
        -:  524:			}
        -:  525:
        1:  526:			td->td_customValues = new_customValues;
        -:  527:
        1:  528:			tv = td->td_customValues + (td->td_customValueCount - 1);
        1:  529:			tv->info = fip;
        1:  530:			tv->value = NULL;
        1:  531:			tv->count = 0;
        -:  532:		}
        -:  533:
        -:  534:		/*
        -:  535:		 * Set custom value ... save a copy of the custom tag value.
        -:  536:		 */
        1:  537:		tv_size = _TIFFDataSize(fip->field_type);
        1:  538:		if (tv_size == 0) {
    #####:  539:			status = 0;
    #####:  540:			TIFFErrorExt(tif->tif_clientdata, module,
        -:  541:			    "%s: Bad field type %d for \"%s\"",
    #####:  542:			    tif->tif_name, fip->field_type,
        -:  543:			    fip->field_name);
    #####:  544:			goto end;
        -:  545:		}
        -:  546:
        1:  547:		if (fip->field_type == TIFF_ASCII)
        -:  548:		{
        -:  549:			uint32 ma;
        -:  550:			char* mb;
        1:  551:			if (fip->field_passcount)
        -:  552:			{
    #####:  553:				assert(fip->field_writecount==TIFF_VARIABLE2);
    #####:  554:				ma=(uint32)va_arg(ap,uint32);
    #####:  555:				mb=(char*)va_arg(ap,char*);
        -:  556:			}
        -:  557:			else
        -:  558:			{
        1:  559:				mb=(char*)va_arg(ap,char*);
       1*:  560:				ma=(uint32)(strlen(mb)+1);
        -:  561:			}
        1:  562:			tv->count=ma;
        1:  563:			setByteArray(&tv->value,mb,ma,1);
        -:  564:		}
        -:  565:		else
        -:  566:		{
    #####:  567:			if (fip->field_passcount) {
    #####:  568:				if (fip->field_writecount == TIFF_VARIABLE2)
    #####:  569:					tv->count = (uint32) va_arg(ap, uint32);
        -:  570:				else
    #####:  571:					tv->count = (int) va_arg(ap, int);
    #####:  572:			} else if (fip->field_writecount == TIFF_VARIABLE
    #####:  573:			   || fip->field_writecount == TIFF_VARIABLE2)
    #####:  574:				tv->count = 1;
    #####:  575:			else if (fip->field_writecount == TIFF_SPP)
    #####:  576:				tv->count = td->td_samplesperpixel;
        -:  577:			else
    #####:  578:				tv->count = fip->field_writecount;
        -:  579:
    #####:  580:			if (tv->count == 0) {
    #####:  581:				status = 0;
    #####:  582:				TIFFErrorExt(tif->tif_clientdata, module,
        -:  583:					     "%s: Null count for \"%s\" (type "
        -:  584:					     "%d, writecount %d, passcount %d)",
        -:  585:					     tif->tif_name,
        -:  586:					     fip->field_name,
    #####:  587:					     fip->field_type,
    #####:  588:					     fip->field_writecount,
    #####:  589:					     fip->field_passcount);
    #####:  590:				goto end;
        -:  591:			}
        -:  592:
    #####:  593:			tv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,
        -:  594:			    "custom tag binary object");
    #####:  595:			if (!tv->value) {
    #####:  596:				status = 0;
    #####:  597:				goto end;
        -:  598:			}
        -:  599:
    #####:  600:			if (fip->field_tag == TIFFTAG_DOTRANGE 
    #####:  601:			    && strcmp(fip->field_name,"DotRange") == 0) {
        -:  602:				/* TODO: This is an evil exception and should not have been
        -:  603:				   handled this way ... likely best if we move it into
        -:  604:				   the directory structure with an explicit field in 
        -:  605:				   libtiff 4.1 and assign it a FIELD_ value */
    #####:  606:				uint16 v2[2];
    #####:  607:				v2[0] = (uint16)va_arg(ap, int);
    #####:  608:				v2[1] = (uint16)va_arg(ap, int);
    #####:  609:				_TIFFmemcpy(tv->value, &v2, 4);
        -:  610:			}
        -:  611:
    #####:  612:			else if (fip->field_passcount
    #####:  613:				  || fip->field_writecount == TIFF_VARIABLE
    #####:  614:				  || fip->field_writecount == TIFF_VARIABLE2
    #####:  615:				  || fip->field_writecount == TIFF_SPP
    #####:  616:				  || tv->count > 1) {
    #####:  617:				_TIFFmemcpy(tv->value, va_arg(ap, void *),
    #####:  618:				    tv->count * tv_size);
        -:  619:			} else {
    #####:  620:				char *val = (char *)tv->value;
    #####:  621:				assert( tv->count == 1 );
        -:  622:
    #####:  623:				switch (fip->field_type) {
    #####:  624:				case TIFF_BYTE:
        -:  625:				case TIFF_UNDEFINED:
        -:  626:					{
    #####:  627:						uint8 v2 = (uint8)va_arg(ap, int);
    #####:  628:						_TIFFmemcpy(val, &v2, tv_size);
        -:  629:					}
        -:  630:					break;
    #####:  631:				case TIFF_SBYTE:
        -:  632:					{
    #####:  633:						int8 v2 = (int8)va_arg(ap, int);
    #####:  634:						_TIFFmemcpy(val, &v2, tv_size);
        -:  635:					}
        -:  636:					break;
    #####:  637:				case TIFF_SHORT:
        -:  638:					{
    #####:  639:						uint16 v2 = (uint16)va_arg(ap, int);
    #####:  640:						_TIFFmemcpy(val, &v2, tv_size);
        -:  641:					}
        -:  642:					break;
    #####:  643:				case TIFF_SSHORT:
        -:  644:					{
    #####:  645:						int16 v2 = (int16)va_arg(ap, int);
    #####:  646:						_TIFFmemcpy(val, &v2, tv_size);
        -:  647:					}
        -:  648:					break;
    #####:  649:				case TIFF_LONG:
        -:  650:				case TIFF_IFD:
        -:  651:					{
    #####:  652:						uint32 v2 = va_arg(ap, uint32);
    #####:  653:						_TIFFmemcpy(val, &v2, tv_size);
        -:  654:					}
        -:  655:					break;
    #####:  656:				case TIFF_SLONG:
        -:  657:					{
    #####:  658:						int32 v2 = va_arg(ap, int32);
    #####:  659:						_TIFFmemcpy(val, &v2, tv_size);
        -:  660:					}
        -:  661:					break;
    #####:  662:				case TIFF_LONG8:
        -:  663:				case TIFF_IFD8:
        -:  664:					{
    #####:  665:						uint64 v2 = va_arg(ap, uint64);
    #####:  666:						_TIFFmemcpy(val, &v2, tv_size);
        -:  667:					}
        -:  668:					break;
    #####:  669:				case TIFF_SLONG8:
        -:  670:					{
    #####:  671:						int64 v2 = va_arg(ap, int64);
    #####:  672:						_TIFFmemcpy(val, &v2, tv_size);
        -:  673:					}
        -:  674:					break;
    #####:  675:				case TIFF_RATIONAL:
        -:  676:				case TIFF_SRATIONAL:
        -:  677:				case TIFF_FLOAT:
        -:  678:					{
    #####:  679:						float v2 = (float)va_arg(ap, double);
    #####:  680:						_TIFFmemcpy(val, &v2, tv_size);
        -:  681:					}
        -:  682:					break;
    #####:  683:				case TIFF_DOUBLE:
        -:  684:					{
    #####:  685:						double v2 = va_arg(ap, double);
    #####:  686:						_TIFFmemcpy(val, &v2, tv_size);
        -:  687:					}
        -:  688:					break;
    #####:  689:				default:
    #####:  690:					_TIFFmemset(val, 0, tv_size);
    #####:  691:					status = 0;
    #####:  692:					break;
        -:  693:				}
        -:  694:			}
        -:  695:		}
        -:  696:	}
        -:  697:	}
       19:  698:	if (status) {
       19:  699:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
       19:  700:		if (fip2)                
      19*:  701:			TIFFSetFieldBit(tif, fip2->field_bit);
       19:  702:		tif->tif_flags |= TIFF_DIRTYDIRECT;
        -:  703:	}
        -:  704:
      19*:  705:end:
       19:  706:	va_end(ap);
       19:  707:	return (status);
    #####:  708:badvalue:
        -:  709:        {
    #####:  710:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  711:		TIFFErrorExt(tif->tif_clientdata, module,
        -:  712:		     "%s: Bad value %u for \"%s\" tag",
        -:  713:		     tif->tif_name, v,
        -:  714:		     fip2 ? fip2->field_name : "Unknown");
    #####:  715:		va_end(ap);
        -:  716:        }
    #####:  717:	return (0);
    #####:  718:badvalue32:
        -:  719:        {
    #####:  720:		const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  721:		TIFFErrorExt(tif->tif_clientdata, module,
        -:  722:		     "%s: Bad value %u for \"%s\" tag",
        -:  723:		     tif->tif_name, v32,
        -:  724:		     fip2 ? fip2->field_name : "Unknown");
    #####:  725:		va_end(ap);
        -:  726:        }
    #####:  727:	return (0);
    #####:  728:badvaluedouble:
        -:  729:        {
    #####:  730:        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);
    #####:  731:        TIFFErrorExt(tif->tif_clientdata, module,
        -:  732:             "%s: Bad value %f for \"%s\" tag",
        -:  733:             tif->tif_name, dblval,
        -:  734:             fip2 ? fip2->field_name : "Unknown");
    #####:  735:        va_end(ap);
        -:  736:        }
    #####:  737:    return (0);
        -:  738:}
        -:  739:
        -:  740:/*
        -:  741: * Return 1/0 according to whether or not
        -:  742: * it is permissible to set the tag's value.
        -:  743: * Note that we allow ImageLength to be changed
        -:  744: * so that we can append and extend to images.
        -:  745: * Any other tag may not be altered once writing
        -:  746: * has commenced, unless its value has no effect
        -:  747: * on the format of the data that is written.
        -:  748: */
        -:  749:static int
       19:  750:OkToChangeTag(TIFF* tif, uint32 tag)
        -:  751:{
       19:  752:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
       19:  753:	if (!fip) {			/* unknown tag */
    #####:  754:		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField", "%s: Unknown %stag %u",
        -:  755:		    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "", tag);
    #####:  756:		return (0);
        -:  757:	}
      19*:  758:	if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&
    #####:  759:	    !fip->field_oktochange) {
        -:  760:		/*
        -:  761:		 * Consult info table to see if tag can be changed
        -:  762:		 * after we've started writing.  We only allow changes
        -:  763:		 * to those tags that don't/shouldn't affect the
        -:  764:		 * compression and/or format of the data.
        -:  765:		 */
    #####:  766:		TIFFErrorExt(tif->tif_clientdata, "TIFFSetField",
        -:  767:		    "%s: Cannot modify tag \"%s\" while writing",
        -:  768:		    tif->tif_name, fip->field_name);
    #####:  769:		return (0);
        -:  770:	}
       19:  771:	return (1);
        -:  772:}
        -:  773:
        -:  774:/*
        -:  775: * Record the value of a field in the
        -:  776: * internal directory structure.  The
        -:  777: * field will be written to the file
        -:  778: * when/if the directory structure is
        -:  779: * updated.
        -:  780: */
        -:  781:int
       19:  782:TIFFSetField(TIFF* tif, uint32 tag, ...)
        -:  783:{
       19:  784:	va_list ap;
        -:  785:	int status;
        -:  786:
       19:  787:	va_start(ap, tag);
       19:  788:	status = TIFFVSetField(tif, tag, ap);
       19:  789:	va_end(ap);
       19:  790:	return (status);
        -:  791:}
        -:  792:
        -:  793:/*
        -:  794: * Clear the contents of the field in the internal structure.
        -:  795: */
        -:  796:int
    #####:  797:TIFFUnsetField(TIFF* tif, uint32 tag)
        -:  798:{
    #####:  799:    const TIFFField *fip =  TIFFFieldWithTag(tif, tag);
    #####:  800:    TIFFDirectory* td = &tif->tif_dir;
        -:  801:
    #####:  802:    if( !fip )
    #####:  803:        return 0;
        -:  804:
    #####:  805:    if( fip->field_bit != FIELD_CUSTOM )
    #####:  806:        TIFFClrFieldBit(tif, fip->field_bit);
        -:  807:    else
        -:  808:    {
    #####:  809:        TIFFTagValue *tv = NULL;
        -:  810:        int i;
        -:  811:
    #####:  812:        for (i = 0; i < td->td_customValueCount; i++) {
        -:  813:                
    #####:  814:            tv = td->td_customValues + i;
    #####:  815:            if( tv->info->field_tag == tag )
    #####:  816:                break;
        -:  817:        }
        -:  818:
    #####:  819:        if( i < td->td_customValueCount )
        -:  820:        {
    #####:  821:            _TIFFfree(tv->value);
    #####:  822:            for( ; i < td->td_customValueCount-1; i++) {
    #####:  823:                td->td_customValues[i] = td->td_customValues[i+1];
        -:  824:            }
    #####:  825:            td->td_customValueCount--;
        -:  826:        }
        -:  827:    }
        -:  828:        
    #####:  829:    tif->tif_flags |= TIFF_DIRTYDIRECT;
        -:  830:
    #####:  831:    return (1);
        -:  832:}
        -:  833:
        -:  834:/*
        -:  835: * Like TIFFSetField, but taking a varargs
        -:  836: * parameter list.  This routine is useful
        -:  837: * for building higher-level interfaces on
        -:  838: * top of the library.
        -:  839: */
        -:  840:int
       19:  841:TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
        -:  842:{
       19:  843:	return OkToChangeTag(tif, tag) ?
      19*:  844:	    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;
        -:  845:}
        -:  846:
        -:  847:static int
        9:  848:_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
        -:  849:{
        9:  850:	TIFFDirectory* td = &tif->tif_dir;
        9:  851:	int ret_val = 1;
        9:  852:	uint32 standard_tag = tag;
        9:  853:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
        9:  854:	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */
    #####:  855:	    return 0;
        -:  856:	
        -:  857:	/*
        -:  858:	 * We want to force the custom code to be used for custom
        -:  859:	 * fields even if the tag happens to match a well known 
        -:  860:	 * one - important for reinterpreted handling of standard
        -:  861:	 * tag values in custom directories (i.e. EXIF) 
        -:  862:	 */
        9:  863:	if (fip->field_bit == FIELD_CUSTOM) {
    #####:  864:		standard_tag = 0;
        -:  865:	}
        -:  866:
        9:  867:	switch (standard_tag) {
    #####:  868:		case TIFFTAG_SUBFILETYPE:
    #####:  869:			*va_arg(ap, uint32*) = td->td_subfiletype;
    #####:  870:			break;
        2:  871:		case TIFFTAG_IMAGEWIDTH:
        2:  872:			*va_arg(ap, uint32*) = td->td_imagewidth;
        2:  873:			break;
        1:  874:		case TIFFTAG_IMAGELENGTH:
        1:  875:			*va_arg(ap, uint32*) = td->td_imagelength;
        1:  876:			break;
        1:  877:		case TIFFTAG_BITSPERSAMPLE:
        1:  878:			*va_arg(ap, uint16*) = td->td_bitspersample;
        1:  879:			break;
        1:  880:		case TIFFTAG_COMPRESSION:
        1:  881:			*va_arg(ap, uint16*) = td->td_compression;
        1:  882:			break;
        1:  883:		case TIFFTAG_PHOTOMETRIC:
        1:  884:			*va_arg(ap, uint16*) = td->td_photometric;
        1:  885:			break;
    #####:  886:		case TIFFTAG_THRESHHOLDING:
    #####:  887:			*va_arg(ap, uint16*) = td->td_threshholding;
    #####:  888:			break;
    #####:  889:		case TIFFTAG_FILLORDER:
    #####:  890:			*va_arg(ap, uint16*) = td->td_fillorder;
    #####:  891:			break;
    #####:  892:		case TIFFTAG_ORIENTATION:
    #####:  893:			*va_arg(ap, uint16*) = td->td_orientation;
    #####:  894:			break;
        1:  895:		case TIFFTAG_SAMPLESPERPIXEL:
        1:  896:			*va_arg(ap, uint16*) = td->td_samplesperpixel;
        1:  897:			break;
    #####:  898:		case TIFFTAG_ROWSPERSTRIP:
    #####:  899:			*va_arg(ap, uint32*) = td->td_rowsperstrip;
    #####:  900:			break;
    #####:  901:		case TIFFTAG_MINSAMPLEVALUE:
    #####:  902:			*va_arg(ap, uint16*) = td->td_minsamplevalue;
    #####:  903:			break;
    #####:  904:		case TIFFTAG_MAXSAMPLEVALUE:
    #####:  905:			*va_arg(ap, uint16*) = td->td_maxsamplevalue;
    #####:  906:			break;
    #####:  907:		case TIFFTAG_SMINSAMPLEVALUE:
    #####:  908:			if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  909:				*va_arg(ap, double**) = td->td_sminsamplevalue;
        -:  910:			else
        -:  911:			{
        -:  912:				/* libtiff historically treats this as a single value. */
        -:  913:				uint16 i;
    #####:  914:				double v = td->td_sminsamplevalue[0];
    #####:  915:				for (i=1; i < td->td_samplesperpixel; ++i)
    #####:  916:					if( td->td_sminsamplevalue[i] < v )
    #####:  917:						v = td->td_sminsamplevalue[i];
    #####:  918:				*va_arg(ap, double*) = v;
        -:  919:			}
    #####:  920:			break;
    #####:  921:		case TIFFTAG_SMAXSAMPLEVALUE:
    #####:  922:			if (tif->tif_flags & TIFF_PERSAMPLE)
    #####:  923:				*va_arg(ap, double**) = td->td_smaxsamplevalue;
        -:  924:			else
        -:  925:			{
        -:  926:				/* libtiff historically treats this as a single value. */
        -:  927:				uint16 i;
    #####:  928:				double v = td->td_smaxsamplevalue[0];
    #####:  929:				for (i=1; i < td->td_samplesperpixel; ++i)
    #####:  930:					if( td->td_smaxsamplevalue[i] > v )
    #####:  931:						v = td->td_smaxsamplevalue[i];
    #####:  932:				*va_arg(ap, double*) = v;
        -:  933:			}
    #####:  934:			break;
    #####:  935:		case TIFFTAG_XRESOLUTION:
    #####:  936:			*va_arg(ap, float*) = td->td_xresolution;
    #####:  937:			break;
    #####:  938:		case TIFFTAG_YRESOLUTION:
    #####:  939:			*va_arg(ap, float*) = td->td_yresolution;
    #####:  940:			break;
        2:  941:		case TIFFTAG_PLANARCONFIG:
        2:  942:			*va_arg(ap, uint16*) = td->td_planarconfig;
        2:  943:			break;
    #####:  944:		case TIFFTAG_XPOSITION:
    #####:  945:			*va_arg(ap, float*) = td->td_xposition;
    #####:  946:			break;
    #####:  947:		case TIFFTAG_YPOSITION:
    #####:  948:			*va_arg(ap, float*) = td->td_yposition;
    #####:  949:			break;
    #####:  950:		case TIFFTAG_RESOLUTIONUNIT:
    #####:  951:			*va_arg(ap, uint16*) = td->td_resolutionunit;
    #####:  952:			break;
    #####:  953:		case TIFFTAG_PAGENUMBER:
    #####:  954:			*va_arg(ap, uint16*) = td->td_pagenumber[0];
    #####:  955:			*va_arg(ap, uint16*) = td->td_pagenumber[1];
    #####:  956:			break;
    #####:  957:		case TIFFTAG_HALFTONEHINTS:
    #####:  958:			*va_arg(ap, uint16*) = td->td_halftonehints[0];
    #####:  959:			*va_arg(ap, uint16*) = td->td_halftonehints[1];
    #####:  960:			break;
    #####:  961:		case TIFFTAG_COLORMAP:
    #####:  962:			*va_arg(ap, uint16**) = td->td_colormap[0];
    #####:  963:			*va_arg(ap, uint16**) = td->td_colormap[1];
    #####:  964:			*va_arg(ap, uint16**) = td->td_colormap[2];
    #####:  965:			break;
    #####:  966:		case TIFFTAG_STRIPOFFSETS:
        -:  967:		case TIFFTAG_TILEOFFSETS:
    #####:  968:			_TIFFFillStriles( tif );
    #####:  969:			*va_arg(ap, uint64**) = td->td_stripoffset;
    #####:  970:			break;
    #####:  971:		case TIFFTAG_STRIPBYTECOUNTS:
        -:  972:		case TIFFTAG_TILEBYTECOUNTS:
    #####:  973:			_TIFFFillStriles( tif );
    #####:  974:			*va_arg(ap, uint64**) = td->td_stripbytecount;
    #####:  975:			break;
    #####:  976:		case TIFFTAG_MATTEING:
    #####:  977:			*va_arg(ap, uint16*) =
    #####:  978:			    (td->td_extrasamples == 1 &&
    #####:  979:			    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
    #####:  980:			break;
    #####:  981:		case TIFFTAG_EXTRASAMPLES:
    #####:  982:			*va_arg(ap, uint16*) = td->td_extrasamples;
    #####:  983:			*va_arg(ap, uint16**) = td->td_sampleinfo;
    #####:  984:			break;
    #####:  985:		case TIFFTAG_TILEWIDTH:
    #####:  986:			*va_arg(ap, uint32*) = td->td_tilewidth;
    #####:  987:			break;
    #####:  988:		case TIFFTAG_TILELENGTH:
    #####:  989:			*va_arg(ap, uint32*) = td->td_tilelength;
    #####:  990:			break;
    #####:  991:		case TIFFTAG_TILEDEPTH:
    #####:  992:			*va_arg(ap, uint32*) = td->td_tiledepth;
    #####:  993:			break;
    #####:  994:		case TIFFTAG_DATATYPE:
    #####:  995:			switch (td->td_sampleformat) {
    #####:  996:				case SAMPLEFORMAT_UINT:
    #####:  997:					*va_arg(ap, uint16*) = DATATYPE_UINT;
    #####:  998:					break;
    #####:  999:				case SAMPLEFORMAT_INT:
    #####: 1000:					*va_arg(ap, uint16*) = DATATYPE_INT;
    #####: 1001:					break;
    #####: 1002:				case SAMPLEFORMAT_IEEEFP:
    #####: 1003:					*va_arg(ap, uint16*) = DATATYPE_IEEEFP;
    #####: 1004:					break;
    #####: 1005:				case SAMPLEFORMAT_VOID:
    #####: 1006:					*va_arg(ap, uint16*) = DATATYPE_VOID;
    #####: 1007:					break;
        -: 1008:			}
    #####: 1009:			break;
    #####: 1010:		case TIFFTAG_SAMPLEFORMAT:
    #####: 1011:			*va_arg(ap, uint16*) = td->td_sampleformat;
    #####: 1012:			break;
    #####: 1013:		case TIFFTAG_IMAGEDEPTH:
    #####: 1014:			*va_arg(ap, uint32*) = td->td_imagedepth;
    #####: 1015:			break;
    #####: 1016:		case TIFFTAG_SUBIFD:
    #####: 1017:			*va_arg(ap, uint16*) = td->td_nsubifd;
    #####: 1018:			*va_arg(ap, uint64**) = td->td_subifd;
    #####: 1019:			break;
    #####: 1020:		case TIFFTAG_YCBCRPOSITIONING:
    #####: 1021:			*va_arg(ap, uint16*) = td->td_ycbcrpositioning;
    #####: 1022:			break;
    #####: 1023:		case TIFFTAG_YCBCRSUBSAMPLING:
    #####: 1024:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];
    #####: 1025:			*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];
    #####: 1026:			break;
    #####: 1027:		case TIFFTAG_TRANSFERFUNCTION:
    #####: 1028:			*va_arg(ap, uint16**) = td->td_transferfunction[0];
    #####: 1029:			if (td->td_samplesperpixel - td->td_extrasamples > 1) {
    #####: 1030:				*va_arg(ap, uint16**) = td->td_transferfunction[1];
    #####: 1031:				*va_arg(ap, uint16**) = td->td_transferfunction[2];
        -: 1032:			}
    #####: 1033:			break;
    #####: 1034:		case TIFFTAG_REFERENCEBLACKWHITE:
    #####: 1035:			*va_arg(ap, float**) = td->td_refblackwhite;
    #####: 1036:			break;
    #####: 1037:		case TIFFTAG_INKNAMES:
    #####: 1038:			*va_arg(ap, char**) = td->td_inknames;
    #####: 1039:			break;
    #####: 1040:		default:
        -: 1041:			{
        -: 1042:				int i;
        -: 1043:
        -: 1044:				/*
        -: 1045:				 * This can happen if multiple images are open
        -: 1046:				 * with different codecs which have private
        -: 1047:				 * tags.  The global tag information table may
        -: 1048:				 * then have tags that are valid for one file
        -: 1049:				 * but not the other. If the client tries to
        -: 1050:				 * get a tag that is not valid for the image's
        -: 1051:				 * codec then we'll arrive here.
        -: 1052:				 */
    #####: 1053:				if( fip->field_bit != FIELD_CUSTOM )
        -: 1054:				{
    #####: 1055:					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
        -: 1056:					    "%s: Invalid %stag \"%s\" "
        -: 1057:					    "(not supported by codec)",
        -: 1058:					    tif->tif_name,
        -: 1059:					    isPseudoTag(tag) ? "pseudo-" : "",
        -: 1060:					    fip->field_name);
    #####: 1061:					ret_val = 0;
    #####: 1062:					break;
        -: 1063:				}
        -: 1064:
        -: 1065:				/*
        -: 1066:				 * Do we have a custom value?
        -: 1067:				 */
    #####: 1068:				ret_val = 0;
    #####: 1069:				for (i = 0; i < td->td_customValueCount; i++) {
    #####: 1070:					TIFFTagValue *tv = td->td_customValues + i;
        -: 1071:
    #####: 1072:					if (tv->info->field_tag != tag)
    #####: 1073:						continue;
        -: 1074:
    #####: 1075:					if (fip->field_passcount) {
    #####: 1076:						if (fip->field_readcount == TIFF_VARIABLE2)
    #####: 1077:							*va_arg(ap, uint32*) = (uint32)tv->count;
        -: 1078:						else  /* Assume TIFF_VARIABLE */
    #####: 1079:							*va_arg(ap, uint16*) = (uint16)tv->count;
    #####: 1080:						*va_arg(ap, void **) = tv->value;
    #####: 1081:						ret_val = 1;
    #####: 1082:					} else if (fip->field_tag == TIFFTAG_DOTRANGE
    #####: 1083:						   && strcmp(fip->field_name,"DotRange") == 0) {
        -: 1084:						/* TODO: This is an evil exception and should not have been
        -: 1085:						   handled this way ... likely best if we move it into
        -: 1086:						   the directory structure with an explicit field in 
        -: 1087:						   libtiff 4.1 and assign it a FIELD_ value */
    #####: 1088:						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];
    #####: 1089:						*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];
    #####: 1090:						ret_val = 1;
        -: 1091:					} else {
    #####: 1092:						if (fip->field_type == TIFF_ASCII
    #####: 1093:						    || fip->field_readcount == TIFF_VARIABLE
    #####: 1094:						    || fip->field_readcount == TIFF_VARIABLE2
    #####: 1095:						    || fip->field_readcount == TIFF_SPP
    #####: 1096:						    || tv->count > 1) {
    #####: 1097:							*va_arg(ap, void **) = tv->value;
    #####: 1098:							ret_val = 1;
        -: 1099:						} else {
    #####: 1100:							char *val = (char *)tv->value;
    #####: 1101:							assert( tv->count == 1 );
    #####: 1102:							switch (fip->field_type) {
    #####: 1103:							case TIFF_BYTE:
        -: 1104:							case TIFF_UNDEFINED:
    #####: 1105:								*va_arg(ap, uint8*) =
    #####: 1106:									*(uint8 *)val;
    #####: 1107:								ret_val = 1;
    #####: 1108:								break;
    #####: 1109:							case TIFF_SBYTE:
    #####: 1110:								*va_arg(ap, int8*) =
    #####: 1111:									*(int8 *)val;
    #####: 1112:								ret_val = 1;
    #####: 1113:								break;
    #####: 1114:							case TIFF_SHORT:
    #####: 1115:								*va_arg(ap, uint16*) =
    #####: 1116:									*(uint16 *)val;
    #####: 1117:								ret_val = 1;
    #####: 1118:								break;
    #####: 1119:							case TIFF_SSHORT:
    #####: 1120:								*va_arg(ap, int16*) =
    #####: 1121:									*(int16 *)val;
    #####: 1122:								ret_val = 1;
    #####: 1123:								break;
    #####: 1124:							case TIFF_LONG:
        -: 1125:							case TIFF_IFD:
    #####: 1126:								*va_arg(ap, uint32*) =
    #####: 1127:									*(uint32 *)val;
    #####: 1128:								ret_val = 1;
    #####: 1129:								break;
    #####: 1130:							case TIFF_SLONG:
    #####: 1131:								*va_arg(ap, int32*) =
    #####: 1132:									*(int32 *)val;
    #####: 1133:								ret_val = 1;
    #####: 1134:								break;
    #####: 1135:							case TIFF_LONG8:
        -: 1136:							case TIFF_IFD8:
    #####: 1137:								*va_arg(ap, uint64*) =
    #####: 1138:									*(uint64 *)val;
    #####: 1139:								ret_val = 1;
    #####: 1140:								break;
    #####: 1141:							case TIFF_SLONG8:
    #####: 1142:								*va_arg(ap, int64*) =
    #####: 1143:									*(int64 *)val;
    #####: 1144:								ret_val = 1;
    #####: 1145:								break;
    #####: 1146:							case TIFF_RATIONAL:
        -: 1147:							case TIFF_SRATIONAL:
        -: 1148:							case TIFF_FLOAT:
    #####: 1149:								*va_arg(ap, float*) =
    #####: 1150:									*(float *)val;
    #####: 1151:								ret_val = 1;
    #####: 1152:								break;
    #####: 1153:							case TIFF_DOUBLE:
    #####: 1154:								*va_arg(ap, double*) =
    #####: 1155:									*(double *)val;
    #####: 1156:								ret_val = 1;
    #####: 1157:								break;
    #####: 1158:							default:
    #####: 1159:								ret_val = 0;
    #####: 1160:								break;
        -: 1161:							}
        -: 1162:						}
        -: 1163:					}
    #####: 1164:					break;
        -: 1165:				}
        -: 1166:			}
        -: 1167:	}
        9: 1168:	return(ret_val);
        -: 1169:}
        -: 1170:
        -: 1171:/*
        -: 1172: * Return the value of a field in the
        -: 1173: * internal directory structure.
        -: 1174: */
        -: 1175:int
       18: 1176:TIFFGetField(TIFF* tif, uint32 tag, ...)
        -: 1177:{
        -: 1178:	int status;
       18: 1179:	va_list ap;
        -: 1180:
       18: 1181:	va_start(ap, tag);
       18: 1182:	status = TIFFVGetField(tif, tag, ap);
       18: 1183:	va_end(ap);
       18: 1184:	return (status);
        -: 1185:}
        -: 1186:
        -: 1187:/*
        -: 1188: * Like TIFFGetField, but taking a varargs
        -: 1189: * parameter list.  This routine is useful
        -: 1190: * for building higher-level interfaces on
        -: 1191: * top of the library.
        -: 1192: */
        -: 1193:int
       18: 1194:TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
        -: 1195:{
       18: 1196:	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
      18*: 1197:	return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?
       36: 1198:	    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);
        -: 1199:}
        -: 1200:
        -: 1201:#define	CleanupField(member) {		\
        -: 1202:    if (td->member) {			\
        -: 1203:	_TIFFfree(td->member);		\
        -: 1204:	td->member = 0;			\
        -: 1205:    }					\
        -: 1206:}
        -: 1207:
        -: 1208:/*
        -: 1209: * Release storage associated with a directory.
        -: 1210: */
        -: 1211:void
        1: 1212:TIFFFreeDirectory(TIFF* tif)
        -: 1213:{
        1: 1214:	TIFFDirectory *td = &tif->tif_dir;
        -: 1215:	int            i;
        -: 1216:
        1: 1217:	_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);
       1*: 1218:	CleanupField(td_sminsamplevalue);
       1*: 1219:	CleanupField(td_smaxsamplevalue);
       1*: 1220:	CleanupField(td_colormap[0]);
       1*: 1221:	CleanupField(td_colormap[1]);
       1*: 1222:	CleanupField(td_colormap[2]);
       1*: 1223:	CleanupField(td_sampleinfo);
       1*: 1224:	CleanupField(td_subifd);
       1*: 1225:	CleanupField(td_inknames);
       1*: 1226:	CleanupField(td_refblackwhite);
       1*: 1227:	CleanupField(td_transferfunction[0]);
       1*: 1228:	CleanupField(td_transferfunction[1]);
       1*: 1229:	CleanupField(td_transferfunction[2]);
       1*: 1230:	CleanupField(td_stripoffset);
       1*: 1231:	CleanupField(td_stripbytecount);
        1: 1232:	TIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);
        1: 1233:	TIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);
        -: 1234:
        -: 1235:	/* Cleanup custom tag values */
       1*: 1236:	for( i = 0; i < td->td_customValueCount; i++ ) {
    #####: 1237:		if (td->td_customValues[i].value)
    #####: 1238:			_TIFFfree(td->td_customValues[i].value);
        -: 1239:	}
        -: 1240:
        1: 1241:	td->td_customValueCount = 0;
       1*: 1242:	CleanupField(td_customValues);
        -: 1243:
        -: 1244:#if defined(DEFER_STRILE_LOAD)
        -: 1245:        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));
        -: 1246:        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));
        -: 1247:#endif        
        1: 1248:}
        -: 1249:#undef CleanupField
        -: 1250:
        -: 1251:/*
        -: 1252: * Client Tag extension support (from Niles Ritter).
        -: 1253: */
        -: 1254:static TIFFExtendProc _TIFFextender = (TIFFExtendProc) NULL;
        -: 1255:
        -: 1256:TIFFExtendProc
    #####: 1257:TIFFSetTagExtender(TIFFExtendProc extender)
        -: 1258:{
    #####: 1259:	TIFFExtendProc prev = _TIFFextender;
    #####: 1260:	_TIFFextender = extender;
    #####: 1261:	return (prev);
        -: 1262:}
        -: 1263:
        -: 1264:/*
        -: 1265: * Setup for a new directory.  Should we automatically call
        -: 1266: * TIFFWriteDirectory() if the current one is dirty?
        -: 1267: *
        -: 1268: * The newly created directory will not exist on the file till
        -: 1269: * TIFFWriteDirectory(), TIFFFlush() or TIFFClose() is called.
        -: 1270: */
        -: 1271:int
    #####: 1272:TIFFCreateDirectory(TIFF* tif)
        -: 1273:{
    #####: 1274:	TIFFDefaultDirectory(tif);
    #####: 1275:	tif->tif_diroff = 0;
    #####: 1276:	tif->tif_nextdiroff = 0;
    #####: 1277:	tif->tif_curoff = 0;
    #####: 1278:	tif->tif_row = (uint32) -1;
    #####: 1279:	tif->tif_curstrip = (uint32) -1;
        -: 1280:
    #####: 1281:	return 0;
        -: 1282:}
        -: 1283:
        -: 1284:int
    #####: 1285:TIFFCreateCustomDirectory(TIFF* tif, const TIFFFieldArray* infoarray)
        -: 1286:{
    #####: 1287:	TIFFDefaultDirectory(tif);
        -: 1288:
        -: 1289:	/*
        -: 1290:	 * Reset the field definitions to match the application provided list. 
        -: 1291:	 * Hopefully TIFFDefaultDirectory() won't have done anything irreversable
        -: 1292:	 * based on it's assumption this is an image directory.
        -: 1293:	 */
    #####: 1294:	_TIFFSetupFields(tif, infoarray);
        -: 1295:
    #####: 1296:	tif->tif_diroff = 0;
    #####: 1297:	tif->tif_nextdiroff = 0;
    #####: 1298:	tif->tif_curoff = 0;
    #####: 1299:	tif->tif_row = (uint32) -1;
    #####: 1300:	tif->tif_curstrip = (uint32) -1;
        -: 1301:
    #####: 1302:	return 0;
        -: 1303:}
        -: 1304:
        -: 1305:int
    #####: 1306:TIFFCreateEXIFDirectory(TIFF* tif)
        -: 1307:{
        -: 1308:	const TIFFFieldArray* exifFieldArray;
    #####: 1309:	exifFieldArray = _TIFFGetExifFields();
    #####: 1310:	return TIFFCreateCustomDirectory(tif, exifFieldArray);
        -: 1311:}
        -: 1312:
        -: 1313:/*
        -: 1314: * Setup a default directory structure.
        -: 1315: */
        -: 1316:int
        2: 1317:TIFFDefaultDirectory(TIFF* tif)
        -: 1318:{
        2: 1319:	register TIFFDirectory* td = &tif->tif_dir;
        -: 1320:	const TIFFFieldArray* tiffFieldArray;
        -: 1321:
        2: 1322:	tiffFieldArray = _TIFFGetFields();
        2: 1323:	_TIFFSetupFields(tif, tiffFieldArray);   
        -: 1324:
        2: 1325:	_TIFFmemset(td, 0, sizeof (*td));
        2: 1326:	td->td_fillorder = FILLORDER_MSB2LSB;
        2: 1327:	td->td_bitspersample = 1;
        2: 1328:	td->td_threshholding = THRESHHOLD_BILEVEL;
        2: 1329:	td->td_orientation = ORIENTATION_TOPLEFT;
        2: 1330:	td->td_samplesperpixel = 1;
        2: 1331:	td->td_rowsperstrip = (uint32) -1;
        2: 1332:	td->td_tilewidth = 0;
        2: 1333:	td->td_tilelength = 0;
        2: 1334:	td->td_tiledepth = 1;
        2: 1335:	td->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  
        2: 1336:	td->td_resolutionunit = RESUNIT_INCH;
        2: 1337:	td->td_sampleformat = SAMPLEFORMAT_UINT;
        2: 1338:	td->td_imagedepth = 1;
        2: 1339:	td->td_ycbcrsubsampling[0] = 2;
        2: 1340:	td->td_ycbcrsubsampling[1] = 2;
        2: 1341:	td->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;
        2: 1342:	tif->tif_postdecode = _TIFFNoPostDecode;  
        2: 1343:	tif->tif_foundfield = NULL;
        2: 1344:	tif->tif_tagmethods.vsetfield = _TIFFVSetField;  
        2: 1345:	tif->tif_tagmethods.vgetfield = _TIFFVGetField;
        2: 1346:	tif->tif_tagmethods.printdir = NULL;
        -: 1347:	/*
        -: 1348:	 *  Give client code a chance to install their own
        -: 1349:	 *  tag extensions & methods, prior to compression overloads,
        -: 1350:	 *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)
        -: 1351:	 */
        2: 1352:	if (tif->tif_nfieldscompat > 0) {
        -: 1353:		uint32 i;
        -: 1354:
    #####: 1355:		for (i = 0; i < tif->tif_nfieldscompat; i++) {
    #####: 1356:				if (tif->tif_fieldscompat[i].allocated_size)
    #####: 1357:						_TIFFfree(tif->tif_fieldscompat[i].fields);
        -: 1358:		}
    #####: 1359:		_TIFFfree(tif->tif_fieldscompat);
    #####: 1360:		tif->tif_nfieldscompat = 0;
    #####: 1361:		tif->tif_fieldscompat = NULL;
        -: 1362:	}
        2: 1363:	if (_TIFFextender)
    #####: 1364:		(*_TIFFextender)(tif);
        2: 1365:	(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
        -: 1366:	/*
        -: 1367:	 * NB: The directory is marked dirty as a result of setting
        -: 1368:	 * up the default compression scheme.  However, this really
        -: 1369:	 * isn't correct -- we want TIFF_DIRTYDIRECT to be set only
        -: 1370:	 * if the user does something.  We could just do the setup
        -: 1371:	 * by hand, but it seems better to use the normal mechanism
        -: 1372:	 * (i.e. TIFFSetField).
        -: 1373:	 */
        2: 1374:	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
        -: 1375:
        -: 1376:	/*
        -: 1377:	 * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19
        -: 1378:	 * we clear the ISTILED flag when setting up a new directory.
        -: 1379:	 * Should we also be clearing stuff like INSUBIFD?
        -: 1380:	 */
        2: 1381:	tif->tif_flags &= ~TIFF_ISTILED;
        -: 1382:
        2: 1383:	return (1);
        -: 1384:}
        -: 1385:
        -: 1386:static int
    #####: 1387:TIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)
        -: 1388:{
        -: 1389:	static const char module[] = "TIFFAdvanceDirectory";
    #####: 1390:	if (isMapped(tif))
        -: 1391:	{
    #####: 1392:		uint64 poff=*nextdir;
    #####: 1393:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1394:		{
        -: 1395:			tmsize_t poffa,poffb,poffc,poffd;
    #####: 1396:			uint16 dircount;
    #####: 1397:			uint32 nextdir32;
    #####: 1398:			poffa=(tmsize_t)poff;
    #####: 1399:			poffb=poffa+sizeof(uint16);
    #####: 1400:			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))
        -: 1401:			{
    #####: 1402:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
    #####: 1403:                                  *nextdir=0;
    #####: 1404:				return(0);
        -: 1405:			}
    #####: 1406:			_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));
    #####: 1407:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1408:				TIFFSwabShort(&dircount);
    #####: 1409:			poffc=poffb+dircount*12;
    #####: 1410:			poffd=poffc+sizeof(uint32);
    #####: 1411:			if ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))
        -: 1412:			{
    #####: 1413:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
    #####: 1414:				return(0);
        -: 1415:			}
    #####: 1416:			if (off!=NULL)
    #####: 1417:				*off=(uint64)poffc;
    #####: 1418:			_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));
    #####: 1419:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1420:				TIFFSwabLong(&nextdir32);
    #####: 1421:			*nextdir=nextdir32;
        -: 1422:		}
        -: 1423:		else
        -: 1424:		{
        -: 1425:			tmsize_t poffa,poffb,poffc,poffd;
    #####: 1426:			uint64 dircount64;
        -: 1427:			uint16 dircount16;
    #####: 1428:			poffa=(tmsize_t)poff;
    #####: 1429:			poffb=poffa+sizeof(uint64);
    #####: 1430:			if (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))
        -: 1431:			{
    #####: 1432:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory count");
    #####: 1433:				return(0);
        -: 1434:			}
    #####: 1435:			_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));
    #####: 1436:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1437:				TIFFSwabLong8(&dircount64);
    #####: 1438:			if (dircount64>0xFFFF)
        -: 1439:			{
    #####: 1440:				TIFFErrorExt(tif->tif_clientdata,module,"Sanity check on directory count failed");
    #####: 1441:				return(0);
        -: 1442:			}
    #####: 1443:			dircount16=(uint16)dircount64;
    #####: 1444:			poffc=poffb+dircount16*20;
    #####: 1445:			poffd=poffc+sizeof(uint64);
    #####: 1446:			if ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))
        -: 1447:			{
    #####: 1448:				TIFFErrorExt(tif->tif_clientdata,module,"Error fetching directory link");
    #####: 1449:				return(0);
        -: 1450:			}
    #####: 1451:			if (off!=NULL)
    #####: 1452:				*off=(uint64)poffc;
    #####: 1453:			_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));
    #####: 1454:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1455:				TIFFSwabLong8(nextdir);
        -: 1456:		}
    #####: 1457:		return(1);
        -: 1458:	}
        -: 1459:	else
        -: 1460:	{
    #####: 1461:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1462:		{
    #####: 1463:			uint16 dircount;
    #####: 1464:			uint32 nextdir32;
    #####: 1465:			if (!SeekOK(tif, *nextdir) ||
    #####: 1466:			    !ReadOK(tif, &dircount, sizeof (uint16))) {
    #####: 1467:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
        -: 1468:				    tif->tif_name);
    #####: 1469:				return (0);
        -: 1470:			}
    #####: 1471:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1472:				TIFFSwabShort(&dircount);
    #####: 1473:			if (off != NULL)
    #####: 1474:				*off = TIFFSeekFile(tif,
        -: 1475:				    dircount*12, SEEK_CUR);
        -: 1476:			else
    #####: 1477:				(void) TIFFSeekFile(tif,
        -: 1478:				    dircount*12, SEEK_CUR);
    #####: 1479:			if (!ReadOK(tif, &nextdir32, sizeof (uint32))) {
    #####: 1480:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory link",
        -: 1481:				    tif->tif_name);
    #####: 1482:				return (0);
        -: 1483:			}
    #####: 1484:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1485:				TIFFSwabLong(&nextdir32);
    #####: 1486:			*nextdir=nextdir32;
        -: 1487:		}
        -: 1488:		else
        -: 1489:		{
    #####: 1490:			uint64 dircount64;
        -: 1491:			uint16 dircount16;
    #####: 1492:			if (!SeekOK(tif, *nextdir) ||
    #####: 1493:			    !ReadOK(tif, &dircount64, sizeof (uint64))) {
    #####: 1494:				TIFFErrorExt(tif->tif_clientdata, module, "%s: Error fetching directory count",
        -: 1495:				    tif->tif_name);
    #####: 1496:				return (0);
        -: 1497:			}
    #####: 1498:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1499:				TIFFSwabLong8(&dircount64);
    #####: 1500:			if (dircount64>0xFFFF)
        -: 1501:			{
    #####: 1502:				TIFFErrorExt(tif->tif_clientdata, module, "Error fetching directory count");
    #####: 1503:				return(0);
        -: 1504:			}
    #####: 1505:			dircount16 = (uint16)dircount64;
    #####: 1506:			if (off != NULL)
    #####: 1507:				*off = TIFFSeekFile(tif,
        -: 1508:				    dircount16*20, SEEK_CUR);
        -: 1509:			else
    #####: 1510:				(void) TIFFSeekFile(tif,
        -: 1511:				    dircount16*20, SEEK_CUR);
    #####: 1512:			if (!ReadOK(tif, nextdir, sizeof (uint64))) {
    #####: 1513:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 1514:                                             "%s: Error fetching directory link",
        -: 1515:				    tif->tif_name);
    #####: 1516:				return (0);
        -: 1517:			}
    #####: 1518:			if (tif->tif_flags & TIFF_SWAB)
    #####: 1519:				TIFFSwabLong8(nextdir);
        -: 1520:		}
    #####: 1521:		return (1);
        -: 1522:	}
        -: 1523:}
        -: 1524:
        -: 1525:/*
        -: 1526: * Count the number of directories in a file.
        -: 1527: */
        -: 1528:uint16
    #####: 1529:TIFFNumberOfDirectories(TIFF* tif)
        -: 1530:{
        -: 1531:	static const char module[] = "TIFFNumberOfDirectories";
    #####: 1532:	uint64 nextdir;
        -: 1533:	uint16 n;
    #####: 1534:	if (!(tif->tif_flags&TIFF_BIGTIFF))
    #####: 1535:		nextdir = tif->tif_header.classic.tiff_diroff;
        -: 1536:	else
    #####: 1537:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1538:	n = 0;
    #####: 1539:	while (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))
        -: 1540:        {
    #####: 1541:                if (n != 65535) {
    #####: 1542:                        ++n;
        -: 1543:                }
        -: 1544:		else
        -: 1545:                {
    #####: 1546:                        TIFFErrorExt(tif->tif_clientdata, module,
        -: 1547:                                     "Directory count exceeded 65535 limit,"
        -: 1548:                                     " giving up on counting.");
    #####: 1549:                        return (65535);
        -: 1550:                }
        -: 1551:        }
    #####: 1552:	return (n);
        -: 1553:}
        -: 1554:
        -: 1555:/*
        -: 1556: * Set the n-th directory as the current directory.
        -: 1557: * NB: Directories are numbered starting at 0.
        -: 1558: */
        -: 1559:int
    #####: 1560:TIFFSetDirectory(TIFF* tif, uint16 dirn)
        -: 1561:{
    #####: 1562:	uint64 nextdir;
        -: 1563:	uint16 n;
        -: 1564:
    #####: 1565:	if (!(tif->tif_flags&TIFF_BIGTIFF))
    #####: 1566:		nextdir = tif->tif_header.classic.tiff_diroff;
        -: 1567:	else
    #####: 1568:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1569:	for (n = dirn; n > 0 && nextdir != 0; n--)
    #####: 1570:		if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
    #####: 1571:			return (0);
    #####: 1572:	tif->tif_nextdiroff = nextdir;
        -: 1573:	/*
        -: 1574:	 * Set curdir to the actual directory index.  The
        -: 1575:	 * -1 is because TIFFReadDirectory will increment
        -: 1576:	 * tif_curdir after successfully reading the directory.
        -: 1577:	 */
    #####: 1578:	tif->tif_curdir = (dirn - n) - 1;
        -: 1579:	/*
        -: 1580:	 * Reset tif_dirnumber counter and start new list of seen directories.
        -: 1581:	 * We need this to prevent IFD loops.
        -: 1582:	 */
    #####: 1583:	tif->tif_dirnumber = 0;
    #####: 1584:	return (TIFFReadDirectory(tif));
        -: 1585:}
        -: 1586:
        -: 1587:/*
        -: 1588: * Set the current directory to be the directory
        -: 1589: * located at the specified file offset.  This interface
        -: 1590: * is used mainly to access directories linked with
        -: 1591: * the SubIFD tag (e.g. thumbnail images).
        -: 1592: */
        -: 1593:int
    #####: 1594:TIFFSetSubDirectory(TIFF* tif, uint64 diroff)
        -: 1595:{
    #####: 1596:	tif->tif_nextdiroff = diroff;
        -: 1597:	/*
        -: 1598:	 * Reset tif_dirnumber counter and start new list of seen directories.
        -: 1599:	 * We need this to prevent IFD loops.
        -: 1600:	 */
    #####: 1601:	tif->tif_dirnumber = 0;
    #####: 1602:	return (TIFFReadDirectory(tif));
        -: 1603:}
        -: 1604:
        -: 1605:/*
        -: 1606: * Return file offset of the current directory.
        -: 1607: */
        -: 1608:uint64
    #####: 1609:TIFFCurrentDirOffset(TIFF* tif)
        -: 1610:{
    #####: 1611:	return (tif->tif_diroff);
        -: 1612:}
        -: 1613:
        -: 1614:/*
        -: 1615: * Return an indication of whether or not we are
        -: 1616: * at the last directory in the file.
        -: 1617: */
        -: 1618:int
    #####: 1619:TIFFLastDirectory(TIFF* tif)
        -: 1620:{
    #####: 1621:	return (tif->tif_nextdiroff == 0);
        -: 1622:}
        -: 1623:
        -: 1624:/*
        -: 1625: * Unlink the specified directory from the directory chain.
        -: 1626: */
        -: 1627:int
    #####: 1628:TIFFUnlinkDirectory(TIFF* tif, uint16 dirn)
        -: 1629:{
        -: 1630:	static const char module[] = "TIFFUnlinkDirectory";
    #####: 1631:	uint64 nextdir;
    #####: 1632:	uint64 off;
        -: 1633:	uint16 n;
        -: 1634:
    #####: 1635:	if (tif->tif_mode == O_RDONLY) {
    #####: 1636:		TIFFErrorExt(tif->tif_clientdata, module,
        -: 1637:                             "Can not unlink directory in read-only file");
    #####: 1638:		return (0);
        -: 1639:	}
        -: 1640:	/*
        -: 1641:	 * Go to the directory before the one we want
        -: 1642:	 * to unlink and nab the offset of the link
        -: 1643:	 * field we'll need to patch.
        -: 1644:	 */
    #####: 1645:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1646:	{
    #####: 1647:		nextdir = tif->tif_header.classic.tiff_diroff;
    #####: 1648:		off = 4;
        -: 1649:	}
        -: 1650:	else
        -: 1651:	{
    #####: 1652:		nextdir = tif->tif_header.big.tiff_diroff;
    #####: 1653:		off = 8;
        -: 1654:	}
    #####: 1655:	for (n = dirn-1; n > 0; n--) {
    #####: 1656:		if (nextdir == 0) {
    #####: 1657:			TIFFErrorExt(tif->tif_clientdata, module, "Directory %d does not exist", dirn);
    #####: 1658:			return (0);
        -: 1659:		}
    #####: 1660:		if (!TIFFAdvanceDirectory(tif, &nextdir, &off))
    #####: 1661:			return (0);
        -: 1662:	}
        -: 1663:	/*
        -: 1664:	 * Advance to the directory to be unlinked and fetch
        -: 1665:	 * the offset of the directory that follows.
        -: 1666:	 */
    #####: 1667:	if (!TIFFAdvanceDirectory(tif, &nextdir, NULL))
    #####: 1668:		return (0);
        -: 1669:	/*
        -: 1670:	 * Go back and patch the link field of the preceding
        -: 1671:	 * directory to point to the offset of the directory
        -: 1672:	 * that follows.
        -: 1673:	 */
    #####: 1674:	(void) TIFFSeekFile(tif, off, SEEK_SET);
    #####: 1675:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 1676:	{
    #####: 1677:		uint32 nextdir32;
    #####: 1678:		nextdir32=(uint32)nextdir;
    #####: 1679:		assert((uint64)nextdir32==nextdir);
    #####: 1680:		if (tif->tif_flags & TIFF_SWAB)
    #####: 1681:			TIFFSwabLong(&nextdir32);
    #####: 1682:		if (!WriteOK(tif, &nextdir32, sizeof (uint32))) {
    #####: 1683:			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
    #####: 1684:			return (0);
        -: 1685:		}
        -: 1686:	}
        -: 1687:	else
        -: 1688:	{
    #####: 1689:		if (tif->tif_flags & TIFF_SWAB)
    #####: 1690:			TIFFSwabLong8(&nextdir);
    #####: 1691:		if (!WriteOK(tif, &nextdir, sizeof (uint64))) {
    #####: 1692:			TIFFErrorExt(tif->tif_clientdata, module, "Error writing directory link");
    #####: 1693:			return (0);
        -: 1694:		}
        -: 1695:	}
        -: 1696:	/*
        -: 1697:	 * Leave directory state setup safely.  We don't have
        -: 1698:	 * facilities for doing inserting and removing directories,
        -: 1699:	 * so it's safest to just invalidate everything.  This
        -: 1700:	 * means that the caller can only append to the directory
        -: 1701:	 * chain.
        -: 1702:	 */
    #####: 1703:	(*tif->tif_cleanup)(tif);
    #####: 1704:	if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {
    #####: 1705:		_TIFFfree(tif->tif_rawdata);
    #####: 1706:		tif->tif_rawdata = NULL;
    #####: 1707:		tif->tif_rawcc = 0;
    #####: 1708:                tif->tif_rawdataoff = 0;
    #####: 1709:                tif->tif_rawdataloaded = 0;
        -: 1710:	}
    #####: 1711:	tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE|TIFF_BUF4WRITE);
    #####: 1712:	TIFFFreeDirectory(tif);
    #####: 1713:	TIFFDefaultDirectory(tif);
    #####: 1714:	tif->tif_diroff = 0;			/* force link on next write */
    #####: 1715:	tif->tif_nextdiroff = 0;		/* next write must be at end */
    #####: 1716:	tif->tif_curoff = 0;
    #####: 1717:	tif->tif_row = (uint32) -1;
    #####: 1718:	tif->tif_curstrip = (uint32) -1;
    #####: 1719:	return (1);
        -: 1720:}
        -: 1721:
        -: 1722:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 1723:/*
        -: 1724: * Local Variables:
        -: 1725: * mode: c
        -: 1726: * c-basic-offset: 8
        -: 1727: * fill-column: 78
        -: 1728: * End:
        -: 1729: */
