        -:    0:Source:tif_aux.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1991-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library.
        -:   29: *
        -:   30: * Auxiliary Support Routines.
        -:   31: */
        -:   32:#include "tiffiop.h"
        -:   33:#include "tif_predict.h"
        -:   34:#include <math.h>
        -:   35:
        -:   36:uint32
    #####:   37:_TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)
        -:   38:{
    #####:   39:	uint32 bytes = first * second;
        -:   40:
    #####:   41:	if (second && bytes / second != first) {
    #####:   42:		TIFFErrorExt(tif->tif_clientdata, where, "Integer overflow in %s", where);
    #####:   43:		bytes = 0;
        -:   44:	}
        -:   45:
    #####:   46:	return bytes;
        -:   47:}
        -:   48:
        -:   49:uint64
       11:   50:_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)
        -:   51:{
       11:   52:	uint64 bytes = first * second;
        -:   53:
      11*:   54:	if (second && bytes / second != first) {
    #####:   55:		TIFFErrorExt(tif->tif_clientdata, where, "Integer overflow in %s", where);
    #####:   56:		bytes = 0;
        -:   57:	}
        -:   58:
       11:   59:	return bytes;
        -:   60:}
        -:   61:
        -:   62:void*
       12:   63:_TIFFCheckRealloc(TIFF* tif, void* buffer,
        -:   64:		  tmsize_t nmemb, tmsize_t elem_size, const char* what)
        -:   65:{
       12:   66:	void* cp = NULL;
       12:   67:	tmsize_t bytes = nmemb * elem_size;
        -:   68:
        -:   69:	/*
        -:   70:	 * XXX: Check for integer overflow.
        -:   71:	 */
      12*:   72:	if (nmemb && elem_size && bytes / elem_size == nmemb)
       12:   73:		cp = _TIFFrealloc(buffer, bytes);
        -:   74:
       12:   75:	if (cp == NULL) {
    #####:   76:		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
        -:   77:			     "Failed to allocate memory for %s "
        -:   78:			     "(%ld elements of %ld bytes each)",
        -:   79:			     what,(long) nmemb, (long) elem_size);
        -:   80:	}
        -:   81:
       12:   82:	return cp;
        -:   83:}
        -:   84:
        -:   85:void*
        8:   86:_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)
        -:   87:{
        8:   88:	return _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  
        -:   89:}
        -:   90:
        -:   91:static int
    #####:   92:TIFFDefaultTransferFunction(TIFFDirectory* td)
        -:   93:{
    #####:   94:	uint16 **tf = td->td_transferfunction;
        -:   95:	tmsize_t i, n, nbytes;
        -:   96:
    #####:   97:	tf[0] = tf[1] = tf[2] = 0;
    #####:   98:	if (td->td_bitspersample >= sizeof(tmsize_t) * 8 - 2)
    #####:   99:		return 0;
        -:  100:
    #####:  101:	n = ((tmsize_t)1)<<td->td_bitspersample;
    #####:  102:	nbytes = n * sizeof (uint16);
    #####:  103:        tf[0] = (uint16 *)_TIFFmalloc(nbytes);
    #####:  104:	if (tf[0] == NULL)
    #####:  105:		return 0;
    #####:  106:	tf[0][0] = 0;
    #####:  107:	for (i = 1; i < n; i++) {
    #####:  108:		double t = (double)i/((double) n-1.);
    #####:  109:		tf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5);
        -:  110:	}
        -:  111:
    #####:  112:	if (td->td_samplesperpixel - td->td_extrasamples > 1) {
    #####:  113:                tf[1] = (uint16 *)_TIFFmalloc(nbytes);
    #####:  114:		if(tf[1] == NULL)
    #####:  115:			goto bad;
    #####:  116:		_TIFFmemcpy(tf[1], tf[0], nbytes);
    #####:  117:                tf[2] = (uint16 *)_TIFFmalloc(nbytes);
    #####:  118:		if (tf[2] == NULL)
    #####:  119:			goto bad;
    #####:  120:		_TIFFmemcpy(tf[2], tf[0], nbytes);
        -:  121:	}
    #####:  122:	return 1;
        -:  123:
    #####:  124:bad:
    #####:  125:	if (tf[0])
    #####:  126:		_TIFFfree(tf[0]);
    #####:  127:	if (tf[1])
    #####:  128:		_TIFFfree(tf[1]);
    #####:  129:	if (tf[2])
    #####:  130:		_TIFFfree(tf[2]);
    #####:  131:	tf[0] = tf[1] = tf[2] = 0;
    #####:  132:	return 0;
        -:  133:}
        -:  134:
        -:  135:static int
    #####:  136:TIFFDefaultRefBlackWhite(TIFFDirectory* td)
        -:  137:{
        -:  138:	int i;
        -:  139:
    #####:  140:        td->td_refblackwhite = (float *)_TIFFmalloc(6*sizeof (float));
    #####:  141:	if (td->td_refblackwhite == NULL)
    #####:  142:		return 0;
    #####:  143:        if (td->td_photometric == PHOTOMETRIC_YCBCR) {
        -:  144:		/*
        -:  145:		 * YCbCr (Class Y) images must have the ReferenceBlackWhite
        -:  146:		 * tag set. Fix the broken images, which lacks that tag.
        -:  147:		 */
    #####:  148:		td->td_refblackwhite[0] = 0.0F;
    #####:  149:		td->td_refblackwhite[1] = td->td_refblackwhite[3] =
    #####:  150:			td->td_refblackwhite[5] = 255.0F;
    #####:  151:		td->td_refblackwhite[2] = td->td_refblackwhite[4] = 128.0F;
        -:  152:	} else {
        -:  153:		/*
        -:  154:		 * Assume RGB (Class R)
        -:  155:		 */
    #####:  156:		for (i = 0; i < 3; i++) {
    #####:  157:		    td->td_refblackwhite[2*i+0] = 0;
    #####:  158:		    td->td_refblackwhite[2*i+1] =
    #####:  159:			    (float)((1L<<td->td_bitspersample)-1L);
        -:  160:		}
        -:  161:	}
    #####:  162:	return 1;
        -:  163:}
        -:  164:
        -:  165:/*
        -:  166: * Like TIFFGetField, but return any default
        -:  167: * value if the tag is not present in the directory.
        -:  168: *
        -:  169: * NB:	We use the value in the directory, rather than
        -:  170: *	explicit values so that defaults exist only one
        -:  171: *	place in the library -- in TIFFDefaultDirectory.
        -:  172: */
        -:  173:int
    #####:  174:TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)
        -:  175:{
    #####:  176:	TIFFDirectory *td = &tif->tif_dir;
        -:  177:
    #####:  178:	if (TIFFVGetField(tif, tag, ap))
    #####:  179:		return (1);
    #####:  180:	switch (tag) {
    #####:  181:	case TIFFTAG_SUBFILETYPE:
    #####:  182:		*va_arg(ap, uint32 *) = td->td_subfiletype;
    #####:  183:		return (1);
    #####:  184:	case TIFFTAG_BITSPERSAMPLE:
    #####:  185:		*va_arg(ap, uint16 *) = td->td_bitspersample;
    #####:  186:		return (1);
    #####:  187:	case TIFFTAG_THRESHHOLDING:
    #####:  188:		*va_arg(ap, uint16 *) = td->td_threshholding;
    #####:  189:		return (1);
    #####:  190:	case TIFFTAG_FILLORDER:
    #####:  191:		*va_arg(ap, uint16 *) = td->td_fillorder;
    #####:  192:		return (1);
    #####:  193:	case TIFFTAG_ORIENTATION:
    #####:  194:		*va_arg(ap, uint16 *) = td->td_orientation;
    #####:  195:		return (1);
    #####:  196:	case TIFFTAG_SAMPLESPERPIXEL:
    #####:  197:		*va_arg(ap, uint16 *) = td->td_samplesperpixel;
    #####:  198:		return (1);
    #####:  199:	case TIFFTAG_ROWSPERSTRIP:
    #####:  200:		*va_arg(ap, uint32 *) = td->td_rowsperstrip;
    #####:  201:		return (1);
    #####:  202:	case TIFFTAG_MINSAMPLEVALUE:
    #####:  203:		*va_arg(ap, uint16 *) = td->td_minsamplevalue;
    #####:  204:		return (1);
    #####:  205:	case TIFFTAG_MAXSAMPLEVALUE:
    #####:  206:		*va_arg(ap, uint16 *) = td->td_maxsamplevalue;
    #####:  207:		return (1);
    #####:  208:	case TIFFTAG_PLANARCONFIG:
    #####:  209:		*va_arg(ap, uint16 *) = td->td_planarconfig;
    #####:  210:		return (1);
    #####:  211:	case TIFFTAG_RESOLUTIONUNIT:
    #####:  212:		*va_arg(ap, uint16 *) = td->td_resolutionunit;
    #####:  213:		return (1);
    #####:  214:	case TIFFTAG_PREDICTOR:
        -:  215:    {
    #####:  216:        TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;
    #####:  217:        if( sp == NULL )
        -:  218:        {
    #####:  219:            TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
        -:  220:                         "Cannot get \"Predictor\" tag as plugin is not configured");
    #####:  221:            *va_arg(ap, uint16*) = 0;
    #####:  222:            return 0;
        -:  223:        }
    #####:  224:        *va_arg(ap, uint16*) = (uint16) sp->predictor;
    #####:  225:        return 1;
        -:  226:    }
    #####:  227:	case TIFFTAG_DOTRANGE:
    #####:  228:		*va_arg(ap, uint16 *) = 0;
    #####:  229:		*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;
    #####:  230:		return (1);
    #####:  231:	case TIFFTAG_INKSET:
    #####:  232:		*va_arg(ap, uint16 *) = INKSET_CMYK;
    #####:  233:		return 1;
    #####:  234:	case TIFFTAG_NUMBEROFINKS:
    #####:  235:		*va_arg(ap, uint16 *) = 4;
    #####:  236:		return (1);
    #####:  237:	case TIFFTAG_EXTRASAMPLES:
    #####:  238:		*va_arg(ap, uint16 *) = td->td_extrasamples;
    #####:  239:		*va_arg(ap, uint16 **) = td->td_sampleinfo;
    #####:  240:		return (1);
    #####:  241:	case TIFFTAG_MATTEING:
    #####:  242:		*va_arg(ap, uint16 *) =
    #####:  243:		    (td->td_extrasamples == 1 &&
    #####:  244:		     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);
    #####:  245:		return (1);
    #####:  246:	case TIFFTAG_TILEDEPTH:
    #####:  247:		*va_arg(ap, uint32 *) = td->td_tiledepth;
    #####:  248:		return (1);
    #####:  249:	case TIFFTAG_DATATYPE:
    #####:  250:		*va_arg(ap, uint16 *) = td->td_sampleformat-1;
    #####:  251:		return (1);
    #####:  252:	case TIFFTAG_SAMPLEFORMAT:
    #####:  253:		*va_arg(ap, uint16 *) = td->td_sampleformat;
    #####:  254:                return(1);
    #####:  255:	case TIFFTAG_IMAGEDEPTH:
    #####:  256:		*va_arg(ap, uint32 *) = td->td_imagedepth;
    #####:  257:		return (1);
    #####:  258:	case TIFFTAG_YCBCRCOEFFICIENTS:
        -:  259:		{
        -:  260:			/* defaults are from CCIR Recommendation 601-1 */
        -:  261:			static float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };
    #####:  262:			*va_arg(ap, float **) = ycbcrcoeffs;
    #####:  263:			return 1;
        -:  264:		}
    #####:  265:	case TIFFTAG_YCBCRSUBSAMPLING:
    #####:  266:		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];
    #####:  267:		*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];
    #####:  268:		return (1);
    #####:  269:	case TIFFTAG_YCBCRPOSITIONING:
    #####:  270:		*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;
    #####:  271:		return (1);
    #####:  272:	case TIFFTAG_WHITEPOINT:
        -:  273:		{
        -:  274:			static float whitepoint[2];
        -:  275:
        -:  276:			/* TIFF 6.0 specification tells that it is no default
        -:  277:			   value for the WhitePoint, but AdobePhotoshop TIFF
        -:  278:			   Technical Note tells that it should be CIE D50. */
    #####:  279:			whitepoint[0] =	D50_X0 / (D50_X0 + D50_Y0 + D50_Z0);
    #####:  280:			whitepoint[1] =	D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);
    #####:  281:			*va_arg(ap, float **) = whitepoint;
    #####:  282:			return 1;
        -:  283:		}
    #####:  284:	case TIFFTAG_TRANSFERFUNCTION:
    #####:  285:		if (!td->td_transferfunction[0] &&
    #####:  286:		    !TIFFDefaultTransferFunction(td)) {
    #####:  287:			TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "No space for \"TransferFunction\" tag");
    #####:  288:			return (0);
        -:  289:		}
    #####:  290:		*va_arg(ap, uint16 **) = td->td_transferfunction[0];
    #####:  291:		if (td->td_samplesperpixel - td->td_extrasamples > 1) {
    #####:  292:			*va_arg(ap, uint16 **) = td->td_transferfunction[1];
    #####:  293:			*va_arg(ap, uint16 **) = td->td_transferfunction[2];
        -:  294:		}
    #####:  295:		return (1);
    #####:  296:	case TIFFTAG_REFERENCEBLACKWHITE:
    #####:  297:		if (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))
    #####:  298:			return (0);
    #####:  299:		*va_arg(ap, float **) = td->td_refblackwhite;
    #####:  300:		return (1);
        -:  301:	}
    #####:  302:	return 0;
        -:  303:}
        -:  304:
        -:  305:/*
        -:  306: * Like TIFFGetField, but return any default
        -:  307: * value if the tag is not present in the directory.
        -:  308: */
        -:  309:int
    #####:  310:TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)
        -:  311:{
        -:  312:	int ok;
    #####:  313:	va_list ap;
        -:  314:
    #####:  315:	va_start(ap, tag);
    #####:  316:	ok =  TIFFVGetFieldDefaulted(tif, tag, ap);
    #####:  317:	va_end(ap);
    #####:  318:	return (ok);
        -:  319:}
        -:  320:
        -:  321:struct _Int64Parts {
        -:  322:	int32 low, high;
        -:  323:};
        -:  324:
        -:  325:typedef union {
        -:  326:	struct _Int64Parts part;
        -:  327:	int64 value;
        -:  328:} _Int64;
        -:  329:
        -:  330:float
    #####:  331:_TIFFUInt64ToFloat(uint64 ui64)
        -:  332:{
        -:  333:	_Int64 i;
        -:  334:
    #####:  335:	i.value = ui64;
    #####:  336:	if (i.part.high >= 0) {
    #####:  337:		return (float)i.value;
        -:  338:	} else {
        -:  339:		long double df;
    #####:  340:		df = (long double)i.value;
    #####:  341:		df += 18446744073709551616.0; /* adding 2**64 */
    #####:  342:		return (float)df;
        -:  343:	}
        -:  344:}
        -:  345:
        -:  346:double
    #####:  347:_TIFFUInt64ToDouble(uint64 ui64)
        -:  348:{
        -:  349:	_Int64 i;
        -:  350:
    #####:  351:	i.value = ui64;
    #####:  352:	if (i.part.high >= 0) {
    #####:  353:		return (double)i.value;
        -:  354:	} else {
        -:  355:		long double df;
    #####:  356:		df = (long double)i.value;
    #####:  357:		df += 18446744073709551616.0; /* adding 2**64 */
    #####:  358:		return (double)df;
        -:  359:	}
        -:  360:}
        -:  361:
        -:  362:/* vim: set ts=8 sts=8 sw=8 noet: */
        -:  363:/*
        -:  364: * Local Variables:
        -:  365: * mode: c
        -:  366: * c-basic-offset: 8
        -:  367: * fill-column: 78
        -:  368: * End:
        -:  369: */
