        -:    0:Source:tif_unix.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: *
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        -:   18: *
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library UNIX-specific Routines. These are should also work with the
        -:   29: * Windows Common RunTime Library.
        -:   30: */
        -:   31:
        -:   32:#include "tif_config.h"
        -:   33:
        -:   34:#ifdef HAVE_SYS_TYPES_H
        -:   35:# include <sys/types.h>
        -:   36:#endif
        -:   37:
        -:   38:#include <errno.h>
        -:   39:
        -:   40:#include <stdarg.h>
        -:   41:#include <stdlib.h>
        -:   42:#include <sys/stat.h>
        -:   43:
        -:   44:#ifdef HAVE_UNISTD_H
        -:   45:# include <unistd.h>
        -:   46:#endif
        -:   47:
        -:   48:#ifdef HAVE_FCNTL_H
        -:   49:# include <fcntl.h>
        -:   50:#endif
        -:   51:
        -:   52:#ifdef HAVE_IO_H
        -:   53:# include <io.h>
        -:   54:#endif
        -:   55:
        -:   56:#include "tiffiop.h"
        -:   57:
        -:   58:
        -:   59:#define TIFF_IO_MAX 2147483647U
        -:   60:
        -:   61:
        -:   62:typedef union fd_as_handle_union
        -:   63:{
        -:   64:	int fd;
        -:   65:	thandle_t h;
        -:   66:} fd_as_handle_union_t;
        -:   67:
        -:   68:static tmsize_t
        2:   69:_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)
        -:   70:{
        -:   71:	fd_as_handle_union_t fdh;
        2:   72:        const size_t bytes_total = (size_t) size;
        -:   73:        size_t bytes_read;
        2:   74:        tmsize_t count = -1;
        2:   75:	if ((tmsize_t) bytes_total != size)
        -:   76:	{
    #####:   77:		errno=EINVAL;
    #####:   78:		return (tmsize_t) -1;
        -:   79:	}
        2:   80:	fdh.h = fd;
        4:   81:        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)
        -:   82:        {
        2:   83:                char *buf_offset = (char *) buf+bytes_read;
        2:   84:                size_t io_size = bytes_total-bytes_read;
        2:   85:                if (io_size > TIFF_IO_MAX)
    #####:   86:                        io_size = TIFF_IO_MAX;
        2:   87:                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);
        2:   88:                if (count <= 0)
    #####:   89:                        break;
        -:   90:        }
        2:   91:        if (count < 0)
    #####:   92:                return (tmsize_t)-1;
        2:   93:        return (tmsize_t) bytes_read;
        -:   94:}
        -:   95:
        -:   96:static tmsize_t
        1:   97:_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)
        -:   98:{
        -:   99:	fd_as_handle_union_t fdh;
        1:  100:	const size_t bytes_total = (size_t) size;
        -:  101:        size_t bytes_written;
        1:  102:        tmsize_t count = -1;
        1:  103:	if ((tmsize_t) bytes_total != size)
        -:  104:	{
    #####:  105:		errno=EINVAL;
    #####:  106:		return (tmsize_t) -1;
        -:  107:	}
        1:  108:	fdh.h = fd;
        2:  109:        for (bytes_written=0; bytes_written < bytes_total; bytes_written+=count)
        -:  110:        {
        1:  111:                const char *buf_offset = (char *) buf+bytes_written;
        1:  112:                size_t io_size = bytes_total-bytes_written;
        1:  113:                if (io_size > TIFF_IO_MAX)
    #####:  114:                        io_size = TIFF_IO_MAX;
        1:  115:                count=write(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);
        1:  116:                if (count <= 0)
    #####:  117:                        break;
        -:  118:        }
        1:  119:        if (count < 0)
    #####:  120:                return (tmsize_t)-1;
        1:  121:        return (tmsize_t) bytes_written;
        -:  122:	/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */
        -:  123:}
        -:  124:
        -:  125:static uint64
        1:  126:_tiffSeekProc(thandle_t fd, uint64 off, int whence)
        -:  127:{
        -:  128:	fd_as_handle_union_t fdh;
        1:  129:	_TIFF_off_t off_io = (_TIFF_off_t) off;
        1:  130:	if ((uint64) off_io != off)
        -:  131:	{
    #####:  132:		errno=EINVAL;
    #####:  133:		return (uint64) -1; /* this is really gross */
        -:  134:	}
        1:  135:	fdh.h = fd;
        1:  136:	return((uint64)_TIFF_lseek_f(fdh.fd,off_io,whence));
        -:  137:}
        -:  138:
        -:  139:static int
    #####:  140:_tiffCloseProc(thandle_t fd)
        -:  141:{
        -:  142:	fd_as_handle_union_t fdh;
    #####:  143:	fdh.h = fd;
    #####:  144:	return(close(fdh.fd));
        -:  145:}
        -:  146:
        -:  147:static uint64
        2:  148:_tiffSizeProc(thandle_t fd)
        -:  149:{
        2:  150:	_TIFF_stat_s sb;
        -:  151:	fd_as_handle_union_t fdh;
        2:  152:	fdh.h = fd;
       2*:  153:	if (_TIFF_fstat_f(fdh.fd,&sb)<0)
    #####:  154:		return(0);
        -:  155:	else
        2:  156:		return((uint64)sb.st_size);
        -:  157:}
        -:  158:
        -:  159:#ifdef HAVE_MMAP
        -:  160:#include <sys/mman.h>
        -:  161:
        -:  162:static int
        1:  163:_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)
        -:  164:{
        1:  165:	uint64 size64 = _tiffSizeProc(fd);
        1:  166:	tmsize_t sizem = (tmsize_t)size64;
        1:  167:	if ((uint64)sizem==size64) {
        -:  168:		fd_as_handle_union_t fdh;
        1:  169:		fdh.h = fd;
        1:  170:		*pbase = (void*)
        -:  171:		    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);
        1:  172:		if (*pbase != (void*) -1) {
        1:  173:			*psize = (tmsize_t)sizem;
        1:  174:			return (1);
        -:  175:		}
        -:  176:	}
    #####:  177:	return (0);
        -:  178:}
        -:  179:
        -:  180:static void
    #####:  181:_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
        -:  182:{
        -:  183:	(void) fd;
    #####:  184:	(void) munmap(base, (off_t) size);
    #####:  185:}
        -:  186:#else /* !HAVE_MMAP */
        -:  187:static int
        -:  188:_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)
        -:  189:{
        -:  190:	(void) fd; (void) pbase; (void) psize;
        -:  191:	return (0);
        -:  192:}
        -:  193:
        -:  194:static void
        -:  195:_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
        -:  196:{
        -:  197:	(void) fd; (void) base; (void) size;
        -:  198:}
        -:  199:#endif /* !HAVE_MMAP */
        -:  200:
        -:  201:/*
        -:  202: * Open a TIFF file descriptor for read/writing.
        -:  203: */
        -:  204:TIFF*
        2:  205:TIFFFdOpen(int fd, const char* name, const char* mode)
        -:  206:{
        -:  207:	TIFF* tif;
        -:  208:
        -:  209:	fd_as_handle_union_t fdh;
        2:  210:	fdh.fd = fd;
        2:  211:	tif = TIFFClientOpen(name, mode,
        -:  212:	    fdh.h,
        -:  213:	    _tiffReadProc, _tiffWriteProc,
        -:  214:	    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
        -:  215:	    _tiffMapProc, _tiffUnmapProc);
        2:  216:	if (tif)
        2:  217:		tif->tif_fd = fd;
        2:  218:	return (tif);
        -:  219:}
        -:  220:
        -:  221:/*
        -:  222: * Open a TIFF file for read/writing.
        -:  223: */
        -:  224:TIFF*
        2:  225:TIFFOpen(const char* name, const char* mode)
        -:  226:{
        -:  227:	static const char module[] = "TIFFOpen";
        -:  228:	int m, fd;
        -:  229:	TIFF* tif;
        -:  230:
        2:  231:	m = _TIFFgetMode(mode, module);
        2:  232:	if (m == -1)
    #####:  233:		return ((TIFF*)0);
        -:  234:
        -:  235:/* for cygwin and mingw */
        -:  236:#ifdef O_BINARY
        -:  237:	m |= O_BINARY;
        -:  238:#endif
        -:  239:
       2*:  240:	fd = open(name, m, 0666);
        2:  241:	if (fd < 0) {
    #####:  242:		if (errno > 0 && strerror(errno) != NULL ) {
    #####:  243:			TIFFErrorExt(0, module, "%s: %s", name, strerror(errno) );
        -:  244:		} else {
    #####:  245:			TIFFErrorExt(0, module, "%s: Cannot open", name);
        -:  246:		}
    #####:  247:		return ((TIFF *)0);
        -:  248:	}
        -:  249:
        2:  250:	tif = TIFFFdOpen((int)fd, name, mode);
        2:  251:	if(!tif)
    #####:  252:		close(fd);
        2:  253:	return tif;
        -:  254:}
        -:  255:
        -:  256:#ifdef __WIN32__
        -:  257:#include <windows.h>
        -:  258:/*
        -:  259: * Open a TIFF file with a Unicode filename, for read/writing.
        -:  260: */
        -:  261:TIFF*
        -:  262:TIFFOpenW(const wchar_t* name, const char* mode)
        -:  263:{
        -:  264:	static const char module[] = "TIFFOpenW";
        -:  265:	int m, fd;
        -:  266:	int mbsize;
        -:  267:	char *mbname;
        -:  268:	TIFF* tif;
        -:  269:
        -:  270:	m = _TIFFgetMode(mode, module);
        -:  271:	if (m == -1)
        -:  272:		return ((TIFF*)0);
        -:  273:
        -:  274:/* for cygwin and mingw */
        -:  275:#ifdef O_BINARY
        -:  276:	m |= O_BINARY;
        -:  277:#endif
        -:  278:
        -:  279:	fd = _wopen(name, m, 0666);
        -:  280:	if (fd < 0) {
        -:  281:		TIFFErrorExt(0, module, "%ls: Cannot open", name);
        -:  282:		return ((TIFF *)0);
        -:  283:	}
        -:  284:
        -:  285:	mbname = NULL;
        -:  286:	mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);
        -:  287:	if (mbsize > 0) {
        -:  288:		mbname = _TIFFmalloc(mbsize);
        -:  289:		if (!mbname) {
        -:  290:			TIFFErrorExt(0, module,
        -:  291:			"Can't allocate space for filename conversion buffer");
        -:  292:			return ((TIFF*)0);
        -:  293:		}
        -:  294:
        -:  295:		WideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,
        -:  296:				    NULL, NULL);
        -:  297:	}
        -:  298:
        -:  299:	tif = TIFFFdOpen((int)fd, (mbname != NULL) ? mbname : "<unknown>",
        -:  300:			 mode);
        -:  301:	
        -:  302:	_TIFFfree(mbname);
        -:  303:	
        -:  304:	if(!tif)
        -:  305:		close(fd);
        -:  306:	return tif;
        -:  307:}
        -:  308:#endif
        -:  309:
        -:  310:void*
       13:  311:_TIFFmalloc(tmsize_t s)
        -:  312:{
       13:  313:        if (s == 0)
    #####:  314:                return ((void *) NULL);
        -:  315:
       13:  316:	return (malloc((size_t) s));
        -:  317:}
        -:  318:
        -:  319:void
        7:  320:_TIFFfree(void* p)
        -:  321:{
        7:  322:	free(p);
        7:  323:}
        -:  324:
        -:  325:void*
       13:  326:_TIFFrealloc(void* p, tmsize_t s)
        -:  327:{
       13:  328:	return (realloc(p, (size_t) s));
        -:  329:}
        -:  330:
        -:  331:void
        9:  332:_TIFFmemset(void* p, int v, tmsize_t c)
        -:  333:{
       9*:  334:	memset(p, v, (size_t) c);
        9:  335:}
        -:  336:
        -:  337:void
        8:  338:_TIFFmemcpy(void* d, const void* s, tmsize_t c)
        -:  339:{
       8*:  340:	memcpy(d, s, (size_t) c);
        8:  341:}
        -:  342:
        -:  343:int
    #####:  344:_TIFFmemcmp(const void* p1, const void* p2, tmsize_t c)
        -:  345:{
    #####:  346:	return (memcmp(p1, p2, (size_t) c));
        -:  347:}
        -:  348:
        -:  349:static void
        4:  350:unixWarningHandler(const char* module, const char* fmt, va_list ap)
        -:  351:{
        4:  352:	if (module != NULL)
       4*:  353:		fprintf(stderr, "%s: ", module);
       4*:  354:	fprintf(stderr, "Warning, ");
       4*:  355:	vfprintf(stderr, fmt, ap);
       4*:  356:	fprintf(stderr, ".\n");
        4:  357:}
        -:  358:TIFFErrorHandler _TIFFwarningHandler = unixWarningHandler;
        -:  359:
        -:  360:static void
    #####:  361:unixErrorHandler(const char* module, const char* fmt, va_list ap)
        -:  362:{
    #####:  363:	if (module != NULL)
    #####:  364:		fprintf(stderr, "%s: ", module);
    #####:  365:	vfprintf(stderr, fmt, ap);
    #####:  366:	fprintf(stderr, ".\n");
    #####:  367:}
        -:  368:TIFFErrorHandler _TIFFerrorHandler = unixErrorHandler;
        -:  369:
        -:  370:/* vim: set ts=8 sts=8 sw=8 noet: */
        -:  371:
        -:  372:/*
        -:  373: * Local Variables:
        -:  374: * mode: c
        -:  375: * c-basic-offset: 8
        -:  376: * fill-column: 78
        -:  377: * End:
        -:  378: */
