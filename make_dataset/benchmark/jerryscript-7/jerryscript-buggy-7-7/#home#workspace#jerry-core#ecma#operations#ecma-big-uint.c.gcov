        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-big-uint.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-big-uint.h"
        -:   17:
        -:   18:#include "ecma-helpers.h"
        -:   19:
        -:   20:#include "jmem.h"
        -:   21:#include "lit-char-helpers.h"
        -:   22:
        -:   23:#if JERRY_BUILTIN_BIGINT
        -:   24:
        -:   25:JERRY_STATIC_ASSERT (sizeof (ecma_bigint_two_digits_t) == 2 * sizeof (ecma_bigint_digit_t),
        -:   26:                     ecma_big_int_two_digits_must_be_twice_as_long_as_ecma_big_int_digit);
        -:   27:
        -:   28:JERRY_STATIC_ASSERT ((1 << ECMA_BIGINT_DIGIT_SHIFT) == (8 * sizeof (ecma_bigint_digit_t)),
        -:   29:                     ecma_bigint_digit_shift_is_incorrect);
        -:   30:
        -:   31:JERRY_STATIC_ASSERT ((ECMA_BIG_UINT_BITWISE_DECREASE_LEFT << 1) == ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT,
        -:   32:                     ecma_big_uint_bitwise_left_and_right_sub_option_bits_must_follow_each_other);
        -:   33:
        -:   34:/**
        -:   35: * Create a new BigInt value
        -:   36: *
        -:   37: * @return new BigInt value, NULL on error
        -:   38: */
        -:   39:ecma_extended_primitive_t *
    #####:   40:ecma_bigint_create (uint32_t size) /**< size of the new BigInt value */
        -:   41:{
    #####:   42:  JERRY_ASSERT (size > 0);
    #####:   43:  JERRY_ASSERT ((size % sizeof (ecma_bigint_digit_t)) == 0);
        -:   44:
    #####:   45:  if (JERRY_UNLIKELY (size > ECMA_BIGINT_MAX_SIZE))
        -:   46:  {
    #####:   47:    return NULL;
        -:   48:  }
        -:   49:
        -:   50:  ecma_extended_primitive_t *value_p;
        -:   51:
    #####:   52:  size_t mem_size = ECMA_BIGINT_GET_BYTE_SIZE (size) + sizeof (ecma_extended_primitive_t);
    #####:   53:  value_p = (ecma_extended_primitive_t *) jmem_heap_alloc_block_null_on_error (mem_size);
        -:   54:
    #####:   55:  if (JERRY_UNLIKELY (value_p == NULL))
        -:   56:  {
    #####:   57:    return NULL;
        -:   58:  }
        -:   59:
    #####:   60:  value_p->refs_and_type = ECMA_EXTENDED_PRIMITIVE_REF_ONE | ECMA_TYPE_BIGINT;
    #####:   61:  value_p->u.bigint_sign_and_size = size;
    #####:   62:  return value_p;
        -:   63:} /* ecma_bigint_create */
        -:   64:
        -:   65:/**
        -:   66: * Extend a BigUInt value with a new data prefix value
        -:   67: *
        -:   68: * @return new BigUInt value, NULL on error
        -:   69: */
        -:   70:ecma_extended_primitive_t *
    #####:   71:ecma_big_uint_extend (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:   72:                      ecma_bigint_digit_t digit) /**< new digit */
        -:   73:{
    #####:   74:  uint32_t old_size = ECMA_BIGINT_GET_SIZE (value_p);
        -:   75:
    #####:   76:  if (ECMA_BIGINT_SIZE_IS_ODD (old_size))
        -:   77:  {
    #####:   78:    value_p->u.bigint_sign_and_size += (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:   79:    *ECMA_BIGINT_GET_DIGITS (value_p, old_size) = digit;
    #####:   80:    return value_p;
        -:   81:  }
        -:   82:
    #####:   83:  ecma_extended_primitive_t *result_p = ecma_bigint_create (old_size + (uint32_t) sizeof (ecma_bigint_digit_t));
        -:   84:
    #####:   85:  if (JERRY_UNLIKELY (result_p == NULL))
        -:   86:  {
    #####:   87:    ecma_deref_bigint (value_p);
    #####:   88:    return NULL;
        -:   89:  }
        -:   90:
    #####:   91:  memcpy (result_p + 1, value_p + 1, old_size);
    #####:   92:  ecma_deref_bigint (value_p);
        -:   93:
    #####:   94:  *ECMA_BIGINT_GET_DIGITS (result_p, old_size) = digit;
    #####:   95:  return result_p;
        -:   96:} /* ecma_big_uint_extend */
        -:   97:
        -:   98:/**
        -:   99: * Count the number of leading zero bits of a digit
        -:  100: *
        -:  101: * return number of leading zero bits
        -:  102: */
        -:  103:ecma_bigint_digit_t
    #####:  104:ecma_big_uint_count_leading_zero (ecma_bigint_digit_t digit) /**< digit value */
        -:  105:{
    #####:  106:  ecma_bigint_digit_t shift = 4 * sizeof (ecma_bigint_digit_t);
    #####:  107:  ecma_bigint_digit_t result = 8 * sizeof (ecma_bigint_digit_t);
        -:  108:
        -:  109:  do
        -:  110:  {
    #####:  111:    ecma_bigint_digit_t value = digit >> shift;
    #####:  112:    if (value > 0)
        -:  113:    {
    #####:  114:      digit = value;
    #####:  115:      result -= shift;
        -:  116:    }
    #####:  117:    shift >>= 1;
    #####:  118:  } while (shift > 0);
        -:  119:
    #####:  120:  return result - digit;
        -:  121:} /* ecma_big_uint_count_leading_zero */
        -:  122:
        -:  123:/**
        -:  124: * Helper function which discards the leading zero digits of a BigUInt value
        -:  125: *
        -:  126: * @return new BigUInt value, NULL on error
        -:  127: */
        -:  128:static ecma_extended_primitive_t *
    #####:  129:ecma_big_uint_normalize_result (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  130:                                ecma_bigint_digit_t *last_digit_p) /**< points to the end of BigUInt */
        -:  131:{
    #####:  132:  JERRY_ASSERT (last_digit_p[-1] == 0);
        -:  133:
    #####:  134:  ecma_bigint_digit_t *first_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  135:
        -:  136:  /* The following code is tricky. The value stored in first_digit_p[-1] is the size
        -:  137:   * of the BigUInt value, and it cannot be zero. Hence the loop below will terminate. */
    #####:  138:  JERRY_ASSERT (first_digit_p[-1] != 0);
        -:  139:
        -:  140:  do
        -:  141:  {
    #####:  142:    --last_digit_p;
    #####:  143:  } while (last_digit_p[-1] == 0);
        -:  144:
    #####:  145:  JERRY_ASSERT (last_digit_p >= first_digit_p);
        -:  146:
    #####:  147:  if (first_digit_p == last_digit_p)
        -:  148:  {
    #####:  149:    ecma_deref_bigint (value_p);
    #####:  150:    return ECMA_BIGINT_POINTER_TO_ZERO;
        -:  151:  }
        -:  152:
    #####:  153:  uint32_t new_size = (uint32_t) ((uint8_t *) last_digit_p - (uint8_t *) first_digit_p);
        -:  154:
    #####:  155:  if (ECMA_BIGINT_SIZE_IS_ODD (new_size)
    #####:  156:      && ((new_size + sizeof (ecma_bigint_digit_t)) == ECMA_BIGINT_GET_SIZE (value_p)))
        -:  157:  {
    #####:  158:    value_p->u.bigint_sign_and_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:  159:    return value_p;
        -:  160:  }
        -:  161:
    #####:  162:  ecma_extended_primitive_t *result_p = ecma_bigint_create (new_size);
        -:  163:
    #####:  164:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  165:  {
    #####:  166:    ecma_deref_bigint (value_p);
    #####:  167:    return NULL;
        -:  168:  }
        -:  169:
    #####:  170:  memcpy (ECMA_BIGINT_GET_DIGITS (result_p, 0), ECMA_BIGINT_GET_DIGITS (value_p, 0), new_size);
    #####:  171:  ecma_deref_bigint (value_p);
        -:  172:
    #####:  173:  return result_p;
        -:  174:} /* ecma_big_uint_normalize_result */
        -:  175:
        -:  176:/**
        -:  177: * Helper function which increases the result by 1 and extends or shrinks the BigUInt when necessary
        -:  178: *
        -:  179: * @return new BigUInt value, NULL on error
        -:  180: */
        -:  181:static ecma_extended_primitive_t *
    #####:  182:ecma_big_uint_increase_result (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  183:{
    #####:  184:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  185:
    #####:  186:  JERRY_ASSERT (size > 0);
        -:  187:
    #####:  188:  ecma_bigint_digit_t *first_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  189:  ecma_bigint_digit_t *last_digit_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  190:
    #####:  191:  while (*first_digit_p == ~((ecma_bigint_digit_t) 0))
        -:  192:  {
    #####:  193:    *first_digit_p++ = 0;
        -:  194:
    #####:  195:    if (first_digit_p == last_digit_p)
        -:  196:    {
    #####:  197:      return ecma_big_uint_extend (value_p, 1);
        -:  198:    }
        -:  199:  }
        -:  200:
    #####:  201:  (*first_digit_p)++;
        -:  202:
    #####:  203:  if (last_digit_p[-1] != 0)
        -:  204:  {
    #####:  205:    return value_p;
        -:  206:  }
        -:  207:
    #####:  208:  return ecma_big_uint_normalize_result (value_p, last_digit_p);
        -:  209:} /* ecma_big_uint_increase_result */
        -:  210:
        -:  211:/**
        -:  212: * Compare two BigUInt numbers
        -:  213: *
        -:  214: * return -1, if left value < right value, 0 if they are equal, and 1 otherwise
        -:  215: */
        -:  216:int
    #####:  217:ecma_big_uint_compare (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  218:                       ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  219:{
    #####:  220:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  221:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  222:
    #####:  223:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  224:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  225:
    #####:  226:  if (left_size > right_size)
        -:  227:  {
    #####:  228:    return 1;
        -:  229:  }
        -:  230:
    #####:  231:  if (left_size < right_size)
        -:  232:  {
    #####:  233:    return -1;
        -:  234:  }
        -:  235:
    #####:  236:  ecma_bigint_digit_t *start_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  237:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####:  238:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, left_size);
        -:  239:
        -:  240:  do
        -:  241:  {
    #####:  242:    ecma_bigint_digit_t left_value = *(--left_p);
    #####:  243:    ecma_bigint_digit_t right_value = *(--right_p);
        -:  244:
    #####:  245:    if (left_value < right_value)
        -:  246:    {
    #####:  247:      return -1;
        -:  248:    }
        -:  249:
    #####:  250:    if (left_value > right_value)
        -:  251:    {
    #####:  252:      return 1;
        -:  253:    }
    #####:  254:  } while (left_p > start_p);
        -:  255:
    #####:  256:  return 0;
        -:  257:} /* ecma_big_uint_compare */
        -:  258:
        -:  259:/**
        -:  260: * In-place multiply and addition operation with digit
        -:  261: *
        -:  262: * return updated value on success, NULL if no memory is available
        -:  263: */
        -:  264:ecma_extended_primitive_t *
    #####:  265:ecma_big_uint_mul_digit (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  266:                         ecma_bigint_digit_t mul, /**< multiply value */
        -:  267:                         ecma_bigint_digit_t add) /**< addition value */
        -:  268:{
    #####:  269:  JERRY_ASSERT (mul > 1);
    #####:  270:  JERRY_ASSERT (add < mul);
        -:  271:
    #####:  272:  if (JERRY_UNLIKELY (value_p == NULL))
        -:  273:  {
    #####:  274:    JERRY_ASSERT (add > 0);
        -:  275:
    #####:  276:    value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:  277:
    #####:  278:    if (JERRY_UNLIKELY (value_p == NULL))
        -:  279:    {
    #####:  280:      return NULL;
        -:  281:    }
        -:  282:
    #####:  283:    *ECMA_BIGINT_GET_DIGITS (value_p, 0) = add;
    #####:  284:    return value_p;
        -:  285:  }
        -:  286:
    #####:  287:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  288:
    #####:  289:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  290:
    #####:  291:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  292:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
    #####:  293:  ecma_bigint_digit_t carry = add;
        -:  294:
        -:  295:  do
        -:  296:  {
    #####:  297:    ecma_bigint_two_digits_t multiply_result = ((ecma_bigint_two_digits_t) *current_p) * mul;
        -:  298:    ecma_bigint_digit_t multiply_result_low, new_carry;
        -:  299:
    #####:  300:    multiply_result_low = (ecma_bigint_digit_t) multiply_result;
    #####:  301:    new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  302:
    #####:  303:    multiply_result_low += carry;
    #####:  304:    if (multiply_result_low < carry)
        -:  305:    {
    #####:  306:      new_carry++;
        -:  307:    }
        -:  308:
    #####:  309:    *current_p++ = multiply_result_low;
    #####:  310:    carry = new_carry;
    #####:  311:  } while (current_p < end_p);
        -:  312:
    #####:  313:  if (carry == 0)
        -:  314:  {
    #####:  315:    return value_p;
        -:  316:  }
        -:  317:
    #####:  318:  return ecma_big_uint_extend (value_p, carry);
        -:  319:} /* ecma_big_uint_mul_digit */
        -:  320:
        -:  321:/**
        -:  322: * Convert a BigUInt to a human readable number
        -:  323: *
        -:  324: * return char sequence on success, NULL otherwise
        -:  325: */
        -:  326:lit_utf8_byte_t *
    #####:  327:ecma_big_uint_to_string (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  328:                         uint32_t radix, /**< radix number between 2 and 36 */
        -:  329:                         uint32_t *char_start_p, /**< [out] start offset of numbers */
        -:  330:                         uint32_t *char_size_p) /**< [out] size of the output buffer */
        -:  331:{
    #####:  332:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  333:
    #####:  334:  JERRY_ASSERT (radix >= 2 && radix <= 36);
    #####:  335:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  336:
    #####:  337:  uint32_t max_size = size * 8;
        -:  338:
    #####:  339:  if (radix < 16)
        -:  340:  {
    #####:  341:    if (radix >= 8)
        -:  342:    {
        -:  343:      /* Most frequent case. */
    #####:  344:      max_size = (max_size + 2) / 3;
        -:  345:    }
    #####:  346:    else if (radix >= 4)
        -:  347:    {
    #####:  348:      max_size = (max_size + 1) >> 1;
        -:  349:    }
        -:  350:  }
    #####:  351:  else if (radix < 32)
        -:  352:  {
    #####:  353:    max_size = (max_size + 3) >> 2;
        -:  354:  }
        -:  355:  else
        -:  356:  {
    #####:  357:    max_size = (max_size + 4) / 5;
        -:  358:  }
        -:  359:
        -:  360:  /* This space can be used to store a sign. */
    #####:  361:  max_size += (uint32_t) (2 * sizeof (ecma_bigint_digit_t) - 1);
    #####:  362:  max_size &= ~(uint32_t) (sizeof (ecma_bigint_digit_t) - 1);
    #####:  363:  *char_size_p = max_size;
        -:  364:
    #####:  365:  lit_utf8_byte_t *result_p = (lit_utf8_byte_t *) jmem_heap_alloc_block_null_on_error (max_size);
        -:  366:
    #####:  367:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  368:  {
    #####:  369:    return NULL;
        -:  370:  }
        -:  371:
    #####:  372:  memcpy (result_p, value_p + 1, size);
        -:  373:
    #####:  374:  ecma_bigint_digit_t *start_p = (ecma_bigint_digit_t *) (result_p + size);
    #####:  375:  ecma_bigint_digit_t *end_p = (ecma_bigint_digit_t *) result_p;
    #####:  376:  lit_utf8_byte_t *string_p = result_p + max_size;
        -:  377:
        -:  378:  do
        -:  379:  {
    #####:  380:    ecma_bigint_digit_t *current_p = (ecma_bigint_digit_t *) start_p;
    #####:  381:    ecma_bigint_digit_t remainder = 0;
        -:  382:
        -:  383:    if (sizeof (uintptr_t) == sizeof (ecma_bigint_two_digits_t))
        -:  384:    {
        -:  385:      do
        -:  386:      {
    #####:  387:        ecma_bigint_two_digits_t result = *(--current_p) | ECMA_BIGINT_HIGH_DIGIT (remainder);
        -:  388:
    #####:  389:        *current_p = (ecma_bigint_digit_t) (result / radix);
    #####:  390:        remainder = (ecma_bigint_digit_t) (result % radix);
    #####:  391:      } while (current_p > end_p);
        -:  392:    }
        -:  393:    else
        -:  394:    {
    #####:  395:      if (ECMA_BIGINT_SIZE_IS_ODD ((uintptr_t) current_p - (uintptr_t) end_p))
        -:  396:      {
    #####:  397:        ecma_bigint_digit_t result = *(--current_p);
    #####:  398:        *current_p = result / radix;
    #####:  399:        remainder = result % radix;
        -:  400:      }
        -:  401:
    #####:  402:      while (current_p > end_p)
        -:  403:      {
        -:  404:        /* The following algorithm splits the 64 bit input into three numbers, extend
        -:  405:         * them with remainder, divide them by radix, and updates the three bit ranges
        -:  406:         * corresponding to the three numbers. */
        -:  407:
    #####:  408:        const uint32_t extract_bits_low = 10;
    #####:  409:        const uint32_t extract_bits_low_mask = (uint32_t) ((1 << extract_bits_low) - 1);
    #####:  410:        const uint32_t extract_bits_high = (uint32_t) ((sizeof (ecma_bigint_digit_t) * 8) - extract_bits_low);
    #####:  411:        const uint32_t extract_bits_high_mask = (uint32_t) ((1 << extract_bits_high) - 1);
        -:  412:
    #####:  413:        ecma_bigint_digit_t result_high = current_p[-1];
    #####:  414:        ecma_bigint_digit_t result_mid = (result_high & extract_bits_low_mask) << extract_bits_low;
        -:  415:
    #####:  416:        result_high = (result_high >> extract_bits_low) | (remainder << extract_bits_high);
    #####:  417:        result_mid |= (result_high % radix) << (extract_bits_low * 2);
    #####:  418:        result_high = (result_high / radix) << extract_bits_low;
        -:  419:
    #####:  420:        ecma_bigint_digit_t result_low = current_p[-2];
    #####:  421:        result_mid |= result_low >> extract_bits_high;
    #####:  422:        result_low = (result_low & extract_bits_high_mask) | ((result_mid % radix) << extract_bits_high);
        -:  423:
    #####:  424:        result_mid = result_mid / radix;
        -:  425:
    #####:  426:        current_p[-1] = result_high | (result_mid >> extract_bits_low);
    #####:  427:        current_p[-2] = (result_low / radix) | (result_mid << extract_bits_high);
        -:  428:
    #####:  429:        remainder = result_low % radix;
    #####:  430:        current_p -= 2;
        -:  431:      }
        -:  432:    }
        -:  433:
    #####:  434:    *(--string_p) =
    #####:  435:      (lit_utf8_byte_t) ((remainder < 10) ? (remainder + LIT_CHAR_0) : (remainder + (LIT_CHAR_LOWERCASE_A - 10)));
    #####:  436:    JERRY_ASSERT (string_p >= (lit_utf8_byte_t *) start_p);
        -:  437:
    #####:  438:    if (start_p[-1] == 0)
        -:  439:    {
    #####:  440:      start_p--;
        -:  441:    }
    #####:  442:  } while (start_p > end_p);
        -:  443:
    #####:  444:  *char_start_p = (uint32_t) (string_p - result_p);
    #####:  445:  return result_p;
        -:  446:} /* ecma_big_uint_to_string */
        -:  447:
        -:  448:/**
        -:  449: * Increase the value of a BigUInt value by 1
        -:  450: *
        -:  451: * return new BigUInt value, NULL on error
        -:  452: */
        -:  453:ecma_extended_primitive_t *
    #####:  454:ecma_big_uint_increase (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  455:{
    #####:  456:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  457:
    #####:  458:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  459:
    #####:  460:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  461:  ecma_bigint_digit_t *digits_end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  462:
    #####:  463:  if (JERRY_UNLIKELY (digits_p[0] == ~((ecma_bigint_digit_t) 0) && digits_end_p[-1] == ~((ecma_bigint_digit_t) 0)))
        -:  464:  {
        -:  465:    do
        -:  466:    {
    #####:  467:      digits_p++;
    #####:  468:    } while (digits_p < digits_end_p && digits_p[0] == ~((ecma_bigint_digit_t) 0));
        -:  469:
    #####:  470:    if (digits_p == digits_end_p)
        -:  471:    {
        -:  472:      ecma_extended_primitive_t *result_value_p;
    #####:  473:      result_value_p = ecma_bigint_create ((uint32_t) (size + sizeof (ecma_bigint_digit_t)));
        -:  474:
    #####:  475:      if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  476:      {
    #####:  477:        return NULL;
        -:  478:      }
        -:  479:
    #####:  480:      memset (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), 0, size);
    #####:  481:      *ECMA_BIGINT_GET_DIGITS (result_value_p, size) = 1;
    #####:  482:      return result_value_p;
        -:  483:    }
        -:  484:
    #####:  485:    digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  486:  }
        -:  487:
    #####:  488:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  489:
    #####:  490:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  491:  {
    #####:  492:    return NULL;
        -:  493:  }
        -:  494:
    #####:  495:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  496:
    #####:  497:  while (digits_p[0] == ~((ecma_bigint_digit_t) 0))
        -:  498:  {
    #####:  499:    digits_p++;
    #####:  500:    *result_p++ = 0;
        -:  501:  }
        -:  502:
    #####:  503:  *result_p++ = (*digits_p++) + 1;
        -:  504:
    #####:  505:  if (digits_p < digits_end_p)
        -:  506:  {
    #####:  507:    memcpy (result_p, digits_p, (size_t) ((uint8_t *) digits_end_p - (uint8_t *) digits_p));
        -:  508:  }
    #####:  509:  return result_value_p;
        -:  510:} /* ecma_big_uint_increase */
        -:  511:
        -:  512:/**
        -:  513: * Decrease the value of a BigUInt value by 1
        -:  514: *
        -:  515: * return new BigUInt value, NULL on error
        -:  516: */
        -:  517:ecma_extended_primitive_t *
    #####:  518:ecma_big_uint_decrease (ecma_extended_primitive_t *value_p) /**< BigUInt value */
        -:  519:{
    #####:  520:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  521:
    #####:  522:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  523:
    #####:  524:  ecma_bigint_digit_t *digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  525:  ecma_bigint_digit_t *digits_end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  526:
    #####:  527:  JERRY_ASSERT (size > sizeof (ecma_bigint_digit_t) || *digits_p > 1);
        -:  528:
    #####:  529:  if (JERRY_UNLIKELY (digits_p[0] == 0 && digits_end_p[-1] == 1))
        -:  530:  {
        -:  531:    do
        -:  532:    {
    #####:  533:      digits_p++;
    #####:  534:      JERRY_ASSERT (digits_p < digits_end_p);
    #####:  535:    } while (digits_p[0] == 0);
        -:  536:
    #####:  537:    if (digits_p + 1 == digits_end_p)
        -:  538:    {
    #####:  539:      size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####:  540:      ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  541:
    #####:  542:      if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  543:      {
    #####:  544:        return NULL;
        -:  545:      }
        -:  546:
    #####:  547:      memset (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), 0xff, size);
    #####:  548:      return result_value_p;
        -:  549:    }
        -:  550:
    #####:  551:    digits_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
        -:  552:  }
        -:  553:
    #####:  554:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -:  555:
    #####:  556:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -:  557:  {
    #####:  558:    return NULL;
        -:  559:  }
        -:  560:
    #####:  561:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -:  562:
    #####:  563:  while (digits_p[0] == 0)
        -:  564:  {
    #####:  565:    digits_p++;
    #####:  566:    *result_p++ = ~((ecma_bigint_digit_t) 0);
        -:  567:  }
        -:  568:
    #####:  569:  *result_p++ = (*digits_p++) - 1;
        -:  570:
    #####:  571:  if (digits_p < digits_end_p)
        -:  572:  {
    #####:  573:    memcpy (result_p, digits_p, (size_t) ((uint8_t *) digits_end_p - (uint8_t *) digits_p));
        -:  574:  }
    #####:  575:  return result_value_p;
        -:  576:} /* ecma_big_uint_decrease */
        -:  577:
        -:  578:/**
        -:  579: * Add right BigUInt value to the left BigUInt value
        -:  580: *
        -:  581: * return new BigUInt value, NULL on error
        -:  582: */
        -:  583:ecma_extended_primitive_t *
    #####:  584:ecma_big_uint_add (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  585:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  586:{
    #####:  587:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  588:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  589:
    #####:  590:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  591:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  592:
    #####:  593:  if (left_size < right_size)
        -:  594:  {
        -:  595:    /* Swap values. */
    #####:  596:    ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####:  597:    left_value_p = right_value_p;
    #####:  598:    right_value_p = tmp_value_p;
        -:  599:
    #####:  600:    uint32_t tmp_size = left_size;
    #####:  601:    left_size = right_size;
    #####:  602:    right_size = tmp_size;
        -:  603:  }
        -:  604:
    #####:  605:  ecma_extended_primitive_t *result_p = ecma_bigint_create (left_size);
        -:  606:
    #####:  607:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  608:  {
    #####:  609:    return NULL;
        -:  610:  }
        -:  611:
    #####:  612:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  613:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_p, right_size);
    #####:  614:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  615:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  616:  ecma_bigint_digit_t carry = 0;
        -:  617:
    #####:  618:  left_size -= right_size;
        -:  619:
        -:  620:  do
        -:  621:  {
    #####:  622:    ecma_bigint_digit_t left = *left_p++;
        -:  623:
    #####:  624:    if (carry == 0 || left != ~(ecma_bigint_digit_t) 0)
        -:  625:    {
    #####:  626:      left += carry;
    #####:  627:      carry = 0;
        -:  628:    }
        -:  629:    else
        -:  630:    {
    #####:  631:      left = 0;
    #####:  632:      carry = 1;
        -:  633:    }
        -:  634:
    #####:  635:    ecma_bigint_digit_t right = *right_p++;
    #####:  636:    left += right;
        -:  637:
    #####:  638:    if (left < right)
        -:  639:    {
    #####:  640:      JERRY_ASSERT (carry == 0);
    #####:  641:      carry = 1;
        -:  642:    }
        -:  643:
    #####:  644:    *current_p++ = left;
    #####:  645:  } while (current_p < end_p);
        -:  646:
    #####:  647:  end_p = (ecma_bigint_digit_t *) (((uint8_t *) end_p) + left_size);
        -:  648:
    #####:  649:  if (carry != 0)
        -:  650:  {
        -:  651:    while (true)
    #####:  652:    {
    #####:  653:      if (JERRY_UNLIKELY (current_p == end_p))
        -:  654:      {
    #####:  655:        return ecma_big_uint_extend (result_p, 1);
        -:  656:      }
        -:  657:
    #####:  658:      ecma_bigint_digit_t value = *left_p++;
        -:  659:
    #####:  660:      if (value != ~(ecma_bigint_digit_t) 0)
        -:  661:      {
    #####:  662:        *current_p++ = value + 1;
    #####:  663:        break;
        -:  664:      }
        -:  665:
    #####:  666:      *current_p++ = 0;
        -:  667:    }
        -:  668:  }
        -:  669:
    #####:  670:  if (current_p < end_p)
        -:  671:  {
    #####:  672:    memcpy (current_p, left_p, (size_t) ((uint8_t *) end_p - (uint8_t *) current_p));
        -:  673:  }
        -:  674:
    #####:  675:  return result_p;
        -:  676:} /* ecma_big_uint_add */
        -:  677:
        -:  678:/**
        -:  679: * Substract right BigUInt value from the left BigUInt value
        -:  680: *
        -:  681: * return new BigUInt value, NULL on error
        -:  682: */
        -:  683:ecma_extended_primitive_t *
    #####:  684:ecma_big_uint_sub (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  685:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  686:{
    #####:  687:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  688:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  689:
    #####:  690:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  691:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
    #####:  692:  JERRY_ASSERT (left_size >= right_size);
        -:  693:
    #####:  694:  ecma_extended_primitive_t *result_p = ecma_bigint_create (left_size);
        -:  695:
    #####:  696:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  697:  {
    #####:  698:    return NULL;
        -:  699:  }
        -:  700:
    #####:  701:  ecma_bigint_digit_t *current_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  702:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_p, right_size);
    #####:  703:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  704:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  705:  ecma_bigint_digit_t carry = 0;
        -:  706:
    #####:  707:  left_size -= right_size;
        -:  708:
        -:  709:  do
        -:  710:  {
    #####:  711:    ecma_bigint_digit_t left = *left_p++;
    #####:  712:    ecma_bigint_digit_t right = *right_p++;
        -:  713:
    #####:  714:    if (carry == 0 || left != 0)
        -:  715:    {
    #####:  716:      left -= carry;
    #####:  717:      carry = left < right;
        -:  718:    }
        -:  719:    else
        -:  720:    {
    #####:  721:      left = ~(ecma_bigint_digit_t) 0;
    #####:  722:      carry = 1;
        -:  723:    }
        -:  724:
    #####:  725:    *current_p++ = left - right;
    #####:  726:  } while (current_p < end_p);
        -:  727:
    #####:  728:  end_p = (ecma_bigint_digit_t *) (((uint8_t *) end_p) + left_size);
        -:  729:
    #####:  730:  if (carry != 0)
        -:  731:  {
        -:  732:    while (true)
    #####:  733:    {
    #####:  734:      JERRY_ASSERT (current_p < end_p);
        -:  735:
    #####:  736:      ecma_bigint_digit_t value = *left_p++;
        -:  737:
    #####:  738:      if (value != 0)
        -:  739:      {
    #####:  740:        *current_p++ = value - 1;
    #####:  741:        break;
        -:  742:      }
        -:  743:
    #####:  744:      *current_p++ = ~(ecma_bigint_digit_t) 0;
        -:  745:    }
        -:  746:  }
        -:  747:
    #####:  748:  if (current_p < end_p)
        -:  749:  {
    #####:  750:    memcpy (current_p, left_p, (size_t) ((uint8_t *) end_p - (uint8_t *) current_p));
    #####:  751:    return result_p;
        -:  752:  }
        -:  753:
    #####:  754:  if (current_p[-1] != 0)
        -:  755:  {
    #####:  756:    return result_p;
        -:  757:  }
        -:  758:
    #####:  759:  return ecma_big_uint_normalize_result (result_p, current_p);
        -:  760:} /* ecma_big_uint_sub */
        -:  761:
        -:  762:/**
        -:  763: * Multiply two BigUInt values
        -:  764: *
        -:  765: * return new BigUInt value, NULL on error
        -:  766: */
        -:  767:ecma_extended_primitive_t *
    #####:  768:ecma_big_uint_mul (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  769:                   ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -:  770:{
    #####:  771:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####:  772:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -:  773:
    #####:  774:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  775:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -:  776:
    #####:  777:  if (left_size < right_size)
        -:  778:  {
        -:  779:    /* Swap values. */
    #####:  780:    ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####:  781:    left_value_p = right_value_p;
    #####:  782:    right_value_p = tmp_value_p;
        -:  783:
    #####:  784:    uint32_t tmp_size = left_size;
    #####:  785:    left_size = right_size;
    #####:  786:    right_size = tmp_size;
        -:  787:  }
        -:  788:
    #####:  789:  uint32_t result_size = left_size + right_size - (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  790:
    #####:  791:  ecma_extended_primitive_t *result_p = ecma_bigint_create (result_size);
        -:  792:
    #####:  793:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  794:  {
    #####:  795:    return NULL;
        -:  796:  }
        -:  797:
    #####:  798:  memset (ECMA_BIGINT_GET_DIGITS (result_p, 0), 0, result_size);
        -:  799:
        -:  800:  /* Lower amount of space is allocated by default. This value provides extra space if needed. */
    #####:  801:  ecma_bigint_digit_t extra_space[1] = { 0 };
        -:  802:
    #####:  803:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####:  804:  ecma_bigint_digit_t *right_end_p = ECMA_BIGINT_GET_DIGITS (right_value_p, right_size);
    #####:  805:  ecma_bigint_digit_t *left_start_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####:  806:  ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
        -:  807:
    #####:  808:  ecma_bigint_digit_t *result_start_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
    #####:  809:  ecma_bigint_digit_t *result_end_p = ECMA_BIGINT_GET_DIGITS (result_p, result_size);
        -:  810:
        -:  811:  do
        -:  812:  {
    #####:  813:    ecma_bigint_two_digits_t right = *right_p++;
        -:  814:
    #####:  815:    if (right == 0)
        -:  816:    {
    #####:  817:      result_start_p++;
    #####:  818:      continue;
        -:  819:    }
        -:  820:
    #####:  821:    ecma_bigint_digit_t *left_p = left_start_p;
    #####:  822:    ecma_bigint_digit_t *destination_p = result_start_p;
    #####:  823:    ecma_bigint_digit_t carry = 0;
        -:  824:
        -:  825:    do
        -:  826:    {
    #####:  827:      JERRY_ASSERT (destination_p != (ecma_bigint_digit_t *) (extra_space + 1));
        -:  828:
        -:  829:      ecma_bigint_two_digits_t multiply_result;
        -:  830:      ecma_bigint_digit_t multiply_result_low, new_carry;
    #####:  831:      ecma_bigint_digit_t value = *destination_p;
        -:  832:
    #####:  833:      multiply_result = ((ecma_bigint_two_digits_t) (*left_p++)) * ((ecma_bigint_two_digits_t) right);
    #####:  834:      multiply_result_low = (ecma_bigint_digit_t) multiply_result;
    #####:  835:      value += multiply_result_low;
    #####:  836:      new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
        -:  837:
        -:  838:      /* The new_carry can never overflow because:
        -:  839:       *   a) If left or right is less than 0xff..ff, new_carry will be less than or equal to
        -:  840:       *      0xff...fd, and increasing it by maximum of two (carries) cannot overflow.
        -:  841:       *   b) If left and right are both equal to 0xff..ff, multiply_result_low will be 1,
        -:  842:       *      and computing value + carry + 1 can only increase new_carry at most once. */
        -:  843:
    #####:  844:      if (value < multiply_result_low)
        -:  845:      {
    #####:  846:        JERRY_ASSERT (new_carry < ~(ecma_bigint_digit_t) 0);
    #####:  847:        new_carry++;
        -:  848:      }
        -:  849:
    #####:  850:      value += carry;
        -:  851:
    #####:  852:      if (value < carry)
        -:  853:      {
    #####:  854:        JERRY_ASSERT (new_carry < ~(ecma_bigint_digit_t) 0);
    #####:  855:        new_carry++;
        -:  856:      }
        -:  857:
    #####:  858:      carry = new_carry;
    #####:  859:      *destination_p++ = value;
        -:  860:
    #####:  861:      if (destination_p == result_end_p)
        -:  862:      {
    #####:  863:        destination_p = (ecma_bigint_digit_t *) extra_space;
        -:  864:      }
    #####:  865:    } while (left_p < left_end_p);
        -:  866:
    #####:  867:    while (carry > 0)
        -:  868:    {
    #####:  869:      JERRY_ASSERT (destination_p != (ecma_bigint_digit_t *) (extra_space + 1));
        -:  870:
    #####:  871:      ecma_bigint_digit_t value = *destination_p;
        -:  872:
    #####:  873:      value += carry;
    #####:  874:      carry = (value < carry);
        -:  875:
    #####:  876:      *destination_p++ = value;
        -:  877:
    #####:  878:      if (destination_p == result_end_p)
        -:  879:      {
    #####:  880:        destination_p = (ecma_bigint_digit_t *) extra_space;
        -:  881:      }
        -:  882:    }
        -:  883:
    #####:  884:    result_start_p++;
    #####:  885:  } while (right_p < right_end_p);
        -:  886:
    #####:  887:  if (extra_space[0] == 0)
        -:  888:  {
    #####:  889:    return result_p;
        -:  890:  }
        -:  891:
    #####:  892:  return ecma_big_uint_extend (result_p, extra_space[0]);
        -:  893:} /* ecma_big_uint_mul */
        -:  894:
        -:  895:/**
        -:  896: * Divide left BigUInt value with right digit value
        -:  897: *
        -:  898: * return new BigUInt value, NULL on error
        -:  899: */
        -:  900:static ecma_extended_primitive_t *
    #####:  901:ecma_big_uint_div_digit (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -:  902:                         ecma_bigint_digit_t divisor_digit, /**< divisor value */
        -:  903:                         bool is_mod) /**< true if return with remainder */
        -:  904:{
    #####:  905:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
        -:  906:
    #####:  907:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####:  908:  JERRY_ASSERT (divisor_digit > 0);
        -:  909:
    #####:  910:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size - sizeof (ecma_bigint_digit_t));
    #####:  911:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
        -:  912:
    #####:  913:  ecma_bigint_digit_t last_digit = *left_p;
    #####:  914:  ecma_bigint_digit_t remainder = last_digit % divisor_digit;
        -:  915:
    #####:  916:  last_digit = last_digit / divisor_digit;
        -:  917:
    #####:  918:  ecma_extended_primitive_t *result_p = NULL;
    #####:  919:  ecma_bigint_digit_t *current_p = NULL;
        -:  920:
    #####:  921:  if (!is_mod)
        -:  922:  {
    #####:  923:    ecma_bigint_digit_t result_size = left_size;
        -:  924:
    #####:  925:    if (last_digit == 0)
        -:  926:    {
    #####:  927:      result_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -:  928:    }
        -:  929:
    #####:  930:    result_p = ecma_bigint_create (result_size);
        -:  931:
    #####:  932:    if (JERRY_UNLIKELY (result_p == NULL))
        -:  933:    {
    #####:  934:      return NULL;
        -:  935:    }
        -:  936:
    #####:  937:    current_p = ECMA_BIGINT_GET_DIGITS (result_p, result_size);
        -:  938:
    #####:  939:    if (last_digit != 0)
        -:  940:    {
    #####:  941:      *(--current_p) = last_digit;
        -:  942:    }
        -:  943:  }
        -:  944:
    #####:  945:  while (left_p > end_p)
        -:  946:  {
    #####:  947:    const uint32_t shift = 1 << ECMA_BIGINT_DIGIT_SHIFT;
        -:  948:
    #####:  949:    ecma_bigint_two_digits_t result = *(--left_p) | (((ecma_bigint_two_digits_t) remainder) << shift);
        -:  950:
    #####:  951:    if (!is_mod)
        -:  952:    {
    #####:  953:      *(--current_p) = (ecma_bigint_digit_t) (result / divisor_digit);
        -:  954:    }
        -:  955:
    #####:  956:    remainder = (ecma_bigint_digit_t) (result % divisor_digit);
        -:  957:  }
        -:  958:
    #####:  959:  if (!is_mod)
        -:  960:  {
    #####:  961:    JERRY_ASSERT (current_p == ECMA_BIGINT_GET_DIGITS (result_p, 0));
    #####:  962:    return result_p;
        -:  963:  }
        -:  964:
    #####:  965:  if (remainder == 0)
        -:  966:  {
    #####:  967:    return ECMA_BIGINT_POINTER_TO_ZERO;
        -:  968:  }
        -:  969:
    #####:  970:  result_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
        -:  971:
    #####:  972:  if (JERRY_UNLIKELY (result_p == NULL))
        -:  973:  {
    #####:  974:    return NULL;
        -:  975:  }
        -:  976:
    #####:  977:  *ECMA_BIGINT_GET_DIGITS (result_p, 0) = remainder;
    #####:  978:  return result_p;
        -:  979:} /* ecma_big_uint_div_digit */
        -:  980:
        -:  981:/**
        -:  982: * Shift left a BigUInt value by a digit value
        -:  983: *
        -:  984: * return newly allocated buffer, NULL on error
        -:  985: */
        -:  986:static ecma_bigint_digit_t *
    #####:  987:ecma_big_uint_div_shift_left (ecma_extended_primitive_t *value_p, /**< BigUInt value */
        -:  988:                              ecma_bigint_digit_t shift_left, /**< left shift */
        -:  989:                              bool extend) /**< extend the result with an extra digit */
        -:  990:{
    #####:  991:  uint32_t size = ECMA_BIGINT_GET_SIZE (value_p);
        -:  992:
    #####:  993:  JERRY_ASSERT (size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (value_p, size) != 0);
        -:  994:
    #####:  995:  ecma_bigint_digit_t *source_p = ECMA_BIGINT_GET_DIGITS (value_p, 0);
    #####:  996:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (value_p, size);
        -:  997:
    #####:  998:  if (extend)
        -:  999:  {
    #####: 1000:    size += (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1001:  }
        -: 1002:
    #####: 1003:  ecma_bigint_digit_t *result_p = (ecma_bigint_digit_t *) jmem_heap_alloc_block_null_on_error (size);
        -: 1004:
    #####: 1005:  if (JERRY_UNLIKELY (result_p == NULL))
        -: 1006:  {
    #####: 1007:    return result_p;
        -: 1008:  }
        -: 1009:
    #####: 1010:  if (shift_left == 0)
        -: 1011:  {
    #####: 1012:    JERRY_ASSERT (extend);
        -: 1013:
    #####: 1014:    size -= (uint32_t) sizeof (ecma_bigint_digit_t);
    #####: 1015:    *(ecma_bigint_digit_t *) (((uint8_t *) result_p) + size) = 0;
        -: 1016:
    #####: 1017:    memcpy (result_p, source_p, size);
    #####: 1018:    return result_p;
        -: 1019:  }
        -: 1020:
    #####: 1021:  ecma_bigint_digit_t *destination_p = result_p;
    #####: 1022:  ecma_bigint_digit_t carry = 0;
    #####: 1023:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -: 1024:
        -: 1025:  do
        -: 1026:  {
    #####: 1027:    ecma_bigint_digit_t value = *source_p++;
        -: 1028:
    #####: 1029:    *destination_p++ = (value << shift_left) | carry;
    #####: 1030:    carry = value >> shift_right;
    #####: 1031:  } while (source_p < end_p);
        -: 1032:
    #####: 1033:  if (extend)
        -: 1034:  {
    #####: 1035:    *destination_p++ = carry;
        -: 1036:  }
        -: 1037:
    #####: 1038:  return result_p;
        -: 1039:} /* ecma_big_uint_div_shift_left */
        -: 1040:
        -: 1041:/**
        -: 1042: * Divide left BigUInt value with right BigUInt value
        -: 1043: *
        -: 1044: * return new BigUInt value, NULL on error
        -: 1045: */
        -: 1046:ecma_extended_primitive_t *
    #####: 1047:ecma_big_uint_div_mod (ecma_extended_primitive_t *dividend_value_p, /**< divider BigUInt value */
        -: 1048:                       ecma_extended_primitive_t *divisor_value_p, /**< divisor BigUInt value */
        -: 1049:                       bool is_mod) /**< true if return with remainder instead of quotient */
        -: 1050:{
        -: 1051:  /* This algorithm is based on Donald Knuth’s "Algorithm D" */
    #####: 1052:  uint32_t divisor_size = ECMA_BIGINT_GET_SIZE (divisor_value_p);
        -: 1053:
    #####: 1054:  JERRY_ASSERT (divisor_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (divisor_value_p, divisor_size) != 0);
        -: 1055:
        -: 1056:  /* The divisor must have at least two digits, so the single digit case is handled separately. */
    #####: 1057:  if (divisor_size == sizeof (ecma_bigint_digit_t))
        -: 1058:  {
    #####: 1059:    return ecma_big_uint_div_digit (dividend_value_p, *ECMA_BIGINT_GET_DIGITS (divisor_value_p, 0), is_mod);
        -: 1060:  }
        -: 1061:
        -: 1062:  /* D1. [Normalize] */
    #####: 1063:  ecma_bigint_digit_t divisor_high = ECMA_BIGINT_GET_LAST_DIGIT (divisor_value_p, divisor_size);
    #####: 1064:  ecma_bigint_digit_t shift_left = ecma_big_uint_count_leading_zero (divisor_high);
    #####: 1065:  ecma_bigint_digit_t *buffer_p = ecma_big_uint_div_shift_left (dividend_value_p, shift_left, true);
        -: 1066:
    #####: 1067:  if (JERRY_UNLIKELY (buffer_p == NULL))
        -: 1068:  {
    #####: 1069:    return NULL;
        -: 1070:  }
        -: 1071:
    #####: 1072:  uint32_t dividend_size = ECMA_BIGINT_GET_SIZE (dividend_value_p);
    #####: 1073:  ecma_extended_primitive_t *result_p = NULL;
        -: 1074:  ecma_bigint_digit_t *divisor_p;
        -: 1075:
    #####: 1076:  JERRY_ASSERT (dividend_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (dividend_value_p, dividend_size) != 0);
    #####: 1077:  JERRY_ASSERT (dividend_size >= divisor_size);
        -: 1078:
    #####: 1079:  if (shift_left > 0)
        -: 1080:  {
    #####: 1081:    divisor_p = ecma_big_uint_div_shift_left (divisor_value_p, shift_left, false);
        -: 1082:
    #####: 1083:    if (JERRY_UNLIKELY (divisor_p == NULL))
        -: 1084:    {
    #####: 1085:      goto error;
        -: 1086:    }
        -: 1087:  }
        -: 1088:  else
        -: 1089:  {
    #####: 1090:    divisor_p = ECMA_BIGINT_GET_DIGITS (divisor_value_p, 0);
        -: 1091:  }
        -: 1092:
    #####: 1093:  ecma_bigint_digit_t *dividend_end_p = (ecma_bigint_digit_t *) (((uint8_t *) buffer_p) + dividend_size);
    #####: 1094:  ecma_bigint_digit_t *dividend_p = (ecma_bigint_digit_t *) (((uint8_t *) dividend_end_p) - divisor_size);
    #####: 1095:  ecma_bigint_digit_t *divisor_end_p = (ecma_bigint_digit_t *) (((uint8_t *) divisor_p) + divisor_size);
    #####: 1096:  ecma_bigint_digit_t divisor_low = divisor_end_p[-2];
        -: 1097:
    #####: 1098:  divisor_high = divisor_end_p[-1];
    #####: 1099:  JERRY_ASSERT ((divisor_high & (((ecma_bigint_digit_t) 1) << (8 * sizeof (ecma_bigint_digit_t) - 1))) != 0);
        -: 1100:
        -: 1101:  do
        -: 1102:  {
        -: 1103:    /* D3. [Calculate Q′] */
        -: 1104:    ecma_bigint_digit_t result_div;
        -: 1105:
        -: 1106:    /* This do-while(false) statement allows local declarations and early exit. */
        -: 1107:    do
        -: 1108:    {
        -: 1109:      ecma_bigint_digit_t result_mod;
        -: 1110:
    #####: 1111:      if (dividend_end_p[0] < divisor_high)
        -: 1112:      {
    #####: 1113:        ecma_bigint_two_digits_t dividend = dividend_end_p[-1] | ECMA_BIGINT_HIGH_DIGIT (dividend_end_p[0]);
    #####: 1114:        result_div = (ecma_bigint_digit_t) (dividend / divisor_high);
    #####: 1115:        result_mod = (ecma_bigint_digit_t) (dividend % divisor_high);
        -: 1116:      }
        -: 1117:      else
        -: 1118:      {
    #####: 1119:        JERRY_ASSERT (dividend_end_p[0] == divisor_high && dividend_end_p[-1] < divisor_high);
        -: 1120:
    #####: 1121:        result_div = ~((ecma_bigint_digit_t) 0);
    #####: 1122:        result_mod = dividend_end_p[-1] + divisor_high;
        -: 1123:
    #####: 1124:        if (result_mod < divisor_high)
        -: 1125:        {
    #####: 1126:          break;
        -: 1127:        }
        -: 1128:      }
        -: 1129:
    #####: 1130:      ecma_bigint_two_digits_t low_digits = ((ecma_bigint_two_digits_t) result_div) * divisor_low;
        -: 1131:
    #####: 1132:      while (low_digits > (ECMA_BIGINT_HIGH_DIGIT (result_mod) | divisor_low))
        -: 1133:      {
    #####: 1134:        result_div--;
    #####: 1135:        result_mod += divisor_high;
        -: 1136:
        -: 1137:        /* If result_mod becomes a two digit long number, the condition of the loop must be true,
        -: 1138:         * so the loop can be aborted. This loop stops after maximum of two iterations, since
        -: 1139:         * the highest bit of divisor_high is set. */
    #####: 1140:        if (result_mod < divisor_high)
        -: 1141:        {
    #####: 1142:          break;
        -: 1143:        }
        -: 1144:
        -: 1145:        /* Subtraction is faster than recomputing result_div * divisor_low. */
    #####: 1146:        low_digits -= divisor_low;
        -: 1147:      }
        -: 1148:    } while (false);
        -: 1149:
        -: 1150:    /* D4. [Multiply and subtract] */
    #####: 1151:    ecma_bigint_digit_t *destination_p = dividend_p;
    #####: 1152:    ecma_bigint_digit_t *source_p = divisor_p;
    #####: 1153:    ecma_bigint_digit_t carry = 0;
        -: 1154:
        -: 1155:    do
        -: 1156:    {
    #####: 1157:      ecma_bigint_two_digits_t multiply_result = ((ecma_bigint_two_digits_t) (*source_p++)) * result_div;
        -: 1158:      ecma_bigint_digit_t multiply_result_low, new_carry;
    #####: 1159:      ecma_bigint_digit_t value = *destination_p;
        -: 1160:
        -: 1161:      /* The new carry never overflows. See the comment in ecma_big_uint_mul. */
    #####: 1162:      new_carry = (ecma_bigint_digit_t) (multiply_result >> (8 * sizeof (ecma_bigint_digit_t)));
    #####: 1163:      multiply_result_low = (ecma_bigint_digit_t) multiply_result;
        -: 1164:
    #####: 1165:      if (value < multiply_result_low)
        -: 1166:      {
    #####: 1167:        new_carry++;
        -: 1168:      }
        -: 1169:
    #####: 1170:      value -= multiply_result_low;
        -: 1171:
    #####: 1172:      if (value < carry)
        -: 1173:      {
    #####: 1174:        new_carry++;
        -: 1175:      }
        -: 1176:
    #####: 1177:      *destination_p++ = value - carry;
    #####: 1178:      carry = new_carry;
    #####: 1179:    } while (source_p < divisor_end_p);
        -: 1180:
    #####: 1181:    bool negative_result = *destination_p < carry;
    #####: 1182:    *destination_p -= carry;
        -: 1183:
    #####: 1184:    if (negative_result)
        -: 1185:    {
        -: 1186:      /* D6. [Add back] */
    #####: 1187:      result_div--;
        -: 1188:
    #####: 1189:      destination_p = dividend_p;
    #####: 1190:      source_p = divisor_p;
    #####: 1191:      carry = 0;
        -: 1192:
        -: 1193:      do
        -: 1194:      {
    #####: 1195:        ecma_bigint_digit_t left = *destination_p;
        -: 1196:
    #####: 1197:        if (carry == 0 || left != ~(ecma_bigint_digit_t) 0)
        -: 1198:        {
    #####: 1199:          left += carry;
    #####: 1200:          carry = 0;
        -: 1201:        }
        -: 1202:        else
        -: 1203:        {
    #####: 1204:          left = 0;
    #####: 1205:          carry = 1;
        -: 1206:        }
        -: 1207:
    #####: 1208:        ecma_bigint_digit_t right = *source_p++;
    #####: 1209:        left += right;
        -: 1210:
    #####: 1211:        if (left < right)
        -: 1212:        {
    #####: 1213:          JERRY_ASSERT (carry == 0);
    #####: 1214:          carry = 1;
        -: 1215:        }
        -: 1216:
    #####: 1217:        *destination_p++ = left;
    #####: 1218:      } while (source_p < divisor_end_p);
        -: 1219:    }
        -: 1220:
    #####: 1221:    *dividend_end_p = result_div;
        -: 1222:
    #####: 1223:    dividend_p--;
    #####: 1224:    dividend_end_p--;
    #####: 1225:  } while (dividend_p >= buffer_p);
        -: 1226:
        -: 1227:  ecma_bigint_digit_t *source_p;
        -: 1228:  ecma_bigint_digit_t *source_end_p;
        -: 1229:
    #####: 1230:  if (is_mod)
        -: 1231:  {
    #####: 1232:    source_p = buffer_p;
    #####: 1233:    source_end_p = dividend_end_p;
        -: 1234:
    #####: 1235:    while (source_end_p > source_p && *source_end_p == 0)
        -: 1236:    {
    #####: 1237:      source_end_p--;
        -: 1238:    }
        -: 1239:
    #####: 1240:    if ((*source_end_p >> shift_left) != 0)
        -: 1241:    {
    #####: 1242:      source_end_p++;
        -: 1243:      /* This is required to reset carry below. */
    #####: 1244:      *source_end_p = 0;
        -: 1245:    }
        -: 1246:  }
        -: 1247:  else
        -: 1248:  {
    #####: 1249:    source_p = dividend_end_p + 1;
    #####: 1250:    source_end_p = (ecma_bigint_digit_t *) (((uint8_t *) buffer_p) + dividend_size);
        -: 1251:
    #####: 1252:    if (*source_end_p != 0)
        -: 1253:    {
    #####: 1254:      source_end_p++;
        -: 1255:    }
        -: 1256:  }
        -: 1257:
    #####: 1258:  result_p = ECMA_BIGINT_POINTER_TO_ZERO;
        -: 1259:
    #####: 1260:  if (source_p < source_end_p)
        -: 1261:  {
    #####: 1262:    result_p = ecma_bigint_create ((uint32_t) ((uint8_t *) source_end_p - (uint8_t *) source_p));
        -: 1263:
    #####: 1264:    if (result_p != NULL)
        -: 1265:    {
    #####: 1266:      ecma_bigint_digit_t *destination_p = ECMA_BIGINT_GET_DIGITS (result_p, 0);
        -: 1267:
    #####: 1268:      if (is_mod && shift_left > 0)
    #####: 1269:      {
    #####: 1270:        ecma_bigint_digit_t shift_right = shift_left;
        -: 1271:
    #####: 1272:        shift_left = (ecma_bigint_digit_t) (8 * (sizeof (ecma_bigint_digit_t)) - shift_left);
    #####: 1273:        destination_p += source_end_p - source_p;
        -: 1274:
    #####: 1275:        ecma_bigint_digit_t carry = *source_end_p << shift_left;
        -: 1276:
        -: 1277:        do
        -: 1278:        {
    #####: 1279:          ecma_bigint_digit_t value = *(--source_end_p);
        -: 1280:
    #####: 1281:          *(--destination_p) = (value >> shift_right) | carry;
    #####: 1282:          carry = value << shift_left;
    #####: 1283:        } while (source_end_p > source_p);
        -: 1284:      }
        -: 1285:      else
        -: 1286:      {
    #####: 1287:        memcpy (destination_p, source_p, (size_t) ((uint8_t *) source_end_p - (uint8_t *) source_p));
        -: 1288:      }
        -: 1289:    }
        -: 1290:  }
        -: 1291:
    #####: 1292:error:
    #####: 1293:  jmem_heap_free_block (buffer_p, dividend_size + sizeof (ecma_bigint_digit_t));
        -: 1294:
    #####: 1295:  if (shift_left > 0 && divisor_p != NULL)
        -: 1296:  {
    #####: 1297:    jmem_heap_free_block (divisor_p, divisor_size);
        -: 1298:  }
        -: 1299:
    #####: 1300:  return result_p;
        -: 1301:} /* ecma_big_uint_div_mod */
        -: 1302:
        -: 1303:/**
        -: 1304: * Shift left BigUInt values by an uint32 value
        -: 1305: *
        -: 1306: * return new BigUInt value, NULL on error
        -: 1307: */
        -: 1308:ecma_extended_primitive_t *
    #####: 1309:ecma_big_uint_shift_left (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1310:                          uint32_t right_value) /**< shift value */
        -: 1311:{
    #####: 1312:  JERRY_ASSERT (right_value > 0);
        -: 1313:
    #####: 1314:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1315:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
        -: 1316:
    #####: 1317:  uint32_t zero_size = (right_value >> ECMA_BIGINT_DIGIT_SHIFT) * (uint32_t) sizeof (ecma_bigint_digit_t);
    #####: 1318:  uint32_t result_size = left_size + zero_size;
        -: 1319:
    #####: 1320:  uint32_t shift_left = right_value & ((1 << ECMA_BIGINT_DIGIT_SHIFT) - 1);
    #####: 1321:  uint32_t shift_right = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_left;
        -: 1322:
    #####: 1323:  if (shift_left > 0 && (ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) >> shift_right) != 0)
        -: 1324:  {
    #####: 1325:    result_size += (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1326:  }
        -: 1327:
    #####: 1328:  if (result_size > ECMA_BIGINT_MAX_SIZE)
        -: 1329:  {
    #####: 1330:    return NULL;
        -: 1331:  }
        -: 1332:
    #####: 1333:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (result_size);
        -: 1334:
    #####: 1335:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1336:  {
    #####: 1337:    return NULL;
        -: 1338:  }
        -: 1339:
    #####: 1340:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1341:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -: 1342:
    #####: 1343:  if (zero_size > 0)
        -: 1344:  {
    #####: 1345:    memset (result_p, 0, zero_size);
    #####: 1346:    result_p = (ecma_bigint_digit_t *) (((uint8_t *) result_p) + zero_size);
        -: 1347:  }
        -: 1348:
    #####: 1349:  if (shift_left == 0)
        -: 1350:  {
        -: 1351:    /* Shift by full digits. */
    #####: 1352:    memcpy (result_p, left_p, left_size);
    #####: 1353:    return result_value_p;
        -: 1354:  }
        -: 1355:
    #####: 1356:  ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####: 1357:  ecma_bigint_digit_t carry = 0;
        -: 1358:
        -: 1359:  do
        -: 1360:  {
    #####: 1361:    ecma_bigint_digit_t value = *left_p++;
        -: 1362:
    #####: 1363:    *result_p++ = (value << shift_left) | carry;
    #####: 1364:    carry = value >> shift_right;
    #####: 1365:  } while (left_p < left_end_p);
        -: 1366:
    #####: 1367:  if (carry > 0)
        -: 1368:  {
    #####: 1369:    *result_p = carry;
        -: 1370:  }
        -: 1371:
    #####: 1372:  return result_value_p;
        -: 1373:} /* ecma_big_uint_shift_left */
        -: 1374:
        -: 1375:/**
        -: 1376: * Shift right BigUInt values by an uint32 value
        -: 1377: *
        -: 1378: * @return new BigUInt value, NULL on error
        -: 1379: */
        -: 1380:ecma_extended_primitive_t *
    #####: 1381:ecma_big_uint_shift_right (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1382:                           uint32_t right_value, /**< shift value */
        -: 1383:                           bool increase_result) /**< increase result */
        -: 1384:{
    #####: 1385:  JERRY_ASSERT (right_value > 0);
        -: 1386:
    #####: 1387:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1388:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
        -: 1389:
    #####: 1390:  uint32_t crop_size = (right_value >> ECMA_BIGINT_DIGIT_SHIFT) * (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1391:
    #####: 1392:  uint32_t shift_right = right_value & ((1 << ECMA_BIGINT_DIGIT_SHIFT) - 1);
    #####: 1393:  uint32_t shift_left = (1 << ECMA_BIGINT_DIGIT_SHIFT) - shift_right;
    #####: 1394:  ecma_bigint_digit_t carry = 0;
        -: 1395:
    #####: 1396:  if (shift_right > 0 && (ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) >> shift_right) == 0)
        -: 1397:  {
    #####: 1398:    carry = ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) << shift_left;
    #####: 1399:    left_size -= (uint32_t) sizeof (ecma_bigint_digit_t);
        -: 1400:  }
        -: 1401:
    #####: 1402:  if (left_size <= crop_size)
        -: 1403:  {
    #####: 1404:    if (JERRY_LIKELY (!increase_result))
        -: 1405:    {
    #####: 1406:      return ECMA_BIGINT_POINTER_TO_ZERO;
        -: 1407:    }
        -: 1408:
    #####: 1409:    ecma_extended_primitive_t *result_value_p = ecma_bigint_create (sizeof (ecma_bigint_digit_t));
    #####: 1410:    if (result_value_p != NULL)
        -: 1411:    {
    #####: 1412:      *ECMA_BIGINT_GET_DIGITS (result_value_p, 0) = 1;
        -: 1413:    }
    #####: 1414:    return result_value_p;
        -: 1415:  }
        -: 1416:
    #####: 1417:  if (JERRY_UNLIKELY (increase_result)
    #####: 1418:      && (shift_right == 0 || (*ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size) << shift_left) == 0))
        -: 1419:  {
    #####: 1420:    ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1421:    ecma_bigint_digit_t *left_end_p = ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size);
        -: 1422:
    #####: 1423:    while (left_p < left_end_p)
        -: 1424:    {
    #####: 1425:      if (*left_p != 0)
        -: 1426:      {
    #####: 1427:        break;
        -: 1428:      }
    #####: 1429:      left_p++;
        -: 1430:    }
        -: 1431:
    #####: 1432:    if (left_p == left_end_p)
        -: 1433:    {
    #####: 1434:      increase_result = false;
        -: 1435:    }
        -: 1436:  }
        -: 1437:
    #####: 1438:  uint32_t size = left_size - crop_size;
    #####: 1439:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (size);
        -: 1440:
    #####: 1441:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1442:  {
    #####: 1443:    return NULL;
        -: 1444:  }
        -: 1445:
    #####: 1446:  if (shift_right == 0)
        -: 1447:  {
    #####: 1448:    memcpy (ECMA_BIGINT_GET_DIGITS (result_value_p, 0), ECMA_BIGINT_GET_DIGITS (left_value_p, crop_size), size);
        -: 1449:
    #####: 1450:    if (JERRY_LIKELY (!increase_result))
        -: 1451:    {
    #####: 1452:      return result_value_p;
        -: 1453:    }
    #####: 1454:    return ecma_big_uint_increase_result (result_value_p);
        -: 1455:  }
        -: 1456:
    #####: 1457:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, left_size);
    #####: 1458:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, size);
    #####: 1459:  ecma_bigint_digit_t *end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
        -: 1460:
        -: 1461:  do
        -: 1462:  {
    #####: 1463:    ecma_bigint_digit_t value = *(--left_p);
        -: 1464:
    #####: 1465:    *(--result_p) = (value >> shift_right) | carry;
    #####: 1466:    carry = value << shift_left;
    #####: 1467:  } while (result_p > end_p);
        -: 1468:
    #####: 1469:  if (JERRY_LIKELY (!increase_result))
        -: 1470:  {
    #####: 1471:    return result_value_p;
        -: 1472:  }
    #####: 1473:  return ecma_big_uint_increase_result (result_value_p);
        -: 1474:} /* ecma_big_uint_shift_right */
        -: 1475:
        -: 1476:#if JERRY_ESNEXT
        -: 1477:
        -: 1478:/**
        -: 1479: * Compute the left value raised to the power of right value
        -: 1480: *
        -: 1481: * return new BigUInt value, NULL on error
        -: 1482: */
        -: 1483:ecma_extended_primitive_t *
    #####: 1484:ecma_big_uint_pow (ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1485:                   uint32_t right_value) /**< power value */
        -: 1486:{
    #####: 1487:  ecma_extended_primitive_t *result_p = ECMA_BIGINT_NUMBER_IS_ODD (right_value) ? left_value_p : NULL;
    #####: 1488:  ecma_extended_primitive_t *square_p = left_value_p;
        -: 1489:
    #####: 1490:  JERRY_ASSERT (right_value >= 2);
        -: 1491:
        -: 1492:  while (true)
    #####: 1493:  {
    #####: 1494:    ecma_extended_primitive_t *new_square_p = ecma_big_uint_mul (square_p, square_p);
        -: 1495:
    #####: 1496:    if (JERRY_UNLIKELY (new_square_p == NULL))
        -: 1497:    {
    #####: 1498:      if (result_p != NULL && result_p != left_value_p)
        -: 1499:      {
    #####: 1500:        ecma_deref_bigint (result_p);
        -: 1501:      }
    #####: 1502:      result_p = NULL;
    #####: 1503:      break;
        -: 1504:    }
        -: 1505:
    #####: 1506:    if (square_p != left_value_p)
        -: 1507:    {
    #####: 1508:      ecma_deref_bigint (square_p);
        -: 1509:    }
        -: 1510:
    #####: 1511:    square_p = new_square_p;
    #####: 1512:    right_value >>= 1;
        -: 1513:
    #####: 1514:    if (ECMA_BIGINT_NUMBER_IS_ODD (right_value))
        -: 1515:    {
    #####: 1516:      if (result_p != NULL)
        -: 1517:      {
    #####: 1518:        ecma_extended_primitive_t *new_result_p = ecma_big_uint_mul (square_p, result_p);
        -: 1519:
    #####: 1520:        if (result_p != left_value_p)
        -: 1521:        {
    #####: 1522:          ecma_deref_bigint (result_p);
        -: 1523:        }
        -: 1524:
    #####: 1525:        result_p = new_result_p;
        -: 1526:      }
        -: 1527:      else
        -: 1528:      {
    #####: 1529:        ecma_ref_extended_primitive (square_p);
    #####: 1530:        result_p = square_p;
        -: 1531:      }
        -: 1532:
    #####: 1533:      if (JERRY_UNLIKELY (result_p == NULL) || right_value == 1)
        -: 1534:      {
        -: 1535:        break;
        -: 1536:      }
        -: 1537:    }
        -: 1538:  }
        -: 1539:
    #####: 1540:  if (square_p != left_value_p)
        -: 1541:  {
    #####: 1542:    ecma_deref_bigint (square_p);
        -: 1543:  }
        -: 1544:
    #####: 1545:  return result_p;
        -: 1546:} /* ecma_big_uint_pow */
        -: 1547:
        -: 1548:#endif /* JERRY_ESNEXT */
        -: 1549:
        -: 1550:/**
        -: 1551: * Perform bitwise operations on two BigUInt numbers
        -: 1552: *
        -: 1553: * return new BigUInt value, NULL on error
        -: 1554: */
        -: 1555:ecma_extended_primitive_t *
    #####: 1556:ecma_big_uint_bitwise_op (uint32_t operation_and_options, /**< bitwise operation type and options */
        -: 1557:                          ecma_extended_primitive_t *left_value_p, /**< left BigUInt value */
        -: 1558:                          ecma_extended_primitive_t *right_value_p) /**< right BigUInt value */
        -: 1559:{
    #####: 1560:  uint32_t left_size = ECMA_BIGINT_GET_SIZE (left_value_p);
    #####: 1561:  uint32_t right_size = ECMA_BIGINT_GET_SIZE (right_value_p);
        -: 1562:
    #####: 1563:  JERRY_ASSERT (left_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (left_value_p, left_size) != 0);
    #####: 1564:  JERRY_ASSERT (right_size > 0 && ECMA_BIGINT_GET_LAST_DIGIT (right_value_p, right_size) != 0);
        -: 1565:
    #####: 1566:  uint32_t operation_type = ECMA_BIGINT_BITWISE_GET_OPERATION_TYPE (operation_and_options);
        -: 1567:
    #####: 1568:  switch (operation_type)
        -: 1569:  {
    #####: 1570:    case ECMA_BIG_UINT_BITWISE_AND:
        -: 1571:    {
    #####: 1572:      if (left_size > right_size)
        -: 1573:      {
    #####: 1574:        left_size = right_size;
    #####: 1575:        break;
        -: 1576:      }
        -: 1577:      /* FALLTHRU */
        -: 1578:    }
        -: 1579:    case ECMA_BIG_UINT_BITWISE_AND_NOT:
        -: 1580:    {
    #####: 1581:      if (right_size > left_size)
        -: 1582:      {
    #####: 1583:        right_size = left_size;
        -: 1584:      }
    #####: 1585:      break;
        -: 1586:    }
    #####: 1587:    default:
        -: 1588:    {
    #####: 1589:      JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_OR || operation_type == ECMA_BIG_UINT_BITWISE_XOR);
        -: 1590:
    #####: 1591:      if (right_size <= left_size)
        -: 1592:      {
    #####: 1593:        break;
        -: 1594:      }
        -: 1595:
        -: 1596:      /* Swap values. */
    #####: 1597:      ecma_extended_primitive_t *tmp_value_p = left_value_p;
    #####: 1598:      left_value_p = right_value_p;
    #####: 1599:      right_value_p = tmp_value_p;
        -: 1600:
    #####: 1601:      uint32_t tmp_size = left_size;
    #####: 1602:      left_size = right_size;
    #####: 1603:      right_size = tmp_size;
        -: 1604:
    #####: 1605:      uint32_t decrease_opts = (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_BOTH);
        -: 1606:
        -: 1607:      /* When exactly one bit is set, invert both bits. */
    #####: 1608:      if (decrease_opts >= ECMA_BIG_UINT_BITWISE_DECREASE_LEFT && decrease_opts <= ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT)
        -: 1609:      {
    #####: 1610:        operation_and_options ^= ECMA_BIG_UINT_BITWISE_DECREASE_BOTH;
        -: 1611:      }
    #####: 1612:      break;
        -: 1613:    }
        -: 1614:  }
        -: 1615:
    #####: 1616:  ecma_extended_primitive_t *result_value_p = ecma_bigint_create (left_size);
        -: 1617:
    #####: 1618:  if (JERRY_UNLIKELY (result_value_p == NULL))
        -: 1619:  {
    #####: 1620:    return NULL;
        -: 1621:  }
        -: 1622:
    #####: 1623:  ecma_bigint_digit_t *left_p = ECMA_BIGINT_GET_DIGITS (left_value_p, 0);
    #####: 1624:  ecma_bigint_digit_t *right_p = ECMA_BIGINT_GET_DIGITS (right_value_p, 0);
    #####: 1625:  ecma_bigint_digit_t *result_p = ECMA_BIGINT_GET_DIGITS (result_value_p, 0);
    #####: 1626:  ecma_bigint_digit_t *result_end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, right_size);
        -: 1627:
    #####: 1628:  if (!(operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_BOTH))
        -: 1629:  {
    #####: 1630:    JERRY_ASSERT (!(operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT));
        -: 1631:
    #####: 1632:    if (operation_type == ECMA_BIG_UINT_BITWISE_AND)
        -: 1633:    {
        -: 1634:      do
        -: 1635:      {
    #####: 1636:        *result_p++ = *left_p++ & *right_p++;
    #####: 1637:      } while (result_p < result_end_p);
        -: 1638:
    #####: 1639:      if (result_p[-1] == 0)
        -: 1640:      {
    #####: 1641:        return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1642:      }
    #####: 1643:      return result_value_p;
        -: 1644:    }
        -: 1645:
    #####: 1646:    if (operation_type == ECMA_BIG_UINT_BITWISE_OR)
        -: 1647:    {
        -: 1648:      do
        -: 1649:      {
    #####: 1650:        *result_p++ = *left_p++ | *right_p++;
    #####: 1651:      } while (result_p < result_end_p);
        -: 1652:
    #####: 1653:      if (left_size > right_size)
        -: 1654:      {
    #####: 1655:        memcpy (result_p, left_p, left_size - right_size);
        -: 1656:      }
    #####: 1657:      return result_value_p;
        -: 1658:    }
        -: 1659:
    #####: 1660:    JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_XOR);
        -: 1661:
        -: 1662:    do
        -: 1663:    {
    #####: 1664:      *result_p++ = *left_p++ ^ *right_p++;
    #####: 1665:    } while (result_p < result_end_p);
        -: 1666:
    #####: 1667:    if (left_size > right_size)
        -: 1668:    {
    #####: 1669:      memcpy (result_p, left_p, left_size - right_size);
    #####: 1670:      return result_value_p;
        -: 1671:    }
        -: 1672:
    #####: 1673:    if (result_p[-1] == 0)
        -: 1674:    {
    #####: 1675:      return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1676:    }
    #####: 1677:    return result_value_p;
        -: 1678:  }
        -: 1679:
    #####: 1680:  uint32_t left_carry = 0, right_carry = 0;
        -: 1681:
    #####: 1682:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_LEFT)
        -: 1683:  {
    #####: 1684:    left_carry = 1;
        -: 1685:  }
        -: 1686:
    #####: 1687:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_DECREASE_RIGHT)
        -: 1688:  {
    #####: 1689:    right_carry = 1;
        -: 1690:  }
        -: 1691:
        -: 1692:  do
        -: 1693:  {
    #####: 1694:    ecma_bigint_digit_t left = (*left_p++) - left_carry;
        -: 1695:
    #####: 1696:    if (left != ~((ecma_bigint_digit_t) 0))
        -: 1697:    {
    #####: 1698:      left_carry = 0;
        -: 1699:    }
        -: 1700:
    #####: 1701:    ecma_bigint_digit_t right = (*right_p++) - right_carry;
        -: 1702:
    #####: 1703:    if (right != ~((ecma_bigint_digit_t) 0))
        -: 1704:    {
    #####: 1705:      right_carry = 0;
        -: 1706:    }
        -: 1707:
    #####: 1708:    switch (operation_type)
        -: 1709:    {
    #####: 1710:      case ECMA_BIG_UINT_BITWISE_AND:
        -: 1711:      {
    #####: 1712:        *result_p++ = left & right;
    #####: 1713:        break;
        -: 1714:      }
    #####: 1715:      case ECMA_BIG_UINT_BITWISE_OR:
        -: 1716:      {
    #####: 1717:        *result_p++ = left | right;
    #####: 1718:        break;
        -: 1719:      }
    #####: 1720:      case ECMA_BIG_UINT_BITWISE_XOR:
        -: 1721:      {
    #####: 1722:        *result_p++ = left ^ right;
    #####: 1723:        break;
        -: 1724:      }
    #####: 1725:      default:
        -: 1726:      {
    #####: 1727:        JERRY_ASSERT (operation_type == ECMA_BIG_UINT_BITWISE_AND_NOT);
    #####: 1728:        *result_p++ = left & ~right;
    #####: 1729:        break;
        -: 1730:      }
        -: 1731:    }
    #####: 1732:  } while (result_p < result_end_p);
        -: 1733:
    #####: 1734:  if (operation_type != ECMA_BIG_UINT_BITWISE_AND)
        -: 1735:  {
    #####: 1736:    result_end_p = ECMA_BIGINT_GET_DIGITS (result_value_p, left_size);
        -: 1737:
    #####: 1738:    if (left_carry > 0)
        -: 1739:    {
    #####: 1740:      while (*left_p == 0)
        -: 1741:      {
    #####: 1742:        *result_p++ = ~((ecma_bigint_digit_t) 0);
    #####: 1743:        left_p++;
        -: 1744:
    #####: 1745:        JERRY_ASSERT (result_p < result_end_p);
        -: 1746:      }
        -: 1747:
    #####: 1748:      *result_p++ = *left_p++ - 1;
        -: 1749:    }
        -: 1750:
    #####: 1751:    if (result_p < result_end_p)
        -: 1752:    {
    #####: 1753:      memcpy (result_p, left_p, (size_t) ((uint8_t *) result_end_p - (uint8_t *) result_p));
        -: 1754:
    #####: 1755:      if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1756:      {
    #####: 1757:        return ecma_big_uint_increase_result (result_value_p);
        -: 1758:      }
    #####: 1759:      return result_value_p;
        -: 1760:    }
        -: 1761:  }
        -: 1762:
    #####: 1763:  if (operation_and_options & ECMA_BIG_UINT_BITWISE_INCREASE_RESULT)
        -: 1764:  {
    #####: 1765:    return ecma_big_uint_increase_result (result_value_p);
        -: 1766:  }
        -: 1767:
    #####: 1768:  if (result_p[-1] == 0)
        -: 1769:  {
    #####: 1770:    return ecma_big_uint_normalize_result (result_value_p, result_p);
        -: 1771:  }
    #####: 1772:  return result_value_p;
        -: 1773:} /* ecma_big_uint_bitwise_op */
        -: 1774:
        -: 1775:#endif /* JERRY_BUILTIN_BIGINT */
