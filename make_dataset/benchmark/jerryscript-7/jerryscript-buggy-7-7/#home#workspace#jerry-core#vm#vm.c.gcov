        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "vm.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtin-object.h"
        -:   23:#include "ecma-builtins.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-errors.h"
        -:   27:#include "ecma-exceptions.h"
        -:   28:#include "ecma-function-object.h"
        -:   29:#include "ecma-gc.h"
        -:   30:#include "ecma-helpers.h"
        -:   31:#include "ecma-iterator-object.h"
        -:   32:#include "ecma-lcache.h"
        -:   33:#include "ecma-lex-env.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-objects.h"
        -:   36:#include "ecma-promise-object.h"
        -:   37:#include "ecma-regexp-object.h"
        -:   38:
        -:   39:#include "common.h"
        -:   40:#include "jcontext.h"
        -:   41:#include "opcodes.h"
        -:   42:#include "vm-stack.h"
        -:   43:
        -:   44:/** \addtogroup vm Virtual machine
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup vm_executor Executor
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((sizeof (vm_frame_ctx_t) % sizeof (ecma_value_t)) == 0,
        -:   52:                     sizeof_vm_frame_ctx_must_be_sizeof_ecma_value_t_aligned);
        -:   53:
        -:   54:/**
        -:   55: * Get the value of object[property].
        -:   56: *
        -:   57: * @return ecma value
        -:   58: */
        -:   59:static ecma_value_t
    #####:   60:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   61:                 ecma_value_t property) /**< property name */
        -:   62:{
    #####:   63:  if (ecma_is_value_object (object))
        -:   64:  {
    #####:   65:    ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####:   66:    ecma_string_t *property_name_p = NULL;
        -:   67:
    #####:   68:    if (ecma_is_value_integer_number (property))
        -:   69:    {
    #####:   70:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   71:
    #####:   72:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   73:      {
    #####:   74:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   75:        {
    #####:   76:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   77:
    #####:   78:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   79:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   80:          {
    #####:   81:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   82:
    #####:   83:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   84:            {
    #####:   85:              return ecma_fast_copy_value (values_p[int_value]);
        -:   86:            }
        -:   87:          }
        -:   88:        }
        -:   89:
    #####:   90:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) int_value);
        -:   91:      }
        -:   92:    }
    #####:   93:    else if (ecma_is_value_string (property))
        -:   94:    {
    #####:   95:      property_name_p = ecma_get_string_from_value (property);
        -:   96:    }
        -:   97:
        -:   98:#if JERRY_ESNEXT
    #####:   99:    if (ecma_is_value_symbol (property))
        -:  100:    {
    #####:  101:      property_name_p = ecma_get_symbol_from_value (property);
        -:  102:    }
        -:  103:#endif /* JERRY_ESNEXT */
        -:  104:
    #####:  105:    if (property_name_p != NULL)
        -:  106:    {
        -:  107:#if JERRY_LCACHE
    #####:  108:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  109:
    #####:  110:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  111:      {
    #####:  112:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  113:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  114:      }
        -:  115:#endif /* JERRY_LCACHE */
        -:  116:
        -:  117:      /* There is no need to free the name. */
    #####:  118:      return ecma_op_object_get (object_p, property_name_p);
        -:  119:    }
        -:  120:  }
        -:  121:
    #####:  122:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  123:  {
        -:  124:#if JERRY_ERROR_MESSAGES
    #####:  125:    ecma_value_t error_value =
        -:  126:      ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot read property '%' of %", property, object);
        -:  127:#else /* !JERRY_ERROR_MESSAGES */
        -:  128:    ecma_value_t error_value = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  129:#endif /* JERRY_ERROR_MESSAGES */
    #####:  130:    return error_value;
        -:  131:  }
        -:  132:
    #####:  133:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  134:
    #####:  135:  if (property_name_p == NULL)
        -:  136:  {
    #####:  137:    return ECMA_VALUE_ERROR;
        -:  138:  }
        -:  139:
    #####:  140:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  141:
    #####:  142:  ecma_deref_ecma_string (property_name_p);
    #####:  143:  return get_value_result;
        -:  144:} /* vm_op_get_value */
        -:  145:
        -:  146:/**
        -:  147: * Set the value of object[property].
        -:  148: *
        -:  149: * Note:
        -:  150: *  this function frees its object and property arguments
        -:  151: *
        -:  152: * @return an ecma value which contains an error
        -:  153: *         if the property setting is unsuccessful
        -:  154: */
        -:  155:static ecma_value_t
        1:  156:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  157:                 ecma_value_t property, /**< property name */
        -:  158:                 ecma_value_t value, /**< ecma value */
        -:  159:                 bool is_strict) /**< strict mode */
        -:  160:{
        1:  161:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  162:  ecma_object_t *object_p;
        -:  163:  ecma_string_t *property_p;
        -:  164:
        1:  165:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  166:  {
        1:  167:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  168:    {
        -:  169:#if JERRY_ERROR_MESSAGES
    #####:  170:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot set property '%' of %", property, base);
        -:  171:#else /* !JERRY_ERROR_MESSAGES */
        -:  172:      result = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  173:#endif /* JERRY_ERROR_MESSAGES */
    #####:  174:      ecma_free_value (property);
    #####:  175:      return result;
        -:  176:    }
        -:  177:
        1:  178:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  179:    {
    #####:  180:      property_p = ecma_op_to_string (property);
    #####:  181:      ecma_fast_free_value (property);
        -:  182:
    #####:  183:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  184:      {
    #####:  185:        ecma_free_value (base);
    #####:  186:        return ECMA_VALUE_ERROR;
        -:  187:      }
        -:  188:    }
        -:  189:    else
        -:  190:    {
        1:  191:      property_p = ecma_get_prop_name_from_value (property);
        -:  192:    }
        -:  193:
        1:  194:    ecma_value_t object = ecma_op_to_object (base);
    #####:  195:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  196:
    #####:  197:    object_p = ecma_get_object_from_value (object);
    #####:  198:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  199:
    #####:  200:    result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  201:
    #####:  202:    ecma_free_value (base);
        -:  203:  }
        -:  204:  else
        -:  205:  {
    #####:  206:    object_p = ecma_get_object_from_value (base);
        -:  207:
    #####:  208:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  209:    {
    #####:  210:      property_p = ecma_op_to_string (property);
    #####:  211:      ecma_fast_free_value (property);
        -:  212:
    #####:  213:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  214:      {
    #####:  215:        ecma_deref_object (object_p);
    #####:  216:        return ECMA_VALUE_ERROR;
        -:  217:      }
        -:  218:    }
        -:  219:    else
        -:  220:    {
    #####:  221:      property_p = ecma_get_prop_name_from_value (property);
        -:  222:    }
        -:  223:
    #####:  224:    if (!ecma_is_lexical_environment (object_p))
        -:  225:    {
    #####:  226:      result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  227:    }
        -:  228:    else
        -:  229:    {
    #####:  230:      result = ecma_op_set_mutable_binding (object_p, property_p, value, is_strict);
        -:  231:    }
        -:  232:  }
        -:  233:
    #####:  234:  ecma_deref_object (object_p);
    #####:  235:  ecma_deref_ecma_string (property_p);
    #####:  236:  return result;
        -:  237:} /* vm_op_set_value */
        -:  238:
        -:  239:/** Compact bytecode define */
        -:  240:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  241:
        -:  242:/**
        -:  243: * Decode table for both opcodes and extended opcodes.
        -:  244: */
        -:  245:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA = { CBC_OPCODE_LIST CBC_EXT_OPCODE_LIST };
        -:  246:
        -:  247:#undef CBC_OPCODE
        -:  248:
        -:  249:/**
        -:  250: * Run global code
        -:  251: *
        -:  252: * Note:
        -:  253: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  254: *
        -:  255: * @return ecma value
        -:  256: */
        -:  257:ecma_value_t
        1:  258:vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  259:               ecma_object_t *function_object_p) /**< function object if available */
        -:  260:{
        -:  261:#if JERRY_BUILTIN_REALMS
        1:  262:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  263:#else /* !JERRY_BUILTIN_REALMS */
    #####:  264:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  265:#endif /* JERRY_BUILTIN_REALMS */
        -:  266:
        -:  267:#if JERRY_ESNEXT
        1:  268:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  269:  {
    #####:  270:    ecma_create_global_lexical_block (global_obj_p);
        -:  271:  }
        -:  272:#endif /* JERRY_ESNEXT */
        -:  273:
        1:  274:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  275:
        1:  276:  vm_frame_ctx_shared_t shared;
        1:  277:  shared.bytecode_header_p = bytecode_p;
        1:  278:  shared.function_object_p = function_object_p;
        1:  279:  shared.status_flags = 0;
        -:  280:
        -:  281:#if JERRY_BUILTIN_REALMS
        1:  282:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  283:
        1:  284:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  285:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  286:#else /* !JERRY_BUILTIN_REALMS */
    #####:  287:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  288:#endif /* JERRY_BUILTIN_REALMS */
        -:  289:
        1:  290:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  291:
        -:  292:#if JERRY_BUILTIN_REALMS
    #####:  293:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  294:#endif /* JERRY_BUILTIN_REALMS */
        -:  295:
    #####:  296:  return result;
        -:  297:} /* vm_run_global */
        -:  298:
        -:  299:/**
        -:  300: * Run specified eval-mode bytecode
        -:  301: *
        -:  302: * @return ecma value
        -:  303: */
        -:  304:ecma_value_t
    #####:  305:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  306:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  307:{
        -:  308:  ecma_value_t this_binding;
        -:  309:  ecma_object_t *lex_env_p;
        -:  310:
        -:  311:  /* ECMA-262 v5, 10.4.2 */
    #####:  312:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  313:  {
    #####:  314:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  315:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  316:
        -:  317:#if JERRY_DEBUGGER
        -:  318:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  319:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  320:
        -:  321:    while (chain_index != 0)
        -:  322:    {
        -:  323:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  324:      {
        -:  325:        ecma_bytecode_deref (bytecode_data_p);
        -:  326:        ecma_free_value (this_binding);
        -:  327:        return ecma_raise_range_error (ECMA_ERR_INVALID_SCOPE_CHAIN_INDEX_FOR_EVAL);
        -:  328:      }
        -:  329:
        -:  330:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  331:
        -:  332:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  333:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  334:      {
        -:  335:        chain_index--;
        -:  336:      }
        -:  337:    }
        -:  338:#endif /* JERRY_DEBUGGER */
        -:  339:  }
        -:  340:  else
        -:  341:  {
        -:  342:#if JERRY_BUILTIN_REALMS
    #####:  343:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  344:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  345:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  346:#else /* !JERRY_BUILTIN_REALMS */
    #####:  347:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  348:    ecma_ref_object (global_obj_p);
    #####:  349:    this_binding = ecma_make_object_value (global_obj_p);
        -:  350:#endif /* JERRY_BUILTIN_REALMS */
    #####:  351:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  352:  }
        -:  353:
    #####:  354:  ecma_ref_object (lex_env_p);
        -:  355:
    #####:  356:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  357:  {
    #####:  358:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  359:
    #####:  360:    ecma_deref_object (lex_env_p);
    #####:  361:    lex_env_p = strict_lex_env_p;
        -:  362:  }
        -:  363:
    #####:  364:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  365:  {
    #####:  366:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  367:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  368:
    #####:  369:    ecma_deref_object (lex_env_p);
    #####:  370:    lex_env_p = lex_block_p;
        -:  371:  }
        -:  372:
    #####:  373:  vm_frame_ctx_shared_t shared;
    #####:  374:  shared.bytecode_header_p = bytecode_data_p;
    #####:  375:  shared.function_object_p = NULL;
    #####:  376:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  377:
    #####:  378:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  379:
    #####:  380:  ecma_deref_object (lex_env_p);
    #####:  381:  ecma_free_value (this_binding);
        -:  382:
        -:  383:#if JERRY_SNAPSHOT_EXEC
    #####:  384:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  385:  {
    #####:  386:    ecma_bytecode_deref (bytecode_data_p);
        -:  387:  }
        -:  388:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  389:  ecma_bytecode_deref (bytecode_data_p);
        -:  390:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  391:
    #####:  392:  return completion_value;
        -:  393:} /* vm_run_eval */
        -:  394:
        -:  395:#if JERRY_MODULE_SYSTEM
        -:  396:
        -:  397:/**
        -:  398: * Run module code
        -:  399: *
        -:  400: * Note:
        -:  401: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  402: *
        -:  403: * @return ecma value
        -:  404: */
        -:  405:ecma_value_t
    #####:  406:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  407:{
    #####:  408:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  409:
    #####:  410:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  411:  {
    #####:  412:    return module_init_result;
        -:  413:  }
        -:  414:
    #####:  415:  vm_frame_ctx_shared_t shared;
    #####:  416:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  417:  shared.function_object_p = &module_p->header.object;
    #####:  418:  shared.status_flags = 0;
        -:  419:
    #####:  420:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  421:} /* vm_run_module */
        -:  422:
        -:  423:#endif /* JERRY_MODULE_SYSTEM */
        -:  424:
        -:  425:/**
        -:  426: * Construct object
        -:  427: *
        -:  428: * @return object value
        -:  429: */
        -:  430:static ecma_value_t
       20:  431:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  432:                             ecma_value_t lit_value) /**< literal */
        -:  433:{
        -:  434:  ecma_compiled_code_t *bytecode_p;
        -:  435:
        -:  436:#if JERRY_SNAPSHOT_EXEC
    #####:  437:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  438:  {
        -:  439:#endif /* JERRY_SNAPSHOT_EXEC */
       20:  440:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, lit_value);
        -:  441:#if JERRY_SNAPSHOT_EXEC
        -:  442:  }
        -:  443:  else
        -:  444:  {
    #####:  445:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  446:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  447:  }
        -:  448:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  449:
        -:  450:#if JERRY_BUILTIN_REGEXP
       20:  451:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  452:  {
    #####:  453:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  454:
    #####:  455:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  456:    {
    #####:  457:      return ECMA_VALUE_ERROR;
        -:  458:    }
        -:  459:
    #####:  460:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  461:  }
        -:  462:#else /* !JERRY_BUILTIN_REGEXP */
        -:  463:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  464:#endif /* JERRY_BUILTIN_REGEXP */
        -:  465:
        -:  466:  ecma_object_t *func_obj_p;
        -:  467:
        -:  468:#if JERRY_ESNEXT
       20:  469:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  470:  {
        1:  471:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p, bytecode_p, frame_ctx_p->this_binding);
        -:  472:  }
        -:  473:  else
        -:  474:  {
       19:  475:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  476:  }
        -:  477:#else /* !JERRY_ESNEXT */
    #####:  478:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  479:#endif /* JERRY_ESNEXT */
        -:  480:
       20:  481:  return ecma_make_object_value (func_obj_p);
        -:  482:} /* vm_construct_literal_object */
        -:  483:
        -:  484:/**
        -:  485: * Get implicit this value
        -:  486: *
        -:  487: * @return true - if the implicit 'this' value is updated,
        -:  488: *         false - otherwise
        -:  489: */
        -:  490:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  491:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  492:{
    #####:  493:  if (ecma_is_value_object (*this_value_p))
        -:  494:  {
    #####:  495:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  496:
    #####:  497:    if (ecma_is_lexical_environment (this_obj_p))
        -:  498:    {
    #####:  499:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  500:
    #####:  501:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  502:
    #####:  503:      *this_value_p = completion_value;
    #####:  504:      return true;
        -:  505:    }
        -:  506:  }
    #####:  507:  return false;
        -:  508:} /* vm_get_implicit_this_value */
        -:  509:
        -:  510:/**
        -:  511: * Special bytecode sequence for error handling while the vm_loop
        -:  512: * is preserved for an execute operation
        -:  513: */
        -:  514:static const uint8_t vm_error_byte_code_p[] = { CBC_EXT_OPCODE, CBC_EXT_ERROR };
        -:  515:
        -:  516:#if JERRY_ESNEXT
        -:  517:
        -:  518:static ecma_object_t *
    #####:  519:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  520:{
    #####:  521:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  522:
    #####:  523:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  524:  {
    #####:  525:    return frame_ctx_p->shared_p->function_object_p;
        -:  526:  }
        -:  527:
    #####:  528:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  529:
    #####:  530:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  531:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  532:} /* vm_get_class_function */
        -:  533:
        -:  534:/**
        -:  535: * 'super(...)' function call handler.
        -:  536: */
        -:  537:static void
    #####:  538:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  539:{
    #####:  540:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  541:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  542:
    #####:  543:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  544:  uint8_t opcode = byte_code_p[-2];
        -:  545:  uint32_t arguments_list_len;
        -:  546:
    #####:  547:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  548:
    #####:  549:  ecma_collection_t *collection_p = NULL;
        -:  550:  ecma_value_t *arguments_p;
        -:  551:
    #####:  552:  if (spread_arguments)
        -:  553:  {
    #####:  554:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  555:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  556:    arguments_p = collection_p->buffer_p;
    #####:  557:    arguments_list_len = collection_p->item_count;
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    arguments_list_len = byte_code_p[-1];
    #####:  562:    arguments_p = frame_ctx_p->stack_top_p;
        -:  563:  }
        -:  564:
    #####:  565:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  566:  ecma_value_t completion_value;
        -:  567:
    #####:  568:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
    #####:  569:  JERRY_ASSERT (environment_record_p);
        -:  570:
    #####:  571:  if (!ecma_is_constructor (func_value))
        -:  572:  {
    #####:  573:    completion_value = ecma_raise_type_error (ECMA_ERR_VALUE_FOR_CLASS_HERITAGE_IS_NOT_A_CONSTRUCTOR);
        -:  574:  }
        -:  575:  else
        -:  576:  {
    #####:  577:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  578:    completion_value =
    #####:  579:      ecma_op_function_construct (func_obj_p, JERRY_CONTEXT (current_new_target_p), arguments_p, arguments_list_len);
        -:  580:
    #####:  581:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  582:    {
    #####:  583:      ecma_free_value (completion_value);
    #####:  584:      completion_value = ecma_raise_reference_error (ECMA_ERR_SUPER_CONSTRUCTOR_MAY_ONLY_BE_CALLED_ONCE);
        -:  585:    }
        -:  586:  }
        -:  587:
        -:  588:  /* Free registers. */
    #####:  589:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  590:  {
    #####:  591:    ecma_fast_free_value (arguments_p[i]);
        -:  592:  }
        -:  593:
    #####:  594:  if (collection_p != NULL)
        -:  595:  {
    #####:  596:    ecma_collection_destroy (collection_p);
        -:  597:  }
        -:  598:
    #####:  599:  if (ecma_is_value_object (completion_value))
        -:  600:  {
    #####:  601:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  602:    frame_ctx_p->this_binding = completion_value;
        -:  603:
    #####:  604:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  605:
    #####:  606:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  607:    {
    #####:  608:      ecma_free_value (completion_value);
    #####:  609:      completion_value = ECMA_VALUE_ERROR;
        -:  610:    }
        -:  611:  }
        -:  612:
    #####:  613:  ecma_free_value (func_value);
        -:  614:
    #####:  615:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  616:  {
        -:  617:#if JERRY_DEBUGGER
        -:  618:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  619:#endif /* JERRY_DEBUGGER */
    #####:  620:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  621:  }
        -:  622:  else
        -:  623:  {
    #####:  624:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  625:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  626:
    #####:  627:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  628:    {
    #####:  629:      ecma_fast_free_value (completion_value);
        -:  630:    }
    #####:  631:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  632:    {
    #####:  633:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  634:    }
        -:  635:    else
        -:  636:    {
    #####:  637:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  638:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  639:    }
        -:  640:  }
    #####:  641:} /* vm_super_call */
        -:  642:
        -:  643:/**
        -:  644: * Perform one of the following call/construct operation with spreaded argument list
        -:  645: *   - f(...args)
        -:  646: *   - o.f(...args)
        -:  647: *   - new O(...args)
        -:  648: */
        -:  649:static void
    #####:  650:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  651:{
    #####:  652:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  653:
    #####:  654:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  655:  ecma_value_t completion_value;
    #####:  656:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  657:
    #####:  658:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  659:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  660:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  661:
    #####:  662:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  663:  {
    #####:  664:    ecma_error_msg_t constructor_message_id = ecma_check_constructor (func_value);
    #####:  665:    if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  666:    {
    #####:  667:      completion_value = ecma_raise_type_error (constructor_message_id);
        -:  668:    }
        -:  669:    else
        -:  670:    {
    #####:  671:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  672:
    #####:  673:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  674:                                                     constructor_obj_p,
    #####:  675:                                                     collection_p->buffer_p,
        -:  676:                                                     collection_p->item_count);
        -:  677:    }
        -:  678:  }
        -:  679:  else
        -:  680:  {
    #####:  681:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  682:
    #####:  683:    if (!ecma_is_value_object (func_value) || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  684:    {
    #####:  685:      completion_value = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);
        -:  686:    }
        -:  687:    else
        -:  688:    {
    #####:  689:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  690:
    #####:  691:      completion_value =
    #####:  692:        ecma_op_function_call (func_obj_p, this_value, collection_p->buffer_p, collection_p->item_count);
        -:  693:    }
        -:  694:
    #####:  695:    if (is_call_prop)
        -:  696:    {
    #####:  697:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  698:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  699:    }
        -:  700:  }
        -:  701:
    #####:  702:  ecma_collection_free (collection_p);
    #####:  703:  ecma_free_value (func_value);
        -:  704:
    #####:  705:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  706:  {
        -:  707:#if JERRY_DEBUGGER
        -:  708:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  709:#endif /* JERRY_DEBUGGER */
    #####:  710:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  711:  }
        -:  712:  else
        -:  713:  {
    #####:  714:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  715:
    #####:  716:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  717:    {
    #####:  718:      ecma_fast_free_value (completion_value);
        -:  719:    }
    #####:  720:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  721:    {
    #####:  722:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  723:    }
        -:  724:    else
        -:  725:    {
    #####:  726:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  727:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  728:    }
        -:  729:
        -:  730:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  731:    frame_ctx_p->byte_code_p += 3;
        -:  732:  }
    #####:  733:} /* vm_spread_operation */
        -:  734:#endif /* JERRY_ESNEXT */
        -:  735:
        -:  736:/**
        -:  737: * 'Function call' opcode handler.
        -:  738: *
        -:  739: * See also: ECMA-262 v5, 11.2.3
        -:  740: */
        -:  741:static void
       15:  742:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  743:{
       15:  744:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
       15:  745:  uint8_t opcode = byte_code_p[-1];
        -:  746:  uint32_t arguments_list_len;
        -:  747:
       15:  748:  if (opcode >= CBC_CALL0)
        -:  749:  {
       15:  750:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  751:  }
        -:  752:  else
        -:  753:  {
    #####:  754:    arguments_list_len = *byte_code_p++;
        -:  755:  }
        -:  756:
       15:  757:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  758:
       15:  759:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
       15:  760:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
       15:  761:  ecma_value_t func_value = stack_top_p[-1];
        -:  762:
       15:  763:  ecma_value_t completion_value =
        -:  764:    ecma_op_function_validated_call (func_value, this_value, stack_top_p, arguments_list_len);
        -:  765:
       10:  766:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  767:
        -:  768:  /* Free registers. */
       14:  769:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  770:  {
        4:  771:    ecma_fast_free_value (stack_top_p[i]);
        -:  772:  }
        -:  773:
       10:  774:  if (is_call_prop)
        -:  775:  {
    #####:  776:    ecma_free_value (*(--stack_top_p));
    #####:  777:    ecma_free_value (*(--stack_top_p));
        -:  778:  }
        -:  779:
       10:  780:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  781:  {
        -:  782:#if JERRY_DEBUGGER
        -:  783:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  784:#endif /* JERRY_DEBUGGER */
        4:  785:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  786:  }
        -:  787:  else
        -:  788:  {
        6:  789:    frame_ctx_p->byte_code_p = byte_code_p;
        6:  790:    ecma_free_value (*(--stack_top_p));
        6:  791:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  792:
        6:  793:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  794:    {
        4:  795:      ecma_fast_free_value (completion_value);
        -:  796:    }
        2:  797:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  798:    {
        2:  799:      *stack_top_p++ = completion_value;
        -:  800:    }
        -:  801:    else
        -:  802:    {
    #####:  803:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  804:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  805:    }
        -:  806:  }
        -:  807:
       10:  808:  frame_ctx_p->stack_top_p = stack_top_p;
       10:  809:} /* opfunc_call */
        -:  810:
        -:  811:/**
        -:  812: * 'Constructor call' opcode handler.
        -:  813: *
        -:  814: * See also: ECMA-262 v5, 11.2.2
        -:  815: */
        -:  816:static void
        5:  817:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  818:{
        5:  819:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        5:  820:  uint8_t opcode = byte_code_p[-1];
        -:  821:  unsigned int arguments_list_len;
        -:  822:
        5:  823:  if (opcode >= CBC_NEW0)
        -:  824:  {
        5:  825:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  826:  }
        -:  827:  else
        -:  828:  {
    #####:  829:    arguments_list_len = *byte_code_p++;
        -:  830:  }
        -:  831:
        5:  832:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        5:  833:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  834:  ecma_value_t completion_value;
        -:  835:
        5:  836:  ecma_error_msg_t constructor_message_id = ecma_check_constructor (constructor_value);
        5:  837:  if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  838:  {
    #####:  839:    completion_value = ecma_raise_type_error (constructor_message_id);
        -:  840:  }
        -:  841:  else
        -:  842:  {
        5:  843:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  844:
        5:  845:    completion_value =
        -:  846:      ecma_op_function_construct (constructor_obj_p, constructor_obj_p, stack_top_p, arguments_list_len);
        -:  847:  }
        -:  848:
        -:  849:  /* Free registers. */
        4:  850:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  851:  {
    #####:  852:    ecma_fast_free_value (stack_top_p[i]);
        -:  853:  }
        -:  854:
        4:  855:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  856:  {
        -:  857:#if JERRY_DEBUGGER
        -:  858:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  859:#endif /* JERRY_DEBUGGER */
        4:  860:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  861:  }
        -:  862:  else
        -:  863:  {
    #####:  864:    ecma_free_value (stack_top_p[-1]);
    #####:  865:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  866:    stack_top_p[-1] = completion_value;
        -:  867:  }
        -:  868:
        4:  869:  frame_ctx_p->stack_top_p = stack_top_p;
        4:  870:} /* opfunc_construct */
        -:  871:
        -:  872:/**
        -:  873: * Read literal index from the byte code stream into destination.
        -:  874: *
        -:  875: * @param destination destination
        -:  876: */
        -:  877:#define READ_LITERAL_INDEX(destination)                                                      \
        -:  878:  do                                                                                         \
        -:  879:  {                                                                                          \
        -:  880:    (destination) = *byte_code_p++;                                                          \
        -:  881:    if ((destination) >= encoding_limit)                                                     \
        -:  882:    {                                                                                        \
        -:  883:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  884:    }                                                                                        \
        -:  885:  } while (0)
        -:  886:
        -:  887:/**
        -:  888: * Get literal value by literal index.
        -:  889: *
        -:  890: * @param literal_index literal index
        -:  891: * @param target_value target value
        -:  892: *
        -:  893: * TODO: For performance reasons, we define this as a macro.
        -:  894: * When we are able to construct a function with similar speed,
        -:  895: * we can remove this macro.
        -:  896: */
        -:  897:#define READ_LITERAL(literal_index, target_value)                                                 \
        -:  898:  do                                                                                              \
        -:  899:  {                                                                                               \
        -:  900:    if ((literal_index) < ident_end)                                                              \
        -:  901:    {                                                                                             \
        -:  902:      if ((literal_index) < register_end)                                                         \
        -:  903:      {                                                                                           \
        -:  904:        /* Note: There should be no specialization for arguments. */                              \
        -:  905:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));     \
        -:  906:      }                                                                                           \
        -:  907:      else                                                                                        \
        -:  908:      {                                                                                           \
        -:  909:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);      \
        -:  910:                                                                                                  \
        -:  911:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, name_p);                \
        -:  912:                                                                                                  \
        -:  913:        if (ECMA_IS_VALUE_ERROR (result))                                                         \
        -:  914:        {                                                                                         \
        -:  915:          goto error;                                                                             \
        -:  916:        }                                                                                         \
        -:  917:        (target_value) = result;                                                                  \
        -:  918:      }                                                                                           \
        -:  919:    }                                                                                             \
        -:  920:    else if (literal_index < const_literal_end)                                                   \
        -:  921:    {                                                                                             \
        -:  922:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]);                     \
        -:  923:    }                                                                                             \
        -:  924:    else                                                                                          \
        -:  925:    {                                                                                             \
        -:  926:      /* Object construction. */                                                                  \
        -:  927:      (target_value) = vm_construct_literal_object (frame_ctx_p, literal_start_p[literal_index]); \
        -:  928:    }                                                                                             \
        -:  929:  } while (0)
        -:  930:
        -:  931:/**
        -:  932: * Store the original value for post increase/decrease operators
        -:  933: *
        -:  934: * @param value original value
        -:  935: */
        -:  936:#define POST_INCREASE_DECREASE_PUT_RESULT(value)                                                             \
        -:  937:  if (opcode_data & VM_OC_PUT_STACK)                                                                         \
        -:  938:  {                                                                                                          \
        -:  939:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)                                                  \
        -:  940:    {                                                                                                        \
        -:  941:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  942:      *stack_top_p++ = (value);                                                                              \
        -:  943:    }                                                                                                        \
        -:  944:    else                                                                                                     \
        -:  945:    {                                                                                                        \
        -:  946:      /* The parser ensures there is enough space for the                                                    \
        -:  947:       * extra value on the stack. See js-parser-expr.c. */                                                  \
        -:  948:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT || opcode == CBC_POST_DECR_PUSH_RESULT);             \
        -:  949:      stack_top_p++;                                                                                         \
        -:  950:      stack_top_p[-1] = stack_top_p[-2];                                                                     \
        -:  951:      stack_top_p[-2] = stack_top_p[-3];                                                                     \
        -:  952:      stack_top_p[-3] = (value);                                                                             \
        -:  953:    }                                                                                                        \
        -:  954:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;                                                              \
        -:  955:  }                                                                                                          \
        -:  956:  else                                                                                                       \
        -:  957:  {                                                                                                          \
        -:  958:    JERRY_ASSERT (opcode_data &VM_OC_PUT_BLOCK);                                                             \
        -:  959:    ecma_free_value (VM_GET_REGISTER (frame_ctx_p, 0));                                                      \
        -:  960:    VM_GET_REGISTERS (frame_ctx_p)[0] = (value);                                                             \
        -:  961:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;                                                              \
        -:  962:  }
        -:  963:
        -:  964:/**
        -:  965: * Get the end of the existing topmost context
        -:  966: */
        -:  967:#define VM_LAST_CONTEXT_END() (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -:  968:
        -:  969:/**
        -:  970: * Run generic byte code.
        -:  971: *
        -:  972: * @return ecma value
        -:  973: */
        -:  974:static ecma_value_t JERRY_ATTR_NOINLINE
       36:  975:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  976:{
       36:  977:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
       36:  978:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
       36:  979:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -:  980:
       36:  981:  ecma_value_t *stack_top_p;
        -:  982:  uint16_t encoding_limit;
        -:  983:  uint16_t encoding_delta;
        -:  984:  uint16_t register_end;
        -:  985:  uint16_t ident_end;
        -:  986:  uint16_t const_literal_end;
       36:  987:  int32_t branch_offset = 0;
       36:  988:  uint8_t branch_offset_length = 0;
       36:  989:  ecma_value_t left_value;
        -:  990:  ecma_value_t right_value;
       36:  991:  ecma_value_t result = ECMA_VALUE_EMPTY;
       36:  992:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -:  993:
        -:  994:  /* Prepare for byte code execution. */
       36:  995:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  996:  {
       36:  997:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
       36:  998:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  999:  }
        -: 1000:  else
        -: 1001:  {
    #####: 1002:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1003:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1004:  }
        -: 1005:
       36: 1006:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1007:  {
    #####: 1008:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1009:    register_end = args_p->register_end;
    #####: 1010:    ident_end = args_p->ident_end;
    #####: 1011:    const_literal_end = args_p->const_literal_end;
        -: 1012:  }
        -: 1013:  else
        -: 1014:  {
       36: 1015:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
       36: 1016:    register_end = args_p->register_end;
       36: 1017:    ident_end = args_p->ident_end;
       36: 1018:    const_literal_end = args_p->const_literal_end;
        -: 1019:  }
        -: 1020:
       36: 1021:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1022:
        -: 1023:  /* Outer loop for exception handling. */
        4: 1024:  while (true)
        -: 1025:  {
        -: 1026:    /* Internal loop for byte code execution. */
        -: 1027:    while (true)
      124: 1028:    {
      164: 1029:      const uint8_t *byte_code_start_p = byte_code_p;
      164: 1030:      uint8_t opcode = *byte_code_p++;
      164: 1031:      uint32_t opcode_data = opcode;
        -: 1032:
      164: 1033:      if (opcode == CBC_EXT_OPCODE)
        -: 1034:      {
       59: 1035:        opcode = *byte_code_p++;
       59: 1036:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1037:      }
        -: 1038:
      164: 1039:      opcode_data = vm_decode_table[opcode_data];
        -: 1040:
      164: 1041:      left_value = ECMA_VALUE_UNDEFINED;
      164: 1042:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1043:
      164: 1044:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1045:
      164: 1046:      if (operands >= VM_OC_GET_LITERAL)
        -: 1047:      {
        -: 1048:        uint16_t literal_index;
       48: 1049:        READ_LITERAL_INDEX (literal_index);
       48: 1050:        READ_LITERAL (literal_index, left_value);
        -: 1051:
       48: 1052:        if (operands != VM_OC_GET_LITERAL)
        -: 1053:        {
        9: 1054:          switch (operands)
        -: 1055:          {
        9: 1056:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1057:            {
        -: 1058:              uint16_t second_literal_index;
        9: 1059:              READ_LITERAL_INDEX (second_literal_index);
        9: 1060:              READ_LITERAL (second_literal_index, right_value);
        9: 1061:              break;
        -: 1062:            }
    #####: 1063:            case VM_OC_GET_STACK_LITERAL:
        -: 1064:            {
    #####: 1065:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1066:              right_value = left_value;
    #####: 1067:              left_value = *(--stack_top_p);
    #####: 1068:              break;
        -: 1069:            }
    #####: 1070:            default:
        -: 1071:            {
    #####: 1072:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1073:
    #####: 1074:              right_value = left_value;
    #####: 1075:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1076:              break;
        -: 1077:            }
        -: 1078:          }
       39: 1079:        }
        -: 1080:      }
      116: 1081:      else if (operands >= VM_OC_GET_STACK)
        -: 1082:      {
       14: 1083:        JERRY_ASSERT (operands == VM_OC_GET_STACK || operands == VM_OC_GET_STACK_STACK);
        -: 1084:
       14: 1085:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
       14: 1086:        left_value = *(--stack_top_p);
        -: 1087:
       14: 1088:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1089:        {
    #####: 1090:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1091:          right_value = left_value;
    #####: 1092:          left_value = *(--stack_top_p);
        -: 1093:        }
        -: 1094:      }
      102: 1095:      else if (operands == VM_OC_GET_BRANCH)
        -: 1096:      {
        7: 1097:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        7: 1098:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1099:
        7: 1100:        branch_offset = *(byte_code_p++);
        -: 1101:
        7: 1102:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1103:        {
    #####: 1104:          branch_offset <<= 8;
    #####: 1105:          branch_offset |= *(byte_code_p++);
        -: 1106:
    #####: 1107:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1108:          {
    #####: 1109:            branch_offset <<= 8;
    #####: 1110:            branch_offset |= *(byte_code_p++);
        -: 1111:          }
        -: 1112:        }
        -: 1113:
        7: 1114:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1115:        {
        -: 1116:#if JERRY_VM_HALT
    #####: 1117:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1118:          {
    #####: 1119:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1120:
    #####: 1121:            if (ecma_is_value_undefined (result))
        -: 1122:            {
    #####: 1123:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1124:            }
        -: 1125:            else
        -: 1126:            {
    #####: 1127:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1128:
    #####: 1129:              if (ecma_is_value_exception (result))
        -: 1130:              {
    #####: 1131:                ecma_throw_exception (result);
        -: 1132:              }
        -: 1133:              else
        -: 1134:              {
    #####: 1135:                jcontext_raise_exception (result);
        -: 1136:              }
        -: 1137:
        -: 1138:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1139:              jcontext_set_abort_flag (true);
    #####: 1140:              result = ECMA_VALUE_ERROR;
    #####: 1141:              goto error;
        -: 1142:            }
        -: 1143:          }
        -: 1144:#endif /* JERRY_VM_HALT */
        -: 1145:
    #####: 1146:          branch_offset = -branch_offset;
        -: 1147:        }
        -: 1148:      }
        -: 1149:
      164: 1150:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1151:      {
    #####: 1152:        case VM_OC_POP:
        -: 1153:        {
    #####: 1154:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1155:          ecma_free_value (*(--stack_top_p));
    #####: 1156:          continue;
        -: 1157:        }
    #####: 1158:        case VM_OC_POP_BLOCK:
        -: 1159:        {
    #####: 1160:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 1161:          VM_GET_REGISTERS (frame_ctx_p)[0] = *(--stack_top_p);
    #####: 1162:          continue;
        -: 1163:        }
       33: 1164:        case VM_OC_PUSH:
        -: 1165:        {
       33: 1166:          *stack_top_p++ = left_value;
       33: 1167:          continue;
        -: 1168:        }
        6: 1169:        case VM_OC_PUSH_TWO:
        -: 1170:        {
        6: 1171:          *stack_top_p++ = left_value;
        6: 1172:          *stack_top_p++ = right_value;
        6: 1173:          continue;
        -: 1174:        }
    #####: 1175:        case VM_OC_PUSH_THREE:
        -: 1176:        {
        -: 1177:          uint16_t literal_index;
        -: 1178:
    #####: 1179:          *stack_top_p++ = left_value;
    #####: 1180:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1181:
    #####: 1182:          READ_LITERAL_INDEX (literal_index);
    #####: 1183:          READ_LITERAL (literal_index, left_value);
        -: 1184:
    #####: 1185:          *stack_top_p++ = right_value;
    #####: 1186:          *stack_top_p++ = left_value;
    #####: 1187:          continue;
        -: 1188:        }
    #####: 1189:        case VM_OC_PUSH_UNDEFINED:
        -: 1190:        {
    #####: 1191:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1192:          continue;
        -: 1193:        }
    #####: 1194:        case VM_OC_PUSH_TRUE:
        -: 1195:        {
    #####: 1196:          *stack_top_p++ = ECMA_VALUE_TRUE;
    #####: 1197:          continue;
        -: 1198:        }
        5: 1199:        case VM_OC_PUSH_FALSE:
        -: 1200:        {
        5: 1201:          *stack_top_p++ = ECMA_VALUE_FALSE;
        5: 1202:          continue;
        -: 1203:        }
    #####: 1204:        case VM_OC_PUSH_NULL:
        -: 1205:        {
    #####: 1206:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1207:          continue;
        -: 1208:        }
    #####: 1209:        case VM_OC_PUSH_THIS:
        -: 1210:        {
    #####: 1211:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1212:          continue;
        -: 1213:        }
        1: 1214:        case VM_OC_PUSH_0:
        -: 1215:        {
        1: 1216:          *stack_top_p++ = ecma_make_integer_value (0);
        1: 1217:          continue;
        -: 1218:        }
        1: 1219:        case VM_OC_PUSH_POS_BYTE:
        -: 1220:        {
        1: 1221:          ecma_integer_value_t number = *byte_code_p++;
        1: 1222:          *stack_top_p++ = ecma_make_integer_value (number + 1);
        1: 1223:          continue;
        -: 1224:        }
    #####: 1225:        case VM_OC_PUSH_NEG_BYTE:
        -: 1226:        {
    #####: 1227:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1228:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1229:          continue;
        -: 1230:        }
    #####: 1231:        case VM_OC_PUSH_LIT_0:
        -: 1232:        {
    #####: 1233:          stack_top_p[0] = left_value;
    #####: 1234:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1235:          stack_top_p += 2;
    #####: 1236:          continue;
        -: 1237:        }
    #####: 1238:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1239:        {
    #####: 1240:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1241:          stack_top_p[0] = left_value;
    #####: 1242:          stack_top_p[1] = ecma_make_integer_value (number + 1);
    #####: 1243:          stack_top_p += 2;
    #####: 1244:          continue;
        -: 1245:        }
    #####: 1246:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1247:        {
    #####: 1248:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1249:          stack_top_p[0] = left_value;
    #####: 1250:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1251:          stack_top_p += 2;
    #####: 1252:          continue;
        -: 1253:        }
    #####: 1254:        case VM_OC_PUSH_OBJECT:
        -: 1255:        {
    #####: 1256:          ecma_object_t *obj_p =
    #####: 1257:            ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE), 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 1258:
    #####: 1259:          *stack_top_p++ = ecma_make_object_value (obj_p);
    #####: 1260:          continue;
        -: 1261:        }
    #####: 1262:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1263:        {
    #####: 1264:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1265:
    #####: 1266:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1267:
    #####: 1268:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1269:
    #####: 1270:          JERRY_ASSERT (frame_ctx_p->lex_env_p
        -: 1271:                        == ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1272:
    #####: 1273:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1274:
    #####: 1275:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1276:
    #####: 1277:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1278:
    #####: 1279:          ecma_free_value (right_value);
    #####: 1280:          ecma_deref_object (name_lex_env);
    #####: 1281:          *stack_top_p++ = left_value;
    #####: 1282:          continue;
        -: 1283:        }
    #####: 1284:        case VM_OC_CREATE_BINDING:
        -: 1285:        {
        -: 1286:#if !JERRY_ESNEXT
        -: 1287:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1288:#endif /* !JERRY_ESNEXT */
        -: 1289:
        -: 1290:          uint32_t literal_index;
        -: 1291:
    #####: 1292:          READ_LITERAL_INDEX (literal_index);
        -: 1293:
    #####: 1294:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1295:
    #####: 1296:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1297:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1298:
    #####: 1299:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1300:
        -: 1301:#if JERRY_ESNEXT
    #####: 1302:          if (opcode == CBC_CREATE_LET)
        -: 1303:          {
    #####: 1304:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1305:          }
    #####: 1306:          else if (opcode == CBC_CREATE_CONST)
        -: 1307:          {
    #####: 1308:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1309:          }
        -: 1310:
        -: 1311:          ecma_property_value_t *property_value_p;
    #####: 1312:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1313:
    #####: 1314:          if (opcode != CBC_CREATE_VAR)
        -: 1315:          {
    #####: 1316:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1317:          }
        -: 1318:#else /* !JERRY_ESNEXT */
    #####: 1319:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1320:#endif /* JERRY_ESNEXT */
        -: 1321:
    #####: 1322:          continue;
        -: 1323:        }
        2: 1324:        case VM_OC_VAR_EVAL:
        -: 1325:        {
        -: 1326:          uint32_t literal_index;
        2: 1327:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1328:
        2: 1329:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1330:          {
        -: 1331:            uint32_t value_index;
        2: 1332:            READ_LITERAL_INDEX (value_index);
        2: 1333:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1334:
        2: 1335:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1336:          }
        -: 1337:
        2: 1338:          READ_LITERAL_INDEX (literal_index);
        2: 1339:          JERRY_ASSERT (literal_index >= register_end);
        -: 1340:
        2: 1341:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        2: 1342:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1343:
        4: 1344:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1345:          {
        -: 1346:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1347:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1348:            {
    #####: 1349:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1350:
    #####: 1351:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1352:            }
        -: 1353:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1354:
    #####: 1355:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1356:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1357:          }
        -: 1358:
        -: 1359:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
        2: 1360:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1361:          {
    #####: 1362:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1363:
    #####: 1364:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1365:          }
        -: 1366:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1367:
        -: 1368:          /* 'Variable declaration' */
        2: 1369:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1370:
        -: 1371:#if JERRY_BUILTIN_PROXY
        2: 1372:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1373:          {
    #####: 1374:            goto error;
        -: 1375:          }
        -: 1376:#endif /* JERRY_BUILTIN_PROXY */
        -: 1377:
        2: 1378:          ecma_property_t *prop_p = NULL;
        -: 1379:
        2: 1380:          if (ecma_is_value_false (result))
        -: 1381:          {
        2: 1382:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
        2: 1383:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1384:
        2: 1385:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1386:            {
    #####: 1387:              result = ECMA_VALUE_ERROR;
    #####: 1388:              goto error;
        -: 1389:            }
        -: 1390:          }
        -: 1391:
        2: 1392:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1393:          {
        2: 1394:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1395:
        2: 1396:            if (prop_p != NULL)
        -: 1397:            {
    #####: 1398:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1399:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1400:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1401:              ecma_free_object (lit_value);
        -: 1402:            }
        -: 1403:            else
        -: 1404:            {
        2: 1405:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
        2: 1406:              ecma_free_object (lit_value);
        -: 1407:
        2: 1408:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1409:              {
    #####: 1410:                goto error;
        -: 1411:              }
        -: 1412:            }
        -: 1413:          }
        2: 1414:          continue;
        -: 1415:        }
        -: 1416:#if JERRY_ESNEXT
    #####: 1417:        case VM_OC_EXT_VAR_EVAL:
        -: 1418:        {
        -: 1419:          uint32_t literal_index;
    #####: 1420:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1421:
    #####: 1422:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1423:
    #####: 1424:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1425:          {
        -: 1426:            uint32_t value_index;
    #####: 1427:            READ_LITERAL_INDEX (value_index);
    #####: 1428:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1429:
    #####: 1430:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1431:          }
        -: 1432:
    #####: 1433:          READ_LITERAL_INDEX (literal_index);
    #####: 1434:          JERRY_ASSERT (literal_index >= register_end);
        -: 1435:
    #####: 1436:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1437:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1438:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1439:
    #####: 1440:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1441:          {
        -: 1442:#if !(defined JERRY_NDEBUG)
    #####: 1443:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1444:            {
    #####: 1445:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1446:
    #####: 1447:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1448:            }
        -: 1449:#endif /* !JERRY_NDEBUG */
        -: 1450:
    #####: 1451:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1452:            prev_lex_env_p = lex_env_p;
    #####: 1453:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1454:          }
        -: 1455:
    #####: 1456:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1457:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1458:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1459:
    #####: 1460:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1461:          ecma_property_value_t *property_value_p;
        -: 1462:
    #####: 1463:          if (property_p == NULL)
        -: 1464:          {
    #####: 1465:            property_value_p =
        -: 1466:              ecma_create_named_data_property (prev_lex_env_p, name_p, ECMA_PROPERTY_CONFIGURABLE_WRITABLE, NULL);
        -: 1467:
    #####: 1468:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1469:            {
    #####: 1470:              continue;
        -: 1471:            }
        -: 1472:          }
        -: 1473:          else
        -: 1474:          {
    #####: 1475:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1476:            {
    #####: 1477:              continue;
        -: 1478:            }
        -: 1479:
    #####: 1480:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1481:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1482:          }
        -: 1483:
    #####: 1484:          property_value_p->value = lit_value;
    #####: 1485:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1486:          continue;
        -: 1487:        }
        -: 1488:#endif /* JERRY_ESNEXT */
    #####: 1489:        case VM_OC_CREATE_ARGUMENTS:
        -: 1490:        {
        -: 1491:          uint32_t literal_index;
    #####: 1492:          READ_LITERAL_INDEX (literal_index);
        -: 1493:
    #####: 1494:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1495:
    #####: 1496:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1497:                                                    frame_ctx_p->lex_env_p);
        -: 1498:
    #####: 1499:          if (literal_index < register_end)
        -: 1500:          {
    #####: 1501:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1502:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1503:            continue;
        -: 1504:          }
        -: 1505:
    #####: 1506:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1507:
    #####: 1508:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1509:
    #####: 1510:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1511:          ecma_property_value_t *property_value_p;
        -: 1512:
    #####: 1513:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1514:          property_value_p->value = result;
        -: 1515:
    #####: 1516:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1517:          continue;
        -: 1518:        }
        -: 1519:#if JERRY_SNAPSHOT_EXEC
    #####: 1520:        case VM_OC_SET_BYTECODE_PTR:
        -: 1521:        {
    #####: 1522:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1523:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1524:          continue;
        -: 1525:        }
        -: 1526:#endif /* JERRY_SNAPSHOT_EXEC */
        1: 1527:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1528:        {
        -: 1529:          uint32_t literal_index, value_index;
        -: 1530:          ecma_value_t lit_value;
        1: 1531:          bool release = false;
        -: 1532:
        1: 1533:          READ_LITERAL_INDEX (value_index);
        -: 1534:
        1: 1535:          if (value_index < register_end)
        -: 1536:          {
        -: 1537:            /* Take (not copy) the reference. */
    #####: 1538:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1539:          }
        -: 1540:          else
        -: 1541:          {
        1: 1542:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        1: 1543:            release = true;
        -: 1544:          }
        -: 1545:
        1: 1546:          READ_LITERAL_INDEX (literal_index);
        -: 1547:
        1: 1548:          JERRY_ASSERT (value_index != literal_index);
        1: 1549:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1550:
        1: 1551:          if (literal_index < register_end)
        -: 1552:          {
    #####: 1553:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1554:            JERRY_ASSERT (release);
    #####: 1555:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1556:            continue;
        -: 1557:          }
        -: 1558:
        1: 1559:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1560:
        1: 1561:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        1: 1562:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1563:
        -: 1564:          ecma_property_value_t *property_value_p;
        1: 1565:          property_value_p =
        1: 1566:            ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1567:
        1: 1568:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        1: 1569:          property_value_p->value = lit_value;
        -: 1570:
        1: 1571:          if (release)
        -: 1572:          {
        1: 1573:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1574:          }
        1: 1575:          continue;
        -: 1576:        }
        -: 1577:#if JERRY_ESNEXT
        2: 1578:        case VM_OC_CHECK_VAR:
        -: 1579:        {
        2: 1580:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1581:                        == CBC_FUNCTION_SCRIPT);
        -: 1582:
        -: 1583:          uint32_t literal_index;
        2: 1584:          READ_LITERAL_INDEX (literal_index);
        -: 1585:
        2: 1586:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1587:          {
        2: 1588:            continue;
        -: 1589:          }
        -: 1590:
    #####: 1591:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1592:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1593:
    #####: 1594:          if (binding_p != NULL)
        -: 1595:          {
    #####: 1596:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1597:            goto error;
        -: 1598:          }
        -: 1599:
    #####: 1600:          continue;
        -: 1601:        }
    #####: 1602:        case VM_OC_CHECK_LET:
        -: 1603:        {
    #####: 1604:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1605:                        == CBC_FUNCTION_SCRIPT);
        -: 1606:
        -: 1607:          uint32_t literal_index;
    #####: 1608:          READ_LITERAL_INDEX (literal_index);
        -: 1609:
    #####: 1610:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1611:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1612:
    #####: 1613:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1614:          {
    #####: 1615:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1616:
    #####: 1617:            if (!ecma_is_value_false (result))
        -: 1618:            {
    #####: 1619:              if (ecma_is_value_true (result))
        -: 1620:              {
    #####: 1621:                result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
        -: 1622:              }
        -: 1623:
    #####: 1624:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1625:              goto error;
        -: 1626:            }
        -: 1627:
    #####: 1628:            continue;
        -: 1629:          }
        -: 1630:
    #####: 1631:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1632:
        -: 1633:#if JERRY_BUILTIN_PROXY
    #####: 1634:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1635:          {
    #####: 1636:            goto error;
        -: 1637:          }
        -: 1638:#endif /* JERRY_BUILTIN_PROXY */
        -: 1639:
    #####: 1640:          if (ecma_is_value_true (result))
        -: 1641:          {
    #####: 1642:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1643:            goto error;
        -: 1644:          }
        -: 1645:
    #####: 1646:          continue;
        -: 1647:        }
    #####: 1648:        case VM_OC_ASSIGN_LET_CONST:
        -: 1649:        {
        -: 1650:          uint32_t literal_index;
    #####: 1651:          READ_LITERAL_INDEX (literal_index);
        -: 1652:
    #####: 1653:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1654:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1655:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1656:                            && ECMA_LEX_ENV_CLASS_IS_MODULE (frame_ctx_p->lex_env_p)));
        -: 1657:
    #####: 1658:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1659:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1660:
    #####: 1661:          JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1662:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
    #####: 1663:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1664:
    #####: 1665:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1666:
    #####: 1667:          if (ecma_is_value_object (left_value))
        -: 1668:          {
    #####: 1669:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1670:          }
    #####: 1671:          continue;
        -: 1672:        }
        8: 1673:        case VM_OC_INIT_BINDING:
        -: 1674:        {
        -: 1675:          uint32_t literal_index;
        -: 1676:
        8: 1677:          READ_LITERAL_INDEX (literal_index);
        -: 1678:
        8: 1679:          JERRY_ASSERT (literal_index >= register_end);
        -: 1680:
        8: 1681:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1682:
        8: 1683:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        8: 1684:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1685:
        8: 1686:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1687:
        8: 1688:          if (opcode == CBC_INIT_LET)
        -: 1689:          {
        8: 1690:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1691:          }
    #####: 1692:          else if (opcode == CBC_INIT_CONST)
        -: 1693:          {
    #####: 1694:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1695:          }
        -: 1696:
        -: 1697:          ecma_property_value_t *property_value_p;
        8: 1698:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1699:
        8: 1700:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1701:
        8: 1702:          ecma_value_t value = *(--stack_top_p);
        -: 1703:
        8: 1704:          property_value_p->value = value;
        8: 1705:          ecma_deref_if_object (value);
        8: 1706:          continue;
        -: 1707:        }
    #####: 1708:        case VM_OC_THROW_CONST_ERROR:
        -: 1709:        {
    #####: 1710:          result = ecma_raise_type_error (ECMA_ERR_CONSTANT_BINDINGS_CANNOT_BE_REASSIGNED);
    #####: 1711:          goto error;
        -: 1712:        }
    #####: 1713:        case VM_OC_COPY_TO_GLOBAL:
        -: 1714:        {
        -: 1715:          uint32_t literal_index;
    #####: 1716:          READ_LITERAL_INDEX (literal_index);
        -: 1717:
    #####: 1718:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1719:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1720:
    #####: 1721:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1722:          {
        -: 1723:#ifndef JERRY_NDEBUG
    #####: 1724:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1725:            {
    #####: 1726:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1727:
    #####: 1728:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1729:            }
        -: 1730:#endif /* !JERRY_NDEBUG */
        -: 1731:
    #####: 1732:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1733:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1734:          }
        -: 1735:
    #####: 1736:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1737:          {
    #####: 1738:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1739:            ecma_property_value_t *prop_value_p;
        -: 1740:
    #####: 1741:            if (property_p == NULL)
        -: 1742:            {
    #####: 1743:              prop_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1744:            }
        -: 1745:            else
        -: 1746:            {
        -: 1747:#ifndef JERRY_NDEBUG
    #####: 1748:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1749:#endif /* !JERRY_NDEBUG */
    #####: 1750:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1751:            }
        -: 1752:
    #####: 1753:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1754:          }
        -: 1755:          else
        -: 1756:          {
    #####: 1757:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1758:
    #####: 1759:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1760:            {
    #####: 1761:              goto error;
        -: 1762:            }
        -: 1763:          }
        -: 1764:
    #####: 1765:          goto free_left_value;
        -: 1766:        }
    #####: 1767:        case VM_OC_COPY_FROM_ARG:
        -: 1768:        {
        -: 1769:          uint32_t literal_index;
    #####: 1770:          READ_LITERAL_INDEX (literal_index);
    #####: 1771:          JERRY_ASSERT (literal_index >= register_end);
        -: 1772:
    #####: 1773:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1774:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1775:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1776:
    #####: 1777:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1778:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1779:          JERRY_ASSERT (arg_lex_env_p != NULL && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1780:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1781:
        -: 1782:          ecma_property_value_t *property_value_p;
    #####: 1783:          property_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1784:
    #####: 1785:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1786:          JERRY_ASSERT (property_p != NULL);
        -: 1787:
    #####: 1788:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1789:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1790:          continue;
        -: 1791:        }
    #####: 1792:        case VM_OC_CLONE_CONTEXT:
        -: 1793:        {
    #####: 1794:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1795:
    #####: 1796:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1797:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1798:          continue;
        -: 1799:        }
    #####: 1800:        case VM_OC_SET__PROTO__:
        -: 1801:        {
    #####: 1802:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1803:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1804:          {
    #####: 1805:            goto error;
        -: 1806:          }
    #####: 1807:          goto free_left_value;
        -: 1808:        }
    #####: 1809:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1810:        {
    #####: 1811:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1812:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1813:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1814:
    #####: 1815:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1816:          ecma_value_t value = stack_top_p[-1];
        -: 1817:
    #####: 1818:          if (!push_computed)
        -: 1819:          {
    #####: 1820:            stack_top_p++;
        -: 1821:          }
        -: 1822:
    #####: 1823:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1824:          stack_top_p[-4] = left_value;
        -: 1825:
    #####: 1826:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1827:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
    #####: 1828:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, class_object_p, class_object_p, initializer_func_p);
        -: 1829:
    #####: 1830:          if (!push_computed)
        -: 1831:          {
    #####: 1832:            continue;
        -: 1833:          }
        -: 1834:
    #####: 1835:          left_value = value;
        -: 1836:          /* FALLTHRU */
        -: 1837:        }
    #####: 1838:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1839:        {
    #####: 1840:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1841:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1842:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1843:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1844:
    #####: 1845:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1846:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1847:
    #####: 1848:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1849:          {
    #####: 1850:            goto error;
        -: 1851:          }
    #####: 1852:          goto free_left_value;
        -: 1853:        }
    #####: 1854:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1855:        {
    #####: 1856:          left_value = *(--stack_top_p);
        -: 1857:
    #####: 1858:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1859:          {
    #####: 1860:            continue;
        -: 1861:          }
        -: 1862:
    #####: 1863:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1864:
    #####: 1865:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1866:          {
    #####: 1867:            goto error;
        -: 1868:          }
        -: 1869:
    #####: 1870:          goto free_left_value;
        -: 1871:        }
    #####: 1872:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1873:        {
        -: 1874:          /* Swap values. */
    #####: 1875:          left_value ^= right_value;
    #####: 1876:          right_value ^= left_value;
    #####: 1877:          left_value ^= right_value;
        -: 1878:          /* FALLTHRU */
        -: 1879:        }
        -: 1880:#endif /* JERRY_ESNEXT */
    #####: 1881:        case VM_OC_SET_PROPERTY:
        -: 1882:        {
        -: 1883:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1884:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1885:
    #####: 1886:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1887:
    #####: 1888:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1889:
    #####: 1890:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1891:          {
    #####: 1892:            result = ECMA_VALUE_ERROR;
    #####: 1893:            goto error;
        -: 1894:          }
        -: 1895:
        -: 1896:#if JERRY_ESNEXT
    #####: 1897:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1898:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1899:          {
    #####: 1900:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1901:            goto error;
        -: 1902:          }
        -: 1903:
    #####: 1904:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1905:#else /* !JERRY_ESNEXT */
    #####: 1906:          const int index = -1;
        -: 1907:#endif /* JERRY_ESNEXT */
        -: 1908:
    #####: 1909:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1910:
    #####: 1911:          opfunc_set_data_property (object_p, prop_name_p, left_value);
    #####: 1912:          ecma_deref_ecma_string (prop_name_p);
        -: 1913:
    #####: 1914:          goto free_both_values;
        -: 1915:        }
        2: 1916:        case VM_OC_SET_GETTER:
        -: 1917:        case VM_OC_SET_SETTER:
        -: 1918:        {
        2: 1919:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1920:
        2: 1921:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1922:
        2: 1923:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1924:          {
    #####: 1925:            result = ECMA_VALUE_ERROR;
    #####: 1926:            goto error;
        -: 1927:          }
        -: 1928:
        -: 1929:#if JERRY_ESNEXT
        2: 1930:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1931:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1932:          {
    #####: 1933:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1934:            goto error;
        -: 1935:          }
        -: 1936:
        2: 1937:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1938:#else /* !JERRY_ESNEXT */
    #####: 1939:          const int index = -1;
        -: 1940:#endif /* JERRY_ESNEXT */
        -: 1941:
        2: 1942:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
        2: 1943:                               stack_top_p[index],
        -: 1944:                               prop_name_p,
        -: 1945:                               right_value);
        -: 1946:
        2: 1947:          ecma_deref_ecma_string (prop_name_p);
        -: 1948:
        2: 1949:          goto free_both_values;
        -: 1950:        }
    #####: 1951:        case VM_OC_PUSH_ARRAY:
        -: 1952:        {
        -: 1953:          /* Note: this operation cannot throw an exception */
    #####: 1954:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
    #####: 1955:          continue;
        -: 1956:        }
        -: 1957:#if JERRY_ESNEXT
    #####: 1958:        case VM_OC_LOCAL_EVAL:
        -: 1959:        {
    #####: 1960:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 1961:          uint8_t parse_opts = *byte_code_p++;
    #####: 1962:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 1963:          continue;
        -: 1964:        }
    #####: 1965:        case VM_OC_SUPER_CALL:
        -: 1966:        {
    #####: 1967:          uint8_t arguments_list_len = *byte_code_p++;
        -: 1968:
    #####: 1969:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 1970:          {
    #####: 1971:            stack_top_p -= arguments_list_len;
    #####: 1972:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 1973:
    #####: 1974:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 1975:            {
    #####: 1976:              result = ECMA_VALUE_ERROR;
    #####: 1977:              goto error;
        -: 1978:            }
        -: 1979:
    #####: 1980:            stack_top_p++;
    #####: 1981:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 1982:          }
        -: 1983:          else
        -: 1984:          {
    #####: 1985:            stack_top_p -= arguments_list_len;
        -: 1986:          }
        -: 1987:
    #####: 1988:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 1989:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 1990:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 1991:          return ECMA_VALUE_UNDEFINED;
        -: 1992:        }
        9: 1993:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 1994:        {
        -: 1995:          uint16_t literal_index;
        -: 1996:
        9: 1997:          READ_LITERAL_INDEX (literal_index);
        9: 1998:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
        9: 1999:          continue;
        -: 2000:        }
        1: 2001:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2002:        {
        1: 2003:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode, frame_ctx_p->shared_p->bytecode_header_p);
        1: 2004:          continue;
        -: 2005:        }
    #####: 2006:        case VM_OC_DEFINE_FIELD:
        -: 2007:        {
    #####: 2008:          result = opfunc_define_field (frame_ctx_p->this_binding, right_value, left_value);
        -: 2009:
    #####: 2010:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2011:          {
    #####: 2012:            goto error;
        -: 2013:          }
        -: 2014:
    #####: 2015:          goto free_both_values;
        -: 2016:        }
    #####: 2017:        case VM_OC_ASSIGN_PRIVATE:
        -: 2018:        {
    #####: 2019:          result = opfunc_private_set (stack_top_p[-3], stack_top_p[-2], stack_top_p[-1]);
        -: 2020:
    #####: 2021:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2022:          {
    #####: 2023:            goto error;
        -: 2024:          }
        -: 2025:
    #####: 2026:          ecma_free_value (stack_top_p[-3]);
    #####: 2027:          ecma_free_value (stack_top_p[-2]);
    #####: 2028:          ecma_free_value (stack_top_p[-1]);
    #####: 2029:          stack_top_p -= 3;
        -: 2030:
    #####: 2031:          if (opcode_data & VM_OC_PUT_STACK)
        -: 2032:          {
    #####: 2033:            *stack_top_p++ = result;
        -: 2034:          }
    #####: 2035:          else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2036:          {
    #####: 2037:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 2038:            VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 2039:          }
        -: 2040:          else
        -: 2041:          {
    #####: 2042:            ecma_free_value (result);
        -: 2043:          }
        -: 2044:
    #####: 2045:          goto free_both_values;
        -: 2046:        }
    #####: 2047:        case VM_OC_PRIVATE_FIELD_ADD:
        -: 2048:        {
    #####: 2049:          result = opfunc_private_field_add (frame_ctx_p->this_binding, right_value, left_value);
        -: 2050:
    #####: 2051:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2052:          {
    #####: 2053:            goto error;
        -: 2054:          }
        -: 2055:
    #####: 2056:          goto free_both_values;
        -: 2057:        }
    #####: 2058:        case VM_OC_PRIVATE_PROP_GET:
        -: 2059:        {
    #####: 2060:          result = opfunc_private_get (left_value, right_value);
        -: 2061:
    #####: 2062:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2063:          {
    #####: 2064:            goto error;
        -: 2065:          }
        -: 2066:
    #####: 2067:          *stack_top_p++ = result;
    #####: 2068:          goto free_both_values;
        -: 2069:        }
    #####: 2070:        case VM_OC_PRIVATE_PROP_REFERENCE:
        -: 2071:        {
    #####: 2072:          result = opfunc_private_get (stack_top_p[-1], left_value);
        -: 2073:
    #####: 2074:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2075:          {
    #####: 2076:            goto error;
        -: 2077:          }
        -: 2078:
    #####: 2079:          *stack_top_p++ = left_value;
    #####: 2080:          *stack_top_p++ = result;
    #####: 2081:          continue;
        -: 2082:        }
    #####: 2083:        case VM_OC_PRIVATE_IN:
        -: 2084:        {
    #####: 2085:          result = opfunc_private_in (left_value, right_value);
        -: 2086:
    #####: 2087:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2088:          {
    #####: 2089:            goto error;
        -: 2090:          }
        -: 2091:
    #####: 2092:          *stack_top_p++ = result;
    #####: 2093:          goto free_both_values;
        -: 2094:        }
    #####: 2095:        case VM_OC_COLLECT_PRIVATE_PROPERTY:
        -: 2096:        {
    #####: 2097:          opfunc_collect_private_properties (stack_top_p[-2], left_value, right_value, opcode);
    #####: 2098:          continue;
        -: 2099:        }
        9: 2100:        case VM_OC_INIT_CLASS:
        -: 2101:        {
        9: 2102:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2103:
        9: 2104:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2105:          {
    #####: 2106:            goto error;
        -: 2107:          }
        9: 2108:          continue;
        -: 2109:        }
        9: 2110:        case VM_OC_FINALIZE_CLASS:
        -: 2111:        {
        9: 2112:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2113:
        9: 2114:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2115:          {
        -: 2116:            uint16_t literal_index;
        9: 2117:            READ_LITERAL_INDEX (literal_index);
        9: 2118:            left_value = literal_start_p[literal_index];
        -: 2119:          }
        -: 2120:
        9: 2121:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
        9: 2122:          continue;
        -: 2123:        }
    #####: 2124:        case VM_OC_SET_FIELD_INIT:
        -: 2125:        {
    #####: 2126:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2127:          ecma_object_t *proto_object_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####: 2128:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 2129:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
        -: 2130:
    #####: 2131:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, proto_object_p, class_object_p, initializer_func_p);
        -: 2132:
    #####: 2133:          ecma_property_value_t *property_value_p =
        -: 2134:            ecma_create_named_data_property (class_object_p, property_name_p, ECMA_PROPERTY_FIXED, NULL);
    #####: 2135:          property_value_p->value = left_value;
        -: 2136:
    #####: 2137:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2138:          ecma_property_t *property_p = ecma_find_named_property (class_object_p, property_name_p);
        -: 2139:
    #####: 2140:          if (property_p != NULL)
        -: 2141:          {
    #####: 2142:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2143:            ecma_value_t *compact_collection_p =
    #####: 2144:              ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
    #####: 2145:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2146:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2147:          }
        -: 2148:
    #####: 2149:          goto free_left_value;
        -: 2150:        }
    #####: 2151:        case VM_OC_RUN_FIELD_INIT:
        -: 2152:        {
    #####: 2153:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2154:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2155:
    #####: 2156:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2157:          {
    #####: 2158:            goto error;
        -: 2159:          }
    #####: 2160:          continue;
        -: 2161:        }
    #####: 2162:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2163:        {
    #####: 2164:          left_value = stack_top_p[-2];
    #####: 2165:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2166:          stack_top_p--;
        -: 2167:
    #####: 2168:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2169:
    #####: 2170:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2171:          {
    #####: 2172:            goto error;
        -: 2173:          }
    #####: 2174:          goto free_left_value;
        -: 2175:        }
    #####: 2176:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2177:        {
    #####: 2178:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2179:          stack_top_p[-2] = ecma_make_integer_value (next_index);
        -: 2180:
    #####: 2181:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2182:
    #####: 2183:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2184:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
    #####: 2185:          ecma_value_t prop_name = computed_class_fields_p[next_index];
        -: 2186:
    #####: 2187:          if (opcode == CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC)
        -: 2188:          {
    #####: 2189:            ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2190:
    #####: 2191:            JERRY_ASSERT (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) == NULL);
        -: 2192:            ecma_property_value_t *value_p;
    #####: 2193:            value_p = ecma_create_named_data_property (func_obj_p,
        -: 2194:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2195:                                                       ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2196:                                                       NULL);
        -: 2197:
    #####: 2198:            if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2199:            {
    #####: 2200:              ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2201:            }
        -: 2202:
    #####: 2203:            value_p->value = ecma_copy_value (prop_name);
        -: 2204:          }
        -: 2205:
    #####: 2206:          result = opfunc_define_field (frame_ctx_p->this_binding, prop_name, stack_top_p[-1]);
        -: 2207:
    #####: 2208:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2209:          {
    #####: 2210:            goto error;
        -: 2211:          }
        -: 2212:
    #####: 2213:          ecma_free_value (*(--stack_top_p));
    #####: 2214:          continue;
        -: 2215:        }
    #####: 2216:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2217:        {
    #####: 2218:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2219:
    #####: 2220:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2221:          {
    #####: 2222:            goto error;
        -: 2223:          }
        -: 2224:
    #####: 2225:          *stack_top_p++ = result;
    #####: 2226:          continue;
        -: 2227:        }
    #####: 2228:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2229:        {
    #####: 2230:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2231:
    #####: 2232:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2233:          {
    #####: 2234:            goto error;
        -: 2235:          }
        -: 2236:
    #####: 2237:          *stack_top_p++ = result;
    #####: 2238:          continue;
        -: 2239:        }
    #####: 2240:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2241:        {
    #####: 2242:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2243:          {
    #####: 2244:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2245:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2246:
    #####: 2247:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2248:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2249:            *stack_top_p++ = obj_value;
        -: 2250:          }
        -: 2251:          else
        -: 2252:          {
    #####: 2253:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2254:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2255:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2256:            stack_top_p--;
        -: 2257:          }
    #####: 2258:          continue;
        -: 2259:        }
    #####: 2260:        case VM_OC_SET_HOME_OBJECT:
        -: 2261:        {
    #####: 2262:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2263:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2264:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2265:          continue;
        -: 2266:        }
        5: 2267:        case VM_OC_SUPER_REFERENCE:
        -: 2268:        {
        5: 2269:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2270:
        5: 2271:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2272:          {
        4: 2273:            goto error;
        -: 2274:          }
        -: 2275:
        1: 2276:          goto free_left_value;
        -: 2277:        }
        9: 2278:        case VM_OC_SET_FUNCTION_NAME:
        -: 2279:        {
        9: 2280:          char *prefix_p = NULL;
        9: 2281:          lit_utf8_size_t prefix_size = 0;
        -: 2282:
        9: 2283:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2284:          {
        -: 2285:            ecma_value_t prop_name_value;
        -: 2286:
        9: 2287:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2288:            {
        -: 2289:              uint16_t literal_index;
        9: 2290:              READ_LITERAL_INDEX (literal_index);
        9: 2291:              prop_name_value = literal_start_p[literal_index];
        -: 2292:            }
        -: 2293:            else
        -: 2294:            {
    #####: 2295:              prop_name_value = stack_top_p[-2];
        -: 2296:            }
        -: 2297:
        9: 2298:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2299:
        9: 2300:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2301:            {
    #####: 2302:              result = ECMA_VALUE_ERROR;
    #####: 2303:              goto error;
        -: 2304:            }
        -: 2305:
        9: 2306:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2307:
        9: 2308:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2309:            {
    #####: 2310:              ecma_ref_ecma_string (prop_name_p);
    #####: 2311:              ecma_free_value (stack_top_p[-2]);
    #####: 2312:              stack_top_p[-2] = left_value;
        -: 2313:            }
        -: 2314:
        9: 2315:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2316:            {
    #####: 2317:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2318:              prefix_size = 4;
        -: 2319:            }
        -: 2320:          }
        -: 2321:
        9: 2322:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2323:
        9: 2324:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2325:          {
    #####: 2326:            ecma_free_value (left_value);
    #####: 2327:            continue;
        -: 2328:          }
        -: 2329:
        -: 2330:          ecma_property_value_t *value_p;
        9: 2331:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2332:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2333:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2334:                                                     NULL);
        -: 2335:
        9: 2336:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2337:          {
        8: 2338:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2339:          }
        -: 2340:
        9: 2341:          value_p->value =
        9: 2342:            ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value), prefix_p, prefix_size);
        9: 2343:          ecma_free_value (left_value);
        9: 2344:          continue;
        -: 2345:        }
    #####: 2346:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2347:        {
    #####: 2348:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2349:          continue;
        -: 2350:        }
    #####: 2351:        case VM_OC_PUSH_REST_OBJECT:
        -: 2352:        {
    #####: 2353:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2354:
    #####: 2355:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2356:
    #####: 2357:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2358:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2359:          uint16_t argument_end;
        -: 2360:
    #####: 2361:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2362:          {
    #####: 2363:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2364:          }
        -: 2365:          else
        -: 2366:          {
    #####: 2367:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2368:          }
        -: 2369:
    #####: 2370:          if (arg_list_len < argument_end)
        -: 2371:          {
    #####: 2372:            arg_list_len = argument_end;
        -: 2373:          }
        -: 2374:
    #####: 2375:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end, arg_list_len - argument_end);
        -: 2376:
    #####: 2377:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2378:          *stack_top_p++ = result;
    #####: 2379:          continue;
        -: 2380:        }
    #####: 2381:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2382:        {
    #####: 2383:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2384:
    #####: 2385:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2386:          {
    #####: 2387:            goto error;
        -: 2388:          }
        -: 2389:
    #####: 2390:          uint32_t context_size =
    #####: 2391:            (uint32_t) (stack_top_p + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION - VM_LAST_CONTEXT_END ());
    #####: 2392:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2393:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2394:
    #####: 2395:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2396:          stack_top_p[-2] = result;
    #####: 2397:          stack_top_p[-3] = left_value;
        -: 2398:
    #####: 2399:          continue;
        -: 2400:        }
    #####: 2401:        case VM_OC_ITERATOR_STEP:
        -: 2402:        {
    #####: 2403:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2404:
    #####: 2405:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2406:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2407:
    #####: 2408:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2409:
    #####: 2410:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2411:          {
    #####: 2412:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2413:            goto error;
        -: 2414:          }
        -: 2415:
    #####: 2416:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2417:
    #####: 2418:          if (!ecma_is_value_false (result))
        -: 2419:          {
    #####: 2420:            value = ecma_op_iterator_value (result);
    #####: 2421:            ecma_free_value (result);
        -: 2422:
    #####: 2423:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2424:            {
    #####: 2425:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2426:              result = value;
    #####: 2427:              goto error;
        -: 2428:            }
        -: 2429:          }
        -: 2430:          else
        -: 2431:          {
    #####: 2432:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2433:          }
        -: 2434:
    #####: 2435:          *stack_top_p++ = value;
    #####: 2436:          continue;
        -: 2437:        }
    #####: 2438:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2439:        {
    #####: 2440:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2441:
    #####: 2442:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2443:          {
    #####: 2444:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2445:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2446:
    #####: 2447:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2448:            {
    #####: 2449:              goto error;
        -: 2450:            }
        -: 2451:          }
        -: 2452:
    #####: 2453:          stack_top_p =
    #####: 2454:            vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2455:          continue;
        -: 2456:        }
        1: 2457:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2458:        {
        1: 2459:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2460:
        1: 2461:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2462:          {
    #####: 2463:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2464:            continue;
        -: 2465:          }
        -: 2466:
        1: 2467:          stack_top_p--;
        1: 2468:          continue;
        -: 2469:        }
    #####: 2470:        case VM_OC_REST_INITIALIZER:
        -: 2471:        {
    #####: 2472:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2473:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2474:
    #####: 2475:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2476:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2477:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2478:          uint32_t index = 0;
        -: 2479:
        -: 2480:          while (true)
    #####: 2481:          {
    #####: 2482:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2483:
    #####: 2484:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2485:            {
    #####: 2486:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2487:              ecma_deref_object (array_p);
    #####: 2488:              goto error;
        -: 2489:            }
        -: 2490:
    #####: 2491:            if (ecma_is_value_false (result))
        -: 2492:            {
    #####: 2493:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2494:              break;
        -: 2495:            }
        -: 2496:
    #####: 2497:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2498:            ecma_free_value (result);
        -: 2499:
    #####: 2500:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2501:            {
    #####: 2502:              ecma_deref_object (array_p);
    #####: 2503:              result = value;
    #####: 2504:              goto error;
        -: 2505:            }
        -: 2506:
    #####: 2507:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2508:            JERRY_ASSERT (set_result);
    #####: 2509:            ecma_free_value (value);
        -: 2510:          }
        -: 2511:
    #####: 2512:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2513:          continue;
        -: 2514:        }
    #####: 2515:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2516:        {
    #####: 2517:          left_value = stack_top_p[-1];
    #####: 2518:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2519:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2520:
    #####: 2521:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2522:          {
    #####: 2523:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2524:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2525:          }
        -: 2526:
    #####: 2527:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2528:          stack_top_p += context_stack_allocation;
    #####: 2529:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2530:
    #####: 2531:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2532:          stack_top_p[-2] = left_value;
        -: 2533:
    #####: 2534:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2535:          {
    #####: 2536:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2537:          }
    #####: 2538:          continue;
        -: 2539:        }
    #####: 2540:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2541:        {
    #####: 2542:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2543:
    #####: 2544:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2545:
    #####: 2546:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2547:          {
    #####: 2548:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2549:          }
        -: 2550:
    #####: 2551:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, context_stack_allocation);
    #####: 2552:          continue;
        -: 2553:        }
    #####: 2554:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2555:        {
    #####: 2556:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2557:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2558:          {
    #####: 2559:            result = ECMA_VALUE_ERROR;
    #####: 2560:            goto error;
        -: 2561:          }
        -: 2562:
    #####: 2563:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2564:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2565:
    #####: 2566:          left_value = ecma_make_object_value (result_object_p);
    #####: 2567:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2568:
    #####: 2569:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2570:          {
    #####: 2571:            goto error;
        -: 2572:          }
        -: 2573:
    #####: 2574:          ecma_free_value (last_context_end_p[-3]);
    #####: 2575:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2576:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2577:
    #####: 2578:          *stack_top_p++ = left_value;
    #####: 2579:          continue;
        -: 2580:        }
    #####: 2581:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2582:        {
    #####: 2583:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2584:          {
    #####: 2585:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2586:
    #####: 2587:            if (property_key == NULL)
        -: 2588:            {
    #####: 2589:              result = ECMA_VALUE_ERROR;
    #####: 2590:              goto error;
        -: 2591:            }
        -: 2592:
    #####: 2593:            ecma_free_value (left_value);
    #####: 2594:            left_value = ecma_make_string_value (property_key);
        -: 2595:          }
        -: 2596:
    #####: 2597:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2598:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2599:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2600:
    #####: 2601:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2602:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2603:          /* FALLTHRU */
        -: 2604:        }
    #####: 2605:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2606:        {
    #####: 2607:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2608:          ecma_value_t base = last_context_end_p[-2];
        -: 2609:
    #####: 2610:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2611:          {
    #####: 2612:            left_value = *last_context_end_p++;
    #####: 2613:            while (last_context_end_p < stack_top_p)
        -: 2614:            {
    #####: 2615:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2616:              last_context_end_p++;
        -: 2617:            }
    #####: 2618:            stack_top_p--;
        -: 2619:          }
        -: 2620:
    #####: 2621:          result = vm_op_get_value (base, left_value);
        -: 2622:
    #####: 2623:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2624:          {
    #####: 2625:            goto error;
        -: 2626:          }
        -: 2627:
    #####: 2628:          *stack_top_p++ = result;
    #####: 2629:          goto free_left_value;
        -: 2630:        }
    #####: 2631:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2632:        {
    #####: 2633:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2634:          stack_top_p -= arguments_list_len;
        -: 2635:
    #####: 2636:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2637:
    #####: 2638:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2639:          {
    #####: 2640:            result = ECMA_VALUE_ERROR;
    #####: 2641:            goto error;
        -: 2642:          }
        -: 2643:
    #####: 2644:          stack_top_p++;
    #####: 2645:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2646:
    #####: 2647:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2648:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2649:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2650:          return ECMA_VALUE_UNDEFINED;
        -: 2651:        }
    #####: 2652:        case VM_OC_CREATE_GENERATOR:
        -: 2653:        {
    #####: 2654:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2655:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2656:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2657:
        -: 2658:          vm_executable_object_t *executable_object_p;
    #####: 2659:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2660:
    #####: 2661:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2662:        }
    #####: 2663:        case VM_OC_YIELD:
        -: 2664:        {
    #####: 2665:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2666:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2667:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2668:          return *stack_top_p;
        -: 2669:        }
    #####: 2670:        case VM_OC_ASYNC_YIELD:
        -: 2671:        {
    #####: 2672:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2673:
    #####: 2674:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2675:
    #####: 2676:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2677:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2678:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2679:          return ECMA_VALUE_UNDEFINED;
        -: 2680:        }
    #####: 2681:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2682:        {
    #####: 2683:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2684:
    #####: 2685:          JERRY_ASSERT (
        -: 2686:            !(async_generator_object_p->u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2687:
        -: 2688:          /* Byte code is executed at the first time. */
    #####: 2689:          left_value = stack_top_p[-1];
    #####: 2690:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2691:
    #####: 2692:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2693:          {
    #####: 2694:            goto error;
        -: 2695:          }
        -: 2696:
    #####: 2697:          ecma_free_value (left_value);
    #####: 2698:          left_value = result;
    #####: 2699:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2700:
    #####: 2701:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2702:          {
    #####: 2703:            goto error;
        -: 2704:          }
        -: 2705:
    #####: 2706:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2707:
    #####: 2708:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2709:          {
    #####: 2710:            goto error;
        -: 2711:          }
        -: 2712:
    #####: 2713:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2714:          *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = left_value;
        -: 2715:
    #####: 2716:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2717:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2718:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2719:          return ECMA_VALUE_UNDEFINED;
        -: 2720:        }
    #####: 2721:        case VM_OC_AWAIT:
        -: 2722:        {
    #####: 2723:          if (JERRY_UNLIKELY (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE)))
        -: 2724:          {
    #####: 2725:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2726:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2727:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2728:
    #####: 2729:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2730:
    #####: 2731:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2732:            {
    #####: 2733:              goto error;
        -: 2734:            }
    #####: 2735:            return result;
        -: 2736:          }
        -: 2737:          /* FALLTHRU */
        -: 2738:        }
        -: 2739:        case VM_OC_GENERATOR_AWAIT:
        -: 2740:        {
    #####: 2741:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2742:
    #####: 2743:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2744:
    #####: 2745:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2746:          {
    #####: 2747:            goto error;
        -: 2748:          }
        -: 2749:
    #####: 2750:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2751:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2752:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2753:          return ECMA_VALUE_UNDEFINED;
        -: 2754:        }
    #####: 2755:        case VM_OC_EXT_RETURN:
        -: 2756:        {
    #####: 2757:          result = left_value;
    #####: 2758:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2759:
    #####: 2760:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2761:
    #####: 2762:          while (stack_top_p > stack_bottom_p)
        -: 2763:          {
    #####: 2764:            ecma_fast_free_value (*(--stack_top_p));
        -: 2765:          }
        -: 2766:
    #####: 2767:          goto error;
        -: 2768:        }
    #####: 2769:        case VM_OC_ASYNC_EXIT:
        -: 2770:        {
    #####: 2771:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2772:
    #####: 2773:          if (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 2774:          {
    #####: 2775:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2776:          }
        -: 2777:          else
        -: 2778:          {
    #####: 2779:            result = *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p);
    #####: 2780:            *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = ECMA_VALUE_UNDEFINED;
        -: 2781:          }
        -: 2782:
    #####: 2783:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2784:
    #####: 2785:          if (context_type == VM_CONTEXT_TRY)
        -: 2786:          {
    #####: 2787:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2788:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2789:          }
        -: 2790:          else
        -: 2791:          {
    #####: 2792:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2793:            left_value = stack_top_p[-2];
        -: 2794:          }
        -: 2795:
    #####: 2796:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2797:          {
    #####: 2798:            ecma_reject_promise (result, left_value);
        -: 2799:          }
        -: 2800:          else
        -: 2801:          {
    #####: 2802:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2803:            ecma_fulfill_promise (result, left_value);
        -: 2804:          }
        -: 2805:
    #####: 2806:          ecma_free_value (left_value);
        -: 2807:
    #####: 2808:          frame_ctx_p->context_depth = 0;
    #####: 2809:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2810:          return result;
        -: 2811:        }
    #####: 2812:        case VM_OC_STRING_CONCAT:
        -: 2813:        {
    #####: 2814:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2815:
    #####: 2816:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2817:          {
    #####: 2818:            result = ECMA_VALUE_ERROR;
    #####: 2819:            goto error;
        -: 2820:          }
    #####: 2821:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2822:
    #####: 2823:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2824:          {
    #####: 2825:            ecma_deref_ecma_string (left_str_p);
    #####: 2826:            result = ECMA_VALUE_ERROR;
    #####: 2827:            goto error;
        -: 2828:          }
        -: 2829:
    #####: 2830:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2831:          ecma_deref_ecma_string (right_str_p);
        -: 2832:
    #####: 2833:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2834:          goto free_both_values;
        -: 2835:        }
    #####: 2836:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2837:        {
    #####: 2838:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2839:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2840:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2841:
    #####: 2842:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2843:          continue;
        -: 2844:        }
    #####: 2845:        case VM_OC_PUSH_NEW_TARGET:
        -: 2846:        {
    #####: 2847:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2848:          if (new_target_object_p == NULL)
        -: 2849:          {
    #####: 2850:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2851:          }
        -: 2852:          else
        -: 2853:          {
    #####: 2854:            ecma_ref_object (new_target_object_p);
    #####: 2855:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2856:          }
    #####: 2857:          continue;
        -: 2858:        }
    #####: 2859:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2860:        {
    #####: 2861:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2862:          {
    #####: 2863:            result = ECMA_VALUE_ERROR;
    #####: 2864:            goto error;
        -: 2865:          }
    #####: 2866:          continue;
        -: 2867:        }
        1: 2868:        case VM_OC_ASSIGN_SUPER:
        -: 2869:        {
        1: 2870:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2871:
    #####: 2872:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2873:          {
    #####: 2874:            goto error;
        -: 2875:          }
    #####: 2876:          continue;
        -: 2877:        }
        -: 2878:#endif /* JERRY_ESNEXT */
        1: 2879:        case VM_OC_PUSH_ELISON:
        -: 2880:        {
        1: 2881:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
        1: 2882:          continue;
        -: 2883:        }
    #####: 2884:        case VM_OC_APPEND_ARRAY:
        -: 2885:        {
    #####: 2886:          uint16_t values_length = *byte_code_p++;
    #####: 2887:          stack_top_p -= values_length;
        -: 2888:
        -: 2889:#if JERRY_ESNEXT
    #####: 2890:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2891:          {
    #####: 2892:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2893:          }
        -: 2894:#endif /* JERRY_ESNEXT */
    #####: 2895:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2896:
        -: 2897:#if JERRY_ESNEXT
    #####: 2898:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2899:          {
    #####: 2900:            goto error;
        -: 2901:          }
        -: 2902:#else /* !JERRY_ESNEXT */
        -: 2903:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2904:#endif /* JERRY_ESNEXT */
    #####: 2905:          continue;
        -: 2906:        }
    #####: 2907:        case VM_OC_IDENT_REFERENCE:
        -: 2908:        {
        -: 2909:          uint16_t literal_index;
        -: 2910:
    #####: 2911:          READ_LITERAL_INDEX (literal_index);
        -: 2912:
    #####: 2913:          JERRY_ASSERT (literal_index < ident_end);
        -: 2914:
    #####: 2915:          if (literal_index < register_end)
        -: 2916:          {
    #####: 2917:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2918:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2919:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2920:          }
        -: 2921:          else
        -: 2922:          {
    #####: 2923:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2924:
    #####: 2925:            ecma_object_t *ref_base_lex_env_p;
        -: 2926:
    #####: 2927:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 2928:
    #####: 2929:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2930:            {
    #####: 2931:              goto error;
        -: 2932:            }
        -: 2933:
    #####: 2934:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2935:            ecma_ref_ecma_string (name_p);
    #####: 2936:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2937:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2938:            *stack_top_p++ = result;
        -: 2939:          }
    #####: 2940:          continue;
        -: 2941:        }
    #####: 2942:        case VM_OC_PROP_GET:
        -: 2943:        {
    #####: 2944:          result = vm_op_get_value (left_value, right_value);
        -: 2945:
    #####: 2946:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2947:          {
    #####: 2948:            goto error;
        -: 2949:          }
        -: 2950:
    #####: 2951:          *stack_top_p++ = result;
    #####: 2952:          goto free_both_values;
        -: 2953:        }
    #####: 2954:        case VM_OC_PROP_REFERENCE:
        -: 2955:        {
        -: 2956:          /* Forms with reference requires preserving the base and offset. */
        -: 2957:
    #####: 2958:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2959:          {
    #####: 2960:            left_value = stack_top_p[-2];
    #####: 2961:            right_value = stack_top_p[-1];
        -: 2962:          }
    #####: 2963:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2964:          {
    #####: 2965:            *stack_top_p++ = left_value;
    #####: 2966:            right_value = left_value;
    #####: 2967:            left_value = stack_top_p[-2];
        -: 2968:          }
        -: 2969:          else
        -: 2970:          {
    #####: 2971:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2972:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
    #####: 2973:            *stack_top_p++ = left_value;
    #####: 2974:            *stack_top_p++ = right_value;
        -: 2975:          }
        -: 2976:          /* FALLTHRU */
        -: 2977:        }
        -: 2978:        case VM_OC_PROP_PRE_INCR:
        -: 2979:        case VM_OC_PROP_PRE_DECR:
        -: 2980:        case VM_OC_PROP_POST_INCR:
        -: 2981:        case VM_OC_PROP_POST_DECR:
        -: 2982:        {
    #####: 2983:          result = vm_op_get_value (left_value, right_value);
        -: 2984:
    #####: 2985:          if (opcode < CBC_PRE_INCR)
        -: 2986:          {
    #####: 2987:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 2988:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2989:          }
        -: 2990:
    #####: 2991:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2992:          {
    #####: 2993:            goto error;
        -: 2994:          }
        -: 2995:
    #####: 2996:          if (opcode < CBC_PRE_INCR)
        -: 2997:          {
    #####: 2998:            break;
        -: 2999:          }
        -: 3000:
    #####: 3001:          stack_top_p += 2;
    #####: 3002:          left_value = result;
    #####: 3003:          right_value = ECMA_VALUE_UNDEFINED;
        -: 3004:          /* FALLTHRU */
        -: 3005:        }
    #####: 3006:        case VM_OC_PRE_INCR:
        -: 3007:        case VM_OC_PRE_DECR:
        -: 3008:        case VM_OC_POST_INCR:
        -: 3009:        case VM_OC_POST_DECR:
        -: 3010:        {
    #####: 3011:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
    #####: 3012:          ecma_number_t result_number;
        -: 3013:
    #####: 3014:          byte_code_p = byte_code_start_p + 1;
        -: 3015:
    #####: 3016:          if (ecma_is_value_integer_number (left_value))
        -: 3017:          {
    #####: 3018:            result = left_value;
    #####: 3019:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3020:
    #####: 3021:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
    #####: 3022:            ecma_integer_value_t int_increase = 0;
        -: 3023:
    #####: 3024:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3025:            {
    #####: 3026:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 3027:              {
    #####: 3028:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 3029:              }
        -: 3030:            }
    #####: 3031:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 3032:            {
    #####: 3033:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 3034:            }
        -: 3035:
    #####: 3036:            if (JERRY_LIKELY (int_increase != 0))
        -: 3037:            {
        -: 3038:              /* Postfix operators require the unmodifed number value. */
    #####: 3039:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3040:              {
    #####: 3041:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3042:              }
        -: 3043:
    #####: 3044:              result = (ecma_value_t) (int_value + int_increase);
    #####: 3045:              break;
        -: 3046:            }
    #####: 3047:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3048:          }
    #####: 3049:          else if (ecma_is_value_float_number (left_value))
        -: 3050:          {
    #####: 3051:            result = left_value;
    #####: 3052:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3053:            result_number = ecma_get_number_from_value (result);
        -: 3054:          }
        -: 3055:          else
        -: 3056:          {
    #####: 3057:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3058:
    #####: 3059:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3060:            {
    #####: 3061:              goto error;
        -: 3062:            }
        -: 3063:
    #####: 3064:            ecma_free_value (left_value);
    #####: 3065:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3066:
        -: 3067:#if JERRY_BUILTIN_BIGINT
    #####: 3068:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3069:            {
    #####: 3070:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3071:
    #####: 3072:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3073:              {
    #####: 3074:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3075:              }
        -: 3076:
        -: 3077:              /* Postfix operators require the unmodifed number value. */
    #####: 3078:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3079:              {
    #####: 3080:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3081:
    #####: 3082:                result = ecma_bigint_unary (result, operation_type);
        -: 3083:              }
        -: 3084:              else
        -: 3085:              {
    #####: 3086:                ecma_value_t original_value = result;
    #####: 3087:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3088:                ecma_free_value (original_value);
        -: 3089:              }
        -: 3090:
    #####: 3091:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3092:              {
    #####: 3093:                goto error;
        -: 3094:              }
    #####: 3095:              break;
        -: 3096:            }
        -: 3097:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3098:
    #####: 3099:            result = ecma_make_number_value (result_number);
        -: 3100:          }
        -: 3101:
    #####: 3102:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3103:
    #####: 3104:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3105:          {
        -: 3106:            /* For decrement operators */
    #####: 3107:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3108:          }
        -: 3109:
        -: 3110:          /* Postfix operators require the unmodifed number value. */
    #####: 3111:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3112:          {
    #####: 3113:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3114:
    #####: 3115:            result = ecma_make_number_value (result_number + increase);
    #####: 3116:            break;
        -: 3117:          }
        -: 3118:
    #####: 3119:          if (ecma_is_value_integer_number (result))
        -: 3120:          {
    #####: 3121:            result = ecma_make_number_value (result_number + increase);
        -: 3122:          }
        -: 3123:          else
        -: 3124:          {
    #####: 3125:            result = ecma_update_float_number (result, result_number + increase);
        -: 3126:          }
    #####: 3127:          break;
        -: 3128:        }
    #####: 3129:        case VM_OC_ASSIGN:
        -: 3130:        {
    #####: 3131:          result = left_value;
    #####: 3132:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3133:          break;
        -: 3134:        }
       12: 3135:        case VM_OC_MOV_IDENT:
        -: 3136:        {
        -: 3137:          uint32_t literal_index;
        -: 3138:
       12: 3139:          READ_LITERAL_INDEX (literal_index);
        -: 3140:
       12: 3141:          JERRY_ASSERT (literal_index < register_end);
       12: 3142:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3143:
       12: 3144:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
       12: 3145:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
       12: 3146:          continue;
        -: 3147:        }
    #####: 3148:        case VM_OC_ASSIGN_PROP:
        -: 3149:        {
    #####: 3150:          result = stack_top_p[-1];
    #####: 3151:          stack_top_p[-1] = left_value;
    #####: 3152:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3153:          break;
        -: 3154:        }
        1: 3155:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3156:        {
        1: 3157:          result = stack_top_p[-1];
        1: 3158:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
        1: 3159:          *stack_top_p++ = left_value;
        1: 3160:          left_value = ECMA_VALUE_UNDEFINED;
        1: 3161:          break;
        -: 3162:        }
        4: 3163:        case VM_OC_RETURN_FUNCTION_END:
        -: 3164:        {
        4: 3165:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_SCRIPT)
        -: 3166:          {
    #####: 3167:            result = VM_GET_REGISTER (frame_ctx_p, 0);
    #####: 3168:            VM_GET_REGISTERS (frame_ctx_p)[0] = ECMA_VALUE_UNDEFINED;
        -: 3169:          }
        -: 3170:          else
        -: 3171:          {
        4: 3172:            result = ECMA_VALUE_UNDEFINED;
        -: 3173:          }
        -: 3174:
        4: 3175:          goto error;
        -: 3176:        }
        2: 3177:        case VM_OC_RETURN:
        -: 3178:        {
        2: 3179:          JERRY_ASSERT (opcode == CBC_RETURN || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3180:
        2: 3181:          result = left_value;
        2: 3182:          left_value = ECMA_VALUE_UNDEFINED;
        2: 3183:          goto error;
        -: 3184:        }
    #####: 3185:        case VM_OC_THROW:
        -: 3186:        {
    #####: 3187:          jcontext_raise_exception (left_value);
        -: 3188:
    #####: 3189:          result = ECMA_VALUE_ERROR;
    #####: 3190:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3191:          goto error;
        -: 3192:        }
    #####: 3193:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3194:        {
    #####: 3195:          result = ecma_raise_reference_error (ECMA_ERR_UNDEFINED_REFERENCE);
    #####: 3196:          goto error;
        -: 3197:        }
    #####: 3198:        case VM_OC_EVAL:
        -: 3199:        {
    #####: 3200:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3201:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3202:                        || (*byte_code_p == CBC_EXT_OPCODE && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3203:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3204:          continue;
        -: 3205:        }
       15: 3206:        case VM_OC_CALL:
        -: 3207:        {
       15: 3208:          frame_ctx_p->call_operation = VM_EXEC_CALL;
       15: 3209:          frame_ctx_p->byte_code_p = byte_code_start_p;
       15: 3210:          frame_ctx_p->stack_top_p = stack_top_p;
       15: 3211:          return ECMA_VALUE_UNDEFINED;
        -: 3212:        }
        5: 3213:        case VM_OC_NEW:
        -: 3214:        {
        5: 3215:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
        5: 3216:          frame_ctx_p->byte_code_p = byte_code_start_p;
        5: 3217:          frame_ctx_p->stack_top_p = stack_top_p;
        5: 3218:          return ECMA_VALUE_UNDEFINED;
        -: 3219:        }
        8: 3220:        case VM_OC_ERROR:
        -: 3221:        {
        8: 3222:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3223:#if JERRY_DEBUGGER
        -: 3224:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3225:#endif /* JERRY_DEBUGGER */
        -: 3226:
        8: 3227:          result = ECMA_VALUE_ERROR;
        8: 3228:          goto error;
        -: 3229:        }
    #####: 3230:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3231:        {
    #####: 3232:          ecma_value_t this_value = stack_top_p[-3];
        -: 3233:
    #####: 3234:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3235:          {
        -: 3236:            /* Lexical environment cannot be 'this' value. */
    #####: 3237:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3238:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3239:          }
    #####: 3240:          else if (vm_get_implicit_this_value (&this_value))
        -: 3241:          {
    #####: 3242:            ecma_free_value (stack_top_p[-3]);
    #####: 3243:            stack_top_p[-3] = this_value;
        -: 3244:          }
        -: 3245:
    #####: 3246:          continue;
        -: 3247:        }
    #####: 3248:        case VM_OC_PROP_DELETE:
        -: 3249:        {
    #####: 3250:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3251:
    #####: 3252:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3253:          {
    #####: 3254:            goto error;
        -: 3255:          }
        -: 3256:
    #####: 3257:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3258:
    #####: 3259:          *stack_top_p++ = result;
    #####: 3260:          goto free_both_values;
        -: 3261:        }
    #####: 3262:        case VM_OC_DELETE:
        -: 3263:        {
        -: 3264:          uint16_t literal_index;
        -: 3265:
    #####: 3266:          READ_LITERAL_INDEX (literal_index);
        -: 3267:
    #####: 3268:          if (literal_index < register_end)
        -: 3269:          {
    #####: 3270:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3271:            continue;
        -: 3272:          }
        -: 3273:
    #####: 3274:          result = vm_op_delete_var (literal_start_p[literal_index], frame_ctx_p->lex_env_p);
        -: 3275:
    #####: 3276:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3277:          {
    #####: 3278:            goto error;
        -: 3279:          }
        -: 3280:
    #####: 3281:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3282:
    #####: 3283:          *stack_top_p++ = result;
    #####: 3284:          continue;
        -: 3285:        }
        1: 3286:        case VM_OC_JUMP:
        -: 3287:        {
        1: 3288:          byte_code_p = byte_code_start_p + branch_offset;
        1: 3289:          continue;
        -: 3290:        }
    #####: 3291:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3292:        {
    #####: 3293:          ecma_value_t value = *(--stack_top_p);
        -: 3294:
    #####: 3295:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3296:
    #####: 3297:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3298:          {
    #####: 3299:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3300:            ecma_free_value (*--stack_top_p);
        -: 3301:          }
    #####: 3302:          ecma_free_value (value);
    #####: 3303:          continue;
        -: 3304:        }
    #####: 3305:        case VM_OC_BRANCH_IF_TRUE:
        -: 3306:        case VM_OC_BRANCH_IF_FALSE:
        -: 3307:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3308:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3309:        {
    #####: 3310:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 3311:          ecma_value_t value = *(--stack_top_p);
        -: 3312:
    #####: 3313:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3314:
    #####: 3315:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3316:          {
    #####: 3317:            boolean_value = !boolean_value;
        -: 3318:          }
        -: 3319:
    #####: 3320:          if (boolean_value)
        -: 3321:          {
    #####: 3322:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3323:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3324:            {
        -: 3325:              /* "Push" the value back to the stack. */
    #####: 3326:              ++stack_top_p;
    #####: 3327:              continue;
        -: 3328:            }
        -: 3329:          }
        -: 3330:
    #####: 3331:          ecma_fast_free_value (value);
    #####: 3332:          continue;
        -: 3333:        }
        -: 3334:#if JERRY_ESNEXT
    #####: 3335:        case VM_OC_POP_REFERENCE:
        -: 3336:        {
    #####: 3337:          ecma_free_value (stack_top_p[-2]);
    #####: 3338:          ecma_free_value (stack_top_p[-3]);
    #####: 3339:          stack_top_p[-3] = stack_top_p[-1];
    #####: 3340:          stack_top_p -= 2;
    #####: 3341:          continue;
        -: 3342:        }
    #####: 3343:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3344:        {
    #####: 3345:          left_value = stack_top_p[-1];
        -: 3346:
    #####: 3347:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3348:          {
    #####: 3349:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3350:            continue;
        -: 3351:          }
    #####: 3352:          --stack_top_p;
    #####: 3353:          continue;
        -: 3354:        }
        -: 3355:#endif /* JERRY_ESNEXT */
    #####: 3356:        case VM_OC_PLUS:
        -: 3357:        case VM_OC_MINUS:
        -: 3358:        {
    #####: 3359:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3360:
    #####: 3361:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3362:          {
    #####: 3363:            goto error;
        -: 3364:          }
        -: 3365:
    #####: 3366:          *stack_top_p++ = result;
    #####: 3367:          goto free_left_value;
        -: 3368:        }
    #####: 3369:        case VM_OC_NOT:
        -: 3370:        {
    #####: 3371:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3372:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3373:          goto free_left_value;
        -: 3374:        }
    #####: 3375:        case VM_OC_BIT_NOT:
        -: 3376:        {
        -: 3377:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3378:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3379:
    #####: 3380:          if (ecma_is_value_integer_number (left_value))
        -: 3381:          {
    #####: 3382:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3383:            goto free_left_value;
        -: 3384:          }
        -: 3385:
    #####: 3386:          result = do_number_bitwise_not (left_value);
        -: 3387:
    #####: 3388:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3389:          {
    #####: 3390:            goto error;
        -: 3391:          }
        -: 3392:
    #####: 3393:          *stack_top_p++ = result;
    #####: 3394:          goto free_left_value;
        -: 3395:        }
    #####: 3396:        case VM_OC_VOID:
        -: 3397:        {
    #####: 3398:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3399:          goto free_left_value;
        -: 3400:        }
    #####: 3401:        case VM_OC_TYPEOF_IDENT:
        -: 3402:        {
        -: 3403:          uint16_t literal_index;
        -: 3404:
    #####: 3405:          READ_LITERAL_INDEX (literal_index);
        -: 3406:
    #####: 3407:          JERRY_ASSERT (literal_index < ident_end);
        -: 3408:
    #####: 3409:          if (literal_index < register_end)
        -: 3410:          {
    #####: 3411:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3412:          }
        -: 3413:          else
        -: 3414:          {
    #####: 3415:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3416:
    #####: 3417:            ecma_object_t *ref_base_lex_env_p;
        -: 3418:
    #####: 3419:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 3420:
    #####: 3421:            if (ref_base_lex_env_p == NULL)
        -: 3422:            {
    #####: 3423:              jcontext_release_exception ();
    #####: 3424:              result = ECMA_VALUE_UNDEFINED;
        -: 3425:            }
    #####: 3426:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3427:            {
    #####: 3428:              goto error;
        -: 3429:            }
        -: 3430:
    #####: 3431:            left_value = result;
        -: 3432:          }
        -: 3433:          /* FALLTHRU */
        -: 3434:        }
        -: 3435:        case VM_OC_TYPEOF:
        -: 3436:        {
    #####: 3437:          result = opfunc_typeof (left_value);
        -: 3438:
    #####: 3439:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3440:          {
    #####: 3441:            goto error;
        -: 3442:          }
        -: 3443:
    #####: 3444:          *stack_top_p++ = result;
    #####: 3445:          goto free_left_value;
        -: 3446:        }
    #####: 3447:        case VM_OC_ADD:
        -: 3448:        {
    #####: 3449:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3450:          {
    #####: 3451:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3452:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3453:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3454:            continue;
        -: 3455:          }
        -: 3456:
    #####: 3457:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3458:          {
    #####: 3459:            ecma_number_t new_value =
    #####: 3460:              (ecma_get_float_from_value (left_value) + ecma_get_number_from_value (right_value));
        -: 3461:
    #####: 3462:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3463:            ecma_free_number (right_value);
    #####: 3464:            continue;
        -: 3465:          }
        -: 3466:
    #####: 3467:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3468:          {
    #####: 3469:            ecma_number_t new_value =
    #####: 3470:              ((ecma_number_t) ecma_get_integer_from_value (left_value) + ecma_get_float_from_value (right_value));
        -: 3471:
    #####: 3472:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3473:            continue;
        -: 3474:          }
        -: 3475:
    #####: 3476:          result = opfunc_addition (left_value, right_value);
        -: 3477:
    #####: 3478:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3479:          {
    #####: 3480:            goto error;
        -: 3481:          }
        -: 3482:
    #####: 3483:          *stack_top_p++ = result;
    #####: 3484:          goto free_both_values;
        -: 3485:        }
    #####: 3486:        case VM_OC_SUB:
        -: 3487:        {
        -: 3488:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3489:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3490:
    #####: 3491:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3492:
    #####: 3493:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3494:          {
    #####: 3495:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3496:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3497:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3498:            continue;
        -: 3499:          }
        -: 3500:
    #####: 3501:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3502:          {
    #####: 3503:            ecma_number_t new_value =
    #####: 3504:              (ecma_get_float_from_value (left_value) - ecma_get_number_from_value (right_value));
        -: 3505:
    #####: 3506:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3507:            ecma_free_number (right_value);
    #####: 3508:            continue;
        -: 3509:          }
        -: 3510:
    #####: 3511:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3512:          {
    #####: 3513:            ecma_number_t new_value =
    #####: 3514:              ((ecma_number_t) ecma_get_integer_from_value (left_value) - ecma_get_float_from_value (right_value));
        -: 3515:
    #####: 3516:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3517:            continue;
        -: 3518:          }
        -: 3519:
    #####: 3520:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION, left_value, right_value);
        -: 3521:
    #####: 3522:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3523:          {
    #####: 3524:            goto error;
        -: 3525:          }
        -: 3526:
    #####: 3527:          *stack_top_p++ = result;
    #####: 3528:          goto free_both_values;
        -: 3529:        }
    #####: 3530:        case VM_OC_MUL:
        -: 3531:        {
    #####: 3532:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3533:
        -: 3534:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3535:                                 && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3536:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3537:
    #####: 3538:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3539:          {
    #####: 3540:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3541:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3542:
    #####: 3543:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3544:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3545:                && left_integer != 0 && right_integer != 0)
        -: 3546:            {
    #####: 3547:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3548:              continue;
        -: 3549:            }
        -: 3550:
    #####: 3551:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3552:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3553:            continue;
        -: 3554:          }
        -: 3555:
    #####: 3556:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3557:          {
    #####: 3558:            ecma_number_t new_value =
    #####: 3559:              (ecma_get_float_from_value (left_value) * ecma_get_number_from_value (right_value));
        -: 3560:
    #####: 3561:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3562:            ecma_free_number (right_value);
    #####: 3563:            continue;
        -: 3564:          }
        -: 3565:
    #####: 3566:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3567:          {
    #####: 3568:            ecma_number_t new_value =
    #####: 3569:              ((ecma_number_t) ecma_get_integer_from_value (left_value) * ecma_get_float_from_value (right_value));
        -: 3570:
    #####: 3571:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3572:            continue;
        -: 3573:          }
        -: 3574:
    #####: 3575:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION, left_value, right_value);
        -: 3576:
    #####: 3577:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3578:          {
    #####: 3579:            goto error;
        -: 3580:          }
        -: 3581:
    #####: 3582:          *stack_top_p++ = result;
    #####: 3583:          goto free_both_values;
        -: 3584:        }
    #####: 3585:        case VM_OC_DIV:
        -: 3586:        {
    #####: 3587:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3588:
    #####: 3589:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION, left_value, right_value);
        -: 3590:
    #####: 3591:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3592:          {
    #####: 3593:            goto error;
        -: 3594:          }
        -: 3595:
    #####: 3596:          *stack_top_p++ = result;
    #####: 3597:          goto free_both_values;
        -: 3598:        }
    #####: 3599:        case VM_OC_MOD:
        -: 3600:        {
    #####: 3601:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3602:
    #####: 3603:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3604:          {
    #####: 3605:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3606:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3607:
    #####: 3608:            if (right_integer != 0)
        -: 3609:            {
    #####: 3610:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3611:
    #####: 3612:              if (mod_result != 0 || left_integer >= 0)
        -: 3613:              {
    #####: 3614:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3615:                continue;
        -: 3616:              }
        -: 3617:            }
        -: 3618:          }
        -: 3619:
    #####: 3620:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER, left_value, right_value);
        -: 3621:
    #####: 3622:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3623:          {
    #####: 3624:            goto error;
        -: 3625:          }
        -: 3626:
    #####: 3627:          *stack_top_p++ = result;
    #####: 3628:          goto free_both_values;
        -: 3629:        }
        -: 3630:#if JERRY_ESNEXT
    #####: 3631:        case VM_OC_EXP:
        -: 3632:        {
    #####: 3633:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION, left_value, right_value);
        -: 3634:
    #####: 3635:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3636:          {
    #####: 3637:            goto error;
        -: 3638:          }
        -: 3639:
    #####: 3640:          *stack_top_p++ = result;
    #####: 3641:          goto free_both_values;
        -: 3642:        }
        -: 3643:#endif /* JERRY_ESNEXT */
    #####: 3644:        case VM_OC_EQUAL:
        -: 3645:        {
    #####: 3646:          result = opfunc_equality (left_value, right_value);
        -: 3647:
    #####: 3648:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3649:          {
    #####: 3650:            goto error;
        -: 3651:          }
        -: 3652:
    #####: 3653:          *stack_top_p++ = result;
    #####: 3654:          goto free_both_values;
        -: 3655:        }
    #####: 3656:        case VM_OC_NOT_EQUAL:
        -: 3657:        {
    #####: 3658:          result = opfunc_equality (left_value, right_value);
        -: 3659:
    #####: 3660:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3661:          {
    #####: 3662:            goto error;
        -: 3663:          }
        -: 3664:
    #####: 3665:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3666:          goto free_both_values;
        -: 3667:        }
    #####: 3668:        case VM_OC_STRICT_EQUAL:
        -: 3669:        {
    #####: 3670:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3671:
    #####: 3672:          result = ecma_make_boolean_value (is_equal);
        -: 3673:
    #####: 3674:          *stack_top_p++ = result;
    #####: 3675:          goto free_both_values;
        -: 3676:        }
    #####: 3677:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3678:        {
    #####: 3679:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3680:
    #####: 3681:          result = ecma_make_boolean_value (!is_equal);
        -: 3682:
    #####: 3683:          *stack_top_p++ = result;
    #####: 3684:          goto free_both_values;
        -: 3685:        }
    #####: 3686:        case VM_OC_BIT_OR:
        -: 3687:        {
        -: 3688:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3689:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3690:
    #####: 3691:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3692:          {
    #####: 3693:            *stack_top_p++ = left_value | right_value;
    #####: 3694:            continue;
        -: 3695:          }
        -: 3696:
    #####: 3697:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR, left_value, right_value);
        -: 3698:
    #####: 3699:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3700:          {
    #####: 3701:            goto error;
        -: 3702:          }
        -: 3703:
    #####: 3704:          *stack_top_p++ = result;
    #####: 3705:          goto free_both_values;
        -: 3706:        }
    #####: 3707:        case VM_OC_BIT_XOR:
        -: 3708:        {
        -: 3709:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3710:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3711:
    #####: 3712:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3713:          {
    #####: 3714:            *stack_top_p++ = left_value ^ right_value;
    #####: 3715:            continue;
        -: 3716:          }
        -: 3717:
    #####: 3718:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR, left_value, right_value);
        -: 3719:
    #####: 3720:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3721:          {
    #####: 3722:            goto error;
        -: 3723:          }
        -: 3724:
    #####: 3725:          *stack_top_p++ = result;
    #####: 3726:          goto free_both_values;
        -: 3727:        }
    #####: 3728:        case VM_OC_BIT_AND:
        -: 3729:        {
        -: 3730:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3731:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3732:
    #####: 3733:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3734:          {
    #####: 3735:            *stack_top_p++ = left_value & right_value;
    #####: 3736:            continue;
        -: 3737:          }
        -: 3738:
    #####: 3739:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND, left_value, right_value);
        -: 3740:
    #####: 3741:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3742:          {
    #####: 3743:            goto error;
        -: 3744:          }
        -: 3745:
    #####: 3746:          *stack_top_p++ = result;
    #####: 3747:          goto free_both_values;
        -: 3748:        }
    #####: 3749:        case VM_OC_LEFT_SHIFT:
        -: 3750:        {
        -: 3751:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3752:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3753:
    #####: 3754:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3755:          {
    #####: 3756:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3757:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3758:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 3759:            continue;
        -: 3760:          }
        -: 3761:
    #####: 3762:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT, left_value, right_value);
        -: 3763:
    #####: 3764:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3765:          {
    #####: 3766:            goto error;
        -: 3767:          }
        -: 3768:
    #####: 3769:          *stack_top_p++ = result;
    #####: 3770:          goto free_both_values;
        -: 3771:        }
    #####: 3772:        case VM_OC_RIGHT_SHIFT:
        -: 3773:        {
        -: 3774:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3775:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3776:
    #####: 3777:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3778:          {
    #####: 3779:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3780:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3781:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3782:            continue;
        -: 3783:          }
        -: 3784:
    #####: 3785:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT, left_value, right_value);
        -: 3786:
    #####: 3787:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3788:          {
    #####: 3789:            goto error;
        -: 3790:          }
        -: 3791:
    #####: 3792:          *stack_top_p++ = result;
    #####: 3793:          goto free_both_values;
        -: 3794:        }
    #####: 3795:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3796:        {
        -: 3797:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3798:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3799:
    #####: 3800:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3801:          {
    #####: 3802:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3803:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3804:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3805:            continue;
        -: 3806:          }
        -: 3807:
    #####: 3808:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT, left_value, right_value);
        -: 3809:
    #####: 3810:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3811:          {
    #####: 3812:            goto error;
        -: 3813:          }
        -: 3814:
    #####: 3815:          *stack_top_p++ = result;
    #####: 3816:          goto free_both_values;
        -: 3817:        }
        1: 3818:        case VM_OC_LESS:
        -: 3819:        {
        1: 3820:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3821:          {
        1: 3822:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3823:#if !JERRY_VM_HALT
        -: 3824:            /* This is a lookahead to the next opcode to improve performance.
        -: 3825:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
        1: 3826:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3827:            {
        1: 3828:              byte_code_start_p = byte_code_p++;
        1: 3829:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
        1: 3830:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3831:
        1: 3832:              if (is_less)
        -: 3833:              {
        1: 3834:                branch_offset = *(byte_code_p++);
        -: 3835:
        1: 3836:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3837:                {
    #####: 3838:                  branch_offset <<= 8;
    #####: 3839:                  branch_offset |= *(byte_code_p++);
    #####: 3840:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3841:                  {
    #####: 3842:                    branch_offset <<= 8;
    #####: 3843:                    branch_offset |= *(byte_code_p++);
        -: 3844:                  }
        -: 3845:                }
        -: 3846:
        -: 3847:                /* Note: The opcode is a backward branch. */
        1: 3848:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3849:              }
        -: 3850:              else
        -: 3851:              {
    #####: 3852:                byte_code_p += branch_offset_length;
        -: 3853:              }
        -: 3854:
        1: 3855:              continue;
        -: 3856:            }
        -: 3857:#endif /* !JERRY_VM_HALT */
    #####: 3858:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3859:            continue;
        -: 3860:          }
        -: 3861:
    #####: 3862:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3863:          {
    #####: 3864:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3865:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3866:
    #####: 3867:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3868:            goto free_both_values;
        -: 3869:          }
        -: 3870:
    #####: 3871:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3872:
    #####: 3873:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3874:          {
    #####: 3875:            goto error;
        -: 3876:          }
        -: 3877:
    #####: 3878:          *stack_top_p++ = result;
    #####: 3879:          goto free_both_values;
        -: 3880:        }
    #####: 3881:        case VM_OC_GREATER:
        -: 3882:        {
    #####: 3883:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3884:          {
    #####: 3885:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3886:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3887:
    #####: 3888:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3889:            continue;
        -: 3890:          }
        -: 3891:
    #####: 3892:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3893:          {
    #####: 3894:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3895:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3896:
    #####: 3897:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3898:            goto free_both_values;
        -: 3899:          }
        -: 3900:
    #####: 3901:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3902:
    #####: 3903:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3904:          {
    #####: 3905:            goto error;
        -: 3906:          }
        -: 3907:
    #####: 3908:          *stack_top_p++ = result;
    #####: 3909:          goto free_both_values;
        -: 3910:        }
    #####: 3911:        case VM_OC_LESS_EQUAL:
        -: 3912:        {
    #####: 3913:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3914:          {
    #####: 3915:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3916:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3917:
    #####: 3918:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3919:            continue;
        -: 3920:          }
        -: 3921:
    #####: 3922:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3923:          {
    #####: 3924:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3925:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3926:
    #####: 3927:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3928:            goto free_both_values;
        -: 3929:          }
        -: 3930:
    #####: 3931:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3932:
    #####: 3933:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3934:          {
    #####: 3935:            goto error;
        -: 3936:          }
        -: 3937:
    #####: 3938:          *stack_top_p++ = result;
    #####: 3939:          goto free_both_values;
        -: 3940:        }
    #####: 3941:        case VM_OC_GREATER_EQUAL:
        -: 3942:        {
    #####: 3943:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3944:          {
    #####: 3945:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3946:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3947:
    #####: 3948:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3949:            continue;
        -: 3950:          }
        -: 3951:
    #####: 3952:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3953:          {
    #####: 3954:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3955:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3956:
    #####: 3957:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3958:            goto free_both_values;
        -: 3959:          }
        -: 3960:
    #####: 3961:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3962:
    #####: 3963:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3964:          {
    #####: 3965:            goto error;
        -: 3966:          }
        -: 3967:
    #####: 3968:          *stack_top_p++ = result;
    #####: 3969:          goto free_both_values;
        -: 3970:        }
    #####: 3971:        case VM_OC_IN:
        -: 3972:        {
    #####: 3973:          result = opfunc_in (left_value, right_value);
        -: 3974:
    #####: 3975:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3976:          {
    #####: 3977:            goto error;
        -: 3978:          }
        -: 3979:
    #####: 3980:          *stack_top_p++ = result;
    #####: 3981:          goto free_both_values;
        -: 3982:        }
    #####: 3983:        case VM_OC_INSTANCEOF:
        -: 3984:        {
    #####: 3985:          result = opfunc_instanceof (left_value, right_value);
        -: 3986:
    #####: 3987:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3988:          {
    #####: 3989:            goto error;
        -: 3990:          }
        -: 3991:
    #####: 3992:          *stack_top_p++ = result;
    #####: 3993:          goto free_both_values;
        -: 3994:        }
    #####: 3995:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3996:        {
        -: 3997:#if JERRY_ESNEXT
        -: 3998:          ecma_value_t *stack_context_top_p;
    #####: 3999:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4000:
    #####: 4001:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 4002:
    #####: 4003:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 4004:          {
    #####: 4005:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4006:
    #####: 4007:            if (stack_context_top_p != stack_top_p)
        -: 4008:            {
        -: 4009:              /* Preserve the value of switch statement. */
    #####: 4010:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 4011:            }
        -: 4012:
    #####: 4013:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 4014:
    #####: 4015:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 4016:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 4017:          }
        -: 4018:          else
        -: 4019:          {
    #####: 4020:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 4021:
    #####: 4022:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4023:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4024:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4025:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4026:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4027:
    #####: 4028:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4029:
    #####: 4030:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4031:          }
        -: 4032:#else /* !JERRY_ESNEXT */
        -: 4033:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4034:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4035:
    #####: 4036:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4037:#endif /* JERRY_ESNEXT */
        -: 4038:
    #####: 4039:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4040:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4041:
    #####: 4042:          continue;
        -: 4043:        }
    #####: 4044:        case VM_OC_WITH:
        -: 4045:        {
    #####: 4046:          ecma_value_t value = *(--stack_top_p);
        -: 4047:          ecma_object_t *object_p;
        -: 4048:          ecma_object_t *with_env_p;
        -: 4049:
    #####: 4050:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4051:
    #####: 4052:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4053:
    #####: 4054:          result = ecma_op_to_object (value);
    #####: 4055:          ecma_free_value (value);
        -: 4056:
    #####: 4057:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4058:          {
    #####: 4059:            goto error;
        -: 4060:          }
        -: 4061:
    #####: 4062:          object_p = ecma_get_object_from_value (result);
        -: 4063:
    #####: 4064:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4065:          ecma_deref_object (object_p);
        -: 4066:
    #####: 4067:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4068:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4069:
    #####: 4070:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4071:
    #####: 4072:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4073:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4074:          continue;
        -: 4075:        }
    #####: 4076:        case VM_OC_FOR_IN_INIT:
        -: 4077:        {
    #####: 4078:          ecma_value_t value = *(--stack_top_p);
        -: 4079:
    #####: 4080:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4081:
    #####: 4082:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 4083:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 4084:          ecma_free_value (value);
        -: 4085:
    #####: 4086:          if (prop_names_p == NULL)
        -: 4087:          {
        -: 4088:#if JERRY_ESNEXT
    #####: 4089:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4090:            {
    #####: 4091:              result = expr_obj_value;
    #####: 4092:              goto error;
        -: 4093:            }
        -: 4094:#endif /* JERRY_ESNEXT */
        -: 4095:
        -: 4096:            /* The collection is already released */
    #####: 4097:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4098:            continue;
        -: 4099:          }
        -: 4100:
    #####: 4101:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4102:
    #####: 4103:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4104:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 4105:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 4106:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 4107:          stack_top_p[-3] = 0;
    #####: 4108:          stack_top_p[-4] = expr_obj_value;
        -: 4109:
        -: 4110:#if JERRY_ESNEXT
    #####: 4111:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4112:          {
        -: 4113:            /* No need to duplicate the first context. */
    #####: 4114:            byte_code_p += 2;
        -: 4115:          }
        -: 4116:#endif /* JERRY_ESNEXT */
    #####: 4117:          continue;
        -: 4118:        }
    #####: 4119:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4120:        {
    #####: 4121:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4122:
        -: 4123:          ecma_collection_t *collection_p;
    #####: 4124:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4125:
    #####: 4126:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4127:
    #####: 4128:          uint32_t index = context_top_p[-3];
    #####: 4129:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4130:
    #####: 4131:          *stack_top_p++ = buffer_p[index];
    #####: 4132:          context_top_p[-3]++;
    #####: 4133:          continue;
        -: 4134:        }
    #####: 4135:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4136:        {
    #####: 4137:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4138:
        -: 4139:          ecma_collection_t *collection_p;
    #####: 4140:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4141:
    #####: 4142:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4143:
    #####: 4144:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 4145:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 4146:          uint32_t index = stack_top_p[-3];
        -: 4147:
    #####: 4148:          while (index < collection_p->item_count)
        -: 4149:          {
    #####: 4150:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4151:
    #####: 4152:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4153:
    #####: 4154:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4155:            {
    #####: 4156:              stack_top_p[-3] = index;
    #####: 4157:              goto error;
        -: 4158:            }
        -: 4159:
    #####: 4160:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4161:            {
    #####: 4162:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4163:              break;
        -: 4164:            }
        -: 4165:
    #####: 4166:            ecma_deref_ecma_string (prop_name_p);
    #####: 4167:            index++;
        -: 4168:          }
        -: 4169:
    #####: 4170:          if (index == collection_p->item_count)
        -: 4171:          {
    #####: 4172:            ecma_deref_object (object_p);
    #####: 4173:            ecma_collection_destroy (collection_p);
    #####: 4174:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4175:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4176:          }
        -: 4177:          else
        -: 4178:          {
    #####: 4179:            stack_top_p[-3] = index;
        -: 4180:          }
    #####: 4181:          continue;
        -: 4182:        }
        -: 4183:#if JERRY_ESNEXT
    #####: 4184:        case VM_OC_FOR_OF_INIT:
        -: 4185:        {
    #####: 4186:          ecma_value_t value = *(--stack_top_p);
        -: 4187:
    #####: 4188:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4189:
    #####: 4190:          ecma_value_t next_method;
    #####: 4191:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4192:
    #####: 4193:          ecma_free_value (value);
        -: 4194:
    #####: 4195:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4196:          {
    #####: 4197:            result = iterator;
    #####: 4198:            goto error;
        -: 4199:          }
        -: 4200:
    #####: 4201:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4202:
    #####: 4203:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4204:          {
    #####: 4205:            ecma_free_value (iterator);
    #####: 4206:            ecma_free_value (next_method);
    #####: 4207:            goto error;
        -: 4208:          }
        -: 4209:
    #####: 4210:          if (ecma_is_value_false (result))
        -: 4211:          {
    #####: 4212:            ecma_free_value (iterator);
    #####: 4213:            ecma_free_value (next_method);
    #####: 4214:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4215:            continue;
        -: 4216:          }
        -: 4217:
    #####: 4218:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4219:          ecma_free_value (result);
        -: 4220:
    #####: 4221:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4222:          {
    #####: 4223:            result = next_value;
    #####: 4224:            ecma_free_value (iterator);
    #####: 4225:            ecma_free_value (next_method);
    #####: 4226:            goto error;
        -: 4227:          }
        -: 4228:
    #####: 4229:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4230:
    #####: 4231:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4232:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4233:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4234:          stack_top_p[-2] = next_value;
    #####: 4235:          stack_top_p[-3] = iterator;
    #####: 4236:          stack_top_p[-4] = next_method;
        -: 4237:
    #####: 4238:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4239:          {
        -: 4240:            /* No need to duplicate the first context. */
    #####: 4241:            byte_code_p += 2;
        -: 4242:          }
    #####: 4243:          continue;
        -: 4244:        }
    #####: 4245:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4246:        {
    #####: 4247:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4248:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4249:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4250:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4251:
    #####: 4252:          *stack_top_p++ = context_top_p[-2];
    #####: 4253:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4254:          continue;
        -: 4255:        }
    #####: 4256:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4257:        {
    #####: 4258:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4259:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4260:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4261:
    #####: 4262:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4263:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4264:
    #####: 4265:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4266:          {
    #####: 4267:            goto error;
        -: 4268:          }
        -: 4269:
    #####: 4270:          if (ecma_is_value_false (result))
        -: 4271:          {
    #####: 4272:            ecma_free_value (stack_top_p[-2]);
    #####: 4273:            ecma_free_value (stack_top_p[-3]);
    #####: 4274:            ecma_free_value (stack_top_p[-4]);
    #####: 4275:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4276:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4277:            continue;
        -: 4278:          }
        -: 4279:
    #####: 4280:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4281:          ecma_free_value (result);
        -: 4282:
    #####: 4283:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4284:          {
    #####: 4285:            result = next_value;
    #####: 4286:            goto error;
        -: 4287:          }
        -: 4288:
    #####: 4289:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4290:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4291:          stack_top_p[-2] = next_value;
    #####: 4292:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4293:          continue;
        -: 4294:        }
    #####: 4295:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4296:        {
    #####: 4297:          ecma_value_t value = *(--stack_top_p);
        -: 4298:
    #####: 4299:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4300:
    #####: 4301:          ecma_value_t next_method;
    #####: 4302:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4303:
    #####: 4304:          ecma_free_value (value);
        -: 4305:
    #####: 4306:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4307:          {
    #####: 4308:            goto error;
        -: 4309:          }
        -: 4310:
    #####: 4311:          ecma_value_t iterator = result;
    #####: 4312:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4313:
    #####: 4314:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4315:          {
    #####: 4316:            ecma_free_value (iterator);
    #####: 4317:            ecma_free_value (next_method);
    #####: 4318:            goto error;
        -: 4319:          }
        -: 4320:
    #####: 4321:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4322:
    #####: 4323:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4324:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4325:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4326:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4327:          stack_top_p[-3] = iterator;
    #####: 4328:          stack_top_p[-4] = next_method;
        -: 4329:
    #####: 4330:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4331:          {
        -: 4332:            /* No need to duplicate the first context. */
    #####: 4333:            byte_code_p += 2;
        -: 4334:          }
        -: 4335:
    #####: 4336:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4337:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4338:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4339:
    #####: 4340:          uint16_t extra_flags =
        -: 4341:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4342:
    #####: 4343:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4344:              || (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 4345:          {
    #####: 4346:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4347:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4348:
    #####: 4349:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4350:            {
    #####: 4351:              goto error;
        -: 4352:            }
        -: 4353:
    #####: 4354:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4355:            return ECMA_VALUE_UNDEFINED;
        -: 4356:          }
        -: 4357:
    #####: 4358:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4359:
    #####: 4360:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4361:          {
    #####: 4362:            goto error;
        -: 4363:          }
    #####: 4364:          return result;
        -: 4365:        }
    #####: 4366:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4367:        {
    #####: 4368:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4369:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4370:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4371:
    #####: 4372:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4373:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4374:
    #####: 4375:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4376:          {
    #####: 4377:            goto error;
        -: 4378:          }
        -: 4379:
    #####: 4380:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4381:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4382:
    #####: 4383:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4384:          {
    #####: 4385:            goto error;
        -: 4386:          }
        -: 4387:
    #####: 4388:          uint16_t extra_flags =
        -: 4389:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4390:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4391:
    #####: 4392:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4393:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4394:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4395:          return ECMA_VALUE_UNDEFINED;
        -: 4396:        }
        -: 4397:#endif /* JERRY_ESNEXT */
        5: 4398:        case VM_OC_TRY:
        -: 4399:        {
        -: 4400:          /* Try opcode simply creates the try context. */
        5: 4401:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4402:
        5: 4403:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4404:
        5: 4405:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        5: 4406:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4407:
        5: 4408:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
        5: 4409:          continue;
        -: 4410:        }
    #####: 4411:        case VM_OC_CATCH:
        -: 4412:        {
        -: 4413:          /* Catches are ignored and turned to jumps. */
    #####: 4414:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4415:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4416:
    #####: 4417:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4418:          continue;
        -: 4419:        }
    #####: 4420:        case VM_OC_FINALLY:
        -: 4421:        {
    #####: 4422:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4423:
    #####: 4424:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4425:
    #####: 4426:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4427:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4428:
    #####: 4429:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4430:          {
    #####: 4431:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4432:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4433:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4434:            ecma_deref_object (lex_env_p);
        -: 4435:          }
        -: 4436:
    #####: 4437:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4438:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4439:
    #####: 4440:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4441:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4442:          continue;
        -: 4443:        }
        4: 4444:        case VM_OC_CONTEXT_END:
        -: 4445:        {
        4: 4446:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        4: 4447:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4448:
        4: 4449:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4450:
        4: 4451:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4452:          {
        4: 4453:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4454:
        4: 4455:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        4: 4456:            continue;
        -: 4457:          }
        -: 4458:
        -: 4459:#if JERRY_ESNEXT
    #####: 4460:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4461:          {
    #####: 4462:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4463:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4464:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4465:            ecma_deref_object (lex_env_p);
        -: 4466:          }
        -: 4467:#endif /* JERRY_ESNEXT */
        -: 4468:
    #####: 4469:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4470:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4471:
    #####: 4472:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4473:          {
    #####: 4474:            result = *stack_top_p;
    #####: 4475:            goto error;
        -: 4476:          }
        -: 4477:
    #####: 4478:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4479:          {
    #####: 4480:            jcontext_raise_exception (*stack_top_p);
        -: 4481:#if JERRY_VM_THROW
    #####: 4482:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4483:#endif /* JERRY_VM_THROW */
    #####: 4484:            result = ECMA_VALUE_ERROR;
        -: 4485:
        -: 4486:#if JERRY_DEBUGGER
        -: 4487:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4488:#endif /* JERRY_DEBUGGER */
    #####: 4489:            goto error;
        -: 4490:          }
        -: 4491:
    #####: 4492:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4493:
    #####: 4494:          uint32_t jump_target = *stack_top_p;
        -: 4495:
    #####: 4496:          vm_stack_found_type type =
    #####: 4497:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, jump_target);
    #####: 4498:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4499:          switch (type)
        -: 4500:          {
    #####: 4501:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4502:            {
    #####: 4503:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4504:
    #####: 4505:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4506:              stack_top_p[-2] = jump_target;
    #####: 4507:              break;
        -: 4508:            }
        -: 4509:#if JERRY_ESNEXT
    #####: 4510:            case VM_CONTEXT_FOUND_ERROR:
        -: 4511:            {
    #####: 4512:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4513:              result = ECMA_VALUE_ERROR;
    #####: 4514:              goto error;
        -: 4515:            }
    #####: 4516:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4517:            {
    #####: 4518:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4519:              stack_top_p[-2] = jump_target;
    #####: 4520:              return ECMA_VALUE_UNDEFINED;
        -: 4521:            }
        -: 4522:#endif /* JERRY_ESNEXT */
    #####: 4523:            default:
        -: 4524:            {
    #####: 4525:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4526:              break;
        -: 4527:            }
        -: 4528:          }
        -: 4529:
    #####: 4530:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4531:          continue;
        -: 4532:        }
    #####: 4533:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4534:        {
    #####: 4535:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4536:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4537:
    #####: 4538:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4539:
    #####: 4540:          vm_stack_found_type type =
    #####: 4541:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, (uint32_t) branch_offset);
    #####: 4542:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4543:          switch (type)
        -: 4544:          {
    #####: 4545:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4546:            {
    #####: 4547:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4548:
    #####: 4549:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4550:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4551:              break;
        -: 4552:            }
        -: 4553:#if JERRY_ESNEXT
    #####: 4554:            case VM_CONTEXT_FOUND_ERROR:
        -: 4555:            {
    #####: 4556:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4557:              result = ECMA_VALUE_ERROR;
    #####: 4558:              goto error;
        -: 4559:            }
    #####: 4560:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4561:            {
    #####: 4562:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4563:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4564:              return ECMA_VALUE_UNDEFINED;
        -: 4565:            }
        -: 4566:#endif /* JERRY_ESNEXT */
    #####: 4567:            default:
        -: 4568:            {
    #####: 4569:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4570:              break;
        -: 4571:            }
        -: 4572:          }
        -: 4573:
    #####: 4574:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4575:          continue;
        -: 4576:        }
        -: 4577:#if JERRY_MODULE_SYSTEM
    #####: 4578:        case VM_OC_MODULE_IMPORT:
        -: 4579:        {
    #####: 4580:          left_value = *(--stack_top_p);
        -: 4581:
    #####: 4582:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4583:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4584:
        -: 4585:#if JERRY_SNAPSHOT_EXEC
    #####: 4586:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4587:          {
        -: 4588:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4589:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4590:
    #####: 4591:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4592:            {
    #####: 4593:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4594:            }
        -: 4595:#if JERRY_SNAPSHOT_EXEC
        -: 4596:          }
        -: 4597:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4598:
    #####: 4599:          result = ecma_module_import (left_value, user_value);
    #####: 4600:          ecma_free_value (left_value);
        -: 4601:
    #####: 4602:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4603:          {
    #####: 4604:            goto error;
        -: 4605:          }
        -: 4606:
    #####: 4607:          *stack_top_p++ = result;
    #####: 4608:          continue;
        -: 4609:        }
    #####: 4610:        case VM_OC_MODULE_IMPORT_META:
        -: 4611:        {
    #####: 4612:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4613:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4614:
    #####: 4615:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4616:
    #####: 4617:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4618:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4619:
    #####: 4620:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4621:          {
    #####: 4622:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4623:
    #####: 4624:            ecma_value_t module = import_meta;
    #####: 4625:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4626:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4627:
    #####: 4628:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4629:            {
    #####: 4630:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4631:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4632:            }
        -: 4633:
    #####: 4634:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4635:          }
        -: 4636:          else
        -: 4637:          {
    #####: 4638:            ecma_ref_object (import_meta_object_p);
        -: 4639:          }
        -: 4640:
    #####: 4641:          *stack_top_p++ = import_meta;
    #####: 4642:          continue;
        -: 4643:        }
        -: 4644:#endif /* JERRY_MODULE_SYSTEM */
        -: 4645:#if JERRY_DEBUGGER
        -: 4646:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4647:        {
        -: 4648:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4649:          {
        -: 4650:            continue;
        -: 4651:          }
        -: 4652:
        -: 4653:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4654:
        -: 4655:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4656:
        -: 4657:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4658:
        -: 4659:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4660:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4661:          {
        -: 4662:            result = ECMA_VALUE_ERROR;
        -: 4663:            goto error;
        -: 4664:          }
        -: 4665:          continue;
        -: 4666:        }
        -: 4667:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4668:        {
        -: 4669:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4670:          {
        -: 4671:            continue;
        -: 4672:          }
        -: 4673:
        -: 4674:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4675:
        -: 4676:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4677:
        -: 4678:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4679:
        -: 4680:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4681:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4682:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4683:          {
        -: 4684:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4685:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4686:            {
        -: 4687:              result = ECMA_VALUE_ERROR;
        -: 4688:              goto error;
        -: 4689:            }
        -: 4690:            continue;
        -: 4691:          }
        -: 4692:
        -: 4693:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4694:          {
        -: 4695:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4696:            continue;
        -: 4697:          }
        -: 4698:
        -: 4699:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4700:
        -: 4701:          if (jerry_debugger_receive (NULL))
        -: 4702:          {
        -: 4703:            continue;
        -: 4704:          }
        -: 4705:
        -: 4706:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4707:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4708:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4709:          {
        -: 4710:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4711:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4712:            {
        -: 4713:              result = ECMA_VALUE_ERROR;
        -: 4714:              goto error;
        -: 4715:            }
        -: 4716:          }
        -: 4717:          continue;
        -: 4718:        }
        -: 4719:#endif /* JERRY_DEBUGGER */
    #####: 4720:        case VM_OC_NONE:
        -: 4721:        default:
        -: 4722:        {
    #####: 4723:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4724:
    #####: 4725:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4726:        }
        -: 4727:      }
        -: 4728:
        1: 4729:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4730:
        1: 4731:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4732:      {
        -: 4733:        uint16_t literal_index;
        -: 4734:
    #####: 4735:        READ_LITERAL_INDEX (literal_index);
        -: 4736:
    #####: 4737:        if (literal_index < register_end)
        -: 4738:        {
    #####: 4739:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4740:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4741:
    #####: 4742:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4743:          {
    #####: 4744:            result = ecma_fast_copy_value (result);
        -: 4745:          }
        -: 4746:        }
        -: 4747:        else
        -: 4748:        {
    #####: 4749:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4750:
    #####: 4751:          ecma_value_t put_value_result =
    #####: 4752:            ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p, var_name_str_p, is_strict, result);
        -: 4753:
    #####: 4754:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4755:          {
    #####: 4756:            ecma_free_value (result);
    #####: 4757:            result = put_value_result;
    #####: 4758:            goto error;
        -: 4759:          }
        -: 4760:
    #####: 4761:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4762:          {
    #####: 4763:            ecma_fast_free_value (result);
        -: 4764:          }
        -: 4765:        }
        -: 4766:      }
        1: 4767:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4768:      {
        1: 4769:        ecma_value_t property = *(--stack_top_p);
        1: 4770:        ecma_value_t base = *(--stack_top_p);
        -: 4771:
        1: 4772:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4773:        {
    #####: 4774:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 4775:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 4776:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4777:
    #####: 4778:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4779:          {
    #####: 4780:            goto free_both_values;
        -: 4781:          }
    #####: 4782:          result = ecma_fast_copy_value (result);
        -: 4783:        }
        -: 4784:        else
        -: 4785:        {
        1: 4786:          ecma_value_t set_value_result = vm_op_set_value (base, property, result, is_strict);
        -: 4787:
    #####: 4788:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4789:          {
    #####: 4790:            ecma_free_value (result);
    #####: 4791:            result = set_value_result;
    #####: 4792:            goto error;
        -: 4793:          }
        -: 4794:
    #####: 4795:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4796:          {
    #####: 4797:            ecma_fast_free_value (result);
    #####: 4798:            goto free_both_values;
        -: 4799:          }
        -: 4800:        }
        -: 4801:      }
        -: 4802:
    #####: 4803:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4804:      {
    #####: 4805:        *stack_top_p++ = result;
        -: 4806:      }
    #####: 4807:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4808:      {
    #####: 4809:        ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 4810:        VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 4811:      }
        -: 4812:
        2: 4813:free_both_values:
        2: 4814:      ecma_fast_free_value (right_value);
        3: 4815:free_left_value:
        3: 4816:      ecma_fast_free_value (left_value);
        -: 4817:    }
        -: 4818:
       18: 4819:error:
       18: 4820:    ecma_fast_free_value (left_value);
       18: 4821:    ecma_fast_free_value (right_value);
        -: 4822:
       18: 4823:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4824:    {
       12: 4825:      JERRY_ASSERT (jcontext_has_pending_exception ());
       12: 4826:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4827:
       32: 4828:      while (stack_top_p > stack_bottom_p)
        -: 4829:      {
        8: 4830:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4831:#if JERRY_ESNEXT
        8: 4832:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4833:        {
    #####: 4834:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4835:          continue;
        -: 4836:        }
        -: 4837:#endif /* JERRY_ESNEXT */
        8: 4838:        ecma_fast_free_value (stack_item);
        -: 4839:      }
        -: 4840:
        -: 4841:#if JERRY_VM_THROW
    #####: 4842:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4843:      {
    #####: 4844:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4845:
    #####: 4846:        jerry_throw_cb_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4847:
    #####: 4848:        if (vm_throw_callback_p != NULL)
        -: 4849:        {
    #####: 4850:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4851:        }
        -: 4852:      }
        -: 4853:#endif /* JERRY_VM_THROW */
        -: 4854:
        -: 4855:#if JERRY_DEBUGGER
        -: 4856:      const uint32_t dont_stop =
        -: 4857:        (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION | JERRY_DEBUGGER_VM_IGNORE | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4858:
        -: 4859:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4860:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4861:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4862:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4863:      {
        -: 4864:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4865:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4866:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4867:
        -: 4868:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4869:        {
        -: 4870:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4871:
        -: 4872:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4873:          {
        -: 4874:            ecma_free_value (current_error_value);
        -: 4875:          }
        -: 4876:          else
        -: 4877:          {
        -: 4878:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4879:          }
        -: 4880:
        -: 4881:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4882:        }
        -: 4883:      }
        -: 4884:#endif /* JERRY_DEBUGGER */
        -: 4885:    }
        -: 4886:
       18: 4887:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4888:
       18: 4889:    if (frame_ctx_p->context_depth == 0)
        -: 4890:    {
        -: 4891:      /* In most cases there is no context. */
       14: 4892:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
       14: 4893:      return result;
        -: 4894:    }
        -: 4895:
        4: 4896:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4897:    {
    #####: 4898:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_RETURN, 0))
        -: 4899:      {
    #####: 4900:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4901:        {
    #####: 4902:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4903:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4904:
    #####: 4905:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4906:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4907:          stack_top_p[-2] = result;
    #####: 4908:          continue;
        -: 4909:        }
        -: 4910:#if JERRY_ESNEXT
    #####: 4911:        case VM_CONTEXT_FOUND_ERROR:
        -: 4912:        {
    #####: 4913:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4914:
    #####: 4915:          ecma_free_value (result);
    #####: 4916:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4917:          result = ECMA_VALUE_ERROR;
    #####: 4918:          break;
        -: 4919:        }
    #####: 4920:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4921:        {
    #####: 4922:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4923:
    #####: 4924:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4925:          stack_top_p[-2] = result;
    #####: 4926:          return ECMA_VALUE_UNDEFINED;
        -: 4927:        }
        -: 4928:#endif /* JERRY_ESNEXT */
    #####: 4929:        default:
        -: 4930:        {
    #####: 4931:          goto finish;
        -: 4932:        }
        -: 4933:      }
        4: 4934:    }
        -: 4935:
        4: 4936:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4937:
        4: 4938:    if (!jcontext_has_pending_abort ())
        -: 4939:    {
        4: 4940:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_THROW, 0))
        -: 4941:      {
        4: 4942:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4943:        {
        4: 4944:          stack_top_p = frame_ctx_p->stack_top_p;
        4: 4945:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4946:
        4: 4947:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        4: 4948:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4949:
        -: 4950:#if JERRY_DEBUGGER
        -: 4951:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4952:#endif /* JERRY_DEBUGGER */
        -: 4953:
        4: 4954:          result = jcontext_take_exception ();
        -: 4955:
        4: 4956:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4957:          {
    #####: 4958:            stack_top_p[-2] = result;
    #####: 4959:            continue;
        -: 4960:          }
        -: 4961:
        4: 4962:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4963:
        4: 4964:          *stack_top_p++ = result;
        4: 4965:          continue;
        -: 4966:        }
        -: 4967:#if JERRY_ESNEXT
    #####: 4968:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4969:        {
    #####: 4970:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4971:          return ECMA_VALUE_UNDEFINED;
        -: 4972:        }
        -: 4973:#endif /* JERRY_ESNEXT */
    #####: 4974:        default:
        -: 4975:        {
    #####: 4976:          break;
        -: 4977:        }
        -: 4978:      }
        -: 4979:    }
        -: 4980:    else
        -: 4981:    {
        -: 4982:      do
        -: 4983:      {
    #####: 4984:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4985:
    #####: 4986:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
    #####: 4987:      } while (frame_ctx_p->context_depth > 0);
        -: 4988:    }
        -: 4989:
    #####: 4990:finish:
    #####: 4991:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4992:    return result;
        -: 4993:  }
        -: 4994:} /* vm_loop */
        -: 4995:
        -: 4996:#if JERRY_MODULE_SYSTEM
        -: 4997:
        -: 4998:/**
        -: 4999: * Create and initialize module scope with all data properties
        -: 5000: *
        -: 5001: * @return ECMA_VALUE_EMPTY on success,
        -: 5002: *         ECMA_VALUE_ERROR on failure
        -: 5003: */
        -: 5004:ecma_value_t
    #####: 5005:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5006:{
        -: 5007:  ecma_object_t *global_object_p;
        -: 5008:#if JERRY_BUILTIN_REALMS
    #####: 5009:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5010:#else /* !JERRY_BUILTIN_REALMS */
        -: 5011:  global_object_p = ecma_builtin_get_global ();
        -: 5012:#endif /* JERRY_BUILTIN_REALMS */
        -: 5013:
    #####: 5014:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5015:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5016:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5017:  ecma_value_t *literal_start_p;
        -: 5018:  uint8_t *byte_code_p;
        -: 5019:  uint16_t encoding_limit;
        -: 5020:  uint16_t encoding_delta;
        -: 5021:
    #####: 5022:  ((ecma_lexical_environment_class_t *) scope_p)->object_p = (ecma_object_t *) module_p;
    #####: 5023:  ((ecma_lexical_environment_class_t *) scope_p)->type = ECMA_LEX_ENV_CLASS_TYPE_MODULE;
        -: 5024:
    #####: 5025:  module_p->scope_p = scope_p;
    #####: 5026:  ecma_deref_object (scope_p);
        -: 5027:
    #####: 5028:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5029:  {
    #####: 5030:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5031:
    #####: 5032:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5033:    literal_start_p -= args_p->register_end;
    #####: 5034:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5035:  }
        -: 5036:  else
        -: 5037:  {
    #####: 5038:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5039:
    #####: 5040:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5041:    literal_start_p -= args_p->register_end;
    #####: 5042:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5043:  }
        -: 5044:
        -: 5045:  /* Prepare for byte code execution. */
    #####: 5046:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5047:  {
    #####: 5048:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5049:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5050:  }
        -: 5051:  else
        -: 5052:  {
    #####: 5053:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5054:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5055:  }
        -: 5056:
    #####: 5057:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5058:
    #####: 5059:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5060:
        -: 5061:  while (true)
    #####: 5062:  {
    #####: 5063:    uint8_t opcode = *byte_code_p++;
        -: 5064:
    #####: 5065:    switch (opcode)
        -: 5066:    {
    #####: 5067:      case CBC_CREATE_VAR:
        -: 5068:      case CBC_CREATE_LET:
        -: 5069:      case CBC_CREATE_CONST:
        -: 5070:      {
        -: 5071:        uint32_t literal_index;
        -: 5072:
    #####: 5073:        READ_LITERAL_INDEX (literal_index);
        -: 5074:
    #####: 5075:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5076:
    #####: 5077:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5078:
    #####: 5079:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5080:
    #####: 5081:        if (opcode == CBC_CREATE_LET)
        -: 5082:        {
    #####: 5083:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5084:        }
    #####: 5085:        else if (opcode == CBC_CREATE_CONST)
        -: 5086:        {
    #####: 5087:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5088:        }
        -: 5089:
        -: 5090:        ecma_property_value_t *property_value_p;
    #####: 5091:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5092:
    #####: 5093:        if (opcode != CBC_CREATE_VAR)
        -: 5094:        {
    #####: 5095:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5096:        }
    #####: 5097:        break;
        -: 5098:      }
    #####: 5099:      case CBC_INIT_ARG_OR_FUNC:
        -: 5100:      {
        -: 5101:        uint32_t literal_index;
        -: 5102:
    #####: 5103:        READ_LITERAL_INDEX (literal_index);
        -: 5104:
        -: 5105:        ecma_compiled_code_t *function_bytecode_p;
        -: 5106:#if JERRY_SNAPSHOT_EXEC
    #####: 5107:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5108:        {
        -: 5109:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5110:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[literal_index]);
        -: 5111:#if JERRY_SNAPSHOT_EXEC
        -: 5112:        }
        -: 5113:        else
        -: 5114:        {
    #####: 5115:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5116:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5117:        }
        -: 5118:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5119:
    #####: 5120:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5121:
        -: 5122:        ecma_object_t *function_obj_p;
        -: 5123:
    #####: 5124:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5125:        {
    #####: 5126:          function_obj_p = ecma_op_create_arrow_function_object (scope_p, function_bytecode_p, ECMA_VALUE_UNDEFINED);
        -: 5127:        }
        -: 5128:        else
        -: 5129:        {
    #####: 5130:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5131:        }
        -: 5132:
    #####: 5133:        READ_LITERAL_INDEX (literal_index);
    #####: 5134:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5135:
    #####: 5136:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5137:
        -: 5138:        ecma_property_value_t *property_value_p;
    #####: 5139:        property_value_p = ecma_create_named_data_property (scope_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 5140:
    #####: 5141:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5142:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5143:        ecma_deref_object (function_obj_p);
    #####: 5144:        break;
        -: 5145:      }
    #####: 5146:      default:
        -: 5147:      {
    #####: 5148:        JERRY_ASSERT (opcode == CBC_RETURN_FUNCTION_END);
    #####: 5149:        return ECMA_VALUE_EMPTY;
        -: 5150:      }
        -: 5151:    }
        -: 5152:  }
        -: 5153:} /* vm_init_module_scope */
        -: 5154:
        -: 5155:#endif /* JERRY_MODULE_SYSTEM */
        -: 5156:
        -: 5157:#undef READ_LITERAL
        -: 5158:#undef READ_LITERAL_INDEX
        -: 5159:
        -: 5160:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5161:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5162:
        -: 5163:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5164:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5165:
        -: 5166:/**
        -: 5167: * Initialize code block execution
        -: 5168: *
        -: 5169: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5170: *         ECMA_VALUE_EMPTY - otherwise
        -: 5171: */
        -: 5172:static void JERRY_ATTR_NOINLINE
       22: 5173:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5174:{
       22: 5175:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
       22: 5176:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5177:
       22: 5178:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
       22: 5179:  frame_ctx_p->context_depth = 0;
       44: 5180:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
       22: 5181:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5182:
        -: 5183:  uint16_t argument_end, register_end;
        -: 5184:  ecma_value_t *literal_p;
        -: 5185:
       22: 5186:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5187:  {
    #####: 5188:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5189:
    #####: 5190:    argument_end = args_p->argument_end;
    #####: 5191:    register_end = args_p->register_end;
        -: 5192:
    #####: 5193:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5194:    literal_p -= register_end;
    #####: 5195:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5196:    literal_p += args_p->literal_end;
        -: 5197:  }
        -: 5198:  else
        -: 5199:  {
       22: 5200:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5201:
       22: 5202:    argument_end = args_p->argument_end;
       22: 5203:    register_end = args_p->register_end;
        -: 5204:
       22: 5205:    literal_p = (ecma_value_t *) (args_p + 1);
       22: 5206:    literal_p -= register_end;
       22: 5207:    frame_ctx_p->literal_start_p = literal_p;
       22: 5208:    literal_p += args_p->literal_end;
        -: 5209:  }
        -: 5210:
       22: 5211:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
       22: 5212:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
       22: 5213:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5214:
       22: 5215:  uint32_t arg_list_len = 0;
        -: 5216:
       22: 5217:  if (argument_end > 0)
        -: 5218:  {
        7: 5219:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5220:
        7: 5221:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
        7: 5222:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5223:
        7: 5224:    if (arg_list_len > argument_end)
        -: 5225:    {
    #####: 5226:      arg_list_len = argument_end;
        -: 5227:    }
        -: 5228:
       14: 5229:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5230:    {
        7: 5231:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5232:    }
        -: 5233:  }
        -: 5234:
        -: 5235:  /* The arg_list_len contains the end of the copied arguments.
        -: 5236:   * Fill everything else with undefined. */
       22: 5237:  if (register_end > arg_list_len)
        -: 5238:  {
        8: 5239:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5240:
       22: 5241:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5242:    {
       14: 5243:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5244:    }
        -: 5245:  }
        -: 5246:
       22: 5247:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
       22: 5248:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
       22: 5249:} /* vm_init_exec */
        -: 5250:
        -: 5251:/**
        -: 5252: * Resume execution of a code block.
        -: 5253: *
        -: 5254: * @return ecma value
        -: 5255: */
        -: 5256:ecma_value_t JERRY_ATTR_NOINLINE
       36: 5257:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5258:{
        -: 5259:  while (true)
       14: 5260:  {
       36: 5261:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5262:
       34: 5263:    switch (frame_ctx_p->call_operation)
        -: 5264:    {
       15: 5265:      case VM_EXEC_CALL:
        -: 5266:      {
       15: 5267:        opfunc_call (frame_ctx_p);
       10: 5268:        break;
        -: 5269:      }
        -: 5270:#if JERRY_ESNEXT
    #####: 5271:      case VM_EXEC_SUPER_CALL:
        -: 5272:      {
    #####: 5273:        vm_super_call (frame_ctx_p);
    #####: 5274:        break;
        -: 5275:      }
    #####: 5276:      case VM_EXEC_SPREAD_OP:
        -: 5277:      {
    #####: 5278:        vm_spread_operation (frame_ctx_p);
    #####: 5279:        break;
        -: 5280:      }
    #####: 5281:      case VM_EXEC_RETURN:
        -: 5282:      {
    #####: 5283:        return completion_value;
        -: 5284:      }
        -: 5285:#endif /* JERRY_ESNEXT */
        5: 5286:      case VM_EXEC_CONSTRUCT:
        -: 5287:      {
        5: 5288:        opfunc_construct (frame_ctx_p);
        4: 5289:        break;
        -: 5290:      }
       14: 5291:      default:
        -: 5292:      {
       14: 5293:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5294:
       14: 5295:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5296:        uint32_t register_end;
        -: 5297:
       14: 5298:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5299:        {
    #####: 5300:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5301:        }
        -: 5302:        else
        -: 5303:        {
       14: 5304:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5305:        }
        -: 5306:
        -: 5307:        /* Free arguments and registers */
       14: 5308:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
       26: 5309:        for (uint32_t i = 0; i < register_end; i++)
        -: 5310:        {
       12: 5311:          ecma_fast_free_value (registers_p[i]);
        -: 5312:        }
        -: 5313:
        -: 5314:#if JERRY_DEBUGGER
        -: 5315:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5316:        {
        -: 5317:          /* The engine will stop when the next breakpoint is reached. */
        -: 5318:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5319:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5320:        }
        -: 5321:#endif /* JERRY_DEBUGGER */
        -: 5322:
       14: 5323:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
       14: 5324:        return completion_value;
        -: 5325:      }
        -: 5326:    }
        -: 5327:  }
        -: 5328:} /* vm_execute */
        -: 5329:
        -: 5330:/**
        -: 5331: * Run the code.
        -: 5332: *
        -: 5333: * @return ecma value
        -: 5334: */
        -: 5335:ecma_value_t
       22: 5336:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5337:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5338:        ecma_object_t *lex_env_p) /**< lexical environment to use */
       22: 5339:{
       22: 5340:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5341:  vm_frame_ctx_t *frame_ctx_p;
        -: 5342:  size_t frame_size;
        -: 5343:
       22: 5344:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5345:  {
    #####: 5346:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5347:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5348:  }
        -: 5349:  else
        -: 5350:  {
       22: 5351:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
       22: 5352:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5353:  }
        -: 5354:
       22: 5355:  JERRY_VLA (ecma_value_t, stack, frame_size + (sizeof (vm_frame_ctx_t) / sizeof (ecma_value_t)));
        -: 5356:
       22: 5357:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5358:
       22: 5359:  frame_ctx_p->shared_p = shared_p;
       22: 5360:  frame_ctx_p->lex_env_p = lex_env_p;
       22: 5361:  frame_ctx_p->this_binding = this_binding_value;
        -: 5362:
       22: 5363:  vm_init_exec (frame_ctx_p);
       22: 5364:  return vm_execute (frame_ctx_p);
        -: 5365:} /* vm_run */
        -: 5366:
        -: 5367:/**
        -: 5368: * @}
        -: 5369: * @}
        -: 5370: */
