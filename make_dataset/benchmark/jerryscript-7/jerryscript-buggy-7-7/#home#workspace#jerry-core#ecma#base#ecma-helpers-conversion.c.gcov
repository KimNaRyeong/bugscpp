        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-conversion.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-globals.h"
        -:   19:#include "ecma-helpers-number.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:
        -:   22:#include "jrt-libc-includes.h"
        -:   23:#include "lit-char-helpers.h"
        -:   24:#include "lit-magic-strings.h"
        -:   25:
        -:   26:/** \addtogroup ecma ECMA
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:#if JERRY_NUMBER_TYPE_FLOAT64
        -:   34:
        -:   35:/**
        -:   36: * \addtogroup ecmahelpersbigintegers Helpers for operations intermediate 128-bit integers
        -:   37: * @{
        -:   38: */
        -:   39:
        -:   40:/**
        -:   41: * 128-bit integer type
        -:   42: */
        -:   43:typedef struct
        -:   44:{
        -:   45:  uint64_t hi; /**< high 64 bits */
        -:   46:  uint64_t lo; /**< low 64 bits */
        -:   47:} ecma_uint128_t;
        -:   48:
        -:   49:/**
        -:   50: * Round high part of 128-bit integer to uint64_t
        -:   51: *
        -:   52: * @return rounded high to uint64_t
        -:   53: */
        -:   54:static uint64_t
        5:   55:ecma_round_high_to_uint64 (ecma_uint128_t *num_p)
        -:   56:{
        5:   57:  uint64_t masked_lo = num_p->lo & ~(1ULL << 63u);
        5:   58:  uint64_t masked_hi = num_p->hi & 0x1;
        -:   59:
        5:   60:  if ((num_p->lo >> 63u != 0) && (masked_lo > 0 || masked_hi != 0))
        -:   61:  {
    #####:   62:    return (num_p->hi + 1);
        -:   63:  }
        -:   64:
        5:   65:  return num_p->hi;
        -:   66:} /* ecma_round_high_to_uint64 */
        -:   67:
        -:   68:/**
        -:   69: * Left shift 128-bit integer by max 63 bits.
        -:   70: */
        -:   71:static void JERRY_ATTR_ALWAYS_INLINE
        -:   72:ecma_uint128_shift_left (ecma_uint128_t *num_p, int32_t shift)
        -:   73:{
        5:   74:  num_p->hi = (num_p->hi << shift) | (num_p->lo >> (64 - shift));
        5:   75:  num_p->lo <<= shift;
        -:   76:} /* ecma_uint128_shift_left */
        -:   77:
        -:   78:/**
        -:   79: * Right shift 128-bit integer by max 63 bits.
        -:   80: */
        -:   81:static void JERRY_ATTR_ALWAYS_INLINE
        -:   82:ecma_uint128_shift_right (ecma_uint128_t *num_p, int32_t shift)
        -:   83:{
        5:   84:  num_p->lo = (num_p->lo >> shift) | (num_p->hi << (64 - shift));
        5:   85:  num_p->hi >>= shift;
        -:   86:} /* ecma_uint128_shift_right */
        -:   87:
        -:   88:/**
        -:   89: * Add two 128-bit integer values and assign the result to the left one.
        -:   90: */
        -:   91:static void
    #####:   92:ecma_uint128_add (ecma_uint128_t *left_p, ecma_uint128_t *right_p)
        -:   93:{
    #####:   94:  left_p->hi += right_p->hi;
    #####:   95:  left_p->lo += right_p->lo;
        -:   96:
    #####:   97:  if (left_p->lo < right_p->lo)
        -:   98:  {
    #####:   99:    left_p->hi++;
        -:  100:  }
    #####:  101:} /* ecma_uint128_add */
        -:  102:
        -:  103:/**
        -:  104: * Multiply 128-bit integer by 10
        -:  105: */
        -:  106:static void
    #####:  107:ecma_uint128_mul10 (ecma_uint128_t *num_p)
        -:  108:{
    #####:  109:  ecma_uint128_shift_left (num_p, 1u);
        -:  110:
    #####:  111:  ecma_uint128_t tmp = { .hi = num_p->hi, .lo = num_p->lo };
    #####:  112:  ecma_uint128_shift_left (&tmp, 2u);
        -:  113:
    #####:  114:  ecma_uint128_add (num_p, &tmp);
    #####:  115:} /* ecma_uint128_mul10 */
        -:  116:
        -:  117:/**
        -:  118: * Divide 128-bit integer by 10
        -:  119: *
        -:  120: * N = N3 *2^96  + N2 *2^64  + N1 *2^32  + N0 *2^0     // 128-bit dividend
        -:  121: * T = T3 *2^-32 + T2 *2^-64 + T1 *2^-96 + T0 *2^-128  // 128-bit divisor reciprocal, 1/10 * 2^-128
        -:  122: *
        -:  123: * N * T    = N3*T3 *2^64 + N2*T3 *2^32 + N1*T3 *2^0 + N0*T3 *2^-32
        -:  124: *          +               N3*T2 *2^32 + N2*T2 *2^0 + N1*T2 *2^-32 + N0*T2 *2^-64
        -:  125: *          +                             N3*T1 *2^0 + N2*T1 *2^-32 + N1*T1 *2^-64 + N0*T1 *2^-96
        -:  126: *          +                                          N3*T0 *2^-32 + N2*T0 *2^-64 + N1*T0 *2^-96 + N0*T0 *2^-128
        -:  127: *
        -:  128: *  Q3=carry  Q2=^+carry    Q1=^+carry    Q0=^+carry   fraction=^...
        -:  129: *
        -:  130: * Q = Q3 *2^96  + Q2 *2^64  + Q1 *2^32  + Q0 *2^0     // 128-bit quotient
        -:  131: */
        -:  132:static void
    #####:  133:ecma_uint128_div10 (ecma_uint128_t *num_p)
        -:  134:{
        -:  135:  /* estimation of reciprocal of 10, 128 bits right of the binary point (T1 == T2) */
    #####:  136:  const uint64_t tenth_l = 0x9999999aul;
    #####:  137:  const uint64_t tenth_m = 0x99999999ul;
    #####:  138:  const uint64_t tenth_h = 0x19999999ul;
        -:  139:
    #####:  140:  const uint64_t l0 = ((uint32_t) num_p->lo) * tenth_l;
    #####:  141:  const uint64_t l1 = (num_p->lo >> 32u) * tenth_l;
    #####:  142:  const uint64_t l2 = ((uint32_t) num_p->hi) * tenth_l;
    #####:  143:  const uint64_t l3 = (num_p->hi >> 32u) * tenth_l;
    #####:  144:  const uint64_t m0 = ((uint32_t) num_p->lo) * tenth_m;
    #####:  145:  const uint64_t m1 = (num_p->lo >> 32u) * tenth_m;
    #####:  146:  const uint64_t m2 = ((uint32_t) num_p->hi) * tenth_m;
    #####:  147:  const uint64_t m3 = (num_p->hi >> 32u) * tenth_m;
    #####:  148:  const uint64_t h0 = ((uint32_t) num_p->lo) * tenth_h;
    #####:  149:  const uint64_t h1 = (num_p->lo >> 32u) * tenth_h;
    #####:  150:  const uint64_t h2 = ((uint32_t) num_p->hi) * tenth_h;
    #####:  151:  const uint64_t h3 = (num_p->hi >> 32u) * tenth_h;
        -:  152:
    #####:  153:  uint64_t q0 = l0 >> 32u;
    #####:  154:  q0 += (uint32_t) l1;
    #####:  155:  q0 += (uint32_t) m0;
        -:  156:
    #####:  157:  q0 >>= 32u;
    #####:  158:  q0 += l1 >> 32u;
    #####:  159:  q0 += m0 >> 32u;
    #####:  160:  q0 += (uint32_t) l2;
    #####:  161:  q0 += (uint32_t) m1;
    #####:  162:  q0 += (uint32_t) m0;
        -:  163:
    #####:  164:  q0 >>= 32u;
    #####:  165:  q0 += l2 >> 32u;
    #####:  166:  q0 += m1 >> 32u;
    #####:  167:  q0 += m0 >> 32u;
    #####:  168:  q0 += (uint32_t) l3;
    #####:  169:  q0 += (uint32_t) m2;
    #####:  170:  q0 += (uint32_t) m1;
    #####:  171:  q0 += (uint32_t) h0;
        -:  172:
    #####:  173:  q0 >>= 32u;
    #####:  174:  q0 += l3 >> 32u;
    #####:  175:  q0 += m2 >> 32u;
    #####:  176:  q0 += m1 >> 32u;
    #####:  177:  q0 += h0 >> 32u;
    #####:  178:  q0 += (uint32_t) m3;
    #####:  179:  q0 += (uint32_t) m2;
    #####:  180:  q0 += (uint32_t) h1;
        -:  181:
    #####:  182:  uint64_t q1 = q0 >> 32u;
    #####:  183:  q1 += m3 >> 32u;
    #####:  184:  q1 += m2 >> 32u;
    #####:  185:  q1 += h1 >> 32u;
    #####:  186:  q1 += (uint32_t) m3;
    #####:  187:  q1 += (uint32_t) h2;
        -:  188:
    #####:  189:  uint64_t q32 = q1 >> 32u;
    #####:  190:  q32 += m3 >> 32u;
    #####:  191:  q32 += h2 >> 32u;
    #####:  192:  q32 += h3;
        -:  193:
    #####:  194:  num_p->lo = (q1 << 32u) | ((uint32_t) q0);
    #####:  195:  num_p->hi = q32;
    #####:  196:} /* ecma_uint128_div10 */
        -:  197:
        -:  198:/**
        -:  199: * Count leading zeros in a 64-bit integer. The behaviour is undefined for 0.
        -:  200: *
        -:  201: * @return number of leading zeros.
        -:  202: */
        -:  203:inline static int JERRY_ATTR_CONST
       15:  204:ecma_uint64_clz (uint64_t n) /**< integer to count leading zeros in */
        -:  205:{
        -:  206:#if defined(__GNUC__) || defined(__clang__)
       15:  207:  return __builtin_clzll (n);
        -:  208:#else /* !defined (__GNUC__) && !defined (__clang__) */
        -:  209:  JERRY_ASSERT (n != 0);
        -:  210:
        -:  211:  int cnt = 0;
        -:  212:  uint64_t one = 0x8000000000000000ull;
        -:  213:
        -:  214:  while ((n & one) == 0)
        -:  215:  {
        -:  216:    cnt++;
        -:  217:    one >>= 1;
        -:  218:  }
        -:  219:
        -:  220:  return cnt;
        -:  221:#endif /* !defined (__GNUC__) && !defined (__clang__) */
        -:  222:} /* ecma_uint64_clz */
        -:  223:
        -:  224:/**
        -:  225: * Count leading zeros in the top 4 bits of a 64-bit integer.
        -:  226: *
        -:  227: * @return number of leading zeros in top 4 bits.
        -:  228: */
        -:  229:inline static int JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        -:  230:ecma_uint64_clz_top4 (uint64_t n) /**< integer to count leading zeros in */
        -:  231:{
        -:  232:  static const uint8_t ecma_uint4_clz[] = { 4, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
        5:  233:  return ecma_uint4_clz[n >> 60];
        -:  234:} /* ecma_uint64_clz */
        -:  235:
        -:  236:/**
        -:  237: * Shift required to clear 4 bits of a 64-bit integer.
        -:  238: *
        -:  239: * @return 0-4
        -:  240: */
        -:  241:inline static int JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
        -:  242:ecma_uint64_normalize_shift (uint64_t n) /**< integer to count leading zeros in */
        -:  243:{
        -:  244:  static const uint8_t ecma_uint4_shift[] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 };
        -:  245:
    #####:  246:  return ecma_uint4_shift[n >> 60];
        -:  247:} /* ecma_uint64_normalize_shift */
        -:  248:
        -:  249:/**
        -:  250: * @}
        -:  251: */
        -:  252:
        -:  253:/**
        -:  254: * Number.MAX_VALUE exponent part when using 64 bit float representation.
        -:  255: */
        -:  256:#define NUMBER_MAX_DECIMAL_EXPONENT 308
        -:  257:/**
        -:  258: * Number.MIN_VALUE exponent part when using 64 bit float representation.
        -:  259: */
        -:  260:#define NUMBER_MIN_DECIMAL_EXPONENT -324
        -:  261:
        -:  262:#elif !JERRY_NUMBER_TYPE_FLOAT64
        -:  263:
        -:  264:/**
        -:  265: * Number.MAX_VALUE exponent part when using 32 bit float representation.
        -:  266: */
        -:  267:#define NUMBER_MAX_DECIMAL_EXPONENT 38
        -:  268:/**
        -:  269: * Number.MIN_VALUE exponent part when using 32 bit float representation.
        -:  270: */
        -:  271:#define NUMBER_MIN_DECIMAL_EXPONENT -45
        -:  272:
        -:  273:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  274:
        -:  275:/**
        -:  276: * Value of epsilon
        -:  277: */
        -:  278:#define EPSILON 0.0000001
        -:  279:
        -:  280:/**
        -:  281: * ECMA-defined conversion from string to number for different radixes (2, 8, 16).
        -:  282: *
        -:  283: * See also:
        -:  284: *          ECMA-262 v5 9.3.1
        -:  285: *          ECMA-262 v6 7.1.3.1
        -:  286: *
        -:  287: * @return NaN - if the conversion fails
        -:  288: *         converted number - otherwise
        -:  289: */
        -:  290:ecma_number_t
    #####:  291:ecma_utf8_string_to_number_by_radix (const lit_utf8_byte_t *str_p, /**< utf-8 string */
        -:  292:                                     const lit_utf8_size_t string_size, /**< end of utf-8 string  */
        -:  293:                                     uint32_t radix, /**< radix */
        -:  294:                                     uint32_t options) /**< option flags */
        -:  295:{
        -:  296:#if JERRY_ESNEXT
    #####:  297:  bool allow_underscore = (options & ECMA_CONVERSION_ALLOW_UNDERSCORE);
        -:  298:#else /* !JERRY_ESNEXT */
        -:  299:  JERRY_UNUSED (options);
        -:  300:#endif /* !JERRY_ESNEXT */
        -:  301:
    #####:  302:  JERRY_ASSERT (radix == 2 || radix == 8 || radix == 16);
    #####:  303:  JERRY_ASSERT (*str_p == LIT_CHAR_0);
        -:  304:
    #####:  305:  const lit_utf8_byte_t *end_p = str_p + string_size;
        -:  306:
        -:  307:  /* Skip leading zero */
    #####:  308:  str_p++;
        -:  309:
    #####:  310:  if (radix != 8 || LEXER_TO_ASCII_LOWERCASE (*str_p) == LIT_CHAR_LOWERCASE_O)
        -:  311:  {
        -:  312:    /* Skip radix specifier */
    #####:  313:    str_p++;
        -:  314:  }
        -:  315:
    #####:  316:  ecma_number_t num = ECMA_NUMBER_ZERO;
        -:  317:
    #####:  318:  while (str_p < end_p)
        -:  319:  {
    #####:  320:    lit_utf8_byte_t digit = *str_p++;
        -:  321:
        -:  322:#if JERRY_ESNEXT
    #####:  323:    if (digit == LIT_CHAR_UNDERSCORE && allow_underscore)
        -:  324:    {
    #####:  325:      continue;
        -:  326:    }
        -:  327:#endif /* JERRY_ESNEXT */
        -:  328:
    #####:  329:    if (!lit_char_is_hex_digit (digit))
        -:  330:    {
    #####:  331:      return ecma_number_make_nan ();
        -:  332:    }
        -:  333:
    #####:  334:    uint32_t value = lit_char_hex_to_int (digit);
        -:  335:
    #####:  336:    if (value >= radix)
        -:  337:    {
    #####:  338:      return ecma_number_make_nan ();
        -:  339:    }
        -:  340:
    #####:  341:    num = num * radix + value;
        -:  342:  }
        -:  343:
    #####:  344:  return num;
        -:  345:} /* ecma_utf8_string_to_number_by_radix */
        -:  346:
        -:  347:/**
        -:  348: * ECMA-defined conversion of string to Number.
        -:  349: *
        -:  350: * See also:
        -:  351: *          ECMA-262 v5, 9.3.1
        -:  352: *
        -:  353: * @return NaN - if the conversion fails
        -:  354: *         converted number - otherwise
        -:  355: */
        -:  356:ecma_number_t
        6:  357:ecma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */
        -:  358:                            lit_utf8_size_t str_size, /**< string size */
        -:  359:                            uint32_t options) /**< allowing underscore option bit */
        -:  360:{
        6:  361:  ecma_string_trim_helper (&str_p, &str_size);
        6:  362:  const lit_utf8_byte_t *end_p = str_p + str_size;
        -:  363:
        6:  364:  if (str_size == 0)
        -:  365:  {
    #####:  366:    return ECMA_NUMBER_ZERO;
        -:  367:  }
        -:  368:
        6:  369:  bool sign = false;
        -:  370:
        6:  371:  if (str_p + 2 < end_p && str_p[0] == LIT_CHAR_0)
        -:  372:  {
    #####:  373:    uint8_t radix = lit_char_to_radix (str_p[1]);
        -:  374:
    #####:  375:    if (radix != 10)
        -:  376:    {
    #####:  377:      return ecma_utf8_string_to_number_by_radix (str_p, str_size, radix, options);
        -:  378:    }
        -:  379:  }
        -:  380:
        6:  381:  if (*str_p == LIT_CHAR_PLUS)
        -:  382:  {
    #####:  383:    str_p++;
        -:  384:  }
        6:  385:  else if (*str_p == LIT_CHAR_MINUS)
        -:  386:  {
    #####:  387:    sign = true;
    #####:  388:    str_p++;
        -:  389:  }
        -:  390:
        -:  391:  /* Check if string is equal to "Infinity". */
        6:  392:  const lit_utf8_byte_t *infinity_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);
        6:  393:  const lit_utf8_size_t infinity_length = lit_get_magic_string_size (LIT_MAGIC_STRING_INFINITY_UL);
        -:  394:
        6:  395:  if ((lit_utf8_size_t) (end_p - str_p) == infinity_length && memcmp (infinity_str_p, str_p, infinity_length) == 0)
        -:  396:  {
    #####:  397:    return ecma_number_make_infinity (sign);
        -:  398:  }
        -:  399:
        6:  400:  uint64_t significand = 0;
        6:  401:  uint32_t digit_count = 0;
        6:  402:  int32_t decimal_exponent = 0;
        6:  403:  bool has_significand = false;
        -:  404:
        -:  405:  /* Parsing integer part */
       25:  406:  while (str_p < end_p)
        -:  407:  {
        -:  408:#if JERRY_ESNEXT
       13:  409:    if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  410:    {
    #####:  411:      str_p++;
    #####:  412:      continue;
        -:  413:    }
        -:  414:#endif /* JERRY_ESNEXT */
        -:  415:
       13:  416:    if (!lit_char_is_decimal_digit (*str_p))
        -:  417:    {
    #####:  418:      break;
        -:  419:    }
        -:  420:
       13:  421:    has_significand = true;
       13:  422:    uint32_t digit_value = (uint32_t) (*str_p++ - LIT_CHAR_0);
        -:  423:
       13:  424:    if (digit_count == 0 && digit_value == 0)
        -:  425:    {
        -:  426:      /* Leading zeros are omitted. */
        1:  427:      continue;
        -:  428:    }
        -:  429:
       12:  430:    if (digit_count >= ECMA_NUMBER_MAX_DIGITS)
        -:  431:    {
    #####:  432:      decimal_exponent++;
    #####:  433:      continue;
        -:  434:    }
        -:  435:
       12:  436:    significand = significand * 10 + digit_value;
       12:  437:    digit_count++;
        -:  438:  }
        -:  439:
        -:  440:  /* Parse fraction part */
        6:  441:  if (str_p < end_p && *str_p == LIT_CHAR_DOT)
        -:  442:  {
    #####:  443:    str_p++;
        -:  444:
    #####:  445:    while (str_p < end_p)
        -:  446:    {
        -:  447:#if JERRY_ESNEXT
    #####:  448:      if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  449:      {
    #####:  450:        str_p++;
    #####:  451:        continue;
        -:  452:      }
        -:  453:#endif /* JERRY_ESNEXT */
        -:  454:
    #####:  455:      if (!lit_char_is_decimal_digit (*str_p))
        -:  456:      {
    #####:  457:        break;
        -:  458:      }
        -:  459:
    #####:  460:      has_significand = true;
    #####:  461:      uint32_t digit_value = (uint32_t) (*str_p++ - LIT_CHAR_0);
        -:  462:
    #####:  463:      if (digit_count == 0 && digit_value == 0)
        -:  464:      {
        -:  465:        /* Leading zeros are omitted. */
    #####:  466:        decimal_exponent--;
    #####:  467:        continue;
        -:  468:      }
        -:  469:
    #####:  470:      if (digit_count < ECMA_NUMBER_MAX_DIGITS)
        -:  471:      {
    #####:  472:        significand = significand * 10 + digit_value;
    #####:  473:        digit_count++;
    #####:  474:        decimal_exponent--;
        -:  475:      }
        -:  476:    }
        -:  477:  }
        -:  478:
        -:  479:  /* Parsing exponent */
        6:  480:  if (str_p < end_p && LEXER_TO_ASCII_LOWERCASE (*str_p) == LIT_CHAR_LOWERCASE_E)
        -:  481:  {
    #####:  482:    str_p++;
        -:  483:
    #####:  484:    int32_t exponent = 0;
    #####:  485:    int32_t exponent_sign = 1;
        -:  486:
    #####:  487:    if (str_p >= end_p)
        -:  488:    {
    #####:  489:      return ecma_number_make_nan ();
        -:  490:    }
        -:  491:
    #####:  492:    if (*str_p == LIT_CHAR_PLUS)
        -:  493:    {
    #####:  494:      str_p++;
        -:  495:    }
    #####:  496:    else if (*str_p == LIT_CHAR_MINUS)
        -:  497:    {
    #####:  498:      exponent_sign = -1;
    #####:  499:      str_p++;
        -:  500:    }
        -:  501:
    #####:  502:    if (str_p >= end_p || !lit_char_is_decimal_digit (*str_p))
        -:  503:    {
    #####:  504:      return ecma_number_make_nan ();
        -:  505:    }
        -:  506:
    #####:  507:    while (str_p < end_p)
        -:  508:    {
        -:  509:#if JERRY_ESNEXT
    #####:  510:      if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  511:      {
    #####:  512:        str_p++;
    #####:  513:        continue;
        -:  514:      }
        -:  515:#endif /* JERRY_ESNEXT */
        -:  516:
    #####:  517:      if (!lit_char_is_decimal_digit (*str_p))
        -:  518:      {
    #####:  519:        break;
        -:  520:      }
        -:  521:
    #####:  522:      int32_t digit_value = (*str_p++ - LIT_CHAR_0);
    #####:  523:      exponent = exponent * 10 + digit_value;
        -:  524:
    #####:  525:      if (exponent_sign * exponent > NUMBER_MAX_DECIMAL_EXPONENT)
        -:  526:      {
    #####:  527:        return ecma_number_make_infinity (sign);
        -:  528:      }
        -:  529:
    #####:  530:      if (exponent_sign * exponent < NUMBER_MIN_DECIMAL_EXPONENT)
        -:  531:      {
    #####:  532:        return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;
        -:  533:      }
        -:  534:    }
        -:  535:
    #####:  536:    decimal_exponent += exponent_sign * exponent;
        -:  537:  }
        -:  538:
        6:  539:  if (!has_significand || str_p < end_p)
        -:  540:  {
    #####:  541:    return ecma_number_make_nan ();
        -:  542:  }
        -:  543:
        6:  544:  if (significand == 0)
        -:  545:  {
        1:  546:    return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;
        -:  547:  }
        -:  548:
        -:  549:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  550:  /*
        -:  551:   * 128-bit mantissa storage
        -:  552:   *
        -:  553:   * Normalized: |4 bits zero|124-bit mantissa with highest bit set to 1|
        -:  554:   */
        5:  555:  ecma_uint128_t significand_uint128 = { .hi = significand, .lo = 0 };
        -:  556:
        -:  557:  /* Normalizing mantissa */
        5:  558:  int shift = 4 - ecma_uint64_clz (significand_uint128.hi);
        -:  559:
        5:  560:  if (shift < 0)
        -:  561:  {
        5:  562:    ecma_uint128_shift_left (&significand_uint128, -shift);
        -:  563:  }
        -:  564:  else
        -:  565:  {
        -:  566:    ecma_uint128_shift_right (&significand_uint128, shift);
        -:  567:  }
        -:  568:
        5:  569:  int32_t binary_exponent = ECMA_NUMBER_FRACTION_WIDTH + shift;
        -:  570:
       10:  571:  while (decimal_exponent > 0)
        -:  572:  {
    #####:  573:    JERRY_ASSERT (ecma_uint64_clz (significand_uint128.hi) == 4);
        -:  574:
    #####:  575:    ecma_uint128_mul10 (&significand_uint128);
    #####:  576:    decimal_exponent--;
        -:  577:
        -:  578:    /* Re-normalizing mantissa */
    #####:  579:    shift = ecma_uint64_normalize_shift (significand_uint128.hi);
    #####:  580:    JERRY_ASSERT (shift >= 0 && shift <= 4);
        -:  581:
    #####:  582:    ecma_uint128_shift_right (&significand_uint128, shift);
    #####:  583:    binary_exponent += shift;
        -:  584:  }
        -:  585:
       10:  586:  while (decimal_exponent < 0)
        -:  587:  {
        -:  588:    /* Denormalizing mantissa, moving highest 1 to bit 127 */
    #####:  589:    JERRY_ASSERT (ecma_uint64_clz (significand_uint128.hi) <= 4);
    #####:  590:    shift = ecma_uint64_clz_top4 (significand_uint128.hi);
    #####:  591:    JERRY_ASSERT (shift >= 0 && shift <= 4);
        -:  592:
    #####:  593:    ecma_uint128_shift_left (&significand_uint128, shift);
    #####:  594:    binary_exponent -= shift;
        -:  595:
    #####:  596:    ecma_uint128_div10 (&significand_uint128);
    #####:  597:    decimal_exponent++;
        -:  598:  }
        -:  599:
        -:  600:  /*
        -:  601:   * Preparing mantissa for conversion to 52-bit representation, converting it to:
        -:  602:   *
        -:  603:   * |11 zero bits|1|116 mantissa bits|
        -:  604:   */
        5:  605:  JERRY_ASSERT (ecma_uint64_clz (significand_uint128.hi) <= 4);
       10:  606:  shift = 11 - ecma_uint64_clz_top4 (significand_uint128.hi);
    #####:  607:  ecma_uint128_shift_right (&significand_uint128, shift);
        5:  608:  binary_exponent += shift;
        -:  609:
        5:  610:  JERRY_ASSERT (ecma_uint64_clz (significand_uint128.hi) == 11);
        -:  611:
        5:  612:  binary_exponent += ECMA_NUMBER_EXPONENT_BIAS;
        -:  613:
        -:  614:  /* Handle denormal numbers */
        5:  615:  if (binary_exponent < 1)
        -:  616:  {
    #####:  617:    ecma_uint128_shift_right (&significand_uint128, -binary_exponent + 1);
    #####:  618:    binary_exponent = 0;
        -:  619:  }
        -:  620:
        5:  621:  significand = ecma_round_high_to_uint64 (&significand_uint128);
        -:  622:
        5:  623:  if (significand >= 1ull << (ECMA_NUMBER_FRACTION_WIDTH + 1))
        -:  624:  {
        -:  625:    /* Rounding carried over to the most significant bit, re-normalize.
        -:  626:     * No need to shift mantissa right, as the low 52 bits will be 0 regardless. */
    #####:  627:    binary_exponent++;
        -:  628:  }
        -:  629:
        5:  630:  if (binary_exponent >= ((1 << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1))
        -:  631:  {
    #####:  632:    return ecma_number_make_infinity (sign);
        -:  633:  }
        -:  634:
        -:  635:  /* Mask low 52 bits. */
        5:  636:  significand &= ((1ull << ECMA_NUMBER_FRACTION_WIDTH) - 1);
        -:  637:
        5:  638:  JERRY_ASSERT (binary_exponent < (1 << ECMA_NUMBER_BIASED_EXP_WIDTH) - 1);
        5:  639:  JERRY_ASSERT (significand < (1ull << ECMA_NUMBER_FRACTION_WIDTH));
        -:  640:
        5:  641:  return ecma_number_create (sign, (uint32_t) binary_exponent, significand);
        -:  642:#elif !JERRY_NUMBER_TYPE_FLOAT64
        -:  643:  /* Less precise conversion */
        -:  644:  ecma_number_t num = (ecma_number_t) (uint32_t) fraction_uint64;
        -:  645:
        -:  646:  ecma_number_t m = e_sign ? (ecma_number_t) 0.1 : (ecma_number_t) 10.0;
        -:  647:
        -:  648:  while (e)
        -:  649:  {
        -:  650:    if (e % 2)
        -:  651:    {
        -:  652:      num *= m;
        -:  653:    }
        -:  654:
        -:  655:    m *= m;
        -:  656:    e /= 2;
        -:  657:  }
        -:  658:
        -:  659:  return num;
        -:  660:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  661:} /* ecma_utf8_string_to_number */
        -:  662:
        -:  663:/**
        -:  664: * ECMA-defined conversion of UInt32 to String (zero-terminated).
        -:  665: *
        -:  666: * See also:
        -:  667: *          ECMA-262 v5, 9.8.1
        -:  668: *
        -:  669: * @return number of bytes copied to buffer
        -:  670: */
        -:  671:lit_utf8_size_t
       48:  672:ecma_uint32_to_utf8_string (uint32_t value, /**< value to convert */
        -:  673:                            lit_utf8_byte_t *out_buffer_p, /**< buffer for string */
        -:  674:                            lit_utf8_size_t buffer_size) /**< size of buffer */
        -:  675:{
       48:  676:  lit_utf8_byte_t *buf_p = out_buffer_p + buffer_size;
        -:  677:
        -:  678:  do
        -:  679:  {
       68:  680:    JERRY_ASSERT (buf_p >= out_buffer_p);
        -:  681:
       68:  682:    buf_p--;
       68:  683:    *buf_p = (lit_utf8_byte_t) ((value % 10) + LIT_CHAR_0);
       68:  684:    value /= 10;
       68:  685:  } while (value != 0);
        -:  686:
       48:  687:  JERRY_ASSERT (buf_p >= out_buffer_p);
        -:  688:
       48:  689:  lit_utf8_size_t bytes_copied = (lit_utf8_size_t) (out_buffer_p + buffer_size - buf_p);
        -:  690:
       48:  691:  if (JERRY_LIKELY (buf_p != out_buffer_p))
        -:  692:  {
       48:  693:    memmove (out_buffer_p, buf_p, bytes_copied);
        -:  694:  }
        -:  695:
       48:  696:  return bytes_copied;
        -:  697:} /* ecma_uint32_to_utf8_string */
        -:  698:
        -:  699:/**
        -:  700: * ECMA-defined conversion of Number value to UInt32 value
        -:  701: *
        -:  702: * See also:
        -:  703: *          ECMA-262 v5, 9.6
        -:  704: *
        -:  705: * @return 32-bit unsigned integer - result of conversion.
        -:  706: */
        -:  707:uint32_t
    #####:  708:ecma_number_to_uint32 (ecma_number_t num) /**< ecma-number */
        -:  709:{
    #####:  710:  if (JERRY_UNLIKELY (ecma_number_is_zero (num) || !ecma_number_is_finite (num)))
        -:  711:  {
    #####:  712:    return 0;
        -:  713:  }
        -:  714:
    #####:  715:  const bool sign = ecma_number_is_negative (num);
    #####:  716:  const ecma_number_t abs_num = sign ? -num : num;
        -:  717:
        -:  718:  /* 2 ^ 32 */
    #####:  719:  const uint64_t uint64_2_pow_32 = (1ull << 32);
        -:  720:
    #####:  721:  const ecma_number_t num_2_pow_32 = (float) uint64_2_pow_32;
        -:  722:
        -:  723:  ecma_number_t num_in_uint32_range;
        -:  724:
    #####:  725:  if (abs_num >= num_2_pow_32)
        -:  726:  {
    #####:  727:    num_in_uint32_range = ecma_number_remainder (abs_num, num_2_pow_32);
        -:  728:  }
        -:  729:  else
        -:  730:  {
    #####:  731:    num_in_uint32_range = abs_num;
        -:  732:  }
        -:  733:
        -:  734:  /* Check that the floating point value can be represented with uint32_t. */
    #####:  735:  JERRY_ASSERT (num_in_uint32_range < uint64_2_pow_32);
    #####:  736:  uint32_t uint32_num = (uint32_t) num_in_uint32_range;
        -:  737:
    #####:  738:  const uint32_t ret = sign ? -uint32_num : uint32_num;
        -:  739:
        -:  740:#ifndef JERRY_NDEBUG
    #####:  741:  if (sign && uint32_num != 0)
        -:  742:  {
    #####:  743:    JERRY_ASSERT (ret == uint64_2_pow_32 - uint32_num);
        -:  744:  }
        -:  745:  else
        -:  746:  {
    #####:  747:    JERRY_ASSERT (ret == uint32_num);
        -:  748:  }
        -:  749:#endif /* !JERRY_NDEBUG */
        -:  750:
    #####:  751:  return ret;
        -:  752:} /* ecma_number_to_uint32 */
        -:  753:
        -:  754:/**
        -:  755: * ECMA-defined conversion of Number value to Int32 value
        -:  756: *
        -:  757: * See also:
        -:  758: *          ECMA-262 v5, 9.5
        -:  759: *
        -:  760: * @return 32-bit signed integer - result of conversion.
        -:  761: */
        -:  762:int32_t
    #####:  763:ecma_number_to_int32 (ecma_number_t num) /**< ecma-number */
        -:  764:{
    #####:  765:  uint32_t uint32_num = ecma_number_to_uint32 (num);
        -:  766:
        -:  767:  /* 2 ^ 32 */
    #####:  768:  const int64_t int64_2_pow_32 = (1ll << 32);
        -:  769:
        -:  770:  /* 2 ^ 31 */
    #####:  771:  const uint32_t uint32_2_pow_31 = (1ull << 31);
        -:  772:
        -:  773:  int32_t ret;
        -:  774:
    #####:  775:  if (uint32_num >= uint32_2_pow_31)
        -:  776:  {
    #####:  777:    ret = (int32_t) (uint32_num - int64_2_pow_32);
        -:  778:  }
        -:  779:  else
        -:  780:  {
    #####:  781:    ret = (int32_t) uint32_num;
        -:  782:  }
        -:  783:
        -:  784:#ifndef JERRY_NDEBUG
    #####:  785:  int64_t int64_num = uint32_num;
        -:  786:
    #####:  787:  JERRY_ASSERT (int64_num >= 0);
        -:  788:
    #####:  789:  if (int64_num >= uint32_2_pow_31)
        -:  790:  {
    #####:  791:    JERRY_ASSERT (ret == int64_num - int64_2_pow_32);
        -:  792:  }
        -:  793:  else
        -:  794:  {
    #####:  795:    JERRY_ASSERT (ret == int64_num);
        -:  796:  }
        -:  797:#endif /* !JERRY_NDEBUG */
        -:  798:
    #####:  799:  return ret;
        -:  800:} /* ecma_number_to_int32 */
        -:  801:
        -:  802:/**
        -:  803: * Perform conversion of ecma-number to decimal representation with decimal exponent.
        -:  804: *
        -:  805: * Note:
        -:  806: *      The calculated values correspond to s, n, k parameters in ECMA-262 v5, 9.8.1, item 5:
        -:  807: *         - parameter out_digits_p corresponds to s, the digits of the number;
        -:  808: *         - parameter out_decimal_exp_p corresponds to n, the decimal exponent;
        -:  809: *         - return value corresponds to k, the number of digits.
        -:  810: *
        -:  811: * @return the number of digits
        -:  812: */
        -:  813:lit_utf8_size_t
    #####:  814:ecma_number_to_decimal (ecma_number_t num, /**< ecma-number */
        -:  815:                        lit_utf8_byte_t *out_digits_p, /**< [out] buffer to fill with digits */
        -:  816:                        int32_t *out_decimal_exp_p) /**< [out] decimal exponent */
        -:  817:{
    #####:  818:  JERRY_ASSERT (!ecma_number_is_nan (num));
    #####:  819:  JERRY_ASSERT (!ecma_number_is_zero (num));
    #####:  820:  JERRY_ASSERT (!ecma_number_is_infinity (num));
    #####:  821:  JERRY_ASSERT (!ecma_number_is_negative (num));
        -:  822:
    #####:  823:  return ecma_errol0_dtoa ((double) num, out_digits_p, out_decimal_exp_p);
        -:  824:} /* ecma_number_to_decimal */
        -:  825:
        -:  826:/**
        -:  827: * Convert ecma-number to zero-terminated string
        -:  828: *
        -:  829: * See also:
        -:  830: *          ECMA-262 v5, 9.8.1
        -:  831: *
        -:  832: *
        -:  833: * @return size of utf-8 string
        -:  834: */
        -:  835:lit_utf8_size_t
    #####:  836:ecma_number_to_utf8_string (ecma_number_t num, /**< ecma-number */
        -:  837:                            lit_utf8_byte_t *buffer_p, /**< buffer for utf-8 string */
        -:  838:                            lit_utf8_size_t buffer_size) /**< size of buffer */
        -:  839:{
        -:  840:  lit_utf8_byte_t *dst_p;
        -:  841:
    #####:  842:  if (ecma_number_is_nan (num))
        -:  843:  {
        -:  844:    /* 1. */
    #####:  845:    dst_p = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_NAN, buffer_p, buffer_size);
    #####:  846:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  847:  }
        -:  848:
    #####:  849:  if (ecma_number_is_zero (num))
        -:  850:  {
        -:  851:    /* 2. */
    #####:  852:    *buffer_p = LIT_CHAR_0;
    #####:  853:    JERRY_ASSERT (1 <= buffer_size);
    #####:  854:    return 1;
        -:  855:  }
        -:  856:
    #####:  857:  dst_p = buffer_p;
        -:  858:
    #####:  859:  if (ecma_number_is_negative (num))
        -:  860:  {
        -:  861:    /* 3. */
    #####:  862:    *dst_p++ = LIT_CHAR_MINUS;
    #####:  863:    num = -num;
        -:  864:  }
        -:  865:
    #####:  866:  if (ecma_number_is_infinity (num))
        -:  867:  {
        -:  868:    /* 4. */
    #####:  869:    dst_p = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_INFINITY_UL,
        -:  870:                                             dst_p,
    #####:  871:                                             (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
    #####:  872:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  873:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  874:  }
        -:  875:
        -:  876:  /* 5. */
    #####:  877:  uint32_t num_uint32 = ecma_number_to_uint32 (num);
        -:  878:
    #####:  879:  if (((ecma_number_t) num_uint32) == num)
        -:  880:  {
    #####:  881:    dst_p += ecma_uint32_to_utf8_string (num_uint32, dst_p, (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
    #####:  882:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  883:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  884:  }
        -:  885:
        -:  886:  /* decimal exponent */
    #####:  887:  int32_t n;
        -:  888:  /* number of digits in mantissa */
        -:  889:  int32_t k;
        -:  890:
    #####:  891:  k = (int32_t) ecma_number_to_decimal (num, dst_p, &n);
        -:  892:
    #####:  893:  if (k <= n && n <= 21)
        -:  894:  {
        -:  895:    /* 6. */
    #####:  896:    dst_p += k;
        -:  897:
    #####:  898:    memset (dst_p, LIT_CHAR_0, (size_t) (n - k));
    #####:  899:    dst_p += n - k;
        -:  900:
    #####:  901:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  902:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  903:  }
        -:  904:
    #####:  905:  if (0 < n && n <= 21)
        -:  906:  {
        -:  907:    /* 7. */
    #####:  908:    memmove (dst_p + n + 1, dst_p + n, (size_t) (k - n));
    #####:  909:    *(dst_p + n) = LIT_CHAR_DOT;
    #####:  910:    dst_p += k + 1;
        -:  911:
    #####:  912:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  913:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  914:  }
        -:  915:
    #####:  916:  if (-6 < n && n <= 0)
        -:  917:  {
        -:  918:    /* 8. */
    #####:  919:    memmove (dst_p + 2 - n, dst_p, (size_t) k);
    #####:  920:    memset (dst_p + 2, LIT_CHAR_0, (size_t) -n);
    #####:  921:    *dst_p = LIT_CHAR_0;
    #####:  922:    *(dst_p + 1) = LIT_CHAR_DOT;
    #####:  923:    dst_p += k - n + 2;
        -:  924:
    #####:  925:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  926:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  927:  }
        -:  928:
    #####:  929:  if (k == 1)
        -:  930:  {
        -:  931:    /* 9. */
    #####:  932:    dst_p++;
        -:  933:  }
        -:  934:  else
        -:  935:  {
        -:  936:    /* 10. */
    #####:  937:    memmove (dst_p + 2, dst_p + 1, (size_t) (k - 1));
    #####:  938:    *(dst_p + 1) = LIT_CHAR_DOT;
    #####:  939:    dst_p += k + 1;
        -:  940:  }
        -:  941:
        -:  942:  /* 9., 10. */
    #####:  943:  *dst_p++ = LIT_CHAR_LOWERCASE_E;
    #####:  944:  *dst_p++ = (n >= 1) ? LIT_CHAR_PLUS : LIT_CHAR_MINUS;
    #####:  945:  uint32_t t = (uint32_t) (n >= 1 ? (n - 1) : -(n - 1));
        -:  946:
    #####:  947:  dst_p += ecma_uint32_to_utf8_string (t, dst_p, (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
        -:  948:
    #####:  949:  JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
        -:  950:
    #####:  951:  return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  952:} /* ecma_number_to_utf8_string */
        -:  953:
        -:  954:/**
        -:  955: * @}
        -:  956: * @}
        -:  957: */
