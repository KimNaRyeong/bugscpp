        -:    0:Source:/home/workspace/jerry-math/trig.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993, 2004 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Developed at SunSoft, a Sun Microsystems, Inc. business.
        -:   21: *     Permission to use, copy, modify, and distribute this
        -:   22: *     software is freely granted, provided that this notice
        -:   23: *     is preserved.
        -:   24: *
        -:   25: *     @(#)k_rem_pio2.c 1.3 95/01/18
        -:   26: *     @(#)e_rem_pio2.c 1.4 95/01/18
        -:   27: *     @(#)k_sin.c 1.3 95/01/18
        -:   28: *     @(#)k_cos.c 1.3 95/01/18
        -:   29: *     @(#)k_tan.c 1.5 04/04/22
        -:   30: *     @(#)s_sin.c 1.3 95/01/18
        -:   31: *     @(#)s_cos.c 1.3 95/01/18
        -:   32: *     @(#)s_tan.c 1.3 95/01/18
        -:   33: */
        -:   34:
        -:   35:#include "jerry-math-internal.h"
        -:   36:
        -:   37:#define zero   0.00000000000000000000e+00 /* 0x00000000, 0x00000000 */
        -:   38:#define half   5.00000000000000000000e-01 /* 0x3FE00000, 0x00000000 */
        -:   39:#define one    1.00000000000000000000e+00 /* 0x3FF00000, 0x00000000 */
        -:   40:#define two24  1.67772160000000000000e+07 /* 0x41700000, 0x00000000 */
        -:   41:#define twon24 5.96046447753906250000e-08 /* 0x3E700000, 0x00000000 */
        -:   42:
        -:   43:/* __kernel_rem_pio2(x,y,e0,nx,prec)
        -:   44: * double x[],y[]; int e0,nx,prec;
        -:   45: *
        -:   46: * __kernel_rem_pio2 return the last three digits of N with
        -:   47: *              y = x - N*pi/2
        -:   48: * so that |y| < pi/2.
        -:   49: *
        -:   50: * The method is to compute the integer (mod 8) and fraction parts of
        -:   51: * (2/pi)*x without doing the full multiplication. In general we
        -:   52: * skip the part of the product that are known to be a huge integer (
        -:   53: * more accurately, = 0 mod 8 ). Thus the number of operations are
        -:   54: * independent of the exponent of the input.
        -:   55: *
        -:   56: * (2/pi) is represented by an array of 24-bit integers in ipio2[].
        -:   57: *
        -:   58: * Input parameters:
        -:   59: *      x[]     The input value (must be positive) is broken into nx
        -:   60: *              pieces of 24-bit integers in double precision format.
        -:   61: *              x[i] will be the i-th 24 bit of x. The scaled exponent
        -:   62: *              of x[0] is given in input parameter e0 (i.e., x[0]*2^e0
        -:   63: *              match x's up to 24 bits.
        -:   64: *
        -:   65: *              Example of breaking a double positive z into x[0]+x[1]+x[2]:
        -:   66: *                      e0 = ilogb(z)-23
        -:   67: *                      z  = scalbn(z,-e0)
        -:   68: *              for i = 0,1,2
        -:   69: *                      x[i] = floor(z)
        -:   70: *                      z    = (z-x[i])*2**24
        -:   71: *
        -:   72: *      y[]     ouput result in an array of double precision numbers.
        -:   73: *              The dimension of y[] is:
        -:   74: *                      24-bit  precision       1
        -:   75: *                      53-bit  precision       2
        -:   76: *                      64-bit  precision       2
        -:   77: *                      113-bit precision       3
        -:   78: *              The actual value is the sum of them. Thus for 113-bit
        -:   79: *              precison, one may have to do something like:
        -:   80: *
        -:   81: *              long double t,w,r_head, r_tail;
        -:   82: *              t = (long double)y[2] + (long double)y[1];
        -:   83: *              w = (long double)y[0];
        -:   84: *              r_head = t+w;
        -:   85: *              r_tail = w - (r_head - t);
        -:   86: *
        -:   87: *      e0      The exponent of x[0]
        -:   88: *
        -:   89: *      nx      dimension of x[]
        -:   90: *
        -:   91: *      prec    an integer indicating the precision:
        -:   92: *                      0       24  bits (single)
        -:   93: *                      1       53  bits (double)
        -:   94: *                      2       64  bits (extended)
        -:   95: *                      3       113 bits (quad)
        -:   96: *
        -:   97: * External function:
        -:   98: *      double scalbn(), floor();
        -:   99: *
        -:  100: * Here is the description of some local variables:
        -:  101: *
        -:  102: *      ipio2[] integer array, contains the (24*i)-th to (24*i+23)-th
        -:  103: *              bit of 2/pi after binary point. The corresponding
        -:  104: *              floating value is
        -:  105: *
        -:  106: *                      ipio2[i] * 2^(-24(i+1)).
        -:  107: *
        -:  108: *      jk      jk+1 is the initial number of terms of ipio2[] needed
        -:  109: *              in the computation. The recommended value is 2,3,4,
        -:  110: *              6 for single, double, extended,and quad.
        -:  111: *
        -:  112: *      jz      local integer variable indicating the number of
        -:  113: *              terms of ipio2[] used.
        -:  114: *
        -:  115: *      jx      nx - 1
        -:  116: *
        -:  117: *      jv      index for pointing to the suitable ipio2[] for the
        -:  118: *              computation. In general, we want
        -:  119: *                      ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
        -:  120: *              is an integer. Thus
        -:  121: *                      e0-3-24*jv >= 0 or (e0-3)/24 >= jv
        -:  122: *              Hence jv = max(0,(e0-3)/24).
        -:  123: *
        -:  124: *      jp      jp+1 is the number of terms in PIo2[] needed, jp = jk.
        -:  125: *
        -:  126: *      q[]     double array with integral value, representing the
        -:  127: *              24-bits chunk of the product of x and 2/pi.
        -:  128: *
        -:  129: *      q0      the corresponding exponent of q[0]. Note that the
        -:  130: *              exponent for q[i] would be q0-24*i.
        -:  131: *
        -:  132: *      PIo2[]  double precision array, obtained by cutting pi/2
        -:  133: *              into 24 bits chunks.
        -:  134: *
        -:  135: *      f[]     ipio2[] in floating point
        -:  136: *
        -:  137: *      iq[]    integer array by breaking up q[] in 24-bits chunk.
        -:  138: *
        -:  139: *      fq[]    final product of x*(2/pi) in fq[0],..,fq[jk]
        -:  140: *
        -:  141: *      ih      integer. If >0 it indicates q[] is >= 0.5, hence
        -:  142: *              it also indicates the *sign* of the result.
        -:  143: */
        -:  144:
        -:  145:/*
        -:  146: * Constants:
        -:  147: * The hexadecimal values are the intended ones for the following
        -:  148: * constants. The decimal values may be used, provided that the
        -:  149: * compiler will convert from decimal to binary accurately enough
        -:  150: * to produce the hexadecimal values shown.
        -:  151: */
        -:  152:
        -:  153:/* initial value for jk */
        -:  154:static const int init_jk[] = { 2, 3, 4, 6 };
        -:  155:
        -:  156:static const double PIo2[] = {
        -:  157:  1.57079625129699707031e+00, /* 0x3FF921FB, 0x40000000 */
        -:  158:  7.54978941586159635335e-08, /* 0x3E74442D, 0x00000000 */
        -:  159:  5.39030252995776476554e-15, /* 0x3CF84698, 0x80000000 */
        -:  160:  3.28200341580791294123e-22, /* 0x3B78CC51, 0x60000000 */
        -:  161:  1.27065575308067607349e-29, /* 0x39F01B83, 0x80000000 */
        -:  162:  1.22933308981111328932e-36, /* 0x387A2520, 0x40000000 */
        -:  163:  2.73370053816464559624e-44, /* 0x36E38222, 0x80000000 */
        -:  164:  2.16741683877804819444e-51, /* 0x3569F31D, 0x00000000 */
        -:  165:};
        -:  166:
        -:  167:/*
        -:  168: * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
        -:  169: */
        -:  170:static const int ipio2[] = {
        -:  171:  0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62, 0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7,
        -:  172:  0x246E3A, 0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129, 0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C,
        -:  173:  0x7026B4, 0x5F7E41, 0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8, 0x97FFDE, 0x05980F, 0xEF2F11,
        -:  174:  0x8B5A0A, 0x6D1F6D, 0x367ECF, 0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5, 0xF17B3D, 0x0739F7,
        -:  175:  0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08, 0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3, 0x91615E,
        -:  176:  0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880, 0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,
        -:  177:};
        -:  178:
        -:  179:static int
    #####:  180:__kernel_rem_pio2 (double *x, double *y, int e0, int nx, int prec)
        -:  181:{
        -:  182:  int jz, jx, jv, jp, jk, carry, n, iq[20], i, j, k, m, q0, ih;
        -:  183:  double z, fw, f[20], fq[20], q[20];
        -:  184:
        -:  185:  /* initialize jk */
    #####:  186:  jk = init_jk[prec];
    #####:  187:  jp = jk;
        -:  188:
        -:  189:  /* determine jx, jv, q0, note that 3 > q0 */
    #####:  190:  jx = nx - 1;
    #####:  191:  jv = (e0 - 3) / 24;
    #####:  192:  if (jv < 0)
        -:  193:  {
    #####:  194:    jv = 0;
        -:  195:  }
    #####:  196:  q0 = e0 - 24 * (jv + 1);
        -:  197:
        -:  198:  /* set up f[0] to f[jx + jk] where f[jx + jk] = ipio2[jv + jk] */
    #####:  199:  j = jv - jx;
    #####:  200:  m = jx + jk;
    #####:  201:  for (i = 0; i <= m; i++, j++)
        -:  202:  {
    #####:  203:    f[i] = (j < 0) ? zero : (double) ipio2[j];
        -:  204:  }
        -:  205:
        -:  206:  /* compute q[0], q[1], ... q[jk] */
    #####:  207:  for (i = 0; i <= jk; i++)
        -:  208:  {
    #####:  209:    for (j = 0, fw = 0.0; j <= jx; j++)
        -:  210:    {
    #####:  211:      fw += x[j] * f[jx + i - j];
        -:  212:    }
    #####:  213:    q[i] = fw;
        -:  214:  }
        -:  215:
        -:  216:  jz = jk;
    #####:  217:recompute:
        -:  218:  /* distill q[] into iq[] reversingly */
    #####:  219:  for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--)
        -:  220:  {
    #####:  221:    fw = (double) ((int) (twon24 * z));
    #####:  222:    iq[i] = (int) (z - two24 * fw);
    #####:  223:    z = q[j - 1] + fw;
        -:  224:  }
        -:  225:
        -:  226:  /* compute n */
    #####:  227:  z = scalbn (z, q0); /* actual value of z */
    #####:  228:  z -= 8.0 * floor (z * 0.125); /* trim off integer >= 8 */
    #####:  229:  n = (int) z;
    #####:  230:  z -= (double) n;
    #####:  231:  ih = 0;
    #####:  232:  if (q0 > 0) /* need iq[jz - 1] to determine n */
        -:  233:  {
    #####:  234:    i = (iq[jz - 1] >> (24 - q0));
    #####:  235:    n += i;
    #####:  236:    iq[jz - 1] -= i << (24 - q0);
    #####:  237:    ih = iq[jz - 1] >> (23 - q0);
        -:  238:  }
    #####:  239:  else if (q0 == 0)
        -:  240:  {
    #####:  241:    ih = iq[jz - 1] >> 23;
        -:  242:  }
    #####:  243:  else if (z >= 0.5)
        -:  244:  {
        -:  245:    ih = 2;
        -:  246:  }
        -:  247:
    #####:  248:  if (ih > 0) /* q > 0.5 */
        -:  249:  {
    #####:  250:    n += 1;
    #####:  251:    carry = 0;
    #####:  252:    for (i = 0; i < jz; i++) /* compute 1 - q */
        -:  253:    {
    #####:  254:      j = iq[i];
    #####:  255:      if (carry == 0)
        -:  256:      {
    #####:  257:        if (j != 0)
        -:  258:        {
    #####:  259:          carry = 1;
    #####:  260:          iq[i] = 0x1000000 - j;
        -:  261:        }
        -:  262:      }
        -:  263:      else
        -:  264:      {
    #####:  265:        iq[i] = 0xffffff - j;
        -:  266:      }
        -:  267:    }
    #####:  268:    if (q0 > 0) /* rare case: chance is 1 in 12 */
        -:  269:    {
    #####:  270:      switch (q0)
        -:  271:      {
    #####:  272:        case 1:
        -:  273:        {
    #####:  274:          iq[jz - 1] &= 0x7fffff;
    #####:  275:          break;
        -:  276:        }
    #####:  277:        case 2:
        -:  278:        {
    #####:  279:          iq[jz - 1] &= 0x3fffff;
    #####:  280:          break;
        -:  281:        }
        -:  282:      }
        -:  283:    }
    #####:  284:    if (ih == 2)
        -:  285:    {
    #####:  286:      z = one - z;
    #####:  287:      if (carry != 0)
        -:  288:      {
    #####:  289:        z -= scalbn (one, q0);
        -:  290:      }
        -:  291:    }
        -:  292:  }
        -:  293:
        -:  294:  /* check if recomputation is needed */
    #####:  295:  if (z == zero)
        -:  296:  {
    #####:  297:    j = 0;
    #####:  298:    for (i = jz - 1; i >= jk; i--)
        -:  299:    {
    #####:  300:      j |= iq[i];
        -:  301:    }
    #####:  302:    if (j == 0) /* need recomputation */
        -:  303:    {
    #####:  304:      for (k = 1; iq[jk - k] == 0; k++) /* k = no. of terms needed */
        -:  305:      {
        -:  306:      }
        -:  307:
    #####:  308:      for (i = jz + 1; i <= jz + k; i++) /* add q[jz + 1] to q[jz + k] */
        -:  309:      {
    #####:  310:        f[jx + i] = (double) ipio2[jv + i];
    #####:  311:        for (j = 0, fw = 0.0; j <= jx; j++)
        -:  312:        {
    #####:  313:          fw += x[j] * f[jx + i - j];
        -:  314:        }
    #####:  315:        q[i] = fw;
        -:  316:      }
        -:  317:      jz += k;
        -:  318:      goto recompute;
        -:  319:    }
        -:  320:  }
        -:  321:
        -:  322:  /* chop off zero terms */
    #####:  323:  if (z == 0.0)
        -:  324:  {
    #####:  325:    jz -= 1;
    #####:  326:    q0 -= 24;
    #####:  327:    while (iq[jz] == 0)
        -:  328:    {
    #####:  329:      jz--;
    #####:  330:      q0 -= 24;
        -:  331:    }
        -:  332:  }
        -:  333:  else
        -:  334:  { /* break z into 24-bit if necessary */
    #####:  335:    z = scalbn (z, -q0);
    #####:  336:    if (z >= two24)
        -:  337:    {
    #####:  338:      fw = (double) ((int) (twon24 * z));
    #####:  339:      iq[jz] = (int) (z - two24 * fw);
    #####:  340:      jz += 1;
    #####:  341:      q0 += 24;
    #####:  342:      iq[jz] = (int) fw;
        -:  343:    }
        -:  344:    else
        -:  345:    {
    #####:  346:      iq[jz] = (int) z;
        -:  347:    }
        -:  348:  }
        -:  349:
        -:  350:  /* convert integer "bit" chunk to floating-point value */
    #####:  351:  fw = scalbn (one, q0);
    #####:  352:  for (i = jz; i >= 0; i--)
        -:  353:  {
    #####:  354:    q[i] = fw * (double) iq[i];
    #####:  355:    fw *= twon24;
        -:  356:  }
        -:  357:
        -:  358:  /* compute PIo2[0, ..., jp] * q[jz, ..., 0] */
    #####:  359:  for (i = jz; i >= 0; i--)
        -:  360:  {
    #####:  361:    for (fw = 0.0, k = 0; k <= jp && k <= jz - i; k++)
        -:  362:    {
    #####:  363:      fw += PIo2[k] * q[i + k];
        -:  364:    }
    #####:  365:    fq[jz - i] = fw;
        -:  366:  }
        -:  367:
        -:  368:  /* compress fq[] into y[] */
    #####:  369:  switch (prec)
        -:  370:  {
        -:  371:    case 0:
        -:  372:    {
        -:  373:      fw = 0.0;
    #####:  374:      for (i = jz; i >= 0; i--)
        -:  375:      {
    #####:  376:        fw += fq[i];
        -:  377:      }
    #####:  378:      y[0] = (ih == 0) ? fw : -fw;
    #####:  379:      break;
        -:  380:    }
        -:  381:    case 1:
        -:  382:    case 2:
        -:  383:    {
        -:  384:      fw = 0.0;
    #####:  385:      for (i = jz; i >= 0; i--)
        -:  386:      {
    #####:  387:        fw += fq[i];
        -:  388:      }
    #####:  389:      y[0] = (ih == 0) ? fw : -fw;
    #####:  390:      fw = fq[0] - fw;
    #####:  391:      for (i = 1; i <= jz; i++)
        -:  392:      {
    #####:  393:        fw += fq[i];
        -:  394:      }
    #####:  395:      y[1] = (ih == 0) ? fw : -fw;
    #####:  396:      break;
        -:  397:    }
        -:  398:    case 3: /* painful */
        -:  399:    {
    #####:  400:      for (i = jz; i > 0; i--)
        -:  401:      {
    #####:  402:        fw = fq[i - 1] + fq[i];
    #####:  403:        fq[i] += fq[i - 1] - fw;
    #####:  404:        fq[i - 1] = fw;
        -:  405:      }
    #####:  406:      for (i = jz; i > 1; i--)
        -:  407:      {
    #####:  408:        fw = fq[i - 1] + fq[i];
    #####:  409:        fq[i] += fq[i - 1] - fw;
    #####:  410:        fq[i - 1] = fw;
        -:  411:      }
    #####:  412:      for (fw = 0.0, i = jz; i >= 2; i--)
        -:  413:      {
    #####:  414:        fw += fq[i];
        -:  415:      }
    #####:  416:      if (ih == 0)
        -:  417:      {
    #####:  418:        y[0] = fq[0];
    #####:  419:        y[1] = fq[1];
    #####:  420:        y[2] = fw;
        -:  421:      }
        -:  422:      else
        -:  423:      {
    #####:  424:        y[0] = -fq[0];
    #####:  425:        y[1] = -fq[1];
    #####:  426:        y[2] = -fw;
        -:  427:      }
        -:  428:    }
        -:  429:  }
    #####:  430:  return n & 7;
        -:  431:} /* __kernel_rem_pio2 */
        -:  432:
        -:  433:/* __ieee754_rem_pio2(x,y)
        -:  434: * return the remainder of x rem pi/2 in y[0]+y[1]
        -:  435: * use __kernel_rem_pio2()
        -:  436: */
        -:  437:
        -:  438:static const int npio2_hw[] = {
        -:  439:  0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C, 0x4025FDBB, 0x402921FB,
        -:  440:  0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C, 0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB,
        -:  441:  0x403AB41B, 0x403C463A, 0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,
        -:  442:  0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB, 0x404858EB, 0x404921FB,
        -:  443:};
        -:  444:
        -:  445:/*
        -:  446: * invpio2:  53 bits of 2/pi
        -:  447: * pio2_1:   first  33 bit of pi/2
        -:  448: * pio2_1t:  pi/2 - pio2_1
        -:  449: * pio2_2:   second 33 bit of pi/2
        -:  450: * pio2_2t:  pi/2 - (pio2_1 + pio2_2)
        -:  451: * pio2_3:   third  33 bit of pi/2
        -:  452: * pio2_3t:  pi/2 - (pio2_1 + pio2_2 + pio2_3)
        -:  453: */
        -:  454:#define invpio2 6.36619772367581382433e-01 /* 0x3FE45F30, 0x6DC9C883 */
        -:  455:#define pio2_1  1.57079632673412561417e+00 /* 0x3FF921FB, 0x54400000 */
        -:  456:#define pio2_1t 6.07710050650619224932e-11 /* 0x3DD0B461, 0x1A626331 */
        -:  457:#define pio2_2  6.07710050630396597660e-11 /* 0x3DD0B461, 0x1A600000 */
        -:  458:#define pio2_2t 2.02226624879595063154e-21 /* 0x3BA3198A, 0x2E037073 */
        -:  459:#define pio2_3  2.02226624871116645580e-21 /* 0x3BA3198A, 0x2E000000 */
        -:  460:#define pio2_3t 8.47842766036889956997e-32 /* 0x397B839A, 0x252049C1 */
        -:  461:
        -:  462:static int
    #####:  463:__ieee754_rem_pio2 (double x, double *y)
        -:  464:{
        -:  465:  double_accessor z;
        -:  466:  double w, t, r, fn;
        -:  467:  double tx[3];
        -:  468:  int e0, i, j, nx, n, ix, hx;
        -:  469:
    #####:  470:  hx = __HI (x); /* high word of x */
    #####:  471:  ix = hx & 0x7fffffff;
    #####:  472:  if (ix <= 0x3fe921fb) /* |x| ~<= pi/4 , no need for reduction */
        -:  473:  {
    #####:  474:    y[0] = x;
    #####:  475:    y[1] = 0;
    #####:  476:    return 0;
        -:  477:  }
    #####:  478:  if (ix < 0x4002d97c) /* |x| < 3pi/4, special case with n = +-1 */
        -:  479:  {
    #####:  480:    if (hx > 0)
        -:  481:    {
    #####:  482:      z.dbl = x - pio2_1;
    #####:  483:      if (ix != 0x3ff921fb) /* 33 + 53 bit pi is good enough */
        -:  484:      {
    #####:  485:        y[0] = z.dbl - pio2_1t;
    #####:  486:        y[1] = (z.dbl - y[0]) - pio2_1t;
        -:  487:      }
        -:  488:      else /* near pi/2, use 33 + 33 + 53 bit pi */
        -:  489:      {
    #####:  490:        z.dbl -= pio2_2;
    #####:  491:        y[0] = z.dbl - pio2_2t;
    #####:  492:        y[1] = (z.dbl - y[0]) - pio2_2t;
        -:  493:      }
        -:  494:      return 1;
        -:  495:    }
        -:  496:    else /* negative x */
        -:  497:    {
    #####:  498:      z.dbl = x + pio2_1;
    #####:  499:      if (ix != 0x3ff921fb) /* 33 + 53 bit pi is good enough */
        -:  500:      {
    #####:  501:        y[0] = z.dbl + pio2_1t;
    #####:  502:        y[1] = (z.dbl - y[0]) + pio2_1t;
        -:  503:      }
        -:  504:      else /* near pi/2, use 33 + 33 + 53 bit pi */
        -:  505:      {
    #####:  506:        z.dbl += pio2_2;
    #####:  507:        y[0] = z.dbl + pio2_2t;
    #####:  508:        y[1] = (z.dbl - y[0]) + pio2_2t;
        -:  509:      }
        -:  510:      return -1;
        -:  511:    }
        -:  512:  }
    #####:  513:  if (ix <= 0x413921fb) /* |x| ~<= 2^19 * (pi/2), medium size */
        -:  514:  {
    #####:  515:    t = fabs (x);
    #####:  516:    n = (int) (t * invpio2 + half);
    #####:  517:    fn = (double) n;
    #####:  518:    r = t - fn * pio2_1;
    #####:  519:    w = fn * pio2_1t; /* 1st round good to 85 bit */
    #####:  520:    if (n < 32 && ix != npio2_hw[n - 1])
        -:  521:    {
    #####:  522:      y[0] = r - w; /* quick check no cancellation */
        -:  523:    }
        -:  524:    else
        -:  525:    {
    #####:  526:      j = ix >> 20;
    #####:  527:      y[0] = r - w;
    #####:  528:      i = j - (((__HI (y[0])) >> 20) & 0x7ff);
    #####:  529:      if (i > 16) /* 2nd iteration needed, good to 118 */
        -:  530:      {
    #####:  531:        t = r;
    #####:  532:        w = fn * pio2_2;
    #####:  533:        r = t - w;
    #####:  534:        w = fn * pio2_2t - ((t - r) - w);
    #####:  535:        y[0] = r - w;
    #####:  536:        i = j - (((__HI (y[0])) >> 20) & 0x7ff);
    #####:  537:        if (i > 49) /* 3rd iteration need, 151 bits acc, will cover all possible cases */
        -:  538:        {
    #####:  539:          t = r;
    #####:  540:          w = fn * pio2_3;
    #####:  541:          r = t - w;
    #####:  542:          w = fn * pio2_3t - ((t - r) - w);
    #####:  543:          y[0] = r - w;
        -:  544:        }
        -:  545:      }
        -:  546:    }
    #####:  547:    y[1] = (r - y[0]) - w;
    #####:  548:    if (hx < 0)
        -:  549:    {
    #####:  550:      y[0] = -y[0];
    #####:  551:      y[1] = -y[1];
    #####:  552:      return -n;
        -:  553:    }
        -:  554:    else
        -:  555:    {
        -:  556:      return n;
        -:  557:    }
        -:  558:  }
        -:  559:  /*
        -:  560:   * all other (large) arguments
        -:  561:   */
    #####:  562:  if (ix >= 0x7ff00000) /* x is inf or NaN */
        -:  563:  {
    #####:  564:    y[0] = y[1] = x - x;
    #####:  565:    return 0;
        -:  566:  }
        -:  567:  /* set z = scalbn(|x|, ilogb(x) - 23) */
    #####:  568:  z.as_int.lo = __LO (x);
    #####:  569:  e0 = (ix >> 20) - 1046; /* e0 = ilogb(z) - 23; */
    #####:  570:  z.as_int.hi = ix - (e0 << 20);
    #####:  571:  for (i = 0; i < 2; i++)
        -:  572:  {
    #####:  573:    tx[i] = (double) ((int) (z.dbl));
    #####:  574:    z.dbl = (z.dbl - tx[i]) * two24;
        -:  575:  }
    #####:  576:  tx[2] = z.dbl;
    #####:  577:  nx = 3;
    #####:  578:  while (tx[nx - 1] == zero) /* skip zero term */
        -:  579:  {
        -:  580:    nx--;
        -:  581:  }
    #####:  582:  n = __kernel_rem_pio2 (tx, y, e0, nx, 2);
    #####:  583:  if (hx < 0)
        -:  584:  {
    #####:  585:    y[0] = -y[0];
    #####:  586:    y[1] = -y[1];
    #####:  587:    return -n;
        -:  588:  }
        -:  589:  return n;
        -:  590:} /* __ieee754_rem_pio2 */
        -:  591:
        -:  592:/* __kernel_sin( x, y, iy)
        -:  593: * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854
        -:  594: * Input x is assumed to be bounded by ~pi/4 in magnitude.
        -:  595: * Input y is the tail of x.
        -:  596: * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).
        -:  597: *
        -:  598: * Algorithm
        -:  599: *      1. Since sin(-x) = -sin(x), we need only to consider positive x.
        -:  600: *      2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.
        -:  601: *      3. sin(x) is approximated by a polynomial of degree 13 on
        -:  602: *         [0,pi/4]
        -:  603: *                               3            13
        -:  604: *              sin(x) ~ x + S1*x + ... + S6*x
        -:  605: *         where
        -:  606: *
        -:  607: *      |sin(x)         2     4     6     8     10     12  |     -58
        -:  608: *      |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2
        -:  609: *      |  x                                               |
        -:  610: *
        -:  611: *      4. sin(x+y) = sin(x) + sin'(x')*y
        -:  612: *                  ~ sin(x) + (1-x*x/2)*y
        -:  613: *         For better accuracy, let
        -:  614: *                   3      2      2      2      2
        -:  615: *              r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))
        -:  616: *         then                   3    2
        -:  617: *              sin(x) = x + (S1*x + (x *(r-y/2)+y))
        -:  618: */
        -:  619:
        -:  620:#define S1 -1.66666666666666324348e-01 /* 0xBFC55555, 0x55555549 */
        -:  621:#define S2 8.33333333332248946124e-03 /* 0x3F811111, 0x1110F8A6 */
        -:  622:#define S3 -1.98412698298579493134e-04 /* 0xBF2A01A0, 0x19C161D5 */
        -:  623:#define S4 2.75573137070700676789e-06 /* 0x3EC71DE3, 0x57B1FE7D */
        -:  624:#define S5 -2.50507602534068634195e-08 /* 0xBE5AE5E6, 0x8A2B9CEB */
        -:  625:#define S6 1.58969099521155010221e-10 /* 0x3DE5D93A, 0x5ACFD57C */
        -:  626:
        -:  627:static double
    #####:  628:__kernel_sin (double x, double y, int iy)
        -:  629:{
        -:  630:  double z, r, v;
        -:  631:  int ix;
        -:  632:
    #####:  633:  ix = __HI (x) & 0x7fffffff; /* high word of x */
    #####:  634:  if (ix < 0x3e400000) /* |x| < 2**-27 */
        -:  635:  {
    #####:  636:    if ((int) x == 0)
        -:  637:    {
        -:  638:      return x; /* generate inexact */
        -:  639:    }
        -:  640:  }
    #####:  641:  z = x * x;
    #####:  642:  v = z * x;
    #####:  643:  r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));
    #####:  644:  if (iy == 0)
        -:  645:  {
    #####:  646:    return x + v * (S1 + z * r);
        -:  647:  }
        -:  648:  else
        -:  649:  {
    #####:  650:    return x - ((z * (half * y - v * r) - y) - v * S1);
        -:  651:  }
        -:  652:} /* __kernel_sin */
        -:  653:
        -:  654:/*
        -:  655: * __kernel_cos( x,  y )
        -:  656: * kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164
        -:  657: * Input x is assumed to be bounded by ~pi/4 in magnitude.
        -:  658: * Input y is the tail of x.
        -:  659: *
        -:  660: * Algorithm
        -:  661: *      1. Since cos(-x) = cos(x), we need only to consider positive x.
        -:  662: *      2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.
        -:  663: *      3. cos(x) is approximated by a polynomial of degree 14 on
        -:  664: *         [0,pi/4]
        -:  665: *                                       4            14
        -:  666: *              cos(x) ~ 1 - x*x/2 + C1*x + ... + C6*x
        -:  667: *         where the remez error is
        -:  668: *
        -:  669: *      |              2     4     6     8     10    12     14 |     -58
        -:  670: *      |cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2
        -:  671: *      |                                                      |
        -:  672: *
        -:  673: *                     4     6     8     10    12     14
        -:  674: *      4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then
        -:  675: *             cos(x) = 1 - x*x/2 + r
        -:  676: *         since cos(x+y) ~ cos(x) - sin(x)*y
        -:  677: *                        ~ cos(x) - x*y,
        -:  678: *         a correction term is necessary in cos(x) and hence
        -:  679: *              cos(x+y) = 1 - (x*x/2 - (r - x*y))
        -:  680: *         For better accuracy when x > 0.3, let qx = |x|/4 with
        -:  681: *         the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.
        -:  682: *         Then
        -:  683: *              cos(x+y) = (1-qx) - ((x*x/2-qx) - (r-x*y)).
        -:  684: *         Note that 1-qx and (x*x/2-qx) is EXACT here, and the
        -:  685: *         magnitude of the latter is at least a quarter of x*x/2,
        -:  686: *         thus, reducing the rounding error in the subtraction.
        -:  687: */
        -:  688:
        -:  689:#define C1 4.16666666666666019037e-02 /* 0x3FA55555, 0x5555554C */
        -:  690:#define C2 -1.38888888888741095749e-03 /* 0xBF56C16C, 0x16C15177 */
        -:  691:#define C3 2.48015872894767294178e-05 /* 0x3EFA01A0, 0x19CB1590 */
        -:  692:#define C4 -2.75573143513906633035e-07 /* 0xBE927E4F, 0x809C52AD */
        -:  693:#define C5 2.08757232129817482790e-09 /* 0x3E21EE9E, 0xBDB4B1C4 */
        -:  694:#define C6 -1.13596475577881948265e-11 /* 0xBDA8FAE9, 0xBE8838D4 */
        -:  695:
        -:  696:static double
    #####:  697:__kernel_cos (double x, double y)
        -:  698:{
        -:  699:  double a, hz, z, r;
        -:  700:  int ix;
        -:  701:
    #####:  702:  ix = __HI (x) & 0x7fffffff; /* ix = |x|'s high word */
    #####:  703:  if (ix < 0x3e400000) /* if x < 2**27 */
        -:  704:  {
    #####:  705:    if (((int) x) == 0)
        -:  706:    {
        -:  707:      return one; /* generate inexact */
        -:  708:    }
        -:  709:  }
    #####:  710:  z = x * x;
    #####:  711:  r = z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));
    #####:  712:  if (ix < 0x3FD33333) /* if |x| < 0.3 */
        -:  713:  {
    #####:  714:    return one - (0.5 * z - (z * r - x * y));
        -:  715:  }
        -:  716:  else
        -:  717:  {
        -:  718:    double_accessor qx;
    #####:  719:    if (ix > 0x3fe90000) /* x > 0.78125 */
        -:  720:    {
    #####:  721:      qx.dbl = 0.28125;
        -:  722:    }
        -:  723:    else
        -:  724:    {
    #####:  725:      qx.as_int.hi = ix - 0x00200000; /* x / 4 */
    #####:  726:      qx.as_int.lo = 0;
        -:  727:    }
    #####:  728:    hz = 0.5 * z - qx.dbl;
    #####:  729:    a = one - qx.dbl;
    #####:  730:    return a - (hz - (z * r - x * y));
        -:  731:  }
        -:  732:} /* __kernel_cos */
        -:  733:
        -:  734:/* __kernel_tan( x, y, k )
        -:  735: * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854
        -:  736: * Input x is assumed to be bounded by ~pi/4 in magnitude.
        -:  737: * Input y is the tail of x.
        -:  738: * Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned.
        -:  739: *
        -:  740: * Algorithm
        -:  741: *      1. Since tan(-x) = -tan(x), we need only to consider positive x.
        -:  742: *      2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.
        -:  743: *      3. tan(x) is approximated by a odd polynomial of degree 27 on
        -:  744: *         [0,0.67434]
        -:  745: *                               3             27
        -:  746: *              tan(x) ~ x + T1*x + ... + T13*x
        -:  747: *         where
        -:  748: *
        -:  749: *              |tan(x)         2     4            26   |     -59.2
        -:  750: *              |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2
        -:  751: *              |  x                                    |
        -:  752: *
        -:  753: *         Note: tan(x+y) = tan(x) + tan'(x)*y
        -:  754: *                        ~ tan(x) + (1+x*x)*y
        -:  755: *         Therefore, for better accuracy in computing tan(x+y), let
        -:  756: *                   3      2      2       2       2
        -:  757: *              r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))
        -:  758: *         then
        -:  759: *                                  3    2
        -:  760: *              tan(x+y) = x + (T1*x + (x *(r+y)+y))
        -:  761: *
        -:  762: *      4. For x in [0.67434,pi/4],  let y = pi/4 - x, then
        -:  763: *              tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y))
        -:  764: *                     = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))
        -:  765: */
        -:  766:
        -:  767:#define T0     3.33333333333334091986e-01 /* 3FD55555, 55555563 */
        -:  768:#define T1     1.33333333333201242699e-01 /* 3FC11111, 1110FE7A */
        -:  769:#define T2     5.39682539762260521377e-02 /* 3FABA1BA, 1BB341FE */
        -:  770:#define T3     2.18694882948595424599e-02 /* 3F9664F4, 8406D637 */
        -:  771:#define T4     8.86323982359930005737e-03 /* 3F8226E3, E96E8493 */
        -:  772:#define T5     3.59207910759131235356e-03 /* 3F6D6D22, C9560328 */
        -:  773:#define T6     1.45620945432529025516e-03 /* 3F57DBC8, FEE08315 */
        -:  774:#define T7     5.88041240820264096874e-04 /* 3F4344D8, F2F26501 */
        -:  775:#define T8     2.46463134818469906812e-04 /* 3F3026F7, 1A8D1068 */
        -:  776:#define T9     7.81794442939557092300e-05 /* 3F147E88, A03792A6 */
        -:  777:#define T10    7.14072491382608190305e-05 /* 3F12B80F, 32F0A7E9 */
        -:  778:#define T11    -1.85586374855275456654e-05 /* BEF375CB, DB605373 */
        -:  779:#define T12    2.59073051863633712884e-05 /* 3EFB2A70, 74BF7AD4 */
        -:  780:#define pio4   7.85398163397448278999e-01 /* 3FE921FB, 54442D18 */
        -:  781:#define pio4lo 3.06161699786838301793e-17 /* 3C81A626, 33145C07 */
        -:  782:
        -:  783:static double
    #####:  784:__kernel_tan (double x, double y, int iy)
        -:  785:{
        -:  786:  double_accessor z;
        -:  787:  double r, v, w, s;
        -:  788:  int ix, hx;
        -:  789:
    #####:  790:  hx = __HI (x); /* high word of x */
    #####:  791:  ix = hx & 0x7fffffff; /* high word of |x| */
    #####:  792:  if (ix < 0x3e300000) /* x < 2**-28 */
        -:  793:  {
    #####:  794:    if ((int) x == 0) /* generate inexact */
        -:  795:    {
    #####:  796:      if (((ix | __LO (x)) | (iy + 1)) == 0)
        -:  797:      {
    #####:  798:        return one / fabs (x);
        -:  799:      }
        -:  800:      else
        -:  801:      {
    #####:  802:        if (iy == 1)
        -:  803:        {
        -:  804:          return x;
        -:  805:        }
        -:  806:        else /* compute -1 / (x + y) carefully */
        -:  807:        {
        -:  808:          double a;
        -:  809:          double_accessor t;
        -:  810:
    #####:  811:          z.dbl = w = x + y;
    #####:  812:          z.as_int.lo = 0;
    #####:  813:          v = y - (z.dbl - x);
    #####:  814:          t.dbl = a = -one / w;
    #####:  815:          t.as_int.lo = 0;
    #####:  816:          s = one + t.dbl * z.dbl;
    #####:  817:          return t.dbl + a * (s + t.dbl * v);
        -:  818:        }
        -:  819:      }
        -:  820:    }
        -:  821:  }
    #####:  822:  if (ix >= 0x3FE59428) /* |x| >= 0.6744 */
        -:  823:  {
    #####:  824:    if (hx < 0)
        -:  825:    {
    #####:  826:      x = -x;
    #####:  827:      y = -y;
        -:  828:    }
    #####:  829:    z.dbl = pio4 - x;
    #####:  830:    w = pio4lo - y;
    #####:  831:    x = z.dbl + w;
    #####:  832:    y = 0.0;
        -:  833:  }
    #####:  834:  z.dbl = x * x;
    #####:  835:  w = z.dbl * z.dbl;
        -:  836:  /*
        -:  837:   * Break x^5 * (T[1] + x^2 * T[2] + ...) into
        -:  838:   * x^5 (T[1] + x^4 * T[3] + ... + x^20 * T[11]) +
        -:  839:   * x^5 (x^2 * (T[2] + x^4 * T[4] + ... + x^22 * [T12]))
        -:  840:   */
    #####:  841:  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));
    #####:  842:  v = z.dbl * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));
    #####:  843:  s = z.dbl * x;
    #####:  844:  r = y + z.dbl * (s * (r + v) + y);
    #####:  845:  r += T0 * s;
    #####:  846:  w = x + r;
    #####:  847:  if (ix >= 0x3FE59428)
        -:  848:  {
    #####:  849:    v = (double) iy;
    #####:  850:    return (double) (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));
        -:  851:  }
    #####:  852:  if (iy == 1)
        -:  853:  {
        -:  854:    return w;
        -:  855:  }
        -:  856:  else
        -:  857:  {
        -:  858:    /*
        -:  859:     * if allow error up to 2 ulp, simply return
        -:  860:     * -1.0 / (x + r) here
        -:  861:     */
        -:  862:    /* compute -1.0 / (x + r) accurately */
        -:  863:    double a;
        -:  864:    double_accessor t;
        -:  865:
    #####:  866:    z.dbl = w;
    #####:  867:    z.as_int.lo = 0;
    #####:  868:    v = r - (z.dbl - x); /* z + v = r + x */
    #####:  869:    t.dbl = a = -1.0 / w; /* a = -1.0 / w */
    #####:  870:    t.as_int.lo = 0;
    #####:  871:    s = 1.0 + t.dbl * z.dbl;
    #####:  872:    return t.dbl + a * (s + t.dbl * v);
        -:  873:  }
        -:  874:} /* __kernel_tan */
        -:  875:
        -:  876:/* Method:
        -:  877: *      Let S,C and T denote the sin, cos and tan respectively on
        -:  878: *      [-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
        -:  879: *      in [-pi/4 , +pi/4], and let n = k mod 4.
        -:  880: *      We have
        -:  881: *
        -:  882: *          n        sin(x)      cos(x)        tan(x)
        -:  883: *     ----------------------------------------------------------
        -:  884: *          0          S           C             T
        -:  885: *          1          C          -S            -1/T
        -:  886: *          2         -S          -C             T
        -:  887: *          3         -C           S            -1/T
        -:  888: *     ----------------------------------------------------------
        -:  889: *
        -:  890: * Special cases:
        -:  891: *      Let trig be any of sin, cos, or tan.
        -:  892: *      trig(+-INF)  is NaN, with signals;
        -:  893: *      trig(NaN)    is that NaN;
        -:  894: *
        -:  895: * Accuracy:
        -:  896: *      TRIG(x) returns trig(x) nearly rounded
        -:  897: */
        -:  898:
        -:  899:/* sin(x)
        -:  900: * Return sine function of x.
        -:  901: *
        -:  902: * kernel function:
        -:  903: *      __kernel_sin            ... sine function on [-pi/4,pi/4]
        -:  904: *      __kernel_cos            ... cose function on [-pi/4,pi/4]
        -:  905: *      __ieee754_rem_pio2      ... argument reduction routine
        -:  906: */
        -:  907:double
    #####:  908:sin (double x)
        -:  909:{
    #####:  910:  double y[2], z = 0.0;
        -:  911:  int n, ix;
        -:  912:
        -:  913:  /* High word of x. */
    #####:  914:  ix = __HI (x);
        -:  915:
        -:  916:  /* |x| ~< pi/4 */
    #####:  917:  ix &= 0x7fffffff;
    #####:  918:  if (ix <= 0x3fe921fb)
        -:  919:  {
    #####:  920:    return __kernel_sin (x, z, 0);
        -:  921:  }
        -:  922:
        -:  923:  /* sin(Inf or NaN) is NaN */
    #####:  924:  else if (ix >= 0x7ff00000)
        -:  925:  {
    #####:  926:    return x - x;
        -:  927:  }
        -:  928:
        -:  929:  /* argument reduction needed */
        -:  930:  else
        -:  931:  {
    #####:  932:    n = __ieee754_rem_pio2 (x, y);
    #####:  933:    switch (n & 3)
        -:  934:    {
    #####:  935:      case 0:
        -:  936:      {
    #####:  937:        return __kernel_sin (y[0], y[1], 1);
        -:  938:      }
    #####:  939:      case 1:
        -:  940:      {
    #####:  941:        return __kernel_cos (y[0], y[1]);
        -:  942:      }
    #####:  943:      case 2:
        -:  944:      {
    #####:  945:        return -__kernel_sin (y[0], y[1], 1);
        -:  946:      }
    #####:  947:      default:
        -:  948:      {
    #####:  949:        return -__kernel_cos (y[0], y[1]);
        -:  950:      }
        -:  951:    }
        -:  952:  }
        -:  953:} /* sin */
        -:  954:
        -:  955:/* cos(x)
        -:  956: * Return cosine function of x.
        -:  957: *
        -:  958: * kernel function:
        -:  959: *      __kernel_sin            ... sine function on [-pi/4,pi/4]
        -:  960: *      __kernel_cos            ... cosine function on [-pi/4,pi/4]
        -:  961: *      __ieee754_rem_pio2      ... argument reduction routine
        -:  962: */
        -:  963:
        -:  964:double
    #####:  965:cos (double x)
        -:  966:{
    #####:  967:  double y[2], z = 0.0;
        -:  968:  int n, ix;
        -:  969:
        -:  970:  /* High word of x. */
    #####:  971:  ix = __HI (x);
        -:  972:
        -:  973:  /* |x| ~< pi/4 */
    #####:  974:  ix &= 0x7fffffff;
    #####:  975:  if (ix <= 0x3fe921fb)
        -:  976:  {
    #####:  977:    return __kernel_cos (x, z);
        -:  978:  }
        -:  979:
        -:  980:  /* cos(Inf or NaN) is NaN */
    #####:  981:  else if (ix >= 0x7ff00000)
        -:  982:  {
    #####:  983:    return x - x;
        -:  984:  }
        -:  985:
        -:  986:  /* argument reduction needed */
        -:  987:  else
        -:  988:  {
    #####:  989:    n = __ieee754_rem_pio2 (x, y);
    #####:  990:    switch (n & 3)
        -:  991:    {
    #####:  992:      case 0:
        -:  993:      {
    #####:  994:        return __kernel_cos (y[0], y[1]);
        -:  995:      }
    #####:  996:      case 1:
        -:  997:      {
    #####:  998:        return -__kernel_sin (y[0], y[1], 1);
        -:  999:      }
    #####: 1000:      case 2:
        -: 1001:      {
    #####: 1002:        return -__kernel_cos (y[0], y[1]);
        -: 1003:      }
    #####: 1004:      default:
        -: 1005:      {
    #####: 1006:        return __kernel_sin (y[0], y[1], 1);
        -: 1007:      }
        -: 1008:    }
        -: 1009:  }
        -: 1010:} /* cos */
        -: 1011:
        -: 1012:/* tan(x)
        -: 1013: * Return tangent function of x.
        -: 1014: *
        -: 1015: * kernel function:
        -: 1016: *      __kernel_tan            ... tangent function on [-pi/4,pi/4]
        -: 1017: *      __ieee754_rem_pio2      ... argument reduction routine
        -: 1018: */
        -: 1019:
        -: 1020:double
    #####: 1021:tan (double x)
        -: 1022:{
    #####: 1023:  double y[2], z = 0.0;
        -: 1024:  int n, ix;
        -: 1025:
        -: 1026:  /* High word of x. */
    #####: 1027:  ix = __HI (x);
        -: 1028:
        -: 1029:  /* |x| ~< pi/4 */
    #####: 1030:  ix &= 0x7fffffff;
    #####: 1031:  if (ix <= 0x3fe921fb)
        -: 1032:  {
    #####: 1033:    return __kernel_tan (x, z, 1);
        -: 1034:  }
        -: 1035:
        -: 1036:  /* tan(Inf or NaN) is NaN */
    #####: 1037:  else if (ix >= 0x7ff00000)
        -: 1038:  {
    #####: 1039:    return x - x; /* NaN */
        -: 1040:  }
        -: 1041:
        -: 1042:  /* argument reduction needed */
        -: 1043:  else
        -: 1044:  {
    #####: 1045:    n = __ieee754_rem_pio2 (x, y);
    #####: 1046:    return __kernel_tan (y[0], y[1], 1 - ((n & 1) << 1)); /*   1 -- n even, -1 -- n odd */
        -: 1047:  }
        -: 1048:} /* tan */
        -: 1049:
        -: 1050:#undef zero
        -: 1051:#undef half
        -: 1052:#undef one
        -: 1053:#undef two24
        -: 1054:#undef twon24
        -: 1055:#undef invpio2
        -: 1056:#undef pio2_1
        -: 1057:#undef pio2_1t
        -: 1058:#undef pio2_2
        -: 1059:#undef pio2_2t
        -: 1060:#undef pio2_3
        -: 1061:#undef pio2_3t
        -: 1062:#undef S1
        -: 1063:#undef S2
        -: 1064:#undef S3
        -: 1065:#undef S4
        -: 1066:#undef S5
        -: 1067:#undef S6
        -: 1068:#undef C1
        -: 1069:#undef C2
        -: 1070:#undef C3
        -: 1071:#undef C4
        -: 1072:#undef C5
        -: 1073:#undef C6
        -: 1074:#undef T0
        -: 1075:#undef T1
        -: 1076:#undef T2
        -: 1077:#undef T3
        -: 1078:#undef T4
        -: 1079:#undef T5
        -: 1080:#undef T6
        -: 1081:#undef T7
        -: 1082:#undef T8
        -: 1083:#undef T9
        -: 1084:#undef T10
        -: 1085:#undef T11
        -: 1086:#undef T12
        -: 1087:#undef pio4
        -: 1088:#undef pio4lo
