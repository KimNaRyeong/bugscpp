        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jcontext.h"
        -:   17:#include "js-parser-internal.h"
        -:   18:#include "js-scanner-internal.h"
        -:   19:#include "lit-char-helpers.h"
        -:   20:
        -:   21:#if JERRY_PARSER
        -:   22:
        -:   23:/** \addtogroup parser Parser
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup jsparser JavaScript
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser_scanner Scanner
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/**
        -:   34: * Scan return types.
        -:   35: */
        -:   36:typedef enum
        -:   37:{
        -:   38:  SCAN_NEXT_TOKEN, /**< get next token after return */
        -:   39:  SCAN_KEEP_TOKEN, /**< keep the current token after return */
        -:   40:} scan_return_types_t;
        -:   41:
        -:   42:/**
        -:   43: * Checks whether token type is "of".
        -:   44: */
        -:   45:#if JERRY_ESNEXT
        -:   46:#define SCANNER_IDENTIFIER_IS_OF() (lexer_token_is_identifier (context_p, "of", 2))
        -:   47:#else /* !JERRY_ESNEXT */
        -:   48:#define SCANNER_IDENTIFIER_IS_OF() (false)
        -:   49:#endif /* JERRY_ESNEXT */
        -:   50:
        -:   51:#if JERRY_ESNEXT
        -:   52:
        -:   53:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_GENERATOR)
        -:   54:                       == SCAN_STACK_COMPUTED_GENERATOR,
        -:   55:                     scanner_invalid_conversion_from_literal_pool_generator_to_computed_generator);
        -:   56:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_ASYNC) == SCAN_STACK_COMPUTED_ASYNC,
        -:   57:                     scanner_invalid_conversion_from_literal_pool_async_to_computed_async);
        -:   58:
        -:   59:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_GENERATOR)
        -:   60:                       == SCANNER_LITERAL_POOL_GENERATOR,
        -:   61:                     scanner_invalid_conversion_from_computed_generator_to_literal_pool_generator);
        -:   62:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_ASYNC) == SCANNER_LITERAL_POOL_ASYNC,
        -:   63:                     scanner_invalid_conversion_from_computed_async_to_literal_pool_async);
        -:   64:
        -:   65:#endif /* JERRY_ESNEXT */
        -:   66:
        -:   67:/**
        -:   68: * Change scanner mode from primary expression to post primary expression.
        -:   69: *
        -:   70: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:   71: */
        -:   72:static scan_return_types_t
       60:   73:scanner_primary_to_post_primary_expression (parser_context_t *context_p, /**< context */
        -:   74:                                            scanner_context_t *scanner_context_p) /* scanner context */
        -:   75:{
       60:   76:  scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:   77:
        -:   78:#if JERRY_ESNEXT
       60:   79:  if (JERRY_UNLIKELY (context_p->stack_top_uint8 == SCAN_STACK_CLASS_FIELD_INITIALIZER
        -:   80:                      && (context_p->status_flags & PARSER_IS_STRICT)))
        -:   81:  {
    #####:   82:    lexer_scan_identifier (context_p, LEXER_PARSE_CHECK_KEYWORDS | LEXER_PARSE_NO_STRICT_IDENT_ERROR);
        -:   83:
    #####:   84:    if (context_p->token.type == LEXER_LITERAL && lexer_compare_literal_to_string (context_p, "static", 6))
        -:   85:    {
    #####:   86:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:   87:    }
        -:   88:
    #####:   89:    return SCAN_KEEP_TOKEN;
        -:   90:  }
        -:   91:#else /* !JERRY_ESNEXT */
        -:   92:  JERRY_UNUSED (context_p);
        -:   93:#endif /* JERRY_ESNEXT */
        -:   94:
       60:   95:  return SCAN_NEXT_TOKEN;
        -:   96:} /* scanner_primary_to_post_primary_expression */
        -:   97:
        -:   98:/**
        -:   99: * Scan primary expression.
        -:  100: *
        -:  101: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:  102: */
        -:  103:static scan_return_types_t
       81:  104:scanner_scan_primary_expression (parser_context_t *context_p, /**< context */
        -:  105:                                 scanner_context_t *scanner_context_p, /* scanner context */
        -:  106:                                 lexer_token_type_t type, /**< current token type */
        -:  107:                                 scan_stack_modes_t stack_top) /**< current stack top */
        -:  108:{
       81:  109:  switch (type)
        -:  110:  {
        8:  111:    case LEXER_KEYW_NEW:
        -:  112:    {
        8:  113:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;
        -:  114:
        -:  115:#if JERRY_ESNEXT
        8:  116:      if (scanner_try_scan_new_target (context_p))
        -:  117:      {
    #####:  118:        return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  119:      }
        -:  120:#endif /* JERRY_ESNEXT */
        8:  121:      break;
        -:  122:    }
    #####:  123:    case LEXER_DIVIDE:
        -:  124:    case LEXER_ASSIGN_DIVIDE:
        -:  125:    {
    #####:  126:      lexer_construct_regexp_object (context_p, true);
    #####:  127:      return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  128:    }
        9:  129:    case LEXER_KEYW_FUNCTION:
        -:  130:    {
        9:  131:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  132:#if JERRY_MODULE_SYSTEM
        9:  133:      bool is_export_default = stack_top == SCAN_STACK_EXPORT_DEFAULT;
        -:  134:#endif /* JERRY_MODULE_SYSTEM */
        -:  135:
        -:  136:#if JERRY_ESNEXT
        9:  137:      if (scanner_context_p->async_source_p != NULL)
        -:  138:      {
    #####:  139:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -:  140:      }
        -:  141:
        9:  142:      if (lexer_consume_generator (context_p))
        -:  143:      {
    #####:  144:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -:  145:      }
        -:  146:#endif /* JERRY_ESNEXT */
        -:  147:
        9:  148:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -:  149:
        9:  150:      lexer_next_token (context_p);
        -:  151:
        9:  152:      if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  153:      {
        -:  154:#if JERRY_MODULE_SYSTEM
    #####:  155:        if (is_export_default)
        -:  156:        {
        -:  157:          lexer_lit_location_t *location_p;
    #####:  158:          location_p = scanner_add_custom_literal (context_p,
    #####:  159:                                                   scanner_context_p->active_literal_pool_p->prev_p,
    #####:  160:                                                   &context_p->token.lit_location);
        -:  161:
    #####:  162:          scanner_detect_invalid_let (context_p, location_p);
    #####:  163:          location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -:  164:        }
        -:  165:#endif /* JERRY_MODULE_SYSTEM */
    #####:  166:        lexer_next_token (context_p);
        -:  167:      }
        -:  168:#if JERRY_MODULE_SYSTEM
        9:  169:      else if (is_export_default)
        -:  170:      {
        -:  171:        lexer_lit_location_t *location_p;
    #####:  172:        location_p = scanner_add_custom_literal (context_p,
    #####:  173:                                                 scanner_context_p->active_literal_pool_p->prev_p,
        -:  174:                                                 &lexer_default_literal);
    #####:  175:        location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -:  176:      }
        -:  177:#endif /* JERRY_MODULE_SYSTEM */
        -:  178:
        9:  179:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);
        9:  180:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        9:  181:      return SCAN_KEEP_TOKEN;
        -:  182:    }
        4:  183:    case LEXER_LEFT_PAREN:
        -:  184:    {
        4:  185:      scanner_scan_bracket (context_p, scanner_context_p);
        4:  186:      return SCAN_KEEP_TOKEN;
        -:  187:    }
    #####:  188:    case LEXER_LEFT_SQUARE:
        -:  189:    {
        -:  190:#if JERRY_ESNEXT
    #####:  191:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
        -:  192:#endif /* JERRY_ESNEXT */
        -:  193:
    #####:  194:      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####:  195:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  196:      break;
        -:  197:    }
    #####:  198:    case LEXER_LEFT_BRACE:
        -:  199:    {
        -:  200:#if JERRY_ESNEXT
    #####:  201:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
    #####:  202:      parser_stack_push_uint8 (context_p, 0);
        -:  203:#endif /* JERRY_ESNEXT */
        -:  204:
    #####:  205:      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####:  206:      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####:  207:      return SCAN_KEEP_TOKEN;
        -:  208:    }
        -:  209:#if JERRY_ESNEXT
    #####:  210:    case LEXER_HASHMARK:
        -:  211:    {
    #####:  212:      if (!lexer_scan_private_identifier (context_p))
        -:  213:      {
    #####:  214:        scanner_raise_error (context_p);
        -:  215:      }
        -:  216:
    #####:  217:      return SCAN_KEEP_TOKEN;
        -:  218:    }
    #####:  219:    case LEXER_TEMPLATE_LITERAL:
        -:  220:    {
    #####:  221:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -:  222:      {
    #####:  223:        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);
    #####:  224:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  225:        break;
        -:  226:      }
        -:  227:
        -:  228:      /* The string is a normal string literal. */
        -:  229:      /* FALLTHRU */
        -:  230:    }
        -:  231:#endif /* JERRY_ESNEXT */
    #####:  232:    case LEXER_LITERAL:
        -:  233:    {
        -:  234:#if JERRY_ESNEXT
       31:  235:      const uint8_t *source_p = context_p->source_p;
        -:  236:
       31:  237:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL && lexer_check_arrow (context_p))
        -:  238:      {
    #####:  239:        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
    #####:  240:        return SCAN_KEEP_TOKEN;
        -:  241:      }
        -:  242:
       31:  243:      if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  244:      {
    #####:  245:        scanner_context_p->async_source_p = source_p;
    #####:  246:        scanner_check_async_function (context_p, scanner_context_p);
    #####:  247:        return SCAN_KEEP_TOKEN;
        -:  248:      }
        -:  249:#endif /* JERRY_ESNEXT */
        -:  250:
       31:  251:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  252:      {
        -:  253:#if JERRY_MODULE_SYSTEM
       24:  254:        if (stack_top == SCAN_STACK_EXPORT_DEFAULT)
        -:  255:        {
    #####:  256:          lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
    #####:  257:          location_p->type |= (SCANNER_LITERAL_IS_USED | SCANNER_LITERAL_IS_VAR);
    #####:  258:          scanner_detect_eval_call (context_p, scanner_context_p);
    #####:  259:          return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  260:        }
        -:  261:#endif /* JERRY_MODULE_SYSTEM */
        -:  262:
       24:  263:        scanner_add_reference (context_p, scanner_context_p);
        -:  264:      }
        -:  265:      /* FALLTHRU */
        -:  266:    }
        -:  267:    case LEXER_KEYW_THIS:
        -:  268:    case LEXER_LIT_TRUE:
        -:  269:    case LEXER_LIT_FALSE:
        -:  270:    case LEXER_LIT_NULL:
        -:  271:    {
       34:  272:      return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  273:    }
        -:  274:#if JERRY_ESNEXT
        8:  275:    case LEXER_KEYW_SUPER:
        -:  276:    {
        8:  277:      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;
        8:  278:      return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  279:    }
    #####:  280:    case LEXER_KEYW_CLASS:
        -:  281:    {
    #####:  282:      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);
        -:  283:
    #####:  284:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  285:      {
    #####:  286:        return SCAN_KEEP_TOKEN;
        -:  287:      }
    #####:  288:      break;
        -:  289:    }
        -:  290:#endif /* JERRY_ESNEXT */
    #####:  291:    case LEXER_RIGHT_SQUARE:
        -:  292:    {
    #####:  293:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  294:      {
    #####:  295:        scanner_raise_error (context_p);
        -:  296:      }
        -:  297:
    #####:  298:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  299:      return SCAN_KEEP_TOKEN;
        -:  300:    }
        -:  301:#if JERRY_ESNEXT
    #####:  302:    case LEXER_THREE_DOTS:
        -:  303:    {
        -:  304:      /* Elision or spread arguments */
    #####:  305:      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  306:      {
    #####:  307:        scanner_raise_error (context_p);
        -:  308:      }
    #####:  309:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  310:      break;
        -:  311:    }
        -:  312:#endif /* JERRY_ESNEXT */
    #####:  313:    case LEXER_COMMA:
        -:  314:    {
    #####:  315:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  316:      {
    #####:  317:        scanner_raise_error (context_p);
        -:  318:      }
    #####:  319:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  320:
        -:  321:#if JERRY_ESNEXT
    #####:  322:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  323:      {
    #####:  324:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  325:      }
        -:  326:#endif /* JERRY_ESNEXT */
    #####:  327:      break;
        -:  328:    }
        -:  329:#if JERRY_ESNEXT
    #####:  330:    case LEXER_KEYW_YIELD:
        -:  331:    {
    #####:  332:      lexer_next_token (context_p);
        -:  333:
    #####:  334:      if (lexer_check_yield_no_arg (context_p))
        -:  335:      {
    #####:  336:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  337:      }
        -:  338:
    #####:  339:      if (context_p->token.type == LEXER_MULTIPLY)
        -:  340:      {
    #####:  341:        return SCAN_NEXT_TOKEN;
        -:  342:      }
    #####:  343:      return SCAN_KEEP_TOKEN;
        -:  344:    }
        -:  345:#endif /* JERRY_ESNEXT */
        -:  346:#if JERRY_MODULE_SYSTEM
    #####:  347:    case LEXER_KEYW_IMPORT:
        -:  348:    {
    #####:  349:      lexer_next_token (context_p);
        -:  350:
    #####:  351:      if (context_p->token.type == LEXER_DOT)
        -:  352:      {
    #####:  353:        scanner_check_import_meta (context_p);
        -:  354:      }
    #####:  355:      else if (context_p->token.type != LEXER_LEFT_PAREN)
        -:  356:      {
    #####:  357:        scanner_raise_error (context_p);
        -:  358:      }
        -:  359:
    #####:  360:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  361:      return SCAN_KEEP_TOKEN;
        -:  362:    }
        -:  363:#endif /* JERRY_MODULE_SYSTEM */
       18:  364:    case LEXER_RIGHT_PAREN:
        -:  365:    {
       18:  366:      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)
        -:  367:      {
       18:  368:        parser_stack_pop_uint8 (context_p);
        -:  369:
        -:  370:#if JERRY_ESNEXT
       18:  371:        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  372:        {
    #####:  373:          scanner_add_async_literal (context_p, scanner_context_p);
        -:  374:        }
        -:  375:#endif /* JERRY_ESNEXT */
        -:  376:
       18:  377:        return scanner_primary_to_post_primary_expression (context_p, scanner_context_p);
        -:  378:      }
        -:  379:      /* FALLTHRU */
        -:  380:    }
        -:  381:    default:
        -:  382:    {
    #####:  383:      scanner_raise_error (context_p);
        -:  384:    }
        -:  385:  }
        8:  386:  return SCAN_NEXT_TOKEN;
        -:  387:} /* scanner_scan_primary_expression */
        -:  388:
        -:  389:/**
        -:  390: * Scan the tokens after the primary expression.
        -:  391: *
        -:  392: * @return true for break, false for fall through
        -:  393: */
        -:  394:static bool
      103:  395:scanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */
        -:  396:                                      scanner_context_t *scanner_context_p, /**< scanner context */
        -:  397:                                      lexer_token_type_t type, /**< current token type */
        -:  398:                                      scan_stack_modes_t stack_top) /**< current stack top */
        -:  399:{
      103:  400:  switch (type)
        -:  401:  {
        6:  402:    case LEXER_DOT:
        -:  403:    {
        6:  404:      lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
        -:  405:
        -:  406:#if JERRY_ESNEXT
        6:  407:      if (context_p->token.type == LEXER_HASHMARK)
        -:  408:      {
    #####:  409:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  410:        lexer_next_token (context_p);
        -:  411:      }
        -:  412:#endif /* JERRY_ESNEXT */
        -:  413:
        6:  414:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  415:      {
    #####:  416:        scanner_raise_error (context_p);
        -:  417:      }
        -:  418:
        6:  419:      return true;
        -:  420:    }
       27:  421:    case LEXER_LEFT_PAREN:
        -:  422:    {
       27:  423:      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
       27:  424:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
       27:  425:      return true;
        -:  426:    }
        -:  427:#if JERRY_ESNEXT
    #####:  428:    case LEXER_TEMPLATE_LITERAL:
        -:  429:    {
    #####:  430:      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))
        -:  431:      {
    #####:  432:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  433:        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);
        -:  434:      }
    #####:  435:      return true;
        -:  436:    }
        -:  437:#endif /* JERRY_ESNEXT */
        4:  438:    case LEXER_LEFT_SQUARE:
        -:  439:    {
        4:  440:      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);
        4:  441:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        4:  442:      return true;
        -:  443:    }
        1:  444:    case LEXER_INCREASE:
        -:  445:    case LEXER_DECREASE:
        -:  446:    {
        1:  447:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  448:
        1:  449:      if (context_p->token.flags & LEXER_WAS_NEWLINE)
        -:  450:      {
    #####:  451:        return false;
        -:  452:      }
        -:  453:
        1:  454:      lexer_next_token (context_p);
        1:  455:      type = (lexer_token_type_t) context_p->token.type;
        -:  456:
        1:  457:      if (type != LEXER_QUESTION_MARK)
        -:  458:      {
        1:  459:        break;
        -:  460:      }
        -:  461:      /* FALLTHRU */
        -:  462:    }
        -:  463:    case LEXER_QUESTION_MARK:
        -:  464:    {
    #####:  465:      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);
    #####:  466:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  467:      return true;
        -:  468:    }
       65:  469:    default:
        -:  470:    {
       65:  471:      break;
        -:  472:    }
        -:  473:  }
        -:  474:
       66:  475:  if (LEXER_IS_BINARY_OP_TOKEN (type) && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))
        -:  476:  {
        6:  477:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        6:  478:    return true;
        -:  479:  }
        -:  480:
       60:  481:  return false;
        -:  482:} /* scanner_scan_post_primary_expression */
        -:  483:
        -:  484:/**
        -:  485: * Scan the tokens after the primary expression.
        -:  486: *
        -:  487: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:  488: */
        -:  489:static scan_return_types_t
       72:  490:scanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */
        -:  491:                                     scanner_context_t *scanner_context_p, /**< scanner context */
        -:  492:                                     lexer_token_type_t type, /**< current token type */
        -:  493:                                     scan_stack_modes_t stack_top) /**< current stack top */
        -:  494:{
       72:  495:  if (type == LEXER_COMMA)
        -:  496:  {
    #####:  497:    switch (stack_top)
        -:  498:    {
    #####:  499:      case SCAN_STACK_VAR:
        -:  500:#if JERRY_ESNEXT
        -:  501:      case SCAN_STACK_LET:
        -:  502:      case SCAN_STACK_CONST:
        -:  503:#endif /* JERRY_ESNEXT */
        -:  504:      case SCAN_STACK_FOR_VAR_START:
        -:  505:#if JERRY_ESNEXT
        -:  506:      case SCAN_STACK_FOR_LET_START:
        -:  507:      case SCAN_STACK_FOR_CONST_START:
        -:  508:#endif /* JERRY_ESNEXT */
        -:  509:      {
    #####:  510:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####:  511:        return SCAN_NEXT_TOKEN;
        -:  512:      }
    #####:  513:      case SCAN_STACK_COLON_EXPRESSION:
        -:  514:      {
    #####:  515:        scanner_raise_error (context_p);
    #####:  516:        break;
        -:  517:      }
        -:  518:#if JERRY_ESNEXT
    #####:  519:      case SCAN_STACK_BINDING_INIT:
        -:  520:      case SCAN_STACK_BINDING_LIST_INIT:
        -:  521:      {
    #####:  522:        break;
        -:  523:      }
    #####:  524:      case SCAN_STACK_ARROW_ARGUMENTS:
        -:  525:      {
    #####:  526:        lexer_next_token (context_p);
    #####:  527:        scanner_check_arrow_arg (context_p, scanner_context_p);
    #####:  528:        return SCAN_KEEP_TOKEN;
        -:  529:      }
    #####:  530:      case SCAN_STACK_ARROW_EXPRESSION:
        -:  531:      {
    #####:  532:        break;
        -:  533:      }
    #####:  534:      case SCAN_STACK_CLASS_FIELD_INITIALIZER:
        -:  535:      {
    #####:  536:        scanner_raise_error (context_p);
    #####:  537:        break;
        -:  538:      }
    #####:  539:      case SCAN_STACK_FUNCTION_PARAMETERS:
        -:  540:      {
    #####:  541:        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
    #####:  542:        parser_stack_pop_uint8 (context_p);
    #####:  543:        return SCAN_NEXT_TOKEN;
        -:  544:      }
    #####:  545:      case SCAN_STACK_ARRAY_LITERAL:
        -:  546:      {
    #####:  547:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  548:
    #####:  549:        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  550:        {
    #####:  551:          scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  552:        }
        -:  553:
    #####:  554:        return SCAN_NEXT_TOKEN;
        -:  555:      }
        -:  556:#endif /* JERRY_ESNEXT */
    #####:  557:      case SCAN_STACK_OBJECT_LITERAL:
        -:  558:      {
    #####:  559:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####:  560:        return SCAN_KEEP_TOKEN;
        -:  561:      }
    #####:  562:      default:
        -:  563:      {
    #####:  564:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  565:        return SCAN_NEXT_TOKEN;
        -:  566:      }
        -:  567:    }
       72:  568:  }
        -:  569:
       72:  570:  switch (stack_top)
        -:  571:  {
    #####:  572:    case SCAN_STACK_WITH_EXPRESSION:
        -:  573:    {
    #####:  574:      if (type != LEXER_RIGHT_PAREN)
        -:  575:      {
    #####:  576:        break;
        -:  577:      }
        -:  578:
    #####:  579:      parser_stack_pop_uint8 (context_p);
        -:  580:
    #####:  581:      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;
    #####:  582:      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);
    #####:  583:      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);
    #####:  584:      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;
    #####:  585:      scanner_context_p->active_literal_pool_p->status_flags = status_flags;
        -:  586:
    #####:  587:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  588:      return SCAN_NEXT_TOKEN;
        -:  589:    }
    #####:  590:    case SCAN_STACK_DO_EXPRESSION:
        -:  591:    {
    #####:  592:      if (type != LEXER_RIGHT_PAREN)
        -:  593:      {
    #####:  594:        break;
        -:  595:      }
        -:  596:
    #####:  597:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####:  598:      return SCAN_NEXT_TOKEN;
        -:  599:    }
    #####:  600:    case SCAN_STACK_WHILE_EXPRESSION:
        -:  601:    {
    #####:  602:      if (type != LEXER_RIGHT_PAREN)
        -:  603:      {
    #####:  604:        break;
        -:  605:      }
        -:  606:
    #####:  607:      scanner_source_start_t source_start;
        -:  608:
    #####:  609:      parser_stack_pop_uint8 (context_p);
    #####:  610:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  611:
        -:  612:      scanner_location_info_t *location_info_p;
    #####:  613:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  614:                                                                         source_start.source_p,
        -:  615:                                                                         sizeof (scanner_location_info_t));
    #####:  616:      location_info_p->info.type = SCANNER_TYPE_WHILE;
        -:  617:
    #####:  618:      scanner_get_location (&location_info_p->location, context_p);
        -:  619:
    #####:  620:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  621:      return SCAN_NEXT_TOKEN;
        -:  622:    }
       13:  623:    case SCAN_STACK_PAREN_EXPRESSION:
        -:  624:    {
       13:  625:      if (type != LEXER_RIGHT_PAREN)
        -:  626:      {
    #####:  627:        break;
        -:  628:      }
        -:  629:
       13:  630:      parser_stack_pop_uint8 (context_p);
        -:  631:
        -:  632:#if JERRY_ESNEXT
       13:  633:      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  634:      {
    #####:  635:        scanner_add_async_literal (context_p, scanner_context_p);
        -:  636:      }
        -:  637:#endif /* JERRY_ESNEXT */
        -:  638:
       13:  639:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
       13:  640:      return SCAN_NEXT_TOKEN;
        -:  641:    }
    #####:  642:    case SCAN_STACK_STATEMENT_WITH_EXPR:
        -:  643:    {
    #####:  644:      if (type != LEXER_RIGHT_PAREN)
        -:  645:      {
    #####:  646:        break;
        -:  647:      }
        -:  648:
    #####:  649:      parser_stack_pop_uint8 (context_p);
        -:  650:
        -:  651:#if JERRY_ESNEXT
    #####:  652:      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)
        -:  653:      {
    #####:  654:        scanner_check_function_after_if (context_p, scanner_context_p);
    #####:  655:        return SCAN_KEEP_TOKEN;
        -:  656:      }
        -:  657:#endif /* JERRY_ESNEXT */
        -:  658:
    #####:  659:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  660:      return SCAN_NEXT_TOKEN;
        -:  661:    }
        -:  662:#if JERRY_ESNEXT
    #####:  663:    case SCAN_STACK_BINDING_LIST_INIT:
        -:  664:    {
    #####:  665:      parser_stack_pop_uint8 (context_p);
        -:  666:
    #####:  667:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  668:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  669:                    || context_p->stack_top_uint8 == SCAN_STACK_LET || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  670:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  671:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  672:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  673:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  674:
    #####:  675:      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -:  676:
    #####:  677:      while (item_p != NULL)
        -:  678:      {
    #####:  679:        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  680:        {
    #####:  681:          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  682:        }
    #####:  683:        item_p = item_p->next_p;
        -:  684:      }
        -:  685:
    #####:  686:      scanner_pop_binding_list (scanner_context_p);
    #####:  687:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  688:      return SCAN_KEEP_TOKEN;
        -:  689:    }
        3:  690:    case SCAN_STACK_BINDING_INIT:
        -:  691:    {
        3:  692:      scanner_binding_literal_t binding_literal;
        -:  693:
        3:  694:      parser_stack_pop_uint8 (context_p);
        3:  695:      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
        -:  696:
        3:  697:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  698:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  699:                    || context_p->stack_top_uint8 == SCAN_STACK_LET || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  700:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  701:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  702:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  703:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  704:
        3:  705:      JERRY_ASSERT (SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type)
        -:  706:                    || (stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL));
        -:  707:
        3:  708:      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  709:      {
    #####:  710:        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  711:      }
        -:  712:
        3:  713:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        3:  714:      return SCAN_KEEP_TOKEN;
        -:  715:    }
        -:  716:#endif /* JERRY_ESNEXT */
        1:  717:    case SCAN_STACK_VAR:
        -:  718:#if JERRY_ESNEXT
        -:  719:    case SCAN_STACK_LET:
        -:  720:    case SCAN_STACK_CONST:
        -:  721:#endif /* JERRY_ESNEXT */
        -:  722:    {
        -:  723:#if JERRY_MODULE_SYSTEM
        1:  724:      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -:  725:#endif /* JERRY_MODULE_SYSTEM */
        -:  726:
        1:  727:      parser_stack_pop_uint8 (context_p);
        1:  728:      return SCAN_KEEP_TOKEN;
        -:  729:    }
        1:  730:    case SCAN_STACK_FOR_VAR_START:
        -:  731:#if JERRY_ESNEXT
        -:  732:    case SCAN_STACK_FOR_LET_START:
        -:  733:    case SCAN_STACK_FOR_CONST_START:
        -:  734:#endif /* JERRY_ESNEXT */
        -:  735:    case SCAN_STACK_FOR_START:
        -:  736:    {
        1:  737:      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())
        -:  738:      {
    #####:  739:        scanner_for_statement_t for_statement;
        -:  740:
    #####:  741:        parser_stack_pop_uint8 (context_p);
    #####:  742:        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  743:
        -:  744:        scanner_location_info_t *location_info;
    #####:  745:        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  746:                                                                         for_statement.u.source_p,
        -:  747:                                                                         sizeof (scanner_location_info_t));
        -:  748:#if JERRY_ESNEXT
    #####:  749:        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;
        -:  750:
    #####:  751:        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  752:        {
    #####:  753:          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);
        -:  754:        }
        -:  755:#else /* !JERRY_ESNEXT */
    #####:  756:        location_info->info.type = SCANNER_TYPE_FOR_IN;
        -:  757:#endif /* JERRY_ESNEXT */
        -:  758:
    #####:  759:        scanner_get_location (&location_info->location, context_p);
        -:  760:
    #####:  761:        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);
    #####:  762:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  763:        return SCAN_NEXT_TOKEN;
        -:  764:      }
        -:  765:
        1:  766:      if (type != LEXER_SEMICOLON)
        -:  767:      {
    #####:  768:        break;
        -:  769:      }
        -:  770:
        1:  771:      scanner_for_statement_t for_statement;
        -:  772:
        1:  773:      parser_stack_pop_uint8 (context_p);
        1:  774:      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));
        -:  775:
        -:  776:#if JERRY_ESNEXT
        1:  777:      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  778:      {
        1:  779:        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  780:      }
        -:  781:#endif /* JERRY_ESNEXT */
        -:  782:
        1:  783:      for_statement.u.source_p = context_p->source_p;
        1:  784:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
        1:  785:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);
        -:  786:
        1:  787:      lexer_next_token (context_p);
        -:  788:
        1:  789:      if (context_p->token.type != LEXER_SEMICOLON)
        -:  790:      {
        1:  791:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  792:        return SCAN_KEEP_TOKEN;
        -:  793:      }
        -:  794:
    #####:  795:      type = LEXER_SEMICOLON;
        -:  796:      /* FALLTHRU */
        -:  797:    }
        -:  798:    case SCAN_STACK_FOR_CONDITION:
        -:  799:    {
        1:  800:      if (type != LEXER_SEMICOLON)
        -:  801:      {
    #####:  802:        break;
        -:  803:      }
        -:  804:
        1:  805:      scanner_for_statement_t for_statement;
        -:  806:
        1:  807:      parser_stack_pop_uint8 (context_p);
        1:  808:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  809:
        -:  810:      scanner_for_info_t *for_info_p;
        1:  811:      for_info_p =
        1:  812:        (scanner_for_info_t *) scanner_insert_info (context_p, for_statement.u.source_p, sizeof (scanner_for_info_t));
        1:  813:      for_info_p->info.type = SCANNER_TYPE_FOR;
        -:  814:
        1:  815:      scanner_get_location (&for_info_p->expression_location, context_p);
        1:  816:      for_info_p->end_location.source_p = NULL;
        -:  817:
        1:  818:      for_statement.u.for_info_p = for_info_p;
        -:  819:
        1:  820:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
        1:  821:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);
        -:  822:
        1:  823:      lexer_next_token (context_p);
        -:  824:
        1:  825:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  826:      {
        1:  827:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  828:        return SCAN_KEEP_TOKEN;
        -:  829:      }
        -:  830:
    #####:  831:      type = LEXER_RIGHT_PAREN;
        -:  832:      /* FALLTHRU */
        -:  833:    }
        -:  834:    case SCAN_STACK_FOR_EXPRESSION:
        -:  835:    {
        1:  836:      if (type != LEXER_RIGHT_PAREN)
        -:  837:      {
    #####:  838:        break;
        -:  839:      }
        -:  840:
        1:  841:      scanner_for_statement_t for_statement;
        -:  842:
        1:  843:      parser_stack_pop_uint8 (context_p);
        1:  844:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  845:
        1:  846:      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);
        -:  847:
        1:  848:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
        1:  849:      return SCAN_NEXT_TOKEN;
        -:  850:    }
    #####:  851:    case SCAN_STACK_SWITCH_EXPRESSION:
        -:  852:    {
    #####:  853:      if (type != LEXER_RIGHT_PAREN)
        -:  854:      {
    #####:  855:        break;
        -:  856:      }
        -:  857:
    #####:  858:      lexer_next_token (context_p);
        -:  859:
    #####:  860:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  861:      {
    #####:  862:        break;
        -:  863:      }
        -:  864:
        -:  865:#if JERRY_ESNEXT
        -:  866:      scanner_literal_pool_t *literal_pool_p;
    #####:  867:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####:  868:      literal_pool_p->source_p = context_p->source_p - 1;
        -:  869:#endif /* JERRY_ESNEXT */
        -:  870:
    #####:  871:      parser_stack_pop_uint8 (context_p);
        -:  872:
    #####:  873:      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;
    #####:  874:      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
    #####:  875:      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);
        -:  876:
        -:  877:      scanner_switch_info_t *switch_info_p;
    #####:  878:      switch_info_p =
    #####:  879:        (scanner_switch_info_t *) scanner_insert_info (context_p, context_p->source_p, sizeof (scanner_switch_info_t));
    #####:  880:      switch_info_p->info.type = SCANNER_TYPE_SWITCH;
    #####:  881:      switch_info_p->case_p = NULL;
    #####:  882:      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;
        -:  883:
    #####:  884:      lexer_next_token (context_p);
        -:  885:
    #####:  886:      if (context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_KEYW_CASE
    #####:  887:          && context_p->token.type != LEXER_KEYW_DEFAULT)
        -:  888:      {
    #####:  889:        break;
        -:  890:      }
        -:  891:
    #####:  892:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  893:      return SCAN_KEEP_TOKEN;
        -:  894:    }
    #####:  895:    case SCAN_STACK_CASE_STATEMENT:
        -:  896:    {
    #####:  897:      if (type != LEXER_COLON)
        -:  898:      {
    #####:  899:        break;
        -:  900:      }
        -:  901:
    #####:  902:      scanner_source_start_t source_start;
        -:  903:
    #####:  904:      parser_stack_pop_uint8 (context_p);
    #####:  905:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  906:
        -:  907:      scanner_location_info_t *location_info_p;
    #####:  908:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  909:                                                                         source_start.source_p,
        -:  910:                                                                         sizeof (scanner_location_info_t));
    #####:  911:      location_info_p->info.type = SCANNER_TYPE_CASE;
        -:  912:
    #####:  913:      scanner_get_location (&location_info_p->location, context_p);
        -:  914:
    #####:  915:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  916:      return SCAN_NEXT_TOKEN;
        -:  917:    }
    #####:  918:    case SCAN_STACK_COLON_EXPRESSION:
        -:  919:    {
    #####:  920:      if (type != LEXER_COLON)
        -:  921:      {
    #####:  922:        break;
        -:  923:      }
        -:  924:
    #####:  925:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  926:      parser_stack_pop_uint8 (context_p);
    #####:  927:      return SCAN_NEXT_TOKEN;
        -:  928:    }
        -:  929:#if JERRY_ESNEXT
    #####:  930:    case SCAN_STACK_ARRAY_LITERAL:
        -:  931:    case SCAN_STACK_OBJECT_LITERAL:
        -:  932:    {
    #####:  933:      if ((stack_top == SCAN_STACK_ARRAY_LITERAL && type != LEXER_RIGHT_SQUARE)
    #####:  934:          || (stack_top == SCAN_STACK_OBJECT_LITERAL && type != LEXER_RIGHT_BRACE))
        -:  935:      {
        -:  936:        break;
        -:  937:      }
        -:  938:
    #####:  939:      scanner_source_start_t source_start;
    #####:  940:      uint8_t binding_type = scanner_context_p->binding_type;
    #####:  941:      uint8_t object_literal_flags = 0;
        -:  942:
    #####:  943:      parser_stack_pop_uint8 (context_p);
        -:  944:
    #####:  945:      if (stack_top == SCAN_STACK_OBJECT_LITERAL)
        -:  946:      {
    #####:  947:        object_literal_flags = context_p->stack_top_uint8;
    #####:  948:        parser_stack_pop_uint8 (context_p);
        -:  949:      }
        -:  950:
    #####:  951:      scanner_context_p->binding_type = context_p->stack_top_uint8;
    #####:  952:      parser_stack_pop_uint8 (context_p);
    #####:  953:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  954:
    #####:  955:      lexer_next_token (context_p);
        -:  956:
    #####:  957:      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -:  958:
    #####:  959:      if (binding_type == SCANNER_BINDING_CATCH && stack_top == SCAN_STACK_CATCH_STATEMENT)
        -:  960:      {
    #####:  961:        scanner_pop_binding_list (scanner_context_p);
        -:  962:
        -:  963:#if JERRY_ESNEXT
    #####:  964:        if (object_literal_flags != 0)
        -:  965:        {
    #####:  966:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####:  967:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####:  968:          info_p->u8_arg = object_literal_flags;
        -:  969:        }
        -:  970:#endif /* JERRY_ESNEXT */
        -:  971:
    #####:  972:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  973:        {
    #####:  974:          scanner_raise_error (context_p);
        -:  975:        }
        -:  976:
    #####:  977:        lexer_next_token (context_p);
        -:  978:
    #####:  979:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  980:        {
    #####:  981:          scanner_raise_error (context_p);
        -:  982:        }
        -:  983:
    #####:  984:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  985:        return SCAN_NEXT_TOKEN;
        -:  986:      }
        -:  987:
    #####:  988:      if (stack_top == SCAN_STACK_FOR_START_PATTERN)
        -:  989:      {
    #####:  990:        JERRY_ASSERT (binding_type == SCANNER_BINDING_NONE);
        -:  991:
    #####:  992:        parser_stack_change_last_uint8 (context_p, SCAN_STACK_FOR_START);
        -:  993:
    #####:  994:        if (context_p->token.type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())
        -:  995:        {
    #####:  996:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####:  997:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####:  998:          info_p->u8_arg = object_literal_flags | SCANNER_LITERAL_DESTRUCTURING_FOR;
    #####:  999:          return SCAN_KEEP_TOKEN;
        -: 1000:        }
        -: 1001:      }
        -: 1002:
    #####: 1003:      if (context_p->token.type != LEXER_ASSIGN)
        -: 1004:      {
    #####: 1005:        if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1006:        {
    #####: 1007:          scanner_pop_binding_list (scanner_context_p);
        -: 1008:        }
        -: 1009:
        -: 1010:#if JERRY_ESNEXT
    #####: 1011:        if ((stack_top == SCAN_STACK_ARRAY_LITERAL || stack_top == SCAN_STACK_OBJECT_LITERAL)
    #####: 1012:            && (binding_type == SCANNER_BINDING_NONE || binding_type == SCANNER_BINDING_ARROW_ARG)
    #####: 1013:            && context_p->token.type != LEXER_EOS && context_p->token.type != LEXER_COMMA
    #####: 1014:            && context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 1015:        {
    #####: 1016:          object_literal_flags |= SCANNER_LITERAL_NO_DESTRUCTURING;
        -: 1017:        }
        -: 1018:
    #####: 1019:        if (object_literal_flags != 0)
        -: 1020:        {
    #####: 1021:          scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####: 1022:          info_p->type = SCANNER_TYPE_LITERAL_FLAGS;
    #####: 1023:          info_p->u8_arg = object_literal_flags;
        -: 1024:        }
        -: 1025:#endif /* JERRY_ESNEXT */
        -: 1026:
    #####: 1027:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1028:        return SCAN_KEEP_TOKEN;
        -: 1029:      }
        -: 1030:
        -: 1031:      scanner_location_info_t *location_info_p;
    #####: 1032:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -: 1033:                                                                         source_start.source_p,
        -: 1034:                                                                         sizeof (scanner_location_info_t));
    #####: 1035:      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;
    #####: 1036:      location_info_p->info.u8_arg = object_literal_flags;
    #####: 1037:      scanner_get_location (&location_info_p->location, context_p);
    #####: 1038:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1039:
    #####: 1040:      if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1041:      {
    #####: 1042:        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -: 1043:
    #####: 1044:        while (item_p != NULL)
        -: 1045:        {
    #####: 1046:          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;
    #####: 1047:          item_p = item_p->next_p;
        -: 1048:        }
        -: 1049:
    #####: 1050:        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);
        -: 1051:      }
    #####: 1052:      return SCAN_NEXT_TOKEN;
        -: 1053:    }
        -: 1054:#else /* !JERRY_ESNEXT */
    #####: 1055:    case SCAN_STACK_OBJECT_LITERAL:
        -: 1056:    {
    #####: 1057:      if (type != LEXER_RIGHT_BRACE)
        -: 1058:      {
        -: 1059:        break;
        -: 1060:      }
        -: 1061:
    #####: 1062:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1063:      parser_stack_pop_uint8 (context_p);
    #####: 1064:      return SCAN_NEXT_TOKEN;
        -: 1065:    }
    #####: 1066:    case SCAN_STACK_ARRAY_LITERAL:
        -: 1067:#endif /* JERRY_ESNEXT */
        4: 1068:    case SCAN_STACK_PROPERTY_ACCESSOR:
        -: 1069:    {
        4: 1070:      if (type != LEXER_RIGHT_SQUARE)
        -: 1071:      {
    #####: 1072:        break;
        -: 1073:      }
        -: 1074:
        4: 1075:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        4: 1076:      parser_stack_pop_uint8 (context_p);
        4: 1077:      return SCAN_NEXT_TOKEN;
        -: 1078:    }
        -: 1079:#if JERRY_ESNEXT
    #####: 1080:    case SCAN_STACK_COMPUTED_PROPERTY:
        -: 1081:    {
    #####: 1082:      if (type != LEXER_RIGHT_SQUARE)
        -: 1083:      {
    #####: 1084:        break;
        -: 1085:      }
        -: 1086:
    #####: 1087:      lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
        -: 1088:
    #####: 1089:      parser_stack_pop_uint8 (context_p);
    #####: 1090:      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -: 1091:
    #####: 1092:      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)
        -: 1093:      {
    #####: 1094:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 1095:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1096:        return SCAN_KEEP_TOKEN;
        -: 1097:      }
        -: 1098:
    #####: 1099:      if (stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR || stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 1100:      {
    #####: 1101:        JERRY_ASSERT (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);
        -: 1102:
    #####: 1103:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1104:        {
    #####: 1105:          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -: 1106:
    #####: 1107:          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 1108:          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1109:          return SCAN_KEEP_TOKEN;
        -: 1110:        }
        -: 1111:
    #####: 1112:        if (context_p->token.type == LEXER_ASSIGN)
        -: 1113:        {
    #####: 1114:          scanner_push_class_field_initializer (context_p, scanner_context_p);
    #####: 1115:          return SCAN_NEXT_TOKEN;
        -: 1116:        }
        -: 1117:
    #####: 1118:        scanner_context_p->mode =
    #####: 1119:          (context_p->token.type != LEXER_SEMICOLON ? SCAN_MODE_CLASS_BODY_NO_SCAN : SCAN_MODE_CLASS_BODY);
    #####: 1120:        return SCAN_KEEP_TOKEN;
        -: 1121:      }
        -: 1122:
    #####: 1123:      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -: 1124:
    #####: 1125:      if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1126:      {
    #####: 1127:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -: 1128:
    #####: 1129:        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 1130:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1131:        return SCAN_KEEP_TOKEN;
        -: 1132:      }
        -: 1133:
    #####: 1134:      if (context_p->token.type != LEXER_COLON)
        -: 1135:      {
    #####: 1136:        scanner_raise_error (context_p);
        -: 1137:      }
        -: 1138:
    #####: 1139:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1140:
    #####: 1141:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -: 1142:      {
    #####: 1143:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -: 1144:      }
    #####: 1145:      return SCAN_NEXT_TOKEN;
        -: 1146:    }
    #####: 1147:    case SCAN_STACK_COMPUTED_GENERATOR:
        -: 1148:    case SCAN_STACK_COMPUTED_ASYNC:
        -: 1149:    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:
        -: 1150:    {
    #####: 1151:      if (type != LEXER_RIGHT_SQUARE)
        -: 1152:      {
    #####: 1153:        break;
        -: 1154:      }
        -: 1155:
    #####: 1156:      lexer_next_token (context_p);
    #####: 1157:      parser_stack_pop_uint8 (context_p);
        -: 1158:
    #####: 1159:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -: 1160:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);
        -: 1161:
    #####: 1162:      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_GENERATOR
    #####: 1163:                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));
        -: 1164:
    #####: 1165:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -: 1166:
    #####: 1167:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1168:      return SCAN_KEEP_TOKEN;
        -: 1169:    }
    #####: 1170:    case SCAN_STACK_TEMPLATE_STRING:
        -: 1171:    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:
        -: 1172:    {
    #####: 1173:      if (type != LEXER_RIGHT_BRACE)
        -: 1174:      {
    #####: 1175:        break;
        -: 1176:      }
        -: 1177:
    #####: 1178:      context_p->source_p--;
    #####: 1179:      context_p->column--;
    #####: 1180:      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1181:
    #####: 1182:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1183:      {
    #####: 1184:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1185:      }
        -: 1186:      else
        -: 1187:      {
    #####: 1188:        parser_stack_pop_uint8 (context_p);
    #####: 1189:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 1190:      }
    #####: 1191:      return SCAN_NEXT_TOKEN;
        -: 1192:    }
        4: 1193:    case SCAN_STACK_ARROW_ARGUMENTS:
        -: 1194:    {
        4: 1195:      if (type != LEXER_RIGHT_PAREN)
        -: 1196:      {
    #####: 1197:        break;
        -: 1198:      }
        -: 1199:
        4: 1200:      scanner_check_arrow (context_p, scanner_context_p);
        4: 1201:      return SCAN_KEEP_TOKEN;
        -: 1202:    }
        4: 1203:    case SCAN_STACK_ARROW_EXPRESSION:
        -: 1204:    {
        4: 1205:      scanner_pop_literal_pool (context_p, scanner_context_p);
        4: 1206:      parser_stack_pop_uint8 (context_p);
        4: 1207:      lexer_update_await_yield (context_p, context_p->status_flags);
        4: 1208:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        4: 1209:      return SCAN_KEEP_TOKEN;
        -: 1210:    }
        8: 1211:    case SCAN_STACK_CLASS_EXTENDS:
        -: 1212:    {
        8: 1213:      if (type != LEXER_LEFT_BRACE)
        -: 1214:      {
    #####: 1215:        break;
        -: 1216:      }
        -: 1217:
        8: 1218:      scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
        8: 1219:      parser_stack_pop_uint8 (context_p);
        -: 1220:
        8: 1221:      return SCAN_KEEP_TOKEN;
        -: 1222:    }
    #####: 1223:    case SCAN_STACK_CLASS_FIELD_INITIALIZER:
        -: 1224:    {
    #####: 1225:      scanner_source_start_t source_start;
    #####: 1226:      const uint8_t *source_p = NULL;
        -: 1227:
    #####: 1228:      parser_stack_pop_uint8 (context_p);
    #####: 1229:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1230:      scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1231:      scanner_context_p->mode = SCAN_MODE_CLASS_BODY_NO_SCAN;
        -: 1232:
    #####: 1233:      switch (type)
        -: 1234:      {
    #####: 1235:        case LEXER_SEMICOLON:
        -: 1236:        {
    #####: 1237:          source_p = context_p->source_p - 1;
    #####: 1238:          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
    #####: 1239:          break;
        -: 1240:        }
    #####: 1241:        case LEXER_RIGHT_BRACE:
        -: 1242:        {
    #####: 1243:          source_p = context_p->source_p - 1;
    #####: 1244:          break;
        -: 1245:        }
    #####: 1246:        default:
        -: 1247:        {
    #####: 1248:          if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 1249:          {
    #####: 1250:            break;
        -: 1251:          }
        -: 1252:
    #####: 1253:          if (type == LEXER_LEFT_SQUARE)
        -: 1254:          {
    #####: 1255:            source_p = context_p->source_p - 1;
    #####: 1256:            break;
        -: 1257:          }
        -: 1258:
    #####: 1259:          if (type == LEXER_LITERAL)
        -: 1260:          {
    #####: 1261:            if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1262:                || context_p->token.lit_location.type == LEXER_NUMBER_LITERAL)
        -: 1263:            {
    #####: 1264:              source_p = context_p->token.lit_location.char_p;
        -: 1265:            }
    #####: 1266:            else if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1267:            {
    #####: 1268:              source_p = context_p->token.lit_location.char_p - 1;
        -: 1269:            }
    #####: 1270:            break;
        -: 1271:          }
        -: 1272:
    #####: 1273:          if (type == context_p->token.keyword_type && type != LEXER_EOS)
        -: 1274:          {
        -: 1275:            /* Convert keyword to literal. */
    #####: 1276:            source_p = context_p->token.lit_location.char_p;
    #####: 1277:            context_p->token.type = LEXER_LITERAL;
        -: 1278:          }
    #####: 1279:          break;
        -: 1280:        }
        -: 1281:      }
        -: 1282:
    #####: 1283:      if (JERRY_UNLIKELY (source_p == NULL))
        -: 1284:      {
    #####: 1285:        scanner_raise_error (context_p);
        -: 1286:      }
        -: 1287:
        -: 1288:      scanner_location_info_t *location_info_p;
    #####: 1289:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -: 1290:                                                                         source_start.source_p,
        -: 1291:                                                                         sizeof (scanner_location_info_t));
    #####: 1292:      location_info_p->info.type = SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END;
    #####: 1293:      location_info_p->location.source_p = source_p;
    #####: 1294:      location_info_p->location.line = context_p->token.line;
    #####: 1295:      location_info_p->location.column = context_p->token.column;
    #####: 1296:      return SCAN_KEEP_TOKEN;
        -: 1297:    }
        1: 1298:    case SCAN_STACK_FUNCTION_PARAMETERS:
        -: 1299:    {
        1: 1300:      parser_stack_pop_uint8 (context_p);
        -: 1301:
        1: 1302:      if (type != LEXER_RIGHT_PAREN && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))
        -: 1303:      {
        -: 1304:        break;
        -: 1305:      }
        -: 1306:
        1: 1307:      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
        1: 1308:      return SCAN_KEEP_TOKEN;
        -: 1309:    }
        -: 1310:#endif /* JERRY_ESNEXT */
       31: 1311:    default:
        -: 1312:    {
       31: 1313:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
       31: 1314:      return SCAN_KEEP_TOKEN;
        -: 1315:    }
        -: 1316:  }
        -: 1317:
    #####: 1318:  scanner_raise_error (context_p);
    #####: 1319:  return SCAN_NEXT_TOKEN;
        -: 1320:} /* scanner_scan_primary_expression_end */
        -: 1321:
        -: 1322:/**
        -: 1323: * Scan statements.
        -: 1324: *
        -: 1325: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 1326: */
        -: 1327:static scan_return_types_t
       47: 1328:scanner_scan_statement (parser_context_t *context_p, /**< context */
        -: 1329:                        scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1330:                        lexer_token_type_t type, /**< current token type */
        -: 1331:                        scan_stack_modes_t stack_top) /**< current stack top */
        -: 1332:{
       47: 1333:  switch (type)
        -: 1334:  {
        1: 1335:    case LEXER_SEMICOLON:
        -: 1336:    {
        1: 1337:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        1: 1338:      return SCAN_KEEP_TOKEN;
        -: 1339:    }
        1: 1340:    case LEXER_LEFT_BRACE:
        -: 1341:    {
        -: 1342:#if JERRY_ESNEXT
        -: 1343:      scanner_literal_pool_t *literal_pool_p;
        1: 1344:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 1345:      literal_pool_p->source_p = context_p->source_p;
        -: 1346:#endif /* JERRY_ESNEXT */
        -: 1347:
        1: 1348:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 1349:      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
        1: 1350:      return SCAN_NEXT_TOKEN;
        -: 1351:    }
    #####: 1352:    case LEXER_KEYW_DO:
        -: 1353:    {
    #####: 1354:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 1355:      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);
    #####: 1356:      return SCAN_NEXT_TOKEN;
        -: 1357:    }
        1: 1358:    case LEXER_KEYW_TRY:
        -: 1359:    {
        1: 1360:      lexer_next_token (context_p);
        -: 1361:
        1: 1362:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1363:      {
    #####: 1364:        scanner_raise_error (context_p);
        -: 1365:      }
        -: 1366:
        -: 1367:#if JERRY_ESNEXT
        -: 1368:      scanner_literal_pool_t *literal_pool_p;
        1: 1369:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 1370:      literal_pool_p->source_p = context_p->source_p;
        -: 1371:#endif /* JERRY_ESNEXT */
        -: 1372:
        1: 1373:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 1374:      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);
        1: 1375:      return SCAN_NEXT_TOKEN;
        -: 1376:    }
    #####: 1377:    case LEXER_KEYW_DEBUGGER:
        -: 1378:    {
    #####: 1379:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1380:      return SCAN_NEXT_TOKEN;
        -: 1381:    }
    #####: 1382:    case LEXER_KEYW_IF:
        -: 1383:    case LEXER_KEYW_WITH:
        -: 1384:    case LEXER_KEYW_SWITCH:
        -: 1385:    {
    #####: 1386:      lexer_next_token (context_p);
    #####: 1387:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1388:      {
    #####: 1389:        scanner_raise_error (context_p);
        -: 1390:      }
        -: 1391:
    #####: 1392:      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;
        -: 1393:
    #####: 1394:      if (type == LEXER_KEYW_IF)
        -: 1395:      {
    #####: 1396:        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);
        -: 1397:      }
    #####: 1398:      else if (type == LEXER_KEYW_WITH)
        -: 1399:      {
    #####: 1400:        mode = SCAN_STACK_WITH_EXPRESSION;
        -: 1401:      }
    #####: 1402:      else if (type == LEXER_KEYW_SWITCH)
        -: 1403:      {
    #####: 1404:        mode = SCAN_STACK_SWITCH_EXPRESSION;
        -: 1405:      }
        -: 1406:
    #####: 1407:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1408:      parser_stack_push_uint8 (context_p, mode);
    #####: 1409:      return SCAN_NEXT_TOKEN;
        -: 1410:    }
    #####: 1411:    case LEXER_KEYW_WHILE:
        -: 1412:    {
    #####: 1413:      lexer_next_token (context_p);
        -: 1414:
    #####: 1415:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1416:      {
    #####: 1417:        scanner_raise_error (context_p);
        -: 1418:      }
        -: 1419:
    #####: 1420:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1421:
    #####: 1422:      scanner_source_start_t source_start;
    #####: 1423:      source_start.source_p = context_p->source_p;
        -: 1424:
    #####: 1425:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1426:      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);
    #####: 1427:      return SCAN_NEXT_TOKEN;
        -: 1428:    }
        1: 1429:    case LEXER_KEYW_FOR:
        -: 1430:    {
        1: 1431:      lexer_next_token (context_p);
        -: 1432:
        -: 1433:#if JERRY_ESNEXT
        1: 1434:      if (context_p->token.type == LEXER_KEYW_AWAIT)
        -: 1435:      {
    #####: 1436:        lexer_next_token (context_p);
        -: 1437:      }
        -: 1438:#endif /* JERRY_ESNEXT */
        -: 1439:
        1: 1440:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1441:      {
    #####: 1442:        scanner_raise_error (context_p);
        -: 1443:      }
        -: 1444:
        1: 1445:      scanner_for_statement_t for_statement;
        1: 1446:      for_statement.u.source_p = context_p->source_p;
        1: 1447:      uint8_t stack_mode = SCAN_STACK_FOR_START;
        1: 1448:      scan_return_types_t return_type = SCAN_KEEP_TOKEN;
        -: 1449:
        1: 1450:      lexer_next_token (context_p);
        1: 1451:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1452:
        -: 1453:#if JERRY_ESNEXT
        1: 1454:      const uint8_t *source_p = context_p->source_p;
        -: 1455:#endif /* JERRY_ESNEXT */
        -: 1456:
        1: 1457:      switch (context_p->token.type)
        -: 1458:      {
    #####: 1459:        case LEXER_SEMICOLON:
        -: 1460:        {
    #####: 1461:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 1462:          break;
        -: 1463:        }
    #####: 1464:        case LEXER_KEYW_VAR:
        -: 1465:        {
    #####: 1466:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1467:          stack_mode = SCAN_STACK_FOR_VAR_START;
    #####: 1468:          return_type = SCAN_NEXT_TOKEN;
    #####: 1469:          break;
        -: 1470:        }
        -: 1471:#if JERRY_ESNEXT
    #####: 1472:        case LEXER_LEFT_BRACE:
        -: 1473:        case LEXER_LEFT_SQUARE:
        -: 1474:        {
    #####: 1475:          stack_mode = SCAN_STACK_FOR_START_PATTERN;
    #####: 1476:          break;
        -: 1477:        }
        1: 1478:        case LEXER_LITERAL:
        -: 1479:        {
        1: 1480:          if (!lexer_token_is_let (context_p))
        -: 1481:          {
    #####: 1482:            break;
        -: 1483:          }
        -: 1484:
        1: 1485:          parser_line_counter_t line = context_p->line;
        1: 1486:          parser_line_counter_t column = context_p->column;
        -: 1487:
        1: 1488:          if (lexer_check_arrow (context_p))
        -: 1489:          {
    #####: 1490:            context_p->source_p = source_p;
    #####: 1491:            context_p->line = line;
    #####: 1492:            context_p->column = column;
    #####: 1493:            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;
    #####: 1494:            break;
        -: 1495:          }
        -: 1496:
        1: 1497:          lexer_next_token (context_p);
        -: 1498:
        1: 1499:          type = (lexer_token_type_t) context_p->token.type;
        -: 1500:
        1: 1501:          if (type != LEXER_LEFT_SQUARE && type != LEXER_LEFT_BRACE
        1: 1502:              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))
        -: 1503:          {
    #####: 1504:            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 1505:            info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 1506:
    #####: 1507:            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1508:            break;
        -: 1509:          }
        -: 1510:
        1: 1511:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        -: 1512:          /* FALLTHRU */
        -: 1513:        }
        1: 1514:        case LEXER_KEYW_LET:
        -: 1515:        case LEXER_KEYW_CONST:
        -: 1516:        {
        -: 1517:          scanner_literal_pool_t *literal_pool_p;
        1: 1518:          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 1519:          literal_pool_p->source_p = source_p;
        -: 1520:
        1: 1521:          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)
        -: 1522:          {
    #####: 1523:            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1524:            return_type = SCAN_NEXT_TOKEN;
        -: 1525:          }
        -: 1526:
        1: 1527:          stack_mode =
        1: 1528:            ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START : SCAN_STACK_FOR_LET_START);
        1: 1529:          break;
        -: 1530:        }
        -: 1531:#endif /* JERRY_ESNEXT */
        -: 1532:      }
        -: 1533:
        1: 1534:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
        1: 1535:      parser_stack_push_uint8 (context_p, stack_mode);
        1: 1536:      return return_type;
        -: 1537:    }
    #####: 1538:    case LEXER_KEYW_VAR:
        -: 1539:    {
    #####: 1540:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1541:      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);
    #####: 1542:      return SCAN_NEXT_TOKEN;
        -: 1543:    }
        -: 1544:#if JERRY_ESNEXT
    #####: 1545:    case LEXER_KEYW_LET:
        -: 1546:    {
    #####: 1547:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1548:      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
    #####: 1549:      return SCAN_NEXT_TOKEN;
        -: 1550:    }
    #####: 1551:    case LEXER_KEYW_CONST:
        -: 1552:    {
    #####: 1553:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1554:      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);
    #####: 1555:      return SCAN_NEXT_TOKEN;
        -: 1556:    }
        -: 1557:#endif /* JERRY_ESNEXT */
    #####: 1558:    case LEXER_KEYW_THROW:
        -: 1559:    {
    #####: 1560:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1561:      return SCAN_NEXT_TOKEN;
        -: 1562:    }
        2: 1563:    case LEXER_KEYW_RETURN:
        -: 1564:    {
        2: 1565:      lexer_next_token (context_p);
        -: 1566:
        2: 1567:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE) && context_p->token.type != LEXER_SEMICOLON
        2: 1568:          && context_p->token.type != LEXER_EOS && context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1569:      {
        2: 1570:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        2: 1571:        return SCAN_KEEP_TOKEN;
        -: 1572:      }
        -: 1573:
    #####: 1574:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1575:      return SCAN_KEEP_TOKEN;
        -: 1576:    }
    #####: 1577:    case LEXER_KEYW_BREAK:
        -: 1578:    case LEXER_KEYW_CONTINUE:
        -: 1579:    {
    #####: 1580:      lexer_next_token (context_p);
    #####: 1581:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1582:
    #####: 1583:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE) && context_p->token.type == LEXER_LITERAL
    #####: 1584:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1585:      {
    #####: 1586:        return SCAN_NEXT_TOKEN;
        -: 1587:      }
    #####: 1588:      return SCAN_KEEP_TOKEN;
        -: 1589:    }
    #####: 1590:    case LEXER_KEYW_CASE:
        -: 1591:    case LEXER_KEYW_DEFAULT:
        -: 1592:    {
    #####: 1593:      if (stack_top != SCAN_STACK_SWITCH_BLOCK)
        -: 1594:      {
    #####: 1595:        scanner_raise_error (context_p);
        -: 1596:      }
        -: 1597:
        -: 1598:      scanner_case_info_t *case_info_p;
    #####: 1599:      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));
        -: 1600:
    #####: 1601:      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;
    #####: 1602:      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;
        -: 1603:
    #####: 1604:      case_info_p->next_p = NULL;
    #####: 1605:      scanner_get_location (&case_info_p->location, context_p);
        -: 1606:
    #####: 1607:      if (type == LEXER_KEYW_DEFAULT)
        -: 1608:      {
    #####: 1609:        lexer_next_token (context_p);
        -: 1610:
    #####: 1611:        if (context_p->token.type != LEXER_COLON)
        -: 1612:        {
    #####: 1613:          scanner_raise_error (context_p);
        -: 1614:        }
        -: 1615:
    #####: 1616:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 1617:        return SCAN_NEXT_TOKEN;
        -: 1618:      }
        -: 1619:
    #####: 1620:      scanner_source_start_t source_start;
    #####: 1621:      source_start.source_p = context_p->source_p;
        -: 1622:
    #####: 1623:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1624:      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);
        -: 1625:
    #####: 1626:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1627:      return SCAN_NEXT_TOKEN;
        -: 1628:    }
        3: 1629:    case LEXER_KEYW_FUNCTION:
        -: 1630:    {
        -: 1631:#if JERRY_ESNEXT
        3: 1632:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;
        -: 1633:
        3: 1634:      if (scanner_context_p->async_source_p != NULL)
        -: 1635:      {
    #####: 1636:        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
    #####: 1637:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 1638:      }
        -: 1639:#endif /* JERRY_ESNEXT */
        -: 1640:
        3: 1641:      lexer_next_token (context_p);
        -: 1642:
        -: 1643:#if JERRY_ESNEXT
        3: 1644:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1645:      {
    #####: 1646:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
    #####: 1647:        lexer_next_token (context_p);
        -: 1648:      }
        -: 1649:#endif /* JERRY_ESNEXT */
        -: 1650:
        3: 1651:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1652:      {
    #####: 1653:        scanner_raise_error (context_p);
        -: 1654:      }
        -: 1655:
        3: 1656:      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1657:
        -: 1658:#if JERRY_ESNEXT
        3: 1659:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);
        -: 1660:
        3: 1661:      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)
    #####: 1662:          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
    #####: 1663:          && (literal_p->type & mask) != SCANNER_LITERAL_IS_LOCAL_FUNC)
        -: 1664:      {
    #####: 1665:        scanner_raise_redeclaration_error (context_p);
        -: 1666:      }
        -: 1667:
        3: 1668:      scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1669:
        3: 1670:      if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1671:          && (literal_p->type & (SCANNER_LITERAL_IS_VAR)))
        -: 1672:      {
    #####: 1673:        scanner_raise_redeclaration_error (context_p);
        -: 1674:      }
        -: 1675:
        3: 1676:      literal_p->type |= SCANNER_LITERAL_IS_LOCAL_FUNC;
        -: 1677:
        3: 1678:      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
        -: 1679:#else /* !JERRY_ESNEXT */
    #####: 1680:      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;
        -: 1681:
    #####: 1682:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 1683:#endif /* JERRY_ESNEXT */
        -: 1684:
        3: 1685:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -: 1686:
        3: 1687:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        3: 1688:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);
        3: 1689:      return SCAN_NEXT_TOKEN;
        -: 1690:    }
        -: 1691:#if JERRY_ESNEXT
        9: 1692:    case LEXER_KEYW_CLASS:
        -: 1693:    {
        -: 1694:      lexer_lit_location_t *literal_p;
        9: 1695:      literal_p = scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);
        -: 1696:
        9: 1697:      if (literal_p == NULL)
        -: 1698:      {
    #####: 1699:        scanner_raise_error (context_p);
        -: 1700:      }
        -: 1701:
        9: 1702:      scanner_detect_invalid_let (context_p, literal_p);
        9: 1703:      literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 1704:
        9: 1705:      if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1706:      {
    #####: 1707:        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1708:      }
        -: 1709:
        -: 1710:#if JERRY_MODULE_SYSTEM
        9: 1711:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 1712:      {
    #####: 1713:        literal_p->type |= SCANNER_LITERAL_NO_REG;
    #####: 1714:        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 1715:      }
        -: 1716:#endif /* JERRY_MODULE_SYSTEM */
        -: 1717:
        9: 1718:      return SCAN_NEXT_TOKEN;
        -: 1719:    }
        -: 1720:#endif /* JERRY_ESNEXT */
        -: 1721:#if JERRY_MODULE_SYSTEM
    #####: 1722:    case LEXER_KEYW_IMPORT:
        -: 1723:    {
    #####: 1724:      lexer_next_token (context_p);
        -: 1725:
    #####: 1726:      if (context_p->token.type == LEXER_DOT)
        -: 1727:      {
    #####: 1728:        scanner_check_import_meta (context_p);
    #####: 1729:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1730:        return SCAN_KEEP_TOKEN;
        -: 1731:      }
        -: 1732:
    #####: 1733:      if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1734:      {
    #####: 1735:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1736:        return SCAN_KEEP_TOKEN;
        -: 1737:      }
        -: 1738:
    #####: 1739:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1740:      {
    #####: 1741:        scanner_raise_error (context_p);
        -: 1742:      }
        -: 1743:
    #####: 1744:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1745:
    #####: 1746:      if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1747:      {
    #####: 1748:        return SCAN_NEXT_TOKEN;
        -: 1749:      }
        -: 1750:
    #####: 1751:      bool parse_imports = true;
        -: 1752:
    #####: 1753:      if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1754:      {
    #####: 1755:        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1756:
    #####: 1757:        scanner_detect_invalid_let (context_p, literal_p);
    #####: 1758:        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1759:
    #####: 1760:        lexer_next_token (context_p);
        -: 1761:
    #####: 1762:        if (context_p->token.type == LEXER_COMMA)
        -: 1763:        {
    #####: 1764:          lexer_next_token (context_p);
        -: 1765:        }
        -: 1766:        else
        -: 1767:        {
    #####: 1768:          parse_imports = false;
        -: 1769:        }
        -: 1770:      }
        -: 1771:
    #####: 1772:      if (parse_imports)
        -: 1773:      {
    #####: 1774:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1775:        {
    #####: 1776:          lexer_next_token (context_p);
    #####: 1777:          if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1778:          {
    #####: 1779:            scanner_raise_error (context_p);
        -: 1780:          }
        -: 1781:
    #####: 1782:          lexer_next_token (context_p);
        -: 1783:
    #####: 1784:          if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1785:          {
    #####: 1786:            scanner_raise_error (context_p);
        -: 1787:          }
        -: 1788:
    #####: 1789:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1790:
    #####: 1791:          scanner_detect_invalid_let (context_p, literal_p);
    #####: 1792:          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1793:
    #####: 1794:          lexer_next_token (context_p);
        -: 1795:        }
    #####: 1796:        else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1797:        {
    #####: 1798:          lexer_next_token (context_p);
        -: 1799:
    #####: 1800:          while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1801:          {
    #####: 1802:            if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1803:            {
    #####: 1804:              scanner_raise_error (context_p);
        -: 1805:            }
        -: 1806:
    #####: 1807:            const uint8_t *source_p = context_p->source_p;
        -: 1808:
    #####: 1809:            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))
        -: 1810:            {
    #####: 1811:              lexer_next_token (context_p);
        -: 1812:
    #####: 1813:              if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1814:              {
    #####: 1815:                scanner_raise_error (context_p);
        -: 1816:              }
        -: 1817:
    #####: 1818:              lexer_next_token (context_p);
        -: 1819:
    #####: 1820:              if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1821:              {
    #####: 1822:                scanner_raise_error (context_p);
        -: 1823:              }
        -: 1824:
    #####: 1825:              source_p = context_p->source_p;
        -: 1826:            }
        -: 1827:
    #####: 1828:            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1829:
    #####: 1830:            if (literal_p->type & (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_LOCAL))
        -: 1831:            {
    #####: 1832:              context_p->source_p = source_p;
    #####: 1833:              scanner_raise_redeclaration_error (context_p);
        -: 1834:            }
        -: 1835:
    #####: 1836:            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1837:            {
    #####: 1838:              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1839:            }
        -: 1840:
    #####: 1841:            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1842:
    #####: 1843:            lexer_next_token (context_p);
        -: 1844:
    #####: 1845:            if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1846:            {
    #####: 1847:              if (context_p->token.type != LEXER_COMMA)
        -: 1848:              {
    #####: 1849:                scanner_raise_error (context_p);
        -: 1850:              }
        -: 1851:
    #####: 1852:              lexer_next_token (context_p);
        -: 1853:            }
        -: 1854:          }
        -: 1855:
    #####: 1856:          lexer_next_token (context_p);
        -: 1857:        }
        -: 1858:        else
        -: 1859:        {
    #####: 1860:          scanner_raise_error (context_p);
        -: 1861:        }
        -: 1862:      }
        -: 1863:
    #####: 1864:      if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1865:      {
    #####: 1866:        scanner_raise_error (context_p);
        -: 1867:      }
        -: 1868:
    #####: 1869:      lexer_next_token (context_p);
        -: 1870:
    #####: 1871:      if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type != LEXER_STRING_LITERAL)
        -: 1872:      {
    #####: 1873:        scanner_raise_error (context_p);
        -: 1874:      }
        -: 1875:
    #####: 1876:      return SCAN_NEXT_TOKEN;
        -: 1877:    }
    #####: 1878:    case LEXER_KEYW_EXPORT:
        -: 1879:    {
    #####: 1880:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1881:      {
    #####: 1882:        scanner_raise_error (context_p);
        -: 1883:      }
        -: 1884:
    #####: 1885:      lexer_next_token (context_p);
        -: 1886:
    #####: 1887:      if (context_p->token.type == LEXER_KEYW_DEFAULT)
        -: 1888:      {
    #####: 1889:        lexer_next_token (context_p);
    #####: 1890:        parser_stack_push_uint8 (context_p, SCAN_STACK_EXPORT_DEFAULT);
    #####: 1891:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1892:        return SCAN_KEEP_TOKEN;
        -: 1893:      }
        -: 1894:
    #####: 1895:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1896:
    #####: 1897:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1898:      {
    #####: 1899:        lexer_next_token (context_p);
        -: 1900:
    #####: 1901:        if (lexer_token_is_identifier (context_p, "as", 2))
        -: 1902:        {
    #####: 1903:          lexer_next_token (context_p);
        -: 1904:
    #####: 1905:          if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1906:          {
    #####: 1907:            scanner_raise_error (context_p);
        -: 1908:          }
        -: 1909:
    #####: 1910:          lexer_next_token (context_p);
        -: 1911:        }
        -: 1912:
    #####: 1913:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1914:        {
    #####: 1915:          scanner_raise_error (context_p);
        -: 1916:        }
        -: 1917:
    #####: 1918:        lexer_next_token (context_p);
        -: 1919:
    #####: 1920:        if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1921:        {
    #####: 1922:          scanner_raise_error (context_p);
        -: 1923:        }
        -: 1924:
    #####: 1925:        return SCAN_NEXT_TOKEN;
        -: 1926:      }
        -: 1927:
        -: 1928:      scanner_source_start_t source_start;
    #####: 1929:      source_start.source_p = context_p->source_p;
        -: 1930:
    #####: 1931:      if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1932:      {
    #####: 1933:        lexer_next_token (context_p);
        -: 1934:
    #####: 1935:        while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1936:        {
    #####: 1937:          if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1938:          {
    #####: 1939:            scanner_raise_error (context_p);
        -: 1940:          }
        -: 1941:
    #####: 1942:          lexer_next_token (context_p);
        -: 1943:
    #####: 1944:          if (lexer_token_is_identifier (context_p, "as", 2))
        -: 1945:          {
    #####: 1946:            lexer_next_token (context_p);
        -: 1947:
    #####: 1948:            if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1949:            {
    #####: 1950:              scanner_raise_error (context_p);
        -: 1951:            }
        -: 1952:
    #####: 1953:            lexer_next_token (context_p);
        -: 1954:          }
        -: 1955:
    #####: 1956:          if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1957:          {
    #####: 1958:            if (context_p->token.type != LEXER_COMMA)
        -: 1959:            {
    #####: 1960:              scanner_raise_error (context_p);
        -: 1961:            }
        -: 1962:
    #####: 1963:            lexer_next_token (context_p);
        -: 1964:          }
        -: 1965:        }
        -: 1966:
    #####: 1967:        lexer_next_token (context_p);
        -: 1968:
    #####: 1969:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1970:        {
    #####: 1971:          return SCAN_KEEP_TOKEN;
        -: 1972:        }
        -: 1973:
    #####: 1974:        scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####: 1975:        info_p->type = SCANNER_TYPE_EXPORT_MODULE_SPECIFIER;
        -: 1976:
    #####: 1977:        lexer_next_token (context_p);
        -: 1978:
    #####: 1979:        if (context_p->token.type != LEXER_LITERAL && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1980:        {
    #####: 1981:          scanner_raise_error (context_p);
        -: 1982:        }
        -: 1983:
    #####: 1984:        return SCAN_NEXT_TOKEN;
        -: 1985:      }
        -: 1986:
    #####: 1987:      switch (context_p->token.type)
        -: 1988:      {
    #####: 1989:        case LEXER_KEYW_CLASS:
        -: 1990:        case LEXER_KEYW_LET:
        -: 1991:        case LEXER_KEYW_CONST:
        -: 1992:        case LEXER_KEYW_VAR:
        -: 1993:        {
    #####: 1994:          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;
    #####: 1995:          break;
        -: 1996:        }
        -: 1997:      }
        -: 1998:
    #####: 1999:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2000:      return SCAN_KEEP_TOKEN;
        -: 2001:    }
        -: 2002:#endif /* JERRY_MODULE_SYSTEM */
       29: 2003:    default:
        -: 2004:    {
       29: 2005:      break;
        -: 2006:    }
        -: 2007:  }
        -: 2008:
       29: 2009:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2010:
       29: 2011:  if (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2012:  {
       12: 2013:    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))
        -: 2014:    {
    #####: 2015:      lexer_consume_next_character (context_p);
    #####: 2016:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2017:      return SCAN_NEXT_TOKEN;
        -: 2018:    }
        -: 2019:
       12: 2020:    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);
        -: 2021:
        -: 2022:#if JERRY_ESNEXT
        -: 2023:    /* The colon needs to be checked first because the parser also checks
        -: 2024:     * it first, and this check skips the spaces which affects source_p. */
       12: 2025:    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))
        -: 2026:    {
    #####: 2027:      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);
    #####: 2028:      return SCAN_KEEP_TOKEN;
        -: 2029:    }
        -: 2030:
       12: 2031:    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))
        -: 2032:    {
        1: 2033:      lexer_lit_location_t let_literal = context_p->token.lit_location;
        1: 2034:      const uint8_t *source_p = context_p->source_p;
        -: 2035:
        1: 2036:      lexer_next_token (context_p);
        -: 2037:
        1: 2038:      type = (lexer_token_type_t) context_p->token.type;
        -: 2039:
        1: 2040:      if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE
        1: 2041:          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))
        -: 2042:      {
        1: 2043:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        1: 2044:        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
        1: 2045:        return SCAN_KEEP_TOKEN;
        -: 2046:      }
        -: 2047:
    #####: 2048:      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 2049:      info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 2050:
    #####: 2051:      lexer_lit_location_t *lit_location_p =
    #####: 2052:        scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &let_literal);
    #####: 2053:      lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 2054:
    #####: 2055:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2056:      {
    #####: 2057:        lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2058:      }
        -: 2059:
    #####: 2060:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 2061:      return SCAN_KEEP_TOKEN;
        -: 2062:    }
        -: 2063:
       11: 2064:    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -: 2065:    {
    #####: 2066:      scanner_context_p->async_source_p = context_p->source_p;
        -: 2067:
    #####: 2068:      if (scanner_check_async_function (context_p, scanner_context_p))
        -: 2069:      {
    #####: 2070:        scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -: 2071:      }
    #####: 2072:      return SCAN_KEEP_TOKEN;
        -: 2073:    }
        -: 2074:#endif /* JERRY_ESNEXT */
        -: 2075:
       11: 2076:    scanner_add_reference (context_p, scanner_context_p);
        -: 2077:
       11: 2078:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
       11: 2079:    return SCAN_NEXT_TOKEN;
        -: 2080:  }
        -: 2081:
       17: 2082:  return SCAN_KEEP_TOKEN;
        -: 2083:} /* scanner_scan_statement */
        -: 2084:
        -: 2085:/**
        -: 2086: * Scan statement terminator.
        -: 2087: *
        -: 2088: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 2089: */
        -: 2090:static scan_return_types_t
       41: 2091:scanner_scan_statement_end (parser_context_t *context_p, /**< context */
        -: 2092:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 2093:                            lexer_token_type_t type) /**< current token type */
        -: 2094:{
       41: 2095:  bool terminator_found = false;
        -: 2096:
       41: 2097:  if (type == LEXER_SEMICOLON)
        -: 2098:  {
       32: 2099:    lexer_next_token (context_p);
       32: 2100:    terminator_found = true;
        -: 2101:  }
        -: 2102:
        -: 2103:  while (true)
        -: 2104:  {
       71: 2105:    type = (lexer_token_type_t) context_p->token.type;
        -: 2106:
       56: 2107:    switch (context_p->stack_top_uint8)
        -: 2108:    {
        3: 2109:      case SCAN_STACK_SCRIPT:
        -: 2110:      case SCAN_STACK_SCRIPT_FUNCTION:
        -: 2111:      {
        3: 2112:        if (type == LEXER_EOS)
        -: 2113:        {
        1: 2114:          return SCAN_NEXT_TOKEN;
        -: 2115:        }
        2: 2116:        break;
        -: 2117:      }
       14: 2118:      case SCAN_STACK_BLOCK_STATEMENT:
        -: 2119:#if JERRY_ESNEXT
        -: 2120:      case SCAN_STACK_CLASS_STATEMENT:
        -: 2121:#endif /* JERRY_ESNEXT */
        -: 2122:      case SCAN_STACK_FUNCTION_STATEMENT:
        -: 2123:      {
       14: 2124:        if (type != LEXER_RIGHT_BRACE)
        -: 2125:        {
        1: 2126:          break;
        -: 2127:        }
        -: 2128:
        -: 2129:#if JERRY_ESNEXT
       13: 2130:        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)
        -: 2131:        {
        4: 2132:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2133:        }
        -: 2134:#else /* !JERRY_ESNEXT */
    #####: 2135:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)
        -: 2136:        {
    #####: 2137:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2138:        }
        -: 2139:#endif /* JERRY_ESNEXT */
        -: 2140:
       13: 2141:        terminator_found = true;
       13: 2142:        parser_stack_pop_uint8 (context_p);
        -: 2143:#if JERRY_MODULE_SYSTEM
       13: 2144:        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 2145:#endif /* JERRY_MODULE_SYSTEM */
       13: 2146:        lexer_next_token (context_p);
       13: 2147:        continue;
        -: 2148:      }
       26: 2149:      case SCAN_STACK_FUNCTION_EXPRESSION:
        -: 2150:#if JERRY_ESNEXT
        -: 2151:      case SCAN_STACK_FUNCTION_ARROW:
        -: 2152:#endif /* JERRY_ESNEXT */
        -: 2153:      {
       26: 2154:        if (type != LEXER_RIGHT_BRACE)
        -: 2155:        {
       17: 2156:          break;
        -: 2157:        }
        -: 2158:
        9: 2159:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 2160:#if JERRY_ESNEXT
        9: 2161:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)
        -: 2162:        {
    #####: 2163:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -: 2164:        }
        -: 2165:#endif /* JERRY_ESNEXT */
        -: 2166:
        9: 2167:        scanner_pop_literal_pool (context_p, scanner_context_p);
        9: 2168:        parser_stack_pop_uint8 (context_p);
        -: 2169:
        -: 2170:#if JERRY_MODULE_SYSTEM
        9: 2171:        if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)
        -: 2172:        {
    #####: 2173:          terminator_found = true;
    #####: 2174:          parser_stack_pop_uint8 (context_p);
    #####: 2175:          lexer_next_token (context_p);
    #####: 2176:          continue;
        -: 2177:        }
        -: 2178:#endif /* JERRY_MODULE_SYSTEM */
        9: 2179:        return SCAN_NEXT_TOKEN;
        -: 2180:      }
       10: 2181:      case SCAN_STACK_FUNCTION_PROPERTY:
        -: 2182:      {
       10: 2183:        if (type != LEXER_RIGHT_BRACE)
        -: 2184:        {
    #####: 2185:          break;
        -: 2186:        }
        -: 2187:
        -: 2188:#if JERRY_ESNEXT
       10: 2189:        bool has_super_reference =
       10: 2190:          (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE) != 0;
        -: 2191:#endif /* JERRY_ESNEXT */
       10: 2192:        scanner_pop_literal_pool (context_p, scanner_context_p);
       10: 2193:        parser_stack_pop_uint8 (context_p);
        -: 2194:
        -: 2195:#if JERRY_ESNEXT
       10: 2196:        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR
        2: 2197:            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 2198:        {
       10: 2199:          scanner_context_p->mode = SCAN_MODE_CLASS_BODY;
       10: 2200:          return SCAN_KEEP_TOKEN;
        -: 2201:        }
        -: 2202:
    #####: 2203:        if (has_super_reference && context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL)
        -: 2204:        {
    #####: 2205:          *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_SUPER;
        -: 2206:        }
        -: 2207:#else /* JERRY_ESNEXT */
        -: 2208:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);
        -: 2209:#endif /* JERRY_ESNEXT */
        -: 2210:
    #####: 2211:        lexer_next_token (context_p);
        -: 2212:
    #####: 2213:        if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2214:        {
    #####: 2215:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2216:          return SCAN_KEEP_TOKEN;
        -: 2217:        }
        -: 2218:
    #####: 2219:        if (context_p->token.type != LEXER_COMMA)
        -: 2220:        {
    #####: 2221:          scanner_raise_error (context_p);
        -: 2222:        }
        -: 2223:
    #####: 2224:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2225:        return SCAN_KEEP_TOKEN;
        -: 2226:      }
    #####: 2227:      case SCAN_STACK_SWITCH_BLOCK:
        -: 2228:      {
    #####: 2229:        if (type != LEXER_RIGHT_BRACE)
        -: 2230:        {
    #####: 2231:          break;
        -: 2232:        }
        -: 2233:
    #####: 2234:        scanner_switch_statement_t switch_statement;
        -: 2235:
    #####: 2236:        parser_stack_pop_uint8 (context_p);
    #####: 2237:        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
        -: 2238:
    #####: 2239:        scanner_context_p->active_switch_statement = switch_statement;
        -: 2240:
        -: 2241:#if JERRY_ESNEXT
    #####: 2242:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2243:#endif /* JERRY_ESNEXT */
        -: 2244:
    #####: 2245:        terminator_found = true;
    #####: 2246:        lexer_next_token (context_p);
    #####: 2247:        continue;
        -: 2248:      }
    #####: 2249:      case SCAN_STACK_IF_STATEMENT:
        -: 2250:      {
    #####: 2251:        parser_stack_pop_uint8 (context_p);
        -: 2252:
    #####: 2253:        if (type == LEXER_KEYW_ELSE && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2254:        {
        -: 2255:#if JERRY_ESNEXT
    #####: 2256:          scanner_check_function_after_if (context_p, scanner_context_p);
    #####: 2257:          return SCAN_KEEP_TOKEN;
        -: 2258:#else /* !JERRY_ESNEXT */
    #####: 2259:          scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2260:          return SCAN_NEXT_TOKEN;
        -: 2261:#endif /* JERRY_ESNEXT */
        -: 2262:        }
    #####: 2263:        continue;
        -: 2264:      }
    #####: 2265:      case SCAN_STACK_WITH_STATEMENT:
        -: 2266:      {
    #####: 2267:        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 2268:
    #####: 2269:        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);
        -: 2270:
    #####: 2271:        parser_stack_pop_uint8 (context_p);
        -: 2272:
    #####: 2273:        if (context_p->stack_top_uint8 == 0)
        -: 2274:        {
    #####: 2275:          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;
        -: 2276:        }
        -: 2277:
    #####: 2278:        parser_stack_pop_uint8 (context_p);
    #####: 2279:        continue;
        -: 2280:      }
    #####: 2281:      case SCAN_STACK_DO_STATEMENT:
        -: 2282:      {
    #####: 2283:        parser_stack_pop_uint8 (context_p);
        -: 2284:
    #####: 2285:        if (type != LEXER_KEYW_WHILE || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2286:        {
    #####: 2287:          scanner_raise_error (context_p);
        -: 2288:        }
        -: 2289:
    #####: 2290:        lexer_next_token (context_p);
    #####: 2291:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2292:        {
    #####: 2293:          scanner_raise_error (context_p);
        -: 2294:        }
        -: 2295:
    #####: 2296:        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);
    #####: 2297:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2298:        return SCAN_NEXT_TOKEN;
        -: 2299:      }
    #####: 2300:      case SCAN_STACK_DO_EXPRESSION:
        -: 2301:      {
    #####: 2302:        parser_stack_pop_uint8 (context_p);
    #####: 2303:        terminator_found = true;
    #####: 2304:        continue;
        -: 2305:      }
        -: 2306:#if JERRY_ESNEXT
    #####: 2307:      case SCAN_STACK_PRIVATE_BLOCK_EARLY:
        -: 2308:      {
    #####: 2309:        parser_list_iterator_t literal_iterator;
        -: 2310:        lexer_lit_location_t *literal_p;
        -: 2311:
    #####: 2312:        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);
        -: 2313:
    #####: 2314:        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 2315:        {
    #####: 2316:          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))
    #####: 2317:              && (literal_p->type & SCANNER_LITERAL_IS_USED))
        -: 2318:          {
    #####: 2319:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2320:          }
        -: 2321:        }
        -: 2322:        /* FALLTHRU */
        -: 2323:      }
        1: 2324:      case SCAN_STACK_PRIVATE_BLOCK:
        -: 2325:      {
        1: 2326:        parser_stack_pop_uint8 (context_p);
        1: 2327:        scanner_pop_literal_pool (context_p, scanner_context_p);
        1: 2328:        continue;
        -: 2329:      }
        -: 2330:#endif /* JERRY_ESNEXT */
        -: 2331:#if JERRY_MODULE_SYSTEM
    #####: 2332:      case SCAN_STACK_EXPORT_DEFAULT:
        -: 2333:      {
    #####: 2334:        parser_stack_pop_uint8 (context_p);
    #####: 2335:        lexer_lit_location_t *location_p =
    #####: 2336:          scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &lexer_default_literal);
    #####: 2337:        location_p->type |= SCANNER_LITERAL_IS_VAR;
    #####: 2338:        continue;
        -: 2339:      }
        -: 2340:#endif /* JERRY_MODULE_SYSTEM */
        2: 2341:      default:
        -: 2342:      {
        2: 2343:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT
        -: 2344:                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);
        -: 2345:
        2: 2346:        if (type != LEXER_RIGHT_BRACE)
        -: 2347:        {
    #####: 2348:          break;
        -: 2349:        }
        -: 2350:
        2: 2351:        uint8_t stack_top = context_p->stack_top_uint8;
        2: 2352:        parser_stack_pop_uint8 (context_p);
        2: 2353:        lexer_next_token (context_p);
        -: 2354:
        -: 2355:#if JERRY_ESNEXT
        2: 2356:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2357:#else /* !JERRY_ESNEXT */
    #####: 2358:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2359:        {
    #####: 2360:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2361:        }
        -: 2362:#endif /* JERRY_ESNEXT */
        -: 2363:
        -: 2364:        /* A finally statement is optional after a try or catch statement. */
        2: 2365:        if (context_p->token.type == LEXER_KEYW_FINALLY)
        -: 2366:        {
    #####: 2367:          lexer_next_token (context_p);
        -: 2368:
    #####: 2369:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2370:          {
    #####: 2371:            scanner_raise_error (context_p);
        -: 2372:          }
        -: 2373:
        -: 2374:#if JERRY_ESNEXT
        -: 2375:          scanner_literal_pool_t *literal_pool_p;
    #####: 2376:          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
    #####: 2377:          literal_pool_p->source_p = context_p->source_p;
        -: 2378:#endif /* JERRY_ESNEXT */
        -: 2379:
    #####: 2380:          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
    #####: 2381:          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2382:          return SCAN_NEXT_TOKEN;
        -: 2383:        }
        -: 2384:
        2: 2385:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2386:        {
        1: 2387:          terminator_found = true;
        1: 2388:          continue;
        -: 2389:        }
        -: 2390:
        -: 2391:        /* A catch statement must be present after a try statement unless a finally is provided. */
        1: 2392:        if (context_p->token.type != LEXER_KEYW_CATCH)
        -: 2393:        {
    #####: 2394:          scanner_raise_error (context_p);
        -: 2395:        }
        -: 2396:
        1: 2397:        lexer_next_token (context_p);
        -: 2398:
        -: 2399:        scanner_literal_pool_t *literal_pool_p;
        1: 2400:        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        1: 2401:        literal_pool_p->source_p = context_p->source_p;
        1: 2402:        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);
        -: 2403:
        -: 2404:#if JERRY_ESNEXT
        1: 2405:        if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2406:        {
    #####: 2407:          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2408:          return SCAN_NEXT_TOKEN;
        -: 2409:        }
        -: 2410:#endif /* JERRY_ESNEXT */
        -: 2411:
        1: 2412:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2413:        {
    #####: 2414:          scanner_raise_error (context_p);
        -: 2415:        }
        -: 2416:
        1: 2417:        lexer_next_token (context_p);
        -: 2418:
        -: 2419:#if JERRY_ESNEXT
        1: 2420:        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 2421:        {
    #####: 2422:          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);
        -: 2423:
    #####: 2424:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2425:          {
    #####: 2426:            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2427:            scanner_context_p->mode = SCAN_MODE_BINDING;
    #####: 2428:            return SCAN_NEXT_TOKEN;
        -: 2429:          }
        -: 2430:
    #####: 2431:          parser_stack_push_uint8 (context_p, 0);
    #####: 2432:          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2433:          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2434:          return SCAN_KEEP_TOKEN;
        -: 2435:        }
        -: 2436:#endif /* JERRY_ESNEXT */
        -: 2437:
        1: 2438:        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2439:        {
    #####: 2440:          scanner_raise_error (context_p);
        -: 2441:        }
        -: 2442:
        1: 2443:        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);
        1: 2444:        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;
        -: 2445:
        1: 2446:        lexer_next_token (context_p);
        -: 2447:
        1: 2448:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2449:        {
    #####: 2450:          scanner_raise_error (context_p);
        -: 2451:        }
        -: 2452:
        1: 2453:        lexer_next_token (context_p);
        -: 2454:
        1: 2455:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2456:        {
    #####: 2457:          scanner_raise_error (context_p);
        -: 2458:        }
        -: 2459:
        1: 2460:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 2461:        return SCAN_NEXT_TOKEN;
        -: 2462:      }
        -: 2463:    }
        -: 2464:
       20: 2465:    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2466:    {
    #####: 2467:      scanner_raise_error (context_p);
        -: 2468:    }
        -: 2469:
       20: 2470:    scanner_context_p->mode = SCAN_MODE_STATEMENT;
       20: 2471:    return SCAN_KEEP_TOKEN;
        -: 2472:  }
        -: 2473:} /* scanner_scan_statement_end */
        -: 2474:
        -: 2475:/**
        -: 2476: * Scan the whole source code.
        -: 2477: */
        -: 2478:void JERRY_ATTR_NOINLINE
        1: 2479:scanner_scan_all (parser_context_t *context_p) /**< context */
        -: 2480:{
        1: 2481:  scanner_context_t scanner_context;
        -: 2482:
        -: 2483:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2484:  if (context_p->is_show_opcodes)
        -: 2485:  {
        -: 2486:    JERRY_DEBUG_MSG ("\n--- Scanning start ---\n\n");
        -: 2487:  }
        -: 2488:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2489:
        1: 2490:  scanner_context.context_status_flags = context_p->status_flags;
        1: 2491:  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;
        -: 2492:#if JERRY_DEBUGGER
        -: 2493:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2494:  {
        -: 2495:    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;
        -: 2496:  }
        -: 2497:#endif /* JERRY_DEBUGGER */
        -: 2498:#if JERRY_ESNEXT
        1: 2499:  scanner_context.binding_type = SCANNER_BINDING_NONE;
        1: 2500:  scanner_context.active_binding_list_p = NULL;
        -: 2501:#endif /* JERRY_ESNEXT */
        1: 2502:  scanner_context.active_literal_pool_p = NULL;
        1: 2503:  scanner_context.active_switch_statement.last_case_p = NULL;
        1: 2504:  scanner_context.end_arguments_p = NULL;
        -: 2505:#if JERRY_ESNEXT
        1: 2506:  scanner_context.async_source_p = NULL;
        -: 2507:#endif /* JERRY_ESNEXT */
        -: 2508:
        -: 2509:  /* This assignment must be here because of Apple compilers. */
        1: 2510:  context_p->u.scanner_context_p = &scanner_context;
        -: 2511:#if JERRY_ESNEXT
        1: 2512:  context_p->global_status_flags |= ECMA_PARSE_INTERNAL_PRE_SCANNING;
        -: 2513:#endif /* JERRY_ESNEXT */
        -: 2514:
        1: 2515:  parser_stack_init (context_p);
        -: 2516:
        1: 2517:  PARSER_TRY (context_p->try_buffer)
        -: 2518:  {
        1: 2519:    if (context_p->arguments_start_p == NULL)
        -: 2520:    {
        1: 2521:      context_p->source_p = context_p->source_start_p;
        1: 2522:      context_p->source_end_p = context_p->source_start_p + context_p->source_size;
        -: 2523:
        1: 2524:      uint16_t status_flags =
        -: 2525:        (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_NO_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL);
        -: 2526:
        1: 2527:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2528:      {
    #####: 2529:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2530:      }
        -: 2531:
        1: 2532:      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);
        1: 2533:      literal_pool_p->source_p = context_p->source_start_p;
        -: 2534:
        1: 2535:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);
        -: 2536:
        1: 2537:      lexer_next_token (context_p);
        1: 2538:      scanner_check_directives (context_p, &scanner_context);
        -: 2539:    }
        -: 2540:    else
        -: 2541:    {
    #####: 2542:      context_p->source_p = context_p->arguments_start_p;
    #####: 2543:      context_p->source_end_p = context_p->arguments_start_p + context_p->arguments_size;
        -: 2544:
    #####: 2545:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2546:
    #####: 2547:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2548:      {
    #####: 2549:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2550:      }
        -: 2551:
        -: 2552:#if JERRY_ESNEXT
    #####: 2553:      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2554:      {
    #####: 2555:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2556:      }
    #####: 2557:      if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 2558:      {
    #####: 2559:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2560:      }
        -: 2561:#endif /* JERRY_ESNEXT */
        -: 2562:
    #####: 2563:      scanner_push_literal_pool (context_p, &scanner_context, status_flags);
    #####: 2564:      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 2565:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);
        -: 2566:
        -: 2567:      /* Faking the first token. */
    #####: 2568:      context_p->token.type = LEXER_LEFT_PAREN;
        -: 2569:    }
        -: 2570:
        -: 2571:    while (true)
      335: 2572:    {
      336: 2573:      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;
      336: 2574:      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -: 2575:
      336: 2576:      switch (scanner_context.mode)
        -: 2577:      {
       73: 2578:        case SCAN_MODE_PRIMARY_EXPRESSION:
        -: 2579:        {
       73: 2580:          if (type == LEXER_ADD || type == LEXER_SUBTRACT || LEXER_IS_UNARY_OP_TOKEN (type))
        -: 2581:          {
        -: 2582:            break;
        -: 2583:          }
        -: 2584:          /* FALLTHRU */
        -: 2585:        }
        -: 2586:        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:
        -: 2587:        {
       81: 2588:          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2589:          {
       13: 2590:            continue;
        -: 2591:          }
       68: 2592:          break;
        -: 2593:        }
        -: 2594:#if JERRY_ESNEXT
        9: 2595:        case SCAN_MODE_CLASS_DECLARATION:
        -: 2596:        {
        9: 2597:          if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 2598:          {
        8: 2599:            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);
        8: 2600:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        8: 2601:            break;
        -: 2602:          }
        1: 2603:          else if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2604:          {
    #####: 2605:            scanner_raise_error (context_p);
        -: 2606:          }
        -: 2607:
        1: 2608:          scanner_context.mode = SCAN_MODE_CLASS_BODY;
        -: 2609:          /* FALLTHRU */
        -: 2610:        }
       19: 2611:        case SCAN_MODE_CLASS_BODY:
        -: 2612:        {
       19: 2613:          lexer_skip_empty_statements (context_p);
       19: 2614:          lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
        -: 2615:          /* FALLTHRU */
        -: 2616:        }
       19: 2617:        case SCAN_MODE_CLASS_BODY_NO_SCAN:
        -: 2618:        {
       19: 2619:          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR
        -: 2620:                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
       19: 2621:          JERRY_ASSERT (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME);
        -: 2622:
       19: 2623:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2624:          {
        9: 2625:            parser_stack_pop_uint8 (context_p);
        -: 2626:
        9: 2627:            scanner_class_info_t *private_members_p;
        9: 2628:            parser_stack_pop (context_p, &private_members_p, sizeof (scanner_class_info_t *));
        -: 2629:
        9: 2630:            private_members_p->info.u8_arg |= SCANNER_SUCCESSFUL_CLASS_SCAN;
        -: 2631:
        9: 2632:            scanner_pop_literal_pool (context_p, &scanner_context);
        -: 2633:
        9: 2634:            JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_CLASS_STATEMENT
        -: 2635:                          || context_p->stack_top_uint8 == SCAN_STACK_CLASS_EXPRESSION);
        -: 2636:
        9: 2637:            if (context_p->stack_top_uint8 == SCAN_STACK_CLASS_STATEMENT)
        -: 2638:            {
        -: 2639:              /* The token is kept to disallow consuming a semicolon after it. */
        9: 2640:              scanner_context.mode = SCAN_MODE_STATEMENT_END;
        9: 2641:              continue;
        -: 2642:            }
        -: 2643:
    #####: 2644:            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 2645:            parser_stack_pop_uint8 (context_p);
        -: 2646:
        -: 2647:#if JERRY_MODULE_SYSTEM
    #####: 2648:            if (context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT)
        -: 2649:            {
        -: 2650:              /* The token is kept to disallow consuming a semicolon after it. */
    #####: 2651:              parser_stack_change_last_uint8 (context_p, SCAN_STACK_CLASS_STATEMENT);
    #####: 2652:              scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2653:              continue;
        -: 2654:            }
        -: 2655:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2656:            break;
        -: 2657:          }
        -: 2658:
       10: 2659:          bool is_private = false;
       10: 2660:          scanner_private_field_flags_t private_field_flags = SCANNER_PRIVATE_FIELD_PROPERTY;
        -: 2661:
       10: 2662:          if (context_p->token.type == LEXER_HASHMARK)
        -: 2663:          {
    #####: 2664:            is_private = true;
    #####: 2665:            context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####: 2666:            lexer_next_token (context_p);
        -: 2667:          }
        -: 2668:
       10: 2669:          bool identifier_found = false;
        -: 2670:
       10: 2671:          if (context_p->token.type == LEXER_LITERAL && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
       10: 2672:              && lexer_compare_literal_to_string (context_p, "constructor", 11)
        8: 2673:              && stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
    #####: 2674:          {
        8: 2675:            parser_stack_pop_uint8 (context_p);
        8: 2676:            scanner_class_info_t *private_members_p;
        8: 2677:            parser_stack_pop (context_p, &private_members_p, sizeof (scanner_class_info_t *));
        8: 2678:            private_members_p->info.u8_arg = SCANNER_CONSTRUCTOR_EXPLICIT;
        8: 2679:            parser_stack_push (context_p, &private_members_p, sizeof (scanner_class_info_t *));
        8: 2680:            parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
        -: 2681:          }
        2: 2682:          else if (lexer_token_is_identifier (context_p, "static", 6))
        -: 2683:          {
    #####: 2684:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
    #####: 2685:            identifier_found = true;
    #####: 2686:            private_field_flags |= SCANNER_PRIVATE_FIELD_STATIC;
        -: 2687:          }
        -: 2688:
       10: 2689:          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        -: 2690:
       10: 2691:          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2692:
       10: 2693:          private_field_flags |= lexer_token_is_identifier (context_p, "get", 3) ? SCANNER_PRIVATE_FIELD_GETTER : 0;
       10: 2694:          private_field_flags |= lexer_token_is_identifier (context_p, "set", 3) ? SCANNER_PRIVATE_FIELD_SETTER : 0;
        -: 2695:
       10: 2696:          if (private_field_flags & SCANNER_PRIVATE_FIELD_GETTER_SETTER)
        -: 2697:          {
        2: 2698:            private_field_flags &= ~(uint32_t) SCANNER_PRIVATE_FIELD_PROPERTY;
        -: 2699:
        2: 2700:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
        2: 2701:            identifier_found = true;
        -: 2702:
        2: 2703:            if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2704:            {
    #####: 2705:              if (is_private)
        -: 2706:              {
    #####: 2707:                private_field_flags |= SCANNER_PRIVATE_FIELD_METHOD;
    #####: 2708:                scanner_add_private_identifier (context_p, private_field_flags);
        -: 2709:              }
        -: 2710:
    #####: 2711:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2712:              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2713:              continue;
        -: 2714:            }
        -: 2715:          }
        8: 2716:          else if (lexer_token_is_identifier (context_p, "async", 5))
        -: 2717:          {
    #####: 2718:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
    #####: 2719:            identifier_found = true;
        -: 2720:
    #####: 2721:            if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2722:            {
    #####: 2723:              if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2724:              {
    #####: 2725:                if (is_private)
        -: 2726:                {
    #####: 2727:                  private_field_flags |= SCANNER_PRIVATE_FIELD_METHOD;
    #####: 2728:                  scanner_add_private_identifier (context_p, private_field_flags);
        -: 2729:                }
        -: 2730:
    #####: 2731:                parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2732:                scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2733:                continue;
        -: 2734:              }
        -: 2735:
    #####: 2736:              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2737:
    #####: 2738:              if (context_p->token.type == LEXER_MULTIPLY)
        -: 2739:              {
    #####: 2740:                lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
    #####: 2741:                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2742:              }
        -: 2743:            }
        -: 2744:          }
        8: 2745:          else if (context_p->token.type == LEXER_MULTIPLY)
        -: 2746:          {
    #####: 2747:            if (is_private)
        -: 2748:            {
    #####: 2749:              scanner_raise_error (context_p);
        -: 2750:            }
        -: 2751:
    #####: 2752:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
    #####: 2753:            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2754:          }
        -: 2755:
       10: 2756:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2757:          {
    #####: 2758:            if (is_private)
        -: 2759:            {
    #####: 2760:              scanner_raise_error (context_p);
        -: 2761:            }
        -: 2762:
    #####: 2763:            if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)
        -: 2764:            {
    #####: 2765:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
        -: 2766:            }
        -: 2767:
    #####: 2768:            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 2769:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2770:            break;
        -: 2771:          }
        -: 2772:
       10: 2773:          if (context_p->token.type == LEXER_HASHMARK)
        -: 2774:          {
    #####: 2775:            if (is_private)
        -: 2776:            {
    #####: 2777:              scanner_raise_error (context_p);
        -: 2778:            }
        -: 2779:
    #####: 2780:            is_private = true;
    #####: 2781:            context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####: 2782:            lexer_next_token (context_p);
        -: 2783:          }
        -: 2784:
       10: 2785:          if (is_private)
        -: 2786:          {
    #####: 2787:            if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 2788:            {
    #####: 2789:              private_field_flags |= SCANNER_PRIVATE_FIELD_METHOD;
        -: 2790:            }
        -: 2791:
    #####: 2792:            scanner_add_private_identifier (context_p, private_field_flags);
        -: 2793:          }
        -: 2794:
       10: 2795:          if (context_p->token.type == LEXER_LITERAL)
        -: 2796:          {
       10: 2797:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
       10: 2798:            identifier_found = true;
        -: 2799:          }
        -: 2800:
       10: 2801:          if (!identifier_found)
        -: 2802:          {
    #####: 2803:            scanner_raise_error (context_p);
        -: 2804:          }
        -: 2805:
       10: 2806:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2807:          {
       10: 2808:            if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 2809:            {
    #####: 2810:              context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2811:            }
        -: 2812:
       10: 2813:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
       10: 2814:            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
       10: 2815:            continue;
        -: 2816:          }
        -: 2817:
    #####: 2818:          if (literal_pool_flags != SCANNER_LITERAL_POOL_FUNCTION)
        -: 2819:          {
    #####: 2820:            scanner_raise_error (context_p);
        -: 2821:          }
        -: 2822:
    #####: 2823:          if (context_p->token.type == LEXER_ASSIGN)
        -: 2824:          {
    #####: 2825:            scanner_push_class_field_initializer (context_p, &scanner_context);
    #####: 2826:            break;
        -: 2827:          }
        -: 2828:
    #####: 2829:          if (context_p->token.type == LEXER_SEMICOLON)
        -: 2830:          {
    #####: 2831:            scanner_context.mode = SCAN_MODE_CLASS_BODY;
    #####: 2832:            continue;
        -: 2833:          }
        -: 2834:
    #####: 2835:          if (context_p->token.type != LEXER_RIGHT_BRACE && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2836:          {
    #####: 2837:            scanner_raise_error (context_p);
        -: 2838:          }
        -: 2839:
    #####: 2840:          scanner_context.mode = SCAN_MODE_CLASS_BODY_NO_SCAN;
    #####: 2841:          continue;
        -: 2842:        }
        -: 2843:#endif /* JERRY_ESNEXT */
      103: 2844:        case SCAN_MODE_POST_PRIMARY_EXPRESSION:
        -: 2845:        {
      103: 2846:          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))
        -: 2847:          {
       43: 2848:            break;
        -: 2849:          }
       60: 2850:          type = (lexer_token_type_t) context_p->token.type;
        -: 2851:          /* FALLTHRU */
        -: 2852:        }
       72: 2853:        case SCAN_MODE_PRIMARY_EXPRESSION_END:
        -: 2854:        {
       72: 2855:          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2856:          {
       54: 2857:            continue;
        -: 2858:          }
       18: 2859:          break;
        -: 2860:        }
       26: 2861:        case SCAN_MODE_STATEMENT_OR_TERMINATOR:
        -: 2862:        {
       26: 2863:          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)
        -: 2864:          {
    #####: 2865:            scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2866:            continue;
        -: 2867:          }
        -: 2868:          /* FALLTHRU */
        -: 2869:        }
        -: 2870:        case SCAN_MODE_STATEMENT:
        -: 2871:        {
       47: 2872:          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2873:          {
       22: 2874:            continue;
        -: 2875:          }
       25: 2876:          break;
        -: 2877:        }
       41: 2878:        case SCAN_MODE_STATEMENT_END:
        -: 2879:        {
       41: 2880:          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)
        -: 2881:          {
       30: 2882:            continue;
        -: 2883:          }
        -: 2884:
       11: 2885:          if (context_p->token.type == LEXER_EOS)
        -: 2886:          {
        1: 2887:            goto scan_completed;
        -: 2888:          }
        -: 2889:
       10: 2890:          break;
        -: 2891:        }
        2: 2892:        case SCAN_MODE_VAR_STATEMENT:
        -: 2893:        {
        -: 2894:#if JERRY_ESNEXT
        2: 2895:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 2896:          {
    #####: 2897:            uint8_t binding_type = SCANNER_BINDING_VAR;
        -: 2898:
    #####: 2899:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2900:            {
    #####: 2901:              binding_type = SCANNER_BINDING_LET;
        -: 2902:            }
    #####: 2903:            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)
        -: 2904:            {
    #####: 2905:              binding_type = SCANNER_BINDING_CONST;
        -: 2906:            }
        -: 2907:
    #####: 2908:            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);
        -: 2909:
    #####: 2910:            if (type == LEXER_LEFT_SQUARE)
        -: 2911:            {
    #####: 2912:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2913:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 2914:              break;
        -: 2915:            }
        -: 2916:
    #####: 2917:            parser_stack_push_uint8 (context_p, 0);
    #####: 2918:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2919:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2920:            continue;
        -: 2921:          }
        -: 2922:#endif /* JERRY_ESNEXT */
        -: 2923:
        2: 2924:          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2925:          {
    #####: 2926:            scanner_raise_error (context_p);
        -: 2927:          }
        -: 2928:
        2: 2929:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 2930:
        -: 2931:#if JERRY_ESNEXT
        2: 2932:          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)
        -: 2933:          {
        2: 2934:            scanner_detect_invalid_let (context_p, literal_p);
        -: 2935:
        2: 2936:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2937:            {
        2: 2938:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 2939:            }
        -: 2940:            else
        -: 2941:            {
    #####: 2942:              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);
    #####: 2943:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 2944:            }
        -: 2945:
        2: 2946:            lexer_next_token (context_p);
        -: 2947:
        4: 2948:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 2949:            {
    #####: 2950:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2951:            }
        2: 2952:            else if (context_p->token.type == LEXER_ASSIGN)
        -: 2953:            {
        2: 2954:              scanner_binding_literal_t binding_literal;
        2: 2955:              binding_literal.literal_p = literal_p;
        -: 2956:
        2: 2957:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
        2: 2958:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 2959:            }
        -: 2960:          }
        -: 2961:          else
        -: 2962:          {
    #####: 2963:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 2964:            {
    #####: 2965:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
    #####: 2966:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2967:
    #####: 2968:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2969:              {
    #####: 2970:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2971:              }
        -: 2972:            }
        -: 2973:
    #####: 2974:            lexer_next_token (context_p);
        -: 2975:          }
        -: 2976:#else /* !JERRY_ESNEXT */
    #####: 2977:          literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2978:
    #####: 2979:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2980:          {
    #####: 2981:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2982:          }
        -: 2983:
    #####: 2984:          lexer_next_token (context_p);
        -: 2985:#endif /* JERRY_ESNEXT */
        -: 2986:
        -: 2987:#if JERRY_MODULE_SYSTEM
        2: 2988:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 2989:          {
    #####: 2990:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2991:          }
        -: 2992:#endif /* JERRY_MODULE_SYSTEM */
        -: 2993:
        2: 2994:          switch (context_p->token.type)
        -: 2995:          {
        2: 2996:            case LEXER_ASSIGN:
        -: 2997:            {
        2: 2998:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2999:              /* FALLTHRU */
        -: 3000:            }
        2: 3001:            case LEXER_COMMA:
        -: 3002:            {
        2: 3003:              lexer_next_token (context_p);
        2: 3004:              continue;
        -: 3005:            }
        -: 3006:          }
        -: 3007:
    #####: 3008:          if (SCANNER_IS_FOR_START (stack_top))
        -: 3009:          {
        -: 3010:#if JERRY_MODULE_SYSTEM
    #####: 3011:            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));
        -: 3012:#endif /* JERRY_MODULE_SYSTEM */
        -: 3013:
    #####: 3014:            if (context_p->token.type != LEXER_SEMICOLON && context_p->token.type != LEXER_KEYW_IN
    #####: 3015:                && !SCANNER_IDENTIFIER_IS_OF ())
        -: 3016:            {
    #####: 3017:              scanner_raise_error (context_p);
        -: 3018:            }
        -: 3019:
    #####: 3020:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 3021:            continue;
        -: 3022:          }
        -: 3023:
        -: 3024:#if JERRY_ESNEXT
    #####: 3025:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);
        -: 3026:#else /* !JERRY_ESNEXT */
        -: 3027:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);
        -: 3028:#endif /* JERRY_ESNEXT */
        -: 3029:
        -: 3030:#if JERRY_MODULE_SYSTEM
    #####: 3031:          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 3032:#endif /* JERRY_MODULE_SYSTEM */
        -: 3033:
    #####: 3034:          scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 3035:          parser_stack_pop_uint8 (context_p);
    #####: 3036:          continue;
        -: 3037:        }
       22: 3038:        case SCAN_MODE_FUNCTION_ARGUMENTS:
        -: 3039:        {
       22: 3040:          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION || stack_top == SCAN_STACK_FUNCTION_STATEMENT
        -: 3041:                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION || stack_top == SCAN_STACK_FUNCTION_PROPERTY);
        -: 3042:
       22: 3043:          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 3044:
       22: 3045:          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -: 3046:
       22: 3047:          literal_pool_p->source_p = context_p->source_p;
        -: 3048:
        -: 3049:#if JERRY_ESNEXT
       22: 3050:          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))
        -: 3051:          {
    #####: 3052:            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####: 3053:            literal_pool_p->source_p = scanner_context.async_source_p;
    #####: 3054:            scanner_context.async_source_p = NULL;
        -: 3055:          }
        -: 3056:#endif /* JERRY_ESNEXT */
        -: 3057:
       22: 3058:          if (type != LEXER_LEFT_PAREN)
        -: 3059:          {
    #####: 3060:            scanner_raise_error (context_p);
        -: 3061:          }
       22: 3062:          lexer_next_token (context_p);
        -: 3063:
        -: 3064:#if JERRY_ESNEXT
        -: 3065:          /* FALLTHRU */
        -: 3066:        }
       23: 3067:        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:
        -: 3068:        {
       23: 3069:          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)
        -: 3070:          {
        -: 3071:            lexer_lit_location_t *argument_literal_p;
        -: 3072:
        -: 3073:            do
        -: 3074:            {
        4: 3075:              if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3076:              {
    #####: 3077:                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
    #####: 3078:                lexer_next_token (context_p);
        -: 3079:              }
        -: 3080:
        4: 3081:              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 3082:              {
    #####: 3083:                argument_literal_p = NULL;
    #####: 3084:                break;
        -: 3085:              }
        -: 3086:
        4: 3087:              if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3088:              {
    #####: 3089:                scanner_raise_error (context_p);
        -: 3090:              }
        -: 3091:
        4: 3092:              argument_literal_p = scanner_append_argument (context_p, &scanner_context);
        4: 3093:              lexer_next_token (context_p);
        -: 3094:
        4: 3095:              if (context_p->token.type != LEXER_COMMA)
        -: 3096:              {
        3: 3097:                break;
        -: 3098:              }
        -: 3099:
        1: 3100:              lexer_next_token (context_p);
        1: 3101:            } while (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS);
        -: 3102:
        3: 3103:            if (argument_literal_p == NULL)
        -: 3104:            {
    #####: 3105:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -: 3106:
    #####: 3107:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
    #####: 3108:              scanner_append_hole (context_p, &scanner_context);
    #####: 3109:              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);
        -: 3110:
    #####: 3111:              if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3112:              {
    #####: 3113:                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 3114:                scanner_context.mode = SCAN_MODE_BINDING;
    #####: 3115:                break;
        -: 3116:              }
        -: 3117:
    #####: 3118:              parser_stack_push_uint8 (context_p, 0);
    #####: 3119:              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 3120:              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 3121:              continue;
        -: 3122:            }
        -: 3123:
        3: 3124:            if (context_p->token.type == LEXER_ASSIGN)
        -: 3125:            {
        1: 3126:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -: 3127:
        1: 3128:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
        1: 3129:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3130:
        1: 3131:              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3132:              {
    #####: 3133:                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####: 3134:                break;
        -: 3135:              }
        -: 3136:
        1: 3137:              scanner_binding_literal_t binding_literal;
        1: 3138:              binding_literal.literal_p = argument_literal_p;
        -: 3139:
        1: 3140:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
        1: 3141:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        1: 3142:              break;
        -: 3143:            }
        -: 3144:          }
        -: 3145:#else /* !JERRY_ESNEXT */
    #####: 3146:          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)
        -: 3147:          {
        -: 3148:            while (true)
        -: 3149:            {
    #####: 3150:              if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3151:              {
    #####: 3152:                scanner_raise_error (context_p);
        -: 3153:              }
        -: 3154:
    #####: 3155:              scanner_append_argument (context_p, &scanner_context);
    #####: 3156:              lexer_next_token (context_p);
        -: 3157:
    #####: 3158:              if (context_p->token.type != LEXER_COMMA)
        -: 3159:              {
        -: 3160:                break;
        -: 3161:              }
        -: 3162:
    #####: 3163:              lexer_next_token (context_p);
        -: 3164:            }
        -: 3165:          }
        -: 3166:#endif /* JERRY_ESNEXT */
        -: 3167:
       22: 3168:          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)
        -: 3169:          {
        -: 3170:            /* End of argument parsing. */
    #####: 3171:            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));
    #####: 3172:            scanner_info_p->next_p = context_p->next_scanner_info_p;
    #####: 3173:            scanner_info_p->source_p = NULL;
    #####: 3174:            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;
    #####: 3175:            scanner_context.end_arguments_p = scanner_info_p;
        -: 3176:
    #####: 3177:            context_p->next_scanner_info_p = scanner_info_p;
    #####: 3178:            context_p->source_p = context_p->source_start_p;
    #####: 3179:            context_p->source_end_p = context_p->source_start_p + context_p->source_size;
    #####: 3180:            lexer_init_line_info (context_p);
        -: 3181:
        -: 3182:#if JERRY_ESNEXT
    #####: 3183:            scanner_filter_arguments (context_p, &scanner_context);
        -: 3184:#endif /* JERRY_ESNEXT */
    #####: 3185:            lexer_next_token (context_p);
    #####: 3186:            scanner_check_directives (context_p, &scanner_context);
    #####: 3187:            continue;
        -: 3188:          }
        -: 3189:
       22: 3190:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 3191:          {
    #####: 3192:            scanner_raise_error (context_p);
        -: 3193:          }
        -: 3194:
       22: 3195:          lexer_next_token (context_p);
        -: 3196:
       22: 3197:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 3198:          {
    #####: 3199:            scanner_raise_error (context_p);
        -: 3200:          }
        -: 3201:
        -: 3202:#if JERRY_ESNEXT
       22: 3203:          scanner_filter_arguments (context_p, &scanner_context);
        -: 3204:#endif /* JERRY_ESNEXT */
       22: 3205:          lexer_next_token (context_p);
       22: 3206:          scanner_check_directives (context_p, &scanner_context);
       22: 3207:          continue;
        -: 3208:        }
    #####: 3209:        case SCAN_MODE_PROPERTY_NAME:
        -: 3210:        {
    #####: 3211:          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -: 3212:
    #####: 3213:          if (lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS))
        -: 3214:          {
    #####: 3215:            lexer_check_property_modifier (context_p);
        -: 3216:          }
        -: 3217:
        -: 3218:#if JERRY_ESNEXT
    #####: 3219:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3220:          {
    #####: 3221:            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);
    #####: 3222:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3223:            break;
        -: 3224:          }
        -: 3225:
    #####: 3226:          if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3227:          {
    #####: 3228:            *parser_stack_get_prev_uint8 (context_p) |= SCANNER_LITERAL_OBJECT_HAS_REST;
    #####: 3229:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3230:
    #####: 3231:            if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3232:            {
    #####: 3233:              scanner_context.mode = SCAN_MODE_BINDING;
        -: 3234:            }
    #####: 3235:            break;
        -: 3236:          }
        -: 3237:#endif /* JERRY_ESNEXT */
        -: 3238:
    #####: 3239:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3240:          {
    #####: 3241:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 3242:            continue;
        -: 3243:          }
        -: 3244:
    #####: 3245:          if (context_p->token.type == LEXER_PROPERTY_GETTER
        -: 3246:#if JERRY_ESNEXT
    #####: 3247:              || context_p->token.type == LEXER_KEYW_ASYNC || context_p->token.type == LEXER_MULTIPLY
        -: 3248:#endif /* JERRY_ESNEXT */
    #####: 3249:              || context_p->token.type == LEXER_PROPERTY_SETTER)
        -: 3250:          {
    #####: 3251:            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 3252:
        -: 3253:#if JERRY_ESNEXT
    #####: 3254:            if (context_p->token.type == LEXER_MULTIPLY)
        -: 3255:            {
    #####: 3256:              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 3257:            }
    #####: 3258:            else if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 3259:            {
    #####: 3260:              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 3261:
    #####: 3262:              if (lexer_consume_generator (context_p))
        -: 3263:              {
    #####: 3264:                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 3265:              }
        -: 3266:            }
        -: 3267:#endif /* JERRY_ESNEXT */
        -: 3268:
    #####: 3269:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 3270:            lexer_scan_identifier (context_p, LEXER_PARSE_NO_OPTS);
        -: 3271:
        -: 3272:#if JERRY_ESNEXT
    #####: 3273:            if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 3274:            {
    #####: 3275:              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 3276:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3277:              break;
        -: 3278:            }
        -: 3279:#endif /* JERRY_ESNEXT */
        -: 3280:
    #####: 3281:            if (context_p->token.type != LEXER_LITERAL)
        -: 3282:            {
    #####: 3283:              scanner_raise_error (context_p);
        -: 3284:            }
        -: 3285:
    #####: 3286:            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
    #####: 3287:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 3288:            break;
        -: 3289:          }
        -: 3290:
    #####: 3291:          if (context_p->token.type != LEXER_LITERAL)
        -: 3292:          {
    #####: 3293:            scanner_raise_error (context_p);
        -: 3294:          }
        -: 3295:
        -: 3296:#if JERRY_ESNEXT
    #####: 3297:          parser_line_counter_t start_line = context_p->token.line;
    #####: 3298:          parser_line_counter_t start_column = context_p->token.column;
    #####: 3299:          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 3300:#endif /* JERRY_ESNEXT */
        -: 3301:
    #####: 3302:          lexer_next_token (context_p);
        -: 3303:
        -: 3304:#if JERRY_ESNEXT
    #####: 3305:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 3306:          {
    #####: 3307:            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
        -: 3308:
    #####: 3309:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 3310:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 3311:            continue;
        -: 3312:          }
        -: 3313:
    #####: 3314:          if (is_ident
    #####: 3315:              && (context_p->token.type == LEXER_COMMA || context_p->token.type == LEXER_RIGHT_BRACE
    #####: 3316:                  || context_p->token.type == LEXER_ASSIGN))
        -: 3317:          {
    #####: 3318:            context_p->source_p = context_p->token.lit_location.char_p;
    #####: 3319:            context_p->line = start_line;
    #####: 3320:            context_p->column = start_column;
        -: 3321:
    #####: 3322:            lexer_next_token (context_p);
        -: 3323:
    #####: 3324:            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL
        -: 3325:                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 3326:
    #####: 3327:            if (context_p->token.type != LEXER_LITERAL)
        -: 3328:            {
    #####: 3329:              scanner_raise_error (context_p);
        -: 3330:            }
        -: 3331:
    #####: 3332:            if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3333:            {
    #####: 3334:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 3335:              continue;
        -: 3336:            }
        -: 3337:
    #####: 3338:            scanner_add_reference (context_p, &scanner_context);
        -: 3339:
    #####: 3340:            lexer_next_token (context_p);
        -: 3341:
    #####: 3342:            if (context_p->token.type == LEXER_ASSIGN)
        -: 3343:            {
    #####: 3344:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3345:              break;
        -: 3346:            }
        -: 3347:
    #####: 3348:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 3349:            continue;
        -: 3350:          }
        -: 3351:#endif /* JERRY_ESNEXT */
        -: 3352:
    #####: 3353:          if (context_p->token.type != LEXER_COLON)
        -: 3354:          {
    #####: 3355:            scanner_raise_error (context_p);
        -: 3356:          }
        -: 3357:
    #####: 3358:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3359:
        -: 3360:#if JERRY_ESNEXT
    #####: 3361:          if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3362:          {
    #####: 3363:            scanner_context.mode = SCAN_MODE_BINDING;
        -: 3364:          }
        -: 3365:#endif /* JERRY_ESNEXT */
    #####: 3366:          break;
        -: 3367:        }
        -: 3368:#if JERRY_ESNEXT
    #####: 3369:        case SCAN_MODE_BINDING:
        -: 3370:        {
    #####: 3371:          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR
        -: 3372:                        || scanner_context.binding_type == SCANNER_BINDING_LET
        -: 3373:                        || scanner_context.binding_type == SCANNER_BINDING_CATCH
        -: 3374:                        || scanner_context.binding_type == SCANNER_BINDING_CONST
        -: 3375:                        || scanner_context.binding_type == SCANNER_BINDING_ARG
        -: 3376:                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);
        -: 3377:
    #####: 3378:          if (type == LEXER_THREE_DOTS)
        -: 3379:          {
    #####: 3380:            lexer_next_token (context_p);
    #####: 3381:            type = (lexer_token_type_t) context_p->token.type;
        -: 3382:          }
        -: 3383:
    #####: 3384:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 3385:          {
    #####: 3386:            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);
        -: 3387:
    #####: 3388:            if (type == LEXER_LEFT_SQUARE)
        -: 3389:            {
    #####: 3390:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 3391:              break;
        -: 3392:            }
        -: 3393:
    #####: 3394:            parser_stack_push_uint8 (context_p, 0);
    #####: 3395:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 3396:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 3397:            continue;
        -: 3398:          }
        -: 3399:
    #####: 3400:          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3401:          {
    #####: 3402:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3403:            continue;
        -: 3404:          }
        -: 3405:
    #####: 3406:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 3407:
    #####: 3408:          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 3409:
    #####: 3410:          if (scanner_context.binding_type == SCANNER_BINDING_VAR)
        -: 3411:          {
    #####: 3412:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 3413:            {
    #####: 3414:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
    #####: 3415:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 3416:
    #####: 3417:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 3418:              {
    #####: 3419:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 3420:              }
        -: 3421:            }
    #####: 3422:            break;
        -: 3423:          }
        -: 3424:
    #####: 3425:          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)
        -: 3426:          {
    #####: 3427:            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
        -: 3428:
    #####: 3429:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3430:            {
    #####: 3431:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3432:              break;
        -: 3433:            }
        -: 3434:          }
        -: 3435:          else
        -: 3436:          {
    #####: 3437:            scanner_detect_invalid_let (context_p, literal_p);
        -: 3438:
    #####: 3439:            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)
        -: 3440:            {
    #####: 3441:              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)
        -: 3442:                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));
        -: 3443:
    #####: 3444:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 3445:            }
        -: 3446:            else
        -: 3447:            {
    #####: 3448:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 3449:
    #####: 3450:              if (scanner_context.binding_type == SCANNER_BINDING_ARG)
        -: 3451:              {
    #####: 3452:                literal_p->type |= SCANNER_LITERAL_IS_ARG;
        -: 3453:
    #####: 3454:                if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3455:                {
    #####: 3456:                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3457:                  break;
        -: 3458:                }
        -: 3459:              }
        -: 3460:            }
        -: 3461:
    #####: 3462:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3463:            {
    #####: 3464:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3465:              break;
        -: 3466:            }
        -: 3467:          }
        -: 3468:
        -: 3469:          scanner_binding_item_t *binding_item_p;
    #####: 3470:          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));
        -: 3471:
    #####: 3472:          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;
    #####: 3473:          binding_item_p->literal_p = literal_p;
        -: 3474:
    #####: 3475:          scanner_context.active_binding_list_p->items_p = binding_item_p;
        -: 3476:
    #####: 3477:          lexer_next_token (context_p);
    #####: 3478:          if (context_p->token.type != LEXER_ASSIGN)
        -: 3479:          {
    #####: 3480:            continue;
        -: 3481:          }
        -: 3482:
    #####: 3483:          scanner_binding_literal_t binding_literal;
    #####: 3484:          binding_literal.literal_p = literal_p;
        -: 3485:
    #####: 3486:          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 3487:          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 3488:
    #####: 3489:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3490:          break;
        -: 3491:        }
        -: 3492:#endif /* JERRY_ESNEXT */
        -: 3493:      }
        -: 3494:
      173: 3495:      lexer_next_token (context_p);
        -: 3496:    }
        -: 3497:
        1: 3498:scan_completed:
        1: 3499:    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)
        -: 3500:    {
    #####: 3501:      scanner_raise_error (context_p);
        -: 3502:    }
        -: 3503:
        1: 3504:    scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3505:
        -: 3506:#if JERRY_ESNEXT
        1: 3507:    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);
        -: 3508:#endif /* JERRY_ESNEXT */
        1: 3509:    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);
        -: 3510:
        -: 3511:#ifndef JERRY_NDEBUG
        1: 3512:    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;
        -: 3513:#endif /* !JERRY_NDEBUG */
        -: 3514:  }
        -: 3515:  PARSER_CATCH
        -: 3516:  {
        -: 3517:#if JERRY_ESNEXT
    #####: 3518:    while (scanner_context.active_binding_list_p != NULL)
        -: 3519:    {
    #####: 3520:      scanner_pop_binding_list (&scanner_context);
        -: 3521:    }
        -: 3522:#endif /* JERRY_ESNEXT */
        -: 3523:
    #####: 3524:    if (JERRY_UNLIKELY (context_p->error != PARSER_ERR_OUT_OF_MEMORY))
        -: 3525:    {
        -: 3526:      /* Ignore the errors thrown by the lexer. */
    #####: 3527:      context_p->error = PARSER_ERR_NO_ERROR;
        -: 3528:
        -: 3529:      /* The following code may allocate memory, so it is enclosed in a try/catch. */
    #####: 3530:      PARSER_TRY (context_p->try_buffer)
        -: 3531:      {
        -: 3532:#if JERRY_ESNEXT
    #####: 3533:        if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)
        -: 3534:        {
    #####: 3535:          JERRY_ASSERT (scanner_context.async_source_p != NULL);
        -: 3536:
        -: 3537:          scanner_info_t *info_p;
    #####: 3538:          info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));
    #####: 3539:          info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;
        -: 3540:        }
        -: 3541:#endif /* JERRY_ESNEXT */
        -: 3542:
    #####: 3543:        while (scanner_context.active_literal_pool_p != NULL)
        -: 3544:        {
    #####: 3545:          scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3546:        }
        -: 3547:      }
        -: 3548:      PARSER_CATCH
        -: 3549:      {
    #####: 3550:        JERRY_ASSERT (context_p->error == PARSER_ERR_OUT_OF_MEMORY);
        -: 3551:      }
        -: 3552:      PARSER_TRY_END
        -: 3553:    }
        -: 3554:
    #####: 3555:    JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR || context_p->error == PARSER_ERR_OUT_OF_MEMORY);
        -: 3556:
    #####: 3557:    if (context_p->error == PARSER_ERR_OUT_OF_MEMORY)
        -: 3558:    {
    #####: 3559:      while (scanner_context.active_literal_pool_p != NULL)
        -: 3560:      {
    #####: 3561:        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 3562:
    #####: 3563:        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;
        -: 3564:
    #####: 3565:        parser_list_free (&literal_pool_p->literal_pool);
    #####: 3566:        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 3567:      }
        -: 3568:
    #####: 3569:      parser_stack_free (context_p);
    #####: 3570:      return;
        -: 3571:    }
        -: 3572:  }
        -: 3573:  PARSER_TRY_END
        -: 3574:
        1: 3575:  context_p->status_flags = scanner_context.context_status_flags;
        -: 3576:#if JERRY_ESNEXT
        1: 3577:  context_p->global_status_flags &= (uint32_t) ~ECMA_PARSE_INTERNAL_PRE_SCANNING;
        -: 3578:#endif /* JERRY_ESNEXT */
        1: 3579:  scanner_reverse_info_list (context_p);
        -: 3580:
        -: 3581:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 3582:  if (context_p->is_show_opcodes)
        -: 3583:  {
        -: 3584:    scanner_info_t *info_p = context_p->next_scanner_info_p;
        -: 3585:    const uint8_t *source_start_p =
        -: 3586:      (context_p->arguments_start_p == NULL ? context_p->source_start_p : context_p->arguments_start_p);
        -: 3587:
        -: 3588:    while (info_p->type != SCANNER_TYPE_END)
        -: 3589:    {
        -: 3590:      const char *name_p = NULL;
        -: 3591:      bool print_location = false;
        -: 3592:
        -: 3593:      switch (info_p->type)
        -: 3594:      {
        -: 3595:        case SCANNER_TYPE_END_ARGUMENTS:
        -: 3596:        {
        -: 3597:          JERRY_DEBUG_MSG ("  END_ARGUMENTS\n");
        -: 3598:          source_start_p = context_p->source_start_p;
        -: 3599:          break;
        -: 3600:        }
        -: 3601:        case SCANNER_TYPE_FUNCTION:
        -: 3602:        case SCANNER_TYPE_BLOCK:
        -: 3603:        {
        -: 3604:          const uint8_t *prev_source_p = info_p->source_p - 1;
        -: 3605:          const uint8_t *data_p;
        -: 3606:
        -: 3607:          if (info_p->type == SCANNER_TYPE_FUNCTION)
        -: 3608:          {
        -: 3609:            data_p = (const uint8_t *) (info_p + 1);
        -: 3610:
        -: 3611:            JERRY_DEBUG_MSG ("  FUNCTION: flags: 0x%x declarations: %d", (int) info_p->u8_arg, (int) info_p->u16_arg);
        -: 3612:          }
        -: 3613:          else
        -: 3614:          {
        -: 3615:            data_p = (const uint8_t *) (info_p + 1);
        -: 3616:
        -: 3617:            JERRY_DEBUG_MSG ("  BLOCK:");
        -: 3618:          }
        -: 3619:
        -: 3620:          JERRY_DEBUG_MSG (" source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3621:
        -: 3622:          while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 3623:          {
        -: 3624:            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -: 3625:            {
        -: 3626:              case SCANNER_STREAM_TYPE_HOLE:
        -: 3627:              {
        -: 3628:                JERRY_DEBUG_MSG ("    HOLE\n");
        -: 3629:                data_p++;
        -: 3630:                continue;
        -: 3631:              }
        -: 3632:#if JERRY_ESNEXT
        -: 3633:              case SCANNER_STREAM_TYPE_ARGUMENTS:
        -: 3634:              {
        -: 3635:                JERRY_DEBUG_MSG ("    ARGUMENTS%s%s\n",
        -: 3636:                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "",
        -: 3637:                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? " L" : "");
        -: 3638:                data_p++;
        -: 3639:                continue;
        -: 3640:              }
        -: 3641:              case SCANNER_STREAM_TYPE_ARGUMENTS_FUNC:
        -: 3642:              {
        -: 3643:                JERRY_DEBUG_MSG ("    ARGUMENTS_FUNC%s%s\n",
        -: 3644:                                 (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "",
        -: 3645:                                 (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS) ? " L" : "");
        -: 3646:                data_p++;
        -: 3647:                continue;
        -: 3648:              }
        -: 3649:#else /* !JERRY_ESNEXT */
        -: 3650:              case SCANNER_STREAM_TYPE_ARGUMENTS:
        -: 3651:              {
        -: 3652:                JERRY_DEBUG_MSG ("    ARGUMENTS%s\n", (data_p[0] & SCANNER_STREAM_NO_REG) ? " *" : "");
        -: 3653:                data_p++;
        -: 3654:                continue;
        -: 3655:              }
        -: 3656:#endif /* JERRY_ESNEXT */
        -: 3657:              case SCANNER_STREAM_TYPE_VAR:
        -: 3658:              {
        -: 3659:                JERRY_DEBUG_MSG ("    VAR ");
        -: 3660:                break;
        -: 3661:              }
        -: 3662:#if JERRY_ESNEXT
        -: 3663:              case SCANNER_STREAM_TYPE_LET:
        -: 3664:              {
        -: 3665:                JERRY_DEBUG_MSG ("    LET ");
        -: 3666:                break;
        -: 3667:              }
        -: 3668:              case SCANNER_STREAM_TYPE_CONST:
        -: 3669:              {
        -: 3670:                JERRY_DEBUG_MSG ("    CONST ");
        -: 3671:                break;
        -: 3672:              }
        -: 3673:              case SCANNER_STREAM_TYPE_LOCAL:
        -: 3674:              {
        -: 3675:                JERRY_DEBUG_MSG ("    LOCAL ");
        -: 3676:                break;
        -: 3677:              }
        -: 3678:#endif /* JERRY_ESNEXT */
        -: 3679:#if JERRY_MODULE_SYSTEM
        -: 3680:              case SCANNER_STREAM_TYPE_IMPORT:
        -: 3681:              {
        -: 3682:                JERRY_DEBUG_MSG ("    IMPORT ");
        -: 3683:                break;
        -: 3684:              }
        -: 3685:#endif /* JERRY_MODULE_SYSTEM */
        -: 3686:              case SCANNER_STREAM_TYPE_ARG:
        -: 3687:              {
        -: 3688:                JERRY_DEBUG_MSG ("    ARG ");
        -: 3689:                break;
        -: 3690:              }
        -: 3691:#if JERRY_ESNEXT
        -: 3692:              case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 3693:              {
        -: 3694:                JERRY_DEBUG_MSG ("    ARG_VAR ");
        -: 3695:                break;
        -: 3696:              }
        -: 3697:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 3698:              {
        -: 3699:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG ");
        -: 3700:                break;
        -: 3701:              }
        -: 3702:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 3703:              {
        -: 3704:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG_VAR ");
        -: 3705:                break;
        -: 3706:              }
        -: 3707:#endif /* JERRY_ESNEXT */
        -: 3708:              case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 3709:              {
        -: 3710:                JERRY_DEBUG_MSG ("    ARG_FUNC ");
        -: 3711:                break;
        -: 3712:              }
        -: 3713:#if JERRY_ESNEXT
        -: 3714:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 3715:              {
        -: 3716:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG_FUNC ");
        -: 3717:                break;
        -: 3718:              }
        -: 3719:#endif /* JERRY_ESNEXT */
        -: 3720:              case SCANNER_STREAM_TYPE_FUNC:
        -: 3721:              {
        -: 3722:                JERRY_DEBUG_MSG ("    FUNC ");
        -: 3723:                break;
        -: 3724:              }
        -: 3725:              default:
        -: 3726:              {
        -: 3727:                JERRY_UNREACHABLE ();
        -: 3728:                data_p++;
        -: 3729:                continue;
        -: 3730:              }
        -: 3731:            }
        -: 3732:
        -: 3733:            size_t length;
        -: 3734:
        -: 3735:            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 3736:            {
        -: 3737:              if (data_p[2] != 0)
        -: 3738:              {
        -: 3739:                prev_source_p += data_p[2];
        -: 3740:                length = 2 + 1;
        -: 3741:              }
        -: 3742:              else
        -: 3743:              {
        -: 3744:                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (uintptr_t));
        -: 3745:                length = 2 + 1 + sizeof (uintptr_t);
        -: 3746:              }
        -: 3747:            }
        -: 3748:            else
        -: 3749:            {
        -: 3750:              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 3751:
        -: 3752:              if (diff <= UINT8_MAX)
        -: 3753:              {
        -: 3754:                diff = -diff;
        -: 3755:              }
        -: 3756:
        -: 3757:              prev_source_p += diff;
        -: 3758:              length = 2 + 2;
        -: 3759:            }
        -: 3760:
        -: 3761:#if JERRY_ESNEXT
        -: 3762:            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 3763:            {
        -: 3764:              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 3765:              JERRY_DEBUG_MSG ("*");
        -: 3766:            }
        -: 3767:#endif /* JERRY_ESNEXT */
        -: 3768:
        -: 3769:            if (data_p[0] & SCANNER_STREAM_NO_REG)
        -: 3770:            {
        -: 3771:              JERRY_DEBUG_MSG ("* ");
        -: 3772:            }
        -: 3773:
        -: 3774:            JERRY_DEBUG_MSG ("'%.*s'\n", data_p[1], (char *) prev_source_p);
        -: 3775:            prev_source_p += data_p[1];
        -: 3776:            data_p += length;
        -: 3777:          }
        -: 3778:          break;
        -: 3779:        }
        -: 3780:        case SCANNER_TYPE_WHILE:
        -: 3781:        {
        -: 3782:          name_p = "WHILE";
        -: 3783:          print_location = true;
        -: 3784:          break;
        -: 3785:        }
        -: 3786:        case SCANNER_TYPE_FOR:
        -: 3787:        {
        -: 3788:          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;
        -: 3789:          JERRY_DEBUG_MSG ("  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\n",
        -: 3790:                           (int) (for_info_p->info.source_p - source_start_p),
        -: 3791:                           (int) (for_info_p->expression_location.source_p - source_start_p),
        -: 3792:                           (int) for_info_p->expression_location.line,
        -: 3793:                           (int) for_info_p->expression_location.column,
        -: 3794:                           (int) (for_info_p->end_location.source_p - source_start_p),
        -: 3795:                           (int) for_info_p->end_location.line,
        -: 3796:                           (int) for_info_p->end_location.column);
        -: 3797:          break;
        -: 3798:        }
        -: 3799:        case SCANNER_TYPE_FOR_IN:
        -: 3800:        {
        -: 3801:          name_p = "FOR-IN";
        -: 3802:          print_location = true;
        -: 3803:          break;
        -: 3804:        }
        -: 3805:#if JERRY_ESNEXT
        -: 3806:        case SCANNER_TYPE_FOR_OF:
        -: 3807:        {
        -: 3808:          name_p = "FOR-OF";
        -: 3809:          print_location = true;
        -: 3810:          break;
        -: 3811:        }
        -: 3812:#endif /* JERRY_ESNEXT */
        -: 3813:        case SCANNER_TYPE_SWITCH:
        -: 3814:        {
        -: 3815:          JERRY_DEBUG_MSG ("  SWITCH: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3816:
        -: 3817:          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;
        -: 3818:
        -: 3819:          while (current_case_p != NULL)
        -: 3820:          {
        -: 3821:            JERRY_DEBUG_MSG ("    CASE: location:%d[%d:%d]\n",
        -: 3822:                             (int) (current_case_p->location.source_p - source_start_p),
        -: 3823:                             (int) current_case_p->location.line,
        -: 3824:                             (int) current_case_p->location.column);
        -: 3825:
        -: 3826:            current_case_p = current_case_p->next_p;
        -: 3827:          }
        -: 3828:          break;
        -: 3829:        }
        -: 3830:        case SCANNER_TYPE_CASE:
        -: 3831:        {
        -: 3832:          name_p = "CASE";
        -: 3833:          print_location = true;
        -: 3834:          break;
        -: 3835:        }
        -: 3836:#if JERRY_ESNEXT
        -: 3837:        case SCANNER_TYPE_INITIALIZER:
        -: 3838:        {
        -: 3839:          scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;
        -: 3840:          JERRY_DEBUG_MSG ("  INITIALIZER: flags: 0x%x source:%d location:%d[%d:%d]\n",
        -: 3841:                           (int) info_p->u8_arg,
        -: 3842:                           (int) (location_info_p->info.source_p - source_start_p),
        -: 3843:                           (int) (location_info_p->location.source_p - source_start_p),
        -: 3844:                           (int) location_info_p->location.line,
        -: 3845:                           (int) location_info_p->location.column);
        -: 3846:          break;
        -: 3847:        }
        -: 3848:        case SCANNER_TYPE_CLASS_CONSTRUCTOR:
        -: 3849:        {
        -: 3850:          JERRY_DEBUG_MSG ("  CLASS: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3851:          print_location = false;
        -: 3852:          break;
        -: 3853:        }
        -: 3854:        case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:
        -: 3855:        {
        -: 3856:          name_p = "SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END";
        -: 3857:          print_location = true;
        -: 3858:          break;
        -: 3859:        }
        -: 3860:        case SCANNER_TYPE_LET_EXPRESSION:
        -: 3861:        {
        -: 3862:          JERRY_DEBUG_MSG ("  LET_EXPRESSION: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3863:          break;
        -: 3864:        }
        -: 3865:        case SCANNER_TYPE_ERR_REDECLARED:
        -: 3866:        {
        -: 3867:          JERRY_DEBUG_MSG ("  ERR_REDECLARED: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3868:          break;
        -: 3869:        }
        -: 3870:        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:
        -: 3871:        {
        -: 3872:          JERRY_DEBUG_MSG ("  ERR_ASYNC_FUNCTION: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3873:          break;
        -: 3874:        }
        -: 3875:        case SCANNER_TYPE_LITERAL_FLAGS:
        -: 3876:        {
        -: 3877:          JERRY_DEBUG_MSG ("  SCANNER_TYPE_LITERAL_FLAGS: flags: 0x%x source:%d\n",
        -: 3878:                           (int) info_p->u8_arg,
        -: 3879:                           (int) (info_p->source_p - source_start_p));
        -: 3880:          print_location = false;
        -: 3881:          break;
        -: 3882:        }
        -: 3883:        case SCANNER_TYPE_EXPORT_MODULE_SPECIFIER:
        -: 3884:        {
        -: 3885:          JERRY_DEBUG_MSG ("  EXPORT_WITH_MODULE_SPECIFIER: source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3886:          print_location = false;
        -: 3887:          break;
        -: 3888:        }
        -: 3889:#endif /* JERRY_ESNEXT */
        -: 3890:      }
        -: 3891:
        -: 3892:      if (print_location)
        -: 3893:      {
        -: 3894:        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;
        -: 3895:        JERRY_DEBUG_MSG ("  %s: source:%d location:%d[%d:%d]\n",
        -: 3896:                         name_p,
        -: 3897:                         (int) (location_info_p->info.source_p - source_start_p),
        -: 3898:                         (int) (location_info_p->location.source_p - source_start_p),
        -: 3899:                         (int) location_info_p->location.line,
        -: 3900:                         (int) location_info_p->location.column);
        -: 3901:      }
        -: 3902:
        -: 3903:      info_p = info_p->next_p;
        -: 3904:    }
        -: 3905:
        -: 3906:    JERRY_DEBUG_MSG ("\n--- Scanning end ---\n\n");
        -: 3907:  }
        -: 3908:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 3909:
        1: 3910:  parser_stack_free (context_p);
        -: 3911:} /* scanner_scan_all */
        -: 3912:
        -: 3913:/**
        -: 3914: * @}
        -: 3915: * @}
        -: 3916: * @}
        -: 3917: */
        -: 3918:
        -: 3919:#endif /* JERRY_PARSER */
