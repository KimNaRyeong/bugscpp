        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-expr.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:#include "ecma-helpers.h"
        -:   20:
        -:   21:#include "jcontext.h"
        -:   22:#include "js-parser-tagged-template-literal.h"
        -:   23:#include "lit-char-helpers.h"
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_expr Expression parser
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Maximum precedence for right-to-left binary operation evaluation.
        -:   37: */
        -:   38:#define PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE 7
        -:   39:
        -:   40:/**
        -:   41: * Precedence for ternary operation.
        -:   42: */
        -:   43:#define PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE 4
        -:   44:
        -:   45:/**
        -:   46: * Precedence for exponentiation operation.
        -:   47: */
        -:   48:#define PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION 16
        -:   49:
        -:   50:/**
        -:   51: * Value of grouping level increase and decrease.
        -:   52: */
        -:   53:#define PARSER_GROUPING_LEVEL_INCREASE 2
        -:   54:
        -:   55:/**
        -:   56: * Precedence of the binary tokens.
        -:   57: *
        -:   58: * See also:
        -:   59: *    lexer_token_type_t
        -:   60: */
        -:   61:static const uint8_t parser_binary_precedence_table[] = {
        -:   62:  3, /**< "=" */
        -:   63:  3, /**< "+=" */
        -:   64:  3, /**< "-=" */
        -:   65:  3, /**< "*=" */
        -:   66:  3, /**< "/=" */
        -:   67:  3, /**< "=" */
        -:   68:  3, /**< "<<=" */
        -:   69:  3, /**< ">>=" */
        -:   70:  3, /**< ">>>=" */
        -:   71:  3, /**< "&=" */
        -:   72:  3, /**< "|=" */
        -:   73:  3, /**< "^=" */
        -:   74:#if JERRY_ESNEXT
        -:   75:  3, /**< "**=" */
        -:   76:  3, /**< "??=" */
        -:   77:  3, /**< "||=" */
        -:   78:  3, /**< "&&=" */
        -:   79:#endif /* JERRY_ESNEXT */
        -:   80:  4, /**< "?"*/
        -:   81:#if JERRY_ESNEXT
        -:   82:  5, /**< "??" */
        -:   83:#endif /* JERRY_ESNEXT */
        -:   84:  6, /**< "||" */
        -:   85:  7, /**< "&&" */
        -:   86:  8, /**< "|" */
        -:   87:  9, /**< "^" */
        -:   88:  10, /**< "&" */
        -:   89:  11, /**< "==" */
        -:   90:  11, /**< "!=" */
        -:   91:  11, /**< "===" */
        -:   92:  11, /**< "!==" */
        -:   93:  12, /**< "<" */
        -:   94:  12, /**< ">" */
        -:   95:  12, /**< "<=" */
        -:   96:  12, /**< ">=" */
        -:   97:  12, /**< in */
        -:   98:  12, /**< instanceof */
        -:   99:  13, /**< "<<" */
        -:  100:  13, /**< ">>" */
        -:  101:  13, /**< ">>>" */
        -:  102:  14, /**< "+" */
        -:  103:  14, /**< "-" */
        -:  104:  15, /**< "*" */
        -:  105:  15, /**< "/" */
        -:  106:  15, /**< "%" */
        -:  107:#if JERRY_ESNEXT
        -:  108:  16, /**< "**" */
        -:  109:#endif /* JERRY_ESNEXT */
        -:  110:};
        -:  111:
        -:  112:#if JERRY_ESNEXT
        -:  113:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 42,
        -:  114:                     parser_binary_precedence_table_should_have_39_values_in_es2015);
        -:  115:#else /* !JERRY_ESNEXT */
        -:  116:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 36,
        -:  117:                     parser_binary_precedence_table_should_have_36_values_in_es51);
        -:  118:#endif /* JERRY_ESNEXT */
        -:  119:
        -:  120:/**
        -:  121: * Generate byte code for operators with lvalue.
        -:  122: */
        -:  123:static inline void
       81:  124:parser_push_result (parser_context_t *context_p) /**< context */
        -:  125:{
       81:  126:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -:  127:  {
        6:  128:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));
        -:  129:
        6:  130:    if ((context_p->last_cbc_opcode == CBC_POST_INCR || context_p->last_cbc_opcode == CBC_POST_DECR)
    #####:  131:        && context_p->stack_depth >= context_p->stack_limit)
        -:  132:    {
        -:  133:      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT
        -:  134:       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */
    #####:  135:      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -:  136:
    #####:  137:      context_p->stack_limit++;
        -:  138:
    #####:  139:      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  140:      {
    #####:  141:        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  142:      }
        -:  143:    }
        -:  144:
        6:  145:    context_p->last_cbc_opcode++;
        6:  146:    parser_flush_cbc (context_p);
        -:  147:  }
       81:  148:} /* parser_push_result */
        -:  149:
        -:  150:/**
        -:  151: * Check for invalid assignment for "eval" and "arguments"
        -:  152: */
        -:  153:static void
        1:  154:parser_check_invalid_assign (parser_context_t *context_p) /**< context */
        -:  155:{
        1:  156:  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);
        -:  157:
        1:  158:  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  159:  {
    #####:  160:    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)
        -:  161:    {
    #####:  162:      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);
        -:  163:    }
    #####:  164:    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)
        -:  165:    {
    #####:  166:      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);
        -:  167:    }
        -:  168:  }
        1:  169:} /* parser_check_invalid_assign */
        -:  170:
        -:  171:#if JERRY_ESNEXT
        -:  172:
        -:  173:/**
        -:  174: * Check and throw an error if the "new.target" is invalid as a left-hand side expression.
        -:  175: */
        -:  176:static void
    #####:  177:parser_check_invalid_new_target (parser_context_t *context_p, /**< parser context */
        -:  178:                                 cbc_opcode_t opcode) /**< current opcode under parsing */
        -:  179:{
        -:  180:  /* new.target is an invalid left-hand side target */
    #####:  181:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NEW_TARGET))
        -:  182:  {
        -:  183:    /* Make sure that the call side is a post/pre increment or an assignment expression.
        -:  184:     * There should be no other ways the "new.target" expression should be here. */
    #####:  185:    JERRY_ASSERT (
        -:  186:      (opcode >= CBC_PRE_INCR && opcode <= CBC_POST_DECR)
        -:  187:      || (opcode == CBC_ASSIGN
        -:  188:          && (context_p->token.type == LEXER_ASSIGN || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->token.type))));
        -:  189:
    #####:  190:    parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -:  191:  }
    #####:  192:} /* parser_check_invalid_new_target */
        -:  193:
        -:  194:#endif /* JERRY_ESNEXT */
        -:  195:
        -:  196:/**
        -:  197: * Emit identifier reference
        -:  198: */
        -:  199:static void
        1:  200:parser_emit_ident_reference (parser_context_t *context_p, /**< context */
        -:  201:                             uint16_t opcode) /* opcode */
        -:  202:{
        1:  203:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  204:  {
        1:  205:    context_p->last_cbc_opcode = opcode;
        1:  206:    return;
        -:  207:  }
        -:  208:
        -:  209:  uint16_t literal_index;
        -:  210:
    #####:  211:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  212:  {
    #####:  213:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  214:    literal_index = context_p->last_cbc.value;
        -:  215:  }
    #####:  216:  else if (context_p->last_cbc_opcode == CBC_PUSH_THIS_LITERAL)
        -:  217:  {
    #####:  218:    context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####:  219:    literal_index = context_p->last_cbc.literal_index;
        -:  220:  }
        -:  221:  else
        -:  222:  {
    #####:  223:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####:  224:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  225:    literal_index = context_p->last_cbc.third_literal_index;
        -:  226:  }
        -:  227:
    #####:  228:  parser_emit_cbc_literal (context_p, opcode, literal_index);
        -:  229:} /* parser_emit_ident_reference */
        -:  230:
        -:  231:/**
        -:  232: * Generate byte code for operators with lvalue.
        -:  233: */
        -:  234:static void
        1:  235:parser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */
        -:  236:                                 cbc_opcode_t opcode) /**< opcode */
        -:  237:{
        1:  238:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        1:  239:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -:  240:  {
        1:  241:    parser_check_invalid_assign (context_p);
        -:  242:
        -:  243:    uint16_t unary_opcode;
        -:  244:
        1:  245:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  246:    {
    #####:  247:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  248:      {
    #####:  249:        parser_raise_error (context_p, PARSER_ERR_DELETE_IDENT_NOT_ALLOWED);
        -:  250:      }
        -:  251:
    #####:  252:      unary_opcode = CBC_DELETE_IDENT_PUSH_RESULT;
        -:  253:    }
        -:  254:    else
        -:  255:    {
        1:  256:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, opcode + CBC_UNARY_LVALUE_WITH_IDENT));
        1:  257:      unary_opcode = (uint16_t) (opcode + CBC_UNARY_LVALUE_WITH_IDENT);
        -:  258:    }
        -:  259:
        1:  260:    parser_emit_ident_reference (context_p, unary_opcode);
        -:  261:
        -:  262:#if JERRY_ESNEXT
        1:  263:    if (unary_opcode != CBC_DELETE_IDENT_PUSH_RESULT
        1:  264:        && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -:  265:    {
        -:  266:      /* The current value must be read, but it cannot be changed. */
    #####:  267:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  268:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -:  269:    }
        -:  270:#endif /* JERRY_ESNEXT */
        1:  271:    return;
        -:  272:  }
        -:  273:
    #####:  274:  if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -:  275:  {
    #####:  276:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, opcode));
    #####:  277:    context_p->last_cbc_opcode = (uint16_t) opcode;
    #####:  278:    return;
        -:  279:  }
        -:  280:
    #####:  281:  if (PARSER_IS_PUSH_PROP_LITERAL (context_p->last_cbc_opcode))
        -:  282:  {
    #####:  283:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_LITERAL_TO_PUSH_LITERAL (context_p->last_cbc_opcode);
        -:  284:  }
        -:  285:  else
        -:  286:  {
        -:  287:    /* Invalid LeftHandSide expression. */
    #####:  288:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  289:    {
        -:  290:#if JERRY_ESNEXT
    #####:  291:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -:  292:      {
    #####:  293:        parser_raise_error (context_p, PARSER_ERR_DELETE_PRIVATE_FIELD);
        -:  294:      }
        -:  295:
    #####:  296:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL)
    #####:  297:          || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -:  298:      {
    #####:  299:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
    #####:  300:        parser_emit_cbc (context_p, CBC_POP);
    #####:  301:        return;
        -:  302:      }
        -:  303:#endif /* JERRY_ESNEXT */
    #####:  304:      parser_emit_cbc (context_p, CBC_POP);
    #####:  305:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####:  306:      return;
        -:  307:    }
        -:  308:
        -:  309:#if JERRY_ESNEXT
    #####:  310:    parser_check_invalid_new_target (context_p, opcode);
    #####:  311:    if (opcode == CBC_PRE_INCR || opcode == CBC_PRE_DECR)
        -:  312:    {
    #####:  313:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_PREFIX_OP);
        -:  314:    }
        -:  315:    else
        -:  316:    {
    #####:  317:      parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_POSTFIX_OP);
        -:  318:    }
        -:  319:#else /* JERRY_ESNEXT */
    #####:  320:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -:  321:#endif /* JERRY_ESNEXT */
        -:  322:  }
        -:  323:
    #####:  324:  parser_emit_cbc (context_p, (uint16_t) opcode);
        -:  325:} /* parser_emit_unary_lvalue_opcode */
        -:  326:
        -:  327:/**
        -:  328: * Parse array literal.
        -:  329: */
        -:  330:static void
    #####:  331:parser_parse_array_literal (parser_context_t *context_p) /**< context */
        -:  332:{
    #####:  333:  uint32_t pushed_items = 0;
    #####:  334:  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  335:
    #####:  336:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
        -:  337:
    #####:  338:  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);
    #####:  339:  lexer_next_token (context_p);
        -:  340:
        -:  341:  while (true)
        -:  342:  {
    #####:  343:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  344:    {
    #####:  345:      if (pushed_items > 0)
        -:  346:      {
    #####:  347:        parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  348:      }
    #####:  349:      return;
        -:  350:    }
        -:  351:
    #####:  352:    pushed_items++;
        -:  353:
    #####:  354:    if (context_p->token.type == LEXER_COMMA)
        -:  355:    {
    #####:  356:      parser_emit_cbc (context_p, CBC_PUSH_ELISION);
    #####:  357:      lexer_next_token (context_p);
        -:  358:    }
        -:  359:    else
        -:  360:    {
        -:  361:#if JERRY_ESNEXT
    #####:  362:      if (context_p->token.type == LEXER_THREE_DOTS)
        -:  363:      {
    #####:  364:        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));
    #####:  365:        pushed_items++;
    #####:  366:        lexer_next_token (context_p);
    #####:  367:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
        -:  368:      }
        -:  369:#endif /* JERRY_ESNEXT */
        -:  370:
    #####:  371:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  372:
    #####:  373:      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -:  374:      {
    #####:  375:        parser_flush_cbc (context_p);
        -:  376:      }
        -:  377:
    #####:  378:      if (context_p->token.type == LEXER_COMMA)
        -:  379:      {
    #####:  380:        lexer_next_token (context_p);
        -:  381:      }
    #####:  382:      else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -:  383:      {
    #####:  384:        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);
        -:  385:      }
        -:  386:    }
        -:  387:
    #####:  388:    if (pushed_items >= 64)
        -:  389:    {
    #####:  390:      parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  391:#if JERRY_ESNEXT
    #####:  392:      opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  393:#endif /* JERRY_ESNEXT */
    #####:  394:      pushed_items = 0;
        -:  395:    }
        -:  396:  }
        -:  397:} /* parser_parse_array_literal */
        -:  398:
        -:  399:#if !JERRY_ESNEXT
        -:  400:/**
        -:  401: * Object literal item types.
        -:  402: */
        -:  403:typedef enum
        -:  404:{
        -:  405:  PARSER_OBJECT_PROPERTY_START, /**< marks the start of the property list */
        -:  406:  PARSER_OBJECT_PROPERTY_VALUE, /**< value property */
        -:  407:  PARSER_OBJECT_PROPERTY_GETTER, /**< getter property */
        -:  408:  PARSER_OBJECT_PROPERTY_SETTER, /**< setter property */
        -:  409:  PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS, /**< both getter and setter properties are set */
        -:  410:} parser_object_literal_item_types_t;
        -:  411:
        -:  412:/**
        -:  413: * Parse object literal.
        -:  414: */
        -:  415:static void
    #####:  416:parser_append_object_literal_item (parser_context_t *context_p, /**< context */
        -:  417:                                   uint16_t item_index, /**< index of the item name */
        -:  418:                                   parser_object_literal_item_types_t item_type) /**< type of the item */
        -:  419:{
        -:  420:  parser_stack_iterator_t iterator;
        -:  421:  uint8_t *current_item_type_p;
        -:  422:
    #####:  423:  iterator.current_p = context_p->stack.first_p;
    #####:  424:  iterator.current_position = context_p->stack.last_position;
        -:  425:
        -:  426:  while (true)
        -:  427:  {
    #####:  428:    current_item_type_p = iterator.current_p->bytes + iterator.current_position - 1;
        -:  429:
    #####:  430:    if (*current_item_type_p == PARSER_OBJECT_PROPERTY_START)
        -:  431:    {
    #####:  432:      parser_stack_push_uint16 (context_p, item_index);
    #####:  433:      parser_stack_push_uint8 (context_p, (uint8_t) item_type);
    #####:  434:      return;
        -:  435:    }
        -:  436:
    #####:  437:    iterator.current_position--;
    #####:  438:    if (iterator.current_position == 0)
        -:  439:    {
    #####:  440:      iterator.current_p = iterator.current_p->next_p;
    #####:  441:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  442:    }
        -:  443:
    #####:  444:    uint32_t current_item_index = iterator.current_p->bytes[iterator.current_position - 1];
        -:  445:
    #####:  446:    iterator.current_position--;
    #####:  447:    if (iterator.current_position == 0)
        -:  448:    {
    #####:  449:      iterator.current_p = iterator.current_p->next_p;
    #####:  450:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  451:    }
        -:  452:
    #####:  453:    current_item_index |= ((uint32_t) iterator.current_p->bytes[iterator.current_position - 1]) << 8;
        -:  454:
    #####:  455:    iterator.current_position--;
    #####:  456:    if (iterator.current_position == 0)
        -:  457:    {
    #####:  458:      iterator.current_p = iterator.current_p->next_p;
    #####:  459:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  460:    }
        -:  461:
    #####:  462:    if (current_item_index == item_index)
        -:  463:    {
    #####:  464:      if (item_type == PARSER_OBJECT_PROPERTY_VALUE && *current_item_type_p == PARSER_OBJECT_PROPERTY_VALUE
    #####:  465:          && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  466:      {
        -:  467:        return;
        -:  468:      }
        -:  469:
    #####:  470:      if (item_type == PARSER_OBJECT_PROPERTY_GETTER && *current_item_type_p == PARSER_OBJECT_PROPERTY_SETTER)
        -:  471:      {
        -:  472:        break;
        -:  473:      }
        -:  474:
    #####:  475:      if (item_type == PARSER_OBJECT_PROPERTY_SETTER && *current_item_type_p == PARSER_OBJECT_PROPERTY_GETTER)
        -:  476:      {
        -:  477:        break;
        -:  478:      }
        -:  479:
    #####:  480:      parser_raise_error (context_p, PARSER_ERR_OBJECT_PROPERTY_REDEFINED);
        -:  481:    }
        -:  482:  }
        -:  483:
    #####:  484:  uint8_t *last_page_p = context_p->stack.first_p->bytes;
        -:  485:
    #####:  486:  *current_item_type_p = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  487:
    #####:  488:  if (current_item_type_p == (last_page_p + context_p->stack.last_position - 1))
        -:  489:  {
    #####:  490:    context_p->stack_top_uint8 = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  491:  }
        -:  492:} /* parser_append_object_literal_item */
        -:  493:#endif /* !JERRY_ESNEXT */
        -:  494:
        -:  495:#if JERRY_ESNEXT
        -:  496:/** Forward definition of parse array initializer. */
        -:  497:static void parser_parse_array_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  498:
        -:  499:/** Forward definition of parse object initializer. */
        -:  500:static void parser_parse_object_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  501:
        -:  502:/**
        -:  503: * Class literal parsing options.
        -:  504: */
        -:  505:typedef enum
        -:  506:{
        -:  507:  PARSER_CLASS_LITERAL_NO_OPTS = 0, /**< no options are provided */
        -:  508:  PARSER_CLASS_LITERAL_CTOR_PRESENT = (1 << 0), /**< class constructor is present */
        -:  509:  PARSER_CLASS_LITERAL_HERTIAGE_PRESENT = (1 << 1), /**< class heritage is present */
        -:  510:} parser_class_literal_opts_t;
        -:  511:
        -:  512:/**
        -:  513: * Checks whether the current string or identifier literal is constructor
        -:  514: *
        -:  515: * @return true, if constructor and false otherwise
        -:  516: */
        -:  517:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  518:parser_is_constructor_literal (parser_context_t *context_p) /**< context */
        -:  519:{
       10:  520:  return (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
       10:  521:          && lexer_compare_literal_to_string (context_p, "constructor", 11));
        -:  522:} /* parser_is_constructor_literal */
        -:  523:
        -:  524:/**
        -:  525: * Checks if current private field is already declared
        -:  526: */
        -:  527:static void
    #####:  528:parser_check_duplicated_private_field (parser_context_t *context_p, /**< context */
        -:  529:                                       uint8_t opts) /**< options */
        -:  530:{
    #####:  531:  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL);
    #####:  532:  JERRY_ASSERT (context_p->private_context_p);
    #####:  533:  scanner_class_private_member_t *iter = context_p->private_context_p->members_p;
        -:  534:
    #####:  535:  bool search_for_property = (opts & SCANNER_PRIVATE_FIELD_PROPERTY);
        -:  536:
    #####:  537:  while (iter != NULL)
        -:  538:  {
    #####:  539:    if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &iter->loc) && (iter->u8_arg & opts))
        -:  540:    {
    #####:  541:      if (iter->u8_arg & SCANNER_PRIVATE_FIELD_SEEN)
        -:  542:      {
    #####:  543:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PRIVATE_FIELD);
        -:  544:      }
        -:  545:
    #####:  546:      iter->u8_arg |= SCANNER_PRIVATE_FIELD_SEEN;
        -:  547:
    #####:  548:      if (!search_for_property)
        -:  549:      {
    #####:  550:        break;
        -:  551:      }
        -:  552:    }
        -:  553:
    #####:  554:    iter = iter->prev_p;
        -:  555:  }
    #####:  556:} /* parser_check_duplicated_private_field */
        -:  557:
        -:  558:/**
        -:  559: * Parse class literal.
        -:  560: *
        -:  561: * @return true - if the class has static fields, false - otherwise
        -:  562: */
        -:  563:static bool
        9:  564:parser_parse_class_body (parser_context_t *context_p, /**< context */
        -:  565:                         parser_class_literal_opts_t opts, /**< class literal parsing options */
        -:  566:                         uint16_t class_name_index) /**< class literal index */
        -:  567:{
        9:  568:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -:  569:
        9:  570:  lexer_literal_t *ctor_literal_p = NULL;
        9:  571:  lexer_literal_t *static_fields_literal_p = NULL;
        -:  572:
        9:  573:  if (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT)
        -:  574:  {
        8:  575:    ctor_literal_p = lexer_construct_unused_literal (context_p);
        8:  576:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, (uint16_t) (context_p->literal_count++));
        -:  577:  }
        1:  578:  else if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  579:  {
    #####:  580:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE);
        -:  581:  }
        -:  582:  else
        -:  583:  {
        1:  584:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR);
        -:  585:  }
        -:  586:
        9:  587:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -:  588:  {
        9:  589:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, class_name_index);
        -:  590:  }
        -:  591:
        9:  592:  parser_emit_cbc_ext (context_p, CBC_EXT_INIT_CLASS);
        -:  593:
        9:  594:  bool is_static = false;
        9:  595:  bool is_private = false;
        9:  596:  size_t fields_size = 0;
        9:  597:  uint32_t computed_field_count = 0;
        -:  598:
        -:  599:  while (true)
       10:  600:  {
       19:  601:    if (!is_static)
        -:  602:    {
       19:  603:      lexer_skip_empty_statements (context_p);
        -:  604:    }
        -:  605:
       19:  606:    uint32_t flags = (LEXER_OBJ_IDENT_CLASS_IDENTIFIER | LEXER_OBJ_IDENT_SET_FUNCTION_START);
        -:  607:
       19:  608:    if (!is_static)
        -:  609:    {
       19:  610:      flags |= LEXER_OBJ_IDENT_CLASS_NO_STATIC;
        -:  611:    }
        -:  612:
       19:  613:    if (is_private)
        -:  614:    {
    #####:  615:      flags |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
        -:  616:    }
        -:  617:
       19:  618:    lexer_expect_object_literal_id (context_p, flags);
        -:  619:
       19:  620:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -:  621:    {
        9:  622:      JERRY_ASSERT (!is_static);
        9:  623:      break;
        -:  624:    }
        -:  625:
       10:  626:    if (context_p->token.type == LEXER_HASHMARK)
        -:  627:    {
    #####:  628:      is_private = true;
    #####:  629:      lexer_next_token (context_p);
    #####:  630:      context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  631:      continue;
        -:  632:    }
        -:  633:
       10:  634:    if (context_p->token.type == LEXER_KEYW_STATIC)
        -:  635:    {
    #####:  636:      JERRY_ASSERT (!is_static);
    #####:  637:      is_static = true;
    #####:  638:      continue;
        -:  639:    }
        -:  640:
       10:  641:    if (is_private)
        -:  642:    {
    #####:  643:      parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  644:    }
        -:  645:
       18:  646:    bool is_constructor_literal = context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p);
        -:  647:
       10:  648:    if (is_private && is_constructor_literal && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  649:    {
    #####:  650:      parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  651:    }
        -:  652:
       10:  653:    if (!is_static && is_constructor_literal)
        -:  654:    {
        8:  655:      JERRY_ASSERT (!is_static);
        8:  656:      JERRY_ASSERT (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT);
        8:  657:      JERRY_ASSERT (ctor_literal_p != NULL);
        -:  658:
        8:  659:      if (ctor_literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  660:      {
        -:  661:        /* 14.5.1 */
    #####:  662:        parser_raise_error (context_p, PARSER_ERR_MULTIPLE_CLASS_CONSTRUCTORS);
        -:  663:      }
        -:  664:
        8:  665:      uint32_t constructor_status_flags =
        -:  666:        (PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER | PARSER_CLASS_CONSTRUCTOR | PARSER_LEXICAL_ENV_NEEDED);
        -:  667:
        8:  668:      if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  669:      {
        8:  670:        constructor_status_flags |= PARSER_ALLOW_SUPER_CALL;
        -:  671:      }
        -:  672:
        8:  673:      if (context_p->status_flags & PARSER_INSIDE_WITH)
        -:  674:      {
    #####:  675:        constructor_status_flags |= PARSER_INSIDE_WITH;
        -:  676:      }
        -:  677:
        8:  678:      parser_flush_cbc (context_p);
        8:  679:      ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, constructor_status_flags);
        8:  680:      ctor_literal_p->u.bytecode_p = compiled_code_p;
        8:  681:      ctor_literal_p->type = LEXER_FUNCTION_LITERAL;
        8:  682:      continue;
        -:  683:    }
        -:  684:
        2:  685:    bool is_computed = false;
        -:  686:
        2:  687:    if (context_p->token.type == LEXER_PROPERTY_GETTER || context_p->token.type == LEXER_PROPERTY_SETTER)
        -:  688:    {
        -:  689:      uint16_t literal_index, function_literal_index;
        2:  690:      bool is_getter = (context_p->token.type == LEXER_PROPERTY_GETTER);
        -:  691:
        2:  692:      uint32_t accessor_status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
        2:  693:      accessor_status_flags |= (is_getter ? PARSER_IS_PROPERTY_GETTER : PARSER_IS_PROPERTY_SETTER);
        -:  694:
        2:  695:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  696:
        2:  697:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  698:      {
    #####:  699:        lexer_next_token (context_p);
    #####:  700:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  701:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  702:        is_private = true;
        -:  703:      }
        -:  704:
        2:  705:      lexer_expect_object_literal_id (context_p, ident_opts);
        -:  706:
        2:  707:      if (is_private)
        -:  708:      {
    #####:  709:        parser_check_duplicated_private_field (context_p,
        -:  710:                                               is_getter ? SCANNER_PRIVATE_FIELD_GETTER : SCANNER_PRIVATE_FIELD_SETTER);
        -:  711:      }
        -:  712:
        2:  713:      literal_index = context_p->lit_object.index;
        -:  714:
        2:  715:      if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  716:      {
    #####:  717:        is_computed = true;
        -:  718:      }
        2:  719:      else if (is_static && !is_private)
        -:  720:      {
    #####:  721:        if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  722:            && lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  723:        {
    #####:  724:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  725:        }
        -:  726:      }
        2:  727:      else if (parser_is_constructor_literal (context_p))
        -:  728:      {
    #####:  729:        JERRY_ASSERT (!is_static || is_private);
    #####:  730:        parser_raise_error (context_p, PARSER_ERR_CLASS_CONSTRUCTOR_AS_ACCESSOR);
        -:  731:      }
        -:  732:
        2:  733:      function_literal_index = lexer_construct_function_object (context_p, accessor_status_flags);
        -:  734:
        2:  735:      parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -:  736:
        2:  737:      JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  738:
        -:  739:      cbc_ext_opcode_t opcode;
        -:  740:
        2:  741:      if (is_computed)
        -:  742:      {
    #####:  743:        context_p->last_cbc.literal_index = function_literal_index;
        -:  744:
    #####:  745:        if (is_getter)
        -:  746:        {
    #####:  747:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_GETTER;
        -:  748:        }
        -:  749:        else
        -:  750:        {
    #####:  751:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_SETTER : CBC_EXT_SET_COMPUTED_SETTER;
        -:  752:        }
        -:  753:      }
        -:  754:      else
        -:  755:      {
        2:  756:        context_p->last_cbc.value = function_literal_index;
        -:  757:
        2:  758:        if (is_getter)
        -:  759:        {
        1:  760:          opcode = is_static ? (is_private ? CBC_EXT_COLLECT_PRIVATE_STATIC_GETTER : CBC_EXT_SET_STATIC_GETTER)
        1:  761:                             : (is_private ? CBC_EXT_COLLECT_PRIVATE_GETTER : CBC_EXT_SET_GETTER);
        -:  762:        }
        -:  763:        else
        -:  764:        {
        1:  765:          opcode = is_static ? (is_private ? CBC_EXT_COLLECT_PRIVATE_STATIC_SETTER : CBC_EXT_SET_STATIC_SETTER)
        1:  766:                             : (is_private ? CBC_EXT_COLLECT_PRIVATE_SETTER : CBC_EXT_SET_SETTER);
        -:  767:        }
        -:  768:      }
        -:  769:
        2:  770:      if (is_computed)
        -:  771:      {
    #####:  772:        parser_emit_cbc_ext (context_p,
        -:  773:                             is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME : CBC_EXT_SET_COMPUTED_SETTER_NAME);
    #####:  774:        parser_emit_cbc_ext (context_p, opcode);
        -:  775:      }
        -:  776:      else
        -:  777:      {
        2:  778:        if (is_private)
        -:  779:        {
    #####:  780:          accessor_status_flags |= PARSER_PRIVATE_FUNCTION_NAME;
        -:  781:        }
        2:  782:        parser_set_function_name (context_p, function_literal_index, literal_index, accessor_status_flags);
        2:  783:        context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
        -:  784:      }
        -:  785:
        2:  786:      is_static = false;
        2:  787:      is_private = false;
        2:  788:      continue;
        -:  789:    }
        -:  790:
    #####:  791:    uint32_t status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
        -:  792:
    #####:  793:    if (context_p->token.type == LEXER_KEYW_ASYNC)
        -:  794:    {
    #####:  795:      status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  796:
    #####:  797:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  798:
    #####:  799:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  800:      {
    #####:  801:        lexer_next_token (context_p);
    #####:  802:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  803:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  804:        is_private = true;
        -:  805:      }
        -:  806:
    #####:  807:      if (!lexer_consume_generator (context_p))
        -:  808:      {
    #####:  809:        lexer_expect_object_literal_id (context_p, ident_opts);
        -:  810:      }
        -:  811:
    #####:  812:      if (is_private)
        -:  813:      {
    #####:  814:        if (context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p))
        -:  815:        {
    #####:  816:          parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  817:        }
        -:  818:
    #####:  819:        parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  820:      }
        -:  821:    }
        -:  822:
    #####:  823:    if (context_p->token.type == LEXER_MULTIPLY)
        -:  824:    {
    #####:  825:      uint8_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
        -:  826:
    #####:  827:      if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -:  828:      {
    #####:  829:        lexer_next_token (context_p);
    #####:  830:        context_p->token.flags |= LEXER_NO_SKIP_SPACES;
    #####:  831:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
    #####:  832:        is_private = true;
        -:  833:      }
        -:  834:
    #####:  835:      lexer_expect_object_literal_id (context_p, ident_opts);
        -:  836:
    #####:  837:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  838:
    #####:  839:      if (is_private)
        -:  840:      {
    #####:  841:        if (context_p->token.type == LEXER_LITERAL && parser_is_constructor_literal (context_p))
        -:  842:        {
    #####:  843:          parser_raise_error (context_p, PARSER_ERR_CLASS_PRIVATE_CONSTRUCTOR);
        -:  844:        }
        -:  845:
    #####:  846:        parser_check_duplicated_private_field (context_p, SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER);
        -:  847:      }
        -:  848:    }
        -:  849:
    #####:  850:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  851:    {
    #####:  852:      is_computed = true;
        -:  853:    }
    #####:  854:    else if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type))
        -:  855:    {
    #####:  856:      if (is_static && !is_private)
        -:  857:      {
    #####:  858:        if (lexer_compare_identifier_to_string (&context_p->token.lit_location, (uint8_t *) "prototype", 9))
        -:  859:        {
    #####:  860:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  861:        }
        -:  862:      }
    #####:  863:      else if ((status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION))
    #####:  864:               && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -:  865:      {
    #####:  866:        parser_raise_error (context_p, PARSER_ERR_INVALID_CLASS_CONSTRUCTOR);
        -:  867:      }
        -:  868:    }
        -:  869:
    #####:  870:    if (!(status_flags & (PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION)))
        -:  871:    {
    #####:  872:      if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  873:      {
        -:  874:        /* Class field. */
    #####:  875:        if (fields_size == 0)
        -:  876:        {
    #####:  877:          parser_stack_push_uint8 (context_p, PARSER_CLASS_FIELD_END);
        -:  878:        }
        -:  879:
    #####:  880:        scanner_range_t range;
    #####:  881:        uint8_t class_field_type = is_static ? PARSER_CLASS_FIELD_STATIC : 0;
        -:  882:
    #####:  883:        if (!is_computed)
        -:  884:        {
    #####:  885:          if (is_private)
        -:  886:          {
    #####:  887:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####:  888:            uint8_t field_opcode = is_static ? CBC_EXT_COLLECT_PRIVATE_STATIC_FIELD : CBC_EXT_COLLECT_PRIVATE_FIELD;
    #####:  889:            parser_emit_cbc_ext_literal_from_token (context_p, field_opcode);
        -:  890:          }
        -:  891:
    #####:  892:          if (is_static && parser_is_constructor_literal (context_p))
        -:  893:          {
    #####:  894:            parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -:  895:          }
        -:  896:
    #####:  897:          range.start_location.source_p = context_p->token.lit_location.char_p;
    #####:  898:          range.start_location.line = context_p->token.line;
    #####:  899:          range.start_location.column = context_p->token.column;
    #####:  900:          class_field_type |= PARSER_CLASS_FIELD_NORMAL;
        -:  901:
    #####:  902:          if (context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  903:          {
    #####:  904:            range.start_location.source_p--;
        -:  905:          }
        -:  906:        }
        -:  907:        else
        -:  908:        {
    #####:  909:          if (++computed_field_count > ECMA_INTEGER_NUMBER_MAX)
        -:  910:          {
    #####:  911:            parser_raise_error (context_p, PARSER_ERR_TOO_MANY_CLASS_FIELDS);
        -:  912:          }
        -:  913:
    #####:  914:          if (is_static && static_fields_literal_p == NULL)
        -:  915:          {
    #####:  916:            static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####:  917:            parser_emit_cbc_ext_literal (context_p,
        -:  918:                                         CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC,
        -:  919:                                         (uint16_t) (context_p->literal_count++));
        -:  920:          }
        -:  921:          else
        -:  922:          {
    #####:  923:            parser_emit_cbc_ext (context_p,
        -:  924:                                 (is_static ? CBC_EXT_ADD_STATIC_COMPUTED_FIELD : CBC_EXT_ADD_COMPUTED_FIELD));
        -:  925:          }
        -:  926:        }
        -:  927:
    #####:  928:        if (lexer_consume_assign (context_p))
        -:  929:        {
    #####:  930:          class_field_type |= PARSER_CLASS_FIELD_INITIALIZED;
        -:  931:
    #####:  932:          if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -:  933:          {
    #####:  934:            lexer_next_token (context_p);
    #####:  935:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####:  936:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  937:          }
        -:  938:
    #####:  939:          if (is_computed)
        -:  940:          {
    #####:  941:            scanner_get_location (&range.start_location, context_p);
        -:  942:          }
        -:  943:
    #####:  944:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END);
    #####:  945:          range.source_end_p = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location.source_p;
        -:  946:
    #####:  947:          scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####:  948:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####:  949:          scanner_seek (context_p);
        -:  950:
    #####:  951:          parser_stack_push (context_p, &range, sizeof (scanner_range_t));
    #####:  952:          fields_size += sizeof (scanner_range_t);
        -:  953:        }
        -:  954:        else
        -:  955:        {
    #####:  956:          if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####:  957:              && !lexer_check_next_characters (context_p, LIT_CHAR_SEMICOLON, LIT_CHAR_RIGHT_BRACE))
        -:  958:          {
    #####:  959:            lexer_next_token (context_p);
    #####:  960:            parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -:  961:          }
        -:  962:
    #####:  963:          if (!is_computed)
        -:  964:          {
    #####:  965:            parser_stack_push (context_p, &range.start_location, sizeof (scanner_location_t));
    #####:  966:            fields_size += sizeof (scanner_location_t);
        -:  967:          }
        -:  968:        }
        -:  969:
    #####:  970:        parser_stack_push_uint8 (context_p, class_field_type);
    #####:  971:        fields_size++;
    #####:  972:        is_static = false;
    #####:  973:        is_private = false;
    #####:  974:        continue;
        -:  975:      }
        -:  976:
    #####:  977:      if (!is_computed)
        -:  978:      {
    #####:  979:        if (context_p->token.lit_location.type != LEXER_NUMBER_LITERAL)
        -:  980:        {
    #####:  981:          JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
        -:  982:                        || context_p->token.lit_location.type == LEXER_STRING_LITERAL);
    #####:  983:          if (is_private)
        -:  984:          {
    #####:  985:            parser_resolve_private_identifier (context_p);
        -:  986:          }
        -:  987:          else
        -:  988:          {
    #####:  989:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -:  990:          }
        -:  991:        }
        -:  992:        else
        -:  993:        {
    #####:  994:          lexer_construct_number_object (context_p, false, false);
        -:  995:        }
        -:  996:      }
        -:  997:    }
        -:  998:
    #####:  999:    uint16_t literal_index = context_p->lit_object.index;
    #####: 1000:    uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags | PARSER_IS_METHOD);
        -: 1001:
    #####: 1002:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1003:
    #####: 1004:    if (is_computed)
        -: 1005:    {
    #####: 1006:      parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1007:      parser_emit_cbc_ext (context_p, is_static ? CBC_EXT_SET_STATIC_COMPUTED_PROPERTY : CBC_EXT_SET_COMPUTED_PROPERTY);
    #####: 1008:      is_static = false;
    #####: 1009:      continue;
        -: 1010:    }
        -: 1011:
    #####: 1012:    uint32_t function_name_status_flags = 0;
        -: 1013:
    #####: 1014:    if (is_private)
        -: 1015:    {
    #####: 1016:      function_name_status_flags = PARSER_PRIVATE_FUNCTION_NAME;
        -: 1017:    }
        -: 1018:
    #####: 1019:    parser_set_function_name (context_p, function_literal_index, literal_index, function_name_status_flags);
        -: 1020:
    #####: 1021:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1022:
    #####: 1023:    context_p->last_cbc.value = literal_index;
        -: 1024:
    #####: 1025:    if (is_static)
        -: 1026:    {
    #####: 1027:      context_p->last_cbc_opcode = (is_private ? PARSER_TO_EXT_OPCODE (CBC_EXT_COLLECT_PRIVATE_STATIC_METHOD)
        -: 1028:                                               : PARSER_TO_EXT_OPCODE (CBC_EXT_SET_STATIC_PROPERTY_LITERAL));
    #####: 1029:      is_static = false;
        -: 1030:    }
    #####: 1031:    else if (is_private)
        -: 1032:    {
    #####: 1033:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_COLLECT_PRIVATE_METHOD);
        -: 1034:    }
        -: 1035:    else
        -: 1036:    {
    #####: 1037:      context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1038:    }
        -: 1039:
    #####: 1040:    is_private = false;
        -: 1041:  }
        -: 1042:
        9: 1043:  if (fields_size == 0)
        -: 1044:  {
        9: 1045:    return false;
        -: 1046:  }
        -: 1047:
    #####: 1048:  parser_reverse_class_fields (context_p, fields_size);
        -: 1049:
        -: 1050:  /* Since PARSER_IS_ARROW_FUNCTION and PARSER_CLASS_CONSTRUCTOR bits cannot
        -: 1051:   * be set at the same time, this bit combination triggers class field parsing. */
        -: 1052:
    #####: 1053:  if (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC))
        -: 1054:  {
    #####: 1055:    lexer_literal_t *literal_p = lexer_construct_unused_literal (context_p);
        -: 1056:
    #####: 1057:    uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####: 1058:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_FIELD_INIT, function_literal_index);
    #####: 1059:    parser_flush_cbc (context_p);
        -: 1060:
    #####: 1061:    literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####: 1062:    literal_p->type = LEXER_FUNCTION_LITERAL;
        -: 1063:  }
        -: 1064:
    #####: 1065:  bool has_static_field = false;
        -: 1066:
    #####: 1067:  if (context_p->stack_top_uint8 & PARSER_CLASS_FIELD_STATIC)
        -: 1068:  {
    #####: 1069:    if (static_fields_literal_p == NULL)
        -: 1070:    {
    #####: 1071:      static_fields_literal_p = lexer_construct_unused_literal (context_p);
    #####: 1072:      uint16_t function_literal_index = (uint16_t) (context_p->literal_count++);
    #####: 1073:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_STATIC_FIELD_FUNC, function_literal_index);
        -: 1074:    }
        -: 1075:
    #####: 1076:    parser_flush_cbc (context_p);
    #####: 1077:    static_fields_literal_p->u.bytecode_p = parser_parse_class_fields (context_p);
    #####: 1078:    static_fields_literal_p->type = LEXER_FUNCTION_LITERAL;
        -: 1079:
    #####: 1080:    has_static_field = true;
        -: 1081:  }
        -: 1082:
    #####: 1083:  parser_stack_pop_uint8 (context_p);
    #####: 1084:  return has_static_field;
        -: 1085:} /* parser_parse_class_body */
        -: 1086:
        -: 1087:/**
        -: 1088: * Parse class statement or expression.
        -: 1089: */
        -: 1090:void
        9: 1091:parser_parse_class (parser_context_t *context_p, /**< context */
        -: 1092:                    bool is_statement) /**< true - if class is parsed as a statement
        -: 1093:                                        *   false - otherwise (as an expression) */
        -: 1094:{
        9: 1095:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1096:
        9: 1097:  uint16_t class_ident_index = PARSER_INVALID_LITERAL_INDEX;
        9: 1098:  uint16_t class_name_index = PARSER_INVALID_LITERAL_INDEX;
        9: 1099:  parser_class_literal_opts_t opts = PARSER_CLASS_LITERAL_NO_OPTS;
        9: 1100:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 1101:
        9: 1102:  scanner_class_info_t *class_info_p = (scanner_class_info_t *) scanner_info_p;
        9: 1103:  parser_private_context_t private_ctx;
        -: 1104:
        9: 1105:  if (scanner_info_p->source_p == context_p->source_p)
        -: 1106:  {
        9: 1107:    JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR);
        9: 1108:    parser_save_private_context (context_p, &private_ctx, class_info_p);
        -: 1109:
        9: 1110:    if (scanner_info_p->u8_arg & SCANNER_CONSTRUCTOR_EXPLICIT)
        -: 1111:    {
        8: 1112:      opts |= PARSER_CLASS_LITERAL_CTOR_PRESENT;
        -: 1113:    }
        -: 1114:
        9: 1115:    scanner_release_next (context_p, sizeof (scanner_class_info_t));
        -: 1116:  }
        -: 1117:
        9: 1118:  if (is_statement)
        -: 1119:  {
        -: 1120:    /* Class statement must contain an identifier. */
        9: 1121:    lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        9: 1122:    JERRY_ASSERT (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1123:
        9: 1124:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1125:    {
    #####: 1126:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 1127:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 1128:    }
        9: 1129:    class_ident_index = context_p->lit_object.index;
        -: 1130:
        9: 1131:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
        9: 1132:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        9: 1133:    class_name_index = context_p->lit_object.index;
        -: 1134:
        -: 1135:#if JERRY_MODULE_SYSTEM
        9: 1136:    parser_module_append_export_name (context_p);
        9: 1137:    context_p->status_flags &= (uint32_t) ~PARSER_MODULE_STORE_IDENT;
        -: 1138:#endif /* JERRY_MODULE_SYSTEM */
        -: 1139:
        9: 1140:    lexer_next_token (context_p);
        -: 1141:  }
        -: 1142:  else
        -: 1143:  {
    #####: 1144:    lexer_next_token (context_p);
        -: 1145:
        -: 1146:    /* Class expression may contain an identifier. */
    #####: 1147:    if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1148:    {
    #####: 1149:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
    #####: 1150:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 1151:      class_name_index = context_p->lit_object.index;
    #####: 1152:      lexer_next_token (context_p);
        -: 1153:    }
        -: 1154:  }
        -: 1155:
        9: 1156:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 1157:  {
        9: 1158:    if (JERRY_UNLIKELY (context_p->scope_stack_top >= context_p->scope_stack_size))
        -: 1159:    {
    #####: 1160:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 1161:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 1162:    }
        -: 1163:
        9: 1164:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 1165:
        9: 1166:    PARSER_PLUS_EQUAL_U16 (context_p->scope_stack_top, 1);
        9: 1167:    scope_stack_p->map_from = class_name_index;
        9: 1168:    scope_stack_p->map_to = 0;
        -: 1169:
        9: 1170:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_NAMED_CLASS_ENV, class_name_index);
        -: 1171:  }
        -: 1172:  else
        -: 1173:  {
    #####: 1174:    parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 1175:  }
        -: 1176:
        9: 1177:  bool is_strict = (context_p->status_flags & PARSER_IS_STRICT) != 0;
        -: 1178:
        -: 1179:  /* 14.5. A ClassBody is always strict code. */
        9: 1180:  context_p->status_flags |= PARSER_IS_STRICT;
        -: 1181:
        9: 1182:  if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 1183:  {
        8: 1184:    lexer_next_token (context_p);
        8: 1185:    parser_parse_expression (context_p, PARSE_EXPR | PARSE_EXPR_LEFT_HAND_SIDE);
        8: 1186:    opts |= PARSER_CLASS_LITERAL_HERTIAGE_PRESENT;
        -: 1187:  }
        -: 1188:  else
        -: 1189:  {
        -: 1190:    /* Elisions represents that the classHeritage is not present */
        1: 1191:    parser_emit_cbc (context_p, CBC_PUSH_ELISION);
        -: 1192:  }
        -: 1193:
        9: 1194:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1195:  {
    #####: 1196:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 1197:  }
        -: 1198:
        9: 1199:  context_p->private_context_p->opts |= SCANNER_PRIVATE_FIELD_ACTIVE;
        -: 1200:
        -: 1201:  /* ClassDeclaration is parsed. Continue with class body. */
        9: 1202:  bool has_static_field = parser_parse_class_body (context_p, opts, class_name_index);
        -: 1203:
        9: 1204:  if (class_name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 1205:  {
        9: 1206:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_FINALIZE_NAMED_CLASS, class_name_index);
        9: 1207:    PARSER_MINUS_EQUAL_U16 (context_p->scope_stack_top, 1);
        -: 1208:  }
        -: 1209:  else
        -: 1210:  {
    #####: 1211:    parser_emit_cbc_ext (context_p, CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 1212:  }
        -: 1213:
        9: 1214:  if (has_static_field)
        -: 1215:  {
    #####: 1216:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_STATIC_FIELD_INIT);
        -: 1217:  }
        -: 1218:
        9: 1219:  if (is_statement)
        -: 1220:  {
        9: 1221:    cbc_opcode_t opcode = CBC_MOV_IDENT;
        -: 1222:
        9: 1223:    if (class_ident_index < PARSER_REGISTER_START)
        -: 1224:    {
        8: 1225:      opcode = (scanner_literal_is_created (context_p, class_ident_index) ? CBC_ASSIGN_LET_CONST : CBC_INIT_LET);
        -: 1226:    }
        -: 1227:
        9: 1228:    parser_emit_cbc_literal (context_p, (uint16_t) opcode, class_ident_index);
        9: 1229:    parser_flush_cbc (context_p);
        -: 1230:  }
        -: 1231:
        9: 1232:  if (!is_strict)
        -: 1233:  {
        -: 1234:    /* Restore flag */
        9: 1235:    context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1236:  }
        9: 1237:  context_p->status_flags &= (uint32_t) ~PARSER_ALLOW_SUPER;
        -: 1238:
        9: 1239:  parser_restore_private_context (context_p, &private_ctx);
        -: 1240:
        9: 1241:  lexer_next_token (context_p);
        9: 1242:} /* parser_parse_class */
        -: 1243:#endif /* JERRY_ESNEXT */
        -: 1244:
        -: 1245:#if JERRY_ESNEXT
        -: 1246:/**
        -: 1247: * Parse object initializer method definition.
        -: 1248: *
        -: 1249: * See also: ES2015 14.3
        -: 1250: */
        -: 1251:static void
    #####: 1252:parser_parse_object_method (parser_context_t *context_p) /**< context */
        -: 1253:{
    #####: 1254:  context_p->source_p--;
    #####: 1255:  context_p->column--;
    #####: 1256:  uint16_t function_literal_index =
        -: 1257:    lexer_construct_function_object (context_p, (PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER | PARSER_IS_METHOD));
        -: 1258:
    #####: 1259:  parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1260:
    #####: 1261:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
        -: 1262:
    #####: 1263:  lexer_next_token (context_p);
    #####: 1264:} /* parser_parse_object_method */
        -: 1265:
        -: 1266:/**
        -: 1267: * Reparse the current literal as a common identifier.
        -: 1268: */
        -: 1269:static void
    #####: 1270:parser_reparse_as_common_identifier (parser_context_t *context_p, /**< context */
        -: 1271:                                     parser_line_counter_t start_line, /**< start line */
        -: 1272:                                     parser_line_counter_t start_column) /**< start column */
        -: 1273:{
        -: 1274:  /* context_p->token.lit_location.char_p is showing the character after the string start,
        -: 1275:     so it is not suitable for reparsing as identifier.
        -: 1276:     e.g.: { 'foo' } */
    #####: 1277:  if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1278:  {
    #####: 1279:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1280:  }
        -: 1281:
    #####: 1282:  context_p->source_p = context_p->token.lit_location.char_p;
    #####: 1283:  context_p->line = start_line;
    #####: 1284:  context_p->column = start_column;
        -: 1285:
    #####: 1286:  lexer_next_token (context_p);
        -: 1287:
    #####: 1288:  if (context_p->token.type != LEXER_LITERAL)
        -: 1289:  {
    #####: 1290:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1291:  }
        -: 1292:
    #####: 1293:  JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1294:
    #####: 1295:  lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 1296:
    #####: 1297:} /* parser_reparse_as_common_identifier */
        -: 1298:#endif /* JERRY_ESNEXT */
        -: 1299:
        -: 1300:/**
        -: 1301: * Parse object literal.
        -: 1302: */
        -: 1303:static void
    #####: 1304:parser_parse_object_literal (parser_context_t *context_p) /**< context */
        -: 1305:{
    #####: 1306:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -: 1307:
    #####: 1308:  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);
        -: 1309:
        -: 1310:#if !JERRY_ESNEXT
    #####: 1311:  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);
        -: 1312:#endif /* !JERRY_ESNEXT */
        -: 1313:
        -: 1314:#if JERRY_ESNEXT
    #####: 1315:  bool proto_seen = false;
    #####: 1316:  bool has_super_env = false;
        -: 1317:
    #####: 1318:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1319:  {
    #####: 1320:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 1321:
    #####: 1322:    if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_SUPER)
        -: 1323:    {
    #####: 1324:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT);
    #####: 1325:      has_super_env = true;
        -: 1326:    }
        -: 1327:
    #####: 1328:    scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1329:  }
        -: 1330:#endif /* JERRY_ESNEXT */
        -: 1331:
        -: 1332:  while (true)
        -: 1333:  {
    #####: 1334:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_SET_FUNCTION_START);
        -: 1335:
    #####: 1336:    switch (context_p->token.type)
        -: 1337:    {
    #####: 1338:      case LEXER_RIGHT_BRACE:
        -: 1339:      {
    #####: 1340:        break;
        -: 1341:      }
    #####: 1342:      case LEXER_PROPERTY_GETTER:
        -: 1343:      case LEXER_PROPERTY_SETTER:
        -: 1344:      {
        -: 1345:        uint32_t status_flags;
        -: 1346:        cbc_ext_opcode_t opcode;
        -: 1347:#if !JERRY_ESNEXT
        -: 1348:        parser_object_literal_item_types_t item_type;
        -: 1349:#endif /* !JERRY_ESNEXT */
    #####: 1350:        bool is_getter = context_p->token.type == LEXER_PROPERTY_GETTER;
        -: 1351:
    #####: 1352:        if (is_getter)
        -: 1353:        {
    #####: 1354:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;
    #####: 1355:          opcode = CBC_EXT_SET_GETTER;
        -: 1356:#if !JERRY_ESNEXT
        -: 1357:          item_type = PARSER_OBJECT_PROPERTY_GETTER;
        -: 1358:#endif /* !JERRY_ESNEXT */
        -: 1359:        }
        -: 1360:        else
        -: 1361:        {
    #####: 1362:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;
    #####: 1363:          opcode = CBC_EXT_SET_SETTER;
        -: 1364:#if !JERRY_ESNEXT
    #####: 1365:          item_type = PARSER_OBJECT_PROPERTY_SETTER;
        -: 1366:#endif /* !JERRY_ESNEXT */
        -: 1367:        }
        -: 1368:
        -: 1369:#if JERRY_ESNEXT
    #####: 1370:        status_flags |= PARSER_ALLOW_SUPER;
        -: 1371:#endif /* !JERRY_ESNEXT */
        -: 1372:
    #####: 1373:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1374:
        -: 1375:        /* This assignment is a nop for computed getters/setters. */
    #####: 1376:        uint16_t literal_index = context_p->lit_object.index;
        -: 1377:
        -: 1378:#if JERRY_ESNEXT
    #####: 1379:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1380:
    #####: 1381:        if (is_computed)
        -: 1382:        {
    #####: 1383:          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1384:        }
        -: 1385:#else /* !JERRY_ESNEXT */
    #####: 1386:        parser_append_object_literal_item (context_p, literal_index, item_type);
        -: 1387:#endif /* JERRY_ESNEXT */
        -: 1388:
    #####: 1389:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1390:
        -: 1391:#if JERRY_ESNEXT
    #####: 1392:        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)
        -: 1393:        {
    #####: 1394:          literal_index = function_literal_index;
        -: 1395:        }
        -: 1396:#endif /* JERRY_ESNEXT */
        -: 1397:
    #####: 1398:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 1399:
    #####: 1400:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1401:
        -: 1402:#if JERRY_ESNEXT
    #####: 1403:        if (is_computed)
        -: 1404:        {
    #####: 1405:          parser_emit_cbc_ext (context_p,
        -: 1406:                               is_getter ? CBC_EXT_SET_COMPUTED_GETTER_NAME : CBC_EXT_SET_COMPUTED_SETTER_NAME);
        -: 1407:
    #####: 1408:          if (has_super_env)
        -: 1409:          {
    #####: 1410:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1411:          }
    #####: 1412:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1413:          lexer_next_token (context_p);
    #####: 1414:          break;
        -: 1415:        }
        -: 1416:
    #####: 1417:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1418:
    #####: 1419:        if (has_super_env)
        -: 1420:        {
    #####: 1421:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1422:          context_p->last_cbc.value = function_literal_index;
    #####: 1423:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
    #####: 1424:          parser_emit_cbc_ext (context_p, is_getter ? CBC_EXT_SET_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_SETTER);
        -: 1425:        }
        -: 1426:        else
        -: 1427:#endif /* JERRY_ESNEXT */
        -: 1428:        {
    #####: 1429:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
    #####: 1430:          context_p->last_cbc.value = function_literal_index;
        -: 1431:        }
        -: 1432:
    #####: 1433:        lexer_next_token (context_p);
    #####: 1434:        break;
        -: 1435:      }
        -: 1436:#if JERRY_ESNEXT
    #####: 1437:      case LEXER_RIGHT_SQUARE:
        -: 1438:      {
    #####: 1439:        lexer_next_token (context_p);
        -: 1440:
    #####: 1441:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1442:        {
    #####: 1443:          parser_parse_object_method (context_p);
    #####: 1444:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1445:
    #####: 1446:          if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1447:          {
    #####: 1448:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1449:            if (has_super_env)
        -: 1450:            {
    #####: 1451:              parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1452:            }
    #####: 1453:            parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1454:          }
        -: 1455:          else
        -: 1456:          {
    #####: 1457:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1458:          }
        -: 1459:
    #####: 1460:          break;
        -: 1461:        }
        -: 1462:
    #####: 1463:        if (context_p->token.type != LEXER_COLON)
        -: 1464:        {
    #####: 1465:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1466:        }
        -: 1467:
    #####: 1468:        lexer_next_token (context_p);
    #####: 1469:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1470:
    #####: 1471:        if (parser_check_anonymous_function_declaration (context_p) < PARSER_NAMED_FUNCTION)
        -: 1472:        {
    #####: 1473:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
        -: 1474:        }
        -: 1475:
    #####: 1476:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1477:        {
    #####: 1478:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1479:        }
        -: 1480:        else
        -: 1481:        {
    #####: 1482:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1483:        }
    #####: 1484:        break;
        -: 1485:      }
    #####: 1486:      case LEXER_THREE_DOTS:
        -: 1487:      {
    #####: 1488:        lexer_next_token (context_p);
    #####: 1489:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 1490:        parser_emit_cbc_ext (context_p, CBC_EXT_COPY_DATA_PROPERTIES);
    #####: 1491:        break;
        -: 1492:      }
    #####: 1493:      case LEXER_KEYW_ASYNC:
        -: 1494:      case LEXER_MULTIPLY:
        -: 1495:      {
    #####: 1496:        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -: 1497:
    #####: 1498:        if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 1499:        {
    #####: 1500:          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1501:          lexer_consume_generator (context_p);
        -: 1502:        }
        -: 1503:
    #####: 1504:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1505:        {
    #####: 1506:          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1507:        }
        -: 1508:
    #####: 1509:        if (has_super_env)
        -: 1510:        {
    #####: 1511:          status_flags |= PARSER_ALLOW_SUPER;
        -: 1512:        }
        -: 1513:
    #####: 1514:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1515:
    #####: 1516:        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1517:        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */
    #####: 1518:        uint16_t literal_index = context_p->lit_object.index;
    #####: 1519:        bool is_computed = context_p->token.type == LEXER_RIGHT_SQUARE;
        -: 1520:
    #####: 1521:        if (is_computed)
        -: 1522:        {
    #####: 1523:          opcode = CBC_EXT_SET_COMPUTED_PROPERTY;
        -: 1524:        }
        -: 1525:
    #####: 1526:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1527:
    #####: 1528:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1529:
    #####: 1530:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -: 1531:
    #####: 1532:        if (is_computed)
        -: 1533:        {
    #####: 1534:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_FUNCTION_NAME);
    #####: 1535:          if (has_super_env)
        -: 1536:          {
    #####: 1537:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED);
        -: 1538:          }
    #####: 1539:          parser_emit_cbc_ext (context_p, opcode);
    #####: 1540:          lexer_next_token (context_p);
    #####: 1541:          break;
        -: 1542:        }
        -: 1543:
    #####: 1544:        parser_set_function_name (context_p, function_literal_index, literal_index, status_flags);
        -: 1545:
    #####: 1546:        if (has_super_env)
        -: 1547:        {
    #####: 1548:          parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1549:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1550:        }
        -: 1551:        else
        -: 1552:        {
    #####: 1553:          context_p->last_cbc_opcode = opcode;
    #####: 1554:          context_p->last_cbc.value = literal_index;
        -: 1555:        }
        -: 1556:
    #####: 1557:        lexer_next_token (context_p);
    #####: 1558:        break;
        -: 1559:      }
        -: 1560:#endif /* JERRY_ESNEXT */
    #####: 1561:      default:
        -: 1562:      {
        -: 1563:#if JERRY_ESNEXT
    #####: 1564:        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;
    #####: 1565:        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1566:                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)
    #####: 1567:                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) "__proto__", 9)
    #####: 1568:                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));
    #####: 1569:        if (is_proto)
        -: 1570:        {
    #####: 1571:          if (proto_seen)
        -: 1572:          {
    #####: 1573:            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);
        -: 1574:          }
        -: 1575:
    #####: 1576:          proto_seen = true;
        -: 1577:        }
        -: 1578:#endif /* JERRY_ESNEXT */
        -: 1579:
    #####: 1580:        uint16_t literal_index = context_p->lit_object.index;
        -: 1581:
        -: 1582:#if JERRY_ESNEXT
    #####: 1583:        parser_line_counter_t start_line = context_p->token.line;
    #####: 1584:        parser_line_counter_t start_column = context_p->token.column;
        -: 1585:#else /* !JERRY_ESNEXT */
    #####: 1586:        parser_append_object_literal_item (context_p, literal_index, PARSER_OBJECT_PROPERTY_VALUE);
        -: 1587:#endif /* JERRY_ESNEXT */
        -: 1588:
    #####: 1589:        lexer_next_token (context_p);
        -: 1590:
        -: 1591:#if JERRY_ESNEXT
    #####: 1592:        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)
        -: 1593:        {
    #####: 1594:          parser_parse_object_method (context_p);
        -: 1595:
    #####: 1596:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 1597:          parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1598:
    #####: 1599:          if (has_super_env)
        -: 1600:          {
    #####: 1601:            parser_emit_cbc_ext (context_p, CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT);
    #####: 1602:            parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
    #####: 1603:            break;
        -: 1604:          }
        -: 1605:
    #####: 1606:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1607:          context_p->last_cbc.value = literal_index;
    #####: 1608:          break;
        -: 1609:        }
        -: 1610:
    #####: 1611:        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA) && !is_proto)
        -: 1612:        {
    #####: 1613:          parser_reparse_as_common_identifier (context_p, start_line, start_column);
    #####: 1614:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1615:
    #####: 1616:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1617:          context_p->last_cbc.value = literal_index;
        -: 1618:
    #####: 1619:          lexer_next_token (context_p);
    #####: 1620:          break;
        -: 1621:        }
        -: 1622:#endif /* JERRY_ESNEXT */
        -: 1623:
    #####: 1624:        if (context_p->token.type != LEXER_COLON)
        -: 1625:        {
    #####: 1626:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1627:        }
        -: 1628:
    #####: 1629:        lexer_next_token (context_p);
    #####: 1630:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1631:
        -: 1632:#if JERRY_ESNEXT
    #####: 1633:        if (is_proto)
        -: 1634:        {
    #####: 1635:          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);
    #####: 1636:          break;
        -: 1637:        }
        -: 1638:#endif /* JERRY_ESNEXT */
        -: 1639:
    #####: 1640:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1641:        {
        -: 1642:#if JERRY_ESNEXT
    #####: 1643:          if (context_p->last_cbc.literal_type == LEXER_FUNCTION_LITERAL)
        -: 1644:          {
    #####: 1645:            parser_set_function_name (context_p, context_p->last_cbc.literal_index, literal_index, 0);
        -: 1646:          }
        -: 1647:#endif /* JERRY_ESNEXT */
    #####: 1648:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1649:          context_p->last_cbc.value = literal_index;
        -: 1650:        }
        -: 1651:        else
        -: 1652:        {
        -: 1653:#if JERRY_ESNEXT
    #####: 1654:          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 1655:          {
    #####: 1656:            uint16_t name_index = scanner_save_literal (context_p, literal_index);
    #####: 1657:            parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 1658:          }
        -: 1659:#endif /* JERRY_ESNEXT */
    #####: 1660:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1661:        }
        -: 1662:
    #####: 1663:        break;
        -: 1664:      }
        -: 1665:    }
        -: 1666:
    #####: 1667:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1668:    {
    #####: 1669:      break;
        -: 1670:    }
    #####: 1671:    else if (context_p->token.type != LEXER_COMMA)
        -: 1672:    {
    #####: 1673:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 1674:    }
        -: 1675:  }
        -: 1676:
        -: 1677:#if !JERRY_ESNEXT
    #####: 1678:  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)
        -: 1679:  {
    #####: 1680:    parser_stack_pop (context_p, NULL, 3);
        -: 1681:  }
        -: 1682:
    #####: 1683:  parser_stack_pop_uint8 (context_p);
        -: 1684:#else /* JERRY_ESNEXT */
    #####: 1685:  if (has_super_env)
        -: 1686:  {
    #####: 1687:    parser_emit_cbc_ext (context_p, CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
        -: 1688:  }
        -: 1689:#endif /* !JERRY_ESNEXT */
    #####: 1690:} /* parser_parse_object_literal */
        -: 1691:
        -: 1692:/**
        -: 1693: * Parse function literal.
        -: 1694: */
        -: 1695:static void
       13: 1696:parser_parse_function_expression (parser_context_t *context_p, /**< context */
        -: 1697:                                  uint32_t status_flags) /**< function status flags */
        -: 1698:{
       13: 1699:  int literals = 0;
       13: 1700:  uint16_t literal1 = 0;
       13: 1701:  uint16_t literal2 = 0;
        -: 1702:  uint16_t function_literal_index;
       13: 1703:  int32_t function_name_index = -1;
        -: 1704:
        -: 1705:#if !JERRY_ESNEXT
        -: 1706:  JERRY_ASSERT (status_flags & PARSER_IS_FUNC_EXPRESSION);
        -: 1707:#endif /* !JERRY_ESNEXT */
        -: 1708:
        -: 1709:#if JERRY_ESNEXT
       13: 1710:  if (status_flags & PARSER_IS_FUNC_EXPRESSION)
        -: 1711:  {
        -: 1712:#endif /* !JERRY_ESNEXT */
        -: 1713:
        -: 1714:#if JERRY_DEBUGGER
        -: 1715:    parser_line_counter_t debugger_line = context_p->token.line;
        -: 1716:    parser_line_counter_t debugger_column = context_p->token.column;
        -: 1717:#endif /* JERRY_DEBUGGER */
        -: 1718:
        -: 1719:#if JERRY_ESNEXT
        9: 1720:    uint32_t parent_status_flags = context_p->status_flags;
        -: 1721:
        9: 1722:    context_p->status_flags &=
        -: 1723:      (uint32_t) ~(PARSER_IS_ASYNC_FUNCTION | PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD);
        -: 1724:
        9: 1725:    if (status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1726:    {
        -: 1727:      /* The name of the function cannot be await. */
    #####: 1728:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1729:    }
        -: 1730:
        9: 1731:    if (lexer_consume_generator (context_p))
        -: 1732:    {
        -: 1733:      /* The name of the function cannot be yield. */
    #####: 1734:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1735:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1736:    }
        -: 1737:#endif /* JERRY_ESNEXT */
        -: 1738:
        9: 1739:    if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1740:    {
    #####: 1741:      lexer_next_token (context_p);
        -: 1742:
    #####: 1743:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1744:      {
    #####: 1745:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1746:      }
        -: 1747:
    #####: 1748:      parser_flush_cbc (context_p);
        -: 1749:
    #####: 1750:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -: 1751:
        -: 1752:#if JERRY_DEBUGGER
        -: 1753:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1754:      {
        -: 1755:        jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -: 1756:                                    JERRY_DEBUGGER_NO_SUBTYPE,
        -: 1757:                                    context_p->lit_object.literal_p->u.char_p,
        -: 1758:                                    context_p->lit_object.literal_p->prop.length);
        -: 1759:
        -: 1760:        /* Reset token position for the function. */
        -: 1761:        context_p->token.line = debugger_line;
        -: 1762:        context_p->token.column = debugger_column;
        -: 1763:      }
        -: 1764:#endif /* JERRY_DEBUGGER */
        -: 1765:
    #####: 1766:      if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1767:      {
    #####: 1768:        status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1769:      }
        -: 1770:
    #####: 1771:      function_name_index = context_p->lit_object.index;
        -: 1772:    }
        -: 1773:
        -: 1774:#if JERRY_ESNEXT
        9: 1775:    context_p->status_flags = parent_status_flags;
        -: 1776:  }
        -: 1777:#endif /* JERRY_ESNEXT */
        -: 1778:
       13: 1779:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1780:  {
        9: 1781:    literals = 1;
        9: 1782:    literal1 = context_p->last_cbc.literal_index;
        9: 1783:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1784:  }
        4: 1785:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1786:  {
    #####: 1787:    literals = 2;
    #####: 1788:    literal1 = context_p->last_cbc.literal_index;
    #####: 1789:    literal2 = context_p->last_cbc.value;
    #####: 1790:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1791:  }
        -: 1792:
       13: 1793:  function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1794:
       13: 1795:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1796:
        -: 1797:#if JERRY_ESNEXT
       13: 1798:  if (function_name_index != -1)
        -: 1799:  {
    #####: 1800:    parser_set_function_name (context_p, function_literal_index, (uint16_t) function_name_index, 0);
        -: 1801:  }
        -: 1802:#endif /* JERRY_ESNEXT */
        -: 1803:
       13: 1804:  if (literals == 1)
        -: 1805:  {
        9: 1806:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        9: 1807:    context_p->last_cbc.literal_index = literal1;
        9: 1808:    context_p->last_cbc.value = function_literal_index;
        -: 1809:  }
        4: 1810:  else if (literals == 2)
        -: 1811:  {
    #####: 1812:    context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 1813:    context_p->last_cbc.literal_index = literal1;
    #####: 1814:    context_p->last_cbc.value = literal2;
    #####: 1815:    context_p->last_cbc.third_literal_index = function_literal_index;
        -: 1816:  }
        -: 1817:  else
        -: 1818:  {
        4: 1819:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, function_literal_index);
        -: 1820:
        4: 1821:    if (function_name_index != -1)
        -: 1822:    {
    #####: 1823:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NAMED_FUNC_EXPRESSION);
    #####: 1824:      context_p->last_cbc.value = (uint16_t) function_name_index;
        -: 1825:    }
        -: 1826:  }
        -: 1827:
       13: 1828:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
       13: 1829:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
       13: 1830:} /* parser_parse_function_expression */
        -: 1831:
        -: 1832:#if JERRY_ESNEXT
        -: 1833:
        -: 1834:/**
        -: 1835: * Parse template literal.
        -: 1836: */
        -: 1837:static void
    #####: 1838:parser_parse_template_literal (parser_context_t *context_p) /**< context */
        -: 1839:{
    #####: 1840:  bool is_empty_head = true;
        -: 1841:
    #####: 1842:  if (context_p->token.lit_location.length > 0)
        -: 1843:  {
    #####: 1844:    is_empty_head = false;
        -: 1845:
    #####: 1846:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1847:
    #####: 1848:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1849:  }
        -: 1850:
    #####: 1851:  lexer_next_token (context_p);
    #####: 1852:  parser_parse_expression (context_p, PARSE_EXPR);
        -: 1853:
    #####: 1854:  if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1855:  {
    #####: 1856:    parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1857:  }
        -: 1858:
    #####: 1859:  if (!is_empty_head)
        -: 1860:  {
    #####: 1861:    if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1862:    {
    #####: 1863:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
        -: 1864:    }
    #####: 1865:    else if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1866:    {
    #####: 1867:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1868:    }
        -: 1869:    else
        -: 1870:    {
    #####: 1871:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1872:    }
        -: 1873:  }
        -: 1874:
    #####: 1875:  context_p->source_p--;
    #####: 1876:  context_p->column--;
    #####: 1877:  lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1878:
    #####: 1879:  if (is_empty_head || context_p->token.lit_location.length > 0)
        -: 1880:  {
    #####: 1881:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1882:
    #####: 1883:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1884:    {
    #####: 1885:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
    #####: 1886:      context_p->last_cbc.value = context_p->lit_object.index;
    #####: 1887:      context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 1888:      context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        -: 1889:    }
        -: 1890:    else
        -: 1891:    {
    #####: 1892:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1893:    }
        -: 1894:  }
        -: 1895:
    #####: 1896:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1897:  {
    #####: 1898:    lexer_next_token (context_p);
        -: 1899:
    #####: 1900:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1901:
    #####: 1902:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1903:    {
    #####: 1904:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1905:    }
        -: 1906:
    #####: 1907:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1908:    {
    #####: 1909:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1910:    }
        -: 1911:    else
        -: 1912:    {
    #####: 1913:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1914:    }
        -: 1915:
    #####: 1916:    context_p->source_p--;
    #####: 1917:    context_p->column--;
    #####: 1918:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1919:
    #####: 1920:    if (context_p->token.lit_location.length > 0)
        -: 1921:    {
    #####: 1922:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 1923:
    #####: 1924:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1925:    }
        -: 1926:  }
    #####: 1927:} /* parser_parse_template_literal */
        -: 1928:
        -: 1929:/**
        -: 1930: * Parse tagged template literal.
        -: 1931: */
        -: 1932:static size_t
    #####: 1933:parser_parse_tagged_template_literal (parser_context_t *context_p) /**< context */
        -: 1934:{
    #####: 1935:  JERRY_ASSERT (context_p->token.type == LEXER_TEMPLATE_LITERAL);
        -: 1936:
    #####: 1937:  uint32_t call_arguments = 0;
        -: 1938:  ecma_collection_t *collection_p;
        -: 1939:
    #####: 1940:  if (context_p->tagged_template_literal_cp == JMEM_CP_NULL)
        -: 1941:  {
    #####: 1942:    collection_p = ecma_new_collection ();
    #####: 1943:    ECMA_SET_INTERNAL_VALUE_POINTER (context_p->tagged_template_literal_cp, collection_p);
        -: 1944:  }
        -: 1945:  else
        -: 1946:  {
    #####: 1947:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 1948:    if (collection_p->item_count > CBC_MAXIMUM_BYTE_VALUE)
        -: 1949:    {
    #####: 1950:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1951:    }
        -: 1952:  }
        -: 1953:
    #####: 1954:  const uint32_t tagged_id = collection_p->item_count;
    #####: 1955:  uint32_t prop_idx = 0;
    #####: 1956:  ecma_object_t *raw_strings_p;
    #####: 1957:  ecma_object_t *template_obj_p = parser_new_tagged_template_literal (&raw_strings_p);
    #####: 1958:  ecma_collection_push_back (collection_p, ecma_make_object_value (template_obj_p));
        -: 1959:
    #####: 1960:  parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1961:
    #####: 1962:  call_arguments++;
    #####: 1963:  parser_emit_cbc_ext_call (context_p, CBC_EXT_GET_TAGGED_TEMPLATE_LITERAL, tagged_id);
        -: 1964:
    #####: 1965:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1966:  {
    #####: 1967:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LEFT_BRACE);
    #####: 1968:    lexer_next_token (context_p);
        -: 1969:
    #####: 1970:    if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 1971:    {
    #####: 1972:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1973:    }
        -: 1974:
    #####: 1975:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1976:
    #####: 1977:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1978:    {
    #####: 1979:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1980:    }
        -: 1981:
    #####: 1982:    context_p->source_p--;
    #####: 1983:    context_p->column--;
    #####: 1984:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1985:
    #####: 1986:    parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1987:  }
        -: 1988:
    #####: 1989:  parser_tagged_template_literal_finalize (template_obj_p, raw_strings_p);
        -: 1990:
    #####: 1991:  return call_arguments;
        -: 1992:} /* parser_parse_tagged_template_literal */
        -: 1993:
        -: 1994:/**
        -: 1995: * Checks wheteher the current expression can be an assignment expression.
        -: 1996: *
        -: 1997: * @return true if the current expression can be an assignment expression, false otherwise
        -: 1998: */
        -: 1999:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 2000:parser_is_assignment_expr (parser_context_t *context_p)
        -: 2001:{
        8: 2002:  return (context_p->stack_top_uint8 == LEXER_EXPRESSION_START || context_p->stack_top_uint8 == LEXER_LEFT_PAREN
    #####: 2003:          || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST
        4: 2004:          || LEXER_IS_BINARY_LVALUE_OP_TOKEN (context_p->stack_top_uint8));
        -: 2005:} /* parser_is_assignment_expr */
        -: 2006:
        -: 2007:/**
        -: 2008: * Throws an error if the current expression is not an assignment expression.
        -: 2009: */
        -: 2010:static inline void JERRY_ATTR_ALWAYS_INLINE
        -: 2011:parser_check_assignment_expr (parser_context_t *context_p)
        -: 2012:{
        4: 2013:  if (!parser_is_assignment_expr (context_p))
        -: 2014:  {
    #####: 2015:    parser_raise_error (context_p, PARSER_ERR_ASSIGNMENT_EXPECTED);
        -: 2016:  }
        -: 2017:} /* parser_check_assignment_expr */
        -: 2018:
        -: 2019:/**
        -: 2020: * Checks whether the next token is a valid continuation token after an AssignmentExpression.
        -: 2021: */
        -: 2022:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 2023:parser_abort_parsing_after_assignment_expression (parser_context_t *context_p)
        -: 2024:{
        4: 2025:  return (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_COMMA);
        -: 2026:} /* parser_abort_parsing_after_assignment_expression */
        -: 2027:
        -: 2028:#endif /* JERRY_ESNEXT */
        -: 2029:
        -: 2030:/**
        -: 2031: * Parse and record unary operators, and parse the primary literal.
        -: 2032: *
        -: 2033: * @return true if parsing should be aborted, true otherwise
        -: 2034: */
        -: 2035:static bool
       66: 2036:parser_parse_unary_expression (parser_context_t *context_p, /**< context */
        -: 2037:                               size_t *grouping_level_p) /**< grouping level */
        -: 2038:{
       66: 2039:  bool new_was_seen = false;
        -: 2040:
        -: 2041:  /* Collect unary operators. */
        -: 2042:  while (true)
        -: 2043:  {
        -: 2044:    /* Convert plus and minus binary operators to unary operators. */
       90: 2045:    switch (context_p->token.type)
        -: 2046:    {
    #####: 2047:      case LEXER_ADD:
        -: 2048:      {
    #####: 2049:        context_p->token.type = LEXER_PLUS;
    #####: 2050:        break;
        -: 2051:      }
    #####: 2052:      case LEXER_SUBTRACT:
        -: 2053:      {
    #####: 2054:        context_p->token.type = LEXER_NEGATE;
    #####: 2055:        break;
        -: 2056:      }
        -: 2057:#if JERRY_ESNEXT
    #####: 2058:      case LEXER_KEYW_AWAIT:
        -: 2059:      {
        -: 2060:#if JERRY_MODULE_SYSTEM
    #####: 2061:        if ((context_p->global_status_flags & ECMA_PARSE_MODULE)
    #####: 2062:            && !(context_p->status_flags & PARSER_IS_ASYNC_FUNCTION))
        -: 2063:        {
    #####: 2064:          parser_raise_error (context_p, PARSER_ERR_AWAIT_NOT_ALLOWED);
        -: 2065:        }
        -: 2066:#endif /* JERRY_MODULE_SYSTEM */
        -: 2067:
    #####: 2068:        if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 2069:        {
    #####: 2070:          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 2071:        }
    #####: 2072:        break;
        -: 2073:      }
        -: 2074:#endif /* JERRY_ESNEXT */
        -: 2075:    }
        -: 2076:
        -: 2077:    /* Bracketed expressions are primary expressions. At this
        -: 2078:     * point their left paren is pushed onto the stack and
        -: 2079:     * they are processed when their closing paren is reached. */
       78: 2080:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2081:    {
        -: 2082:#if JERRY_ESNEXT
        8: 2083:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2084:      {
        4: 2085:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        4: 2086:        break;
        -: 2087:      }
        -: 2088:#endif /* JERRY_ESNEXT */
        4: 2089:      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;
        4: 2090:      new_was_seen = false;
        -: 2091:    }
       70: 2092:    else if (context_p->token.type == LEXER_KEYW_NEW)
        -: 2093:    {
        -: 2094:      /* After 'new' unary operators are not allowed. */
        8: 2095:      new_was_seen = true;
        -: 2096:
        -: 2097:#if JERRY_ESNEXT
        -: 2098:      /* Check if "new.target" is written here. */
        8: 2099:      if (scanner_try_scan_new_target (context_p))
        -: 2100:      {
    #####: 2101:        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))
        -: 2102:        {
    #####: 2103:          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -: 2104:        }
        -: 2105:
    #####: 2106:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);
    #####: 2107:        lexer_next_token (context_p);
        -: 2108:        /* Found "new.target" return here */
    #####: 2109:        return false;
        -: 2110:      }
        -: 2111:#endif /* JERRY_ESNEXT */
        -: 2112:    }
       62: 2113:    else if (new_was_seen || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)
       46: 2114:             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))
        -: 2115:    {
        -: 2116:      break;
        -: 2117:    }
        -: 2118:
       12: 2119:    parser_stack_push_uint8 (context_p, context_p->token.type);
       12: 2120:    lexer_next_token (context_p);
        -: 2121:  }
        -: 2122:
        -: 2123:  /* Parse primary expression. */
       66: 2124:  switch (context_p->token.type)
        -: 2125:  {
        -: 2126:#if JERRY_ESNEXT
    #####: 2127:    case LEXER_HASHMARK:
        -: 2128:    {
    #####: 2129:      if (!lexer_scan_private_identifier (context_p))
        -: 2130:      {
    #####: 2131:        parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2132:      }
        -: 2133:
    #####: 2134:      parser_resolve_private_identifier (context_p);
        -: 2135:
    #####: 2136:      lexer_next_token (context_p);
        -: 2137:
    #####: 2138:      if (context_p->token.type != LEXER_KEYW_IN)
        -: 2139:      {
    #####: 2140:        parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2141:      }
        -: 2142:
    #####: 2143:      parser_stack_push_uint16 (context_p, context_p->lit_object.index);
    #####: 2144:      parser_stack_push_uint8 (context_p, LEXER_PRIVATE_PRIMARY_EXPR);
    #####: 2145:      return false;
        -: 2146:    }
    #####: 2147:    case LEXER_TEMPLATE_LITERAL:
        -: 2148:    {
    #####: 2149:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 2150:      {
    #####: 2151:        parser_parse_template_literal (context_p);
    #####: 2152:        break;
        -: 2153:      }
        -: 2154:
        -: 2155:      /* The string is a normal string literal. */
        -: 2156:      /* FALLTHRU */
        -: 2157:    }
        -: 2158:#endif /* JERRY_ESNEXT */
    #####: 2159:    case LEXER_LITERAL:
        -: 2160:    {
        -: 2161:#if JERRY_ESNEXT
       42: 2162:      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))
        -: 2163:      {
    #####: 2164:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2165:
        -: 2166:#if JERRY_FUNCTION_TO_STRING
    #####: 2167:        context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2168:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2169:
    #####: 2170:        uint32_t arrow_status_flags =
    #####: 2171:          (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));
        -: 2172:
    #####: 2173:        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -: 2174:        {
    #####: 2175:          JERRY_ASSERT (lexer_token_is_async (context_p));
    #####: 2176:          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));
        -: 2177:
    #####: 2178:          uint32_t saved_status_flags = context_p->status_flags;
        -: 2179:
    #####: 2180:          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 2181:          lexer_next_token (context_p);
    #####: 2182:          context_p->status_flags = saved_status_flags;
        -: 2183:
    #####: 2184:          if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 2185:          {
    #####: 2186:            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION | PARSER_IS_ASYNC_FUNCTION
        -: 2187:                                     | PARSER_DISALLOW_AWAIT_YIELD);
    #####: 2188:            parser_parse_function_expression (context_p, status_flags);
    #####: 2189:            break;
        -: 2190:          }
        -: 2191:
    #####: 2192:          arrow_status_flags =
        -: 2193:            (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION | PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD);
        -: 2194:        }
        -: 2195:
    #####: 2196:        parser_check_assignment_expr (context_p);
    #####: 2197:        parser_parse_function_expression (context_p, arrow_status_flags);
    #####: 2198:        return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2199:      }
        -: 2200:#endif /* JERRY_ESNEXT */
        -: 2201:
       42: 2202:      uint8_t type = context_p->token.lit_location.type;
        -: 2203:
       42: 2204:      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)
        -: 2205:      {
       36: 2206:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, context_p->token.lit_location.type);
        -: 2207:      }
        6: 2208:      else if (type == LEXER_NUMBER_LITERAL)
        -: 2209:      {
        6: 2210:        bool is_negative_number = false;
        -: 2211:
        6: 2212:        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)
    #####: 2213:            && !lexer_check_post_primary_exp (context_p))
        -: 2214:        {
        -: 2215:          do
        -: 2216:          {
    #####: 2217:            if (context_p->stack_top_uint8 == LEXER_NEGATE)
        -: 2218:            {
    #####: 2219:              is_negative_number = !is_negative_number;
        -: 2220:            }
        -: 2221:#if JERRY_BUILTIN_BIGINT
    #####: 2222:            else if (JERRY_LIKELY (context_p->token.extra_value == LEXER_NUMBER_BIGINT))
        -: 2223:            {
    #####: 2224:              break;
        -: 2225:            }
        -: 2226:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 2227:            parser_stack_pop_uint8 (context_p);
    #####: 2228:          } while (context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE);
        -: 2229:        }
        -: 2230:
        6: 2231:        if (lexer_construct_number_object (context_p, true, is_negative_number))
        -: 2232:        {
        5: 2233:          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -: 2234:
        5: 2235:          parser_emit_cbc_push_number (context_p, is_negative_number);
        5: 2236:          break;
        -: 2237:        }
        -: 2238:      }
        -: 2239:
       37: 2240:      cbc_opcode_t opcode = CBC_PUSH_LITERAL;
        -: 2241:
       37: 2242:      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)
        -: 2243:      {
       37: 2244:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2245:        {
        1: 2246:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        1: 2247:          context_p->last_cbc.value = context_p->lit_object.index;
        1: 2248:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        1: 2249:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        1: 2250:          break;
        -: 2251:        }
        -: 2252:
       36: 2253:        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2254:        {
    #####: 2255:          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2256:          context_p->last_cbc.third_literal_index = context_p->lit_object.index;
    #####: 2257:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 2258:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
    #####: 2259:          break;
        -: 2260:        }
        -: 2261:
       36: 2262:        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2263:        {
    #####: 2264:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 2265:          opcode = CBC_PUSH_THIS_LITERAL;
        -: 2266:        }
        -: 2267:      }
        -: 2268:
       36: 2269:      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);
       36: 2270:      break;
        -: 2271:    }
        9: 2272:    case LEXER_KEYW_FUNCTION:
        -: 2273:    {
        -: 2274:#if JERRY_FUNCTION_TO_STRING
    #####: 2275:      context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2276:#endif /* JERRY_FUNCTION_TO_STRING */
        9: 2277:      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);
        9: 2278:      break;
        -: 2279:    }
    #####: 2280:    case LEXER_LEFT_BRACE:
        -: 2281:    {
        -: 2282:#if JERRY_ESNEXT
    #####: 2283:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 2284:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2285:      {
    #####: 2286:        if (parser_is_assignment_expr (context_p))
        -: 2287:        {
    #####: 2288:          uint32_t flags = PARSER_PATTERN_NO_OPTS;
        -: 2289:
    #####: 2290:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 2291:          {
    #####: 2292:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 2293:          }
        -: 2294:
    #####: 2295:          parser_parse_object_initializer (context_p, flags);
    #####: 2296:          return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2297:        }
        -: 2298:
    #####: 2299:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2300:      }
        -: 2301:#endif /* JERRY_ESNEXT */
        -: 2302:
    #####: 2303:      parser_parse_object_literal (context_p);
    #####: 2304:      break;
        -: 2305:    }
    #####: 2306:    case LEXER_LEFT_SQUARE:
        -: 2307:    {
        -: 2308:#if JERRY_ESNEXT
    #####: 2309:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2310:      {
    #####: 2311:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 2312:        {
    #####: 2313:          if (parser_is_assignment_expr (context_p))
        -: 2314:          {
    #####: 2315:            parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);
    #####: 2316:            return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2317:          }
        -: 2318:
    #####: 2319:          scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 2320:        }
        -: 2321:        else
        -: 2322:        {
    #####: 2323:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 2324:                        && context_p->next_scanner_info_p->u8_arg == SCANNER_LITERAL_NO_DESTRUCTURING);
        -: 2325:
    #####: 2326:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 2327:        }
        -: 2328:      }
        -: 2329:#endif /* JERRY_ESNEXT */
        -: 2330:
    #####: 2331:      parser_parse_array_literal (context_p);
    #####: 2332:      break;
        -: 2333:    }
    #####: 2334:    case LEXER_DIVIDE:
        -: 2335:    case LEXER_ASSIGN_DIVIDE:
        -: 2336:    {
    #####: 2337:      lexer_construct_regexp_object (context_p, false);
    #####: 2338:      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);
        -: 2339:
    #####: 2340:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2341:      {
    #####: 2342:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 2343:        context_p->last_cbc.value = literal_index;
        -: 2344:      }
    #####: 2345:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2346:      {
    #####: 2347:        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 2348:        context_p->last_cbc.third_literal_index = literal_index;
        -: 2349:      }
        -: 2350:      else
        -: 2351:      {
    #####: 2352:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 2353:      }
        -: 2354:
    #####: 2355:      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;
    #####: 2356:      context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 2357:      break;
        -: 2358:    }
        2: 2359:    case LEXER_KEYW_THIS:
        -: 2360:    {
        -: 2361:#if JERRY_ESNEXT
        2: 2362:      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)
        -: 2363:      {
    #####: 2364:        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);
        -: 2365:      }
        -: 2366:      else
        -: 2367:      {
        -: 2368:#endif /* JERRY_ESNEXT */
        2: 2369:        parser_emit_cbc (context_p, CBC_PUSH_THIS);
        -: 2370:#if JERRY_ESNEXT
        -: 2371:      }
        -: 2372:#endif /* JERRY_ESNEXT */
        2: 2373:      break;
        -: 2374:    }
    #####: 2375:    case LEXER_LIT_TRUE:
        -: 2376:    {
    #####: 2377:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####: 2378:      break;
        -: 2379:    }
        1: 2380:    case LEXER_LIT_FALSE:
        -: 2381:    {
        1: 2382:      parser_emit_cbc (context_p, CBC_PUSH_FALSE);
        1: 2383:      break;
        -: 2384:    }
    #####: 2385:    case LEXER_LIT_NULL:
        -: 2386:    {
    #####: 2387:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
    #####: 2388:      break;
        -: 2389:    }
        -: 2390:#if JERRY_ESNEXT
    #####: 2391:    case LEXER_KEYW_CLASS:
        -: 2392:    {
    #####: 2393:      parser_parse_class (context_p, false);
    #####: 2394:      return false;
        -: 2395:    }
        8: 2396:    case LEXER_KEYW_SUPER:
        -: 2397:    {
        8: 2398:      if (context_p->status_flags & PARSER_ALLOW_SUPER)
        -: 2399:      {
        8: 2400:        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))
        -: 2401:        {
        8: 2402:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);
        8: 2403:          break;
        -: 2404:        }
        -: 2405:
    #####: 2406:        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)
    #####: 2407:            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))
        -: 2408:        {
    #####: 2409:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);
    #####: 2410:          break;
        -: 2411:        }
        -: 2412:      }
        -: 2413:
    #####: 2414:      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);
        -: 2415:    }
        4: 2416:    case LEXER_LEFT_PAREN:
        -: 2417:    {
        4: 2418:      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 2419:                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2420:
    #####: 2421:      parser_check_assignment_expr (context_p);
        -: 2422:
        -: 2423:#if JERRY_FUNCTION_TO_STRING
    #####: 2424:      context_p->function_start_p = context_p->source_p - 1;
        -: 2425:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2426:
        4: 2427:      uint32_t arrow_status_flags =
        4: 2428:        (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION | (context_p->status_flags & PARSER_INSIDE_CLASS_FIELD));
        4: 2429:      parser_parse_function_expression (context_p, arrow_status_flags);
        4: 2430:      return parser_abort_parsing_after_assignment_expression (context_p);
        -: 2431:    }
    #####: 2432:    case LEXER_KEYW_YIELD:
        -: 2433:    {
    #####: 2434:      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2435:                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));
        -: 2436:
    #####: 2437:      if (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 2438:      {
    #####: 2439:        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 2440:      }
        -: 2441:
    #####: 2442:      parser_check_assignment_expr (context_p);
    #####: 2443:      lexer_next_token (context_p);
        -: 2444:
    #####: 2445:      cbc_ext_opcode_t opcode =
    #####: 2446:        ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD : CBC_EXT_YIELD);
    #####: 2447:      if (!lexer_check_yield_no_arg (context_p))
        -: 2448:      {
    #####: 2449:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 2450:        {
    #####: 2451:          lexer_next_token (context_p);
    #####: 2452:          opcode = ((context_p->status_flags & PARSER_IS_ASYNC_FUNCTION) ? CBC_EXT_ASYNC_YIELD_ITERATOR
    #####: 2453:                                                                         : CBC_EXT_YIELD_ITERATOR);
        -: 2454:        }
        -: 2455:
    #####: 2456:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2457:      }
        -: 2458:      else
        -: 2459:      {
    #####: 2460:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 2461:      }
        -: 2462:
    #####: 2463:      parser_emit_cbc_ext (context_p, opcode);
        -: 2464:
    #####: 2465:      return (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_COMMA);
        -: 2466:    }
        -: 2467:#endif /* JERRY_ESNEXT */
        -: 2468:#if JERRY_MODULE_SYSTEM
    #####: 2469:    case LEXER_KEYW_IMPORT:
        -: 2470:    {
    #####: 2471:      lexer_next_token (context_p);
        -: 2472:
    #####: 2473:      if (context_p->token.type == LEXER_DOT)
        -: 2474:      {
    #####: 2475:        lexer_next_token (context_p);
        -: 2476:
    #####: 2477:        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL
    #####: 2478:            || context_p->token.keyword_type != LEXER_KEYW_META
    #####: 2479:            || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 2480:        {
    #####: 2481:          parser_raise_error (context_p, PARSER_ERR_META_EXPECTED);
        -: 2482:        }
        -: 2483:
    #####: 2484:        if (!(context_p->global_status_flags & ECMA_PARSE_MODULE))
        -: 2485:        {
    #####: 2486:          parser_raise_error (context_p, PARSER_ERR_IMPORT_META_REQUIRE_MODULE);
        -: 2487:        }
        -: 2488:
    #####: 2489:        JERRY_ASSERT (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META);
        -: 2490:
    #####: 2491:        parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT_META);
    #####: 2492:        break;
        -: 2493:      }
        -: 2494:
    #####: 2495:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2496:      {
    #####: 2497:        parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 2498:      }
        -: 2499:
    #####: 2500:      if (new_was_seen)
        -: 2501:      {
    #####: 2502:        parser_raise_error (context_p, PARSER_ERR_IMPORT_AFTER_NEW);
        -: 2503:      }
        -: 2504:
    #####: 2505:      lexer_next_token (context_p);
    #####: 2506:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2507:
    #####: 2508:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2509:      {
    #####: 2510:        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2511:      }
        -: 2512:
    #####: 2513:      parser_emit_cbc_ext (context_p, CBC_EXT_MODULE_IMPORT);
    #####: 2514:      break;
        -: 2515:    }
        -: 2516:#endif /* JERRY_MODULE_SYSTEM */
    #####: 2517:    default:
        -: 2518:    {
    #####: 2519:      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 2520:      parser_raise_error (context_p,
        -: 2521:                          (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED : PARSER_ERR_UNEXPECTED_END));
    #####: 2522:      break;
        -: 2523:    }
        -: 2524:  }
       62: 2525:  lexer_next_token (context_p);
       62: 2526:  return false;
        -: 2527:} /* parser_parse_unary_expression */
        -: 2528:
        -: 2529:/**
        -: 2530: * Parse the postfix part of unary operators, and
        -: 2531: * generate byte code for the whole expression.
        -: 2532: */
        -: 2533:static void
      107: 2534:parser_process_unary_expression (parser_context_t *context_p, /**< context */
        -: 2535:                                 size_t grouping_level) /**< grouping level */
        -: 2536:{
        -: 2537:  /* Parse postfix part of a primary expression. */
        -: 2538:  while (true)
        -: 2539:  {
        -: 2540:    /* Since break would only break the switch, we use
        -: 2541:     * continue to continue this loop. Without continue,
        -: 2542:     * the code abandons the loop. */
      144: 2543:    switch (context_p->token.type)
        -: 2544:    {
        6: 2545:      case LEXER_DOT:
        -: 2546:      {
        6: 2547:        parser_push_result (context_p);
        -: 2548:
        -: 2549:#if JERRY_ESNEXT
        6: 2550:        if (lexer_check_next_character (context_p, LIT_CHAR_HASHMARK))
        -: 2551:        {
    #####: 2552:          lexer_next_token (context_p);
        -: 2553:
    #####: 2554:          if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2555:          {
    #####: 2556:            parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_PRIVATE_FIELD);
        -: 2557:          }
        -: 2558:
    #####: 2559:          if (!lexer_scan_private_identifier (context_p))
        -: 2560:          {
    #####: 2561:            parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2562:          }
        -: 2563:
    #####: 2564:          parser_resolve_private_identifier (context_p);
        -: 2565:
    #####: 2566:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_PRIVATE_PROP_LITERAL, context_p->lit_object.index);
    #####: 2567:          lexer_next_token (context_p);
    #####: 2568:          continue;
        -: 2569:        }
        -: 2570:#endif /* JERRY_ESNEXT */
        6: 2571:        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);
        -: 2572:
        6: 2573:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 2574:                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);
        6: 2575:        context_p->token.lit_location.type = LEXER_STRING_LITERAL;
        -: 2576:
        6: 2577:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2578:        {
    #####: 2579:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
    #####: 2580:          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;
    #####: 2581:          context_p->last_cbc.value = context_p->lit_object.index;
        -: 2582:        }
        6: 2583:        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 2584:        {
        2: 2585:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        2: 2586:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);
        -: 2587:        }
        -: 2588:#if JERRY_ESNEXT
        4: 2589:        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2590:        {
        4: 2591:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);
        4: 2592:          context_p->last_cbc.literal_index = context_p->lit_object.index;
        -: 2593:        }
        -: 2594:#endif /* JERRY_ESNEXT */
        -: 2595:        else
        -: 2596:        {
    #####: 2597:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);
        -: 2598:        }
        6: 2599:        lexer_next_token (context_p);
        6: 2600:        continue;
        -: 2601:      }
        -: 2602:
        4: 2603:      case LEXER_LEFT_SQUARE:
        -: 2604:      {
        4: 2605:        parser_push_result (context_p);
        -: 2606:
        -: 2607:#if JERRY_ESNEXT
        4: 2608:        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
        -: 2609:
        4: 2610:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2611:        {
        4: 2612:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2613:        }
        -: 2614:#endif /* JERRY_ESNEXT */
        -: 2615:
        4: 2616:        lexer_next_token (context_p);
        4: 2617:        parser_parse_expression (context_p, PARSE_EXPR);
        4: 2618:        if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 2619:        {
    #####: 2620:          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);
        -: 2621:        }
        4: 2622:        lexer_next_token (context_p);
        -: 2623:
        -: 2624:#if JERRY_ESNEXT
        4: 2625:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 2626:        {
        4: 2627:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);
        4: 2628:          continue;
        -: 2629:        }
        -: 2630:#endif /* JERRY_ESNEXT */
        -: 2631:
    #####: 2632:        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))
        -: 2633:        {
    #####: 2634:          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);
        -: 2635:        }
        -: 2636:        else
        -: 2637:        {
    #####: 2638:          parser_emit_cbc (context_p, CBC_PUSH_PROP);
        -: 2639:        }
    #####: 2640:        continue;
        -: 2641:      }
        -: 2642:
        -: 2643:#if JERRY_ESNEXT
       27: 2644:      case LEXER_TEMPLATE_LITERAL:
        -: 2645:#endif /* JERRY_ESNEXT */
    #####: 2646:      case LEXER_LEFT_PAREN:
        -: 2647:      {
       27: 2648:        size_t call_arguments = 0;
       27: 2649:        uint16_t opcode = CBC_CALL;
       27: 2650:        bool is_eval = false;
        -: 2651:
       27: 2652:        parser_push_result (context_p);
        -: 2653:
       27: 2654:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2655:        {
        -: 2656:#if JERRY_ESNEXT
        8: 2657:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2658:#endif /* JERRY_ESNEXT */
        -: 2659:          {
        8: 2660:            parser_stack_pop_uint8 (context_p);
        8: 2661:            opcode = CBC_NEW;
        -: 2662:          }
        -: 2663:        }
        -: 2664:        else
        -: 2665:        {
       19: 2666:          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
       19: 2667:              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL
    #####: 2668:              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2669:          {
    #####: 2670:            is_eval = true;
        -: 2671:          }
        -: 2672:
       19: 2673:          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2674:          {
    #####: 2675:            opcode = CBC_CALL_PROP;
    #####: 2676:            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 2677:          }
        -: 2678:#if JERRY_ESNEXT
       19: 2679:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))
        -: 2680:          {
    #####: 2681:            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);
        -: 2682:          }
       19: 2683:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2684:          {
    #####: 2685:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);
    #####: 2686:            opcode = CBC_CALL_PROP;
        -: 2687:          }
       19: 2688:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2689:          {
    #####: 2690:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);
    #####: 2691:            opcode = CBC_CALL_PROP;
        -: 2692:          }
       19: 2693:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -: 2694:          {
    #####: 2695:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL_REFERENCE);
    #####: 2696:            opcode = CBC_CALL_PROP;
        -: 2697:          }
        -: 2698:#endif /* JERRY_ESNEXT */
       19: 2699:          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)
    #####: 2700:                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2701:                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2702:          {
    #####: 2703:            opcode = CBC_CALL_PROP;
    #####: 2704:            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
    #####: 2705:            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);
        -: 2706:          }
        -: 2707:        }
        -: 2708:
        -: 2709:#if JERRY_ESNEXT
       27: 2710:        bool has_spread_element = false;
        -: 2711:
       27: 2712:        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)
        -: 2713:        {
    #####: 2714:          call_arguments = parser_parse_tagged_template_literal (context_p);
        -: 2715:        }
        -: 2716:        else
        -: 2717:        {
       27: 2718:          lexer_next_token (context_p);
        -: 2719:
       27: 2720:          while (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2721:          {
        9: 2722:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2723:            {
    #####: 2724:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2725:            }
        -: 2726:
        9: 2727:            if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2728:            {
    #####: 2729:              has_spread_element = true;
    #####: 2730:              call_arguments++;
    #####: 2731:              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
    #####: 2732:              lexer_next_token (context_p);
        -: 2733:            }
        -: 2734:
        9: 2735:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2736:
        9: 2737:            if (context_p->token.type == LEXER_COMMA)
        -: 2738:            {
    #####: 2739:              lexer_next_token (context_p);
    #####: 2740:              continue;
        -: 2741:            }
        -: 2742:
        9: 2743:            if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2744:            {
    #####: 2745:              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2746:            }
        -: 2747:
        9: 2748:            break;
        -: 2749:          }
        -: 2750:        }
        -: 2751:#else /* !JERRY_ESNEXT */
    #####: 2752:        lexer_next_token (context_p);
        -: 2753:
    #####: 2754:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2755:        {
        -: 2756:          while (true)
        -: 2757:          {
    #####: 2758:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2759:            {
    #####: 2760:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2761:            }
        -: 2762:
    #####: 2763:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2764:
    #####: 2765:            if (context_p->token.type != LEXER_COMMA)
        -: 2766:            {
        -: 2767:              break;
        -: 2768:            }
    #####: 2769:            lexer_next_token (context_p);
        -: 2770:          }
        -: 2771:
    #####: 2772:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2773:          {
    #####: 2774:            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2775:          }
        -: 2776:        }
        -: 2777:#endif /* JERRY_ESNEXT */
        -: 2778:
       27: 2779:        lexer_next_token (context_p);
        -: 2780:
       27: 2781:        if (is_eval)
        -: 2782:        {
    #####: 2783:          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2784:
        -: 2785:#if JERRY_ESNEXT
    #####: 2786:          uint16_t eval_flags = PARSER_SAVE_STATUS_FLAGS (context_p->status_flags);
    #####: 2787:          const uint32_t required_flags = PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2788:
    #####: 2789:          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2790:          {
    #####: 2791:            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2792:          }
    #####: 2793:          else if (((context_p->status_flags & (required_flags | PARSER_IS_STRICT)) == required_flags)
    #####: 2794:                   || ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2795:                       && !(context_p->status_flags & PARSER_IS_FUNCTION)))
        -: 2796:          {
    #####: 2797:            eval_flags |= PARSER_GET_EVAL_FLAG (ECMA_PARSE_FUNCTION_CONTEXT);
        -: 2798:          }
        -: 2799:
    #####: 2800:          if (eval_flags != 0)
        -: 2801:          {
    #####: 2802:            parser_emit_cbc_ext_call (context_p, CBC_EXT_LOCAL_EVAL, eval_flags);
        -: 2803:          }
        -: 2804:          else
        -: 2805:          {
        -: 2806:#endif /* JERRY_ESNEXT */
    #####: 2807:            parser_emit_cbc (context_p, CBC_EVAL);
        -: 2808:#if JERRY_ESNEXT
        -: 2809:          }
        -: 2810:#endif /* JERRY_ESNEXT */
        -: 2811:        }
        -: 2812:
        -: 2813:#if JERRY_ESNEXT
       27: 2814:        if (has_spread_element)
        -: 2815:        {
        -: 2816:          uint16_t spread_opcode;
        -: 2817:
    #####: 2818:          if (opcode == CBC_CALL)
        -: 2819:          {
    #####: 2820:            spread_opcode = CBC_EXT_SPREAD_CALL;
        -: 2821:          }
    #####: 2822:          else if (opcode == CBC_CALL_PROP)
        -: 2823:          {
    #####: 2824:            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;
        -: 2825:          }
    #####: 2826:          else if (opcode == CBC_NEW)
        -: 2827:          {
    #####: 2828:            spread_opcode = CBC_EXT_SPREAD_NEW;
        -: 2829:          }
        -: 2830:          else
        -: 2831:          {
        -: 2832:            /* opcode is unchanged */
    #####: 2833:            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));
    #####: 2834:            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;
        -: 2835:          }
        -: 2836:
    #####: 2837:          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);
    #####: 2838:          continue;
        -: 2839:        }
        -: 2840:#endif /* JERRY_ESNEXT */
        -: 2841:
       27: 2842:        if (call_arguments <= 1)
        -: 2843:        {
       27: 2844:          if (opcode == CBC_CALL)
        -: 2845:          {
       19: 2846:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));
       19: 2847:            continue;
        -: 2848:          }
        8: 2849:          if (opcode == CBC_CALL_PROP)
        -: 2850:          {
    #####: 2851:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));
    #####: 2852:            continue;
        -: 2853:          }
        8: 2854:          if (opcode == CBC_NEW)
        -: 2855:          {
        8: 2856:            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));
        8: 2857:            continue;
        -: 2858:          }
        -: 2859:        }
    #####: 2860:        else if (call_arguments == 2)
        -: 2861:        {
    #####: 2862:          if (opcode == CBC_CALL)
        -: 2863:          {
    #####: 2864:            parser_emit_cbc (context_p, CBC_CALL2);
    #####: 2865:            continue;
        -: 2866:          }
    #####: 2867:          if (opcode == CBC_CALL_PROP)
        -: 2868:          {
    #####: 2869:            parser_flush_cbc (context_p);
        -: 2870:            /* Manually adjusting stack usage. */
    #####: 2871:            JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 2872:            context_p->stack_depth--;
    #####: 2873:            parser_emit_cbc (context_p, CBC_CALL2_PROP);
    #####: 2874:            continue;
        -: 2875:          }
        -: 2876:        }
        -: 2877:
    #####: 2878:        parser_emit_cbc_call (context_p, opcode, call_arguments);
    #####: 2879:        continue;
        -: 2880:      }
       70: 2881:      default:
        -: 2882:      {
       70: 2883:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2884:        {
    #####: 2885:          parser_push_result (context_p);
    #####: 2886:          parser_emit_cbc (context_p, CBC_NEW0);
    #####: 2887:          parser_stack_pop_uint8 (context_p);
    #####: 2888:          continue;
        -: 2889:        }
        -: 2890:
       70: 2891:        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
       70: 2892:            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)
        1: 2893:            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)
        -: 2894:        {
        1: 2895:          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;
        1: 2896:          parser_push_result (context_p);
        1: 2897:          parser_emit_unary_lvalue_opcode (context_p, opcode);
        1: 2898:          lexer_next_token (context_p);
        -: 2899:        }
       70: 2900:        break;
        -: 2901:      }
        -: 2902:    }
       70: 2903:    break;
        -: 2904:  }
        -: 2905:
        -: 2906:#if JERRY_ESNEXT
       70: 2907:  uint8_t last_unary_token = LEXER_INCREASE;
        -: 2908:#endif /* JERRY_ESNEXT */
        -: 2909:
        -: 2910:  /* Generate byte code for the unary operators. */
        -: 2911:  while (true)
    #####: 2912:  {
       70: 2913:    uint8_t token = context_p->stack_top_uint8;
       70: 2914:    if (!LEXER_IS_UNARY_OP_TOKEN (token))
        -: 2915:    {
        -: 2916:#if JERRY_ESNEXT
       70: 2917:      if (context_p->token.type == LEXER_EXPONENTIATION && last_unary_token != LEXER_INCREASE
    #####: 2918:          && last_unary_token != LEXER_DECREASE)
        -: 2919:      {
    #####: 2920:        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);
        -: 2921:      }
        -: 2922:#endif /* JERRY_ESNEXT */
       70: 2923:      break;
        -: 2924:    }
        -: 2925:
        -: 2926:#if JERRY_ESNEXT
    #####: 2927:    last_unary_token = token;
        -: 2928:#endif /* JERRY_ESNEXT */
        -: 2929:
    #####: 2930:    parser_push_result (context_p);
    #####: 2931:    parser_stack_pop_uint8 (context_p);
        -: 2932:
    #####: 2933:    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))
        -: 2934:    {
    #####: 2935:      if (token == LEXER_KEYW_DELETE)
        -: 2936:      {
    #####: 2937:        token = CBC_DELETE_PUSH_RESULT;
        -: 2938:      }
        -: 2939:      else
        -: 2940:      {
    #####: 2941:        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));
        -: 2942:      }
    #####: 2943:      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);
        -: 2944:    }
        -: 2945:#if JERRY_ESNEXT
    #####: 2946:    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))
        -: 2947:    {
    #####: 2948:      cbc_ext_opcode_t opcode =
    #####: 2949:        ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION) ? CBC_EXT_GENERATOR_AWAIT : CBC_EXT_AWAIT);
    #####: 2950:      parser_emit_cbc_ext (context_p, opcode);
        -: 2951:    }
        -: 2952:#endif /* JERRY_ESNEXT */
        -: 2953:    else
        -: 2954:    {
    #####: 2955:      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));
        -: 2956:
    #####: 2957:      if (token == CBC_TYPEOF)
        -: 2958:      {
    #####: 2959:        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2960:            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2961:        {
    #####: 2962:          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);
        -: 2963:        }
        -: 2964:        else
        -: 2965:        {
    #####: 2966:          parser_emit_cbc (context_p, token);
        -: 2967:        }
        -: 2968:      }
        -: 2969:      else
        -: 2970:      {
    #####: 2971:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2972:        {
        -: 2973:          /* It is not worth to combine with push multiple literals
        -: 2974:           * since the byte code size will not decrease. */
    #####: 2975:          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));
    #####: 2976:          context_p->last_cbc_opcode = (uint16_t) (token + 1);
        -: 2977:        }
        -: 2978:        else
        -: 2979:        {
    #####: 2980:          parser_emit_cbc (context_p, token);
        -: 2981:        }
        -: 2982:      }
        -: 2983:    }
        -: 2984:  }
       70: 2985:} /* parser_process_unary_expression */
        -: 2986:
        -: 2987:/**
        -: 2988: * Append a binary '=' token.
        -: 2989: *
        -: 2990: * @return - pushed assignment opcode onto the parser stack
        -: 2991: */
        -: 2992:static void
        5: 2993:parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */
        -: 2994:                                              uint32_t pattern_flags) /**< pattern flags */
        -: 2995:{
        -: 2996:  JERRY_UNUSED (pattern_flags);
        -: 2997:
        -: 2998:  /* Unlike other tokens, the whole byte code is saved for binary
        -: 2999:   * assignment, since it has multiple forms depending on the
        -: 3000:   * previous instruction. */
        -: 3001:
        5: 3002:  uint8_t assign_opcode = CBC_ASSIGN;
        -: 3003:
        5: 3004:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 3005:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
    #####: 3006:  {
    #####: 3007:    parser_check_invalid_assign (context_p);
        -: 3008:
        -: 3009:    uint16_t literal_index;
        -: 3010:
    #####: 3011:    switch (context_p->last_cbc_opcode)
        -: 3012:    {
    #####: 3013:      case CBC_PUSH_LITERAL:
        -: 3014:      {
    #####: 3015:        literal_index = context_p->last_cbc.literal_index;
    #####: 3016:        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 3017:        break;
        -: 3018:      }
    #####: 3019:      case CBC_PUSH_TWO_LITERALS:
        -: 3020:      {
    #####: 3021:        literal_index = context_p->last_cbc.value;
    #####: 3022:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 3023:        break;
        -: 3024:      }
    #####: 3025:      case CBC_PUSH_THIS_LITERAL:
        -: 3026:      {
    #####: 3027:        literal_index = context_p->last_cbc.literal_index;
    #####: 3028:        context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####: 3029:        parser_flush_cbc (context_p);
    #####: 3030:        break;
        -: 3031:      }
    #####: 3032:      default:
        -: 3033:      {
    #####: 3034:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####: 3035:        literal_index = context_p->last_cbc.third_literal_index;
    #####: 3036:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 3037:        break;
        -: 3038:      }
        -: 3039:    }
        -: 3040:
    #####: 3041:    assign_opcode = CBC_ASSIGN_SET_IDENT;
        -: 3042:
        -: 3043:#if JERRY_ESNEXT
    #####: 3044:    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))
        -: 3045:    {
    #####: 3046:      if (scanner_literal_is_const_reg (context_p, literal_index))
        -: 3047:      {
    #####: 3048:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 3049:      }
        -: 3050:    }
    #####: 3051:    else if (literal_index < PARSER_REGISTER_START)
        -: 3052:    {
    #####: 3053:      assign_opcode = CBC_INIT_LET;
        -: 3054:
    #####: 3055:      if (scanner_literal_is_created (context_p, literal_index))
        -: 3056:      {
    #####: 3057:        assign_opcode = CBC_ASSIGN_LET_CONST;
        -: 3058:      }
    #####: 3059:      else if (pattern_flags & PARSER_PATTERN_CONST)
        -: 3060:      {
    #####: 3061:        assign_opcode = CBC_INIT_CONST;
        -: 3062:      }
    #####: 3063:      else if (pattern_flags & PARSER_PATTERN_LOCAL)
        -: 3064:      {
    #####: 3065:        assign_opcode = CBC_INIT_ARG_OR_CATCH;
        -: 3066:      }
        -: 3067:    }
        -: 3068:#endif /* JERRY_ESNEXT */
        -: 3069:
    #####: 3070:    parser_stack_push_uint16 (context_p, literal_index);
    #####: 3071:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));
        -: 3072:  }
        5: 3073:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -: 3074:  {
    #####: 3075:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));
    #####: 3076:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3077:  }
        5: 3078:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)
        -: 3079:  {
    #####: 3080:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 3081:    {
    #####: 3082:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));
    #####: 3083:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 3084:      assign_opcode = CBC_ASSIGN_PROP_LITERAL;
    #####: 3085:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3086:    }
        -: 3087:    else
        -: 3088:    {
    #####: 3089:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
        -: 3090:    }
        -: 3091:  }
        5: 3092:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 3093:  {
    #####: 3094:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));
    #####: 3095:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        -: 3096:  }
        5: 3097:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 3098:  {
        1: 3099:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 3100:    {
        1: 3101:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));
        1: 3102:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
        1: 3103:      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;
        1: 3104:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 3105:    }
        -: 3106:    else
        -: 3107:    {
    #####: 3108:      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
        -: 3109:    }
        -: 3110:  }
        -: 3111:#if JERRY_ESNEXT
        4: 3112:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 3113:  {
        2: 3114:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
        2: 3115:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
        2: 3116:    assign_opcode = CBC_EXT_OPCODE;
        -: 3117:  }
        2: 3118:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 3119:  {
        2: 3120:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);
        2: 3121:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_SUPER);
        2: 3122:    assign_opcode = CBC_EXT_OPCODE;
        -: 3123:  }
    #####: 3124:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_PRIVATE_PROP_LITERAL))
        -: 3125:  {
    #####: 3126:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 3127:    parser_stack_push_uint8 (context_p, CBC_EXT_ASSIGN_PRIVATE);
    #####: 3128:    assign_opcode = CBC_EXT_OPCODE;
        -: 3129:  }
        -: 3130:#endif /* JERRY_ESNEXT */
        -: 3131:  else
        -: 3132:  {
        -: 3133:    /* Invalid LeftHandSide expression. */ // 3820, 3815
        -: 3134:#if JERRY_ESNEXT
    #####: 3135:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 3136:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3137:#else /* !JERRY_ESNEXT */
    #####: 3138:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 3139:#endif /* JERRY_ESNEXT */
        -: 3140:  }
        -: 3141:
        5: 3142:  parser_stack_push_uint8 (context_p, assign_opcode);
        5: 3143:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
        5: 3144:} /* parser_append_binary_single_assignment_token */
        -: 3145:
        -: 3146:#if JERRY_ESNEXT
        -: 3147:
        -: 3148:/**
        -: 3149: * Check for invalid chain of logical operators
        -: 3150: */
        -: 3151:static void
    #####: 3152:parser_check_invalid_logical_op (parser_context_t *context_p, /**< context */
        -: 3153:                                 uint8_t invalid_token1, /**< token id of first invalid token */
        -: 3154:                                 uint8_t invalid_token2) /**< token id of second invalid token */
        -: 3155:{
    #####: 3156:  parser_stack_iterator_t iterator;
    #####: 3157:  parser_stack_iterator_init (context_p, &iterator);
        -: 3158:
        -: 3159:  while (true)
    #####: 3160:  {
    #####: 3161:    uint8_t token = parser_stack_iterator_read_uint8 (&iterator);
        -: 3162:
    #####: 3163:    if (!LEXER_IS_BINARY_NON_LVALUE_OP_TOKEN (token))
        -: 3164:    {
    #####: 3165:      return;
        -: 3166:    }
        -: 3167:
    #####: 3168:    if (token == invalid_token1 || token == invalid_token2)
        -: 3169:    {
    #####: 3170:      parser_raise_error (context_p, PARSER_ERR_INVALID_NULLISH_COALESCING);
        -: 3171:    }
        -: 3172:
        -: 3173:    /* If a logical operator is found, and there is no SyntaxError, the scan can be terminated
        -: 3174:     * since there was no SyntaxError when the logical operator was pushed onto the stack. */
    #####: 3175:    if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND || token == LEXER_NULLISH_COALESCING)
        -: 3176:    {
    #####: 3177:      return;
        -: 3178:    }
        -: 3179:
    #####: 3180:    parser_stack_iterator_skip (&iterator, sizeof (uint8_t));
        -: 3181:  }
        -: 3182:} /* parser_check_invalid_logical_op */
        -: 3183:
        -: 3184:#endif /* JERRY_ESNEXT */
        -: 3185:
        -: 3186:/**
        -: 3187: * Append a binary lvalue token.
        -: 3188: */
        -: 3189:static void
    #####: 3190:parser_append_binary_lvalue_token (parser_context_t *context_p, /**< context */
        -: 3191:                                   bool is_logical_assignment) /**< true - if form logical assignment reference
        -: 3192:                                                                *   false - otherwise */
        -: 3193:{
    #####: 3194:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 3195:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 3196:  {
    #####: 3197:    parser_check_invalid_assign (context_p);
        -: 3198:
    #####: 3199:    parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
        -: 3200:
        -: 3201:#if JERRY_ESNEXT
    #####: 3202:    if (!is_logical_assignment && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -: 3203:    {
    #####: 3204:      parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 3205:    }
        -: 3206:#endif /* JERRY_ESNEXT */
        -: 3207:  }
    #####: 3208:  else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3209:  {
    #####: 3210:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 3211:  }
        -: 3212:  else
        -: 3213:  {
        -: 3214:    /* Invalid LeftHandSide expression. */
        -: 3215:#if JERRY_ESNEXT
    #####: 3216:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
    #####: 3217:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 3218:#else /* !JERRY_ESNEXT */
    #####: 3219:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 3220:#endif /* JERRY_ESNEXT */
        -: 3221:
    #####: 3222:    parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);
        -: 3223:  }
        -: 3224:
    #####: 3225:  if (!is_logical_assignment)
        -: 3226:  {
    #####: 3227:    parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
        -: 3228:  }
    #####: 3229:} /* parser_append_binary_lvalue_token */
        -: 3230:
        -: 3231:/**
        -: 3232: * Append a logical token.
        -: 3233: */
        -: 3234:static void
    #####: 3235:parser_append_logical_token (parser_context_t *context_p, /**< context */
        -: 3236:                             uint16_t opcode) /**< opcode */
        -: 3237:{
        -: 3238:#if JERRY_ESNEXT
    #####: 3239:  if (opcode != PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH))
        -: 3240:  {
    #####: 3241:    parser_check_invalid_logical_op (context_p, LEXER_NULLISH_COALESCING, LEXER_NULLISH_COALESCING);
        -: 3242:  }
        -: 3243:#endif /* JERRY_ESNEXT */
        -: 3244:
    #####: 3245:  parser_branch_t branch;
        -: 3246:
    #####: 3247:  parser_emit_cbc_forward_branch (context_p, opcode, &branch);
    #####: 3248:  parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
    #####: 3249:  parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
    #####: 3250:} /* parser_append_logical_token */
        -: 3251:
        -: 3252:#if JERRY_ESNEXT
        -: 3253:/**
        -: 3254: * Append a logical token.
        -: 3255: */
        -: 3256:static void
    #####: 3257:parser_append_logical_assignment_token (parser_context_t *context_p, /**< context */
        -: 3258:                                        uint16_t opcode) /**< opcode */
        -: 3259:{
    #####: 3260:  uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
    #####: 3261:  parser_append_binary_single_assignment_token (context_p, 0);
    #####: 3262:  parser_stack_change_last_uint8 (context_p, LEXER_ASSIGN_REFERENCE);
    #####: 3263:  context_p->last_cbc_opcode = last_cbc_opcode;
        -: 3264:
    #####: 3265:  parser_append_binary_lvalue_token (context_p, true);
    #####: 3266:  parser_append_logical_token (context_p, opcode);
    #####: 3267:} /* parser_append_logical_assignment_token */
        -: 3268:#endif /* JERRY_ESNEXT */
        -: 3269:
        -: 3270:/**
        -: 3271: * Append a binary token.
        -: 3272: */
        -: 3273:static void
        6: 3274:parser_append_binary_token (parser_context_t *context_p) /**< context */
        -: 3275:{
        6: 3276:  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));
        6: 3277:  parser_push_result (context_p);
        -: 3278:
        6: 3279:  switch (context_p->token.type)
        -: 3280:  {
        5: 3281:    case LEXER_ASSIGN:
        -: 3282:    {
        5: 3283:      parser_append_binary_single_assignment_token (context_p, 0);
        5: 3284:      break;
        -: 3285:    }
        -: 3286:    /* Binary lvalue-opcodes */
    #####: 3287:    case LEXER_ASSIGN_ADD:
        -: 3288:    case LEXER_ASSIGN_SUBTRACT:
        -: 3289:    case LEXER_ASSIGN_MULTIPLY:
        -: 3290:    case LEXER_ASSIGN_DIVIDE:
        -: 3291:    case LEXER_ASSIGN_MODULO:
        -: 3292:#if JERRY_ESNEXT
        -: 3293:    case LEXER_ASSIGN_EXPONENTIATION:
        -: 3294:#endif /* JERRY_ESNEXT */
        -: 3295:    case LEXER_ASSIGN_LEFT_SHIFT:
        -: 3296:    case LEXER_ASSIGN_RIGHT_SHIFT:
        -: 3297:    case LEXER_ASSIGN_UNS_RIGHT_SHIFT:
        -: 3298:    case LEXER_ASSIGN_BIT_AND:
        -: 3299:    case LEXER_ASSIGN_BIT_OR:
        -: 3300:    case LEXER_ASSIGN_BIT_XOR:
        -: 3301:    {
    #####: 3302:      parser_append_binary_lvalue_token (context_p, false);
    #####: 3303:      break;
        -: 3304:    }
        -: 3305:#if JERRY_ESNEXT
    #####: 3306:    case LEXER_ASSIGN_NULLISH_COALESCING:
        -: 3307:    {
    #####: 3308:      parser_append_logical_assignment_token (context_p, PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH));
    #####: 3309:      break;
        -: 3310:    }
    #####: 3311:    case LEXER_ASSIGN_LOGICAL_OR:
        -: 3312:    {
    #####: 3313:      parser_append_logical_assignment_token (context_p, CBC_BRANCH_IF_LOGICAL_TRUE);
    #####: 3314:      break;
        -: 3315:    }
    #####: 3316:    case LEXER_ASSIGN_LOGICAL_AND:
        -: 3317:    {
    #####: 3318:      parser_append_logical_assignment_token (context_p, CBC_BRANCH_IF_LOGICAL_FALSE);
    #####: 3319:      break;
        -: 3320:    }
    #####: 3321:    case LEXER_NULLISH_COALESCING:
        -: 3322:    {
    #####: 3323:      parser_append_logical_token (context_p, PARSER_TO_EXT_OPCODE (CBC_EXT_BRANCH_IF_NULLISH));
    #####: 3324:      break;
        -: 3325:    }
        -: 3326:#endif /* JERRY_ESNEXT */
    #####: 3327:    case LEXER_LOGICAL_OR:
        -: 3328:    {
    #####: 3329:      parser_append_logical_token (context_p, CBC_BRANCH_IF_LOGICAL_TRUE);
    #####: 3330:      break;
        -: 3331:    }
    #####: 3332:    case LEXER_LOGICAL_AND:
        -: 3333:    {
    #####: 3334:      parser_append_logical_token (context_p, CBC_BRANCH_IF_LOGICAL_FALSE);
    #####: 3335:      break;
        -: 3336:    }
        1: 3337:    default:
        -: 3338:    {
        1: 3339:      parser_stack_push_uint8 (context_p, (uint8_t) context_p->token.type);
        1: 3340:      break;
        -: 3341:    }
        -: 3342:  }
        6: 3343:} /* parser_append_binary_token */
        -: 3344:
        -: 3345:/**
        -: 3346: * Emit opcode for binary assignment token.
        -: 3347: */
        -: 3348:static void
        5: 3349:parser_process_binary_assignment_token (parser_context_t *context_p, /**< context */
        -: 3350:                                        uint8_t token) /**< token */
        -: 3351:{
        -: 3352:#if !JERRY_ESNEXT
        -: 3353:  JERRY_UNUSED (token);
        -: 3354:#endif /* !JERRY_ESNEXT */
        -: 3355:
        5: 3356:  uint16_t index = PARSER_INVALID_LITERAL_INDEX;
        5: 3357:  uint16_t opcode = context_p->stack_top_uint8;
        -: 3358:
        -: 3359:#if JERRY_ESNEXT
        5: 3360:  if (JERRY_UNLIKELY (opcode == CBC_EXT_OPCODE))
        -: 3361:  {
        4: 3362:    parser_stack_pop_uint8 (context_p);
        4: 3363:    JERRY_ASSERT (context_p->stack_top_uint8 == CBC_EXT_ASSIGN_SUPER
        -: 3364:                  || context_p->stack_top_uint8 == CBC_EXT_ASSIGN_PRIVATE);
        4: 3365:    opcode = PARSER_TO_EXT_OPCODE (context_p->stack_top_uint8);
        4: 3366:    parser_stack_pop_uint8 (context_p);
        -: 3367:  }
        -: 3368:  else
        -: 3369:#endif /* JERRY_ESNEXT */
        -: 3370:  {
        1: 3371:    parser_stack_pop_uint8 (context_p);
        -: 3372:
        1: 3373:    if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)
        -: 3374:    {
        1: 3375:      JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT || opcode == CBC_ASSIGN_PROP_LITERAL
        -: 3376:                    || opcode == CBC_ASSIGN_PROP_THIS_LITERAL || opcode == CBC_ASSIGN_LET_CONST
        -: 3377:                    || opcode == CBC_INIT_ARG_OR_CATCH || opcode == CBC_INIT_LET || opcode == CBC_INIT_CONST);
        -: 3378:
        1: 3379:      index = parser_stack_pop_uint16 (context_p);
        -: 3380:    }
        -: 3381:  }
        -: 3382:
        -: 3383:#if JERRY_ESNEXT
        5: 3384:  bool group_expr_assingment = false;
        -: 3385:
        5: 3386:  if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_GROUP_EXPR))
        -: 3387:  {
    #####: 3388:    group_expr_assingment = true;
    #####: 3389:    parser_stack_pop_uint8 (context_p);
        -: 3390:  }
        -: 3391:
        5: 3392:  if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))
        -: 3393:  {
    #####: 3394:    parser_stack_pop_uint8 (context_p);
    #####: 3395:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -: 3396:  }
        -: 3397:#endif /* JERRY_ESNEXT */
        -: 3398:
        5: 3399:  if (index == PARSER_INVALID_LITERAL_INDEX)
        -: 3400:  {
        -: 3401:#if JERRY_ESNEXT
        4: 3402:    if (JERRY_UNLIKELY (token == LEXER_ASSIGN_REFERENCE))
        -: 3403:    {
    #####: 3404:      opcode = CBC_ASSIGN_PUSH_RESULT;
        -: 3405:    }
        -: 3406:#endif /* JERRY_ESNEXT */
        -: 3407:
        4: 3408:    parser_emit_cbc (context_p, opcode);
        4: 3409:    return;
        -: 3410:  }
        -: 3411:
        -: 3412:#if JERRY_ESNEXT
        1: 3413:  if (!group_expr_assingment)
        -: 3414:  {
        1: 3415:    uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3416:
        1: 3417:    if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3418:    {
    #####: 3419:      uint16_t name_index = scanner_save_literal (context_p, index);
    #####: 3420:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3421:    }
        1: 3422:    else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3423:    {
    #####: 3424:      parser_set_function_name (context_p, function_literal_index, (uint16_t) index, 0);
        -: 3425:    }
        -: 3426:  }
        -: 3427:
        1: 3428:  if (JERRY_UNLIKELY (token == LEXER_ASSIGN_REFERENCE))
        -: 3429:  {
    #####: 3430:    parser_emit_cbc (context_p, CBC_ASSIGN_PUSH_RESULT);
    #####: 3431:    return;
        -: 3432:  }
        -: 3433:#endif /* JERRY_ESNEXT */
        -: 3434:
        1: 3435:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL && opcode == CBC_ASSIGN_SET_IDENT)
        -: 3436:  {
    #####: 3437:    JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -: 3438:
    #####: 3439:    context_p->last_cbc.value = index;
    #####: 3440:    context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;
    #####: 3441:    return;
        -: 3442:  }
        -: 3443:
        1: 3444:  parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -: 3445:
        1: 3446:  if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL && (context_p->stack_depth >= context_p->stack_limit))
        -: 3447:  {
        -: 3448:    /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */
        1: 3449:    JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -: 3450:
        1: 3451:    context_p->stack_limit++;
        -: 3452:
        1: 3453:    if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3454:    {
    #####: 3455:      parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3456:    }
        -: 3457:  }
        -: 3458:} /* parser_process_binary_opcodes */
        -: 3459:
        -: 3460:/**
        -: 3461: * Emit opcode for logical tokens.
        -: 3462: */
        -: 3463:static void
    #####: 3464:parser_process_logical_token (parser_context_t *context_p) /**< context */
        -: 3465:{
    #####: 3466:  parser_branch_t branch;
    #####: 3467:  parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####: 3468:  parser_set_branch_to_current_position (context_p, &branch);
    #####: 3469:} /* parser_process_logical_token */
        -: 3470:
        -: 3471:#if JERRY_ESNEXT
        -: 3472:/**
        -: 3473: * Emit opcode for logical assignment tokens.
        -: 3474: */
        -: 3475:static void
    #####: 3476:parser_process_logical_assignment_token (parser_context_t *context_p) /**< context */
        -: 3477:{
    #####: 3478:  parser_branch_t condition_branch;
    #####: 3479:  parser_stack_pop (context_p, &condition_branch, sizeof (parser_branch_t));
        -: 3480:
    #####: 3481:  uint8_t token = context_p->stack_top_uint8;
    #####: 3482:  JERRY_ASSERT (token == LEXER_ASSIGN_REFERENCE);
    #####: 3483:  parser_stack_pop_uint8 (context_p);
    #####: 3484:  parser_process_binary_assignment_token (context_p, token);
        -: 3485:
    #####: 3486:  parser_branch_t prop_reference_branch;
    #####: 3487:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &prop_reference_branch);
        -: 3488:
    #####: 3489:  parser_set_branch_to_current_position (context_p, &condition_branch);
    #####: 3490:  parser_emit_cbc_ext (context_p, CBC_EXT_POP_REFERENCE);
        -: 3491:
    #####: 3492:  JERRY_ASSERT (context_p->stack_limit - context_p->stack_depth >= 2);
    #####: 3493:  PARSER_PLUS_EQUAL_U16 (context_p->stack_depth, 2);
        -: 3494:
    #####: 3495:  parser_set_branch_to_current_position (context_p, &prop_reference_branch);
    #####: 3496:} /* parser_process_logical_assignment_token */
        -: 3497:
        -: 3498:#endif /* JERRY_ESNEXT */
        -: 3499:
        -: 3500:/**
        -: 3501: * Emit opcode for binary tokens.
        -: 3502: */
        -: 3503:static void
        1: 3504:parser_process_binary_token (parser_context_t *context_p, /**< context */
        -: 3505:                             uint8_t token) /**< token */
        -: 3506:{
        1: 3507:  uint16_t opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);
        -: 3508:
        1: 3509:  if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))
        -: 3510:  {
    #####: 3511:    lexer_convert_push_number_to_push_literal (context_p);
        -: 3512:  }
        -: 3513:
        1: 3514:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3515:  {
    #####: 3516:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));
    #####: 3517:    context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);
    #####: 3518:    return;
        -: 3519:  }
        -: 3520:
        1: 3521:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3522:  {
        1: 3523:    JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS, CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        1: 3524:    context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);
        1: 3525:    return;
        -: 3526:  }
        -: 3527:
    #####: 3528:  parser_emit_cbc (context_p, opcode);
        -: 3529:} /* parser_process_binary_token */
        -: 3530:
        -: 3531:/**
        -: 3532: * Emit opcode for binary lvalue tokens.
        -: 3533: */
        -: 3534:static void
    #####: 3535:parser_process_binary_lvalue_token (parser_context_t *context_p, /**< context */
        -: 3536:                                    uint8_t token) /**< token */
        -: 3537:{
    #####: 3538:  parser_stack_push_uint8 (context_p, CBC_ASSIGN);
    #####: 3539:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 3540:  parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));
    #####: 3541:} /* parser_process_binary_lvalue_token */
        -: 3542:
        -: 3543:/**
        -: 3544: * Emit opcode for binary computations.
        -: 3545: */
        -: 3546:static void
       68: 3547:parser_process_binary_opcodes (parser_context_t *context_p, /**< context */
        -: 3548:                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */
        -: 3549:{
        -: 3550:  while (true)
        6: 3551:  {
       68: 3552:    uint8_t token = context_p->stack_top_uint8;
        -: 3553:
        -: 3554:    /* For left-to-right operators (all binary operators except assignment
        -: 3555:     * and logical operators), the byte code is flushed if the precedence
        -: 3556:     * of the next operator is less or equal than the current operator. For
        -: 3557:     * assignment and logical operators, we add 1 to the min precendence to
        -: 3558:     * force right-to-left evaluation order. */
        -: 3559:
       68: 3560:    if (!LEXER_IS_BINARY_OP_TOKEN (token)
        6: 3561:        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)
        -: 3562:    {
      124: 3563:      return;
        -: 3564:    }
        -: 3565:
        6: 3566:    parser_push_result (context_p);
        6: 3567:    parser_stack_pop_uint8 (context_p);
        -: 3568:
        6: 3569:    switch (token)
        -: 3570:    {
        5: 3571:      case LEXER_ASSIGN:
        -: 3572:      {
        5: 3573:        parser_process_binary_assignment_token (context_p, token);
        5: 3574:        continue;
        -: 3575:      }
        -: 3576:        /* Binary lvalue-opcodes */
    #####: 3577:      case LEXER_ASSIGN_ADD:
        -: 3578:      case LEXER_ASSIGN_SUBTRACT:
        -: 3579:      case LEXER_ASSIGN_MULTIPLY:
        -: 3580:      case LEXER_ASSIGN_DIVIDE:
        -: 3581:      case LEXER_ASSIGN_MODULO:
        -: 3582:#if JERRY_ESNEXT
        -: 3583:      case LEXER_ASSIGN_EXPONENTIATION:
        -: 3584:#endif /* JERRY_ESNEXT */
        -: 3585:      case LEXER_ASSIGN_LEFT_SHIFT:
        -: 3586:      case LEXER_ASSIGN_RIGHT_SHIFT:
        -: 3587:      case LEXER_ASSIGN_UNS_RIGHT_SHIFT:
        -: 3588:      case LEXER_ASSIGN_BIT_AND:
        -: 3589:      case LEXER_ASSIGN_BIT_OR:
        -: 3590:      case LEXER_ASSIGN_BIT_XOR:
        -: 3591:      {
    #####: 3592:        parser_process_binary_lvalue_token (context_p, token);
    #####: 3593:        continue;
        -: 3594:      }
        -: 3595:#if JERRY_ESNEXT
    #####: 3596:      case LEXER_ASSIGN_NULLISH_COALESCING:
        -: 3597:      case LEXER_ASSIGN_LOGICAL_OR:
        -: 3598:      case LEXER_ASSIGN_LOGICAL_AND:
        -: 3599:      {
    #####: 3600:        parser_process_logical_assignment_token (context_p);
    #####: 3601:        continue;
        -: 3602:      }
    #####: 3603:      case LEXER_NULLISH_COALESCING:
        -: 3604:#endif /* JERRY_ESNEXT */
    #####: 3605:      case LEXER_LOGICAL_OR:
        -: 3606:      case LEXER_LOGICAL_AND:
        -: 3607:      {
    #####: 3608:        parser_process_logical_token (context_p);
    #####: 3609:        continue;
        -: 3610:      }
        -: 3611:#if JERRY_ESNEXT
    #####: 3612:      case LEXER_KEYW_IN:
        -: 3613:      {
    #####: 3614:        if (context_p->stack_top_uint8 == LEXER_PRIVATE_PRIMARY_EXPR)
        -: 3615:        {
    #####: 3616:          parser_stack_pop_uint8 (context_p);
    #####: 3617:          uint16_t lit_id = parser_stack_pop_uint16 (context_p);
    #####: 3618:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_PRIVATE_PROP_LITERAL_IN, lit_id);
    #####: 3619:          continue;
        -: 3620:        }
        -: 3621:
        -: 3622:        /* FALLTHRU */
        -: 3623:      }
        -: 3624:#endif /* JERRY_ESNEXT */
    #####: 3625:      default:
        -: 3626:      {
        1: 3627:        parser_process_binary_token (context_p, token);
        1: 3628:        continue;
        -: 3629:      }
        -: 3630:    }
        -: 3631:  }
        -: 3632:} /* parser_process_binary_opcodes */
        -: 3633:
        -: 3634:#if JERRY_ESNEXT
        -: 3635:/**
        -: 3636: * End position marker of a pattern.
        -: 3637: */
        -: 3638:typedef struct
        -: 3639:{
        -: 3640:  scanner_location_t location; /**< end position of the pattern */
        -: 3641:  lexer_token_t token; /**< token at the end position */
        -: 3642:} parser_pattern_end_marker_t;
        -: 3643:
        -: 3644:/**
        -: 3645: * Literal index should not be emitted while processing rhs target value
        -: 3646: */
        -: 3647:#define PARSER_PATTERN_RHS_NO_LIT PARSER_INVALID_LITERAL_INDEX
        -: 3648:
        -: 3649:/**
        -: 3650: * Process the target of an initializer pattern.
        -: 3651: */
        -: 3652:static parser_pattern_end_marker_t
    #####: 3653:parser_pattern_get_target (parser_context_t *context_p, /**< context */
        -: 3654:                           parser_pattern_flags_t flags) /**< flags */
        -: 3655:{
    #####: 3656:  parser_pattern_end_marker_t end_marker;
    #####: 3657:  end_marker.token.type = LEXER_INVALID_PATTERN;
    #####: 3658:  parser_branch_t skip_init;
        -: 3659:
    #####: 3660:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3661:  {
    #####: 3662:    JERRY_ASSERT (flags & PARSER_PATTERN_TARGET_ON_STACK);
        -: 3663:
    #####: 3664:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3665:  }
        -: 3666:
    #####: 3667:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3668:  {
    #####: 3669:    scanner_location_t start_location;
        -: 3670:
    #####: 3671:    if (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3672:        || context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED || (flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3673:    {
        -: 3674:      /* Found invalid pattern, push null value to fake the rhs target. */
    #####: 3675:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
        -: 3676:    }
        -: 3677:    else
        -: 3678:    {
    #####: 3679:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
    #####: 3680:      scanner_get_location (&start_location, context_p);
        -: 3681:
    #####: 3682:      scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 3683:      scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 3684:      scanner_seek (context_p);
    #####: 3685:      lexer_next_token (context_p);
        -: 3686:
    #####: 3687:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 3688:      scanner_get_location (&(end_marker.location), context_p);
    #####: 3689:      end_marker.token = context_p->token;
        -: 3690:
    #####: 3691:      scanner_set_location (context_p, &start_location);
    #####: 3692:      scanner_seek (context_p);
    #####: 3693:      parser_flush_cbc (context_p);
        -: 3694:    }
        -: 3695:  }
        -: 3696:
    #####: 3697:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 3698:  {
    #####: 3699:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3700:  }
        -: 3701:
    #####: 3702:  return end_marker;
        -: 3703:} /* parser_pattern_get_target */
        -: 3704:
        -: 3705:/**
        -: 3706: * Finalize an assignment/binding pattern.
        -: 3707: */
        -: 3708:static void
    #####: 3709:parser_pattern_finalize (parser_context_t *context_p, /**< context */
        -: 3710:                         parser_pattern_flags_t flags, /**< flags */
        -: 3711:                         parser_pattern_end_marker_t *end_marker_p) /**< pattern end position  */
        -: 3712:{
    #####: 3713:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 3714:  {
    #####: 3715:    if (end_marker_p->token.type == LEXER_INVALID_PATTERN)
        -: 3716:    {
    #####: 3717:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3718:    }
        -: 3719:
    #####: 3720:    scanner_set_location (context_p, &(end_marker_p->location));
    #####: 3721:    context_p->token = end_marker_p->token;
        -: 3722:  }
        -: 3723:  else
        -: 3724:  {
    #####: 3725:    JERRY_ASSERT (!(flags & PARSER_PATTERN_TARGET_DEFAULT));
    #####: 3726:    lexer_next_token (context_p);
        -: 3727:  }
        -: 3728:
    #####: 3729:  if ((flags & (PARSER_PATTERN_BINDING | PARSER_PATTERN_NESTED_PATTERN)) == PARSER_PATTERN_BINDING)
        -: 3730:  {
        -: 3731:    /* Pop the result of the expression. */
    #####: 3732:    parser_emit_cbc (context_p, CBC_POP);
        -: 3733:  }
        -: 3734:
    #####: 3735:  parser_flush_cbc (context_p);
    #####: 3736:} /* parser_pattern_finalize */
        -: 3737:
        -: 3738:/**
        -: 3739: * Emit right-hand-side target value.
        -: 3740: */
        -: 3741:static void
    #####: 3742:parser_pattern_emit_rhs (parser_context_t *context_p, /**< context */
        -: 3743:                         uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3744:                         uint16_t literal_index) /**< literal index for object pattern */
        -: 3745:{
    #####: 3746:  if (literal_index != PARSER_PATTERN_RHS_NO_LIT)
        -: 3747:  {
    #####: 3748:    parser_emit_cbc_ext_literal (context_p, rhs_opcode, literal_index);
        -: 3749:  }
        -: 3750:  else
        -: 3751:  {
    #####: 3752:    parser_emit_cbc_ext (context_p, rhs_opcode);
        -: 3753:  }
    #####: 3754:} /* parser_pattern_emit_rhs */
        -: 3755:
        -: 3756:/**
        -: 3757: * Form an assignment from a pattern.
        -: 3758: */
        -: 3759:static void
    #####: 3760:parser_pattern_form_assignment (parser_context_t *context_p, /**< context */
        -: 3761:                                parser_pattern_flags_t flags, /**< flags */
        -: 3762:                                uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3763:                                uint16_t literal_index, /**< literal index for object pattern */
        -: 3764:                                parser_line_counter_t ident_line_counter) /**< identifier line counter */
        -: 3765:{
        -: 3766:  JERRY_UNUSED (ident_line_counter);
        -: 3767:
    #####: 3768:  uint16_t name_index = PARSER_INVALID_LITERAL_INDEX;
        -: 3769:
    #####: 3770:  if ((flags & PARSER_PATTERN_BINDING)
    #####: 3771:      || (context_p->last_cbc_opcode == CBC_PUSH_LITERAL && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL))
        -: 3772:  {
    #####: 3773:    name_index = context_p->lit_object.index;
        -: 3774:  }
        -: 3775:
    #####: 3776:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
    #####: 3777:  parser_append_binary_single_assignment_token (context_p, flags);
    #####: 3778:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3779:
    #####: 3780:  if (context_p->token.type == LEXER_ASSIGN && !(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3781:  {
    #####: 3782:    parser_branch_t skip_init;
    #####: 3783:    lexer_next_token (context_p);
    #####: 3784:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 3785:
    #####: 3786:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 3787:
    #####: 3788:    if (name_index != PARSER_INVALID_LITERAL_INDEX)
        -: 3789:    {
    #####: 3790:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3791:
    #####: 3792:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3793:      {
    #####: 3794:        name_index = scanner_save_literal (context_p, name_index);
    #####: 3795:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -: 3796:      }
    #####: 3797:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3798:      {
    #####: 3799:        parser_set_function_name (context_p, function_literal_index, name_index, 0);
        -: 3800:      }
        -: 3801:    }
    #####: 3802:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 3803:  }
        -: 3804:
    #####: 3805:  parser_process_binary_opcodes (context_p, 0);
        -: 3806:
    #####: 3807:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
    #####: 3808:  parser_stack_pop_uint8 (context_p);
        -: 3809:
        -: 3810:#if JERRY_DEBUGGER
        -: 3811:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3812:      && ident_line_counter != context_p->last_breakpoint_line)
        -: 3813:  {
        -: 3814:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 3815:    parser_flush_cbc (context_p);
        -: 3816:
        -: 3817:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -: 3818:
        -: 3819:    context_p->last_breakpoint_line = ident_line_counter;
        -: 3820:  }
        -: 3821:#endif /* JERRY_DEBUGGER */
    #####: 3822:} /* parser_pattern_form_assignment */
        -: 3823:
        -: 3824:/**
        -: 3825: * Parse pattern inside a pattern.
        -: 3826: */
        -: 3827:static void
    #####: 3828:parser_pattern_process_nested_pattern (parser_context_t *context_p, /**< context */
        -: 3829:                                       parser_pattern_flags_t flags, /**< flags */
        -: 3830:                                       uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3831:                                       uint16_t literal_index) /**< literal index for object pattern */
        -: 3832:{
    #####: 3833:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE);
        -: 3834:
    #####: 3835:  parser_pattern_flags_t options = (PARSER_PATTERN_NESTED_PATTERN | PARSER_PATTERN_TARGET_ON_STACK
        -: 3836:                                    | (flags
    #####: 3837:                                       & (PARSER_PATTERN_BINDING | PARSER_PATTERN_LET | PARSER_PATTERN_CONST
        -: 3838:                                          | PARSER_PATTERN_LOCAL | PARSER_PATTERN_ARGUMENTS)));
        -: 3839:
    #####: 3840:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 3841:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 3842:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 3843:
    #####: 3844:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3845:  {
    #####: 3846:    if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 3847:    {
    #####: 3848:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3849:      {
    #####: 3850:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3851:      }
        -: 3852:
    #####: 3853:      if (!(flags & PARSER_PATTERN_REST_ELEMENT))
        -: 3854:      {
    #####: 3855:        options |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 3856:      }
        -: 3857:      else
        -: 3858:      {
    #####: 3859:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 3860:      }
        -: 3861:    }
        -: 3862:    else
        -: 3863:    {
    #####: 3864:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 3865:      {
    #####: 3866:        options |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 3867:      }
    #####: 3868:      scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3869:    }
        -: 3870:  }
        -: 3871:
    #####: 3872:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 3873:
    #####: 3874:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 3875:  {
    #####: 3876:    parser_parse_object_initializer (context_p, options);
        -: 3877:  }
        -: 3878:  else
        -: 3879:  {
    #####: 3880:    parser_parse_array_initializer (context_p, options);
        -: 3881:  }
        -: 3882:
    #####: 3883:  parser_emit_cbc (context_p, CBC_POP);
    #####: 3884:} /* parser_pattern_process_nested_pattern */
        -: 3885:
        -: 3886:/**
        -: 3887: * Process the current {Binding, Assignment}Property
        -: 3888: *
        -: 3889: * @return true, if a nested pattern is processed, false otherwise
        -: 3890: */
        -: 3891:static bool
    #####: 3892:parser_pattern_process_assignment (parser_context_t *context_p, /**< context */
        -: 3893:                                   parser_pattern_flags_t flags, /**< flags */
        -: 3894:                                   uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 3895:                                   uint16_t literal_index, /**< literal index for object pattern */
        -: 3896:                                   lexer_token_type_t end_type) /**< end type token */
        -: 3897:{
    #####: 3898:  if ((context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE)
    #####: 3899:      && (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 3900:          || !(context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_NO_DESTRUCTURING)))
        -: 3901:  {
    #####: 3902:    parser_pattern_process_nested_pattern (context_p, flags, rhs_opcode, literal_index);
    #####: 3903:    return true;
        -: 3904:  }
        -: 3905:
    #####: 3906:  parser_line_counter_t ident_line_counter = context_p->token.line;
        -: 3907:#if JERRY_LINE_INFO
    #####: 3908:  parser_line_counter_t ident_column_counter = context_p->token.column;
        -: 3909:#endif /* JERRY_LINE_INFO */
        -: 3910:
    #####: 3911:  if (flags & PARSER_PATTERN_BINDING)
        -: 3912:  {
    #####: 3913:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3914:    {
    #####: 3915:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 3916:    }
        -: 3917:
    #####: 3918:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 3919:
    #####: 3920:    if (flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST) && context_p->token.keyword_type == LEXER_KEYW_LET)
        -: 3921:    {
    #####: 3922:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 3923:    }
        -: 3924:
    #####: 3925:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3926:    {
    #####: 3927:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 3928:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3929:    }
        -: 3930:
    #####: 3931:    if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 3932:    {
    #####: 3933:      if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 3934:      {
    #####: 3935:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3936:      }
    #####: 3937:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 3938:    }
        -: 3939:#if JERRY_MODULE_SYSTEM
    #####: 3940:    parser_module_append_export_name (context_p);
        -: 3941:#endif /* JERRY_MODULE_SYSTEM */
        -: 3942:
    #####: 3943:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 3944:    lexer_next_token (context_p);
        -: 3945:
    #####: 3946:    if (context_p->token.type != end_type && context_p->token.type != LEXER_ASSIGN
    #####: 3947:        && context_p->token.type != LEXER_COMMA)
        -: 3948:    {
    #####: 3949:      parser_raise_error (context_p, PARSER_ERR_ILLEGAL_PROPERTY_IN_DECLARATION);
        -: 3950:    }
        -: 3951:  }
        -: 3952:  else
        -: 3953:  {
    #####: 3954:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_LEFT_HAND_SIDE);
        -: 3955:
    #####: 3956:    if (!PARSER_IS_PUSH_LITERAL (context_p->last_cbc_opcode) && !PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 3957:    {
    #####: 3958:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3959:    }
        -: 3960:  }
        -: 3961:
    #####: 3962:  parser_pattern_form_assignment (context_p, flags, rhs_opcode, literal_index, ident_line_counter);
        -: 3963:#if JERRY_LINE_INFO
    #####: 3964:  parser_line_info_append (context_p, ident_line_counter, ident_column_counter);
        -: 3965:#endif /* JERRY_LINE_INFO */
    #####: 3966:  return false;
        -: 3967:} /* parser_pattern_process_assignment */
        -: 3968:
        -: 3969:/**
        -: 3970: * Parse array initializer.
        -: 3971: */
        -: 3972:static void
    #####: 3973:parser_parse_array_initializer (parser_context_t *context_p, /**< context */
        -: 3974:                                parser_pattern_flags_t flags) /**< flags */
        -: 3975:{
    #####: 3976:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 3977:
    #####: 3978:  lexer_next_token (context_p);
    #####: 3979:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_CREATE);
        -: 3980:
    #####: 3981:  while (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 3982:  {
    #####: 3983:    uint16_t rhs_opcode = CBC_EXT_ITERATOR_STEP;
        -: 3984:
    #####: 3985:    if (context_p->token.type == LEXER_COMMA)
        -: 3986:    {
    #####: 3987:      parser_emit_cbc_ext (context_p, rhs_opcode);
    #####: 3988:      parser_emit_cbc (context_p, CBC_POP);
    #####: 3989:      lexer_next_token (context_p);
    #####: 3990:      continue;
        -: 3991:    }
        -: 3992:
    #####: 3993:    parser_pattern_flags_t options = flags;
        -: 3994:
    #####: 3995:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 3996:    {
    #####: 3997:      lexer_next_token (context_p);
    #####: 3998:      rhs_opcode = CBC_EXT_REST_INITIALIZER;
    #####: 3999:      options |= PARSER_PATTERN_REST_ELEMENT;
        -: 4000:    }
        -: 4001:
    #####: 4002:    parser_pattern_process_assignment (context_p, options, rhs_opcode, PARSER_PATTERN_RHS_NO_LIT, LEXER_RIGHT_SQUARE);
        -: 4003:
    #####: 4004:    if (context_p->token.type == LEXER_COMMA && rhs_opcode != CBC_EXT_REST_INITIALIZER)
        -: 4005:    {
    #####: 4006:      lexer_next_token (context_p);
        -: 4007:    }
    #####: 4008:    else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 4009:    {
    #####: 4010:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 4011:    }
        -: 4012:  }
        -: 4013:
        -: 4014:  /* close the iterator */
    #####: 4015:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CONTEXT_END);
        -: 4016:
    #####: 4017:  parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 4018:} /* parser_parse_array_initializer */
        -: 4019:
        -: 4020:/**
        -: 4021: * Parse object initializer.
        -: 4022: */
        -: 4023:static void
    #####: 4024:parser_parse_object_initializer (parser_context_t *context_p, /**< context */
        -: 4025:                                 parser_pattern_flags_t flags) /**< flags */
        -: 4026:{
    #####: 4027:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 4028:
        -: 4029:  /* 12.14.5.2:  ObjectAssignmentPattern : { } */
    #####: 4030:  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))
        -: 4031:  {
    #####: 4032:    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);
    #####: 4033:    lexer_consume_next_character (context_p);
    #####: 4034:    parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 4035:    return;
        -: 4036:  }
        -: 4037:
    #####: 4038:  cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;
        -: 4039:
    #####: 4040:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4041:  {
    #####: 4042:    context_opcode = CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE;
        -: 4043:  }
        -: 4044:
    #####: 4045:  parser_emit_cbc_ext (context_p, context_opcode);
        -: 4046:
        -: 4047:  while (true)
    #####: 4048:  {
    #####: 4049:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);
        -: 4050:
    #####: 4051:    uint16_t prop_index = context_p->lit_object.index;
    #####: 4052:    parser_line_counter_t start_line = context_p->token.line;
    #####: 4053:    parser_line_counter_t start_column = context_p->token.column;
    #####: 4054:    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;
        -: 4055:
    #####: 4056:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 4057:    {
    #####: 4058:      break;
        -: 4059:    }
        -: 4060:
    #####: 4061:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 4062:    {
    #####: 4063:      lexer_next_token (context_p);
        -: 4064:
    #####: 4065:      flags |= PARSER_PATTERN_REST_ELEMENT;
        -: 4066:
    #####: 4067:      if (parser_pattern_process_assignment (context_p,
        -: 4068:                                             flags,
        -: 4069:                                             CBC_EXT_OBJ_INIT_PUSH_REST,
        -: 4070:                                             PARSER_PATTERN_RHS_NO_LIT,
        -: 4071:                                             LEXER_RIGHT_BRACE))
        -: 4072:      {
    #####: 4073:        parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);
        -: 4074:      }
        -: 4075:
    #####: 4076:      if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 4077:      {
    #####: 4078:        parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 4079:      }
        -: 4080:
        -: 4081:      /* Checked at the end because there might be syntax errors before. */
    #####: 4082:      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);
    #####: 4083:      break;
        -: 4084:    }
        -: 4085:
    #####: 4086:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -: 4087:    {
    #####: 4088:      prop_index = PARSER_PATTERN_RHS_NO_LIT;
    #####: 4089:      push_prop_opcode =
    #####: 4090:        ((flags & PARSER_PATTERN_HAS_REST_ELEMENT) ? CBC_EXT_INITIALIZER_PUSH_NAME : CBC_EXT_INITIALIZER_PUSH_PROP);
        -: 4091:    }
    #####: 4092:    else if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4093:    {
    #####: 4094:      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_NAME_LITERAL;
        -: 4095:    }
        -: 4096:
    #####: 4097:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 4098:    {
    #####: 4099:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 4100:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 4101:    }
        -: 4102:
    #####: 4103:    lexer_next_token (context_p);
        -: 4104:
    #####: 4105:    if (context_p->token.type == LEXER_COLON)
        -: 4106:    {
    #####: 4107:      lexer_next_token (context_p);
    #####: 4108:      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);
        -: 4109:    }
        -: 4110:    else
        -: 4111:    {
    #####: 4112:      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_NAME || push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 4113:      {
    #####: 4114:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 4115:      }
        -: 4116:
    #####: 4117:      if (context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_ASSIGN
    #####: 4118:          && context_p->token.type != LEXER_COMMA)
        -: 4119:      {
    #####: 4120:        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 4121:      }
        -: 4122:
    #####: 4123:      parser_reparse_as_common_identifier (context_p, start_line, start_column);
        -: 4124:
    #####: 4125:      if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 4126:      {
    #####: 4127:        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 4128:        {
    #####: 4129:          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 4130:        }
    #####: 4131:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 4132:      }
        -: 4133:
        -: 4134:#if JERRY_MODULE_SYSTEM
    #####: 4135:      parser_module_append_export_name (context_p);
        -: 4136:#endif /* JERRY_MODULE_SYSTEM */
        -: 4137:
    #####: 4138:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 4139:
    #####: 4140:      lexer_next_token (context_p);
    #####: 4141:      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_ASSIGN
        -: 4142:                    || context_p->token.type == LEXER_COMMA);
        -: 4143:
    #####: 4144:      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);
        -: 4145:#if JERRY_LINE_INFO
    #####: 4146:      parser_line_info_append (context_p, start_line, start_column);
        -: 4147:#endif /* JERRY_LINE_INFO */
        -: 4148:    }
        -: 4149:
    #####: 4150:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 4151:    {
    #####: 4152:      break;
        -: 4153:    }
    #####: 4154:    else if (context_p->token.type != LEXER_COMMA)
        -: 4155:    {
    #####: 4156:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 4157:    }
        -: 4158:  }
        -: 4159:
    #####: 4160:  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)
        -: 4161:  {
    #####: 4162:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth,
        -: 4163:                            (PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION - PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION));
        -: 4164:  }
        -: 4165:
    #####: 4166:  parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);
        -: 4167:
    #####: 4168:  parser_pattern_finalize (context_p, flags, &end_pos);
        -: 4169:} /* parser_parse_object_initializer */
        -: 4170:
        -: 4171:/**
        -: 4172: * Parse an initializer.
        -: 4173: */
        -: 4174:void
    #####: 4175:parser_parse_initializer (parser_context_t *context_p, /**< context */
        -: 4176:                          parser_pattern_flags_t flags) /**< flags */
        -: 4177:{
    #####: 4178:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 4179:  {
    #####: 4180:    parser_parse_object_initializer (context_p, flags);
        -: 4181:  }
        -: 4182:  else
        -: 4183:  {
    #####: 4184:    JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
    #####: 4185:    parser_parse_array_initializer (context_p, flags);
        -: 4186:  }
    #####: 4187:} /* parser_parse_initializer */
        -: 4188:
        -: 4189:/**
        -: 4190: * Parse an initializer using the next character.
        -: 4191: */
        -: 4192:void
    #####: 4193:parser_parse_initializer_by_next_char (parser_context_t *context_p, /**< context */
        -: 4194:                                       parser_pattern_flags_t flags) /**< flags */
        -: 4195:{
    #####: 4196:  JERRY_ASSERT (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE));
        -: 4197:
    #####: 4198:  if (lexer_consume_next_character (context_p) == LIT_CHAR_LEFT_BRACE)
        -: 4199:  {
    #####: 4200:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 4201:    {
    #####: 4202:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER
        -: 4203:                    || context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
        -: 4204:
    #####: 4205:      if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 4206:      {
    #####: 4207:        flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 4208:      }
        -: 4209:
    #####: 4210:      if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 4211:      {
    #####: 4212:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 4213:      }
        -: 4214:    }
        -: 4215:
    #####: 4216:    parser_parse_object_initializer (context_p, flags);
        -: 4217:  }
        -: 4218:  else
        -: 4219:  {
    #####: 4220:    parser_parse_array_initializer (context_p, flags);
        -: 4221:  }
    #####: 4222:} /* parser_parse_initializer_by_next_char */
        -: 4223:
        -: 4224:#endif /* JERRY_ESNEXT */
        -: 4225:
        -: 4226:/**
        -: 4227: * Process ternary expression.
        -: 4228: */
        -: 4229:static void
    #####: 4230:parser_process_ternary_expression (parser_context_t *context_p) /**< context */
        -: 4231:{
    #####: 4232:  JERRY_ASSERT (context_p->token.type == LEXER_QUESTION_MARK);
        -: 4233:
    #####: 4234:  cbc_opcode_t opcode = CBC_BRANCH_IF_FALSE_FORWARD;
    #####: 4235:  parser_branch_t cond_branch;
    #####: 4236:  parser_branch_t uncond_branch;
        -: 4237:
    #####: 4238:  parser_push_result (context_p);
        -: 4239:
    #####: 4240:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 4241:  {
    #####: 4242:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 4243:    opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 4244:  }
        -: 4245:
    #####: 4246:  parser_emit_cbc_forward_branch (context_p, (uint16_t) opcode, &cond_branch);
        -: 4247:
    #####: 4248:  lexer_next_token (context_p);
    #####: 4249:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 4250:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &uncond_branch);
    #####: 4251:  parser_set_branch_to_current_position (context_p, &cond_branch);
        -: 4252:
        -: 4253:  /* Although byte code is constructed for two branches,
        -: 4254:   * only one of them will be executed. To reflect this
        -: 4255:   * the stack is manually adjusted. */
    #####: 4256:  JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 4257:  context_p->stack_depth--;
        -: 4258:
    #####: 4259:  if (context_p->token.type != LEXER_COLON)
        -: 4260:  {
    #####: 4261:    parser_raise_error (context_p, PARSER_ERR_COLON_FOR_CONDITIONAL_EXPECTED);
        -: 4262:  }
        -: 4263:
    #####: 4264:  lexer_next_token (context_p);
        -: 4265:
    #####: 4266:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 4267:  parser_set_branch_to_current_position (context_p, &uncond_branch);
        -: 4268:
        -: 4269:  /* Last opcode rewrite is not allowed because
        -: 4270:   * the result may come from the first branch. */
    #####: 4271:  parser_flush_cbc (context_p);
        -: 4272:
    #####: 4273:  parser_process_binary_opcodes (context_p, 0);
    #####: 4274:} /* parser_process_ternary_expression */
        -: 4275:
        -: 4276:/**
        -: 4277: * Process expression sequence.
        -: 4278: */
        -: 4279:static void
    #####: 4280:parser_process_expression_sequence (parser_context_t *context_p) /**< context */
        -: 4281:{
    #####: 4282:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4283:  {
    #####: 4284:    parser_emit_cbc (context_p, CBC_POP);
        -: 4285:  }
        -: 4286:
    #####: 4287:  if (context_p->stack_top_uint8 == LEXER_LEFT_PAREN)
        -: 4288:  {
    #####: 4289:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -: 4290:
    #####: 4291:    JERRY_ASSERT (page_p != NULL);
        -: 4292:
    #####: 4293:    page_p->bytes[context_p->stack.last_position - 1] = LEXER_COMMA_SEP_LIST;
    #####: 4294:    context_p->stack_top_uint8 = LEXER_COMMA_SEP_LIST;
        -: 4295:  }
        -: 4296:
    #####: 4297:  lexer_next_token (context_p);
    #####: 4298:} /* parser_process_expression_sequence */
        -: 4299:
        -: 4300:/**
        -: 4301: * Process group expression.
        -: 4302: */
        -: 4303:static void
        4: 4304:parser_process_group_expression (parser_context_t *context_p, /**< context */
        -: 4305:                                 size_t *grouping_level_p) /**< grouping level */
        -: 4306:{
        4: 4307:  JERRY_ASSERT (*grouping_level_p >= PARSER_GROUPING_LEVEL_INCREASE);
        4: 4308:  (*grouping_level_p) -= PARSER_GROUPING_LEVEL_INCREASE;
        -: 4309:
        4: 4310:  uint8_t token = context_p->stack_top_uint8;
        -: 4311:
        4: 4312:  if (token == LEXER_COMMA_SEP_LIST)
        -: 4313:  {
    #####: 4314:    parser_push_result (context_p);
    #####: 4315:    parser_flush_cbc (context_p);
        -: 4316:  }
        -: 4317:
        4: 4318:  parser_stack_pop_uint8 (context_p);
        4: 4319:  lexer_next_token (context_p);
        -: 4320:
        -: 4321:#if JERRY_ESNEXT
        -: 4322:  /* Lookahead for anonymous function declaration after '=' token when the assignment base is LHS expression
        -: 4323:     with a single indentifier in it. e.g.: (a) = function () {} */
        4: 4324:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_ASSIGN
        -: 4325:                      && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        -: 4326:                      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL
        -: 4327:                      && parser_is_assignment_expr (context_p) && *grouping_level_p != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 4328:  {
    #####: 4329:    parser_stack_push_uint8 (context_p, LEXER_ASSIGN_GROUP_EXPR);
        -: 4330:  }
        -: 4331:#endif /* JERRY_ESNEXT */
        4: 4332:} /* parser_process_group_expression */
        -: 4333:
        -: 4334:/**
        -: 4335: * Parse block expression.
        -: 4336: */
        -: 4337:void
        1: 4338:parser_parse_block_expression (parser_context_t *context_p, /**< context */
        -: 4339:                               int options) /**< option flags */
        -: 4340:{
        1: 4341:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 4342:
        1: 4343:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4344:  {
        1: 4345:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));
        1: 4346:    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);
        1: 4347:    parser_flush_cbc (context_p);
        -: 4348:  }
        -: 4349:  else
        -: 4350:  {
    #####: 4351:    parser_emit_cbc (context_p, CBC_POP_BLOCK);
        -: 4352:  }
        1: 4353:} /* parser_parse_block_expression */
        -: 4354:
        -: 4355:/**
        -: 4356: * Parse expression statement.
        -: 4357: */
        -: 4358:void
       28: 4359:parser_parse_expression_statement (parser_context_t *context_p, /**< context */
        -: 4360:                                   int options) /**< option flags */
        -: 4361:{
       28: 4362:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 4363:
       28: 4364:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 4365:  {
       10: 4366:    parser_emit_cbc (context_p, CBC_POP);
        -: 4367:  }
       28: 4368:} /* parser_parse_expression_statement */
        -: 4369:
        -: 4370:JERRY_STATIC_ASSERT (PARSE_EXPR_LEFT_HAND_SIDE == 0x1, value_of_parse_expr_left_hand_side_must_be_1);
        -: 4371:
        -: 4372:/**
        -: 4373: * Parse expression.
        -: 4374: */
        -: 4375:void
       60: 4376:parser_parse_expression (parser_context_t *context_p, /**< context */
        -: 4377:                         int options) /**< option flags */
        -: 4378:{
       60: 4379:  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);
        -: 4380:
       60: 4381:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
        -: 4382:
       60: 4383:  if (options & PARSE_EXPR_HAS_LITERAL)
        -: 4384:  {
    #####: 4385:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 4386:    goto process_unary_expression;
        -: 4387:  }
        -: 4388:
        -: 4389:  while (true)
        -: 4390:  {
       72: 4391:    if (parser_parse_unary_expression (context_p, &grouping_level))
        -: 4392:    {
    #####: 4393:      parser_process_binary_opcodes (context_p, 0);
    #####: 4394:      break;
        -: 4395:    }
        -: 4396:
        -: 4397:    while (true)
        -: 4398:    {
       70: 4399:process_unary_expression:
       70: 4400:      parser_process_unary_expression (context_p, grouping_level);
        -: 4401:
       70: 4402:      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 4403:      {
       62: 4404:        uint8_t min_prec_treshold = 0;
        -: 4405:
       62: 4406:        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4407:        {
        -: 4408:#if JERRY_ESNEXT
        6: 4409:          if (JERRY_UNLIKELY (context_p->token.type == LEXER_NULLISH_COALESCING))
        -: 4410:          {
    #####: 4411:            parser_check_invalid_logical_op (context_p, LEXER_LOGICAL_OR, LEXER_LOGICAL_AND);
        -: 4412:          }
        -: 4413:#endif /* JERRY_ESNEXT */
        -: 4414:
        6: 4415:          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];
        -: 4416:
        -: 4417:#if JERRY_ESNEXT
        -: 4418:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */
        6: 4419:          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)
        6: 4420:              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
        5: 4421:                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))
        -: 4422:          {
        -: 4423:            /* Right-to-left evaluation order. */
        5: 4424:            min_prec_treshold++;
        -: 4425:          }
        -: 4426:#else /* !JERRY_ESNEXT */
        -: 4427:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */
    #####: 4428:          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
    #####: 4429:              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)
        -: 4430:          {
        -: 4431:            /* Right-to-left evaluation order. */
    #####: 4432:            min_prec_treshold++;
        -: 4433:          }
        -: 4434:#endif /* JERRY_ESNEXT */
        -: 4435:        }
        -: 4436:
       62: 4437:        parser_process_binary_opcodes (context_p, min_prec_treshold);
        -: 4438:      }
       70: 4439:      if (context_p->token.type == LEXER_RIGHT_PAREN
       19: 4440:          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))
        -: 4441:      {
        4: 4442:        parser_process_group_expression (context_p, &grouping_level);
        4: 4443:        continue;
        -: 4444:      }
        -: 4445:
       66: 4446:      break;
        -: 4447:    }
        -: 4448:
       66: 4449:    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)
        -: 4450:    {
        8: 4451:      break;
        -: 4452:    }
        -: 4453:
       58: 4454:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK))
        -: 4455:    {
    #####: 4456:      parser_process_ternary_expression (context_p);
        -: 4457:
    #####: 4458:      if (context_p->token.type == LEXER_RIGHT_PAREN)
        -: 4459:      {
    #####: 4460:        goto process_unary_expression;
        -: 4461:      }
        -: 4462:    }
       58: 4463:    else if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 4464:    {
        6: 4465:      parser_append_binary_token (context_p);
        6: 4466:      lexer_next_token (context_p);
        6: 4467:      continue;
        -: 4468:    }
        -: 4469:
       52: 4470:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)
    #####: 4471:        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))
        -: 4472:    {
    #####: 4473:      parser_process_expression_sequence (context_p);
    #####: 4474:      continue;
        -: 4475:    }
        -: 4476:
       52: 4477:    break;
        -: 4478:  }
        -: 4479:
       60: 4480:  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)
        -: 4481:  {
    #####: 4482:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 4483:  }
        -: 4484:
       60: 4485:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
       60: 4486:  parser_stack_pop_uint8 (context_p);
        -: 4487:
       60: 4488:  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))
        -: 4489:  {
       31: 4490:    parser_push_result (context_p);
        -: 4491:  }
       60: 4492:} /* parser_parse_expression */
        -: 4493:
        -: 4494:/**
        -: 4495: * @}
        -: 4496: * @}
        -: 4497: * @}
        -: 4498: */
        -: 4499:
        -: 4500:#endif /* JERRY_PARSER */
