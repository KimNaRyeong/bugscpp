        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-regexp-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-regexp-object.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-objects.h"
        -:   26:
        -:   27:#include "jcontext.h"
        -:   28:#include "jrt-libc-includes.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "re-compiler.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_REGEXP
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/** \addtogroup ecma ECMA
        -:   38: * @{
        -:   39: *
        -:   40: * \addtogroup ecmaregexpobject ECMA RegExp object related routines
        -:   41: * @{
        -:   42: */
        -:   43:
        -:   44:/**
        -:   45: * Index of the global capturing group
        -:   46: */
        -:   47:#define RE_GLOBAL_CAPTURE 0
        -:   48:
        -:   49:/**
        -:   50: * Parse RegExp flags (global, ignoreCase, multiline)
        -:   51: *
        -:   52: * See also: ECMA-262 v5, 15.10.4.1
        -:   53: *
        -:   54: * @return empty ecma value - if parsed successfully
        -:   55: *         error ecma value - otherwise
        -:   56: *
        -:   57: *         Returned value must be freed with ecma_free_value
        -:   58: */
        -:   59:ecma_value_t
    #####:   60:ecma_regexp_parse_flags (ecma_string_t *flags_str_p, /**< Input string with flags */
        -:   61:                         uint16_t *flags_p) /**< [out] parsed flag bits */
        -:   62:{
    #####:   63:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####:   64:  uint16_t result_flags = RE_FLAG_EMPTY;
        -:   65:
    #####:   66:  ECMA_STRING_TO_UTF8_STRING (flags_str_p, flags_start_p, flags_start_size);
        -:   67:
    #####:   68:  const lit_utf8_byte_t *flags_str_curr_p = flags_start_p;
    #####:   69:  const lit_utf8_byte_t *flags_str_end_p = flags_start_p + flags_start_size;
        -:   70:
    #####:   71:  while (flags_str_curr_p < flags_str_end_p)
        -:   72:  {
        -:   73:    ecma_regexp_flags_t flag;
    #####:   74:    switch (*flags_str_curr_p++)
        -:   75:    {
    #####:   76:      case 'g':
        -:   77:      {
    #####:   78:        flag = RE_FLAG_GLOBAL;
    #####:   79:        break;
        -:   80:      }
    #####:   81:      case 'i':
        -:   82:      {
    #####:   83:        flag = RE_FLAG_IGNORE_CASE;
    #####:   84:        break;
        -:   85:      }
    #####:   86:      case 'm':
        -:   87:      {
    #####:   88:        flag = RE_FLAG_MULTILINE;
    #####:   89:        break;
        -:   90:      }
    #####:   91:      case 'y':
        -:   92:      {
    #####:   93:        flag = RE_FLAG_STICKY;
    #####:   94:        break;
        -:   95:      }
    #####:   96:      case 'u':
        -:   97:      {
    #####:   98:        flag = RE_FLAG_UNICODE;
    #####:   99:        break;
        -:  100:      }
        -:  101:#if JERRY_ESNEXT
    #####:  102:      case 's':
        -:  103:      {
    #####:  104:        flag = RE_FLAG_DOTALL;
    #####:  105:        break;
        -:  106:      }
        -:  107:#endif /* JERRY_ESNEXT */
    #####:  108:      default:
        -:  109:      {
    #####:  110:        flag = RE_FLAG_EMPTY;
    #####:  111:        break;
        -:  112:      }
        -:  113:    }
        -:  114:
    #####:  115:    if (flag == RE_FLAG_EMPTY || (result_flags & flag) != 0)
        -:  116:    {
    #####:  117:      ret_value = ecma_raise_syntax_error (ECMA_ERR_INVALID_REGEXP_FLAGS);
    #####:  118:      break;
        -:  119:    }
        -:  120:
    #####:  121:    result_flags = (uint16_t) (result_flags | flag);
        -:  122:  }
        -:  123:
    #####:  124:  ECMA_FINALIZE_UTF8_STRING (flags_start_p, flags_start_size);
        -:  125:
    #####:  126:  *flags_p = result_flags;
    #####:  127:  return ret_value;
        -:  128:} /* ecma_regexp_parse_flags */
        -:  129:
        -:  130:#if !JERRY_ESNEXT
        -:  131:/*
        -:  132: * Create the properties of a RegExp instance.
        -:  133: */
        -:  134:static void
    #####:  135:ecma_regexp_create_props (ecma_object_t *re_object_p, /**< RegExp object */
        -:  136:                          ecma_string_t *source_p, /**< source string */
        -:  137:                          uint16_t flags) /**< flags */
        -:  138:{
        -:  139:  ecma_property_value_t *prop_value_p;
        -:  140:
    #####:  141:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  142:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_SOURCE),
        -:  143:                                                  ECMA_PROPERTY_FIXED,
        -:  144:                                                  NULL);
        -:  145:
    #####:  146:  ecma_ref_ecma_string (source_p);
    #####:  147:  prop_value_p->value = ecma_make_string_value (source_p);
        -:  148:
    #####:  149:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  150:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_GLOBAL),
        -:  151:                                                  ECMA_PROPERTY_FIXED,
        -:  152:                                                  NULL);
        -:  153:
    #####:  154:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_GLOBAL);
        -:  155:
    #####:  156:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  157:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_IGNORECASE_UL),
        -:  158:                                                  ECMA_PROPERTY_FIXED,
        -:  159:                                                  NULL);
        -:  160:
    #####:  161:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_IGNORE_CASE);
        -:  162:
    #####:  163:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  164:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_MULTILINE),
        -:  165:                                                  ECMA_PROPERTY_FIXED,
        -:  166:                                                  NULL);
        -:  167:
    #####:  168:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_MULTILINE);
    #####:  169:} /* ecma_regexp_create_props */
        -:  170:
        -:  171:/*
        -:  172: * Update the properties of a RegExp instance.
        -:  173: */
        -:  174:static void
    #####:  175:ecma_regexp_update_props (ecma_object_t *re_object_p, /**< RegExp object */
        -:  176:                          ecma_string_t *source_p, /**< source string */
        -:  177:                          uint16_t flags) /**< flags */
        -:  178:{
        -:  179:  ecma_property_t *prop_p;
        -:  180:
    #####:  181:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_SOURCE));
        -:  182:  JERRY_ASSERT (prop_p != NULL);
    #####:  183:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  184:  ecma_free_value (prop_value_p->value);
    #####:  185:  ecma_ref_ecma_string (source_p);
    #####:  186:  prop_value_p->value = ecma_make_string_value (source_p);
        -:  187:
    #####:  188:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_GLOBAL));
        -:  189:  JERRY_ASSERT (prop_p != NULL);
    #####:  190:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  191:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_GLOBAL);
        -:  192:
    #####:  193:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_IGNORECASE_UL));
        -:  194:  JERRY_ASSERT (prop_p != NULL);
    #####:  195:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  196:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_IGNORE_CASE);
        -:  197:
    #####:  198:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_MULTILINE));
        -:  199:  JERRY_ASSERT (prop_p != NULL);
    #####:  200:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  201:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_MULTILINE);
    #####:  202:} /* ecma_regexp_update_props */
        -:  203:#endif /* !JERRY_ESNEXT */
        -:  204:
        -:  205:/**
        -:  206: * RegExpAlloc method
        -:  207: *
        -:  208: * See also: ECMA-262 v5, 15.10.4.1
        -:  209: *           ECMA-262 v6, 21.2.3.2.1
        -:  210: *
        -:  211: * Note:
        -:  212: *      Returned value must be freed with ecma_free_value.
        -:  213: *
        -:  214: * @return ecma_object_t
        -:  215: */
        -:  216:ecma_object_t *
    #####:  217:ecma_op_regexp_alloc (ecma_object_t *ctr_obj_p) /**< constructor object pointer */
        -:  218:{
        -:  219:#if JERRY_ESNEXT
    #####:  220:  if (ctr_obj_p == NULL)
        -:  221:  {
    #####:  222:    ctr_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP);
        -:  223:  }
        -:  224:
    #####:  225:  ecma_object_t *proto_obj_p = ecma_op_get_prototype_from_constructor (ctr_obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE);
        -:  226:
    #####:  227:  if (JERRY_UNLIKELY (proto_obj_p == NULL))
        -:  228:  {
    #####:  229:    return proto_obj_p;
        -:  230:  }
        -:  231:
        -:  232:#else /* !JERRY_ESNEXT */
        -:  233:  JERRY_UNUSED (ctr_obj_p);
    #####:  234:  ecma_object_t *proto_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE);
        -:  235:#endif /* JERRY_ESNEXT */
        -:  236:
    #####:  237:  ecma_object_t *new_object_p =
        -:  238:    ecma_create_object (proto_obj_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  239:
        -:  240:#if JERRY_ESNEXT
    #####:  241:  ecma_deref_object (proto_obj_p);
        -:  242:#endif /* JERRY_ESNEXT */
        -:  243:
    #####:  244:  ecma_extended_object_t *regexp_obj_p = (ecma_extended_object_t *) new_object_p;
        -:  245:
        -:  246:  /* Class id will be initialized after the bytecode is compiled. */
    #####:  247:  regexp_obj_p->u.cls.type = ECMA_OBJECT_CLASS__MAX;
        -:  248:
    #####:  249:  ecma_value_t status = ecma_builtin_helper_def_prop (new_object_p,
        -:  250:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -:  251:                                                      ecma_make_uint32_value (0),
        -:  252:                                                      ECMA_PROPERTY_FLAG_WRITABLE | JERRY_PROP_SHOULD_THROW);
        -:  253:
    #####:  254:  JERRY_ASSERT (ecma_is_value_true (status));
        -:  255:
    #####:  256:  return new_object_p;
        -:  257:} /* ecma_op_regexp_alloc */
        -:  258:
        -:  259:/**
        -:  260: * Helper method for initializing an aready existing RegExp object.
        -:  261: */
        -:  262:static void
    #####:  263:ecma_op_regexp_initialize (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  264:                           const re_compiled_code_t *bc_p, /**< bytecode */
        -:  265:                           ecma_string_t *pattern_str_p, /**< pattern */
        -:  266:                           uint16_t flags) /**< flags */
        -:  267:{
    #####:  268:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) regexp_obj_p;
        -:  269:
        -:  270:#if !JERRY_ESNEXT
    #####:  271:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS__MAX)
        -:  272:  {
        -:  273:    /* This instance has not been initialized before. */
    #####:  274:    ecma_regexp_create_props (regexp_obj_p, pattern_str_p, flags);
        -:  275:  }
        -:  276:  else
        -:  277:  {
    #####:  278:    ecma_regexp_update_props (regexp_obj_p, pattern_str_p, flags);
        -:  279:  }
        -:  280:#endif /* !JERRY_ESNEXT */
        -:  281:
        -:  282:#if JERRY_ESNEXT
        -:  283:  JERRY_UNUSED (pattern_str_p);
        -:  284:  JERRY_UNUSED (flags);
        -:  285:#endif /* JERRY_ESNEXT */
        -:  286:
    #####:  287:  ext_obj_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP;
    #####:  288:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_obj_p->u.cls.u3.value, bc_p);
    #####:  289:} /* ecma_op_regexp_initialize */
        -:  290:
        -:  291:/**
        -:  292: * Method for creating a RegExp object from pattern.
        -:  293: *
        -:  294: * Note:
        -:  295: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  296: *
        -:  297: * @return ecma_value_t
        -:  298: */
        -:  299:ecma_value_t
    #####:  300:ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  301:                                    ecma_value_t pattern_value, /**< pattern */
        -:  302:                                    ecma_value_t flags_value) /**< flags */
        -:  303:{
    #####:  304:  ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
    #####:  305:  uint16_t flags = 0;
        -:  306:
    #####:  307:  if (JERRY_UNLIKELY (pattern_str_p == NULL))
        -:  308:  {
    #####:  309:    return ECMA_VALUE_ERROR;
        -:  310:  }
        -:  311:
    #####:  312:  if (!ecma_is_value_undefined (flags_value))
        -:  313:  {
    #####:  314:    ecma_string_t *flags_str_p = ecma_op_to_string (flags_value);
        -:  315:
    #####:  316:    if (JERRY_UNLIKELY (flags_str_p == NULL))
        -:  317:    {
    #####:  318:      ecma_deref_ecma_string (pattern_str_p);
    #####:  319:      return ECMA_VALUE_ERROR;
        -:  320:    }
        -:  321:
    #####:  322:    ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags);
    #####:  323:    ecma_deref_ecma_string (flags_str_p);
        -:  324:
    #####:  325:    if (ECMA_IS_VALUE_ERROR (parse_flags_value))
        -:  326:    {
    #####:  327:      ecma_deref_ecma_string (pattern_str_p);
    #####:  328:      return parse_flags_value;
        -:  329:    }
        -:  330:
    #####:  331:    JERRY_ASSERT (ecma_is_value_empty (parse_flags_value));
        -:  332:  }
        -:  333:
    #####:  334:  re_compiled_code_t *bc_p = re_compile_bytecode (pattern_str_p, flags);
        -:  335:
    #####:  336:  if (JERRY_UNLIKELY (bc_p == NULL))
        -:  337:  {
    #####:  338:    ecma_deref_ecma_string (pattern_str_p);
    #####:  339:    return ECMA_VALUE_ERROR;
        -:  340:  }
        -:  341:
    #####:  342:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
    #####:  343:  ecma_deref_ecma_string (pattern_str_p);
        -:  344:
    #####:  345:  return ecma_make_object_value (regexp_obj_p);
        -:  346:} /* ecma_op_create_regexp_from_pattern */
        -:  347:
        -:  348:/**
        -:  349: * Method for creating a RegExp object from bytecode.
        -:  350: *
        -:  351: * Note:
        -:  352: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  353: *
        -:  354: * @return ecma_value_t
        -:  355: */
        -:  356:ecma_value_t
    #####:  357:ecma_op_create_regexp_from_bytecode (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  358:                                     re_compiled_code_t *bc_p) /**< bytecode */
        -:  359:{
    #####:  360:  ecma_bytecode_ref ((ecma_compiled_code_t *) bc_p);
    #####:  361:  ecma_string_t *pattern_str_p = ecma_get_string_from_value (bc_p->source);
    #####:  362:  uint16_t flags = bc_p->header.status_flags;
        -:  363:
    #####:  364:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
        -:  365:
    #####:  366:  return ecma_make_object_value (regexp_obj_p);
        -:  367:} /* ecma_op_create_regexp_from_bytecode */
        -:  368:
        -:  369:/**
        -:  370: * Method for creating a RegExp object from pattern with already parsed flags.
        -:  371: *
        -:  372: * Note:
        -:  373: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  374: *
        -:  375: * @return ecma_value_t
        -:  376: */
        -:  377:ecma_value_t
    #####:  378:ecma_op_create_regexp_with_flags (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  379:                                  ecma_value_t pattern_value, /**< pattern */
        -:  380:                                  uint16_t flags) /**< flags */
        -:  381:{
    #####:  382:  ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
        -:  383:
    #####:  384:  if (JERRY_UNLIKELY (pattern_str_p == NULL))
        -:  385:  {
    #####:  386:    return ECMA_VALUE_ERROR;
        -:  387:  }
        -:  388:
    #####:  389:  re_compiled_code_t *bc_p = re_compile_bytecode (pattern_str_p, flags);
    #####:  390:  ecma_deref_ecma_string (pattern_str_p);
        -:  391:
    #####:  392:  if (JERRY_UNLIKELY (bc_p == NULL))
        -:  393:  {
    #####:  394:    return ECMA_VALUE_ERROR;
        -:  395:  }
        -:  396:
    #####:  397:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
        -:  398:
    #####:  399:  return ecma_make_object_value (regexp_obj_p);
        -:  400:} /* ecma_op_create_regexp_with_flags */
        -:  401:
        -:  402:/**
        -:  403: * Canonicalize a character
        -:  404: *
        -:  405: * @return ecma_char_t canonicalized character
        -:  406: */
        -:  407:lit_code_point_t
    #####:  408:ecma_regexp_canonicalize_char (lit_code_point_t ch, /**< character */
        -:  409:                               bool unicode) /**< unicode */
        -:  410:{
        -:  411:#if JERRY_ESNEXT
    #####:  412:  if (unicode)
        -:  413:  {
        -:  414:    /* In unicode mode the mappings contained in the CaseFolding.txt file should be used to canonicalize the character.
        -:  415:     * These mappings generally correspond to the lowercase variant of the character, however there are some
        -:  416:     * differences. In some cases the uppercase variant is used, in others the lowercase of the uppercase character is
        -:  417:     * used, and there are also cases where the character has no case folding mapping even though it has upper/lower
        -:  418:     * variants. Since lowercasing is the most common this is used as the default behaviour, and characters with
        -:  419:     * differing behaviours are encoded in lookup tables. */
        -:  420:
    #####:  421:    if (lit_char_fold_to_upper (ch))
        -:  422:    {
    #####:  423:      ch = lit_char_to_upper_case (ch, NULL);
    #####:  424:      JERRY_ASSERT (ch != LIT_MULTIPLE_CU);
        -:  425:    }
        -:  426:
    #####:  427:    if (lit_char_fold_to_lower (ch))
        -:  428:    {
    #####:  429:      ch = lit_char_to_lower_case (ch, NULL);
    #####:  430:      JERRY_ASSERT (ch != LIT_MULTIPLE_CU);
        -:  431:    }
        -:  432:
    #####:  433:    return ch;
        -:  434:  }
        -:  435:#endif /* !JERRY_ESNEXT */
        -:  436:
        -:  437:  JERRY_UNUSED (unicode);
    #####:  438:  lit_code_point_t cu = lit_char_to_upper_case (ch, NULL);
        -:  439:
    #####:  440:  if (ch <= LIT_UTF8_1_BYTE_CODE_POINT_MAX || (cu > LIT_UTF8_1_BYTE_CODE_POINT_MAX && cu != LIT_MULTIPLE_CU))
        -:  441:  {
    #####:  442:    return cu;
        -:  443:  }
        -:  444:
    #####:  445:  return ch;
        -:  446:} /* ecma_regexp_canonicalize_char */
        -:  447:
        -:  448:/**
        -:  449: * RegExp Canonicalize abstract operation
        -:  450: *
        -:  451: * See also: ECMA-262 v5, 15.10.2.8
        -:  452: *
        -:  453: * @return ecma_char_t canonicalized character
        -:  454: */
        -:  455:static inline lit_code_point_t JERRY_ATTR_ALWAYS_INLINE
        -:  456:ecma_regexp_canonicalize (lit_code_point_t ch, /**< character */
        -:  457:                          uint16_t flags) /**< flags */
        -:  458:{
    #####:  459:  if (flags & RE_FLAG_IGNORE_CASE)
        -:  460:  {
    #####:  461:    return ecma_regexp_canonicalize_char (ch, flags & RE_FLAG_UNICODE);
        -:  462:  }
        -:  463:
    #####:  464:  return ch;
        -:  465:} /* ecma_regexp_canonicalize */
        -:  466:
        -:  467:/**
        -:  468: * Check if a code point is matched by a class escape.
        -:  469: *
        -:  470: * @return true, if code point matches escape
        -:  471: *         false, otherwise
        -:  472: */
        -:  473:static bool
    #####:  474:ecma_regexp_check_class_escape (lit_code_point_t cp, /**< char */
        -:  475:                                ecma_class_escape_t escape) /**< escape */
        -:  476:{
    #####:  477:  switch (escape)
        -:  478:  {
    #####:  479:    case RE_ESCAPE_DIGIT:
        -:  480:    {
    #####:  481:      return (cp >= LIT_CHAR_0 && cp <= LIT_CHAR_9);
        -:  482:    }
    #####:  483:    case RE_ESCAPE_NOT_DIGIT:
        -:  484:    {
    #####:  485:      return (cp < LIT_CHAR_0 || cp > LIT_CHAR_9);
        -:  486:    }
    #####:  487:    case RE_ESCAPE_WORD_CHAR:
        -:  488:    {
    #####:  489:      return lit_char_is_word_char (cp);
        -:  490:    }
    #####:  491:    case RE_ESCAPE_NOT_WORD_CHAR:
        -:  492:    {
    #####:  493:      return !lit_char_is_word_char (cp);
        -:  494:    }
    #####:  495:    case RE_ESCAPE_WHITESPACE:
        -:  496:    {
    #####:  497:      return lit_char_is_white_space ((ecma_char_t) cp);
        -:  498:    }
    #####:  499:    case RE_ESCAPE_NOT_WHITESPACE:
        -:  500:    {
    #####:  501:      return !lit_char_is_white_space ((ecma_char_t) cp);
        -:  502:    }
    #####:  503:    default:
        -:  504:    {
    #####:  505:      JERRY_UNREACHABLE ();
        -:  506:    }
        -:  507:  }
        -:  508:} /* ecma_regexp_check_class_escape */
        -:  509:
        -:  510:/**
        -:  511: * Helper function to get current code point or code unit depending on execution mode,
        -:  512: * and advance the string pointer.
        -:  513: *
        -:  514: * @return lit_code_point_t current code point
        -:  515: */
        -:  516:static lit_code_point_t
    #####:  517:ecma_regexp_advance (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  518:                     const lit_utf8_byte_t **str_p) /**< reference to string pointer */
        -:  519:{
    #####:  520:  JERRY_ASSERT (str_p != NULL);
    #####:  521:  lit_code_point_t cp = lit_cesu8_read_next (str_p);
        -:  522:
        -:  523:#if JERRY_ESNEXT
    #####:  524:  if (JERRY_UNLIKELY (re_ctx_p->flags & RE_FLAG_UNICODE) && lit_is_code_point_utf16_high_surrogate ((ecma_char_t) cp)
    #####:  525:      && *str_p < re_ctx_p->input_end_p)
        -:  526:  {
    #####:  527:    const ecma_char_t next_ch = lit_cesu8_peek_next (*str_p);
    #####:  528:    if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  529:    {
    #####:  530:      cp = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) cp, next_ch);
    #####:  531:      *str_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  532:    }
        -:  533:  }
        -:  534:#endif /* JERRY_ESNEXT */
        -:  535:
    #####:  536:  return ecma_regexp_canonicalize (cp, re_ctx_p->flags);
        -:  537:} /* ecma_regexp_advance */
        -:  538:
        -:  539:#if JERRY_ESNEXT
        -:  540:/**
        -:  541: * Helper function to get current full unicode code point and advance the string pointer.
        -:  542: *
        -:  543: * @return lit_code_point_t current code point
        -:  544: */
        -:  545:lit_code_point_t
    #####:  546:ecma_regexp_unicode_advance (const lit_utf8_byte_t **str_p, /**< reference to string pointer */
        -:  547:                             const lit_utf8_byte_t *end_p) /**< string end pointer */
        -:  548:{
    #####:  549:  JERRY_ASSERT (str_p != NULL);
    #####:  550:  const lit_utf8_byte_t *current_p = *str_p;
        -:  551:
    #####:  552:  lit_code_point_t ch = lit_cesu8_read_next (&current_p);
    #####:  553:  if (lit_is_code_point_utf16_high_surrogate ((ecma_char_t) ch) && current_p < end_p)
        -:  554:  {
    #####:  555:    const ecma_char_t next_ch = lit_cesu8_peek_next (current_p);
    #####:  556:    if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  557:    {
    #####:  558:      ch = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) ch, next_ch);
    #####:  559:      current_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  560:    }
        -:  561:  }
        -:  562:
    #####:  563:  *str_p = current_p;
    #####:  564:  return ch;
        -:  565:} /* ecma_regexp_unicode_advance */
        -:  566:#endif /* JERRY_ESNEXT */
        -:  567:
        -:  568:/**
        -:  569: * Helper function to revert the string pointer to the previous code point.
        -:  570: *
        -:  571: * @return pointer to previous code point
        -:  572: */
        -:  573:static JERRY_ATTR_NOINLINE const lit_utf8_byte_t *
    #####:  574:ecma_regexp_step_back (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  575:                       const lit_utf8_byte_t *str_p) /**< reference to string pointer */
        -:  576:{
    #####:  577:  JERRY_ASSERT (str_p != NULL);
        -:  578:#if JERRY_ESNEXT
    #####:  579:  lit_code_point_t ch = lit_cesu8_read_prev (&str_p);
    #####:  580:  if (JERRY_UNLIKELY (re_ctx_p->flags & RE_FLAG_UNICODE) && lit_is_code_point_utf16_low_surrogate (ch)
    #####:  581:      && lit_is_code_point_utf16_high_surrogate (lit_cesu8_peek_prev (str_p)))
        -:  582:  {
    #####:  583:    str_p -= LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  584:  }
        -:  585:#else /* !JERRY_ESNEXT */
        -:  586:  JERRY_UNUSED (re_ctx_p);
    #####:  587:  lit_utf8_decr (&str_p);
        -:  588:#endif /* !JERRY_ESNEXT */
    #####:  589:  return str_p;
        -:  590:} /* ecma_regexp_step_back */
        -:  591:
        -:  592:/**
        -:  593: * Check if the current poisition is on a word boundary.
        -:  594: *
        -:  595: * @return true, if on a word boundary
        -:  596: *         false - otherwise
        -:  597: */
        -:  598:static bool
    #####:  599:ecma_regexp_is_word_boundary (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  600:                              const lit_utf8_byte_t *str_p) /**< string pointer */
        -:  601:{
        -:  602:  lit_code_point_t left_cp;
        -:  603:  lit_code_point_t right_cp;
        -:  604:
    #####:  605:  if (JERRY_UNLIKELY (str_p <= re_ctx_p->input_start_p))
        -:  606:  {
    #####:  607:    left_cp = LIT_INVALID_CP;
        -:  608:  }
        -:  609:#if JERRY_ESNEXT
    #####:  610:  else if (JERRY_UNLIKELY ((re_ctx_p->flags & (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE))
        -:  611:                           == (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE)))
        -:  612:  {
    #####:  613:    const lit_utf8_byte_t *prev_p = ecma_regexp_step_back (re_ctx_p, str_p);
    #####:  614:    left_cp = ecma_regexp_advance (re_ctx_p, &prev_p);
    #####:  615:    JERRY_ASSERT (prev_p == str_p);
        -:  616:  }
        -:  617:#endif /* JERRY_ESNEXT */
        -:  618:  else
        -:  619:  {
    #####:  620:    left_cp = str_p[-1];
        -:  621:  }
        -:  622:
    #####:  623:  if (JERRY_UNLIKELY (str_p >= re_ctx_p->input_end_p))
        -:  624:  {
    #####:  625:    right_cp = LIT_INVALID_CP;
        -:  626:  }
        -:  627:#if JERRY_ESNEXT
    #####:  628:  else if (JERRY_UNLIKELY ((re_ctx_p->flags & (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE))
        -:  629:                           == (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE)))
        -:  630:  {
    #####:  631:    right_cp = ecma_regexp_advance (re_ctx_p, &str_p);
        -:  632:  }
        -:  633:#endif /* JERRY_ESNEXT */
        -:  634:  else
        -:  635:  {
    #####:  636:    right_cp = str_p[0];
        -:  637:  }
        -:  638:
    #####:  639:  return lit_char_is_word_char (left_cp) != lit_char_is_word_char (right_cp);
        -:  640:} /* ecma_regexp_is_word_boundary */
        -:  641:
        -:  642:/**
        -:  643: * Recursive function for executing RegExp bytecode.
        -:  644: *
        -:  645: * See also:
        -:  646: *          ECMA-262 v5, 15.10.2.1
        -:  647: *
        -:  648: * @return pointer to the end of the currently matched substring
        -:  649: *         NULL, if pattern did not match
        -:  650: */
        -:  651:static const lit_utf8_byte_t *
    #####:  652:ecma_regexp_run (ecma_regexp_ctx_t *re_ctx_p, /**< RegExp matcher context */
        -:  653:                 const uint8_t *bc_p, /**< pointer to the current RegExp bytecode */
        -:  654:                 const lit_utf8_byte_t *str_curr_p) /**< input string pointer */
        -:  655:{
        -:  656:#if (JERRY_STACK_LIMIT != 0)
    #####:  657:  if (JERRY_UNLIKELY (ecma_get_current_stack_usage () > CONFIG_MEM_STACK_LIMIT))
        -:  658:  {
    #####:  659:    return ECMA_RE_OUT_OF_STACK;
        -:  660:  }
        -:  661:#endif /* JERRY_STACK_LIMIT != 0 */
        -:  662:
    #####:  663:  const lit_utf8_byte_t *str_start_p = str_curr_p;
    #####:  664:  const uint8_t *next_alternative_p = NULL;
        -:  665:
        -:  666:  while (true)
    #####:  667:  {
    #####:  668:    const re_opcode_t op = re_get_opcode (&bc_p);
        -:  669:
    #####:  670:    switch (op)
        -:  671:    {
    #####:  672:      case RE_OP_EOF:
        -:  673:      {
    #####:  674:        re_ctx_p->captures_p[RE_GLOBAL_CAPTURE].end_p = str_curr_p;
        -:  675:        /* FALLTHRU */
        -:  676:      }
    #####:  677:      case RE_OP_ASSERT_END:
        -:  678:      case RE_OP_ITERATOR_END:
        -:  679:      {
    #####:  680:        return str_curr_p;
        -:  681:      }
    #####:  682:      case RE_OP_ALTERNATIVE_START:
        -:  683:      {
    #####:  684:        const uint32_t offset = re_get_value (&bc_p);
    #####:  685:        next_alternative_p = bc_p + offset;
    #####:  686:        continue;
        -:  687:      }
    #####:  688:      case RE_OP_ALTERNATIVE_NEXT:
        -:  689:      {
        -:  690:        while (true)
    #####:  691:        {
    #####:  692:          const uint32_t offset = re_get_value (&bc_p);
    #####:  693:          bc_p += offset;
        -:  694:
    #####:  695:          if (*bc_p != RE_OP_ALTERNATIVE_NEXT)
        -:  696:          {
    #####:  697:            break;
        -:  698:          }
        -:  699:
    #####:  700:          bc_p++;
        -:  701:        }
        -:  702:
    #####:  703:        continue;
        -:  704:      }
    #####:  705:      case RE_OP_NO_ALTERNATIVE:
        -:  706:      {
    #####:  707:        return NULL;
        -:  708:      }
    #####:  709:      case RE_OP_CAPTURING_GROUP_START:
        -:  710:      {
    #####:  711:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  712:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  713:        group_p->subcapture_count = re_get_value (&bc_p);
        -:  714:
    #####:  715:        const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  716:        const lit_utf8_byte_t *const saved_end_p = group_p->end_p;
    #####:  717:        const uint32_t saved_iterator = group_p->iterator;
        -:  718:
    #####:  719:        const uint32_t qmin = re_get_value (&bc_p);
    #####:  720:        group_p->end_p = NULL;
        -:  721:
        -:  722:        /* If zero iterations are allowed, then execute the end opcode which will handle further iterations,
        -:  723:         * otherwise run the 1st iteration immediately by executing group bytecode. */
    #####:  724:        if (qmin == 0)
        -:  725:        {
    #####:  726:          group_p->iterator = 0;
    #####:  727:          group_p->begin_p = NULL;
    #####:  728:          const uint32_t end_offset = re_get_value (&bc_p);
    #####:  729:          group_p->bc_p = bc_p;
        -:  730:
    #####:  731:          bc_p += end_offset;
        -:  732:        }
        -:  733:        else
        -:  734:        {
    #####:  735:          group_p->iterator = 1;
    #####:  736:          group_p->begin_p = str_curr_p;
    #####:  737:          group_p->bc_p = bc_p;
        -:  738:        }
        -:  739:
    #####:  740:        const lit_utf8_byte_t *matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
    #####:  741:        group_p->iterator = saved_iterator;
        -:  742:
    #####:  743:        if (matched_p == NULL)
        -:  744:        {
    #####:  745:          group_p->begin_p = saved_begin_p;
    #####:  746:          group_p->end_p = saved_end_p;
    #####:  747:          goto fail;
        -:  748:        }
        -:  749:
    #####:  750:        return matched_p;
        -:  751:      }
    #####:  752:      case RE_OP_NON_CAPTURING_GROUP_START:
        -:  753:      {
    #####:  754:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  755:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
        -:  756:
    #####:  757:        group_p->subcapture_start = re_get_value (&bc_p);
    #####:  758:        group_p->subcapture_count = re_get_value (&bc_p);
        -:  759:
    #####:  760:        const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  761:        const uint32_t saved_iterator = group_p->iterator;
    #####:  762:        const uint32_t qmin = re_get_value (&bc_p);
        -:  763:
        -:  764:        /* If zero iterations are allowed, then execute the end opcode which will handle further iterations,
        -:  765:         * otherwise run the 1st iteration immediately by executing group bytecode. */
    #####:  766:        if (qmin == 0)
        -:  767:        {
    #####:  768:          group_p->iterator = 0;
    #####:  769:          group_p->begin_p = NULL;
    #####:  770:          const uint32_t end_offset = re_get_value (&bc_p);
    #####:  771:          group_p->bc_p = bc_p;
        -:  772:
    #####:  773:          bc_p += end_offset;
        -:  774:        }
        -:  775:        else
        -:  776:        {
    #####:  777:          group_p->iterator = 1;
    #####:  778:          group_p->begin_p = str_curr_p;
    #####:  779:          group_p->bc_p = bc_p;
        -:  780:        }
        -:  781:
    #####:  782:        const lit_utf8_byte_t *matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
    #####:  783:        group_p->iterator = saved_iterator;
        -:  784:
    #####:  785:        if (matched_p == NULL)
        -:  786:        {
    #####:  787:          group_p->begin_p = saved_begin_p;
    #####:  788:          goto fail;
        -:  789:        }
        -:  790:
    #####:  791:        return matched_p;
        -:  792:      }
    #####:  793:      case RE_OP_GREEDY_CAPTURING_GROUP_END:
        -:  794:      {
    #####:  795:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  796:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  797:        const uint32_t qmin = re_get_value (&bc_p);
        -:  798:
    #####:  799:        if (group_p->iterator < qmin)
        -:  800:        {
        -:  801:          /* No need to save begin_p since we don't have to backtrack beyond the minimum iteration count, but we have
        -:  802:           * to clear nested capturing groups. */
    #####:  803:          group_p->begin_p = str_curr_p;
    #####:  804:          for (uint32_t i = 1; i < group_p->subcapture_count; ++i)
        -:  805:          {
    #####:  806:            group_p[i].begin_p = NULL;
        -:  807:          }
        -:  808:
    #####:  809:          group_p->iterator++;
    #####:  810:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  811:
    #####:  812:          if (matched_p != NULL)
        -:  813:          {
    #####:  814:            return matched_p;
        -:  815:          }
        -:  816:
    #####:  817:          group_p->iterator--;
    #####:  818:          goto fail;
        -:  819:        }
        -:  820:
        -:  821:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####:  822:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -:  823:        {
    #####:  824:          goto fail;
        -:  825:        }
        -:  826:
    #####:  827:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####:  828:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -:  829:        {
        -:  830:          /* Reached maximum number of iterations, try to match tail bytecode. */
    #####:  831:          group_p->end_p = str_curr_p;
    #####:  832:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  833:
    #####:  834:          if (matched_p != NULL)
        -:  835:          {
    #####:  836:            return matched_p;
        -:  837:          }
        -:  838:
    #####:  839:          goto fail;
        -:  840:        }
        -:  841:
    #####:  842:        {
        -:  843:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####:  844:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####:  845:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  846:          {
    #####:  847:            saved_captures_p[i] = group_p[i].begin_p;
    #####:  848:            group_p[i].begin_p = NULL;
        -:  849:          }
        -:  850:
    #####:  851:          group_p->iterator++;
    #####:  852:          group_p->begin_p = str_curr_p;
        -:  853:
    #####:  854:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  855:
    #####:  856:          if (matched_p != NULL)
        -:  857:          {
    #####:  858:            return matched_p;
        -:  859:          }
        -:  860:
        -:  861:          /* Failed to iterate again, backtrack to current match, and try to run tail bytecode. */
    #####:  862:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  863:          {
    #####:  864:            group_p[i].begin_p = saved_captures_p[i];
        -:  865:          }
        -:  866:
    #####:  867:          group_p->iterator--;
    #####:  868:          group_p->end_p = str_curr_p;
        -:  869:        }
        -:  870:
    #####:  871:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  872:
    #####:  873:        if (tail_match_p != NULL)
        -:  874:        {
    #####:  875:          return tail_match_p;
        -:  876:        }
        -:  877:
    #####:  878:        goto fail;
        -:  879:      }
    #####:  880:      case RE_OP_GREEDY_NON_CAPTURING_GROUP_END:
        -:  881:      {
    #####:  882:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  883:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
    #####:  884:        const uint32_t qmin = re_get_value (&bc_p);
        -:  885:
    #####:  886:        if (group_p->iterator < qmin)
        -:  887:        {
        -:  888:          /* No need to save begin_p but we have to clear nested capturing groups. */
    #####:  889:          group_p->begin_p = str_curr_p;
        -:  890:
    #####:  891:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start;
    #####:  892:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  893:          {
    #####:  894:            capture_p[i].begin_p = NULL;
        -:  895:          }
        -:  896:
    #####:  897:          group_p->iterator++;
    #####:  898:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  899:
    #####:  900:          if (matched_p != NULL)
        -:  901:          {
    #####:  902:            return matched_p;
        -:  903:          }
        -:  904:
    #####:  905:          group_p->iterator--;
    #####:  906:          goto fail;
        -:  907:        }
        -:  908:
        -:  909:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####:  910:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -:  911:        {
    #####:  912:          goto fail;
        -:  913:        }
        -:  914:
    #####:  915:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####:  916:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -:  917:        {
        -:  918:          /* Reached maximum number of iterations, try to match tail bytecode. */
    #####:  919:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  920:
    #####:  921:          if (matched_p != NULL)
        -:  922:          {
    #####:  923:            return matched_p;
        -:  924:          }
        -:  925:
    #####:  926:          goto fail;
        -:  927:        }
        -:  928:
    #####:  929:        {
        -:  930:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####:  931:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####:  932:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  933:          {
    #####:  934:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####:  935:            saved_captures_p[i] = capture_p->begin_p;
    #####:  936:            capture_p->begin_p = NULL;
        -:  937:          }
        -:  938:
    #####:  939:          group_p->iterator++;
    #####:  940:          const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  941:          group_p->begin_p = str_curr_p;
        -:  942:
    #####:  943:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  944:
    #####:  945:          if (matched_p != NULL)
        -:  946:          {
    #####:  947:            return matched_p;
        -:  948:          }
        -:  949:
        -:  950:          /* Failed to iterate again, backtrack to current match, and try to run tail bytecode. */
    #####:  951:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  952:          {
    #####:  953:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####:  954:            capture_p->begin_p = saved_captures_p[i];
        -:  955:          }
        -:  956:
    #####:  957:          group_p->iterator--;
    #####:  958:          group_p->begin_p = saved_begin_p;
        -:  959:        }
        -:  960:
    #####:  961:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  962:
    #####:  963:        if (tail_match_p != NULL)
        -:  964:        {
    #####:  965:          return tail_match_p;
        -:  966:        }
        -:  967:
    #####:  968:        goto fail;
        -:  969:      }
    #####:  970:      case RE_OP_LAZY_CAPTURING_GROUP_END:
        -:  971:      {
    #####:  972:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  973:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  974:        const uint32_t qmin = re_get_value (&bc_p);
        -:  975:
    #####:  976:        if (group_p->iterator < qmin)
        -:  977:        {
        -:  978:          /* No need to save begin_p but we have to clear nested capturing groups. */
    #####:  979:          group_p->begin_p = str_curr_p;
    #####:  980:          for (uint32_t i = 1; i < group_p->subcapture_count; ++i)
        -:  981:          {
    #####:  982:            group_p[i].begin_p = NULL;
        -:  983:          }
        -:  984:
    #####:  985:          group_p->iterator++;
    #####:  986:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  987:
    #####:  988:          if (matched_p != NULL)
        -:  989:          {
    #####:  990:            return matched_p;
        -:  991:          }
        -:  992:
    #####:  993:          group_p->iterator--;
    #####:  994:          goto fail;
        -:  995:        }
        -:  996:
        -:  997:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####:  998:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -:  999:        {
    #####: 1000:          goto fail;
        -: 1001:        }
        -: 1002:
    #####: 1003:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1004:        group_p->end_p = str_curr_p;
        -: 1005:
        -: 1006:        /* Try to match tail bytecode. */
    #####: 1007:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1008:
    #####: 1009:        if (tail_match_p != NULL)
        -: 1010:        {
    #####: 1011:          return tail_match_p;
        -: 1012:        }
        -: 1013:
    #####: 1014:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -: 1015:        {
        -: 1016:          /* Reached maximum number of iterations and tail bytecode did not match. */
    #####: 1017:          goto fail;
        -: 1018:        }
        -: 1019:
    #####: 1020:        {
        -: 1021:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####: 1022:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####: 1023:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1024:          {
    #####: 1025:            saved_captures_p[i] = group_p[i].begin_p;
    #####: 1026:            group_p[i].begin_p = NULL;
        -: 1027:          }
        -: 1028:
    #####: 1029:          group_p->iterator++;
    #####: 1030:          group_p->begin_p = str_curr_p;
        -: 1031:
    #####: 1032:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1033:
    #####: 1034:          if (matched_p != NULL)
        -: 1035:          {
    #####: 1036:            return matched_p;
        -: 1037:          }
        -: 1038:
        -: 1039:          /* Backtrack to current match. */
    #####: 1040:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1041:          {
    #####: 1042:            group_p[i].begin_p = saved_captures_p[i];
        -: 1043:          }
        -: 1044:
    #####: 1045:          group_p->iterator--;
        -: 1046:        }
        -: 1047:
    #####: 1048:        goto fail;
        -: 1049:      }
    #####: 1050:      case RE_OP_LAZY_NON_CAPTURING_GROUP_END:
        -: 1051:      {
    #####: 1052:        const uint32_t group_idx = re_get_value (&bc_p);
    #####: 1053:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
    #####: 1054:        const uint32_t qmin = re_get_value (&bc_p);
        -: 1055:
    #####: 1056:        if (group_p->iterator < qmin)
        -: 1057:        {
        -: 1058:          /* Clear nested captures. */
    #####: 1059:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start;
    #####: 1060:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1061:          {
    #####: 1062:            capture_p[i].begin_p = NULL;
        -: 1063:          }
        -: 1064:
    #####: 1065:          group_p->iterator++;
    #####: 1066:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1067:
    #####: 1068:          if (matched_p != NULL)
        -: 1069:          {
    #####: 1070:            return matched_p;
        -: 1071:          }
        -: 1072:
    #####: 1073:          group_p->iterator--;
    #####: 1074:          goto fail;
        -: 1075:        }
        -: 1076:
        -: 1077:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####: 1078:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -: 1079:        {
    #####: 1080:          goto fail;
        -: 1081:        }
        -: 1082:
    #####: 1083:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
        -: 1084:
        -: 1085:        /* Try to match tail bytecode. */
    #####: 1086:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1087:
    #####: 1088:        if (tail_match_p != NULL)
        -: 1089:        {
    #####: 1090:          return tail_match_p;
        -: 1091:        }
        -: 1092:
    #####: 1093:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -: 1094:        {
        -: 1095:          /* Reached maximum number of iterations and tail bytecode did not match. */
    #####: 1096:          goto fail;
        -: 1097:        }
        -: 1098:
    #####: 1099:        {
        -: 1100:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####: 1101:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####: 1102:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1103:          {
    #####: 1104:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####: 1105:            saved_captures_p[i] = capture_p->begin_p;
    #####: 1106:            capture_p->begin_p = NULL;
        -: 1107:          }
        -: 1108:
    #####: 1109:          group_p->iterator++;
    #####: 1110:          const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####: 1111:          group_p->begin_p = str_curr_p;
        -: 1112:
    #####: 1113:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1114:
    #####: 1115:          if (matched_p != NULL)
        -: 1116:          {
    #####: 1117:            return matched_p;
        -: 1118:          }
        -: 1119:
        -: 1120:          /* Backtrack to current match. */
    #####: 1121:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1122:          {
    #####: 1123:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####: 1124:            capture_p->begin_p = saved_captures_p[i];
        -: 1125:          }
        -: 1126:
    #####: 1127:          group_p->iterator--;
    #####: 1128:          group_p->begin_p = saved_begin_p;
        -: 1129:        }
        -: 1130:
    #####: 1131:        goto fail;
        -: 1132:      }
    #####: 1133:      case RE_OP_GREEDY_ITERATOR:
        -: 1134:      {
    #####: 1135:        const uint32_t qmin = re_get_value (&bc_p);
    #####: 1136:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1137:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1138:
    #####: 1139:        uint32_t iterator = 0;
    #####: 1140:        while (iterator < qmin)
        -: 1141:        {
    #####: 1142:          str_curr_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1143:
    #####: 1144:          if (str_curr_p == NULL)
        -: 1145:          {
    #####: 1146:            goto fail;
        -: 1147:          }
        -: 1148:
    #####: 1149:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1150:          {
    #####: 1151:            return str_curr_p;
        -: 1152:          }
        -: 1153:
    #####: 1154:          iterator++;
        -: 1155:        }
        -: 1156:
    #####: 1157:        while (iterator < qmax)
        -: 1158:        {
    #####: 1159:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1160:
    #####: 1161:          if (matched_p == NULL)
        -: 1162:          {
    #####: 1163:            break;
        -: 1164:          }
        -: 1165:
    #####: 1166:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1167:          {
    #####: 1168:            return str_curr_p;
        -: 1169:          }
        -: 1170:
    #####: 1171:          str_curr_p = matched_p;
    #####: 1172:          iterator++;
        -: 1173:        }
        -: 1174:
    #####: 1175:        const uint8_t *const tail_bc_p = bc_p + end_offset;
        -: 1176:        while (true)
    #####: 1177:        {
    #####: 1178:          const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, tail_bc_p, str_curr_p);
        -: 1179:
    #####: 1180:          if (tail_match_p != NULL)
        -: 1181:          {
    #####: 1182:            return tail_match_p;
        -: 1183:          }
        -: 1184:
    #####: 1185:          if (JERRY_UNLIKELY (iterator <= qmin))
        -: 1186:          {
    #####: 1187:            goto fail;
        -: 1188:          }
        -: 1189:
    #####: 1190:          iterator--;
    #####: 1191:          JERRY_ASSERT (str_curr_p > re_ctx_p->input_start_p);
    #####: 1192:          str_curr_p = ecma_regexp_step_back (re_ctx_p, str_curr_p);
        -: 1193:        }
        -: 1194:
        -: 1195:        JERRY_UNREACHABLE ();
        -: 1196:      }
    #####: 1197:      case RE_OP_LAZY_ITERATOR:
        -: 1198:      {
    #####: 1199:        const uint32_t qmin = re_get_value (&bc_p);
    #####: 1200:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1201:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1202:
    #####: 1203:        uint32_t iterator = 0;
    #####: 1204:        while (iterator < qmin)
        -: 1205:        {
    #####: 1206:          str_curr_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1207:
    #####: 1208:          if (str_curr_p == NULL)
        -: 1209:          {
    #####: 1210:            goto fail;
        -: 1211:          }
        -: 1212:
    #####: 1213:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1214:          {
    #####: 1215:            return str_curr_p;
        -: 1216:          }
        -: 1217:
    #####: 1218:          iterator++;
        -: 1219:        }
        -: 1220:
    #####: 1221:        const uint8_t *const tail_bc_p = bc_p + end_offset;
        -: 1222:        while (true)
    #####: 1223:        {
    #####: 1224:          const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, tail_bc_p, str_curr_p);
        -: 1225:
    #####: 1226:          if (tail_match_p != NULL)
        -: 1227:          {
    #####: 1228:            return tail_match_p;
        -: 1229:          }
        -: 1230:
    #####: 1231:          if (JERRY_UNLIKELY (iterator >= qmax))
        -: 1232:          {
    #####: 1233:            goto fail;
        -: 1234:          }
        -: 1235:
    #####: 1236:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1237:
    #####: 1238:          if (matched_p == NULL)
        -: 1239:          {
    #####: 1240:            goto fail;
        -: 1241:          }
        -: 1242:
    #####: 1243:          if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1244:          {
    #####: 1245:            return matched_p;
        -: 1246:          }
        -: 1247:
    #####: 1248:          iterator++;
    #####: 1249:          str_curr_p = matched_p;
        -: 1250:        }
        -: 1251:
        -: 1252:        JERRY_UNREACHABLE ();
        -: 1253:      }
    #####: 1254:      case RE_OP_BACKREFERENCE:
        -: 1255:      {
    #####: 1256:        const uint32_t backref_idx = re_get_value (&bc_p);
    #####: 1257:        JERRY_ASSERT (backref_idx >= 1 && backref_idx < re_ctx_p->captures_count);
    #####: 1258:        const ecma_regexp_capture_t *capture_p = re_ctx_p->captures_p + backref_idx;
        -: 1259:
    #####: 1260:        if (!ECMA_RE_IS_CAPTURE_DEFINED (capture_p) || capture_p->end_p <= capture_p->begin_p)
        -: 1261:        {
        -: 1262:          /* Undefined or zero length captures always match. */
    #####: 1263:          continue;
        -: 1264:        }
        -: 1265:
    #####: 1266:        const lit_utf8_size_t capture_size = (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p);
        -: 1267:
    #####: 1268:        if (str_curr_p + capture_size > re_ctx_p->input_end_p || memcmp (str_curr_p, capture_p->begin_p, capture_size))
        -: 1269:        {
        -: 1270:          goto fail;
        -: 1271:        }
        -: 1272:
    #####: 1273:        str_curr_p += capture_size;
    #####: 1274:        continue;
        -: 1275:      }
    #####: 1276:      case RE_OP_ASSERT_LINE_START:
        -: 1277:      {
    #####: 1278:        if (str_curr_p <= re_ctx_p->input_start_p)
        -: 1279:        {
    #####: 1280:          continue;
        -: 1281:        }
        -: 1282:
    #####: 1283:        if (!(re_ctx_p->flags & RE_FLAG_MULTILINE) || !lit_char_is_line_terminator (lit_cesu8_peek_prev (str_curr_p)))
        -: 1284:        {
        -: 1285:          goto fail;
        -: 1286:        }
        -: 1287:
    #####: 1288:        continue;
        -: 1289:      }
    #####: 1290:      case RE_OP_ASSERT_LINE_END:
        -: 1291:      {
    #####: 1292:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1293:        {
    #####: 1294:          continue;
        -: 1295:        }
        -: 1296:
    #####: 1297:        if (!(re_ctx_p->flags & RE_FLAG_MULTILINE) || !lit_char_is_line_terminator (lit_cesu8_peek_next (str_curr_p)))
        -: 1298:        {
        -: 1299:          goto fail;
        -: 1300:        }
        -: 1301:
    #####: 1302:        continue;
        -: 1303:      }
    #####: 1304:      case RE_OP_ASSERT_WORD_BOUNDARY:
        -: 1305:      {
    #####: 1306:        if (!ecma_regexp_is_word_boundary (re_ctx_p, str_curr_p))
        -: 1307:        {
    #####: 1308:          goto fail;
        -: 1309:        }
        -: 1310:
    #####: 1311:        continue;
        -: 1312:      }
    #####: 1313:      case RE_OP_ASSERT_NOT_WORD_BOUNDARY:
        -: 1314:      {
    #####: 1315:        if (ecma_regexp_is_word_boundary (re_ctx_p, str_curr_p))
        -: 1316:        {
    #####: 1317:          goto fail;
        -: 1318:        }
        -: 1319:
    #####: 1320:        continue;
        -: 1321:      }
    #####: 1322:      case RE_OP_ASSERT_LOOKAHEAD_POS:
    #####: 1323:      {
    #####: 1324:        const uint8_t qmin = re_get_byte (&bc_p);
    #####: 1325:        const uint32_t capture_start = re_get_value (&bc_p);
    #####: 1326:        const uint32_t capture_count = re_get_value (&bc_p);
    #####: 1327:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1328:
        -: 1329:        /* If qmin is zero, the assertion implicitly matches. */
    #####: 1330:        if (qmin == 0)
        -: 1331:        {
    #####: 1332:          bc_p += end_offset;
    #####: 1333:          continue;
        -: 1334:        }
        -: 1335:
        -: 1336:        /* Capture end pointers might get clobbered and need to be restored after a tail match fail. */
    #####: 1337:        JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, capture_count);
    #####: 1338:        for (uint32_t i = 0; i < capture_count; ++i)
        -: 1339:        {
    #####: 1340:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + capture_start + i;
    #####: 1341:          saved_captures_p[i] = capture_p->end_p;
        -: 1342:        }
        -: 1343:
        -: 1344:        /* The first iteration will decide whether the assertion matches depending on whether
        -: 1345:         * the iteration matched or not. */
    #####: 1346:        const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1347:
    #####: 1348:        if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1349:        {
    #####: 1350:          return matched_p;
        -: 1351:        }
        -: 1352:
    #####: 1353:        if (matched_p == NULL)
        -: 1354:        {
    #####: 1355:          goto fail;
        -: 1356:        }
        -: 1357:
    #####: 1358:        const lit_utf8_byte_t *tail_match_p = ecma_regexp_run (re_ctx_p, bc_p + end_offset, str_curr_p);
        -: 1359:
    #####: 1360:        if (tail_match_p == NULL)
        -: 1361:        {
    #####: 1362:          for (uint32_t i = 0; i < capture_count; ++i)
        -: 1363:          {
    #####: 1364:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + capture_start + i;
    #####: 1365:            capture_p->begin_p = NULL;
    #####: 1366:            capture_p->end_p = saved_captures_p[i];
        -: 1367:          }
        -: 1368:
    #####: 1369:          goto fail;
        -: 1370:        }
        -: 1371:
    #####: 1372:        return tail_match_p;
        -: 1373:      }
    #####: 1374:      case RE_OP_ASSERT_LOOKAHEAD_NEG:
        -: 1375:      {
    #####: 1376:        const uint8_t qmin = re_get_byte (&bc_p);
    #####: 1377:        uint32_t capture_idx = re_get_value (&bc_p);
    #####: 1378:        const uint32_t capture_count = re_get_value (&bc_p);
    #####: 1379:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1380:
        -: 1381:        /* If qmin is zero, the assertion implicitly matches. */
    #####: 1382:        if (qmin > 0)
        -: 1383:        {
        -: 1384:          /* The first iteration will decide whether the assertion matches depending on whether
        -: 1385:           * the iteration matched or not. */
    #####: 1386:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1387:
    #####: 1388:          if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1389:          {
    #####: 1390:            return matched_p;
        -: 1391:          }
        -: 1392:
    #####: 1393:          if (matched_p != NULL)
        -: 1394:          {
        -: 1395:            /* Nested capturing groups inside a negative lookahead can never capture, so we clear their results. */
    #####: 1396:            const uint32_t capture_end = capture_idx + capture_count;
    #####: 1397:            while (capture_idx < capture_end)
        -: 1398:            {
    #####: 1399:              re_ctx_p->captures_p[capture_idx++].begin_p = NULL;
        -: 1400:            }
        -: 1401:
    #####: 1402:            goto fail;
        -: 1403:          }
        -: 1404:        }
        -: 1405:
    #####: 1406:        bc_p += end_offset;
    #####: 1407:        continue;
        -: 1408:      }
    #####: 1409:      case RE_OP_CLASS_ESCAPE:
        -: 1410:      {
    #####: 1411:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1412:        {
    #####: 1413:          goto fail;
        -: 1414:        }
        -: 1415:
    #####: 1416:        const lit_code_point_t cp = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1417:
    #####: 1418:        const ecma_class_escape_t escape = (ecma_class_escape_t) re_get_byte (&bc_p);
    #####: 1419:        if (!ecma_regexp_check_class_escape (cp, escape))
        -: 1420:        {
    #####: 1421:          goto fail;
        -: 1422:        }
        -: 1423:
    #####: 1424:        continue;
        -: 1425:      }
    #####: 1426:      case RE_OP_CHAR_CLASS:
        -: 1427:      {
    #####: 1428:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1429:        {
    #####: 1430:          goto fail;
        -: 1431:        }
        -: 1432:
    #####: 1433:        uint8_t flags = re_get_byte (&bc_p);
    #####: 1434:        uint32_t char_count = (flags & RE_CLASS_HAS_CHARS) ? re_get_value (&bc_p) : 0;
    #####: 1435:        uint32_t range_count = (flags & RE_CLASS_HAS_RANGES) ? re_get_value (&bc_p) : 0;
        -: 1436:
    #####: 1437:        const lit_code_point_t cp = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1438:
    #####: 1439:        uint8_t escape_count = flags & RE_CLASS_ESCAPE_COUNT_MASK;
    #####: 1440:        while (escape_count > 0)
        -: 1441:        {
    #####: 1442:          escape_count--;
    #####: 1443:          const ecma_class_escape_t escape = re_get_byte (&bc_p);
    #####: 1444:          if (ecma_regexp_check_class_escape (cp, escape))
        -: 1445:          {
    #####: 1446:            goto class_found;
        -: 1447:          }
        -: 1448:        }
        -: 1449:
    #####: 1450:        while (char_count > 0)
        -: 1451:        {
    #####: 1452:          char_count--;
    #####: 1453:          const lit_code_point_t curr = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1454:          if (cp == curr)
        -: 1455:          {
    #####: 1456:            goto class_found;
        -: 1457:          }
        -: 1458:        }
        -: 1459:
    #####: 1460:        while (range_count > 0)
        -: 1461:        {
    #####: 1462:          range_count--;
    #####: 1463:          const lit_code_point_t begin = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
        -: 1464:
    #####: 1465:          if (cp < begin)
        -: 1466:          {
    #####: 1467:            bc_p += re_ctx_p->char_size;
    #####: 1468:            continue;
        -: 1469:          }
        -: 1470:
    #####: 1471:          const lit_code_point_t end = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1472:          if (cp <= end)
        -: 1473:          {
    #####: 1474:            goto class_found;
        -: 1475:          }
        -: 1476:        }
        -: 1477:
        -: 1478:        /* Not found */
    #####: 1479:        if (flags & RE_CLASS_INVERT)
        -: 1480:        {
    #####: 1481:          continue;
        -: 1482:        }
        -: 1483:
    #####: 1484:        goto fail;
        -: 1485:
    #####: 1486:class_found:
    #####: 1487:        if (flags & RE_CLASS_INVERT)
        -: 1488:        {
    #####: 1489:          goto fail;
        -: 1490:        }
        -: 1491:
    #####: 1492:        const uint32_t chars_size = char_count * re_ctx_p->char_size;
    #####: 1493:        const uint32_t ranges_size = range_count * re_ctx_p->char_size * 2;
    #####: 1494:        bc_p = bc_p + escape_count + chars_size + ranges_size;
    #####: 1495:        continue;
        -: 1496:      }
        -: 1497:#if JERRY_ESNEXT
    #####: 1498:      case RE_OP_UNICODE_PERIOD:
        -: 1499:      {
    #####: 1500:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1501:        {
    #####: 1502:          goto fail;
        -: 1503:        }
        -: 1504:
    #####: 1505:        const lit_code_point_t cp = ecma_regexp_unicode_advance (&str_curr_p, re_ctx_p->input_end_p);
        -: 1506:
    #####: 1507:        if (!(re_ctx_p->flags & RE_FLAG_DOTALL)
    #####: 1508:            && JERRY_UNLIKELY (cp <= LIT_UTF16_CODE_UNIT_MAX && lit_char_is_line_terminator ((ecma_char_t) cp)))
        -: 1509:        {
    #####: 1510:          goto fail;
        -: 1511:        }
        -: 1512:
    #####: 1513:        continue;
        -: 1514:      }
        -: 1515:#endif /* JERRY_ESNEXT */
    #####: 1516:      case RE_OP_PERIOD:
        -: 1517:      {
    #####: 1518:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1519:        {
    #####: 1520:          goto fail;
        -: 1521:        }
        -: 1522:
    #####: 1523:        const ecma_char_t ch = lit_cesu8_read_next (&str_curr_p);
        -: 1524:#if !JERRY_ESNEXT
    #####: 1525:        bool has_dot_all_flag = false;
        -: 1526:#else /* JERRY_ESNEXT */
    #####: 1527:        bool has_dot_all_flag = (re_ctx_p->flags & RE_FLAG_DOTALL) != 0;
        -: 1528:#endif /* !JERRY_ESNEXT */
        -: 1529:
    #####: 1530:        if (!has_dot_all_flag && lit_char_is_line_terminator (ch))
        -: 1531:        {
    #####: 1532:          goto fail;
        -: 1533:        }
        -: 1534:
    #####: 1535:        continue;
        -: 1536:      }
    #####: 1537:      case RE_OP_CHAR:
        -: 1538:      {
    #####: 1539:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1540:        {
    #####: 1541:          goto fail;
        -: 1542:        }
        -: 1543:
    #####: 1544:        const lit_code_point_t ch1 = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1545:        const lit_code_point_t ch2 = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1546:
    #####: 1547:        if (ch1 != ch2)
        -: 1548:        {
    #####: 1549:          goto fail;
        -: 1550:        }
        -: 1551:
    #####: 1552:        continue;
        -: 1553:      }
    #####: 1554:      default:
        -: 1555:      {
    #####: 1556:        JERRY_ASSERT (op == RE_OP_BYTE);
        -: 1557:
    #####: 1558:        if (str_curr_p >= re_ctx_p->input_end_p || *bc_p++ != *str_curr_p++)
        -: 1559:        {
        -: 1560:          goto fail;
        -: 1561:        }
        -: 1562:
    #####: 1563:        continue;
        -: 1564:      }
        -: 1565:    }
        -: 1566:
        -: 1567:    JERRY_UNREACHABLE ();
    #####: 1568:fail:
    #####: 1569:    bc_p = next_alternative_p;
        -: 1570:
    #####: 1571:    if (bc_p == NULL || *bc_p++ != RE_OP_ALTERNATIVE_NEXT)
        -: 1572:    {
        -: 1573:      /* None of the alternatives matched. */
    #####: 1574:      return NULL;
        -: 1575:    }
        -: 1576:
        -: 1577:    /* Get the end of the new alternative and continue execution. */
    #####: 1578:    str_curr_p = str_start_p;
    #####: 1579:    const uint32_t offset = re_get_value (&bc_p);
    #####: 1580:    next_alternative_p = bc_p + offset;
        -: 1581:  }
        -: 1582:} /* ecma_regexp_run */
        -: 1583:
        -: 1584:/**
        -: 1585: * Match a RegExp at a specific position in the input string.
        -: 1586: *
        -: 1587: * @return pointer to the end of the matched sub-string
        -: 1588: *         NULL, if pattern did not match
        -: 1589: */
        -: 1590:static const lit_utf8_byte_t *
    #####: 1591:ecma_regexp_match (ecma_regexp_ctx_t *re_ctx_p, /**< RegExp matcher context */
        -: 1592:                   const uint8_t *bc_p, /**< pointer to the current RegExp bytecode */
        -: 1593:                   const lit_utf8_byte_t *str_curr_p) /**< input string pointer */
        -: 1594:{
    #####: 1595:  re_ctx_p->captures_p[RE_GLOBAL_CAPTURE].begin_p = str_curr_p;
        -: 1596:
    #####: 1597:  for (uint32_t i = 1; i < re_ctx_p->captures_count; ++i)
        -: 1598:  {
    #####: 1599:    re_ctx_p->captures_p[i].begin_p = NULL;
        -: 1600:  }
        -: 1601:
    #####: 1602:  return ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1603:} /* ecma_regexp_match */
        -: 1604:
        -: 1605:/*
        -: 1606: * Helper function to get the result of a capture
        -: 1607: *
        -: 1608: * @return string value, if capture is defined
        -: 1609: *         undefined, otherwise
        -: 1610: */
        -: 1611:ecma_value_t
    #####: 1612:ecma_regexp_get_capture_value (const ecma_regexp_capture_t *const capture_p) /**< capture */
        -: 1613:{
    #####: 1614:  if (ECMA_RE_IS_CAPTURE_DEFINED (capture_p))
        -: 1615:  {
    #####: 1616:    JERRY_ASSERT (capture_p->end_p >= capture_p->begin_p);
    #####: 1617:    const lit_utf8_size_t capture_size = (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p);
    #####: 1618:    ecma_string_t *const capture_str_p = ecma_new_ecma_string_from_utf8 (capture_p->begin_p, capture_size);
    #####: 1619:    return ecma_make_string_value (capture_str_p);
        -: 1620:  }
        -: 1621:
    #####: 1622:  return ECMA_VALUE_UNDEFINED;
        -: 1623:} /* ecma_regexp_get_capture_value */
        -: 1624:
        -: 1625:/**
        -: 1626: * Helper function to create a result array from the captures in a regexp context
        -: 1627: *
        -: 1628: * @return ecma value containing the created array object
        -: 1629: */
        -: 1630:static ecma_value_t
    #####: 1631:ecma_regexp_create_result_object (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -: 1632:                                  ecma_string_t *input_string_p, /**< input ecma string */
        -: 1633:                                  uint32_t index) /**< match index */
        -: 1634:{
    #####: 1635:  ecma_object_t *result_p = ecma_op_new_array_object (0);
        -: 1636:
    #####: 1637:  for (uint32_t i = 0; i < re_ctx_p->captures_count; i++)
        -: 1638:  {
    #####: 1639:    ecma_value_t capture_value = ecma_regexp_get_capture_value (re_ctx_p->captures_p + i);
    #####: 1640:    ecma_builtin_helper_def_prop_by_index (result_p, i, capture_value, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1641:    ecma_free_value (capture_value);
        -: 1642:  }
        -: 1643:
    #####: 1644:  ecma_builtin_helper_def_prop (result_p,
        -: 1645:                                ecma_get_magic_string (LIT_MAGIC_STRING_INDEX),
        -: 1646:                                ecma_make_uint32_value (index),
        -: 1647:                                ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1648:
    #####: 1649:  ecma_builtin_helper_def_prop (result_p,
        -: 1650:                                ecma_get_magic_string (LIT_MAGIC_STRING_INPUT),
        -: 1651:                                ecma_make_string_value (input_string_p),
        -: 1652:                                ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1653:
    #####: 1654:  return ecma_make_object_value (result_p);
        -: 1655:} /* ecma_regexp_create_result_object */
        -: 1656:
        -: 1657:/**
        -: 1658: * Helper function to initialize a regexp match context
        -: 1659: */
        -: 1660:static void
    #####: 1661:ecma_regexp_initialize_context (ecma_regexp_ctx_t *ctx_p, /**< regexp context */
        -: 1662:                                const re_compiled_code_t *bc_p, /**< regexp bytecode */
        -: 1663:                                const lit_utf8_byte_t *input_start_p, /**< pointer to input string */
        -: 1664:                                const lit_utf8_byte_t *input_end_p) /**< pointer to end of input string */
        -: 1665:{
    #####: 1666:  JERRY_ASSERT (ctx_p != NULL);
    #####: 1667:  JERRY_ASSERT (bc_p != NULL);
    #####: 1668:  JERRY_ASSERT (input_start_p != NULL);
    #####: 1669:  JERRY_ASSERT (input_end_p >= input_start_p);
        -: 1670:
    #####: 1671:  ctx_p->flags = bc_p->header.status_flags;
    #####: 1672:  ctx_p->char_size = (ctx_p->flags & RE_FLAG_UNICODE) ? sizeof (lit_code_point_t) : sizeof (ecma_char_t);
        -: 1673:
    #####: 1674:  ctx_p->input_start_p = input_start_p;
    #####: 1675:  ctx_p->input_end_p = input_end_p;
        -: 1676:
    #####: 1677:  ctx_p->captures_count = bc_p->captures_count;
    #####: 1678:  ctx_p->non_captures_count = bc_p->non_captures_count;
        -: 1679:
    #####: 1680:  ctx_p->captures_p = jmem_heap_alloc_block (ctx_p->captures_count * sizeof (ecma_regexp_capture_t));
        -: 1681:
    #####: 1682:  if (ctx_p->non_captures_count > 0)
        -: 1683:  {
    #####: 1684:    ctx_p->non_captures_p = jmem_heap_alloc_block (ctx_p->non_captures_count * sizeof (ecma_regexp_non_capture_t));
        -: 1685:  }
    #####: 1686:} /* ecma_regexp_initialize_context */
        -: 1687:
        -: 1688:/**
        -: 1689: * Helper function to clean up a regexp context
        -: 1690: */
        -: 1691:static void
    #####: 1692:ecma_regexp_cleanup_context (ecma_regexp_ctx_t *ctx_p) /**< regexp context */
        -: 1693:{
    #####: 1694:  JERRY_ASSERT (ctx_p != NULL);
    #####: 1695:  jmem_heap_free_block (ctx_p->captures_p, ctx_p->captures_count * sizeof (ecma_regexp_capture_t));
        -: 1696:
    #####: 1697:  if (ctx_p->non_captures_count > 0)
        -: 1698:  {
    #####: 1699:    jmem_heap_free_block (ctx_p->non_captures_p, ctx_p->non_captures_count * sizeof (ecma_regexp_non_capture_t));
        -: 1700:  }
    #####: 1701:} /* ecma_regexp_cleanup_context */
        -: 1702:
        -: 1703:/**
        -: 1704: * RegExp helper function to start the recursive matching algorithm
        -: 1705: * and create the result Array object
        -: 1706: *
        -: 1707: * See also:
        -: 1708: *          ECMA-262 v5, 15.10.6.2
        -: 1709: *          ECMA-262 v11, 21.2.5.2.2
        -: 1710: *
        -: 1711: * @return array object - if matched
        -: 1712: *         null         - otherwise
        -: 1713: *
        -: 1714: *         May raise error.
        -: 1715: *         Returned value must be freed with ecma_free_value
        -: 1716: */
        -: 1717:ecma_value_t
    #####: 1718:ecma_regexp_exec_helper (ecma_object_t *regexp_object_p, /**< RegExp object */
        -: 1719:                         ecma_string_t *input_string_p) /**< input string */
        -: 1720:{
    #####: 1721:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1722:
        -: 1723:  /* 1. */
    #####: 1724:  JERRY_ASSERT (ecma_object_is_regexp_object (ecma_make_object_value (regexp_object_p)));
        -: 1725:
        -: 1726:  /* 9. */
    #####: 1727:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) regexp_object_p;
    #####: 1728:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 1729:
        -: 1730:  /* 3. */
    #####: 1731:  lit_utf8_size_t input_size;
    #####: 1732:  lit_utf8_size_t input_length;
    #####: 1733:  uint8_t input_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1734:  const lit_utf8_byte_t *input_buffer_p =
        -: 1735:    ecma_string_get_chars (input_string_p, &input_size, &input_length, NULL, &input_flags);
        -: 1736:
    #####: 1737:  const lit_utf8_byte_t *input_curr_p = input_buffer_p;
    #####: 1738:  const lit_utf8_byte_t *input_end_p = input_buffer_p + input_size;
        -: 1739:
    #####: 1740:  ecma_regexp_ctx_t re_ctx;
    #####: 1741:  ecma_regexp_initialize_context (&re_ctx, bc_p, input_buffer_p, input_end_p);
        -: 1742:
        -: 1743:  /* 4. */
    #####: 1744:  ecma_length_t index = 0;
    #####: 1745:  ecma_value_t lastindex_value = ecma_op_object_get_by_magic_id (regexp_object_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 1746:
        -: 1747:#if JERRY_ESNEXT
    #####: 1748:  ret_value = ecma_op_to_length (lastindex_value, &index);
    #####: 1749:  ecma_free_value (lastindex_value);
        -: 1750:#else /* !JERRY_ESNEXT */
    #####: 1751:  ecma_number_t lastindex_num = 0.0f;
    #####: 1752:  ret_value = ecma_op_to_integer (lastindex_value, &lastindex_num);
    #####: 1753:  ecma_free_value (lastindex_value);
        -: 1754:
        -: 1755:  /* The ToInteger operation might have thrown an error, however in that case lastindex_num will still be zero,
        -: 1756:   * and the error will be handled later after the uint32 coercion. */
    #####: 1757:  if ((re_ctx.flags & RE_FLAG_GLOBAL) && lastindex_num < 0.0f)
        -: 1758:  {
        -: 1759:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (ret_value));
        -: 1760:    goto fail_put_lastindex;
        -: 1761:  }
        -: 1762:
    #####: 1763:  index = ecma_number_to_uint32 (lastindex_num);
        -: 1764:#endif /* JERRY_ESNEXT */
        -: 1765:
    #####: 1766:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1767:  {
    #####: 1768:    goto cleanup_context;
        -: 1769:  }
        -: 1770:
    #####: 1771:  if (re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY))
        -: 1772:  {
        -: 1773:    /* 12.a */
    #####: 1774:    if (index > input_length)
        -: 1775:    {
    #####: 1776:      goto fail_put_lastindex;
        -: 1777:    }
        -: 1778:
    #####: 1779:    if (index > 0)
        -: 1780:    {
    #####: 1781:      if (input_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 1782:      {
    #####: 1783:        input_curr_p += index;
        -: 1784:      }
        -: 1785:      else
        -: 1786:      {
    #####: 1787:        for (uint32_t i = 0; i < index; i++)
        -: 1788:        {
    #####: 1789:          lit_utf8_incr (&input_curr_p);
        -: 1790:        }
        -: 1791:      }
        -: 1792:    }
        -: 1793:  }
        -: 1794:  /* 8. */
        -: 1795:  else
        -: 1796:  {
    #####: 1797:    index = 0;
        -: 1798:  }
        -: 1799:
        -: 1800:  /* 9. */
    #####: 1801:  uint8_t *bc_start_p = (uint8_t *) (bc_p + 1);
        -: 1802:
        -: 1803:  /* 11. */
    #####: 1804:  const lit_utf8_byte_t *matched_p = NULL;
        -: 1805:
        -: 1806:  /* 12. */
    #####: 1807:  JERRY_ASSERT (index <= input_length);
        -: 1808:  while (true)
        -: 1809:  {
    #####: 1810:    matched_p = ecma_regexp_match (&re_ctx, bc_start_p, input_curr_p);
        -: 1811:
    #####: 1812:    if (matched_p != NULL)
        -: 1813:    {
    #####: 1814:      goto match_found;
        -: 1815:    }
        -: 1816:
        -: 1817:#if JERRY_ESNEXT
        -: 1818:    /* 12.c.i */
    #####: 1819:    if (re_ctx.flags & RE_FLAG_STICKY)
        -: 1820:    {
    #####: 1821:      goto fail_put_lastindex;
        -: 1822:    }
        -: 1823:#endif /* JERRY_ESNEXT */
        -: 1824:
        -: 1825:    /* 12.a */
    #####: 1826:    if (input_curr_p >= input_end_p)
        -: 1827:    {
    #####: 1828:      if (re_ctx.flags & RE_FLAG_GLOBAL)
        -: 1829:      {
    #####: 1830:        goto fail_put_lastindex;
        -: 1831:      }
        -: 1832:
    #####: 1833:      goto match_failed;
        -: 1834:    }
        -: 1835:
    #####: 1836:    JERRY_ASSERT (input_curr_p < input_end_p);
        -: 1837:
        -: 1838:    /* 12.c.ii */
    #####: 1839:    index++;
        -: 1840:
        -: 1841:#if JERRY_ESNEXT
    #####: 1842:    if (re_ctx.flags & RE_FLAG_UNICODE)
        -: 1843:    {
    #####: 1844:      const lit_code_point_t cp = ecma_regexp_unicode_advance (&input_curr_p, input_end_p);
        -: 1845:
    #####: 1846:      if (cp > LIT_UTF16_CODE_UNIT_MAX)
        -: 1847:      {
    #####: 1848:        index++;
        -: 1849:      }
        -: 1850:
    #####: 1851:      continue;
        -: 1852:    }
        -: 1853:#endif /* JERRY_ESNEXT */
        -: 1854:
    #####: 1855:    lit_utf8_incr (&input_curr_p);
        -: 1856:  }
        -: 1857:
        -: 1858:  JERRY_UNREACHABLE ();
        -: 1859:
    #####: 1860:fail_put_lastindex:
        -: 1861:  /* We should only get here if the regexp is global or sticky */
    #####: 1862:  JERRY_ASSERT ((re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY)) != 0);
        -: 1863:
    #####: 1864:  ret_value = ecma_op_object_put (regexp_object_p,
        -: 1865:                                  ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 1866:                                  ecma_make_integer_value (0),
        -: 1867:                                  true);
        -: 1868:
    #####: 1869:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1870:  {
    #####: 1871:    goto cleanup_context;
        -: 1872:  }
        -: 1873:
    #####: 1874:  JERRY_ASSERT (ecma_is_value_boolean (ret_value));
        -: 1875:
    #####: 1876:match_failed:
        -: 1877:  /* 12.a.ii */
    #####: 1878:  ret_value = ECMA_VALUE_NULL;
    #####: 1879:  goto cleanup_context;
        -: 1880:
    #####: 1881:match_found:
    #####: 1882:  JERRY_ASSERT (matched_p != NULL);
        -: 1883:
    #####: 1884:  if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1885:  {
    #####: 1886:    ret_value = ecma_raise_range_error (ECMA_ERR_STACK_LIMIT_EXCEEDED);
    #####: 1887:    goto cleanup_context;
        -: 1888:  }
        -: 1889:
    #####: 1890:  JERRY_ASSERT (index <= input_length);
        -: 1891:
        -: 1892:  /* 15. */
    #####: 1893:  if (re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY))
        -: 1894:  {
        -: 1895:    /* 13-14. */
        -: 1896:    lit_utf8_size_t match_length;
    #####: 1897:    const lit_utf8_byte_t *match_begin_p = re_ctx.captures_p[0].begin_p;
    #####: 1898:    const lit_utf8_byte_t *match_end_p = re_ctx.captures_p[0].end_p;
        -: 1899:
    #####: 1900:    if (input_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 1901:    {
    #####: 1902:      match_length = (lit_utf8_size_t) (match_end_p - match_begin_p);
        -: 1903:    }
        -: 1904:    else
        -: 1905:    {
    #####: 1906:      match_length = lit_utf8_string_length (match_begin_p, (lit_utf8_size_t) (match_end_p - match_begin_p));
        -: 1907:    }
        -: 1908:
    #####: 1909:    ret_value = ecma_op_object_put (regexp_object_p,
        -: 1910:                                    ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
    #####: 1911:                                    ecma_make_uint32_value ((uint32_t) index + match_length),
        -: 1912:                                    true);
        -: 1913:
    #####: 1914:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1915:    {
    #####: 1916:      goto cleanup_context;
        -: 1917:    }
        -: 1918:
    #####: 1919:    JERRY_ASSERT (ecma_is_value_boolean (ret_value));
        -: 1920:  }
        -: 1921:
        -: 1922:  /* 16-27. */
    #####: 1923:  ret_value = ecma_regexp_create_result_object (&re_ctx, input_string_p, (uint32_t) index);
        -: 1924:
    #####: 1925:cleanup_context:
    #####: 1926:  ecma_regexp_cleanup_context (&re_ctx);
        -: 1927:
    #####: 1928:  if (input_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1929:  {
    #####: 1930:    jmem_heap_free_block ((void *) input_buffer_p, input_size);
        -: 1931:  }
        -: 1932:
    #####: 1933:  return ret_value;
        -: 1934:} /* ecma_regexp_exec_helper */
        -: 1935:
        -: 1936:/**
        -: 1937: * Helper function for converting a RegExp pattern parameter to string.
        -: 1938: *
        -: 1939: * See also:
        -: 1940: *         RegExp.compile
        -: 1941: *         RegExp dispatch call
        -: 1942: *
        -: 1943: * @return empty value if success, error value otherwise
        -: 1944: *         Returned value must be freed with ecma_free_value.
        -: 1945: */
        -: 1946:ecma_string_t *
    #####: 1947:ecma_regexp_read_pattern_str_helper (ecma_value_t pattern_arg) /**< the RegExp pattern */
        -: 1948:{
    #####: 1949:  if (!ecma_is_value_undefined (pattern_arg))
        -: 1950:  {
    #####: 1951:    ecma_string_t *pattern_string_p = ecma_op_to_string (pattern_arg);
    #####: 1952:    if (JERRY_UNLIKELY (pattern_string_p == NULL) || !ecma_string_is_empty (pattern_string_p))
        -: 1953:    {
    #####: 1954:      return pattern_string_p;
        -: 1955:    }
        -: 1956:  }
        -: 1957:
    #####: 1958:  return ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP);
        -: 1959:} /* ecma_regexp_read_pattern_str_helper */
        -: 1960:
        -: 1961:/**
        -: 1962: * Helper function for RegExp based string searches
        -: 1963: *
        -: 1964: * See also:
        -: 1965: *          ECMA-262 v6, 21.2.5.9
        -: 1966: *
        -: 1967: * @return index of the match
        -: 1968: */
        -: 1969:ecma_value_t
    #####: 1970:ecma_regexp_search_helper (ecma_value_t regexp_arg, /**< regexp argument */
        -: 1971:                           ecma_value_t string_arg) /**< string argument */
        -: 1972:{
        -: 1973:  /* 2. */
    #####: 1974:  if (!ecma_is_value_object (regexp_arg))
        -: 1975:  {
    #####: 1976:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -: 1977:  }
        -: 1978:
    #####: 1979:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 1980:
        -: 1981:  /* 3. */
    #####: 1982:  ecma_string_t *const string_p = ecma_op_to_string (string_arg);
    #####: 1983:  if (string_p == NULL)
        -: 1984:  {
    #####: 1985:    return result;
        -: 1986:  }
        -: 1987:
    #####: 1988:  ecma_object_t *const regexp_object_p = ecma_get_object_from_value (regexp_arg);
        -: 1989:
        -: 1990:  /* 4. */
    #####: 1991:  ecma_string_t *const last_index_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 1992:  const ecma_value_t prev_last_index = ecma_op_object_get (regexp_object_p, last_index_str_p);
    #####: 1993:  if (ECMA_IS_VALUE_ERROR (prev_last_index))
        -: 1994:  {
    #####: 1995:    goto cleanup_string;
        -: 1996:  }
        -: 1997:
        -: 1998:  /* 5. */
    #####: 1999:  if (prev_last_index != ecma_make_uint32_value (0))
        -: 2000:  {
    #####: 2001:    const ecma_value_t status =
    #####: 2002:      ecma_op_object_put (regexp_object_p, last_index_str_p, ecma_make_uint32_value (0), true);
        -: 2003:
    #####: 2004:    if (ECMA_IS_VALUE_ERROR (status))
        -: 2005:    {
    #####: 2006:      goto cleanup_prev_last_index;
        -: 2007:    }
        -: 2008:
    #####: 2009:    JERRY_ASSERT (ecma_is_value_boolean (status));
        -: 2010:  }
        -: 2011:
        -: 2012:  /* 6. */
    #####: 2013:  const ecma_value_t match = ecma_op_regexp_exec (regexp_arg, string_p);
    #####: 2014:  if (ECMA_IS_VALUE_ERROR (match))
        -: 2015:  {
    #####: 2016:    goto cleanup_prev_last_index;
        -: 2017:  }
        -: 2018:
        -: 2019:  /* 7. */
    #####: 2020:  const ecma_value_t current_last_index = ecma_op_object_get (regexp_object_p, last_index_str_p);
    #####: 2021:  if (ECMA_IS_VALUE_ERROR (current_last_index))
        -: 2022:  {
    #####: 2023:    ecma_free_value (match);
    #####: 2024:    goto cleanup_prev_last_index;
        -: 2025:  }
        -: 2026:
    #####: 2027:  const bool same_value = ecma_op_same_value (prev_last_index, current_last_index);
        -: 2028:
    #####: 2029:  ecma_free_value (current_last_index);
        -: 2030:
        -: 2031:  /* 8. */
    #####: 2032:  if (!same_value)
        -: 2033:  {
    #####: 2034:    result = ecma_op_object_put (regexp_object_p, last_index_str_p, prev_last_index, true);
        -: 2035:
    #####: 2036:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2037:    {
    #####: 2038:      ecma_free_value (match);
    #####: 2039:      goto cleanup_prev_last_index;
        -: 2040:    }
        -: 2041:
    #####: 2042:    JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2043:  }
        -: 2044:
        -: 2045:  /* 9-10. */
    #####: 2046:  if (ecma_is_value_null (match))
        -: 2047:  {
    #####: 2048:    result = ecma_make_int32_value (-1);
        -: 2049:  }
        -: 2050:  else
        -: 2051:  {
    #####: 2052:    ecma_object_t *const match_p = ecma_get_object_from_value (match);
    #####: 2053:    result = ecma_op_object_get_by_magic_id (match_p, LIT_MAGIC_STRING_INDEX);
    #####: 2054:    ecma_deref_object (match_p);
        -: 2055:  }
        -: 2056:
    #####: 2057:cleanup_prev_last_index:
    #####: 2058:  ecma_free_value (prev_last_index);
        -: 2059:
    #####: 2060:cleanup_string:
    #####: 2061:  ecma_deref_ecma_string (string_p);
    #####: 2062:  return result;
        -: 2063:} /* ecma_regexp_search_helper */
        -: 2064:
        -: 2065:/**
        -: 2066: * Helper function for RegExp based string split operation
        -: 2067: *
        -: 2068: * See also:
        -: 2069: *          ECMA-262 v6, 21.2.5.11
        -: 2070: *
        -: 2071: * @return array of split and captured strings
        -: 2072: */
        -: 2073:ecma_value_t
    #####: 2074:ecma_regexp_split_helper (ecma_value_t this_arg, /**< this value */
        -: 2075:                          ecma_value_t string_arg, /**< string value */
        -: 2076:                          ecma_value_t limit_arg) /**< limit value */
        -: 2077:{
        -: 2078:#if JERRY_ESNEXT
        -: 2079:  /* 2. */
    #####: 2080:  if (!ecma_is_value_object (this_arg))
        -: 2081:  {
    #####: 2082:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -: 2083:  }
        -: 2084:
    #####: 2085:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2086:
        -: 2087:  /* 3-4. */
    #####: 2088:  ecma_string_t *const string_p = ecma_op_to_string (string_arg);
    #####: 2089:  if (string_p == NULL)
        -: 2090:  {
    #####: 2091:    return result;
        -: 2092:  }
        -: 2093:
        -: 2094:  /* 5-6. */
    #####: 2095:  ecma_object_t *const regexp_obj_p = ecma_get_object_from_value (this_arg);
    #####: 2096:  ecma_value_t constructor = ecma_op_species_constructor (regexp_obj_p, ECMA_BUILTIN_ID_REGEXP);
    #####: 2097:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2098:  {
    #####: 2099:    goto cleanup_string;
        -: 2100:  }
        -: 2101:
    #####: 2102:  ecma_object_t *const constructor_obj_p = ecma_get_object_from_value (constructor);
        -: 2103:
        -: 2104:  /* 7-8. */
    #####: 2105:  ecma_value_t flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
    #####: 2106:  if (ECMA_IS_VALUE_ERROR (flags))
        -: 2107:  {
    #####: 2108:    ecma_deref_object (constructor_obj_p);
    #####: 2109:    goto cleanup_string;
        -: 2110:  }
        -: 2111:
    #####: 2112:  ecma_string_t *flags_str_p = ecma_op_to_string (flags);
    #####: 2113:  ecma_free_value (flags);
        -: 2114:
    #####: 2115:  if (JERRY_UNLIKELY (flags_str_p == NULL))
        -: 2116:  {
    #####: 2117:    ecma_deref_object (constructor_obj_p);
    #####: 2118:    goto cleanup_string;
        -: 2119:  }
        -: 2120:
    #####: 2121:  lit_utf8_size_t flags_size;
    #####: 2122:  uint8_t flags_str_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2123:  const lit_utf8_byte_t *flags_buffer_p =
        -: 2124:    ecma_string_get_chars (flags_str_p, &flags_size, NULL, NULL, &flags_str_flags);
        -: 2125:
    #####: 2126:  bool unicode = false;
    #####: 2127:  bool sticky = false;
        -: 2128:
        -: 2129:  /* 9-11. */
    #####: 2130:  const lit_utf8_byte_t *const flags_end_p = flags_buffer_p + flags_size;
    #####: 2131:  for (const lit_utf8_byte_t *current_p = flags_buffer_p; current_p < flags_end_p; ++current_p)
        -: 2132:  {
    #####: 2133:    switch (*current_p)
        -: 2134:    {
    #####: 2135:      case LIT_CHAR_LOWERCASE_U:
        -: 2136:      {
    #####: 2137:        unicode = true;
    #####: 2138:        break;
        -: 2139:      }
    #####: 2140:      case LIT_CHAR_LOWERCASE_Y:
        -: 2141:      {
    #####: 2142:        sticky = true;
    #####: 2143:        break;
        -: 2144:      }
        -: 2145:    }
        -: 2146:  }
        -: 2147:
    #####: 2148:  if (flags_str_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2149:  {
    #####: 2150:    jmem_heap_free_block ((void *) flags_buffer_p, flags_size);
        -: 2151:  }
        -: 2152:
        -: 2153:  /* 12. */
    #####: 2154:  if (!sticky)
        -: 2155:  {
    #####: 2156:    ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (flags_str_p);
    #####: 2157:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_LOWERCASE_Y);
        -: 2158:
    #####: 2159:    ecma_deref_ecma_string (flags_str_p);
    #####: 2160:    flags_str_p = ecma_stringbuilder_finalize (&builder);
        -: 2161:  }
        -: 2162:
        -: 2163:  /* 13-14. */
    #####: 2164:  ecma_value_t arguments[] = { this_arg, ecma_make_string_value (flags_str_p) };
    #####: 2165:  ecma_value_t splitter = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, arguments, 2);
        -: 2166:
    #####: 2167:  ecma_deref_ecma_string (flags_str_p);
    #####: 2168:  ecma_deref_object (constructor_obj_p);
        -: 2169:
    #####: 2170:  if (ECMA_IS_VALUE_ERROR (splitter))
        -: 2171:  {
    #####: 2172:    goto cleanup_string;
        -: 2173:  }
        -: 2174:
    #####: 2175:  ecma_object_t *const splitter_obj_p = ecma_get_object_from_value (splitter);
        -: 2176:
        -: 2177:  /* 17. */
    #####: 2178:  uint32_t limit = UINT32_MAX - 1;
    #####: 2179:  if (!ecma_is_value_undefined (limit_arg))
        -: 2180:  {
        -: 2181:    /* ECMA-262 v11, 21.2.5.13 13 */
    #####: 2182:    ecma_number_t num;
    #####: 2183:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (limit_arg, &num)))
        -: 2184:    {
    #####: 2185:      goto cleanup_splitter;
        -: 2186:    }
    #####: 2187:    limit = ecma_number_to_uint32 (num);
        -: 2188:  }
        -: 2189:
        -: 2190:  /* 15. */
    #####: 2191:  ecma_object_t *const array_p = ecma_op_new_array_object (0);
    #####: 2192:  ecma_value_t array = ecma_make_object_value (array_p);
        -: 2193:
        -: 2194:  /* 21. */
    #####: 2195:  if (limit == 0)
        -: 2196:  {
    #####: 2197:    result = array;
    #####: 2198:    goto cleanup_splitter;
        -: 2199:  }
        -: 2200:
    #####: 2201:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
        -: 2202:
    #####: 2203:  uint32_t array_length = 0;
        -: 2204:
        -: 2205:  /* 22. */
    #####: 2206:  if (string_length == 0)
        -: 2207:  {
    #####: 2208:    const ecma_value_t match = ecma_op_regexp_exec (splitter, string_p);
        -: 2209:
    #####: 2210:    if (ECMA_IS_VALUE_ERROR (match))
        -: 2211:    {
    #####: 2212:      goto cleanup_array;
        -: 2213:    }
        -: 2214:
    #####: 2215:    if (ecma_is_value_null (match))
        -: 2216:    {
    #####: 2217:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2218:                                                      array_length,
        -: 2219:                                                      ecma_make_string_value (string_p),
        -: 2220:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2221:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2222:    }
        -: 2223:
    #####: 2224:    ecma_free_value (match);
    #####: 2225:    result = array;
    #####: 2226:    goto cleanup_splitter;
        -: 2227:  }
        -: 2228:
        -: 2229:  /* 23. */
    #####: 2230:  ecma_length_t current_index = 0;
    #####: 2231:  ecma_length_t previous_index = 0;
        -: 2232:
    #####: 2233:  ecma_string_t *const lastindex_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 2234:
        -: 2235:  /* 24. */
    #####: 2236:  while (current_index < string_length)
        -: 2237:  {
        -: 2238:    /* 24.a-b. */
    #####: 2239:    ecma_value_t index_value = ecma_make_length_value (current_index);
    #####: 2240:    result = ecma_op_object_put (splitter_obj_p, lastindex_str_p, index_value, true);
        -: 2241:
    #####: 2242:    ecma_free_value (index_value);
        -: 2243:
    #####: 2244:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2245:    {
    #####: 2246:      goto cleanup_array;
        -: 2247:    }
        -: 2248:
    #####: 2249:    JERRY_ASSERT (ecma_is_value_true (result));
        -: 2250:
        -: 2251:    /* 24.c-d. */
    #####: 2252:    result = ecma_op_regexp_exec (splitter, string_p);
    #####: 2253:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2254:    {
    #####: 2255:      goto cleanup_array;
        -: 2256:    }
        -: 2257:
        -: 2258:    /* 24.e. */
    #####: 2259:    if (ecma_is_value_null (result))
        -: 2260:    {
    #####: 2261:      current_index = ecma_op_advance_string_index (string_p, current_index, unicode);
    #####: 2262:      continue;
        -: 2263:    }
        -: 2264:
    #####: 2265:    ecma_object_t *const match_array_p = ecma_get_object_from_value (result);
        -: 2266:
        -: 2267:    /* 24.f.i. */
    #####: 2268:    result = ecma_op_object_get (splitter_obj_p, lastindex_str_p);
    #####: 2269:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2270:    {
    #####: 2271:      ecma_deref_object (match_array_p);
    #####: 2272:      goto cleanup_array;
        -: 2273:    }
        -: 2274:
    #####: 2275:    ecma_length_t end_index;
    #####: 2276:    const ecma_value_t length_value = ecma_op_to_length (result, &end_index);
    #####: 2277:    ecma_free_value (result);
        -: 2278:
    #####: 2279:    if (ECMA_IS_VALUE_ERROR (length_value))
        -: 2280:    {
    #####: 2281:      result = ECMA_VALUE_ERROR;
    #####: 2282:      ecma_deref_object (match_array_p);
    #####: 2283:      goto cleanup_array;
        -: 2284:    }
        -: 2285:
        -: 2286:    /* ECMA-262 v11, 21.2.5.11 19.d.ii */
    #####: 2287:    if (end_index > string_length)
        -: 2288:    {
    #####: 2289:      end_index = string_length;
        -: 2290:    }
        -: 2291:
        -: 2292:    /* 24.f.iii. */
    #####: 2293:    if (previous_index == end_index)
        -: 2294:    {
    #####: 2295:      ecma_deref_object (match_array_p);
    #####: 2296:      current_index = ecma_op_advance_string_index (string_p, current_index, unicode);
    #####: 2297:      continue;
        -: 2298:    }
        -: 2299:
        -: 2300:    /* 24.f.iv.1-4. */
    #####: 2301:    JERRY_ASSERT (previous_index <= string_length && current_index <= string_length);
    #####: 2302:    ecma_string_t *const split_str_p =
    #####: 2303:      ecma_string_substr (string_p, (lit_utf8_size_t) previous_index, (lit_utf8_size_t) current_index);
        -: 2304:
    #####: 2305:    result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2306:                                                    array_length++,
        -: 2307:                                                    ecma_make_string_value (split_str_p),
        -: 2308:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2309:    JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2310:    ecma_deref_ecma_string (split_str_p);
        -: 2311:
        -: 2312:    /* 24.f.iv.5. */
    #####: 2313:    if (array_length == limit)
        -: 2314:    {
    #####: 2315:      ecma_deref_object (match_array_p);
    #####: 2316:      result = array;
    #####: 2317:      goto cleanup_splitter;
        -: 2318:    }
        -: 2319:
        -: 2320:    /* 24.f.iv.6. */
    #####: 2321:    previous_index = end_index;
        -: 2322:
        -: 2323:    /* 24.f.iv.7-8. */
    #####: 2324:    ecma_length_t match_length;
    #####: 2325:    result = ecma_op_object_get_length (match_array_p, &match_length);
    #####: 2326:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2327:    {
    #####: 2328:      ecma_deref_object (match_array_p);
    #####: 2329:      goto cleanup_array;
        -: 2330:    }
        -: 2331:
        -: 2332:    /* 24.f.iv.9. */
    #####: 2333:    match_length = (match_length > 0) ? match_length - 1 : match_length;
        -: 2334:
    #####: 2335:    ecma_length_t match_index = 1;
    #####: 2336:    while (match_index <= match_length)
        -: 2337:    {
        -: 2338:      /* 24.f.iv.11.a-b. */
    #####: 2339:      result = ecma_op_object_get_by_index (match_array_p, match_index++);
    #####: 2340:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2341:      {
    #####: 2342:        ecma_deref_object (match_array_p);
    #####: 2343:        goto cleanup_array;
        -: 2344:      }
        -: 2345:
    #####: 2346:      const ecma_value_t capture = result;
        -: 2347:
        -: 2348:      /* 24.f.iv.11.c. */
    #####: 2349:      result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2350:                                                      array_length++,
        -: 2351:                                                      capture,
        -: 2352:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2353:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2354:
    #####: 2355:      ecma_free_value (capture);
        -: 2356:
    #####: 2357:      if (array_length == limit)
        -: 2358:      {
    #####: 2359:        ecma_deref_object (match_array_p);
    #####: 2360:        result = array;
    #####: 2361:        goto cleanup_splitter;
        -: 2362:      }
        -: 2363:    }
        -: 2364:
        -: 2365:    /* 24.f.iv.12. */
    #####: 2366:    JERRY_ASSERT (end_index <= UINT32_MAX);
    #####: 2367:    current_index = (uint32_t) end_index;
        -: 2368:
    #####: 2369:    ecma_deref_object (match_array_p);
        -: 2370:  }
        -: 2371:
    #####: 2372:  JERRY_ASSERT (previous_index <= string_length);
    #####: 2373:  ecma_string_t *const end_str_p = ecma_string_substr (string_p, (lit_utf8_size_t) previous_index, string_length);
    #####: 2374:  result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2375:                                                  array_length++,
        -: 2376:                                                  ecma_make_string_value (end_str_p),
        -: 2377:                                                  ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2378:  JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2379:  ecma_deref_ecma_string (end_str_p);
        -: 2380:
    #####: 2381:  result = array;
    #####: 2382:  goto cleanup_splitter;
        -: 2383:
    #####: 2384:cleanup_array:
    #####: 2385:  ecma_deref_object (array_p);
    #####: 2386:cleanup_splitter:
    #####: 2387:  ecma_deref_object (splitter_obj_p);
    #####: 2388:cleanup_string:
    #####: 2389:  ecma_deref_ecma_string (string_p);
        -: 2390:
    #####: 2391:  return result;
        -: 2392:#else /* !JERRY_ESNEXT */
    #####: 2393:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2394:
        -: 2395:  /* 2. */
    #####: 2396:  ecma_string_t *string_p = ecma_op_to_string (string_arg);
    #####: 2397:  if (JERRY_UNLIKELY (string_p == NULL))
        -: 2398:  {
        -: 2399:    return result;
        -: 2400:  }
        -: 2401:
        -: 2402:  /* 5. */
    #####: 2403:  uint32_t limit = UINT32_MAX;
    #####: 2404:  if (!ecma_is_value_undefined (limit_arg))
        -: 2405:  {
    #####: 2406:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (limit_arg, &limit)))
        -: 2407:    {
        -: 2408:      goto cleanup_string;
        -: 2409:    }
        -: 2410:  }
        -: 2411:
        -: 2412:  /* 15. */
    #####: 2413:  ecma_object_t *const array_p = ecma_op_new_array_object (0);
    #####: 2414:  ecma_value_t array = ecma_make_object_value (array_p);
        -: 2415:
        -: 2416:  /* 21. */
    #####: 2417:  if (limit == 0)
        -: 2418:  {
        -: 2419:    result = array;
        -: 2420:    goto cleanup_string;
        -: 2421:  }
        -: 2422:
    #####: 2423:  uint32_t array_length = 0;
        -: 2424:
    #####: 2425:  ecma_object_t *const regexp_p = ecma_get_object_from_value (this_arg);
    #####: 2426:  ecma_extended_object_t *const ext_object_p = (ecma_extended_object_t *) regexp_p;
    #####: 2427:  re_compiled_code_t *const bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 2428:
        -: 2429:  lit_utf8_size_t string_size;
        -: 2430:  lit_utf8_size_t string_length;
    #####: 2431:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2432:  const lit_utf8_byte_t *string_buffer_p =
        -: 2433:    ecma_string_get_chars (string_p, &string_size, &string_length, NULL, &string_flags);
        -: 2434:
    #####: 2435:  const lit_utf8_byte_t *current_str_p = string_buffer_p;
    #####: 2436:  const lit_utf8_byte_t *previous_str_p = string_buffer_p;
    #####: 2437:  const lit_utf8_byte_t *const string_end_p = string_buffer_p + string_size;
        -: 2438:
        -: 2439:  ecma_regexp_ctx_t re_ctx;
    #####: 2440:  ecma_regexp_initialize_context (&re_ctx, bc_p, string_buffer_p, string_buffer_p + string_size);
        -: 2441:
    #####: 2442:  uint8_t *const bc_start_p = (uint8_t *) (bc_p + 1);
        -: 2443:
    #####: 2444:  if (string_length == 0)
        -: 2445:  {
    #####: 2446:    const lit_utf8_byte_t *const matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_str_p);
        -: 2447:
        -: 2448:    if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2449:    {
        -: 2450:      result = ecma_raise_range_error (ECMA_ERR_STACK_LIMIT_EXCEEDED);
        -: 2451:      goto cleanup_array;
        -: 2452:    }
        -: 2453:
    #####: 2454:    if (matched_p == NULL)
        -: 2455:    {
    #####: 2456:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2457:                                                      array_length,
        -: 2458:                                                      ecma_make_string_value (string_p),
        -: 2459:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2460:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2461:    }
        -: 2462:
        -: 2463:    result = array;
        -: 2464:    goto cleanup_context;
        -: 2465:  }
        -: 2466:
        -: 2467:  /* 13. */
    #####: 2468:  while (current_str_p < string_end_p)
        -: 2469:  {
        -: 2470:    /* 13.a. */
    #####: 2471:    const lit_utf8_byte_t *const matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_str_p);
        -: 2472:
        -: 2473:    if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2474:    {
        -: 2475:      result = ecma_raise_range_error (ECMA_ERR_STACK_LIMIT_EXCEEDED);
        -: 2476:      goto cleanup_array;
        -: 2477:    }
        -: 2478:
    #####: 2479:    if (matched_p == NULL || matched_p == previous_str_p)
        -: 2480:    {
    #####: 2481:      lit_utf8_incr (&current_str_p);
    #####: 2482:      continue;
        -: 2483:    }
        -: 2484:
        -: 2485:    /* 13.c.iii.1. */
    #####: 2486:    ecma_string_t *const str_p =
    #####: 2487:      ecma_new_ecma_string_from_utf8 (previous_str_p, (lit_utf8_size_t) (current_str_p - previous_str_p));
        -: 2488:
    #####: 2489:    result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2490:                                                    array_length++,
        -: 2491:                                                    ecma_make_string_value (str_p),
        -: 2492:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2493:    JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2494:    ecma_deref_ecma_string (str_p);
        -: 2495:
    #####: 2496:    if (array_length == limit)
        -: 2497:    {
        -: 2498:      result = array;
        -: 2499:      goto cleanup_context;
        -: 2500:    }
        -: 2501:
        -: 2502:    /* 13.c.iii.5. */
        -: 2503:    previous_str_p = matched_p;
        -: 2504:
        -: 2505:    uint32_t index = 1;
    #####: 2506:    while (index < re_ctx.captures_count)
        -: 2507:    {
    #####: 2508:      const ecma_value_t capture = ecma_regexp_get_capture_value (re_ctx.captures_p + index);
    #####: 2509:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2510:                                                      array_length++,
        -: 2511:                                                      capture,
        -: 2512:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2513:      JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2514:      ecma_free_value (capture);
        -: 2515:
    #####: 2516:      if (array_length == limit)
        -: 2517:      {
        -: 2518:        result = array;
        -: 2519:        goto cleanup_context;
        -: 2520:      }
        -: 2521:
    #####: 2522:      index++;
        -: 2523:    }
        -: 2524:
        -: 2525:    /* 13.c.iii.8. */
    #####: 2526:    current_str_p = matched_p;
        -: 2527:  }
        -: 2528:
    #####: 2529:  ecma_string_t *const str_p =
    #####: 2530:    ecma_new_ecma_string_from_utf8 (previous_str_p, (lit_utf8_size_t) (string_end_p - previous_str_p));
        -: 2531:
    #####: 2532:  result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2533:                                                  array_length++,
        -: 2534:                                                  ecma_make_string_value (str_p),
        -: 2535:                                                  ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2536:  JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2537:  ecma_deref_ecma_string (str_p);
        -: 2538:
    #####: 2539:  result = array;
    #####: 2540:  goto cleanup_context;
        -: 2541:
        -: 2542:cleanup_array:
        -: 2543:  ecma_deref_object (array_p);
    #####: 2544:cleanup_context:
    #####: 2545:  ecma_regexp_cleanup_context (&re_ctx);
    #####: 2546:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2547:  {
    #####: 2548:    jmem_heap_free_block ((void *) string_buffer_p, string_size);
        -: 2549:  }
    #####: 2550:cleanup_string:
    #####: 2551:  ecma_deref_ecma_string (string_p);
        -: 2552:
    #####: 2553:  return result;
        -: 2554:#endif /* JERRY_ESNEXT */
        -: 2555:} /* ecma_regexp_split_helper */
        -: 2556:
        -: 2557:/**
        -: 2558: * Fast path for RegExp based replace operation
        -: 2559: *
        -: 2560: * This method assumes the following:
        -: 2561: *   - The RegExp object is a built-in RegExp
        -: 2562: *   - The 'exec' method of the RegExp object is the built-in 'exec' method
        -: 2563: *   - The 'lastIndex' property is writable
        -: 2564: *
        -: 2565: * The standard would normally require us to first execute the regexp and collect the results,
        -: 2566: * and after that iterate over the collected results and replace them.
        -: 2567: * The assumptions above guarantee that during the matching phase there will be no exceptions thrown,
        -: 2568: * which means we can do the match/replace in a single loop, without collecting the results.
        -: 2569: *
        -: 2570: * @return string value if successful
        -: 2571: *         thrown value otherwise
        -: 2572: */
        -: 2573:static ecma_value_t
    #####: 2574:ecma_regexp_replace_helper_fast (ecma_replace_context_t *ctx_p, /**<replace context */
        -: 2575:                                 ecma_extended_object_t *re_obj_p, /**< regexp object */
        -: 2576:                                 ecma_string_t *string_p, /**< source string */
        -: 2577:                                 ecma_value_t replace_arg) /**< replace argument */
        -: 2578:{
    #####: 2579:  const re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
    #####: 2580:  ecma_bytecode_ref ((ecma_compiled_code_t *) bc_p);
        -: 2581:
    #####: 2582:  JERRY_ASSERT (bc_p != NULL);
        -: 2583:
    #####: 2584:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2585:  lit_utf8_size_t string_length;
    #####: 2586:  ctx_p->string_p = ecma_string_get_chars (string_p, &(ctx_p->string_size), &string_length, NULL, &string_flags);
        -: 2587:
    #####: 2588:  const lit_utf8_byte_t *const string_end_p = ctx_p->string_p + ctx_p->string_size;
    #####: 2589:  const uint8_t *const bc_start_p = (const uint8_t *) (bc_p + 1);
    #####: 2590:  const lit_utf8_byte_t *matched_p = NULL;
    #####: 2591:  const lit_utf8_byte_t *current_p = ctx_p->string_p;
    #####: 2592:  const lit_utf8_byte_t *last_append_p = current_p;
    #####: 2593:  ecma_length_t index;
        -: 2594:
    #####: 2595:  ecma_regexp_ctx_t re_ctx;
    #####: 2596:  ecma_regexp_initialize_context (&re_ctx, bc_p, ctx_p->string_p, string_end_p);
        -: 2597:
        -: 2598:  /* lastIndex must be accessed to remain consistent with the standard, even though we may not need the value. */
    #####: 2599:  ecma_value_t lastindex_value =
        -: 2600:    ecma_op_object_get_by_magic_id ((ecma_object_t *) re_obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 2601:  ecma_value_t result = ecma_op_to_length (lastindex_value, &index);
    #####: 2602:  ecma_free_value (lastindex_value);
        -: 2603:
    #####: 2604:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2605:  {
    #####: 2606:    goto cleanup_context;
        -: 2607:  }
        -: 2608:
        -: 2609:#if JERRY_ESNEXT
        -: 2610:  /* Only non-global sticky matches use the lastIndex value, otherwise the starting index is 0. */
    #####: 2611:  if (JERRY_UNLIKELY ((ctx_p->flags & RE_FLAG_GLOBAL) == 0 && (re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2612:  {
    #####: 2613:    if (index > string_length)
        -: 2614:    {
    #####: 2615:      result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2616:                                   ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2617:                                   ecma_make_uint32_value (0),
        -: 2618:                                   true);
        -: 2619:
    #####: 2620:      if (!ECMA_IS_VALUE_ERROR (result))
        -: 2621:      {
    #####: 2622:        JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2623:        ecma_ref_ecma_string (string_p);
    #####: 2624:        result = ecma_make_string_value (string_p);
        -: 2625:      }
        -: 2626:
    #####: 2627:      goto cleanup_context;
        -: 2628:    }
        -: 2629:
    #####: 2630:    if (string_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 2631:    {
    #####: 2632:      current_p += index;
        -: 2633:    }
        -: 2634:    else
        -: 2635:    {
    #####: 2636:      ecma_length_t counter = index;
    #####: 2637:      while (counter--)
        -: 2638:      {
    #####: 2639:        lit_utf8_incr (&current_p);
        -: 2640:      }
        -: 2641:    }
        -: 2642:  }
        -: 2643:  else
        -: 2644:#endif /* JERRY_ESNEXT */
        -: 2645:  {
    #####: 2646:    index = 0;
        -: 2647:  }
        -: 2648:
    #####: 2649:  ctx_p->builder = ecma_stringbuilder_create ();
    #####: 2650:  ctx_p->capture_count = re_ctx.captures_count;
    #####: 2651:  ctx_p->u.captures_p = re_ctx.captures_p;
        -: 2652:
        -: 2653:  while (true)
        -: 2654:  {
    #####: 2655:    matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_p);
        -: 2656:
    #####: 2657:    if (matched_p != NULL)
        -: 2658:    {
    #####: 2659:      if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2660:      {
    #####: 2661:        result = ecma_raise_range_error (ECMA_ERR_STACK_LIMIT_EXCEEDED);
    #####: 2662:        goto cleanup_builder;
        -: 2663:      }
        -: 2664:
    #####: 2665:      const lit_utf8_size_t remaining_size = (lit_utf8_size_t) (current_p - last_append_p);
    #####: 2666:      ecma_stringbuilder_append_raw (&(ctx_p->builder), last_append_p, remaining_size);
        -: 2667:
    #####: 2668:      if (ctx_p->replace_str_p != NULL)
        -: 2669:      {
    #####: 2670:        ctx_p->matched_p = current_p;
    #####: 2671:        const ecma_regexp_capture_t *const global_capture_p = re_ctx.captures_p;
    #####: 2672:        ctx_p->matched_size = (lit_utf8_size_t) (global_capture_p->end_p - global_capture_p->begin_p);
    #####: 2673:        ctx_p->match_byte_pos = (lit_utf8_size_t) (current_p - re_ctx.input_start_p);
        -: 2674:
    #####: 2675:        ecma_builtin_replace_substitute (ctx_p);
        -: 2676:      }
        -: 2677:      else
        -: 2678:      {
    #####: 2679:        ecma_collection_t *arguments_p = ecma_new_collection ();
        -: 2680:
    #####: 2681:        for (uint32_t i = 0; i < re_ctx.captures_count; i++)
        -: 2682:        {
    #####: 2683:          ecma_value_t capture = ecma_regexp_get_capture_value (re_ctx.captures_p + i);
    #####: 2684:          ecma_collection_push_back (arguments_p, capture);
        -: 2685:        }
        -: 2686:
    #####: 2687:        ecma_collection_push_back (arguments_p, ecma_make_length_value (index));
    #####: 2688:        ecma_ref_ecma_string (string_p);
    #####: 2689:        ecma_collection_push_back (arguments_p, ecma_make_string_value (string_p));
    #####: 2690:        ecma_object_t *function_p = ecma_get_object_from_value (replace_arg);
        -: 2691:
    #####: 2692:        result =
    #####: 2693:          ecma_op_function_call (function_p, ECMA_VALUE_UNDEFINED, arguments_p->buffer_p, arguments_p->item_count);
        -: 2694:
    #####: 2695:        ecma_collection_free (arguments_p);
        -: 2696:
    #####: 2697:        if (ECMA_IS_VALUE_ERROR (result))
        -: 2698:        {
    #####: 2699:          goto cleanup_builder;
        -: 2700:        }
        -: 2701:
        -: 2702:        /* 16.m.v */
    #####: 2703:        ecma_string_t *const replace_result_p = ecma_op_to_string (result);
    #####: 2704:        ecma_free_value (result);
        -: 2705:
    #####: 2706:        if (replace_result_p == NULL)
        -: 2707:        {
    #####: 2708:          result = ECMA_VALUE_ERROR;
    #####: 2709:          goto cleanup_builder;
        -: 2710:        }
        -: 2711:
    #####: 2712:        ecma_stringbuilder_append (&(ctx_p->builder), replace_result_p);
    #####: 2713:        ecma_deref_ecma_string (replace_result_p);
        -: 2714:      }
        -: 2715:
    #####: 2716:      const ecma_regexp_capture_t *global_capture_p = re_ctx.captures_p;
    #####: 2717:      last_append_p = global_capture_p->end_p;
        -: 2718:
    #####: 2719:      const lit_utf8_size_t matched_size = (lit_utf8_size_t) (global_capture_p->end_p - global_capture_p->begin_p);
        -: 2720:
    #####: 2721:      const bool is_ascii = (string_flags & ECMA_STRING_FLAG_IS_ASCII) != 0;
    #####: 2722:      index += is_ascii ? matched_size : lit_utf8_string_length (current_p, matched_size);
        -: 2723:
    #####: 2724:      if (!(ctx_p->flags & RE_FLAG_GLOBAL))
        -: 2725:      {
        -: 2726:#if JERRY_ESNEXT
    #####: 2727:        if (JERRY_UNLIKELY ((re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2728:        {
    #####: 2729:          ecma_value_t index_value = ecma_make_length_value (index);
    #####: 2730:          result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2731:                                       ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2732:                                       index_value,
        -: 2733:                                       true);
        -: 2734:
    #####: 2735:          ecma_free_value (index_value);
        -: 2736:
    #####: 2737:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2738:          {
    #####: 2739:            goto cleanup_builder;
        -: 2740:          }
        -: 2741:        }
        -: 2742:#endif /* JERRY_ESNEXT */
        -: 2743:
    #####: 2744:        break;
        -: 2745:      }
        -: 2746:
    #####: 2747:      if (matched_size > 0)
        -: 2748:      {
    #####: 2749:        current_p = last_append_p;
    #####: 2750:        continue;
        -: 2751:      }
        -: 2752:    }
        -: 2753:#if JERRY_ESNEXT
    #####: 2754:    else if (JERRY_UNLIKELY ((re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2755:    {
    #####: 2756:      result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2757:                                   ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2758:                                   ecma_make_uint32_value (0),
        -: 2759:                                   true);
        -: 2760:
    #####: 2761:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2762:      {
    #####: 2763:        goto cleanup_builder;
        -: 2764:      }
        -: 2765:
    #####: 2766:      break;
        -: 2767:    }
        -: 2768:#endif /* JERRY_ESNEXT */
        -: 2769:
    #####: 2770:    if (current_p >= string_end_p)
        -: 2771:    {
    #####: 2772:      break;
        -: 2773:    }
        -: 2774:
        -: 2775:#if JERRY_ESNEXT
    #####: 2776:    if ((ctx_p->flags & RE_FLAG_UNICODE) != 0)
        -: 2777:    {
    #####: 2778:      index++;
    #####: 2779:      const lit_code_point_t cp = ecma_regexp_unicode_advance (&current_p, string_end_p);
        -: 2780:
    #####: 2781:      if (cp > LIT_UTF16_CODE_UNIT_MAX)
        -: 2782:      {
    #####: 2783:        index++;
        -: 2784:      }
        -: 2785:
    #####: 2786:      continue;
        -: 2787:    }
        -: 2788:#endif /* JERRY_ESNEXT */
        -: 2789:
    #####: 2790:    index++;
    #####: 2791:    lit_utf8_incr (&current_p);
        -: 2792:  }
        -: 2793:
    #####: 2794:  const lit_utf8_size_t trailing_size = (lit_utf8_size_t) (string_end_p - last_append_p);
    #####: 2795:  ecma_stringbuilder_append_raw (&(ctx_p->builder), last_append_p, trailing_size);
        -: 2796:
    #####: 2797:  result = ecma_make_string_value (ecma_stringbuilder_finalize (&(ctx_p->builder)));
    #####: 2798:  goto cleanup_context;
        -: 2799:
    #####: 2800:cleanup_builder:
    #####: 2801:  ecma_stringbuilder_destroy (&(ctx_p->builder));
        -: 2802:
    #####: 2803:cleanup_context:
    #####: 2804:  ecma_regexp_cleanup_context (&re_ctx);
    #####: 2805:  ecma_bytecode_deref ((ecma_compiled_code_t *) bc_p);
        -: 2806:
    #####: 2807:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2808:  {
    #####: 2809:    jmem_heap_free_block ((void *) ctx_p->string_p, ctx_p->string_size);
        -: 2810:  }
        -: 2811:
    #####: 2812:  return result;
        -: 2813:} /* ecma_regexp_replace_helper_fast */
        -: 2814:
        -: 2815:/**
        -: 2816: * Helper function for RegExp based replacing
        -: 2817: *
        -: 2818: * See also:
        -: 2819: *          String.prototype.replace
        -: 2820: *          RegExp.prototype[@@replace]
        -: 2821: *
        -: 2822: * @return result string of the replacement, if successful
        -: 2823: *         error value, otherwise
        -: 2824: */
        -: 2825:ecma_value_t
    #####: 2826:ecma_regexp_replace_helper (ecma_value_t this_arg, /**< this argument */
        -: 2827:                            ecma_value_t string_arg, /**< source string */
        -: 2828:                            ecma_value_t replace_arg) /**< replace string */
        -: 2829:{
        -: 2830:  /* 2. */
    #####: 2831:  if (!ecma_is_value_object (this_arg))
        -: 2832:  {
    #####: 2833:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -: 2834:  }
        -: 2835:
    #####: 2836:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
        -: 2837:
    #####: 2838:  ecma_replace_context_t replace_ctx;
    #####: 2839:  replace_ctx.flags = RE_FLAG_EMPTY;
        -: 2840:
        -: 2841:  /* 3. */
    #####: 2842:  ecma_string_t *string_p = ecma_op_to_string (string_arg);
    #####: 2843:  if (string_p == NULL)
        -: 2844:  {
    #####: 2845:    return ECMA_VALUE_ERROR;
        -: 2846:  }
        -: 2847:
    #####: 2848:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2849:
        -: 2850:  /* 6. */
    #####: 2851:  replace_ctx.replace_str_p = NULL;
    #####: 2852:  if (!ecma_op_is_callable (replace_arg))
        -: 2853:  {
    #####: 2854:    replace_ctx.replace_str_p = ecma_op_to_string (replace_arg);
        -: 2855:
    #####: 2856:    if (replace_ctx.replace_str_p == NULL)
        -: 2857:    {
    #####: 2858:      goto cleanup_string;
        -: 2859:    }
        -: 2860:  }
        -: 2861:
        -: 2862:  /* 8 */
    #####: 2863:  result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_GLOBAL);
    #####: 2864:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2865:  {
    #####: 2866:    goto cleanup_replace;
        -: 2867:  }
        -: 2868:
    #####: 2869:  if (ecma_op_to_boolean (result))
        -: 2870:  {
    #####: 2871:    replace_ctx.flags |= RE_FLAG_GLOBAL;
        -: 2872:  }
        -: 2873:
    #####: 2874:  ecma_free_value (result);
        -: 2875:
        -: 2876:#if JERRY_ESNEXT
    #####: 2877:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
        -: 2878:#endif /* JERRY_ESNEXT */
        -: 2879:
        -: 2880:  /* 10. */
    #####: 2881:  if (replace_ctx.flags & RE_FLAG_GLOBAL)
        -: 2882:  {
        -: 2883:#if JERRY_ESNEXT
    #####: 2884:    result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_UNICODE);
    #####: 2885:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2886:    {
    #####: 2887:      goto cleanup_replace;
        -: 2888:    }
        -: 2889:
    #####: 2890:    if (ecma_op_to_boolean (result))
        -: 2891:    {
    #####: 2892:      replace_ctx.flags |= RE_FLAG_UNICODE;
        -: 2893:    }
        -: 2894:
    #####: 2895:    ecma_free_value (result);
        -: 2896:#endif /* JERRY_ESNEXT */
        -: 2897:
    #####: 2898:    result = ecma_op_object_put (this_obj_p,
        -: 2899:                                 ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2900:                                 ecma_make_uint32_value (0),
        -: 2901:                                 true);
    #####: 2902:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2903:    {
    #####: 2904:      goto cleanup_replace;
        -: 2905:    }
        -: 2906:
    #####: 2907:    JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2908:  }
        -: 2909:
        -: 2910:#if !JERRY_ESNEXT
    #####: 2911:  result = ecma_regexp_replace_helper_fast (&replace_ctx, (ecma_extended_object_t *) this_obj_p, string_p, replace_arg);
        -: 2912:
    #####: 2913:  goto cleanup_replace;
        -: 2914:#else /* JERRY_ESNEXT */
    #####: 2915:  result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 2916:
    #####: 2917:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2918:  {
    #####: 2919:    goto cleanup_replace;
        -: 2920:  }
        -: 2921:
        -: 2922:  /* Check for fast path. */
    #####: 2923:  if (ecma_op_is_callable (result))
        -: 2924:  {
    #####: 2925:    ecma_extended_object_t *function_p = (ecma_extended_object_t *) ecma_get_object_from_value (result);
    #####: 2926:    if (ecma_object_class_is (this_obj_p, ECMA_OBJECT_CLASS_REGEXP) && ecma_builtin_is_regexp_exec (function_p))
        -: 2927:    {
    #####: 2928:      ecma_deref_object ((ecma_object_t *) function_p);
        -: 2929:
    #####: 2930:      result =
        -: 2931:        ecma_regexp_replace_helper_fast (&replace_ctx, (ecma_extended_object_t *) this_obj_p, string_p, replace_arg);
        -: 2932:
    #####: 2933:      goto cleanup_replace;
        -: 2934:    }
        -: 2935:  }
        -: 2936:
    #####: 2937:  ecma_collection_t *results_p = ecma_new_collection ();
        -: 2938:
        -: 2939:  while (true)
    #####: 2940:  {
        -: 2941:    /* 13.a */
    #####: 2942:    if (ecma_op_is_callable (result))
        -: 2943:    {
    #####: 2944:      ecma_object_t *const function_p = ecma_get_object_from_value (result);
        -: 2945:
    #####: 2946:      ecma_value_t arguments[] = { ecma_make_string_value (string_p) };
    #####: 2947:      result = ecma_op_function_call (function_p, this_arg, arguments, 1);
        -: 2948:
    #####: 2949:      ecma_deref_object (function_p);
        -: 2950:
    #####: 2951:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2952:      {
    #####: 2953:        goto cleanup_results;
        -: 2954:      }
        -: 2955:
    #####: 2956:      if (!ecma_is_value_object (result) && !ecma_is_value_null (result))
        -: 2957:      {
    #####: 2958:        ecma_free_value (result);
    #####: 2959:        result = ecma_raise_type_error (ECMA_ERR_RETURN_VALUE_OF_EXEC_MUST_BE_AN_OBJECT_OR_NULL);
    #####: 2960:        goto cleanup_results;
        -: 2961:      }
        -: 2962:    }
        -: 2963:    else
        -: 2964:    {
    #####: 2965:      ecma_free_value (result);
        -: 2966:
    #####: 2967:      if (!ecma_object_class_is (this_obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -: 2968:      {
    #####: 2969:        result = ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_REG_EXP_OBJECT);
    #####: 2970:        goto cleanup_results;
        -: 2971:      }
        -: 2972:
    #####: 2973:      result = ecma_regexp_exec_helper (this_obj_p, string_p);
        -: 2974:    }
        -: 2975:
        -: 2976:    /* 13.c */
    #####: 2977:    if (ecma_is_value_null (result))
        -: 2978:    {
    #####: 2979:      break;
        -: 2980:    }
        -: 2981:
        -: 2982:    /* 13.d.i */
    #####: 2983:    ecma_collection_push_back (results_p, result);
        -: 2984:
    #####: 2985:    if ((replace_ctx.flags & RE_FLAG_GLOBAL) == 0)
        -: 2986:    {
    #####: 2987:      break;
        -: 2988:    }
        -: 2989:
        -: 2990:    /* 13.d.iii.1 */
    #####: 2991:    result = ecma_op_object_get_by_index (ecma_get_object_from_value (result), 0);
    #####: 2992:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2993:    {
    #####: 2994:      goto cleanup_results;
        -: 2995:    }
        -: 2996:
    #####: 2997:    ecma_string_t *match_str_p = ecma_op_to_string (result);
    #####: 2998:    ecma_free_value (result);
        -: 2999:
    #####: 3000:    if (match_str_p == NULL)
        -: 3001:    {
    #####: 3002:      result = ECMA_VALUE_ERROR;
    #####: 3003:      goto cleanup_results;
        -: 3004:    }
        -: 3005:
    #####: 3006:    const bool is_empty = ecma_string_is_empty (match_str_p);
    #####: 3007:    ecma_deref_ecma_string (match_str_p);
        -: 3008:
        -: 3009:    /* 13.d.iii.3 */
    #####: 3010:    if (is_empty)
        -: 3011:    {
    #####: 3012:      result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 3013:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3014:      {
    #####: 3015:        goto cleanup_results;
        -: 3016:      }
        -: 3017:
    #####: 3018:      ecma_value_t last_index = result;
        -: 3019:
    #####: 3020:      ecma_length_t index;
    #####: 3021:      result = ecma_op_to_length (last_index, &index);
    #####: 3022:      ecma_free_value (last_index);
        -: 3023:
    #####: 3024:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3025:      {
    #####: 3026:        goto cleanup_results;
        -: 3027:      }
        -: 3028:
    #####: 3029:      index = ecma_op_advance_string_index (string_p, index, (replace_ctx.flags & RE_FLAG_UNICODE) != 0);
    #####: 3030:      last_index = ecma_make_length_value (index);
        -: 3031:
        -: 3032:      /* 10.d.iii.3.c */
    #####: 3033:      result = ecma_op_object_put (this_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), last_index, true);
        -: 3034:
    #####: 3035:      ecma_free_value (last_index);
        -: 3036:
    #####: 3037:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3038:      {
    #####: 3039:        goto cleanup_results;
        -: 3040:      }
        -: 3041:
    #####: 3042:      JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3043:    }
        -: 3044:
    #####: 3045:    result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 3046:
    #####: 3047:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3048:    {
    #####: 3049:      goto cleanup_results;
        -: 3050:    }
        -: 3051:  }
        -: 3052:
    #####: 3053:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 3054:  replace_ctx.string_p = ecma_string_get_chars (string_p, &(replace_ctx.string_size), NULL, NULL, &string_flags);
        -: 3055:
        -: 3056:  /* 14. */
    #####: 3057:  replace_ctx.builder = ecma_stringbuilder_create ();
    #####: 3058:  replace_ctx.matched_p = NULL;
    #####: 3059:  replace_ctx.capture_count = 0;
    #####: 3060:  lit_utf8_size_t index = 0;
        -: 3061:
        -: 3062:  /* 15. */
    #####: 3063:  const lit_utf8_byte_t *source_position_p = replace_ctx.string_p;
    #####: 3064:  const lit_utf8_byte_t *const string_end_p = replace_ctx.string_p + replace_ctx.string_size;
        -: 3065:
        -: 3066:  /* 16. */
    #####: 3067:  for (ecma_value_t *current_p = results_p->buffer_p; current_p < results_p->buffer_p + results_p->item_count;
    #####: 3068:       current_p++)
        -: 3069:  {
        -: 3070:    /* 16.a */
    #####: 3071:    ecma_object_t *current_object_p = ecma_get_object_from_value (*current_p);
        -: 3072:
    #####: 3073:    ecma_length_t capture_count;
    #####: 3074:    result = ecma_op_object_get_length (current_object_p, &capture_count);
    #####: 3075:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3076:    {
    #####: 3077:      goto cleanup_builder;
        -: 3078:    }
        -: 3079:
        -: 3080:    /* 16.c */
    #####: 3081:    capture_count = (capture_count > 0) ? capture_count - 1 : capture_count;
        -: 3082:
        -: 3083:    /* 16.d */
    #####: 3084:    result = ecma_op_object_get_by_index (current_object_p, 0);
    #####: 3085:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3086:    {
    #####: 3087:      goto cleanup_builder;
        -: 3088:    }
        -: 3089:
    #####: 3090:    ecma_string_t *matched_str_p = ecma_op_to_string (result);
    #####: 3091:    ecma_free_value (result);
        -: 3092:
        -: 3093:    /* 16.e */
    #####: 3094:    if (matched_str_p == NULL)
        -: 3095:    {
    #####: 3096:      result = ECMA_VALUE_ERROR;
    #####: 3097:      goto cleanup_builder;
        -: 3098:    }
        -: 3099:
        -: 3100:    /* 16.g */
    #####: 3101:    result = ecma_op_object_get_by_magic_id (current_object_p, LIT_MAGIC_STRING_INDEX);
    #####: 3102:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3103:    {
    #####: 3104:      ecma_deref_ecma_string (matched_str_p);
    #####: 3105:      goto cleanup_builder;
        -: 3106:    }
        -: 3107:
    #####: 3108:    const ecma_value_t index_value = result;
        -: 3109:
    #####: 3110:    ecma_number_t position_num;
    #####: 3111:    result = ecma_op_to_integer (index_value, &position_num);
    #####: 3112:    ecma_free_value (index_value);
        -: 3113:
    #####: 3114:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3115:    {
    #####: 3116:      ecma_deref_ecma_string (matched_str_p);
    #####: 3117:      goto cleanup_builder;
        -: 3118:    }
        -: 3119:
        -: 3120:    /* 16.i */
    #####: 3121:    lit_utf8_size_t position = JERRY_MIN ((lit_utf8_size_t) JERRY_MAX (position_num, 0.0f), string_length);
        -: 3122:
        -: 3123:    /* 16.k */
    #####: 3124:    ecma_collection_t *arguments_p = ecma_new_collection ();
    #####: 3125:    ecma_collection_push_back (arguments_p, ecma_make_string_value (matched_str_p));
        -: 3126:
        -: 3127:    /* 16.j, l */
    #####: 3128:    ecma_length_t n = 1;
    #####: 3129:    while (n <= capture_count)
        -: 3130:    {
    #####: 3131:      result = ecma_op_object_get_by_index (current_object_p, n);
    #####: 3132:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3133:      {
    #####: 3134:        ecma_collection_free (arguments_p);
    #####: 3135:        goto cleanup_builder;
        -: 3136:      }
        -: 3137:
        -: 3138:      /* 16.l.iii */
    #####: 3139:      if (!ecma_is_value_undefined (result))
        -: 3140:      {
    #####: 3141:        ecma_string_t *capture_str_p = ecma_op_to_string (result);
    #####: 3142:        ecma_free_value (result);
        -: 3143:
    #####: 3144:        if (capture_str_p == NULL)
        -: 3145:        {
    #####: 3146:          ecma_collection_free (arguments_p);
    #####: 3147:          result = ECMA_VALUE_ERROR;
    #####: 3148:          goto cleanup_builder;
        -: 3149:        }
        -: 3150:
    #####: 3151:        result = ecma_make_string_value (capture_str_p);
        -: 3152:      }
        -: 3153:
        -: 3154:      /* 16.l.iv */
    #####: 3155:      ecma_collection_push_back (arguments_p, result);
    #####: 3156:      n++;
        -: 3157:    }
        -: 3158:
    #####: 3159:    const bool should_replace = (position >= index);
        -: 3160:    /* 16.p */
    #####: 3161:    if (should_replace)
        -: 3162:    {
    #####: 3163:      const lit_utf8_byte_t *match_position_p;
    #####: 3164:      const lit_utf8_size_t matched_str_size = ecma_string_get_size (matched_str_p);
    #####: 3165:      const lit_utf8_size_t matched_str_length = ecma_string_get_length (matched_str_p);
        -: 3166:
    #####: 3167:      if (string_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 3168:      {
    #####: 3169:        match_position_p = replace_ctx.string_p + position;
        -: 3170:      }
        -: 3171:      else
        -: 3172:      {
    #####: 3173:        match_position_p = source_position_p;
    #####: 3174:        lit_utf8_size_t distance = position - index;
    #####: 3175:        while (distance--)
        -: 3176:        {
    #####: 3177:          lit_utf8_incr (&match_position_p);
        -: 3178:        }
        -: 3179:      }
        -: 3180:
    #####: 3181:      ecma_stringbuilder_append_raw (&replace_ctx.builder,
        -: 3182:                                     source_position_p,
    #####: 3183:                                     (lit_utf8_size_t) (match_position_p - source_position_p));
    #####: 3184:      replace_ctx.match_byte_pos = (lit_utf8_size_t) (match_position_p - replace_ctx.string_p);
        -: 3185:
    #####: 3186:      if ((string_flags & ECMA_STRING_FLAG_IS_ASCII) && matched_str_size == matched_str_length)
        -: 3187:      {
    #####: 3188:        source_position_p = JERRY_MIN (match_position_p + matched_str_size, string_end_p);
        -: 3189:      }
        -: 3190:      else
        -: 3191:      {
    #####: 3192:        lit_utf8_size_t code_unit_count = matched_str_length;
        -: 3193:
    #####: 3194:        while (code_unit_count-- > 0 && JERRY_LIKELY (match_position_p < string_end_p))
        -: 3195:        {
    #####: 3196:          lit_utf8_incr (&match_position_p);
        -: 3197:        }
        -: 3198:
    #####: 3199:        source_position_p = match_position_p;
        -: 3200:      }
        -: 3201:
    #####: 3202:      index = JERRY_MIN (position + matched_str_length, string_length);
        -: 3203:    }
        -: 3204:
        -: 3205:    /* 16.m */
    #####: 3206:    if (replace_ctx.replace_str_p == NULL)
        -: 3207:    {
        -: 3208:      /* 16.m.i-ii.
        -: 3209:       * arguments_p already contains <<Matched, cap1, cap2, ..., capN>> */
        -: 3210:
        -: 3211:      /* 16.m.iii */
    #####: 3212:      ecma_collection_push_back (arguments_p, ecma_make_uint32_value (position));
    #####: 3213:      ecma_ref_ecma_string (string_p);
    #####: 3214:      ecma_collection_push_back (arguments_p, ecma_make_string_value (string_p));
        -: 3215:
    #####: 3216:      result = ecma_op_function_call (ecma_get_object_from_value (replace_arg),
        -: 3217:                                      ECMA_VALUE_UNDEFINED,
    #####: 3218:                                      arguments_p->buffer_p,
        -: 3219:                                      arguments_p->item_count);
        -: 3220:
    #####: 3221:      ecma_collection_free (arguments_p);
        -: 3222:
    #####: 3223:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3224:      {
    #####: 3225:        goto cleanup_builder;
        -: 3226:      }
        -: 3227:
        -: 3228:      /* 16.m.v */
    #####: 3229:      ecma_string_t *const replace_result_p = ecma_op_to_string (result);
    #####: 3230:      ecma_free_value (result);
        -: 3231:
    #####: 3232:      if (replace_result_p == NULL)
        -: 3233:      {
    #####: 3234:        result = ECMA_VALUE_ERROR;
    #####: 3235:        goto cleanup_builder;
        -: 3236:      }
        -: 3237:
        -: 3238:      /* 16.m/p */
    #####: 3239:      if (should_replace)
        -: 3240:      {
    #####: 3241:        ecma_stringbuilder_append (&replace_ctx.builder, replace_result_p);
        -: 3242:      }
        -: 3243:
    #####: 3244:      ecma_deref_ecma_string (replace_result_p);
        -: 3245:    }
        -: 3246:    else
        -: 3247:    {
        -: 3248:      /* 16.n/p */
    #####: 3249:      if (should_replace)
        -: 3250:      {
    #####: 3251:        replace_ctx.u.collection_p = arguments_p;
    #####: 3252:        ecma_builtin_replace_substitute (&replace_ctx);
        -: 3253:      }
        -: 3254:
    #####: 3255:      ecma_collection_free (arguments_p);
        -: 3256:    }
        -: 3257:  }
        -: 3258:
        -: 3259:  /* 18. */
    #####: 3260:  JERRY_ASSERT (index <= string_length);
    #####: 3261:  ecma_stringbuilder_append_raw (&(replace_ctx.builder),
        -: 3262:                                 source_position_p,
    #####: 3263:                                 (lit_utf8_size_t) (string_end_p - source_position_p));
        -: 3264:
    #####: 3265:  result = ecma_make_string_value (ecma_stringbuilder_finalize (&replace_ctx.builder));
    #####: 3266:  goto cleanup_chars;
        -: 3267:
    #####: 3268:cleanup_builder:
    #####: 3269:  ecma_stringbuilder_destroy (&replace_ctx.builder);
        -: 3270:
    #####: 3271:cleanup_chars:
    #####: 3272:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 3273:  {
    #####: 3274:    jmem_heap_free_block ((void *) replace_ctx.string_p, replace_ctx.string_size);
        -: 3275:  }
        -: 3276:
    #####: 3277:cleanup_results:
    #####: 3278:  ecma_collection_free (results_p);
        -: 3279:#endif /* !JERRY_ESNEXT */
        -: 3280:
    #####: 3281:cleanup_replace:
    #####: 3282:  if (replace_ctx.replace_str_p != NULL)
        -: 3283:  {
    #####: 3284:    ecma_deref_ecma_string (replace_ctx.replace_str_p);
        -: 3285:  }
        -: 3286:
    #####: 3287:cleanup_string:
    #####: 3288:  ecma_deref_ecma_string (string_p);
        -: 3289:
    #####: 3290:  return result;
        -: 3291:} /* ecma_regexp_replace_helper */
        -: 3292:
        -: 3293:/**
        -: 3294: * Helper function for RegExp based matching
        -: 3295: *
        -: 3296: * See also:
        -: 3297: *          String.prototype.match
        -: 3298: *          RegExp.prototype[@@match]
        -: 3299: *
        -: 3300: * @return ecma_value_t
        -: 3301: */
        -: 3302:ecma_value_t
    #####: 3303:ecma_regexp_match_helper (ecma_value_t this_arg, /**< this argument */
        -: 3304:                          ecma_value_t string_arg) /**< source string */
        -: 3305:{
    #####: 3306:  if (!ecma_is_value_object (this_arg))
        -: 3307:  {
    #####: 3308:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -: 3309:  }
        -: 3310:
    #####: 3311:  ecma_string_t *str_p = ecma_op_to_string (string_arg);
        -: 3312:
    #####: 3313:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 3314:  {
    #####: 3315:    return ECMA_VALUE_ERROR;
        -: 3316:  }
        -: 3317:
    #####: 3318:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
        -: 3319:
    #####: 3320:  ecma_value_t global_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_GLOBAL);
        -: 3321:
    #####: 3322:  if (ECMA_IS_VALUE_ERROR (global_value))
        -: 3323:  {
    #####: 3324:    ecma_deref_ecma_string (str_p);
    #####: 3325:    return global_value;
        -: 3326:  }
        -: 3327:
    #####: 3328:  bool global = ecma_op_to_boolean (global_value);
        -: 3329:
    #####: 3330:  ecma_free_value (global_value);
        -: 3331:
    #####: 3332:  if (!global)
        -: 3333:  {
    #####: 3334:    ecma_value_t result = ecma_op_regexp_exec (this_arg, str_p);
    #####: 3335:    ecma_deref_ecma_string (str_p);
    #####: 3336:    return result;
        -: 3337:  }
        -: 3338:
        -: 3339:#if JERRY_ESNEXT
    #####: 3340:  ecma_value_t full_unicode_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_UNICODE);
        -: 3341:
    #####: 3342:  if (ECMA_IS_VALUE_ERROR (full_unicode_value))
        -: 3343:  {
    #####: 3344:    ecma_deref_ecma_string (str_p);
    #####: 3345:    return full_unicode_value;
        -: 3346:  }
        -: 3347:
    #####: 3348:  bool full_unicode = ecma_op_to_boolean (full_unicode_value);
        -: 3349:
    #####: 3350:  ecma_free_value (full_unicode_value);
        -: 3351:#endif /* JERRY_ESNEXT */
        -: 3352:
    #####: 3353:  ecma_value_t set_status =
    #####: 3354:    ecma_op_object_put (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), ecma_make_uint32_value (0), true);
        -: 3355:
    #####: 3356:  if (ECMA_IS_VALUE_ERROR (set_status))
        -: 3357:  {
    #####: 3358:    ecma_deref_ecma_string (str_p);
    #####: 3359:    return set_status;
        -: 3360:  }
        -: 3361:
    #####: 3362:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 3363:  ecma_object_t *result_array_p = ecma_op_new_array_object (0);
    #####: 3364:  uint32_t n = 0;
        -: 3365:
        -: 3366:  while (true)
    #####: 3367:  {
    #####: 3368:    ecma_value_t result_value = ecma_op_regexp_exec (this_arg, str_p);
        -: 3369:
    #####: 3370:    if (ECMA_IS_VALUE_ERROR (result_value))
        -: 3371:    {
    #####: 3372:      goto result_cleanup;
        -: 3373:    }
        -: 3374:
    #####: 3375:    if (ecma_is_value_null (result_value))
        -: 3376:    {
    #####: 3377:      if (n == 0)
        -: 3378:      {
    #####: 3379:        ret_value = ECMA_VALUE_NULL;
    #####: 3380:        goto result_cleanup;
        -: 3381:      }
        -: 3382:
    #####: 3383:      ecma_deref_ecma_string (str_p);
    #####: 3384:      return ecma_make_object_value (result_array_p);
        -: 3385:    }
        -: 3386:
    #####: 3387:    ecma_object_t *result_value_p = ecma_get_object_from_value (result_value);
    #####: 3388:    ecma_value_t match_value = ecma_op_object_get_by_index (result_value_p, 0);
        -: 3389:
    #####: 3390:    ecma_deref_object (result_value_p);
        -: 3391:
    #####: 3392:    if (ECMA_IS_VALUE_ERROR (match_value))
        -: 3393:    {
    #####: 3394:      goto result_cleanup;
        -: 3395:    }
        -: 3396:
    #####: 3397:    ecma_string_t *match_str_p = ecma_op_to_string (match_value);
    #####: 3398:    ecma_free_value (match_value);
        -: 3399:
    #####: 3400:    if (JERRY_UNLIKELY (match_str_p == NULL))
        -: 3401:    {
    #####: 3402:      goto result_cleanup;
        -: 3403:    }
        -: 3404:
    #####: 3405:    ecma_value_t new_prop = ecma_builtin_helper_def_prop_by_index (result_array_p,
        -: 3406:                                                                   n,
        -: 3407:                                                                   ecma_make_string_value (match_str_p),
        -: 3408:                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 3409:
    #####: 3410:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_prop));
        -: 3411:
    #####: 3412:    const bool is_match_empty = ecma_string_is_empty (match_str_p);
    #####: 3413:    ecma_deref_ecma_string (match_str_p);
        -: 3414:
    #####: 3415:    if (is_match_empty)
        -: 3416:    {
    #####: 3417:      ecma_value_t last_index = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 3418:
    #####: 3419:      if (ECMA_IS_VALUE_ERROR (last_index))
        -: 3420:      {
    #####: 3421:        goto result_cleanup;
        -: 3422:      }
        -: 3423:
        -: 3424:#if JERRY_ESNEXT
    #####: 3425:      ecma_length_t index;
    #####: 3426:      ecma_value_t length_value = ecma_op_to_length (last_index, &index);
        -: 3427:
    #####: 3428:      ecma_free_value (last_index);
        -: 3429:
    #####: 3430:      if (ECMA_IS_VALUE_ERROR (length_value))
        -: 3431:      {
    #####: 3432:        goto result_cleanup;
        -: 3433:      }
        -: 3434:
    #####: 3435:      index = ecma_op_advance_string_index (str_p, index, full_unicode);
        -: 3436:
    #####: 3437:      last_index = ecma_make_length_value (index);
    #####: 3438:      ecma_value_t next_set_status =
    #####: 3439:        ecma_op_object_put (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), last_index, true);
        -: 3440:#else /* !JERRY_ESNEXT */
    #####: 3441:      ecma_number_t index = ecma_get_number_from_value (last_index);
    #####: 3442:      ecma_free_value (last_index);
        -: 3443:
    #####: 3444:      last_index = ecma_make_number_value (index + 1);
    #####: 3445:      ecma_value_t next_set_status =
    #####: 3446:        ecma_op_object_put (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), last_index, true);
        -: 3447:
        -: 3448:#endif /* JERRY_ESNEXT */
    #####: 3449:      ecma_free_value (last_index);
        -: 3450:
    #####: 3451:      if (ECMA_IS_VALUE_ERROR (next_set_status))
        -: 3452:      {
    #####: 3453:        goto result_cleanup;
        -: 3454:      }
        -: 3455:    }
        -: 3456:
    #####: 3457:    n++;
        -: 3458:  }
        -: 3459:
    #####: 3460:result_cleanup:
    #####: 3461:  ecma_deref_ecma_string (str_p);
    #####: 3462:  ecma_deref_object (result_array_p);
    #####: 3463:  return ret_value;
        -: 3464:} /* ecma_regexp_match_helper */
        -: 3465:
        -: 3466:/**
        -: 3467: * RegExpExec operation
        -: 3468: *
        -: 3469: * See also:
        -: 3470: *          ECMA-262 v6.0, 21.2.5.2.1
        -: 3471: *
        -: 3472: * @return ecma value
        -: 3473: *         Returned value must be freed with ecma_free_value.
        -: 3474: */
        -: 3475:ecma_value_t
    #####: 3476:ecma_op_regexp_exec (ecma_value_t this_arg, /**< this argument */
        -: 3477:                     ecma_string_t *str_p) /**< input string */
        -: 3478:{
    #####: 3479:  ecma_object_t *arg_obj_p = ecma_get_object_from_value (this_arg);
        -: 3480:
        -: 3481:#if JERRY_ESNEXT
    #####: 3482:  ecma_value_t exec = ecma_op_object_get_by_magic_id (arg_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 3483:
    #####: 3484:  if (ECMA_IS_VALUE_ERROR (exec))
        -: 3485:  {
    #####: 3486:    return exec;
        -: 3487:  }
        -: 3488:
    #####: 3489:  if (ecma_op_is_callable (exec))
        -: 3490:  {
    #####: 3491:    ecma_object_t *function_p = ecma_get_object_from_value (exec);
    #####: 3492:    ecma_value_t arguments[] = { ecma_make_string_value (str_p) };
        -: 3493:
    #####: 3494:    ecma_value_t result = ecma_op_function_call (function_p, this_arg, arguments, 1);
        -: 3495:
    #####: 3496:    ecma_deref_object (function_p);
        -: 3497:
    #####: 3498:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3499:    {
    #####: 3500:      return result;
        -: 3501:    }
        -: 3502:
    #####: 3503:    if (!ecma_is_value_object (result) && !ecma_is_value_null (result))
        -: 3504:    {
    #####: 3505:      ecma_free_value (result);
    #####: 3506:      return ecma_raise_type_error (ECMA_ERR_RETURN_VALUE_OF_EXEC_MUST_BE_AN_OBJECT_OR_NULL);
        -: 3507:    }
        -: 3508:
    #####: 3509:    return result;
        -: 3510:  }
        -: 3511:  else
        -: 3512:  {
    #####: 3513:    ecma_free_value (exec);
        -: 3514:  }
        -: 3515:#endif /* JERRY_ESNEXT */
        -: 3516:
    #####: 3517:  if (!ecma_object_is_regexp_object (this_arg))
        -: 3518:  {
    #####: 3519:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_REG_EXP);
        -: 3520:  }
        -: 3521:
    #####: 3522:  return ecma_regexp_exec_helper (arg_obj_p, str_p);
        -: 3523:} /* ecma_op_regexp_exec */
        -: 3524:
        -: 3525:/**
        -: 3526: * @}
        -: 3527: * @}
        -: 3528: */
        -: 3529:
        -: 3530:#endif /* JERRY_BUILTIN_REGEXP */
