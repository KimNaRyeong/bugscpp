        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-line-info.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-line-info.h"
        -:   17:
        -:   18:#include "ecma-helpers.h"
        -:   19:
        -:   20:#if JERRY_LINE_INFO
        -:   21:
        -:   22:/** \addtogroup ecma ECMA
        -:   23: * @{
        -:   24: *
        -:   25: * \addtogroup ecmalineinfo Line info
        -:   26: * @{
        -:   27: */
        -:   28:
        -:   29:/* The layout of the structure is defined in js-parser-line-info-create.c */
        -:   30:
        -:   31:JERRY_STATIC_ASSERT ((ECMA_LINE_INFO_COLUMN_DEFAULT - 1) == ((ECMA_LINE_INFO_ENCODE_TWO_BYTE >> 1) - 1),
        -:   32:                     ecma_line_info_column_1_must_be_accessible_with_the_highest_one_byte_negative_value);
        -:   33:
        -:   34:/**
        -:   35: * Decodes an uint32_t number, and updates the buffer position.
        -:   36: * Numbers expected to be larger values.
        -:   37: *
        -:   38: * @return the decoded value
        -:   39: */
        -:   40:uint32_t
      324:   41:ecma_line_info_decode_vlq (uint8_t **buffer_p) /**< [in/out] target buffer */
        -:   42:{
      324:   43:  uint8_t *source_p = *buffer_p;
      324:   44:  uint32_t value = 0;
        -:   45:
        -:   46:  do
        -:   47:  {
      352:   48:    value = (value << ECMA_LINE_INFO_VLQ_SHIFT) | (*source_p & ECMA_LINE_INFO_VLQ_MASK);
      352:   49:  } while (*source_p++ & ECMA_LINE_INFO_VLQ_CONTINUE);
        -:   50:
      324:   51:  *buffer_p = source_p;
      324:   52:  return value;
        -:   53:} /* ecma_line_info_decode_vlq */
        -:   54:
        -:   55:/**
        -:   56: * Decodes an uint32_t number, and updates the buffer position.
        -:   57: * Numbers expected to be smaller values.
        -:   58: *
        -:   59: * @return the decoded value
        -:   60: */
        -:   61:static uint32_t
      210:   62:ecma_line_info_decode_small (uint8_t **buffer_p) /**< [in/out] target buffer */
        -:   63:{
      210:   64:  uint8_t *source_p = *buffer_p;
      210:   65:  uint32_t type = source_p[0];
        -:   66:
      210:   67:  *buffer_p = source_p + 1;
        -:   68:
      210:   69:  if (type < ECMA_LINE_INFO_ENCODE_TWO_BYTE_MIN)
        -:   70:  {
      210:   71:    return type;
        -:   72:  }
        -:   73:
    #####:   74:  if (type == ECMA_LINE_INFO_ENCODE_TWO_BYTE)
        -:   75:  {
    #####:   76:    *buffer_p = source_p + 2;
    #####:   77:    return ((uint32_t) source_p[1]) + ECMA_LINE_INFO_ENCODE_TWO_BYTE_MIN;
        -:   78:  }
        -:   79:
    #####:   80:  JERRY_ASSERT (type == ECMA_LINE_INFO_ENCODE_VLQ);
    #####:   81:  return ecma_line_info_decode_vlq (buffer_p) + ECMA_LINE_INFO_ENCODE_VLQ_MIN;
        -:   82:} /* ecma_line_info_decode_small */
        -:   83:
        -:   84:/**
        -:   85: * Updates a value using an encoded difference.
        -:   86: *
        -:   87: * @return updated value
        -:   88: */
        -:   89:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
      184:   90:ecma_line_info_difference_update (uint32_t current_value, /**< current value */
        -:   91:                                  uint32_t difference_value) /**< encoded difference */
        -:   92:{
      340:   93:  if ((difference_value & 0x1) == ECMA_LINE_INFO_INCREASE)
        -:   94:  {
      226:   95:    return current_value + (difference_value >> 1) + 1;
        -:   96:  }
        -:   97:
      114:   98:  return current_value - (difference_value >> 1);
        -:   99:} /* ecma_line_info_difference_update */
        -:  100:
        -:  101:/**
        -:  102: * Release line info data.
        -:  103: */
        -:  104:void
    #####:  105:ecma_line_info_free (uint8_t *line_info_p) /**< line info buffer */
        -:  106:{
    #####:  107:  uint8_t *source_p = line_info_p;
    #####:  108:  uint32_t total_length = ecma_line_info_decode_vlq (&source_p);
        -:  109:
    #####:  110:  jmem_heap_free_block (line_info_p, total_length + (uint32_t) (source_p - line_info_p));
    #####:  111:} /* ecma_line_info_free */
        -:  112:
        -:  113:/**
        -:  114: * Returns the line/column information for a given byte code offset.
        -:  115: */
        -:  116:void
       24:  117:ecma_line_info_get (uint8_t *line_info_p, /**< line info buffer */
        -:  118:                    uint32_t offset, /**< byte code offset */
        -:  119:                    jerry_frame_location_t *location_p) /**< [out] location */
        -:  120:{
       24:  121:  uint32_t line = 1;
       24:  122:  uint32_t column = ECMA_LINE_INFO_COLUMN_DEFAULT;
       24:  123:  uint32_t end_offset = 0;
        -:  124:  uint32_t end_offset_increase;
        -:  125:  uint32_t value;
        -:  126:
        -:  127:  /* Skip total_length. */
       24:  128:  ecma_line_info_decode_vlq (&line_info_p);
        -:  129:
        -:  130:  while (true)
    #####:  131:  {
       24:  132:    value = ecma_line_info_decode_vlq (&line_info_p);
       24:  133:    line = ecma_line_info_difference_update (line, value);
        -:  134:
       24:  135:    if (*line_info_p == 0)
        -:  136:    {
       24:  137:      break;
        -:  138:    }
        -:  139:
    #####:  140:    uint8_t *size_p = line_info_p + *line_info_p + (ECMA_LINE_INFO_STREAM_SIZE_MIN + 1);
        -:  141:
    #####:  142:    uint32_t next_end_offset = end_offset + ecma_line_info_decode_vlq (&size_p);
        -:  143:
    #####:  144:    if (offset < next_end_offset)
        -:  145:    {
    #####:  146:      break;
        -:  147:    }
        -:  148:
    #####:  149:    end_offset = next_end_offset;
    #####:  150:    line_info_p = size_p;
        -:  151:  }
        -:  152:
       24:  153:  line_info_p++;
        -:  154:
        -:  155:  do
        -:  156:  {
       78:  157:    end_offset_increase = ecma_line_info_decode_small (&line_info_p);
        -:  158:
       78:  159:    if (end_offset_increase & ECMA_LINE_INFO_HAS_LINE)
        -:  160:    {
       54:  161:      value = ecma_line_info_decode_small (&line_info_p);
       54:  162:      line = ecma_line_info_difference_update (line, value);
       54:  163:      column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  164:    }
        -:  165:
       78:  166:    end_offset_increase >>= 1;
        -:  167:
       78:  168:    value = ecma_line_info_decode_small (&line_info_p);
       78:  169:    column = ecma_line_info_difference_update (column, value);
        -:  170:
       78:  171:    end_offset += end_offset_increase;
       78:  172:  } while (end_offset_increase != 0 && end_offset <= offset);
        -:  173:
       24:  174:  location_p->line = line;
       24:  175:  location_p->column = column;
       24:  176:} /* ecma_line_info_get */
        -:  177:
        -:  178:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  179:
        -:  180:/**
        -:  181: * Dumps line info data.
        -:  182: */
        -:  183:void
        -:  184:ecma_line_info_dump (uint8_t *line_info_p) /**< dumps line info data */
        -:  185:{
        -:  186:  bool block_last = false;
        -:  187:  uint32_t block_line = 1;
        -:  188:  uint32_t block_byte_code_offset = 0;
        -:  189:  uint32_t value;
        -:  190:
        -:  191:  value = ecma_line_info_decode_vlq (&line_info_p);
        -:  192:  JERRY_DEBUG_MSG ("\nLine info size: %d bytes\n", (int) value);
        -:  193:
        -:  194:  while (true)
        -:  195:  {
        -:  196:    value = ecma_line_info_decode_vlq (&line_info_p);
        -:  197:    block_line = ecma_line_info_difference_update (block_line, value);
        -:  198:
        -:  199:    JERRY_DEBUG_MSG ("\nNew block: line: %d", (int) block_line);
        -:  200:
        -:  201:    if (*line_info_p == 0)
        -:  202:    {
        -:  203:      JERRY_DEBUG_MSG (" StreamLength: [last]\n");
        -:  204:      block_last = true;
        -:  205:    }
        -:  206:    else
        -:  207:    {
        -:  208:      uint8_t *size_p = line_info_p + *line_info_p + (ECMA_LINE_INFO_STREAM_SIZE_MIN + 1);
        -:  209:
        -:  210:      value = ecma_line_info_decode_vlq (&size_p);
        -:  211:
        -:  212:      JERRY_DEBUG_MSG (" StreamLength: %d ByteCodeSize: %d\n",
        -:  213:                       (int) (*line_info_p + ECMA_LINE_INFO_STREAM_SIZE_MIN),
        -:  214:                       (int) value);
        -:  215:    }
        -:  216:
        -:  217:    line_info_p++;
        -:  218:
        -:  219:    uint32_t stream_line = block_line;
        -:  220:    uint32_t stream_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  221:    uint32_t stream_end_offset = block_byte_code_offset;
        -:  222:
        -:  223:    while (true)
        -:  224:    {
        -:  225:      uint32_t stream_end_offset_increase = ecma_line_info_decode_small (&line_info_p);
        -:  226:
        -:  227:      if (stream_end_offset_increase & ECMA_LINE_INFO_HAS_LINE)
        -:  228:      {
        -:  229:        value = ecma_line_info_decode_small (&line_info_p);
        -:  230:        stream_line = ecma_line_info_difference_update (stream_line, value);
        -:  231:        stream_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  232:      }
        -:  233:
        -:  234:      stream_end_offset_increase >>= 1;
        -:  235:
        -:  236:      value = ecma_line_info_decode_small (&line_info_p);
        -:  237:      stream_column = ecma_line_info_difference_update (stream_column, value);
        -:  238:
        -:  239:      if (stream_end_offset_increase == 0)
        -:  240:      {
        -:  241:        JERRY_DEBUG_MSG ("  ByteCodeEndOffset: [unterminated] Line: %d Column: %d\n",
        -:  242:                         (int) stream_line,
        -:  243:                         (int) stream_column);
        -:  244:        break;
        -:  245:      }
        -:  246:
        -:  247:      stream_end_offset += stream_end_offset_increase;
        -:  248:
        -:  249:      JERRY_DEBUG_MSG ("  ByteCodeEndOffset: %d Line: %d Column: %d\n",
        -:  250:                       (int) stream_end_offset,
        -:  251:                       (int) stream_line,
        -:  252:                       (int) stream_column);
        -:  253:    }
        -:  254:
        -:  255:    if (block_last)
        -:  256:    {
        -:  257:      break;
        -:  258:    }
        -:  259:
        -:  260:    block_byte_code_offset += ecma_line_info_decode_vlq (&line_info_p);
        -:  261:  }
        -:  262:} /* ecma_line_info_dump */
        -:  263:
        -:  264:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  265:
        -:  266:#endif /* JERRY_LINE_INFO */
        -:  267:
        -:  268:/**
        -:  269: * @}
        -:  270: * @}
        -:  271: */
