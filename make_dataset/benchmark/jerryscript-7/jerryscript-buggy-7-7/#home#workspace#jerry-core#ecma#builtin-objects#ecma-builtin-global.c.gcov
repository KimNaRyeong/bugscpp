        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-global.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-eval.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-gc.h"
        -:   22:#include "ecma-globals.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:
        -:   25:#include "jcontext.h"
        -:   26:#include "jrt-bit-fields.h"
        -:   27:#include "jrt-libc-includes.h"
        -:   28:#include "jrt.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "lit-magic-strings.h"
        -:   31:#include "lit-strings.h"
        -:   32:#include "vm.h"
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_GLOBAL_ROUTINE_START = 0,
        -:   48:  /* Note: these 5 routine ids must be in this order */
        -:   49:  ECMA_GLOBAL_IS_NAN,
        -:   50:  ECMA_GLOBAL_IS_FINITE,
        -:   51:  ECMA_GLOBAL_EVAL,
        -:   52:  ECMA_GLOBAL_PARSE_INT,
        -:   53:  ECMA_GLOBAL_PARSE_FLOAT,
        -:   54:  ECMA_GLOBAL_DECODE_URI,
        -:   55:  ECMA_GLOBAL_DECODE_URI_COMPONENT,
        -:   56:  ECMA_GLOBAL_ENCODE_URI,
        -:   57:  ECMA_GLOBAL_ENCODE_URI_COMPONENT,
        -:   58:  ECMA_GLOBAL_ESCAPE,
        -:   59:  ECMA_GLOBAL_UNESCAPE,
        -:   60:};
        -:   61:
        -:   62:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-global.inc.h"
        -:   63:#define BUILTIN_UNDERSCORED_ID  global
        -:   64:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   65:
        -:   66:/** \addtogroup ecma ECMA
        -:   67: * @{
        -:   68: *
        -:   69: * \addtogroup ecmabuiltins
        -:   70: * @{
        -:   71: *
        -:   72: * \addtogroup global ECMA Global object built-in
        -:   73: * @{
        -:   74: */
        -:   75:
        -:   76:/**
        -:   77: * The Global object's 'eval' routine
        -:   78: *
        -:   79: * See also:
        -:   80: *          ECMA-262 v5, 15.1.2.1
        -:   81: *
        -:   82: * @return ecma value
        -:   83: *         Returned value must be freed with ecma_free_value.
        -:   84: */
        -:   85:static ecma_value_t
    #####:   86:ecma_builtin_global_object_eval (ecma_value_t x) /**< routine's first argument */
        -:   87:{
    #####:   88:  if (JERRY_UNLIKELY (!ecma_is_value_string (x)))
        -:   89:  {
        -:   90:    /* step 1 */
    #####:   91:    return ecma_copy_value (x);
        -:   92:  }
        -:   93:
    #####:   94:  uint32_t parse_opts = vm_is_direct_eval_form_call () ? ECMA_PARSE_DIRECT_EVAL : ECMA_PARSE_NO_OPTS;
        -:   95:
        -:   96:  /* See also: ECMA-262 v5, 10.1.1 */
    #####:   97:  if (parse_opts && vm_is_strict_mode ())
        -:   98:  {
    #####:   99:    JERRY_ASSERT (parse_opts & ECMA_PARSE_DIRECT_EVAL);
    #####:  100:    parse_opts |= ECMA_PARSE_STRICT_MODE;
        -:  101:  }
        -:  102:
        -:  103:#if JERRY_ESNEXT
    #####:  104:  if (vm_is_direct_eval_form_call ())
        -:  105:  {
    #####:  106:    parse_opts |= ECMA_GET_LOCAL_PARSE_OPTS ();
        -:  107:  }
        -:  108:#endif /* JERRY_ESNEXT */
        -:  109:
        -:  110:  /* steps 2 to 8 */
    #####:  111:  return ecma_op_eval (x, parse_opts);
        -:  112:} /* ecma_builtin_global_object_eval */
        -:  113:
        -:  114:/**
        -:  115: * The Global object's 'isNaN' routine
        -:  116: *
        -:  117: * See also:
        -:  118: *          ECMA-262 v5, 15.1.2.4
        -:  119: *
        -:  120: * @return ecma value
        -:  121: *         Returned value must be freed with ecma_free_value.
        -:  122: */
        -:  123:static ecma_value_t
    #####:  124:ecma_builtin_global_object_is_nan (ecma_number_t arg_num) /**< routine's first argument */
        -:  125:{
    #####:  126:  return ecma_make_boolean_value (ecma_number_is_nan (arg_num));
        -:  127:} /* ecma_builtin_global_object_is_nan */
        -:  128:
        -:  129:/**
        -:  130: * The Global object's 'isFinite' routine
        -:  131: *
        -:  132: * See also:
        -:  133: *          ECMA-262 v5, 15.1.2.5
        -:  134: *
        -:  135: * @return ecma value
        -:  136: *         Returned value must be freed with ecma_free_value.
        -:  137: */
        -:  138:static ecma_value_t
    #####:  139:ecma_builtin_global_object_is_finite (ecma_number_t arg_num) /**< routine's first argument */
        -:  140:{
    #####:  141:  bool is_finite = !(ecma_number_is_nan (arg_num) || ecma_number_is_infinity (arg_num));
        -:  142:
    #####:  143:  return ecma_make_boolean_value (is_finite);
        -:  144:} /* ecma_builtin_global_object_is_finite */
        -:  145:
        -:  146:/**
        -:  147: * Helper function to check whether a character is in a character bitset.
        -:  148: *
        -:  149: * @return true if the character is in the character bitset.
        -:  150: */
        -:  151:static bool
    #####:  152:ecma_builtin_global_object_character_is_in (uint32_t character, /**< character */
        -:  153:                                            const uint8_t *bitset) /**< character set */
        -:  154:{
    #####:  155:  JERRY_ASSERT (character < 128);
    #####:  156:  return (bitset[character >> 3] & (1u << (character & 0x7))) != 0;
        -:  157:} /* ecma_builtin_global_object_character_is_in */
        -:  158:
        -:  159:/**
        -:  160: * Unescaped URI characters bitset:
        -:  161: *   One bit for each character between 0 - 127.
        -:  162: *   Bit is set if the character is in the unescaped URI set.
        -:  163: */
        -:  164:static const uint8_t unescaped_uri_set[16] = { 0x0,  0x0,  0x0,  0x0,  0xda, 0xff, 0xff, 0xaf,
        -:  165:                                               0xff, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x47 };
        -:  166:
        -:  167:/**
        -:  168: * Unescaped URI component characters bitset:
        -:  169: *   One bit for each character between 0 - 127.
        -:  170: *   Bit is set if the character is in the unescaped component URI set.
        -:  171: */
        -:  172:static const uint8_t unescaped_uri_component_set[16] = { 0x0,  0x0,  0x0,  0x0,  0x82, 0x67, 0xff, 0x3,
        -:  173:                                                         0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x47 };
        -:  174:
        -:  175:/**
        -:  176: * Format is a percent sign followed by two hex digits.
        -:  177: */
        -:  178:#define URI_ENCODED_BYTE_SIZE (3)
        -:  179:
        -:  180:/**
        -:  181: * The Global object's 'decodeURI' and 'decodeURIComponent' routines
        -:  182: *
        -:  183: * See also:
        -:  184: *          ECMA-262 v5, 15.1.3.1
        -:  185: *          ECMA-262 v5, 15.1.3.2
        -:  186: *
        -:  187: * @return ecma value
        -:  188: *         Returned value must be freed with ecma_free_value.
        -:  189: */
        -:  190:static ecma_value_t
    #####:  191:ecma_builtin_global_object_decode_uri_helper (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  192:                                                                               *   string buffer */
        -:  193:                                              lit_utf8_size_t input_size, /**< routine's first argument's
        -:  194:                                                                           *   string buffer's size */
        -:  195:                                              const uint8_t *reserved_uri_bitset) /**< reserved characters bitset */
        -:  196:{
    #####:  197:  lit_utf8_byte_t *input_char_p = input_start_p;
    #####:  198:  lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  199:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  200:
    #####:  201:  while (input_char_p < input_end_p)
        -:  202:  {
    #####:  203:    if (*input_char_p != '%')
        -:  204:    {
    #####:  205:      ecma_stringbuilder_append_byte (&builder, *input_char_p++);
    #####:  206:      continue;
        -:  207:    }
        -:  208:
    #####:  209:    uint32_t hex_value = lit_char_hex_lookup (input_char_p + 1, input_end_p, 2);
    #####:  210:    if (hex_value == UINT32_MAX)
        -:  211:    {
    #####:  212:      ecma_stringbuilder_destroy (&builder);
    #####:  213:      return ecma_raise_uri_error (ECMA_ERR_INVALID_HEXADECIMAL_VALUE);
        -:  214:    }
        -:  215:
    #####:  216:    ecma_char_t decoded_byte = (ecma_char_t) hex_value;
    #####:  217:    input_char_p += URI_ENCODED_BYTE_SIZE;
        -:  218:
    #####:  219:    if (decoded_byte <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  220:    {
    #####:  221:      if (ecma_builtin_global_object_character_is_in (decoded_byte, reserved_uri_bitset)
    #####:  222:          && !ecma_builtin_global_object_character_is_in (decoded_byte, unescaped_uri_component_set))
        -:  223:      {
    #####:  224:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_PERCENT);
    #####:  225:        input_char_p -= 2;
        -:  226:      }
        -:  227:      else
        -:  228:      {
    #####:  229:        ecma_stringbuilder_append_byte (&builder, (lit_utf8_byte_t) decoded_byte);
        -:  230:      }
        -:  231:    }
        -:  232:    else
        -:  233:    {
        -:  234:      uint32_t bytes_count;
        -:  235:
    #####:  236:      if ((decoded_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  237:      {
    #####:  238:        bytes_count = 2;
        -:  239:      }
    #####:  240:      else if ((decoded_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  241:      {
    #####:  242:        bytes_count = 3;
        -:  243:      }
    #####:  244:      else if ((decoded_byte & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)
        -:  245:      {
    #####:  246:        bytes_count = 4;
        -:  247:      }
        -:  248:      else
        -:  249:      {
    #####:  250:        ecma_stringbuilder_destroy (&builder);
    #####:  251:        return ecma_raise_uri_error (ECMA_ERR_INVALID_UTF8_CHARACTER);
        -:  252:      }
        -:  253:
    #####:  254:      lit_utf8_byte_t octets[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####:  255:      octets[0] = (lit_utf8_byte_t) decoded_byte;
    #####:  256:      bool is_valid = true;
        -:  257:
    #####:  258:      for (uint32_t i = 1; i < bytes_count; i++)
        -:  259:      {
    #####:  260:        if (input_char_p >= input_end_p || *input_char_p != '%')
        -:  261:        {
    #####:  262:          is_valid = false;
    #####:  263:          break;
        -:  264:        }
        -:  265:        else
        -:  266:        {
    #####:  267:          hex_value = lit_char_hex_lookup (input_char_p + 1, input_end_p, 2);
        -:  268:
    #####:  269:          if (hex_value == UINT32_MAX || (hex_value & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  270:          {
    #####:  271:            is_valid = false;
    #####:  272:            break;
        -:  273:          }
        -:  274:
    #####:  275:          input_char_p += URI_ENCODED_BYTE_SIZE;
    #####:  276:          octets[i] = (lit_utf8_byte_t) hex_value;
        -:  277:        }
        -:  278:      }
        -:  279:
    #####:  280:      if (!is_valid || !lit_is_valid_utf8_string (octets, bytes_count, true))
        -:  281:      {
    #####:  282:        ecma_stringbuilder_destroy (&builder);
    #####:  283:        return ecma_raise_uri_error (ECMA_ERR_INVALID_UTF8_STRING);
        -:  284:      }
        -:  285:
    #####:  286:      lit_code_point_t cp;
    #####:  287:      lit_read_code_point_from_utf8 (octets, bytes_count, &cp);
        -:  288:
    #####:  289:      if (lit_is_code_point_utf16_high_surrogate (cp) || lit_is_code_point_utf16_low_surrogate (cp))
        -:  290:      {
    #####:  291:        ecma_stringbuilder_destroy (&builder);
    #####:  292:        return ecma_raise_uri_error (ECMA_ERR_INVALID_UTF8_CODEPOINT);
        -:  293:      }
        -:  294:
    #####:  295:      lit_utf8_byte_t result_chars[LIT_CESU8_MAX_BYTES_IN_CODE_POINT];
    #####:  296:      lit_utf8_size_t cp_size = lit_code_point_to_cesu8 (cp, result_chars);
    #####:  297:      ecma_stringbuilder_append_raw (&builder, result_chars, cp_size);
        -:  298:    }
        -:  299:  }
        -:  300:
    #####:  301:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  302:} /* ecma_builtin_global_object_decode_uri_helper */
        -:  303:
        -:  304:/**
        -:  305: * Helper function to encode byte as hexadecimal values.
        -:  306: */
        -:  307:static void
    #####:  308:ecma_builtin_global_object_byte_to_hex (lit_utf8_byte_t *dest_p, /**< destination pointer */
        -:  309:                                        uint32_t byte) /**< value */
        -:  310:{
    #####:  311:  JERRY_ASSERT (byte < 256);
        -:  312:
    #####:  313:  dest_p[0] = LIT_CHAR_PERCENT;
    #####:  314:  ecma_char_t hex_digit = (ecma_char_t) (byte >> 4);
    #####:  315:  dest_p[1] = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
    #####:  316:  hex_digit = (lit_utf8_byte_t) (byte & 0xf);
    #####:  317:  dest_p[2] = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
    #####:  318:} /* ecma_builtin_global_object_byte_to_hex */
        -:  319:
        -:  320:/**
        -:  321: * The Global object's 'encodeURI' and 'encodeURIComponent' routines
        -:  322: *
        -:  323: * See also:
        -:  324: *          ECMA-262 v5, 15.1.3.3
        -:  325: *          ECMA-262 v5, 15.1.3.4
        -:  326: *
        -:  327: * @return ecma value
        -:  328: *         Returned value must be freed with ecma_free_value.
        -:  329: */
        -:  330:static ecma_value_t
    #####:  331:ecma_builtin_global_object_encode_uri_helper (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  332:                                                                               *   string buffer */
        -:  333:                                              lit_utf8_size_t input_size, /**< routine's first argument's
        -:  334:                                                                           *   string buffer's size */
        -:  335:                                              const uint8_t *unescaped_uri_bitset_p) /**< unescaped bitset */
        -:  336:{
    #####:  337:  lit_utf8_byte_t *input_char_p = input_start_p;
    #####:  338:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  339:  ecma_char_t ch;
    #####:  340:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  341:  lit_utf8_byte_t octets[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####:  342:  memset (octets, LIT_BYTE_NULL, LIT_UTF8_MAX_BYTES_IN_CODE_POINT);
        -:  343:
    #####:  344:  while (input_char_p < input_end_p)
        -:  345:  {
    #####:  346:    input_char_p += lit_read_code_unit_from_cesu8 (input_char_p, &ch);
        -:  347:
    #####:  348:    if (lit_is_code_point_utf16_low_surrogate (ch))
        -:  349:    {
    #####:  350:      ecma_stringbuilder_destroy (&builder);
    #####:  351:      return ecma_raise_uri_error (ECMA_ERR_UNICODE_SURROGATE_PAIR_MISSING);
        -:  352:    }
        -:  353:
    #####:  354:    lit_code_point_t cp = ch;
        -:  355:
    #####:  356:    if (lit_is_code_point_utf16_high_surrogate (ch))
        -:  357:    {
    #####:  358:      if (input_char_p == input_end_p)
        -:  359:      {
    #####:  360:        ecma_stringbuilder_destroy (&builder);
    #####:  361:        return ecma_raise_uri_error (ECMA_ERR_UNICODE_SURROGATE_PAIR_MISSING);
        -:  362:      }
        -:  363:
    #####:  364:      ecma_char_t next_ch;
    #####:  365:      lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (input_char_p, &next_ch);
        -:  366:
    #####:  367:      if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  368:      {
    #####:  369:        cp = lit_convert_surrogate_pair_to_code_point (ch, next_ch);
    #####:  370:        input_char_p += read_size;
        -:  371:      }
        -:  372:      else
        -:  373:      {
    #####:  374:        ecma_stringbuilder_destroy (&builder);
    #####:  375:        return ecma_raise_uri_error (ECMA_ERR_UNICODE_SURROGATE_PAIR_MISSING);
        -:  376:      }
        -:  377:    }
        -:  378:
    #####:  379:    lit_utf8_size_t utf_size = lit_code_point_to_utf8 (cp, octets);
    #####:  380:    lit_utf8_byte_t result_chars[URI_ENCODED_BYTE_SIZE];
        -:  381:
    #####:  382:    if (utf_size == 1)
        -:  383:    {
    #####:  384:      if (ecma_builtin_global_object_character_is_in (octets[0], unescaped_uri_bitset_p))
        -:  385:      {
    #####:  386:        ecma_stringbuilder_append_byte (&builder, octets[0]);
        -:  387:      }
        -:  388:      else
        -:  389:      {
    #####:  390:        ecma_builtin_global_object_byte_to_hex (result_chars, octets[0]);
    #####:  391:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  392:      }
        -:  393:    }
        -:  394:    else
        -:  395:    {
    #####:  396:      for (uint32_t i = 0; i < utf_size; i++)
        -:  397:      {
    #####:  398:        JERRY_ASSERT (utf_size <= LIT_UTF8_MAX_BYTES_IN_CODE_POINT);
    #####:  399:        ecma_builtin_global_object_byte_to_hex (result_chars, octets[i]);
    #####:  400:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  401:      }
        -:  402:    }
        -:  403:  }
        -:  404:
    #####:  405:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  406:} /* ecma_builtin_global_object_encode_uri_helper */
        -:  407:
        -:  408:#if JERRY_BUILTIN_ANNEXB
        -:  409:
        -:  410:/**
        -:  411: * Maximum value of a byte.
        -:  412: */
        -:  413:#define ECMA_ESCAPE_MAXIMUM_BYTE_VALUE (255)
        -:  414:
        -:  415:/**
        -:  416: * Format is a percent sign followed by lowercase u and four hex digits.
        -:  417: */
        -:  418:#define ECMA_ESCAPE_ENCODED_UNICODE_CHARACTER_SIZE (6)
        -:  419:
        -:  420:/**
        -:  421: * Escape characters bitset:
        -:  422: *   One bit for each character between 0 - 127.
        -:  423: *   Bit is set if the character does not need to be converted to %xx form.
        -:  424: *   These characters are: a-z A-Z 0-9 @ * _ + - . /
        -:  425: */
        -:  426:static const uint8_t ecma_escape_set[16] = { 0x0,  0x0,  0x0,  0x0,  0x0,  0xec, 0xff, 0x3,
        -:  427:                                             0xff, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x7 };
        -:  428:
        -:  429:/**
        -:  430: * The Global object's 'escape' routine
        -:  431: *
        -:  432: * See also:
        -:  433: *          ECMA-262 v5, B.2.1
        -:  434: *
        -:  435: * @return ecma value
        -:  436: *         Returned value must be freed with ecma_free_value.
        -:  437: */
        -:  438:static ecma_value_t
    #####:  439:ecma_builtin_global_object_escape (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  440:                                                                    *   string buffer */
        -:  441:                                   lit_utf8_size_t input_size) /**< routine's first argument's
        -:  442:                                                                *   string buffer's size */
        -:  443:{
    #####:  444:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####:  445:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  446:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  447:  lit_utf8_byte_t result_chars[URI_ENCODED_BYTE_SIZE];
        -:  448:
    #####:  449:  while (input_curr_p < input_end_p)
        -:  450:  {
    #####:  451:    ecma_char_t chr = lit_cesu8_read_next (&input_curr_p);
        -:  452:
    #####:  453:    if (chr <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  454:    {
    #####:  455:      if (ecma_builtin_global_object_character_is_in ((uint32_t) chr, ecma_escape_set))
        -:  456:      {
    #####:  457:        ecma_stringbuilder_append_char (&builder, chr);
        -:  458:      }
        -:  459:      else
        -:  460:      {
    #####:  461:        ecma_builtin_global_object_byte_to_hex (result_chars, chr);
    #####:  462:        ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  463:      }
        -:  464:    }
    #####:  465:    else if (chr > ECMA_ESCAPE_MAXIMUM_BYTE_VALUE)
        -:  466:    {
    #####:  467:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_PERCENT);
    #####:  468:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_LOWERCASE_U);
        -:  469:
    #####:  470:      ecma_builtin_global_object_byte_to_hex (result_chars, (chr >> JERRY_BITSINBYTE));
    #####:  471:      ecma_stringbuilder_append_raw (&builder, result_chars + 1, 2);
        -:  472:
    #####:  473:      ecma_builtin_global_object_byte_to_hex (result_chars, (chr & 0xff));
    #####:  474:      ecma_stringbuilder_append_raw (&builder, result_chars + 1, 2);
        -:  475:    }
        -:  476:    else
        -:  477:    {
    #####:  478:      ecma_builtin_global_object_byte_to_hex (result_chars, chr);
    #####:  479:      ecma_stringbuilder_append_raw (&builder, result_chars, URI_ENCODED_BYTE_SIZE);
        -:  480:    }
        -:  481:  }
        -:  482:
    #####:  483:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  484:} /* ecma_builtin_global_object_escape */
        -:  485:
        -:  486:/**
        -:  487: * Utility method to resolve character sequences for the 'unescape' method.
        -:  488: *
        -:  489: * Expected formats: %uxxxx or %yy
        -:  490: *
        -:  491: * @return number of characters processed during the escape resolve
        -:  492: */
        -:  493:static uint8_t
    #####:  494:ecma_builtin_global_object_unescape_resolve_escape (const lit_utf8_byte_t *buffer_p, /**< character buffer */
        -:  495:                                                    bool unicode_sequence, /**< true if unescaping unicode sequence */
        -:  496:                                                    ecma_char_t *out_result_p) /**< [out] resolved character */
        -:  497:{
    #####:  498:  JERRY_ASSERT (buffer_p != NULL);
    #####:  499:  JERRY_ASSERT (out_result_p != NULL);
        -:  500:
    #####:  501:  ecma_char_t unescaped_chr = 0;
    #####:  502:  uint8_t sequence_length = unicode_sequence ? 5 : 2;
    #####:  503:  uint8_t start = unicode_sequence ? 1 : 0;
        -:  504:
    #####:  505:  for (uint8_t i = start; i < sequence_length; i++)
        -:  506:  {
    #####:  507:    const lit_utf8_byte_t current_char = buffer_p[i];
        -:  508:
    #####:  509:    if (!lit_char_is_hex_digit (current_char))
        -:  510:    {
        -:  511:      /* This was not an escape sequence, skip processing */
    #####:  512:      return 0;
        -:  513:    }
        -:  514:
    #####:  515:    unescaped_chr = (ecma_char_t) ((unescaped_chr << 4) + (ecma_char_t) lit_char_hex_to_int (current_char));
        -:  516:  }
        -:  517:
    #####:  518:  *out_result_p = unescaped_chr;
        -:  519:
    #####:  520:  return sequence_length;
        -:  521:} /* ecma_builtin_global_object_unescape_resolve_escape */
        -:  522:
        -:  523:/**
        -:  524: * The Global object's 'unescape' routine
        -:  525: *
        -:  526: * See also:
        -:  527: *          ECMA-262 v5, B.2.2
        -:  528: *          ECMA-262 v11, B.2.1.2
        -:  529: *
        -:  530: * @return ecma value
        -:  531: *         Returned value must be freed with ecma_free_value.
        -:  532: */
        -:  533:static ecma_value_t
    #####:  534:ecma_builtin_global_object_unescape (lit_utf8_byte_t *input_start_p, /**< routine's first argument's
        -:  535:                                                                      *   string buffer */
        -:  536:                                     lit_utf8_size_t input_size) /**< routine's first argument's
        -:  537:                                                                  *   string buffer's size */
        -:  538:{
    #####:  539:  if (input_size == 0)
        -:  540:  {
    #####:  541:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  542:  }
        -:  543:
    #####:  544:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####:  545:  const lit_utf8_byte_t *input_end_p = input_start_p + input_size;
    #####:  546:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  547:
    #####:  548:  while (input_curr_p < input_end_p)
        -:  549:  {
    #####:  550:    ecma_char_t chr = lit_cesu8_read_next (&input_curr_p);
        -:  551:
        -:  552:    // potential pattern
    #####:  553:    if (chr == LIT_CHAR_PERCENT)
        -:  554:    {
    #####:  555:      const lit_utf8_size_t chars_leftover = (lit_utf8_size_t) (input_end_p - input_curr_p);
        -:  556:
        -:  557:      // potential unicode sequence
    #####:  558:      if (chars_leftover >= 5 && input_curr_p[0] == LIT_CHAR_LOWERCASE_U)
        -:  559:      {
    #####:  560:        input_curr_p += ecma_builtin_global_object_unescape_resolve_escape (input_curr_p, true, &chr);
        -:  561:      }
        -:  562:      // potential two hexa sequence
    #####:  563:      else if (chars_leftover >= 2)
        -:  564:      {
    #####:  565:        input_curr_p += ecma_builtin_global_object_unescape_resolve_escape (input_curr_p, false, &chr);
        -:  566:      }
        -:  567:    }
        -:  568:
    #####:  569:    ecma_stringbuilder_append_char (&builder, chr);
        -:  570:  }
        -:  571:
    #####:  572:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  573:} /* ecma_builtin_global_object_unescape */
        -:  574:
        -:  575:#endif /* JERRY_BUILTIN_ANNEXB */
        -:  576:
        -:  577:/**
        -:  578: * Dispatcher of the built-in's routines
        -:  579: *
        -:  580: * @return ecma value
        -:  581: *         Returned value must be freed with ecma_free_value.
        -:  582: */
        -:  583:ecma_value_t
    #####:  584:ecma_builtin_global_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  585:                                      ecma_value_t this_arg, /**< 'this' argument value */
        -:  586:                                      const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  587:                                                                              *   passed to routine */
        -:  588:                                      uint32_t arguments_number) /**< length of arguments' list */
        -:  589:{
        -:  590:  JERRY_UNUSED_2 (this_arg, arguments_number);
        -:  591:
    #####:  592:  ecma_value_t routine_arg_1 = arguments_list_p[0];
        -:  593:
    #####:  594:  if (builtin_routine_id == ECMA_GLOBAL_EVAL)
        -:  595:  {
    #####:  596:    return ecma_builtin_global_object_eval (routine_arg_1);
        -:  597:  }
        -:  598:
    #####:  599:  if (builtin_routine_id <= ECMA_GLOBAL_IS_FINITE)
        -:  600:  {
    #####:  601:    ecma_number_t arg_num;
        -:  602:
    #####:  603:    routine_arg_1 = ecma_op_to_number (routine_arg_1, &arg_num);
        -:  604:
    #####:  605:    if (!ecma_is_value_empty (routine_arg_1))
        -:  606:    {
    #####:  607:      return routine_arg_1;
        -:  608:    }
        -:  609:
    #####:  610:    if (builtin_routine_id == ECMA_GLOBAL_IS_NAN)
        -:  611:    {
    #####:  612:      return ecma_builtin_global_object_is_nan (arg_num);
        -:  613:    }
        -:  614:
    #####:  615:    JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_IS_FINITE);
        -:  616:
    #####:  617:    return ecma_builtin_global_object_is_finite (arg_num);
        -:  618:  }
        -:  619:
    #####:  620:  ecma_string_t *str_p = ecma_op_to_string (routine_arg_1);
        -:  621:
    #####:  622:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  623:  {
    #####:  624:    return ECMA_VALUE_ERROR;
        -:  625:  }
        -:  626:
        -:  627:  ecma_value_t ret_value;
        -:  628:
    #####:  629:  if (builtin_routine_id <= ECMA_GLOBAL_PARSE_FLOAT)
        -:  630:  {
    #####:  631:    ECMA_STRING_TO_UTF8_STRING (str_p, string_buff, string_buff_size);
        -:  632:
    #####:  633:    if (builtin_routine_id == ECMA_GLOBAL_PARSE_INT)
        -:  634:    {
    #####:  635:      ret_value = ecma_number_parse_int (string_buff, string_buff_size, arguments_list_p[1]);
        -:  636:    }
        -:  637:    else
        -:  638:    {
    #####:  639:      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_PARSE_FLOAT);
    #####:  640:      ret_value = ecma_number_parse_float (string_buff, string_buff_size);
        -:  641:    }
        -:  642:
    #####:  643:    ECMA_FINALIZE_UTF8_STRING (string_buff, string_buff_size);
    #####:  644:    ecma_deref_ecma_string (str_p);
    #####:  645:    return ret_value;
        -:  646:  }
        -:  647:
    #####:  648:  lit_utf8_size_t input_size = ecma_string_get_size (str_p);
        -:  649:
    #####:  650:  JMEM_DEFINE_LOCAL_ARRAY (input_start_p, input_size + 1, lit_utf8_byte_t);
        -:  651:
    #####:  652:  ecma_string_to_cesu8_bytes (str_p, input_start_p, input_size);
        -:  653:
    #####:  654:  input_start_p[input_size] = LIT_BYTE_NULL;
        -:  655:
    #####:  656:  switch (builtin_routine_id)
        -:  657:  {
        -:  658:#if JERRY_BUILTIN_ANNEXB
    #####:  659:    case ECMA_GLOBAL_ESCAPE:
        -:  660:    {
    #####:  661:      ret_value = ecma_builtin_global_object_escape (input_start_p, input_size);
    #####:  662:      break;
        -:  663:    }
    #####:  664:    case ECMA_GLOBAL_UNESCAPE:
        -:  665:    {
    #####:  666:      ret_value = ecma_builtin_global_object_unescape (input_start_p, input_size);
    #####:  667:      break;
        -:  668:    }
        -:  669:#endif /* JERRY_BUILTIN_ANNEXB */
    #####:  670:    case ECMA_GLOBAL_DECODE_URI:
        -:  671:    case ECMA_GLOBAL_DECODE_URI_COMPONENT:
        -:  672:    {
    #####:  673:      const uint8_t *uri_set =
    #####:  674:        (builtin_routine_id == ECMA_GLOBAL_DECODE_URI ? unescaped_uri_set : unescaped_uri_component_set);
        -:  675:
    #####:  676:      ret_value = ecma_builtin_global_object_decode_uri_helper (input_start_p, input_size, uri_set);
    #####:  677:      break;
        -:  678:    }
    #####:  679:    default:
        -:  680:    {
    #####:  681:      JERRY_ASSERT (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI
        -:  682:                    || builtin_routine_id == ECMA_GLOBAL_ENCODE_URI_COMPONENT);
        -:  683:
    #####:  684:      const uint8_t *uri_set =
    #####:  685:        (builtin_routine_id == ECMA_GLOBAL_ENCODE_URI ? unescaped_uri_set : unescaped_uri_component_set);
        -:  686:
    #####:  687:      ret_value = ecma_builtin_global_object_encode_uri_helper (input_start_p, input_size, uri_set);
    #####:  688:      break;
        -:  689:    }
        -:  690:  }
        -:  691:
    #####:  692:  JMEM_FINALIZE_LOCAL_ARRAY (input_start_p);
        -:  693:
    #####:  694:  ecma_deref_ecma_string (str_p);
    #####:  695:  return ret_value;
        -:  696:} /* ecma_builtin_global_dispatch_routine */
        -:  697:
        -:  698:/**
        -:  699: * @}
        -:  700: * @}
        -:  701: * @}
        -:  702: */
