        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-util.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:#include "ecma-lex-env.h"
        -:   18:
        -:   19:#include "jcontext.h"
        -:   20:#include "js-parser-internal.h"
        -:   21:#include "js-scanner-internal.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:#if JERRY_PARSER
        -:   25:
        -:   26:/** \addtogroup parser Parser
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser JavaScript
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup jsparser_scanner Scanner
        -:   33: * @{
        -:   34: */
        -:   35:
        -:   36:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_NUMBER_OF_LITERALS + PARSER_MAXIMUM_NUMBER_OF_REGISTERS < PARSER_REGISTER_START,
        -:   37:                     maximum_number_of_literals_plus_registers_must_be_less_than_register_start);
        -:   38:
        -:   39:#if JERRY_ESNEXT
        -:   40:
        -:   41:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) == 0,
        -:   42:                     is_arrow_arg_binding_flag_must_not_use_local_flags);
        -:   43:
        -:   44:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_LET & SCANNER_LITERAL_IS_LOCAL) != 0, is_let_flag_must_use_local_flags);
        -:   45:
        -:   46:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_CONST & SCANNER_LITERAL_IS_LOCAL) != 0, is_const_flag_must_use_local_flags);
        -:   47:
        -:   48:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_FUNC_DECLARATION & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   49:                     is_func_declaration_flag_must_use_local_flags);
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   52:                     is_arg_binding_flag_must_use_local_flags);
        -:   53:
        -:   54:JERRY_STATIC_ASSERT (SCANNER_LITERAL_IS_FUNC_DECLARATION != SCANNER_LITERAL_IS_DESTRUCTURED_ARG,
        -:   55:                     is_func_declaration_must_be_different_from_is_arg_binding);
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (PARSER_SCOPE_STACK_IS_CONST_REG == PARSER_SCOPE_STACK_IS_LOCAL_CREATED,
        -:   58:                     scope_stack_is_const_reg_and_scope_stack_is_local_created_must_be_the_same);
        -:   59:
        -:   60:#endif /* JERRY_ESNEXT */
        -:   61:
        -:   62:/**
        -:   63: * Raise a scanner error.
        -:   64: */
        -:   65:void
    #####:   66:scanner_raise_error (parser_context_t *context_p) /**< context */
        -:   67:{
    #####:   68:  PARSER_THROW (context_p->try_buffer);
        -:   69:  /* Should never been reached. */
        -:   70:  JERRY_ASSERT (0);
        -:   71:} /* scanner_raise_error */
        -:   72:
        -:   73:#if JERRY_ESNEXT
        -:   74:
        -:   75:/**
        -:   76: * Raise a variable redeclaration error.
        -:   77: */
        -:   78:void
    #####:   79:scanner_raise_redeclaration_error (parser_context_t *context_p) /**< context */
        -:   80:{
    #####:   81:  scanner_info_t *info_p = scanner_insert_info (context_p, context_p->source_p, sizeof (scanner_info_t));
    #####:   82:  info_p->type = SCANNER_TYPE_ERR_REDECLARED;
        -:   83:
    #####:   84:  scanner_raise_error (context_p);
    #####:   85:} /* scanner_raise_redeclaration_error */
        -:   86:
        -:   87:#endif /* JERRY_ESNEXT */
        -:   88:
        -:   89:/**
        -:   90: * Allocate memory for scanner.
        -:   91: *
        -:   92: * @return allocated memory
        -:   93: */
        -:   94:void *
       79:   95:scanner_malloc (parser_context_t *context_p, /**< context */
        -:   96:                size_t size) /**< size of the memory block */
        -:   97:{
        -:   98:  void *result;
        -:   99:
       79:  100:  JERRY_ASSERT (size > 0);
       79:  101:  result = jmem_heap_alloc_block_null_on_error (size);
        -:  102:
       79:  103:  if (result == NULL)
        -:  104:  {
    #####:  105:    scanner_cleanup (context_p);
        -:  106:
        -:  107:    /* This is the only error which specify its reason. */
    #####:  108:    context_p->error = PARSER_ERR_OUT_OF_MEMORY;
    #####:  109:    PARSER_THROW (context_p->try_buffer);
        -:  110:  }
       79:  111:  return result;
        -:  112:} /* scanner_malloc */
        -:  113:
        -:  114:/**
        -:  115: * Free memory allocated by scanner_malloc.
        -:  116: */
        -:  117:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  118:scanner_free (void *ptr, /**< pointer to free */
        -:  119:              size_t size) /**< size of the memory block */
        -:  120:{
       40:  121:  jmem_heap_free_block (ptr, size);
    #####:  122:} /* scanner_free */
        -:  123:
        -:  124:/**
        -:  125: * Count the size of a stream after an info block.
        -:  126: *
        -:  127: * @return the size in bytes
        -:  128: */
        -:  129:size_t
    #####:  130:scanner_get_stream_size (scanner_info_t *info_p, /**< scanner info block */
        -:  131:                         size_t size) /**< size excluding the stream */
        -:  132:{
    #####:  133:  const uint8_t *data_p = ((const uint8_t *) info_p) + size;
    #####:  134:  const uint8_t *data_p_start = data_p;
        -:  135:
    #####:  136:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -:  137:  {
    #####:  138:    switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -:  139:    {
    #####:  140:      case SCANNER_STREAM_TYPE_VAR:
        -:  141:#if JERRY_ESNEXT
        -:  142:      case SCANNER_STREAM_TYPE_LET:
        -:  143:      case SCANNER_STREAM_TYPE_CONST:
        -:  144:      case SCANNER_STREAM_TYPE_LOCAL:
        -:  145:#endif /* JERRY_ESNEXT */
        -:  146:#if JERRY_MODULE_SYSTEM
        -:  147:      case SCANNER_STREAM_TYPE_IMPORT:
        -:  148:#endif /* JERRY_MODULE_SYSTEM */
        -:  149:      case SCANNER_STREAM_TYPE_ARG:
        -:  150:#if JERRY_ESNEXT
        -:  151:      case SCANNER_STREAM_TYPE_ARG_VAR:
        -:  152:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -:  153:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -:  154:#endif /* JERRY_MODULE_SYSTEM */
        -:  155:      case SCANNER_STREAM_TYPE_ARG_FUNC:
        -:  156:#if JERRY_ESNEXT
        -:  157:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -:  158:#endif /* JERRY_ESNEXT */
        -:  159:      case SCANNER_STREAM_TYPE_FUNC:
        -:  160:      {
    #####:  161:        break;
        -:  162:      }
    #####:  163:      default:
        -:  164:      {
    #####:  165:        JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE
        -:  166:                      || SCANNER_STREAM_TYPE_IS_ARGUMENTS (data_p[0] & SCANNER_STREAM_TYPE_MASK));
    #####:  167:        data_p++;
    #####:  168:        continue;
        -:  169:      }
        -:  170:    }
        -:  171:
    #####:  172:    data_p += 3;
        -:  173:
    #####:  174:    if (data_p[-3] & SCANNER_STREAM_UINT16_DIFF)
        -:  175:    {
    #####:  176:      data_p++;
        -:  177:    }
    #####:  178:    else if (data_p[-1] == 0)
        -:  179:    {
    #####:  180:      data_p += sizeof (const uint8_t *);
        -:  181:    }
        -:  182:  }
        -:  183:
    #####:  184:  return size + 1 + (size_t) (data_p - data_p_start);
        -:  185:} /* scanner_get_stream_size */
        -:  186:
        -:  187:/**
        -:  188: * Insert a scanner info block into the scanner info chain.
        -:  189: *
        -:  190: * @return newly allocated scanner info
        -:  191: */
        -:  192:scanner_info_t *
       39:  193:scanner_insert_info (parser_context_t *context_p, /**< context */
        -:  194:                     const uint8_t *source_p, /**< triggering position */
        -:  195:                     size_t size) /**< size of the memory block */
        -:  196:{
       39:  197:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
       39:  198:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
       39:  199:  scanner_info_t *prev_scanner_info_p = NULL;
        -:  200:
       39:  201:  JERRY_ASSERT (scanner_info_p != NULL);
       39:  202:  JERRY_ASSERT (source_p != NULL);
        -:  203:
       39:  204:  new_scanner_info_p->source_p = source_p;
        -:  205:
      156:  206:  while (source_p < scanner_info_p->source_p)
        -:  207:  {
       78:  208:    prev_scanner_info_p = scanner_info_p;
       78:  209:    scanner_info_p = scanner_info_p->next_p;
        -:  210:
       78:  211:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  212:  }
        -:  213:
        -:  214:  /* Multiple scanner info blocks cannot be assigned to the same position. */
       39:  215:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  216:
       39:  217:  new_scanner_info_p->next_p = scanner_info_p;
        -:  218:
       39:  219:  if (JERRY_LIKELY (prev_scanner_info_p == NULL))
        -:  220:  {
       30:  221:    context_p->next_scanner_info_p = new_scanner_info_p;
        -:  222:  }
        -:  223:  else
        -:  224:  {
        9:  225:    prev_scanner_info_p->next_p = new_scanner_info_p;
        -:  226:  }
        -:  227:
       39:  228:  return new_scanner_info_p;
        -:  229:} /* scanner_insert_info */
        -:  230:
        -:  231:/**
        -:  232: * Insert a scanner info block into the scanner info chain before a given info block.
        -:  233: *
        -:  234: * @return newly allocated scanner info
        -:  235: */
        -:  236:scanner_info_t *
    #####:  237:scanner_insert_info_before (parser_context_t *context_p, /**< context */
        -:  238:                            const uint8_t *source_p, /**< triggering position */
        -:  239:                            scanner_info_t *start_info_p, /**< first info position */
        -:  240:                            size_t size) /**< size of the memory block */
        -:  241:{
    #####:  242:  JERRY_ASSERT (start_info_p != NULL);
        -:  243:
    #####:  244:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
    #####:  245:  scanner_info_t *scanner_info_p = start_info_p->next_p;
    #####:  246:  scanner_info_t *prev_scanner_info_p = start_info_p;
        -:  247:
    #####:  248:  new_scanner_info_p->source_p = source_p;
        -:  249:
    #####:  250:  while (source_p < scanner_info_p->source_p)
        -:  251:  {
    #####:  252:    prev_scanner_info_p = scanner_info_p;
    #####:  253:    scanner_info_p = scanner_info_p->next_p;
        -:  254:
    #####:  255:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  256:  }
        -:  257:
        -:  258:  /* Multiple scanner info blocks cannot be assigned to the same position. */
    #####:  259:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  260:
    #####:  261:  new_scanner_info_p->next_p = scanner_info_p;
        -:  262:
    #####:  263:  prev_scanner_info_p->next_p = new_scanner_info_p;
    #####:  264:  return new_scanner_info_p;
        -:  265:} /* scanner_insert_info_before */
        -:  266:
        -:  267:/**
        -:  268: * Release the next scanner info.
        -:  269: */
        -:  270:extern inline void JERRY_ATTR_ALWAYS_INLINE
       10:  271:scanner_release_next (parser_context_t *context_p, /**< context */
        -:  272:                      size_t size) /**< size of the memory block */
        -:  273:{
       39:  274:  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;
        -:  275:
       39:  276:  jmem_heap_free_block (context_p->next_scanner_info_p, size);
       39:  277:  context_p->next_scanner_info_p = next_p;
       10:  278:} /* scanner_release_next */
        -:  279:
        -:  280:/**
        -:  281: * Set the active scanner info to the next scanner info.
        -:  282: */
        -:  283:extern inline void JERRY_ATTR_ALWAYS_INLINE
        3:  284:scanner_set_active (parser_context_t *context_p) /**< context */
        -:  285:{
        3:  286:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -:  287:
        3:  288:  context_p->next_scanner_info_p = scanner_info_p->next_p;
        3:  289:  scanner_info_p->next_p = context_p->active_scanner_info_p;
        3:  290:  context_p->active_scanner_info_p = scanner_info_p;
        3:  291:} /* scanner_set_active */
        -:  292:
        -:  293:/**
        -:  294: * Set the next scanner info to the active scanner info.
        -:  295: */
        -:  296:extern inline void JERRY_ATTR_ALWAYS_INLINE
        3:  297:scanner_revert_active (parser_context_t *context_p) /**< context */
        -:  298:{
        3:  299:  scanner_info_t *scanner_info_p = context_p->active_scanner_info_p;
        -:  300:
        3:  301:  context_p->active_scanner_info_p = scanner_info_p->next_p;
        3:  302:  scanner_info_p->next_p = context_p->next_scanner_info_p;
        3:  303:  context_p->next_scanner_info_p = scanner_info_p;
        3:  304:} /* scanner_revert_active */
        -:  305:
        -:  306:/**
        -:  307: * Release the active scanner info.
        -:  308: */
        -:  309:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  310:scanner_release_active (parser_context_t *context_p, /**< context */
        -:  311:                        size_t size) /**< size of the memory block */
        -:  312:{
    #####:  313:  scanner_info_t *next_p = context_p->active_scanner_info_p->next_p;
        -:  314:
    #####:  315:  jmem_heap_free_block (context_p->active_scanner_info_p, size);
    #####:  316:  context_p->active_scanner_info_p = next_p;
    #####:  317:} /* scanner_release_active */
        -:  318:
        -:  319:/**
        -:  320: * Release switch cases.
        -:  321: */
        -:  322:void
    #####:  323:scanner_release_switch_cases (scanner_case_info_t *case_p) /**< case list */
        -:  324:{
    #####:  325:  while (case_p != NULL)
        -:  326:  {
    #####:  327:    scanner_case_info_t *next_p = case_p->next_p;
        -:  328:
    #####:  329:    jmem_heap_free_block (case_p, sizeof (scanner_case_info_t));
    #####:  330:    case_p = next_p;
        -:  331:  }
    #####:  332:} /* scanner_release_switch_cases */
        -:  333:
        -:  334:/**
        -:  335: * Release private fields.
        -:  336: */
        -:  337:void
        9:  338:scanner_release_private_fields (scanner_class_private_member_t *member_p) /**< private member list */
        -:  339:{
       18:  340:  while (member_p != NULL)
        -:  341:  {
    #####:  342:    scanner_class_private_member_t *prev_p = member_p->prev_p;
        -:  343:
    #####:  344:    jmem_heap_free_block (member_p, sizeof (scanner_class_private_member_t));
    #####:  345:    member_p = prev_p;
        -:  346:  }
        9:  347:} /* scanner_release_private_fields */
        -:  348:
        -:  349:/**
        -:  350: * Seek to correct position in the scanner info list.
        -:  351: */
        -:  352:void
        3:  353:scanner_seek (parser_context_t *context_p) /**< context */
        -:  354:{
        3:  355:  const uint8_t *source_p = context_p->source_p;
        -:  356:  scanner_info_t *prev_p;
        -:  357:
        3:  358:  if (context_p->skipped_scanner_info_p != NULL)
        -:  359:  {
    #####:  360:    JERRY_ASSERT (context_p->skipped_scanner_info_p->source_p != NULL);
        -:  361:
    #####:  362:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
        -:  363:
    #####:  364:    if (context_p->skipped_scanner_info_end_p->source_p <= source_p)
        -:  365:    {
    #####:  366:      prev_p = context_p->skipped_scanner_info_end_p;
        -:  367:    }
        -:  368:    else
        -:  369:    {
    #####:  370:      prev_p = context_p->skipped_scanner_info_p;
        -:  371:
    #####:  372:      if (prev_p->source_p > source_p)
        -:  373:      {
    #####:  374:        context_p->next_scanner_info_p = prev_p;
    #####:  375:        context_p->skipped_scanner_info_p = NULL;
    #####:  376:        return;
        -:  377:      }
        -:  378:
    #####:  379:      context_p->skipped_scanner_info_p = prev_p;
        -:  380:    }
        -:  381:  }
        -:  382:  else
        -:  383:  {
        3:  384:    prev_p = context_p->next_scanner_info_p;
        -:  385:
        3:  386:    if (prev_p->source_p == NULL || prev_p->source_p > source_p)
        -:  387:    {
        3:  388:      return;
        -:  389:    }
        -:  390:
    #####:  391:    context_p->skipped_scanner_info_p = prev_p;
        -:  392:  }
        -:  393:
    #####:  394:  while (prev_p->next_p->source_p != NULL && prev_p->next_p->source_p <= source_p)
        -:  395:  {
    #####:  396:    prev_p = prev_p->next_p;
        -:  397:  }
        -:  398:
    #####:  399:  context_p->skipped_scanner_info_end_p = prev_p;
    #####:  400:  context_p->next_scanner_info_p = prev_p->next_p;
        -:  401:} /* scanner_seek */
        -:  402:
        -:  403:#if JERRY_ESNEXT
        -:  404:
        -:  405:/**
        -:  406: * Find any let/const declaration of a given literal.
        -:  407: *
        -:  408: * @return true - if the literal is found, false - otherwise
        -:  409: */
        -:  410:static bool
        2:  411:scanner_scope_find_lexical_declaration (parser_context_t *context_p, /**< context */
        -:  412:                                        lexer_lit_location_t *literal_p) /**< literal */
        -:  413:{
        -:  414:  ecma_string_t *name_p;
        2:  415:  uint32_t flags = context_p->global_status_flags;
        -:  416:
        2:  417:  if (!(flags & ECMA_PARSE_EVAL) || (!(flags & ECMA_PARSE_DIRECT_EVAL) && (context_p->status_flags & PARSER_IS_STRICT)))
        -:  418:  {
        2:  419:    return false;
        -:  420:  }
        -:  421:
    #####:  422:  if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -:  423:  {
    #####:  424:    name_p = ecma_new_ecma_string_from_utf8 (literal_p->char_p, literal_p->length);
        -:  425:  }
        -:  426:  else
        -:  427:  {
    #####:  428:    uint8_t *destination_p = (uint8_t *) scanner_malloc (context_p, literal_p->length);
        -:  429:
    #####:  430:    lexer_convert_ident_to_cesu8 (destination_p, literal_p->char_p, literal_p->length);
        -:  431:
    #####:  432:    name_p = ecma_new_ecma_string_from_utf8 (destination_p, literal_p->length);
        -:  433:
    #####:  434:    scanner_free (destination_p, literal_p->length);
        -:  435:  }
        -:  436:
        -:  437:  ecma_object_t *lex_env_p;
        -:  438:
    #####:  439:  if (flags & ECMA_PARSE_DIRECT_EVAL)
        -:  440:  {
    #####:  441:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  442:
    #####:  443:    while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -:  444:    {
    #####:  445:      if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  446:      {
    #####:  447:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  448:
    #####:  449:        if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -:  450:        {
    #####:  451:          ecma_deref_ecma_string (name_p);
    #####:  452:          return true;
        -:  453:        }
        -:  454:      }
        -:  455:
    #####:  456:      JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####:  457:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  458:    }
        -:  459:  }
        -:  460:  else
        -:  461:  {
    #####:  462:    lex_env_p = ecma_get_global_scope (ecma_builtin_get_global ());
        -:  463:  }
        -:  464:
    #####:  465:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  466:  {
    #####:  467:    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  468:
    #####:  469:    if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -:  470:    {
    #####:  471:      ecma_deref_ecma_string (name_p);
    #####:  472:      return true;
        -:  473:    }
        -:  474:  }
        -:  475:
    #####:  476:  ecma_deref_ecma_string (name_p);
    #####:  477:  return false;
        -:  478:} /* scanner_scope_find_lexical_declaration */
        -:  479:
        -:  480:#endif /* JERRY_ESNEXT */
        -:  481:
        -:  482:/**
        -:  483: * Push a new literal pool.
        -:  484: *
        -:  485: * @return the newly created literal pool
        -:  486: */
        -:  487:scanner_literal_pool_t *
       40:  488:scanner_push_literal_pool (parser_context_t *context_p, /**< context */
        -:  489:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  490:                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */
        -:  491:{
       40:  492:  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;
        -:  493:  scanner_literal_pool_t *literal_pool_p;
        -:  494:
       40:  495:  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -:  496:
       40:  497:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -:  498:  {
       17:  499:    JERRY_ASSERT (prev_literal_pool_p != NULL);
       17:  500:    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  501:
        -:  502:#if JERRY_ESNEXT
       17:  503:    const uint16_t copied_flags =
        -:  504:      (SCANNER_LITERAL_POOL_IN_WITH | SCANNER_LITERAL_POOL_GENERATOR | SCANNER_LITERAL_POOL_ASYNC);
        -:  505:#else /* !JERRY_ESNEXT */
    #####:  506:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;
        -:  507:#endif /* JERRY_ESNEXT */
        -:  508:
       17:  509:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  510:  }
        -:  511:#if JERRY_ESNEXT
        -:  512:  else
        -:  513:  {
       23:  514:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  515:
       23:  516:    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -:  517:    {
    #####:  518:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -:  519:    }
        -:  520:
       23:  521:    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  522:    {
    #####:  523:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  524:    }
        -:  525:  }
        -:  526:#endif /* JERRY_ESNEXT */
        -:  527:
       40:  528:  if (prev_literal_pool_p != NULL)
        -:  529:  {
       39:  530:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;
       39:  531:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  532:
        -:  533:    /* The logical value of these flags must be the same. */
       39:  534:    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));
        -:  535:  }
        -:  536:
       40:  537:  parser_list_init (&literal_pool_p->literal_pool,
        -:  538:                    sizeof (lexer_lit_location_t),
        -:  539:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
       40:  540:  literal_pool_p->source_p = NULL;
       40:  541:  literal_pool_p->status_flags = status_flags;
       40:  542:  literal_pool_p->no_declarations = 0;
        -:  543:
       40:  544:  literal_pool_p->prev_p = prev_literal_pool_p;
       40:  545:  scanner_context_p->active_literal_pool_p = literal_pool_p;
        -:  546:
       40:  547:  return literal_pool_p;
        -:  548:} /* scanner_push_literal_pool */
        -:  549:
        -:  550:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_IDENT_LENGTH <= UINT8_MAX, maximum_ident_length_must_fit_in_a_byte);
        -:  551:
        -:  552:/**
        -:  553: * Checks whether a literal is equal to "arguments".
        -:  554: */
        -:  555:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  556:scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */
        -:  557:{
       28:  558:  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) "arguments", 9);
        -:  559:} /* scanner_literal_is_arguments */
        -:  560:
        -:  561:/**
        -:  562: * Current status of arguments.
        -:  563: */
        -:  564:typedef enum
        -:  565:{
        -:  566:  SCANNER_ARGUMENTS_NOT_PRESENT, /**< arguments object must not be created */
        -:  567:  SCANNER_ARGUMENTS_MAY_PRESENT, /**< arguments object can be created */
        -:  568:  SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL, /**< arguments object must be present unless otherwise declared */
        -:  569:  SCANNER_ARGUMENTS_PRESENT, /**< arguments object must be created */
        -:  570:  SCANNER_ARGUMENTS_PRESENT_NO_REG, /**< arguments object must be created and cannot be stored in registers */
        -:  571:} scanner_arguments_type_t;
        -:  572:
        -:  573:/**
        -:  574: * Pop the last literal pool from the end.
        -:  575: */
        -:  576:void
       40:  577:scanner_pop_literal_pool (parser_context_t *context_p, /**< context */
        -:  578:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  579:{
       40:  580:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
       40:  581:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        -:  582:
        -:  583:#if JERRY_ESNEXT
       40:  584:  const uint32_t arrow_super_flags = (SCANNER_LITERAL_POOL_ARROW | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
       40:  585:  if ((literal_pool_p->status_flags & arrow_super_flags) == arrow_super_flags)
        -:  586:  {
        4:  587:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;
        -:  588:  }
        -:  589:#endif /* JERRY_ESNEXT */
        -:  590:
       40:  591:  if (JERRY_UNLIKELY (literal_pool_p->source_p == NULL))
        -:  592:  {
    #####:  593:    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);
    #####:  594:    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL
        -:  595:                  && literal_pool_p->literal_pool.data.last_p == NULL);
        -:  596:
    #####:  597:    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
    #####:  598:    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
    #####:  599:    return;
        -:  600:  }
        -:  601:
       40:  602:  uint16_t status_flags = literal_pool_p->status_flags;
       40:  603:  scanner_arguments_type_t arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT;
        -:  604:
       40:  605:  if (status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS)
        -:  606:  {
       18:  607:    arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  608:  }
       22:  609:  else if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -:  610:  {
    #####:  611:    arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL;
        -:  612:  }
        -:  613:
        -:  614:#if JERRY_ESNEXT
       40:  615:  if (status_flags & SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS)
        -:  616:  {
    #####:  617:    arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  618:
    #####:  619:    if (status_flags & (SCANNER_LITERAL_POOL_NO_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL))
        -:  620:    {
    #####:  621:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
    #####:  622:      status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  623:    }
        -:  624:  }
        -:  625:#endif /* JERRY_ESNEXT */
        -:  626:
       40:  627:  uint8_t can_eval_types = 0;
        -:  628:#if JERRY_ESNEXT
       40:  629:  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -:  630:  {
        1:  631:    can_eval_types |= SCANNER_LITERAL_IS_FUNC;
        -:  632:  }
        -:  633:#endif /* JERRY_ESNEXT */
        -:  634:
       40:  635:  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)
        -:  636:  {
    #####:  637:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  638:  }
        -:  639:
        -:  640:#if JERRY_DEBUGGER
        -:  641:  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)
        -:  642:  {
        -:  643:    /* When debugger is enabled, identifiers are not stored in registers. However,
        -:  644:     * this does not affect 'eval' detection, so 'arguments' object is not created. */
        -:  645:    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  646:  }
        -:  647:#endif /* JERRY_DEBUGGER */
        -:  648:
       40:  649:  parser_list_iterator_t literal_iterator;
        -:  650:  lexer_lit_location_t *literal_p;
       40:  651:  int32_t no_declarations = literal_pool_p->no_declarations;
        -:  652:
       40:  653:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -:  654:
       40:  655:  uint8_t arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS;
       40:  656:  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;
       40:  657:  lexer_lit_location_t *last_argument_p = NULL;
       40:  658:  size_t compressed_size = 1;
        -:  659:
      127:  660:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  661:  {
       47:  662:    uint8_t type = literal_p->type;
        -:  663:
       47:  664:    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))
        -:  665:    {
    #####:  666:      continue;
        -:  667:    }
        -:  668:
       75:  669:    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))
        -:  670:    {
        -:  671:#if JERRY_ESNEXT
    #####:  672:      JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT);
        -:  673:#else /* !JERRY_ESNEXT */
        -:  674:      JERRY_ASSERT (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT
        -:  675:                    || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL);
        -:  676:#endif /* JERRY_ESNEXT */
        -:  677:
    #####:  678:      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  679:
    #####:  680:      if (type & SCANNER_LITERAL_IS_ARG)
        -:  681:      {
    #####:  682:        JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_PRESENT
        -:  683:                      && arguments_type != SCANNER_ARGUMENTS_PRESENT_NO_REG);
    #####:  684:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
    #####:  685:        last_argument_p = literal_p;
        -:  686:      }
        -:  687:#if JERRY_ESNEXT
    #####:  688:      else if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  689:      {
    #####:  690:        if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  691:        {
    #####:  692:          arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  693:        }
        -:  694:        else
        -:  695:        {
    #####:  696:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  697:          {
    #####:  698:            type |= SCANNER_LITERAL_NO_REG;
        -:  699:          }
    #####:  700:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  701:          {
    #####:  702:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  703:          }
        -:  704:
    #####:  705:          if ((type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC)
        -:  706:          {
    #####:  707:            type |= SCANNER_LITERAL_IS_ARG;
    #####:  708:            literal_p->type = type;
    #####:  709:            no_declarations--;
    #####:  710:            arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS_FUNC;
        -:  711:          }
        -:  712:          else
        -:  713:          {
    #####:  714:            arguments_stream_type |= SCANNER_STREAM_LOCAL_ARGUMENTS;
        -:  715:          }
        -:  716:        }
        -:  717:      }
        -:  718:#else /* !JERRY_ESNEXT */
    #####:  719:      else if (type & SCANNER_LITERAL_IS_FUNC)
        -:  720:      {
        -:  721:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  722:      }
        -:  723:#endif /* JERRY_ESNEXT */
        -:  724:      else
        -:  725:      {
        -:  726:#if JERRY_ESNEXT
    #####:  727:        if ((type & SCANNER_LITERAL_IS_VAR)
    #####:  728:            && (arguments_type == SCANNER_ARGUMENTS_PRESENT || arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG))
        -:  729:        {
    #####:  730:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  731:          {
    #####:  732:            type |= SCANNER_LITERAL_NO_REG;
        -:  733:          }
    #####:  734:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  735:          {
    #####:  736:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  737:          }
        -:  738:
    #####:  739:          type |= SCANNER_LITERAL_IS_ARG;
    #####:  740:          literal_p->type = type;
    #####:  741:          no_declarations--;
        -:  742:        }
        -:  743:#endif /* JERRY_ESNEXT */
        -:  744:
    #####:  745:        if ((type & SCANNER_LITERAL_NO_REG) || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  746:        {
    #####:  747:          arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  748:        }
    #####:  749:        else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  750:        {
    #####:  751:          arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  752:        }
        -:  753:
        -:  754:#if JERRY_ESNEXT
        -:  755:        /* The SCANNER_LITERAL_IS_ARG may be set above. */
    #####:  756:        if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  757:        {
    #####:  758:          literal_p->type = 0;
    #####:  759:          continue;
        -:  760:        }
        -:  761:#else /* !JERRY_ESNEXT */
    #####:  762:        literal_p->type = 0;
    #####:  763:        continue;
        -:  764:#endif /* JERRY_ESNEXT */
        -:  765:      }
        -:  766:    }
       47:  767:    else if (type & SCANNER_LITERAL_IS_ARG)
        -:  768:    {
        4:  769:      last_argument_p = literal_p;
        -:  770:    }
        -:  771:
        -:  772:#if JERRY_ESNEXT
       47:  773:    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
       32:  774:        && (type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_FUNC)
        -:  775:    {
    #####:  776:      if (prev_literal_pool_p == NULL && scanner_scope_find_lexical_declaration (context_p, literal_p))
        -:  777:      {
    #####:  778:        literal_p->type = 0;
    #####:  779:        continue;
        -:  780:      }
        -:  781:
    #####:  782:      if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  783:      {
    #####:  784:        type |= SCANNER_LITERAL_IS_VAR;
        -:  785:      }
        -:  786:
    #####:  787:      type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
    #####:  788:      literal_p->type = type;
        -:  789:    }
        -:  790:#endif /* JERRY_ESNEXT */
        -:  791:
       47:  792:    if ((type & SCANNER_LITERAL_IS_LOCAL)
       32:  793:        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        4:  794:            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))
        -:  795:    {
       19:  796:      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || !(literal_p->type & SCANNER_LITERAL_IS_ARG));
        -:  797:
       19:  798:      if (literal_p->length == 0)
        -:  799:      {
    #####:  800:        compressed_size += 1;
    #####:  801:        continue;
        -:  802:      }
        -:  803:
       19:  804:      no_declarations++;
        -:  805:
       19:  806:      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))
        -:  807:      {
        2:  808:        type |= SCANNER_LITERAL_NO_REG;
        2:  809:        literal_p->type = type;
        -:  810:      }
        -:  811:
       19:  812:      if (type & SCANNER_LITERAL_IS_FUNC)
        -:  813:      {
        3:  814:        no_declarations++;
        -:  815:
        -:  816:#if JERRY_ESNEXT
        3:  817:        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)
        -:  818:        {
    #####:  819:          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);
        -:  820:
        -:  821:          /* Catch parameters cannot be functions. */
    #####:  822:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  823:          no_declarations--;
        -:  824:        }
        -:  825:#else /* !JERRY_ESNEXT */
    #####:  826:        if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  827:        {
        -:  828:          /* Catch parameters cannot be functions. */
    #####:  829:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  830:          no_declarations--;
        -:  831:        }
        -:  832:#endif /* JERRY_ESNEXT */
        -:  833:      }
        -:  834:
       19:  835:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -:  836:
       19:  837:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -:  838:      {
       19:  839:        compressed_size += 2 + 1;
        -:  840:      }
    #####:  841:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -:  842:      {
    #####:  843:        compressed_size += 2 + 2;
        -:  844:      }
        -:  845:      else
        -:  846:      {
    #####:  847:        compressed_size += 2 + 1 + sizeof (const uint8_t *);
        -:  848:      }
        -:  849:
       19:  850:      prev_source_p = literal_p->char_p + literal_p->length;
        -:  851:
       19:  852:      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  853:#if JERRY_ESNEXT
        2:  854:          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))
        -:  855:#endif /* JERRY_ESNEXT */
        2:  856:          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))
        -:  857:      {
       19:  858:        continue;
        -:  859:      }
        -:  860:    }
        -:  861:
       28:  862:    if (prev_literal_pool_p != NULL && literal_p->length > 0)
        -:  863:    {
        -:  864:      /* Propagate literal to upper level. */
       28:  865:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
       28:  866:      uint8_t extended_type = literal_location_p->type;
        -:  867:
        -:  868:#if JERRY_ESNEXT
       28:  869:      const uint16_t no_reg_flags = (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_CLASS_FIELD);
        -:  870:#else /* !JERRY_ESNEXT */
    #####:  871:      const uint16_t no_reg_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  872:#endif /* JERRY_ESNEXT */
        -:  873:
       28:  874:      if ((status_flags & no_reg_flags) || (type & SCANNER_LITERAL_NO_REG))
        -:  875:      {
       15:  876:        extended_type |= SCANNER_LITERAL_NO_REG;
        -:  877:      }
        -:  878:
        -:  879:#if JERRY_ESNEXT
       28:  880:      extended_type |= SCANNER_LITERAL_IS_USED;
        -:  881:
       28:  882:      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  883:      {
    #####:  884:        extended_type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  885:      }
        -:  886:
       28:  887:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);
        -:  888:
       28:  889:      if ((type & SCANNER_LITERAL_IS_ARG) || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET
        6:  890:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)
        -:  891:      {
        -:  892:        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags
        -:  893:         * for speculative arrow parameters and local (non-var) functions. */
       22:  894:        type = 0;
        -:  895:      }
        -:  896:#endif /* JERRY_ESNEXT */
        -:  897:
       28:  898:      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));
       28:  899:      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -:  900:
       28:  901:      literal_location_p->type = (uint8_t) (extended_type | type);
        -:  902:    }
        -:  903:  }
        -:  904:
       40:  905:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))
        -:  906:  {
       29:  907:    if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  908:    {
       22:  909:      arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  910:    }
        7:  911:    else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  912:    {
    #####:  913:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  914:    }
        -:  915:
       29:  916:    if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -:  917:    {
    #####:  918:      compressed_size++;
        -:  919:    }
        -:  920:
       29:  921:    compressed_size += sizeof (scanner_info_t);
        -:  922:
        -:  923:    scanner_info_t *info_p;
        -:  924:
       29:  925:    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)
        -:  926:    {
       29:  927:      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);
        -:  928:    }
        -:  929:    else
        -:  930:    {
    #####:  931:      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;
    #####:  932:      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);
        -:  933:    }
        -:  934:
       29:  935:    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  936:    {
    #####:  937:      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;
        -:  938:    }
        -:  939:
       29:  940:    uint8_t *data_p = (uint8_t *) (info_p + 1);
       29:  941:    bool mapped_arguments = false;
        -:  942:
       29:  943:    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  944:    {
       27:  945:      info_p->type = SCANNER_TYPE_FUNCTION;
        -:  946:
       27:  947:      uint8_t u8_arg = 0;
        -:  948:
       27:  949:      if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -:  950:      {
    #####:  951:        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;
        -:  952:
    #####:  953:        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  954:        {
    #####:  955:          no_declarations++;
        -:  956:        }
        -:  957:
        -:  958:#if JERRY_ESNEXT
    #####:  959:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -:  960:#else /* !JERRY_ESNEXT */
    #####:  961:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;
        -:  962:#endif /* JERRY_ESNEXT */
        -:  963:
    #####:  964:        if (!(status_flags & is_unmapped))
        -:  965:        {
    #####:  966:          mapped_arguments = true;
        -:  967:        }
        -:  968:
    #####:  969:        if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  970:        {
    #####:  971:          arguments_stream_type |= SCANNER_STREAM_NO_REG;
        -:  972:        }
        -:  973:
    #####:  974:        if (last_argument_p == NULL)
        -:  975:        {
    #####:  976:          *data_p++ = arguments_stream_type;
        -:  977:        }
        -:  978:      }
        -:  979:      else
        -:  980:      {
       27:  981:        last_argument_p = NULL;
        -:  982:      }
        -:  983:
        -:  984:#if JERRY_ESNEXT
       27:  985:      if (status_flags & (SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT | SCANNER_LITERAL_POOL_ARROW))
        -:  986:      {
        5:  987:        u8_arg |= SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -:  988:      }
        -:  989:
       27:  990:      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  991:      {
    #####:  992:        u8_arg |= SCANNER_FUNCTION_ASYNC;
        -:  993:
    #####:  994:        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  995:        {
    #####:  996:          u8_arg |= SCANNER_FUNCTION_STATEMENT;
        -:  997:        }
        -:  998:      }
        -:  999:
       27: 1000:      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -: 1001:      {
        1: 1002:        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;
        -: 1003:      }
        -: 1004:
       27: 1005:      if (status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -: 1006:      {
    #####: 1007:        u8_arg |= SCANNER_FUNCTION_IS_STRICT;
        -: 1008:      }
        -: 1009:#endif /* JERRY_ESNEXT */
        -: 1010:
       27: 1011:      info_p->u8_arg = u8_arg;
       27: 1012:      info_p->u16_arg = (uint16_t) no_declarations;
        -: 1013:    }
        -: 1014:    else
        -: 1015:    {
        2: 1016:      info_p->type = SCANNER_TYPE_BLOCK;
        -: 1017:
        2: 1018:      JERRY_ASSERT (prev_literal_pool_p != NULL);
        -: 1019:    }
        -: 1020:
       29: 1021:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
       29: 1022:    prev_source_p = literal_pool_p->source_p - 1;
       29: 1023:    no_declarations = literal_pool_p->no_declarations;
        -: 1024:
       94: 1025:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1026:    {
       36: 1027:      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
       36: 1028:          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)
       21: 1029:              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        4: 1030:                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))
        -: 1031:      {
       17: 1032:        continue;
        -: 1033:      }
        -: 1034:
       19: 1035:      if (literal_p->length == 0)
        -: 1036:      {
    #####: 1037:        *data_p++ = SCANNER_STREAM_TYPE_HOLE;
        -: 1038:
    #####: 1039:        if (literal_p == last_argument_p)
        -: 1040:        {
    #####: 1041:          *data_p++ = arguments_stream_type;
        -: 1042:        }
    #####: 1043:        continue;
        -: 1044:      }
        -: 1045:
       19: 1046:      no_declarations++;
        -: 1047:
       19: 1048:      uint8_t type = SCANNER_STREAM_TYPE_VAR;
        -: 1049:
       19: 1050:      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1051:      {
        3: 1052:        no_declarations++;
        3: 1053:        type = SCANNER_STREAM_TYPE_FUNC;
        -: 1054:
        3: 1055:        if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1056:        {
    #####: 1057:          type = SCANNER_STREAM_TYPE_ARG_FUNC;
        -: 1058:
        -: 1059:#if JERRY_ESNEXT
    #####: 1060:          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1061:          {
    #####: 1062:            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;
        -: 1063:          }
        -: 1064:#endif /* JERRY_ESNEXT */
        -: 1065:        }
        -: 1066:      }
       16: 1067:      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1068:      {
        4: 1069:        type = SCANNER_STREAM_TYPE_ARG;
        -: 1070:
        -: 1071:#if JERRY_ESNEXT
        4: 1072:        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1073:        {
    #####: 1074:          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;
        -: 1075:        }
        -: 1076:
        4: 1077:        if (literal_p->type & SCANNER_LITERAL_IS_VAR)
        -: 1078:        {
    #####: 1079:          type = (uint8_t) (type + 1);
        -: 1080:
    #####: 1081:          JERRY_ASSERT (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR);
        -: 1082:        }
        -: 1083:#endif /* JERRY_ESNEXT */
        -: 1084:      }
        -: 1085:#if JERRY_ESNEXT
       12: 1086:      else if (literal_p->type & SCANNER_LITERAL_IS_LET)
        -: 1087:      {
       12: 1088:        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))
        -: 1089:        {
       11: 1090:          type = SCANNER_STREAM_TYPE_LET;
        -: 1091:
       11: 1092:          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1093:          {
    #####: 1094:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1095:          }
        -: 1096:        }
        -: 1097:#if JERRY_MODULE_SYSTEM
        1: 1098:        else if (prev_literal_pool_p == NULL)
        -: 1099:        {
    #####: 1100:          type = SCANNER_STREAM_TYPE_IMPORT;
        -: 1101:        }
        -: 1102:#endif /* JERRY_MODULE_SYSTEM */
        -: 1103:        else
        -: 1104:        {
        1: 1105:          type = SCANNER_STREAM_TYPE_LOCAL;
        -: 1106:        }
        -: 1107:      }
    #####: 1108:      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)
        -: 1109:      {
    #####: 1110:        type = SCANNER_STREAM_TYPE_CONST;
        -: 1111:
    #####: 1112:        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1113:        {
    #####: 1114:          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1115:        }
        -: 1116:      }
        -: 1117:
       19: 1118:      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)
        -: 1119:      {
    #####: 1120:        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;
        -: 1121:      }
        -: 1122:#endif /* JERRY_ESNEXT */
        -: 1123:
       19: 1124:      if (literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 1125:      {
    #####: 1126:        type |= SCANNER_STREAM_HAS_ESCAPE;
        -: 1127:      }
        -: 1128:
       19: 1129:      if ((literal_p->type & SCANNER_LITERAL_NO_REG)
        8: 1130:          || (mapped_arguments && (literal_p->type & SCANNER_LITERAL_IS_ARG)))
        -: 1131:      {
       11: 1132:        type |= SCANNER_STREAM_NO_REG;
        -: 1133:      }
        -: 1134:
       19: 1135:      data_p[0] = type;
       19: 1136:      data_p[1] = (uint8_t) literal_p->length;
       19: 1137:      data_p += 3;
        -: 1138:
       19: 1139:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -: 1140:
       19: 1141:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -: 1142:      {
       19: 1143:        data_p[-1] = (uint8_t) diff;
        -: 1144:      }
    #####: 1145:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -: 1146:      {
    #####: 1147:        if (diff < 0)
        -: 1148:        {
    #####: 1149:          diff = -diff;
        -: 1150:        }
        -: 1151:
    #####: 1152:        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;
    #####: 1153:        data_p[-1] = (uint8_t) diff;
    #####: 1154:        data_p[0] = (uint8_t) (diff >> 8);
    #####: 1155:        data_p += 1;
        -: 1156:      }
        -: 1157:      else
        -: 1158:      {
    #####: 1159:        data_p[-1] = 0;
    #####: 1160:        memcpy (data_p, &literal_p->char_p, sizeof (uintptr_t));
    #####: 1161:        data_p += sizeof (uintptr_t);
        -: 1162:      }
        -: 1163:
       19: 1164:      if (literal_p == last_argument_p)
        -: 1165:      {
    #####: 1166:        *data_p++ = arguments_stream_type;
        -: 1167:      }
        -: 1168:
       19: 1169:      prev_source_p = literal_p->char_p + literal_p->length;
        -: 1170:    }
        -: 1171:
       29: 1172:    data_p[0] = SCANNER_STREAM_TYPE_END;
        -: 1173:
       29: 1174:    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);
        -: 1175:  }
        -: 1176:
       40: 1177:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)
       13: 1178:      && (int32_t) prev_literal_pool_p->no_declarations < no_declarations)
        -: 1179:  {
        2: 1180:    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;
        -: 1181:  }
        -: 1182:
       40: 1183:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)
        -: 1184:  {
       26: 1185:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -: 1186:    {
    #####: 1187:      context_p->status_flags |= PARSER_IS_STRICT;
        -: 1188:    }
        -: 1189:    else
        -: 1190:    {
       26: 1191:      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1192:    }
        -: 1193:
        -: 1194:#if JERRY_ESNEXT
       26: 1195:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 1196:    {
    #####: 1197:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 1198:    }
        -: 1199:    else
        -: 1200:    {
       26: 1201:      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;
        -: 1202:    }
        -: 1203:
       26: 1204:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -: 1205:    {
    #####: 1206:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 1207:    }
        -: 1208:    else
        -: 1209:    {
       26: 1210:      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;
        -: 1211:    }
        -: 1212:#endif /* JERRY_ESNEXT */
        -: 1213:  }
        -: 1214:
       40: 1215:  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
        -: 1216:
       40: 1217:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1218:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1219:} /* scanner_pop_literal_pool */
        -: 1220:
        -: 1221:#if JERRY_ESNEXT
        -: 1222:
        -: 1223:/**
        -: 1224: * Filter out the arguments from a literal pool.
        -: 1225: */
        -: 1226:void
       26: 1227:scanner_filter_arguments (parser_context_t *context_p, /**< context */
        -: 1228:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1229:{
        -: 1230:  /* Fast case: check whether all literals are arguments. */
       26: 1231:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
       26: 1232:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
       26: 1233:  parser_list_iterator_t literal_iterator;
        -: 1234:  lexer_lit_location_t *literal_p;
       26: 1235:  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
       26: 1236:  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;
        -: 1237:
       26: 1238:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1239:
       26: 1240:  if (can_eval)
        -: 1241:  {
    #####: 1242:    if (prev_literal_pool_p != NULL)
        -: 1243:    {
    #####: 1244:      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1245:    }
        -: 1246:
    #####: 1247:    if (has_arguments)
        -: 1248:    {
        -: 1249:      /* Force the lexically stored arguments object creation */
    #####: 1250:      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
        -: 1251:    }
        -: 1252:  }
        -: 1253:
       26: 1254:  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1255:
       26: 1256:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1257:
        -: 1258:  while (true)
        4: 1259:  {
       30: 1260:    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);
        -: 1261:
       30: 1262:    if (literal_p == NULL)
        -: 1263:    {
       26: 1264:      return;
        -: 1265:    }
        -: 1266:
        4: 1267:    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1268:    {
    #####: 1269:      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1270:    }
        -: 1271:
        4: 1272:    uint8_t type = literal_p->type;
        4: 1273:    const uint8_t mask =
        -: 1274:      (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);
        -: 1275:
        4: 1276:    if ((type & mask) != SCANNER_LITERAL_IS_ARG)
        -: 1277:    {
    #####: 1278:      break;
        -: 1279:    }
        -: 1280:  }
        -: 1281:
        -: 1282:  /* Destructured args are placed after the other arguments because of register assignments. */
    #####: 1283:  bool has_destructured_arg = false;
        -: 1284:  scanner_literal_pool_t *new_literal_pool_p;
        -: 1285:
    #####: 1286:  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -: 1287:
    #####: 1288:  new_literal_pool_p->prev_p = literal_pool_p;
    #####: 1289:  scanner_context_p->active_literal_pool_p = new_literal_pool_p;
        -: 1290:
    #####: 1291:  *new_literal_pool_p = *literal_pool_p;
    #####: 1292:  parser_list_init (&new_literal_pool_p->literal_pool,
        -: 1293:                    sizeof (lexer_lit_location_t),
        -: 1294:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        -: 1295:
    #####: 1296:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1297:
    #####: 1298:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1299:  {
    #####: 1300:    uint8_t type = literal_p->type;
        -: 1301:
    #####: 1302:    if (type & SCANNER_LITERAL_IS_ARG)
        -: 1303:    {
    #####: 1304:      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1305:      {
    #####: 1306:        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
    #####: 1307:        literal_p->type = type;
        -: 1308:      }
        -: 1309:
    #####: 1310:      if (has_arguments && scanner_literal_is_arguments (literal_p))
        -: 1311:      {
        -: 1312:        /* 'arguments' function argument existence should prevent the arguments object construction */
    #####: 1313:        new_literal_pool_p->status_flags =
    #####: 1314:          (uint16_t) (new_literal_pool_p->status_flags
        -: 1315:                      & ~(SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS));
        -: 1316:      }
        -: 1317:
    #####: 1318:      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
        -: 1319:      {
    #####: 1320:        has_destructured_arg = true;
        -: 1321:
    #####: 1322:        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1323:        {
    #####: 1324:          continue;
        -: 1325:        }
        -: 1326:
    #####: 1327:        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
    #####: 1328:        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1329:
    #####: 1330:        literal_p->type = type;
    #####: 1331:        continue;
        -: 1332:      }
        -: 1333:
        -: 1334:      lexer_lit_location_t *new_literal_p;
    #####: 1335:      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1336:      *new_literal_p = *literal_p;
        -: 1337:    }
    #####: 1338:    else if (has_arguments && scanner_literal_is_arguments (literal_p))
        -: 1339:    {
        -: 1340:      /* Arguments object is directly referenced from the function arguments */
    #####: 1341:      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;
        -: 1342:
    #####: 1343:      if (type & SCANNER_LITERAL_NO_REG)
        -: 1344:      {
    #####: 1345:        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -: 1346:      }
        -: 1347:    }
    #####: 1348:    else if (prev_literal_pool_p != NULL)
        -: 1349:    {
        -: 1350:      /* Propagate literal to upper level. */
    #####: 1351:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
    #####: 1352:      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;
    #####: 1353:      literal_location_p->type |= type;
        -: 1354:    }
        -: 1355:  }
        -: 1356:
    #####: 1357:  if (has_destructured_arg)
        -: 1358:  {
    #####: 1359:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1360:
    #####: 1361:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1362:    {
    #####: 1363:      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1364:
    #####: 1365:      if ((literal_p->type & expected_flags) == expected_flags)
        -: 1366:      {
        -: 1367:        lexer_lit_location_t *new_literal_p;
    #####: 1368:        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1369:        *new_literal_p = *literal_p;
        -: 1370:      }
        -: 1371:    }
        -: 1372:  }
        -: 1373:
    #####: 1374:  new_literal_pool_p->prev_p = prev_literal_pool_p;
        -: 1375:
    #####: 1376:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1377:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1378:} /* scanner_filter_arguments */
        -: 1379:
        -: 1380:#endif /* JERRY_ESNEXT */
        -: 1381:
        -: 1382:/**
        -: 1383: * Add any literal to the specified literal pool.
        -: 1384: *
        -: 1385: * @return pointer to the literal
        -: 1386: */
        -: 1387:lexer_lit_location_t *
       99: 1388:scanner_add_custom_literal (parser_context_t *context_p, /**< context */
        -: 1389:                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */
        -: 1390:                            const lexer_lit_location_t *literal_location_p) /**< literal */
        -: 1391:{
        -: 1392:  while (true)
       12: 1393:  {
       99: 1394:    parser_list_iterator_t literal_iterator;
       99: 1395:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1396:    lexer_lit_location_t *literal_p;
        -: 1397:
       99: 1398:    const uint8_t *char_p = literal_location_p->char_p;
       99: 1399:    prop_length_t length = literal_location_p->length;
        -: 1400:
       99: 1401:    if (JERRY_LIKELY (!(literal_location_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1402:    {
      434: 1403:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1404:      {
      280: 1405:        if (literal_p->length == length)
        -: 1406:        {
      129: 1407:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1408:          {
      129: 1409:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1410:            {
       44: 1411:              return literal_p;
        -: 1412:            }
        -: 1413:          }
    #####: 1414:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1415:          {
        -: 1416:            /* The non-escaped version is preferred. */
    #####: 1417:            literal_p->char_p = char_p;
    #####: 1418:            literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 1419:            return literal_p;
        -: 1420:          }
        -: 1421:        }
        -: 1422:      }
        -: 1423:    }
        -: 1424:    else
        -: 1425:    {
    #####: 1426:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1427:      {
    #####: 1428:        if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1429:        {
    #####: 1430:          return literal_p;
        -: 1431:        }
        -: 1432:      }
        -: 1433:    }
        -: 1434:
        -: 1435:#if JERRY_ESNEXT
       55: 1436:    if (JERRY_UNLIKELY (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME))
        -: 1437:    {
       12: 1438:      literal_pool_p = literal_pool_p->prev_p;
       12: 1439:      continue;
        -: 1440:    }
        -: 1441:#endif /* JERRY_ESNEXT */
        -: 1442:
       43: 1443:    literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
       43: 1444:    *literal_p = *literal_location_p;
        -: 1445:
       43: 1446:    literal_p->type = 0;
        -: 1447:
       43: 1448:    return literal_p;
        -: 1449:  }
        -: 1450:} /* scanner_add_custom_literal */
        -: 1451:
        -: 1452:/**
        -: 1453: * Add the current literal token to the current literal pool.
        -: 1454: *
        -: 1455: * @return pointer to the literal
        -: 1456: */
        -: 1457:extern inline lexer_lit_location_t *JERRY_ATTR_ALWAYS_INLINE
        6: 1458:scanner_add_literal (parser_context_t *context_p, /**< context */
        -: 1459:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1460:{
       24: 1461:  return scanner_add_custom_literal (context_p,
        -: 1462:                                     scanner_context_p->active_literal_pool_p,
       24: 1463:                                     &context_p->token.lit_location);
        -: 1464:} /* scanner_add_literal */
        -: 1465:
        -: 1466:/**
        -: 1467: * Add the current literal token to the current literal pool and
        -: 1468: * set SCANNER_LITERAL_NO_REG if it is inside a with statement.
        -: 1469: *
        -: 1470: * @return pointer to the literal
        -: 1471: */
        -: 1472:extern inline void JERRY_ATTR_ALWAYS_INLINE
       35: 1473:scanner_add_reference (parser_context_t *context_p, /**< context */
        -: 1474:                       scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1475:{
       35: 1476:  lexer_lit_location_t *lit_location_p =
       35: 1477:    scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &context_p->token.lit_location);
        -: 1478:#if JERRY_ESNEXT
       35: 1479:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 1480:#endif /* JERRY_ESNEXT */
        -: 1481:
       35: 1482:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 1483:  {
    #####: 1484:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1485:  }
        -: 1486:
       35: 1487:  scanner_detect_eval_call (context_p, scanner_context_p);
       35: 1488:} /* scanner_add_reference */
        -: 1489:
        -: 1490:/**
        -: 1491: * Append an argument to the literal pool. If the argument is already present, make it a "hole".
        -: 1492: *
        -: 1493: * @return newly created literal
        -: 1494: */
        -: 1495:lexer_lit_location_t *
        4: 1496:scanner_append_argument (parser_context_t *context_p, /**< context */
        -: 1497:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1498:{
        4: 1499:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        4: 1500:  parser_list_iterator_t literal_iterator;
        4: 1501:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        4: 1502:  lexer_lit_location_t *literal_location_p = &context_p->token.lit_location;
        -: 1503:  lexer_lit_location_t *literal_p;
        -: 1504:
        4: 1505:  const uint8_t *char_p = literal_location_p->char_p;
        4: 1506:  prop_length_t length = literal_location_p->length;
        -: 1507:
        4: 1508:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1509:
        4: 1510:  if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1511:  {
        9: 1512:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1513:    {
        1: 1514:      if (literal_p->length == length)
        -: 1515:      {
    #####: 1516:        if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1517:        {
    #####: 1518:          if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1519:          {
    #####: 1520:            break;
        -: 1521:          }
        -: 1522:        }
    #####: 1523:        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1524:        {
    #####: 1525:          break;
        -: 1526:        }
        -: 1527:      }
        -: 1528:    }
        -: 1529:  }
        -: 1530:  else
        -: 1531:  {
    #####: 1532:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1533:    {
    #####: 1534:      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1535:      {
    #####: 1536:        break;
        -: 1537:      }
        -: 1538:    }
        -: 1539:  }
        -: 1540:
        4: 1541:  uint8_t literal_type = SCANNER_LITERAL_IS_ARG;
        -: 1542:
        4: 1543:  if (literal_p != NULL)
        -: 1544:  {
    #####: 1545:    literal_p->length = 0;
        -: 1546:
        -: 1547:#if JERRY_ESNEXT
    #####: 1548:    if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1549:    {
    #####: 1550:      literal_type = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1551:    }
        -: 1552:#endif /* JERRY_ESNEXT */
        -: 1553:  }
        -: 1554:
        4: 1555:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1556:
        4: 1557:  *literal_p = context_p->token.lit_location;
        4: 1558:  literal_p->type = literal_type;
        -: 1559:
        4: 1560:  return literal_p;
        -: 1561:} /* scanner_append_argument */
        -: 1562:
        -: 1563:/**
        -: 1564: * Add private identifiers to private ident pool
        -: 1565: */
        -: 1566:void
    #####: 1567:scanner_add_private_identifier (parser_context_t *context_p, /**< context  */
        -: 1568:                                scanner_private_field_flags_t opts) /**< options */
        -: 1569:{
    #####: 1570:  scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
    #####: 1571:  parser_stack_pop_uint8 (context_p);
    #####: 1572:  scanner_class_info_t *class_info_p;
    #####: 1573:  parser_stack_pop (context_p, &class_info_p, sizeof (scanner_class_info_t *));
        -: 1574:
    #####: 1575:  scanner_class_private_member_t *iter = class_info_p->members;
        -: 1576:
    #####: 1577:  scanner_private_field_flags_t search_flag =
    #####: 1578:    ((opts & SCANNER_PRIVATE_FIELD_PROPERTY) ? SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER
    #####: 1579:                                             : (opts & SCANNER_PRIVATE_FIELD_GETTER_SETTER));
        -: 1580:
    #####: 1581:  while (iter != NULL)
        -: 1582:  {
    #####: 1583:    if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &iter->loc)
    #####: 1584:        && (iter->u8_arg & search_flag))
        -: 1585:    {
    #####: 1586:      scanner_raise_error (context_p);
        -: 1587:    }
        -: 1588:
    #####: 1589:    iter = iter->prev_p;
        -: 1590:  }
        -: 1591:
        -: 1592:  scanner_class_private_member_t *p_member;
    #####: 1593:  p_member = (scanner_class_private_member_t *) scanner_malloc (context_p, sizeof (scanner_class_private_member_t));
    #####: 1594:  p_member->loc = context_p->token.lit_location;
    #####: 1595:  p_member->u8_arg = (uint8_t) opts;
    #####: 1596:  p_member->prev_p = class_info_p->members;
    #####: 1597:  class_info_p->members = p_member;
        -: 1598:
    #####: 1599:  parser_stack_push (context_p, &class_info_p, sizeof (scanner_class_info_t *));
    #####: 1600:  parser_stack_push_uint8 (context_p, (uint8_t) stack_top);
    #####: 1601:} /* scanner_add_private_identifier */
        -: 1602:
        -: 1603:/**
        -: 1604: * Check whether an eval call is performed and update the status flags accordingly.
        -: 1605: */
        -: 1606:void
       35: 1607:scanner_detect_eval_call (parser_context_t *context_p, /**< context */
        -: 1608:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1609:{
       35: 1610:  if (context_p->token.keyword_type == LEXER_KEYW_EVAL && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1611:  {
        -: 1612:#if JERRY_ESNEXT
    #####: 1613:    const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        -: 1614:#else /* !JERRY_ESNEXT */
    #####: 1615:    const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1616:#endif /* JERRY_ESNEXT */
        -: 1617:
    #####: 1618:    scanner_context_p->active_literal_pool_p->status_flags |= flags;
        -: 1619:  }
       35: 1620:} /* scanner_detect_eval_call */
        -: 1621:
        -: 1622:#if JERRY_ESNEXT
        -: 1623:
        -: 1624:/**
        -: 1625: * Throws an error for invalid var statements.
        -: 1626: */
        -: 1627:void
    #####: 1628:scanner_detect_invalid_var (parser_context_t *context_p, /**< context */
        -: 1629:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1630:                            lexer_lit_location_t *var_literal_p) /**< var literal */
        -: 1631:{
    #####: 1632:  if (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1633:      && !(var_literal_p->type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_ARG))
    #####: 1634:      && (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL)
        -: 1635:  {
    #####: 1636:    scanner_raise_redeclaration_error (context_p);
        -: 1637:  }
        -: 1638:
    #####: 1639:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1640:
    #####: 1641:  if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1642:      && ((var_literal_p->type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC))
        -: 1643:  {
    #####: 1644:    scanner_raise_redeclaration_error (context_p);
        -: 1645:  }
        -: 1646:
    #####: 1647:  const uint8_t *char_p = var_literal_p->char_p;
    #####: 1648:  prop_length_t length = var_literal_p->length;
        -: 1649:
    #####: 1650:  while (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -: 1651:  {
    #####: 1652:    literal_pool_p = literal_pool_p->prev_p;
        -: 1653:
    #####: 1654:    parser_list_iterator_t literal_iterator;
    #####: 1655:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1656:    lexer_lit_location_t *literal_p;
        -: 1657:
    #####: 1658:    if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1659:    {
    #####: 1660:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1661:      {
    #####: 1662:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL) && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1663:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1664:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1665:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL && literal_p->length == length)
        -: 1666:        {
    #####: 1667:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1668:          {
    #####: 1669:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1670:            {
    #####: 1671:              scanner_raise_redeclaration_error (context_p);
    #####: 1672:              return;
        -: 1673:            }
        -: 1674:          }
    #####: 1675:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1676:          {
    #####: 1677:            scanner_raise_redeclaration_error (context_p);
    #####: 1678:            return;
        -: 1679:          }
        -: 1680:        }
        -: 1681:      }
        -: 1682:    }
        -: 1683:    else
        -: 1684:    {
    #####: 1685:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1686:      {
    #####: 1687:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL) && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1688:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1689:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1690:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1691:            && lexer_compare_identifiers (context_p, literal_p, var_literal_p))
        -: 1692:        {
    #####: 1693:          scanner_raise_redeclaration_error (context_p);
    #####: 1694:          return;
        -: 1695:        }
        -: 1696:      }
        -: 1697:    }
        -: 1698:  }
        -: 1699:
    #####: 1700:  if (scanner_scope_find_lexical_declaration (context_p, var_literal_p))
        -: 1701:  {
    #####: 1702:    scanner_raise_redeclaration_error (context_p);
        -: 1703:  }
        -: 1704:} /* scanner_detect_invalid_var */
        -: 1705:
        -: 1706:/**
        -: 1707: * Throws an error for invalid let statements.
        -: 1708: */
        -: 1709:void
       11: 1710:scanner_detect_invalid_let (parser_context_t *context_p, /**< context */
        -: 1711:                            lexer_lit_location_t *let_literal_p) /**< let literal */
        -: 1712:{
       11: 1713:  if (let_literal_p->type & (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_LOCAL))
        -: 1714:  {
    #####: 1715:    scanner_raise_redeclaration_error (context_p);
        -: 1716:  }
        -: 1717:
       11: 1718:  if (let_literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1719:  {
    #####: 1720:    let_literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1721:  }
       11: 1722:} /* scanner_detect_invalid_let */
        -: 1723:
        -: 1724:/**
        -: 1725: * Push the values required for class declaration parsing.
        -: 1726: *
        -: 1727: * @return literal reference created for class statements, NULL otherwise
        -: 1728: */
        -: 1729:lexer_lit_location_t *
        9: 1730:scanner_push_class_declaration (parser_context_t *context_p, /**< context */
        -: 1731:                                scanner_context_t *scanner_context_p, /* scanner context */
        -: 1732:                                uint8_t stack_mode) /**< stack mode */
        -: 1733:{
        9: 1734:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1735:
        9: 1736:  const uint8_t *source_p = context_p->source_p;
        9: 1737:  lexer_lit_location_t *literal_p = NULL;
        -: 1738:
        -: 1739:#if JERRY_MODULE_SYSTEM
        9: 1740:  bool is_export_default = context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT;
        9: 1741:  JERRY_ASSERT (!is_export_default || stack_mode == SCAN_STACK_CLASS_EXPRESSION);
        -: 1742:#endif /* JERRY_MODULE_SYSTEM */
        -: 1743:
        9: 1744:  parser_stack_push_uint8 (context_p, stack_mode);
        9: 1745:  lexer_next_token (context_p);
        -: 1746:
        9: 1747:  bool class_has_name =
        9: 1748:    (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1749:
        9: 1750:  if (class_has_name)
        -: 1751:  {
        9: 1752:    if (stack_mode == SCAN_STACK_CLASS_STATEMENT)
        -: 1753:    {
        9: 1754:      literal_p = scanner_add_literal (context_p, scanner_context_p);
        9: 1755:      scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1756:    }
        -: 1757:#if JERRY_MODULE_SYSTEM
    #####: 1758:    else if (is_export_default)
        -: 1759:    {
    #####: 1760:      literal_p = scanner_add_literal (context_p, scanner_context_p);
    #####: 1761:      scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1762:
    #####: 1763:      scanner_detect_invalid_let (context_p, literal_p);
        -: 1764:
    #####: 1765:      if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1766:      {
    #####: 1767:        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1768:      }
        -: 1769:
    #####: 1770:      literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
        -: 1771:    }
        -: 1772:#endif /* JERRY_MODULE_SYSTEM */
        -: 1773:  }
        -: 1774:
        9: 1775:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        -: 1776:
        9: 1777:  if (class_has_name)
        -: 1778:  {
    #####: 1779:    scanner_add_literal (context_p, scanner_context_p);
        9: 1780:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1781:  }
        -: 1782:#if JERRY_MODULE_SYSTEM
    #####: 1783:  else if (is_export_default)
        -: 1784:  {
        -: 1785:    lexer_lit_location_t *name_literal_p;
    #####: 1786:    name_literal_p =
    #####: 1787:      scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p->prev_p, &lexer_default_literal);
        -: 1788:
    #####: 1789:    name_literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
    #####: 1790:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1791:  }
        -: 1792:#endif /* JERRY_MODULE_SYSTEM */
        -: 1793:
        9: 1794:  literal_pool_p->source_p = source_p;
        9: 1795:  literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CLASS_NAME;
        -: 1796:
        9: 1797:  const uint8_t *class_source_p = scanner_context_p->active_literal_pool_p->source_p;
       18: 1798:  scanner_class_info_t *class_info_p =
        9: 1799:    (scanner_class_info_t *) scanner_insert_info (context_p, class_source_p, sizeof (scanner_class_info_t));
        -: 1800:
        9: 1801:  class_info_p->info.type = SCANNER_TYPE_CLASS_CONSTRUCTOR;
        9: 1802:  class_info_p->members = NULL;
        9: 1803:  class_info_p->info.u8_arg = SCANNER_CONSTRUCTOR_IMPLICIT;
        -: 1804:
        9: 1805:  parser_stack_push (context_p, &class_info_p, sizeof (scanner_class_info_t *));
        9: 1806:  parser_stack_push_uint8 (context_p, SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR);
        9: 1807:  scanner_context_p->mode = SCAN_MODE_CLASS_DECLARATION;
        -: 1808:
        9: 1809:  return literal_p;
        -: 1810:} /* scanner_push_class_declaration */
        -: 1811:
        -: 1812:/**
        -: 1813: * Push the start of a class field initializer.
        -: 1814: */
        -: 1815:void
    #####: 1816:scanner_push_class_field_initializer (parser_context_t *context_p, /**< context */
        -: 1817:                                      scanner_context_t *scanner_context_p) /* scanner context */
        -: 1818:{
    #####: 1819:  scanner_source_start_t source_start;
    #####: 1820:  source_start.source_p = context_p->source_p;
        -: 1821:
    #####: 1822:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1823:  parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_FIELD_INITIALIZER);
        -: 1824:
        -: 1825:  scanner_literal_pool_t *literal_pool_p;
    #####: 1826:  literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_CLASS_FIELD);
    #####: 1827:  literal_pool_p->source_p = context_p->source_p;
        -: 1828:
    #####: 1829:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1830:} /* scanner_push_class_field_initializer */
        -: 1831:
        -: 1832:/**
        -: 1833: * Push the values required for destructuring assignment or binding parsing.
        -: 1834: */
        -: 1835:void
    #####: 1836:scanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */
        -: 1837:                                    scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1838:                                    uint8_t binding_type, /**< type of destructuring binding pattern */
        -: 1839:                                    bool is_nested) /**< nested declaration */
        -: 1840:{
    #####: 1841:  JERRY_ASSERT (binding_type != SCANNER_BINDING_NONE || !is_nested);
        -: 1842:
    #####: 1843:  scanner_source_start_t source_start;
    #####: 1844:  source_start.source_p = context_p->source_p;
        -: 1845:
    #####: 1846:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1847:  parser_stack_push_uint8 (context_p, scanner_context_p->binding_type);
    #####: 1848:  scanner_context_p->binding_type = binding_type;
        -: 1849:
    #####: 1850:  if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1851:  {
        -: 1852:    scanner_binding_list_t *binding_list_p;
    #####: 1853:    binding_list_p = (scanner_binding_list_t *) scanner_malloc (context_p, sizeof (scanner_binding_list_t));
        -: 1854:
    #####: 1855:    binding_list_p->prev_p = scanner_context_p->active_binding_list_p;
    #####: 1856:    binding_list_p->items_p = NULL;
    #####: 1857:    binding_list_p->is_nested = is_nested;
        -: 1858:
    #####: 1859:    scanner_context_p->active_binding_list_p = binding_list_p;
        -: 1860:  }
    #####: 1861:} /* scanner_push_destructuring_pattern */
        -: 1862:
        -: 1863:/**
        -: 1864: * Pop binding list.
        -: 1865: */
        -: 1866:void
    #####: 1867:scanner_pop_binding_list (scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1868:{
    #####: 1869:  scanner_binding_list_t *binding_list_p = scanner_context_p->active_binding_list_p;
    #####: 1870:  JERRY_ASSERT (binding_list_p != NULL);
        -: 1871:
    #####: 1872:  scanner_binding_item_t *item_p = binding_list_p->items_p;
    #####: 1873:  scanner_binding_list_t *prev_binding_list_p = binding_list_p->prev_p;
    #####: 1874:  bool is_nested = binding_list_p->is_nested;
        -: 1875:
    #####: 1876:  scanner_free (binding_list_p, sizeof (scanner_binding_list_t));
    #####: 1877:  scanner_context_p->active_binding_list_p = prev_binding_list_p;
        -: 1878:
    #####: 1879:  if (!is_nested)
        -: 1880:  {
    #####: 1881:    while (item_p != NULL)
        -: 1882:    {
    #####: 1883:      scanner_binding_item_t *next_p = item_p->next_p;
        -: 1884:
    #####: 1885:      JERRY_ASSERT (item_p->literal_p->type & (SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_IS_ARG));
        -: 1886:
    #####: 1887:      scanner_free (item_p, sizeof (scanner_binding_item_t));
    #####: 1888:      item_p = next_p;
        -: 1889:    }
    #####: 1890:    return;
        -: 1891:  }
        -: 1892:
    #####: 1893:  JERRY_ASSERT (prev_binding_list_p != NULL);
        -: 1894:
    #####: 1895:  while (item_p != NULL)
        -: 1896:  {
    #####: 1897:    scanner_binding_item_t *next_p = item_p->next_p;
        -: 1898:
    #####: 1899:    item_p->next_p = prev_binding_list_p->items_p;
    #####: 1900:    prev_binding_list_p->items_p = item_p;
        -: 1901:
    #####: 1902:    item_p = next_p;
        -: 1903:  }
        -: 1904:} /* scanner_pop_binding_list */
        -: 1905:
        -: 1906:/**
        -: 1907: * Append a hole into the literal pool.
        -: 1908: */
        -: 1909:void
    #####: 1910:scanner_append_hole (parser_context_t *context_p, scanner_context_t *scanner_context_p)
        -: 1911:{
    #####: 1912:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1913:
        -: 1914:  lexer_lit_location_t *literal_p;
    #####: 1915:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1916:
    #####: 1917:  literal_p->char_p = NULL;
    #####: 1918:  literal_p->length = 0;
    #####: 1919:  literal_p->type = SCANNER_LITERAL_IS_ARG;
    #####: 1920:  literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 1921:} /* scanner_append_hole */
        -: 1922:
        -: 1923:#endif /* JERRY_ESNEXT */
        -: 1924:
        -: 1925:/**
        -: 1926: * Reverse the scanner info chain after the scanning is completed.
        -: 1927: */
        -: 1928:void
        1: 1929:scanner_reverse_info_list (parser_context_t *context_p) /**< context */
        -: 1930:{
        1: 1931:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        1: 1932:  scanner_info_t *last_scanner_info_p = NULL;
        -: 1933:
        1: 1934:  if (scanner_info_p->type == SCANNER_TYPE_END)
        -: 1935:  {
    #####: 1936:    return;
        -: 1937:  }
        -: 1938:
        -: 1939:  do
        -: 1940:  {
       39: 1941:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
       39: 1942:    scanner_info_p->next_p = last_scanner_info_p;
        -: 1943:
       39: 1944:    last_scanner_info_p = scanner_info_p;
       39: 1945:    scanner_info_p = next_scanner_info_p;
       39: 1946:  } while (scanner_info_p->type != SCANNER_TYPE_END);
        -: 1947:
        1: 1948:  context_p->next_scanner_info_p->next_p = scanner_info_p;
        1: 1949:  context_p->next_scanner_info_p = last_scanner_info_p;
        -: 1950:} /* scanner_reverse_info_list */
        -: 1951:
        -: 1952:/**
        -: 1953: * Release unused scanner info blocks.
        -: 1954: * This should happen only if an error is occurred.
        -: 1955: */
        -: 1956:void
    #####: 1957:scanner_cleanup (parser_context_t *context_p) /**< context */
        -: 1958:{
    #####: 1959:  if (context_p->skipped_scanner_info_p != NULL)
        -: 1960:  {
    #####: 1961:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
    #####: 1962:    context_p->next_scanner_info_p = context_p->skipped_scanner_info_p;
    #####: 1963:    context_p->skipped_scanner_info_p = NULL;
        -: 1964:  }
        -: 1965:
    #####: 1966:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 1967:
    #####: 1968:  while (scanner_info_p != NULL)
        -: 1969:  {
    #####: 1970:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        -: 1971:
    #####: 1972:    size_t size = sizeof (scanner_info_t);
        -: 1973:
    #####: 1974:    switch (scanner_info_p->type)
        -: 1975:    {
    #####: 1976:      case SCANNER_TYPE_END:
        -: 1977:      {
    #####: 1978:        scanner_info_p = context_p->active_scanner_info_p;
    #####: 1979:        continue;
        -: 1980:      }
    #####: 1981:      case SCANNER_TYPE_FUNCTION:
        -: 1982:      case SCANNER_TYPE_BLOCK:
        -: 1983:      {
    #####: 1984:        size = scanner_get_stream_size (scanner_info_p, sizeof (scanner_info_t));
    #####: 1985:        break;
        -: 1986:      }
    #####: 1987:      case SCANNER_TYPE_WHILE:
        -: 1988:      case SCANNER_TYPE_FOR_IN:
        -: 1989:#if JERRY_ESNEXT
        -: 1990:      case SCANNER_TYPE_FOR_OF:
        -: 1991:#endif /* JERRY_ESNEXT */
        -: 1992:      case SCANNER_TYPE_CASE:
        -: 1993:#if JERRY_ESNEXT
        -: 1994:      case SCANNER_TYPE_INITIALIZER:
        -: 1995:      case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:
        -: 1996:#endif /* JERRY_ESNEXT */
        -: 1997:      {
    #####: 1998:        size = sizeof (scanner_location_info_t);
    #####: 1999:        break;
        -: 2000:      }
    #####: 2001:      case SCANNER_TYPE_FOR:
        -: 2002:      {
    #####: 2003:        size = sizeof (scanner_for_info_t);
    #####: 2004:        break;
        -: 2005:      }
    #####: 2006:      case SCANNER_TYPE_SWITCH:
        -: 2007:      {
    #####: 2008:        scanner_release_switch_cases (((scanner_switch_info_t *) scanner_info_p)->case_p);
    #####: 2009:        size = sizeof (scanner_switch_info_t);
    #####: 2010:        break;
        -: 2011:      }
        -: 2012:#if JERRY_ESNEXT
    #####: 2013:      case SCANNER_TYPE_CLASS_CONSTRUCTOR:
        -: 2014:      {
    #####: 2015:        scanner_release_private_fields (((scanner_class_info_t *) scanner_info_p)->members);
    #####: 2016:        size = sizeof (scanner_class_info_t);
    #####: 2017:        break;
        -: 2018:      }
        -: 2019:#endif /* JERRY_ESNEXT */
    #####: 2020:      default:
        -: 2021:      {
        -: 2022:#if JERRY_ESNEXT
    #####: 2023:        JERRY_ASSERT (
        -: 2024:          scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS || scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 2025:          || scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION || scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
        -: 2026:          || scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION
        -: 2027:          || scanner_info_p->type == SCANNER_TYPE_EXPORT_MODULE_SPECIFIER);
        -: 2028:#else /* !JERRY_ESNEXT */
        -: 2029:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
        -: 2030:#endif /* JERRY_ESNEXT */
    #####: 2031:        break;
        -: 2032:      }
        -: 2033:    }
        -: 2034:
    #####: 2035:    scanner_free (scanner_info_p, size);
    #####: 2036:    scanner_info_p = next_scanner_info_p;
        -: 2037:  }
        -: 2038:
    #####: 2039:  context_p->next_scanner_info_p = NULL;
    #####: 2040:  context_p->active_scanner_info_p = NULL;
    #####: 2041:} /* scanner_cleanup */
        -: 2042:
        -: 2043:/**
        -: 2044: * Checks whether a context needs to be created for a block.
        -: 2045: *
        -: 2046: * @return true - if context is needed,
        -: 2047: *         false - otherwise
        -: 2048: */
        -: 2049:bool
        3: 2050:scanner_is_context_needed (parser_context_t *context_p, /**< context */
        -: 2051:                           parser_check_context_type_t check_type) /**< context type */
        -: 2052:{
        3: 2053:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        3: 2054:  const uint8_t *data_p = (const uint8_t *) (info_p + 1);
        -: 2055:
        -: 2056:  JERRY_UNUSED (check_type);
        -: 2057:
        -: 2058:#if JERRY_ESNEXT
        3: 2059:  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK
        -: 2060:                                                          : info_p->type == SCANNER_TYPE_FUNCTION));
        -: 2061:
        3: 2062:  uint32_t scope_stack_reg_top =
        3: 2063:    (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top : 1); /* block result */
        -: 2064:#else /* !JERRY_ESNEXT */
        -: 2065:  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);
        -: 2066:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);
        -: 2067:
    #####: 2068:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2069:#endif /* !JERRY_NDEBUG */
        -: 2070:
       10: 2071:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2072:  {
        4: 2073:    uint8_t data = data_p[0];
        -: 2074:
        -: 2075:#if JERRY_ESNEXT
        4: 2076:    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;
        -: 2077:
        4: 2078:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2079:    {
    #####: 2080:      if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2081:      {
    #####: 2082:        data_p++;
    #####: 2083:        continue;
        -: 2084:      }
        -: 2085:
    #####: 2086:      if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2087:      {
    #####: 2088:        if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2089:        {
    #####: 2090:          return true;
        -: 2091:        }
        -: 2092:
    #####: 2093:        scope_stack_reg_top++;
    #####: 2094:        data_p++;
    #####: 2095:        continue;
        -: 2096:      }
        -: 2097:    }
        -: 2098:
        -: 2099:#ifndef JERRY_NDEBUG
        4: 2100:    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)
        -: 2101:    {
        2: 2102:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2103:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2104:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2105:    }
        2: 2106:    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        -: 2107:    {
        -: 2108:#if JERRY_MODULE_SYSTEM
        2: 2109:      const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2110:#else /* !JERRY_MODULE_SYSTEM */
        -: 2111:      const bool is_import = true;
        -: 2112:#endif /* JERRY_MODULE_SYSTEM */
        -: 2113:
        -: 2114:      /* FIXME: a private declarative lexical environment should always be present
        -: 2115:       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */
        2: 2116:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2117:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_FUNC || is_import);
        -: 2118:
        -: 2119:      /* Only let/const can be stored in registers */
        2: 2120:      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)
        -: 2121:                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -: 2122:                    || type == SCANNER_STREAM_TYPE_LET || type == SCANNER_STREAM_TYPE_CONST);
        -: 2123:    }
        -: 2124:    else
        -: 2125:    {
    #####: 2126:      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);
        -: 2127:
    #####: 2128:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2129:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2130:                    || type == SCANNER_STREAM_TYPE_ARG || type == SCANNER_STREAM_TYPE_ARG_VAR
        -: 2131:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2132:                    || type == SCANNER_STREAM_TYPE_ARG_FUNC || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC
        -: 2133:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2134:    }
        -: 2135:#endif /* !JERRY_NDEBUG */
        -: 2136:
        -: 2137:#else /* !JERRY_ESNEXT */
        -: 2138:    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);
        -: 2139:#endif /* JERRY_ESNEXT */
        -: 2140:
        4: 2141:    if (!(data & SCANNER_STREAM_UINT16_DIFF))
        -: 2142:    {
        4: 2143:      if (data_p[2] != 0)
        -: 2144:      {
        4: 2145:        data_p += 2 + 1;
        -: 2146:      }
        -: 2147:      else
        -: 2148:      {
    #####: 2149:        data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 2150:      }
        -: 2151:    }
        -: 2152:    else
        -: 2153:    {
    #####: 2154:      data_p += 2 + 2;
        -: 2155:    }
        -: 2156:
        -: 2157:#if JERRY_ESNEXT
        -: 2158:#if JERRY_MODULE_SYSTEM
        4: 2159:    const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2160:#else /* !JERRY_MODULE_SYSTEM */
        -: 2161:    const bool is_import = false;
        -: 2162:#endif /* JERRY_MODULE_SYSTEM */
        -: 2163:
        4: 2164:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        2: 2165:        && (type == SCANNER_STREAM_TYPE_VAR
        2: 2166:            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_EVAL)) || is_import))
        -: 2167:    {
        2: 2168:      continue;
        -: 2169:    }
        -: 2170:
        2: 2171:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2172:    {
    #####: 2173:      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) || type == SCANNER_STREAM_TYPE_ARG_VAR
    #####: 2174:          || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR)
        -: 2175:      {
        -: 2176:        /* The return value is true, if the variable is stored in the lexical environment
        -: 2177:         * or all registers have already been used for function arguments. This can be
        -: 2178:         * inprecise in the latter case, but this is a very rare corner case. A more
        -: 2179:         * sophisticated check would require to decode the literal. */
    #####: 2180:        if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2181:        {
    #####: 2182:          return true;
        -: 2183:        }
    #####: 2184:        continue;
        -: 2185:      }
        -: 2186:
    #####: 2187:      if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2188:      {
    #####: 2189:        continue;
        -: 2190:      }
        -: 2191:    }
        -: 2192:#endif /* JERRY_ESNEXT */
        -: 2193:
        2: 2194:    if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2195:    {
    #####: 2196:      return true;
        -: 2197:    }
        -: 2198:
        2: 2199:    scope_stack_reg_top++;
        -: 2200:  }
        -: 2201:
        3: 2202:  return false;
        -: 2203:} /* scanner_is_context_needed */
        -: 2204:
        -: 2205:#if JERRY_ESNEXT
        -: 2206:
        -: 2207:/**
        -: 2208: * Try to scan/parse the ".target" part in the "new.target" expression.
        -: 2209: *
        -: 2210: * Upon exiting with "true" the current token will point to the "target"
        -: 2211: * literal.
        -: 2212: *
        -: 2213: * If the "target" literal is not after the "new." then a scanner/parser
        -: 2214: * error will be raised.
        -: 2215: *
        -: 2216: * @returns true if the ".target" part was found
        -: 2217: *          false if there is no "." after the new.
        -: 2218: */
        -: 2219:bool
       16: 2220:scanner_try_scan_new_target (parser_context_t *context_p) /**< parser/scanner context */
        -: 2221:{
       16: 2222:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_NEW);
        -: 2223:
       16: 2224:  if (lexer_check_next_character (context_p, LIT_CHAR_DOT))
        -: 2225:  {
    #####: 2226:    lexer_next_token (context_p);
    #####: 2227:    if (context_p->token.type != LEXER_DOT)
        -: 2228:    {
    #####: 2229:      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2230:    }
        -: 2231:
    #####: 2232:    lexer_next_token (context_p);
    #####: 2233:    if (!lexer_token_is_identifier (context_p, "target", 6))
        -: 2234:    {
    #####: 2235:      parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_EXPECTED);
        -: 2236:    }
        -: 2237:
    #####: 2238:    return true;
        -: 2239:  }
       16: 2240:  return false;
        -: 2241:} /* scanner_try_scan_new_target */
        -: 2242:
        -: 2243:#endif /* JERRY_ESNEXT */
        -: 2244:
        -: 2245:/**
        -: 2246: * Description of "arguments" literal string.
        -: 2247: */
        -: 2248:const lexer_lit_location_t lexer_arguments_literal = { (const uint8_t *) "arguments",
        -: 2249:                                                       9,
        -: 2250:                                                       LEXER_IDENT_LITERAL,
        -: 2251:                                                       LEXER_LIT_LOCATION_IS_ASCII };
        -: 2252:
        -: 2253:/**
        -: 2254: * Create an unused literal.
        -: 2255: */
        -: 2256:static void
        3: 2257:scanner_create_unused_literal (parser_context_t *context_p, /**< context */
        -: 2258:                               uint8_t status_flags) /**< initial status flags */
        -: 2259:{
        3: 2260:  if (JERRY_UNLIKELY (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS))
        -: 2261:  {
    #####: 2262:    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
        -: 2263:  }
        -: 2264:
        3: 2265:  lexer_literal_t *literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
        -: 2266:
        3: 2267:  literal_p->type = LEXER_UNUSED_LITERAL;
        3: 2268:  literal_p->status_flags = status_flags;
        -: 2269:
        3: 2270:  context_p->literal_count++;
        3: 2271:} /* scanner_create_unused_literal */
        -: 2272:
        -: 2273:#if JERRY_ESNEXT
        -: 2274:/**
        -: 2275: * Emit checks for redeclared bindings in the global lexical scope.
        -: 2276: */
        -: 2277:void
        1: 2278:scanner_check_variables (parser_context_t *context_p) /**< context */
        -: 2279:{
        1: 2280:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 2281:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        1: 2282:  lexer_lit_location_t literal;
        -: 2283:
        1: 2284:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2285:
        1: 2286:  literal.char_p = info_p->source_p - 1;
        -: 2287:
        4: 2288:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2289:  {
        2: 2290:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        2: 2291:    const uint8_t *data_p = next_data_p;
        -: 2292:
        2: 2293:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_HOLE && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2294:                  && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type));
        2: 2295:    JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 2296:
        2: 2297:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2298:    {
        2: 2299:      if (data_p[2] != 0)
        -: 2300:      {
        2: 2301:        literal.char_p += data_p[2];
        2: 2302:        next_data_p += 2 + 1;
        -: 2303:      }
        -: 2304:      else
        -: 2305:      {
    #####: 2306:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2307:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2308:      }
        -: 2309:    }
        -: 2310:    else
        -: 2311:    {
    #####: 2312:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2313:
    #####: 2314:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2315:      {
    #####: 2316:        diff = -diff;
        -: 2317:      }
        -: 2318:
    #####: 2319:      literal.char_p += diff;
    #####: 2320:      next_data_p += 2 + 2;
        -: 2321:    }
        -: 2322:
        2: 2323:    literal.length = data_p[1];
        2: 2324:    literal.type = LEXER_IDENT_LITERAL;
        2: 2325:    literal.status_flags =
        2: 2326:      ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2327:
        2: 2328:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        2: 2329:    literal.char_p += data_p[1];
        -: 2330:
        -: 2331:#if JERRY_MODULE_SYSTEM
        2: 2332:    if (type == SCANNER_STREAM_TYPE_IMPORT)
        -: 2333:    {
    #####: 2334:      continue;
        -: 2335:    }
        -: 2336:#endif /* JERRY_MODULE_SYSTEM */
        -: 2337:
        2: 2338:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        -: 2339:
        -: 2340:    uint16_t opcode;
        2: 2341:    if (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_FUNC)
        -: 2342:    {
        2: 2343:      opcode = CBC_CHECK_VAR;
        -: 2344:    }
        -: 2345:    else
        -: 2346:    {
    #####: 2347:      opcode = CBC_CHECK_LET;
        -: 2348:    }
        -: 2349:
        2: 2350:    parser_emit_cbc_literal (context_p, opcode, context_p->lit_object.index);
        -: 2351:  }
        -: 2352:
        1: 2353:  parser_flush_cbc (context_p);
        1: 2354:} /* scanner_check_variables */
        -: 2355:#endif /* JERRY_ESNEXT */
        -: 2356:
        -: 2357:/**
        -: 2358: * Create and/or initialize var/let/const/function/etc. variables.
        -: 2359: */
        -: 2360:void
       32: 2361:scanner_create_variables (parser_context_t *context_p, /**< context */
        -: 2362:                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */
        -: 2363:{
       32: 2364:  scanner_info_t *info_p = context_p->next_scanner_info_p;
       32: 2365:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
       32: 2366:  uint8_t info_type = info_p->type;
       32: 2367:  uint8_t info_u8_arg = info_p->u8_arg;
       32: 2368:  lexer_lit_location_t literal;
        -: 2369:  parser_scope_stack_t *scope_stack_p;
        -: 2370:  parser_scope_stack_t *scope_stack_end_p;
        -: 2371:
       32: 2372:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);
       32: 2373:  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2374:                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));
       32: 2375:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION
        -: 2376:                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));
        -: 2377:
       32: 2378:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2379:
       32: 2380:  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
       27: 2381:  {
       27: 2382:    JERRY_ASSERT (context_p->scope_stack_p == NULL);
        -: 2383:
       27: 2384:    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);
       27: 2385:    context_p->scope_stack_size = info_p->u16_arg;
        -: 2386:
       27: 2387:    scope_stack_p = NULL;
        -: 2388:
       27: 2389:    if (stack_size > 0)
        -: 2390:    {
        5: 2391:      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);
        -: 2392:    }
        -: 2393:
       27: 2394:    context_p->scope_stack_p = scope_stack_p;
       27: 2395:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        -: 2396:
       27: 2397:    if (option_flags & (SCANNER_CREATE_VARS_IS_SCRIPT | SCANNER_CREATE_VARS_IS_MODULE))
        -: 2398:    {
        1: 2399:      scope_stack_reg_top++; /* block result */
        -: 2400:    }
        -: 2401:  }
        -: 2402:  else
        -: 2403:  {
        5: 2404:    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);
        -: 2405:
        5: 2406:    scope_stack_p = context_p->scope_stack_p;
        5: 2407:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        5: 2408:    scope_stack_p += context_p->scope_stack_top;
        -: 2409:  }
        -: 2410:
       32: 2411:  literal.char_p = info_p->source_p - 1;
        -: 2412:
       87: 2413:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2414:  {
       24: 2415:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
       24: 2416:    const uint8_t *data_p = next_data_p;
        -: 2417:
       24: 2418:    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2419:                  || (type != SCANNER_STREAM_TYPE_HOLE && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2420:                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));
        -: 2421:
        -: 2422:#if JERRY_MODULE_SYSTEM
       24: 2423:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));
        -: 2424:#endif /* JERRY_MODULE_SYSTEM */
        -: 2425:
       24: 2426:    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2427:    {
    #####: 2428:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2429:      next_data_p++;
        -: 2430:
    #####: 2431:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2432:      {
    #####: 2433:        continue;
        -: 2434:      }
        -: 2435:
    #####: 2436:      uint8_t mask = SCANNER_FUNCTION_ARGUMENTS_NEEDED | SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 2437:
    #####: 2438:      if (!(context_p->status_flags & PARSER_IS_STRICT) && (info_u8_arg & mask) == SCANNER_FUNCTION_ARGUMENTS_NEEDED)
        -: 2439:      {
    #####: 2440:        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);
        -: 2441:      }
        -: 2442:
    #####: 2443:      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2444:      {
    #####: 2445:        scope_stack_reg_top++;
        -: 2446:      }
    #####: 2447:      continue;
        -: 2448:    }
        -: 2449:
       24: 2450:    if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2451:    {
    #####: 2452:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2453:      next_data_p++;
        -: 2454:
    #####: 2455:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2456:      {
    #####: 2457:        continue;
        -: 2458:      }
        -: 2459:
    #####: 2460:      context_p->status_flags |= PARSER_ARGUMENTS_NEEDED;
        -: 2461:
    #####: 2462:      if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2463:      {
    #####: 2464:        JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2465:        parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2466:      }
        -: 2467:
    #####: 2468:      lexer_construct_literal_object (context_p, &lexer_arguments_literal, LEXER_NEW_IDENT_LITERAL);
    #####: 2469:      scope_stack_p->map_from = context_p->lit_object.index;
        -: 2470:
        -: 2471:      uint16_t map_to;
        -: 2472:
    #####: 2473:      if (!(data_p[0] & SCANNER_STREAM_NO_REG) && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2474:      {
    #####: 2475:        map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2476:
        -: 2477:#if JERRY_ESNEXT
    #####: 2478:        scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2479:#endif /* JERRY_ESNEXT */
        -: 2480:
    #####: 2481:        scope_stack_reg_top++;
        -: 2482:      }
        -: 2483:      else
        -: 2484:      {
    #####: 2485:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 2486:        map_to = context_p->lit_object.index;
        -: 2487:
    #####: 2488:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2489:
        -: 2490:#if JERRY_ESNEXT
    #####: 2491:        if (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS)
        -: 2492:        {
    #####: 2493:          context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2494:        }
        -: 2495:
    #####: 2496:        scope_stack_p->map_to = 0;
        -: 2497:#endif /* JERRY_ESNEXT */
        -: 2498:      }
        -: 2499:
        -: 2500:#if !JERRY_ESNEXT
    #####: 2501:      scope_stack_p->map_to = map_to;
        -: 2502:#endif /* !JERRY_ESNEXT */
    #####: 2503:      scope_stack_p++;
        -: 2504:
        -: 2505:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2506:      context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2507:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2508:
    #####: 2509:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_CREATE_ARGUMENTS, map_to);
        -: 2510:
        -: 2511:#if JERRY_ESNEXT
    #####: 2512:      if (type == SCANNER_STREAM_TYPE_ARGUMENTS_FUNC)
        -: 2513:      {
    #####: 2514:        if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2515:        {
    #####: 2516:          JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2517:          parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2518:        }
        -: 2519:
    #####: 2520:        scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
    #####: 2521:        scope_stack_p->map_to = context_p->literal_count;
    #####: 2522:        scope_stack_p++;
        -: 2523:
    #####: 2524:        scanner_create_unused_literal (context_p, 0);
        -: 2525:      }
        -: 2526:#endif /* JERRY_ESNEXT */
        -: 2527:
    #####: 2528:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2529:      {
    #####: 2530:        break;
        -: 2531:      }
    #####: 2532:      continue;
        -: 2533:    }
        -: 2534:
       24: 2535:    JERRY_ASSERT (context_p->scope_stack_size != 0);
        -: 2536:
       24: 2537:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2538:    {
       24: 2539:      if (data_p[2] != 0)
        -: 2540:      {
       24: 2541:        literal.char_p += data_p[2];
       24: 2542:        next_data_p += 2 + 1;
        -: 2543:      }
        -: 2544:      else
        -: 2545:      {
    #####: 2546:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2547:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2548:      }
        -: 2549:    }
        -: 2550:    else
        -: 2551:    {
    #####: 2552:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2553:
    #####: 2554:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2555:      {
    #####: 2556:        diff = -diff;
        -: 2557:      }
        -: 2558:
    #####: 2559:      literal.char_p += diff;
    #####: 2560:      next_data_p += 2 + 2;
        -: 2561:    }
        -: 2562:
       24: 2563:    if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2564:    {
       12: 2565:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2566:      {
        -: 2567:#if JERRY_ESNEXT
        4: 2568:        if ((context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2569:            && (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR))
        -: 2570:        {
    #####: 2571:          literal.length = data_p[1];
    #####: 2572:          literal.type = LEXER_IDENT_LITERAL;
    #####: 2573:          literal.status_flags =
    #####: 2574:            ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2575:
        -: 2576:          /* Literal must be exists. */
    #####: 2577:          lexer_construct_literal_object (context_p, &literal, LEXER_IDENT_LITERAL);
        -: 2578:
    #####: 2579:          if (context_p->lit_object.index < PARSER_REGISTER_START)
        -: 2580:          {
    #####: 2581:            parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_COPY_FROM_ARG);
        -: 2582:          }
        -: 2583:        }
        -: 2584:#endif /* JERRY_ESNEXT */
        -: 2585:
        4: 2586:        literal.char_p += data_p[1];
        4: 2587:        continue;
        -: 2588:      }
        -: 2589:    }
       16: 2590:    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS) && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2591:    {
        -: 2592:      /* Function arguments must come first. */
        1: 2593:      break;
        -: 2594:    }
        -: 2595:
       19: 2596:    literal.length = data_p[1];
       19: 2597:    literal.type = LEXER_IDENT_LITERAL;
       19: 2598:    literal.status_flags =
       19: 2599:      ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2600:
       19: 2601:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
       19: 2602:    literal.char_p += data_p[1];
        -: 2603:
       19: 2604:    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        -: 2605:    {
    #####: 2606:      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);
    #####: 2607:      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        -: 2608:#if JERRY_ESNEXT
    #####: 2609:      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));
        -: 2610:#endif /* JERRY_ESNEXT */
        -: 2611:
    #####: 2612:      parser_scope_stack_t *function_map_p = scope_stack_p - 2;
    #####: 2613:      uint16_t literal_index = context_p->lit_object.index;
        -: 2614:
    #####: 2615:      while (literal_index != function_map_p->map_from)
        -: 2616:      {
    #####: 2617:        function_map_p--;
        -: 2618:
    #####: 2619:        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);
        -: 2620:      }
        -: 2621:
    #####: 2622:      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -: 2623:
    #####: 2624:      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;
        -: 2625:
        -: 2626:#if JERRY_ESNEXT
    #####: 2627:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2628:          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)
        -: 2629:      {
    #####: 2630:        opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2631:      }
        -: 2632:#endif /* JERRY_ESNEXT */
        -: 2633:
    #####: 2634:      parser_emit_cbc_literal_value (context_p,
    #####: 2635:                                     (uint16_t) opcode,
    #####: 2636:                                     function_map_p[1].map_to,
    #####: 2637:                                     scanner_decode_map_to (function_map_p));
    #####: 2638:      continue;
        -: 2639:    }
        -: 2640:
       19: 2641:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2642:    {
    #####: 2643:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2644:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2645:    }
        -: 2646:
       19: 2647:    scope_stack_p->map_from = context_p->lit_object.index;
        -: 2648:
        -: 2649:#if JERRY_ESNEXT
       19: 2650:    if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2651:    {
       17: 2652:      if (type != SCANNER_STREAM_TYPE_LET
        -: 2653:#if JERRY_MODULE_SYSTEM
        7: 2654:          && type != SCANNER_STREAM_TYPE_IMPORT
        -: 2655:#endif /* JERRY_MODULE_SYSTEM */
        7: 2656:          && type != SCANNER_STREAM_TYPE_CONST)
        -: 2657:      {
        7: 2658:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;
        -: 2659:      }
        -: 2660:    }
        -: 2661:#endif /* JERRY_ESNEXT */
        -: 2662:
        -: 2663:    uint16_t map_to;
       19: 2664:    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2665:
       19: 2666:    if (!(data_p[0] & SCANNER_STREAM_NO_REG) && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2667:    {
        8: 2668:      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2669:
        -: 2670:#if JERRY_ESNEXT
        8: 2671:      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2672:#else /* !JERRY_ESNEXT */
    #####: 2673:      scope_stack_p->map_to = map_to;
        -: 2674:#endif /* JERRY_ESNEXT */
        -: 2675:
        8: 2676:      scope_stack_reg_top++;
        -: 2677:#if JERRY_ESNEXT
        8: 2678:      switch (type)
        -: 2679:      {
    #####: 2680:        case SCANNER_STREAM_TYPE_CONST:
        -: 2681:        {
    #####: 2682:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;
        -: 2683:          /* FALLTHRU */
        -: 2684:        }
        7: 2685:        case SCANNER_STREAM_TYPE_LET:
        -: 2686:        case SCANNER_STREAM_TYPE_ARG:
        -: 2687:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2688:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2689:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2690:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2691:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2692:        {
        7: 2693:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        7: 2694:          break;
        -: 2695:        }
        -: 2696:      }
        -: 2697:
        8: 2698:      func_init_opcode = CBC_SET_VAR_FUNC;
        -: 2699:#endif /* JERRY_ESNEXT */
        -: 2700:    }
        -: 2701:    else
        -: 2702:    {
       11: 2703:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
       11: 2704:      map_to = context_p->lit_object.index;
        -: 2705:
        -: 2706:#if JERRY_ESNEXT
       11: 2707:      uint16_t scope_stack_map_to = 0;
        -: 2708:#else /* !JERRY_ESNEXT */
    #####: 2709:      scope_stack_p->map_to = map_to;
        -: 2710:#endif /* JERRY_ESNEXT */
        -: 2711:
       11: 2712:      if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2713:      {
       11: 2714:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2715:      }
        -: 2716:
       11: 2717:      switch (type)
        -: 2718:      {
        -: 2719:#if JERRY_ESNEXT
        8: 2720:        case SCANNER_STREAM_TYPE_LET:
        -: 2721:        case SCANNER_STREAM_TYPE_CONST:
        -: 2722:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2723:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2724:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2725:        {
        8: 2726:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2727:
        8: 2728:          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))
        -: 2729:          {
        8: 2730:            break;
        -: 2731:          }
    #####: 2732:          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2733:          /* FALLTHRU */
        -: 2734:        }
    #####: 2735:        case SCANNER_STREAM_TYPE_LOCAL:
        -: 2736:#endif /* JERRY_ESNEXT */
    #####: 2737:        case SCANNER_STREAM_TYPE_VAR:
        -: 2738:        {
        -: 2739:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2740:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2741:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2742:
        -: 2743:#if JERRY_ESNEXT
        -: 2744:          uint16_t opcode;
        -: 2745:
    #####: 2746:          switch (type)
        -: 2747:          {
    #####: 2748:            case SCANNER_STREAM_TYPE_LET:
        -: 2749:            {
    #####: 2750:              opcode = CBC_CREATE_LET;
    #####: 2751:              break;
        -: 2752:            }
    #####: 2753:            case SCANNER_STREAM_TYPE_CONST:
        -: 2754:            {
    #####: 2755:              opcode = CBC_CREATE_CONST;
    #####: 2756:              break;
        -: 2757:            }
    #####: 2758:            case SCANNER_STREAM_TYPE_VAR:
        -: 2759:            {
    #####: 2760:              opcode = CBC_CREATE_VAR;
        -: 2761:
    #####: 2762:              if (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT)
        -: 2763:              {
    #####: 2764:                opcode = CBC_CREATE_VAR_EVAL;
        -: 2765:
    #####: 2766:                if ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2767:                    && !(context_p->status_flags & PARSER_IS_STRICT))
        -: 2768:                {
    #####: 2769:                  opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_EVAL);
        -: 2770:                }
        -: 2771:              }
    #####: 2772:              break;
        -: 2773:            }
    #####: 2774:            default:
        -: 2775:            {
    #####: 2776:              JERRY_ASSERT (type == SCANNER_STREAM_TYPE_LOCAL || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG
        -: 2777:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2778:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC);
        -: 2779:
    #####: 2780:              opcode = CBC_CREATE_LOCAL;
    #####: 2781:              break;
        -: 2782:            }
        -: 2783:          }
        -: 2784:#else /* !JERRY_ESNEXT */
    #####: 2785:          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL : CBC_CREATE_VAR);
        -: 2786:#endif /* JERRY_ESNEXT */
        -: 2787:
    #####: 2788:          parser_emit_cbc_literal (context_p, opcode, map_to);
    #####: 2789:          break;
        -: 2790:        }
    #####: 2791:        case SCANNER_STREAM_TYPE_ARG:
        -: 2792:#if JERRY_ESNEXT
        -: 2793:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2794:#endif /* JERRY_ESNEXT */
        -: 2795:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2796:        {
        -: 2797:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2798:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2799:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2800:
        -: 2801:#if JERRY_ESNEXT
    #####: 2802:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2803:
        -: 2804:          /* Argument initializers of functions with simple arguments (e.g. function f(a,b,a) {}) are
        -: 2805:           * generated here. The other initializers are handled by parser_parse_function_arguments(). */
    #####: 2806:          if (!(info_u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT))
        -: 2807:          {
        -: 2808:#endif /* JERRY_ESNEXT */
    #####: 2809:            parser_emit_cbc_literal_value (context_p,
        -: 2810:                                           CBC_INIT_ARG_OR_FUNC,
    #####: 2811:                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),
        -: 2812:                                           map_to);
        -: 2813:#if JERRY_ESNEXT
        -: 2814:          }
    #####: 2815:          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 2816:          {
    #####: 2817:            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);
    #####: 2818:            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2819:          }
        -: 2820:#endif /* JERRY_ESNEXT */
        -: 2821:
    #####: 2822:          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2823:          {
    #####: 2824:            scope_stack_reg_top++;
        -: 2825:          }
    #####: 2826:          break;
        -: 2827:        }
        -: 2828:      }
        -: 2829:
        -: 2830:#if JERRY_ESNEXT
       11: 2831:      scope_stack_p->map_to = scope_stack_map_to;
        -: 2832:#endif /* JERRY_ESNEXT */
        -: 2833:    }
        -: 2834:
       19: 2835:    scope_stack_p++;
        -: 2836:
       19: 2837:    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))
        -: 2838:    {
       16: 2839:      continue;
        -: 2840:    }
        -: 2841:
        3: 2842:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2843:    {
    #####: 2844:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2845:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2846:    }
        -: 2847:
        -: 2848:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2849:    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2850:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2851:
        3: 2852:    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2853:    {
        3: 2854:      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))
        -: 2855:      {
        -: 2856:#if JERRY_ESNEXT
        2: 2857:        literal.char_p -= data_p[1];
        -: 2858:
        2: 2859:        if (!scanner_scope_find_lexical_declaration (context_p, &literal))
        -: 2860:        {
        2: 2861:          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2862:
        2: 2863:          if (context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
        -: 2864:          {
    #####: 2865:            func_init_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_FUNC_EVAL);
        -: 2866:          }
        -: 2867:        }
        2: 2868:        literal.char_p += data_p[1];
        -: 2869:#else /* !JERRY_ESNEXT */
    #####: 2870:        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2871:#endif /* JERRY_ESNEXT */
        -: 2872:      }
        -: 2873:
        3: 2874:      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);
        -: 2875:    }
        -: 2876:
        3: 2877:    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
        3: 2878:    scope_stack_p->map_to = context_p->literal_count;
        3: 2879:    scope_stack_p++;
        -: 2880:
        3: 2881:    scanner_create_unused_literal (context_p, 0);
        -: 2882:  }
        -: 2883:
       32: 2884:  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
       32: 2885:  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;
        -: 2886:
        -: 2887:#if JERRY_ESNEXT
       32: 2888:  if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2889:  {
       30: 2890:    context_p->scope_stack_global_end = context_p->scope_stack_top;
        -: 2891:  }
        -: 2892:#endif /* JERRY_ESNEXT */
        -: 2893:
       32: 2894:  if (context_p->register_count < scope_stack_reg_top)
        -: 2895:  {
        8: 2896:    context_p->register_count = (uint16_t) scope_stack_reg_top;
        -: 2897:  }
        -: 2898:
       32: 2899:  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2900:  {
       29: 2901:    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));
        -: 2902:  }
       32: 2903:  parser_flush_cbc (context_p);
       32: 2904:} /* scanner_create_variables */
        -: 2905:
        -: 2906:/**
        -: 2907: * Get location from context.
        -: 2908: */
        -: 2909:extern inline void JERRY_ATTR_ALWAYS_INLINE
        4: 2910:scanner_get_location (scanner_location_t *location_p, /**< location */
        -: 2911:                      parser_context_t *context_p) /**< context */
        -: 2912:{
        4: 2913:  location_p->source_p = context_p->source_p;
        4: 2914:  location_p->line = context_p->line;
        4: 2915:  location_p->column = context_p->column;
        4: 2916:} /* scanner_get_location */
        -: 2917:
        -: 2918:/**
        -: 2919: * Set context location.
        -: 2920: */
        -: 2921:extern inline void JERRY_ATTR_ALWAYS_INLINE
        4: 2922:scanner_set_location (parser_context_t *context_p, /**< context */
        -: 2923:                      scanner_location_t *location_p) /**< location */
        -: 2924:{
        4: 2925:  context_p->source_p = location_p->source_p;
        4: 2926:  context_p->line = location_p->line;
        4: 2927:  context_p->column = location_p->column;
        4: 2928:} /* scanner_set_location */
        -: 2929:
        -: 2930:/**
        -: 2931: * Get the real map_to value.
        -: 2932: */
        -: 2933:extern inline uint16_t JERRY_ATTR_ALWAYS_INLINE
       96: 2934:scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */
        -: 2935:{
       96: 2936:  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);
        -: 2937:
        -: 2938:#if JERRY_ESNEXT
       96: 2939:  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);
       96: 2940:  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));
        -: 2941:#else /* !JERRY_ESNEXT */
    #####: 2942:  return stack_item_p->map_to;
        -: 2943:#endif /* JERRY_ESNEXT */
        -: 2944:} /* scanner_decode_map_to */
        -: 2945:
        -: 2946:#if JERRY_ESNEXT
        -: 2947:
        -: 2948:/**
        -: 2949: * Find the given literal index in the scope stack
        -: 2950: * and save it the constant literal pool if the literal is register stored
        -: 2951: *
        -: 2952: * @return given literal index - if literal corresponds to this index is not register stored
        -: 2953: *         literal index on which literal index has been mapped - otherwise
        -: 2954: */
        -: 2955:uint16_t
    #####: 2956:scanner_save_literal (parser_context_t *context_p, /**< context */
        -: 2957:                      uint16_t literal_index) /**< literal index */
        -: 2958:{
    #####: 2959:  if (literal_index >= PARSER_REGISTER_START)
        -: 2960:  {
    #####: 2961:    literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 2962:
    #####: 2963:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2964:
        -: 2965:    do
        -: 2966:    {
        -: 2967:      /* Registers must be found in the scope stack. */
    #####: 2968:      JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 2969:      scope_stack_p--;
    #####: 2970:    } while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
    #####: 2971:             || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 2972:
    #####: 2973:    literal_index = scope_stack_p->map_from;
    #####: 2974:    PARSER_GET_LITERAL (literal_index)->status_flags |= LEXER_FLAG_USED;
        -: 2975:  }
        -: 2976:
    #####: 2977:  return literal_index;
        -: 2978:} /* scanner_save_literal */
        -: 2979:
        -: 2980:/**
        -: 2981: * Checks whether the literal is a const in the current scope.
        -: 2982: *
        -: 2983: * @return true if the literal is a const, false otherwise
        -: 2984: */
        -: 2985:bool
        1: 2986:scanner_literal_is_const_reg (parser_context_t *context_p, /**< context */
        -: 2987:                              uint16_t literal_index) /**< literal index */
        -: 2988:{
        1: 2989:  if (literal_index < PARSER_REGISTER_START)
        -: 2990:  {
        -: 2991:    /* Re-assignment of non-register const bindings are detected elsewhere. */
    #####: 2992:    return false;
        -: 2993:  }
        -: 2994:
        1: 2995:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2996:
        1: 2997:  literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 2998:
        -: 2999:  do
        -: 3000:  {
        -: 3001:    /* Registers must be found in the scope stack. */
        1: 3002:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
        1: 3003:    scope_stack_p--;
        1: 3004:  } while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
        1: 3005:           || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 3006:
        1: 3007:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_CONST_REG) != 0;
        -: 3008:} /* scanner_literal_is_const_reg */
        -: 3009:
        -: 3010:/**
        -: 3011: * Checks whether the literal is created before.
        -: 3012: *
        -: 3013: * @return true if the literal is created before, false otherwise
        -: 3014: */
        -: 3015:bool
        8: 3016:scanner_literal_is_created (parser_context_t *context_p, /**< context */
        -: 3017:                            uint16_t literal_index) /**< literal index */
        -: 3018:{
        8: 3019:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 3020:
        8: 3021:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3022:
        -: 3023:  do
        -: 3024:  {
        -: 3025:    /* These literals must be found in the scope stack. */
       36: 3026:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
       36: 3027:    scope_stack_p--;
       36: 3028:  } while (literal_index != scope_stack_p->map_from);
        -: 3029:
        8: 3030:  JERRY_ASSERT ((scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0);
        -: 3031:
        8: 3032:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_LOCAL_CREATED) != 0;
        -: 3033:} /* scanner_literal_is_created */
        -: 3034:
        -: 3035:/**
        -: 3036: * Checks whether the literal exists.
        -: 3037: *
        -: 3038: * @return true if the literal exists, false otherwise
        -: 3039: */
        -: 3040:bool
    #####: 3041:scanner_literal_exists (parser_context_t *context_p, /**< context */
        -: 3042:                        uint16_t literal_index) /**< literal index */
        -: 3043:{
    #####: 3044:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 3045:
    #####: 3046:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3047:
    #####: 3048:  while (scope_stack_p-- > context_p->scope_stack_p)
        -: 3049:  {
    #####: 3050:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC && scanner_decode_map_to (scope_stack_p) == literal_index)
        -: 3051:    {
    #####: 3052:      return true;
        -: 3053:    }
        -: 3054:  }
        -: 3055:
    #####: 3056:  return false;
        -: 3057:} /* scanner_literal_exists */
        -: 3058:
        -: 3059:#endif /* JERRY_ESNEXT */
        -: 3060:
        -: 3061:/**
        -: 3062: * @}
        -: 3063: * @}
        -: 3064: * @}
        -: 3065: */
        -: 3066:
        -: 3067:#endif /* JERRY_PARSER */
