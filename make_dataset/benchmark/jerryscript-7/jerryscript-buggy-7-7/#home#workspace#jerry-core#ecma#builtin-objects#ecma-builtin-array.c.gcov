        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#include "jcontext.h"
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_ARRAY
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_ARRAY_ROUTINE_START = 0,
        -:   48:  ECMA_ARRAY_ROUTINE_IS_ARRAY,
        -:   49:#if JERRY_ESNEXT
        -:   50:  ECMA_ARRAY_ROUTINE_FROM,
        -:   51:  ECMA_ARRAY_ROUTINE_OF,
        -:   52:  ECMA_ARRAY_ROUTINE_SPECIES_GET
        -:   53:#endif /* JERRY_ESNEXT */
        -:   54:};
        -:   55:
        -:   56:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array.inc.h"
        -:   57:#define BUILTIN_UNDERSCORED_ID  array
        -:   58:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   59:
        -:   60:/** \addtogroup ecma ECMA
        -:   61: * @{
        -:   62: *
        -:   63: * \addtogroup ecmabuiltins
        -:   64: * @{
        -:   65: *
        -:   66: * \addtogroup array ECMA Array object built-in
        -:   67: * @{
        -:   68: */
        -:   69:
        -:   70:#if JERRY_ESNEXT
        -:   71:/**
        -:   72: * The Array object's 'from' routine
        -:   73: *
        -:   74: * See also:
        -:   75: *          ECMA-262 v6, 22.1.2.1
        -:   76: *
        -:   77: * @return ecma value
        -:   78: *         Returned value must be freed with ecma_free_value.
        -:   79: */
        -:   80:static ecma_value_t
    #####:   81:ecma_builtin_array_object_from (ecma_value_t this_arg, /**< 'this' argument */
        -:   82:                                const ecma_value_t *arguments_list_p, /**< arguments list */
        -:   83:                                uint32_t arguments_list_len) /**< number of arguments */
        -:   84:{
        -:   85:  /* 1. */
    #####:   86:  ecma_value_t constructor = this_arg;
    #####:   87:  ecma_value_t call_this_arg = ECMA_VALUE_UNDEFINED;
    #####:   88:  ecma_value_t items = arguments_list_p[0];
    #####:   89:  ecma_value_t mapfn = (arguments_list_len > 1) ? arguments_list_p[1] : ECMA_VALUE_UNDEFINED;
        -:   90:
        -:   91:  /* 2. */
    #####:   92:  ecma_object_t *mapfn_obj_p = NULL;
        -:   93:
        -:   94:  /* 3. */
    #####:   95:  if (!ecma_is_value_undefined (mapfn))
        -:   96:  {
        -:   97:    /* 3.a */
    #####:   98:    if (!ecma_op_is_callable (mapfn))
        -:   99:    {
    #####:  100:      return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -:  101:    }
        -:  102:
        -:  103:    /* 3.b */
    #####:  104:    if (arguments_list_len > 2)
        -:  105:    {
    #####:  106:      call_this_arg = arguments_list_p[2];
        -:  107:    }
        -:  108:
        -:  109:    /* 3.c */
    #####:  110:    mapfn_obj_p = ecma_get_object_from_value (mapfn);
        -:  111:  }
        -:  112:
        -:  113:  /* 4. */
    #####:  114:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (items, LIT_GLOBAL_SYMBOL_ITERATOR);
        -:  115:
        -:  116:  /* 5. */
    #####:  117:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -:  118:  {
    #####:  119:    return using_iterator;
        -:  120:  }
        -:  121:
    #####:  122:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  123:
        -:  124:  /* 6. */
    #####:  125:  if (!ecma_is_value_undefined (using_iterator))
        -:  126:  {
        -:  127:    ecma_object_t *array_obj_p;
        -:  128:
        -:  129:    /* 6.a */
    #####:  130:    if (ecma_is_constructor (constructor))
        -:  131:    {
    #####:  132:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor);
        -:  133:
    #####:  134:      ecma_value_t array = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, NULL, 0);
        -:  135:
    #####:  136:      if (ecma_is_value_undefined (array) || ecma_is_value_null (array))
        -:  137:      {
    #####:  138:        ecma_free_value (using_iterator);
    #####:  139:        return ecma_raise_type_error (ECMA_ERR_CANNOT_CONVERT_TO_OBJECT);
        -:  140:      }
        -:  141:
        -:  142:      /* 6.c */
    #####:  143:      if (ECMA_IS_VALUE_ERROR (array))
        -:  144:      {
    #####:  145:        ecma_free_value (using_iterator);
    #####:  146:        return array;
        -:  147:      }
        -:  148:
    #####:  149:      array_obj_p = ecma_get_object_from_value (array);
        -:  150:    }
        -:  151:    else
        -:  152:    {
        -:  153:      /* 6.b */
    #####:  154:      array_obj_p = ecma_op_new_array_object (0);
        -:  155:    }
        -:  156:
        -:  157:    /* 6.d */
    #####:  158:    ecma_value_t next_method;
    #####:  159:    ecma_value_t iterator = ecma_op_get_iterator (items, using_iterator, &next_method);
    #####:  160:    ecma_free_value (using_iterator);
        -:  161:
        -:  162:    /* 6.e */
    #####:  163:    if (ECMA_IS_VALUE_ERROR (iterator))
        -:  164:    {
    #####:  165:      ecma_deref_object (array_obj_p);
    #####:  166:      return iterator;
        -:  167:    }
        -:  168:
        -:  169:    /* 6.f */
    #####:  170:    uint32_t k = 0;
        -:  171:
        -:  172:    /* 6.g */
        -:  173:    while (true)
    #####:  174:    {
        -:  175:      /* 6.g.ii */
    #####:  176:      ecma_value_t next = ecma_op_iterator_step (iterator, next_method);
        -:  177:
        -:  178:      /* 6.g.iii */
    #####:  179:      if (ECMA_IS_VALUE_ERROR (next))
        -:  180:      {
    #####:  181:        goto iterator_cleanup;
        -:  182:      }
        -:  183:
        -:  184:      /* 6.g.iii */
    #####:  185:      if (ecma_is_value_false (next))
        -:  186:      {
        -:  187:        /* 6.g.iv.1 */
    #####:  188:        ecma_value_t len_value = ecma_make_uint32_value (k);
    #####:  189:        ecma_value_t set_status =
    #####:  190:          ecma_op_object_put (array_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), len_value, true);
    #####:  191:        ecma_free_value (len_value);
        -:  192:
        -:  193:        /* 6.g.iv.2 */
    #####:  194:        if (ECMA_IS_VALUE_ERROR (set_status))
        -:  195:        {
    #####:  196:          goto iterator_cleanup;
        -:  197:        }
        -:  198:
    #####:  199:        ecma_free_value (iterator);
    #####:  200:        ecma_free_value (next_method);
        -:  201:        /* 6.g.iv.3 */
    #####:  202:        return ecma_make_object_value (array_obj_p);
        -:  203:      }
        -:  204:
        -:  205:      /* 6.g.v */
    #####:  206:      ecma_value_t next_value = ecma_op_iterator_value (next);
        -:  207:
    #####:  208:      ecma_free_value (next);
        -:  209:
        -:  210:      /* 6.g.vi */
    #####:  211:      if (ECMA_IS_VALUE_ERROR (next_value))
        -:  212:      {
    #####:  213:        goto iterator_cleanup;
        -:  214:      }
        -:  215:
        -:  216:      ecma_value_t mapped_value;
        -:  217:      /* 6.g.vii */
    #####:  218:      if (mapfn_obj_p != NULL)
        -:  219:      {
        -:  220:        /* 6.g.vii.1 */
    #####:  221:        ecma_value_t args_p[2] = { next_value, ecma_make_uint32_value (k) };
        -:  222:        /* 6.g.vii.3 */
    #####:  223:        mapped_value = ecma_op_function_call (mapfn_obj_p, call_this_arg, args_p, 2);
    #####:  224:        ecma_free_value (args_p[1]);
    #####:  225:        ecma_free_value (next_value);
        -:  226:
        -:  227:        /* 6.g.vii.2 */
    #####:  228:        if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  229:        {
    #####:  230:          ecma_op_iterator_close (iterator);
    #####:  231:          goto iterator_cleanup;
        -:  232:        }
        -:  233:      }
        -:  234:      else
        -:  235:      {
        -:  236:        /* 6.g.viii */
    #####:  237:        mapped_value = next_value;
        -:  238:      }
        -:  239:
        -:  240:      /* 6.g.ix */
    #####:  241:      const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####:  242:      ecma_value_t set_status = ecma_builtin_helper_def_prop_by_index (array_obj_p, k, mapped_value, flags);
        -:  243:
    #####:  244:      ecma_free_value (mapped_value);
        -:  245:
        -:  246:      /* 6.g.x */
    #####:  247:      if (ECMA_IS_VALUE_ERROR (set_status))
        -:  248:      {
    #####:  249:        ecma_op_iterator_close (iterator);
    #####:  250:        goto iterator_cleanup;
        -:  251:      }
        -:  252:
        -:  253:      /* 6.g.xi */
    #####:  254:      k++;
        -:  255:    }
        -:  256:
    #####:  257:iterator_cleanup:
    #####:  258:    ecma_free_value (iterator);
    #####:  259:    ecma_free_value (next_method);
    #####:  260:    ecma_deref_object (array_obj_p);
        -:  261:
    #####:  262:    return ret_value;
        -:  263:  }
        -:  264:
        -:  265:  /* 8. */
    #####:  266:  ecma_value_t array_like = ecma_op_to_object (items);
        -:  267:
        -:  268:  /* 9. */
    #####:  269:  if (ECMA_IS_VALUE_ERROR (array_like))
        -:  270:  {
    #####:  271:    return array_like;
        -:  272:  }
        -:  273:
    #####:  274:  ecma_object_t *array_like_obj_p = ecma_get_object_from_value (array_like);
        -:  275:
        -:  276:  /* 10. */
    #####:  277:  ecma_length_t len;
    #####:  278:  ecma_value_t len_value = ecma_op_object_get_length (array_like_obj_p, &len);
        -:  279:
        -:  280:  /* 11. */
    #####:  281:  if (ECMA_IS_VALUE_ERROR (len_value))
        -:  282:  {
    #####:  283:    goto cleanup;
        -:  284:  }
        -:  285:
        -:  286:  /* 12. */
        -:  287:  ecma_object_t *array_obj_p;
        -:  288:
        -:  289:  /* 12.a */
    #####:  290:  if (ecma_is_constructor (constructor))
        -:  291:  {
    #####:  292:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor);
        -:  293:
    #####:  294:    len_value = ecma_make_length_value (len);
    #####:  295:    ecma_value_t array = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, &len_value, 1);
    #####:  296:    ecma_free_value (len_value);
        -:  297:
    #####:  298:    if (ecma_is_value_undefined (array) || ecma_is_value_null (array))
        -:  299:    {
    #####:  300:      ecma_raise_type_error (ECMA_ERR_CANNOT_CONVERT_TO_OBJECT);
    #####:  301:      goto cleanup;
        -:  302:    }
        -:  303:
        -:  304:    /* 14. */
    #####:  305:    if (ECMA_IS_VALUE_ERROR (array))
        -:  306:    {
    #####:  307:      goto cleanup;
        -:  308:    }
        -:  309:
    #####:  310:    array_obj_p = ecma_get_object_from_value (array);
        -:  311:  }
        -:  312:  else
        -:  313:  {
        -:  314:    /* 13.a */
    #####:  315:    array_obj_p = ecma_op_new_array_object_from_length (len);
        -:  316:
    #####:  317:    if (JERRY_UNLIKELY (array_obj_p == NULL))
        -:  318:    {
    #####:  319:      goto cleanup;
        -:  320:    }
        -:  321:  }
        -:  322:
        -:  323:  /* 15. */
    #####:  324:  ecma_length_t k = 0;
        -:  325:
        -:  326:  /* 16. */
    #####:  327:  while (k < len)
        -:  328:  {
        -:  329:    /* 16.b */
    #####:  330:    ecma_value_t k_value = ecma_op_object_get_by_index (array_like_obj_p, k);
        -:  331:
        -:  332:    /* 16.c */
    #####:  333:    if (ECMA_IS_VALUE_ERROR (k_value))
        -:  334:    {
    #####:  335:      goto construct_cleanup;
        -:  336:    }
        -:  337:
        -:  338:    ecma_value_t mapped_value;
        -:  339:    /* 16.d */
    #####:  340:    if (mapfn_obj_p != NULL)
        -:  341:    {
        -:  342:      /* 16.d.i */
    #####:  343:      ecma_value_t args_p[2] = { k_value, ecma_make_length_value (k) };
    #####:  344:      mapped_value = ecma_op_function_call (mapfn_obj_p, call_this_arg, args_p, 2);
    #####:  345:      ecma_free_value (args_p[1]);
    #####:  346:      ecma_free_value (k_value);
        -:  347:
        -:  348:      /* 16.d.ii */
    #####:  349:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  350:      {
    #####:  351:        goto construct_cleanup;
        -:  352:      }
        -:  353:    }
        -:  354:    else
        -:  355:    {
        -:  356:      /* 16.e */
    #####:  357:      mapped_value = k_value;
        -:  358:    }
        -:  359:
        -:  360:    /* 16.f */
    #####:  361:    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####:  362:    ecma_value_t set_status = ecma_builtin_helper_def_prop_by_index (array_obj_p, k, mapped_value, flags);
        -:  363:
    #####:  364:    ecma_free_value (mapped_value);
        -:  365:
        -:  366:    /* 16.g */
    #####:  367:    if (ECMA_IS_VALUE_ERROR (set_status))
        -:  368:    {
    #####:  369:      goto construct_cleanup;
        -:  370:    }
        -:  371:
        -:  372:    /* 16.h */
    #####:  373:    k++;
        -:  374:  }
        -:  375:
        -:  376:  /* 17. */
    #####:  377:  len_value = ecma_make_length_value (k);
    #####:  378:  ecma_value_t set_status =
    #####:  379:    ecma_op_object_put (array_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), len_value, true);
    #####:  380:  ecma_free_value (len_value);
        -:  381:
        -:  382:  /* 18. */
    #####:  383:  if (ECMA_IS_VALUE_ERROR (set_status))
        -:  384:  {
    #####:  385:    goto construct_cleanup;
        -:  386:  }
        -:  387:
        -:  388:  /* 19. */
    #####:  389:  ecma_deref_object (array_like_obj_p);
    #####:  390:  return ecma_make_object_value (array_obj_p);
        -:  391:
    #####:  392:construct_cleanup:
    #####:  393:  ecma_deref_object (array_obj_p);
    #####:  394:cleanup:
    #####:  395:  ecma_deref_object (array_like_obj_p);
    #####:  396:  return ret_value;
        -:  397:} /* ecma_builtin_array_object_from */
        -:  398:
        -:  399:/**
        -:  400: * The Array object's 'of' routine
        -:  401: *
        -:  402: * See also:
        -:  403: *          ECMA-262 v6, 22.1.2.3
        -:  404: *
        -:  405: * @return ecma value
        -:  406: *         Returned value must be freed with ecma_free_value.
        -:  407: */
        -:  408:static ecma_value_t
    #####:  409:ecma_builtin_array_object_of (ecma_value_t this_arg, /**< 'this' argument */
        -:  410:                              const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  411:                              uint32_t arguments_list_len) /**< number of arguments */
        -:  412:{
    #####:  413:  if (!ecma_is_constructor (this_arg))
        -:  414:  {
    #####:  415:    return ecma_op_new_array_object_from_buffer (arguments_list_p, arguments_list_len);
        -:  416:  }
        -:  417:
    #####:  418:  ecma_value_t len = ecma_make_uint32_value (arguments_list_len);
        -:  419:
    #####:  420:  ecma_value_t ret_val =
    #####:  421:    ecma_op_function_construct (ecma_get_object_from_value (this_arg), ecma_get_object_from_value (this_arg), &len, 1);
        -:  422:
    #####:  423:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  424:  {
    #####:  425:    ecma_free_value (len);
    #####:  426:    return ret_val;
        -:  427:  }
        -:  428:
    #####:  429:  uint32_t k = 0;
    #####:  430:  ecma_object_t *obj_p = ecma_get_object_from_value (ret_val);
    #####:  431:  const uint32_t prop_status_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  432:
    #####:  433:  while (k < arguments_list_len)
        -:  434:  {
    #####:  435:    ecma_value_t define_status =
    #####:  436:      ecma_builtin_helper_def_prop_by_index (obj_p, k, arguments_list_p[k], prop_status_flags);
        -:  437:
    #####:  438:    if (ECMA_IS_VALUE_ERROR (define_status))
        -:  439:    {
    #####:  440:      ecma_free_value (len);
    #####:  441:      ecma_deref_object (obj_p);
    #####:  442:      return define_status;
        -:  443:    }
        -:  444:
    #####:  445:    k++;
        -:  446:  }
        -:  447:
    #####:  448:  ret_val = ecma_op_object_put (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH), len, true);
        -:  449:
    #####:  450:  ecma_free_value (len);
        -:  451:
    #####:  452:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  453:  {
    #####:  454:    ecma_deref_object (obj_p);
    #####:  455:    return ret_val;
        -:  456:  }
        -:  457:
    #####:  458:  return ecma_make_object_value (obj_p);
        -:  459:} /* ecma_builtin_array_object_of */
        -:  460:
        -:  461:#endif /* JERRY_ESNEXT */
        -:  462:
        -:  463:/**
        -:  464: * Handle calling [[Call]] of built-in Array object
        -:  465: *
        -:  466: * @return ECMA_VALUE_ERROR - if the array construction fails
        -:  467: *         constructed array object - otherwise
        -:  468: */
        -:  469:ecma_value_t
    #####:  470:ecma_builtin_array_dispatch_call (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  471:                                  uint32_t arguments_list_len) /**< number of arguments */
        -:  472:{
    #####:  473:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  474:
    #####:  475:  if (arguments_list_len != 1 || !ecma_is_value_number (arguments_list_p[0]))
        -:  476:  {
    #####:  477:    return ecma_op_new_array_object_from_buffer (arguments_list_p, arguments_list_len);
        -:  478:  }
        -:  479:
    #####:  480:  ecma_number_t num = ecma_get_number_from_value (arguments_list_p[0]);
    #####:  481:  uint32_t num_uint32 = ecma_number_to_uint32 (num);
        -:  482:
    #####:  483:  if (num != ((ecma_number_t) num_uint32))
        -:  484:  {
    #####:  485:    return ecma_raise_range_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -:  486:  }
        -:  487:
    #####:  488:  return ecma_make_object_value (ecma_op_new_array_object (num_uint32));
        -:  489:} /* ecma_builtin_array_dispatch_call */
        -:  490:
        -:  491:/**
        -:  492: * Handle calling [[Construct]] of built-in Array object
        -:  493: *
        -:  494: * @return ECMA_VALUE_ERROR - if the array construction fails
        -:  495: *         constructed array object - otherwise
        -:  496: */
        -:  497:ecma_value_t
    #####:  498:ecma_builtin_array_dispatch_construct (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  499:                                       uint32_t arguments_list_len) /**< number of arguments */
        -:  500:{
    #####:  501:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  502:
        -:  503:#if !JERRY_ESNEXT
    #####:  504:  return ecma_builtin_array_dispatch_call (arguments_list_p, arguments_list_len);
        -:  505:#else /* JERRY_ESNEXT */
    #####:  506:  ecma_object_t *proto_p =
    #####:  507:    ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p), ECMA_BUILTIN_ID_ARRAY_PROTOTYPE);
        -:  508:
    #####:  509:  if (proto_p == NULL)
        -:  510:  {
    #####:  511:    return ECMA_VALUE_ERROR;
        -:  512:  }
        -:  513:
    #####:  514:  ecma_value_t result = ecma_builtin_array_dispatch_call (arguments_list_p, arguments_list_len);
        -:  515:
    #####:  516:  if (ECMA_IS_VALUE_ERROR (result))
        -:  517:  {
    #####:  518:    ecma_deref_object (proto_p);
    #####:  519:    return result;
        -:  520:  }
        -:  521:
    #####:  522:  ecma_object_t *object_p = ecma_get_object_from_value (result);
    #####:  523:  ECMA_SET_NON_NULL_POINTER (object_p->u2.prototype_cp, proto_p);
    #####:  524:  ecma_deref_object (proto_p);
    #####:  525:  return result;
        -:  526:#endif /* JERRY_ESNEXT */
        -:  527:} /* ecma_builtin_array_dispatch_construct */
        -:  528:
        -:  529:/**
        -:  530: * Dispatcher of the built-in's routines
        -:  531: *
        -:  532: * @return ecma value
        -:  533: *         Returned value must be freed with ecma_free_value.
        -:  534: */
        -:  535:ecma_value_t
    #####:  536:ecma_builtin_array_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  537:                                     ecma_value_t this_arg, /**< 'this' argument value */
        -:  538:                                     const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  539:                                                                             *   passed to routine */
        -:  540:                                     uint32_t arguments_number) /**< length of arguments' list */
        -:  541:{
        -:  542:  JERRY_UNUSED (arguments_number);
        -:  543:
    #####:  544:  switch (builtin_routine_id)
        -:  545:  {
    #####:  546:    case ECMA_ARRAY_ROUTINE_IS_ARRAY:
        -:  547:    {
        -:  548:      JERRY_UNUSED (this_arg);
        -:  549:
    #####:  550:      return ecma_is_value_array (arguments_list_p[0]);
        -:  551:    }
        -:  552:#if JERRY_ESNEXT
    #####:  553:    case ECMA_ARRAY_ROUTINE_FROM:
        -:  554:    {
    #####:  555:      return ecma_builtin_array_object_from (this_arg, arguments_list_p, arguments_number);
        -:  556:    }
    #####:  557:    case ECMA_ARRAY_ROUTINE_OF:
        -:  558:    {
    #####:  559:      return ecma_builtin_array_object_of (this_arg, arguments_list_p, arguments_number);
        -:  560:    }
    #####:  561:    case ECMA_ARRAY_ROUTINE_SPECIES_GET:
        -:  562:    {
    #####:  563:      return ecma_copy_value (this_arg);
        -:  564:    }
        -:  565:#endif /* JERRY_ESNEXT */
    #####:  566:    default:
        -:  567:    {
    #####:  568:      JERRY_UNREACHABLE ();
        -:  569:    }
        -:  570:  }
        -:  571:} /* ecma_builtin_array_dispatch_routine */
        -:  572:
        -:  573:/**
        -:  574: * @}
        -:  575: * @}
        -:  576: * @}
        -:  577: */
        -:  578:
        -:  579:#endif /* JERRY_BUILTIN_ARRAY */
