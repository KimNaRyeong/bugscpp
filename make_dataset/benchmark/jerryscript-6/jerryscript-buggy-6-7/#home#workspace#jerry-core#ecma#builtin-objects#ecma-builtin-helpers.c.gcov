        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-builtin-helpers.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-helpers-number.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#include "jmem.h"
        -:   30:#include "lit-char-helpers.h"
        -:   31:#include "lit-magic-strings.h"
        -:   32:
        -:   33:/** \addtogroup ecma ECMA
        -:   34: * @{
        -:   35: *
        -:   36: * \addtogroup ecmabuiltinhelpers ECMA builtin helper operations
        -:   37: * @{
        -:   38: */
        -:   39:
        -:   40:#if JERRY_ESNEXT
        -:   41:/**
        -:   42: * Helper function for Object.prototype.toString routine when
        -:   43: * the @@toStringTag property is present
        -:   44: *
        -:   45: * See also:
        -:   46: *          ECMA-262 v6, 19.1.3.6
        -:   47: *
        -:   48: * @return ecma value
        -:   49: *         Returned value must be freed with ecma_free_value.
        -:   50: */
        -:   51:static ecma_value_t
    #####:   52:ecma_builtin_helper_object_to_string_tag_helper (ecma_value_t tag_value) /**< string tag */
        -:   53:{
    #####:   54:  JERRY_ASSERT (ecma_is_value_string (tag_value));
        -:   55:
    #####:   56:  ecma_string_t *tag_str_p = ecma_get_string_from_value (tag_value);
    #####:   57:  lit_utf8_size_t tag_str_size = ecma_string_get_size (tag_str_p);
        -:   58:  ecma_string_t *ret_string_p;
        -:   59:
        -:   60:  /* Building string "[object #@@toStringTag#]"
        -:   61:     The string size will be size("[object ") + size(#@@toStringTag#) + size ("]"). */
    #####:   62:  const lit_utf8_size_t buffer_size = 9 + tag_str_size;
    #####:   63:  JMEM_DEFINE_LOCAL_ARRAY (str_buffer, buffer_size, lit_utf8_byte_t);
        -:   64:
    #####:   65:  lit_utf8_byte_t *buffer_ptr = str_buffer;
        -:   66:
    #####:   67:  const lit_magic_string_id_t magic_string_ids[] = {
        -:   68:    LIT_MAGIC_STRING_LEFT_SQUARE_CHAR,
        -:   69:    LIT_MAGIC_STRING_OBJECT,
        -:   70:    LIT_MAGIC_STRING_SPACE_CHAR,
        -:   71:  };
        -:   72:
        -:   73:  /* Copy to buffer the "[object " string */
    #####:   74:  for (uint32_t i = 0; i < sizeof (magic_string_ids) / sizeof (lit_magic_string_id_t); ++i)
        -:   75:  {
    #####:   76:    buffer_ptr = lit_copy_magic_string_to_buffer (magic_string_ids[i],
        -:   77:                                                  buffer_ptr,
    #####:   78:                                                  (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));
        -:   79:
    #####:   80:    JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   81:  }
        -:   82:
        -:   83:  /* Copy to buffer the #@@toStringTag# string */
    #####:   84:  ecma_string_to_cesu8_bytes (tag_str_p, buffer_ptr, tag_str_size);
    #####:   85:  buffer_ptr += tag_str_size;
        -:   86:
    #####:   87:  JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   88:
        -:   89:  /* Copy to buffer the "]" string */
    #####:   90:  buffer_ptr = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_RIGHT_SQUARE_CHAR,
        -:   91:                                                buffer_ptr,
    #####:   92:                                                (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));
        -:   93:
    #####:   94:  JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   95:
    #####:   96:  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));
        -:   97:
    #####:   98:  JMEM_FINALIZE_LOCAL_ARRAY (str_buffer);
    #####:   99:  ecma_deref_ecma_string (tag_str_p);
        -:  100:
    #####:  101:  return ecma_make_string_value (ret_string_p);
        -:  102:} /* ecma_builtin_helper_object_to_string_tag_helper */
        -:  103:#endif /* JERRY_ESNEXT */
        -:  104:
        -:  105:/**
        -:  106: * Common implementation of the Object.prototype.toString routine
        -:  107: *
        -:  108: * See also:
        -:  109: *          ECMA-262 v5, 15.2.4.2
        -:  110: *
        -:  111: * Used by:
        -:  112: *         - The Object.prototype.toString routine.
        -:  113: *         - The Array.prototype.toString routine as fallback.
        -:  114: *
        -:  115: * @return ecma value
        -:  116: *         Returned value must be freed with ecma_free_value.
        -:  117: */
        -:  118:
        -:  119:ecma_value_t
    #####:  120:ecma_builtin_helper_object_to_string (const ecma_value_t this_arg) /**< this argument */
        -:  121:{
        -:  122:  lit_magic_string_id_t builtin_tag;
        -:  123:
    #####:  124:  if (ecma_is_value_undefined (this_arg))
        -:  125:  {
    #####:  126:    builtin_tag = LIT_MAGIC_STRING_UNDEFINED_UL;
        -:  127:  }
    #####:  128:  else if (ecma_is_value_null (this_arg))
        -:  129:  {
    #####:  130:    builtin_tag = LIT_MAGIC_STRING_NULL_UL;
        -:  131:  }
        -:  132:  else
        -:  133:  {
    #####:  134:    ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -:  135:
    #####:  136:    if (ECMA_IS_VALUE_ERROR (obj_this))
        -:  137:    {
    #####:  138:      return obj_this;
        -:  139:    }
        -:  140:
    #####:  141:    JERRY_ASSERT (ecma_is_value_object (obj_this));
        -:  142:
    #####:  143:    ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -:  144:
    #####:  145:    builtin_tag = ecma_object_get_class_name (obj_p);
        -:  146:
        -:  147:#if JERRY_ESNEXT
    #####:  148:    ecma_value_t is_array = ecma_is_value_array (obj_this);
        -:  149:
    #####:  150:    if (ECMA_IS_VALUE_ERROR (is_array))
        -:  151:    {
    #####:  152:      ecma_deref_object (obj_p);
    #####:  153:      return is_array;
        -:  154:    }
        -:  155:
    #####:  156:    if (ecma_is_value_true (is_array))
        -:  157:    {
    #####:  158:      builtin_tag = LIT_MAGIC_STRING_ARRAY_UL;
        -:  159:    }
        -:  160:
    #####:  161:    ecma_value_t tag = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG);
        -:  162:
    #####:  163:    if (ECMA_IS_VALUE_ERROR (tag))
        -:  164:    {
    #####:  165:      ecma_deref_object (obj_p);
    #####:  166:      return tag;
        -:  167:    }
        -:  168:
    #####:  169:    if (ecma_is_value_string (tag))
        -:  170:    {
    #####:  171:      ecma_deref_object (obj_p);
    #####:  172:      return ecma_builtin_helper_object_to_string_tag_helper (tag);
        -:  173:    }
    #####:  174:    else if (builtin_tag != LIT_MAGIC_STRING_ARGUMENTS_UL && builtin_tag != LIT_MAGIC_STRING_FUNCTION_UL
    #####:  175:             && builtin_tag != LIT_MAGIC_STRING_ERROR_UL && builtin_tag != LIT_MAGIC_STRING_BOOLEAN_UL
    #####:  176:             && builtin_tag != LIT_MAGIC_STRING_NUMBER_UL && builtin_tag != LIT_MAGIC_STRING_STRING_UL
    #####:  177:             && builtin_tag != LIT_MAGIC_STRING_DATE_UL && builtin_tag != LIT_MAGIC_STRING_REGEXP_UL
    #####:  178:             && builtin_tag != LIT_MAGIC_STRING_ARRAY_UL)
        -:  179:    {
    #####:  180:      builtin_tag = LIT_MAGIC_STRING_OBJECT_UL;
        -:  181:    }
        -:  182:
    #####:  183:    ecma_free_value (tag);
        -:  184:#endif /* JERRY_ESNEXT */
        -:  185:
    #####:  186:    ecma_deref_object (obj_p);
        -:  187:  }
        -:  188:
    #####:  189:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  190:
    #####:  191:  ecma_stringbuilder_append_magic (&builder, LIT_MAGIC_STRING_OBJECT_TO_STRING_UL);
    #####:  192:  ecma_stringbuilder_append_magic (&builder, builtin_tag);
    #####:  193:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_RIGHT_SQUARE);
        -:  194:
    #####:  195:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  196:} /* ecma_builtin_helper_object_to_string */
        -:  197:
        -:  198:/**
        -:  199: * The Array.prototype's 'toLocaleString' single element operation routine
        -:  200: *
        -:  201: * See also:
        -:  202: *          ECMA-262 v5, 15.4.4.3 steps 6-8 and 10.b-d
        -:  203: *
        -:  204: * @return ecma value
        -:  205: *         Returned value must be freed with ecma_free_value.
        -:  206: */
        -:  207:ecma_string_t *
    #####:  208:ecma_builtin_helper_get_to_locale_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  209:                                                   ecma_length_t index) /**< array index */
        -:  210:{
    #####:  211:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  212:
    #####:  213:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  214:  {
    #####:  215:    return NULL;
        -:  216:  }
        -:  217:
    #####:  218:  if (ecma_is_value_undefined (index_value) || ecma_is_value_null (index_value))
        -:  219:  {
    #####:  220:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  221:  }
        -:  222:
    #####:  223:  ecma_value_t call_value = ecma_op_invoke_by_magic_id (index_value, LIT_MAGIC_STRING_TO_LOCALE_STRING_UL, NULL, 0);
        -:  224:
    #####:  225:  ecma_free_value (index_value);
        -:  226:
    #####:  227:  if (ECMA_IS_VALUE_ERROR (call_value))
        -:  228:  {
    #####:  229:    return NULL;
        -:  230:  }
        -:  231:
    #####:  232:  ecma_string_t *ret_string_p = ecma_op_to_string (call_value);
        -:  233:
    #####:  234:  ecma_free_value (call_value);
        -:  235:
    #####:  236:  return ret_string_p;
        -:  237:} /* ecma_builtin_helper_get_to_locale_string_at_index */
        -:  238:
        -:  239:/**
        -:  240: * Helper function to normalizing an array index
        -:  241: *
        -:  242: * See also:
        -:  243: *          ECMA-262 v5, 15.4.4.10 steps 5, 6, 7 part 2, 8
        -:  244: *          ECMA-262 v5, 15.4.4.12 steps 5, 6
        -:  245: *
        -:  246: *          ECMA-262 v6, 22.1.3.6 steps 5 - 7, 8 part 2, 9, 10
        -:  247: *          ECMA-262 v6, 22.1.3.3 steps 5 - 10, 11 part 2, 12, 13
        -:  248: *
        -:  249: * Used by:
        -:  250: *         - The Array.prototype.slice routine.
        -:  251: *         - The Array.prototype.splice routine.
        -:  252: *         - The Array.prototype.fill routine.
        -:  253: *         - The Array.prototype.copyWithin routine.
        -:  254: *
        -:  255: * @return ECMA_VALUE_EMPTY if successful
        -:  256: *         conversion error otherwise
        -:  257: */
        -:  258:ecma_value_t
    #####:  259:ecma_builtin_helper_array_index_normalize (ecma_value_t arg, /**< index */
        -:  260:                                           ecma_length_t length, /**< array's length */
        -:  261:                                           ecma_length_t *number_p) /**< [out] ecma_length_t */
        -:  262:{
        -:  263:#if JERRY_ESNEXT
    #####:  264:  ecma_number_t to_int;
        -:  265:
    #####:  266:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg, &to_int)))
        -:  267:  {
    #####:  268:    return ECMA_VALUE_ERROR;
        -:  269:  }
        -:  270:
    #####:  271:  *number_p = ((to_int < 0) ? (ecma_length_t) JERRY_MAX (((ecma_number_t) length + to_int), 0)
    #####:  272:                            : (ecma_length_t) JERRY_MIN (to_int, (ecma_number_t) length));
        -:  273:
    #####:  274:  return ECMA_VALUE_EMPTY;
        -:  275:#else /* !JERRY_ESNEXT */
    #####:  276:  return ecma_builtin_helper_uint32_index_normalize (arg, length, number_p);
        -:  277:#endif /* JERRY_ESNEXT */
        -:  278:} /* ecma_builtin_helper_array_index_normalize */
        -:  279:
        -:  280:/**
        -:  281: * Helper function to normalizing an uint32 index
        -:  282: *
        -:  283: * See also:
        -:  284: *          ECMA-262 v5, 15.5.4.13 steps 4 - 7
        -:  285: *          ECMA-262 v6, 22.2.3.5 steps 5 - 10, 11 part 2, 12, 13
        -:  286: *          ECMA-262 v6, 22.2.3.23 steps 5 - 10
        -:  287: *          ECMA-262 v6, 24.1.4.3 steps 6 - 8, 9 part 2, 10, 11
        -:  288: *          ECMA-262 v6, 22.2.3.26 steps 7 - 9, 10 part 2, 11, 12
        -:  289: *          ECMA-262 v6, 22.2.3.8 steps 5 - 7, 8 part 2, 9, 10
        -:  290: *
        -:  291: * Used by:
        -:  292: *         - The String.prototype.slice routine.
        -:  293: *         - The Array.prototype.copyWithin routine.
        -:  294: *         - The TypedArray.prototype.copyWithin routine.
        -:  295: *         - The TypedArray.prototype.slice routine.
        -:  296: *         - The ArrayBuffer.prototype.slice routine.
        -:  297: *         - The TypedArray.prototype.subarray routine.
        -:  298: *         - The TypedArray.prototype.fill routine.
        -:  299: *
        -:  300: * @return ECMA_VALUE_EMPTY if successful
        -:  301: *         conversion error otherwise
        -:  302: */
        -:  303:ecma_value_t
    #####:  304:ecma_builtin_helper_uint32_index_normalize (ecma_value_t arg, /**< index */
        -:  305:                                            uint32_t length, /**< array's length */
        -:  306:                                            uint32_t *number_p) /**< [out] uint32_t number */
        -:  307:{
    #####:  308:  ecma_number_t to_int;
        -:  309:
    #####:  310:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg, &to_int)))
        -:  311:  {
    #####:  312:    return ECMA_VALUE_ERROR;
        -:  313:  }
        -:  314:
    #####:  315:  *number_p = ((to_int < 0) ? (uint32_t) JERRY_MAX ((ecma_number_t) length + to_int, 0)
    #####:  316:                            : (uint32_t) JERRY_MIN (to_int, (ecma_number_t) length));
        -:  317:
    #####:  318:  return ECMA_VALUE_EMPTY;
        -:  319:} /* ecma_builtin_helper_uint32_index_normalize */
        -:  320:
        -:  321:/**
        -:  322: * Helper function for concatenating an ecma_value_t to an Array.
        -:  323: *
        -:  324: * See also:
        -:  325: *          ECMA-262 v5, 15.4.4.4 steps 5.b - 5.c
        -:  326: *
        -:  327: * Used by:
        -:  328: *         - The Array.prototype.concat routine.
        -:  329: *
        -:  330: * @return ecma value
        -:  331: *         Returned value must be freed with ecma_free_value.
        -:  332: */
        -:  333:ecma_value_t
    #####:  334:ecma_builtin_helper_array_concat_value (ecma_object_t *array_obj_p, /**< array */
        -:  335:                                        ecma_length_t *length_p, /**< [in,out] array's length */
        -:  336:                                        ecma_value_t value) /**< value to concat */
        -:  337:{
        -:  338:  /* 5.b */
        -:  339:#if JERRY_ESNEXT
    #####:  340:  ecma_value_t is_spreadable = ecma_op_is_concat_spreadable (value);
        -:  341:
    #####:  342:  if (ECMA_IS_VALUE_ERROR (is_spreadable))
        -:  343:  {
    #####:  344:    return is_spreadable;
        -:  345:  }
        -:  346:
    #####:  347:  bool spread_object = is_spreadable == ECMA_VALUE_TRUE;
        -:  348:  /* ES11: 22.1.3.1.5.c.iv.3.b */
    #####:  349:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  350:#else /* !JERRY_ESNEXT */
        -:  351:  /* ES5.1: 15.4.4.4.5.b.iii.3.b */
    #####:  352:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
    #####:  353:  bool spread_object = ecma_is_value_true (ecma_is_value_array (value));
        -:  354:#endif /* JERRY_ESNEXT */
        -:  355:
    #####:  356:  if (spread_object)
        -:  357:  {
    #####:  358:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  359:
        -:  360:#if JERRY_ESNEXT
    #####:  361:    ecma_length_t arg_len;
    #####:  362:    ecma_value_t error = ecma_op_object_get_length (obj_p, &arg_len);
        -:  363:
    #####:  364:    if (ECMA_IS_VALUE_ERROR (error))
        -:  365:    {
    #####:  366:      return error;
        -:  367:    }
        -:  368:
        -:  369:    /* 4 . */
    #####:  370:    if ((ecma_number_t) (*length_p + arg_len) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  371:    {
    #####:  372:      return ecma_raise_type_error (ECMA_ERR_INVALID_ARRAY_LENGTH);
        -:  373:    }
        -:  374:#else /* !JERRY_ESNEXT */
        -:  375:    /* 5.b.ii */
    #####:  376:    uint32_t arg_len = ecma_array_get_length (obj_p);
        -:  377:#endif /* JERRY_ESNEXT */
        -:  378:    /* 5.b.iii */
    #####:  379:    for (ecma_length_t array_index = 0; array_index < arg_len; array_index++)
        -:  380:    {
        -:  381:      /* 5.b.iii.2 */
    #####:  382:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, array_index);
        -:  383:
    #####:  384:      if (ECMA_IS_VALUE_ERROR (get_value))
        -:  385:      {
    #####:  386:        return get_value;
        -:  387:      }
        -:  388:
    #####:  389:      if (!ecma_is_value_found (get_value))
        -:  390:      {
    #####:  391:        continue;
        -:  392:      }
        -:  393:
        -:  394:      /* 5.b.iii.3.b */
        -:  395:      /* This will always be a simple value since 'is_throw' is false, so no need to free. */
    #####:  396:      ecma_value_t put_comp =
    #####:  397:        ecma_builtin_helper_def_prop_by_index (array_obj_p, *length_p + array_index, get_value, prop_flags);
    #####:  398:      ecma_free_value (get_value);
        -:  399:#if JERRY_ESNEXT
    #####:  400:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  401:      {
    #####:  402:        return put_comp;
        -:  403:      }
        -:  404:#else /* !JERRY_ESNEXT */
        -:  405:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  406:#endif /* JERRY_ESNEXT */
        -:  407:    }
        -:  408:
    #####:  409:    *length_p += arg_len;
    #####:  410:    return ECMA_VALUE_EMPTY;
        -:  411:  }
        -:  412:
        -:  413:  /* 5.c.i */
        -:  414:  /* This will always be a simple value since 'is_throw' is false, so no need to free. */
    #####:  415:  ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p, (*length_p)++, value, prop_flags);
        -:  416:
        -:  417:#if JERRY_ESNEXT
    #####:  418:  if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  419:  {
    #####:  420:    return put_comp;
        -:  421:  }
        -:  422:#else /* !JERRY_ESNEXT */
        -:  423:  JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  424:#endif /* JERRY_ESNEXT */
        -:  425:
    #####:  426:  return ECMA_VALUE_EMPTY;
        -:  427:} /* ecma_builtin_helper_array_concat_value */
        -:  428:
        -:  429:/**
        -:  430: * Helper function to normalizing a string index
        -:  431: *
        -:  432: * This function clamps the given index to the [0, length] range.
        -:  433: * If the index is negative, 0 value is used.
        -:  434: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  435: * NaN is mapped to zero or length depending on the nan_to_zero parameter.
        -:  436: *
        -:  437: * See also:
        -:  438: *          ECMA-262 v5, 15.5.4.15
        -:  439: *
        -:  440: * Used by:
        -:  441: *         - The String.prototype.substring routine.
        -:  442: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  443: *
        -:  444: * @return lit_utf8_size_t - the normalized value of the index
        -:  445: */
        -:  446:lit_utf8_size_t
    #####:  447:ecma_builtin_helper_string_index_normalize (ecma_number_t index, /**< index */
        -:  448:                                            lit_utf8_size_t length, /**< string's length */
        -:  449:                                            bool nan_to_zero) /**< whether NaN is mapped to zero (t) or length (f) */
        -:  450:{
    #####:  451:  uint32_t norm_index = 0;
        -:  452:
    #####:  453:  if (ecma_number_is_nan (index))
        -:  454:  {
    #####:  455:    if (!nan_to_zero)
        -:  456:    {
    #####:  457:      norm_index = length;
        -:  458:    }
        -:  459:  }
    #####:  460:  else if (!ecma_number_is_negative (index))
        -:  461:  {
    #####:  462:    if (ecma_number_is_infinity (index))
        -:  463:    {
    #####:  464:      norm_index = length;
        -:  465:    }
        -:  466:    else
        -:  467:    {
    #####:  468:      norm_index = ecma_number_to_uint32 (index);
        -:  469:
    #####:  470:      if (norm_index > length)
        -:  471:      {
    #####:  472:        norm_index = length;
        -:  473:      }
        -:  474:    }
        -:  475:  }
        -:  476:
    #####:  477:  return norm_index;
        -:  478:} /* ecma_builtin_helper_string_index_normalize */
        -:  479:
        -:  480:/**
        -:  481: * Helper function for finding lastindex of a search string
        -:  482: *
        -:  483: * This function clamps the given index to the [0, length] range.
        -:  484: * If the index is negative, 0 value is used.
        -:  485: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  486: *
        -:  487: * See also:
        -:  488: *          ECMA-262 v6, 21.1.3.9
        -:  489: *
        -:  490: * Used by:
        -:  491: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  492: *         - The ecma_builtin_string_prototype_object_replace_match helper routine.
        -:  493: *
        -:  494: * @return uint32_t - whether there is a match for the search string
        -:  495: */
        -:  496:static uint32_t
    #####:  497:ecma_builtin_helper_string_find_last_index (ecma_string_t *original_str_p, /**< original string */
        -:  498:                                            ecma_string_t *search_str_p, /**< search string */
        -:  499:                                            uint32_t position) /**< start_position */
        -:  500:{
    #####:  501:  if (ecma_string_is_empty (search_str_p))
        -:  502:  {
    #####:  503:    return position;
        -:  504:  }
        -:  505:
    #####:  506:  uint32_t original_length = ecma_string_get_length (original_str_p);
        -:  507:
    #####:  508:  ECMA_STRING_TO_UTF8_STRING (search_str_p, search_str_utf8_p, search_str_size);
    #####:  509:  ECMA_STRING_TO_UTF8_STRING (original_str_p, original_str_utf8_p, original_str_size);
        -:  510:
    #####:  511:  uint32_t ret_value = UINT32_MAX;
        -:  512:
    #####:  513:  if (original_str_size >= search_str_size)
        -:  514:  {
    #####:  515:    const lit_utf8_byte_t *end_p = original_str_utf8_p + original_str_size;
    #####:  516:    const lit_utf8_byte_t *current_p = end_p;
        -:  517:
    #####:  518:    for (ecma_number_t i = original_length; i > position; i--)
        -:  519:    {
    #####:  520:      lit_utf8_decr (&current_p);
        -:  521:    }
        -:  522:
    #####:  523:    while (current_p + search_str_size > end_p)
        -:  524:    {
    #####:  525:      lit_utf8_decr (&current_p);
    #####:  526:      position--;
        -:  527:    }
        -:  528:
        -:  529:    while (true)
        -:  530:    {
    #####:  531:      if (memcmp (current_p, search_str_utf8_p, search_str_size) == 0)
        -:  532:      {
    #####:  533:        ret_value = position;
    #####:  534:        break;
        -:  535:      }
        -:  536:
    #####:  537:      if (position == 0)
        -:  538:      {
    #####:  539:        break;
        -:  540:      }
        -:  541:
    #####:  542:      lit_utf8_decr (&current_p);
    #####:  543:      position--;
        -:  544:    }
        -:  545:  }
    #####:  546:  ECMA_FINALIZE_UTF8_STRING (original_str_utf8_p, original_str_size);
    #####:  547:  ECMA_FINALIZE_UTF8_STRING (search_str_utf8_p, search_str_size);
        -:  548:
    #####:  549:  return ret_value;
        -:  550:} /* ecma_builtin_helper_string_find_last_index */
        -:  551:
        -:  552:/**
        -:  553: * Helper function for string indexOf, lastIndexOf, startsWith, includes, endsWith functions
        -:  554: *
        -:  555: * See also:
        -:  556: *          ECMA-262 v5, 15.5.4.7
        -:  557: *          ECMA-262 v5, 15.5.4.8
        -:  558: *          ECMA-262 v6, 21.1.3.6
        -:  559: *          ECMA-262 v6, 21.1.3.7
        -:  560: *          ECMA-262 v6, 21.1.3.18
        -:  561: *
        -:  562: * Used by:
        -:  563: *         - The String.prototype.indexOf routine.
        -:  564: *         - The String.prototype.lastIndexOf routine.
        -:  565: *         - The String.prototype.startsWith routine.
        -:  566: *         - The String.prototype.includes routine.
        -:  567: *         - The String.prototype.endsWith routine.
        -:  568: *
        -:  569: * @return ecma_value_t - Returns index (last index) or a
        -:  570: *                        boolean value
        -:  571: */
        -:  572:ecma_value_t
    #####:  573:ecma_builtin_helper_string_prototype_object_index_of (ecma_string_t *original_str_p, /**< this argument */
        -:  574:                                                      ecma_value_t arg1, /**< routine's first argument */
        -:  575:                                                      ecma_value_t arg2, /**< routine's second argument */
        -:  576:                                                      ecma_string_index_of_mode_t mode) /**< routine's mode */
        -:  577:{
        -:  578:  /* 5 (indexOf) -- 6 (lastIndexOf) */
    #####:  579:  const lit_utf8_size_t original_len = ecma_string_get_length (original_str_p);
        -:  580:
        -:  581:#if JERRY_ESNEXT
        -:  582:  /* 4, 6 (startsWith, includes, endsWith) */
    #####:  583:  if (mode >= ECMA_STRING_STARTS_WITH)
        -:  584:  {
    #####:  585:    ecma_value_t regexp = ecma_op_is_regexp (arg1);
        -:  586:
    #####:  587:    if (ECMA_IS_VALUE_ERROR (regexp))
        -:  588:    {
    #####:  589:      return regexp;
        -:  590:    }
        -:  591:
    #####:  592:    if (regexp == ECMA_VALUE_TRUE)
        -:  593:    {
    #####:  594:      JERRY_ASSERT (ECMA_STRING_LAST_INDEX_OF < mode && mode <= ECMA_STRING_ENDS_WITH);
    #####:  595:      return ecma_raise_type_error (ECMA_ERR_SEARCH_STRING_CANNOT_BE_OF_TYPE_REGEXP);
        -:  596:    }
        -:  597:  }
        -:  598:#endif /* JERRY_ESNEXT */
        -:  599:
        -:  600:  /* 7, 8 */
    #####:  601:  ecma_string_t *search_str_p = ecma_op_to_string (arg1);
        -:  602:
    #####:  603:  if (JERRY_UNLIKELY (search_str_p == NULL))
        -:  604:  {
    #####:  605:    return ECMA_VALUE_ERROR;
        -:  606:  }
        -:  607:
        -:  608:  ecma_value_t ret_value;
        -:  609:
        -:  610:  /* 4 (indexOf, lastIndexOf), 9 (startsWith, includes), 10 (endsWith) */
    #####:  611:  ecma_number_t pos_num;
        -:  612:#if JERRY_ESNEXT
    #####:  613:  if (mode > ECMA_STRING_LAST_INDEX_OF)
        -:  614:  {
    #####:  615:    ret_value = ecma_op_to_integer (arg2, &pos_num);
        -:  616:  }
        -:  617:  else
        -:  618:  {
        -:  619:#endif /* JERRY_ESNEXT */
    #####:  620:    ret_value = ecma_op_to_number (arg2, &pos_num);
        -:  621:#if JERRY_ESNEXT
        -:  622:  }
        -:  623:#endif /* JERRY_ESNEXT */
        -:  624:
        -:  625:  /* 10 (startsWith, includes), 11 (endsWith) */
    #####:  626:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  627:  {
    #####:  628:    ecma_deref_ecma_string (search_str_p);
    #####:  629:    return ret_value;
        -:  630:  }
        -:  631:
    #####:  632:  bool use_first_index = mode != ECMA_STRING_LAST_INDEX_OF;
        -:  633:
        -:  634:  /* 4b, 6 (indexOf) - 4b, 5, 7 (lastIndexOf) */
    #####:  635:  lit_utf8_size_t start = ecma_builtin_helper_string_index_normalize (pos_num, original_len, use_first_index);
        -:  636:
    #####:  637:  ecma_number_t ret_num = ECMA_NUMBER_MINUS_ONE;
        -:  638:
    #####:  639:  ret_value = ECMA_VALUE_FALSE;
        -:  640:
    #####:  641:  switch (mode)
        -:  642:  {
        -:  643:#if JERRY_ESNEXT
    #####:  644:    case ECMA_STRING_STARTS_WITH:
        -:  645:    {
    #####:  646:      if (start > original_len)
        -:  647:      {
    #####:  648:        break;
        -:  649:      }
        -:  650:      /* 15, 16 (startsWith) */
    #####:  651:      uint32_t index = ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start);
    #####:  652:      ret_value = ecma_make_boolean_value (index == start);
    #####:  653:      break;
        -:  654:    }
    #####:  655:    case ECMA_STRING_INCLUDES:
        -:  656:    {
    #####:  657:      if (ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start) != UINT32_MAX)
        -:  658:      {
    #####:  659:        ret_value = ECMA_VALUE_TRUE;
        -:  660:      }
    #####:  661:      break;
        -:  662:    }
    #####:  663:    case ECMA_STRING_ENDS_WITH:
        -:  664:    {
    #####:  665:      if (start == 0)
        -:  666:      {
    #####:  667:        start = original_len;
        -:  668:      }
        -:  669:
    #####:  670:      lit_utf8_size_t search_str_len = ecma_string_get_length (search_str_p);
        -:  671:
    #####:  672:      if (search_str_len == 0)
        -:  673:      {
    #####:  674:        ret_value = ECMA_VALUE_TRUE;
    #####:  675:        break;
        -:  676:      }
        -:  677:
    #####:  678:      int32_t start_ends_with = (int32_t) (start - search_str_len);
        -:  679:
    #####:  680:      if (start_ends_with < 0)
        -:  681:      {
    #####:  682:        break;
        -:  683:      }
    #####:  684:      uint32_t index = ecma_builtin_helper_string_find_index (original_str_p, search_str_p, (uint32_t) start_ends_with);
    #####:  685:      ret_value = ecma_make_boolean_value (index == (uint32_t) start_ends_with);
    #####:  686:      break;
        -:  687:    }
        -:  688:#endif /* JERRY_ESNEXT */
        -:  689:
    #####:  690:    case ECMA_STRING_INDEX_OF:
        -:  691:    {
        -:  692:      /* 8 (indexOf) -- 9 (lastIndexOf) */
    #####:  693:      ecma_value_t find_index = ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start);
        -:  694:
    #####:  695:      if (find_index != UINT32_MAX)
        -:  696:      {
    #####:  697:        ret_num = ((ecma_number_t) find_index);
        -:  698:      }
    #####:  699:      ret_value = ecma_make_number_value (ret_num);
    #####:  700:      break;
        -:  701:    }
        -:  702:
    #####:  703:    case ECMA_STRING_LAST_INDEX_OF:
        -:  704:    {
    #####:  705:      uint32_t index = ecma_builtin_helper_string_find_last_index (original_str_p, search_str_p, start);
        -:  706:
    #####:  707:      if (index != UINT32_MAX)
        -:  708:      {
    #####:  709:        ret_num = ((ecma_number_t) index);
        -:  710:      }
    #####:  711:      ret_value = ecma_make_number_value (ret_num);
    #####:  712:      break;
        -:  713:    }
        -:  714:
    #####:  715:    default:
        -:  716:    {
    #####:  717:      JERRY_UNREACHABLE ();
        -:  718:    }
        -:  719:  }
        -:  720:
    #####:  721:  ecma_deref_ecma_string (search_str_p);
        -:  722:
    #####:  723:  return ret_value;
        -:  724:} /* ecma_builtin_helper_string_prototype_object_index_of */
        -:  725:
        -:  726:/**
        -:  727: * Helper function for finding index of a search string
        -:  728: *
        -:  729: * This function clamps the given index to the [0, length] range.
        -:  730: * If the index is negative, 0 value is used.
        -:  731: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  732: *
        -:  733: * See also:
        -:  734: *          ECMA-262 v6, 21.1.3.8
        -:  735: *
        -:  736: * Used by:
        -:  737: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  738: *         - The ecma_builtin_string_prototype_object_replace_match helper routine.
        -:  739: *
        -:  740: * @return uint32_t - whether there is a match for the search string
        -:  741: */
        -:  742:uint32_t
    #####:  743:ecma_builtin_helper_string_find_index (ecma_string_t *original_str_p, /**< index */
        -:  744:                                       ecma_string_t *search_str_p, /**< string's length */
        -:  745:                                       uint32_t start_pos) /**< start position */
        -:  746:{
    #####:  747:  uint32_t match_found = UINT32_MAX;
        -:  748:
    #####:  749:  if (ecma_string_is_empty (search_str_p))
        -:  750:  {
    #####:  751:    return start_pos;
        -:  752:  }
        -:  753:
    #####:  754:  ECMA_STRING_TO_UTF8_STRING (search_str_p, search_str_utf8_p, search_str_size);
    #####:  755:  ECMA_STRING_TO_UTF8_STRING (original_str_p, original_str_utf8_p, original_str_size);
        -:  756:
    #####:  757:  const lit_utf8_byte_t *str_current_p = original_str_utf8_p;
        -:  758:
    #####:  759:  for (ecma_number_t i = 0; i < start_pos; i++)
        -:  760:  {
    #####:  761:    lit_utf8_incr (&str_current_p);
        -:  762:  }
        -:  763:
    #####:  764:  const lit_utf8_byte_t *original_end_p = original_str_utf8_p + original_str_size;
        -:  765:
    #####:  766:  while (!((size_t) (original_end_p - str_current_p) < search_str_size))
        -:  767:  {
    #####:  768:    if (memcmp (str_current_p, search_str_utf8_p, search_str_size) == 0)
        -:  769:    {
    #####:  770:      match_found = start_pos;
    #####:  771:      break;
        -:  772:    }
        -:  773:
    #####:  774:    lit_utf8_incr (&str_current_p);
    #####:  775:    start_pos++;
        -:  776:  }
        -:  777:
    #####:  778:  ECMA_FINALIZE_UTF8_STRING (original_str_utf8_p, original_str_size);
    #####:  779:  ECMA_FINALIZE_UTF8_STRING (search_str_utf8_p, search_str_size);
        -:  780:
    #####:  781:  return match_found;
        -:  782:} /* ecma_builtin_helper_string_find_index */
        -:  783:
        -:  784:/**
        -:  785: * Helper function for using [[DefineOwnProperty]] specialized for indexed property names
        -:  786: *
        -:  787: * Note: this method falls back to the general ecma_builtin_helper_def_prop
        -:  788: *
        -:  789: * @return ecma value
        -:  790: *         Returned value must be freed with ecma_free_value.
        -:  791: */
        -:  792:ecma_value_t
    #####:  793:ecma_builtin_helper_def_prop_by_index (ecma_object_t *obj_p, /**< object */
        -:  794:                                       ecma_length_t index, /**< property index */
        -:  795:                                       ecma_value_t value, /**< value */
        -:  796:                                       uint32_t opts) /**< any combination of ecma_property_flag_t bits */
        -:  797:{
    #####:  798:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  799:  {
    #####:  800:    return ecma_builtin_helper_def_prop (obj_p, ECMA_CREATE_DIRECT_UINT32_STRING (index), value, opts);
        -:  801:  }
        -:  802:
    #####:  803:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  804:  ecma_value_t ret_value = ecma_builtin_helper_def_prop (obj_p, index_str_p, value, opts);
    #####:  805:  ecma_deref_ecma_string (index_str_p);
        -:  806:
    #####:  807:  return ret_value;
        -:  808:} /* ecma_builtin_helper_def_prop_by_index */
        -:  809:
        -:  810:/**
        -:  811: * Helper function for at() functions.
        -:  812: *
        -:  813: * See also:
        -:  814: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal 3. 4. 5. 6.
        -:  815: *
        -:  816: * Used by:
        -:  817: *         - The Array.prototype.at routine.
        -:  818: *         - The String.prototype.at routine.
        -:  819: *         - The TypedArray.prototype.at routine.
        -:  820: *
        -:  821: * @return ECMA_VALUE_ERROR - on conversion error
        -:  822: *         ECMA_VALUE_UNDEFINED - if the requested index is not exist
        -:  823: *         ECMA_VALUE_EMPTY - otherwise
        -:  824: */
        -:  825:ecma_value_t
    #####:  826:ecma_builtin_helper_calculate_index (ecma_value_t index, /**< relative index argument */
        -:  827:                                     ecma_length_t length, /**< object's length */
        -:  828:                                     ecma_length_t *out_index) /**< calculated index */
        -:  829:{
    #####:  830:  JERRY_ASSERT (out_index != NULL);
        -:  831:
    #####:  832:  ecma_number_t relative_index;
    #####:  833:  ecma_value_t conversion_result = ecma_op_to_integer (index, &relative_index);
        -:  834:
        -:  835:  /* 4. */
    #####:  836:  if (ECMA_IS_VALUE_ERROR (conversion_result))
        -:  837:  {
    #####:  838:    return ECMA_VALUE_ERROR;
        -:  839:  }
        -:  840:
        -:  841:  /* 5. 6. */
        -:  842:  ecma_number_t k;
        -:  843:
    #####:  844:  if (relative_index >= 0)
        -:  845:  {
    #####:  846:    k = relative_index;
        -:  847:  }
        -:  848:  else
        -:  849:  {
    #####:  850:    k = ((ecma_number_t) length + relative_index);
        -:  851:  }
        -:  852:
        -:  853:  /* 7. */
    #####:  854:  if (k < 0 || k >= ((ecma_number_t) length))
        -:  855:  {
    #####:  856:    return ECMA_VALUE_UNDEFINED;
        -:  857:  }
        -:  858:
    #####:  859:  *out_index = (ecma_length_t) k;
        -:  860:
    #####:  861:  return ECMA_VALUE_EMPTY;
        -:  862:} /* ecma_builtin_helper_calculate_index */
        -:  863:
        -:  864:/**
        -:  865: * Helper function for using [[DefineOwnProperty]].
        -:  866: *
        -:  867: * See also:
        -:  868: *          ECMA-262 v5, 8.12.9
        -:  869: *          ECMA-262 v5, 15.4.5.1
        -:  870: *
        -:  871: * @return ecma value
        -:  872: *         Returned value must be freed with ecma_free_value.
        -:  873: */
        -:  874:ecma_value_t
        4:  875:ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */
        -:  876:                              ecma_string_t *name_p, /**< name string */
        -:  877:                              ecma_value_t value, /**< value */
        -:  878:                              uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */
        -:  879:{
        4:  880:  ecma_property_descriptor_t prop_desc;
        -:  881:
        4:  882:  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);
        -:  883:
        4:  884:  prop_desc.value = value;
        -:  885:
        4:  886:  return ecma_op_object_define_own_property (obj_p, name_p, &prop_desc);
        -:  887:} /* ecma_builtin_helper_def_prop */
        -:  888:
        -:  889:/**
        -:  890: * GetSubstitution abstract operation
        -:  891: *
        -:  892: * See:
        -:  893: *     ECMA-262 v6.0 21.1.3.14.1
        -:  894: */
        -:  895:void
    #####:  896:ecma_builtin_replace_substitute (ecma_replace_context_t *ctx_p) /**< replace context */
        -:  897:{
    #####:  898:  JERRY_ASSERT (ctx_p->string_p != NULL);
    #####:  899:  JERRY_ASSERT (ctx_p->matched_p == NULL
        -:  900:                || (ctx_p->matched_p >= ctx_p->string_p && ctx_p->matched_p <= ctx_p->string_p + ctx_p->string_size));
        -:  901:
    #####:  902:  lit_utf8_size_t replace_size;
    #####:  903:  uint8_t replace_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  904:  const lit_utf8_byte_t *replace_buf_p =
    #####:  905:    ecma_string_get_chars (ctx_p->replace_str_p, &replace_size, NULL, NULL, &replace_flags);
        -:  906:
    #####:  907:  const lit_utf8_byte_t *const replace_end_p = replace_buf_p + replace_size;
    #####:  908:  const lit_utf8_byte_t *curr_p = replace_buf_p;
    #####:  909:  const lit_utf8_byte_t *last_inserted_end_p = replace_buf_p;
        -:  910:
    #####:  911:  while (curr_p < replace_end_p)
        -:  912:  {
    #####:  913:    if (*curr_p++ == LIT_CHAR_DOLLAR_SIGN)
        -:  914:    {
    #####:  915:      ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -:  916:                                     last_inserted_end_p,
    #####:  917:                                     (lit_utf8_size_t) (curr_p - last_inserted_end_p - 1));
    #####:  918:      if (curr_p >= replace_end_p)
        -:  919:      {
    #####:  920:        last_inserted_end_p = curr_p - 1;
    #####:  921:        break;
        -:  922:      }
        -:  923:
    #####:  924:      const lit_utf8_byte_t c = *curr_p++;
        -:  925:
    #####:  926:      switch (c)
        -:  927:      {
    #####:  928:        case LIT_CHAR_DOLLAR_SIGN:
        -:  929:        {
    #####:  930:          ecma_stringbuilder_append_byte (&(ctx_p->builder), LIT_CHAR_DOLLAR_SIGN);
    #####:  931:          break;
        -:  932:        }
    #####:  933:        case LIT_CHAR_AMPERSAND:
        -:  934:        {
        -:  935:#if JERRY_ESNEXT
    #####:  936:          if (JERRY_UNLIKELY (ctx_p->matched_p == NULL))
        -:  937:          {
    #####:  938:            JERRY_ASSERT (ctx_p->capture_count == 0);
    #####:  939:            JERRY_ASSERT (ctx_p->u.collection_p != NULL);
    #####:  940:            JERRY_ASSERT (ctx_p->u.collection_p->item_count > 0);
    #####:  941:            const ecma_value_t match_value = ctx_p->u.collection_p->buffer_p[0];
        -:  942:
    #####:  943:            JERRY_ASSERT (ecma_is_value_string (match_value));
    #####:  944:            ecma_stringbuilder_append (&(ctx_p->builder), ecma_get_string_from_value (match_value));
    #####:  945:            break;
        -:  946:          }
        -:  947:#endif /* JERRY_ESNEXT */
        -:  948:
    #####:  949:          JERRY_ASSERT (ctx_p->matched_p != NULL);
    #####:  950:          ecma_stringbuilder_append_raw (&(ctx_p->builder), ctx_p->matched_p, ctx_p->matched_size);
    #####:  951:          break;
        -:  952:        }
    #####:  953:        case LIT_CHAR_GRAVE_ACCENT:
        -:  954:        {
    #####:  955:          ecma_stringbuilder_append_raw (&(ctx_p->builder), ctx_p->string_p, ctx_p->match_byte_pos);
    #####:  956:          break;
        -:  957:        }
    #####:  958:        case LIT_CHAR_SINGLE_QUOTE:
        -:  959:        {
        -:  960:#if JERRY_ESNEXT
    #####:  961:          if (JERRY_UNLIKELY (ctx_p->matched_p == NULL))
        -:  962:          {
    #####:  963:            JERRY_ASSERT (ctx_p->capture_count == 0);
    #####:  964:            JERRY_ASSERT (ctx_p->u.collection_p != NULL);
    #####:  965:            JERRY_ASSERT (ctx_p->u.collection_p->item_count > 0);
    #####:  966:            const ecma_value_t match_value = ctx_p->u.collection_p->buffer_p[0];
        -:  967:
    #####:  968:            JERRY_ASSERT (ecma_is_value_string (match_value));
    #####:  969:            const ecma_string_t *const matched_p = ecma_get_string_from_value (match_value);
    #####:  970:            const lit_utf8_size_t match_size = ecma_string_get_size (matched_p);
    #####:  971:            const lit_utf8_byte_t *const begin_p = ctx_p->string_p + ctx_p->match_byte_pos + match_size;
        -:  972:
    #####:  973:            ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -:  974:                                           begin_p,
    #####:  975:                                           (lit_utf8_size_t) (ctx_p->string_p + ctx_p->string_size - begin_p));
    #####:  976:            break;
        -:  977:          }
        -:  978:#endif /* JERRY_ESNEXT */
        -:  979:
    #####:  980:          JERRY_ASSERT (ctx_p->matched_p != NULL);
    #####:  981:          ecma_stringbuilder_append_raw (&(ctx_p->builder),
    #####:  982:                                         ctx_p->matched_p + ctx_p->matched_size,
    #####:  983:                                         ctx_p->string_size - ctx_p->match_byte_pos - ctx_p->matched_size);
    #####:  984:          break;
        -:  985:        }
    #####:  986:        default:
        -:  987:        {
    #####:  988:          const lit_utf8_byte_t *const number_begin_p = curr_p - 1;
        -:  989:
    #####:  990:          if (lit_char_is_decimal_digit (c))
        -:  991:          {
    #####:  992:            uint32_t capture_count = ctx_p->capture_count;
        -:  993:#if JERRY_ESNEXT
    #####:  994:            if (capture_count == 0 && ctx_p->u.collection_p != NULL)
        -:  995:            {
    #####:  996:              capture_count = ctx_p->u.collection_p->item_count;
        -:  997:            }
        -:  998:#endif /* JERRY_ESNEXT */
        -:  999:
    #####: 1000:            uint8_t idx = (uint8_t) (c - LIT_CHAR_0);
    #####: 1001:            if (curr_p < replace_end_p && lit_char_is_decimal_digit (*(curr_p)))
        -: 1002:            {
    #####: 1003:              uint8_t two_digit_index = (uint8_t) (idx * 10 + (uint8_t) (*(curr_p) -LIT_CHAR_0));
    #####: 1004:              if (two_digit_index < capture_count)
        -: 1005:              {
    #####: 1006:                idx = two_digit_index;
    #####: 1007:                curr_p++;
        -: 1008:              }
        -: 1009:            }
        -: 1010:
    #####: 1011:            if (idx > 0 && idx < capture_count)
        -: 1012:            {
    #####: 1013:              if (ctx_p->capture_count > 0)
        -: 1014:              {
        -: 1015:#if JERRY_BUILTIN_REGEXP
    #####: 1016:                JERRY_ASSERT (ctx_p->u.captures_p != NULL);
    #####: 1017:                const ecma_regexp_capture_t *const capture_p = ctx_p->u.captures_p + idx;
        -: 1018:
    #####: 1019:                if (ECMA_RE_IS_CAPTURE_DEFINED (capture_p))
        -: 1020:                {
    #####: 1021:                  ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -: 1022:                                                 capture_p->begin_p,
    #####: 1023:                                                 (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p));
        -: 1024:                }
        -: 1025:
    #####: 1026:                break;
        -: 1027:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1028:              }
        -: 1029:#if JERRY_ESNEXT
    #####: 1030:              else if (ctx_p->u.collection_p != NULL)
        -: 1031:              {
    #####: 1032:                const ecma_value_t capture_value = ctx_p->u.collection_p->buffer_p[idx];
    #####: 1033:                if (!ecma_is_value_undefined (capture_value))
        -: 1034:                {
    #####: 1035:                  ecma_stringbuilder_append (&(ctx_p->builder), ecma_get_string_from_value (capture_value));
        -: 1036:                }
        -: 1037:
    #####: 1038:                break;
        -: 1039:              }
        -: 1040:#endif /* JERRY_ESNEXT */
        -: 1041:            }
        -: 1042:          }
        -: 1043:
    #####: 1044:          ecma_stringbuilder_append_byte (&(ctx_p->builder), LIT_CHAR_DOLLAR_SIGN);
    #####: 1045:          curr_p = number_begin_p;
    #####: 1046:          break;
        -: 1047:        }
        -: 1048:      }
        -: 1049:
    #####: 1050:      last_inserted_end_p = curr_p;
        -: 1051:    }
        -: 1052:  }
        -: 1053:
    #####: 1054:  ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -: 1055:                                 last_inserted_end_p,
    #####: 1056:                                 (lit_utf8_size_t) (replace_end_p - last_inserted_end_p));
        -: 1057:
    #####: 1058:  if (replace_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1059:  {
    #####: 1060:    jmem_heap_free_block ((void *) replace_buf_p, replace_size);
        -: 1061:  }
    #####: 1062:} /* ecma_builtin_replace_substitute */
        -: 1063:
        -: 1064:/**
        -: 1065: * @}
        -: 1066: * @}
        -: 1067: */
